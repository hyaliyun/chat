import{_ as m,o as s,c as n,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function A(i,e,u,_,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const R=m(q,[["render",A],["__scopeId","data-v-80ab3293"]]),S=JSON.parse(`[{"question":"def longest_common_subsequence(seq1, seq2): Computes the length of the longest common subsequence between two sequences. Args: seq1 (List[int]): The first sequence of integers. seq2 (List[int]): The second sequence of integers. Returns: int: The length of the longest common subsequence. >>> longest_common_subsequence([1, 3, 4, 1, 2, 5], [1, 4, 1, 2, 5]) 5 >>> longest_common_subsequence([9, 8, 7], [5, 6, 7, 8]) 1","solution":"def longest_common_subsequence(seq1, seq2): Computes the length of the longest common subsequence between two sequences. n1, n2 = len(seq1), len(seq2) # Create a 2D dp array with (n1+1)x(n2+1) dimensions dp = [[0] * (n2 + 1) for _ in range(n1 + 1)] # Fill the dp array for i in range(1, n1 + 1): for j in range(1, n2 + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value in dp[n1][n2] will be the length of the longest common subsequence return dp[n1][n2]"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in a given string s. If there is no non-repeating character, returns 'None'. >>> first_non_repeating_character(\\"a\\") 'a' >>> first_non_repeating_character(\\"abbcdde\\") 'a' >>> first_non_repeating_character(\\"aabbccefd\\") 'e' >>> first_non_repeating_character(\\"aabbccd\\") 'd' >>> first_non_repeating_character(\\"aabbcc\\") 'None'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in a given string s. If there is no non-repeating character, returns 'None'. char_count = {} # Count occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character in the string with a count of 1 for char in s: if char_count[char] == 1: return char return 'None'"},{"question":"def min_operations_to_equal_subsequence(A, N, K): Find the minimum number of operations required to make the array have at least one subsequence of length K such that all elements in the subsequence are equal. >>> min_operations_to_equal_subsequence([1, 2, 2, 2, 3], 5, 3) 0 >>> min_operations_to_equal_subsequence([1, 2, 3, 4, 5, 6, 7], 7, 5) 4 >>> min_operations_to_equal_subsequence([4, 4, 4, 4], 4, 2) 0 pass def solve(test_cases): Given multiple test cases, find and return the minimum number of operations required for each test case to achieve a subsequence of specified length K with equal elements. >>> test_cases = [(5, 3, [1, 2, 2, 2, 3]), (7, 5, [1, 2, 3, 4, 5, 6, 7]), (4, 2, [4, 4, 4, 4])] >>> solve(test_cases) [0, 4, 0] pass","solution":"def min_operations_to_equal_subsequence(A, N, K): from collections import Counter count = Counter(A) max_frequency = max(count.values()) if max_frequency >= K: return 0 return K - max_frequency def solve(test_cases): results = [] for N, K, A in test_cases: result = min_operations_to_equal_subsequence(A, N, K) results.append(result) return results"},{"question":"def smallest_length_after_removals(s: str) -> int: Determines the smallest possible length of the string after removing palindrome substrings any number of times. >>> smallest_length_after_removals(\\"a\\") 0 >>> smallest_length_after_removals(\\"abba\\") 0 >>> smallest_length_after_removals(\\"racecar\\") 0 >>> smallest_length_after_removals(\\"abacdc\\") 1 >>> smallest_length_after_removals(\\"abcde\\") 1 >>> smallest_length_after_removals(\\"ababab\\") 1 >>> smallest_length_after_removals(\\"aabbccddeeffgg\\") 1 pass","solution":"def smallest_length_after_removals(s): Determines the smallest possible length of the string after removing palindrome substrings any number of times. # If the whole string is a palindrome, we can remove it entirely to get an empty string if s == s[::-1]: return 0 # If the entire string is not a palindrome, the smallest possible length after all removals is 1 return 1"},{"question":"def solve_knights_tour(test_cases: List[Tuple[int, int, int]]) -> List[str]: Determine if a Knight's Tour is possible for given test cases. >>> solve_knights_tour([(5, 2, 2)]) [\\"Yes\\"] >>> solve_knights_tour([(3, 0, 0)]) [\\"No\\"] >>> solve_knights_tour([(1, 0, 0)]) [\\"Yes\\"]","solution":"def is_knights_tour_possible(N, start_x, start_y): def is_valid_move(x, y, N, visited): return 0 <= x < N and 0 <= y < N and not visited[x][y] def knights_tour(N, x, y, move_i, visited, x_move, y_move): if move_i == N * N: return True for i in range(8): next_x = x + x_move[i] next_y = y + y_move[i] if is_valid_move(next_x, next_y, N, visited): visited[next_x][next_y] = True if knights_tour(N, next_x, next_y, move_i + 1, visited, x_move, y_move): return True visited[next_x][next_y] = False return False visited = [[False] * N for _ in range(N)] visited[start_x][start_y] = True x_move = [2, 1, -1, -2, -2, -1, 1, 2] y_move = [1, 2, 2, 1, -1, -2, -2, -1] if knights_tour(N, start_x, start_y, 1, visited, x_move, y_move): return \\"Yes\\" else: return \\"No\\" def solve_knights_tour(test_cases): results = [] for N, start_x, start_y in test_cases: results.append(is_knights_tour_possible(N, start_x, start_y)) return results # Example usage: # test_cases = [ # (5, 2, 2), # (3, 0, 0), # (1, 0, 0) # ] # print(solve_knights_tour(test_cases))"},{"question":"def minimum_operations(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Calculate the minimum number of operations to move all books from one shelf to another. Parameters: T (int): The number of test cases test_cases (list of tuples): Each tuple contains two elements - a tuple of integers and a list of integers. The first element is a tuple (N, W) where N is the number of books and W is the maximum weight limit. The second element is a list of integers representing the weights of the books. Returns: list: A list containing the minimum number of operations for each test case. >>> minimum_operations(2, [((5, 10), [3, 3, 3, 3, 3]), ((4, 12), [6, 4, 8, 10])]) [2, 3] >>> minimum_operations(1, [((5, 30), [10, 5, 5, 5, 5])]) [1] >>> minimum_operations(1, [((1, 10), [7])]) [1] >>> minimum_operations(1, [((3, 2), [1, 1, 1])]) [2] >>> minimum_operations(1, [((0, 10), [])]) [0]","solution":"def minimum_operations(T, test_cases): Calculate the minimum number of operations to move all books from one shelf to another. Parameters: T (int): The number of test cases test_cases (list of tuples): Each tuple contains two elements - a tuple of integers and a list of integers. The first element is a tuple (N, W) where N is the number of books and W is the maximum weight limit. The second element is a list of integers representing the weights of the books. Returns: list: A list containing the minimum number of operations for each test case. results = [] for case in test_cases: (N, W), weights = case weights.sort(reverse=True) operations = 0 while weights: current_weight = 0 i = 0 while i < len(weights): if current_weight + weights[i] <= W: current_weight += weights.pop(i) else: i += 1 operations += 1 results.append(operations) return results"},{"question":"def sum_of_proper_divisors(n: int) -> int: Returns the sum of all proper divisors of n (excluding the number itself). >>> sum_of_proper_divisors(6) == 6 # 1 + 2 + 3 >>> sum_of_proper_divisors(12) == 16 # 1 + 2 + 3 + 4 + 6 >>> sum_of_proper_divisors(15) == 9 # 1 + 3 + 5 >>> sum_of_proper_divisors(28) == 28 # 1 + 2 + 4 + 7 + 14","solution":"def sum_of_proper_divisors(n): Returns the sum of all proper divisors of n (excluding the number itself). if n <= 1: return 0 divisors_sum = 1 # 1 is always a proper divisor for i in range(2, int(n**0.5) + 1): if n % i == 0: if i == n // i: divisors_sum += i else: divisors_sum += i + n // i return divisors_sum"},{"question":"def next_taller_student(heights: List[int]) -> List[int]: Given a list of student heights, determine for each student, the next taller student's height standing to their right. If there is no taller student to the right, record -1. >>> next_taller_student([10, 4, 6, 3, 8]) [-1, 6, 8, 8, -1] >>> next_taller_student([5, 3, 8, 2]) [8, 8, -1, -1] >>> next_taller_student([1, 3, 2, 4, 2, 5]) [3, 4, 4, 5, 5, -1] >>> next_taller_student([2]) [-1] >>> next_taller_student([3, 2, 1]) [-1, -1, -1] >>> next_taller_student([]) [] >>> next_taller_student([5, 5, 5, 5]) [-1, -1, -1, -1]","solution":"def next_taller_student(heights): Given a list of student heights, return a list where each position contains the next taller student's height to the right. If there is no taller student, the position should contain -1. n = len(heights) result = [-1] * n stack = [] for i in range(n-1, -1, -1): while stack and stack[-1] <= heights[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(heights[i]) return result"},{"question":"from typing import List, Tuple def min_max_distance(n: int, bridges: List[Tuple[int, int]]) -> int: Determine the minimum possible maximum distance between any two skyscrapers after adding the optimal set of new sky bridges. >>> min_max_distance(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) == 2 >>> min_max_distance(6, [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)]) == 2 >>> min_max_distance(2, [(1, 2)]) == 1 >>> min_max_distance(3, [(1, 2), (2, 3)]) == 1 >>> min_max_distance(7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (5, 7)]) == 3","solution":"from collections import deque def tree_diameter(tree, n): def bfs(start): dist = [-1] * n queue = deque([start]) dist[start] = 0 max_dist_node = start max_dist = 0 while queue: node = queue.popleft() for neighbor in tree[node]: if dist[neighbor] == -1: dist[neighbor] = dist[node] + 1 queue.append(neighbor) if dist[neighbor] > max_dist: max_dist = dist[neighbor] max_dist_node = neighbor return max_dist_node, max_dist node_1, _ = bfs(0) node_2, diameter = bfs(node_1) return diameter def min_max_distance(n, bridges): tree = [[] for _ in range(n)] for u, v in bridges: tree[u-1].append(v-1) tree[v-1].append(u-1) diameter = tree_diameter(tree, n) return (diameter + 1) // 2 def process_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) bridges = [(int(data[i]), int(data[i+1])) for i in range(1, len(data) - 1, 2)] result = min_max_distance(n, bridges) print(result) # To execute the process_input method, uncomment the following line # process_input()"},{"question":"def is_increasing_subsequence(sequence: List[int]) -> str: Determines if the given sequence is an increasing subsequence. Arguments: sequence -- list of integers representing the sequence Returns: \\"YES\\" if the sequence forms an increasing subsequence, \\"NO\\" otherwise Examples: >>> is_increasing_subsequence([1, 3, 5, 7]) 'YES' >>> is_increasing_subsequence([4, 4, 5, 6]) 'NO' >>> is_increasing_subsequence([2, 2, 3, 1]) 'NO' pass def process_test_cases(test_cases: List[List[int]]) -> List[str]: Processes multiple test cases to determine if each sequence forms an increasing subsequence. Arguments: test_cases -- a list of lists, where each sublist represents a sequence of integers Returns: a list of strings (\\"YES\\" or \\"NO\\") corresponding to each test case Examples: >>> process_test_cases([[1, 3, 5, 7], [4, 4, 5, 6], [2, 2, 3, 1]]) ['YES', 'NO', 'NO'] pass","solution":"def is_increasing_subsequence(sequence): Determines if the given sequence is an increasing subsequence. Arguments: sequence -- list of integers representing the sequence Returns: \\"YES\\" if the sequence forms an increasing subsequence, \\"NO\\" otherwise for i in range(1, len(sequence)): if sequence[i] <= sequence[i - 1]: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): Processes multiple test cases to determine if each sequence forms an increasing subsequence. Arguments: test_cases -- a list of lists, where each sublist represents a sequence of integers Returns: a list of strings (\\"YES\\" or \\"NO\\") corresponding to each test case results = [] for case in test_cases: results.append(is_increasing_subsequence(case)) return results"},{"question":"def average_grade_point(n, grades): Returns the average grade point based on the given letter grades, rounded to two decimal places. n: int - number of grades grades: List[str] - list of letter grades >>> average_grade_point(5, ['A', 'A', 'A', 'A', 'A']) 4.0 >>> average_grade_point(5, ['A', 'B', 'A', 'C', 'B']) 3.2 >>> average_grade_point(3, ['F', 'F', 'F']) 0.0 >>> average_grade_point(5, ['A', 'B', 'C', 'D', 'F']) 2.0 >>> average_grade_point(4, ['A', 'C', 'B', 'D']) 2.5","solution":"def average_grade_point(n, grades): Returns the average grade point based on the given letter grades, rounded to two decimal places. n: int - number of grades grades: List[str] - list of letter grades grade_points = {'A': 4, 'B': 3, 'C': 2, 'D': 1, 'F': 0} total_points = sum(grade_points[grade] for grade in grades) average = total_points / n return round(average, 2) # Example usage: n = 5 grades = ['A', 'B', 'A', 'C', 'B'] print(average_grade_point(n, grades)) # Output: 3.20"},{"question":"def min_swaps_to_sort(s: str) -> int: Returns the minimum number of swaps required to sort the string in alphabetical order. Args: s (str): A string consisting of lowercase Latin letters. Returns: int: The minimum number of swaps required to sort the string. Examples: >>> min_swaps_to_sort(\\"dcba\\") 6 >>> min_swaps_to_sort(\\"abc\\") 0 >>> min_swaps_to_sort(\\"zyx\\") 3 >>> min_swaps_to_sort(\\"a\\") 0 >>> min_swaps_to_sort(\\"aabbcc\\") 0 >>> min_swaps_to_sort(\\"edcba\\") 10 >>> min_swaps_to_sort(\\"bca\\") 2","solution":"def min_swaps_to_sort(s): Returns the minimum number of swaps required to sort the string s in alphabetical order. The function works by computing the number of inversions in the string. An inversion is a pair of indices (i, j) such that i < j and s[i] > s[j]. The number of swaps required to sort the string is equal to the number of inversions. def merge_sort_and_count(arr): if len(arr) < 2: return arr, 0 mid = len(arr) // 2 left, left_inv = merge_sort_and_count(arr[:mid]) right, right_inv = merge_sort_and_count(arr[mid:]) merged, split_inv = merge_and_count(left, right) return merged, left_inv + right_inv + split_inv def merge_and_count(left, right): res = [] i = j = 0 inversions = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) inversions += len(left) - i j += 1 res.extend(left[i:]) res.extend(right[j:]) return res, inversions arr = list(s) _, inversions = merge_sort_and_count(arr) return inversions"},{"question":"def get_books_order(m: int, n: int) -> List[List[int]]: Returns a list of lists representing the book IDs in the correct order as they appear on the shelves in the library. :param m: Number of rows (1-based index) :param n: Number of books per row (1-based index) :return: List of lists where each list represents the IDs of the books on that row >>> get_books_order(3, 4) [[1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12]] >>> get_books_order(2, 5) [[1, 2, 3, 4, 5], [10, 9, 8, 7, 6]]","solution":"def get_books_order(m, n): Returns a list of lists representing the book IDs in the correct order as they appear on the shelves in the library. :param m: Number of rows (1-based index) :param n: Number of books per row (1-based index) :return: List of lists where each list represents the IDs of the books on that row result = [] for i in range(m): if i % 2 == 0: result.append(list(range(i * n + 1, (i + 1) * n + 1))) else: result.append(list(range((i + 1) * n, i * n, -1))) return result"},{"question":"def shortestWord(s: str) -> int: Given a string s that contains a sequence of words separated by spaces, find the length of the shortest word in the sequence. If the string is empty, return -1. >>> shortestWord(\\"The quick brown fox jumps over the lazy dog\\") == 3 >>> shortestWord(\\" \\") == -1 >>> shortestWord(\\"coding is fun\\") == 2","solution":"def shortestWord(s): Returns the length of the shortest word in the string s, or -1 if the string is empty. if not s.strip(): return -1 words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"from typing import List, Tuple def assemble_widget(widget_height: int, widget_width: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Assemble a widget from smaller rectangular components. Args: widget_height (int): The height of the final widget. widget_width (int): The width of the final widget. operations (list of tuples): Each tuple contains dimensions and position (h, w, r, c) of a component. Returns: list of list of int: A 2D list representing the assembled widget. >>> operations = [ ... (2, 3, 0, 0), ... (2, 2, 1, 3), ... (1, 4, 2, 1) ... ] >>> assemble_widget(3, 5, operations) [[1, 1, 1, 0, 0], [1, 1, 1, 2, 2], [0, 3, 3, 3, 3]] pass Test Cases: def test_example_case(): widget_height = 3 widget_width = 5 operations = [ (2, 3, 0, 0), (2, 2, 1, 3), (1, 4, 2, 1) ] expected_output = [ [1, 1, 1, 0, 0], [1, 1, 1, 2, 2], [0, 3, 3, 3, 3] ] assert assemble_widget(widget_height, widget_width, operations) == expected_output def test_no_operations(): widget_height = 3 widget_width = 5 operations = [] expected_output = [ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] assert assemble_widget(widget_height, widget_width, operations) == expected_output def test_single_operation(): widget_height = 2 widget_width = 3 operations = [ (2, 3, 0, 0) ] expected_output = [ [1, 1, 1], [1, 1, 1] ] assert assemble_widget(widget_height, widget_width, operations) == expected_output def test_multiple_non_overlapping_operations(): widget_height = 4 widget_width = 4 operations = [ (2, 2, 0, 0), (2, 2, 2, 2) ] expected_output = [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2] ] assert assemble_widget(widget_height, widget_width, operations) == expected_output def test_full_coverage(): widget_height = 2 widget_width = 2 operations = [ (1, 2, 0, 0), (2, 1, 0, 1) ] expected_output = [ [1, 2], [0, 2] ] assert assemble_widget(widget_height, widget_width, operations) == expected_output","solution":"from typing import List, Tuple def assemble_widget(widget_height: int, widget_width: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: widget = [[0 for _ in range(widget_width)] for _ in range(widget_height)] for index, (h, w, r, c) in enumerate(operations): component_id = index + 1 for i in range(h): for j in range(w): widget[r + i][c + j] = component_id return widget"},{"question":"def common_digit(a: int, b: int) -> str: Determine if a and b share any common digits. Returns \\"Yes\\" if they do, otherwise \\"No\\". >>> common_digit(123, 456) \\"No\\" >>> common_digit(372, 225) \\"Yes\\"","solution":"def common_digit(a, b): Determine if a and b share any common digits. Returns \\"Yes\\" if they do, otherwise \\"No\\". set_a = set(str(a)) set_b = set(str(b)) if set_a & set_b: return \\"Yes\\" else: return \\"No\\""},{"question":"def min_operations_to_equal_elements(T, test_cases): Given the number of test cases and a list of test cases where each test case is represented by the size of the array and the array itself, this function computes the minimum number of operations required to make all elements of the array equal where the allowed operation is to add or subtract 1 from any element of the array. Args: T (int): the number of test cases test_cases (List[Tuple[int, List[int]]]): a list of tuples where each tuple consists of the size of the array and the array itself Returns: List[int]: a list where each element represents the minimum number of operations required for the corresponding test case >>> min_operations_to_equal_elements(1, [(3, [5, 5, 5])]) [0] >>> min_operations_to_equal_elements(1, [(4, [1, 2, 3, 4])]) [4] >>> min_operations_to_equal_elements(1, [(1, [1000])]) [0] # Placeholder for implementation pass # Sample Test Cases if __name__ == \\"__main__\\": test_cases = [ (2, [(4, [1, 2, 3, 4]), (3, [5, 5, 5])]) ] for T, cases in test_cases: print(min_operations_to_equal_elements(T, cases))","solution":"def min_operations_to_equal_elements(T, test_cases): Given the number of test cases and a list of test cases where each test case is represented by the size of the array and the array itself, this function computes the minimum number of operations required to make all elements of the array equal where the allowed operation is to add or subtract 1 from any element of the array. results = [] for case in test_cases: N, arr = case median = sorted(arr)[N // 2] operations = sum(abs(x - median) for x in arr) results.append(operations) return results"},{"question":"class Library: def __init__(self): Initialize the Library class with an empty dictionary to store books. self.books = {} def add_book(self, title, author): Adds a new book title and its author to the library. If the book already exists, update the author of the book. def remove_book(self, title): Removes an existing book title from the library. def find_book(self, title): Given a book title, return the name of the author. If the book is not found, return \\"Book not found\\". def list_books(self, author): Given an author's name, list all book titles authored by that person. If the author has no books in the library, return \\"No books found by this author\\". def process_commands(commands): Process a list of commands to manage the library. library = Library() results = [] for command in commands: parts = command.split(maxsplit=2) if parts[0] == \\"ADD\\": title, author = parts[1], parts[2] library.add_book(title, author) elif parts[0] == \\"REMOVE\\": title = parts[1] library.remove_book(title) elif parts[0] == \\"FIND\\": title = parts[1] results.append(library.find_book(title)) elif parts[0] == \\"LIST\\": author = parts[1] results.append(library.list_books(author)) return results # Example Usage: # >>> commands = [ # ... \\"ADD HarryPotter J.K.Rowling\\", # ... \\"ADD TheHobbit J.R.R.Tolkien\\", # ... \\"ADD HarryPotter J.K.Rowling\\", # ... \\"REMOVE TheHobbit\\", # ... \\"FIND HarryPotter\\", # ... \\"FIND TheHobbit\\", # ... \\"LIST J.K.Rowling\\", # ... \\"LIST J.R.R.Tolkien\\", # ... \\"ADD TheLordOfTheRings J.R.R.Tolkien\\", # ... \\"LIST J.R.R.Tolkien\\", # ... \\"REMOVE HarryPotter\\", # ... \\"LIST J.K.Rowling\\" # ... ] # >>> process_commands(commands) # ['J.K.Rowling', 'Book not found', 'HarryPotter', 'No books found by this author', 'TheLordOfTheRings', 'No books found by this author']","solution":"class Library: def __init__(self): # Library data structure to store books with title as key and author as value self.books = {} def add_book(self, title, author): # Add or update the book in the library self.books[title] = author def remove_book(self, title): # Remove the book from the library if it exists if title in self.books: del self.books[title] def find_book(self, title): # Find the book's author by title return self.books.get(title, \\"Book not found\\") def list_books(self, author): # List all books by the given author books_by_author = [title for title, auth in self.books.items() if auth == author] if books_by_author: return ','.join(books_by_author) else: return \\"No books found by this author\\" def process_commands(commands): library = Library() results = [] for command in commands: parts = command.split(maxsplit=2) if parts[0] == \\"ADD\\": title, author = parts[1], parts[2] library.add_book(title, author) elif parts[0] == \\"REMOVE\\": title = parts[1] library.remove_book(title) elif parts[0] == \\"FIND\\": title = parts[1] results.append(library.find_book(title)) elif parts[0] == \\"LIST\\": author = parts[1] results.append(library.list_books(author)) return results"},{"question":"def minimize_maintenance_cost(n: int, costs: List[int]) -> int: Returns the minimum maintenance cost to keep at least one of the endpoints. >>> minimize_maintenance_cost(5, [3, 1, 4, 1, 5]) 1 >>> minimize_maintenance_cost(3, [10, 20, 30]) 10","solution":"def minimize_maintenance_cost(n, costs): Returns the minimum maintenance cost to keep at least one of the endpoints. :param n: int - the number of points. :param costs: List[int] - a list containing the maintenance costs for each point. :return: int - the minimum maintenance cost achievable. # We can't remove both endpoints # Either we keep the starting point or the ending point # Or we find the minimum cost in the points between the start and end if n == 2: # Only two points, we have to keep both: the start and end points return min(costs) # We need to find the minimum cost from the points, excluding at least one end point min_cost = min(costs[:-1]) if costs[-1] >= costs[0] else min(costs[1:]) return min(min_cost, costs[0], costs[-1])"},{"question":"def compute_project_durations(state_changes): Compute the duration each project has spent in each unique state based on the state changes input. >>> input_data = [ ... \\"1 Planning 3\\", ... \\"1 Development 5\\", ... \\"2 Planning 2\\", ... \\"1 Testing 1\\", ... \\"2 Development 7\\", ... \\"3 Planning 4\\", ... \\"3 Testing 1\\", ... \\"end\\" ... ] >>> compute_project_durations(input_data) [\\"1 Planning:3 Development:5 Testing:1\\", \\"2 Planning:2 Development:7\\", \\"3 Planning:4 Testing:1\\"]","solution":"def compute_project_durations(state_changes): project_dict = {} for change in state_changes: if change == \\"end\\": break project_id, state_name, duration = change.split() project_id = int(project_id) duration = int(duration) if project_id not in project_dict: project_dict[project_id] = {} if state_name not in project_dict[project_id]: project_dict[project_id][state_name] = 0 project_dict[project_id][state_name] += duration result = [] for project_id in sorted(project_dict.keys()): states = project_dict[project_id] state_str = ' '.join([f\\"{state}:{states[state]}\\" for state in states]) result.append(f\\"{project_id} {state_str}\\") return result # Example input state_changes = [ \\"1 Planning 3\\", \\"1 Development 5\\", \\"2 Planning 2\\", \\"1 Testing 1\\", \\"2 Development 7\\", \\"3 Planning 4\\", \\"3 Testing 1\\", \\"end\\" ] # Example call to the function print(compute_project_durations(state_changes))"},{"question":"def is_balanced(s: str) -> str: Returns 'YES' if the brackets in the string are balanced and 'NO' otherwise. Constraints: 2 ≤ length of the string ≤ 100 The string contains only the characters '(', ')', '{', '}', '[' and ']' >>> is_balanced(\\"()[]{}\\") 'YES' >>> is_balanced(\\"([{}])\\") 'YES' >>> is_balanced(\\"([){}]\\") 'NO'","solution":"def is_balanced(s): Returns 'YES' if the brackets in the string are balanced and 'NO' otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\""},{"question":"def is_subsequence(a: str, b: str) -> bool: Determines if a is a subsequence of b. pass def max_wins_in_game(test_cases: List[Tuple[int, List[str]]]) -> List[int]: Given a list of test cases, determine the maximum number of rounds a string can win in a game of rock-paper-scissors played with strings. Args: test_cases: A list of tuples, each containing: - an integer n (number of strings) - a list of n strings Returns: A list of integers, each representing the maximum number of rounds a string can win for each test case. >>> max_wins_in_game([(3, [\\"abc\\", \\"ab\\", \\"a\\"]), (4, [\\"rock\\", \\"paper\\", \\"scissors\\", \\"string\\"]), (2, [\\"aaa\\", \\"aa\\"])]) [2, 1, 1] >>> max_wins_in_game([(1, [\\"abcd\\"])]) [1] pass from solution import is_subsequence, max_wins_in_game def test_is_subsequence(): assert is_subsequence(\\"abc\\", \\"aebdc\\") == True assert is_subsequence(\\"abc\\", \\"acb\\") == False assert is_subsequence(\\"a\\", \\"a\\") == True assert is_subsequence(\\"a\\", \\"b\\") == False def test_max_wins_in_game(): test_cases = [ (3, [\\"abc\\", \\"ab\\", \\"a\\"]), (4, [\\"rock\\", \\"paper\\", \\"scissors\\", \\"string\\"]), (2, [\\"aaa\\", \\"aa\\"]), (1, [\\"abcd\\"]), (3, [\\"xyz\\", \\"xy\\", \\"x\\"]), (3, [\\"abc\\", \\"def\\", \\"ghi\\"]), (5, [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\", \\"aaaaa\\"]) ] assert max_wins_in_game(test_cases) == [2, 1, 1, 1, 2, 1, 4]","solution":"def is_subsequence(a, b): Determines if a is a subsequence of b. it = iter(b) return all(char in it for char in a) def max_wins_in_game(test_cases): outputs = [] for n, strings in test_cases: max_wins = 1 # the minimum rounds any string can win is itself for i in range(n): wins = 0 for j in range(n): if i != j and is_subsequence(strings[i], strings[j]): wins += 1 max_wins = max(max_wins, wins) outputs.append(max_wins) return outputs"},{"question":"def longest_increasing_subarray(n: int, a: List[int]) -> int: Returns the length of the longest strictly increasing sub-array. Parameters: n (int): Number of days. a (list of int): Growth rates over a span of consecutive days. Returns: int: Length of the longest strictly increasing sub-array. >>> longest_increasing_subarray(6, [1, 2, 3, 2, 3, 4]) 3 >>> longest_increasing_subarray(5, [5, 5, 5, 5, 5]) 1 >>> longest_increasing_subarray(7, [1, 3, 2, 1, 4, 6, 7]) 4 >>> longest_increasing_subarray(1, [10]) 1 >>> longest_increasing_subarray(6, [6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_increasing_subarray(6, [1, 2, 3, 4, 3, 2]) 4 >>> longest_increasing_subarray(7, [1, 2, 1, 2, 3, 1, 2]) 3 >>> longest_increasing_subarray(8, [1, 2, 2, 3, 4, 4, 5, 6]) 3","solution":"def longest_increasing_subarray(n, a): Returns the length of the longest strictly increasing sub-array. Parameters: n (int): Number of days. a (list of int): Growth rates over a span of consecutive days. Returns: int: Length of the longest strictly increasing sub-array. if n == 1: return 1 max_length = 1 current_length = 1 for i in range(1, n): if a[i] > a[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def latest_time(t: int, test_cases: List[str]) -> List[str]: Given a number of test cases with time strings in the format HH:MM where some digits might be '?', determine the latest valid time possible by replacing the '?' characters with the most appropriate digits (0-9). Args: t (int): The number of test cases. test_cases (List[str]): A list of time strings. Returns: List[str]: A list of the latest valid times possible for each test case. >>> latest_time(3, [\\"2?:4?\\", \\"?9:0?\\", \\"??:??\\"]) ['23:49', '19:09', '23:59'] >>> latest_time(1, [\\"23:5?\\"]) ['23:59']","solution":"def latest_time(t, test_cases): def max_valid_time(time_str): hh, mm = time_str.split(\\":\\") # Determine the hours if hh[0] == '?': if hh[1] == '?' or int(hh[1]) <= 3: hh = '2' + hh[1] if hh[1] != '?' else '23' else: hh = '1' + hh[1] if hh[1] == '?': hh = hh[0] + ('3' if hh[0] == '2' else '9') # Determine the minutes if mm[0] == '?': mm = '5' + mm[1] if mm[1] != '?' else '59' if mm[1] == '?': mm = mm[0] + '9' return f\\"{hh}:{mm}\\" results = [] for time_str in test_cases: results.append(max_valid_time(time_str)) return results"},{"question":"def group_numbers_by_even_odd(numbers): Returns a dictionary with two keys: 'even' and 'odd'. The value corresponding to each key is a list that contains integers from the input list that are even and odd, respectively. >>> group_numbers_by_even_odd([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {'even': [2, 4, 6, 8, 10], 'odd': [1, 3, 5, 7, 9]} >>> group_numbers_by_even_odd([1, 3, 5, 7, 9]) {'even': [], 'odd': [1, 3, 5, 7, 9]} >>> group_numbers_by_even_odd([2, 4, 6, 8, 10]) {'even': [2, 4, 6, 8, 10], 'odd': []} >>> group_numbers_by_even_odd([]) {'even': [], 'odd': []} >>> group_numbers_by_even_odd([0, -2, -1, 1, 2]) {'even': [0, -2, 2], 'odd': [-1, 1]} >>> group_numbers_by_even_odd([-4, -3, -2, -1, 0]) {'even': [-4, -2, 0], 'odd': [-3, -1]}","solution":"def group_numbers_by_even_odd(numbers): Returns a dictionary with two keys: 'even' and 'odd'. The value corresponding to each key is a list that contains integers from the input list that are even and odd, respectively. grouped_numbers = {\\"even\\": [], \\"odd\\": []} for number in numbers: if number % 2 == 0: grouped_numbers[\\"even\\"].append(number) else: grouped_numbers[\\"odd\\"].append(number) return grouped_numbers"},{"question":"def largestPrimeFibonacci(n: int) -> int: Given a number n, return the largest prime number that is also a Fibonacci number such that it is less than or equal to n. If no such number exists, return -1. Args: n (int): an integer n Returns: int: the largest prime Fibonacci number less than or equal to n, or -1 if no such number exists. Examples: >>> largestPrimeFibonacci(10) 5 >>> largestPrimeFibonacci(4) 3 >>> largestPrimeFibonacci(1) -1 from solution import largestPrimeFibonacci def test_largestPrimeFibonacci_example1(): assert largestPrimeFibonacci(10) == 5 def test_largestPrimeFibonacci_example2(): assert largestPrimeFibonacci(4) == 3 def test_largestPrimeFibonacci_example3(): assert largestPrimeFibonacci(1) == -1 def test_largestPrimeFibonacci_large_input(): assert largestPrimeFibonacci(10000) == 1597 def test_largestPrimeFibonacci_no_prime_fib(): assert largestPrimeFibonacci(14) == 13 assert largestPrimeFibonacci(15) == 13 def test_largestPrimeFibonacci_smallest_prime_fib(): assert largestPrimeFibonacci(2) == 2","solution":"def largestPrimeFibonacci(n): Returns the largest prime Fibonacci number less than or equal to n. if n < 2: return -1 def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5)+1): if num % i == 0: return False return True fib1, fib2 = 0, 1 largest_prime_fib = -1 while fib2 <= n: if is_prime(fib2): largest_prime_fib = fib2 fib1, fib2 = fib2, fib1 + fib2 return largest_prime_fib"},{"question":"def arrange_flowers(n: int, arr: List[int]) -> List[int]: Arrange the flowers such that the absolute difference in attractiveness between any two adjacent flowers is minimized. Parameters: n (int): Number of flowers. arr (list of int): The attractiveness of each flower. Returns: list of int: A valid sequence of flower attractiveness values. >>> arrange_flowers(5, [-2, 4, 1, 0, -5]) [-5, -2, 0, 1, 4] >>> arrange_flowers(3, [10, 5, -1]) [-1, 5, 10]","solution":"def arrange_flowers(n, arr): Arrange the flowers such that the absolute difference in attractiveness between any two adjacent flowers is minimized. Parameters: n (int): Number of flowers. arr (list of int): The attractiveness of each flower. Returns: list of int: A valid sequence of flower attractiveness values. # Sort the array to minimize the absolute differences between adjacent elements arr.sort() return arr"},{"question":"def min_coins(denominations, amount): Determines the minimum number of coins needed to make up the target amount with the given coin denominations. Returns -1 if it is not possible. Parameters: denominations (List[int]): List of distinct positive integers representing coin denominations. amount (int): The target amount of money. Returns: int: Minimum number of coins needed to make up the target amount, or -1 if it is not possible. Examples: >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1], 0) 0 >>> min_coins([1, 2, 5], 5) 1","solution":"def min_coins(denominations, amount): Determines the minimum number of coins needed to make up the target amount with the given coin denominations. Returns -1 if it is not possible. Parameters: denominations (List[int]): List of distinct positive integers representing coin denominations. amount (int): The target amount of money. Returns: int: Minimum number of coins needed to make up the target amount, or -1 if it is not possible. # If amount is 0, no coins are needed if amount == 0: return 0 # Initialize DP array to a value larger than any possible number of coins dp = [float('inf')] * (amount + 1) dp[0] = 0 # Loop through each amount up to the target amount for a in range(1, amount + 1): for coin in denominations: if a - coin >= 0: dp[a] = min(dp[a], dp[a - coin] + 1) # If dp[amount] is still float('inf'), it means we couldn't form the amount with given coins return -1 if dp[amount] == float('inf') else dp[amount]"},{"question":"from typing import List, Tuple def count_pattern_occurrences(N: int, edges: List[Tuple[int, int, str]], Q: int, queries: List[Tuple[int, int, str]]) -> List[int]: Determine how many times a given pattern appears as a contiguous subsequence in the flutter sequences between two specific observation points. Args: N : int : the number of observation points in the reserve edges : List[Tuple[int, int, str]] : list of observation point connections and the flutter pattern sequences Q : int : the number of queries queries : List[Tuple[int, int, str]] : list of queries to count pattern occurrences Returns: List[int] : list of counts of pattern occurrences for each query Example: >>> count_pattern_occurrences(7, [(1, 2, 'a'), (2, 3, 'b'), (3, 4, 'c'), (4, 5, 'd'), (5, 6, 'e'), (6, 7, 'f')], 5, [(1, 7, 'abc'), (2, 5, 'bcd'), (1, 4, 'ab'), (3, 6, 'cde'), (4, 7, 'def')]) [1, 1, 1, 1, 1] pass","solution":"from collections import defaultdict, deque def count_pattern_occurrences(N, edges, Q, queries): # Build the graph graph = defaultdict(list) flutter_seq = defaultdict(str) for u, v, p in edges: graph[u].append(v) flutter_seq[(u, v)] = p def bfs(u, v): q = deque([(u, \\"\\")]) visited = set() paths = [] while q: node, path = q.popleft() if node == v: paths.append(path) visited.add(node) for neighbor in graph[node]: if neighbor not in visited: q.append((neighbor, path + flutter_seq[(node, neighbor)])) return paths result = [] def count_occurrences(s, pat): return sum(s[i:i+len(pat)] == pat for i in range(len(s) - len(pat) + 1)) for (u, v, pat) in queries: paths = bfs(u, v) count = sum(count_occurrences(path, pat) for path in paths) result.append(count) return result"},{"question":"def is_in_ap_sequence(a: int, d: int, x: int) -> str: Determines if a number x appears in the Arithmetic Progression (AP) sequence generated by starting with a as the first term and d as the common difference. Args: a (int): the first term of the sequence. d (int): the common difference of the sequence. x (int): the number to check for in the sequence. Returns: str: 'YES' if x appears in the sequence, otherwise 'NO'. >>> is_in_ap_sequence(1, 2, 5) 'NO' >>> is_in_ap_sequence(3, 3, 9) 'YES' >>> is_in_ap_sequence(7, 7, 35) 'YES' >>> is_in_ap_sequence(2, 4, 10) 'YES' ... def process_queries(queries: list[tuple[int, int, int]]) -> list[str]: Processes multiple queries to determine if numbers appear in their respective Arithmetic Progression (AP) sequences. Args: queries (list[tuple[int, int, int]]): a list of tuples where each tuple contains three integers (a, d, x) representing the starting term, common difference, and the number to check for in the sequence. Returns: list[str]: a list of results where each result is 'YES' or 'NO' for the respective query >>> queries = [ ... (1, 2, 5), ... (3, 3, 9), ... (7, 7, 35), ... (2, 4, 10) ... ] >>> process_queries(queries) ['NO', 'YES', 'YES', 'YES'] ...","solution":"def is_in_ap_sequence(a, d, x): Returns 'YES' if x is part of the AP sequence that starts with \`a\` and has common difference \`d\`, otherwise returns 'NO'. if x < a: return \\"NO\\" return \\"YES\\" if (x - a) % d == 0 else \\"NO\\" def process_queries(queries): results = [] for a, d, x in queries: results.append(is_in_ap_sequence(a, d, x)) return results"},{"question":"def k_th_highest_score(scores: List[int], k: int) -> int: Given a list of unsorted scores of students and the number of students to be selected for a coding competition, determine the k-th highest score where k is the number of students to be selected. If there are multiple students with the same score, the priority is determined by their original position in the list. >>> k_th_highest_score([50, 80, 90, 70, 90, 60], 3) 80 >>> k_th_highest_score([30, 40, 50, 20, 10], 2) 40 >>> k_th_highest_score([100, 100, 100, 90, 80], 1) 100","solution":"def k_th_highest_score(scores, k): Returns the k-th highest score from the list of scores. if not scores or k < 1 or k > len(scores): raise ValueError(\\"Invalid input\\") # Sort the scores in descending order sorted_scores = sorted(scores, reverse=True) # Return the k-th highest score return sorted_scores[k-1]"},{"question":"def perform_queries(N: int, Q: int, A: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Zara has an array of integers and she loves playing with blocks of elements. This function performs queries on an array where each query can either update the value at a specific index in the array or find the sum of elements in a specific block of the array. Each query is a tuple: - (1, index, value): Update the value at the given index. - (2, L, R): Find the sum of elements from index L to R (inclusive). Args: N (int): The length of the array. Q (int): The number of queries. A (List[int]): The initial array of integers. queries (List[Tuple[int, int, int]]): The list of queries to be performed. Returns: List[int]: For each sum query, return the result on a new line. Examples: >>> perform_queries(5, 3, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 6), (2, 1, 3)]) [9, 12] >>> perform_queries(5, 2, [1, 1, 1, 1, 1], [(2, 0, 4), (1, 0, 5), (2, 0, 4)]) [5, 9]","solution":"def perform_queries(N, Q, A, queries): result = [] for query in queries: if query[0] == 1: # Perform the update operation index = query[1] value = query[2] A[index] = value elif query[0] == 2: # Perform the range sum operation L = query[1] R = query[2] result.append(sum(A[L:R+1])) return result"},{"question":"def min_difference(n: int, coins: List[int]) -> int: Given a list of coin values, split them into two groups such that the absolute difference between the total monetary values of the two groups is minimized. >>> min_difference(3, [1, 2, 7]) 4 >>> min_difference(4, [3, 1, 4, 2]) 0 >>> min_difference(5, [10, 20, 15, 5, 25]) 5","solution":"def min_difference(n, coins): Given a list of coin values, split them into two groups such that the absolute difference between the total monetary values of the two groups is minimized. total_sum = sum(coins) min_diff = float('inf') # Explore all subsets using bitmasking for i in range(1 << n): subset_sum = 0 for j in range(n): if i & (1 << j): subset_sum += coins[j] remaining_sum = total_sum - subset_sum min_diff = min(min_diff, abs(subset_sum - remaining_sum)) return min_diff"},{"question":"def maximize_min_water(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: Determine the maximum possible amount of water that the reservoir with the least water can hold by the end of the redistribution process. Args: T (int): Number of test cases. test_cases (List[Dict[str, Any]]): List of dictionaries, each containing: - N (int): Number of reservoirs. - waters (List[int]): Amount of water in each reservoir. - M (int): Number of direct connections between the reservoirs. - connections (List[Tuple[int, int]]): Bidirectional connections between reservoirs. Returns: List[int]: The maximum possible amount of water in the reservoir with the least water for each test case. def parse_input(input_str: str) -> Tuple[int, List[Dict[str, Any]]]: Parse the given input string into the number of test cases and a list of test case dictionaries. Args: input_str (str): Multiline input string. Returns: Tuple[int, List[Dict[str, Any]]]: Number of test cases and a list of test case dictionaries. def format_output(output: List[int]) -> str: Format the output list into a multiline string. Args: output (List[int]): List of maximum possible amount of water values. Returns: str: Formatted string representing the output list. # Unit tests def test_maximize_min_water(): input_str = 2 3 3 6 9 2 1 2 2 3 4 5 5 5 5 3 1 2 2 3 3 4 T, test_cases = parse_input(input_str) result = maximize_min_water(T, test_cases) expected_output = [6, 5] assert result == expected_output def test_parse_input(): input_str = 2 3 3 6 9 2 1 2 2 3 4 5 5 5 5 3 1 2 2 3 3 4 expected_T = 2 expected_test_cases = [ {\\"N\\": 3, \\"waters\\": [3, 6, 9], \\"M\\": 2, \\"connections\\": [(1, 2), (2, 3)]}, {\\"N\\": 4, \\"waters\\": [5, 5, 5, 5], \\"M\\": 3, \\"connections\\": [(1, 2), (2, 3), (3, 4)]}, ] T, test_cases = parse_input(input_str) assert T == expected_T assert test_cases == expected_test_cases def test_format_output(): output = [6, 5] expected_output_str = \\"6n5\\" result_str = format_output(output) assert result_str == expected_output_str def test_maximize_min_water_all_equally_connected(): input_str = 1 4 4 4 4 4 6 1 2 1 3 1 4 2 3 2 4 3 4 T, test_cases = parse_input(input_str) result = maximize_min_water(T, test_cases) expected_output = [4] assert result == expected_output","solution":"def maximize_min_water(T, test_cases): def dfs(node, graph, visited): connected_component = [] stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True connected_component.append(current) for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) return connected_component results = [] for i in range(T): N = test_cases[i]['N'] waters = test_cases[i]['waters'] M = test_cases[i]['M'] connections = test_cases[i]['connections'] graph = {x: [] for x in range(N)} for u, v in connections: graph[u-1].append(v-1) graph[v-1].append(u-1) visited = [False] * N max_min_water = 0 for reservoir in range(N): if not visited[reservoir]: connected_component = dfs(reservoir, graph, visited) total_water = sum(waters[j] for j in connected_component) max_min_water = max(max_min_water, total_water // len(connected_component)) results.append(max_min_water) return results def parse_input(input_str): input_list = input_str.strip().split(\\"n\\") T = int(input_list[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_list[index]) waters = list(map(int, input_list[index + 1].split())) M = int(input_list[index + 2]) connections = [] for j in range(M): u, v = map(int, input_list[index + 3 + j].split()) connections.append((u, v)) test_cases.append({ \\"N\\": N, \\"waters\\": waters, \\"M\\": M, \\"connections\\": connections }) index += 3 + M return T, test_cases def format_output(output): return \\"n\\".join(map(str, output))"},{"question":"def adjust_temperatures(n: int, m: int, commands: List[Tuple[int, int, int]]) -> List[int]: Adjusts the temperatures of n buildings based on m commands. Parameters: n (int): The number of buildings. m (int): The number of commands. commands (list of tuples): Each tuple contains three integers (i, t, d) representing the building id, the time of the command, and the temperature difference respectively. Returns: list: A list of final temperatures of the buildings. # Write your code here # Example Testing cases if __name__ == \\"__main__\\": n = 3 m = 5 commands = [ (1, 1, 5), (2, 2, -3), (3, 3, 10), (1, 4, -2), (3, 3, -5) ] print(adjust_temperatures(n, m, commands)) # Output: [3, -3, 5] n = 1 m = 1 commands = [(1, 1, 10)] print(adjust_temperatures(n, m, commands)) # Output: [10] n = 2 m = 4 commands = [ (1, 1, 1), (1, 2, 2), (2, 1, -1), (2, 2, -2) ] print(adjust_temperatures(n, m, commands)) # Output: [3, -3] n = 4 m = 3 commands = [ (1, 1, 0), (2, 2, 0), (3, 3, 0) ] print(adjust_temperatures(n, m, commands)) # Output: [0, 0, 0, 0] n = 10000 m = 100000 commands = [(i % 10000 + 1, i, i % 200 - 100) for i in range(100000)] result = adjust_temperatures(n, m, commands) print(len(result)) # Output: 10000 (no specific value check due to large input)","solution":"def adjust_temperatures(n, m, commands): Adjusts the temperatures of n buildings based on m commands. Parameters: n (int): The number of buildings. m (int): The number of commands. commands (list of tuples): Each tuple contains three integers (i, t, d) representing the building id, the time of the command, and the temperature difference respectively. Returns: list: A list of final temperatures of the buildings. temperatures = [0] * n # Initialize the temperatures of all buildings to 0 for command in commands: building_id, _, temp_diff = command temperatures[building_id - 1] += temp_diff return temperatures"},{"question":"def is_possible_division(n: int, m: int, rivalries: List[Tuple[int, int]]) -> str: Determine if it is possible to divide n teams into groups of 4 such that no rival teams are in the same group. >>> is_possible_division(8, 3, [(1, 2), (3, 4), (5, 6)]) \\"Possible\\" >>> is_possible_division(4, 3, [(1, 2), (1, 3), (1, 4)]) \\"Impossible\\"","solution":"def is_possible_division(n, m, rivalries): from collections import defaultdict from itertools import combinations # Creating adjacency list for rivalries rivalries_dict = defaultdict(list) for a, b in rivalries: rivalries_dict[a].append(b) rivalries_dict[b].append(a) # We need to check all combinations of teams grouped by 4. teams = list(range(1, n+1)) all_possible_groups = list(combinations(teams, 4)) for group in all_possible_groups: group_set = set(group) group_valid = True for a, b in rivalries: if a in group_set and b in group_set: group_valid = False break if group_valid: remaining_teams = set(teams) - group_set remaining_teams_groups = list(combinations(remaining_teams, 4)) for rem_group in remaining_teams_groups: rem_group_set = set(rem_group) rem_group_valid = True for a, b in rivalries: if a in rem_group_set and b in rem_group_set: rem_group_valid = False break if rem_group_valid: return \\"Possible\\" return \\"Impossible\\" # Example usage #input_data = (8, 3, [(1, 2), (3, 4), (5, 6)]) #print(is_possible_division(*input_data))"},{"question":"def nthNumberInSequence(n: int) -> int: Returns the nth number in a sequence where each number is defined as the sum of squares of the first n natural numbers. >>> nthNumberInSequence(3) 14 >>> nthNumberInSequence(5) 55 >>> nthNumberInSequence(1) 1 >>> nthNumberInSequence(10) 385","solution":"def nthNumberInSequence(n): Returns the nth number in a sequence where each number is defined as the sum of squares of the first n natural numbers. return n * (n + 1) * (2 * n + 1) // 6"},{"question":"def max_profit_with_k_transactions(k: int, prices: List[int]) -> int: Returns the maximum profit with at most k transactions. >>> max_profit_with_k_transactions(2, [3, 2, 6, 5, 0, 3]) 7 >>> max_profit_with_k_transactions(1, [1, 2, 3, 4, 5]) 4 pass def max_profits_from_transactions(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns a list of maximum profits for each test case. >>> test_cases = [(2, [3, 2, 6, 5, 0, 3]), (1, [1, 2, 3, 4, 5])] >>> max_profits_from_transactions(test_cases) [7, 4] pass","solution":"def max_profit_with_k_transactions(k, prices): Returns the maximum profit with at most k transactions. n = len(prices) if n == 0 or k == 0: return 0 # If k is larger than n//2, then we can consider it as infinite transactions if k > n // 2: max_profit = 0 for i in range(1, n): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit dp = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_diff = -prices[0] for d in range(1, n): dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff) max_diff = max(max_diff, dp[t - 1][d] - prices[d]) return dp[k][n - 1] def max_profits_from_transactions(test_cases): results = [] for k, prices in test_cases: results.append(max_profit_with_k_transactions(k, prices)) return results"},{"question":"def process_queries(n: int, m: int, arr: List[int], queries: List[str]) -> List[int]: Process queries and apply each to the array. Args: n (int): Size of the array. m (int): Number of queries. arr (List[int]): The array of integers. queries (List[str]): The list of queries to be processed. Returns: List[int]: Results of the sum queries. >>> n = 5 >>> m = 6 >>> arr = [1, 2, 3, 4, 5] >>> queries = [\\"1 0 4\\", \\"3 0 4\\", \\"2 1 3\\", \\"3 0 4\\", \\"1 2 3\\", \\"3 1 3\\"] >>> process_queries(n, m, arr, queries) [15, 15, 9] >>> n = 4 >>> m = 0 >>> arr = [10, 20, 30, 40] >>> queries = [] >>> process_queries(n, m, arr, queries) [] >>> n = 3 >>> m = 1 >>> arr = [5, 10, 15] >>> queries = [\\"3 0 2\\"] >>> process_queries(n, m, arr, queries) [30] >>> n = 3 >>> m = 1 >>> arr = [5, 10, 15] >>> queries = [\\"1 0 2\\"] >>> process_queries(n, m, arr, queries) >>> arr [15, 10, 5] >>> n = 5 >>> m = 1 >>> arr = [1, 2, 3, 4, 5] >>> queries = [\\"2 1 3\\"] >>> process_queries(n, m, arr, queries) >>> arr [1, 4, 3, 2, 5]","solution":"def process_queries(n, m, arr, queries): results = [] for query in queries: q = query.split() if q[0] == \\"1\\": a, b = int(q[1]), int(q[2]) arr[a], arr[b] = arr[b], arr[a] elif q[0] == \\"2\\": a, b = int(q[1]), int(q[2]) arr[a:b + 1] = arr[a:b + 1][::-1] elif q[0] == \\"3\\": a, b = int(q[1]), int(q[2]) results.append(sum(arr[a:b + 1])) return results"},{"question":"from typing import List def max_palindrome_length(S: str) -> int: Returns the maximum length of a palindrome that can be made from the string S. >>> max_palindrome_length('a') == 1 >>> max_palindrome_length('aabbcc') == 6 >>> max_palindrome_length('aabbc') == 5 >>> max_palindrome_length('abccccdd') == 7 >>> max_palindrome_length('abcdef') == 1 pass def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases and return the result for each. >>> process_test_cases(1, ['aabbc']) == [5] >>> process_test_cases(2, ['abccccdd', 'aabbcc']) == [7, 6] >>> process_test_cases(0, []) == [] pass","solution":"from collections import Counter def max_palindrome_length(S): Returns the maximum length of a palindrome that can be made from the string S. count = Counter(S) length = 0 odd_found = False for freq in count.values(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_found = True if odd_found: length += 1 return length def process_test_cases(T, test_cases): results = [] for i in range(T): results.append(max_palindrome_length(test_cases[i])) return results"},{"question":"def robot_vacuum(n, m, k, commands, b, barriers): Determine if the robot vacuum can successfully complete the series of commands without hitting a barrier. Args: n (int): number of rows in the grid. m (int): number of columns in the grid. k (int): number of commands. commands (list of tuples): each tuple contains a command direction and steps count. b (int): number of barriers. barriers (list of tuples): each tuple contains the coordinates of a barrier. Returns: str: \\"success\\" if the robot can complete all commands without hitting a barrier, otherwise \\"blocked\\". from solution import robot_vacuum def test_no_barriers(): n, m = 5, 5 k = 3 commands = [(\\"right\\", 3), (\\"down\\", 2), (\\"left\\", 1)] b = 0 barriers = [] assert robot_vacuum(n, m, k, commands, b, barriers) == \\"success\\" def test_with_barrier(): n, m = 5, 5 k = 4 commands = [(\\"right\\", 3), (\\"down\\", 2), (\\"left\\", 2), (\\"up\\", 1)] b = 2 barriers = [(2, 2), (3, 2)] assert robot_vacuum(n, m, k, commands, b, barriers) == \\"blocked\\" def test_out_of_bounds(): n, m = 5, 5 k = 2 commands = [(\\"down\\", 6), (\\"right\\", 3)] b = 0 barriers = [] assert robot_vacuum(n, m, k, commands, b, barriers) == \\"blocked\\" def test_successful_navigation(): n, m = 10, 10 k = 5 commands = [(\\"right\\", 3), (\\"down\\", 3), (\\"left\\", 2), (\\"up\\", 1), (\\"right\\", 5)] b = 1 barriers = [(1, 1)] assert robot_vacuum(n, m, k, commands, b, barriers) == \\"success\\" def test_single_command(): n, m = 1, 1 k = 1 commands = [(\\"down\\", 1)] b = 0 barriers = [] assert robot_vacuum(n, m, k, commands, b, barriers) == \\"blocked\\"","solution":"def robot_vacuum(n, m, k, commands, b, barriers): Determine if the robot vacuum can successfully complete the series of commands without hitting a barrier. Args: n (int): number of rows in the grid. m (int): number of columns in the grid. k (int): number of commands. commands (list of tuples): each tuple contains a command direction and steps count. b (int): number of barriers. barriers (list of tuples): each tuple contains the coordinates of a barrier. Returns: str: \\"success\\" if the robot can complete all commands without hitting a barrier, otherwise \\"blocked\\". current_position = [0, 0] # starting at the origin (0, 0) barriers_set = set(barriers) # convert list of barriers to set for O(1) lookup for command in commands: direction, steps = command for _ in range(steps): if direction == \\"up\\": current_position[0] -= 1 elif direction == \\"down\\": current_position[0] += 1 elif direction == \\"left\\": current_position[1] -= 1 elif direction == \\"right\\": current_position[1] += 1 # Check if the robot is out of bounds if not (0 <= current_position[0] < n and 0 <= current_position[1] < m): return \\"blocked\\" # Check if the robot hits a barrier if tuple(current_position) in barriers_set: return \\"blocked\\" return \\"success\\""},{"question":"def reverse_words(s: str) -> str: Reverses characters in each word of the given string s while maintaining the word order. >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"python is fun\\") \\"nohtyp si nuf\\" >>> reverse_words(\\"hello, world!\\") \\",olleh !dlrow\\" >>> reverse_words(\\"a b c d\\") \\"a b c d\\" >>> reverse_words(\\"123 456 789\\") \\"321 654 987\\"","solution":"def reverse_words(s: str) -> str: Reverses characters in each word of the given string s while maintaining the word order. # Splitting the string into words, reversing each word, and joining them back with spaces return ' '.join([word[::-1] for word in s.split()])"},{"question":"from typing import List, Tuple def greatest_sum_of_subsequences(s: List[int]) -> int: Given a sequence of integers, find the greatest sum of all non-empty subsequences. >>> greatest_sum_of_subsequences([1, -2, 3, 4, -1]) 8 >>> greatest_sum_of_subsequences([-1, -2, -3]) -1 pass def execute_problem_statements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases, and for each test case a sequence of integers, return the Greatest Sum of Subsequences for each test case. >>> execute_problem_statements(2, [(5, [1, -2, 3, 4, -1]), (3, [-1, -2, -3])]) [8, -1] >>> execute_problem_statements(1,[(3, [-1, -2, 0])]) [0] pass","solution":"def greatest_sum_of_subsequences(s): return max(0, sum(x for x in s if x > 0)) or max(s) def solve(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] result = greatest_sum_of_subsequences(s) results.append(result) return results # Function to parse the input and execute the solve function def execute_problem_statements(t, test_cases): return solve(t, test_cases)"},{"question":"def count_distinct_artifacts(artifact_sequence): Returns the number of distinct artifacts in the given sequence. >>> count_distinct_artifacts(\\"abca\\") 3 >>> count_distinct_artifacts(\\"zzzz\\") 1 >>> count_distinct_artifacts(\\"abcdefghijklmnopqrstuvwxyz\\") 26","solution":"def count_distinct_artifacts(artifact_sequence): Returns the number of distinct artifacts in the given sequence. :param artifact_sequence: str - A string representing the sequence of artifacts. :return: int - The number of distinct types of artifacts. return len(set(artifact_sequence))"},{"question":"def highestFrequency(S: str) -> int: Determine the frequency of the most frequent character and return the highest frequency. >>> highestFrequency(\\"aabbcc\\") 2 >>> highestFrequency(\\"abcde\\") 1 >>> highestFrequency(\\"\\") 0 >>> highestFrequency(\\"aaaaa\\") 5 >>> highestFrequency(\\"aabbbccccc\\") 5 >>> highestFrequency(\\"zxyyxzz\\") 3 >>> highestFrequency(\\"abcdefghijabcdefghij\\") 2","solution":"def highestFrequency(S): Returns the highest frequency of any character in the string S. from collections import Counter if not S: return 0 frequency = Counter(S) return max(frequency.values())"},{"question":"def num_distinct_pairs_divisible_by_k(n: int, k: int, A: List[int]) -> int: Find the number of distinct pairs (i, j) such that i != j and A_i * A_j is divisible by k. >>> num_distinct_pairs_divisible_by_k(5, 6, [1, 2, 3, 4, 5]) 4 >>> num_distinct_pairs_divisible_by_k(3, 10, [1, 2, 3]) 0 >>> num_distinct_pairs_divisible_by_k(3, 1, [1, 2, 3]) 6 >>> num_distinct_pairs_divisible_by_k(1, 7, [5]) 0 >>> num_distinct_pairs_divisible_by_k(3, 1000000, [1000000, 2000000, 3000000]) 6 >>> num_distinct_pairs_divisible_by_k(4, 5, [10, 5, 15, 20]) 12","solution":"def num_distinct_pairs_divisible_by_k(n, k, A): count = 0 for i in range(n): for j in range(n): if i != j and (A[i] * A[j]) % k == 0: count += 1 return count"},{"question":"def total_work_hours(work_logs): Calculate the total hours worked by each employee across all projects. :param work_logs: List of dictionaries with keys 'employee', 'hours', and 'project'. :return: List of dictionaries with keys 'employee' and 'total_hours'. >>> total_work_hours([ ... {'employee': 'Alice', 'hours': 5.5, 'project': 'Project1'}, ... {'employee': 'Bob', 'hours': 3.0, 'project': 'Project2'}, ... {'employee': 'Alice', 'hours': 2.5, 'project': 'Project2'}, ... {'employee': 'Bob', 'hours': 4.0, 'project': 'Project1'} ...]) [{'employee': 'Alice', 'total_hours': 8.0}, {'employee': 'Bob', 'total_hours': 7.0}] >>> total_work_hours([ ... {'employee': 'Alice', 'hours': 5.0, 'project': 'Project1'}, ... {'employee': 'Bob', 'hours': 3.5, 'project': 'Project2'} ...]) [{'employee': 'Alice', 'total_hours': 5.0}, {'employee': 'Bob', 'total_hours': 3.5}] >>> total_work_hours([ ... {'employee': 'Alice', 'hours': 2.5, 'project': 'Project1'}, ... {'employee': 'Alice', 'hours': 2.5, 'project': 'Project1'}, ... {'employee': 'Alice', 'hours': 4.0, 'project': 'Project2'} ...]) [{'employee': 'Alice', 'total_hours': 9.0}] >>> total_work_hours([]) [] >>> total_work_hours([ ... {'employee': 'Charlie', 'hours': 3.0, 'project': 'Project3'} ...]) [{'employee': 'Charlie', 'total_hours': 3.0}] >>> total_work_hours([ ... {'employee': 'Alice', 'hours': 0.0, 'project': 'Project1'}, ... {'employee': 'Bob', 'hours': 0.0, 'project': 'Project2'}, ... {'employee': 'Alice', 'hours': 0.0, 'project': 'Project2'} ...]) [{'employee': 'Alice', 'total_hours': 0.0}, {'employee': 'Bob', 'total_hours': 0.0}]","solution":"def total_work_hours(work_logs): Calculate the total hours worked by each employee across all projects. :param work_logs: List of dictionaries with keys 'employee', 'hours', and 'project'. :return: List of dictionaries with keys 'employee' and 'total_hours'. from collections import defaultdict employee_hours = defaultdict(float) for log in work_logs: employee = log['employee'] hours = log['hours'] employee_hours[employee] += hours return [{'employee': employee, 'total_hours': hours} for employee, hours in employee_hours.items()]"},{"question":"def longest_beautiful_subsequence(n: int, b: List[int]) -> int: Determine the length of the longest beautiful subsequence in the given sequence. >>> longest_beautiful_subsequence(5, [1, 5, 9, 13, 17]) 5 >>> longest_beautiful_subsequence(4, [3, 1, 4, 1]) 2 >>> longest_beautiful_subsequence(7, [2, 2, 2, 2, 2, 2, 2]) 7 >>> longest_beautiful_subsequence(1, [5]) 1 >>> longest_beautiful_subsequence(3, [5, 10, 15]) 3 >>> longest_beautiful_subsequence(5, [1000000000, 2000000000, 3000000000, 4000000000, 5000000000]) 5 >>> longest_beautiful_subsequence(2, [1, 3]) 2","solution":"def longest_beautiful_subsequence(n, b): from collections import defaultdict if n == 1: return 1 longest = 1 dp = [defaultdict(int) for _ in range(n)] for i in range(n): for j in range(i): difference = b[i] - b[j] dp[i][difference] = max(dp[i][difference], dp[j][difference] + 1) longest = max(longest, dp[i][difference] + 1) return longest"},{"question":"def count_unique_values_for_queries(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the count of unique values in the subsegment of the array for each query. :param n: int - Length of the array :param q: int - Number of queries :param a: List[int] - The array of elements :param queries: List[Tuple[int, int]] - Each tuple contains (l, r) representing the indices of the subsegment :return: List[int] - Results for each query results = [] for l, r in queries: subsegment = a[l-1:r] unique_values = set(subsegment) results.append(len(unique_values)) return results","solution":"def count_unique_values_for_queries(n, q, a, queries): Returns the list of results for each query. Each result is the number of unique values in the subsegment of the array. :param n: int - Length of the array :param q: int - Number of queries :param a: list of int - The array of elements :param queries: list of tuples - Each tuple contains (l, r) representing the indices of the subsegment :return: list of int - Results for each query results = [] for l, r in queries: subsegment = a[l-1:r] unique_values = set(subsegment) results.append(len(unique_values)) return results"},{"question":"def can_arrange_herbs(N, herbs) -> str: Determines if it's possible to arrange herbs such that no two adjacent herbs have the same height. Parameters: N (int): The number of herbs. herbs (list[int]): A list of integers representing the heights of the herbs. Returns: str: \\"Yes\\" if it's possible to arrange the herbs as required, \\"No\\" otherwise. # Your code here pass # Example test cases def test_example_1(): assert can_arrange_herbs(3, [1, 2, 3]) == \\"Yes\\" def test_example_2(): assert can_arrange_herbs(5, [1, 1, 2, 2, 3]) == \\"No\\" def test_example_3(): assert can_arrange_herbs(1, [42]) == \\"Yes\\" def test_single_herb(): assert can_arrange_herbs(1, [1000000000]) == \\"Yes\\" def test_two_same_herbs(): assert can_arrange_herbs(2, [1, 1]) == \\"No\\" def test_large_unique_herbs(): assert can_arrange_herbs(5, [1, 2, 3, 4, 5]) == \\"Yes\\" def test_large_non_unique_herbs(): assert can_arrange_herbs(6, [1, 3, 3, 2, 4, 2]) == \\"No\\"","solution":"def can_arrange_herbs(N, herbs): Determines if it's possible to arrange herbs such that no two adjacent herbs have the same height. Parameters: N (int): The number of herbs. herbs (list[int]): A list of integers representing the heights of the herbs. Returns: str: \\"Yes\\" if it's possible to arrange the herbs as required, \\"No\\" otherwise. # A set to track the heights we've seen. seen = set() for height in herbs: if height in seen: return \\"No\\" seen.add(height) return \\"Yes\\" # Example usage: # N = 3 # herbs = [1, 2, 3] # print(can_arrange_herbs(N, herbs)) # Output: \\"Yes\\""},{"question":"def fluffalo_states(p: int, n: int, k: int, transitions: List[Tuple[int, int, int, int]]) -> List[int]: Determine the number of distinct states each Fluffalo can transition to. Args: p (int): The number of possible transitions. n (int): The number of different Fluffalo types. k (int): The maximum number of herbs. transitions (List[Tuple[int, int, int, int]]): Each tuple represents a transition rule. Returns: List[int]: A list with an integer indicating the number of distinct states (including state 0) for each Fluffalo. Examples: >>> fluffalo_states( ... 6, 3, 2, ... [ ... (1, 0, 1, 1), ... (1, 1, 1, 2), ... (2, 0, 1, 1), ... (2, 1, 1, 2), ... (2, 2, 1, 2), ... (3, 0, 1, 0), ... ] ... ) [3, 3, 1]","solution":"from collections import defaultdict, deque def fluffalo_states(p, n, k, transitions): Determine the number of distinct states each Fluffalo can transition to. # Create a table to store transitions for each Fluffalo and state. transition_dict = defaultdict(lambda: defaultdict(list)) for fi, si, t, si_prime in transitions: transition_dict[fi][si].append((t, si_prime)) # Resultant list to store the number of states for each Fluffalo. Initialize with 1 to account for the initial state 0. result = [1] * n for fi in range(1, n+1): # A set to store distinct states each Fluffalo can transition to. states_set = set([0]) # A queue to perform BFS. queue = deque([(0, 0)]) # (current_state, herb_count) while queue: current_state, current_herbs = queue.popleft() if current_herbs < k: for t, new_state in transition_dict[fi][current_state]: if current_herbs + t <= k and new_state not in states_set: states_set.add(new_state) queue.append((new_state, current_herbs + t)) result[fi-1] = len(states_set) return result"},{"question":"def tallest_building(heights: list) -> int: Find the position of the tallest building in the list. >>> tallest_building([150, 450, 230, 450, 300]) # returns 1 >>> tallest_building([50, 100, 70, 100, 80, 100]) # returns 1 >>> tallest_building([1, 2, 3, 4, 5]) # returns 4 >>> tallest_building([100, 200, 50, 300, 250]) # returns 3 >>> tallest_building([300, 100, 200, 300, 250]) # returns 0","solution":"def tallest_building(heights): Finds the position of the tallest building in the list. Parameters: heights (list): A list of integers representing the heights of the buildings. Returns: int: The 0-based index of the tallest building. max_height = max(heights) return heights.index(max_height)"},{"question":"import math from typing import List def circular_permutations(N: int) -> int: Returns the number of unique circular permutations possible with N distinct items. >>> circular_permutations(1) == 1 >>> circular_permutations(2) == 1 >>> circular_permutations(3) == 2 >>> circular_permutations(4) == 6 >>> circular_permutations(5) == 24 >>> circular_permutations(10) == 362880 >>> circular_permutations(20) == 121645100408832000","solution":"import math def circular_permutations(N): Returns the number of unique circular permutations possible with N distinct items. if N <= 1: return 1 return math.factorial(N - 1)"},{"question":"def find_highest_priced_pastries(n: int, prices: List[int], queries: List[Tuple[int, int]]) -> List[int]: Find the highest priced pastry within a given range of pastries (inclusive) for each query. Args: n : int : number of different types of pastries for the day prices : List[int] : the prices of the pastries listed in ascending order of their index queries : List[Tuple[int, int]] : a list of tuples, each containing two integers, l and r, representing the inclusive range of indices Returns: List[int] : a list of integers representing the price of the most expensive pastry within the given range for each query Example: >>> find_highest_priced_pastries(6, [3, 1, 4, 1, 5, 9], [(1, 3), (2, 5), (4, 6)]) [4, 5, 9] >>> find_highest_priced_pastries(5, [10, 20, 30, 40, 50], [(1, 5), (3, 4), (2, 5)]) [50, 40, 50]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self._build(data) def _build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, l, r): l += self.n # shift index to leaf r += self.n # shift index to leaf result = 0 while l < r: if l % 2: result = max(result, self.tree[l]) l += 1 if r % 2: r -= 1 result = max(result, self.tree[r]) l //= 2 r //= 2 return result def find_highest_priced_pastries(n, prices, queries): segment_tree = SegmentTree(prices) results = [] for l, r in queries: # Shift l and r to zero-based index l -= 1 results.append(segment_tree.query(l, r)) return results"},{"question":"def find_pair_sum(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: For each test case, determine whether there exists a pair of distinct elements that add up to the target sum X. Args: T : int : Number of test cases test_cases : List[Tuple[int, int, List[int]]] : List of test cases where each test case contains: - N: Size of the array - X: Target sum - array: List of integers representing the array elements Returns: List[str] : List containing \\"YES\\" or \\"NO\\" for each test case indicating if a pair exists that sums to X >>> find_pair_sum(3, [(5, 9, [1, 2, 3, 4, 5]), (4, 8, [2, 3, 5, 7]), (3, 10, [1, 2, 4])]) ['YES', 'YES', 'NO'] >>> find_pair_sum(1, [(2, 1, [0, 1])]) ['YES'] >>> find_pair_sum(1, [(3, -3, [-1, -2, -3])]) ['YES'] >>> find_pair_sum(1, [(3, 4, [1, 1, 1])]) ['NO'] >>> find_pair_sum(1, [(4, 0, [-1, 1, 0, 2])]) ['YES'] # Your implementation here def process_input(input_string: str) -> List[str]: Parses the input string and calls \`find_pair_sum\` function to get the results Args: input_string : str : Multi-line string containing the number of test cases, and each test case with N, X, and array elements Returns: List[str] : Results from \`find_pair_sum\` function # Your implementation here def test_find_pair_sum(): # Test case 1 input_data = \\"3n5 9n1 2 3 4 5n4 8n2 3 5 7n3 10n1 2 4\\" expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_input(input_data) == expected_output # Test case 2: Edge case with minimum values input_data = \\"1n2 1n0 1\\" expected_output = [\\"YES\\"] assert process_input(input_data) == expected_output # Test case 3: Edge case with negative values input_data = \\"1n3 -3n-1 -2 -3\\" expected_output = [\\"YES\\"] assert process_input(input_data) == expected_output # Test case 4: Case with no pairs summing to X input_data = \\"1n3 4n1 1 1\\" expected_output = [\\"NO\\"] assert process_input(input_data) == expected_output # Test case 5: Case where summing to X includes zero input_data = \\"1n4 0n-1 1 0 2\\" expected_output = [\\"YES\\"] assert process_input(input_data) == expected output","solution":"def find_pair_sum(T, test_cases): results = [] for case in test_cases: N, X, array = case seen = set() found = False for num in array: if X - num in seen: results.append(\\"YES\\") found = True break seen.add(num) if not found: results.append(\\"NO\\") return results # Function to parse input and call the matching function def process_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N, X = map(int, lines[idx].split()) array = list(map(int, lines[idx + 1].split())) test_cases.append((N, X, array)) idx += 2 return find_pair_sum(T, test_cases)"},{"question":"def transformGrid(n: int, m: int, k: int, grid: List[List[int]]) -> List[List[int]]: Transforms the grid by multiplying each element by k and removing rows and columns that consist entirely of zeros. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): The multiplier. grid (List[List[int]]): The 2-dimensional list of integers representing the grid. Returns: List[List[int]]: The transformed grid with rows and columns consisting entirely of zeros removed. >>> transformGrid(3, 4, 2, [[1, 0, 3, -2], [4, -2, 0, 0], [0, 0, 0, 0]]) [[2, 0, 6, -4], [8, -4, 0, 0]] >>> transformGrid(2, 2, 0, [[1, 2], [3, 4]]) []","solution":"def transformGrid(n, m, k, grid): # Multiply each element by k transformed_grid = [[grid[i][j] * k for j in range(m)] for i in range(n)] # Remove rows that consist entirely of zeros non_zero_rows = [row for row in transformed_grid if any(cell != 0 for cell in row)] # Transposing the grid to remove columns consisting entirely of zeros if not non_zero_rows: return [] transposed_grid = list(map(list, zip(*non_zero_rows))) # Remove columns that consist entirely of zeros non_zero_columns = [col for col in transposed_grid if any(cell != 0 for cell in col)] # Transpose back to original orientation final_grid = list(map(list, zip(*non_zero_columns))) return final_grid"},{"question":"def sumOfDigits(n): Returns the sum of the individual digits of the integer n. If n is not an integer, returns None. >>> sumOfDigits(123) == 6 >>> sumOfDigits(-123) == 6 >>> sumOfDigits(7) == 7 >>> sumOfDigits(-5) == 5 >>> sumOfDigits(0) == 0 >>> sumOfDigits(\\"123\\") == None >>> sumOfDigits(123.45) == None >>> sumOfDigits([1, 2, 3]) == None >>> sumOfDigits(None) == None","solution":"def sumOfDigits(n): Returns the sum of the individual digits of the integer n. If n is not an integer, returns None. if not isinstance(n, int): return None # Make n positive for simplicity n = abs(n) # Calculate the sum of digits sum_digits = 0 while n > 0: sum_digits += n % 10 n //= 10 return sum_digits"},{"question":"def remove_element(nums, val): Removes all instances of val in nums in-place and returns the new length. Args: nums : List[int] - List of integers. val : int - Integer to be removed from nums. Returns: int - The new length of nums after removal of val. Examples: >>> nums = [3, 2, 2, 3] >>> val = 3 >>> new_length = remove_element(nums, val) >>> assert new_length == 2 >>> assert nums[:new_length] == [2, 2] >>> nums = [0, 1, 2, 2, 3, 0, 4, 2] >>> val = 2 >>> new_length = remove_element(nums, val) >>> assert new_length == 5 >>> assert sorted(nums[:new_length]) == sorted([0, 1, 3, 0, 4])","solution":"def remove_element(nums, val): Removes all instances of val in nums in-place and returns the new length. Args: nums : List[int] - List of integers. val : int - Integer to be removed from nums. Returns: int - The new length of nums after removal of val. k = 0 # pointer for the location of the next non-val element for i in range(len(nums)): if nums[i] != val: nums[k] = nums[i] k += 1 return k"},{"question":"def compress(string: str) -> str: Compresses the input string by replacing contiguous sequences of the same character with the character followed by the count of repetition. >>> compress(\\"AAABBBCCAAA\\") 'A3B3C2A3' >>> compress(\\"AB\\") 'A1B1' >>> compress(\\"AABBCC\\") 'A2B2C2' # Your code here pass def decompress(string: str) -> str: Decompresses the input string from its compressed format back to its original string. >>> decompress(\\"A3B3C2A3\\") 'AAABBBCCAAA' >>> decompress(\\"A1B1\\") 'AB' >>> decompress(\\"A2B2C2\\") 'AABBCC' # Your code here pass","solution":"def compress(string: str) -> str: if not string: return \\"\\" compressed = [] count = 1 for i in range(1, len(string)): if string[i] == string[i - 1]: count += 1 else: compressed.append(f\\"{string[i - 1]}{count}\\") count = 1 compressed.append(f\\"{string[-1]}{count}\\") return ''.join(compressed) def decompress(string: str) -> str: decompressed = [] i = 0 while i < len(string): char = string[i] i += 1 count = 0 while i < len(string) and string[i].isdigit(): count = count * 10 + int(string[i]) i += 1 decompressed.append(char * count) return ''.join(decompressed)"},{"question":"def can_transform_length(s: str, k: int) -> str: Determine if the string s can be transformed to length k by duplicating characters. Parameters: s (str): The original string. k (int): The desired length after transformations. Returns: str: 'YES' if the transformation is possible, otherwise 'NO'. >>> can_transform_length(\\"abc\\", 7) 'YES' >>> can_transform_length(\\"hello\\", 5) 'YES' >>> can_transform_length(\\"world\\", 10) 'YES' >>> can_transform_length(\\"code\\", 3) 'NO' def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases to determine if each string can be transformed to the desired length. Parameters: test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string and an integer. Returns: List[str]: A list containing 'YES' or 'NO' for each test case. def test_example_cases(): test_cases = [ (\\"abc\\", 7), (\\"hello\\", 5), (\\"world\\", 10), (\\"code\\", 3) ] expected_results = [ \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\" ] assert process_test_cases(test_cases) == expected_results def test_minimal_case(): assert process_test_cases([(\\"a\\", 1)]) == [\\"YES\\"] def test_less_than_current_length(): assert process_test_cases([(\\"hello\\", 3)]) == [\\"NO\\"] def test_same_length(): assert process_test_cases([(\\"data\\", 4)]) == [\\"YES\\"] def test_more_than_current_length(): assert process_test_cases([(\\"algorithm\\", 15)]) == [\\"YES\\"] def test_edge_case_max_length(): long_string = \\"x\\" * 50 assert process_test_cases([(long_string, 1000)]) == [\\"YES\\"]","solution":"def can_transform_length(s, k): Return 'YES' if string s can be transformed to length k by duplicating characters, otherwise return 'NO'. current_length = len(s) if current_length > k: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for s, k in test_cases: results.append(can_transform_length(s, k)) return results"},{"question":"def is_strict_sequence(arr: List[int]) -> bool: Determines if the elements in the list form a strictly increasing or strictly decreasing sequence. >>> is_strict_sequence([1, 2, 3, 4]) == True >>> is_strict_sequence([4, 3, 2, 1]) == True >>> is_strict_sequence([1, 2, 2, 3]) == False >>> is_strict_sequence([3, 2, 3, 2]) == False >>> is_strict_sequence([1]) == True >>> is_strict_sequence([]) == True","solution":"def is_strict_sequence(arr): Determines if the elements in the list form a strictly increasing or strictly decreasing sequence. Parameters: arr (list): A non-empty list of integers Returns: bool: True if the elements form a strictly increasing or strictly decreasing sequence, False otherwise if len(arr) <= 1: return True # Single element or no element is trivially true as they can't show inconsistency increasing = all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) decreasing = all(arr[i] > arr[i + 1] for i in range(len(arr) - 1)) return increasing or decreasing"},{"question":"from typing import List def minimize_max_difference(N: int, difficulties: List[int]) -> int: Elena is participating in a sports tournament with N obstacle courses. Your task is to find the minimal possible maximum difference in difficulty between any two consecutive courses after reordering the courses. Args: N: an integer representing the number of obstacle courses. difficulties: a list of integers representing the difficulty levels of the courses. Returns: The minimal possible maximum difference. Example: >>> minimize_max_difference(5, [4, 2, 9, 7, 5]) 2 >>> minimize_max_difference(2, [1, 1000000]) 999999 def test_minimize_max_difference(): assert minimize_max_difference(5, [4, 2, 9, 7, 5]) == 2 assert minimize_max_difference(2, [1, 1000000]) == 999999 assert minimize_max_difference(4, [7, 7, 7, 7]) == 0 assert minimize_max_difference(5, [1, 3, 5, 7, 9]) == 2 assert minimize_max_difference(6, [100, 200, 300, 400, 500, 600]) == 100 assert minimize_max_difference(7, [10, 30, 50, 20, 40, 60, 70]) == 10","solution":"def minimize_max_difference(N, difficulties): Returns the minimized maximum difference between the difficulties of consecutive courses. # Sort the courses based on difficulty difficulties.sort() # The minimal possible maximum difference is the maximum difference # found in the sorted list of difficulties between consecutive elements min_max_diff = float('inf') for i in range(1, N): min_max_diff = min(min_max_diff, difficulties[i] - difficulties[i - 1]) return min_max_diff # Example usage N = 5 difficulties = [4, 2, 9, 7, 5] print(minimize_max_difference(N, difficulties)) # Outputs 1"},{"question":"from typing import List def find_unsorted_subarray_length(arr: List[int]) -> int: Given an array of integers, find the length of the shortest contiguous subarray, which when sorted, results in the entire array being sorted. If the array is already sorted, return 0. >>> find_unsorted_subarray_length([2, 6, 4, 8, 10, 9, 15]) 5 >>> find_unsorted_subarray_length([1, 2, 3, 4, 5]) 0 >>> find_unsorted_subarray_length([1, 1, 1, 1, 1]) 0 >>> find_unsorted_subarray_length([5, 4, 3, 2, 1]) 5 >>> find_unsorted_subarray_length([3, 2, 1, 4, 5, 6]) 3 >>> find_unsorted_subarray_length([1, 2, 3, 4, 6, 5]) 2 >>> find_unsorted_subarray_length([1]) 0 >>> find_unsorted_subarray_length([2, 1]) 2","solution":"def find_unsorted_subarray_length(arr): n = len(arr) if n <= 1: return 0 left, right = 0, n - 1 # Find the first element from the left which is out of order while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # If the array is fully sorted if left == n - 1: return 0 # Find the first element from the right which is out of order while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Find the minimum and maximum values in the unsorted subarray subarray_max = max(arr[left:right + 1]) subarray_min = min(arr[left:right + 1]) # Expand the subarray to include any numbers which are out of place while left > 0 and arr[left - 1] > subarray_min: left -= 1 while right < n - 1 and arr[right + 1] < subarray_max: right += 1 return right - left + 1"},{"question":"def process_queries(t: int, queries: List[int]) -> List[str]: Determines if within 50 moves, Limak can hold any card with a prime number. Args: t: An integer representing the number of test cases. queries: A list of integers representing the initial values of cards for each test case. Returns: A list of \\"yes\\" or \\"no\\" for each test case. Example: >>> process_queries(3, [10, 15, 4]) ['yes', 'yes', 'yes'] >>> process_queries(1, [1]) ['yes'] # Define your helper functions here, if needed","solution":"def is_prime(n): Function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def can_hold_prime(n): Function to determine if a prime number can be held within 50 moves. max_moves = 50 queue = [(n, 0)] visited = set() while queue: current_value, moves = queue.pop(0) if moves > max_moves: continue if is_prime(current_value): return \\"yes\\" visited.add(current_value) # Trying all possible increasing moves for k in range(1, 11): new_value = current_value + k if new_value not in visited: queue.append((new_value, moves + 1)) # Trying doubling the card value new_value = current_value * 2 if new_value not in visited: queue.append((new_value, moves + 1)) return \\"no\\" def process_queries(t, queries): results = [] for n in queries: results.append(can_hold_prime(n)) return results"},{"question":"from typing import List def max_distinct_fruits(N: int, K: int, weights: List[int]) -> int: Determine the maximum possible number of distinct fruits that can be obtained by combining the given fruits following the specific factor K. >>> max_distinct_fruits(5, 2, [1, 2, 4, 8, 16]) 5 >>> max_distinct_fruits(6, 3, [1, 3, 9, 27, 81, 243]) 6 >>> max_distinct_fruits(5, 10, [1, 2, 3, 4, 5]) 5 >>> max_distinct_fruits(5, 2, [10, 10, 10, 10, 10]) 1 >>> max_distinct_fruits(7, 1000, [1, 2000, 3000000, 4000000000, 5000000000000, 6000000000000000, 7000000000000000000]) 7 >>> max_distinct_fruits(10, 3, [1, 3, 9, 27, 2, 6, 18, 54, 162, 486]) 10","solution":"def max_distinct_fruits(N, K, weights): # Convert weights list to a set to eliminate duplicates and enable efficient lookups weights_set = set(weights) distinct_fruits = set(weights) for weight in weights: multiplier = weight * K while multiplier in weights_set: distinct_fruits.add(multiplier) multiplier *= K return len(distinct_fruits)"},{"question":"def count_subarrays_with_sum(arr, X): Returns the number of contiguous subarrays that sum up to a given integer X. Parameters: arr (list): List of integers X (int): The target sum Returns: int: Number of contiguous subarrays that sum up to X >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([1, 2, 3], 3) 2 >>> count_subarrays_with_sum([1, 2, 3], 10) 0 >>> count_subarrays_with_sum([-1, -1, -1], -2) 2 >>> count_subarrays_with_sum([1, -1, 1, -1], 0) 4 >>> count_subarrays_with_sum([2], 2) 1 >>> count_subarrays_with_sum([-2], -2) 1 >>> count_subarrays_with_sum([1] * 100000, 2) 99999","solution":"def count_subarrays_with_sum(arr, X): Returns the number of contiguous subarrays that sum up to a given integer X. Parameters: arr (list): List of integers X (int): The target sum Returns: int: Number of contiguous subarrays that sum up to X count = 0 current_sum = 0 prefix_sum_count = {0: 1} for num in arr: current_sum += num if current_sum - X in prefix_sum_count: count += prefix_sum_count[current_sum - X] prefix_sum_count[current_sum] = prefix_sum_count.get(current_sum, 0) + 1 return count"},{"question":"def max_minerals_extracted(N: int, M: int, grid: List[List[int]]) -> int: Determines the maximum amount of minerals that can be extracted by choosing either one block, one row, or one column. Args: N : int : number of rows M : int : number of columns grid : list of list of int : 2D grid of minerals in each block Returns: int : maximum amount of minerals that can be extracted >>> max_minerals_extracted(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 24 >>> max_minerals_extracted(2, 3, [ ... [10, 20, 30], ... [50, 60, 70] ... ]) 180","solution":"def max_minerals_extracted(N, M, grid): Determines the maximum amount of minerals that can be extracted by choosing either one block, one row, or one column. Args: N : int : number of rows M : int : number of columns grid : list of list of int : 2D grid of minerals in each block Returns: int : maximum amount of minerals that can be extracted max_single_block = max(max(row) for row in grid) max_row_sum = max(sum(row) for row in grid) max_column_sum = max(sum(grid[row][col] for row in range(N)) for col in range(M)) return max(max_single_block, max_row_sum, max_column_sum)"},{"question":"def isSumPrime(N: int) -> bool: Determine whether the sum of the digits of N is a prime number. >>> isSumPrime(47) True >>> isSumPrime(123) False","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def isSumPrime(N): Function to determine whether the sum of the digits of N is a prime number. # Calculate sum of digits digit_sum = sum(int(digit) for digit in str(N)) # Check if the sum is a prime number return is_prime(digit_sum)"},{"question":"def lengthOfLongestSubstring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> lengthOfLongestSubstring(\\"abcabcbb\\") 3 >>> lengthOfLongestSubstring(\\"bbbbb\\") 1 >>> lengthOfLongestSubstring(\\"pwwkew\\") 3","solution":"def lengthOfLongestSubstring(s): Returns the length of the longest substring with all distinct characters. char_index_map = {} longest = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"def increasing_triplet(nums: List[int]) -> bool: Given an array of integers, return true if there exists a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exist, return false. >>> increasing_triplet([1, 2, 3, 4, 5]) True >>> increasing_triplet([5, 4, 3, 2, 1]) False >>> increasing_triplet([2, 1, 5, 0, 4, 6]) True","solution":"def increasing_triplet(nums): Returns true if there exists a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k], otherwise false. first = second = float('inf') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"def filter_products(products, selected_attributes): Returns the list of product IDs that have all the selected attributes. :param products: List of products, each product is a dictionary with keys \\"id\\" and \\"attributes\\". :param selected_attributes: List of strings representing the selected attributes to filter by. :return: List of integers representing product IDs that meet the filtering criteria. >>> products = [ ... {\\"id\\": 1, \\"attributes\\": [\\"red\\", \\"large\\", \\"cotton\\"]}, ... {\\"id\\": 2, \\"attributes\\": [\\"blue\\", \\"small\\", \\"silk\\"]}, ... {\\"id\\": 3, \\"attributes\\": [\\"red\\", \\"small\\", \\"cotton\\"]} ... ] >>> selected_attributes = [\\"red\\", \\"cotton\\"] >>> filter_products(products, selected_attributes) [1, 3] >>> selected_attributes = [\\"small\\", \\"silk\\"] >>> filter_products(products, selected_attributes) [2] >>> selected_attributes = [\\"green\\"] >>> filter_products(products, selected_attributes) [] >>> selected_attributes = [] >>> filter_products(products, selected_attributes) [1, 2, 3] >>> products = [ ... {\\"id\\": 1, \\"attributes\\": [\\"red\\", \\"large\\", \\"cotton\\", \\"soft\\"]}, ... {\\"id\\": 2, \\"attributes\\": [\\"blue\\", \\"small\\", \\"silk\\", \\"soft\\"]}, ... {\\"id\\": 3, \\"attributes\\": [\\"red\\", \\"small\\", \\"cotton\\", \\"soft\\"]} ... ] >>> selected_attributes = [\\"soft\\"] >>> filter_products(products, selected_attributes) [1, 2, 3]","solution":"def filter_products(products, selected_attributes): Returns the list of product IDs that have all the selected attributes. :param products: List of products, each product is a dictionary with keys \\"id\\" and \\"attributes\\". :param selected_attributes: List of strings representing the selected attributes to filter by. :return: List of integers representing product IDs that meet the filtering criteria. filtered_product_ids = [] for product in products: if all(attribute in product[\\"attributes\\"] for attribute in selected_attributes): filtered_product_ids.append(product[\\"id\\"]) return filtered_product_ids"},{"question":"def max_non_overlapping_events(events: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping events that can be scheduled. Args: events (List of tuples): A list of tuples where each tuple contains the start and end times of an event. Returns: int: The maximum number of non-overlapping events that can be scheduled. Examples: >>> max_non_overlapping_events([(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_events([(1, 3), (2, 4), (3, 5), (4, 6)]) 2 >>> max_non_overlapping_events([(5, 10), (1, 2), (7, 8), (3, 4), (2, 3)]) 4","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be scheduled. Args: events (List of tuples): A list of tuples where each tuple contains the start and end times of an event. Returns: int: The maximum number of non-overlapping events that can be scheduled. if not events: return 0 # Sort events by their end times events.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in events: if start >= end_time: count += 1 end_time = end return count"},{"question":"def min_groups(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of groups that can be formed. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers N and K — the number of employees and the group size respectively. Returns: List[int]: A list of integers where each integer represents the minimum number of groups that can be formed for the corresponding test case. >>> min_groups(3, [(8, 3), (10, 1), (7, 5)]) [2, 10, 1] >>> min_groups(4, [(15, 4), (20, 5), (100, 10), (23, 7)]) [3, 4, 10, 3]","solution":"def min_groups(T, test_cases): results = [] for N, K in test_cases: results.append(N // K) return results"},{"question":"def assign_seats(n: int, m: int, preferences: List[List[int]]) -> int: Assign seats to guests such that the sum of the preference indices is minimized. :param n: Number of guests :param m: Number of seats :param preferences: List of lists where preferences[i][j] is the preference score of seat j for guest i :return: Minimum sum of the preference indices pass def test_assign_seats_example1(): n, m = 3, 3 preferences = [ [1, 2, 3], [3, 1, 2], [2, 3, 1] ] assert assign_seats(n, m, preferences) == 3 def test_assign_seats_example2(): n, m = 2, 2 preferences = [ [2, 1], [1, 2] ] assert assign_seats(n, m, preferences) == 2 def test_assign_seats_all_equal(): n, m = 2, 2 preferences = [ [1, 1], [1, 1] ] assert assign_seats(n, m, preferences) == 2 def test_assign_seats_one_guest(): n, m = 1, 3 preferences = [ [2, 1, 3] ] assert assign_seats(n, m, preferences) == 1 def test_assign_seats_several_guests(): n, m = 4, 4 preferences = [ [1, 4, 3, 2], [2, 1, 4, 3], [3, 2, 1, 4], [4, 3, 2, 1] ] assert assign_seats(n, m, preferences) == 4","solution":"import heapq def assign_seats(n, m, preferences): Assign seats to guests such that the sum of the preference indices is minimized. :param n: Number of guests :param m: Number of seats :param preferences: List of lists where preferences[i][j] is the preference score of seat j for guest i :return: Minimum sum of the preference indices seats_taken = [False] * m # Track which seats have been taken guest_preferences = [] # List of (preference score, guest index, seat index) for guest in range(n): for seat in range(m): # Append a tuple of (preference score, guest index, seat index) guest_preferences.append((preferences[guest][seat], guest, seat)) # Sort the list of guest preferences by preference score (lower score comes first) guest_preferences.sort() # Initialize the array to store the seat assigned to each guest (initially None) guest_to_seat = [None] * n seat_count = 0 preference_sum = 0 for score, guest, seat in guest_preferences: # Since seats are limited, we need to ensure each seat is assigned at most once if guest_to_seat[guest] is None and not seats_taken[seat]: guest_to_seat[guest] = seat seats_taken[seat] = True seat_count += 1 preference_sum += score if seat_count == n: break return preference_sum"},{"question":"from typing import List, Tuple def unique_shortest_path(n: int, m: int, roads: List[Tuple[int, int, int]]) -> str: Determine if it's possible to assign travel times to roads so that the shortest path from the warehouse (location 1) to each other location is unique. >>> unique_shortest_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 5), (3, 4, 3), (3, 5, 4)]) \\"YES\\" >>> unique_shortest_path(3, 3, [(1, 2, 1), (1, 3, 1), (2, 3, 2)]) \\"NO\\" pass def test_unique_path_yes(): roads = [ (1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 5), (3, 4, 3), (3, 5, 4) ] assert unique_shortest_path(5, 6, roads) == \\"YES\\" def test_unique_path_no(): roads = [ (1, 2, 1), (1, 3, 1), (2, 3, 2) ] assert unique_shortest_path(3, 3, roads) == \\"NO\\" def test_unique_path_single_road(): roads = [ (1, 2, 5), ] assert unique_shortest_path(2, 1, roads) == \\"YES\\" def test_unique_path_multiple_ways(): roads = [ (1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (3, 4, 1), (1, 5, 4), (4, 5, 2) ] assert unique_shortest_path(5, 7, roads) == \\"YES\\" def test_unique_path_complex_graph(): roads = [ (1, 2, 10), (1, 3, 1), (2, 3, 3), (2, 4, 2), (3, 4, 4), (4, 5, 1), (3, 5, 8) ] assert unique_shortest_path(5, 7, roads) == \\"YES\\" def test_unique_path_no_due_to_duplicate_distances(): roads = [ (1, 2, 3), (1, 3, 3), (2, 4, 4), (3, 4, 4), (2, 5, 3), (3, 5, 5) ] assert unique_shortest_path(5, 6, roads) == \\"NO\\"","solution":"import heapq from collections import defaultdict, deque def unique_shortest_path(n, m, roads): graph = defaultdict(list) for a, b, t in roads: graph[a].append((t, b)) graph[b].append((t, a)) # Dijkstra's algorithm to find the shortest paths from node 1 def dijkstra(source): dist = {node: float(\\"inf\\") for node in range(1, n + 1)} dist[source] = 0 queue = [(0, source)] while queue: cur_dist, u = heapq.heappop(queue) if cur_dist > dist[u]: continue for time, v in graph[u]: new_dist = cur_dist + time if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(queue, (new_dist, v)) return dist # Find shortest paths distance from node 1 shortest_path_from_1 = dijkstra(1) # A set to store seen distances seen_distances = set() for node in range(2, n + 1): distance = shortest_path_from_1[node] if distance in seen_distances: return \\"NO\\" seen_distances.add(distance) return \\"YES\\""},{"question":"def are_anagrams(string_list): Checks if all strings in the given list are anagrams of each other. :param string_list: List of strings :return: True if all strings are anagrams, False otherwise >>> are_anagrams(['listen', 'silent', 'enlist']) True >>> are_anagrams(['apple', 'pale', 'peal']) False >>> are_anagrams(['a gentleman', 'elegant man']) True >>> are_anagrams(['a gentleman', 'elegant Manny']) False >>> are_anagrams(['Listen', 'Silent', 'Enlist']) False >>> are_anagrams(['abc', 'ab', 'a']) False","solution":"def are_anagrams(string_list): Checks if all strings in the given list are anagrams of each other. :param string_list: List of strings :return: True if all strings are anagrams, False otherwise if not string_list: return False def char_count_map(s): return {ch: s.count(ch) for ch in set(s)} # Use the first string as the baseline baseline = char_count_map(string_list[0]) for s in string_list[1:]: if char_count_map(s) != baseline: return False return True"},{"question":"def most_borrowed_book(test_cases): Determine the most borrowed book for multiple test cases. Each test case contains the number of records followed by the titles of the borrowed books. Output the title of the most borrowed book for each test case. If there are ties, return the lexicographically smallest title. Arguments: test_cases -- a list of tuples, where each tuple contains an integer N and a list of N book titles Returns: A list of strings representing the most borrowed book title for each test case. Examples: >>> most_borrowed_book([(5, [\\"Harry Potter and the Philosopher's Stone\\", \\"The Hobbit\\", \\"Harry Potter and the Philosopher's Stone\\", \\"The Lord of the Rings\\", \\"The Hobbit\\"])]) [\\"Harry Potter and the Philosopher's Stone\\"] >>> most_borrowed_book([(4, [\\"To Kill a Mockingbird\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"])]) [\\"To Kill a Mockingbird\\"]","solution":"def most_borrowed_book(test_cases): results = [] for case in test_cases: n, records = case book_count = {} for book in records: if book in book_count: book_count[book] += 1 else: book_count[book] = 1 # Determine the most borrowed book, considering lexicographical order in case of ties most_borrowed = min(book_count.items(), key=lambda x: (-x[1], x[0])) results.append(most_borrowed[0]) return results # Parsing input would be handled outside this function"},{"question":"def min_changes_to_make_unique(t: int, test_cases: List[str]) -> List[int]: Given a number of test cases, calculate the minimum number of character changes needed to make each string unique. Parameters: t (int): Number of test cases. test_cases (list of str): List of strings for each test case. Returns: list of int: List with the minimum number of character changes for each test case. >>> min_changes_to_make_unique(3, ['aabb', 'ab', 'aaaa']) [2, 0, 3] >>> min_changes_to_make_unique(2, ['ab', 'abcde']) [0, 0] >>> min_changes_to_make_unique(2, ['aaaa', 'bbbb']) [3, 3]","solution":"def min_changes_to_make_unique(t, test_cases): Given a number of test cases and corresponding strings, this function calculates the minimum number of changes needed for each string to become unique where no two adjacent characters are the same. Parameters: t (int): Number of test cases. test_cases (list of str): List containing the test case strings. Returns: list of int: List containing the minimum number of required changes for each test case. results = [] for s in test_cases: changes = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: changes += 1 results.append(changes) return results"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the integer n. >>> sum_of_digits(123) 6 >>> sum_of_digits(456) 15 >>> sum_of_digits(789) 24 >>> sum_of_digits(100000) 1 pass def process_queries(queries: List[int]) -> List[int]: Processes a list of queries, where each query is an integer X for which the sum of its digits needs to be computed. Returns a list of results. >>> process_queries([123]) [6] >>> process_queries([123, 456, 789]) [6, 15, 24] >>> process_queries([100000, 99999]) [1, 45] pass","solution":"def sum_of_digits(n): Returns the sum of the digits of the integer n. return sum(int(digit) for digit in str(n)) def process_queries(queries): Processes a list of queries, where each query is an integer X for which the sum of its digits needs to be computed. Returns a list of results. :param queries: List of integers. :return: List of integers, each being the sum of digits of the corresponding query integer. return [sum_of_digits(query) for query in queries]"},{"question":"def consecutive_sessions(timestamps, k): This function takes a list of timestamps and an integer k, and returns an array of the lengths of each consecutive browsing session. Parameters: timestamps (list of int): A list of integers representing the timestamps of the visits. k (int): The maximum allowed gap in minutes between consecutive timestamps for them to be considered part of the same session. Returns: list of int: A list of integers where each integer represents the length of a consecutive browsing session. Examples: >>> consecutive_sessions([1, 3, 4, 10, 12, 13], 5) [3, 3] >>> consecutive_sessions([1, 2, 4, 10, 12, 13], 5) [3, 3]","solution":"def consecutive_sessions(timestamps, k): This function takes a list of timestamps and an integer k, and returns an array of the lengths of each consecutive browsing session. Parameters: timestamps (list of int): A list of integers representing the timestamps of the visits. k (int): The maximum allowed gap in minutes between consecutive timestamps for them to be considered part of the same session. Returns: list of int: A list of integers where each integer represents the length of a consecutive browsing session. n = len(timestamps) if n == 0: return [] session_lengths = [] session_length = 1 for i in range(1, n): if timestamps[i] - timestamps[i - 1] <= k: session_length += 1 else: session_lengths.append(session_length) session_length = 1 session_lengths.append(session_length) return session_lengths"},{"question":"def maxFriends(n: int, times: List[List[int]]) -> int: Determine the maximum number of friends that can be present at the party at the same time. >>> maxFriends(3, [[1, 4], [2, 5], [6, 8]]) 2 >>> maxFriends(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) 1","solution":"def maxFriends(n, times): This function returns the maximum number of friends that can be present at the party at the same time. events = [] # Create a list of events, marking arrivals and departures for arrival, departure in times: events.append((arrival, 1)) # 1 indicates arrival events.append((departure, -1)) # -1 indicates departure # Sort the events first by time, then by type (departure before arrival if same time) events.sort(key=lambda x: (x[0], x[1])) max_friends = 0 current_friends = 0 for event in events: current_friends += event[1] max_friends = max(max_friends, current_friends) return max_friends"},{"question":"def compress_string(S: str) -> str: Compress a given string as per the rules. >>> compress_string(\\"aaabbc\\") \\"a3b2c1\\" >>> compress_string(\\"hello\\") \\"h1e1l2o1\\" >>> compress_string(\\"aabbcc\\") \\"a2b2c2\\" def compress_strings(T: int, strings: List[str]) -> List[str]: Compress each string in the list of test cases. >>> compress_strings(3, [\\"aaabbc\\", \\"hello\\", \\"aabbcc\\"]) [\\"a3b2c1\\", \\"h1e1l2o1\\", \\"a2b2c2\\"] >>> compress_strings(2, [\\"a\\", \\"aa\\"]) [\\"a1\\", \\"a2\\"] >>> compress_strings(1, [\\"abc\\"]) [\\"a1b1c1\\"] >>> compress_strings(0, []) [] from solution import compress_string, compress_strings def test_compress_string(): assert compress_string(\\"aaabbc\\") == \\"a3b2c1\\" assert compress_string(\\"hello\\") == \\"h1e1l2o1\\" assert compress_string(\\"aabbcc\\") == \\"a2b2c2\\" assert compress_string(\\"a\\") == \\"a1\\" assert compress_string(\\"aa\\") == \\"a2\\" assert compress_string(\\"abc\\") == \\"a1b1c1\\" assert compress_string(\\"\\") == \\"\\" def test_compress_strings(): assert compress_strings(3, [\\"aaabbc\\", \\"hello\\", \\"aabbcc\\"]) == [\\"a3b2c1\\", \\"h1e1l2o1\\", \\"a2b2c2\\"] assert compress_strings(2, [\\"a\\", \\"aa\\"]) == [\\"a1\\", \\"a2\\"] assert compress_strings(1, [\\"abc\\"]) == [\\"a1b1c1\\"] assert compress_strings(0, []) == []","solution":"def compress_string(S): Compress a given string as per the rules. if not S: return \\"\\" compressed = [] count = 1 n = len(S) for i in range(1, n): if S[i] == S[i - 1]: count += 1 else: compressed.append(f\\"{S[i-1]}{count}\\") count = 1 compressed.append(f\\"{S[-1]}{count}\\") return ''.join(compressed) def compress_strings(T, strings): Compress each string in the list of test cases. results = [] for S in strings: results.append(compress_string(S)) return results"},{"question":"def assign_dormitories(M, capacities, N, preferences): Assign students to dormitories based on their preferences and dormitory capacities. Parameters: M (int): Number of dormitories capacities (list of int): Capacities of each dormitory N (int): Number of students preferences (list of list of int): List of student preferences for dormitories. Returns: list of int: List of assigned dormitories for each student. >>> assign_dormitories(3, [2, 1, 1], 4, [[1, 2, 3], [2, 1, 3], [3, 1, 2], [3, -1, -1]]) [1, 2, 3, 1] >>> assign_dormitories(3, [2, 1, 1], 2, [[-1, -1, -1], [-1, -1, -1]]) [1, 1] >>> assign_dormitories(2, [1, 1], 3, [[1, 2, -1], [1, 2, -1], [1, 2, -1]]) [1, 2, 1] >>> assign_dormitories(3, [1, 1, 1], 4, [[2, 3, 2], [2, 3, 2], [3, 1, 3], [1, 3, 2]]) [2, 3, 1, 1]","solution":"def assign_dormitories(M, capacities, N, preferences): Assign students to dormitories based on their preferences and dormitory capacities. Parameters: M (int): Number of dormitories capacities (list of int): Capacities of each dormitory N (int): Number of students preferences (list of list of int): List of student preferences for dormitories. Returns: list of int: List of assigned dormitories for each student. assigned_dorms = [] dorm_capacity_left = capacities[:] for pref in preferences: assigned = False for choice in pref: if choice == -1: continue if dorm_capacity_left[choice - 1] > 0: assigned_dorms.append(choice) dorm_capacity_left[choice - 1] -= 1 assigned = True break if not assigned: assigned_dorms.append(1) return assigned_dorms"},{"question":"def is_sorting_possible(test_cases): Given a list of integers, determine if it is possible to sort the list in strictly increasing order by taking turns moving any number from the list to the front. >>> is_sorting_possible([[3, 1, 2], [5, 4, 3, 2, 1], [2, 2, 2, 2], [1, 9, 2, 8, 3, 7]]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> is_sorting_possible([[42]]) [\\"YES\\"] >>> is_sorting_possible([[1, 1, 1, 1]]) [\\"NO\\"] >>> is_sorting_possible([[1, 2, 3, 4, 5]]) [\\"YES\\"] >>> is_sorting_possible([[5, 4, 3, 2]]) [\\"YES\\"] >>> is_sorting_possible([[1000000, -1000000, -999999, 999999]]) [\\"YES\\"] def parse_input(user_input): Parse input string into test cases and determine if each can be sorted. >>> user_input = \\"4n3 1 2n5 4 3 2 1n2 2 2 2n1 9 2 8 3 7\\" >>> parse_input(user_input) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> user_input = \\"1n42\\" >>> parse_input(user_input) [\\"YES\\"] >>> user_input = \\"1n1 1 1 1\\" >>> parse_input(user_input) [\\"NO\\"] >>> user_input = \\"1n1 2 3 4 5\\" >>> parse_input(user_input) [\\"YES\\"] >>> user_input = \\"1n5 4 3 2\\" >>> parse_input(user_input) [\\"YES\\"] >>> user_input = \\"1n1000000 -1000000 -999999 999999\\" >>> parse_input(user_input) [\\"YES\\"]","solution":"def is_sorting_possible(test_cases): results = [] for lst in test_cases: # A list with duplicates cannot be sorted in strictly increasing order if len(lst) != len(set(lst)): results.append(\\"NO\\") continue # If the list and the sorted version of the list is the same, it's possible if lst == sorted(lst): results.append(\\"YES\\") else: results.append(\\"YES\\") return results def parse_input(user_input): lines = user_input.split('n') m = int(lines[0]) test_cases = [] for i in range(1, m + 1): test_cases.append(list(map(int, lines[i].split()))) return is_sorting_possible(test_cases)"},{"question":"def find_pairs(n: int, elements: List[int], target: int) -> List[Tuple[int, int]]: Consider a list of integers. Implement a function that finds all possible pairs of elements in the list where the sum of the pair is equal to a given target number. >>> find_pairs(6, [1, 5, 7, -1, 5, 4], 6) [(-1, 7), (1, 5)] >>> find_pairs(5, [1, 1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs(4, [3, 3, 4, 7], 10) [(3, 7)]","solution":"from typing import List, Tuple def find_pairs(n: int, elements: List[int], target: int) -> List[Tuple[int, int]]: pairs = [] elements.sort() used = set() for i in range(n): if elements[i] in used: continue for j in range(i + 1, n): if elements[j] in used: continue if elements[i] + elements[j] == target: pairs.append((elements[i], elements[j])) used.add(elements[i]) used.add(elements[j]) break return pairs"},{"question":"def minimum_power(T, M, test_cases): Calculate the minimum power that can be obtained by combining pairs of neighboring nodes. :param T: Number of test cases :param M: Modulo value :param test_cases: List of integers where each integer denotes the number of nodes in the tree :return: List of minimum powers for each test case >>> minimum_power(2, 100, [3, 4]) [6, 24] >>> minimum_power(1, 1000000000, [5]) [120] >>> minimum_power(1, 1, [4]) [0]","solution":"def minimum_power(T, M, test_cases): Calculates the minimum power that can be obtained by combining pairs of neighboring nodes. :param T: Number of test cases :param M: Modulo value :param test_cases: List of integers where each integer denotes the number of nodes in the tree :return: List of minimum powers for each test case def factorial_mod(n, m): result = 1 for i in range(1, n + 1): result = (result * i) % m return result results = [] for n in test_cases: results.append(factorial_mod(n, M)) return results"},{"question":"def longest_common_divisor_subsequence(arr: List[int]) -> List[int]: Given a list of integers, find and return the longest subsequence such that all elements of the subsequence are common divisors of the maximum element in the list. Example 1: >>> longest_common_divisor_subsequence([1, 3, 6, 24]) == [1, 3, 6, 24] Example 2: >>> longest_common_divisor_subsequence([1, 2, 4, 5, 10]) == [1, 2, 5, 10] Example 3: >>> longest_common_divisor_subsequence([7]) == [7] Example 4: >>> longest_common_divisor_subsequence([3, 3, 3]) == [3, 3, 3] Example 5: >>> longest_common_divisor_subsequence([1, 2, 4, 8]) == [1, 2, 4, 8] Example 6: >>> longest_common_divisor_subsequence([]) == [] Example 7: >>> longest_common_divisor_subsequence([1, 2, 50, 100]) == [1, 2, 50, 100]","solution":"def longest_common_divisor_subsequence(arr): if not arr: return [] max_element = max(arr) divisors = [] for num in arr: if max_element % num == 0: divisors.append(num) return divisors"},{"question":"def maxSquareTiles(H: int, W: int) -> int: Find the maximum number of equal-sized square tiles that can completely cover the given rectangle of height H and width W. The size of the square tile must be a factor of both the height and the width of the rectangle. >>> maxSquareTiles(6, 9) 6 >>> maxSquareTiles(8, 12) 6 >>> maxSquareTiles(7, 11) 77 >>> maxSquareTiles(1000000000000000000, 500000000000000000) 2 >>> maxSquareTiles(5, 5) 1 >>> maxSquareTiles(10, 2) 5","solution":"def gcd(a, b): Helper function to compute the greatest common divisor (GCD) using the Euclidean algorithm. while b != 0: a, b = b, a % b return a def maxSquareTiles(H, W): Function to find the maximum number of equal-sized square tiles that can completely cover the given rectangle of height H and width W. # Find the largest size of square tile which is the GCD of H and W tile_size = gcd(H, W) # Number of square tiles along the height and width num_tiles_height = H // tile_size num_tiles_width = W // tile_size # Total number of tiles return num_tiles_height * num_tiles_width"},{"question":"def max_visible_sums(n, heights): Determine the maximum possible sum of heights of 1, ..., n visible buildings respectively. Args: n (int): number of buildings heights (List[int]): the heights of the buildings Returns: List[int]: a list of n integers representing the maximum possible sum of heights >>> max_visible_sums(5, [3, 1, 4, 2, 5]) [5, 9, 12, 14, 15] >>> max_visible_sums(1, [10]) [10] >>> max_visible_sums(2, [3, 8]) [8, 11] >>> max_visible_sums(3, [5, 5, 5]) [5, 10, 15] >>> max_visible_sums(4, [1, 3, 2, 4]) [4, 7, 9, 10] >>> max_visible_sums(3, [6, 2, 4]) [6, 10, 12] >>> max_visible_sums(4, [2, 5, 2, 5]) [5, 10, 12, 14] >>> n = 100 >>> heights = list(range(1, 101)) >>> max_visible_sums(n, heights) [sum(range(1, 101)[-i:]) for i in range(1, 101)] pass","solution":"def max_visible_sums(n, heights): Returns the maximum possible sum of heights of 1, ..., n visible buildings respectively. heights_sorted = sorted(heights, reverse=True) results = [] current_sum = 0 for i in range(n): current_sum += heights_sorted[i] results.append(current_sum) return results # Example usage: # n = 5 # heights = [3, 1, 4, 2, 5] # print(max_visible_sums(n, heights)) # Output: [5, 9, 12, 14, 15]"},{"question":"def count_stars(n: int, k: int) -> int: Returns the total number of stars Tina will count. Parameters: n (int): The total number of visible stars. k (int): The counting pattern, Tina counts every k-th star. Returns: int: The total number of stars Tina will count. >>> count_stars(10, 3) 4 >>> count_stars(15, 5) 3 >>> count_stars(7, 2) 4 >>> count_stars(1, 1) 1 >>> count_stars(5, 10) 1 >>> count_stars(6, 6) 1 >>> count_stars(1000000000, 1) 1000000000 >>> count_stars(1000000000, 1000000000) 1","solution":"def count_stars(n: int, k: int) -> int: Returns the total number of stars Tina will count. Parameters: n (int): The total number of visible stars. k (int): The counting pattern, Tina counts every k-th star. Returns: int: The total number of stars Tina will count. return (n + k - 1) // k"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring of s that contains at most k distinct characters. >>> longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_k_distinct(\\"aa\\", 1) 2 >>> longest_substring_k_distinct(\\"abcabcabc\\", 2) 2 >>> longest_substring_k_distinct(\\"\\", 5) 0 >>> longest_substring_k_distinct(\\"a\\", 0) 0","solution":"def longest_substring_k_distinct(s, k): Returns the length of the longest substring of s that contains at most k distinct characters. if k == 0 or not s: return 0 char_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_map: char_map[s[end]] += 1 else: char_map[s[end]] = 1 while len(char_map) > k: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def determine_winner(m, n, k): Determine the winner of the game given the grid dimensions m x n and the target value k. Alex starts first and both play optimally. Parameters: m (int): number of rows n (int): number of columns k (int): target value for a cell Returns: str: the name of the winner (\\"Alex\\" or \\"Bob\\") Examples: >>> determine_winner(2, 3, 3) \\"Alex\\" >>> determine_winner(4, 4, 2) \\"Bob\\" >>> determine_winner(3, 3, 5) \\"Bob\\"","solution":"def determine_winner(m, n, k): Determine the winner of the game given the grid dimensions m x n and the target value k. Alex starts first and both play optimally. # Each cell needs k increments to reach the target # Since Alex starts, he will win if k is odd as he makes the last increment # Otherwise, Bob will win. if k % 2 == 1: return \\"Alex\\" else: return \\"Bob\\""},{"question":"from typing import List, Tuple def count_ways_to_fill_slots(N: int, M: int, song_durations: List[int], slot_durations: List[int]) -> List[int]: Calculate the number of ways to fill each slot's duration using the available songs. Args: N (int): Number of available songs. M (int): Number of time slots. song_durations (List[int]): List of durations of the songs. slot_durations (List[int]): List of durations of the time slots. Returns: List[int]: List of the number of ways to fill each time slot. def solve(T: int, cases: List[Tuple[int, int, List[int], List[int]]]) -> List[List[int]]: Solve the problem for multiple test cases. Args: T (int): Number of test cases. cases (List[Tuple[int, int, List[int], List[int]]]): List of test cases where each test case is a tuple consisting of: N (int): Number of available songs. M (int): Number of time slots. List[int]: List of durations of the songs. List[int]: List of durations of the time slots. Returns: List[List[int]]: List of results where each result is a list of the number of ways to fill each time slot. >>> solve(1, [(4, 2, [30, 40, 20, 10], [50, 60])]) [[2, 2]] >>> solve(1, [(1, 1, [50], [50])]) [[1]] >>> solve(1, [(3, 2, [10, 20, 30], [100, 200])]) [[0, 0]] >>> solve(1, [(4, 3, [10, 20, 30, 40], [50, 60, 100])]) [[2, 2, 1]] >>> solve(2, [(4, 2, [30, 40, 20, 10], [50, 60]), (3, 1, [15, 25, 35], [50])]) [[2, 2], [1]]","solution":"from itertools import combinations def count_ways_to_fill_slots(N, M, song_durations, slot_durations): ways = [] for slot in slot_durations: count = 0 # Check combinations of songs that sum up to the slot duration for r in range(1, N+1): # Length of combinations can vary from 1 to N for combo in combinations(song_durations, r): if sum(combo) == slot: count += 1 ways.append(count) return ways def solve(T, cases): results = [] for i in range(T): N, M, song_durations, slot_durations = cases[i] results.append(count_ways_to_fill_slots(N, M, song_durations, slot_durations)) return results"},{"question":"def min_teams(N: int, capacity: int, skills: List[int]) -> int: Determines the minimum number of teams needed to accommodate all employees under the given capacity constraint. Parameters: - N (int): The number of employees. - capacity (int): The maximum capacity of each team. - skills (List[int]): A list of skill levels of the employees. Returns: - int: The minimum number of teams required. >>> min_teams(5, 10, [6, 3, 5, 8, 2]) 3 >>> min_teams(6, 10, [1, 2, 3, 4, 5, 6]) 3","solution":"def min_teams(N, capacity, skills): Determines the minimum number of teams needed to accommodate all employees under the given capacity constraint. Parameters: N (int): The number of employees. capacity (int): The maximum capacity of each team. skills (list): A list of skill levels of the employees. Returns: int: The minimum number of teams required. skills.sort(reverse=True) teams = 0 i, j = 0, N - 1 while i <= j: if skills[i] + skills[j] <= capacity: j -= 1 i += 1 teams += 1 return teams"},{"question":"def is_prime(n: int) -> bool: Determines if a number is prime. >>> is_prime(2) True >>> is_prime(4) False def filter_primes(arr: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the input list. :param arr: List[int] :return: List[int] >>> filter_primes([4, 6, 7, 9, 10, 13]) [7, 13] >>> filter_primes([15, 25, 31, 37, 41]) [31, 37, 41] from typing import List def test_filter_primes_all_primes(): assert filter_primes([2, 3, 5, 7, 11, 13, 17, 19, 23]) == [2, 3, 5, 7, 11, 13, 17, 19, 23] def test_filter_primes_mixed_numbers(): assert filter_primes([4, 6, 7, 9, 10, 13]) == [7, 13] assert filter_primes([15, 25, 31, 37, 41]) == [31, 37, 41] def test_filter_primes_no_primes(): assert filter_primes([4, 6, 8, 10, 12]) == [] assert filter_primes([1, 16, 18, 20, 21, 24]) == [] def test_filter_primes_with_single_element(): assert filter_primes([7]) == [7] assert filter_primes([9]) == [] def test_filter_primes_empty_list(): assert filter_primes([]) == [] def test_filter_primes_with_one(): assert filter_primes([1, 2, 3, 4, 5]) == [2, 3, 5]","solution":"def is_prime(n): Determines if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False limit = int(n**0.5) + 1 for i in range(3, limit, 2): if n % i == 0: return False return True def filter_primes(arr): Returns a new list containing only the prime numbers from the input list. :param arr: List[int] :return: List[int] return [x for x in arr if is_prime(x)]"},{"question":"def trap_rain_water(heights): Given an array representing the heights of buildings, returns the total units of rainwater that can be trapped between the buildings after it rains. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([3, 0, 2, 0, 4]) 7 >>> trap_rain_water([1, 2, 1, 3, 2, 1, 2, 1]) 4","solution":"def trap_rain_water(heights): Given an array representing the heights of buildings, returns the total units of rainwater that can be trapped between the buildings after it rains. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water # Example usage heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(trap_rain_water(heights)) # Output: 6"},{"question":"def generate_n_grams(S: str, n: int) -> List[str]: Generates n-grams from the given string S. :param S: The input string composed of lowercase English letters. :param n: The length of each n-gram. :return: A list of n-grams in the order they appear in the string S. Examples: >>> generate_n_grams(\\"hello\\", 2) ['he', 'el', 'll', 'lo'] >>> generate_n_grams(\\"abcdef\\", 3) ['abc', 'bcd', 'cde', 'def']","solution":"def generate_n_grams(S, n): Generates n-grams from the given string S. :param S: The input string composed of lowercase English letters. :param n: The length of each n-gram. :return: A list of n-grams in the order they appear in the string S. n_grams = [S[i:i+n] for i in range(len(S) - n + 1)] return n_grams"},{"question":"from typing import List def decrypt_message(encrypted_message: List[int]) -> str: Decrypts a list of integers representing positions in the alphabet into a string of uppercase letters. Args: encrypted_message (List[int]): A list of integers where 1 corresponds to 'A', 2 to 'B', etc. Returns: str: The decrypted message as a string of uppercase letters. Examples: >>> decrypt_message([8, 5, 12, 12, 15]) \\"HELLO\\" >>> decrypt_message([1, 1, 1, 1, 1]) \\"AAAAA\\" >>> decrypt_message([20, 9, 13, 5]) \\"TIME\\"","solution":"from typing import List def decrypt_message(encrypted_message: List[int]) -> str: Decrypts a list of integers representing positions in the alphabet into a string of uppercase letters. Args: encrypted_message (List[int]): A list of integers where 1 corresponds to 'A', 2 to 'B', etc. Returns: str: The decrypted message as a string of uppercase letters. decrypted_message = ''.join(chr(num + 64) for num in encrypted_message) return decrypted_message"},{"question":"def max_height_difference(n: int, heights: List[int]) -> int: Compute the maximum difference in height between any two plants where the second plant in the pair has grown on a day later than the day the first plant has grown. Parameters: - n (int): The number of days - heights (List[int]): A list of integers representing the heights of the plants over the days Returns: - int: The maximum difference in height >>> max_height_difference(6, [3, 1, 4, 1, 5, 9]) 8 >>> max_height_difference(1, [10]) 0","solution":"def max_height_difference(n, heights): Returns the maximum difference in height between any two plants where the second plant has grown on a day later than the day the first plant has grown. if n < 2: return 0 min_height_so_far = heights[0] max_difference = 0 for i in range(1, n): max_difference = max(max_difference, heights[i] - min_height_so_far) min_height_so_far = min(min_height_so_far, heights[i]) return max_difference"},{"question":"def reversal_count(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of contiguous subarray reversals to transform the array into a non-decreasing array. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where the first element is the size of the array and the second element is the array itself. Returns: List[int]: A list of integers representing the reversal count for each test case. >>> reversal_count(2, [(6, [3, 2, 1, 5, 4, 6]), (5, [1, 2, 3, 4, 5])]) [2, 0] >>> reversal_count(1, [(4, [1, 2, 3, 4])]) [0]","solution":"def reversal_count(t, test_cases): Calculate the minimum number of contiguous subarray reversals to transform the array into a non-decreasing array. result = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] # Edge case: array with one element requires 0 reversals if n == 1: result.append(0) continue # Initialize count of reversals needed to zero reversals = 0 # Iterate through the array and count the number of \\"descent regions\\" i = 0 while i < n - 1: if a[i] > a[i + 1]: # If a descent is found, increment the reversal count reversals += 1 # Skip over the entire descent sequence while i < n - 1 and a[i] > a[i + 1]: i += 1 i += 1 result.append(reversals) return result"},{"question":"def count_distinct_blends(n: int, blend_list: List[str]) -> int: Returns the count of distinct blends given the predefined blends' descriptions. >>> count_distinct_blends(5, [\\"1 2 3\\", \\"2 3 4\\", \\"3 4\\", \\"4\\", \\"5 1 4\\"]) 5 >>> count_distinct_blends(3, [\\"0\\", \\"1 0 2\\", \\"2\\"]) 3 pass # Unit tests def test_example1(): n = 5 blend_list = [ \\"1 2 3\\", \\"2 3 4\\", \\"3 4\\", \\"4\\", \\"5 1 4\\" ] assert count_distinct_blends(n, blend_list) == 5 def test_example2(): n = 3 blend_list = [ \\"0\\", \\"1 0 2\\", \\"2\\" ] assert count_distinct_blends(n, blend_list) == 3 def test_single_blend(): n = 1 blend_list = [\\"0\\"] assert count_distinct_blends(n, blend_list) == 1 def test_disjoint_blends(): n = 4 blend_list = [ \\"0\\", \\"1\\", \\"2\\", \\"3\\" ] assert count_distinct_blends(n, blend_list) == 4 def test_complex_blend(): n = 6 blend_list = [ \\"10 20 30\\", \\"20 30 40\\", \\"30 40 50\\", \\"40 50\\", \\"50\\", \\"60 10 40\\" ] assert count_distinct_blends(n, blend_list) == 6","solution":"def count_distinct_blends(n, blend_list): Returns the count of distinct blends given the predefined blends' descriptions. # Use a set to keep track of all unique blends unique_blends = set() # Process each blend from the blend_list for blend_str in blend_list: blend_components = list(map(int, blend_str.split())) blend_id = blend_components[0] unique_blends.add(blend_id) return len(unique_blends)"},{"question":"def run_digital_clock(start_time: str, t: int) -> list: Runs a digital clock for \`t\` seconds starting from \`start_time\`. Parameters: - start_time (str): The initial time in \\"hh:mm:ss\\" format. - t (int): The number of seconds the clock should run. Returns: - List of strings with each time displayed in \\"hh:mm:ss\\" format for each second. >>> run_digital_clock(\\"23:59:55\\", 10) [ \\"23:59:55\\", \\"23:59:56\\", \\"23:59:57\\", \\"23:59:58\\", \\"23:59:59\\", \\"00:00:00\\", \\"00:00:01\\", \\"00:00:02\\", \\"00:00:03\\", \\"00:00:04\\", \\"00:00:05\\" ] >>> run_digital_clock(\\"12:00:00\\", 5) [\\"12:00:00\\", \\"12:00:01\\", \\"12:00:02\\", \\"12:00:03\\", \\"12:00:04\\", \\"12:00:05\\"] >>> run_digital_clock(\\"23:59:00\\", 60) [ \\"23:59:00\\", \\"23:59:01\\", \\"23:59:02\\", \\"23:59:03\\", \\"23:59:04\\", \\"23:59:05\\", \\"23:59:06\\", \\"23:59:07\\", \\"23:59:08\\", \\"23:59:09\\", \\"23:59:10\\", \\"23:59:11\\", \\"23:59:12\\", \\"23:59:13\\", \\"23:59:14\\", \\"23:59:15\\", \\"23:59:16\\", \\"23:59:17\\", \\"23:59:18\\", \\"23:59:19\\", \\"23:59:20\\", \\"23:59:21\\", \\"23:59:22\\", \\"23:59:23\\", \\"23:59:24\\", \\"23:59:25\\", \\"23:59:26\\", \\"23:59:27\\", \\"23:59:28\\", \\"23:59:29\\", \\"23:59:30\\", \\"23:59:31\\", \\"23:59:32\\", \\"23:59:33\\", \\"23:59:34\\", \\"23:59:35\\", \\"23:59:36\\", \\"23:59:37\\", \\"23:59:38\\", \\"23:59:39\\", \\"23:59:40\\", \\"23:59:41\\", \\"23:59:42\\", \\"23:59:43\\", \\"23:59:44\\", \\"23:59:45\\", \\"23:59:46\\", \\"23:59:47\\", \\"23:59:48\\", \\"23:59:49\\", \\"23:59:50\\", \\"23:59:51\\", \\"23:59:52\\", \\"23:59:53\\", \\"23:59:54\\", \\"23:59:55\\", \\"23:59:56\\", \\"23:59:57\\", \\"23:59:58\\", \\"23:59:59\\", \\"00:00:00\\" ] >>> run_digital_clock(\\"00:00:58\\", 4) [\\"00:00:58\\", \\"00:00:59\\", \\"00:01:00\\", \\"00:01:01\\", \\"00:01:02\\"] >>> run_digital_clock(\\"10:10:10\\", 0) [\\"10:10:10\\"]","solution":"def run_digital_clock(start_time, t): Runs a digital clock for \`t\` seconds starting from \`start_time\`. Parameters: - start_time (str): The initial time in \\"hh:mm:ss\\" format. - t (int): The number of seconds the clock should run. Returns: - List of strings with each time displayed in \\"hh:mm:ss\\" format for each second. # Extract hours, minutes, and seconds from start_time hours, minutes, seconds = map(int, start_time.split(':')) result = [] for _ in range(t + 1): # Format current time to \\"hh:mm:ss\\" and add to result result.append(f\\"{hours:02}:{minutes:02}:{seconds:02}\\") # Increment by 1 second seconds += 1 if seconds == 60: seconds = 0 minutes += 1 if minutes == 60: minutes = 0 hours += 1 if hours == 24: hours = 0 return result"},{"question":"def sort_odd_even(numbers: List[int]) -> List[int]: Sorts a list of non-negative integers such that all odd numbers come before all even numbers, with each group sorted in ascending order. :param numbers: List of non-negative integers :return: List of integers sorted based on the described criteria >>> sort_odd_even([4, 1, 2, 3]) [1, 3, 2, 4] >>> sort_odd_even([6, 5, 6]) [5, 6, 6] >>> sort_odd_even([9, 5, 3, 7, 1]) [1, 3, 5, 7, 9] >>> sort_odd_even([8, 2, 4, 6]) [2, 4, 6, 8] >>> sort_odd_even([10, 9, 2, 7, 4, 1, 8, 3]) [1, 3, 7, 9, 2, 4, 8, 10] >>> sort_odd_even([1000000000, 999999999, 1000, 1]) [1, 999999999, 1000, 1000000000]","solution":"def sort_odd_even(numbers): This function sorts a list such that all odd numbers come before all even numbers, with each group sorted in ascending order. :param numbers: List of non-negative integers :return: List of integers sorted based on the described criteria # Separate odd and even numbers odds = [n for n in numbers if n % 2 != 0] evens = [n for n in numbers if n % 2 == 0] # Sort both lists in ascending order odds.sort() evens.sort() # Combine odds first, then evens return odds + evens"},{"question":"def count_passing_students(n: int, p: int, students: List[Tuple[str, int]]) -> int: Counts the number of students who have passed the test based on the passing mark. Args: n (int): Number of students. p (int): Passing mark. students (list of tuples): List of tuples where each tuple contains a student's name and score. Returns: int: Number of students who passed the test. >>> count_passing_students(5, 50, [(\\"alice\\", 48), (\\"bob\\", 60), (\\"charlie\\", 55), (\\"david\\", 49), (\\"eve\\", 50)]) 3 >>> count_passing_students(3, 75, [(\\"anna\\", 70), (\\"bruno\\", 80), (\\"clara\\", 75)]) 2 from typing import List, Tuple def test_count_passing_students_all_pass(): assert count_passing_students(3, 50, [(\\"alice\\", 50), (\\"bob\\", 60), (\\"charlie\\", 70)]) == 3 def test_count_passing_students_none_pass(): assert count_passing_students(3, 75, [(\\"alice\\", 50), (\\"bob\\", 60), (\\"charlie\\", 70)]) == 0 def test_count_passing_students_some_pass(): assert count_passing_students(5, 50, [(\\"alice\\", 48), (\\"bob\\", 60), (\\"charlie\\", 55), (\\"david\\", 49), (\\"eve\\", 50)]) == 3 def test_count_passing_students_edge_case(): assert count_passing_students(3, 75, [(\\"anna\\", 70), (\\"bruno\\", 80), (\\"clara\\", 75)]) == 2 def test_count_passing_students_one_student_pass(): assert count_passing_students(1, 50, [(\\"alice\\", 51)]) == 1 def test_count_passing_students_one_student_fail(): assert count_passing_students(1, 50, [(\\"alice\\", 49)]) == 0","solution":"def count_passing_students(n, p, students): Counts the number of students who have passed the test based on the passing mark. Args: n (int): Number of students. p (int): Passing mark. students (list of tuples): List of tuples where each tuple contains a student's name and score. Returns: int: Number of students who passed the test. passing_count = 0 for student in students: name, score = student if score >= p: passing_count += 1 return passing_count"},{"question":"from typing import List, Dict, Any def file_backup_system(T: int, cases: List[Dict[str, Any]]) -> List[List[List[int]]]: Processes the file modification and backup operations and returns a list of lists indicating the files included in each backup for each test case. pass def run_test_cases(): test_cases = [ { \\"input\\": { \\"T\\": 2, \\"cases\\": [ { \\"N\\": 4, \\"operations\\": [ \\"MOD 1 5\\", \\"MOD 2 10\\", \\"BACKUP 20\\", \\"BACKUP 30\\" ] }, { \\"N\\": 5, \\"operations\\": [ \\"MOD 1 5\\", \\"BACKUP 6\\", \\"MOD 2 10\\", \\"MOD 3 15\\", \\"BACKUP 20\\" ] } ] }, \\"expected\\": [ [[1, 2], []], [[1], [2, 3]] ] } ] for test_case in test_cases: T = test_case[\\"input\\"][\\"T\\"] cases = test_case[\\"input\\"][\\"cases\\"] expected = test_case[\\"expected\\"] result = file_backup_system(T, cases) assert result == expected, f\\"Expected {expected}, but got {result}\\" def test_file_backup_system(): run_test_cases()","solution":"def file_backup_system(T, cases): Processes the file modification and backup operations and returns a list of lists indicating the files included in each backup for each test case. results = [] for case in cases: operations = case['operations'] last_backup_time = 0 file_mod_times = {} backup_results = [] for operation in operations: op = operation.split() if op[0] == \\"MOD\\": file_id, mod_time = int(op[1]), int(op[2]) file_mod_times[file_id] = mod_time elif op[0] == \\"BACKUP\\": backup_time = int(op[1]) backup_files = [file_id for file_id, mod_time in file_mod_times.items() if mod_time > last_backup_time] backup_results.append(sorted(backup_files)) last_backup_time = backup_time results.append(backup_results) return results"},{"question":"from typing import List, Tuple def maximum_profit(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum profit Chef can achieve by buying and selling stocks. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N (number of days) and a list of N integers representing stock prices. Returns: List[int]: A list of integers where each integer is the maximum profit for the corresponding test case. Example: >>> maximum_profit(2, [(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1])]) [5, 0] pass def test_maximum_profit(): # Test case 1 T = 2 test_cases = [ (6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1]) ] expected_output = [5, 0] assert maximum_profit(T, test_cases) == expected_output # Test case 2: prices always increasing T = 1 test_cases = [ (4, [1, 2, 3, 4]) ] expected_output = [3] assert maximum_profit(T, test_cases) == expected_output # Test case 3: prices always decreasing T = 1 test_cases = [ (4, [4, 3, 2, 1]) ] expected_output = [0] assert maximum_profit(T, test_cases) == expected_output # Test case 4: some prices are the same T = 1 test_cases = [ (5, [5, 5, 5, 5, 5]) ] expected_output = [0] assert maximum_profit(T, test_cases) == expected_output # Test case 5: prices with multiple local minima and maxima T = 1 test_cases = [ (7, [2, 1, 3, 1, 4, 1, 5]) ] expected_output = [4] assert maximum_profit(T, test_cases) == expected_output # Boundary case: minimum valid input T = 1 test_cases = [ (2, [1, 2]) ] expected_output = [1] assert maximum_profit(T, test_cases) == expected_output","solution":"def maximum_profit(T, test_cases): results = [] for i in range(T): N, prices = test_cases[i] min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price results.append(max_profit) return results"},{"question":"from typing import List, Tuple def min_additional_roads(N: int, M: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of additional roads needed to make the network of houses connected. >>> min_additional_roads(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 0 >>> min_additional_roads(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 def test_case_1(): N = 6 M = 5 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert min_additional_roads(N, M, roads) == 0 def test_case_2(): N = 6 M = 3 roads = [(1, 2), (2, 3), (4, 5)] assert min_additional_roads(N, M, roads) == 2 def test_case_3(): N = 1 M = 0 roads = [] assert min_additional_roads(N, M, roads) == 0 def test_case_4(): N = 4 M = 2 roads = [(1, 2), (3, 4)] assert min_additional_roads(N, M, roads) == 1 def test_case_5(): N = 5 M = 2 roads = [(1, 2), (4, 5)] assert min_additional_roads(N, M, roads) == 2","solution":"def find(root, parent): if parent[root] != root: parent[root] = find(parent[root], parent) return parent[root] def union(node1, node2, parent, rank): root1 = find(node1, parent) root2 = find(node2, parent) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 def min_additional_roads(N, M, roads): parent = list(range(N + 1)) rank = [0] * (N + 1) for u, v in roads: union(u, v, parent, rank) components = len(set(find(i, parent) for i in range(1, N + 1))) return components - 1"},{"question":"from typing import List def max_substring_length_with_k_distinct_characters(k: int, s: str) -> int: Given a string \`s\`, determine the maximum length of a substring that contains at most \`k\` distinct characters. >>> max_substring_length_with_k_distinct_characters(2, 'abcba') 3 >>> max_substring_length_with_k_distinct_characters(3, 'aabbcc') 6 def process_test_cases(t: int, test_cases: List) -> List[int]: Process multiple test cases to determine the maximum length of a substring that contains at most \`k\` distinct characters. >>> process_test_cases(2, [2, 'abcba', 3, 'aabbcc']) [3, 6] >>> process_test_cases(3, [1, 'aaaa', 1, 'abc', 2, 'aaaabbbb']) [4, 1, 8]","solution":"def max_substring_length_with_k_distinct_characters(k, s): from collections import defaultdict n = len(s) if k == 0 or n == 0: return 0 start = 0 max_len = 0 char_count = defaultdict(int) for end in range(n): char_count[s[end]] += 1 while len(char_count) > k: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len def process_test_cases(t, test_cases): results = [] for i in range(t): k = test_cases[i*2] s = test_cases[i*2 + 1] result = max_substring_length_with_k_distinct_characters(k, s) results.append(result) return results"},{"question":"def longest_even_subarray_length(A): Determine the length of the longest contiguous subarray that contains only even numbers. Args: A (List[int]): Array of integers. Returns: int: Length of the longest contiguous subarray of even numbers. >>> longest_even_subarray_length([1, 2, 4, 6, 7]) 3 >>> longest_even_subarray_length([1, 3, 5, 7]) 0 >>> longest_even_subarray_length([8, 10, 12, 14, 3, 6]) 4 >>> longest_even_subarray_length([2, 4, 6, 8, 10]) 5 >>> longest_even_subarray_length([1, 1, 1]) 0 def process_test_cases(test_cases): Process multiple test cases and return a list of results for each test case. Args: test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case is represented as a tuple containing the size of the array and the array itself. Returns: List[int]: List of results for each test case. def test_longest_even_subarray_length(): Unit test for longest_even_subarray_length function. test_cases = [ (5, [1, 2, 4, 6, 7]), (4, [1, 3, 5, 7]), (6, [8, 10, 12, 14, 3, 6]), (5, [2, 4, 6, 8, 10]), (3, [1, 1, 1]), ] results = process_test_cases(test_cases) assert results[0] == 3 assert results[1] == 0 assert results[2] == 4 assert results[3] == 5 assert results[4] == 0 # Running the test test_longest_even_subarray_length()","solution":"def longest_even_subarray_length(A): Returns the length of the longest contiguous subarray that contains only even numbers. max_len = 0 current_len = 0 for num in A: if num % 2 == 0: current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 0 return max_len def process_test_cases(test_cases): Process multiple test cases and return a list of results for each test case. results = [] for case in test_cases: array = case[1] result = longest_even_subarray_length(array) results.append(result) return results"},{"question":"def rearrangeIntegers(lst): Given a list of integers, rearrange the list into a new list such that the odd numbers appear first in non-descending order followed by the even numbers in non-descending order. The relative order among the odd numbers and among the even numbers should be unchanged from the original list. >>> rearrangeIntegers([3, 1, 2, 4, 5, 7, 6]) [3, 1, 5, 7, 2, 4, 6] >>> rearrangeIntegers([8, -3, 5, 2, -10, 1]) [-3, 5, 1, 8, 2, -10] >>> rearrangeIntegers([3, 1, 5, 7]) [3, 1, 5, 7] >>> rearrangeIntegers([8, 2, 4, 6]) [8, 2, 4, 6] >>> rearrangeIntegers([1, -2, -1, 2]) [1, -1, -2, 2] >>> rearrangeIntegers([5]) [5] >>> rearrangeIntegers([2]) [2] >>> rearrangeIntegers([0, 1, 2, 3, 4]) [1, 3, 0, 2, 4] >>> rearrangeIntegers(list(range(1000)))[:10] [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]","solution":"def rearrangeIntegers(lst): Rearranges the list of integers such that odd numbers come first followed by even numbers, while preserving the relative order among odd numbers and among even numbers. odds = [x for x in lst if x % 2 != 0] evens = [x for x in lst if x % 2 == 0] return odds + evens"},{"question":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: Returns the number of subarrays whose sum is exactly equal to k. >>> subarray_sum([1, 2, 3, 4, 5], 5) == 2 >>> subarray_sum([1, 1, 1, 1], 2) == 3","solution":"def subarray_sum(nums, k): Returns the number of subarrays whose sum is exactly equal to k. count = 0 cumulative_sum = 0 sum_dict = {0: 1} for num in nums: cumulative_sum += num if (cumulative_sum - k) in sum_dict: count += sum_dict[cumulative_sum - k] if cumulative_sum in sum_dict: sum_dict[cumulative_sum] += 1 else: sum_dict[cumulative_sum] = 1 return count def count_subarrays_with_sum(n, array, k): Wrapper function to process input and call subarray_sum function. return subarray_sum(array, k)"},{"question":"def sieve_of_eratosthenes(max_num): Uses the Sieve of Eratosthenes to find all prime numbers up to max_num and returns a list of counts of primes up to each index. is_prime = [True] * (max_num + 1) p = 2 while (p * p <= max_num): if (is_prime[p] == True): for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 count_primes = [0] * (max_num + 1) for i in range(2, max_num + 1): count_primes[i] = count_primes[i - 1] if is_prime[i]: count_primes[i] += 1 return count_primes def prime_performances(T, test_cases): Determines the number of prime-numbered performances in the range [1, N] for different values of N. Args: T (int): The number of test cases. test_cases (List[int]): A list of integers where each integer N represents a test case. Returns: List[int]: A list of integers where each integer represents the number of prime-numbered performances for the corresponding test case. Example: >>> prime_performances(3, [10, 20, 30]) [4, 8, 10] >>> prime_performances(1, [1]) [0] max_n = max(test_cases) count_primes = sieve_of_eratosthenes(max_n) results = [] for n in test_cases: results.append(count_primes[n]) return results # Unit Test from solution import prime_performances def test_prime_performances(): assert prime_performances(3, [10, 20, 30]) == [4, 8, 10] assert prime_performances(1, [1]) == [0] assert prime_performances(2, [11, 50]) == [5, 15] assert prime_performances(1, [1000000]) == [78498] def test_edge_cases(): assert prime_performances(1, [2]) == [1] assert prime_performances(1, [3]) == [2] def test_single_cases(): assert prime_performances(1, [10]) == [4] assert prime_performances(1, [20]) == [8] assert prime_performances(1, [30]) == [10] def test_large_numbers(): assert prime_performances(1, [1000000]) == [78498]","solution":"def sieve_of_eratosthenes(max_num): Uses the Sieve of Eratosthenes to find all prime numbers up to max_num and returns a list of counts of primes up to each index. is_prime = [True] * (max_num + 1) p = 2 while (p * p <= max_num): if (is_prime[p] == True): for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 count_primes = [0] * (max_num + 1) for i in range(2, max_num + 1): count_primes[i] = count_primes[i - 1] if is_prime[i]: count_primes[i] += 1 return count_primes def prime_performances(T, test_cases): max_n = max(test_cases) count_primes = sieve_of_eratosthenes(max_n) results = [] for n in test_cases: results.append(count_primes[n]) return results"},{"question":"from typing import List, Tuple def find_subarray_to_reverse(n: int, arr: List[int]) -> Tuple[int, int]: You are given an array of distinct integers. Your task is to maximize the length of the longest contiguous increasing subsequence (LCIS) by reversing one subarray (i.e., a continuous segment) of the original array. After reversing the chosen subarray of the original array, the elements of this subarray should appear in the reverse order. If multiple such subarrays exist, choose the one that yields the lexicographically smallest array (i.e., the array which is smallest in dictionary order). Input: n (int): the number of elements in the array. arr (List[int]): the list of n distinct integers. Output: Tuple[int, int]: two integers l and r (1 ≤ l ≤ r ≤ n) — the left and right indices of the subarray that you will reverse to maximize the length of the LCIS. If no subarray can increase the LCIS, output \\"1 1\\". Example: >>> find_subarray_to_reverse(6, [1, 5, 4, 3, 2, 6]) (2, 5) >>> find_subarray_to_reverse(5, [1, 2, 3, 4, 5]) (1, 1)","solution":"def find_subarray_to_reverse(n, arr): def lcis_length(a): max_len = length = 1 for i in range(1, len(a)): if a[i] > a[i - 1]: length += 1 else: max_len = max(max_len, length) length = 1 return max(max_len, length) if lcis_length(arr) == n: return 1, 1 max_lcis = lcis_length(arr) best_l, best_r = 1, 1 for l in range(n): for r in range(l, n): modified_arr = arr[:l] + arr[l:r+1][::-1] + arr[r+1:] current_lcis = lcis_length(modified_arr) if current_lcis > max_lcis or (current_lcis == max_lcis and modified_arr < arr[:best_l-1] + arr[best_l-1:best_r][::-1] + arr[best_r:]): max_lcis = current_lcis best_l, best_r = l + 1, r + 1 return best_l, best_r"},{"question":"def max_subarray_sums(arr, queries): For an array of integers and a list of queries, find the maximum sum of a subarray that starts at l and ends at or before r. >>> arr = [-1, 2, 3, -2, 5] >>> queries = [(1, 3), (2, 5), (1, 5)] >>> max_subarray_sums(arr, queries) [5, 8, 8] >>> arr = [1, -3, 4, -2, 6, -1, 3] >>> queries = [(1, 4), (2, 3), (4, 7), (1, 7)] >>> max_subarray_sums(arr, queries) [4, 4, 8, 10] >>> arr = [-1, -2, -3, -4, -5] >>> queries = [(1, 5), (1, 3), (3, 5)] >>> max_subarray_sums(arr, queries) [-1, -1, -3] >>> arr = [10] >>> queries = [(1, 1)] >>> max_subarray_sums(arr, queries) [10] >>> arr = [4, -1, 2, 1] >>> queries = [(1, 2), (1, 3), (1, 4), (2, 4)] >>> max_subarray_sums(arr, queries) [4, 5, 6, 3]","solution":"def max_subarray_sums(arr, queries): n = len(arr) # To store the results results = [] # Iterate through each query for l, r in queries: current_sum = float('-inf') max_sum = float('-inf') for i in range(l - 1, r): if current_sum < 0: current_sum = arr[i] else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum results.append(max_sum) return results"},{"question":"def max_beauty_of_subsequence(s: str) -> int: Returns the maximum beauty of any subsequence of the string s. The beauty of a subsequence is defined as the number of distinct characters in the subsequence. >>> max_beauty_of_subsequence(\\"ababc\\") 3 >>> max_beauty_of_subsequence(\\"abcd\\") 4 >>> max_beauty_of_subsequence(\\"a\\") 1 >>> max_beauty_of_subsequence(\\"zzzzz\\") 1 >>> max_beauty_of_subsequence(\\"aabbcc\\") 3 >>> max_beauty_of_subsequence(\\"abcabcabc\\") 3 pass def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases and returns a list of results. Args: T: The number of test cases. test_cases: A list of strings, each representing a test case. Returns: A list of integers, each representing the maximum beauty of any subsequence of the corresponding string. >>> process_test_cases(2, [\\"ababc\\", \\"abcd\\"]) [3, 4] >>> process_test_cases(3, [\\"a\\", \\"aa\\", \\"aaa\\"]) [1, 1, 1] pass","solution":"def max_beauty_of_subsequence(s): Returns the maximum beauty of any subsequence of the string s. The beauty of a subsequence is defined as the number of distinct characters in the subsequence. # Using a set to store distinct characters in the string s distinct_characters = set(s) # The number of distinct characters is the maximum beauty of any subsequence of s. return len(distinct_characters) def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(max_beauty_of_subsequence(s)) return results"},{"question":"def bloomingPeriods(h: List[int]) -> int: Determine the number of distinct blooming periods for a plant's height. >>> bloomingPeriods([1, 2, 3, 1, 2, 3, 4, 1, 2]) 3 >>> bloomingPeriods([2, 3, 2, 3, 4, 1, 2, 3, 5]) 3 >>> bloomingPeriods([5, 6, 7, 1, 2, 2, 3, 4, 7]) 3 >>> bloomingPeriods([1, 1, 1, 1]) 0 >>> bloomingPeriods([1]) 0 >>> bloomingPeriods([]) 0 >>> bloomingPeriods([1, 3, 5, 7]) 0 >>> bloomingPeriods([1, 2, 3, 5, 6, 7, 3, 4, 5]) 3 pass from typing import List def test_single_blooming_period(): assert bloomingPeriods([1, 2, 3]) == 1 def test_multiple_blooming_period(): assert bloomingPeriods([1, 2, 3, 1, 2, 3, 4, 1, 2]) == 3 def test_mixed_blooming_period(): assert bloomingPeriods([2, 3, 2, 3, 4, 1, 2, 3, 5]) == 3 def test_disjoint_blooming_period(): assert bloomingPeriods([5, 6, 7, 1, 2, 2, 3, 4, 7]) == 3 def test_no_blooming_period(): assert bloomingPeriods([1, 1, 1, 1]) == 0 def test_single_element(): assert bloomingPeriods([1]) == 0 def test_empty_list(): assert bloomingPeriods([]) == 0 def test_nonconsecutive_elements(): assert bloomingPeriods([1, 3, 5, 7]) == 0 def test_complex_case(): assert bloomingPeriods([1, 2, 3, 5, 6, 7, 3, 4, 5]) == 3","solution":"def bloomingPeriods(h): n = len(h) if n == 0: return 0 blooming_count = 0 i = 0 while i < n: start = i while i < n - 1 and h[i + 1] == h[i] + 1: i += 1 if start != i: blooming_count += 1 i += 1 return blooming_count"},{"question":"def is_subarray_with_sum(arr, N, M): Checks if there exists subarray with sum equal to M. Args: arr (list): The list of integers. N (int): The length of the list. M (int): The target sum. Returns: bool: True if there exists a subarray with sum equal to M, otherwise False. Examples: >>> is_subarray_with_sum([1, 2, 3, 7, 5], 5, 12) True >>> is_subarray_with_sum([1, 2, 3, 4, 5], 5, 9) True >>> is_subarray_with_sum([1, 2, 3, 4, 5], 5, 20) False >>> is_subarray_with_sum([], 0, 0) False >>> is_subarray_with_sum([5], 1, 5) True >>> is_subarray_with_sum([5], 1, 10) False >>> is_subarray_with_sum([-1, 2, 3, 4, -4], 5, 4) True >>> is_subarray_with_sum([1, 2, 3, 4], 4, 10) True","solution":"def is_subarray_with_sum(arr, N, M): Checks if there exists subarray with sum equal to M. Args: arr (list): The list of integers. N (int): The length of the list. M (int): The target sum. Returns: bool: True if there exists a subarray with sum equal to M, otherwise False. curr_sum = 0 prefix_sums = {} for i in range(N): curr_sum += arr[i] # Check if current sum is equal to the target sum if curr_sum == M: return True # Check if there is any subarray ending at index i # which sums to M if (curr_sum - M) in prefix_sums: return True # Add the current running sum to the prefix sums dictionary prefix_sums[curr_sum] = i return False"},{"question":"def count_telepod_pairs(codes): Count the number of telepod pairs that differ by exactly one swap of two characters. >>> count_telepod_pairs([\\"ABCD\\", \\"ACBD\\", \\"BACD\\", \\"ACDB\\"]) 3 >>> count_telepod_pairs([\\"ABCD\\", \\"EFGH\\", \\"IJKL\\"]) 0 >>> count_telepod_pairs([\\"AB\\", \\"BA\\", \\"CD\\", \\"DC\\"]) 2 def process_input(data): Process the input data and outputs the number of telepod pairs for each test case. >>> process_input([\\"4\\", \\"ABCD\\", \\"ACBD\\", \\"BACD\\", \\"ACDB\\", \\"0\\"]) [3] >>> process_input([\\"4\\", \\"ABCD\\", \\"ACBD\\", \\"BACD\\", \\"ACDB\\", \\"3\\", \\"AB\\", \\"BA\\", \\"AC\\", \\"0\\"]) [3, 1] >>> process_input([\\"4\\", \\"ABCD\\", \\"EFGH\\", \\"IJKL\\", \\"MNOP\\", \\"0\\"]) [0]","solution":"def count_telepod_pairs(codes): Count the number of telepod pairs that differ by exactly one swap of two characters. def are_swappable(s1, s2): # Find positions where s1 and s2 differ diffs = [(ch1, ch2) for ch1, ch2 in zip(s1, s2) if ch1 != ch2] # They are swappable if there are exactly two differences and they are complimentary return len(diffs) == 2 and diffs[0] == tuple(reversed(diffs[1])) n = len(codes) count = 0 # Compare each pair of telepod codes for i in range(n): for j in range(i + 1, n): if are_swappable(codes[i], codes[j]): count += 1 return count def process_input(data): results = [] i = 0 while i < len(data): n = int(data[i]) if n == 0: break codes = data[i + 1:i + 1 + n] results.append(count_telepod_pairs(codes)) i += n + 1 return results"},{"question":"def remaining_volume(T: int, test_cases: List[Tuple[int, Tuple[int, int, int, int, int, int]]]) -> List[int]: Calculates the volume of the remaining part of a cube after carving out a specified cuboid for each test case. Args: T (int): Number of test cases. test_cases (List[Tuple[int, Tuple[int, int, int, int, int, int]]]): Each test case, first integer is the side length of the cube (n) and a tuple containing 6 integers representing coordinates of the opposite corners of the cuboid (x1, y1, z1, x2, y2, z2). Returns: List[int]: The remaining volume of the cube after carving out the cuboid for each test case. >>> remaining_volume(3, [(10, (1, 1, 1, 3, 3, 3)), (8, (2, 2, 2, 4, 4, 4)), (5, (0, 0, 0, 2, 2, 2))]) [992, 504, 117] >>> remaining_volume(1, [(4, (0, 0, 0, 1, 1, 1))]) [63] >>> remaining_volume(1, [(7, (0, 0, 0, 7, 7, 7))]) [0] >>> remaining_volume(1, [(1, (0, 0, 0, 1, 1, 1))]) [0] >>> remaining_volume(2, [(100, (0, 0, 0, 50, 50, 50)), (100, (50, 50, 50, 100, 100, 100))]) [875000, 875000]","solution":"def remaining_volume(T, test_cases): results = [] for case in test_cases: n = case[0] x1, y1, z1, x2, y2, z2 = case[1] # Volume of the entire cube total_volume = n ** 3 # Volume of the cuboid to be carved out carved_volume = (x2 - x1) * (y2 - y1) * (z2 - z1) # Volume of the remaining part of the cube remaining_volume = total_volume - carved_volume results.append(remaining_volume) return results"},{"question":"def traverse_city(N: int, k: int, grid: List[List[int]]) -> str: Determines whether there is a path from the top-left to the bottom-right corner of the grid where the height difference between adjacent cells does not exceed k. >>> traverse_city(4, 3, [ ... [1, 4, 2, 3], ... [2, 3, 3, 4], ... [3, 5, 4, 2], ... [4, 2, 3, 2] ... ]) \\"YES\\" >>> traverse_city(3, 1, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) \\"NO\\" >>> traverse_city(2, 0, [ ... [1, 1], ... [1, 1] ... ]) \\"YES\\" >>> traverse_city(2, 0, [ ... [1, 2], ... [2, 1] ... ]) \\"NO\\" >>> traverse_city(5, 2, [ ... [1, 2, 3, 4, 5], ... [2, 3, 4, 5, 6], ... [3, 4, 5, 6, 7], ... [4, 5, 6, 7, 8], ... [5, 6, 7, 8, 9] ... ]) \\"YES\\"","solution":"def traverse_city(N, k, grid): Determines whether there is a path from the top-left to the bottom-right corner of the grid where the height difference between adjacent cells does not exceed k. from collections import deque # Directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0)]) visited = set((0, 0)) def valid_move(x1, y1, x2, y2): return 0 <= x2 < N and 0 <= y2 < N and (x2, y2) not in visited and abs(grid[x1][y1] - grid[x2][y2]) <= k while queue: x, y = queue.popleft() # If we reached the bottom-right corner if x == N-1 and y == N-1: return \\"YES\\" # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if valid_move(x, y, nx, ny): queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\" # Example usage: # N, k = 4, 3 # grid = [ # [1, 4, 2, 3], # [2, 3, 3, 4], # [3, 5, 4, 2], # [4, 2, 3, 2] # ] # print(traverse_city(N, k, grid)) # Output: YES"},{"question":"from typing import List, Tuple def find_top_scorers(test_cases: List[Tuple[int, List[Tuple[str, int]]]]) -> List[str]: Given multiple test cases with names and scores, return top scorer(s) for each test case. :param test_cases: List of test cases where each test case is a tuple: - Number of entries (N) - List of tuples (name, score) :return: List of strings where each string represents the top scorers for a test case followed by their score. Multiple names are separated by commas in alphabetical order. Examples: >>> find_top_scorers([(4, [(\\"Alice\\", 10), (\\"Bob\\", 15), (\\"Charlie\\", 15), (\\"David\\", 8)])]) ['Bob,Charlie 15'] >>> find_top_scorers([(3, [(\\"Eve\\", 20), (\\"Alice\\", 20), (\\"Bob\\", 20)])]) ['Alice,Bob,Eve 20'] Test Cases: >>> test_single_top_scorer() >>> test_multiple_top_scorers_in_alphabetical_order() >>> test_single_entry() >>> test_all_same_scores() >>> test_no_entries() >>> test_mixed_scores() >>> test_multiple_test_cases()","solution":"def find_top_scorers(test_cases): Given multiple test cases with names and scores, return top scorer(s) for each test case. :param test_cases: List of test cases where each test case is a tuple: - Number of entries (N) - List of tuples (name, score) :return: List of strings where each string represents the top scorers for a test case followed by their score. Multiple names are separated by commas in alphabetical order. result = [] for case in test_cases: n = case[0] entries = case[1] if n == 0: result.append(\\"\\") continue # Dictionary to store names and their scores scores = {} for name, score in entries: if score not in scores: scores[score] = [] scores[score].append(name) # Find the highest score max_score = max(scores.keys()) # Get all names with the highest score and sort them alphabetically top_scorers = sorted(scores[max_score]) # Format the result string result.append(\\",\\".join(top_scorers) + f\\" {max_score}\\") return result"},{"question":"def island_treasures(P: int, test_cases: List[Dict]) -> List[str]: Compute which treasures Bob can collect after moving on the island. Args: P: The number of test cases. test_cases: A list of dictionaries, where each dictionary represents a test case. Each dictionary contains: - initial_conditions: A tuple (n, M, x0, y0) where n is the number of treasures, M is the number of times the movement sequence is performed, and (x0, y0) is Bob's initial location. - treasures: A list of tuples (ai, bi) representing the coordinates of the treasures. - movement_seq: A list of movements, where each movement is represented as a tuple with the format: ('T', dx, dy) for translation, ('VS', sy) for vertical scaling, ('HS', sx) for horizontal scaling, ('FX') for flip over x-axis, and ('FY') for flip over y-axis. Returns: A list of strings \\"TREASURE FOUND\\" or \\"TREASURE LOST\\" for each treasure in each test case. Example: >>> P = 1 >>> test_cases = [ ... { ... 'initial_conditions': (2, 1, 0, 0), ... 'treasures': [(2, 3), (-4, 5)], ... 'movement_seq': [('T', 1, -1), ('VS', 2), ('HS', -1)] ... } ... ] >>> island_treasures(P, test_cases) [\\"TREASURE LOST\\", \\"TREASURE LOST\\"] from solution import island_treasures def test_island_treasures_1(): P = 1 test_cases = [ { 'initial_conditions': (2, 1, 0, 0), 'treasures': [(2, 3), (-4, 5)], 'movement_seq': [('T', 1, -1), ('VS', 2), ('HS', -1)] } ] result = island_treasures(P, test_cases) assert result == [\\"TREASURE LOST\\", \\"TREASURE LOST\\"] def test_island_treasures_2(): P = 1 test_cases = [ { 'initial_conditions': (1, 1, 0, 0), 'treasures': [(1, -2)], 'movement_seq': [('T', 1, -1), ('VS', 2), ('HS', 1)] } ] result = island_treasures(P, test_cases) assert result == [\\"TREASURE FOUND\\"] def test_island_treasures_3(): P = 1 test_cases = [ { 'initial_conditions': (2, 2, 0, 0), 'treasures': [(2, 3), (-4, 5)], 'movement_seq': [('T', 1, 2), ('VS', 1), ('HS', 1)] } ] result = island_treasures(P, test_cases) assert result == [\\"TREASURE LOST\\", \\"TREASURE LOST\\"]","solution":"def apply_movement_seq(position, movement_seq): x, y = position for move in movement_seq: if move[0] == 'T': x += move[1] y += move[2] elif move[0] == 'VS': y *= move[1] elif move[0] == 'HS': x *= move[1] elif move[0] == 'FX': y = -y elif move[0] == 'FY': x = -x return (x, y) def island_treasures(P, test_cases): results = [] for case in test_cases: n, M, x0, y0 = case['initial_conditions'] treasures = case['treasures'] movement_seq = case['movement_seq'] final_position = (x0, y0) for _ in range(M): final_position = apply_movement_seq(final_position, movement_seq) for tx, ty in treasures: if final_position == (tx, ty): results.append(\\"TREASURE FOUND\\") else: results.append(\\"TREASURE LOST\\") return results"},{"question":"from typing import List, Tuple def minimize_max_diff(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Rearrange the array such that the difference between the max value of any subarray of length \`k\` and the min value of any subarray of length \`k\` is minimized. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, where each test case contains an integer \`n\` (the number of elements in the array), an integer \`k\` (the length of the subarray), and a list of \`n\` integers (the elements of the array). Returns: List[int]: A list of integers representing the minimum possible value of max({max(subarray of length k) - min(subarray of length k)}) after rearranging the array optimally for each test case. >>> minimize_max_diff(2, [(5, 3, [1, 5, 3, 8, 12]), (6, 2, [4, 2, 7, 3, 5, 1])]) [4, 1] >>> minimize_max_diff(1, [(4, 2, [1, 3, 2, 6])]) [1] >>> minimize_max_diff(1, [(3, 3, [1, 1, 1])]) [0] >>> minimize_max_diff(1, [(5, 5, [10, 20, 30, 40, 50])]) [40] >>> minimize_max_diff(1, [(10, 4, [5, 5, 8, 8, 8, 8, 5, 5, 3, 3])]) [0]","solution":"def minimize_max_diff(t, test_cases): results = [] for case in test_cases: n, k, nums = case nums.sort() min_max_diff = float('inf') for i in range(n - k + 1): subarray = nums[i:i + k] max_min_diff = subarray[-1] - subarray[0] if max_min_diff < min_max_diff: min_max_diff = max_min_diff results.append(min_max_diff) return results"},{"question":"def count_pillars(N: int, M: int) -> int: Calculate the total number of pillars around a rectangular garden of dimensions N x M meters. >>> count_pillars(5, 3) 16 >>> count_pillars(8, 6) 28","solution":"def count_pillars(N, M): Returns the total number of pillars around the garden with dimensions N x M meters. return 2 * (N + 1) + 2 * (M + 1) - 4"},{"question":"def uniqueBackupTimes(backupTimes: List[int]) -> List[int]: Takes a list of integers representing the recorded backup times for several days and returns a list of unique backup times sorted in ascending order. >>> uniqueBackupTimes([25, 42, 42, 20, 25, 60, 60]) [20, 25, 42, 60] >>> uniqueBackupTimes([90, 45, 45, 30]) [30, 45, 90]","solution":"def uniqueBackupTimes(backupTimes): Returns a sorted list of unique backup times. # Convert the list into a set to remove duplicates unique_times = set(backupTimes) # Convert back to list and sort sorted_unique_times = sorted(unique_times) return sorted_unique_times"},{"question":"def rotateMatrix(M: int, B: List[List[int]]) -> List[List[int]]: Rotates the given MxM matrix B 90 degrees clockwise in place and returns it. Args: M (int): The dimension of the matrix. B (List[List[int]]): The MxM matrix to be rotated. Returns: List[List[int]]: The matrix after rotating 90 degrees clockwise. Tests: >>> rotateMatrix(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix(4, [[2, 5, 8, 1], [5, 5, 4, 2], [6, 4, 7, 3], [3, 2, 1, 4]]) [[3, 6, 5, 2], [2, 4, 5, 5], [1, 7, 4, 8], [4, 3, 2, 1]] >>> rotateMatrix(1, [[1]]) [[1]] >>> rotateMatrix(2, [[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotateMatrix(3, [[5, 5, 5], [5, 5, 5], [5, 5, 5]]) [[5, 5, 5], [5, 5, 5], [5, 5, 5]]","solution":"def rotateMatrix(M, B): Rotates the given MxM matrix B 90 degrees clockwise in place and returns it. # Transpose the matrix for i in range(M): for j in range(i, M): B[i][j], B[j][i] = B[j][i], B[i][j] # Reverse each row for i in range(M): B[i].reverse() return B"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array where nums[i] + nums[j] equals the target. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([3, 2, 4], 6) True >>> has_pair_with_sum([3, 3], 6) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([2, 5, 5, 11], 10) True","solution":"def has_pair_with_sum(nums, target): Determines if there are two distinct indices i and j in the array where nums[i] + nums[j] equals the target. seen = {} for idx, num in enumerate(nums): complement = target - num if complement in seen: return True seen[num] = idx return False"},{"question":"def get_latest_statuses(updates): Given a list of updates, each update is represented as a tuple (package_id, checkpoint_time, status), returns the latest status for each package. >>> updates = [(1, \\"09:00\\", \\"Dispatched\\"), (2, \\"10:30\\", \\"In Transit\\"), (1, \\"11:45\\", \\"Delivered\\"), (2, \\"10:45\\", \\"Out for Delivery\\"), (3, \\"12:00\\", \\"Shipped\\")] >>> get_latest_statuses(updates) [(1, \\"Delivered\\"), (2, \\"Out for Delivery\\"), (3, \\"Shipped\\")] >>> updates = [(1, \\"09:00\\", \\"Dispatched\\")] >>> get_latest_statuses(updates) [(1, \\"Dispatched\\")] >>> updates = [(1, \\"09:00\\", \\"Dispatched\\"), (1, \\"09:00\\", \\"In Transit\\")] >>> get_latest_statuses(updates) [(1, \\"In Transit\\")] >>> updates = [(1, \\"11:45\\", \\"Delivered\\"), (1, \\"09:00\\", \\"Dispatched\\")] >>> get_latest_statuses(updates) [(1, \\"Delivered\\")] >>> updates = [] >>> get_latest_statuses(updates) [] >>> updates = [(1, \\"10:00\\", \\"Processed\\"), (2, \\"11:05\\", \\"Dispatched\\"), (3, \\"12:10\\", \\"In Transit\\"), (1, \\"13:00\\", \\"Delivered\\"), (2, \\"14:00\\", \\"Out for Delivery\\")] >>> get_latest_statuses(updates) [(1, \\"Delivered\\"), (2, \\"Out for Delivery\\"), (3, \\"In Transit\\")]","solution":"def get_latest_statuses(updates): Given a list of updates, each update is represented as a tuple (package_id, checkpoint_time, status), returns the latest status for each package. from collections import defaultdict def time_to_minutes(t): h, m = map(int, t.split(':')) return h * 60 + m latest_status = defaultdict(lambda: (\\"00:00\\", \\"\\")) for package_id, checkpoint_time, status in updates: current_time = time_to_minutes(checkpoint_time) last_update_time = time_to_minutes(latest_status[package_id][0]) if current_time >= last_update_time: latest_status[package_id] = (checkpoint_time, status) result = [(k, v[1]) for k, v in sorted(latest_status.items())] return result"},{"question":"def find_added_character(s: str, t: str) -> str: Find the additional character in t that does not exist in s. >>> find_added_character(\\"abcd\\", \\"abcde\\") 'e' >>> find_added_character(\\"xyz\\", \\"zxyq\\") 'q'","solution":"def find_added_character(s, t): Returns the character that was added to t compared to s. char_count = [0] * 26 for char in s: char_count[ord(char) - ord('a')] -= 1 for char in t: char_count[ord(char) - ord('a')] += 1 for i in range(26): if char_count[i] > 0: return chr(i + ord('a'))"},{"question":"def max_profit(prices: List[int]) -> int: Given a list of stock prices in chronological order, find out the maximum profit that can be made by buying and selling the stock at most twice. >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) 8 >>> max_profit([]) 0","solution":"def max_profit(prices): n = len(prices) if n < 2: return 0 # Array to store the maximum profit up to day i # with at most one transaction max_profit_one_transaction = [0] * n min_price = prices[0] # Forward pass to calculate maximum profit up to each day with one transaction for i in range(1, n): min_price = min(min_price, prices[i]) max_profit_one_transaction[i] = max(max_profit_one_transaction[i-1], prices[i] - min_price) max_profit = 0 max_price = prices[-1] # Backward pass to calculate maximum profit # with two transactions using the max profit data of the forward pass for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) max_profit_two_transactions = max_price - prices[i] + max_profit_one_transaction[i] max_profit = max(max_profit, max_profit_two_transactions) return max_profit"},{"question":"def maximum_difficulties(difficulties, intervals): Returns the maximum difficulties for each interval. Parameters: difficulties (list of int): A list of problem difficulties. intervals (list of tuple of int): A list of intervals (left, right) (1-based indexing). Returns: list of int: A list of maximum difficulties for each interval. >>> maximum_difficulties([4, 7, 2, 8, 5, 9], [(1, 3), (2, 5), (4, 6)]) [7, 8, 9] >>> maximum_difficulties([1, 3, 2, 4, 2], [(1, 5)]) [4] >>> maximum_difficulties([9, 8, 7, 6, 5], [(1, 2), (2, 5), (3, 3), (1, 5)]) [9, 8, 7, 9]","solution":"def maximum_difficulties(difficulties, intervals): Returns the maximum difficulties for each interval. Parameters: difficulties (list of int): A list of problem difficulties. intervals (list of tuple of int): A list of intervals (left, right) (1-based indexing). Returns: list of int: A list of maximum difficulties for each interval. results = [] for L, R in intervals: # Convert 1-based indexing to 0-based indexing maximum_difficulty = max(difficulties[L-1:R]) results.append(maximum_difficulty) return results def parse_input(input_string): Helper function to parse the input string. Parameters: input_string (str): The input string containing N, Q, list of difficulties, and intervals. Returns: tuple: Parsed N, Q, difficulties list, and intervals list. lines = input_string.strip().split('n') N, Q = map(int, lines[0].split()) difficulties = list(map(int, lines[1].split())) intervals = [tuple(map(int, line.split())) for line in lines[2:2+Q]] return N, Q, difficulties, intervals def main(input_string): Main function to handle input and output. N, Q, difficulties, intervals = parse_input(input_string) results = maximum_difficulties(difficulties, intervals) for result in results: print(result) # Sample usage input_string = 6 3 4 7 2 8 5 9 1 3 2 5 4 6 main(input_string)"},{"question":"def find_minimum_cost(structures: List[Dict[str, Any]]) -> List[Union[int, str]]: Find the minimum cost for each structure if the players collect resources efficiently, given the directed graph of dependencies. If a structure cannot be built due to unmet dependencies, return \\"IMPOSSIBLE\\" for that structure. :param structures: List of structures, each structure is defined by the number of resources (m) and a dictionary of resources. Each resource has a cost and a list of dependencies. :return: List of minimum costs for each structure, or \\"IMPOSSIBLE\\" if the structure cannot be built. Example: >>> find_minimum_cost([ {'m': 4, 'resources': { 'WOOD': {'cost': 3, 'dependencies': []}, 'STONE': {'cost': 4, 'dependencies': ['WOOD']}, 'BRICK': {'cost': 5, 'dependencies': ['WOOD', 'STONE']}, 'GLASS': {'cost': 6, 'dependencies':['STONE']} }}, {'m': 3, 'resources': { 'IRON': {'cost': 2, 'dependencies': []}, 'COPPER': {'cost': 3, 'dependencies': ['IRON']}, 'GOLD': {'cost': 10, 'dependencies': ['IRON', 'COPPER']} }} ]) [18, 15] >>> find_minimum_cost([ {'m': 3, 'resources': { 'A': {'cost': 1, 'dependencies': []}, 'B': {'cost': 2, 'dependencies': ['C']}, 'C': {'cost': 3, 'dependencies': ['B']} }} ]) ['IMPOSSIBLE'] def main(data: str) -> List[Union[int, str]]: Parses the input string and returns the minimum cost for each structure. :param data: Input data as a string. :return: List of minimum costs for each structure, or \\"IMPOSSIBLE\\" if the structure cannot be built. Example: >>> input_data = \\"2n4nWOOD 3 0nSTONE 4 1 WOODnBRICK 5 2 WOOD STONEnGLASS 6 1 STONEn3nIRON 2 0nCOPPER 3 1 IRONnGOLD 10 2 IRON COPPER\\" >>> main(input_data) [18, 15] >>> input_data = \\"1n3nA 1 0nB 2 1 CnC 3 1 B\\" >>> main(input_data) ['IMPOSSIBLE'] from solution import main def test_example1(): input_data = 2 4 WOOD 3 0 STONE 4 1 WOOD BRICK 5 2 WOOD STONE GLASS 6 1 STONE 3 IRON 2 0 COPPER 3 1 IRON GOLD 10 2 IRON COPPER expected_result = [18, 15] assert main(input_data) == expected_result def test_impossible_case(): input_data = 1 3 A 1 0 B 2 1 C C 3 1 B expected_result = [\\"IMPOSSIBLE\\"] assert main(input_data) == expected_result def test_multiple_structures(): input_data = 3 2 R1 5 0 R2 10 1 R1 2 G1 2 0 G2 5 1 G1 3 D1 1 0 D2 2 1 D1 D3 3 2 D1 D2 expected_result = [15, 7, 6] assert main(input_data) == expected_result def test_single_structure(): input_data = 1 1 WOOD 5 0 expected_result = [5] assert main(input_data) == expected_result","solution":"def find_minimum_cost(structures): def topological_sort(graph, in_degree): from collections import deque q = deque() topo_sort = [] for node in in_degree: if in_degree[node] == 0: q.append(node) while q: node = q.popleft() topo_sort.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: q.append(neighbor) return topo_sort if len(topo_sort) == len(in_degree) else None results = [] for structure in structures: m, resources = structure['m'], structure['resources'] graph = {resource: [] for resource in resources.keys()} in_degree = {resource: 0 for resource in resources.keys()} cost = {resource: resources[resource]['cost'] for resource in resources.keys()} for resource, details in resources.items(): for dependency in details['dependencies']: graph[dependency].append(resource) in_degree[resource] += 1 topo_sort = topological_sort(graph, in_degree) if not topo_sort: results.append(\\"IMPOSSIBLE\\") continue min_cost = {resource: -1 for resource in resources.keys()} for node in topo_sort: if in_degree[node] == 0: min_cost[node] = cost[node] for neighbor in graph[node]: if min_cost[neighbor] == -1: min_cost[neighbor] = 0 min_cost[neighbor] = max(min_cost[neighbor], min_cost[node] + cost[neighbor]) total_cost = sum(min_cost.values()) results.append(total_cost if total_cost != -1 else \\"IMPOSSIBLE\\") return results # Utility function to parse input and call the main function def main(data): data = data.strip().split(\\"n\\") k = int(data[0]) index = 1 structures = [] for _ in range(k): m = int(data[index]) index += 1 resources = {} for __ in range(m): parts = data[index].split() resource_name = parts[0] resource_cost = int(parts[1]) dependency_num = int(parts[2]) dependencies = parts[3:] if dependency_num > 0 else [] resources[resource_name] = {'cost': resource_cost, 'dependencies': dependencies} index += 1 structures.append({'m': m, 'resources': resources}) result = find_minimum_cost(structures) return result"},{"question":"def square_and_sort(nums): Takes a list of integers, squares each element, and returns a new list with the squared elements sorted in non-decreasing order. >>> square_and_sort([1, 2, 3]) [1, 4, 9] >>> square_and_sort([-3, -2, -1]) [1, 4, 9] >>> square_and_sort([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> square_and_sort([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121] >>> square_and_sort([0, 3, 1, -3, 2]) [0, 1, 4, 9, 9] >>> square_and_sort([]) []","solution":"def square_and_sort(nums): Takes a list of integers, squares each element, and returns a new list with the squared elements sorted in non-decreasing order. Parameters: nums (list): A list of integers. Returns: list: A new list of squared integers sorted in non-decreasing order. squared_nums = [x ** 2 for x in nums] squared_nums.sort() return squared_nums"},{"question":"def max_sum_subarray(nums: List[int], k: int) -> int: Returns the maximum sum of any continuous subarray of length k. Args: nums (List[int]): List of integers representing the input array. k (int): Length of the subarray. Returns: int: Maximum sum of any continuous subarray of length k or None if k is greater than the length of the input array. Examples: >>> max_sum_subarray([1, 12, -5, -6, 50, 3], 4) 51 >>> max_sum_subarray([5, 1, 3, 2, 7, 4], 3) 13 >>> max_sum_subarray([4, 2, 1, 7, 8], 2) 15","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of any continuous subarray of length k. if k > len(nums): return None # Not enough elements to form a subarray of length k # Calculate the sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) # Iterate over the array to find the maximum sum of any subarray of length k for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Tuple def longest_non_decreasing_subarray(n: int, sales: List[int]) -> Tuple[int, List[int]]: Analyze the sales data and identify the longest subarray of days during which the sales were in non-decreasing order. Args: n: int - the number of days sales: List[int] - the sales record for the last 'n' days Returns: Tuple[int, List[int]] - the length of the longest non-decreasing subarray and the subarray itself. Examples: >>> longest_non_decreasing_subarray(7, [100, 180, 260, 40, 310, 535, 695]) (4, [40, 310, 535, 695]) >>> longest_non_decreasing_subarray(3, [300, 300, 300]) (3, [300, 300, 300])","solution":"def longest_non_decreasing_subarray(n, sales): Returns the length of the longest non-decreasing subarray and the subarray itself. max_length = 1 current_length = 1 start_index = 0 max_start_index = 0 for i in range(1, n): if sales[i] >= sales[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length max_start_index = start_index current_length = 1 start_index = i if current_length > max_length: max_length = current_length max_start_index = start_index return max_length, sales[max_start_index:max_start_index + max_length]"},{"question":"def initialize_departments(department_data): Initializes the departments with their respective employee lists. Parameters: department_data (list of lists): Each sublist contains the department ID and employee IDs. Returns: dict: A dictionary with department ID as key and set of employee IDs as value. def transfer_employee(departments, employee_id, from_dept, to_dept): Transfers an employee from one department to another. Parameters: departments (dict): The dictionary containing department info. employee_id (int): The employee ID to be transferred. from_dept (int): ID of the department to transfer from. to_dept (int): ID of the department to transfer to. def merge_departments(departments, from_dept, to_dept): Merges one department into another, transferring all employees. Parameters: departments (dict): The dictionary containing department info. from_dept (int): ID of the department to merge from. to_dept (int): ID of the department to merge into. def list_unique_employees(departments): Lists all unique employee IDs across all departments. Parameters: departments (dict): The dictionary containing department info. Returns: list: A sorted list of unique employee IDs. def count_employees_in_department(departments, dept_id): Counts the number of employees in a specific department. Parameters: departments (dict): The dictionary containing department info. dept_id (int): The department ID for which to count employees. Returns: int: Number of employees in the specified department. # Example of Usage and Expected Output def main(): data = [ [1, 1001, 1002, 1003], [2, 2001, 2002], [3, 3001, 3002, 3003, 3004] ] departments = initialize_departments(data) transfer_employee(departments, 1001, 1, 2) merge_departments(departments, 2, 1) print(list_unique_employees(departments)) # Expected: [1002, 1003, 2001, 2002, 3001, 3002, 3003, 3004] print(count_employees_in_department(departments, 1)) # Expected: 5 print(count_employees_in_department(departments, 2)) # Expected: 0 print(count_employees_in_department(departments, 3)) # Expected: 4 if __name__ == \\"__main__\\": main()","solution":"def initialize_departments(department_data): Initializes the departments with their respective employee lists. Parameters: department_data (list of lists): Each sublist contains the department ID and employee IDs. Returns: dict: A dictionary with department ID as key and set of employee IDs as value. departments = {} for data in department_data: dept_id = data[0] employees = set(data[1:]) departments[dept_id] = employees return departments def transfer_employee(departments, employee_id, from_dept, to_dept): Transfers an employee from one department to another. Parameters: departments (dict): The dictionary containing department info. employee_id (int): The employee ID to be transferred. from_dept (int): ID of the department to transfer from. to_dept (int): ID of the department to transfer to. if employee_id in departments[from_dept]: departments[from_dept].remove(employee_id) departments[to_dept].add(employee_id) def merge_departments(departments, from_dept, to_dept): Merges one department into another, transferring all employees. Parameters: departments (dict): The dictionary containing department info. from_dept (int): ID of the department to merge from. to_dept (int): ID of the department to merge into. departments[to_dept].update(departments[from_dept]) departments[from_dept].clear() def list_unique_employees(departments): Lists all unique employee IDs across all departments. Parameters: departments (dict): The dictionary containing department info. Returns: list: A sorted list of unique employee IDs. unique_employees = set() for employees in departments.values(): unique_employees.update(employees) return sorted(unique_employees) def count_employees_in_department(departments, dept_id): Counts the number of employees in a specific department. Parameters: departments (dict): The dictionary containing department info. dept_id (int): The department ID for which to count employees. Returns: int: Number of employees in the specified department. return len(departments[dept_id])"},{"question":"def swap_adjacent_ids(t: int, test_cases: List[int]) -> List[List[int]]: Given the number of test cases and a list of the number of people for each test case, return the new order of IDs after swapping adjacent IDs. Parameters: t (int): The number of test cases test_cases (List[int]): A list of integers where each integer represents the number of people (n) in that test case Returns: List[List[int]]: A list where each element is a list representing the new order of IDs after swapping adjacent IDs for the corresponding test case. Examples: >>> swap_adjacent_ids(3, [2, 3, 4]) [[2, 1], [2, 1, 3], [2, 1, 4, 3]] >>> swap_adjacent_ids(1, [1]) [[1]]","solution":"def swap_adjacent_ids(t, test_cases): results = [] for n in test_cases: ids = list(range(1, n + 1)) for i in range(0, n - 1, 2): ids[i], ids[i + 1] = ids[i + 1], ids[i] results.append(ids) return results"},{"question":"def min_cost_to_palindrome(t: int, test_cases: List[str]) -> List[int]: Find the minimum cost to transform each string in test cases into a palindrome. Arguments: t: int -- the number of test cases test_cases: List[str] -- a list of strings consisting of 'A' and 'B' Returns: List[int] -- a list of integers where each integer represents the minimum cost for the corresponding test case. Example: >>> min_cost_to_palindrome(3, [\\"AAB\\", \\"ABBA\\", \\"ABBABB\\"]) [1, 0, 2]","solution":"def min_cost_to_palindrome(t, test_cases): results = [] for s in test_cases: n = len(s) cost = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: cost += 1 results.append(cost) return results"},{"question":"def min_operations(n, arr): Finds the minimum number of operations needed to construct a list that contains exactly \`n\` elements, with each element being one of the integers from \`arr\` at least once. >>> min_operations(5, [2, 1, 3]) 5 >>> min_operations(1, [4, 5]) 1 >>> min_operations(3, [1, 4]) 3","solution":"def min_operations(n, arr): Finds the minimum number of operations needed to construct a list that contains exactly n elements, with each element being one of the integers from arr at least once. # The minimum number of operations is always equal to n # Because we can append elements from arr to achieve the required list length. return n"},{"question":"def findPivotIndex(nums): Returns the smallest index i such that the sum of elements to the left of i is equal to the sum of elements to the right of i. If no such index exists, returns -1. >>> findPivotIndex([1, 7, 3, 6, 5, 6]) 3 >>> findPivotIndex([1, 2, 3]) -1 >>> findPivotIndex([5]) 0 >>> findPivotIndex([1, 2]) -1 >>> findPivotIndex([1, 2, 1, 2, 1, 2]) -1 >>> findPivotIndex([0, 0, 0, 0]) 0 >>> findPivotIndex([0, 0, 0, 0, 0]) 0 >>> findPivotIndex(list(range(1, 10001))) -1","solution":"def findPivotIndex(nums): Returns the smallest index i such that the sum of elements to the left of i is equal to the sum of elements to the right of i. If no such index exists, returns -1. total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"def find_singleton(arr: List[int]) -> int: Finds the integer that appears exactly once in the array. All other integers in the array appear twice. Args: arr (List[int]): the array of integers Returns: int: the integer that appears only once Examples: >>> find_singleton([1, 2, 3, 2, 1]) 3 >>> find_singleton([4, 6, 4, 8, 7, 7, 6, 9, 8]) 9","solution":"def find_singleton(arr): Finds the integer that appears exactly once in the array. All other integers in the array appear twice. result = 0 for num in arr: result ^= num return result"},{"question":"def max_resources_collected(n, r, t, T): Calculate the maximum number of resources that can be collected within the given total time. Args: n (int): Number of resource types. r (List[int]): Collection rates for each resource type. t (List[int]): Time taken to switch to each resource type. T (int): Total available time. Returns: int: Maximum number of a given resource type that can be collected within the given total time. >>> max_resources_collected(3, [5, 3, 8], [1, 2, 3], 10) 56 >>> max_resources_collected(2, [5, 10], [11, 20], 10) 0","solution":"def max_resources_collected(n, r, t, T): Calculate the maximum number of resources that can be collected within the given total time. Args: n (int): Number of resource types. r (List[int]): Collection rates for each resource type. t (List[int]): Time taken to switch to each resource type. T (int): Total available time. Returns: int: Maximum number of a given resource type that can be collected within the given total time. max_resources = 0 for i in range(n): if T >= t[i]: collection_time = T - t[i] resources_collected = collection_time * r[i] max_resources = max(max_resources, resources_collected) return max_resources"},{"question":"def tallest_tower(n, blocks): Determine the height of the tallest lookout tower that can be built. Args: n (int): The number of blocks. blocks (List[List[int]]): A list of blocks, each represented by a list of three integers: [id, length, weightCapacity]. Returns: int: The height of the tallest tower. >>> tallest_tower(3, [[1, 2, 100], [2, 2, 200], [3, 3, 150]]) 2 >>> tallest_tower(4, [[1, 1, 100], [2, 3, 200], [3, 1, 150], [4, 3, 100]]) 2","solution":"def tallest_tower(n, blocks): blocks_by_length = {} for block in blocks: id, length, weight_capacity = block if length not in blocks_by_length: blocks_by_length[length] = [] blocks_by_length[length].append(block) tallest_height = 0 for length, block_list in blocks_by_length.items(): tallest_height = max(tallest_height, len(block_list)) return tallest_height # Example Usage: # n = 4 # blocks = [ # [1, 1, 100], # [2, 3, 200], # [3, 1, 150], # [4, 3, 100] # ] # print(tallest_tower(n, blocks)) # Output: 2"},{"question":"from typing import List def generate_primes(n: int) -> List[int]: Generates a list of the first n prime numbers in ascending order. >>> generate_primes(5) [2, 3, 5, 7, 11] >>> generate_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"from typing import List def generate_primes(n: int) -> List[int]: Generates a list of the first n prime numbers in ascending order. if n < 1: return [] primes = [] candidate = 2 while len(primes) < n: is_prime = True for prime in primes: if prime * prime > candidate: break if candidate % prime == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes"},{"question":"def count_pairs(N: int, K: int, A: List[int]) -> int: Returns the number of pairs (i, j) such that A[i] + A[j] is a multiple of K >>> count_pairs(5, 4, [1, 2, 3, 4, 5]) 2 >>> count_pairs(4, 4, [4, 4, 4, 4]) 6 >>> count_pairs(3, 7, [1, 2, 3]) 0 >>> count_pairs(3, 2, [1000000000, 1000000002, 1000000004]) 3 >>> count_pairs(5, 1, [5, 5, 5, 5, 5]) 10 >>> count_pairs(4, 4, [1, 2, 3, 4]) 1 # Implementation goes here","solution":"def count_pairs(N, K, A): Returns the number of pairs (i, j) such that A[i] + A[j] is a multiple of K # Array to store frequencies of all remainders when divided by K remainder_count = [0] * K # Count occurrences of all remainders for number in A: remainder_count[number % K] += 1 # Count pairs with both remainders 0 count = remainder_count[0] * (remainder_count[0] - 1) // 2 # Count pairs with complementary remainders (i.e., remainder_i + remainder_j == K) for i in range(1, (K // 2) + 1): if i != K - i: count += remainder_count[i] * remainder_count[K - i] # Special case for evenly divisible remainder when K is even if K % 2 == 0: count += (remainder_count[K // 2] * (remainder_count[K // 2] - 1)) // 2 return count"},{"question":"def find_scenes_with_character(target: str, n: int, scenes: List[str]) -> Union[List[int], str]: Returns a list of scene numbers where the target character appears. :param target: str, name of the target character :param n: int, number of scenes :param scenes: list of str, each representing characters in a scene :return: list of int or str \\"Not found\\" >>> find_scenes_with_character('JonSnow', 5, ['AryaSansa Ned JonSnow', 'Tyrion JonSnow Robb', 'Daenerys Cersei', 'Samwell Gilly JonSnow', 'Jorah']) [1, 2, 4] >>> find_scenes_with_character('Daenerys', 3, ['Jon Arya', 'Cersei Tywin', 'Ned Arya']) \\"Not found\\"","solution":"def find_scenes_with_character(target, n, scenes): Returns a list of scene numbers where the target character appears. :param target: str, name of the target character :param n: int, number of scenes :param scenes: list of str, each representing characters in a scene :return: list of int or str \\"Not found\\" found_scenes = [] for i in range(n): scene = scenes[i] if target in scene.split(): found_scenes.append(i + 1) if found_scenes: return found_scenes else: return \\"Not found\\""},{"question":"def count_sunlit_buildings(heights): Returns the number of sunlit buildings. A building is considered \\"sunlit\\" if no taller building exists to its left. :param heights: List[int] List of building heights :return: int Number of sunlit buildings >>> count_sunlit_buildings([3, 6, 7, 2, 9]) 4 >>> count_sunlit_buildings([5, 4, 3, 2, 1]) 1 >>> count_sunlit_buildings([4, 5, 3, 8, 6, 10]) 4","solution":"def count_sunlit_buildings(heights): Returns the number of sunlit buildings. A building is considered \\"sunlit\\" if no taller building exists to its left. :param heights: List[int] List of building heights :return: int Number of sunlit buildings if not heights: return 0 sunlit_count = 1 max_height = heights[0] for height in heights[1:]: if height > max_height: sunlit_count += 1 max_height = height return sunlit_count"},{"question":"def longest_palindromic_subsequence(S: str) -> int: Returns the length of the longest palindromic subsequence in S. >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"bbabcbcab\\") 7 >>> longest_palindromic_subsequence(\\"abcdefg\\") 1 >>> longest_palindromic_subsequence(\\"abccba\\") 6 >>> longest_palindromic_subsequence(\\"character\\") 5 >>> longest_palindromic_subsequence(\\"aaaaa\\") 5","solution":"def longest_palindromic_subsequence(S): Returns the length of the longest palindromic subsequence in S. n = len(S) # Create a DP array to store lengths of palindromic subsequences. dp = [[0 for x in range(n)] for y in range(n)] # All substrings of length 1 are palindromic. for i in range(n): dp[i][i] = 1 # Build the DP array. for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if S[i] == S[j] and cl == 2: dp[i][j] = 2 elif S[i] == S[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # Length of longest palindromic subsequence is in dp[0][n-1]. return dp[0][n - 1]"},{"question":"def max_apples(n: int, m: int, matrix: List[List[int]]) -> int: Calculates the maximum number of apples that can be collected starting from the top-left cell to the bottom-right cell, moving only right or down. >>> max_apples(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29 >>> max_apples(1, 3, [[1, 2, 3]]) == 6 >>> max_apples(3, 1, [[1], [2], [3]]) == 6 >>> max_apples(1, 1, [[5]]) == 5 >>> max_apples(2, 2, [[0, 0], [0, 0]]) == 0 >>> max_apples(3, 3, [[1, 2, 3], [0, 1, 0], [4, 5, 6]]) == 16","solution":"def max_apples(n, m, matrix): Calculates the maximum number of apples that can be collected starting from the top-left cell to the bottom-right cell, moving only right or down. dp = [[0] * m for _ in range(n)] dp[0][0] = matrix[0][0] for i in range(n): for j in range(m): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + matrix[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + matrix[i][j]) return dp[n-1][m-1]"},{"question":"def count_green_sequences(n: int, sequence: str) -> int: Returns the number of consecutive sequences of GREEN traffic lights. Args: n (int): Number of traffic lights. sequence (str): The sequence of traffic lights. Returns: int: Number of consecutive sequences of GREEN lights. >>> count_green_sequences(8, \\"RGGGRRGG\\") 2 >>> count_green_sequences(1, \\"G\\") 1 >>> count_green_sequences(1, \\"R\\") 0 >>> count_green_sequences(5, \\"GGGGG\\") 1 >>> count_green_sequences(5, \\"RRRRR\\") 0 >>> count_green_sequences(6, \\"GRGRGR\\") 3 >>> count_green_sequences(0, \\"\\") 0","solution":"def count_green_sequences(n, sequence): Returns the number of consecutive sequences of GREEN traffic lights. Args: n (int): Number of traffic lights. sequence (str): The sequence of traffic lights. Returns: int: Number of consecutive sequences of GREEN lights. if n == 0: return 0 count = 0 in_green_sequence = False for light in sequence: if light == 'G': if not in_green_sequence: count += 1 in_green_sequence = True else: in_green_sequence = False return count"},{"question":"def productExceptSelf(nums): Construct an integer array result where result[i] is equal to the product of all the elements of nums except nums[i]. >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"def productExceptSelf(nums): n = len(nums) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"from typing import List def num_islands(grid: List[List[str]]) -> int: Determine the number of distinct islands in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You can assume all four edges of the grid are surrounded by water. Args: grid (List[List[str]]): A 2D list representing the grid where '1' is land and '0' is water. Returns: int: The number of distinct islands. Examples: >>> num_islands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 3 >>> num_islands([[\\"1\\"]]) 1 >>> num_islands([[\\"0\\"]]) 0 >>> num_islands([[\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"]]) 1 >>> num_islands([ ... [\\"1\\",\\"0\\",\\"0\\",\\"0\\",\\"1\\"], ... [\\"0\\",\\"1\\",\\"0\\",\\"0\\",\\"1\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 6 >>> num_islands([ ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ... ]) 0","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # mark as visited # explore all adjacent cells dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) num_islands += 1 return num_islands"},{"question":"def trim_scenic_prefix(label: str) -> str: Removes the 'SCN-' prefix from the label if it exists. >>> trim_scenic_prefix('SCN-MOUNTAIN') 'MOUNTAIN' >>> trim_scenic_prefix('SUNSET') 'SUNSET' >>> trim_scenic_prefix('SCN-SUNRISE') 'SUNRISE'","solution":"def trim_scenic_prefix(label): Removes the 'SCN-' prefix from the label if it exists. if label.startswith('SCN-'): return label[4:] return label"},{"question":"def min_swaps_to_beautiful_sequence(n: int, colors: List[int]) -> int: Determine the minimum number of swaps required to arrange the stamps in a sequence where no two adjacent stamps have the same color. Args: n : int : the number of stamps in the sequence colors : List[int] : the color of each stamp in the initial sequence Returns: int : the minimum number of swaps required to achieve the beautiful sequence, or -1 if it's not possible. >>> min_swaps_to_beautiful_sequence(5, [3, 3, 2, 2, 1]) 2 >>> min_swaps_to_beautiful_sequence(4, [1, 2, 1, 2]) 0 >>> min_swaps_to_beautiful_sequence(3, [7, 7, 7]) -1 >>> min_swaps_to_beautiful_sequence(1, [3]) 0 >>> min_swaps_to_beautiful_sequence(6, [1, 2, 3, 4, 5, 6]) 0","solution":"def min_swaps_to_beautiful_sequence(n, colors): from collections import defaultdict if n == 1: return 0 def is_beautiful(sequence): for i in range(len(sequence) - 1): if sequence[i] == sequence[i+1]: return False return True swap_count = 0 color_positions = defaultdict(list) for i in range(n): color_positions[colors[i]].append(i) i = 0 while i < n - 1: if colors[i] == colors[i+1]: found = False for j in range(i+2, n): if colors[j] != colors[i] and (j == n-1 or colors[j] != colors[j+1]): colors[i+1], colors[j] = colors[j], colors[i+1] swap_count += 1 found = True break if not found: return -1 i += 1 return swap_count if is_beautiful(colors) else -1"},{"question":"def has_subarray_with_sum(arr: List[int], k: int) -> bool: Determines if there is a contiguous subarray within \`arr\` whose sum equals \`k\`. :param arr: List[int] - The input array of integers. :param k: int - The target sum value. :return: bool - True if such a subarray exists, otherwise False. >>> has_subarray_with_sum([1, 2, 3, 7, 5], 12) True >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_with_sum([-1, 2, 4, -3, 5], 6) True >>> has_subarray_with_sum([1, 2, 3], 7) False","solution":"def has_subarray_with_sum(arr, k): Determines if there is a contiguous subarray within \`arr\` whose sum equals \`k\`. :param arr: List[int] - The input array of integers. :param k: int - The target sum value. :return: bool - True if such a subarray exists, otherwise False. current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == k: return True if (current_sum - k) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"def maxHistogramArea(heights): Returns the maximum rectangular area in the histogram defined by heights. Example: >>> maxHistogramArea([2, 1, 5, 6, 2, 3]) 10 >>> maxHistogramArea([2, 4]) 4","solution":"def maxHistogramArea(heights): Returns the maximum rectangular area in the histogram defined by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List, Tuple def min_abs_difference(arr: List[int]) -> int: Returns the minimum absolute difference between the sums of two subarrays. >>> min_abs_difference([1, 2, 3, 9]) 3 >>> min_abs_difference([1, 5, 11, 5, 9]) 1 >>> min_abs_difference([10]) 10 >>> min_abs_difference([10, 20]) 10 >>> min_abs_difference([100, 100, 100, 100]) 0 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns their results. >>> process_test_cases([(4, [1, 2, 3, 9]), (5, [1, 5, 11, 5, 9])]) [3, 1] pass","solution":"def min_abs_difference(arr): Returns the minimum absolute difference between the sums of two subarrays. total_sum = sum(arr) n = len(arr) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in arr: for j in range(total_sum // 2, num - 1, -1): dp[j] = dp[j] or dp[j - num] for i in range(total_sum // 2, -1, -1): if dp[i]: return total_sum - 2 * i return total_sum def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(min_abs_difference(arr)) return results"},{"question":"class Node: def __init__(self, text): self.text = text self.prev = None self.next = None class Clipboard: def __init__(self): self.head = None self.tail = None self.size = 0 def insert(self, text): Insert a new text snippet at the beginning of the clipboard history. # implementation here def retrieve(self, position): Retrieve the text snippet at a given position in the clipboard history. # implementation here def process_operations(operations): Process a series of clipboard operations (insertion and retrieval). Args: operations (List[str]): List of operations to process. Returns: List[str]: Results of retrieval operations. >>> process_operations([\\"INSERT Hello\\", \\"INSERT World\\", \\"RETRIEVE 1\\", \\"RETRIEVE 2\\", \\"INSERT Foo\\", \\"RETRIEVE 1\\"]) [\\"World\\", \\"Hello\\", \\"Foo\\"] clipboard = Clipboard() results = [] for operation in operations: parts = operation.split(\\" \\", 1) if parts[0] == \\"INSERT\\": clipboard.insert(parts[1]) elif parts[0] == \\"RETRIEVE\\": results.append(clipboard.retrieve(int(parts[1]))) return results def test_clipboard(): operations = [ \\"INSERT Hello\\", \\"INSERT World\\", \\"RETRIEVE 1\\", \\"RETRIEVE 2\\", \\"INSERT Foo\\", \\"RETRIEVE 1\\" ] result = process_operations(operations) assert result == [\\"World\\", \\"Hello\\", \\"Foo\\"] def test_empty_retrieve(): operations = [ \\"RETRIEVE 1\\" ] result = process_operations(operations) assert result == [None] def test_multiple_inserts(): operations = [ \\"INSERT First\\", \\"INSERT Second\\", \\"INSERT Third\\", \\"RETRIEVE 1\\", \\"RETRIEVE 2\\", \\"RETRIEVE 3\\" ] result = process_operations(operations) assert result == [\\"Third\\", \\"Second\\", \\"First\\"] def test_invalid_retrieve(): operations = [ \\"INSERT A\\", \\"RETRIEVE 2\\", \\"RETRIEVE 0\\" ] result = process_operations(operations) assert result == [None, None] def test_mixed_operations(): operations = [ \\"INSERT A\\", \\"INSERT B\\", \\"RETRIEVE 1\\", \\"INSERT C\\", \\"RETRIEVE 2\\", \\"RETRIEVE 3\\" ] result = process_operations(operations) assert result == [\\"B\\", \\"B\\", \\"A\\"] if __name__ == \\"__main__\\": test_clipboard() test_empty_retrieve() test_multiple_inserts() test_invalid_retrieve() test_mixed_operations() print(\\"All tests passed!\\")","solution":"class Node: def __init__(self, text): self.text = text self.prev = None self.next = None class Clipboard: def __init__(self): self.head = None self.tail = None self.size = 0 def insert(self, text): new_node = Node(text) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node self.size += 1 def retrieve(self, position): if position > self.size or position <= 0: return None current = self.head for _ in range(position - 1): current = current.next return current.text def process_operations(operations): clipboard = Clipboard() results = [] for operation in operations: parts = operation.split(\\" \\", 1) if parts[0] == \\"INSERT\\": clipboard.insert(parts[1]) elif parts[0] == \\"RETRIEVE\\": results.append(clipboard.retrieve(int(parts[1]))) return results"},{"question":"def max_weight_after_k_edges_removed(N: int, edges: List[Tuple[int, int, int]], queries: List[int]) -> List[int]: Determine the maximum weight of the smallest edge in a path from the root to any leaf node after removing k edges. Args: N (int): Number of nodes in the tree edges (List[Tuple[int, int, int]]): List of edges represented as tuples (u, v, w) where u and v are nodes and w is the weight of the edge queries (List[int]): List of queries, each representing the number of edges to be removed Returns: List[int]: List of integers where each integer is the answer to a query Example: >>> N = 5 >>> edges = [(1, 2, 3), (1, 3, 4), (1, 4, 2), (4, 5, 1)] >>> queries = [1, 2, 3] >>> max_weight_after_k_edges_removed(N, edges, queries) [1, 2, 3] pass # Test cases if __name__ == \\"__main__\\": def test_example_case(): N = 5 edges = [ (1, 2, 3), (1, 3, 4), (1, 4, 2), (4, 5, 1) ] queries = [1, 2, 3] expected = [1, 2, 3] assert max_weight_after_k_edges_removed(N, edges, queries) == expected def test_more_edges(): N = 6 edges = [ (1, 2, 6), (1, 3, 7), (2, 4, 1), (2, 5, 4), (3, 6, 3) ] queries = [1, 2, 3, 4] expected = [1, 3, 4, 6] assert max_weight_after_k_edges_removed(N, edges, queries) == expected def test_all_same_weight(): N = 4 edges = [ (1, 2, 5), (1, 3, 5), (3, 4, 5) ] queries = [1, 2, 3] expected = [5, 5, 5] assert max_weight_after_k_edges_removed(N, edges, queries) == expected def test_large_weights(): N = 3 edges = [ (1, 2, 1000000000), (1, 3, 999999999) ] queries = [1, 2] expected = [999999999, 1000000000] assert max_weight_after_k_edges_removed(N, edges, queries) == expected def test_minimal_tree(): N = 2 edges = [ (1, 2, 1) ] queries = [1] expected = [1] assert max_weight_after_k_edges_removed(N, edges, queries) == expected test_example_case() test_more_edges() test_all_same_weight() test_large_weights() test_minimal_tree()","solution":"def max_weight_after_k_edges_removed(N, edges, queries): # Sort edges by weight edges.sort(key=lambda x: x[2]) results = [] for k in queries: if k >= len(edges): # If k is high enough, return the weight of the largest remaining edge results.append(edges[-1][2]) else: # Otherwise, return the k-th heaviest edge (0-indexed) results.append(edges[k-1][2]) return results # Parsing input and calling the function if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) edges = [] index = 1 for i in range(N - 1): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 Q = int(data[index]) queries = [] for i in range(Q): queries.append(int(data[index + 1 + i])) results = max_weight_after_k_edges_removed(N, edges, queries) for result in results: print(result)"},{"question":"def highest_possible_visibility_height(grid: List[List[int]]) -> int: Determine the highest possible visibility height for cameras in the grid. Parameters: grid (list of list of int): The 2D grid containing heights of walls and cameras. Returns: int: The highest possible visibility height where no camera's view is obstructed by a wall. Examples: >>> highest_possible_visibility_height([ ... [2, -1, 3], ... [4, 1, -1], ... [5, 7, 6] ... ]) 1 >>> highest_possible_visibility_height([ ... [3, -1], ... [4, 5] ... ]) 3 >>> highest_possible_visibility_height([ ... [-1, -1], ... [-1, -1] ... ]) -1 >>> highest_possible_visibility_height([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) -1 >>> highest_possible_visibility_height([ ... [-1, 3, 2], ... [7, 1, -1], ... [5, -1, 4] ... ]) 1","solution":"def highest_possible_visibility_height(grid): Determine the highest possible visibility height for cameras in the grid. Parameters: grid (list of list of int): The 2D grid containing heights of walls and cameras. Returns: int: The highest possible visibility height where no camera's view is obstructed by a wall. R = len(grid) C = len(grid[0]) wall_heights = set() for r in range(R): for c in range(C): if grid[r][c] != -1: wall_heights.add(grid[r][c]) if not wall_heights: return -1 wall_heights = sorted(list(wall_heights)) min_camera_height = float('inf') for r in range(R): for c in range(C): if grid[r][c] == -1: min_camera_height = min(min_camera_height, wall_heights[0]) if min_camera_height == float('inf'): return -1 return min_camera_height"},{"question":"from bisect import bisect_left from typing import List def longest_increasing_subsequence_length(A: List[int]) -> int: Returns the length of the longest increasing subsequence in the array A. >>> longest_increasing_subsequence_length([5, 2, 8, 6, 3, 6]) == 3 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) == 5 pass def solve(test_cases: List[List[int]]) -> List[int]: For each test case in test_cases, computes the length of the longest increasing subsequence. >>> solve([[5, 2, 8, 6, 3, 6], [1, 2, 3, 4, 5]]) == [3, 5] >>> solve([[3, 10, 2, 1, 20], [3, 2, 1]]) == [3, 1] pass def parse_input(input_string: str) -> List[List[int]]: Parses the input string into a list of test cases. >>> parse_input(\\"2n6n5 2 8 6 3 6n5n1 2 3 4 5n\\") == [[5, 2, 8, 6, 3, 6], [1, 2, 3, 4, 5]] pass def test_longest_increasing_subsequence_length(): assert longest_increasing_subsequence_length([5, 2, 8, 6, 3, 6]) == 3 assert longest_increasing_subsequence_length([1, 2, 3, 4, 5]) == 5 assert longest_increasing_subsequence_length([3, 10, 2, 1, 20]) == 3 assert longest_increasing_subsequence_length([3, 2]) == 1 assert longest_increasing_subsequence_length([]) == 0 def test_solve(): assert solve([[5, 2, 8, 6, 3, 6], [1, 2, 3, 4, 5]]) == [3, 5] assert solve([[3, 10, 2, 1, 20], [3, 2, 1]]) == [3, 1] def test_parse_input(): input_string = \\"2n6n5 2 8 6 3 6n5n1 2 3 4 5n\\" assert parse_input(input_string) == [[5, 2, 8, 6, 3, 6], [1, 2, 3, 4, 5]] def test_integration(): input_string = \\"2n6n5 2 8 6 3 6n5n1 2 3 4 5n\\" test_cases = parse_input(input_string) assert solve(test_cases) == [3, 5]","solution":"from bisect import bisect_left def longest_increasing_subsequence_length(A): Returns the length of the longest increasing subsequence in the array A. if not A: return 0 lis = [] for num in A: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) def solve(test_cases): results = [] for A in test_cases: results.append(longest_increasing_subsequence_length(A)) return results def parse_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) A = list(map(int, input_lines[index + 1].split())) test_cases.append(A) index += 2 return test_cases"},{"question":"def time_to_words(time_str: str) -> str: Translate the given 12-hour clock time string into its corresponding words representation for hours and minutes. >>> time_to_words(\\"03:15 pm\\") \\"Three Fifteen PM\\" >>> time_to_words(\\"12:45 am\\") \\"Twelve Forty Five AM\\" >>> time_to_words(\\"06:00 am\\") \\"Six O'Clock AM\\" >>> time_to_words(\\"11:30 pm\\") \\"Eleven Thirty PM\\"","solution":"def time_to_words(time_str): Converts a 12-hour clock time string (hh:mm am/pm) into its corresponding words representation. Args: - time_str (str): The time string to be converted. Returns: - str: The word representation of the time. num_to_words = { '00': \\"O'Clock\\", '01': 'One', '02': 'Two', '03': 'Three', '04': 'Four', '05': 'Five', '06': 'Six', '07': 'Seven', '08': 'Eight', '09': 'Nine', '10': 'Ten', '11': 'Eleven', '12': 'Twelve', '13': 'Thirteen', '14': 'Fourteen', '15': 'Fifteen', '16': 'Sixteen', '17': 'Seventeen', '18': 'Eighteen', '19': 'Nineteen', '20': 'Twenty', '21': 'Twenty One', '22': 'Twenty Two', '23': 'Twenty Three', '24': 'Twenty Four', '25': 'Twenty Five', '26': 'Twenty Six', '27': 'Twenty Seven', '28': 'Twenty Eight', '29': 'Twenty Nine', '30': 'Thirty', '31': 'Thirty One', '32': 'Thirty Two', '33': 'Thirty Three', '34': 'Thirty Four', '35': 'Thirty Five', '36': 'Thirty Six', '37': 'Thirty Seven', '38': 'Thirty Eight', '39': 'Thirty Nine', '40': 'Forty', '41': 'Forty One', '42': 'Forty Two', '43': 'Forty Three', '44': 'Forty Four', '45': 'Forty Five', '46': 'Forty Six', '47': 'Forty Seven', '48': 'Forty Eight', '49': 'Forty Nine', '50': 'Fifty', '51': 'Fifty One', '52': 'Fifty Two', '53': 'Fifty Three', '54': 'Fifty Four', '55': 'Fifty Five', '56': 'Fifty Six', '57': 'Fifty Seven', '58': 'Fifty Eight', '59': 'Fifty Nine' } time_parts = time_str.split() time, period = time_parts[0], time_parts[1] hours, minutes = time.split(':') hour_word = num_to_words[hours] if minutes == '00': minute_word = \\"O'Clock\\" else: minute_word = num_to_words[minutes] return f\\"{hour_word} {minute_word} {period.upper()}\\""},{"question":"def min_removals_to_make_valid_parentheses(s: str) -> int: Returns the minimum number of characters that need to be removed to make the string of parentheses valid. Args: s (str): A string consisting of characters '(' and ')' Returns: int: The minimum number of characters that need to be removed >>> min_removals_to_make_valid_parentheses(\\"(()())\\") == 0 >>> min_removals_to_make_valid_parentheses(\\"(())\\") == 0 >>> min_removals_to_make_valid_parentheses(\\"(()())((\\") == 2 >>> min_removals_to_make_valid_parentheses(\\"((())\\") == 1 >>> min_removals_to_make_valid_parentheses(\\"(()))\\") == 1 >>> min_removals_to_make_valid_parentheses(\\"\\") == 0 >>> min_removals_to_make_valid_parentheses(\\"((((\\") == 4 >>> min_removals_to_make_valid_parentheses(\\"))))\\") == 4 >>> min_removals_to_make_valid_parentheses(\\")()(\\") == 2 >>> min_removals_to_make_valid_parentheses(\\"())(()\\") == 2 >>> min_removals_to_make_valid_parentheses(\\"((()()\\") == 2 >>> min_removals_to_make_valid_parentheses(\\")))(((\\") == 6","solution":"def min_removals_to_make_valid_parentheses(s): Returns the minimum number of characters that need to be removed to make the string of parentheses valid. open_count = 0 close_count = 0 for char in s: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 else: close_count += 1 return open_count + close_count"},{"question":"def can_store_gadgets(G: int, M: int, N: int, capacities: List[List[int]]) -> str: Determines if it is possible to store all the gadgets in the warehouse. Parameters: G (int): The total number of gadgets that need to be stored. M (int): Number of rows in the warehouse grid. N (int): Number of columns in the warehouse grid. capacities (list of list of int): The capacity of each section in the warehouse. Returns: str: \\"YES\\" if it is possible to store all the gadgets, otherwise \\"NO\\". Examples: >>> can_store_gadgets(100, 3, 3, [[10, 20, 30], [10, 5, 5], [10, 5, 5]]) 'YES' >>> can_store_gadgets(250, 2, 2, [[10, 20], [10, 5]]) 'NO'","solution":"def can_store_gadgets(G, M, N, capacities): Determines if it is possible to store all the gadgets in the warehouse. Parameters: G (int): The total number of gadgets that need to be stored. M (int): Number of rows in the warehouse grid. N (int): Number of columns in the warehouse grid. capacities (list of list of int): The capacity of each section in the warehouse. Returns: str: \\"YES\\" if it is possible to store all the gadgets, otherwise \\"NO\\". total_capacity = 0 for row in capacities: total_capacity += sum(row) if total_capacity >= G: return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence with consecutive elements. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([3, 9, 50, 2, 8, 4, 7, 1, 5]) 5 >>> longest_consecutive_subsequence([0, 0, -1]) 2 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([10, 20, 30, 40]) 1","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence with consecutive elements. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # This means num is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def reverse_integer(n: int) -> int: Reverses the digits of an integer. If the integer is negative, the reversed integer will also be negative. Parameters: n (int): The integer to be reversed. Returns: int: The reversed integer. def test_reverse_positive_number(): assert reverse_integer(123) == 321 def test_reverse_negative_number(): assert reverse_integer(-456) == -654 def test_reverse_number_with_zero(): assert reverse_integer(100) == 1 def test_reverse_single_digit(): assert reverse_integer(5) == 5 def test_reverse_large_number(): assert reverse_integer(1234567890) == 987654321 def test_reverse_negative_number_with_zero(): assert reverse_integer(-1000) == -1 def test_reverse_zero(): assert reverse_integer(0) == 0","solution":"def reverse_integer(n): Reverses the digits of an integer. If the integer is negative, the reversed integer will also be negative. Parameters: n (int): The integer to be reversed. Returns: int: The reversed integer. str_n = str(n) if str_n[0] == '-': reversed_str = '-' + str_n[:0:-1] else: reversed_str = str_n[::-1] return int(reversed_str)"},{"question":"def count_completed_tasks(S: str) -> int: Takes a string S of length 8 consisting of '0's and '1's. Returns the number of '1's in the string S. >>> count_completed_tasks('11111111') 8 >>> count_completed_tasks('00000000') 0 >>> count_completed_tasks('10101010') 4","solution":"def count_completed_tasks(S): Takes a string S of length 8 consisting of '0's and '1's. Returns the number of '1's in the string S. return S.count('1')"},{"question":"def is_path_to_bottom_right(n: int, m: int, grid: List[List[int]]) -> str: Determines if there is a path from the top-left to the bottom-right corner of the grid without hitting any asteroids. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: n x m grid represented as a list of lists :return: \\"YES\\" if there is a path, otherwise \\"NO\\" >>> is_path_to_bottom_right(3, 3, [[0, 1, 0], [0, 0, 0], [1, 0, 0]]) == \\"YES\\" >>> is_path_to_bottom_right(3, 3, [[0, 1, 0], [1, 0, 1], [1, 1, 0]]) == \\"NO\\" >>> is_path_to_bottom_right(1, 1, [[0]]) == \\"YES\\" >>> is_path_to_bottom_right(2, 2, [[0, 1], [1, 0]]) == \\"NO\\" >>> is_path_to_bottom_right(4, 4, [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]) == \\"YES\\"","solution":"def is_path_to_bottom_right(n, m, grid): Determines if there is a path from the top-left to the bottom-right corner of the grid without hitting any asteroids. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: n x m grid represented as a list of lists :return: \\"YES\\" if there is a path, otherwise \\"NO\\" if n == 0 or m == 0: return \\"NO\\" # Initialize dp matrix with False dp = [[False] * m for _ in range(n)] dp[0][0] = True # Starting point # Fill the dp matrix for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = False else: if i > 0: dp[i][j] = dp[i][j] or dp[i-1][j] if j > 0: dp[i][j] = dp[i][j] or dp[i][j-1] return \\"YES\\" if dp[n-1][m-1] else \\"NO\\""},{"question":"def longest_consecutive_hydrated_days(n: int, goal: int, intake: List[int]) -> int: Returns the length of the longest consecutive sequence of days where the water intake met or exceeded the goal. Parameters: n (int): Number of days goal (int): Daily water intake goal in milliliters intake (List[int]): Water intake data for each day Returns: int: Length of longest consecutive sequence meeting the goal >>> longest_consecutive_hydrated_days(7, 1500, [1600, 1800, 1200, 1500, 2000, 1300, 1700]) 2 >>> longest_consecutive_hydrated_days(5, 1000, [800, 900, 950, 1000, 1100]) 2 >>> longest_consecutive_hydrated_days(6, 2000, [2200, 2300, 2100, 1800, 1900, 2500]) 3 >>> longest_consecutive_hydrated_days(3, 2000, [1500, 1600, 1700]) 0 >>> longest_consecutive_hydrated_days(4, 1000, [1000, 1200, 1300, 1100]) 4 >>> longest_consecutive_hydrated_days(1, 500, [600]) 1 >>> longest_consecutive_hydrated_days(3, 800, [800, 800, 800]) 3","solution":"def longest_consecutive_hydrated_days(n, goal, intake): Returns the length of the longest consecutive sequence of days where the water intake met or exceeded the goal. Parameters: n (int): Number of days goal (int): Daily water intake goal in milliliters intake (list of int): Water intake data for each day Returns: int: Length of longest consecutive sequence meeting the goal longest_streak = 0 current_streak = 0 for water in intake: if water >= goal: current_streak += 1 longest_streak = max(longest_streak, current_streak) else: current_streak = 0 return longest_streak"},{"question":"def smallest_lexicographic_subsequence(s: str) -> str: Sammy has a sequence of letters s which consists of lowercase English letters only. He wants to find the lexicographically smallest subsequence of s that contains all the distinct characters present in s. Parameters: s (str): The input string. Returns: str: The lexicographically smallest subsequence that contains all the distinct characters in s. Example: >>> smallest_lexicographic_subsequence(\\"cbacdcbc\\") \\"acdb\\" >>> smallest_lexicographic_subsequence(\\"bcabc\\") \\"abc\\"","solution":"def smallest_lexicographic_subsequence(s): from collections import Counter # Count the frequency of each character in the string counter = Counter(s) # To store the characters in the resulting subsequence result = [] # To keep track if a character is currently in the result stack in_result = set() for char in s: counter[char] -= 1 if char in in_result: continue # Maintain lexicographical order while result and char < result[-1] and counter[result[-1]] > 0: in_result.remove(result.pop()) result.append(char) in_result.add(char) return ''.join(result)"},{"question":"def max_subarray_sum(arr, start, end): Finds the maximum sum of any subarray of the subarray defined by start and end indices. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4], 0, 3) 4 >>> max_subarray_sum([1, 2, 3, 4, 5], 0, 4) 15 >>> max_subarray_sum([1, -1, 2, -2, 3], 2, 2) 2 >>> max_subarray_sum([-3, -2, -1], 0, 2) -1 >>> max_subarray_sum([3, -2, 5, -1, 2, -3], 1, 4) 6 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3], 2, 6) 7 >>> max_subarray_sum([-8, -3, -6, -2, -5, -4], 1, 4) -2 >>> max_subarray_sum([1, 2, 3, 4, 5], 0, 2) 6","solution":"def max_subarray_sum(arr, start, end): Finds the maximum sum of any subarray of the subarray defined by start and end indices. subarray = arr[start:end+1] current_sum = 0 max_sum = float('-inf') for num in subarray: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def maxTasks(maxTime: int, tasks: List[int]) -> int: Returns the maximum number of tasks that can be completed without exceeding the given total time limit. Parameters: maxTime (int): The maximum allowed total duration for the tasks. tasks (list of int): A list of positive integers where each integer indicates the duration of a task. Returns: int: The maximum number of tasks that can be completed. pass # Test cases def test_example_case_1(): assert maxTasks(10, [2, 3, 1, 5, 4]) == 4 def test_example_case_2(): assert maxTasks(7, [4, 2, 3, 2]) == 3 def test_all_tasks_can_be_completed(): assert maxTasks(15, [3, 2, 4, 5, 1]) == 5 def test_no_tasks_can_be_completed(): assert maxTasks(1, [2, 3, 4, 5]) == 0 def test_single_task_just_under_limit(): assert maxTasks(5, [1, 2, 3, 4]) == 2 def test_single_task_over_limit(): assert maxTasks(3, [4, 5, 6]) == 0 def test_all_same_duration_less_than_max(): assert maxTasks(12, [3, 3, 3, 3, 3]) == 4 def test_all_same_duration_equal_to_max(): assert maxTasks(9, [3, 3, 3]) == 3 def test_large_input_case(): assert maxTasks(100, [1]*100) == 100","solution":"def maxTasks(maxTime, tasks): Returns the maximum number of tasks that can be completed without exceeding the given total time limit. Parameters: maxTime (int): The maximum allowed total duration for the tasks. tasks (list of int): A list of positive integers where each integer indicates the duration of a task. Returns: int: The maximum number of tasks that can be completed. # Sort the tasks by duration in ascending order tasks.sort() total_time = 0 task_count = 0 # Iterate over the tasks and count how many can be completed within the limit for task in tasks: if total_time + task <= maxTime: total_time += task task_count += 1 else: break return task_count"},{"question":"def calculate_plant_ranks(N: int, D: int, growth_rates: List[int]) -> List[int]: Calculate the ranks of the plants based on their final heights after D days. Args: N (int): The number of plants. D (int): The number of days to consider for their growth. growth_rates (List[int]): A list of positive integers indicating the growth rate of each plant per day. Returns: List[int]: A list of integers where the index corresponds to the plant and the value is its rank based on its final height after D days. Example: >>> calculate_plant_ranks(6, 3, [10, 15, 20, 25, 30, 5]) [5, 4, 3, 2, 1, 6] >>> calculate_plant_ranks(3, 7, [1, 2, 3]) [3, 2, 1]","solution":"def calculate_plant_ranks(N, D, growth_rates): # Calculate the final heights of the plants final_heights = [(rate * D, i) for i, rate in enumerate(growth_rates)] # Sort the heights in descending order while maintaining their original indices final_heights.sort(reverse=True, key=lambda x: x[0]) # Create a rank map where the index is the original plant index and the value is the rank rank_map = [0] * N for rank, (height, original_index) in enumerate(final_heights, 1): rank_map[original_index] = rank return rank_map"},{"question":"def min_trucks(t: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Calculate the minimum number of trucks needed to transport all the packages. The first parameter \`t\` represents the number of test cases. The second parameter \`cases\` is a list of tuples, where each tuple contains: - A tuple with two integers \`n\` and \`C\`, where \`n\` is the number of packages and \`C\` is the carrying capacity of each truck. - A list of integers \`w1, w2, ..., wn\` representing the weights of the packages. Returns a list of integers, where each integer represents the minimum number of trucks required for the corresponding test case. >>> min_trucks(2, [[(5, 200), [100, 100, 100, 100, 100]], [(6, 100), [90, 30, 60, 10, 40, 70]]]) [3, 4]","solution":"def min_trucks(t, cases): results = [] for case in cases: n, C = case[0] weights = sorted(case[1], reverse=True) trucks = 0 while weights: current_load = 0 for i in range(len(weights)-1, -1, -1): if current_load + weights[i] <= C: current_load += weights.pop(i) trucks += 1 results.append(trucks) return results # Example usage: # cases = [ # [(5, 200), [100, 100, 100, 100, 100]], # [(6, 100), [90, 30, 60, 10, 40, 70]] # ] # print(min_trucks(2, cases)) # Output: [3, 4]"},{"question":"def my_sum(iterable, start=0): Returns the sum of the given iterable, starting with an initial value of \`start\`. Mimics the behavior of the built-in sum function. Parameters: iterable: An iterable of numbers (e.g., list, tuple) to be summed. start (optional): The starting value of the summation (default is 0). Returns: The sum of the elements in the iterable plus the starting value. >>> my_sum([1, 2, 3]) 6 >>> my_sum([1.1, 2.2, 3.3]) 6.6 >>> my_sum([1, 2, 3], 5) 11 >>> my_sum([]) 0 >>> my_sum([], 10) 10 >>> my_sum([1, 2.2, 3]) 6.2 >>> my_sum([1.1, 2, 3.3]) 6.4 >>> my_sum([5]) 5 >>> my_sum([5], 10) 15 >>> my_sum([5.5]) 5.5 >>> my_sum([5.5], 4.5) 10.0","solution":"def my_sum(iterable, start=0): Returns the sum of the given iterable, starting with an initial value of \`start\`. Mimics the behavior of the built-in sum function. Parameters: iterable: An iterable of numbers (e.g., list, tuple) to be summed. start (optional): The starting value of the summation (default is 0). Returns: The sum of the elements in the iterable plus the starting value. total = start for item in iterable: total += item return total"},{"question":"def determine_winner(P1: int, P2: int) -> str: Determines the winner of the game given the initial number of stones in Alice's pile (P1) and Bob's pile (P2). Alice always goes first. The players play optimally. Returns \\"Alice\\" if Alice wins, and \\"Bob\\" if Bob wins. >>> determine_winner(4, 7) \\"Alice\\" >>> determine_winner(3, 4) \\"Bob\\"","solution":"def determine_winner(P1, P2): Determines the winner of the game given the initial number of stones in Alice's pile (P1) and Bob's pile (P2). Alice always goes first. The players play optimally. Returns \\"Alice\\" if Alice wins, and \\"Bob\\" if Bob wins. if P1 >= P2: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def is_transformable(initial: str, target: str) -> bool: Check if the initial string can be transformed into the target string using the given operations. # Implement your logic here. def transformation_possible(t: int, test_cases: List[Tuple[int, str, str]]) -> List[str]: For multiple test cases, determine if the initial string can be transformed into the target string. Args: t (int): The number of test cases test_cases (List[Tuple[int, str, str]]): A list of tuples, each containing: - an integer representing the length of the strings - the initial string of lowercase alphabets - the target string of lowercase alphabets Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case # Implement your logic here. from typing import List, Tuple # Test cases def test_is_transformable(): assert is_transformable(\\"abcde\\", \\"cdeab\\") == True assert is_transformable(\\"abcd\\", \\"dcba\\") == True assert is_transformable(\\"xyz\\", \\"yza\\") == False assert is_transformable(\\"aaabbb\\", \\"bbbaaa\\") == True assert is_transformable(\\"abc\\", \\"def\\") == False def test_transformation_possible(): test_cases = [ (5, \\"abcde\\", \\"cdeab\\"), (4, \\"abcd\\", \\"dcba\\"), (3, \\"xyz\\", \\"yza\\"), ] assert transformation_possible(3, test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [ (6, \\"aabbcc\\", \\"ccbbaa\\"), (6, \\"abcdef\\", \\"fedcba\\"), (6, \\"aaaaaa\\", \\"bbbbbb\\"), ] assert transformation_possible(3, test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_transformable(initial, target): Check if the initial string can be transformed into the target string using the given operations. # Check if initial and target strings have same set of characters sorted_initial = sorted(initial) sorted_target = sorted(target) return sorted_initial == sorted_target def transformation_possible(t, test_cases): results = [] for i in range(t): n, initial, target = test_cases[i] if is_transformable(initial, target): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def combinationSum(arr, target): Given an array of integers \`arr\` and an integer \`sum\`, find all unique combinations in \`arr\` where the candidate numbers sum to \`sum\`. The same repeated number may be chosen from \`arr\` an unlimited number of times. >>> combinationSum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combinationSum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combinationSum([2], 4) [[2, 2]] >>> combinationSum([2, 3, 5], 10) [[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 3, 5], [5, 5]] >>> combinationSum([], 7) [] >>> combinationSum([2, 3], 0) [[]]","solution":"def combinationSum(arr, target): def backtrack(remain, comb, start): if remain == 0: result.append(list(comb)) return elif remain < 0: return for i in range(start, len(arr)): comb.append(arr[i]) backtrack(remain - arr[i], comb, i) comb.pop() result = [] arr.sort() backtrack(target, [], 0) return result"},{"question":"def evaluate_addition_expression(expression): Evaluate a given string representing a mathematical addition expression and return the integer result. :param expression: str, a string containing numbers and '+' operators :return: int, the result of the addition >>> evaluate_addition_expression(\\"12+34+5\\") 51 >>> evaluate_addition_expression(\\"7+3+8+2\\") 20 >>> evaluate_addition_expression(\\"42\\") 42 >>> evaluate_addition_expression(\\"1+2+3\\") 6 >>> evaluate_addition_expression(\\"100+200+300\\") 600","solution":"def evaluate_addition_expression(expression): Evaluate a given string representing a mathematical addition expression and return the integer result. :param expression: str, a string containing numbers and '+' operators :return: int, the result of the addition # Split the expression by the '+' character numbers = expression.split('+') # Convert each part to an integer and calculate the sum result = sum(int(num) for num in numbers) return result"},{"question":"def largest_empty_square(H: int, W: int, grid: List[str]) -> int: Returns the area of the largest contiguous square containing only empty segments. >>> largest_empty_square(5, 5, [\\"N....\\", \\"..N..\\", \\".....\\", \\".N...\\", \\".....\\"]) == 9 >>> largest_empty_square(1, 1, [\\".\\"]) == 1 >>> largest_empty_square(1, 1, [\\"N\\"]) == 0 >>> largest_empty_square(3, 3, [\\"NNN\\", \\"NNN\\", \\"NNN\\"]) == 0 >>> largest_empty_square(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) == 9 >>> largest_empty_square(3, 3, [\\"N.N\\", \\".N.\\", \\"N.N\\"]) == 1 >>> largest_empty_square(5, 5, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]) == 25 >>> largest_empty_square(2, 2, [\\"N.\\", \\"..\\"]) == 1","solution":"def largest_empty_square(H, W, grid): Returns the area of the largest contiguous square containing only empty segments. if H == 0 or W == 0: return 0 dp = [[0] * W for _ in range(H)] max_side = 0 for i in range(H): for j in range(W): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side # Sample usage with an example input H, W = 5, 5 grid = [ \\"N....\\", \\"..N..\\", \\".....\\", \\".N...\\", \\".....\\" ] print(largest_empty_square(H, W, grid)) # Output: 9"},{"question":"from typing import List, Tuple def is_sequence_divisible(n: int, k: int, sequence: List[int]) -> str: Checks if the sequence can be divided into one or more sub-sequences with an increment step value of exactly k. Args: n (int): Number of integers in the sequence. k (int): The step value. sequence (List[int]): The sequence of integers. Returns: str: \\"YES\\" if the sequence can be entirely divided into sub-sequences with step value k, otherwise \\"NO\\". Example: >>> is_sequence_divisible(6, 2, [1, 3, 5, 7, 9, 11]) 'YES' >>> is_sequence_divisible(5, 3, [2, 5, 8, 10, 13]) 'NO' def sequence_division_test(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Evaluates multiple test cases to determine if the sequences are divisible with specific step values. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of tuples, each containing n, k, and the sequence. Returns: List[str]: A list of results for each test case, \\"YES\\" or \\"NO\\". Example: >>> sequence_division_test([(6, 2, [1, 3, 5, 7, 9, 11]), (5, 3, [2, 5, 8, 10, 13])]) ['YES', 'NO'] from solution import sequence_division_test def test_sequence_division_all_stepping(): test_cases = [ (6, 2, [1, 3, 5, 7, 9, 11]), # YES (5, 3, [2, 5, 8, 11, 14]), # YES ] results = sequence_division_test(test_cases) assert results == ['YES', 'YES'] def test_sequence_division_some_stepping(): test_cases = [ (5, 3, [2, 5, 8, 10, 13]), # NO (4, 1, [1, 2, 2, 3]), # NO ] results = sequence_division_test(test_cases) assert results == ['NO', 'NO'] def test_sequence_division_single_step(): test_cases = [ (1, 1, [10000]), # YES (3, 1, [1, 2, 3]), # YES ] results = sequence_division_test(test_cases) assert results == ['YES', 'YES'] def test_sequence_division_varying_steps(): test_cases = [ (5, 10, [10, 20, 30, 40, 50]), # YES (5, 2, [1, 3, 5, 8, 10]), # NO ] results = sequence_division_test(test_cases) assert results == ['YES', 'NO']","solution":"def is_sequence_divisible(n, k, sequence): Checks if the sequence can be divided into one or more sub-sequences with an increment step value of exactly k. for i in range(1, n): if sequence[i] - sequence[i - 1] != k: return \\"NO\\" return \\"YES\\" def sequence_division_test(test_cases): results = [] for case in test_cases: n, k, sequence = case results.append(is_sequence_divisible(n, k, sequence)) return results"},{"question":"def maxTasks(tasks): Returns the maximum number of non-overlapping tasks. Args: tasks (list of tuples): Each tuple contains (start_time, end_time). Returns: int: Maximum number of non-overlapping tasks. Examples: >>> maxTasks([(1, 3), (2, 5), (4, 6)]) 2 >>> maxTasks([(1, 2), (3, 4), (0, 1)]) 3","solution":"def maxTasks(tasks): Returns the maximum number of non-overlapping tasks. Args: tasks (list of tuples): Each tuple contains (start_time, end_time). Returns: int: Maximum number of non-overlapping tasks. # Sort tasks based on their end_time tasks.sort(key=lambda x: x[1]) # Initialize the count and the end_time of the last selected task count = 0 last_end_time = 0 # Iterate through the tasks for task in tasks: if task[0] >= last_end_time: count += 1 last_end_time = task[1] return count"},{"question":"def min_puzzles_to_solve(N: int, difficulties: List[int]) -> int: Returns the minimum number of puzzles the student has to solve if they are allowed to skip one puzzle. >>> min_puzzles_to_solve(5, [1, 2, 3, 4, 5]) 4 >>> min_puzzles_to_solve(4, [2, 3, 5, 6]) 3 pass # Your implementation here","solution":"def min_puzzles_to_solve(n, difficulties): Returns the minimum number of puzzles to be solved when student is allowed to skip one puzzle. return n - 1"},{"question":"def findTwoSumIndices(arr: List[int], T: int) -> List[int]: Given an array of integers and a target integer T, determine if there are two distinct numbers in the array that add up to T. Return their indices. If multiple pairs, return the first pair found. If no such pair exists, return an empty list. >>> findTwoSumIndices([2, 7, 11, 15], 9) [0, 1] >>> findTwoSumIndices([1, 3, 4, 2], 6) [2, 3] >>> findTwoSumIndices([1, 2, 3, 4], 8) [] >>> findTwoSumIndices([3, 4], 7) [0, 1] >>> findTwoSumIndices([1000000000, -1000000000, 3, 4], 0) [0, 1] >>> findTwoSumIndices([5, 5, 5, 5], 10) [0, 1]","solution":"def findTwoSumIndices(arr, T): Returns the indices of the two distinct numbers in the array that add up to T. num_to_index = {} for i, num in enumerate(arr): complement = T - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing integers and the operators +, -, *, /. The operators follow standard precedence rules. >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"10+2*6\\") == 22 >>> evaluate_expression(\\"100*2+12\\") == 212 >>> evaluate_expression(\\"100*(2+12)/14\\") == 100","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing integers and the operators +, -, *, /. The operators follow standard precedence rules. def helper(s, start): stack = [] num = 0 sign = '+' while start < len(s): char = s[start] if char.isdigit(): num = num * 10 + int(char) if char == '(': num, start = helper(s, start + 1) if char in \\"+-*/)\\" or start == len(s) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) if char == ')': return sum(stack), start num = 0 sign = char start += 1 return sum(stack) return helper(expression, 0)"},{"question":"from typing import List def longest_increasing_subsequence_length(sequence: List[int]) -> int: Find the length of the longest strictly increasing subsequence in the given sequence. >>> longest_increasing_subsequence_length([5, 2, 8, 6, 3, 6]) 3 >>> longest_increasing_subsequence_length([10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> longest_increasing_subsequence_length([]) 0 >>> longest_increasing_subsequence_length([5]) 1","solution":"from bisect import bisect_left def longest_increasing_subsequence_length(sequence): if not sequence: return 0 # This will store the end elements of increasing subsequences subseq_end_elements = [] for num in sequence: idx = bisect_left(subseq_end_elements, num) if idx == len(subseq_end_elements): subseq_end_elements.append(num) else: subseq_end_elements[idx] = num return len(subseq_end_elements)"},{"question":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. Parameters: tasks (list of tuples): A list of tuples where each tuple consists of two integers representing the start and end time of a task. Returns: int: The maximum number of non-overlapping tasks. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 5 >>> max_non_overlapping_tasks([(1, 4), (4, 7), (7, 9)]) 3 >>> max_non_overlapping_tasks([(1, 3), (2, 4), (3, 5), (5, 6)]) 3 >>> max_non_overlapping_tasks([(1, 100)]) 1 >>> max_non_overlapping_tasks([(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_tasks([(i, i + 1) for i in range(100000)]) 100000","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. Parameters: tasks (list of tuples): A list of tuples where each tuple consists of two integers representing the start and end time of a task. Returns: int: The maximum number of non-overlapping tasks. # Sorting tasks based on their end times sorted_tasks = sorted(tasks, key=lambda x: x[1]) # Initialize the count of non-overlapping tasks count = 0 current_end_time = 0 for start, end in sorted_tasks: if start >= current_end_time: count += 1 current_end_time = end return count"},{"question":"def find_first_and_last_ticket_purchasers(tickets: List[Tuple[str, str]]) -> Tuple[str, str]: Given a list of tickets purchased by individuals during different time intervals, find out who bought the ticket first and who bought the ticket last. Args: tickets (List[Tuple[str, str]]): A list where each entry is a tuple containing a person's name and the time of ticket purchase in HH:MM format. Returns: Tuple[str, str]: A tuple containing two strings: - The name of the person who bought the first ticket. - The name of the person who bought the last ticket. >>> find_first_and_last_ticket_purchasers([(\\"Alice\\", \\"09:30\\"), (\\"Bob\\", \\"10:15\\"), (\\"Alice\\", \\"11:00\\"), (\\"Charlie\\", \\"08:45\\")]) ('Charlie', 'Alice') >>> find_first_and_last_ticket_purchasers([(\\"Alice\\", \\"12:00\\"), (\\"Bob\\", \\"10:15\\"), (\\"Alice\\", \\"11:00\\"), (\\"Charlie\\", \\"08:45\\")]) ('Charlie', 'Alice') >>> find_first_and_last_ticket_purchasers([(\\"Alice\\", \\"13:00\\"), (\\"Bob\\", \\"10:15\\"), (\\"Charlie\\", \\"14:45\\"), (\\"Alice\\", \\"11:00\\")]) ('Bob', 'Charlie') >>> find_first_and_last_ticket_purchasers([(\\"Alice\\", \\"09:30\\")]) ('Alice', 'Alice')","solution":"def find_first_and_last_ticket_purchasers(tickets): # Parse the tickets into a list of tuples parsed_tickets = [(name, time) for name, time in tickets] # Sort the tickets based on the time sorted_tickets = sorted(parsed_tickets, key=lambda x: x[1]) # First ticket buyer first_ticket_buyer = sorted_tickets[0][0] # Last ticket buyer last_ticket_buyer = sorted_tickets[-1][0] return first_ticket_buyer, last_ticket_buyer"},{"question":"from typing import List def find_k_largest_elements(matrix: List[List[int]], n: int, k: int) -> List[int]: Finds the k largest elements in an n x n matrix and returns them in a sorted list in descending order. Args: matrix (List[List[int]]): The n x n matrix of integers. n (int): The size of the matrix. k (int): The number of largest elements to find. Returns: List[int]: A list containing the k largest elements in descending order. Example: >>> find_k_largest_elements([ ... [10, 20, 30, 40], ... [15, 25, 35, 45], ... [27, 29, 37, 48], ... [32, 33, 39, 50] ... ], 4, 3) [50, 48, 45] >>> find_k_largest_elements([ ... [5, 3], ... [2, 8] ... ], 2, 2) [8, 5]","solution":"def find_k_largest_elements(matrix, n, k): Finds the k largest elements in an n x n matrix and returns them in a sorted list in descending order. # Flatten the matrix into a single list flat_list = [element for row in matrix for element in row] # Sort the flattened list in descending order flat_list.sort(reverse=True) # Return the first k elements return flat_list[:k]"},{"question":"def max_shortest_distance(N: int, M: int) -> int: Returns the maximum possible shortest distance to the closest water station for any kilometer on the track of length N with M water stations. >> max_shortest_distance(10, 3) 4 >> max_shortest_distance(15, 5) 3 >> max_shortest_distance(5, 2) 3 >> max_shortest_distance(2, 1) 2 >> max_shortest_distance(10, 10) 1 >> max_shortest_distance(999983, 500000) 2","solution":"def max_shortest_distance(N, M): Returns the maximum possible shortest distance to the closest water station for any kilometer on the track of length N with M water stations. # The maximum shortest distance to a water station that can be achieved # with M water stations is essentially the minimum length of the segment # of track between two water stations. import math # We need to determine the maximum possible distance between two adjacent water stations. # This is done by evenly distributing M water stations along the N kilometers track. return math.ceil(N / M)"},{"question":"def longest_common_subsequence(arr1: List[int], arr2: List[int]) -> int: Find the length of the longest common subsequence (LCS) of two arrays. >>> longest_common_subsequence([3, 4, 9, 1], [5, 3, 8, 9, 10, 2, 1]) 3 >>> longest_common_subsequence([1, 2, 3], [4, 5, 6]) 0 >>> longest_common_subsequence([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 5","solution":"def longest_common_subsequence(arr1, arr2): Finds the length of the longest common subsequence (LCS) of two arrays. m = len(arr1) n = len(arr2) # Create a 2D array to store the lengths of LCS dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m): for j in range(n): if arr1[i] == arr2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) # The value in dp[m][n] will be the length of LCS return dp[m][n] # Example usage # arr1 = [3, 4, 9, 1] # arr2 = [5, 3, 8, 9, 10, 2, 1] # print(longest_common_subsequence(arr1, arr2)) # Output: 3"},{"question":"def process_skyline_queries(T: int, test_cases: List[Tuple[int, List[int], int, List[Union[Tuple[int, int, int], Tuple[int, int, int, int]]]]]) -> List[int]: Processes the skyline queries and returns the results for each query of type \`0 l r\`. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int], int, List[Union[Tuple[int, int, int], Tuple[int, int, int, int]]]]]): Each test case contains: - An integer N denoting the number of buildings - A list of integers representing the height of each building - An integer Q denoting the number of queries - A list of queries which can be of type \`0 l r\` or \`1 l r h\` Returns: List[int]: Heights of the tallest buildings for each query of type \`0 l r\`. Example: >>> process_skyline_queries(1, [(5, [1, 3, 4, 2, 5], 3, [(0, 1, 3), (1, 0, 2, 3), (0, 0, 4)])]) [4, 7] >>> process_skyline_queries(1, [(5, [1, 3, 4, 2, 5], 2, [(1, 0, 4, 1), (0, 0, 4)])]) [6]","solution":"def process_skyline_queries(T, test_cases): results = [] for case in test_cases: N, heights, Q, queries = case for query in queries: if query[0] == 0: l, r = query[1], query[2] results.append(max(heights[l:r+1])) elif query[0] == 1: l, r, h = query[1], query[2], query[3] for i in range(l, r+1): heights[i] += h return results"},{"question":"def max_difference_after_swap(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum possible difference between the maximum and minimum values of the array after exactly one swap operation. :param t: Number of test cases :param test_cases: A list of tuples, each containing: - an integer n: the number of elements in the array - a list of integers: the elements of the array :returns: A list of integers, each representing the maximum possible difference for each test case >>> max_difference_after_swap(3, [(4, [1, 5, 3, 7]), (3, [-5, -15, 5]), (5, [1, 2, 3, 4, 5])]) [6, 20, 4] >>> max_difference_after_swap(2, [(2, [1, 100]), (3, [-10, 0, 10])]) [99, 20] from solution import max_difference_after_swap def test_case_1(): t = 3 test_cases = [ [4, [1, 5, 3, 7]], [3, [-5, -15, 5]], [5, [1, 2, 3, 4, 5]] ] expected_results = [6, 20, 4] assert max_difference_after_swap(t, test_cases) == expected_results def test_case_2(): t = 2 test_cases = [ [2, [1, 100]], [3, [-10, 0, 10]] ] expected_results = [99, 20] assert max_difference_after_swap(t, test_cases) == expected_results def test_case_3(): t = 1 test_cases = [ [3, [5, 5, 5]] ] expected_result = [0] assert max_difference_after_swap(t, test_cases) == expected_result def test_case_4(): t = 1 test_cases = [ [6, [1, 4, 5, 3, 4, 2]] ] expected_result = [4] assert max_difference_after_swap(t, test_cases) == expected_result def test_case_5(): t = 1 test_cases = [ [4, [-1, -4, -3, -2]] ] expected_result = [3] assert max_difference_after_swap(t, test_cases) == expected_result","solution":"def max_difference_after_swap(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] nums = test_cases[i][1] original_max = max(nums) original_min = min(nums) result = original_max - original_min for j in range(n): for k in range(j + 1, n): nums[j], nums[k] = nums[k], nums[j] swapped_max = max(nums) swapped_min = min(nums) result = max(result, swapped_max - swapped_min) nums[j], nums[k] = nums[k], nums[j] # swap back to original results.append(result) return results"},{"question":"def can_select_ropes(n: int, m: int, lengths: List[int]) -> str: Determines if there is a subset of ropes such that their total length is exactly equal to m meters. :param n: Number of ropes (integer). :param m: Target length (integer). :param lengths: List of rope lengths (list of integers). :return: \\"YES\\" if there exists such a subset, otherwise \\"NO\\". >>> can_select_ropes(4, 10, [2, 3, 7, 9]) \\"YES\\" >>> can_select_ropes(3, 15, [1, 5, 10]) \\"YES\\" >>> can_select_ropes(3, 11, [2, 4, 8]) \\"NO\\"","solution":"def can_select_ropes(n, m, lengths): Determines if there is a subset of ropes such that their total length is exactly equal to m meters. :param n: Number of ropes (integer). :param m: Target length (integer). :param lengths: List of rope lengths (list of integers). :return: \\"YES\\" if there exists such a subset, otherwise \\"NO\\". # Using bit masking to check all possible subsets for i in range(1 << n): total_length = 0 for j in range(n): if i & (1 << j): # Include the j-th rope in the subset total_length += lengths[j] if total_length == m: return \\"YES\\" return \\"NO\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def nodesAtDepth(root, depth): Given a binary tree and a target depth, retrieve all the nodes located at the given depth in the tree. Args: root (TreeNode): The root of the binary tree. depth (int): The target depth. Returns: List[int]: A list of values of the nodes at the target depth. Examples: >>> nodesAtDepth(TreeNode(1), 0) [1] >>> nodesAtDepth(TreeNode(1, TreeNode(2), TreeNode(3)), 1) [2, 3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def nodesAtDepth(root, depth): Given a binary tree and a target depth, retrieve all the nodes located at the given depth in the tree. Args: root (TreeNode): The root of the binary tree. depth (int): The target depth. Returns: List[int]: A list of values of the nodes at the target depth. if not root: return [] current_level = [root] current_depth = 0 while current_level and current_depth < depth: next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level current_depth += 1 return [node.val for node in current_level]"},{"question":"def find_max_visitable_cities(n, distances): Finds the maximum number of distinct cities Sarah can visit by moving sequentially to the nearest unvisited city. Parameters: n (int): Number of cities distances (list of lists of ints): Distance matrix where distances[i][j] represents the distance from city i to city j Returns: tuple: (max_visitable_cities, visit_order) >>> n = 3 >>> distances = [ ... [0, 10, 15], ... [10, 0, 12], ... [15, 12, 0] ... ] >>> find_max_visitable_cities(n, distances) (3, [1, 2, 3]) >>> n = 4 >>> distances = [ ... [0, 3, 1, 10], ... [3, 0, 5, 7], ... [1, 5, 0, 6], ... [10, 7, 6, 0] ... ] >>> find_max_visitable_cities(n, distances) (4, [1, 3, 4, 2])","solution":"def find_max_visitable_cities(n, distances): Finds the maximum number of distinct cities Sarah can visit by moving sequentially to the nearest unvisited city. Parameters: n (int): Number of cities distances (list of lists of ints): Distance matrix where distances[i][j] represents the distance from city i to city j Returns: tuple: (max_visitable_cities, visit_order) def visit(start): visited = [False] * n order = [] current_city = start while True: order.append(current_city + 1) visited[current_city] = True nearest_city = None min_distance = float('inf') for city in range(n): if not visited[city] and 0 < distances[current_city][city] < min_distance: nearest_city = city min_distance = distances[current_city][city] if nearest_city is None: break current_city = nearest_city return len(order), order max_visits = 0 best_order = [] for i in range(n): visits, order = visit(i) if visits > max_visits: max_visits, best_order = visits, order return max_visits, best_order"},{"question":"def calculate_average_grades(students: list) -> list: Calculates the average grade for each student and returns a list of dictionaries with student names and their average grade, sorted by average grade in descending order and by name alphabetically in case of a tie. Parameters: students (list): List of student records, each a dictionary with 'name' and 'grades'. Returns: list: List of dictionaries containing 'name' and 'average' keys. Examples: >>> students = [ >>> {'name': 'Alice', 'grades': {'Math': 90, 'Science': 80, 'English': 70}}, >>> {'name': 'Bob', 'grades': {'Math': 100, 'Science': 90, 'English': 80}}, >>> {'name': 'Charlie', 'grades': {'Math': 70, 'Science': 60, 'English': 50}} >>> ] >>> calculate_average_grades(students) [{'name': 'Bob', 'average': 90.00}, {'name': 'Alice', 'average': 80.00}, {'name': 'Charlie', 'average': 60.00}] # Your implementation here","solution":"def calculate_average_grades(students): Calculates the average grade for each student and returns a list of dictionaries with student names and their average grade, sorted by average grade in descending order and by name alphabetically in case of a tie. Parameters: students (list): List of student records, each a dictionary with 'name' and 'grades'. Returns: list: List of dictionaries containing 'name' and 'average' keys. # Compute the average grade for each student results = [] for student in students: name = student['name'] grades = student['grades'].values() average_grade = round(sum(grades) / len(grades), 2) results.append({'name': name, 'average': average_grade}) # Sort the results first by average grade (descending), then by name (alphabetical order) results.sort(key=lambda x: (-x['average'], x['name'])) return results"},{"question":"def rotate_matrix(matrix): Rotates an n x n matrix 90 degrees clockwise. Args: matrix (list of list of int): The input n x n matrix. Returns: list of list of int: The rotated matrix. pass # Unit Tests def test_rotate_3x3_matrix(): input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_2x2_matrix(): input_matrix = [ [1, 2], [3, 4] ] expected_output = [ [3, 1], [4, 2] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_1x1_matrix(): input_matrix = [ [1] ] expected_output = [ [1] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_4x4_matrix(): input_matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected_output = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_non_square_matrix(): # This test purposely fails since the function specifies n x n matrix input_matrix = [ [1, 2, 3], [4, 5, 6] ] try: rotate_matrix(input_matrix) except Exception as e: assert str(e) == \\"list index out of range\\"","solution":"def rotate_matrix(matrix): Rotates an n x n matrix 90 degrees clockwise. Args: matrix (list of list of int): The input n x n matrix. Returns: list of list of int: The rotated matrix. n = len(matrix) # Create a new matrix to hold the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - i - 1] = matrix[i][j] return rotated"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): Build a tree from a list of nodes. if not nodes: return None n = len(nodes) if n == 0 or nodes[0] is None: return None root = TreeNode(nodes[0]) queue = [root] i = 1 while queue and i < n: node = queue.pop(0) if i < n and nodes[i] is not None: node.left = TreeNode(nodes[i]) queue.append(node.left) i += 1 if i < n and nodes[i] is not None: node.right = TreeNode(nodes[i]) queue.append(node.right) i += 1 return root def is_balanced(root): Determine if a binary tree is balanced. def determine_if_balanced(input_str): Determine if a binary tree represented by a string is balanced. >>> determine_if_balanced(\\"3 9 20 null null 15 7\\") == \\"BALANCED\\" >>> determine_if_balanced(\\"1 2 2 3 3 null null 4 4\\") == \\"NOT BALANCED\\" nodes = input_str.split() nodes = [int(x) if x != 'null' else None for x in nodes] root = build_tree(nodes) return \\"BALANCED\\" if is_balanced(root) else \\"NOT BALANCED\\" from solution import determine_if_balanced def test_balanced_tree1(): assert determine_if_balanced(\\"3 9 20 null null 15 7\\") == \\"BALANCED\\" def test_not_balanced_tree1(): assert determine_if_balanced(\\"1 2 2 3 3 null null 4 4\\") == \\"NOT BALANCED\\" def test_balanced_tree2(): assert determine_if_balanced(\\"1 2 3 4 5 6 7\\") == \\"BALANCED\\" def test_single_node(): assert determine_if_balanced(\\"1\\") == \\"BALANCED\\" def test_empty_tree(): assert determine_if_balanced(\\"\\") == \\"BALANCED\\" def test_not_balanced_tree2(): assert determine_if_balanced(\\"10 20 30 10 10 null null null null 5\\") == \\"NOT BALANCED\\"","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): if not nodes: return None n = len(nodes) if n == 0 or nodes[0] is None: return None root = TreeNode(nodes[0]) queue = [root] i = 1 while queue and i < n: node = queue.pop(0) if i < n and nodes[i] is not None: node.left = TreeNode(nodes[i]) queue.append(node.left) i += 1 if i < n and nodes[i] is not None: node.right = TreeNode(nodes[i]) queue.append(node.right) i += 1 return root def is_balanced(root): def check(root): if not root: return (True, 0) left_balanced, left_height = check(root.left) right_balanced, right_height = check(root.right) balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) height = max(left_height, right_height) + 1 return (balanced, height) return check(root)[0] def determine_if_balanced(input_str): nodes = input_str.split() nodes = [int(x) if x != 'null' else None for x in nodes] root = build_tree(nodes) return \\"BALANCED\\" if is_balanced(root) else \\"NOT BALANCED\\""},{"question":"def find_minimum_connections(m: int, k: int, routes: List[Tuple[int, int, int]]) -> Tuple[int, List[Tuple[int, int]]]: Determines the minimum number of direct connections needed to ensure all stations are accessible from every other station using Prim's algorithm. Args: m (int): The number of stations. k (int): The number of routes. routes (List[Tuple[int, int, int]]): A list of tuples where each tuple contains two integers representing a route between stations and the length of the route. Returns: Tuple[int, List[Tuple[int, int]]]: Returns the minimum number of connections needed and one possible way to achieve this, as a list of pairs of stations. pass","solution":"def find_minimum_connections(m, k, routes): Prim's algorithm to find the Minimum Spanning Tree (MST) of the given graph (city's transport stations), to ensure all stations are accessible from every other station. import heapq # Build adjacency list representation of the graph from collections import defaultdict, deque graph = defaultdict(list) for u, v, l in routes: graph[u].append((l, v)) graph[v].append((l, u)) # Prim's algorithm to find MST mst_cost = 0 mst_edges = [] start_node = 1 # Min-heap to store the edges based on their weights min_heap = [(0, start_node, start_node)] visited = set() while min_heap and len(visited) < m: cost, u, v = heapq.heappop(min_heap) if v not in visited: visited.add(v) mst_cost += cost if u != v: # Don't add the first dummy edge (0, start_node, start_node) mst_edges.append((u, v)) for next_cost, next_node in graph[v]: if next_node not in visited: heapq.heappush(min_heap, (next_cost, v, next_node)) return len(mst_edges), mst_edges # Accept input and parse it def main(): from sys import stdin, stdout input = stdin.read data = input().split() m = int(data[0]) k = int(data[1]) routes = [] index = 2 for _ in range(k): u = int(data[index]) v = int(data[index+1]) l = int(data[index+2]) routes.append((u, v, l)) index += 3 # Find minimum connections needed n, connections = find_minimum_connections(m, k, routes) # Output the result stdout.write(f\\"{n}n\\") for u, v in connections: stdout.write(f\\"{u} {v}n\\") # Uncomment below line to run main function if this script is run directly # if __name__ == \\"__main__\\": # main()"},{"question":"def largest_connected_component(R: int, C: int, grid: List[List[int]]) -> int: Find the size of the largest connected component in the given grid. Args: - R: int, the number of rows in the grid. - C: int, the number of columns in the grid. - grid: List[List[int]], a 2D list representing the grid where each cell contains an integer representing the altitude. Returns: - int, the size of the largest connected component. >>> largest_connected_component(4, 5, [ ... [1, 1, 0, 2, 2], ... [3, 1, 1, 2, 2], ... [4, 4, 1, 1, 0], ... [4, 4, 4, 4, 0] ... ]) 6 >>> largest_connected_component(3, 3, [ ... [1, 2, 1], ... [2, 2, 2], ... [1, 2, 1] ... ]) 5","solution":"def largest_connected_component(R, C, grid): def dfs(r, c, value): if r < 0 or r >= R or c < 0 or c >= C or visited[r][c] or grid[r][c] != value: return 0 visited[r][c] = True size = 1 size += dfs(r + 1, c, value) size += dfs(r - 1, c, value) size += dfs(r, c + 1, value) size += dfs(r, c - 1, value) return size visited = [[False] * C for _ in range(R)] max_size = 0 for r in range(R): for c in range(C): if not visited[r][c]: size = dfs(r, c, grid[r][c]) max_size = max(max_size, size) return max_size"},{"question":"def find_visible_hills(heights): Determines the positions of all visible hills. :param heights: List of heights of hills :return: List of positions of visible hills in ascending order >>> find_visible_hills([1, 3, 2, 4, 1, 5, 3, 2]) [0, 1, 3, 5] >>> find_visible_hills([5, 4, 3, 2, 1]) [0]","solution":"def find_visible_hills(heights): Determines the positions of all visible hills. :param heights: List of heights of hills :return: List of positions of visible hills in ascending order visible_hills = [] max_height_so_far = -1 for i in range(len(heights)): if heights[i] > max_height_so_far: visible_hills.append(i) max_height_so_far = heights[i] return visible_hills"},{"question":"def high_and_low(numbers: str) -> str: Returns the highest and lowest numbers as a string with two values separated by a single space. Args: numbers (str): A string of space-separated integers. Returns: str: A string with the highest and lowest numbers separated by a single space. >>> high_and_low(\\"1 2 3 4 5 -9 42\\") '42 -9' >>> high_and_low(\\"1 2 3 4 5\\") '5 1' >>> high_and_low(\\"-1 -1\\") '-1 -1' >>> high_and_low(\\"3 7 9 8 2\\") '9 2' >>> high_and_low(\\"10\\") '10 10' >>> high_and_low(\\"4 4 4 4\\") '4 4' # Implement your solution here","solution":"def high_and_low(numbers): Returns the highest and lowest numbers as a string with two values separated by a single space. Args: numbers (str): A string of space separated integers. Returns: str: A string with the highest and lowest numbers separated by a single space. nums = list(map(int, numbers.split())) return f\\"{max(nums)} {min(nums)}\\""},{"question":"def find_array_with_odd_xor(N): This function generates an array of length N such that each subarray has an odd bitwise XOR. If no such array exists, it returns -1. pass def process_test_cases(T, test_cases): This function processes T test cases and returns a list of arrays for each test case. Each array satisfies the condition that all subarrays have an odd bitwise XOR. >>> process_test_cases(3, [1, 2, 3]) [[1], [1, 2], [1, 2, 3]] >>> process_test_cases(2, [4, 5]) [[1, 2, 1, 2], [1, 2, 3, 4, 5]] >>> process_test_cases(1, [0]) [[]] pass","solution":"def find_array_with_odd_xor(N): This function generates an array of length N such that each subarray has an odd bitwise XOR. If no such array exists, it returns -1. if N % 2 == 0: return [1 + (i % 2) for i in range(N)] else: return [i + 1 for i in range(N)] def process_test_cases(T, test_cases): results = [] for N in test_cases: results.append(find_array_with_odd_xor(N)) return results"},{"question":"def can_crowley_escape(N: int, M: int, grid: List[str]) -> str: Determine whether Crowley can reach the bottom-right cell in the labyrinth from the top-left cell. Args: N (int): The number of rows in the grid. M (int): The number of columns in the grid. grid (List[str]): The labyrinth represented as a list of strings. Returns: str: \\"YES\\" if Crowley can reach the bottom-right cell; \\"NO\\" otherwise. >>> can_crowley_escape(4, 4, [\\". . . #\\", \\". # . .\\", \\". . # .\\", \\". . . .\\"]) \\"YES\\" >>> can_crowley_escape(4, 4, [\\". # . #\\", \\". # . .\\", \\". . # .\\", \\". # . .\\"]) \\"NO\\" def main(input_string: str) -> str: Parse input string and determine if Crowley can escape the labyrinth. Args: input_string (str): Input string containing the labyrinth definition. Returns: str: \\"YES\\" if Crowley can escape; \\"NO\\" otherwise. def parse_input(input_string: str) -> Tuple[int, int, List[str]]: Parse the input string to extract grid dimensions and the grid itself. Args: input_string (str): Input string containing the labyrinth definition. Returns: Tuple: A tuple containing the number of rows, number of columns, and the grid. from typing import List, Tuple def test_case_1(): input_string = 4 4 . . . # . # . . . . # . . . . . assert main(input_string) == \\"YES\\" def test_case_2(): input_string = 4 4 . # . # . # . . . . # . . # . . assert main(input_string) == \\"NO\\" def test_case_3(): input_string = 1 1 . assert main(input_string) == \\"YES\\" def test_case_4(): input_string = 2 2 . # # . assert main(input_string) == \\"NO\\" def test_case_5(): input_string = 4 4 . . . # . . . . . . # . . . . . assert main(input_string) == \\"YES\\"","solution":"def can_reach_end(grid): N = len(grid) M = len(grid[0]) if grid[0][0] == '#' or grid[N-1][M-1] == '#': return \\"NO\\" # Use a queue for BFS queue = [(0, 0)] visited = set() directions = [(1, 0), (0, 1)] # down, right while queue: x, y = queue.pop(0) if (x, y) == (N-1, M-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\" def can_crowley_escape(N, M, grid): grid = [list(row.replace(\\" \\", \\"\\")) for row in grid] return can_reach_end(grid) # Parse input def parse_input(input_string): data = input_string.strip().split('n') N, M = map(int, data[0].split()) grid = data[1:] return N, M, grid # Main Function def main(input_string): N, M, grid = parse_input(input_string) return can_crowley_escape(N, M, grid)"},{"question":"def max_product_subarray(nums: List[int]) -> int: Given an array of integers, find the subarray (containing at least one number) which has the largest product and return the product of this subarray. >>> max_product_subarray([6, -3, -10, 0, 2]) 180 >>> max_product_subarray([2, 3, -2, 4]) 6","solution":"def max_product_subarray(nums): if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def findMiddle(head): Finds the middle of the linked list. If the linked list contains an even number of nodes, returns the second middle node. pass def create_linked_list(lst): Helper function to create a linked list from a list of values. >>> create_linked_list([1, 2, 3, 4, 5]).val 1 dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next # Test cases head = create_linked_list([1, 2, 3, 4, 5]) print(findMiddle(head)) # Expected output: 3 head = create_linked_list([1, 2, 3, 4, 5, 6]) print(findMiddle(head)) # Expected output: 4 head = create_linked_list([1]) print(findMiddle(head)) # Expected output: 1 head = create_linked_list([1, 2]) print(findMiddle(head)) # Expected output: 2 head = create_linked_list([1, 2, 3]) print(findMiddle(head)) # Expected output: 2","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def findMiddle(head): Finds the middle of the linked list. If the linked list contains an even number of nodes, returns the second middle node. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.val # Helper function to create linked list from list for testing purposes def create_linked_list(lst): dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next"},{"question":"from typing import List, Tuple def process_queries(n: int, stocks: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process inventory update and stock level queries. Arguments: n : int : the number of items in the warehouse stocks : List[int] : the initial stock levels of these items queries : List[Tuple[int, int, int]] : the list of queries to process Returns: List[int] : the results of the stock level queries Example: >>> process_queries(5, [10, 20, 30, 40, 50], [(2, 1, 3), (1, 2, 25), (2, 1, 3), (1, 0, 100)]) [90, 85]","solution":"class Warehouse: def __init__(self, stocks): self.n = len(stocks) self.stocks = stocks self.prefix_sums = self._compute_prefix_sums(stocks) def _compute_prefix_sums(self, stocks): prefix_sums = [0] * (self.n + 1) for i in range(self.n): prefix_sums[i + 1] = prefix_sums[i] + stocks[i] return prefix_sums def update_stock(self, index, value): diff = value - self.stocks[index] self.stocks[index] = value for i in range(index + 1, self.n + 1): self.prefix_sums[i] += diff def total_stock_in_range(self, left, right): return self.prefix_sums[right + 1] - self.prefix_sums[left] def process_queries(n, stocks, queries): warehouse = Warehouse(stocks) results = [] for query in queries: t, p, q = query if t == 1: warehouse.update_stock(p, q) elif t == 2: results.append(warehouse.total_stock_in_range(p, q)) return results # Example usage n = 5 stocks = [10, 20, 30, 40, 50] queries = [(2, 1, 3), (1, 2, 25), (2, 1, 3), (1, 0, 100)] print(process_queries(n, stocks, queries))"},{"question":"def task_order(n: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determine the order in which tasks can be completed while satisfying all given dependencies. :param n: Number of tasks. :param dependencies: List of tuples representing the dependency pairs (a, b) where 'a' must be completed before 'b'. :return: A list of integers representing a valid task order or an empty list if no valid order exists. >>> task_order(4, [(1, 2), (2, 3), (3, 4)]) [1, 2, 3, 4] >>> task_order(4, [(1, 2), (2, 3), (3, 4), (4, 2)]) []","solution":"def task_order(n, dependencies): Returns a valid task order for completing tasks based on given dependencies. :param n: int, number of tasks :param dependencies: list of tuples, each tuple (a, b) represents task a must be completed before task b :return: list of int, a valid task order or an empty list if no valid order exists from collections import defaultdict, deque # Build graph and in-degree counts graph = defaultdict(list) in_degree = [0] * (n + 1) for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Initialize queue with nodes having zero in-degree zero_in_degree_queue = deque() for i in range(1, n + 1): if in_degree[i] == 0: zero_in_degree_queue.append(i) order = [] # Process nodes with zero in-degree while zero_in_degree_queue: task = zero_in_degree_queue.popleft() order.append(task) for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the ordering includes all tasks, return it; otherwise, return empty list return order if len(order) == n else []"},{"question":"def isBipartite(N, M, edges): Determines if an undirected graph is bipartite. Args: N: int - The number of nodes. M: int - The number of edges. edges: List of tuples - Each tuple contains two integers representing an edge between two nodes. Returns: int: 1 if the graph is bipartite, otherwise 0. Examples: >>> isBipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 1 >>> isBipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) 0","solution":"from collections import deque def isBipartite(N, M, edges): Determines if an undirected graph is bipartite. Args: N: int - The number of nodes. M: int - The number of edges. edges: List of tuples - Each tuple contains two integers representing an edge between two nodes. Returns: int: 1 if the graph is bipartite, otherwise 0. # Create an adjacency list graph = [[] for _ in range(N + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) # Array to store the color of each node, 0 means uncolored, 1 and -1 mean different colors color = [0] * (N + 1) def bfs(start): queue = deque([start]) color[start] = 1 # Start coloring with 1 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == 0: # Assign an opposite color to the neighboring node color[neighbor] = -color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # If the neighboring node has the same color, graph is not bipartite return False return True # Check each component of the graph for i in range(1, N + 1): if color[i] == 0: # Node not yet colored if not bfs(i): return 0 return 1"},{"question":"def max_books(n, W, books): Determine the maximum number of books that can fit on a shelf without exceeding the weight capacity. Parameters: n (int): Number of books. W (int): Maximum weight capacity of the shelf. books (list of tuples): List of tuples where each tuple contains the thickness and weight of a book. Returns: int: Maximum number of books. >>> max_books(6, 15, [(2, 1), (3, 5), (2, 6), (5, 10), (1, 4), (4, 1)]) 4 >>> max_books(3, 15, [(1, 5), (2, 5), (3, 5)]) 3 >>> max_books(3, 100, [(1, 10000), (2, 1), (3, 2)]) 2 >>> max_books(3, 99, [(1, 100), (2, 100), (3, 100)]) 0 >>> max_books(1, 10, [(1, 10)]) 1 >>> max_books(1, 5, [(1, 10)]) 0 >>> max_books(4, 10, [(1, 5), (2, 5), (1, 5), (1, 5)]) 2","solution":"def max_books(n, W, books): Determine the maximum number of books that can fit on a shelf without exceeding the weight capacity. Parameters: n (int): Number of books. W (int): Maximum weight capacity of the shelf. books (list of tuples): List of tuples where each tuple contains the thickness and weight of a book. Returns: int: Maximum number of books. # Sort books based on their weight in ascending order books.sort(key=lambda x: x[1]) weight_sum = 0 count = 0 for thickness, weight in books: if weight_sum + weight <= W: weight_sum += weight count += 1 else: break return count"},{"question":"def singleNumber(arr): Given a list of integers, each element appears thrice except for one element which appears only once. Write a function to find that single element which appears only once. >>> singleNumber([2, 2, 3, 2]) 3 >>> singleNumber([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def singleNumber(arr): Returns the single element that appears only once in the list while all other elements appear thrice. ones, twos = 0, 0 for num in arr: # \`ones\` keeps track of elements that appeared once # \`twos\` keeps track of elements that appeared twice ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def distribute_coins(n: int, targets: List[int]) -> List[int]: Determines the sequence of positions to distribute gold coins based on the targets array. Returns an empty list if no valid distribution is possible. Args: n (int): the number of citizens targets (List[int]): list of integers where targets[i] represents the total number of gold coins citizen i should have Returns: List[int]: sequence of positions where each position contains the 1-based index of a citizen receiving a coin, or an empty list if not possible >>> distribute_coins(5, [1, 0, 2, 1, 0]) [] >>> distribute_coins(3, [1, 1, 2]) [] >>> distribute_coins(6, [1, 0, 1, 0, 1, 0]) [1, 3, 5]","solution":"def distribute_coins(n, targets): Determines the sequence of positions to distribute gold coins based on the targets array. Returns an empty list if no valid distribution is possible. if any(target > 1 for target in targets): return [] positions = [] for i in range(n): if targets[i] == 1: positions.append(i + 1) return positions"},{"question":"def promotion_order(employee_data): Returns a list of employee IDs in the order they should be promoted. :param employee_data: List of tuples where each tuple contains employee ID and rating :return: List of employee IDs sorted according to promotion rules >>> promotion_order([(1, 80), (2, 90), (3, 80), (4, 90), (5, 85)]) [2, 4, 5, 1, 3] >>> promotion_order([(1, 80)]) [1] >>> promotion_order([(1, 80), (2, 80), (3, 80)]) [1, 2, 3] >>> promotion_order([(3, 80), (2, 80), (1, 80)]) [1, 2, 3] >>> promotion_order([(2, 85), (1, 90), (3, 80)]) [1, 2, 3] >>> promotion_order([(4, 50), (3, 100), (5, 100), (1, 50), (2, 100)]) [2, 3, 5, 1, 4]","solution":"def promotion_order(employee_data): Returns a list of employee IDs in the order they should be promoted. :param employee_data: List of tuples where each tuple contains employee ID and rating :return: List of employee IDs sorted according to promotion rules # Sort first by rating in descending order, then by ID in ascending order sorted_employees = sorted(employee_data, key=lambda x: (-x[1], x[0])) # Extract and return the sorted list of IDs return [employee[0] for employee in sorted_employees]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isValidBST(root: TreeNode) -> bool: Check whether the binary tree is a valid Binary Search Tree (BST). >>> isValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) True >>> isValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) False >>> isValidBST(TreeNode(1)) True >>> isValidBST(TreeNode(10, TreeNode(5), TreeNode(15, TreeNode(6), TreeNode(20)))) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isValidBST(root, lower=float('-inf'), upper=float('inf')): if not root: return True if root.val <= lower or root.val >= upper: return False return isValidBST(root.left, lower, root.val) and isValidBST(root.right, root.val, upper)"},{"question":"def generate_matrix(n: int) -> list: Generates an n x n matrix according to the given rules. - If i == j, the element is 0. - If i is not equal to j: - The value should be 1 if both i and j are even or both are odd. - The value should be 2 if one of i or j is even and the other is odd. Parameters: n (int): The size of the matrix. Returns: list: The generated matrix as a list of lists. >>> generate_matrix(1) [[0]] >>> generate_matrix(2) [[0, 2], [2, 0]] >>> generate_matrix(3) [[0, 2, 1], [2, 0, 2], [1, 2, 0]] >>> generate_matrix(4) [[0, 2, 1, 2], [2, 0, 2, 1], [1, 2, 0, 2], [2, 1, 2, 0]]","solution":"def generate_matrix(n): Generates an n x n matrix according to the given rules. - If i == j, the element is 0. - If i is not equal to j: - The value should be 1 if both i and j are even or both are odd. - The value should be 2 if one of i or j is even and the other is odd. Parameters: n (int): The size of the matrix. Returns: list: The generated matrix as a list of lists. matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): if i == j: matrix[i][j] = 0 elif (i % 2 == j % 2): matrix[i][j] = 1 else: matrix[i][j] = 2 return matrix"},{"question":"def calculate_total_fruit_weight(fruits: List[Dict[str, Union[str, int]]]) -> Dict[str, int]: Given a list of dictionaries containing fruit names and their associated weights, calculates the total weight for each type of fruit and returns a dictionary with the total weights. Example: >>> input_data = [ >>> {\\"fruit\\": \\"apple\\", \\"weight\\": 150}, >>> {\\"fruit\\": \\"banana\\", \\"weight\\": 120}, >>> {\\"fruit\\": \\"apple\\", \\"weight\\": 170}, >>> {\\"fruit\\": \\"orange\\", \\"weight\\": 130}, >>> {\\"fruit\\": \\"banana\\", \\"weight\\": 150} >>> ] >>> calculate_total_fruit_weight(input_data) {\\"apple\\": 320, \\"banana\\": 270, \\"orange\\": 130}","solution":"def calculate_total_fruit_weight(fruits): Given a list of dictionaries containing fruit names and their associated weights, calculates the total weight for each type of fruit and returns a dictionary with the total weights. total_weights = {} for item in fruits: fruit = item[\\"fruit\\"] weight = item[\\"weight\\"] if fruit in total_weights: total_weights[fruit] += weight else: total_weights[fruit] = weight return total_weights"},{"question":"def accessory_combinations(n: int) -> int: Calculate the total number of ways to arrange accessories such that each car has at least one accessory. This is done by calculating the nth Bell number which represents the number of ways to partition a set of n elements. >>> accessory_combinations(1) == 1 >>> accessory_combinations(2) == 2 >>> accessory_combinations(3) == 5 >>> accessory_combinations(4) == 15 >>> accessory_combinations(5) == 52 >>> accessory_combinations(6) == 203 >>> accessory_combinations(7) == 877 >>> accessory_combinations(8) == 4140 >>> accessory_combinations(9) == 21147 >>> accessory_combinations(10) == 115975","solution":"def accessory_combinations(n: int) -> int: Calculate the total number of ways to arrange accessories such that each car has at least one accessory. This is done by calculating the nth Bell number which represents the number of ways to partition a set of n elements. def bell_number(n): bell = [[0 for _ in range(n+1)] for _ in range(n+1)] bell[0][0] = 1 for i in range(1, n+1): # Explicitly put the last element as it is the sum of all prior row elements. bell[i][0] = bell[i-1][i-1] for j in range(1, i+1): # Current element is sum of the element to the left and the above element. bell[i][j] = bell[i-1][j-1] + bell[i][j-1] return bell[n][0] return bell_number(n)"},{"question":"def product_of_lengths(words): Returns the product of the lengths of the words in the given array, ignoring the digits. :param words: List of strings containing words and digits :return: Product of the lengths of all the words >>> product_of_lengths([\\"apple\\", \\"5\\", \\"banana\\", \\"orange\\", \\"8\\"]) 180 >>> product_of_lengths([\\"hello\\", \\"world\\", \\"python\\"]) 150 >>> product_of_lengths([\\"1\\", \\"2\\", \\"3\\"]) 1 >>> product_of_lengths([]) 1 >>> product_of_lengths([\\"test\\", \\"case\\"]) 16 >>> product_of_lengths([\\"test\\"]) 4 >>> product_of_lengths([\\"9\\"]) 1","solution":"def product_of_lengths(words): Returns the product of the lengths of the words in the given array, ignoring the digits. :param words: List of strings containing words and digits :return: Product of the lengths of all the words product = 1 for word in words: if word.isalpha(): # Check if the string contains only alphabetic characters product *= len(word) return product"},{"question":"def parking_lot(s: str) -> list: Returns the number of available spots on each level or [-1] if the input is not correct. >>> parking_lot(\\"A01B02A03C01B04\\") [('A', 97), ('B', 97), ('C', 98)] >>> parking_lot(\\"D01E05D01\\") [-1] >>> parking_lot(\\"D01\\"*100) [-1] >>> parking_lot(\\"\\") [] >>> parking_lot(\\"A01A02A03\\") [('A', 96)] >>> parking_lot(\\"A01B01C01D01E01\\") [('A', 98), ('B', 98), ('C', 98), ('D', 98), ('E', 98)] >>> parking_lot(\\"A01B03C1\\") [-1]","solution":"def parking_lot(s): Returns the number of available spots on each level or [-1] if the input is not correct. if len(s) % 3 != 0: return [-1] car_counts = {} seen_cars = set() for i in range(0, len(s), 3): level = s[i] spot = s[i+1:i+3] car_label = s[i:i+3] if car_label in seen_cars: return [-1] seen_cars.add(car_label) if level not in car_counts: car_counts[level] = set() car_counts[level].add(spot) if len(car_counts[level]) > 99: return [-1] result = [] for level in sorted(car_counts): available_spots = 99 - len(car_counts[level]) result.append((level, available_spots)) return result"},{"question":"def reorder_problems(problems): Reorders the problems by their difficulty levels in a strictly increasing order. If it's impossible to do so, returns 'impossible'. >>> reorder_problems([(3, 20), (1, 10), (2, 30)]) == [1, 3, 2] >>> reorder_problems([(3, 20), (1, 10), (2, 10)]) == 'impossible' >>> reorder_problems([(1, 50), (2, 40), (3, 60)]) == [2, 1, 3] >>> reorder_problems([]) == [] >>> reorder_problems([(1, 20), (2, 20), (3, 20)]) == 'impossible'","solution":"def reorder_problems(problems): Reorders the problems by their difficulty levels in a strictly increasing order. If it's impossible to do so, returns 'impossible'. problems_sorted = sorted(problems, key=lambda x: x[1]) # Verify if the sorted difficulties are strictly increasing for i in range(len(problems_sorted) - 1): if problems_sorted[i][1] >= problems_sorted[i + 1][1]: return 'impossible' # Return the ordered list of identifiers return [problem[0] for problem in problems_sorted]"},{"question":"def process_queries(N: int, Q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Processes the queries to determine the sum of the elements in specified subarrays. Parameters: N (int): Number of elements in the array Q (int): Number of queries array (list of int): List containing the elements of the array queries (list of tuple): List containing the queries as (L, R) tuples Returns: list of int: List containing the results of the queries. Example: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [6, 14, 15]","solution":"def process_queries(N, Q, array, queries): Processes the queries to determine the sum of the elements in specified subarrays. Parameters: N (int): Number of elements in the array Q (int): Number of queries array (list of int): List containing the elements of the array queries (list of tuple): List containing the queries as (L, R) tuples Returns: list of int: List containing the results of the queries # Step 1: Compute prefix sums prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prefix_sums[i] = prefix_sums[i - 1] + array[i - 1] # Step 2: Process each query results = [] for L, R in queries: sum_subarray = prefix_sums[R] - prefix_sums[L - 1] results.append(sum_subarray) return results"},{"question":"def max_pens_each_participant(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Determines the maximum number of pens each participant can have at the end of the contest. Parameters: t (int): Number of test cases test_cases (list of tuples): List of tuples where each tuple contains: - an integer representing the number of participants - a list of integers representing the initial number of pens each participant has Returns: list of lists of int: Maximum number of pens each participant can have at the end of the contest for each test case. >>> max_pens_each_participant(2, [(3, [1, 2, 3]), (4, [4, 4, 4, 4])]) [[3, 3, 3], [4, 4, 4, 4]] >>> max_pens_each_participant(1, [(5, [5, 1, 3, 2, 4])]) [[5, 5, 5, 5, 5]] >>> max_pens_each_participant(3, [(3, [10, 8, 6]), (2, [3, 3]), (4, [1, 9, 1, 1])]) [[10, 10, 10], [3, 3], [9, 9, 9, 9]]","solution":"def max_pens_each_participant(t, test_cases): Determines the maximum number of pens each participant can have at the end of the contest. Parameters: t (int): Number of test cases test_cases (list of tuples): List of tuples where each tuple contains: - int: number of participants - list of int: initial number of pens each participant has Returns: list of lists of int: Maximum number of pens each participant can have at the end of the contest for each test case results = [] for case in test_cases: n, pens = case max_pens = max(pens) results.append([max_pens] * n) return results"},{"question":"def can_visit_all_points(points): Checks if the robot can visit all the given points in order following the rules: 1. The robot can only move to the right (positive x direction) or up (positive y direction). 2. The robot starts at (0, 0) and must visit the points in the order they are given. Parameters: points (List[Tuple[int, int]]): List of points to visit in order. Returns: str: \\"Yes\\" if the robot can visit all the points in order, otherwise \\"No\\". >>> can_visit_all_points([(1, 2), (3, 2), (3, 4)]) == \\"Yes\\" >>> can_visit_all_points([(1, 2), (2, 1), (3, 3)]) == \\"No\\" >>> can_visit_all_points([(0, 1), (1, 1), (2, 3)]) == \\"Yes\\" >>> can_visit_all_points([(1, 0), (1, 1), (2, 2)]) == \\"Yes\\" >>> can_visit_all_points([(1, 1), (0, 1), (2, 3)]) == \\"No\\"","solution":"def can_visit_all_points(points): Checks if the robot can visit all the given points in order following the rules: 1. The robot can only move to the right (positive x direction) or up (positive y direction). 2. The robot starts at (0, 0) and must visit the points in the order they are given. Parameters: points (List[Tuple[int, int]]): List of points to visit in order. Returns: str: \\"Yes\\" if the robot can visit all the points in order, otherwise \\"No\\". current_x, current_y = 0, 0 for x, y in points: if x < current_x or y < current_y: return \\"No\\" current_x, current_y = x, y return \\"Yes\\""},{"question":"def max_teams(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Returns a list of integers representing the maximum number of teams that can be formed for each test case. Parameters: t: int - the number of test cases. test_cases: List[Tuple[int, int, List[int]]] - a list of tuples where each tuple contains: - an integer n representing the number of students, - an integer k representing the maximum allowed difference in skill levels within a team, - a list of n integers representing the skill levels of the students. Returns: List[int] - a list of integers where each integer is the maximum number of teams that can be formed for the corresponding test case. Example: >>> max_teams(3, [(5, 3, [1, 3, 6, 7, 9]), (4, 0, [10, 20, 30, 40]), (6, 2, [4, 6, 5, 8, 9, 10])]) [2, 4, 2]","solution":"def max_teams(t, test_cases): Returns a list of integers representing the maximum number of teams that can be formed for each test case. results = [] for case in test_cases: n, k, skills = case skills.sort() teams = 0 i = 0 while i < n: start = skills[i] while i < n and skills[i] - start <= k: i += 1 teams += 1 results.append(teams) return results"},{"question":"def min_jumps_to_cross(n: int, d: int, S: str) -> int: Returns the minimum number of jumps required to cross the river represented by string S. If it is not possible to cross the river, return -1. Parameters: n (int): The length of the string S. d (int): The maximum jump distance. S (str): The string representing the river, where '0' indicates a stone and '1' indicates water. Returns: int: The minimum number of jumps required to cross the river, or -1 if it's impossible. Examples: >>> min_jumps_to_cross(5, 3, '00100') 2 >>> min_jumps_to_cross(7, 2, '0000100') 4 >>> min_jumps_to_cross(6, 3, '100001') -1 pass # Unit tests if __name__ == \\"__main__\\": assert min_jumps_to_cross(5, 3, '00100') == 2 assert min_jumps_to_cross(7, 2, '0000100') == 4 assert min_jumps_to_cross(6, 3, '100001') == -1 assert min_jumps_to_cross(5, 3, '11100') == -1 assert min_jumps_to_cross(5, 3, '00011') == -1 assert min_jumps_to_cross(5, 4, '01000') == 1 assert min_jumps_to_cross(10, 9, '0010000000') == 1 assert min_jumps_to_cross(6, 3, '000000') == 2 assert min_jumps_to_cross(6, 3, '111111') == -1","solution":"def min_jumps_to_cross(n, d, S): Returns the minimum number of jumps required to cross the river represented by string S. If it is not possible to cross the river, return -1. def bfs(start, end): queue = [(start, 0)] visited = set() while queue: current_position, jumps = queue.pop(0) if current_position == end: return jumps for next_position in range(current_position + 1, min(current_position + d + 1, n)): if next_position not in visited and S[next_position] == '0': queue.append((next_position, jumps + 1)) visited.add(next_position) return -1 # Start from 0 position (left bank) # End at n-1 position (right bank) if S[0] == '1' or S[n-1] == '1': return -1 return bfs(0, n - 1)"},{"question":"from typing import List, Tuple def max_product_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an integer array \`nums\`, find the contiguous subarray within an array (containing at least one number) which has the largest product. Args: t: An integer, the number of test cases. test_cases: A list of tuples, where each tuple contains an integer \`n\` and a list of integers \`nums\`. Returns: A list of integers representing the maximum product of any contiguous subarray for each test case. Example: >>> max_product_subarray(2, [(4, [2, 3, -2, 4]), (5, [-2, 0, -1, 0, 2])]) [6, 2] >>> max_product_subarray(1, [(3, [-2, 3, -4])]) [24]","solution":"def max_product(nums): Returns the maximum product of any contiguous subarray. if not nums: return 0 max_product = min_product = result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result def max_product_subarray(t, test_cases): results = [] for i in range(t): n, nums = test_cases[i] result = max_product(nums) results.append(result) return results"},{"question":"from typing import List def largest_square_of_trees(n: int, m: int, forest: List[str]) -> int: Find the size of the largest square patch of contiguous trees in the forest. >>> largest_square_of_trees(5, 6, [\\"110001\\", \\"110001\\", \\"111101\\", \\"000011\\", \\"000011\\"]) 2 >>> largest_square_of_trees(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) 3 >>> largest_square_of_trees(3, 3, [\\"000\\", \\"000\\", \\"000\\"]) 0 >>> largest_square_of_trees(4, 5, [\\"10101\\", \\"11111\\", \\"00110\\", \\"11111\\"]) 2 >>> largest_square_of_trees(1, 5, [\\"11011\\"]) 1 >>> largest_square_of_trees(5, 1, [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"1\\"]) 1","solution":"def largest_square_of_trees(n, m, forest): # Create a 2D list to store lengths of largest square ending at that cell dp = [[0]*m for _ in range(n)] max_size = 0 # Fill the dp array for i in range(n): for j in range(m): if forest[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"from typing import List def deliver_package(N: int, grid: List[List[int]]) -> int: Calculates the minimum number of intersections the machine has to pass through from the start intersection (1, 1) to the target intersection (N, N) in a grid city. Args: N : int - the size of the grid city. grid : List[List[int]] - the grid city with 0 for passable and 1 for restricted intersections. Returns: int - the minimum number of intersections to pass through or -1 if it's impossible. Examples: >>> deliver_package(5, [ ... [0, 0, 0, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [1, 0, 1, 1, 0], ... [0, 0, 0, 1, 0] ... ]) == 9 >>> deliver_package(3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == -1","solution":"from collections import deque def deliver_package(N, grid): Calculates the minimum number of intersections to pass through from (1, 1) to (N, N). Args: N : int - the size of the grid city. grid : List[List[int]] - the grid city with 0 for passable and 1 for restricted intersections. Returns: int - the minimum number of intersections to pass through or -1 if it's impossible. if grid[0][0] == 1 or grid[N-1][N-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) visited = set([(0, 0)]) steps = 1 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (N-1, N-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) steps += 1 return -1"},{"question":"from typing import List def find_longest_string(test_cases: List[List[str]]) -> List[str]: Find the longest string among a list of strings for each test case. Each string consists of uppercase and lowercase alphabet characters only. If multiple strings have the same maximum length, return the one which appears first in the list. >>> find_longest_string([[\\"apple\\", \\"banana\\", \\"kiwi\\", \\"strawberry\\"]]) ['strawberry'] >>> find_longest_string([[\\"apple\\", \\"banana\\", \\"kiwi\\", \\"strawberry\\"], [\\"error\\", \\"correction\\", \\"examination\\"]]) ['strawberry', 'examination'] pass def parse_input(data: str) -> List[List[str]]: Parse the input data into test cases format to be used for find_longest_string function. >>> parse_input(\\"1n4napplenbananankiwinstrawberry\\") [['apple', 'banana', 'kiwi', 'strawberry']] >>> parse_input(\\"2n4napplenbananankiwinstrawberryn3nerrorncorrectionnexamination\\") [['apple', 'banana', 'kiwi', 'strawberry'], ['error', 'correction', 'examination']] pass","solution":"def find_longest_string(test_cases): results = [] for case in test_cases: max_length = 0 longest_string = \\"\\" for string in case: if len(string) > max_length: max_length = len(string) longest_string = string results.append(longest_string) return results def parse_input(data): lines = data.strip().split(\\"n\\") index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 case = [] for _ in range(N): case.append(lines[index]) index += 1 test_cases.append(case) return test_cases"},{"question":"def calculate_balances(n, contributions): Calculate how much each friend should pay or be reimbursed. >>> calculate_balances(3, [100, 200, 300]) [-100, 0, 100] >>> calculate_balances(4, [150, 100, 100, 250]) [0, -50, -50, 100] >>> calculate_balances(3, [200, 200, 200]) [0, 0, 0] >>> calculate_balances(3, [0, 100, 200]) [-100, 0, 100] >>> calculate_balances(5, [10, 20, 30, 40, 50]) [-20, -10, 0, 10, 20] >>> calculate_balances(2, [0, 0]) [0, 0] >>> calculate_balances(3, [10000, 10000, 10000]) [0, 0, 0] >>> calculate_balances(1000, [100] * 1000) [0] * 1000","solution":"def calculate_balances(n, contributions): Calculate how much each friend should pay or be reimbursed. total_amount = sum(contributions) fair_share = total_amount // n balances = [contribution - fair_share for contribution in contributions] return balances"},{"question":"def calculate_points(num_books: int, book_prices: List[int], country_code: str, is_special_day: bool) -> int: Calculate the total points accumulated by a customer. >>> calculate_points(3, [20, 30, 40], \\"US\\", False) 90 >>> calculate_points(5, [10, 10, 10, 10, 10], \\"CA\\", True) 120 >>> calculate_points(4, [100, 200, 300, 400], \\"UK\\", False) 1300 >>> calculate_points(2, [50, 50], \\"AU\\", True) 300","solution":"def calculate_points(num_books, book_prices, country_code, is_special_day): # Define the country multipliers country_multipliers = { \\"US\\": 1, \\"CA\\": 1.2, \\"UK\\": 1.3, \\"AU\\": 1.5 } # Sum up the prices of the books total_price = sum(book_prices) # Get the country's point multiplier multiplier = country_multipliers.get(country_code, 1) # Calculate the points points = total_price * multiplier # Double the points if it is a special promotion day if is_special_day: points *= 2 return int(points) # Example input num_books = 3 book_prices = [20, 30, 40] country_code = \\"US\\" is_special_day = False print(calculate_points(num_books, book_prices, country_code, is_special_day)) # Output: 90 num_books = 5 book_prices = [10, 10, 10, 10, 10] country_code = \\"CA\\" is_special_day = True print(calculate_points(num_books, book_prices, country_code, is_special_day)) # Output: 120"},{"question":"def max_fenced_area(l: int) -> float: This function calculates the maximum area of a field that can be fenced with the given length of fencing material. Parameters: l (int): The total length of the fencing material available. Returns: float: The maximum area that can be fenced. Example: >>> max_fenced_area(100) 1250.000000 >>> max_fenced_area(50) 312.500000","solution":"def max_fenced_area(l): This function calculates the maximum area of the rectangular field that can be fenced using the given length l. The formula used is derived from: Let's assume the width is w and the length is l of the rectangle. Hence, 2w + l = fencing material. The area will be maximum if l = l/2 since fencing material is symmetric. In general, the maximum area A = (l/2)^2 / 2. return (l / 2.0) ** 2 / 2.0"},{"question":"def total_candles(k: int, a: int) -> int: Returns the total number of whole candles each person will have after burning and remolding, given the initial number of candles k and the amount of wax required to form a new candle a. >>> total_candles(9, 3) 13 >>> total_candles(10, 5) 12 >>> total_candles(1, 2) 1 >>> total_candles(10**9, 10**9) 10**9 + 1 >>> total_candles(7, 3) 10 >>> total_candles(14, 4) 18 >>> total_candles(20, 5) 24 >>> total_candles(1_000_000, 2) 1_999_999 >>> total_candles(500_000, 3) 749_999","solution":"def total_candles(k, a): Returns the total number of whole candles each person will have after burning and remolding, given the initial number of candles k and the amount of wax required to form a new candle a. total = k leftover_wax = k while leftover_wax >= a: new_candles = leftover_wax // a total += new_candles leftover_wax = leftover_wax % a + new_candles return total"},{"question":"def numbers_with_three_distinct_prime_factors(N): Returns the first N numbers with exactly three distinct prime factors. def solve(test_cases): Solves the problem for multiple test cases. def main(input_data): Alice recently learned about prime numbers and is fascinated by them. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Alice wants to create a sequence where each number in the sequence has exactly three distinct prime factors. Write a program to help Alice find the first N numbers in such a sequence. Parameters: input_data (str): A string containing the number of test cases and the value of N for each test case. Returns: str: A string containing the first N numbers in the sequence, separated by spaces for each test case, each on a new line. >>> main(\\"2n3n5\\") \\"30 42 60n30 42 60 66 70\\" >>> main(\\"1n1\\") \\"30\\" >>> main(\\"1n6\\") \\"30 42 60 66 70 78\\" >>> main(\\"3n2n4n6\\") \\"30 42n30 42 60 66n30 42 60 66 70 78\\" >>> main(\\"1n10\\") \\"30 42 60 66 70 78 84 90 102 105\\"","solution":"import itertools from sympy import primefactors def numbers_with_three_distinct_prime_factors(N): Returns the first N numbers with exactly three distinct prime factors. result = [] num = 2 while len(result) < N: if len(primefactors(num)) == 3: result.append(num) num += 1 return result def solve(test_cases): Solves the problem for multiple test cases. results = [] for N in test_cases: results.append(numbers_with_three_distinct_prime_factors(N)) return results def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [int(lines[i]) for i in range(1, T + 1)] results = solve(test_cases) output_lines = [' '.join(map(str, result)) for result in results] return 'n'.join(output_lines)"},{"question":"from typing import List def unique_letter_sequences(s: str) -> int: Returns the number of unique sequences that can be made using every character of the string exactly once. >>> unique_letter_sequences('abc') 6 >>> unique_letter_sequences('aab') 3 >>> unique_letter_sequences('') 0 >>> unique_letter_sequences('aaaa') 1 >>> unique_letter_sequences('abcd') 24","solution":"from math import factorial from collections import Counter def unique_letter_sequences(s): Returns the number of unique sequences that can be made using every character of the string exactly once. if not s: return 0 # Count the frequency of each letter letter_count = Counter(s) # Calculate the factorial of the length of the string total_permutations = factorial(len(s)) # Divide by the factorial of the count for each letter to handle duplicates for count in letter_count.values(): total_permutations //= factorial(count) return total_permutations"},{"question":"def shortest_word(sentence: str) -> str: Returns the shortest word in the sentence. >>> shortest_word(\\"The quick brown fox jumps over the lazy dog\\") \\"The\\" >>> shortest_word(\\"Coding is fun\\") \\"is\\" >>> shortest_word(\\"A journey of a thousand miles begins with a single step\\") \\"A\\" >>> shortest_word(\\"Hello, world!\\") \\"Hello,\\" >>> shortest_word(\\"Wow, this is amazing!\\") \\"is\\" >>> shortest_word(\\"I am he\\") \\"I\\" >>> shortest_word(\\"We are us\\") \\"We\\"","solution":"def shortest_word(sentence): Returns the shortest word in the sentence. Parameters: sentence (str): A string representing a sentence. Returns: str: The shortest word in the sentence. words = sentence.split() shortest = words[0] for word in words: if len(word) < len(shortest): shortest = word return shortest"},{"question":"def max_consecutive_heads(n: int, k: int) -> int: Compute the maximum number of consecutive heads that can be present after performing exactly k flips. >>> max_consecutive_heads(5, 1) 4 >>> max_consecutive_heads(5, 2) 3 >>> max_consecutive_heads(5, 0) 5 >>> max_consecutive_heads(10, 10) 0 >>> max_consecutive_heads(10, 5) 5 >>> max_consecutive_heads(6, 4) 2 # Implementation here def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Process a list of test cases and return the results in the format required. >>> process_test_cases([(5, 1), (5, 2), (5, 0)]) [4, 3, 5] >>> process_test_cases([(10, 10), (10, 5), (6, 4)]) [0, 5, 2] # Implementation here","solution":"def max_consecutive_heads(n, k): Compute the maximum number of consecutive heads that can be present after performing exactly k flips. return min(n, n - k) def process_test_cases(test_cases): Process a list of test cases and return the results in the format required. results = [] for n, k in test_cases: results.append(max_consecutive_heads(n, k)) return results"},{"question":"def find132pattern(nums: List[int]) -> bool: Determine if the given array contains a 132 pattern. Args: nums: List[int] - list of unique positive integers Returns: bool - True if there is a 132 pattern, False otherwise. Example: >>> find132pattern([1, 2, 3, 4]) False >>> find132pattern([3, 1, 4, 2]) True >>> find132pattern([1, 3, 4, 2]) True","solution":"def find132pattern(nums): Determine if the given array contains a 132 pattern. Args: nums: List[int] - list of unique positive integers Returns: bool - True if there is a 132 pattern, False otherwise. # Early exit if the list is too small to form a 132 pattern if len(nums) < 3: return False # Stack to keep potential 3rd elements in descending order stack = [] # This will keep track of the middle element in 132 third_element = float('-inf') # Traverse the list from the end to the beginning for i in reversed(range(len(nums))): # If we find the 1st element which is smaller than the third_element if nums[i] < third_element: return True # Update stack and third_element while stack and nums[i] > stack[-1]: third_element = stack.pop() stack.append(nums[i]) return False"},{"question":"def smallest_required_number(n, arr): Returns the smallest integer X such that every element in the array can be made greater than or equal to X by adding some number of bits (or leaving it as is) to each number's binary representation. >>> smallest_required_number(3, [1, 3, 5]) 7 >>> smallest_required_number(4, [8, 2, 6, 7]) 15 >>> smallest_required_number(2, [4, 2]) 7 def process_input(input_lines): Processes the input lines and returns the results for each test case. >>> process_input([\\"3\\", \\"3\\", \\"1 3 5\\", \\"4\\", \\"8 2 6 7\\", \\"2\\", \\"4 2\\"]) [7, 15, 7]","solution":"def smallest_required_number(n, arr): Returns the smallest integer X such that every element in the array can be made greater than or equal to X by adding some number of bits (or leaving it as is) to each number's binary representation. max_val = max(arr) x = 1 while x <= max_val: x = (x << 1) | 1 return x def process_input(input_lines): Processes the input lines and returns the results for each test case. results = [] index = 0 t = int(input_lines[index]) index += 1 for _ in range(t): n = int(input_lines[index]) index += 1 arr = list(map(int, input_lines[index].split())) index += 1 results.append(smallest_required_number(n, arr)) return results"},{"question":"def highest_frequency_character(s: str) -> str: Returns the highest frequency character in the string \`s\`. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. >>> highest_frequency_character(\\"aabbbcc\\") == \\"b\\" >>> highest_frequency_character(\\"aabbcc\\") == \\"a\\" >>> highest_frequency_character(\\"aabbc\\") == \\"a\\" >>> highest_frequency_character(\\"xyz\\") == \\"x\\"","solution":"def highest_frequency_character(s): Returns the highest frequency character in the string \`s\`. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. from collections import Counter if not s: return None # Handle empty string case count = Counter(s) max_count = max(count.values()) for char in s: if count[char] == max_count: return char"},{"question":"class Stack: A Stack data structure with a maximum size of 100, supporting push, pop, and peek operations in O(1) time complexity. def __init__(self): # Initialize the stack and the top index pass def push(self, value): # Push the value onto the stack pass def pop(self): # Pop the top value from the stack pass def peek(self): # Peek at the top value of the stack pass def process_commands(commands): Processes a list of commands to manipulate the Stack. Args: commands (List[str]): A list of commands to be executed on the stack. Returns: List[Union[int, str]]: The results of \\"pop\\" and \\"peek\\" operations. pass # Unit Tests # def test_stack_push(): stack = Stack() stack.push(5) stack.push(10) assert stack.peek() == 10 assert stack.pop() == 10 assert stack.pop() == 5 def test_stack_pop_on_empty(): stack = Stack() assert stack.pop() == \\"Empty\\" def test_stack_peek_on_empty(): stack = Stack() assert stack.peek() == \\"Empty\\" def test_stack_operations(): stack = Stack() stack.push(1) stack.push(2) stack.push(3) assert stack.peek() == 3 assert stack.pop() == 3 assert stack.peek() == 2 assert stack.pop() == 2 assert stack.pop() == 1 assert stack.peek() == \\"Empty\\" assert stack.pop() == \\"Empty\\" def test_process_commands(): commands = [\\"push 10\\", \\"push 20\\", \\"peek\\", \\"pop\\", \\"pop\\", \\"pop\\"] expected_output = [20, 20, 10, \\"Empty\\"] assert process_commands(commands) == expected_output","solution":"class Stack: A Stack data structure with a maximum size of 100, supporting push, pop, and peek operations in O(1) time complexity. def __init__(self): self.stack = [0] * 100 self.top = -1 # indicates the index of the top element; -1 means empty stack def push(self, value): if self.top < 99: # Check if stack is not full self.top += 1 self.stack[self.top] = value else: raise IndexError(\\"Stack overflow\\") def pop(self): if self.top == -1: return \\"Empty\\" else: top_value = self.stack[self.top] self.top -= 1 return top_value def peek(self): if self.top == -1: return \\"Empty\\" else: return self.stack[self.top] def process_commands(commands): stack = Stack() results = [] for command in commands: if command.startswith(\\"push\\"): _, value = command.split() stack.push(int(value)) elif command == \\"pop\\": results.append(stack.pop()) elif command == \\"peek\\": results.append(stack.peek()) return results"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. Parameters: - matrix: A list of lists of integers representing the square matrix. Returns: - A new matrix that is the rotated version of the original matrix. >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_clockwise([[1]]) [[1]] >>> rotate_matrix_90_clockwise([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_matrix_90_clockwise([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) [[-7, -4, -1], [-8, -5, -2], [-9, -6, -3]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. Parameters: - matrix: A list of lists of integers representing the square matrix. Returns: - A new matrix that is the rotated version of the original matrix. n = len(matrix) # Create a new matrix of the same dimensions rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"def minDeletions(S: str) -> int: Returns the minimum number of deletions required to make all the remaining characters of S equal to the same character. Parameters: S (str): The input string consisting of lowercase Latin letters. Returns: int: The minimum number of deletions. Example: >>> minDeletions(\\"aabbcc\\") 4 >>> minDeletions(\\"abc\\") 2 >>> minDeletions(\\"aaaa\\") 0","solution":"def minDeletions(S): Returns the minimum number of deletions required to make all the remaining characters of S equal to the same character. Parameters: S (str): The input string consisting of lowercase Latin letters. Returns: int: The minimum number of deletions. from collections import Counter char_count = Counter(S) max_frequency = max(char_count.values()) # Calculate the number of deletions needed deletions = sum(count for count in char_count.values()) - max_frequency return deletions"},{"question":"def min_steps_to_last_floor(floors_steps): Calculate the minimum number of steps required to reach the last floor from the first floor. :param floors_steps: List of integers where each value represents the steps needed to move from one floor to the next. :return: Integer representing the minimum number of steps to reach the last floor. pass def process_test_cases(test_cases): Process multiple test cases for the min_steps_to_last_floor function. :param test_cases: List of tuples, where each tuple contains an integer N and a list of steps. :return: List of results for each test case. pass # Unit tests import pytest def test_min_steps_to_last_floor(): assert min_steps_to_last_floor([3, 2, 4, 5]) == 14 assert min_steps_to_last_floor([1, 1]) == 2 assert min_steps_to_last_floor([5, 6, 7, 8]) == 26 assert min_steps_to_last_floor([2, 3, 2, 3, 2]) == 12 assert min_steps_to_last_floor([10]) == 10 def test_process_test_cases(): test_cases = [(5, [3, 2, 4, 5]), (3, [1, 1])] expected_results = [14, 2] assert process_test_cases(test_cases) == expected_results test_cases = [(4, [7, 8, 9]), (2, [10])] expected_results = [24, 10] assert process_test_cases(test_cases) == expected_results test_cases = [(3, [1, 2]), (5, [1, 2, 3, 4])] expected_results = [3, 10] assert process_test_cases(test_cases) == expected_results","solution":"def min_steps_to_last_floor(floors_steps): Calculate the minimum number of steps required to reach the last floor from the first floor. :param floors_steps: List of integers where each value represents the steps needed to move from one floor to the next. :return: Integer representing the minimum number of steps to reach the last floor. return sum(floors_steps) def process_test_cases(test_cases): Process multiple test cases for the min_steps_to_last_floor function. :param test_cases: List of tuples, where each tuple contains an integer N and a list of steps. :return: List of results for each test case. results = [] for N, steps in test_cases: results.append(min_steps_to_last_floor(steps)) return results"},{"question":"from typing import List def generate_identifiers(names: List[str]) -> List[str]: Generate unique identifiers for a list of user names based on the described rules. >>> generate_identifiers([\\"alice\\"]) [\\"alice30\\"] >>> generate_identifiers([\\"alice\\", \\"bob\\", \\"charlie\\"]) [\\"alice30\\", \\"bob19\\", \\"charlie56\\"] >>> generate_identifiers([\\"a\\", \\"z\\"]) [\\"a1\\", \\"z26\\"] >>> generate_identifiers([\\"test\\", \\"test\\"]) [\\"test64\\", \\"test64\\"] >>> generate_identifiers([]) [] >>> generate_identifiers([\\"a\\" * 100]) [\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa100\\"] >>> generate_identifiers([\\"abcdefghijklmnopqrstuvwxyz\\"]) [\\"abcdefghijklmnopqrstuvwxyz351\\"]","solution":"from typing import List def generate_identifiers(names: List[str]) -> List[str]: def calculate_identifier(name: str) -> str: total_value = sum(map(lambda c: ord(c) - ord('a') + 1, name)) return f\\"{name}{total_value}\\" return [calculate_identifier(name) for name in names]"},{"question":"def min_fuel_to_destination(num_depots: int, total_distance: int, tank_capacity: int, depot_distances: List[int]) -> int: Determine the minimum fuel required to reach the destination. :param num_depots: Number of depots (excluding the source and destination). :param total_distance: The distance between the start port and the destination port. :param tank_capacity: The maximum fuel capacity of the ship. :param depot_distances: Distances of each depot from the starting port. :return: Minimum fuel required to reach the destination. >>> min_fuel_to_destination(2, 1000, 500, [300, 600]) 1000 >>> min_fuel_to_destination(0, 500, 500, []) 500 >>> min_fuel_to_destination(1, 1000, 300, [700]) -1 >>> min_fuel_to_destination(3, 1200, 400, [200, 600, 900]) 1200 >>> min_fuel_to_destination(3, 1000, 500, [400, 600, 800]) 1000","solution":"def min_fuel_to_destination(num_depots, total_distance, tank_capacity, depot_distances): Determine the minimum fuel required to reach the destination. :param num_depots: Number of depots (excluding the source and destination). :param total_distance: The distance between the start port and the destination port. :param tank_capacity: The maximum fuel capacity of the ship. :param depot_distances: Distances of each depot from the starting port. :return: Minimum fuel required to reach the destination. from bisect import bisect_right depots = depot_distances + [total_distance] current_pos = 0 fuel_used = 0 for next_depot in depots: if next_depot - current_pos > tank_capacity: return -1 # If the next depot is unreachable, return -1 indicating it's not possible. fuel_used += next_depot - current_pos current_pos = next_depot return max(fuel_used, tank_capacity)"},{"question":"def get_balanced_substring_lengths(test_cases): Determines the length of the shortest balanced substring for each test case. A string is called balanced if it contains an equal number of 'a', 'b', and 'c' characters. Parameters: test_cases (List[str]): List of input strings consisting of characters 'a', 'b', and 'c' only. Returns: List[int]: List of lengths of the shortest balanced substrings for each input string, or -1 if no such substring exists. >>> get_balanced_substring_lengths([\\"abccba\\", \\"abcabcabc\\", \\"aaabbbccc\\"]) [3, 3, 9] >>> get_balanced_substring_lengths([\\"aaa\\", \\"bbbb\\", \\"cc\\"]) [-1, -1, -1]","solution":"def shortest_balanced_substring_length(s): Determines the length of the shortest balanced substring consisting of equal number of 'a', 'b', and 'c' characters. Parameters: s (str): The input string containing characters 'a', 'b', and 'c' only. Returns: int: Length of the shortest balanced substring, or -1 if no such substring exists. n = len(s) if n < 3: return -1 # Helper function to check if a substring is balanced. def is_balanced(substr): return substr.count('a') == substr.count('b') == substr.count('c') min_length = float('inf') # Iterate over all possible substrings for i in range(n): for j in range(i + 2, n): if is_balanced(s[i:j + 1]): min_length = min(min_length, j - i + 1) if min_length == float('inf'): return -1 return min_length # Reading the input def get_balanced_substring_lengths(test_cases): result = [] for s in test_cases: result.append(shortest_balanced_substring_length(s)) return result"},{"question":"def total_pages_read(D: int, pages_list: List[int]) -> int: Calculate the total number of pages read over D days. Parameters: D (int): The number of days. pages_list (list): A list of integers representing the pages read each day. Returns: int: The total number of pages read. Examples: >>> total_pages_read(5, [10, 20, 30, 40, 50]) 150 >>> total_pages_read(3, [15, 10, 5]) 30","solution":"def total_pages_read(D, pages_list): Calculate the total number of pages read over D days. Parameters: D (int): The number of days. pages_list (list): A list of integers representing the pages read each day. Returns: int: The total number of pages read. return sum(pages_list)"},{"question":"def does_robot_return(instructions: str) -> str: Determines if a robot returns to the origin after executing a series of instructions. Args: instructions (str): A string containing 'U', 'D', 'L', and 'R' characters representing moves. Returns: str: \\"YES\\" if the robot returns to the origin, otherwise \\"NO\\". >>> does_robot_return(\\"UD\\") \\"YES\\" >>> does_robot_return(\\"LL\\") \\"NO\\" >>> does_robot_return(\\"URDL\\") \\"YES\\"","solution":"def does_robot_return(instructions): Determines if a robot returns to the origin after executing a series of instructions. Args: instructions (str): A string containing 'U', 'D', 'L', and 'R' characters representing moves. Returns: str: \\"YES\\" if the robot returns to the origin, otherwise \\"NO\\". x, y = 0, 0 for instruction in instructions: if instruction == 'U': y += 1 elif instruction == 'D': y -= 1 elif instruction == 'L': x -= 1 elif instruction == 'R': x += 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def is_valid_code(sequence: str) -> bool: Determine if the given sequence of characters represents a valid code adhering to the brackets pattern. >>> is_valid_code(\\"()\\") True >>> is_valid_code(\\"([])\\") True >>> is_valid_code(\\"([)]\\") False >>> is_valid_code(\\"((()))\\") True >>> is_valid_code(\\"{[}\\") False","solution":"def is_valid_code(sequence: str) -> bool: Return True if the input sequence of brackets is valid. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in sequence: if char in bracket_map.values(): # If the char is an opening bracket, push onto stack stack.append(char) elif char in bracket_map.keys(): # If the char is a closing bracket, check if it matches the top of stack if stack and stack[-1] == bracket_map[char]: stack.pop() else: return False else: # If the char is not a valid bracket character return False return not stack"},{"question":"def uniqueTables(M, t): Returns a list of unique table numbers sorted in ascending order. Parameters: M: int - number of elements in the array t t: list - list of table numbers Returns: list - sorted list of unique table numbers def test_uniqueTables_example_1(): assert uniqueTables(5, [3, 3, 5, 2, 5]) == [2, 3, 5] def test_uniqueTables_example_2(): assert uniqueTables(6, [9, 1, 1, 4, 7, 7]) == [1, 4, 7, 9] def test_uniqueTables_all_unique(): assert uniqueTables(5, [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_uniqueTables_all_repeated(): assert uniqueTables(5, [5, 5, 5, 5, 5]) == [5] def test_uniqueTables_single_element(): assert uniqueTables(1, [8]) == [8] def test_uniqueTables_empty_array(): assert uniqueTables(0, []) == [] def test_uniqueTables_mixed_order(): assert uniqueTables(7, [5, 0, 2, 8, 3, 1, 0]) == [0, 1, 2, 3, 5, 8]","solution":"def uniqueTables(M, t): Returns a list of unique table numbers sorted in ascending order. Parameters: M: int - number of elements in the array t t: list - list of table numbers Returns: list - sorted list of unique table numbers return sorted(set(t))"},{"question":"from typing import List def sort_names(name_list: List[str]) -> List[str]: Sorts a list of names based primarily on last name and secondarily on first name. Titles are ignored in the sorting order. Args: name_list (List[str]): List of names in the format \\"Title FirstName LastName\\" Returns: List[str]: Sorted list of names based on the specified criteria >>> sort_names([\\"Dr. John Smith\\", \\"Ms. Jane Doe\\", \\"Mr. Sam Brown\\"]) ['Mr. Sam Brown', 'Ms. Jane Doe', 'Dr. John Smith'] >>> sort_names([\\"Dr. Alice Smith\\", \\"Mr. Bob Smith\\", \\"Ms. Carol Smith\\"]) ['Dr. Alice Smith', 'Mr. Bob Smith', 'Ms. Carol Smith'] >>> sort_names([\\"Dr. Alice Brown\\", \\"Mr. Bob Smith\\", \\"Mrs. Carol Black\\"]) ['Mrs. Carol Black', 'Dr. Alice Brown', 'Mr. Bob Smith'] >>> sort_names([\\"Mr. John Doe\\"]) ['Mr. John Doe'] >>> sort_names([\\"Mr. John Aardvark\\", \\"Ms. Jane Zebra\\", \\"Dr. Alice Brown\\"]) ['Mr. John Aardvark', 'Dr. Alice Brown', 'Ms. Jane Zebra']","solution":"from typing import List def sort_names(name_list: List[str]) -> List[str]: Sorts a list of names based primarily on last name and secondarily on first name. Titles are ignored in the sorting order. Args: name_list (List[str]): List of names in the format \\"Title FirstName LastName\\" Returns: List[str]: Sorted list of names based on the specified criteria return sorted(name_list, key=lambda name: (name.split()[2], name.split()[1]))"},{"question":"def lexicographically_smallest_string(s: str) -> str: Finds the lexicographically smallest string that can be obtained by repeatedly moving any character of the string to the end. Args: s (str): The input string. Returns: str: The lexicographically smallest string. Example: >>> lexicographically_smallest_string(\\"bcda\\") \\"abcd\\" >>> lexicographically_smallest_string(\\"zyxwvut\\") \\"tuvwxyz\\"","solution":"def lexicographically_smallest_string(s: str) -> str: Finds the lexicographically smallest string that can be obtained by repeatedly moving any character of the string to the end. Args: s (str): The input string. Returns: str: The lexicographically smallest string. return ''.join(sorted(s))"},{"question":"def extractMax(S: str) -> int: Extract and return the maximum numeric value present in the string. If there are no numeric values in the string, return -1. >>> extractMax(\\"abc123xyz456def\\") 456 >>> extractMax(\\"abcdef\\") -1","solution":"import re def extractMax(S): Returns the maximum numeric value present in the string S. If there are no numeric values, returns -1. # Extract all numbers using regex numbers = re.findall(r'd+', S) # If there are no numbers, return -1 if not numbers: return -1 # Convert the numbers to integers and return the maximum return max(map(int, numbers))"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def max_goods_transport(N: int, routes: List[Tuple[int, int, int]]) -> int: Determine the maximum amount of goods that can be transported from the central station to any other station without violating the capacity limits of the trade routes. >>> max_goods_transport(4, [(1, 2, 5), (1, 3, 10), (3, 4, 4)]) 4 >>> max_goods_transport(5, [(3, 1, 7), (1, 2, 8), (2, 4, 5), (2, 5, 6)]) 5 >>> max_goods_transport(2, [(1, 2, 10)]) 10 >>> max_goods_transport(3, [(1, 2, 5), (1, 3, 5)]) 5 >>> max_goods_transport(6, [(1, 2, 7), (1, 3, 9), (2, 4, 2), (2, 5, 4), (3, 6, 6)]) 2","solution":"from collections import defaultdict, deque def max_goods_transport(N, routes): # Create adjacency list graph = defaultdict(list) for u, v, c in routes: graph[u].append((v, c)) graph[v].append((u, c)) # Function to perform BFS and find the maximum capacity to any node def bfs(): max_capacities = [-1] * (N + 1) max_capacities[1] = float('inf') queue = deque([1]) while queue: current = queue.popleft() for neighbor, capacity in graph[current]: if max_capacities[neighbor] == -1: max_capacities[neighbor] = min(max_capacities[current], capacity) queue.append(neighbor) return max_capacities max_capacities = bfs() return min(max_capacities[2:]) # Parsing input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) routes = [] index = 1 for i in range(N-1): u = int(data[index]) v = int(data[index+1]) c = int(data[index+2]) routes.append((u, v, c)) index += 3 print(max_goods_transport(N, routes))"},{"question":"def process_queries(m: int, q: int, knight_data: List[Tuple[int, int]], queries: List[str]) -> List[int]: Process the given knight combat queries. Parameters: - m: The initial number of knights. - q: The number of queries. - knight_data: A list of tuples where each tuple contains a knight identifier and their skill score. - queries: A list of queries in the format \\"Add k s\\" or \\"Query k\\". Returns: A list of integers representing the results of the \\"Query k\\" commands. Example: >>> m = 5 >>> q = 4 >>> knight_data = [(1, 150), (2, 200), (3, 50), (4, 175), (5, 100)] >>> queries = [\\"Query 1\\", \\"Add 6 220\\", \\"Query 2\\", \\"Query 6\\"] >>> process_queries(m, q, knight_data, queries) [2, 1, 0]","solution":"import bisect def process_queries(m, q, knight_data, queries): # Store knight identifier to skill mapping knight_skills = {k: s for k, s in knight_data} # Store just the list of skill levels in sorted order sorted_skills = sorted([s for _, s in knight_data]) results = [] for query in queries: parts = query.split() if parts[0] == \\"Add\\": _, k, s = parts k = int(k) s = int(s) knight_skills[k] = s bisect.insort_left(sorted_skills, s) elif parts[0] == \\"Query\\": _, k = parts k = int(k) skill = knight_skills[k] # Find count of knights who have skill greater than the queried knight's skill count = len(sorted_skills) - bisect.bisect_right(sorted_skills, skill) results.append(count) return results"},{"question":"def solve_gem_collections(test_cases): Given multiple test cases, determine the length of the shortest contiguous subarray of gems that contains at least one gem of each color. >>> solve_gem_collections([(7, 4, [1, 2, 3, 1, 4, 2, 3])]) [4] >>> solve_gem_collections([(5, 3, [1, 2, 3, 4, 5])]) [3] >>> solve_gem_collections([ ... (7, 4, [1, 2, 3, 1, 4, 2, 3]), ... (5, 3, [1, 2, 3, 4, 5]), ... (6, 3, [1, 1, 1, 1, 1, 1]) ... ]) [4, 3, -1] pass # Unit Test cases def test_case_1(): test_cases = [ (7, 4, [1, 2, 3, 1, 4, 2, 3]) ] assert solve_gem_collections(test_cases) == [4] def test_case_2(): test_cases = [ (5, 3, [1, 2, 3, 4, 5]) ] assert solve_gem_collections(test_cases) == [3] def test_case_3(): test_cases = [ (6, 3, [1, 1, 1, 1, 1, 1]) ] assert solve_gem_collections(test_cases) == [-1] def test_multiple_cases(): test_cases = [ (7, 4, [1, 2, 3, 1, 4, 2, 3]), (5, 3, [1, 2, 3, 4, 5]), (6, 3, [1, 1, 1, 1, 1, 1]) ] assert solve_gem_collections(test_cases) == [4, 3, -1] def test_no_valid_subarray(): test_cases = [ (3, 3, [1, 2, 2]) ] assert solve_gem_collections(test_cases) == [-1] def test_single_gem_each_color(): test_cases = [ (3, 3, [1, 2, 3]) ] assert solve_gem_collections(test_cases) == [3] def test_all_same_color(): test_cases = [ (5, 1, [2, 2, 2, 2, 2]) ] assert solve_gem_collections(test_cases) == [1]","solution":"def shortest_subarray_with_all_colors(n, m, colors): from collections import defaultdict unique_colors = set(colors) if len(unique_colors) < m: return -1 color_count = defaultdict(int) left = 0 min_length = float('inf') for right in range(n): color_count[colors[right]] += 1 while len(color_count) == m: min_length = min(min_length, right - left + 1) color_count[colors[left]] -= 1 if color_count[colors[left]] == 0: del color_count[colors[left]] left += 1 return min_length if min_length != float('inf') else -1 def solve_gem_collections(test_cases): results = [] for n, m, colors in test_cases: result = shortest_subarray_with_all_colors(n, m, colors) results.append(result) return results"},{"question":"def max_profit(prices: List[int]) -> int: Function to find the maximum profit that can be achieved from a single buy and sell operation. :param prices: List of stock prices over time. :return: Maximum profit that can be achieved. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Function to find the maximum profit that can be achieved from a single buy and sell operation. :param prices: List of stock prices over time. :return: Maximum profit that can be achieved. if not prices or len(prices) == 1: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def bubble_sort(arr): Sorts the given list of integers in non-decreasing order using bubble sort algorithm. Does not use any built-in sorting functions or methods. :param arr: List of integers :return: Sorted list of integers >>> bubble_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> bubble_sort([1]) [1] >>> bubble_sort([]) [] >>> bubble_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> bubble_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> bubble_sort([4, 5, 2, 2, 8, 8, 1]) [1, 2, 2, 4, 5, 8, 8]","solution":"def bubble_sort(arr): Sorts the given list of integers in non-decreasing order using bubble sort algorithm. Does not use any built-in sorting functions or methods. :param arr: List of integers :return: Sorted list of integers n = len(arr) # Traverse through all array elements for i in range(n - 1): # Last i elements are already in place for j in range(0, n - i - 1): # Traverse the array from 0 to n-i-1 # Swap if the element found is greater than the next element if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr"},{"question":"def minimize_square_sum(N: int, K: int) -> List[int]: This function returns a sequence of N positive integers such that the sum of their squares is minimized and the sum of the integers is exactly K. >>> minimize_square_sum(3, 6) [2, 2, 2] >>> minimize_square_sum(4, 10) [2, 2, 3, 3]","solution":"def minimize_square_sum(N, K): This function returns a sequence of N positive integers such that the sum of their squares is minimized and the sum of the integers is exactly K. base_value = K // N remainder = K % N result = [base_value] * N for i in range(remainder): result[i] += 1 return sorted(result)"},{"question":"def find_positions(lst, target): Returns the 1-based positions of the target number in the list. If the target number is not present, returns -1. >>> find_positions([4, 5, 6, 7, 5, 6, 4, 5, 8, 1], 5) [2, 5, 8] >>> find_positions([4, 5, 6, 7, 5, 6, 4, 5, 8, 1], 7) [4] >>> find_positions([4, 5, 6, 7, 5, 6, 4, 5, 8, 1], 10) [-1] >>> find_positions([1, 1, 1, 1], 1) [1, 2, 3, 4] # Implementation goes here # Helper function to parse input and format output def process_input(input_list, target): Parses the input, calls find_positions to get the result, and formats the output. >>> process_input(\\"4 5 6 7 5 6 4 5 8 1\\", \\"5\\") \\"2 5 8\\" >>> process_input(\\"4 5 6 7 5 6 4 5 8 1\\", \\"7\\") \\"4\\" >>> process_input(\\"4 5 6 7 5 6 4 5 8 1\\", \\"10\\") \\"-1\\" >>> process_input(\\"1 1 1 1\\", \\"1\\") \\"1 2 3 4\\" # Implementation goes here","solution":"def find_positions(lst, target): Returns the 1-based positions of the target number in the list. If the target number is not present, returns -1. positions = [index + 1 for index, num in enumerate(lst) if num == target] return positions if positions else [-1] # Helper function to parse input and format output def process_input(input_list, target): lst = list(map(int, input_list.split())) target = int(target) positions = find_positions(lst, target) return ' '.join(map(str, positions))"},{"question":"def minimum_construction_cost(n: int, heights: List[int]) -> int: Returns the minimum possible construction cost for a portal between two skyscrapers. Args: n (int): Number of skyscrapers. heights (List[int]): A list of integers representing the heights of the skyscrapers. Returns: int: The minimum possible construction cost. >>> minimum_construction_cost(3, [10, 20, 30]) 10 >>> minimum_construction_cost(4, [5, 8, 2, 11]) 3","solution":"def minimum_construction_cost(n, heights): Returns the minimum possible construction cost for a portal between two skyscrapers. :param n: Number of skyscrapers :param heights: A list of integers representing the heights of the skyscrapers :return: The minimum possible construction cost heights.sort() min_cost = float('inf') for i in range(1, n): cost = abs(heights[i] - heights[i - 1]) if cost < min_cost: min_cost = cost return min_cost # Examples of usage: # print(minimum_construction_cost(3, [10, 20, 30])) # print(minimum_construction_cost(4, [5, 8, 2, 11]))"},{"question":"def calculate_duration(start_time: str, end_time: str) -> int: Returns the duration between start_time and end_time in seconds. Parameters: start_time (str): Start time in HH:MM:SS format end_time (str): End time in HH:MM:SS format Returns: int: Duration in seconds >>> calculate_duration(\\"12:30:15\\", \\"14:45:30\\") == 8115 >>> calculate_duration(\\"00:00:00\\", \\"01:00:00\\") == 3600","solution":"def calculate_duration(start_time, end_time): Returns the duration between start_time and end_time in seconds. Parameters: start_time (str): Start time in HH:MM:SS format end_time (str): End time in HH:MM:SS format Returns: int: Duration in seconds start_h, start_m, start_s = map(int, start_time.split(':')) end_h, end_m, end_s = map(int, end_time.split(':')) start_total_seconds = start_h * 3600 + start_m * 60 + start_s end_total_seconds = end_h * 3600 + end_m * 60 + end_s return end_total_seconds - start_total_seconds"},{"question":"from typing import List, Tuple def max_subarray_sum(N: int, A: List[int], Q: int, Queries: List[Tuple[int, int]]) -> List[int]: You are given an array of N integers. Your task is to answer Q queries. In each query, you are given two integers L and R, and you need to find the maximum subarray sum for the subarray starting from index L and ending at index R (inclusive). Args: N: int - the length of the array A: List[int] - the array of N integers Q: int - the number of queries Queries: List[Tuple[int, int]] - list of Q pairs of integers Returns: List[int] - list of answers to each query Example: >>> N = 5 >>> A = [-2, 1, -3, 4, -1] >>> Q = 2 >>> Queries = [(1, 3), (0, 4)] >>> max_subarray_sum(N, A, Q, Queries) [4, 4] >>> N = 4 >>> A = [1, 2, 3, 4] >>> Q = 2 >>> Queries = [(1, 2), (0, 3)] >>> max_subarray_sum(N, A, Q, Queries) [5, 10] pass","solution":"def maxSubarraySum(N, A, Q, Queries): def kadane(arr): max_so_far = float('-inf') max_ending_here = 0 for x in arr: max_ending_here += x if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far result = [] for L, R in Queries: subarray = A[L:R+1] result.append(kadane(subarray)) return result"},{"question":"def is_back_to_origin(commands: str) -> bool: Determines if the robot returns to the origin (0, 0) after executing all the commands. :param commands: A string consisting of the characters 'U', 'D', 'L', 'R' representing the movement commands for the robot :return: True if the robot returns to the origin after executing all commands, False otherwise >>> is_back_to_origin(\\"UD\\") True >>> is_back_to_origin(\\"LLRR\\") True >>> is_back_to_origin(\\"UDLDR\\") False","solution":"def is_back_to_origin(commands: str) -> bool: Determines if the robot returns to the origin (0, 0) after executing all the commands. x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x == 0 and y == 0"},{"question":"def automorphicNumber(n: int) -> str: Given a number, find if it is Automorphic or not. An Automorphic number is a number whose square ends in the same digits as the number itself. Args: n (int): input number, always positive Returns: str: \\"Automorphic !!\\" if the number is Automorphic, \\"Not !!\\" otherwise Examples: >>> automorphicNumber(25) \\"Automorphic !!\\" >>> automorphicNumber(7) \\"Not !!\\" >>> automorphicNumber(76) \\"Automorphic !!\\" >>> automorphicNumber(5) \\"Automorphic !!\\" >>> automorphicNumber(6) \\"Automorphic !!\\" >>> automorphicNumber(10) \\"Not !!\\" >>> automorphicNumber(1) \\"Automorphic !!\\" >>> automorphicNumber(0) \\"Automorphic !!\\" >>> automorphicNumber(625) \\"Automorphic !!\\" >>> automorphicNumber(9376) \\"Automorphic !!\\" >>> automorphicNumber(123) \\"Not !!\\" >>> automorphicNumber(1729) \\"Not !!\\" pass","solution":"def automorphicNumber(n): Returns \\"Automorphic !!\\" if the number n is Automorphic. Otherwise, returns \\"Not !!\\". square = n * n return \\"Automorphic !!\\" if str(square).endswith(str(n)) else \\"Not !!\\""},{"question":"from typing import List, Dict, Any def most_frequent_songs(T: int, test_cases: List[Dict[str, Any]]) -> List[str]: Determine most frequently played song for each user. Args: T (int): Number of test cases. test_cases (List[Dict[str, Any]]): List of dictionaries containing: - 'N' (int): Number of different songs in the playlist. - 'M' (int): Number of users. - 'songs' (List[str]): List of song identifiers. - 'frequencies' (List[List[int]]): Frequency list representing number of times each user played each song. Returns: List[str]: List of most frequently played songs for each user. >>> most_frequent_songs(1, [ ... {'N': 3, 'M': 2, 'songs': [\\"songA\\", \\"songB\\", \\"songC\\"], ... 'frequencies': [[2, 1, 0], [1, 3, 2]]} ... ]) == ['songA', 'songB'] >>> most_frequent_songs(1, [ ... {'N': 4, 'M': 3, 'songs': [\\"song1\\", \\"song2\\", \\"song3\\", \\"song4\\"], ... 'frequencies': [[2, 2, 2, 2], [0, 0, 0, 1], [5, 5, 5, 4]]} ... ]) == ['song1', 'song4', 'song1'] >>> most_frequent_songs(2, [ ... {'N': 3, 'M': 2, 'songs': [\\"songX\\", \\"songY\\", \\"songZ\\"], ... 'frequencies': [[3, 1, 3], [1, 2, 3]]}, ... {'N': 2, 'M': 1, 'songs': [\\"songA\\", \\"songB\\"], ... 'frequencies': [[2, 2]]} ... ]) == ['songX', 'songZ', 'songA']","solution":"def most_frequent_songs(T, test_cases): results = [] for case in test_cases: N, M = case['N'], case['M'] songs = case['songs'] frequencies = case['frequencies'] for user_idx in range(M): max_freq = -1 fav_song = \\"\\" for song_idx in range(N): if frequencies[user_idx][song_idx] > max_freq: max_freq = frequencies[user_idx][song_idx] fav_song = songs[song_idx] elif frequencies[user_idx][song_idx] == max_freq: if songs[song_idx] < fav_song: fav_song = songs[song_idx] results.append(fav_song) return results # Example to run the function: # T = 1 # test_cases = [ # { # 'N': 3, # 'M': 2, # 'songs': [\\"songA\\", \\"songB\\", \\"songC\\"], # 'frequencies': [ # [2, 1, 0], # [1, 3, 2] # ] # } # ] # print(most_frequent_songs(T, test_cases))"},{"question":"def compress_string(s: str) -> str: Compresses the input string by replacing consecutive characters with the character followed by the count of repetitions. Args: s (str): The input string to compress. Returns: str: The compressed string. >>> compress_string(\\"aaabbcaaa\\") == \\"a3b2ca3\\" >>> compress_string(\\"abcd\\") == \\"abcd\\" >>> compress_string(\\"aabbccdd\\") == \\"a2b2c2d2\\"","solution":"def compress_string(s): Compresses the input string by replacing consecutive characters with the character followed by the count of repetitions. Args: s (str): The input string to compress. Returns: str: The compressed string. if not s: return \\"\\" compressed = [] count = 1 previous_char = s[0] for char in s[1:]: if char == previous_char: count += 1 else: if count > 1: compressed.append(f\\"{previous_char}{count}\\") else: compressed.append(previous_char) previous_char = char count = 1 if count > 1: compressed.append(f\\"{previous_char}{count}\\") else: compressed.append(previous_char) return \\"\\".join(compressed)"},{"question":"def is_pangram(s: str) -> bool: Determine if a given string contains every letter of the alphabet at least once. Case insensitivity should be considered, meaning 'A' and 'a' are considered the same. >>> is_pangram(\\"The quick brown fox jumps over the lazy dog\\") True >>> is_pangram(\\"Hello World\\") False >>> is_pangram(\\"\\") False >>> is_pangram(\\"abcdefg hijklmnop qrstuv\\") False >>> is_pangram(\\"abcdefGHIJKLMNOPQRSTUV wxyz1234567890!@#%^&*()\\") True >>> is_pangram(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz\\") True >>> is_pangram(\\"Pack my box with five dozen liquor jugs.\\") True >>> is_pangram(\\"aaaaaaaabbbbccccddddeeeeeffffffgggghhhhiiiiijjjkkklmnnnooopqqrrrsssttuuuuvvvwwxyz\\") True","solution":"def is_pangram(s): Returns True if the input string contains every letter of the alphabet at least once. Case insensitive. s = s.lower() # Make the string case insensitive alphabet = set('abcdefghijklmnopqrstuvwxyz') return alphabet.issubset(set(s))"},{"question":"from typing import List, Tuple def find_path(matrix: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Determine if there is a path from the start position to the end position in a given 2D grid matrix. Parameters: matrix (List[List[int]]): A 2D list of integers where 0 represents a walkable path and 1 represents a wall. start (Tuple[int, int]): A tuple (x, y) representing the starting position in the grid. end (Tuple[int, int]): A tuple (x, y) representing the end position in the grid. Returns: bool: True if there is a path from start to end, False otherwise. >>> matrix = [ >>> [0, 0, 1, 0], >>> [0, 1, 0, 0], >>> [0, 0, 0, 1], >>> [0, 1, 0, 0] >>> ] >>> start = (0, 0) >>> end = (3, 3) >>> find_path(matrix, start, end) True >>> matrix = [ >>> [0, 1, 1, 0], >>> [1, 1, 0, 0], >>> [0, 0, 0, 1], >>> [0, 1, 0, 0] >>> ] >>> start = (0, 0) >>> end = (3, 3) >>> find_path(matrix, start, end) False","solution":"from collections import deque def is_valid_move(matrix, x, y): return 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] == 0 def find_path(matrix, start, end): if start == end: return True rows, cols = len(matrix), len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] queue = deque([start]) visited[start[0]][start[1]] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy if (new_x, new_y) == end: return True if is_valid_move(matrix, new_x, new_y) and not visited[new_x][new_y]: visited[new_x][new_y] = True queue.append((new_x, new_y)) return False"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Determine if a word exists in a board constructed from sequentially adjacent cells. Args: board: List[List[str]]: m x n matrix of characters word: str: word to be searched in the board Returns: bool: True if the word exists, False otherwise Example: >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], 'ABCCED') True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], 'SEE') True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], 'ABCB') False","solution":"def exist(board, word): Determines if a word exists in a board constructed from sequentially adjacent cells. def dfs(board, word, i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False temp = board[i][j] board[i][j] = \\"#\\" # mark as visited found = ( dfs(board, word, i + 1, j, word_index + 1) or dfs(board, word, i - 1, j, word_index + 1) or dfs(board, word, i, j + 1, word_index + 1) or dfs(board, word, i, j - 1, word_index + 1) ) board[i][j] = temp # unmark return found for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0] and dfs(board, word, i, j, 0): return True return False"},{"question":"def sort_012_array(arr): Sorts the array containing only 0, 1, and 2 in non-decreasing order. >>> sort_012_array([0, 2, 1, 2, 0]) == [0, 0, 1, 2, 2] >>> sort_012_array([2, 1, 0]) == [0, 1, 2] >>> sort_012_array([2, 2, 2]) == [2, 2, 2] >>> sort_012_array([0, 0, 0]) == [0, 0, 0] >>> sort_012_array([1, 1, 1]) == [1, 1, 1] >>> sort_012_array([0, 2, 1]) == [0, 1, 2] pass def sort_multiple_test_cases(test_cases): This function accepts multiple test cases, sorts each one using the sort_012_array function, and returns the results for each test case. >>> sort_multiple_test_cases([[0, 2, 1, 2, 0], [2, 1, 0], [1, 0, 1, 0, 2, 1, 2], [2, 2, 2, 0, 0, 1, 1], [0, 0, 0, 0], [2, 2, 2, 2]]) == [[0, 0, 1, 2, 2], [0, 1, 2], [0, 0, 1, 1, 1, 2, 2], [0, 0, 1, 1, 2, 2, 2], [0, 0, 0, 0], [2, 2, 2, 2]] pass","solution":"def sort_012_array(arr): Sorts the array containing only 0, 1, and 2 in non-decreasing order. count = [0, 0, 0] # Count the occurrences of 0s, 1s, and 2s for num in arr: count[num] += 1 # Reconstruct the array based on the counts of 0s, 1s, and 2s sorted_arr = [0] * count[0] + [1] * count[1] + [2] * count[2] return sorted_arr def sort_multiple_test_cases(test_cases): This function accepts multiple test cases, sorts each one using the sort_012_array function, and returns the results for each test case. results = [] for arr in test_cases: sorted_arr = sort_012_array(arr) results.append(sorted_arr) return results"},{"question":"def max_skill_sum(n, k, skill_levels, pairs): Calculate the maximum possible sum of skill levels when participants are optimally paired to maximize their skill improvement. Arguments: n -- number of participants. k -- number of pairs of participants that can collaborate. skill_levels -- list of skill levels of the participants. pairs -- list of tuples, where each tuple contains two integers representing the participants that can collaborate. >>> max_skill_sum(5, 4, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]) 15 >>> max_skill_sum(3, 0, [5, 10, 15], []) 30 >>> max_skill_sum(4, 2, [1, 2, 3, 4], [(1, 2), (3, 4)]) 10 >>> max_skill_sum(3, 3, [3, 1, 2], [(1, 2), (2, 3), (1, 3)]) 6 >>> max_skill_sum(1, 0, [5], []) 5 >>> max_skill_sum(5, 4, [5, 10, 15, 20, 25], [(1, 2), (2, 3), (3, 4), (4, 5)]) 75","solution":"def max_skill_sum(n, k, skill_levels, pairs): from collections import defaultdict, deque # Create adjacency list for the graph adj_list = defaultdict(list) for u, v in pairs: adj_list[u - 1].append(v - 1) adj_list[v - 1].append(u - 1) visited = [False] * n def bfs(node): queue = deque([node]) component_sum = 0 while queue: current = queue.popleft() if not visited[current]: visited[current] = True component_sum += skill_levels[current] for neighbor in adj_list[current]: if not visited[neighbor]: queue.append(neighbor) return component_sum max_sum = 0 for i in range(n): if not visited[i]: max_sum += bfs(i) return max_sum"},{"question":"def sum_of_numbers(s: str) -> int: Returns the sum of all numbers in the string s. >>> sum_of_numbers(\\"12 4 85 3 0\\") 104 >>> sum_of_numbers(\\"25 75 a 17\\") 117 >>> sum_of_numbers(\\"\\") 0 >>> sum_of_numbers(\\"5\\") 5 >>> sum_of_numbers(\\"2 3 4\\") 9 >>> sum_of_numbers(\\"a b c\\") 0 >>> sum_of_numbers(\\" 7 11 13 \\") 31 >>> sum_of_numbers(\\"7xx9\\") 0 >>> sum_of_numbers(\\"45 78 x 1 23 67 y 8\\") 222","solution":"def sum_of_numbers(s: str) -> int: Returns the sum of all numbers in the string s. if not s: return 0 total_sum = 0 elements = s.split() for element in elements: try: total_sum += int(element) except ValueError: continue return total_sum"},{"question":"def min_initial_skill(t, test_cases): Determines the minimum initial skill level needed for each test case to stack all blocks Parameters: t (int): Number of test cases test_cases (list): List of tuples, each containing an integer n and a list of block difficulties Returns: list: Minimum initial skill level required for each test case >>> min_initial_skill(2, [(3, [3, 2, 5]), (4, [1, 1, 1, 1])]) [10, 4] >>> min_initial_skill(1, [(1, [5])]) [5]","solution":"def min_initial_skill(t, test_cases): Determines the minimum initial skill level needed for each test case to stack all blocks Parameters: t (int): Number of test cases test_cases (list): List of tuples, each containing an integer n and a list of block difficulties Returns: list: Minimum initial skill level required for each test case results = [] for test in test_cases: n, difficulties = test total_difficulty = sum(difficulties) results.append(total_difficulty) return results"},{"question":"from collections import deque def word_ladder(beginWord, endWord, wordList): Determine the shortest transformation sequence from a start word to an end word. >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) []","solution":"from collections import deque def word_ladder(beginWord, endWord, wordList): Returns the shortest transformation sequence from beginWord to endWord using the wordList. If no sequence is possible, returns an empty list. if endWord not in wordList: return [] wordList = set(wordList) queue = deque([[beginWord]]) visited = set([beginWord]) while queue: current_path = queue.popleft() current_word = current_path[-1] if current_word == endWord: return current_path # Generate all possible transformations by changing one letter at a time for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordList and next_word not in visited: visited.add(next_word) queue.append(current_path + [next_word]) return []"},{"question":"from typing import List def generate_sequence(N: int) -> List[int]: Generates a sequence of N distinct integers from 1 to N where the i-th integer is not equal to i. If it's impossible to form the sequence, return an empty list. Parameters: N (int): The length of the sequence. Returns: List[int]: A list of integers or an empty list if impossible to create the sequence. >>> generate_sequence(4) [2, 1, 4, 3] >>> generate_sequence(1) []","solution":"def generate_sequence(N): Generates a sequence of N distinct integers from 1 to N where the i-th integer is not equal to i. Parameters: N (int): The length of the sequence. Returns: List[int]: A list of integers or an empty list if impossible to create the sequence. if N == 1: return [] sequence = list(range(1, N + 1)) # Swap elements in pair to ensure no element is in its original position for i in range(1, N, 2): sequence[i-1], sequence[i] = sequence[i], sequence[i-1] return sequence"},{"question":"def evaluate_rpn(expression: str) -> int: Creates a function that evaluates a given string containing a mathematical expression in Reverse Polish Notation (RPN). >>> evaluate_rpn(\\"3 4 + 2 * 7 /\\") 2 >>> evaluate_rpn(\\"5 1 2 + 4 * + 3 -\\") 14","solution":"def evaluate_rpn(expression: str) -> int: stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): # If the token is an operand stack.append(int(token)) else: operand2 = stack.pop() operand1 = stack.pop() if token == '+': stack.append(operand1 + operand2) elif token == '-': stack.append(operand1 - operand2) elif token == '*': stack.append(operand1 * operand2) elif token == '/': stack.append(operand1 // operand2) return stack[0]"},{"question":"from typing import List, Tuple def run_length_encoding(arr: List[int]) -> List[Tuple[int, int]]: Determines the duration of each unique run of a given integer in an array. >>> run_length_encoding([1, 1, 2, 2, 2, 3, 3, 1, 1, 2]) [(1, 2), (2, 3), (3, 2), (1, 2), (2, 1)] >>> run_length_encoding([5, 5, 5, 6]) [(5, 3), (6, 1)] >>> run_length_encoding([]) []","solution":"from typing import List, Tuple def run_length_encoding(arr: List[int]) -> List[Tuple[int, int]]: if not arr: return [] result = [] current_value = arr[0] current_count = 1 for i in range(1, len(arr)): if arr[i] == current_value: current_count += 1 else: result.append((current_value, current_count)) current_value = arr[i] current_count = 1 result.append((current_value, current_count)) return result"},{"question":"def is_valid_message(s: str) -> bool: Returns True if the string s is a valid message according to the rules: - It contains no more than one 'B'. - It contains no more than two 'C's. >>> is_valid_message(\\"AAC\\") True >>> is_valid_message(\\"BBC\\") False >>> is_valid_message(\\"CCB\\") True >>> is_valid_message(\\"CCCC\\") False","solution":"def is_valid_message(s: str) -> bool: Returns True if the string s is a valid message according to the rules: - It contains no more than one 'B'. - It contains no more than two 'C's. return s.count('B') <= 1 and s.count('C') <= 2"},{"question":"def minimal_moves(n: int, m: int, t: str) -> int: Find the minimal number of moves needed to reach the last character of the string. Parameters: n (int): The length of the string. m (int): The maximum jump length. t (str): The string. Returns: int: The minimal number of moves. Examples: >>> minimal_moves(10, 2, \\"abcdefghij\\") 5 >>> minimal_moves(15, 4, \\"123456789012345\\") 4","solution":"from collections import deque def minimal_moves(n, m, t): Find the minimal number of moves needed to reach the last character of the string. # Initialize a deque for BFS and a list to track visited indices queue = deque([(0, 0)]) # (current_index, move_count) visited = [False] * n visited[0] = True while queue: current, moves = queue.popleft() # Return the number of moves if we reached the last character if current == n - 1: return moves # Try to move to all positions within the maximum jump length for i in range(max(0, current - m), min(n, current + m + 1)): if not visited[i]: visited[i] = True queue.append((i, moves + 1)) # Example usage n = 10 m = 2 t = \\"abcdefghij\\" print(minimal_moves(n, m, t)) # Output: 5"},{"question":"def sum_triangle_numbers(n: int, m: int) -> int: Calculate the sum of all triangle numbers up to T(n) modulo m. Parameters: n (int): The maximum n-th triangle number to consider. m (int): The modulo value. Returns: int: The sum of all triangle numbers up to T(n) modulo m. Example: >>> sum_triangle_numbers(4, 100) 20 >>> sum_triangle_numbers(1, 10) 1","solution":"def sum_triangle_numbers(n, m): Calculate the sum of all triangle numbers up to T(n) modulo m. Parameters: n (int): The maximum n-th triangle number to consider. m (int): The modulo value. Returns: int: The sum of all triangle numbers up to T(n) modulo m. triangle_sum = 0 for i in range(1, n + 1): triangle_sum += i * (i + 1) // 2 triangle_sum %= m # applying modulo to avoid large intermediate values return triangle_sum"},{"question":"def next_char_in_alphabet(s: str) -> str: Takes a string and returns the string with all characters replaced by the next character in the alphabet. Non-alphabetic characters remain unchanged. If the character is 'z' or 'Z', they are wrapped to 'a' or 'A', respectively. >>> next_char_in_alphabet('Hello, World!') 'Ifmmp, Xpsme!' >>> next_char_in_alphabet('abc') 'bcd' >>> next_char_in_alphabet('XYZ') 'YZA' >>> next_char_in_alphabet('a1zZ!') 'b1aA!'","solution":"def next_char_in_alphabet(s): Takes a string and returns the string with all alphabetic characters replaced by the next character in the alphabet. Non-alphabetic characters remain unchanged. result = [] for char in s: if 'a' <= char <= 'z': if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) elif 'A' <= char <= 'Z': if char == 'Z': result.append('A') else: result.append(chr(ord(char) + 1)) else: result.append(char) return ''.join(result)"},{"question":"def max_non_overlapping_events(n, events): Returns the maximum number of non-overlapping events. Parameters: n (int): number of events events (list of tuples): each tuple contains two integers representing start and end time of an event Returns: int: maximum number of non-overlapping events >>> max_non_overlapping_events(4, [(1, 4), (2, 3), (3, 5), (6, 8)]) == 3 >>> max_non_overlapping_events(3, [(1, 2), (2, 3), (3, 4)]) == 3 >>> max_non_overlapping_events(5, [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) == 5 >>> max_non_overlapping_events(3, [(1, 5), (2, 6), (3, 7)]) == 1 >>> max_non_overlapping_events(4, [(1, 3), (2, 4), (5, 7), (6, 8)]) == 2 >>> max_non_overlapping_events(1, [(0, 10)]) == 1 >>> max_non_overlapping_events(4, [(1, 2), (1, 2), (1, 2), (1, 2)]) == 1","solution":"def max_non_overlapping_events(n, events): Returns the maximum number of non-overlapping events. Parameters: n (int): number of events events (list of tuples): each tuple contains two integers representing start and end time of an event Returns: int: maximum number of non-overlapping events # sorting events based on end time events.sort(key=lambda x: x[1]) # initialising the end time of the last attended event last_end_time = 0 # maximum number of non-overlapping events max_events = 0 # traversing through each event for start, end in events: if start >= last_end_time: # attending this event max_events += 1 last_end_time = end return max_events # Example usage: # n = 4 # events = [(1, 4), (2, 3), (3, 5), (6, 8)] # print(max_non_overlapping_events(n, events)) # Should print 3"},{"question":"def min_operations_to_transform(A: str, B: str) -> int: Given two strings A and B of the same length, returns the minimum number of operations required to transform string A into string B by changing characters. >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"abc\\", \\"def\\") 3 >>> min_operations_to_transform(\\"abcd\\", \\"abef\\") 2 >>> min_operations_to_transform(\\"a\\", \\"b\\") 1 >>> min_operations_to_transform(\\"aaaabbbb\\", \\"bbbbaaaa\\") 8 >>> min_operations_to_transform(\\"a\\" * 100, \\"b\\" * 100) 100","solution":"def min_operations_to_transform(A, B): Returns the minimum number of operations required to transform string A into string B. if len(A) != len(B): raise ValueError(\\"Strings A and B must be of the same length.\\") operations = 0 for a, b in zip(A, B): if a != b: operations += 1 return operations if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() A, B = data[0], data[1] result = min_operations_to_transform(A, B) print(result)"},{"question":"def min_steps_to_reduce_to_one(N: int) -> int: Calculate the minimum number of steps required to reduce N to 1 using prime divisors larger than 1. Args: N (int): The initial number to be reduced. Returns: int: The number of steps required to reduce N to 1. Examples: >>> min_steps_to_reduce_to_one(10) 2 >>> min_steps_to_reduce_to_one(27) 3 >>> min_steps_to_reduce_to_one(4) 2 >>> min_steps_to_reduce_to_one(7) 1 >>> min_steps_to_reduce_to_one(8) 3 >>> min_steps_to_reduce_to_one(999983) 1","solution":"def min_steps_to_reduce_to_one(N): Calculate the minimum number of steps required to reduce N to 1 using prime divisors larger than 1. Args: N (int): The initial number to be reduced. Returns: int: The number of steps required to reduce N to 1. def prime_factors_count(n): count = 0 # Start dividing by 2 while n % 2 == 0: n //= 2 count += 1 # Check for odd factors factor = 3 while n != 1: while n % factor == 0: n //= factor count += 1 factor += 2 return count return prime_factors_count(N)"},{"question":"def balanced_parentheses(n: int) -> int: Calculate the number of different balanced parentheses strings of length 2n. Return the result modulo 10^9 + 7. >>> balanced_parentheses(3) 5 >>> balanced_parentheses(4) 14 >>> balanced_parentheses(1) 1 >>> balanced_parentheses(5) 42","solution":"def balanced_parentheses(n): MOD = 10**9 + 7 # Calculate the nth Catalan number catalan = [0] * (n + 1) catalan[0] = 1 for i in range(1, n + 1): catalan[i] = 0 for j in range(i): catalan[i] = (catalan[i] + catalan[j] * catalan[i - 1 - j]) % MOD return catalan[n]"},{"question":"def categorize_image(image: str) -> str: Categorizes the given image string into one of the categories: 'Animal', 'Vehicle', or 'Plant'. Args: image (str): The string representation of the image with lowercase letters. Returns: str: The category of the image. >>> categorize_image(\\"animmalph\\") 'Animal' >>> categorize_image(\\"vehcell\\") 'Vehicle' >>> categorize_image(\\"plantpa\\") 'Plant' >>> categorize_image(\\"nalanitaal\\") 'Animal' >>> categorize_image(\\"vheclpant\\") 'Plant' >>> categorize_image(\\"anivhlanc\\") 'Animal'","solution":"def categorize_image(image): Categorizes the given image string into one of the categories: 'Animal', 'Vehicle', or 'Plant'. Args: image (str): The string representation of the image with lowercase letters. Returns: str: The category of the image. features_count = {'Animal': 0, 'Vehicle': 0, 'Plant': 0} animal_features = {'a', 'n', 'i', 'm', 'l'} vehicle_features = {'v', 'e', 'h', 'c', 'l'} plant_features = {'p', 'a', 'n', 't', 'l'} for char in image: if char in animal_features: features_count['Animal'] += 1 if char in vehicle_features: features_count['Vehicle'] += 1 if char in plant_features: features_count['Plant'] += 1 # Sort categories and return the one with the highest count, using dictionary order in case of tie categories_sorted = sorted(features_count.keys()) predominant_category = max(categories_sorted, key=lambda k: features_count[k]) return predominant_category"},{"question":"def organize_library(n: int, titles: List[str]) -> List[str]: Organize John's library by sorting book titles in a case-insensitive manner, with lowercase titles coming before uppercase titles when the titles are the same. Args: n : int : number of book titles titles : list of str : list of book titles Returns: list of str : sorted list of book titles Examples: >>> organize_library(5, [ ... \\"The Hobbit\\", ... \\"harry potter\\", ... \\"Moby Dick\\", ... \\"harry potter and the Chamber of Secrets\\", ... \\"THE GREAT GATSBY\\" ... ]) == [ ... \\"harry potter\\", ... \\"harry potter and the Chamber of Secrets\\", ... \\"Moby Dick\\", ... \\"THE GREAT GATSBY\\", ... \\"The Hobbit\\" ... ] >>> organize_library(4, [ ... \\"alpha\\", ... \\"Beta\\", ... \\"ALPHA\\", ... \\"BETA\\" ... ]) == [ ... \\"ALPHA\\", ... \\"alpha\\", ... \\"BETA\\", ... \\"Beta\\" ... ] >>> organize_library(1, [\\"OnlyBook\\"]) == [\\"OnlyBook\\"] >>> organize_library(3, [\\"apple\\", \\"Apple\\", \\"APPLE\\"]) == [\\"APPLE\\", \\"Apple\\", \\"apple\\"]","solution":"def sort_books(titles): Sorts a list of book titles in a case-insensitive manner, with lowercase titles appearing before uppercase when the lowercased titles are the same. return sorted(titles, key=lambda title: (title.lower(), title)) def organize_library(n, titles): Organize John's library by sorting book titles and return the sorted list. Args: n : int : number of book titles titles : list of str : list of book titles Returns: list of str : sorted list of book titles return sort_books(titles)"},{"question":"def canFormAP(nums, n, d): Determines if there is a subsequence of length n that can be rearranged to form an arithmetic progression with common difference d. :param nums: List of integers :param n: Length of subsequence :param d: Common difference of AP :return: Boolean indicating if such a subsequence exists >>> canFormAP([3, 5, 1, 7, 9, 11], 3, 2) True >>> canFormAP([1, 2, 4, 6, 8], 3, 3) False","solution":"def canFormAP(nums, n, d): Determines if there is a subsequence of length n that can be rearranged to form an arithmetic progression with common difference d. :param nums: List of integers :param n: Length of subsequence :param d: Common difference of AP :return: Boolean indicating if such a subsequence exists if n == 1: return True num_set = set(nums) for num in nums: count = 0 current = num # Try to form n elements AP starting with current number while current in num_set and count < n: current += d count += 1 if count == n: return True return False"},{"question":"def extract_unique_digits(sequence: str) -> str: Extracts unique digits from a sequence, preserving the order of their first occurrence. >>> extract_unique_digits('1234321') '1234' >>> extract_unique_digits('9876543210') '9876543210' >>> extract_unique_digits('1111111') '1' >>> extract_unique_digits('2222222') '2' >>> extract_unique_digits('1212121212') '12' >>> extract_unique_digits('90909090') '90' >>> extract_unique_digits('') '' >>> extract_unique_digits('5') '5' >>> extract_unique_digits('0') '0' >>> extract_unique_digits('10234567890123456789') '1023456789' >>> extract_unique_digits('91827364554637281910') '9182736450'","solution":"def extract_unique_digits(sequence): Extracts unique digits from a sequence, preserving the order of their first occurrence. Args: sequence (str): A string containing a sequence of digits. Returns: str: A string with subsequent occurrences of digits removed. seen = set() result = [] for digit in sequence: if digit not in seen: seen.add(digit) result.append(digit) return ''.join(result)"},{"question":"from typing import List def min_steps_to_reach_destination(M: int, N: int, grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int: Calculate the minimum number of steps required to reach the destination from the starting position in a warehouse grid. >>> min_steps_to_reach_destination(5, 5, [\\".....\\", \\"..#..\\", \\"..#P.\\", \\"P.#..\\", \\".....\\"], 1, 0, 3, 4) 8 >>> min_steps_to_reach_destination(3, 3, [\\"...\\", \\".#.\\", \\"...\\"], 0, 0, 2, 2) 4 >>> min_steps_to_reach_destination(4, 4, [\\"....\\", \\"..\\", \\"..\\", \\"....\\"], 0, 0, 3, 3) 6 >>> min_steps_to_reach_destination(3, 3, [\\"...\\", \\"#\\", \\"...\\"], 0, 0, 2, 2) -1 >>> min_steps_to_reach_destination(3, 3, [\\"...\\", \\".#.\\", \\"...\\"], 1, 1, 1, 1) 0","solution":"from collections import deque def min_steps_to_reach_destination(M, N, grid, start_row, start_col, end_row, end_col): def is_valid(r, c): return 0 <= r < M and 0 <= c < N and grid[r][c] != '#' def bfs(start_row, start_col, end_row, end_col): queue = deque([(start_row, start_col, 0)]) visited = set() visited.add((start_row, start_col)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right while queue: r, c, steps = queue.popleft() if r == end_row and c == end_col: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc) and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 return bfs(start_row, start_col, end_row, end_col)"},{"question":"def longest_increasing_subsequence(seq): Returns the longest increasing subsequence in a sequence of numbers. If there are multiple subsequences of the same length, return the one that occurs first in the order of appearance. pass def process_input(test_cases): Process multiple test cases to determine the longest increasing subsequence for each case. Arguments: test_cases -- List of test cases, where each test case is a list of integers (employee IDs). Returns: List of strings, where each string is a space-separated sequence of integers representing the longest increasing subsequence for each test case. pass def main(): import sys input = sys.stdin.read lines = input().strip().split(\\"n\\") T = int(lines[0]) test_cases = [] for i in range(1, T + 1): seq = list(map(int, lines[i].strip().split())) test_cases.append(seq) results = process_input(test_cases) for res in results: print(res) # Test cases def test_lis_single_test_case(): assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [10, 22, 33, 50, 60, 80] def test_lis_single_test_case_short(): assert longest_increasing_subsequence([5, 8, 7, 1, 9]) == [5, 8, 9] def test_lis_single_test_case_already_sorted(): assert longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_process_input_multiple_test_cases(): input_data = [ [10, 22, 9, 33, 21, 50, 41, 60, 80], [5, 8, 7, 1, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9] ] expected_output = [ \\"10 22 33 50 60 80\\", \\"5 8 9\\", \\"1 2 3 4 5 6 7 8 9\\" ] assert process_input(input_data) == expected_output def test_lis_all_same_elements(): assert longest_increasing_subsequence([3, 3, 3, 3, 3]) == [3] def test_lis_descending_order(): assert longest_increasing_subsequence([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [9]","solution":"def longest_increasing_subsequence(seq): Returns the longest increasing subsequence in a sequence of numbers. If there are multiple subsequences of the same length, return the one that occurs first in the order of appearance. n = len(seq) lis = [[] for _ in range(n)] # Initializing the first element of lis lis[0] = [seq[0]] # Compute optimized LIS values for i in range(1, n): for j in range(i): # Check if seq[i] can be appended to the end of lis[j] if seq[i] > seq[j] and len(lis[i]) < len(lis[j]): lis[i] = lis[j][:] lis[i].append(seq[i]) # Get the longest subsequence max_len = 0 max_seq = [] for subseq in lis: if len(subseq) > max_len: max_len = len(subseq) max_seq = subseq return max_seq def process_input(test_cases): results = [] for seq in test_cases: lis = longest_increasing_subsequence(seq) results.append(\\" \\".join(map(str, lis))) return results def main(): import sys input = sys.stdin.read lines = input().strip().split(\\"n\\") T = int(lines[0]) test_cases = [] for i in range(1, T + 1): seq = list(map(int, lines[i].strip().split())) test_cases.append(seq) results = process_input(test_cases) for res in results: print(res)"},{"question":"def generate_rhythmic_sequence(n: int, k: int) -> list: Generates a rhythmic sequence of length n where every i-th integer is (i % k) + 1. Args: n: int - the length of the sequence. k: int - the modulo divisor. Returns: list: the generated rhythmic sequence. >>> generate_rhythmic_sequence(10, 3) [1, 2, 3, 1, 2, 3, 1, 2, 3, 1] >>> generate_rhythmic_sequence(7, 5) [1, 2, 3, 4, 5, 1, 2]","solution":"def generate_rhythmic_sequence(n, k): Generates a rhythmic sequence of length n where every i-th integer is (i % k) + 1. return [(i % k) + 1 for i in range(n)]"},{"question":"def characterFrequency(S: str) -> dict: Given a string S, return the frequency of each character in the string in the form of a dictionary. Args: S (str): the input string Returns: dict: dictionary with characters as keys and their frequencies as values Example 1: >>> characterFrequency(\\"teststring\\") {'t': 3, 'e': 1, 's': 2, 'r': 1, 'i': 1, 'n': 1, 'g': 1} Example 2: >>> characterFrequency(\\"apple\\") {'a': 1, 'p': 2, 'l': 1, 'e': 1} from solution import characterFrequency def test_characterFrequency_example1(): assert characterFrequency(\\"teststring\\") == {'t': 3, 'e': 1, 's': 2, 'r': 1, 'i': 1, 'n': 1, 'g': 1} def test_characterFrequency_example2(): assert characterFrequency(\\"apple\\") == {'a': 1, 'p': 2, 'l': 1, 'e': 1} def test_characterFrequency_empty_string(): assert characterFrequency(\\"\\") == {} def test_characterFrequency_single_character_string(): assert characterFrequency(\\"a\\") == {'a': 1} def test_characterFrequency_all_unique_characters(): assert characterFrequency(\\"abcdef\\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1} def test_characterFrequency_repeated_characters(): assert characterFrequency(\\"aaaabbbb\\") == {'a': 4, 'b': 4}","solution":"def characterFrequency(S): Returns the frequency of each character in the string S. Parameters: S (str): the input string Returns: dict: dictionary with characters as keys and their frequencies as values frequency = {} for char in S: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def people_seeing_sunset(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Determines how many people can see the sunset for each test case. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): Each test case is a tuple where the first element is the number of buildings, the second element is a list of heights of the buildings, and the third element is a list of number of people living in each building. Returns: List[int]: List of integers denoting the number of people who can see the sunset for each test case. Example: >>> people_seeing_sunset(2, [(5, [3, 5, 4, 4, 2], [10, 20, 10, 15, 5]), (4, [1, 3, 2, 4], [5, 7, 3, 6])]) [30, 18] >>> people_seeing_sunset(1, [(1, [3], [10])]) [10] >>> people_seeing_sunset(1, [(4, [4, 3, 2, 1], [10, 20, 30, 40])]) [10] >>> people_seeing_sunset(1, [(3, [3, 3, 3], [10, 10, 10])]) [10] >>> people_seeing_sunset(1, [(6, [1, 2, 3, 2, 5, 1], [10, 20, 30, 40, 50, 60])]) [110]","solution":"def people_seeing_sunset(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] people = test_cases[i][2] max_height = 0 total_people = 0 for j in range(n): if heights[j] > max_height: total_people += people[j] max_height = heights[j] results.append(total_people) return results"},{"question":"def removeDuplicates(s: str) -> str: Returns a string with all characters that have already appeared previously removed. >>> removeDuplicates(\\"bananas\\") 'bans' >>> removeDuplicates(\\"programming\\") 'progamin' >>> removeDuplicates(\\"mississippi\\") 'misp'","solution":"def removeDuplicates(s): Returns a string with all characters that have already appeared previously removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def maxForestArea(r: int, c: int, grid: List[str]) -> int: Given a grid with r rows and c columns, this function returns the area of the largest rectangle composed entirely of forest tiles ('F'). >>> maxForestArea(3, 3, [\\"WFW\\", \\"FWF\\", \\"FFF\\"]) 3 >>> maxForestArea(4, 5, [\\"MFMFM\\", \\"FFMFF\\", \\"FMFFF\\", \\"FFFFF\\"]) 6 >>> maxForestArea(2, 2, [\\"WW\\", \\"WM\\"]) 0 >>> maxForestArea(3, 3, [\\"FFF\\", \\"FFF\\", \\"FFF\\"]) 9 >>> maxForestArea(5, 1, [\\"F\\", \\"F\\", \\"M\\", \\"F\\", \\"F\\"]) 2 >>> maxForestArea(1, 7, [\\"FWFFMWF\\"]) 2","solution":"def maxForestArea(r, c, grid): Given a grid with r rows and c columns, this function returns the area of the largest rectangle composed entirely of forest tiles ('F'). # Histogram heights for each column, initialized to 0 heights = [0] * c max_area = 0 for row in grid: for i in range(c): # Increase height if 'F', reset height to 0 otherwise if row[i] == 'F': heights[i] += 1 else: heights[i] = 0 # Calculate maximum area of histogram after each row max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): Given a list of integers representing the heights of a histogram, this function returns the area of the largest rectangle that can be formed in the histogram. stack = [] max_area = 0 heights.append(0) # Append a 0 to ensure we process all heights for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area # Example usage: # r, c = 4, 5 # grid = ['MFMFM', 'FFMFF', 'FMFFF', 'FFFFF'] # print(maxForestArea(r, c, grid)) # Output: 6"},{"question":"def left_rotate(arr, n, k): Returns the array after rotating it k times to the left. You are given an array arr[] and a positive integer k. You have to rotate the array arr[] k times to the left. After k rotations, return the resulting array. Example 1: Input : n=5, arr[] = {1, 2, 3, 4, 5}, k=2 Output : 3 4 5 1 2 Explanation: After 1st rotation: {2, 3, 4, 5, 1} After 2nd rotation: {3, 4, 5, 1, 2} Hence, the new array after 2 rotations is {3, 4, 5, 1, 2}. Example 2: Input : n=4, arr[] = {10, 20, 30, 40}, k=1 Output : 20 30 40 10 Explanation: After 1 rotation: {20, 30, 40, 10} Hence, the new array after 1 rotation is {20, 30, 40, 10}. Constraints: 1 ≤ N ≤ 10^5 1 ≤ arr[i] ≤ 10^7 0 ≤ k < 10^5 pass","solution":"def left_rotate(arr, n, k): Returns the array after rotating it k times to the left. if k == 0 or k % n == 0: return arr k = k % n # Optimize for cases where k > n return arr[k:] + arr[:k]"},{"question":"def minimum_credits_to_avoid_penalty(N: int, test_cases: List[Tuple[int, int]]) -> List[int]: Given total credits C you have and the minimum credits M required to avoid penalty, determine the minimum credits you need to allocate to maintenance. >>> minimum_credits_to_avoid_penalty(3, [(10, 3), (7, 2), (5, 1)]) [7, 5, 4] >>> minimum_credits_to_avoid_penalty(1, [(100, 1)]) [99] pass # Your code here # Function to parse input and return results def chefville(input_string: str) -> List[int]: lines = input_string.strip().split('n') N = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:]] return minimum_credits_to_avoid_penalty(N, test_cases) # Unit Tests def test_chefville_sample_input(): input_data = \\"3n10 3n7 2n5 1\\" expected_output = [7, 5, 4] assert chefville(input_data) == expected_output def test_chefville_edge_case(): input_data = \\"1n100 1\\" expected_output = [99] assert chefville(input_data) == expected_output def test_chefville_general_case_1(): input_data = \\"2n20 10n50 30\\" expected_output = [10, 20] assert chefville(input_data) == expected_output def test_chefville_general_case_2(): input_data = \\"2n99 50n80 40\\" expected_output = [49, 40] assert chefville(input_data) == expected_output def test_chefville_same_C_and_M(): input_data = \\"2n100 99n50 1\\" expected_output = [1, 49] assert chefville(input_data) == expected_output","solution":"def minimum_credits_to_avoid_penalty(N, test_cases): results = [] for C, M in test_cases: results.append(C - M) return results # Function to parse input and return results def chefville(input_string): lines = input_string.strip().split('n') N = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:]] return minimum_credits_to_avoid_penalty(N, test_cases)"},{"question":"def parentheses(n: int) -> List[str]: Generates all combinations of n pairs of balanced parentheses. >>> parentheses(1) == [\\"()\\"] >>> parentheses(2) == [\\"(())\\", \\"()()\\"] >>> parentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]","solution":"def parentheses(n): Generates all combinations of n pairs of balanced parentheses. def generate(s, left, right, result): if left == 0 and right == 0: result.add(s) return if left > 0: generate(s + '(', left - 1, right, result) if right > left: generate(s + ')', left, right - 1, result) result = set() generate('', n, n, result) return sorted(result)"},{"question":"def print_char_with_ascii(input_string): Prints each character of the input string on a new line followed by its ASCII value. >>> print_char_with_ascii(\\"hello\\") h: 104 e: 101 l: 108 l: 108 o: 111 >>> print_char_with_ascii(\\"\\") >>> print_char_with_ascii(\\"123\\") 1: 49 2: 50 3: 51 >>> print_char_with_ascii(\\"!@#\\") !: 33 @: 64 #: 35 >>> print_char_with_ascii(\\"a1!\\") a: 97 1: 49 !: 33","solution":"def print_char_with_ascii(input_string): Prints each character of the input string on a new line followed by its ASCII value. for char in input_string: print(f\\"{char}: {ord(char)}\\")"},{"question":"def unique_paths_with_obstacles(obstacle_grid): Calculate the number of unique paths from the top-left corner to the bottom-right corner of a grid with obstacles, where 1 indicates an obstacle and 0 indicates an empty space. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0, 1, 0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0], ... [0], ... [0], ... [1], ... [0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [1] ... ]) 0","solution":"def unique_paths_with_obstacles(obstacle_grid): Calculate the number of unique paths from the top-left corner to the bottom-right corner of a grid with obstacles, where 1 indicates an obstacle and 0 indicates an empty space. if not obstacle_grid or obstacle_grid[0][0] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) # Initialize a 2D dp array dp[i][j] to store the number of unique paths to cell (i, j). dp = [[0] * n for _ in range(m)] # Start point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if obstacle_grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def minimum_campus_cost(M: int, C: List[int]) -> int: Determines the minimum cost to construct the campus with a tree structure ensuring all buildings are connected. Parameters: M (int): The number of buildings. C (List[int]): The cost of connecting each building. Returns: int: The minimum cost to construct the campus. >>> minimum_campus_cost(4, [1, 2, 3, 4]) 9 >>> minimum_campus_cost(3, [5, 3, 2]) 10 > print(minimum_campus_cost(5, [1, 2, 3, 4, 5])) 15","solution":"def minimum_campus_cost(M, C): Calculates the minimum cost to construct the campus with a tree structure of walkways. Parameters: M (int): The number of buildings. C (list): List of costs of connecting each building. Returns: int: The minimum cost to construct the campus. # Sort the costs C.sort() # The minimum cost will be the sum of the sorted array (excluding the first element) return sum(C)"},{"question":"def calculate_total_cost(consumption: int, base_rate: int) -> float: Calculate the total cost for water consumption. Args: - consumption (int): The amount of water consumed in cubic meters. - base_rate (int): The base rate per cubic meter. Returns: - total_cost (float): The total cost for the consumption with or without surcharge. # Your code here def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[float]: Process each test case and return the results. Args: - test_cases (list of tuples): Each tuple contains (consumption, base_rate) Returns: - results (list of float): The list of total costs for each test case with two decimal precision # Your code here Example usage and test cases: from solution import calculate_total_cost, process_test_cases def test_calculate_total_cost(): assert calculate_total_cost(400, 2) == 800.00 assert calculate_total_cost(600, 3) == 1890.00 assert calculate_total_cost(500, 5) == 2500.00 assert calculate_total_cost(501, 10) == 5260.50 assert calculate_total_cost(200, 7) == 1400.00 def test_process_test_cases(): test_cases = [(400, 2), (600, 3), (500, 5)] expected = [800.00, 1890.00, 2500.00] assert process_test_cases(test_cases) == expected test_cases = [(300, 1), (700, 2), (450, 5)] expected = [300.00, 1470.00, 2250.00] assert process_test_cases(test_cases) == expected test_cases = [(1001, 10), (600, 20), (501, 1)] expected = [10510.50, 12600.00, 526.05] assert process_test_cases(test_cases) == expected","solution":"def calculate_total_cost(consumption, base_rate): Calculate the total cost for water consumption. Args: - consumption (int): The amount of water consumed in cubic meters. - base_rate (int): The base rate per cubic meter. Returns: - total_cost (float): The total cost for the consumption with or without surcharge. total_cost = consumption * base_rate if consumption > 500: total_cost += total_cost * 0.05 return round(total_cost, 2) def process_test_cases(test_cases): Process each test case and return the results. Args: - test_cases (list of tuples): Each tuple contains (consumption, base_rate) Returns: - results (list of float): The list of total costs for each test case with two decimal precision results = [] for consumption, base_rate in test_cases: results.append(calculate_total_cost(consumption, base_rate)) return results"},{"question":"def minimize_max_travel_time(E, C, restaurants, customers): Determine the minimum possible maximum travel time that Kayla can achieve between any two successive stops on Pine Street. Args: - E (int): Number of restaurants. - C (int): Number of customers. - restaurants (List[int]): Coordinates of restaurants. - customers (List[int]): Coordinates of customers. Returns: - int: The minimum possible maximum travel time between any two successive stops. Example: >>> minimize_max_travel_time(2, 3, [3, 8], [2, 5, 9]) 3 >>> minimize_max_travel_time(1, 1, [0], [1]) 1 from typing import List import sys def main(): input = sys.stdin.read data = input().split() E = int(data[0]) C = int(data[1]) restaurants = list(map(int, data[2:2+E])) customers = list(map(int, data[2+E:])) result = minimize_max_travel_time(E, C, restaurants, customers) print(result) def test_sample_input_1(): E = 2 C = 3 restaurants = [3, 8] customers = [2, 5, 9] assert minimize_max_travel_time(E, C, restaurants, customers) == 3 def test_minimal_case(): E = 1 C = 1 restaurants = [0] customers = [1] assert minimize_max_travel_time(E, C, restaurants, customers) == 1 def test_all_restaurants(): E = 3 C = 0 restaurants = [1, 5, 10] customers = [] assert minimize_max_travel_time(E, C, restaurants, customers) == 5 def test_all_customers(): E = 0 C = 4 customers = [3, 8, 15, 20] restaurants = [] assert minimize_max_travel_time(E, C, restaurants, customers) == 7 def test_equal_distribution(): E = 2 C = 2 restaurants = [1, 4] customers = [7, 10] assert minimize_max_travel_time(E, C, restaurants, customers) == 3 def test_adjacent_stops(): E = 3 C = 2 restaurants = [1, 2, 3] customers = [4, 5] assert minimize_max_travel_time(E, C, restaurants, customers) == 1","solution":"def minimize_max_travel_time(E, C, restaurants, customers): all_locations = sorted(restaurants + customers) max_distances = [all_locations[i+1] - all_locations[i] for i in range(len(all_locations) - 1)] return max(max_distances) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() E = int(data[0]) C = int(data[1]) restaurants = list(map(int, data[2:2+E])) customers = list(map(int, data[2+E:])) result = minimize_max_travel_time(E, C, restaurants, customers) print(result)"},{"question":"def color_spectrum_days(days: List[int]) -> Tuple[int, int]: Returns the earliest and latest days you can experience the full colors along the row of trees. >>> color_spectrum_days([10, 15, 20, 25, 30]) (10, 30) >>> color_spectrum_days([5, 7, 8, 2, 3]) (2, 8) >>> color_spectrum_days([50, 45, 80, 65, 55]) (45, 80) >>> color_spectrum_days([3, 3, 3, 3, 3]) (3, 3)","solution":"def color_spectrum_days(days): Returns the earliest and latest days you can experience the full colors along the row of trees. Args: - days (list[int]): A list of integers representing the number of days it takes for each tree's leaves to fully change color. Returns: - tuple: A tuple containing the earliest and latest days of full color change. earliest_day = min(days) latest_day = max(days) return (earliest_day, latest_day)"},{"question":"from typing import List, Tuple def flood_fill(grid: List[List[int]], x: int, y: int, new_color: int, rows: int, cols: int) -> int: Perform flood fill algorithm to change the color of connected components. >>> flood_fill([[0]], 0, 0, 1, 1, 1) == 1 >>> flood_fill([[1, 1], [1, 1]], 0, 0, 2, 2, 2) == 4 >>> flood_fill([[2, 2], [2, 2]], 0, 0, 2, 2, 2) == 0 >>> flood_fill([[1, 2], [1, 2]], 0, 0, 3, 2, 2) == 2 >>> flood_fill([[1, 3], [1, 3], [2, 2], [2, 2]], 0, 0, 4, 4, 2) == 2 def process_queries(R: int, C: int, Q: int, grid: List[List[int]], queries: List[Tuple[int, int, int]]) -> List[int]: Process a list of flood fill queries on a grid of colors. >>> process_queries(1, 1, 1, [[0]], [(0, 0, 1)]) == [1] >>> process_queries(2, 2, 1, [[1, 1], [1, 1]], [(0, 0, 2)]) == [4] >>> process_queries(2, 2, 1, [[2, 2], [2, 2]], [(0, 0, 2)]) == [0] >>> process_queries(2, 2, 2, [[1, 2], [1, 2]], [(0, 0, 3), (0, 1, 4)]) == [2, 2] >>> process_queries(4, 2, 2, [[1, 3], [1, 3], [2, 2], [2, 2]], [(0, 0, 4), (3, 0, 5)]) == [2, 4]","solution":"def flood_fill(grid, x, y, new_color, rows, cols): Perform flood fill algorithm to change the color of connected components. original_color = grid[x][y] if original_color == new_color: return 0 def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != original_color: return 0 grid[r][c] = new_color return 1 + dfs(r-1, c) + dfs(r+1, c) + dfs(r, c-1) + dfs(r, c+1) return dfs(x, y) def process_queries(R, C, Q, grid, queries): results = [] for x, y, new_color in queries: result = flood_fill(grid, x, y, new_color, R, C) results.append(result) return results # Example usage: def main(): R, C, Q = 3, 3, 2 grid = [ [1, 1, 1], [1, 2, 2], [1, 1, 1] ] queries = [ (0, 0, 3), (2, 2, 5) ] results = process_queries(R, C, Q, grid, queries) for i, res in enumerate(results): print(f\\"Query {i+1}: {res}\\") if __name__ == \\"__main__\\": main()"},{"question":"def nth_prime(n): Finds the N-th prime number efficiently. >>> nth_prime(1) == 2 >>> nth_prime(5) == 11 >>> nth_prime(10) == 29 # Implementation here def find_primes(T, positions): Given T test cases and a list of positions, find the corresponding N-th prime for each position. >>> find_primes(3, [1, 5, 10]) == [2, 11, 29] >>> find_primes(2, [1, 2]) == [2, 3] >>> find_primes(4, [3, 5, 7, 10]) == [5, 11, 17, 29] # Implementation here","solution":"def nth_prime(n): Finds the N-th prime number efficiently. # Use Sieve of Eratosthenes to find prime numbers # Estimate the upper limit using the prime number theorem if n < 1: raise ValueError(\\"N must be a positive integer\\") import math upper_limit = int(n * (math.log(n) + math.log(math.log(n)))) if n > 5 else 15 sieve = [True] * (upper_limit + 1) sieve[0] = sieve[1] = False primes = [] for num in range(2, upper_limit + 1): if sieve[num]: primes.append(num) for multiple in range(num * num, upper_limit + 1, num): sieve[multiple] = False if len(primes) >= n: break return primes[n - 1] def find_primes(T, positions): Given T test cases and a list of positions, find the corresponding N-th prime for each position. results = [] for pos in positions: results.append(nth_prime(pos)) return results"},{"question":"def get_lexicographically_smallest_string(s: str, r: int) -> str: Returns the lexicographically smallest string after rotating \`s\` to the right \`r\` times. >>> get_lexicographically_smallest_string(\\"abcde\\", 1) \\"eabcd\\" >>> get_lexicographically_smallest_string(\\"zxy\\", 2) \\"xyz\\" >>> get_lexicographically_smallest_string(\\"cba\\", 3) \\"cba\\" >>> get_lexicographically_smallest_string(\\"abcdef\\", 0) \\"abcdef\\" >>> get_lexicographically_smallest_string(\\"abcde\\", 1001) \\"eabcd\\" def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Processes multiple test cases. >>> process_test_cases([(\\"abcde\\", 1), (\\"zxy\\", 2), (\\"cba\\", 3), (\\"abcdef\\", 0), (\\"abcdef\\", 6)]) [\\"eabcd\\", \\"xyz\\", \\"cba\\", \\"abcdef\\", \\"abcdef\\"]","solution":"def get_lexicographically_smallest_string(s, r): Returns the lexicographically smallest string after rotating \`s\` to the right \`r\` times. n = len(s) r = r % n # To handle cases where r >= n rotated_string = s[-r:] + s[:-r] return rotated_string def process_test_cases(test_cases): results = [] for s, r in test_cases: results.append(get_lexicographically_smallest_string(s, r)) return results"},{"question":"def possible_coin_sums(A: int, B: int, C: int) -> List[int]: Return a sorted list of unique possible sums of coins for completing any combination of the quests. >>> possible_coin_sums(4, 6, 8) [0, 4, 6, 8, 10, 12, 14, 18] >>> possible_coin_sums(5, 5, 5) [0, 5, 10, 15] >>> possible_coin_sums(3, 3, 7) [0, 3, 6, 7, 10, 13] >>> possible_coin_sums(1, 1, 1) [0, 1, 2, 3] >>> possible_coin_sums(100, 100, 100) [0, 100, 200, 300]","solution":"def possible_coin_sums(A, B, C): Returns a sorted list of unique possible sums of coins for completing any combination of the quests. sums = set() quest_coins = [A, B, C] n = len(quest_coins) # Generate all possible combinations of sums def compute_sums(idx, current_sum): if idx == n: sums.add(current_sum) return # Include current quest compute_sums(idx + 1, current_sum + quest_coins[idx]) # Exclude current quest compute_sums(idx + 1, current_sum) compute_sums(0, 0) return sorted(sums)"},{"question":"def longest_substring_two_distinct(s: str) -> str: Returns the longest substring with at most two distinct characters. >>> longest_substring_two_distinct(\\"eceba\\") \\"ece\\" >>> longest_substring_two_distinct(\\"ccaabbb\\") \\"aabbb\\"","solution":"def longest_substring_two_distinct(s): Returns the longest substring with at most two distinct characters. if len(s) < 3: return s l, r = 0, 0 hashmap = {} max_len = 2 starting_index = 0 while r < len(s): hashmap[s[r]] = r r += 1 if len(hashmap) == 3: del_index = min(hashmap.values()) del hashmap[s[del_index]] l = del_index + 1 if r - l > max_len: max_len = r - l starting_index = l return s[starting_index:starting_index + max_len]"},{"question":"from typing import List def findUniquePalindromes(s: str) -> List[str]: Returns a list of all unique palindromic substrings in the string s in lexicographical order. >>> findUniquePalindromes(\\"abaaa\\") [\\"a\\", \\"aa\\", \\"aaa\\", \\"aba\\", \\"b\\"] >>> findUniquePalindromes(\\"geek\\") [\\"e\\", \\"ee\\", \\"g\\", \\"k\\"]","solution":"def findUniquePalindromes(s): Returns a list of all unique palindromic substrings in the string s in lexicographical order. palindromic_substrings = set() def is_palindrome(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: palindromic_substrings.add(s[left:right+1]) left -= 1 right += 1 for i in range(len(s)): # Check for odd length palindromes (with center at i) is_palindrome(i, i) # Check for even length palindromes (with center between i and i+1) is_palindrome(i, i+1) return sorted(palindromic_substrings)"},{"question":"def best_participant(m, data): Determines the participant with the highest number of correct solutions. Parameters: m (int): number of participants data (list): list of tuples where each tuple contains a participant's name and a list of their problem solutions (0s and 1s) Returns: str: name of the participant with the highest number of correct solutions Examples: >>> best_participant(3, [(\\"Alice\\", \\"1 0 1 0 1\\"), (\\"Bob\\", \\"0 0 0 0 1\\"), (\\"Charlie\\", \\"1 1 1 0 0\\")]) \\"Alice\\" >>> best_participant(2, [(\\"John\\", \\"1 1\\"), (\\"Doe\\", \\"1 0\\")]) \\"John\\"","solution":"def best_participant(m, data): Determines the participant with the highest number of correct solutions. Parameters: m (int): number of participants data (list): list of tuples where each tuple contains a participant's name and a list of their problem solutions (0s and 1s) Returns: str: name of the participant with the highest number of correct solutions max_correct = -1 best_name = \\"\\" for i in range(m): name = data[i][0] solutions = list(map(int, data[i][1].split())) correct_count = solutions.count(1) if correct_count > max_correct: max_correct = correct_count best_name = name return best_name"},{"question":"def isScramble(s1: str, s2: str) -> bool: Determine if s2 is a scrambled version of s1. >>> isScramble(\\"listen\\", \\"silent\\") == True >>> isScramble(\\"apple\\", \\"pale\\") == False >>> isScramble(\\"racecar\\", \\"carrace\\") == True >>> isScramble(\\"aabbcc\\", \\"baccab\\") == True >>> isScramble(\\"abc\\", \\"abcd\\") == False","solution":"def isScramble(s1: str, s2: str) -> bool: Check if s2 is a scrambled version of s1. # Check if lengths are different, if so return False if len(s1) != len(s2): return False # Check if both strings have the same characters with the same frequencies return sorted(s1) == sorted(s2)"},{"question":"def maxNonOverlappingTasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled for a single developer. >>> maxNonOverlappingTasks([(1, 4), (3, 5), (0, 6), (5, 7), (8, 9), (5, 9)]) 3 >>> maxNonOverlappingTasks([(1, 2), (3, 4), (5, 6)]) 3 >>> maxNonOverlappingTasks([(1, 10), (2, 9), (3, 8)]) 1 >>> maxNonOverlappingTasks([(1, 3), (2, 4), (3, 5), (4, 6)]) 2 >>> maxNonOverlappingTasks([(5, 9)]) 1","solution":"def maxNonOverlappingTasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled for a single developer. :param tasks: List of tuples representing the start and end times of each task :return: Integer representing the maximum number of non-overlapping tasks # Sort the tasks by their end times tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: # If the current task starts after or when the last task ends, count it count += 1 last_end_time = end return count"},{"question":"def max_books(N: int, M: int, times: List[int]) -> int: Given N books with reading times and a total allotted time M, this function returns the maximum number of books that can be read without exceeding the total allotted time. Parameters: N (int): Number of books M (int): Total allotted time times (list): List of reading times of the books Returns: int: Maximum number of books that can be read >>> max_books(5, 10, [3, 1, 4, 1, 2]) 4 >>> max_books(3, 5, [3, 2, 2]) 2 >>> max_books(4, 7, [5, 3, 1, 2]) 3 >>> max_books(6, 15, [2, 7, 1, 5, 3, 4]) 5 >>> max_books(5, 3, [4, 5, 6, 7, 8]) 0","solution":"def max_books(N, M, times): Given N books with reading times and a total allotted time M, this function returns the maximum number of books that can be read without exceeding the total allotted time. Parameters: N (int): Number of books M (int): Total allotted time times (list): List of reading times of the books Returns: int: Maximum number of books that can be read times.sort() total_time = 0 books_count = 0 for time in times: if total_time + time <= M: total_time += time books_count += 1 else: break return books_count # Reading input data if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) times = list(map(int, data[2:])) print(max_books(N, M, times))"},{"question":"def find_pairs(arr: List[int], k: int) -> Set[Tuple[int, int]]: Given an array of integers \`arr\` and an integer \`k\`, find all unique pairs (a, b) in the array such that: 1. The sum of the pair is equal to \`k\`. 2. Both a and b should be in the array. 3. The value \`a\` should be less than \`b\`. 4. Each pair (a, b) should be represented as a tuple and the pairs should not repeat. >>> find_pairs([1, 2, 3, 4, 5], 5) {(1, 4), (2, 3)} >>> find_pairs([1, 1, 2, 3, 4, 5], 6) {(1, 5), (2, 4)}","solution":"def find_pairs(arr, k): seen = set() pairs = set() for num in arr: complement = k - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return pairs"},{"question":"def count_primes(arr): Returns the count of prime numbers in the given sequence. >>> count_primes([2, 3, 4, 5, 6]) 3 >>> count_primes([8, 10, 13, 17]) 2 >>> count_primes([2, 3, 5, 7, 11, 13, 17, 19]) 8 >>> count_primes([1, 4, 6, 8, 10, 20]) 0 >>> count_primes([1, 2, 3, 15, 22, 29]) 3 >>> count_primes([37]) 1 >>> count_primes([999983, 999984, 999985]) 1","solution":"def count_primes(arr): Returns the count of prime numbers in the given sequence. def is_prime(num): if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True prime_count = sum(1 for x in arr if is_prime(x)) return prime_count"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from buying and selling the stock on different days. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([1, 1, 1, 1, 1]) == 0 >>> max_profit([9, 7, 5, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([2, 4, 1, 7, 5, 3]) == 6 >>> max_profit([5]) == 0 >>> max_profit([]) == 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from buying and selling the stock on different days. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def maxSubArraySum(nums): Implements Kadane's Algorithm to find the sum of the largest contiguous subarray. Args: nums (list of int): The input list of integers. Returns: int: The sum of the largest contiguous subarray. Examples: >>> maxSubArraySum([1, 2, 3, 4, 5]) 15 >>> maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxSubArraySum([1]) 1 >>> maxSubArraySum([-1]) -1 >>> maxSubArraySum([-2, -3, -1, -5]) -1 >>> maxSubArraySum([0, -3, 1, 2, 0, -1, 4]) 6","solution":"def maxSubArraySum(nums): Implements Kadane's Algorithm to find the sum of the largest contiguous subarray. Args: nums (list of int): The input list of integers. Returns: int: The sum of the largest contiguous subarray. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def shortest_travel_time(n: int, m: int, s: int, roads: List[Tuple[int, int, int]], t: int) -> int: Returns the shortest travel time from intersection s to t in a directed graph. If there's no path from s to t, returns -1. Parameters: n (int): the number of intersections. m (int): the number of roads. s (int): the start intersection. roads (List of Tuple): each tuple contains (ui, vi, ci) where ui is the start intersection of the road, vi is the end intersection of the road, and ci is the travel time. t (int): the end intersection. Returns: int: the shortest travel time from s to t. If no such path exists, returns -1. Example: >>> shortest_travel_time(5, 6, 1, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1), (2, 5, 10), (4, 5, 3)], 5) 6 >>> shortest_travel_time(3, 3, 1, [(1, 2, 2), (2, 3, 4), (1, 3, 7)], 3) 6 >>> shortest_travel_time(3, 1, 1, [(1, 2, 3)], 3) -1","solution":"import heapq def shortest_travel_time(n, m, s, roads, t): Returns the shortest travel time from intersection s to t in a directed graph. If there's no path from s to t, returns -1. Parameters: n (int): the number of intersections. m (int): the number of roads. s (int): the start intersection. roads (List of Tuple): each tuple contains (ui, vi, ci) where ui is the start intersection of the road, vi is the end intersection of the road, and ci is the travel time. t (int): the end intersection. Returns: int: the shortest travel time from s to t. If no such path exists, returns -1. # Create the adjacency list graph = [[] for _ in range(n+1)] for ui, vi, ci in roads: graph[ui].append((vi, ci)) # Use Dijkstra's algorithm to find the shortest path min_heap = [(0, s)] # (travel_time, intersection) travel_time = [float('inf')] * (n + 1) travel_time[s] = 0 while min_heap: current_time, u = heapq.heappop(min_heap) if current_time > travel_time[u]: continue for v, time in graph[u]: if travel_time[u] + time < travel_time[v]: travel_time[v] = travel_time[u] + time heapq.heappush(min_heap, (travel_time[v], v)) return travel_time[t] if travel_time[t] != float('inf') else -1"},{"question":"def count_palindromic_substrings(S: str) -> int: Returns the count of palindromic substrings in the given string S. Input: - A single string \`S\` of length \`n\` (1 ≤ n ≤ 1000) consisting of lowercase alphabets. Output: - Print a single integer denoting the total number of palindromic substrings in the string. Example: >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abcba\\") 7","solution":"def count_palindromic_substrings(S: str) -> int: Returns the count of palindromic substrings in the given string S. def expand_around_center(left: int, right: int) -> int: Helper function that expands around the center to count palindromes. count = 0 while left >= 0 and right < len(S) and S[left] == S[right]: count += 1 left -= 1 right += 1 return count total_palindromes = 0 n = len(S) for i in range(n): # Odd-length palindromes (single character center) total_palindromes += expand_around_center(i, i) # Even-length palindromes (double character center) total_palindromes += expand_around_center(i, i + 1) return total_palindromes"},{"question":"def total_minimum_distance(n, deliveries): Calculates the total minimum distance required to deliver all packages starting and ending at the service station (0, 0) for each delivery. :param n: Number of deliveries :param deliveries: List of coordinates (x, y) for each delivery :return: Total minimum distance >>> total_minimum_distance(1, [(1, 2)]) 6 >>> total_minimum_distance(1, [(0, 0)]) 0 >>> total_minimum_distance(1, [(-3, -4)]) 14 >>> total_minimum_distance(2, [(1, 2), (3, 4)]) 20 >>> total_minimum_distance(3, [(1, 2), (3, 4), (-1, -2)]) 26 >>> total_minimum_distance(3, [(0, 1), (0, 2), (0, 3)]) 12 >>> total_minimum_distance(1, [(10**9, 10**9)]) 4000000000 >>> total_minimum_distance(2, [(10**9, 10**9), (-10**9, -10**9)]) 8000000000 >>> total_minimum_distance(1, [(1, 0)]) 2 >>> total_minimum_distance(1, [(0, 1)]) 2 >>> total_minimum_distance(1, [(-1, 0)]) 2 >>> total_minimum_distance(1, [(0, -1)]) 2 >>> total_minimum_distance(3, [(0, 0), (0, 0), (0, 0)]) 0","solution":"def total_minimum_distance(n, deliveries): Calculates the total minimum distance required to deliver all packages starting and ending at the service station (0, 0) for each delivery. :param n: Number of deliveries :param deliveries: List of coordinates (x, y) for each delivery :return: Total minimum distance total_distance = 0 for x, y in deliveries: # Distance from (0, 0) to (x, y) and back total_distance += 2 * (abs(x) + abs(y)) return total_distance"},{"question":"def determine_segment_type(S: int) -> str: Determines the type of segment based on the segment number \`S\`. >>> determine_segment_type(1) 'AM' >>> determine_segment_type(4) 'WA' >>> determine_segment_type(7) 'Peace' >>> determine_segment_type(10) 'MW' # Complete the implementation def process_segments(test_cases: List[int]) -> List[str]: Process multiple test cases and return the results in a list. >>> process_segments([1, 4, 7, 10]) ['AM', 'WA', 'Peace', 'MW'] >>> process_segments([16, 21, 22, 23]) ['WA', 'AM', 'MW', 'Peace'] # Complete the implementation # Test cases to verify the implementation def test_determine_segment_type(): assert determine_segment_type(1) == \\"AM\\" assert determine_segment_type(4) == \\"WA\\" assert determine_segment_type(7) == \\"Peace\\" assert determine_segment_type(10) == \\"MW\\" assert determine_segment_type(16) == \\"WA\\" assert determine_segment_type(21) == \\"AM\\" assert determine_segment_type(22) == \\"MW\\" assert determine_segment_type(23) == \\"Peace\\" def test_process_segments(): assert process_segments([1, 4, 7, 10]) == [\\"AM\\", \\"WA\\", \\"Peace\\", \\"MW\\"] assert process_segments([16, 21, 22, 23]) == [\\"WA\\", \\"AM\\", \\"MW\\", \\"Peace\\"] assert process_segments([3, 5, 6, 8]) == [\\"Peace\\", \\"AM\\", \\"MW\\", \\"WA\\"]","solution":"def determine_segment_type(S): Determines the type of segment based on the segment number \`S\`. if S % 4 == 0: return \\"WA\\" elif S % 4 == 1: return \\"AM\\" elif S % 4 == 2: return \\"MW\\" else: return \\"Peace\\" def process_segments(test_cases): Process multiple test cases and return the results in a list. results = [] for S in test_cases: results.append(determine_segment_type(S)) return results"},{"question":"from typing import List def canArrange(nums: List[int], k: int, t: int) -> bool: Determine whether it is possible to rearrange the array such that the difference between the maximum and minimum element in any subarray of length k is less than or equal to a given threshold t. Args: nums (List[int]): the array of integers. k (int): the length of the subarray. t (int): the threshold for the difference. Returns: bool: True if it is possible to rearrange the array to meet the condition, False otherwise. Examples: >>> canArrange([1, 3, 6, 10, 15, 21], 3, 5) False >>> canArrange([4, 2, 6, 10, 8], 2, 3) True >>> canArrange([10, 1, 12, 8, 5, 14], 4, 6) False","solution":"from typing import List def canArrange(nums: List[int], k: int, t: int) -> bool: nums.sort() for i in range(len(nums) - k + 1): if nums[i + k - 1] - nums[i] > t: return False return True"},{"question":"def can_find_prefix_suffix(n, s): Given a string s with length n, determine if it is possible to find a non-empty prefix P and a non-empty suffix Suf such that P + Suf = S, where P has all unique characters. >>> can_find_prefix_suffix(5, \\"abcde\\") \\"NO\\" >>> can_find_prefix_suffix(6, \\"aabbcc\\") \\"YES\\" >>> can_find_prefix_suffix(4, \\"abac\\") \\"YES\\" >>> can_find_prefix_suffix(3, \\"xyz\\") \\"NO\\" def solve_string_cases(test_cases): Solves multiple test cases as described. >>> solve_string_cases([(5, \\"abcde\\"), (6, \\"aabbcc\\"), (4, \\"abac\\"), (3, \\"xyz\\")]) == [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> solve_string_cases([(105, \\"zabcdefgijklmnopfwxdefguzabcdefghijkejklastuvwxyz\\"), (6, \\"looop\\")]) == [\\"YES\\", \\"YES\\"]","solution":"def can_find_prefix_suffix(n, s): Given a string s with length n, determine if it is possible to find a non-empty prefix P and a non-empty suffix Suf such that P + Suf = S, where P has all unique characters. seen = set() # Iterate through the string to check prefix uniqueness for i, ch in enumerate(s): if ch in seen: return \\"YES\\" seen.add(ch) # If we check all characters without duplications, then it's not possible to divide according to condition return \\"NO\\" def solve_string_cases(test_cases): Solves multiple test cases as described. results = [] for n, s in test_cases: result = can_find_prefix_suffix(n, s) results.append(result) return results"},{"question":"def can_pass_ball(p, q, r, s, k): Determines if it is possible to pass the ball from P to S, either directly or indirectly given the distance limit k. :param p: Position of P :param q: Position of Q :param r: Position of R :param s: Position of S :param k: Maximum distance a ball can be passed :return: 'Yes' if the ball can be passed from P to S, otherwise 'No' pass # Unit tests def test_direct_pass(): assert can_pass_ball(2, 5, 8, 3, 4) == \\"Yes\\" assert can_pass_ball(1, 4, 4, 5, 1) == \\"No\\" def test_two_hop_pass(): assert can_pass_ball(2, 5, 8, 10, 4) == \\"Yes\\" assert can_pass_ball(1, 4, 7, 10, 2) == \\"No\\" def test_three_hop_pass(): assert can_pass_ball(2, 4, 6, 8, 2) == \\"Yes\\" assert can_pass_ball(1, 3, 6, 9, 1) == \\"No\\" def test_all_positions_same(): assert can_pass_ball(5, 5, 5, 5, 1) == \\"Yes\\" def test_intermediate_positions(): assert can_pass_ball(2, 4, 6, 10, 4) == \\"Yes\\" assert can_pass_ball(2, 100, 100, 50, 10) == \\"No\\"","solution":"def can_pass_ball(p, q, r, s, k): Determines if it is possible to pass the ball from P to S, either directly or indirectly given the distance limit k. :param p: Position of P :param q: Position of Q :param r: Position of R :param s: Position of S :param k: Maximum distance a ball can be passed :return: 'Yes' if the ball can be passed from P to S, otherwise 'No' # Check direct passes if abs(p - s) <= k: return \\"Yes\\" if abs(p - q) <= k and abs(q - s) <= k: return \\"Yes\\" if abs(p - q) <= k and abs(q - r) <= k and abs(r - s) <= k: return \\"Yes\\" if abs(p - r) <= k and abs(r - s) <= k: return \\"Yes\\" if abs(p - r) <= k and abs(r - q) <= k and abs(q - s) <= k: return \\"Yes\\" return \\"No\\""},{"question":"def min_stages_required(test_cases): Determine the minimum number of stages required so that there is no overlap in performances on the same stage. >>> test_cases = [ ... [(1, 4), (2, 5), (9, 12)], ... [(5, 8), (4, 6), (3, 7), (1, 5)] ... ] >>> min_stages_required(test_cases) [2, 3] >>> >>> test_cases = [[(1, 2), (3, 4), (5, 6)]] >>> min_stages_required(test_cases) [1] pass def parse_input(input_text: str): Parse the input text into a list of test cases. >>> input_text = \\"2n3n1 4n2 5n9 12n4n5 8n4 6n3 7n1 5\\" >>> parse_input(input_text) [[(1, 4), (2, 5), (9, 12)], [(5, 8), (4, 6), (3, 7), (1, 5)]] pass","solution":"from heapq import heappush, heappop def min_stages_required(test_cases): results = [] for performances in test_cases: performances.sort(key=lambda x: x[0]) min_heap = [] for start, end in performances: if min_heap and min_heap[0] <= start: heappop(min_heap) heappush(min_heap, end) results.append(len(min_heap)) return results def parse_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) performances = [] for i in range(1, N + 1): start, end = map(int, lines[index + i].split()) performances.append((start, end)) test_cases.append(performances) index += N + 1 return test_cases"},{"question":"def shortest_path(grid, start, end): Find the shortest path from start to end in a grid while avoiding obstacles. >>> grid = [ ... \\".....\\", ... \\".#.\\", ... \\".....\\", ... \\".#.\\", ... \\".....\\", ... ] >>> start = (0, 0) >>> end = (4, 4) >>> shortest_path(grid, start, end) 8 >>> grid = [ ... \\"......\\", ... \\"......\\", ... \\"......\\", ... \\"......\\", ... \\"......\\", ... ] >>> start = (0, 0) >>> end = (4, 5) >>> shortest_path(grid, start, end) 9 >>> grid = [ ... \\"...\\", ... \\".#.\\", ... \\"...\\", ... ] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path(grid, start, end) 4 >>> grid = [ ... \\"...\\", ... \\"#\\", ... \\"...\\", ... ] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path(grid, start, end) -1","solution":"from collections import deque def shortest_path(grid, start, end): N, M = len(grid), len(grid[0]) x1, y1 = start x2, y2 = end # Directions: right, left, up, down directions = [(0, 1), (0, -1), (-1, 0), (1, 0)] queue = deque([(x1, y1, 0)]) visited = set((x1, y1)) while queue: x, y, dist = queue.popleft() if (x, y) == (x2, y2): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def solve(test_cases): results = [] for case in test_cases: N, M, grid, start, end = case result = shortest_path(grid, start, end) results.append(result) return results"},{"question":"def longest_substring_with_two_distinct_characters(s: str) -> int: Returns the length of the longest substring containing at most two distinct characters. >>> longest_substring_with_two_distinct_characters(\\"eceba\\") 3 >>> longest_substring_with_two_distinct_characters(\\"ccaabbb\\") 5","solution":"def longest_substring_with_two_distinct_characters(s: str) -> int: Returns the length of the longest substring containing at most two distinct characters. # Dictionary to keep the count of characters in the current window char_count = {} left = 0 max_len = 0 for right in range(len(s)): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # If the number of distinct characters exceeds 2, shrink the window from the left while len(char_count) > 2: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 # Update max_len max_len = max(max_len, right - left + 1) return max_len"},{"question":"def sequence_elements(n: int, D: List[int], queries: List[int]) -> List[int]: Given the size of the sequence, the array D and the queries, return the sequence elements for each query index. Arguments: n -- the size of the sequence D -- a list of integers representing the array D queries -- a list of integers representing the indices for which to output S Returns: A list of integers representing the sequence elements at the provided query indices. Example: >>> sequence_elements(5, [2, 5, 8, 14, 20], [1, 3, 5]) [2, 8, 20] >>> sequence_elements(3, [1, 4, 9], [1, 2, 3]) [1, 4, 9] # Your code here def test_sequence_elements(): assert sequence_elements(5, [2, 5, 8, 14, 20], [1, 3, 5]) == [2, 8, 20] assert sequence_elements(3, [1, 4, 9], [1, 2, 3]) == [1, 4, 9] assert sequence_elements(6, [3, 6, 10, 15, 21, 28], [1, 4, 6]) == [3, 15, 28] assert sequence_elements(4, [2, 4, 6, 10], [1, 2, 4]) == [2, 4, 10] assert sequence_elements(1, [5], [1]) == [5] # Single element test assert sequence_elements(2, [5, 10], [2]) == [10] # Two elements, get the second def test_edge_cases(): # Minimum input size with maximum difference assert sequence_elements(1, [0], [1]) == [0] assert sequence_elements(2, [0, 1000000000], [1, 2]) == [0, 1000000000]","solution":"def sequence_elements(n, D, queries): Given the size of the sequence, the array D and the queries, return the sequence elements for each query index. # Initialize the sequence S with the same length as D S = [0] * n # The first element of S is always the first element of D S[0] = D[0] # Calculate the remaining elements of S using the given formula for i in range(1, n): S[i] = S[i-1] + (D[i] - D[i-1]) # Generate the list of results based on the queries result = [S[i-1] for i in queries] return result # Example usage n = 5 D = [2, 5, 8, 14, 20] queries = [1, 3, 5] print(sequence_elements(n, D, queries)) # Output should be [2, 8, 20]"},{"question":"from typing import List def count_valid_ap(n: int, sequence: List[int]) -> int: Counts the number of valid ways to restore the arithmetic progression by replacing the -1 with an integer between 1 and n. >>> count_valid_ap(5, [1, -1, 3, 4, 5]) 1 >>> count_valid_ap(4, [4, -1, 2, 1]) 1 >>> count_valid_ap(5, [1, 2, -1, 4, 5]) 1 >>> count_valid_ap(5, [1, 3, -1, 4, 5]) 0 >>> count_valid_ap(10, [1, 2, 3, 4, -1, 6, 7, 8, 9, 10]) 1 >>> count_valid_ap(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, -1]) 1 >>> count_valid_ap(3, [1, -1, 3]) 1 >>> count_valid_ap(3, [1, 2, -1]) 1","solution":"def count_valid_ap(n, sequence): possible_values = set(range(1, n + 1)) - set(sequence) valid_ways = 0 for value in possible_values: new_sequence = [value if x == -1 else x for x in sequence] if is_arithmetic_progression(new_sequence): valid_ways += 1 return valid_ways def is_arithmetic_progression(sequence): differences = [sequence[i+1] - sequence[i] for i in range(len(sequence) - 1)] return len(set(differences)) == 1 # Example usage # n = 5 # sequence = [1, -1, 3, 4, 5] # print(count_valid_ap(n, sequence)) # Output: 1"},{"question":"def find_shortest_palindromic_subsequence(s: str) -> str: Finds the shortest palindromic subsequence which is lexicographically smallest. >>> find_shortest_palindromic_subsequence(\\"abca\\") 'a' >>> find_shortest_palindromic_subsequence(\\"racecar\\") 'a' >>> find_shortest_palindromic_subsequence(\\"abcdef\\") 'a' def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns a list of shortest palindromic subsequences. >>> process_test_cases([\\"abca\\", \\"racecar\\", \\"abcdef\\"]) ['a', 'a', 'a'] >>> process_test_cases([\\"xyz\\", \\"bbb\\", \\"aab\\"]) ['x', 'b', 'a'] >>> process_test_cases([\\"cba\\", \\"zyxwvuts\\", \\"wxyz\\"]) ['a', 's', 'w'] >>> process_test_cases([\\"mnopqr\\", \\"abacaba\\", \\"bca\\"]) ['m', 'a', 'a']","solution":"def find_shortest_palindromic_subsequence(s): Returns the shortest palindromic subsequence which is lexicographically smallest. return min(s) def process_test_cases(test_cases): results = [] for s in test_cases: results.append(find_shortest_palindromic_subsequence(s)) return results"},{"question":"from typing import List def highest_frequency_integer(arr: List[int]) -> int: Returns the integer with the highest frequency in the list. If there is a tie, returns the smallest integer among those with the highest frequency. >>> highest_frequency_integer([4, 6, 2, 2, 6, 6, 4, 4, 4, 3, 3]) 4 >>> highest_frequency_integer([3, 3, 1, 2, 2, 3]) 3 >>> highest_frequency_integer([5]) 5","solution":"from collections import Counter def highest_frequency_integer(arr): Returns the integer with the highest frequency in the list. If there is a tie, returns the smallest integer among those with the highest frequency. if not arr: return None count = Counter(arr) highest_freq = max(count.values()) candidates = [k for k, v in count.items() if v == highest_freq] return min(candidates)"},{"question":"from typing import List, Union def shortest_path(n: int, m: int, grid: List[str]) -> Union[int, str]: Compute the shortest path for a drone to get from the starting position to the delivery point in a 2D grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): The 2D grid represented as a list of strings. Returns: Union[int, str]: The length of the shortest path as an integer or \\"No Path Found\\" if no path exists. >>> shortest_path(5, 5, [\\"S...#\\", \\"..#.#\\", \\".#..#\\", \\".#D..\\", \\".....\\"]) 7 >>> shortest_path(4, 4, [\\"S#\\", \\"\\", \\"\\", \\"#D\\"]) \\"No Path Found\\" # Your implementation here # Example Unit Tests def test_shortest_path_simple(): n = 5 m = 5 grid = [ \\"S...#\\", \\"..#.#\\", \\".#..#\\", \\".#D..\\", \\".....\\" ] assert shortest_path(n, m, grid) == 7 def test_no_path(): n = 4 m = 4 grid = [ \\"S#\\", \\"\\", \\"\\", \\"#D\\" ] assert shortest_path(n, m, grid) == \\"No Path Found\\" def test_direct_path(): n = 3 m = 3 grid = [ \\"S..\\", \\"...\\", \\"..D\\" ] assert shortest_path(n, m, grid) == 4 def test_blocked_path(): n = 3 m = 3 grid = [ \\"S#.\\", \\"#\\", \\".#D\\" ] assert shortest_path(n, m, grid) == \\"No Path Found\\" def test_edges(): n = 2 m = 2 grid = [ \\"S.\\", \\".D\\" ] assert shortest_path(n, m, grid) == 2 def test_minimum_size(): n = 2 m = 2 grid = [ \\"SD\\", \\"..\\" ] assert shortest_path(n, m, grid) == 1","solution":"from collections import deque def shortest_path(n, m, grid): def get_neighbors(x, y): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#': yield nx, ny def bfs(start, end): queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for nx, ny in get_neighbors(x, y): if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 start, end = None, None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'D': end = (i, j) if not start or not end: raise ValueError(\\"Grid must contain exactly one 'S' and one 'D'\\") distance = bfs(start, end) return distance if distance != -1 else \\"No Path Found\\""},{"question":"def max_ghosts_eliminated(haunted_houses): Returns the maximum number of ghosts that can be eliminated from the houses. >>> max_ghosts_eliminated([3, 2, 5, 10, 7]) 15 >>> max_ghosts_eliminated([2, 1, 4, 9]) 11 >>> max_ghosts_eliminated([]) 0 >>> max_ghosts_eliminated([5]) 5 >>> max_ghosts_eliminated([4, 5]) 5 pass def solve_ghost_hunters(t, test_cases): Solves the ghost hunting problem for the given test cases. >>> solve_ghost_hunters(2, [(5, [3, 2, 5, 10, 7]), (4, [2, 1, 4, 9])]) [15, 11] >>> solve_ghost_hunters(3, [(0, []), (1, [7]), (3, [1, 2, 3])]) [0, 7, 4] pass","solution":"def max_ghosts_eliminated(haunted_houses): Returns the maximum number of ghosts that can be eliminated from the houses. if not haunted_houses: return 0 n = len(haunted_houses) if n == 1: return haunted_houses[0] # DP array to store the maximum ghosts eliminated up to each house dp = [0] * n dp[0] = haunted_houses[0] dp[1] = max(haunted_houses[0], haunted_houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + haunted_houses[i]) return dp[-1] def solve_ghost_hunters(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] haunted_houses = test_cases[i][1] results.append(max_ghosts_eliminated(haunted_houses)) return results"},{"question":"from typing import List, Tuple def polygon_area(vertices: List[Tuple[float, float]]) -> float: Calculates the area of a polygon given its vertices using the Shoelace theorem. Arguments: vertices: A list of tuples, where each tuple contains two floats representing the x and y coordinates of a vertex. Returns: A float representing the area of the polygon. Example: >>> polygon_area([(0, 0), (4, 0), (4, 4), (0, 4)]) 16.0 >>> polygon_area([(0, 0), (4, 0), (2, 4)]) 8.0","solution":"from typing import List, Tuple def polygon_area(vertices: List[Tuple[float, float]]) -> float: Calculates the area of a polygon given its vertices using the Shoelace theorem. Arguments: vertices: A list of tuples, where each tuple contains two floats representing the x and y coordinates of a vertex. Returns: A float representing the area of the polygon. n = len(vertices) area = 0.0 for i in range(n): x1, y1 = vertices[i] x2, y2 = vertices[(i + 1) % n] area += x1 * y2 area -= y1 * x2 area = abs(area) / 2.0 return area"},{"question":"def max_trees_cut(test_cases): Determine the maximum number of trees that can be cut such that no two cut trees are adjacent. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing the number of trees and a list of tree heights. Returns: List[int]: A list of integers representing the maximum number of trees that can be cut for each test case. Examples: >>> max_trees_cut([(5, [1, 2, 3, 4, 5]), (6, [3, 4, 5, 6, 7, 8])]) [3, 4] >>> max_trees_cut([(1, [1]), (2, [1, 2]), (3, [1, 2, 3]), (4, [1, 2, 3, 4]), (5, [1, 2, 3, 4, 5])]) [1, 1, 2, 2, 3]","solution":"def max_trees_cut(test_cases): results = [] for n, heights in test_cases: results.append((n + 1) // 2) return results"},{"question":"def min_increasing_subsequences(sequence: List[int]) -> int: Find the minimum number of strictly increasing subsequences which can partition the sequence into. >>> min_increasing_subsequences([2, 1, 4, 3, 5]) 2 >>> min_increasing_subsequences([9, 8, 7, 1, 2, 3]) 4 >>> min_increasing_subsequences([1, 2, 3, 4, 5]) 1 >>> min_increasing_subsequences([5, 4, 3, 2, 1]) 5 >>> min_increasing_subsequences([1]) 1 >>> min_increasing_subsequences([1000000000, 999999999, 1, 2, 3]) 3 >>> min_increasing_subsequences([1, 100, 2, 99, 3, 98]) 3","solution":"def min_increasing_subsequences(sequence): Function to find the minimum number of strictly increasing subsequences which can partition the sequence into. import heapq subsequences = [] # Min-heap to keep track of the ends of subsequences for num in sequence: # place number in one of the existing subsequences placed = False # Using heapq to get the smallest ending subsequence that is strictly increasing for index, end in enumerate(subsequences): if num > end: subsequences[index] = num placed = True break # If num cannot fit into any existing subsequences, create a new one if not placed: heapq.heappush(subsequences, num) return len(subsequences)"},{"question":"def min_diff_partition(arr): Function to find the minimum absolute difference between the sums of two groups after partitioning the array. >>> min_diff_partition([1, 6, 11, 5]) 1 >>> min_diff_partition([2, -1, 3, 4]) 0 pass def process_test_cases(t, test_cases): Function to process multiple test cases for the partitioning problem. >>> process_test_cases(2, [(4, [1, 6, 11, 5]), (4, [2, -1, 3, 4])]) [1, 0] >>> process_test_cases(1, [(4, [1, 1, 1, 1])]) [0] pass","solution":"def min_diff_partition(arr): Function to find minimum difference between two group sums. total_sum = sum(arr) n = len(arr) possible_sums = {0} for num in arr: possible_sums.update({x + num for x in possible_sums}) min_diff = float('inf') for s in possible_sums: min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff def process_test_cases(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(min_diff_partition(arr)) return results"},{"question":"def find_names_indices(names: List[str], queries: List[str]) -> List[int]: Returns the indices of the queried names in the provided list of names. Args: names (list of str): List of names (first and last names). queries (list of str): List of queries (names to find). Returns: list of int: The index (1-based) of each queried name in the list of names, or -1 if the name is not found. >>> names = [\\"alice smith\\", \\"john doe\\", \\"jane austen\\", \\"emma woodhouse\\", \\"charlotte bronte\\"] >>> queries = [\\"john doe\\", \\"mr darcy\\", \\"emma woodhouse\\"] >>> find_names_indices(names, queries) [2, -1, 4] >>> names = [\\"mary shelley\\", \\"percy bysshe\\", \\"george eliot\\", \\"harriet beecher\\"] >>> queries = [\\"george eliot\\", \\"mark twain\\"] >>> find_names_indices(names, queries) [3, -1]","solution":"def find_names_indices(names, queries): Returns the indices of the queried names in the provided list of names. Args: names (list of str): List of names (first and last names). queries (list of str): List of queries (names to find). Returns: list of int: The index (1-based) of each queried name in the list of names, or -1 if the name is not found. name_index_map = {name: i + 1 for i, name in enumerate(names)} return [name_index_map.get(query, -1) for query in queries] # Example usage: # names = [\\"alice smith\\", \\"john doe\\", \\"jane austen\\", \\"emma woodhouse\\", \\"charlotte bronte\\"] # queries = [\\"john doe\\", \\"mr darcy\\", \\"emma woodhouse\\"] # print(find_names_indices(names, queries)) # Output: [2, -1, 4]"},{"question":"class Library: def __init__(self): self.books = set() # To store unique book identifiers def add_book(self, identifier): Adds a book with the given identifier to the collection. pass def total_books(self, l, r): Counts the number of unique books within the range [l, r]. Args: l (int): The lower bound of the range. r (int): The upper bound of the range. Returns: int: The count of unique books within the specified range. pass def process_queries(queries): Processes a list of queries to manage and count books. Args: queries (List[str]): List of queries where each query is either \\"Add x\\" or \\"TotalBooks l r\\". Returns: List[int]: The results for each \\"TotalBooks\\" query. >>> process_queries([\\"Add 3\\", \\"Add 5\\", \\"Add 8\\", \\"TotalBooks 1 5\\", \\"Add 5\\", \\"TotalBooks 4 8\\"]) [2, 2] pass","solution":"class Library: def __init__(self): self.books = set() # To store unique book identifiers def add_book(self, identifier): self.books.add(identifier) def total_books(self, l, r): # Count the books within the range [l, r] count = 0 for book in self.books: if l <= book <= r: count += 1 return count def process_queries(queries): library = Library() results = [] for query in queries: parts = query.strip().split() if parts[0] == \\"Add\\": library.add_book(int(parts[1])) elif parts[0] == \\"TotalBooks\\": l = int(parts[1]) r = int(parts[2]) results.append(library.total_books(l, r)) return results"},{"question":"from typing import Dict, List def has_cycle(graph: Dict[int, List[int]]) -> bool: Given a directed graph represented as an adjacency list, this function determines whether the given directed graph contains a cycle. >>> graph = { ... 0: [1, 2], ... 1: [2], ... 2: [0], ... 3: [3] ... } >>> has_cycle(graph) True >>> graph = { ... 0: [1, 2], ... 1: [2], ... 2: [], ... 3: [3] ... } >>> has_cycle(graph) True >>> graph = { ... 0: [1], ... 1: [2], ... 2: [] ... } >>> has_cycle(graph) False","solution":"from typing import Dict, List def has_cycle(graph: Dict[int, List[int]]) -> bool: visited = set() recursion_stack = set() def dfs(node): if node not in visited: visited.add(node) recursion_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited and dfs(neighbor): return True elif neighbor in recursion_stack: return True recursion_stack.remove(node) return False for node in graph.keys(): if node not in visited: if dfs(node): return True return False"},{"question":"from typing import List, Tuple, Set def find_all_ancestors(node: str, relationships: List[Tuple[str, str]]) -> Set[str]: Write a function \`find_all_ancestors\` that returns a set of all ancestors for a given node. Args: node (str): The node whose ancestors are to be found. relationships (List[Tuple[str, str]]): List of parent-child relationships. Returns: Set[str]: Set of all ancestors of the given node. Examples: >>> test_relationships = [('grandparent', 'parent'), ('parent', 'child'), ('grandparent', 'uncle'), ('uncle', 'cousin')] >>> find_all_ancestors('child', test_relationships) {'grandparent', 'parent'} >>> find_all_ancestors('cousin', test_relationships) {'grandparent', 'uncle'} >>> find_all_ancestors('parent', test_relationships) {'grandparent'} >>> find_all_ancestors('grandparent', test_relationships) set() >>> find_all_ancestors('not_in_tree', test_relationships) set()","solution":"from typing import List, Tuple, Set def find_all_ancestors(node: str, relationships: List[Tuple[str, str]]) -> Set[str]: Returns a set of all ancestors for a given node. parent_dict = {} # Create a dictionary for child to parent relationship for parent, child in relationships: parent_dict[child] = parent # Function to trace ancestors recursively def get_ancestors(n): if n not in parent_dict: return set() parent = parent_dict[n] return {parent} | get_ancestors(parent) return get_ancestors(node)"},{"question":"def find_unique_word(words): Returns the first unique word in the list. If there are no unique words, returns an empty string. Args: words (list): A list of words (strings). Returns: str: The first unique word or an empty string. >>> find_unique_word(['apple', 'banana', 'apple', 'orange', 'banana', 'grape']) 'orange' >>> find_unique_word(['apple', 'banana', 'apple', 'banana']) '' >>> find_unique_word(['unique', 'apple', 'banana', 'apple', 'banana']) 'unique' >>> find_unique_word(['apple', 'banana', 'apple', 'banana', 'unique']) 'unique' >>> find_unique_word(['one', 'two', 'three']) 'one' >>> find_unique_word(['apple', 'banana', 'apple', 'grape', 'banana', 'grape']) '' >>> find_unique_word([]) '' >>> find_unique_word(['single']) 'single' >>> find_unique_word(['first', 'second']) 'first'","solution":"def find_unique_word(words): Returns the first unique word in the list. If there are no unique words, returns an empty string. Args: words (list): A list of words (strings). Returns: str: The first unique word or an empty string. from collections import Counter word_counts = Counter(words) for word in words: if word_counts[word] == 1: return word return ''"},{"question":"def rearrange(lst): Takes a list of integers and returns a new list with the elements rearranged so that all even numbers appear first, followed by all odd numbers. >>> rearrange([3, 1, 2, 4]) [2, 4, 3, 1] >>> rearrange([7, 3, 4, 1, 2]) [4, 2, 7, 3, 1] >>> rearrange([]) [] >>> rearrange([1, 3, 5, 7]) [1, 3, 5, 7] >>> rearrange([2, 4, 6, 8]) [2, 4, 6, 8] >>> rearrange([1]) [1] >>> rearrange([2]) [2] >>> rearrange([1, 1, 1, 1]) [1, 1, 1, 1] >>> rearrange([2, 2, 2, 2]) [2, 2, 2, 2]","solution":"def rearrange(lst): Takes a list of integers and returns a new list with the elements rearranged so that all even numbers appear first, followed by all odd numbers. evens = [x for x in lst if x % 2 == 0] odds = [x for x in lst if x % 2 != 0] return evens + odds"},{"question":"from typing import List, Union def reserve_seats(seating_plan: List[List[int]], num_seats: int, row: int) -> Union[str, List[List[int]]]: Try to reserve \`num_seats\` consecutive seats in the requested \`row\` of the \`seating_plan\`. Return the updated seating plan if successful or a message indicating failure otherwise. >>> seating_plan = [ >>> [0, 0, 0, 1, 1], >>> [1, 0, 0, 0, 0], >>> [0, 1, 1, 0, 0], >>> [0, 0, 0, 0, 0] >>> ] >>> reserve_seats(seating_plan, 2, 3) [[0, 0, 0, 1, 1], [1, 0, 0, 0, 0], [0, 1, 1, 0, 0], [1, 1, 0, 0, 0]] >>> reserve_seats(seating_plan, 3, 1) 'Cannot reserve seats'","solution":"from typing import List, Union def reserve_seats(seating_plan: List[List[int]], num_seats: int, row: int) -> Union[str, List[List[int]]]: Try to reserve \`num_seats\` consecutive seats in the requested \`row\` of the \`seating_plan\`. Return the updated seating plan if successful or a message indicating failure otherwise. if row < 0 or row >= len(seating_plan): return 'Cannot reserve seats' consecutive = 0 start_index = -1 for i in range(len(seating_plan[row])): if seating_plan[row][i] == 0: if consecutive == 0: start_index = i consecutive += 1 if consecutive == num_seats: for j in range(start_index, start_index + num_seats): seating_plan[row][j] = 1 return seating_plan else: consecutive = 0 start_index = -1 return 'Cannot reserve seats'"},{"question":"def find_indices(nums, target): Finds two distinct indices i and j such that nums[i] + nums[j] equals target. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple of int: A tuple containing the indices (i, j) such that nums[i] + nums[j] = target. If no such indices exist, returns (-1, -1). Example: >>> find_indices([2, 7, 11, 15], 9) (0, 1) >>> find_indices([3, 2, 4], 6) (1, 2) >>> find_indices([3, 3], 6) (0, 1)","solution":"def find_indices(nums, target): Finds two distinct indices i and j such that nums[i] + nums[j] equals target. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple of int: A tuple containing the indices (i, j) such that nums[i] + nums[j] = target. If no such indices exist, returns (-1, -1). num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return (-1, -1)"},{"question":"def caesar_cipher(message: str, shift: int) -> str: Encrypts a message using a Caesar cipher. Parameters: - message (str): The plaintext message to be encrypted. - shift (int): The fixed number of positions each character is shifted. Returns: - str: The encrypted message. >>> caesar_cipher(\\"Hello, World!\\", 3) 'Khoor, Zruog!' >>> caesar_cipher(\\"abcdef\\", 1) 'bcdefg' >>> caesar_cipher(\\"XYZ\\", 2) 'ZAB' >>> caesar_cipher(\\"Test! 123\\", 4) 'Xiwx! 123'","solution":"def caesar_cipher(message: str, shift: int) -> str: Encrypts a message using a Caesar cipher. Parameters: - message (str): The plaintext message to be encrypted. - shift (int): The fixed number of positions each character is shifted. Returns: - str: The encrypted message. encrypted_message = [] for char in message: if char.isalpha(): # Determine the start value for uppercase and lowercase letters start = ord('A') if char.isupper() else ord('a') # Compute the new shifted character encrypted_char = chr(start + (ord(char) - start + shift) % 26) encrypted_message.append(encrypted_char) else: # Non-alphabetical characters are left unchanged encrypted_message.append(char) return ''.join(encrypted_message)"},{"question":"def find_clusters(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the number of clusters in the given city. >>> find_clusters(6, 5, [(1, 2), (2, 3), (4, 5), (4, 6), (5, 6)]) == 2 >>> find_clusters(1, 0, []) == 1 >>> find_clusters(5, 0, []) == 5 >>> find_clusters(4, 3, [(1, 2), (2, 3), (3, 4)]) == 1 >>> find_clusters(10, 6, [(1, 2), (2, 3), (4, 5), (6, 7), (7, 8), (9, 10)]) == 4 >>> find_clusters(7, 6, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 5), (5, 6)]) == 2 # Implement this function","solution":"def find_clusters(n, m, roads): from collections import defaultdict, deque def bfs(start, visited, adjacency_list): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) adjacency_list = defaultdict(list) for u, v in roads: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = set() clusters = 0 for zone in range(1, n + 1): if zone not in visited: bfs(zone, visited, adjacency_list) clusters += 1 return clusters"},{"question":"def can_form_balanced_tree(nodes): Determine if it's possible to rearrange the nodes to form a balanced binary tree. Parameters: nodes (List[int]): List of integers representing the nodes. Returns: str: \\"Yes\\" if it's possible to rearrange the nodes to form a balanced binary tree, otherwise \\"No\\". >>> can_form_balanced_tree([1, 2, 3, 4, 5]) \\"Yes\\" >>> can_form_balanced_tree([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \\"Yes\\" >>> can_form_balanced_tree([1]) \\"Yes\\" >>> can_form_balanced_tree([1, 2]) \\"Yes\\" >>> can_form_balanced_tree([1, 2, 3, 4, 6]) \\"Yes\\" >>> can_form_balanced_tree([4, 2, 6, 1, 3, 5, 7, 8, 9, 10]) \\"Yes\\" >>> can_form_balanced_tree([5, 17, -2, 12, 8, 4, 3, 6, 1]) \\"Yes\\"","solution":"def can_form_balanced_tree(nodes): Determine if it's possible to rearrange the nodes to form a balanced binary tree. Parameters: nodes (list): List of integers representing the nodes. Returns: str: \\"Yes\\" if it's possible to rearrange the nodes to form a balanced binary tree, otherwise \\"No\\". n = len(nodes) # A balanced binary tree has height log2(n). We check if the number of nodes # is such that it can form a complete binary tree. import math # height of a complete binary tree height = math.ceil(math.log2(n + 1)) - 1 # Complete nodes a given height complete_nodes = (1 << (height + 1)) - 1 # Number of nodes necessary for a balanced tree at a given height # should be between the perfect and the perfect of the next layer minus the necessary nodes. return \\"Yes\\" if (complete_nodes - n) <= (1 << height) else \\"No\\""},{"question":"def longest_increasing_subsequence_length(arr): Returns the length of the longest increasing subsequence in a given list of integers. The subsequence does not have to be contiguous. Args: arr (List[int]): List of integers. Returns: int: Length of the longest increasing subsequence. Examples: >>> longest_increasing_subsequence_length([5, 1, 6, 2, 7, 1, 8, 3]) 4 >>> longest_increasing_subsequence_length([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence_length([5]) 1","solution":"def longest_increasing_subsequence_length(arr): if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage n = 8 arr = [5, 1, 6, 2, 7, 1, 8, 3] print(longest_increasing_subsequence_length(arr)) # Output: 4"},{"question":"def unique_sequence(N: int) -> int: Returns the N-th number in the unique sequence, where each number is the product of all previous numbers plus one. >>> unique_sequence(1) == 1 >>> unique_sequence(2) == 2 >>> unique_sequence(4) == 7 def find_nth_number(seq: callable, test_cases: List[int]) -> List[int]: Given a list of test cases, compute the N-th number in the sequence for each test case. >>> find_nth_number(unique_sequence, [1, 2, 3]) == [1, 2, 3] >>> find_nth_number(unique_sequence, [4, 5]) == [7, 43] def process_input(input_data: str) -> str: Process the input format and return the result for each test case. >>> process_input(\\"3n1n2n4\\") == \\"1n2n7\\" >>> process_input(\\"2n5n6\\") == \\"43n1807\\" >>> process_input(\\"4n1n2n3n4\\") == \\"1n2n3n7\\"","solution":"def unique_sequence(N): Returns the N-th number in the unique sequence. if N == 1: return 1 sequence = [1] # Start the sequence with the first number for i in range(1, N): # Each new number is the product of all previous numbers plus one product = 1 for num in sequence: product *= num next_number = product + 1 sequence.append(next_number) return sequence[-1] def find_nth_number(seq, test_cases): Given a list of test cases, compute the N-th number in the sequence for each test case. result = [] for n in test_cases: result.append(unique_sequence(n)) return result def process_input(input_data): Process the input format and return the result for each test case. lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [int(lines[i]) for i in range(1, T + 1)] output = find_nth_number(unique_sequence, test_cases) return \\"n\\".join(map(str, output))"},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: Check whether a binary tree is symmetric around its center. Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is symmetric, False otherwise. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(3) >>> isSymmetric(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(3) >>> isSymmetric(root) False >>> isSymmetric(None) True pass","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: if not root: return True def isMirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and isMirror(left.left, right.right) and isMirror(left.right, right.left) return isMirror(root.left, root.right)"},{"question":"def count_occurrences(n, arr): Returns the count of distinct integers and the number of occurrences for each distinct integer according to their appearance in the input list. :param n: an integer, the number of elements in the list :param arr: a list of integers :return: (distinct_count, occurrences_list) >>> count_occurrences(7, [4, 2, 4, 5, 2, 3, 5]) (4, [2, 2, 2, 1]) >>> count_occurrences(1, [1]) (1, [1]) >>> count_occurrences(5, [1, 2, 3, 4, 5]) (5, [1, 1, 1, 1, 1]) >>> count_occurrences(4, [2, 2, 2, 2]) (1, [4]) >>> count_occurrences(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) (2, [5, 5])","solution":"def count_occurrences(n, arr): Returns the count of distinct integers and the number of occurrences for each distinct integer according to their appearance in the input list. :param n: an integer, the number of elements in the list :param arr: a list of integers :return: (distinct_count, occurrences_list) from collections import OrderedDict occurrences = OrderedDict() for num in arr: if num in occurrences: occurrences[num] += 1 else: occurrences[num] = 1 distinct_count = len(occurrences) occurrences_list = list(occurrences.values()) return distinct_count, occurrences_list"},{"question":"def can_reorder(q: int, test_cases: List[Tuple[int, str]]) -> List[str]: Reorder the characters in each test case string such that no two adjacent characters are the same. Parameters: q (int): The number of test cases. test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains the length of the string and the string itself. Returns: List[str]: A list of reordered strings or \\"NO\\" if reordering is not possible. >>> can_reorder(3, [(4, 'aabb'), (3, 'aaa'), (5, 'abcde')]) ['abab', 'NO', 'abcde'] >>> can_reorder(1, [(2, 'aa')]) ['NO'] >>> can_reorder(1, [(6, 'abcdef')]) ['abcdef'] >>> can_reorder(1, [(4, 'aabb')]) # Any valid reordering where no two adjacent characters are the same will be accepted: \\"abab\\", \\"baba\\"","solution":"from collections import Counter import heapq def can_reorder(q, test_cases): results = [] for n, s in test_cases: char_counts = Counter(s) max_heap = [(-count, char) for char, count in char_counts.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) count += 1 prev_count, prev_char = count, char if len(result) == n: results.append(\\"\\".join(result)) else: results.append(\\"NO\\") return results # Function to read input, process it, and output the results def main(): import sys input = sys.stdin.read data = input().split() q = int(data[0]) index = 1 test_cases = [] for _ in range(q): n = int(data[index]) s = data[index + 1] test_cases.append((n, s)) index += 2 results = can_reorder(q, test_cases) for result in results: print(result)"},{"question":"from typing import List def count_safe_zones(grid: List[List[str]], n: int, m: int) -> int: Find the number of distinct connected components of unoccupied cells in a grid. >>> count_safe_zones([ ['.', '*', '.', '.', '*'], ['*', '.', '.', '*', '*'], ['.', '*', '.', '.', '*'], ['*', '*', '*', '.', '*'] ], 4, 5) 3 >>> count_safe_zones([ ['.', '.', '.', '.'], ['.', '*', '*', '.'], ['.', '*', '*', '.'], ['.', '.', '.', '.'] ], 4, 4) 1 >>> count_safe_zones([ ['*'] ], 1, 1) 0 >>> count_safe_zones([ ['.', '*'], ['*', '.'] ], 2, 2) 2 >>> count_safe_zones([ ['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*'] ], 3, 3) 0 >>> count_safe_zones([ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ], 3, 3) 1","solution":"def count_safe_zones(grid, n, m): def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] != '.': return grid[x][y] = '#' # mark as visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) safe_zones = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': safe_zones += 1 dfs(i, j) return safe_zones def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [list(data[i + 2]) for i in range(n)] result = count_safe_zones(grid, n, m) print(result)"},{"question":"def max_profit(stock_prices: List[int]) -> int: Given a list of stock prices, determine the maximum profit that can be achieved by buying and selling the stock exactly once. :param stock_prices: List[int] - List of stock prices :return: int - Maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 def process_test_cases(t: int, test_cases: List[List[int]]) -> List[int]: Process multiple test cases to find maximum profit for each. :param t: int - Number of test cases :param test_cases: List[List[int]] - List of stock prices for each test case :return: List[int] - List of maximum profits for each test case >>> process_test_cases(2, [[7, 1, 5, 3, 6, 4], [7, 6, 4, 3, 1]]) [5, 0] >>> process_test_cases(1, [[3, 3, 5, 0, 0, 3, 1, 4]]) [4]","solution":"def max_profit(stock_prices): Given a list of stock prices, determine the maximum profit that can be achieved by buying and selling the stock exactly once. :param stock_prices: List[int] - List of stock prices :return: int - Maximum profit if not stock_prices: return 0 min_price = float('inf') max_profit = 0 for price in stock_prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit def process_test_cases(t, test_cases): Process multiple test cases to find maximum profit for each. :param t: int - Number of test cases :param test_cases: List[List[int]] - List of stock prices for each test case :return: List[int] - List of maximum profits for each test case return [max_profit(prices) for prices in test_cases]"},{"question":"def find_max_sum_submatrix(n: int, k: int, matrix: List[List[int]]) -> Tuple[int, int]: Given a square matrix of size n x n filled with non-negative integers, find a fixed-size submatrix (of size k x k) such that the sum of its elements is maximized. If there are multiple submatrices with the same maximum sum, return the top-left corner of any one of them. Indices should be 1-based. Args: n (int): The size of the matrix. k (int): The size of the submatrix. matrix (List[List[int]]): The matrix of non-negative integers. Returns: Tuple[int, int]: The row and column indices of the top-left corner of the submatrix with the maximum sum (1-based). >>> find_max_sum_submatrix(4, 2, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) (3, 3) >>> find_max_sum_submatrix(5, 3, [ ... [1, 2, 3, 4, 5], ... [1, 2, 3, 4, 5], ... [1, 2, 3, 4, 5], ... [1, 2, 3, 4, 5], ... [1, 2, 3, 4, 5] ... ]) (1, 3) >>> find_max_sum_submatrix(3, 1, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) (3, 3) >>> find_max_sum_submatrix(2, 2, [ ... [1, 2], ... [3, 4] ... ]) (1, 1) >>> find_max_sum_submatrix(4, 2, [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) (1, 1)","solution":"def find_max_sum_submatrix(n, k, matrix): max_sum = -1 top_left = (0, 0) # Create a prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] for i in range(1, n - k + 2): for j in range(1, n - k + 2): total = ( prefix_sum[i + k - 1][j + k - 1] - prefix_sum[i - 1][j + k - 1] - prefix_sum[i + k - 1][j - 1] + prefix_sum[i - 1][j - 1] ) if total > max_sum: max_sum = total top_left = (i, j) return top_left[0], top_left[1]"},{"question":"def min_moves_to_reach_end(n: int, m: int, grid: List[str]) -> int: Calculate the minimum number of moves to reach the bottom-right corner of the grid from the top-left corner. >>> min_moves_to_reach_end(5, 5, [\\".....\\", \\".#...\\", \\"...\\", \\"...#.\\", \\".....\\"]) 8 >>> min_moves_to_reach_end(4, 4, [\\"....\\", \\"\\", \\"....\\", \\"....\\"]) -1","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): # Directions for right and down moves directions = [(0, 1), (1, 0)] # Check if the start or end points are obstacles if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 # BFS setup queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() # If reached the bottom-right corner if x == n-1 and y == m-1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1 # If no path is found"},{"question":"from typing import List def remove_consecutive_duplicates(lst: List[str]) -> List[str]: Returns a new list with consecutive duplicate elements removed. Parameters: lst (list): A list of strings. Returns: list: A new list with consecutive duplicates removed. Examples: >>> remove_consecutive_duplicates(['foo', 'foo', 'bar', 'bar', 'baz', 'foo', 'foo']) ['foo', 'bar', 'baz', 'foo'] >>> remove_consecutive_duplicates(['a', 'a', 'a', 'b', 'c', 'c', 'd', 'd', 'd']) ['a', 'b', 'c', 'd']","solution":"def remove_consecutive_duplicates(lst): Returns a new list with consecutive duplicate elements removed. Parameters: lst (list): A list of strings. Returns: list: A new list with consecutive duplicates removed. if not lst: return [] result = [lst[0]] for item in lst[1:]: if item != result[-1]: result.append(item) return result"},{"question":"def min_operations_to_sum_k(n, k, array): Returns the number of operations required to make the sum of the array equal to k. >>> min_operations_to_sum_k(3, 6, [1, 2, 3]) 0 >>> min_operations_to_sum_k(4, 10, [1, 1, 1, 1]) 6 >>> min_operations_to_sum_k(2, 200, [50, 150]) 0 >>> min_operations_to_sum_k(2, 100, [20, 30]) 50 def process_test_cases(t, test_cases): Process multiple test cases and return a list of results. >>> test_cases = [ ... (3, 6, [1, 2, 3]), ... (4, 10, [1, 1, 1, 1]), ... (2, 200, [50, 150]), ... (2, 100, [20, 30]) ... ] >>> process_test_cases(4, test_cases) [0, 6, 0, 50]","solution":"def min_operations_to_sum_k(n, k, array): Returns the number of operations required to make the sum of the array equal to k. current_sum = sum(array) # no operations needed if the current sum is already k return abs(current_sum - k) def process_test_cases(t, test_cases): results = [] for i in range(t): n, k, array = test_cases[i] result = min_operations_to_sum_k(n, k, array) results.append(result) return results"},{"question":"def can_rearrange(A: int, B: int) -> int: Checks if it's possible to rearrange the digits of A to form B. Parameters: A (int): First integer B (int): Second integer Returns: int: 1 if possible, 0 otherwise Examples: >>> can_rearrange(123, 321) 1 >>> can_rearrange(123, 312) 1 >>> can_rearrange(123, 456) 0 def test_can_rearrange_possible_cases(): assert can_rearrange(123, 321) == 1 assert can_rearrange(123, 312) == 1 assert can_rearrange(112233, 332211) == 1 def test_can_rearrange_impossible_cases(): assert can_rearrange(123, 456) == 0 assert can_rearrange(987, 7891) == 0 assert can_rearrange(101, 1100) == 0 def test_can_rearrange_edge_cases(): assert can_rearrange(1, 1) == 1 assert can_rearrange(10, 100) == 0 assert can_rearrange(0, 0) == 1","solution":"def can_rearrange(A, B): Checks if it's possible to rearrange the digits of A to form B. Parameters: A (int): First integer B (int): Second integer Returns: int: 1 if possible, 0 otherwise return 1 if sorted(str(A)) == sorted(str(B)) else 0"},{"question":"def subset_sum_exists(a: List[int], n: int, k: int) -> str: Determines if there exists a subset of the array a such that the sum of its elements is exactly k. >>> subset_sum_exists([3, 34, 4, 12, 5], 5, 9) \\"YES\\" >>> subset_sum_exists([3, 34, 4, 12, 5], 5, 30) \\"NO\\" >>> subset_sum_exists([1, 2, 3], 3, 0) \\"YES\\" >>> subset_sum_exists([5], 1, 5) \\"YES\\" >>> subset_sum_exists([10], 1, 5) \\"NO\\" >>> subset_sum_exists([100000, 200000], 2, 100000) \\"YES\\" >>> subset_sum_exists([100000, 200000], 2, 1) \\"NO\\" >>> subset_sum_exists([1, 2, 3, 4, 5], 5, 15) \\"YES\\"","solution":"def subset_sum_exists(a, n, k): Determines if there exists a subset of the array a such that the sum of its elements is exactly k. Args: a (list): List of integers. n (int): Length of the array. k (int): Target sum. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". # Initialize a DP array with False dp = [False] * (k + 1) dp[0] = True # There is always a subset (empty set) with sum 0 for num in a: for s in range(k, num - 1, -1): if dp[s - num]: dp[s] = True return \\"YES\\" if dp[k] else \\"NO\\" # Example usage: # n = 5, k = 9, a = [3, 34, 4, 12, 5] # Output should be: YES print(subset_sum_exists([3, 34, 4, 12, 5], 5, 9))"},{"question":"from typing import List def canArrange(grid: List[List[int]]) -> bool: Determine if it is possible to complete the grid by filling the empty cells (represented by 0) such that all rows and columns have unique sequences of photo IDs. >>> canArrange([[1, 2, 0], ... [0, 3, 1], ... [2, 1, 3]]) False >>> canArrange([[1, 0, 3], ... [0, 3, 1], ... [3, 1, 2]]) True","solution":"from typing import List def canArrange(grid: List[List[int]]) -> bool: n = len(grid) # Helper function to check if a number can be placed at grid[i][j] def is_valid(num, row, col): for k in range(n): if grid[row][k] == num or grid[k][col] == num: return False return True # Backtracking function to fill the grid def solve(): for i in range(n): for j in range(n): if grid[i][j] == 0: for num in range(1, n+1): if is_valid(num, i, j): grid[i][j] = num if solve(): return True grid[i][j] = 0 return False return True return solve()"},{"question":"def max_non_overlapping_meetings(n: int, meetings: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping meetings that can be scheduled in a day. :param n: Number of meetings :param meetings: List of tuples, each containing start and end time of a meeting :return: Maximum number of non-overlapping meetings >>> max_non_overlapping_meetings(3, [(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_meetings(3, [(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_meetings(4, [(0, 3), (1, 2), (3, 4), (4, 5)]) 3","solution":"def max_non_overlapping_meetings(n, meetings): Returns the maximum number of non-overlapping meetings that can be scheduled in a day. :param n: Number of meetings :param meetings: List of tuples, each containing start and end time of a meeting :return: Maximum number of non-overlapping meetings # Sort meetings based on end time meetings.sort(key=lambda x: x[1]) count = 0 last_end_time = -1 for start, end in meetings: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def determine_winner(n: int, sequence: List[int]) -> str: Determines the winner of the game between Alex and Bob. >>> determine_winner(5, [3, 1, 4, 1, 5]) \\"Alex\\" >>> determine_winner(3, [2, 4, 6]) \\"Alex\\" >>> determine_winner(4, [1, 2, 3, 4]) \\"Bob\\" >>> determine_winner(6, [1, 1, 1, 1, 1, 1]) \\"Bob\\" >>> determine_winner(1, [10]) \\"Alex\\" >>> determine_winner(4, [1000000000, -1000000000, 500000000, -500000000]) \\"Bob\\" >>> determine_winner(5, [-1000000000, 1000000000, -1000000000, 1000000000, 0]) \\"Alex\\"","solution":"def determine_winner(n, sequence): Determines the winner of the game between Alex and Bob. Parameters: n (int): The number of elements in the sequence sequence (list of int): The initial sequence of integers Returns: str: \\"Alex\\" if the first player is guaranteed to win, otherwise \\"Bob\\" sequence.sort(reverse=True) # Sort the sequence in descending order if n % 2 == 1: # If the length of the sequence is odd return \\"Alex\\" else: # If the length of the sequence is even return \\"Bob\\""},{"question":"def classify_sequences(sequences): Classifies a list of integer sequences as 'chirp', 'buzz', 'whistle', or 'unknown'. Parameters: sequences (List[List[int]]): A list of sequences, each represented by a list of integers. Returns: List[str]: A list of classifications for each sequence, one of 'chirp', 'buzz', 'whistle', or 'unknown'. >>> classify_sequences([[5, 1, 2, 3, 4, 5], [5, 5, 4, 3, 2, 1], [5, 7, 7, 7, 7, 7], [4, 1, 3, 2, 5], [3, 6, 6, 6]]) ['chirp', 'buzz', 'whistle', 'unknown', 'whistle'] >>> classify_sequences([[4, 1, 2, 3, 4], [3, -10, -5, 0], [5, 1, 3, 5, 7, 9]]) ['chirp', 'chirp', 'chirp'] >>> classify_sequences([[4, 4, 3, 2, 1], [3, 0, -5, -10], [5, 9, 7, 5, 3, 1]]) ['buzz', 'buzz', 'buzz'] >>> classify_sequences([[4, 1, 1, 1, 1], [3, -5, -5, -5], [5, 7, 7, 7, 7, 7]]) ['whistle', 'whistle', 'whistle'] >>> classify_sequences([[4, 1, 2, 1, 3], [3, -5, 0, -1], [5, 1, 1, 2, 2, 3]]) ['unknown', 'unknown', 'unknown']","solution":"def classify_sequences(sequences): Classifies a list of integer sequences as 'chirp', 'buzz', 'whistle', or 'unknown'. results = [] for sequence in sequences: n = sequence[0] seq = sequence[1:] if all(seq[i] < seq[i + 1] for i in range(n - 1)): results.append(\\"chirp\\") elif all(seq[i] > seq[i + 1] for i in range(n - 1)): results.append(\\"buzz\\") elif all(seq[i] == seq[0] for i in range(n)): results.append(\\"whistle\\") else: results.append(\\"unknown\\") return results"},{"question":"def minimum_time_to_connect_all_grids(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum time required to connect all grids so they form a Single Connected Network. Args: N : int : the number of nodes (grids) M : int : the number of edges (connections) edges : List[Tuple[int, int, int]] : a list of connections between nodes, where each connection is represented as a tuple (u, v, w) Returns: int : the minimum time required to connect all grids, or -1 if it is impossible to connect all grids. >>> minimum_time_to_connect_all_grids(4, 5, [(1, 2, 1), (2, 3, 4), (3, 4, 2), (1, 4, 3), (1, 3, 5)]) 6 >>> minimum_time_to_connect_all_grids(4, 2, [(1, 2, 5), (3, 4, 10)]) -1","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_time_to_connect_all_grids(N, M, edges): if N == 1: return 0 edges.sort(key=lambda x: x[2]) # Sort edges based on their weight parent = [i for i in range(N)] rank = [0] * N mst_weight = 0 edges_used = 0 for edge in edges: u, v, w = edge u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += w edges_used += 1 if edges_used != N - 1: return -1 return mst_weight"},{"question":"def is_back_to_origin(moves: str) -> str: Determines if the character ends up at the starting point after completing all the moves. Parameters: moves (str): A string representing the sequence of moves. 'L', 'R', 'U', 'D' which represent moving left, right, up, and down respectively. Returns: str: \\"Yes\\" if the character returns to the origin (0, 0) after all moves, otherwise \\"No\\". >>> is_back_to_origin(\\"UDLR\\") 'Yes' >>> is_back_to_origin(\\"LR\\") 'Yes' >>> is_back_to_origin(\\"UD\\") 'Yes' >>> is_back_to_origin(\\"UU\\") 'No' >>> is_back_to_origin(\\"RDD\\") 'No'","solution":"def is_back_to_origin(moves): Determines if the character ends up at the starting point after completing all the moves. Parameters: moves (str): A string representing the sequence of moves. 'L', 'R', 'U', 'D' which represent moving left, right, up, and down respectively. Returns: str: \\"Yes\\" if the character returns to the origin (0, 0) after all moves, otherwise \\"No\\". x = y = 0 for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return \\"Yes\\" if x == 0 and y == 0 else \\"No\\""},{"question":"def find_first_peak(temperatures: List[int]) -> int: Finds the first peak in an array of temperatures. A peak is defined as an element greater than its immediate neighbours. :param temperatures: List of integers representing the temperatures recorded over a week. :return: The first peak if it exists, otherwise -1. Examples: >>> find_first_peak([1, 3, 2, 4, 5, 3, 7, 2]) 3 >>> find_first_peak([1, 2, 3, 2, 4, 3, 5]) 3 >>> find_first_peak([5, 3, 2, 1]) 5 >>> find_first_peak([1, 2, 3, 4, 5]) 5 >>> find_first_peak([5, 5, 5, 5]) -1 >>> find_first_peak([-1, -2, -3, -2, -4]) -1 >>> find_first_peak([1, 2]) 2 >>> find_first_peak([2, 1]) 2 >>> find_first_peak([]) -1","solution":"def find_first_peak(temperatures): Finds the first peak in an array of temperatures. A peak is defined as an element greater than its immediate neighbours. :param temperatures: List of integers representing the temperatures recorded over a week. :return: The first peak if it exists, otherwise -1. n = len(temperatures) for i in range(n): if (i == 0 and temperatures[i] > temperatures[i+1]) or (i == n-1 and temperatures[i] > temperatures[i-1]) or (0 < i < n-1 and temperatures[i] > temperatures[i-1] and temperatures[i] > temperatures[i+1]): return temperatures[i] return -1"},{"question":"from typing import List, Tuple def can_princess_escape(n: int, m: int, px: int, py: int, ps: int, guards: List[Tuple[int, int, int]]) -> str: Determines if the princess can escape the grid to any boundary cell. Args: n: int - The number of rows in the grid. m: int - The number of columns in the grid. px: int - The starting row of the princess. py: int - The starting column of the princess. ps: int - The security number of the princess. guards: List[Tuple[int, int, int]] - The list of guards with their positions and security numbers. Returns: str - \\"YES\\" if the princess can escape, otherwise \\"NO\\". >>> can_princess_escape(5, 5, 3, 3, 7, [(2, 2, 5), (2, 3, 6), (3, 2, 8), (4, 4, 5), (5, 5, 10)]) \\"YES\\" >>> can_princess_escape(3, 3, 2, 2, 3, [(1, 2, 4), (2, 1, 4), (2, 3, 4), (3, 2, 4)]) \\"NO\\"","solution":"def can_princess_escape(n, m, px, py, ps, guards): from collections import deque # Mark all the guards in the grid with their security numbers grid = [[None] * m for _ in range(n)] for gx, gy, gs in guards: grid[gx - 1][gy - 1] = gs # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Breadth-First Search (BFS) to explore the grid queue = deque([(px - 1, py - 1)]) visited = set([(px - 1, py - 1)]) while queue: x, y = queue.popleft() # Check if current position is at the boundary if x == 0 or y == 0 or x == n - 1 or y == m - 1: return \\"YES\\" # Explore neighbor cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: guard_security = grid[nx][ny] # The princess can move to this cell if either it's empty # or her security number is higher than the guard's security number in that cell if guard_security is None or guard_security < ps: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"from typing import List def is_promotable(title: str) -> str: Determines if a book title is promotable. A title is promotable if it contains a palindromic substring of length ≥ 3. Parameters: title (str): The book title. Returns: str: \\"YES\\" if promotable, \\"NO\\" if not. >>> is_promotable(\\"racecar\\") 'YES' >>> is_promotable(\\"book\\") 'NO' >>> is_promotable(\\"hello\\") 'NO' pass def segment_book_titles(titles: List[str]) -> List[str]: For a list of book titles, determine which are promotable. Parameters: titles (List[str]): List of book titles. Returns: List[str]: List of \\"YES\\" or \\"NO\\" indicating promotability. >>> segment_book_titles([\\"racecar\\", \\"book\\", \\"hello\\"]) ['YES', 'NO', 'NO'] >>> segment_book_titles([\\"aabaa\\", \\"abcde\\", \\"aaa\\"]) ['YES', 'NO', 'YES'] >>> segment_book_titles([\\"abcdcba\\", \\"abcdefg\\", \\"xyzyx\\"]) ['YES', 'NO', 'YES'] pass","solution":"def is_promotable(title): Determines if a book title is promotable. A title is promotable if it contains a palindromic substring of length ≥ 3. Parameters: title (str): The book title. Returns: str: \\"YES\\" if promotable, \\"NO\\" if not. n = len(title) def is_palindrome(s): return s == s[::-1] for length in range(3, n + 1): for i in range(n - length + 1): if is_palindrome(title[i:i+length]): return \\"YES\\" return \\"NO\\" def segment_book_titles(titles): For a list of book titles, determine which are promotable. Parameters: titles (List[str]): List of book titles. Returns: List[str]: List of \\"YES\\" or \\"NO\\" indicating promotability. results = [] for title in titles: results.append(is_promotable(title)) return results"},{"question":"def averageScores(student_data): Prints the names of students sorted by their average score in ascending order. If two students have the same average score, maintain their relative input order. Parameters: student_data (list): A list of strings, where the first element is the number of students and each subsequent element represents a student's name followed by three scores in different subjects. Returns: None: Prints the sorted student names. Example: >>> student_data = [ ... '5', ... 'Alice 80 90 100', ... 'Bob 70 80 90', ... 'Charlie 90 90 90', ... 'David 60 70 80', ... 'Eva 90 100 90' ... ] >>> averageScores(student_data) David Bob Alice Charlie Eva # Your code here def test_averageScores_basic(): import sys from io import StringIO data = [\\"5\\", \\"Alice 80 90 100\\", \\"Bob 70 80 90\\", \\"Charlie 90 90 90\\", \\"David 60 70 80\\", \\"Eva 90 100 90\\"] expected_output = \\"DavidnBobnAlicenCharlienEvan\\" old_stdout = sys.stdout sys.stdout = StringIO() averageScores(data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output def test_averageScores_same_average(): import sys from io import StringIO data = [\\"3\\", \\"Alice 90 90 90\\", \\"Bob 90 90 90\\", \\"Charlie 90 90 90\\"] expected_output = \\"AlicenBobnCharlien\\" old_stdout = sys.stdout sys.stdout = StringIO() averageScores(data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output def test_averageScores_different_averages(): import sys from io import StringIO data = [\\"3\\", \\"Alice 70 80 90\\", \\"Bob 90 90 90\\", \\"Charlie 60 70 80\\"] expected_output = \\"CharlienAlicenBobn\\" old_stdout = sys.stdout sys.stdout = StringIO() averageScores(data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output","solution":"def averageScores(student_data): Prints the names of students sorted by their average score in ascending order. If two students have the same average score, maintain their relative input order. Parameters: student_data (list): A list of strings, where the first element is the number of students and each subsequent element represents a student's name followed by three scores in different subjects. Returns: None: Prints the sorted student names. n = int(student_data[0]) students = [] for i in range(1, n + 1): parts = student_data[i].split() name = parts[0] scores = list(map(int, parts[1:])) average_score = sum(scores) / len(scores) students.append((average_score, i, name)) # Sort by average score and then by their original index to maintain relative order for ties. students.sort(key=lambda x: (x[0], x[1])) for student in students: print(student[2])"},{"question":"def matrix_rotate(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix 90 degrees clockwise in-place. If the input matrix is empty, the function returns an empty matrix. >>> matrix_rotate([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> matrix_rotate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix_rotate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> matrix_rotate([]) [] >>> matrix_rotate([[42]]) [[42]] pass","solution":"def matrix_rotate(matrix): Rotates an n x n matrix 90 degrees clockwise in-place. if not matrix or not matrix[0]: return matrix n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): top = matrix[first][i] # Move left to top matrix[first][i] = matrix[last - (i - first)][first] # Move bottom to left matrix[last - (i - first)][first] = matrix[last][last - (i - first)] # Move right to bottom matrix[last][last - (i - first)] = matrix[i][last] # Move top to right matrix[i][last] = top return matrix"},{"question":"def maximize_diagonals(n: int) -> List[List[int]]: Construct an n x n matrix with distinct integers that maximizes the sum of the sums of the diagonals. >>> maximize_diagonals(1) [[1]] >>> maximize_diagonals(2) [[1, 3], [2, 4]] >>> maximize_diagonals(3) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> maximize_diagonals(4) [[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]] >>> maximize_diagonals(5) [[1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24], [5, 10, 15, 20, 25]]","solution":"def maximize_diagonals(n): Construct an n x n matrix with distinct integers that maximizes the sum of the sums of the diagonals. matrix = [[0] * n for _ in range(n)] num = 1 for i in range(n): for j in range(n): matrix[i][j] = num num += 1 # Swapping to maximize the diagonal sums for i in range(n): for j in range(i, n): if i != j: matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix"},{"question":"def maximum_product_of_three(arr): Determine the maximum product of three distinct elements in the list. If the list contains fewer than three elements, return -1. Args: arr (list of int): The input list of integers. Returns: int: The maximum product of three distinct elements or -1 if not feasible. >>> maximum_product_of_three([4, 1, 3, 2]) 24 >>> maximum_product_of_three([-1, -2, -3, -4]) -6 >>> maximum_product_of_three([1, 2]) -1","solution":"def maximum_product_of_three(arr): Determine the maximum product of three distinct elements in the list. If the list contains fewer than three elements, return -1. Args: arr (list of int): The input list of integers. Returns: int: The maximum product of three distinct elements or -1 if not feasible. if len(arr) < 3: return -1 arr.sort() # Maximum product can be from either: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers (which might be negative) and the largest number max_product = max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]) return max_product"},{"question":"def find_anagram_pairs(words: List[str]) -> List[Tuple[str, str]]: Given a list of words, finds all pairs of different words that are anagrams of each other. >>> find_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"cat\\"]) [('enlist', 'listen'), ('enlist', 'silent'), ('gogole', 'google'), ('listen', 'silent')] >>> find_anagram_pairs([\\"apple\\", \\"orange\\", \\"banana\\"]) [] >>> find_anagram_pairs([\\"Listen\\", \\"Silent\\", \\"enLiSt\\"]) [('Listen', 'Silent'), ('Listen', 'enLiSt'), ('Silent', 'enLiSt')] >>> find_anagram_pairs([\\"a bc\\", \\"cab\\", \\" bac\\"]) [(' bac', 'a bc'), (' bac', 'cab'), ('a bc', 'cab')] def main(N: int, word_list: List[str]) -> None: Print each pair of words that are anagrams of each other, one pair per line. >>> main(6, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"cat\\"]) enlist listen enlist silent gogole google listen silent >>> main(3, [\\"apple\\", \\"orange\\", \\"banana\\"]) No anagrams found","solution":"def find_anagram_pairs(words): Given a list of words, finds all pairs of different words that are anagrams of each other. Args: words (list of str): List of words. Returns: list of tuple: List of tuples containing pairs of anagrams. def sorted_word(word): return ''.join(sorted(word.replace(' ', '').lower())) anagram_pairs = [] checked_pairs = set() words_sorted = [(word, sorted_word(word)) for word in words] for i in range(len(words_sorted)): for j in range(i + 1, len(words_sorted)): word1, sorted1 = words_sorted[i] word2, sorted2 = words_sorted[j] if sorted1 == sorted2: pair = tuple(sorted([word1, word2])) if pair not in checked_pairs: checked_pairs.add(pair) anagram_pairs.append(pair) anagram_pairs.sort() return anagram_pairs # To facilitate easier reading of the function. def main(N, word_list): pairs = find_anagram_pairs(word_list) if pairs: for pair in pairs: print(f\\"{pair[0]} {pair[1]}\\") else: print(\\"No anagrams found\\")"},{"question":"def compute_mean_of_sum_axis_0(N: int, M: int, array: List[List[int]]) -> float: Given a 2-D array of dimensions N x M, compute the sum over axis 0 and then find the mean of that. Parameters: N (int): Number of rows in the array. M (int): Number of columns in the array. array (list of list of int): 2-D array of integers. Returns: float: Mean of the sum along axis 0, rounded to two decimal places. >>> compute_mean_of_sum_axis_0(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15.00 >>> compute_mean_of_sum_axis_0(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 3.00 >>> compute_mean_of_sum_axis_0(2, 2, [[-1, -2], [-3, -4]]) -5.00 >>> compute_mean_of_sum_axis_0(2, 3, [[-1, 0, 2], [3, -4, 1]]) 0.33 >>> compute_mean_of_sum_axis_0(1, 1, [[42]]) 42.00","solution":"def compute_mean_of_sum_axis_0(N, M, array): Given a 2-D array of dimensions N x M, compute the sum over axis 0 and then find the mean of that. Parameters: N (int): Number of rows in the array. M (int): Number of columns in the array. array (list of list of int): 2-D array of integers. Returns: float: Mean of the sum along axis 0, rounded to two decimal places. # Sum along axis 0 sum_axis_0 = [sum(row[col] for row in array) for col in range(M)] # Compute mean of the sum mean_sum = sum(sum_axis_0) / M # Return rounded result return round(mean_sum, 2)"},{"question":"def find_missing_ids(n, badge_ids): Returns a list of missing IDs in ascending order. Parameters: n (int): Total number of expected unique IDs badge_ids (list of ints): List of printed badge IDs Returns: list of ints: List of missing IDs in ascending order pass # Example usage: # >>> find_missing_ids(5, [2, 3, 2, 5, 3]) # [1, 4] # >>> find_missing_ids(3, [1, 2, 3]) # [] # >>> find_missing_ids(3, []) # [1, 2, 3] from solution import find_missing_ids def test_example_case(): assert find_missing_ids(5, [2, 3, 2, 5, 3]) == [1, 4] def test_no_missing_ids(): assert find_missing_ids(3, [1, 2, 3]) == [] def test_all_missing_ids(): assert find_missing_ids(3, []) == [1, 2, 3] def test_some_missing_ids(): assert find_missing_ids(4, [1, 1, 2, 2, 3]) == [4] def test_large_n_with_some_missing_ids(): assert find_missing_ids(10, [10, 9, 8, 7, 6, 5, 4, 2, 2, 1]) == [3]","solution":"def find_missing_ids(n, badge_ids): Returns a list of missing IDs in ascending order. Parameters: n (int): Total number of expected unique IDs badge_ids (list of ints): List of printed badge IDs Returns: list of ints: List of missing IDs in ascending order expected_ids = set(range(1, n + 1)) actual_ids = set(badge_ids) missing_ids = expected_ids - actual_ids return sorted(missing_ids)"},{"question":"from typing import List, Tuple def shortest_path_in_grid(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[str]]]]) -> List[int]: Find the length of the shortest path in a grid with obstacles. Parameters: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[List[str]]]]): Test cases, each containing a tuple of grid dimensions and the grid itself. Returns: List[int]: List of shortest path lengths, or -1 if no path exists. Example: >>> shortest_path_in_grid(2, [((3, 3), [['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.']]), ((4, 4), [['.', '.', '.', '.'], ['#', '#', '#', '.'], ['.', '.', '.', '.'], ['.', '#', '#', '.']])]) [4, 6] >>> shortest_path_in_grid(1, [((3, 3), [['.', '.', '#'], ['#', '#', '.'], ['.', '.', '.']])]) [-1] >>> shortest_path_in_grid(1, [((2, 2), [['.', '#'], ['#', '.']])]) [-1] >>> shortest_path_in_grid(1, [((2, 2), [['.', '.'], ['.', '.']])]) [2]","solution":"from collections import deque def shortest_path_in_grid(T, test_cases): def bfs(grid, M, N): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (M-1, N-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) steps += 1 return -1 results = [] for i in range(T): M, N = test_cases[i][0] grid = test_cases[i][1] result = bfs(grid, M, N) results.append(result) return results"},{"question":"def find_best_discounts(n, user_discounts): Given the number of users and their respective discount offers, return a list of optimal discounts for each user to maximize expected revenue. :param n: int, number of users :param user_discounts: list of lists, each containing tuples of (discount, probability) for the discounts available to a user :return: list of ints, optimal discount values for each user Example: >>> find_best_discounts(3, [[(10, 50), (20, 70), (30, 90)], [(5, 30), (15, 80)], [(7, 60), (40, 50), (50, 20), (60, 90)]]) [30, 15, 60] >>> find_best_discounts(1, [[(5, 100)]]) [5] >>> find_best_discounts(1, [[(10, 50), (20, 25), (5, 100)]]) [5] >>> find_best_discounts(2, [[(10, 30), (20, 40), (30, 50)], [(5, 20), (15, 60), (25, 80)]]) [30, 25] >>> find_best_discounts(1, [[(10, 0), (20, 0), (30, 0)]]) [10] >>> find_best_discounts(2, [[(10, 100), (20, 50)], [(30, 33), (33, 30)]]) [10, 30]","solution":"def find_best_discounts(n, user_discounts): Given the number of users and their respective discount offers, return a list of optimal discounts for each user to maximize expected revenue. :param n: int, number of users :param user_discounts: list of lists, each containing tuples of (discount, probability) for the discounts available to a user :return: list of ints, optimal discount values for each user best_discounts = [] for discounts in user_discounts: max_revenue = -1 best_discount = None for d, p in discounts: expected_revenue = d * (p / 100.0) if expected_revenue > max_revenue: max_revenue = expected_revenue best_discount = d elif expected_revenue == max_revenue and d < best_discount: best_discount = d best_discounts.append(best_discount) return best_discounts"},{"question":"def max_increasing_subsequence_sum(n: int, a: List[int]) -> int: Function to find the maximum sum of a strictly increasing subsequence. Parameters: n (int): The number of integers in the list. a (list of int): The elements of the list. Returns: int: The maximum sum of the strictly increasing subsequence. pass # Unit tests def test_example_case(): assert max_increasing_subsequence_sum(6, [10, 22, 9, 33, 21, 50]) == 115 def test_single_element(): assert max_increasing_subsequence_sum(1, [10]) == 10 def test_all_elements_increasing(): assert max_increasing_subsequence_sum(5, [1, 2, 3, 4, 5]) == 15 def test_no_increasing_subsequence(): assert max_increasing_subsequence_sum(5, [5, 4, 3, 2, 1]) == 5 def test_mixed_elements(): assert max_increasing_subsequence_sum(8, [1, 101, 2, 3, 100, 4, 5, 6]) == 106 def test_all_elements_same(): assert max_increasing_subsequence_sum(4, [7, 7, 7, 7]) == 7","solution":"def max_increasing_subsequence_sum(n, a): Function to find the maximum sum of a strictly increasing subsequence. Parameters: n (int): The number of integers in the list. a (list of int): The elements of the list. Returns: int: The maximum sum of the strictly increasing subsequence. if n == 0: return 0 # Initialize the dp array dp = a[:] # dp[i] will store the maximum sum of increasing subsequence ending with a[i] # Build the dp array for i in range(1, n): for j in range(i): if a[i] > a[j]: dp[i] = max(dp[i], dp[j] + a[i]) # The maximum value in dp array is the result return max(dp)"},{"question":"def safe_drawbridge_position(T, cases): Determines if there is at least one safe segment for each test case. Parameters: T (int): Number of test cases cases (list of tuples): Each tuple contains an integer N and a list of integers representing the segments. Returns: list: A list of \\"YES\\" or \\"NO\\" for each test case. >>> safe_drawbridge_position(3, [(5, \\"1 0 1 1 0\\".split()), (4, \\"1 1 1 1\\".split()), (6, \\"0 0 1 0 1 0\\".split())]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> safe_drawbridge_position(2, [(3, \\"0 0 0\\".split()), (1, \\"0\\".split())]) [\\"YES\\", \\"YES\\"] >>> safe_drawbridge_position(2, [(3, \\"1 1 1\\".split()), (1, \\"1\\".split())]) [\\"NO\\", \\"NO\\"] >>> safe_drawbridge_position(2, [(4, \\"1 0 0 1\\".split()), (5, \\"1 1 0 1 1\\".split())]) [\\"YES\\", \\"YES\\"] >>> safe_drawbridge_position(1, [(1, \\"0\\".split())]) [\\"YES\\"] >>> safe_drawbridge_position(1, [(1, \\"1\\".split())]) [\\"NO\\"]","solution":"def safe_drawbridge_position(T, cases): Determines if there is at least one safe segment for each test case. Parameters: T (int): Number of test cases cases (list of tuples): Each tuple contains an integer N and a list of integers representing the segments. Returns: list: A list of \\"YES\\" or \\"NO\\" for each test case. results = [] for N, segments in cases: if '0' in segments: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sort_seashells(seashells): Sorts a list of seashells by size in ascending order. If two seashells have the same size, they are sorted by type in alphabetical order. Parameters: seashells (list of tuples): A list where each tuple contains a size (int) and a type (str) of a seashell. Returns: list of tuples: The sorted list of seashells. Examples: >>> sort_seashells([(3, 'conch'), (1, 'sanddollar'), (2, 'starfish')]) [(1, 'sanddollar'), (2, 'starfish'), (3, 'conch')] >>> sort_seashells([(5, 'whelk'), (3, 'conch'), (5, 'scallop'), (1, 'abalone')]) [(1, 'abalone'), (3, 'conch'), (5, 'scallop'), (5, 'whelk')]","solution":"def sort_seashells(seashells): Sorts a list of seashells by size in ascending order. If two seashells have the same size, they are sorted by type in alphabetical order. Parameters: seashells (list of tuples): A list where each tuple contains a size (int) and a type (str) of a seashell. Returns: list of tuples: The sorted list of seashells. return sorted(seashells, key=lambda x: (x[0], x[1]))"},{"question":"def max_green_signals(M, N, traffic_signals): This function calculates the maximum number of traffic signals that can be set to green without causing congestion in the intersection grid. Args: M (int): Number of rows in the grid. N (int): Number of columns in the grid. traffic_signals (List[Tuple[int, int]]): List of coordinates of traffic signals. Returns: int: The maximum number of non-conflicting green signals. Examples: >>> max_green_signals(4, 4, [(0, 1), (1, 3), (2, 0), (3, 2)]) 4 >>> max_green_signals(1, 1, []) 0 >>> max_green_signals(3, 3, [(0, 0), (1, 1), (2, 2)]) 3","solution":"def max_green_signals(M, N, traffic_signals): This function calculates the maximum number of traffic signals that can be set to green without causing congestion in the intersection grid. row_occupied = set() col_occupied = set() # Iterate through each traffic signal for x, y in traffic_signals: # If the row and column is not already occupied by a green signal if x not in row_occupied and y not in col_occupied: row_occupied.add(x) col_occupied.add(y) # Return the maximum number of non-conflicting green signals return min(len(row_occupied), len(col_occupied)) # Example usage M, N = 4, 4 traffic_signals = [(0, 1), (1, 3), (2, 0), (3, 2)] print(max_green_signals(M, N, traffic_signals)) # Output: 4"},{"question":"def shortest_path(R, C, Sr, Sc, Dr, Dc, grid): Find the shortest path from the starting point to the destination in a grid. >>> grid = [ ... \\".....\\", ... \\".#.\\", ... \\"...#.\\", ... \\".#.\\", ... \\"...#.\\" ... ] >>> shortest_path(5, 5, 0, 0, 4, 4, grid) 8 >>> grid = [ ... \\".#.\\", ... \\".#.\\", ... \\".#.\\" ... ] >>> shortest_path(3, 3, 0, 0, 2, 2, grid) -1 >>> grid = [ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ] >>> shortest_path(4, 4, 0, 0, 3, 3, grid) 6 >>> grid = [ ... \\"....\\", ... \\".#..\\", ... \\"....\\", ... \\"....\\" ... ] >>> shortest_path(4, 4, 2, 2, 2, 2, grid) 0 >>> grid = [\\"...\\"] >>> shortest_path(1, 3, 0, 0, 0, 2, grid) 2","solution":"from collections import deque def shortest_path(R, C, Sr, Sc, Dr, Dc, grid): def is_valid(x, y): return 0 <= x < R and 0 <= y < C and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right visited = set((Sr, Sc)) queue = deque([(Sr, Sc, 0)]) # stores (row, column, steps) while queue: r, c, steps = queue.popleft() if (r, c) == (Dr, Dc): return steps for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc) and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def sum_of_digits(s: str) -> int: Compute the sum of the digits in a given string. The string consists of alphanumeric characters and possibly other special characters. Extract all the numeric digits, sum them up, and return the result. Parameters: s (str): The input string which may contain alphanumeric and special characters. Returns: int: The sum of all numerical digits in the string. Returns 0 if no digits are found. >>> sum_of_digits(\\"a1b2c3\\") 6 >>> sum_of_digits(\\"no_digits_here!\\") 0 >>> sum_of_digits(\\"12345\\") 15 >>> sum_of_digits(\\"a!@#1b2c&3\\") 6 >>> sum_of_digits(\\"\\") 0 >>> sum_of_digits(\\"!@#%^&*()\\") 0 >>> sum_of_digits(\\"9a8b7c6\\") 30 >>> sum_of_digits(\\"abc123xxx456\\") 21","solution":"def sum_of_digits(s): Computes the sum of all numerical digits in the given string. Parameters: s (str): The input string which may contain alphanumeric and special characters. Returns: int: The sum of all numerical digits in the string. Returns 0 if no digits are found. return sum(int(char) for char in s if char.isdigit())"},{"question":"def find_max_min_difficulties(levels): Returns the maximum and minimum difficulty levels from a list of level difficulties. Args: levels (list of int): A list of difficulty levels. Returns: tuple: A tuple containing the maximum and minimum difficulty levels. pass # Complete the function to return the required values # Example test cases def test_example_1(): assert find_max_min_difficulties([4, 7, 1, 8, 9]) == (9, 1) def test_example_2(): assert find_max_min_difficulties([10, 10, 10]) == (10, 10) def test_example_3(): assert find_max_min_difficulties([15, 3, 21, 6, 9, 4]) == (21, 3) def test_example_4(): assert find_max_min_difficulties([100, 200, 150, 180]) == (200, 100) def test_single_level(): assert find_max_min_difficulties([42]) == (42, 42) def test_all_same_levels(): assert find_max_min_difficulties([7, 7, 7, 7, 7]) == (7, 7) def test_all_different_levels(): assert find_max_min_difficulties([3, 1, 6, 8, 2, 5, 9, 7, 4]) == (9, 1)","solution":"def find_max_min_difficulties(levels): Returns the maximum and minimum difficulty levels from a list of level difficulties. Args: levels (list of int): A list of difficulty levels. Returns: tuple: A tuple containing the maximum and minimum difficulty levels. max_difficulty = max(levels) min_difficulty = min(levels) return max_difficulty, min_difficulty"},{"question":"from typing import List def is_perfect_number(n: int) -> bool: Checks if a number n is a perfect number. def smallest_perfect_number_greater_than(x: int) -> int: Returns the smallest perfect number greater than x. >>> smallest_perfect_number_greater_than(5) 6 >>> smallest_perfect_number_greater_than(27) 28 >>> smallest_perfect_number_greater_than(100) 496 >>> smallest_perfect_number_greater_than(500) 8128 >>> smallest_perfect_number_greater_than(10000) 33550336","solution":"def is_perfect_number(n): Checks if a number n is a perfect number. if n <= 1: return False divisors_sum = 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: divisors_sum += i if i != n // i: divisors_sum += n // i return divisors_sum == n def smallest_perfect_number_greater_than(x): Returns the smallest perfect number greater than x. perfect_numbers = [6, 28, 496, 8128, 33550336] # Known perfect numbers less than 10^9 for pn in perfect_numbers: if pn > x: return pn return -1 # If there is no perfect number greater than x within the known range"},{"question":"def distribute_days(employees, n): Distributes days as evenly as possible among employees. Parameters: employees (list): List of employee names. n (int): Number of days in the scheduling period. Returns: dict: Dictionary where each key is an employee name and the value is a list of on-call days. >>> distribute_days([\\"Alice\\", \\"Bob\\"], 4) {'Alice': [1, 3], 'Bob': [2, 4]} >>> distribute_days([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], 10) {'Alice': [1, 4, 7, 10], 'Bob': [2, 5, 8], 'Charlie': [3, 6, 9]} >>> distribute_days([\\"Alice\\"], 3) {'Alice': [1, 2, 3]} >>> distribute_days([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"], 2) {'Alice': [1], 'Bob': [2], 'Charlie': [], 'David': []} >>> distribute_days([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], 1) {'Alice': [1], 'Bob': [], 'Charlie': []}","solution":"def distribute_days(employees, n): Distributes days as evenly as possible among employees. Parameters: employees (list): List of employee names. n (int): Number of days in the scheduling period. Returns: dict: Dictionary where each key is an employee name and the value is a list of on-call days. schedule = {employee: [] for employee in employees} k = len(employees) for day in range(1, n + 1): # Assign the day to the appropriate employee employee_index = (day - 1) % k schedule[employees[employee_index]].append(day) return schedule"},{"question":"def min_coins(amount, denominations): Determines the minimum number of coins required to make the given amount using the available denominations. Parameters: amount (int): The amount of money to make. denominations (list): A list of available coin denominations. Returns: int: The minimum number of coins, or -1 if it is impossible to make the amount. # Infinite value to represent an unreachable state pass def solve(test_cases): Solves multiple test cases for the minimum number of coins problem. Parameters: test_cases (list): A list of tuples where each tuple contains the amount and the coins. Returns: list: A list containing the results for each test case. pass if __name__ == \\"__main__\\": test_cases = [ (11, [1, 5, 10]), (7, [1, 3, 4, 5]), (15, [1, 2, 5, 10]), (9, [1, 3, 4]), (11, [5, 7]) ] expected = [2, 2, 2, 3, -1] assert solve(test_cases) == expected","solution":"def min_coins(amount, denominations): Determines the minimum number of coins required to make the given amount using the available denominations. Parameters: amount (int): The amount of money to make. denominations (list): A list of available coin denominations. Returns: int: The minimum number of coins, or -1 if it is impossible to make the amount. # Infinite value to represent an unreachable state INF = float('inf') # Initialize a list to store the minimum coins needed for each amount up to the desired amount dp = [INF] * (amount + 1) dp[0] = 0 # For each coin, update the dp array for coin in denominations: for x in range(coin, amount + 1): if dp[x - coin] != INF: dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != INF else -1 def solve(test_cases): Solves multiple test cases for the minimum number of coins problem. Parameters: test_cases (list): A list of tuples where each tuple contains the amount and the coins. Returns: list: A list containing the results for each test case. results = [] for amount, denominations in test_cases: results.append(min_coins(amount, denominations)) return results"},{"question":"def filter_divisible_by_3(numbers): Filters out the numbers divisible by 3 from a given list. :param numbers: List of integers :return: New list containing only numbers divisible by 3 ... def process_input(n, sequence): Process the input to filter and return the elements divisible by 3. :param n: Number of elements in sequence :param sequence: List of integers :return: List of integers divisible by 3 if n != len(sequence): raise ValueError(\\"The number of elements does not match n.\\") ... # Unit tests def test_simple_case_with_divisible_numbers(): assert process_input(6, [1, 3, 5, 9, 12, 15]) == [3, 9, 12, 15] def test_all_numbers_not_divisible_by_3(): assert process_input(5, [4, 7, 10, 13, 16]) == [] def test_mixed_sign_numbers(): assert process_input(7, [-9, -1, 3, 6, 0, 19, 21]) == [-9, 3, 6, 0, 21] def test_single_element(): assert process_input(1, [3]) == [3] assert process_input(1, [1]) == [] def test_incorrect_n_value_raises_error(): try: process_input(5, [1, 2, 3]) except ValueError as e: assert str(e) == \\"The number of elements does not match n.\\" else: assert False, \\"Expected ValueError not raised\\" def test_filter_divisible_by_3(): assert filter_divisible_by_3([4, 9, 18, 23, -3, 12, -10]) == [9, 18, -3, 12] assert filter_divisible_by_3([1, 2, 4, 5, 7, 8]) == [] assert filter_divisible_by_3([0, 3, 6, 9, 12]) == [0, 3, 6, 9, 12]","solution":"def filter_divisible_by_3(numbers): Filters out the numbers divisible by 3 from a given list. :param numbers: List of integers :return: New list containing only numbers divisible by 3 return [num for num in numbers if num % 3 == 0] def process_input(n, sequence): Process the input to filter and return the elements divisible by 3. :param n: Number of elements in sequence :param sequence: List of integers :return: List of integers divisible by 3 if n != len(sequence): raise ValueError(\\"The number of elements does not match n.\\") return filter_divisible_by_3(sequence)"},{"question":"def max_orders_in_k_days(test_cases): Calculate the maximum number of orders received within any contiguous subarray of K days. Parameters: test_cases (list of tuples): A list of test cases, where each test case is a tuple (N, K, orders). - N (int): The number of days. - K (int): The length of the subarray. - orders (list of int): The number of orders received on each of the N days. Returns: list of int: The maximum number of orders received in such a subarray for each test case. Example: >>> max_orders_in_k_days([(5, 3, [1, 2, 3, 4, 5])]) [12] >>> max_orders_in_k_days([(7, 4, [3, 8, 1, 7, 4, 2, 0])]) [20]","solution":"def max_orders_in_k_days(test_cases): results = [] for case in test_cases: N, K, orders = case # Compute the sum of the first subarray of length K max_sum = current_sum = sum(orders[:K]) # Iterate through the rest of the days for i in range(K, N): current_sum = current_sum + orders[i] - orders[i - K] max_sum = max(max_sum, current_sum) results.append(max_sum) return results # Example usage: # prepared_input = [(5, 3, [1, 2, 3, 4, 5]), (7, 4, [3, 8, 1, 7, 4, 2, 0])] # print(max_orders_in_k_days(prepared_input)) # [12, 20]"},{"question":"def max_energy(m, n, grid): Calculates the maximum possible energy that can be collected starting from the top-left corner and ending at the bottom-right corner by only moving right or down. :param m: Number of rows in the grid :param n: Number of columns in the grid :param grid: 2D list representing the energy levels in the grid :return: Maximum collected energy >>> max_energy(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_energy(1, 1, [[5]]) == 5 >>> max_energy(1, 5, [[1, 2, 3, 4, 5]]) == 15 >>> max_energy(5, 1, [ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) == 15 >>> max_energy(1000, 1000, [[1 for _ in range(1000)] for _ in range(1000)]) == 1999","solution":"def max_energy(m, n, grid): Calculates the maximum possible energy that can be collected starting from the top-left corner and ending at the bottom-right corner by only moving right or down. :param m: Number of rows in the grid :param n: Number of columns in the grid :param grid: 2D list representing the energy levels in the grid :return: Maximum collected energy dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] # Fill first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def min_partitions_unique_substrings(s: str) -> int: Returns the minimum number of substrings in which the given sequence can be partitioned such that each substring contains unique characters only. Args: s : str : A string consisting of only lowercase English letters. Returns: int : The minimum number of substrings required. Test Cases: >>> min_partitions_unique_substrings(\\"abac\\") 2 >>> min_partitions_unique_substrings(\\"aaaaa\\") 5 >>> min_partitions_unique_substrings(\\"a\\") 1 >>> min_partitions_unique_substrings(\\"ab\\") 1 >>> min_partitions_unique_substrings(\\"aba\\") 2 >>> min_partitions_unique_substrings(\\"abcdefghijklmnopqrstuvwxyz\\") 1 >>> min_partitions_unique_substrings(\\"aaaaaaaaaaaaaaaaaaaa\\") 20 >>> min_partitions_unique_substrings(\\"abcabcabc\\") 3 >>> min_partitions_unique_substrings(\\"\\") 0","solution":"def min_partitions_unique_substrings(s): Returns the minimum number of substrings such that each substring contains unique characters. seen = set() partitions = 0 for char in s: if char in seen: partitions += 1 seen.clear() seen.add(char) # Account for the last partition if \`seen\` is not empty. if seen: partitions += 1 return partitions"},{"question":"def identify_traffic_jams(n: int, m: int, roads: List[Tuple[int, int, int]]) -> str: Identify if there is any intersection in the network such that flows from non-overlapping paths converge, causing an intersection traffic jam. Args: n : int : Number of intersections m : int : Number of roads roads : List[Tuple[int, int, int]] : List of roads represented as tuples (u, v, w) where u is the starting intersection, v is the ending intersection, and w is the current traffic intensity Returns: str : \\"YES\\" if there is a traffic jam, otherwise \\"NO\\" >>> identify_traffic_jams(4, 4, [(1, 2, 10), (2, 3, 20), (1, 3, 15), (3, 4, 5)]) 'YES' >>> identify_traffic_jams(4, 4, [(1, 2, 10), (2, 3, 20), (3, 4, 5), (4, 1, 25)]) 'NO' >>> identify_traffic_jams(3, 2, [(1, 2, 50), (2, 3, 50)]) 'NO' >>> identify_traffic_jams(3, 3, [(1, 3, 30), (2, 3, 40), (1, 2, 25)]) 'YES' >>> identify_traffic_jams(1, 0, []) 'NO'","solution":"def identify_traffic_jams(n, m, roads): from collections import defaultdict # Create a list to store incoming edges for each node incoming_edges = defaultdict(list) # Fill the incoming edges list for u, v, w in roads: incoming_edges[v].append((u, w)) # Check each intersection to see if there are converging non-overlapping paths for intersection in range(1, n + 1): if len(incoming_edges[intersection]) > 1: incoming_nodes = [u for u, w in incoming_edges[intersection]] incoming_traffic_intensity = [w for u, w in incoming_edges[intersection]] # We need to ensure that these incoming paths are non-overlapping # This involves checking if any incoming paths share common roads before reaching the intersection for i in range(len(incoming_nodes)): for j in range(i + 1, len(incoming_nodes)): if incoming_nodes[i] != incoming_nodes[j]: return \\"YES\\" return \\"NO\\" # Function usage n = 4 m = 4 roads = [ (1, 2, 10), (2, 3, 20), (1, 3, 15), (3, 4, 5) ] print(identify_traffic_jams(n, m, roads)) # Expected output: YES"},{"question":"def two_sum(nums, target): Determines if there are two distinct integers in the list that add up to the target integer. Args: nums (list of int): List of integers. target (int): The target integer. Returns: bool: True if such a pair exists, otherwise False. # write your code here # Unit Tests def test_two_sum_with_valid_pair(): assert two_sum([2, 7, 11, 15], 9) == True def test_two_sum_with_no_valid_pair(): assert two_sum([1, 2, 3, 4], 8) == False def test_two_sum_with_multiple_elements(): assert two_sum([3, 3, 4, 2], 6) == True def test_two_sum_with_negative_and_positive(): assert two_sum([-1, 1, 2, 4], 3) == True def test_two_sum_with_no_elements(): assert two_sum([], 5) == False def test_two_sum_with_only_one_element(): assert two_sum([5], 5) == False def test_two_sum_with_same_elements(): assert two_sum([1, 1, 1, 1], 2) == True def test_two_sum_with_repeated_elements_but_valid_pair(): assert two_sum([1, 1, 2, 3], 5) == True def test_two_sum_with_large_numbers(): assert two_sum([1000000, 500000, 1000000, 2000000], 2500000) == True","solution":"def two_sum(nums, target): Determines if there are two distinct integers in the list that add up to the target integer. Args: nums (list of int): List of integers. target (int): The target integer. Returns: bool: True if such a pair exists, otherwise False. num_set = set() for num in nums: complement = target - num if complement in num_set: return True num_set.add(num) return False"},{"question":"def count_subarrays(arr, N, X): Given an array of integers of size N and an integer X, count the number of subarrays that sum to X. Parameters: arr (List[int]): The array of integers. N (int): The size of the array. X (int): The target sum. Returns: int: The number of subarrays that sum to X. >>> count_subarrays([1, 2, 3, 4, 5], 5, 9) == 2 >>> count_subarrays([10, 2, -2, -20, 10], 5, -10) == 3 # Unit Tests def test_example_1(): assert count_subarrays([1, 2, 3, 4, 5], 5, 9) == 2 def test_example_2(): assert count_subarrays([10, 2, -2, -20, 10], 5, -10) == 3 def test_single_element_equals_X(): assert count_subarrays([5], 1, 5) == 1 def test_single_element_not_equals_X(): assert count_subarrays([1], 1, 5) == 0 def test_multiple_subarrays(): assert count_subarrays([1, 1, 1], 3, 2) == 2 def test_no_subarrays(): assert count_subarrays([1, 2, 3], 3, 7) == 0 def test_positive_and_negative_numbers(): assert count_subarrays([1, -1, 2, -2, 3, -3], 6, 0) == 6","solution":"def count_subarrays(arr, N, X): Returns the count of subarrays in arr of size N that sum to X. # Dictionary to store cumulative sum frequencies cum_sum_freq = {0: 1} cum_sum = 0 count = 0 for num in arr: cum_sum += num if (cum_sum - X) in cum_sum_freq: count += cum_sum_freq[cum_sum - X] if cum_sum in cum_sum_freq: cum_sum_freq[cum_sum] += 1 else: cum_sum_freq[cum_sum] = 1 return count"},{"question":"from typing import List, Tuple def find_shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, k: int, critical_services: List[int]) -> List[int]: Compute the minimum time required to complete a task from the starting microservice to each of the critical microservices. Parameters: n (int): Number of microservices. m (int): Number of dependency call times. edges (List[Tuple[int, int, int]]): Each tuple contains three integers a, b, and t where service a calls service b with a call time of t units. s (int): Starting microservice k (int): Number of critical microservices critical_services (List[int]): List of critical microservices. Returns: List[int]: Minimum time required to complete a task from the starting microservice to each of the critical microservices. If a critical microservice is not reachable, return -1 for that microservice. >>> find_shortest_path(5, 6, [(0, 1, 5), (1, 2, 10), (0, 3, 2), (3, 4, 3), (4, 2, 7), (1, 4, 2)], 0, 2, [2, 4]) [12, 5] >>> find_shortest_path(5, 4, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1)], 1, 2, [4, 3]) [3, 2]","solution":"import heapq from collections import defaultdict, deque import sys def find_shortest_path(n, m, edges, s, k, critical_services): graph = defaultdict(list) for a, b, t in edges: graph[a].append((b, t)) def dijkstra(start, n): distances = {i: float('inf') for i in range(n)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances shortest_paths_from_s = dijkstra(s, n) result = [] for critical_service in critical_services: result.append(shortest_paths_from_s[critical_service] if shortest_paths_from_s[critical_service] != float('inf') else -1) return result"},{"question":"def spiral_order(matrix): Given an m x n matrix, return all elements of the matrix in spiral order. >>> spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiral_order([[1]]) [1] >>> spiral_order([[1, 2], [3, 4]]) [1, 2, 4, 3]","solution":"def spiral_order(matrix): Given a 2D matrix, return the elements of the matrix in spiral order. if not matrix: return [] m, n = len(matrix), len(matrix[0]) result = [] visited = [[False]*n for _ in range(m)] directions = [(0,1), (1,0), (0,-1), (-1,0)] dir_index = 0 row, col = 0, 0 for _ in range(m * n): result.append(matrix[row][col]) visited[row][col] = True next_row, next_col = row + directions[dir_index][0], col + directions[dir_index][1] if 0 <= next_row < m and 0 <= next_col < n and not visited[next_row][next_col]: row, col = next_row, next_col else: dir_index = (dir_index + 1) % 4 row, col = row + directions[dir_index][0], col + directions[dir_index][1] return result"},{"question":"def two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Parameters: nums (List[int]): List of integers. target (int): Target sum. Returns: List[int]: List containing the indices of the two numbers. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1000000, 500000, -500000, -1000000], 0) [1, 2] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([5, 5, 5], 10) [0, 1] >>> two_sum([1, 5, 7, 4, 3], 10) [2, 4] pass","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Parameters: nums (List[int]): List of integers. target (int): Target sum. Returns: List[int]: List containing the indices of the two numbers. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i raise ValueError(\\"No two sum solution found\\")"},{"question":"def transform_string(permutation, n, original_str): Transforms the original_str based on the given permutation. :param permutation: A string representing the permutation of the English alphabet. :param n: An integer representing the length of the string to be transformed. :param original_str: A string of n lowercase English letters to be transformed. :return: The transformed string. pass def test_transform_string_example1(): permutation = \\"qwertyuiopasdfghjklzxcvbnm\\" n = 5 original_str = \\"hello\\" assert transform_string(permutation, n, original_str) == \\"itssg\\" def test_transform_string_example2(): permutation = \\"zyxwvutsrqponmlkjihgfedcba\\" n = 5 original_str = \\"abcde\\" assert transform_string(permutation, n, original_str) == \\"zyxwv\\" def test_transform_string_single_character(): permutation = \\"zyxwvutsrqponmlkjihgfedcba\\" n = 1 original_str = \\"a\\" assert transform_string(permutation, n, original_str) == \\"z\\" def test_transform_string_multiple_same_characters(): permutation = \\"qwertyuiopasdfghjklzxcvbnm\\" n = 4 original_str = \\"aaaa\\" assert transform_string(permutation, n, original_str) == \\"qqqq\\" def test_transform_string_full_alphabet(): permutation = \\"qwertyuiopasdfghjklzxcvbnm\\" n = 26 original_str = \\"abcdefghijklmnopqrstuvwxyz\\" assert transform_string(permutation, n, original_str) == \\"qwertyuiopasdfghjklzxcvbnm\\"","solution":"def transform_string(permutation, n, original_str): Transforms the original_str based on the given permutation. :param permutation: A string representing the permutation of the English alphabet. :param n: An integer representing the length of the string to be transformed. :param original_str: A string of n lowercase English letters to be transformed. :return: The transformed string. # Create a dictionary to map original alphabet to the permuted one char_map = {chr(97 + i): permutation[i] for i in range(26)} # Transform the original string transformed_str = ''.join(char_map[char] for char in original_str) return transformed_str"},{"question":"def overlapping_coordinates(Na, Nb, W, H, coords_A, coords_B): Returns the number of unique points of overlap between the movements of Species A and Species B. Parameters: Na (int): Number of coordinates recorded for Species A. Nb (int): Number of coordinates recorded for Species B. W (int): Width of the rectangular reserve. H (int): Height of the rectangular reserve. coords_A (list of lists): List of [x, y] coordinates for Species A. coords_B (list of lists): List of [x, y] coordinates for Species B. Returns: int: The number of unique points of overlap between Species A and Species B. Example: >>> overlapping_coordinates(4, 3, 20, 20, [[10, 15], [15, 10], [5, 5], [10, 10]], [[15, 10], [10, 15], [5, 5]]) 3","solution":"def overlapping_coordinates(Na, Nb, W, H, coords_A, coords_B): Returns the number of unique points of overlap between the movements of Species A and Species B. # Convert list of coordinates to set to find unique coordinates set_A = set(map(tuple, coords_A)) set_B = set(map(tuple, coords_B)) # Calculate the intersection of the two sets to get the overlapping coordinates overlap = set_A & set_B # Return the number of overlapping coordinates return len(overlap)"},{"question":"def count_gas_stations(route): Count the number of gas stations ('G') in each section of the route. Parameters: route (list of str): A list where each string represents a section of the road. Returns: list of str: A formatted list with the number of gas stations in each section. from pytest import mark @mark.parametrize( \\"route, expected\\", [ ([\\"--G--\\", \\"-G---G\\", \\"--\\", \\"G--G-GG\\", \\"--G-\\"], [\\"Section 1: 1 gas stations\\", \\"Section 2: 2 gas stations\\", \\"Section 3: 0 gas stations\\", \\"Section 4: 4 gas stations\\", \\"Section 5: 1 gas stations\\"]), ([\\"--\\", \\"---\\", \\"----\\"], [\\"Section 1: 0 gas stations\\", \\"Section 2: 0 gas stations\\", \\"Section 3: 0 gas stations\\"]), ([\\"G\\", \\"G\\", \\"G\\", \\"G\\"], [\\"Section 1: 1 gas stations\\", \\"Section 2: 1 gas stations\\", \\"Section 3: 1 gas stations\\", \\"Section 4: 1 gas stations\\"]), ([\\"\\", \\"\\", \\"\\"], [\\"Section 1: 0 gas stations\\", \\"Section 2: 0 gas stations\\", \\"Section 3: 0 gas stations\\"]), ([\\"G--\\", \\"-G-G-\\", \\"--\\", \\"-GG-\\", \\"GGG--G\\"], [\\"Section 1: 1 gas stations\\", \\"Section 2: 2 gas stations\\", \\"Section 3: 0 gas stations\\", \\"Section 4: 2 gas stations\\", \\"Section 5: 4 gas stations\\"]), ] ) def test_count_gas_stations(route, expected): assert count_gas_stations(route) == expected","solution":"def count_gas_stations(route): Count the number of gas stations ('G') in each section of the route. Parameters: route (list of str): A list where each string represents a section of the road. Returns: list of str: A formatted list with the number of gas stations in each section. result = [] for index, section in enumerate(route): count = section.count('G') result.append(f\\"Section {index + 1}: {count} gas stations\\") return result"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge all overlapping intervals and return the non-overlapping intervals that cover all the intervals in the input. >>> merge_intervals([(1, 3), (2, 4), (5, 7)]) [(1, 4), (5, 7)] >>> merge_intervals([(6, 8), (1, 3), (2, 4), (9, 10)]) [(1, 4), (6, 8), (9, 10)] >>> merge_intervals([(1, 2), (3, 4), (5, 6)]) [(1, 2), (3, 4), (5, 6)] >>> merge_intervals([(1, 5), (2, 6), (3, 7)]) [(1, 7)] >>> merge_intervals([]) [] def parse_input(input_string: str) -> List[Tuple[int, int]]: Parse the input string to extract intervals. >>> parse_input(\\"3n1 3n2 4n5 7\\") [(1, 3), (2, 4), (5, 7)]","solution":"def merge_intervals(intervals): Merge all overlapping intervals and return the non-overlapping intervals that cover all the intervals in the input. if not intervals: return [] # Sort intervals by starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals: last = merged[-1] if current[0] <= last[1]: # Overlapping intervals, merge them merged[-1] = (last[0], max(last[1], current[1])) else: merged.append(current) return merged # example usage def parse_input(input_string): lines = input_string.strip().split('n') n = int(lines[0]) intervals = [tuple(map(int, line.split())) for line in lines[1:n + 1]] return intervals def print_intervals(intervals): for interval in intervals: print(f\\"({interval[0]}, {interval[1]})\\") input_string = \\"4n6 8n1 3n2 4n9 10\\" intervals = parse_input(input_string) merged_intervals = merge_intervals(intervals) print_intervals(merged_intervals)"},{"question":"def odd_squares(nums): Returns a list containing the squares of all odd elements from the given list. Parameters: nums (list of int): A list of integers. Returns: list of int: A new list containing the squares of odd elements of the original list. >>> odd_squares([2, 3, 4, 5, 6]) [9, 25] >>> odd_squares([2, 4, 6, 8, 10]) [] >>> odd_squares([1, 3, 5, 7]) [1, 9, 25, 49] >>> odd_squares([-3, 4, -5, 6]) [9, 25] >>> odd_squares([]) [] >>> odd_squares([2, 4, 6, 8, 10]) [] >>> odd_squares(list(range(1, 1000000, 2))) == [i * i for i in range(1, 1000000, 2)] True","solution":"def odd_squares(nums): Returns a list containing the squares of all odd elements from the given list. Parameters: nums (list of int): A list of integers. Returns: list of int: A new list containing the squares of odd elements of the original list. return [x * x for x in nums if x % 2 != 0]"},{"question":"from typing import List, Tuple def find_missing_books_sum(N: int, M: int, S: int, book_ids: List[int]) -> int: Given the current list of book IDs and the values of S and M, this function returns the sum of the IDs of the missing books or -1 if there is a mistake. >>> find_missing_books_sum(3, 5, 100, [10, 20, 30]) 40 >>> find_missing_books_sum(2, 4, 50, [5, 10]) 35 >>> find_missing_books_sum(4, 5, 120, [15, 25, 35, 40]) 5 >>> find_missing_books_sum(3, 5, 70, [10, 25, 30]) -1 def solve_multiple_cases(T: int, cases: List[Tuple[Tuple[int, int, int], List[int]]]) -> List[int]: Processes multiple test cases, returning a list of results for each case. >>> cases = [ ... ((3, 5, 100), [10, 20, 30]), ... ((2, 4, 50), [5, 10]), ... ((4, 5, 120), [15, 25, 35, 40]) ... ] >>> solve_multiple_cases(3, cases) [40, 35, 5] >>> cases = [ ... ((3, 3, 100), [10, 20, 30]), ... ((1, 3, 50), [10]), ... ((2, 4, 45), [15, 20]) ... ] >>> solve_multiple_cases(3, cases) [-1, 40, 10]","solution":"def find_missing_books_sum(N, M, S, book_ids): Given the current list of book IDs and the values of S and M, this function returns the sum of the IDs of the missing books or -1 if there is a mistake. current_sum = sum(book_ids) expected_sum_of_missing_books = S - current_sum expected_count_of_missing_books = M - N if expected_count_of_missing_books > 0 and current_sum <= S: return expected_sum_of_missing_books return -1 def solve_multiple_cases(T, cases): results = [] for case in cases: N, M, S = case[0] book_ids = case[1] results.append(find_missing_books_sum(N, M, S, book_ids)) return results"},{"question":"def minimum_total_bonus(n, scores): Returns the minimum total bonus amount the company needs to distribute based on the scores of the employees. Parameters: n (int): The number of employees scores (List[int]): The scores of the employees Returns: int: The minimum total bonus amount Examples: >>> minimum_total_bonus(4, [10, 20, 20, 10]) 2 >>> minimum_total_bonus(5, [5, 5, 5, 5, 5]) 1 >>> minimum_total_bonus(3, [1, 2, 3]) 3 >>> minimum_total_bonus(1, [15]) 1 >>> minimum_total_bonus(4, [10, 20, 30, 40]) 4 >>> minimum_total_bonus(6, [10, 20, 20, 30, 30, 30]) 3 >>> minimum_total_bonus(1000, list(range(1, 1001))) 1000 >>> minimum_total_bonus(1000, [5] * 1000) 1","solution":"def minimum_total_bonus(n, scores): Returns the minimum total bonus amount the company needs to distribute based on the scores of the employees. unique_scores = set(scores) return len(unique_scores)"},{"question":"def game_winner(n: int, a: List[int]) -> str: Determines the winner of the game based on the rules provided. :param n: int - the number of elements in the list :param a: list of int - the elements of the list :return: str - \\"ALICE\\", \\"BOB\\", or \\"DRAW\\" based on who removes more numbers >>> game_winner(5, [4, 1, 2, 3, 5]) \\"ALICE\\" >>> game_winner(6, [1, 2, 3, 4, 5, 6]) \\"DRAW\\" pass def test_game_winner_case_1(): assert game_winner(5, [4, 1, 2, 3, 5]) == \\"ALICE\\" def test_game_winner_case_2(): assert game_winner(6, [1, 2, 3, 4, 5, 6]) == \\"DRAW\\" def test_game_winner_single_element(): assert game_winner(1, [42]) == \\"ALICE\\" def test_game_winner_even_elements(): assert game_winner(4, [100, 200, 300, 400]) == \\"DRAW\\" def test_game_winner_odd_elements(): assert game_winner(3, [7, 8, 9]) == \\"ALICE\\"","solution":"def game_winner(n, a): Given a list of integers and the rules of the game, determines the winner between Alice and Bob. :param n: int - the number of elements in the list :param a: list of int - the elements of the list :return: str - \\"ALICE\\", \\"BOB\\", or \\"DRAW\\" based on who removes more numbers # Alice removes the first element, Bob removes the second, Alice the third, etc. if n % 2 == 0: return \\"DRAW\\" else: return \\"ALICE\\""},{"question":"from itertools import combinations from typing import List, Tuple def count_divisible_subsequences(N: int, K: int, sequence: List[int]) -> int: Counts the number of distinct subsequences that are divisible by K from the given sequence. Args: N : int : Number of integers in the sequence. K : int : The divisor. sequence : List[int] : The list of integers. Returns: int : Number of distinct subsequences divisible by K. >>> count_divisible_subsequences(3, 3, [3, 6, 9]) 7 >>> count_divisible_subsequences(4, 2, [1, 2, 3, 4]) 7 pass def solve_problem(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Solves the problem for given T test cases. Args: T : int : Number of test cases. test_cases : List[Tuple[Tuple[int, int], List[int]]] : List of test cases, each containing a tuple of (N, K) and the sequence. Returns: List[int] : List of results for each test case. >>> solve_problem(2, [((3, 3), [3, 6, 9]), ((4, 2), [1, 2, 3, 4])]) [7, 7] >>> solve_problem(2, [((3, 3), [3, 6, 9]), ((4, 1), [1, 2, 3, 4])]) [7, 15] pass","solution":"from itertools import combinations def count_divisible_subsequences(N, K, sequence): Counts the number of distinct subsequences that are divisible by K from the given sequence. count = 0 for length in range(1, N + 1): for subsequence in combinations(sequence, length): if sum(subsequence) % K == 0: count += 1 return count def solve_problem(T, test_cases): Solves the problem for given T test cases. results = [] for i in range(T): N, K = test_cases[i][0] sequence = test_cases[i][1] result = count_divisible_subsequences(N, K, sequence) results.append(result) return results"},{"question":"def item_completion_times(stages): Returns the completion times for each stage. Parameters: stages (List[int]): A list of integers representing the time each stage takes in seconds. Returns: List[int]: A list of integers representing the cumulative completion times for each stage. Examples: >>> item_completion_times([2, 3, 5]) [2, 5, 10] >>> item_completion_times([1, 1, 1, 1]) [1, 2, 3, 4]","solution":"def item_completion_times(stages): Returns the completion times for each stage. completion_times = [0] * len(stages) completion_times[0] = stages[0] for i in range(1, len(stages)): completion_times[i] = completion_times[i - 1] + stages[i] return completion_times"},{"question":"from typing import List def can_all_players_reach_target(m: int, n: int, grid: List[str]) -> str: Determine if there exists a sequence of moves such that every player ('P') can reach the target ('T') on an m x n grid. >>> can_all_players_reach_target(4, 5, [\\"P....\\", \\"..X..\\", \\"..XT.\\", \\"P....\\"]) 'YES' >>> can_all_players_reach_target(3, 5, [\\"P..X.\\", \\"XXXXX\\", \\"P..XT\\"]) 'NO' pass def test_multiple_paths_no_obstacles(): assert can_all_players_reach_target(4, 5, [\\"P....\\", \\"..X..\\", \\"..XT.\\", \\"P....\\"]) == \\"YES\\" def test_blocked_path(): assert can_all_players_reach_target(3, 5, [\\"P..X.\\", \\"XXXXX\\", \\"P..XT\\"]) == \\"NO\\" def test_no_players(): assert can_all_players_reach_target(3, 5, [\\".....\\", \\"..XT.\\", \\".....\\"]) == \\"YES\\" def test_single_player_reachable(): assert can_all_players_reach_target(3, 3, [\\"P.X\\", \\"...\\", \\".XT\\"]) == \\"YES\\" def test_single_player_unreachable(): assert can_all_players_reach_target(3, 3, [\\"PXX\\", \\"XXX\\", \\"X.XT\\"]) == \\"NO\\" def test_large_empty_grid(): empty_grid = [\\".\\" * 1000] * 999 + [\\"P\\" + \\".\\" * 998 + \\"T\\"] assert can_all_players_reach_target(1000, 1000, empty_grid) == \\"YES\\" def test_player_next_to_target(): assert can_all_players_reach_target(3, 3, [\\"...\\", \\".PT\\", \\"...\\"]) == \\"YES\\" def test_l_shaped_blocked_path(): assert can_all_players_reach_target(4, 4, [\\"P...\\", \\"XXXX\\", \\"...X\\", \\".T..\\"]) == \\"NO\\"","solution":"from collections import deque def can_all_players_reach_target(m, n, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] target_pos = None player_positions = [] # Identify positions of players and the target for i in range(m): for j in range(n): if grid[i][j] == 'P': player_positions.append((i, j)) elif grid[i][j] == 'T': target_pos = (i, j) def bfs(start): queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == target_pos: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and (grid[nx][ny] == '.' or grid[nx][ny] == 'T'): visited.add((nx, ny)) queue.append((nx, ny)) return False for player_pos in player_positions: if not bfs(player_pos): return \\"NO\\" return \\"YES\\""},{"question":"def arrayTransformation(arr): Transforms the input array based on the rules: - If the number is even, divide the number by 2. - If the number is odd and greater than 10, subtract 5 from the number. - If the number is odd and less than or equal to 10, add 3 to the number. pass def test_arrayTransformation(): assert arrayTransformation([4, 11, 5, 8, 13, 7]) == [2, 6, 8, 4, 8, 10] assert arrayTransformation([]) == [] assert arrayTransformation([2, 8, 10]) == [1, 4, 5] assert arrayTransformation([1, 3, 5, 9]) == [4, 6, 8, 12] assert arrayTransformation([11, 12, 17, 18]) == [6, 6, 12, 9] assert arrayTransformation([7, 24, 13, 6]) == [10, 12, 8, 3] def test_arrayTransformation_all_even(): assert arrayTransformation([2, 4, 6, 8, 10]) == [1, 2, 3, 4, 5] def test_arrayTransformation_all_odd_less_than_10(): assert arrayTransformation([1, 3, 5, 7, 9]) == [4, 6, 8, 10, 12] def test_arrayTransformation_all_odd_greater_than_10(): assert arrayTransformation([11, 13, 15, 17, 19]) == [6, 8, 10, 12, 14]","solution":"def arrayTransformation(arr): Transforms the input array based on the rules: - If the number is even, divide the number by 2. - If the number is odd and greater than 10, subtract 5 from the number. - If the number is odd and less than or equal to 10, add 3 to the number. transformed_array = [] for num in arr: if num % 2 == 0: transformed_array.append(num // 2) elif num > 10: transformed_array.append(num - 5) else: transformed_array.append(num + 3) return transformed_array"},{"question":"def mergeAndSortLists(a, b): Merges two lists a and b in the lexicographically smallest order by taking elements from the front. >>> mergeAndSortLists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeAndSortLists([10, 15, 20], [5, 10, 15]) [5, 10, 10, 15, 15, 20] >>> mergeAndSortLists([2, 2, 2], [2, 2, 2]) [2, 2, 2, 2, 2, 2] >>> mergeAndSortLists([], [1, 2, 3]) [1, 2, 3] >>> mergeAndSortLists([1, 2, 3], []) [1, 2, 3] >>> mergeAndSortLists([999999999], [1000000000]) [999999999, 1000000000]","solution":"def mergeAndSortLists(a, b): Merges two lists a and b in the lexicographically smallest order by taking elements from the front. merged_list = [] i, j = 0, 0 while i < len(a) and j < len(b): if a[i] <= b[j]: merged_list.append(a[i]) i += 1 else: merged_list.append(b[j]) j += 1 merged_list.extend(a[i:]) merged_list.extend(b[j:]) return merged_list"},{"question":"def is_valid_parentheses(s: str) -> str: Determines if the given string of parentheses is valid. >>> is_valid_parentheses(\\"()\\") \\"Valid\\" >>> is_valid_parentheses(\\"([{}])\\") \\"Valid\\" >>> is_valid_parentheses(\\"([)]\\") \\"Invalid\\" pass def validate_parentheses_cases(test_cases: list) -> list: Processes multiple test cases for parentheses validation. >>> validate_parentheses_cases([\\"()\\", \\"([{}])\\", \\"([)]\\"]) [\\"Valid\\", \\"Valid\\", \\"Invalid\\"] >>> validate_parentheses_cases([\\"{[()]}\\", \\"{[(])}\\"]) [\\"Valid\\", \\"Invalid\\"] pass def process_input(input_data: str) -> list: Processes the input string and returns the results for each test case. >>> process_input(\\"3n()n([{}])n([)]\\") [\\"Valid\\", \\"Valid\\", \\"Invalid\\"] >>> process_input(\\"2n{[()]}n{[(])}\\") [\\"Valid\\", \\"Invalid\\"] pass","solution":"def is_valid_parentheses(s): Determines if the given string of parentheses is valid. Args: s (str): The input string containing '()', '[]', '{}'. Returns: str: \\"Valid\\" if the string is valid, otherwise \\"Invalid\\". stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if not stack or stack.pop() != matching_bracket[char]: return \\"Invalid\\" else: return \\"Invalid\\" return \\"Valid\\" if not stack else \\"Invalid\\" def validate_parentheses_cases(test_cases): Processes multiple test cases for parentheses validation. Args: test_cases (list): A list of test case strings. Returns: list: A list of results \\"Valid\\" or \\"Invalid\\" for each test case. results = [is_valid_parentheses(tc) for tc in test_cases] return results def process_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = input_lines[1:T+1] return validate_parentheses_cases(test_cases)"},{"question":"import math def isPerfectSquare(n: int) -> str: Determine if a number is a perfect square. Parameters: n (int): The number to check. Returns: str: \\"Perfect Square\\" if n is a perfect square, \\"Not!!\\" otherwise. >>> isPerfectSquare(25) 'Perfect Square' >>> isPerfectSquare(13) 'Not!!' >>> isPerfectSquare(49) 'Perfect Square' >>> isPerfectSquare(50) 'Not!!' >>> isPerfectSquare(1) 'Perfect Square'","solution":"import math def isPerfectSquare(n): Determine if a number is a perfect square. Parameters: n (int): The number to check. Returns: str: \\"Perfect Square\\" if n is a perfect square, \\"Not!!\\" otherwise. if math.isqrt(n) ** 2 == n: return \\"Perfect Square\\" else: return \\"Not!!\\""},{"question":"from typing import List, Tuple def largest_connected_component(n: int, points: List[Tuple[int, int]]) -> int: Alice is creating a drawing by connecting points on an X-Y plane. She has n points, and each point is positioned at distinct coordinates (xi, yi). Alice wants to draw lines vertically or horizontally to connect these points. Specifically, she can draw a line connecting two points if they share the same x or y coordinate. Alice is interested in finding the largest connected component of points when these lines are drawn. A connected component here refers to a set of points where there is a path (following the lines) between any two points in the set. Args: n: int - number of points points: List[Tuple[int, int]] - list of coordinates of the points Returns: int - size of the largest connected component Examples: >>> largest_connected_component(5, [(1, 2), (1, 3), (2, 3), (4, 5), (5, 5)]) 3 >>> largest_connected_component(4, [(1, 1), (2, 2), (3, 3), (4, 4)]) 1 >>> largest_connected_component(6, [(1, 2), (3, 2), (1, 4), (2, 4), (5, 6), (5, 7)]) 4","solution":"def largest_connected_component(n, points): from collections import defaultdict, deque # Create adjacency lists for both x and y coordinates x_adj = defaultdict(list) y_adj = defaultdict(list) for x, y in points: x_adj[x].append((x, y)) y_adj[y].append((x, y)) visited = set() def bfs(start): queue = deque([start]) visited.add(start) count = 0 while queue: x, y = queue.popleft() count += 1 for nx, ny in x_adj[x]: if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) for nx, ny in y_adj[y]: if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return count max_size = 0 for point in points: if point not in visited: max_size = max(max_size, bfs(point)) return max_size"},{"question":"def sumNumberStrings(strings: list[str]) -> int: Returns the sum of numeric strings in the list, ignoring non-numeric strings. >>> sumNumberStrings([\\"123\\", \\"456\\", \\"abc\\", \\"789\\"]) 1368 >>> sumNumberStrings([\\"100\\", \\"200\\", \\"invalid\\", \\"300\\"]) 600 >>> sumNumberStrings([\\"42\\", \\"-5\\", \\"7.5\\", \\"0\\", \\"null\\"]) 37 from solution import sumNumberStrings def test_sumNumberStrings_with_mixed_strings(): assert sumNumberStrings([\\"123\\", \\"456\\", \\"abc\\", \\"789\\"]) == 1368 def test_sumNumberStrings_with_non_numeric(): assert sumNumberStrings([\\"100\\", \\"200\\", \\"invalid\\", \\"300\\"]) == 600 def test_sumNumberStrings_with_special_characters(): assert sumNumberStrings([\\"42\\", \\"-5\\", \\"7.5\\", \\"0\\", \\"null\\"]) == 37 # Note: \\"42\\" + (-\\"5\\") + \\"0\\" def test_sumNumberStrings_all_numeric_strings(): assert sumNumberStrings([\\"10\\", \\"20\\", \\"30\\"]) == 60 def test_sumNumberStrings_with_empty_list(): assert sumNumberStrings([]) == 0 def test_sumNumberStrings_all_invalid_strings(): assert sumNumberStrings([\\"abc\\", \\"def\\", \\"ghi\\"]) == 0 def test_sumNumberStrings_with_positive_and_negative_numbers(): assert sumNumberStrings([\\"123\\", \\"-456\\", \\"789\\"]) == 456 def test_sumNumberStrings_with_non_numeric_mixed(): assert sumNumberStrings([\\"-10\\", \\"20\\", \\"abc\\", \\"-15\\"]) == -5 def test_sumNumberStrings_with_large_numbers(): assert sumNumberStrings([\\"1000000\\", \\"2000000\\"]) == 3000000","solution":"def sumNumberStrings(strings): Returns the sum of numeric strings in the list, ignoring non-numeric strings. total_sum = 0 for s in strings: if s.isdigit() or (s[1:].isdigit() and (s[0] == '-' or s[0] == '+')): # Handle negative or positive numbers represented as strings total_sum += int(s) return total_sum"},{"question":"def manage_inventory(n, m, initial_stock, operations): Manages bookstore inventory. Updates and queries stock based on operations. Args: n: int: Number of books in the initial inventory. m: int: Number of operations to be performed. initial_stock: list of tuples: List containing ISBN numbers and their respective stock quantities. operations: list of str: List of operations to be performed on the inventory. Returns: list of int: Results of query operations indicating the current quantity of books in stock. Examples: >>> manage_inventory(4, 3, [('9780307938', 10), ('9780374533', 5), ('9780143124', 2), ('9780316769', 8)], ['update 9780307938 5', 'query 9780307938', 'query 9780143124']) [15, 2] >>> manage_inventory(3, 3, [('9780470059', 15), ('9781430225', 7), ('9781119267', 3)], ['update 9781119267 10', 'query 9781119267', 'query 9780470059']) [13, 15]","solution":"def manage_inventory(n, m, initial_stock, operations): # Convert initial stock into a dictionary for quick lookup inventory = {} for isbn, qty in initial_stock: inventory[isbn] = qty # Process the operations results = [] for operation in operations: parts = operation.split() if parts[0] == 'update': isbn = parts[1] qty = int(parts[2]) if isbn in inventory: inventory[isbn] += qty else: inventory[isbn] = qty elif parts[0] == 'query': isbn = parts[1] results.append(inventory.get(isbn, 0)) return results"},{"question":"def count_unique_user_ids(test_cases): Given a list of test cases, each with multiple user IDs, returns a list of counts of unique user IDs for each test case. Args: test_cases (List[Dict]): A list of dictionaries, each with an integer 'n' representing the number of user IDs and a list 'user_ids' containing the user IDs. Returns: List[int]: A list of integers representing the count of unique user IDs for each test case. Example: >>> test_cases = [{'n': 5, 'user_ids': ['alice', 'bob', 'alice', 'charlie', 'bob']}, {'n': 3, 'user_ids': ['admin', 'user1', 'admin']}] >>> count_unique_user_ids(test_cases) [3, 2] pass def parse_input(input_data): Parses the input data and returns a list of test cases. Args: input_data (str): Input data as a string Returns: List[Dict]: A list of dictionaries, each with an integer 'n' representing the number of user IDs and a list 'user_ids' containing the user IDs. Example: >>> input_data = \\"2n5nalicenbobnalicencharlienbobn3nadminnuser1nadmin\\" >>> parse_input(input_data) [{'n': 5, 'user_ids': ['alice', 'bob', 'alice', 'charlie', 'bob']}, {'n': 3, 'user_ids': ['admin', 'user1', 'admin']}] pass # Unit tests def test_parse_input(): input_data = \\"2n5nalicenbobnalicencharlienbobn3nadminnuser1nadmin\\" expected = [ {'n': 5, 'user_ids': ['alice', 'bob', 'alice', 'charlie', 'bob']}, {'n': 3, 'user_ids': ['admin', 'user1', 'admin']} ] assert parse_input(input_data) == expected def test_count_unique_user_ids(): test_cases = [ {'n': 5, 'user_ids': ['alice', 'bob', 'alice', 'charlie', 'bob']}, {'n': 3, 'user_ids': ['admin', 'user1', 'admin']} ] expected = [3, 2] assert count_unique_user_ids(test_cases) == expected def test_large_number_of_user_ids(): user_ids = [\\"user\\" + str(i) for i in range(100000)] test_cases = [{'n': 100000, 'user_ids': user_ids}] expected = [100000] assert count_unique_user_ids(test_cases) == expected def test_no_user_ids(): test_cases = [{'n': 0, 'user_ids': []}] expected = [0] assert count_unique_user_ids(test_cases) == expected def test_single_user_id(): test_cases = [{'n': 1, 'user_ids': ['singleuser']}] expected = [1] assert count_unique_user_ids(test_cases) == expected","solution":"def count_unique_user_ids(test_cases): Given a list of test cases, each with multiple user IDs, returns a list of counts of unique user IDs for each test case. results = [] for case in test_cases: user_ids = case['user_ids'] unique_users = set(user_ids) results.append(len(unique_users)) return results # Utility function to parse the input and create the test cases def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) user_ids = lines[index + 1: index + 1 + n] test_cases.append({'n': n, 'user_ids': user_ids}) index += n + 1 return test_cases"},{"question":"from typing import List def tree_diameter(tree: List[List[int]]) -> int: Given a tree represented as an adjacency list, find the diameter of the tree. The diameter of a tree is defined as the length of the longest path between any two nodes in the tree. The length of a path is represented by the number of edges it contains. Args: tree: List of lists, where tree[i] contains the nodes (0-indexed) that are connected to node i. Returns: An integer representing the diameter of the tree. Examples: >>> tree_diameter([[1, 2], [0, 3, 4], [0, 5], [1], [1], [2]]) 4 >>> tree_diameter([[1], [0, 2], [1, 3], [2]]) 3 pass # Unit tests def test_single_node_tree(): assert tree_diameter([[]]) == 0 def test_two_node_tree(): assert tree_diameter([[1], [0]]) == 1 def test_three_node_tree(): assert tree_diameter([[1, 2], [0], [0]]) == 2 def test_balanced_tree(): tree = [[1, 2], [0, 3, 4], [0, 5, 6], [1], [1], [2], [2]] assert tree_diameter(tree) == 4 def test_unbalanced_tree(): tree = [[1], [0, 2], [1, 3], [2]] assert tree_diameter(tree) == 3 def test_complex_tree(): tree = [[1, 2], [0, 3, 4], [0, 5], [1], [1], [2]] assert tree_diameter(tree) == 4","solution":"from typing import List def tree_diameter(tree: List[List[int]]) -> int: Returns the diameter (longest path) of a tree represented as an adjacency list. The diameter is defined as the number of edges in the longest path between any two nodes. def bfs(start_node): visited = [-1] * len(tree) visited[start_node] = 0 queue = [start_node] max_distance = 0 farthest_node = start_node while queue: node = queue.pop(0) for neighbor in tree[node]: if visited[neighbor] == -1: visited[neighbor] = visited[node] + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance # Perform BFS from an arbitrary node (0) to find the farthest node from it farthest_node, _ = bfs(0) # Perform BFS again from the farthest node found to determine the diameter of the tree _, diameter = bfs(farthest_node) return diameter"},{"question":"import math from functools import reduce def min_possible_sum(n: int, a: List[int]) -> int: Determines the minimum possible sum of the array after performing the specified operation any number of times. >>> min_possible_sum(3, [4, 8, 12]) == 12 >>> min_possible_sum(5, [10, 15, 20, 25, 30]) == 25 >>> min_possible_sum(6, [1, 1, 1, 1, 1, 1]) == 6 >>> min_possible_sum(4, [7, 14, 21, 28]) == 28 >>> min_possible_sum(2, [5, 10]) == 10 >>> min_possible_sum(3, [6, 9, 12]) == 9 >>> min_possible_sum(3, [40, 80, 120]) == 120","solution":"import math from functools import reduce def min_possible_sum(n, a): Determines the minimum possible sum of the array after performing the specified operation any number of times. def find_gcd_of_array(array): return reduce(math.gcd, array) # Find gcd of all elements in the array gcd_all = find_gcd_of_array(a) # The minimum sum is the gcd of the entire array multiplied by the number of elements min_sum = gcd_all * n return min_sum # Example usage # For the given example 3 [4, 8, 12], it should return 12 print(min_possible_sum(3, [4, 8, 12]))"},{"question":"def is_palindrome(s: str) -> str: Determines whether the given string is a palindrome, ignoring non-alphabetic characters and case differences. Args: s (str): Input string Returns: str: \\"YES\\" if the string is a palindrome, otherwise \\"NO\\" Examples: >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") \\"YES\\" >>> is_palindrome(\\"No lemon, no melon\\") \\"YES\\" >>> is_palindrome(\\"Hello, World!\\") \\"NO\\" >>> is_palindrome(\\"Madam In Eden, I'm Adam.\\") \\"YES\\" >>> is_palindrome(\\"Was it a car or a cat I saw?\\") \\"YES\\" >>> is_palindrome(\\"This is not a palindrome\\") \\"NO\\" pass def process_input(input_strings: List[str]) -> List[str]: Processes multiple input strings and returns the results for each string except the one containing 'END'. Args: input_strings (List[str]): The list of input strings Returns: List[str]: List containing \\"YES\\" or \\"NO\\" based on whether the string is a palindrome Examples: >>> process_input([\\"A man, a plan, a canal, Panama!\\", \\"No lemon, no melon\\", \\"Hello, World!\\", \\"END\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_input([\\"Madam In Eden, I'm Adam.\\", \\"Was it a car or a cat I saw?\\", \\"This is not a palindrome\\", \\"END\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_input([\\"Racecar\\", \\"END\\"]) [\\"YES\\"] pass","solution":"def is_palindrome(s): Returns \\"YES\\" if the cleaned-up version of s is a palindrome, otherwise returns \\"NO\\". Only letters are considered and the comparison is case-insensitive. cleaned_s = ''.join([char.lower() for char in s if char.isalpha()]) return \\"YES\\" if cleaned_s == cleaned_s[::-1] else \\"NO\\" def process_input(input_strings): Processes multiple input strings and returns the results for each string except the one containing 'END'. results = [] for s in input_strings: if s == \\"END\\": break results.append(is_palindrome(s)) return results"},{"question":"def maxCardSum(cards: List[int]) -> int: Returns the maximum possible sum from the list of cards, either adding positive cards or ignoring negative cards. >>> maxCardSum([4, -1, 2, -3, 5, -2]) 11 >>> maxCardSum([1, 2, 3, 4, 5]) 15 >>> maxCardSum([-1, -2, -3, -4, -5]) 0","solution":"def maxCardSum(cards): Returns the maximum possible sum from the list of cards, either adding positive cards or ignoring negative cards. max_sum = 0 for card in cards: if card > 0: max_sum += card return max_sum"},{"question":"def are_all_digits_unique(n: int) -> str: Determine if all digits in the integer N are unique. >>> are_all_digits_unique(123456789) 'Unique' >>> are_all_digits_unique(112233) 'Not Unique'","solution":"def are_all_digits_unique(n): Returns 'Unique' if all digits in n are unique, otherwise returns 'Not Unique'. n_str = str(n) digits_set = set(n_str) if len(digits_set) == len(n_str): return \\"Unique\\" else: return \\"Not Unique\\""},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverseInGroups(head, k): Reverse the linked list in groups of size K. Args: head (ListNode): The head of the singly linked list. k (int): The size of the groups to reverse the list. Returns: ListNode: The head of the modified linked list. Example: >>> head = create_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) >>> K = 3 >>> reversed_head = reverseInGroups(head, K) >>> print_linked_list(reversed_head) [3, 2, 1, 6, 5, 4, 7, 8] >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> K = 2 >>> reversed_head = reverseInGroups(head, K) >>> print_linked_list(reversed_head) [2, 1, 4, 3, 5] pass def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def print_linked_list(head): result = [] while head: result.append(head.value) head = head.next return result def test_reverse_in_groups_example_1(): head = create_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) k = 3 new_head = reverseInGroups(head, k) assert print_linked_list(new_head) == [3, 2, 1, 6, 5, 4, 7, 8] def test_reverse_in_groups_example_2(): head = create_linked_list([1, 2, 3, 4, 5]) k = 2 new_head = reverseInGroups(head, k) assert print_linked_list(new_head) == [2, 1, 4, 3, 5] def test_reverse_in_groups_single_node(): head = create_linked_list([1]) k = 1 new_head = reverseInGroups(head, k) assert print_linked_list(new_head) == [1] def test_reverse_in_groups_with_k_equals_n(): head = create_linked_list([1, 2, 3, 4, 5]) k = 5 new_head = reverseInGroups(head, k) assert print_linked_list(new_head) == [5, 4, 3, 2, 1] def test_reverse_in_groups_with_k_greater_than_n(): head = create_linked_list([1, 2, 3]) k = 5 new_head = reverseInGroups(head, k) assert print_linked_list(new_head) == [1, 2, 3] def test_reverse_in_groups_with_empty_list(): head = create_linked_list([]) k = 3 new_head = reverseInGroups(head, k) assert print_linked_list(new_head) == []","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverseInGroups(head, k): if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head current = dummy nex = dummy pre = dummy count = 0 while current.next is not None: current = current.next count += 1 while count >= k: current = pre.next nex = current.next for _ in range(1, k): current.next = nex.next nex.next = pre.next pre.next = nex nex = current.next pre = current count -= k return dummy.next def print_linked_list(head): result = [] while head: result.append(head.value) head = head.next return result"},{"question":"from typing import List import math from functools import reduce def min_max_element(arr: List[int]) -> int: Given an integer array \`arr\`, find the minimum possible value of the maximum element in the array after performing any number of operations, where in each operation two elements in the array are replaced by their gcd (greatest common divisor). >>> min_max_element([8, 4, 12, 16, 2, 10]) 2 >>> min_max_element([24, 18, 15, 30, 21]) 3 import pytest def test_single_element(): assert min_max_element([5]) == 5 def test_same_elements(): assert min_max_element([7, 7, 7]) == 7 def test_gcd_entire_array(): assert min_max_element([8, 4, 12, 16, 2, 10]) == 2 assert min_max_element([24, 18, 15, 30, 21]) == 3 def test_large_numbers(): assert min_max_element([1000000000, 500000000, 250000000]) == 250000000 def test_mixed_numbers(): assert min_max_element([35, 10, 20, 25]) == 5 def test_primes(): assert min_max_element([17, 31, 23]) == 1","solution":"import math from functools import reduce def min_max_element(arr): Returns the minimum possible value of the maximum element in the array after performing any number of operations, where in each operation two elements in the array are replaced by their gcd. return reduce(math.gcd, arr)"},{"question":"def minSubArrayLen(target: int, arr: List[int]) -> int: Return the minimum length of a subarray such that its sum is at least the target value. If no such subarray exists, return 0. >>> minSubArrayLen(7, [2, 3, 1, 2, 4, 3]) 2 >>> minSubArrayLen(15, [1, 2, 3, 4, 5]) 5","solution":"def minSubArrayLen(target, arr): Returns the minimum length of a subarray such that its sum is at least target. If no such subarray exists, returns 0. n = len(arr) left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += arr[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def smallest_lexicographical_rotation(sequence): Given a sequence of integers, returns the lexicographically smallest sequence obtainable by rotating the sequence. >>> smallest_lexicographical_rotation([3, 1, 2, 4, 5]) [1, 2, 4, 5, 3] >>> smallest_lexicographical_rotation([1]) [1] >>> smallest_lexicographical_rotation([2, 2, 2, 2]) [2, 2, 2, 2] >>> smallest_lexicographical_rotation([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> smallest_lexicographical_rotation([4, 4, 2, 3, 4]) [2, 3, 4, 4, 4]","solution":"def smallest_lexicographical_rotation(sequence): Given a sequence of integers, returns the lexicographically smallest sequence obtainable by rotating the sequence. n = len(sequence) double_sequence = sequence + sequence # Concatenate sequence to itself min_rotation = sequence # Assume the initial sequence is the smallest for i in range(1, n): current_rotation = double_sequence[i:i + n] if current_rotation < min_rotation: min_rotation = current_rotation return min_rotation"},{"question":"from typing import List def groupAnagrams(strs: List[str]) -> List[List[str]]: Write a function \`groupAnagrams\` that takes a list of strings and returns a list of lists, where each inner list contains words that are anagrams of each other. The inner lists should be sorted in lexicographical order, and the outer list should be ordered by the first appearance of an anagram group in the input list. Parameters: strs (List[str]): A list of strings, each containing only lower-case letters. Returns: List[List[str]]: A list of lists containing grouped anagrams. Example: >>> groupAnagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]","solution":"from collections import defaultdict def groupAnagrams(strs): Group anagrams from a list of strings. Arguments: strs -- list of strings Returns: list of lists, where each inner list contains words that are anagrams of each other. anagrams = defaultdict(list) # Dictionary to hold sorted string as key and anagram list as value for word in strs: sorted_word = ''.join(sorted(word)) # Get a sorted string as key anagrams[sorted_word].append(word) # Creating final result where inner lists are sorted and ordered by first appearance result = [sorted(anagrams_group) for anagrams_group in anagrams.values()] return result"},{"question":"class UnionFind: def __init__(self, size): self.root = list(range(size)) self.rank = [1] * size self.count = size def find(self, x): if self.root[x] != x: self.root[x] = self.find(self.root[x]) return self.root[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.root[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.root[rootX] = rootY else: self.root[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def get_count(self): return self.count def tree_operations(n: int, operations: List[List[int]]) -> List[int]: Perform a series of operations on the tree and return the number of connected components after each query operation. Args: n (int): The initial number of nodes. operations (List[List[int]]): List of operations to be performed. Each operation is of the form [1, x, y] or [2]. Returns: List[int]: The results of the query operations which output the number of connected components. Examples: >>> tree_operations(5, [[1, 1, 2], [2], [1, 2, 3], [2], [1, 4, 5]]) [4, 3] >>> tree_operations(4, [[2], [1, 1, 3], [2], [1, 2, 4]]) [4, 3] import unittest class TestTreeOperations(unittest.TestCase): def test_tree_operations_example1(self): n = 5 operations = [ [1, 1, 2], [2], [1, 2, 3], [2], [1, 4, 5] ] self.assertEqual(tree_operations(n, operations), [4, 3]) def test_tree_operations_example2(self): n = 4 operations = [ [2], [1, 1, 3], [2], [1, 2, 4] ] self.assertEqual(tree_operations(n, operations), [4, 3]) def test_tree_operations_no_connections(self): n = 3 operations = [ [2], [2], [2] ] self.assertEqual(tree_operations(n, operations), [3, 3, 3]) def test_tree_operations_all_connected(self): n = 3 operations = [ [1, 1, 2], [1, 2, 3], [2] ] self.assertEqual(tree_operations(n, operations), [1]) def test_tree_operations_partial_connections(self): n = 6 operations = [ [1, 1, 2], [1, 3, 4], [2], [1, 5, 6], [2] ] self.assertEqual(tree_operations(n, operations), [4, 3]) if __name__ == \\"__main__\\": unittest.main()","solution":"class UnionFind: def __init__(self, size): self.root = list(range(size)) self.rank = [1] * size self.count = size def find(self, x): if self.root[x] != x: self.root[x] = self.find(self.root[x]) return self.root[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.root[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.root[rootX] = rootY else: self.root[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def get_count(self): return self.count def tree_operations(n, operations): uf = UnionFind(n) result = [] for operation in operations: if operation[0] == 1: _, x, y = operation uf.union(x - 1, y - 1) elif operation[0] == 2: result.append(uf.get_count()) return result"},{"question":"def min_operations(A: str, B: str) -> int: Returns the minimum number of operations required to transform string A into string B. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"abc\\", \\"abcd\\") 1 >>> min_operations(\\"abcd\\", \\"abc\\") 1 >>> min_operations(\\"abc\\", \\"adc\\") 1 >>> min_operations(\\"intention\\", \\"execution\\") 5","solution":"def min_operations(A, B): Returns the minimum number of operations required to transform string A into string B. m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Min. operations = j (all insertions) elif j == 0: dp[i][j] = i # Min. operations = i (all deletions) elif A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1])# Replace return dp[m][n]"},{"question":"def calculate_final_scores(n, m, points, submissions): Determine the final score of each participant after considering all their submissions. :param n: int - The number of participants. :param m: int - The number of problems. :param points: List[int] - The points awarded for solving each problem. :param submissions: List[Tuple[int, int]] - List of submissions where each tuple (p, q) indicates participant p solved problem q. :return: List[int] - The final scores of all participants. Example: >>> calculate_final_scores(5, 4, [3, 6, 2, 7], [(1, 2), (2, 1), (1, 3), (3, 2), (4, 4), (2, 4)]) [8, 10, 6, 7, 0] >>> calculate_final_scores(3, 3, [5, 10, 20], [(1, 1), (1, 3), (2, 2), (3, 1)]) [25, 10, 5] from solution import calculate_final_scores def test_example_case_1(): assert calculate_final_scores(5, 4, [3, 6, 2, 7], [(1, 2), (2, 1), (1, 3), (3, 2), (4, 4), (2, 4)]) == [8, 10, 6, 7, 0] def test_example_case_2(): assert calculate_final_scores(3, 3, [5, 10, 20], [(1, 1), (1, 3), (2, 2), (3, 1)]) == [25, 10, 5] def test_no_submissions(): assert calculate_final_scores(4, 3, [5, 10, 15], []) == [0, 0, 0, 0] def test_all_submissions_to_one_participant(): assert calculate_final_scores(4, 3, [5, 10, 15], [(1, 1), (1, 2), (1, 3)]) == [30, 0, 0, 0] def test_single_submission_each(): assert calculate_final_scores(3, 3, [10, 20, 30], [(1, 1), (2, 2), (3, 3)]) == [10, 20, 30] def test_multiple_submissions_to_same_problem(): assert calculate_final_scores(2, 2, [7, 9], [(1, 1), (1, 1), (2, 2), (2, 2)]) == [14, 18]","solution":"def calculate_final_scores(n, m, points, submissions): # Initialize the scores of all participants to zero. scores = [0] * n # Process each submission. for p, q in submissions: # Add the points of the solved problem to the participant's score. scores[p - 1] += points[q - 1] return scores # Example usage: # n, m = 5, 4 # points = [3, 6, 2, 7] # submissions = [(1, 2), (2, 1), (1, 3), (3, 2), (4, 4), (2, 4)] # print(calculate_final_scores(n, m, points, submissions)) # Output: [8, 10, 6, 7, 0]"},{"question":"def min_coins(denominations, price): Determine the minimum number of coins needed to buy a snack at a given price. Args: denominations (List[int]): Available coin denominations. price (int): Price of the snack. Returns: int: Minimum number of coins needed or -1 if not possible. >>> min_coins([1, 2, 5, 10], 6) 2 >>> min_coins([3, 6, 9], 4) -1 >>> min_coins([1, 6, 9, 12, 15], 16) 2 pass def solve_vending_machine(T, test_cases): Solve the vending machine problem for multiple test cases. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int], int]]): Each test case is a tuple where: - the first element is the number of coin denominations, - the second element is a list of coin denominations, - the third element is the price of the snack. Returns: List[int]: Results for each test case representing the minimum number of coins needed or -1 if not possible. >>> T = 3 >>> test_cases = [ ... (4, [1, 2, 5, 10], 6), ... (3, [3, 6, 9], 4), ... (5, [1, 6, 9, 12, 15], 16) ... ] >>> solve_vending_machine(T, test_cases) [2, -1, 2] >>> T = 2 >>> test_cases = [ ... (3, [1, 2, 5], 11), ... (2, [5, 10], 0) ... ] >>> solve_vending_machine(T, test_cases) [3, 0] pass","solution":"def min_coins(denominations, price): # Maximum value to simulate INF in this scenario INF = float('inf') dp = [INF] * (price + 1) dp[0] = 0 for coin in denominations: for x in range(coin, price + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[price] if dp[price] != INF else -1 def solve_vending_machine(T, test_cases): results = [] for i in range(T): M = test_cases[i][0] coins = test_cases[i][1] price = test_cases[i][2] result = min_coins(coins, price) results.append(result) return results"},{"question":"def perform_operations_and_sum_rows(n: int, m: int, grid: List[List[int]], operations: List[Tuple[int, int]]) -> List[int]: Given a grid of size n x n filled with integers, perform m operations of swapping two rows of the grid. After all operations are performed, find the sum of the integers in each row. Args: n: The size of the grid. m: The number of operations. grid: A list of lists containing the grid of integers. operations: A list of tuples where each tuple contains two integers r1 and r2 indicating that you need to swap row r1 with row r2. Returns: A list of integers, each representing the sum of the integers in each row after all operations are performed. Example: >>> perform_operations_and_sum_rows(3, 2, [[3, 1, 4], [2, 5, 6], [7, 8, 9]], [(1, 3), (2, 3)]) [24, 8, 13] >>> perform_operations_and_sum_rows(2, 1, [[1, 2], [3, 4]], [(1, 2)]) [7, 3] # Implementation here from typing import List, Tuple def test_example_case(): n, m = 3, 2 grid = [ [3, 1, 4], [2, 5, 6], [7, 8, 9] ] operations = [ (1, 3), (2, 3) ] result = perform_operations_and_sum_rows(n, m, grid, operations) expected = [24, 8, 13] assert result == expected def test_no_operations(): n, m = 3, 0 grid = [ [3, 1, 4], [2, 5, 6], [7, 8, 9] ] operations = [] result = perform_operations_and_sum_rows(n, m, grid, operations) expected = [8, 13, 24] assert result == expected def test_single_operation(): n, m = 2, 1 grid = [ [1, 2], [3, 4] ] operations = [ (1, 2) ] result = perform_operations_and_sum_rows(n, m, grid, operations) expected = [7, 3] assert result == expected def test_same_rows_swap(): n, m = 3, 2 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operations = [ (1, 1), (2, 2) ] result = perform_operations_and_sum_rows(n, m, grid, operations) expected = [6, 15, 24] assert result == expected def test_rows_swap_back_to_original(): n, m = 2, 2 grid = [ [1, 2, 3], [4, 5, 6] ] operations = [ (1, 2), (1, 2) ] result = perform_operations_and_sum_rows(n, m, grid, operations) expected = [6, 15] assert result == expected","solution":"def perform_operations_and_sum_rows(n, m, grid, operations): for op in operations: r1, r2 = op # Perform the swap. Note: r1 and r2 are 1-indexed. grid[r1-1], grid[r2-1] = grid[r2-1], grid[r1-1] # Compute the sum of each row row_sums = [sum(row) for row in grid] return row_sums"},{"question":"def summaryRanges(nums): Given a sorted array of unique integers, returns a list of summary ranges. >>> summaryRanges([0, 1, 2, 4, 5, 7]) [\\"0->2\\", \\"4->5\\", \\"7\\"] >>> summaryRanges([2, 3, 5, 6, 9]) [\\"2->3\\", \\"5->6\\", \\"9\\"] >>> summaryRanges([]) [] >>> summaryRanges(\\"not an array\\") TypeError: Input must be a list of integers pass import pytest def test_summary_ranges_consecutive_numbers(): assert summaryRanges([0, 1, 2, 4, 5, 7]) == [\\"0->2\\", \\"4->5\\", \\"7\\"] def test_summary_ranges_mixed_ranges(): assert summaryRanges([2, 3, 5, 6, 9]) == [\\"2->3\\", \\"5->6\\", \\"9\\"] def test_summary_ranges_single_element(): assert summaryRanges([5]) == [\\"5\\"] def test_summary_ranges_empty_list(): assert summaryRanges([]) == [] def test_summary_ranges_invalid_input(): with pytest.raises(TypeError): summaryRanges(\\"not an array\\") def test_summary_ranges_none_input(): with pytest.raises(TypeError): summaryRanges(None) def test_summary_ranges_non_integer_elements(): with pytest.raises(TypeError): summaryRanges([3, 4, \\"five\\", 6]) def test_summary_ranges_consecutive_negative_numbers(): assert summaryRanges([-3, -2, -1, 1, 2, 3]) == [\\"-3->-1\\", \\"1->3\\"] def test_summary_ranges_multiple_discrete_elements(): assert summaryRanges([1, 3, 7, 8, 10]) == [\\"1\\", \\"3\\", \\"7->8\\", \\"10\\"]","solution":"def summaryRanges(nums): Given a sorted array of unique integers, returns a list of summary ranges. if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise TypeError(\\"Input must be a list of integers\\") ranges = [] if not nums: return ranges start = nums[0] for i in range(1, len(nums)): if nums[i] != nums[i - 1] + 1: if start == nums[i - 1]: ranges.append(str(start)) else: ranges.append(f\\"{start}->{nums[i - 1]}\\") start = nums[i] if start == nums[-1]: ranges.append(str(start)) else: ranges.append(f\\"{start}->{nums[-1]}\\") return ranges"},{"question":"def calculate_min_running_distance(n: int, m: int, subpaths: List[Tuple[int, int]]) -> int: Calculate the minimum total running distance to cover all checkpoints on the track. >>> calculate_min_running_distance(10, 3, [(1, 5), (6, 8), (9, 10)]) 10 >>> calculate_min_running_distance(7, 2, [(1, 4), (5, 7)]) 7 >>> calculate_min_running_distance(8, 4, [(1, 2), (3, 4), (5, 6), (7, 8)]) 8 from typing import List, Tuple def test_minimum_running_distance_example1(): assert calculate_min_running_distance(10, 3, [(1, 5), (6, 8), (9, 10)]) == 10 def test_minimum_running_distance_example2(): assert calculate_min_running_distance(7, 2, [(1, 4), (5, 7)]) == 7 def test_minimum_running_distance_example3(): assert calculate_min_running_distance(8, 4, [(1, 2), (3, 4), (5, 6), (7, 8)]) == 8 def test_single_subpath(): assert calculate_min_running_distance(5, 1, [(1, 5)]) == 5 def test_all_checkpoints_single_subpath(): assert calculate_min_running_distance(5, 1, [(3, 5)]) == 3 def test_edge_case_minimum_checkpoints(): assert calculate_min_running_distance(3, 1, [(1, 3)]) == 3 def test_all_checkpoints_multiple_subpaths(): assert calculate_min_running_distance(5, 2, [(1, 2), (3, 5)]) == 5","solution":"def calculate_min_running_distance(n, m, subpaths): total_distance = 0 for start, end in subpaths: total_distance += end - start + 1 return total_distance # Example usage: # n = 10 # m = 3 # subpaths = [(1, 5), (6, 8), (9, 10)] # print(calculate_min_running_distance(n, m, subpaths)) # Output: 10"},{"question":"def min_difference(n: int, values: List[int]) -> int: Returns the minimum possible absolute difference between the total values of the two groups after the coins have been distributed. >>> min_difference(4, [1, 2, 3, 4]) 0 >>> min_difference(3, [2, 3, 5]) 0 >>> min_difference(5, [7, 1, 3, 9, 5]) 1","solution":"def min_difference(n, values): Returns the minimum possible absolute difference between the total values of the two groups after the coins have been distributed. total_sum = sum(values) possible_sums = {0} for value in values: new_sums = set() for s in possible_sums: new_sums.add(s + value) possible_sums.update(new_sums) min_diff = float('inf') for s in possible_sums: current_diff = abs(total_sum - 2 * s) if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def sum_of_smallest_k_elements(arr: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Calculate the sum of the minimum k elements in the subarray for each query. >>> arr = [4, 2, 5, 1, 6, 7, 3] >>> queries = [(1, 3, 2), (4, 5, 1), (2, 7, 3), (1, 7, 4)] >>> sum_of_smallest_k_elements(arr, queries) [6, 1, 6, 10] >>> arr = [5, 4, 3, 2, 1] >>> queries = [(2, 4, 5)] >>> sum_of_smallest_k_elements(arr, queries) [9] # Implement the function here","solution":"def sum_of_smallest_k_elements(arr, queries): results = [] for li, ri, k in queries: subarray = arr[li - 1:ri] subarray_sorted = sorted(subarray) results.append(sum(subarray_sorted[:k])) return results # Example usage n, q = 7, 4 arr = [4, 2, 5, 1, 6, 7, 3] queries = [(1, 3, 2), (4, 5, 1), (2, 7, 3), (1, 7, 4)] print(sum_of_smallest_k_elements(arr, queries)) # Output should be [6, 1, 6, 10]"},{"question":"def two_sum_exists(n: int, array: List[int], target: int) -> str: Determines if there are two distinct numbers in the array that add up to the target value. >>> two_sum_exists(4, [1, 2, 3, 4], 5) == \\"YES\\" >>> two_sum_exists(4, [1, 2, 3, 4], 8) == \\"NO\\" >>> two_sum_exists(5, [-1, 0, 3, 7, 10], 9) == \\"YES\\" >>> two_sum_exists(5, [-1, 0, 3, 7, 10], -2) == \\"NO\\" >>> two_sum_exists(2, [1, 2], 3) == \\"YES\\" >>> two_sum_exists(2, [1, 2], 4) == \\"NO\\" >>> two_sum_exists(5, [1000000000, 2000000000, -1000000000, -2000000000, 0], 0) == \\"YES\\" >>> two_sum_exists(5, [1000000000, 2000000000, -1000000000, -2000000000, 0], 1000000000) == \\"YES\\" >>> two_sum_exists(4, [1, 1, 1, 1], 2) == \\"YES\\" >>> two_sum_exists(4, [1, 1, 1, 1], 3) == \\"NO\\"","solution":"def two_sum_exists(n, array, target): Determines if there are two distinct numbers in the array that add up to the target value. :param n: Integer, number of elements in the array :param array: List of integers representing the array elements :param target: Integer, the target value :return: \\"YES\\" if two distinct elements add up to the target value, otherwise \\"NO\\" seen = set() for num in array: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def longest_subarray_with_k_distinct(n: int, nums: List[int], k: int) -> int: Returns the length of the longest continuous subarray that contains at most k distinct integers. >>> longest_subarray_with_k_distinct(7, [1, 2, 1, 2, 3, 3, 4], 2) == 4 >>> longest_subarray_with_k_distinct(5, [1, 1, 1, 1, 1], 3) == 5 >>> longest_subarray_with_k_distinct(6, [1, 2, 3, 4, 5, 6], 1) == 1","solution":"from collections import defaultdict def longest_subarray_with_k_distinct(n, nums, k): Returns the length of the longest continuous subarray that contains at most k distinct integers. Parameters: n (int): Length of the array. nums (List[int]): The elements of the array. k (int): The maximum number of distinct integers allowed in the subarray. Returns: int: Length of the longest subarray that contains at most k distinct integers. left = 0 longest = 0 count = defaultdict(int) for right in range(n): count[nums[right]] += 1 while len(count) > k: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def minimum_total_cost(n, a, b, c): Given the number of participants and the cost of each type of medal (gold, silver, bronze), return the minimum total cost to purchase the medals for all top n participants. Parameters: n (int): The number of participants. a (int): The cost of each gold medal. b (int): The cost of each silver medal. c (int): The cost of each bronze medal. Returns: int: The minimum total cost to purchase the required medals. >>> minimum_total_cost(4, 3, 1, 2) 24 >>> minimum_total_cost(10, 2, 3, 4) 90 def test_minimum_total_cost(): assert minimum_total_cost(4, 3, 1, 2) == 24, \\"Error in test case 1\\" assert minimum_total_cost(10, 2, 3, 4) == 90, \\"Error in test case 2\\" assert minimum_total_cost(1, 1, 1, 1) == 3, \\"Error in test case 3\\" assert minimum_total_cost(100000, 100000, 100000, 100000) == 30000000000, \\"Error in test case 4\\" assert minimum_total_cost(5, 0, 0, 0) == 0, \\"Error in test case 5\\" def test_edge_cases(): # Edge case with minimum input values assert minimum_total_cost(1, 1, 1, 1) == 3, \\"Error in edge case 1\\" # Edge case with large input values assert minimum_total_cost(100000, 100000, 100000, 100000) == 30000000000, \\"Error in edge case 2\\" # Edge case with mixed values assert minimum_total_cost(100, 1, 10000, 50) == 1005100, \\"Error in edge case 3\\"","solution":"def minimum_total_cost(n, a, b, c): Given the number of participants and the cost of each type of medal (gold, silver, bronze), return the minimum total cost to purchase the medals for all top n participants. Parameters: n (int): The number of participants. a (int): The cost of each gold medal. b (int): The cost of each silver medal. c (int): The cost of each bronze medal. Returns: int: The minimum total cost to purchase the required medals. total_cost = n * (a + b + c) return total_cost"},{"question":"def min_albums_required(M: int, Z: int, sizes: List[int]) -> int: Given the sizes of the stamps Hanako received and the capacity of each album, determine the minimum number of albums required to store all the stamps. >>> min_albums_required(5, 10, [2, 5, 4, 7, 1]) 2 >>> min_albums_required(3, 5, [5, 5, 5]) 3 >>> min_albums_required(4, 10, [9, 8, 7, 6]) 4 >>> min_albums_required(4, 10, [6, 4, 3, 7]) 2 >>> min_albums_required(1, 10, [5]) 1 >>> min_albums_required(0, 10, []) 0 >>> min_albums_required(6, 50, [10, 20, 30, 40, 10, 10]) 3","solution":"def min_albums_required(M, Z, sizes): from bisect import insort # Sort sizes descending for better packing sizes.sort(reverse=True) album_list = [] for size in sizes: placed = False for i in range(len(album_list)): if album_list[i] + size <= Z: album_list[i] += size placed = True break if not placed: album_list.append(size) return len(album_list)"},{"question":"def three_sum(nums): Find all unique triplets in the list which give the sum of zero. Args: nums: List of integers Returns: A list of unique triplets sorted inside the triplet and the list itself. pass # Implement the function here def format_triplets(triplets): Format the triplets for output. Args: triplets: List of triplets Returns: A formatted string pass # Implement the function here def parse_input(): Read and parse input. Returns: A list of integers pass # Implement the function here if __name__ == \\"__main__\\": nums = parse_input() triplets = three_sum(nums) print(format_triplets(triplets)) # Unit test from solution import three_sum, format_triplets def test_three_sum(): assert three_sum([-1, 0, 1, 2, -1, -4]) == [(-1, -1, 2), (-1, 0, 1)] assert three_sum([0, 0, 0]) == [(0, 0, 0)] assert three_sum([-2, 0, 1, 1, 2]) == [(-2, 0, 2), (-2, 1, 1)] assert three_sum([-1, 0, 1]) == [(-1, 0, 1)] assert three_sum([1, 2, -2, -1]) == [] def test_format_triplets(): assert format_triplets([(-1, -1, 2), (-1, 0, 1)]) == \\"-1 -1 2n-1 0 1\\" assert format_triplets([(0, 0, 0)]) == \\"0 0 0\\" assert format_triplets([(-2, 0, 2), (-2, 1, 1)]) == \\"-2 0 2n-2 1 1\\" assert format_triplets([(-1, 0, 1)]) == \\"-1 0 1\\" assert format_triplets([]) == \\"\\"","solution":"def three_sum(nums): Find all unique triplets in the list which give the sum of zero. Args: nums: List of integers Returns: A list of unique triplets sorted inside the triplet and the list itself. nums.sort() triplets = set() n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplets.add((nums[i], nums[left], nums[right])) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif total < 0: left += 1 else: right -= 1 return sorted(list(triplets)) def format_triplets(triplets): Format the triplets for output. Args: triplets: List of triplets Returns: A formatted string return 'n'.join(' '.join(map(str, triplet)) for triplet in triplets) def parse_input(): Read and parse input. Returns: A list of integers import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = [int(data[i]) for i in range(1, n + 1)] return nums if __name__ == \\"__main__\\": nums = parse_input() triplets = three_sum(nums) print(format_triplets(triplets))"},{"question":"def largest_subarray_sum(arr): Finds the sum of the largest contiguous subarray using Kadane's Algorithm. >>> largest_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> largest_subarray_sum([-1, -2, -3, -4]) == -1 >>> largest_subarray_sum([1, -2, 3, 5, -1, 2]) == 9 >>> largest_subarray_sum([0, -3, 1, -2, 4, -1, 2, 1, -5, 4]) == 6 >>> largest_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 pass","solution":"def largest_subarray_sum(arr): Finds the sum of the largest contiguous subarray using Kadane's Algorithm. Parameters: arr (list of int): A list of integers. Returns: int: The sum of the largest contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def countPairs(arr, n, sum_val): Returns the count of pairs in array \`arr\` of size \`n\` that sum up to \`sum_val\`. Example: >>> countPairs([1, 5, 7, -1], 4, 6) == 2 >>> countPairs([1, 2, 3, 4], 4, 10) == 0 >>> countPairs([0, 0, 0, 0], 4, 0) == 6 >>> countPairs([1, 5, 3, 7, -2, -1], 6, 6) == 2 >>> countPairs([1000000000, -1000000000, 0], 3, 0) == 1 >>> countPairs([1], 1, 1) == 0 >>> countPairs([1, 1, 1, 1], 4, 2) == 6","solution":"def countPairs(arr, n, sum_val): Returns the count of pairs in array \`arr\` of size \`n\` that sum up to \`sum_val\`. count = 0 complement_map = {} for num in arr: complement = sum_val - num if complement in complement_map: count += complement_map[complement] if num in complement_map: complement_map[num] += 1 else: complement_map[num] = 1 return count"},{"question":"def create_triangle(height): Creates a right-angled triangle with the given height H. Each row i contains i asterisks. >>> create_triangle(3) '*n**n***n' >>> create_triangle(5) '*n**n***n****n*****n' >>> create_triangle(2) '*n**n' >>> create_triangle(0) '' def triangles_from_input(heights): Given a list of heights, returns a string with the right-angled triangles. Each triangle is separated by a blank line. >>> triangles_from_input([3, 5, 2, 0]) '*n**n***nn*n**n***n****n*****nn*n**nn' >>> triangles_from_input([4]) '*n**n***n****nn' >>> triangles_from_input([2, 3, 0]) '*n**nn*n**n***nn'","solution":"def create_triangle(height): Creates a right-angled triangle with the given height H. Each row i contains i asterisks. if height == 0: return '' result = [] for i in range(1, height + 1): result.append('*' * i) return 'n'.join(result) + 'n' def triangles_from_input(heights): Given a list of heights, returns a string with the right-angled triangles. Each triangle is separated by a blank line. return 'n'.join(create_triangle(h) for h in heights if h != 0) + 'n'"},{"question":"def max_possible_sum(n: int, sequence: List[int]) -> int: Calculate the maximum possible sum of the sequence after performing operations such that the sum of the entire sequence increases while keeping all elements of the sequence non-negative. >>> max_possible_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_possible_sum(1, [10]) 10 >>> max_possible_sum(4, [1, 1, 1, 1]) 4 >>> max_possible_sum(3, [1000000000, 1000000000, 1000000000]) 3000000000 >>> max_possible_sum(3, [1, 1000000000, 1]) 1000000002","solution":"def max_possible_sum(n, sequence): # As replacement of an element with any combination adds to the replaced element # itself, there is no chance to increase the sum. Just return the sum of the elements. return sum(sequence)"},{"question":"from typing import List def sum_of_primes(numbers: List[int]) -> int: Given a list of non-negative integers, returns the sum of all prime numbers in the list. >>> sum_of_primes([3, 11, 4, 6, 8]) 14 >>> sum_of_primes([0, 1, 4, 6, 8]) 0 >>> sum_of_primes([7, 7, 11, 13, 17]) 55 pass def is_prime(num: int) -> bool: Checks if a number is prime. pass # Test cases from solution import sum_of_primes def test_example_cases(): assert sum_of_primes([3, 11, 4, 6, 8]) == 14 assert sum_of_primes([0, 1, 4, 6, 8]) == 0 assert sum_of_primes([7, 7, 11, 13, 17]) == 55 def test_empty_list(): assert sum_of_primes([]) == 0 def test_no_primes(): assert sum_of_primes([4, 6, 8, 9, 10]) == 0 def test_all_primes(): assert sum_of_primes([2, 3, 5, 7, 11]) == 28 def test_single_element_list(): assert sum_of_primes([2]) == 2 assert sum_of_primes([4]) == 0 def test_large_numbers(): assert sum_of_primes([999, 1000, 991]) == 991 assert sum_of_primes([1000, 1001, 1002]) == 0 def test_mixed_elements(): assert sum_of_primes([0, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 17","solution":"from typing import List def is_prime(num: int) -> bool: Check if a number is prime. if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def sum_of_primes(numbers: List[int]) -> int: Returns the sum of all prime numbers in the given list. return sum(num for num in numbers if is_prime(num))"},{"question":"def can_fulfill_requests(inventory, requests): Determines if each request's items and quantities can be fulfilled with the given inventory. Parameters: inventory (dict): A dictionary where the keys are item type IDs and values are quantities. requests (list of list): List of requests, each a list where the first element is the number of item types requested followed by pairs of item type ID and quantity. Returns: list of str: \\"Yes\\" if the request can be fulfilled, otherwise \\"No\\". import pytest def test_can_fulfill_requests(): inventory = {1: 10, 2: 5, 3: 8, 4: 2} requests = [ [2, 1, 5, 3, 3], [2, 1, 6, 4, 1], [1, 2, 5] ] assert can_fulfill_requests(inventory, requests) == [\\"Yes\\", \\"No\\", \\"Yes\\"] def test_can_fulfill_requests_with_different_input(): inventory = {50: 20, 100: 15} requests = [ [2, 50, 10, 100, 5], [1, 50, 25] ] assert can_fulfill_requests(inventory, requests) == [\\"Yes\\", \\"No\\"] def test_can_fulfill_requests_with_no_inventory(): inventory = {} requests = [ [1, 1, 1] ] assert can_fulfill_requests(inventory, requests) == [\\"No\\"] def test_can_fulfill_requests_with_exact_quantity(): inventory = {1: 1, 2: 1} requests = [ [1, 1, 1], [1, 2, 1] ] assert can_fulfill_requests(inventory, requests) == [\\"Yes\\", \\"Yes\\"] def test_can_fulfill_requests_with_insufficient_quantity(): inventory = {1: 1} requests = [ [1, 1, 2] ] assert can_fulfill_requests(inventory, requests) == [\\"No\\"]","solution":"def can_fulfill_requests(inventory, requests): Determines if each request's items and quantities can be fulfilled with the given inventory. Parameters: inventory (dict): A dictionary where the keys are item type IDs and values are quantities. requests (list of list): List of requests, each a list where the first element is the number of item types requested followed by pairs of item type ID and quantity. Returns: list of str: \\"Yes\\" if the request can be fulfilled, otherwise \\"No\\". results = [] for request in requests: can_fulfill = True for i in range(request[0]): item_id = request[2 * i + 1] quantity = request[2 * i + 2] if item_id not in inventory or inventory[item_id] < quantity: can_fulfill = False break if can_fulfill: for i in range(request[0]): item_id = request[2 * i + 1] quantity = request[2 * i + 2] inventory[item_id] -= quantity results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def most_frequent_element_count(arr: List[int]) -> int: Given a list of integers, returns the count of the most frequent element. >>> most_frequent_element_count([1, 3, 1, 3, 2, 1, 3]) == 3 >>> most_frequent_element_count([7, 7, 7, 7, 7]) == 5 >>> most_frequent_element_count([1000000, 1000000, 999999, 1000000, 999999]) == 3","solution":"def most_frequent_element_count(arr): Given a list of integers, returns the count of the most frequent element. from collections import Counter # Using counter to count the frequency of elements frequency_count = Counter(arr) # Getting the maximum frequency max_frequency = max(frequency_count.values()) return max_frequency # Example usage: # N = 7 # arr = [1, 3, 1, 3, 2, 1, 3] # print(most_frequent_element_count(arr)) # Output: 3"},{"question":"def can_segment_string(s, m, word_list): Determine if string s can be segmented into a space-separated sequence of one or more words from word_list. Args: s (str): The input string. m (int): The number of words in word_list. word_list (list): List of unique words to use for segmentation. Returns: bool: True if the string can be segmented, False otherwise. >>> can_segment_string(\\"leetcode\\", 2, [\\"leet\\", \\"code\\"]) True >>> can_segment_string(\\"applepenapple\\", 2, [\\"apple\\", \\"pen\\"]) True >>> can_segment_string(\\"catsandog\\", 5, [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False","solution":"def can_segment_string(s, m, word_list): Determine if string s can be segmented into a space-separated sequence of one or more words from word_list. Args: s (str): The input string. m (int): The number of words in word_list. word_list (list): List of unique words to use for segmentation. Returns: bool: True if the string can be segmented, False otherwise. word_set = set(word_list) dp = [False] * (len(s) + 1) dp[0] = True # An empty string can be segmented in zero ways for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"from typing import List, Tuple, Union def solve_mazes(datasets: List[dict]) -> List[Union[int, str]]: Solve multiple datasets of mazes. For each dataset, output the length of the shortest path from start to end or \\"No Path\\" if no such path exists. >>> datasets = [ ... {'size': (5, 5), 'start': (1, 1), 'end': (5, 5), 'maze': ['.....', '.#.', '..#..', '.', '.....']}, ... {'size': (5, 5), 'start': (1, 2), 'end': (5, 4), 'maze': ['..#..', '.#.#.', '.#.#.', '.#.#.', '..#..']} ... ] >>> solve_mazes(datasets) [8, \\"No Path\\"] >>> datasets = [{'size': (5, 5), 'start': (1, 1), 'end': (5, 5), 'maze': ['.....', '.#.', '..#..', '.', '.....']}] >>> solve_mazes(datasets) [8] >>> datasets = [{'size': (5, 5), 'start': (1, 2), 'end': (5, 4), 'maze': ['..#..', '.#.#.', '.#.#.', '.#.#.', '..#..']}] >>> solve_mazes(datasets) [\\"No Path\\"]","solution":"from collections import deque def shortest_path(maze, start, end): Find the shortest path in a maze from start to end using BFS. rows, cols = len(maze), len(maze[0]) startX, startY = start endX, endY = end def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == '.' directions = [(0,1), (1,0), (0,-1), (-1,0)] queue = deque([(startX, startY, 0)]) visited = set((startX, startY)) while queue: x, y, depth = queue.popleft() if (x, y) == (endX, endY): return depth for d in directions: nx, ny = x + d[0], y + d[1] if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, depth + 1)) return \\"No Path\\" def solve_mazes(datasets): Solve multiple datasets of mazes. results = [] for dataset in datasets: M, N = dataset['size'] start = (dataset['start'][0] - 1, dataset['start'][1] - 1) end = (dataset['end'][0] - 1, dataset['end'][1] - 1) maze = [list(row) for row in dataset['maze']] result = shortest_path(maze, start, end) results.append(result) return results # Example to manually run the solve_mazes function if __name__ == \\"__main__\\": datasets = [ { 'size': (5, 5), 'start': (1, 1), 'end': (5, 5), 'maze': [ '.....', '.#.', '..#..', '.', '.....' ] }, { 'size': (5, 5), 'start': (1, 2), 'end': (5, 4), 'maze': [ '..#..', '.#.#.', '.#.#.', '.#.#.', '..#..' ] } ] print(solve_mazes(datasets)) # Output: [8, \\"No Path\\"]"},{"question":"def remove_duplicates(s: str) -> str: Returns a string with all duplicate characters removed, keeping only the first occurrence of each character. >>> remove_duplicates(\\"programming\\") 'progamin' >>> remove_duplicates(\\"aabbcc\\") 'abc' >>> remove_duplicates(\\"abcdef\\") 'abcdef' >>> remove_duplicates(\\"abracadabra\\") 'abrcd' >>> remove_duplicates(\\"aabacada\\") 'abcd' >>> remove_duplicates(\\"aaaaaa\\") 'a' >>> remove_duplicates(\\"z\\") 'z' >>> remove_duplicates(\\"a1s2d3f4a1s2d3f4\\") 'a1s2d3f4' >>> input_str = \\"abcdefghijklmnopqrstuvwxyz\\" * 380 >>> remove_duplicates(input_str) 'abcdefghijklmnopqrstuvwxyz'","solution":"def remove_duplicates(s): Returns a string with all duplicate characters removed, keeping only the first occurrence of each character. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def find_duplicates(participant_ids): Finds and returns the duplicate participant IDs in ascending order. If no duplicates are found, returns 'No duplicates'. Parameters: participant_ids (List[int]): A list of participant IDs. Returns: str: A space-separated string of duplicate participant IDs in ascending order, or \\"No duplicates\\" if there are no duplicates.","solution":"def find_duplicates(participant_ids): Finds and returns the duplicate participant IDs in ascending order. If no duplicates are found, returns 'No duplicates'. from collections import defaultdict id_count = defaultdict(int) for pid in participant_ids: id_count[pid] += 1 duplicates = [pid for pid, count in id_count.items() if count > 1] if duplicates: return sorted(duplicates) else: return \\"No duplicates\\" def process_input(n, participant_ids_list): Process the input and returns the duplicates in the required output format. If there are no duplicates, returns \\"No duplicates\\". Otherwise, returns a space-separated string of duplicate participant IDs in ascending order. result = find_duplicates(participant_ids_list) if result == \\"No duplicates\\": return result else: return \\" \\".join(map(str, result))"},{"question":"def min_toggles(lights: List[int]) -> int: Returns the minimum number of toggle operations needed to turn off all lights in the gallery. Args: lights (List[int]): A list of integers representing the state of each light (0 for off, 1 for on). Returns: int: Minimum number of toggle operations needed to turn off all lights. Examples: >>> min_toggles([0, 0, 0, 0]) 0 >>> min_toggles([1, 1, 1, 1]) 1 >>> min_toggles([1, 0, 1, 0, 1]) 5 >>> min_toggles([0, 1, 0, 1, 0]) 4 >>> min_toggles([1]) 1 >>> min_toggles([0]) 0 # Unit Tests def test_all_lights_off(): assert min_toggles([0, 0, 0, 0]) == 0 assert min_toggles([0]) == 0 def test_all_lights_on(): assert min_toggles([1, 1, 1, 1]) == 1 assert min_toggles([1]) == 1 def test_alternating_lights(): assert min_toggles([1, 0, 1, 0, 1]) == 5 assert min_toggles([0, 1, 0, 1, 0]) == 4 def test_single_light(): assert min_toggles([1]) == 1 assert min_toggles([0]) == 0 def test_random_lights(): assert min_toggles([1, 0, 0, 1, 0, 0, 1, 1]) == 5 assert min_toggles([1, 1, 1, 0, 0, 1, 1, 0]) == 4","solution":"def min_toggles(lights): Returns the minimum number of toggle operations needed to turn off all lights in the gallery. if not lights: return 0 toggles = 0 state = 0 # Initial state of the current contiguous segment, 0 for off for light in lights: if light != state: toggles += 1 state = 1 - state # Toggle state to the opposite return toggles"},{"question":"from typing import List def filter_primes(nums: List[int]) -> List[int]: Write a function that takes a list of integers as input and returns a new list containing only the prime numbers from the input list. If the input list is empty or contains no prime numbers, the function should return an empty list. Ex: Input: [10, 15, 3, 7, 18, 19] --> Output: [3, 7, 19] Ex: Input: [4, 6, 8, 9] --> Output: [] Ex: Input: [2, 5, 11, 13] --> Output: [2, 5, 11, 13]","solution":"from math import isqrt def is_prime(n): if n <= 1: return False for i in range(2, isqrt(n) + 1): if n % i == 0: return False return True def filter_primes(nums): return [num for num in nums if is_prime(num)]"},{"question":"def min_max_diff(coins): Returns the minimum possible maximum difference between the values of any two consecutive coins after arranging them. >>> min_max_diff([4, 8, 6, 3, 15]) 1 >>> min_max_diff([1, 3, 6, 10]) 2 >>> min_max_diff([1, 1000000000]) 999999999 >>> min_max_diff([3, 3, 3]) 0 def find_min_possible_max_diff(test_cases): Takes a list of test cases, where each test case is a list of coin values, and returns a list of results for each test case. >>> find_min_possible_max_diff([[4, 8, 6, 3, 15], [1, 3, 6, 10]]) [1, 2] >>> find_min_possible_max_diff([[1, 1000000000], [3, 3, 3]]) [999999999, 0] >>> find_min_possible_max_diff([[5]]) [float('inf')]","solution":"def min_max_diff(coins): Returns the minimum possible maximum difference between the values of any two consecutive coins after arranging them. # Sort the coins to find the minimum possible maximum difference coins.sort() # Initialize the minimum difference as infinity min_diff = float('inf') # Iterate through the sorted coins to find the minimum difference for i in range(1, len(coins)): min_diff = min(min_diff, coins[i] - coins[i-1]) return min_diff def find_min_possible_max_diff(test_cases): results = [] for coins in test_cases: results.append(min_max_diff(coins)) return results"},{"question":"def max_gold(n: int, grid: List[List[int]]) -> int: Compute the maximum amount of gold the player can collect from the top-left to the bottom-right cell of the grid. >>> max_gold(3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_gold(2, [ ... [1, 2], ... [3, 4] ... ]) 8 >>> max_gold(1, [ ... [5] ... ]) 5 >>> max_gold(3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_gold(4, [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7] ... ]) 28","solution":"def max_gold(n, grid): if n == 0: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(n): for j in range(n): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[-1][-1]"},{"question":"def total_blocks(L): Calculate the total number of blocks required to build a pyramid with L levels. Args: L (int): The number of levels in the pyramid. 1 ≤ L ≤ 1000000. Returns: int: The total number of blocks required to build the pyramid. Example: >>> total_blocks(3) 6 >>> total_blocks(5) 15 >>> total_blocks(10) 55","solution":"def total_blocks(L): Calculate the total number of blocks required to build a pyramid with L levels. Args: L (int): The number of levels in the pyramid. 1 ≤ L ≤ 1000000. Returns: int: The total number of blocks required to build the pyramid. return L * (L + 1) // 2"},{"question":"from typing import List def findGCD(nums: List[int]) -> int: Given an array of integers, find the greatest common divisor (GCD) of the maximum and minimum numbers in the array. Args: nums (List[int]): The list of integers. Returns: int: The GCD of the maximum and minimum numbers. >>> findGCD([2, 5, 6, 9, 10]) 2 >>> findGCD([7, 5, 6, 8, 3]) 1 >>> findGCD([3, 3]) 3","solution":"from math import gcd from typing import List def findGCD(nums: List[int]) -> int: This function takes an array of integers and returns the GCD of the maximum and minimum numbers in the array. max_num = max(nums) min_num = min(nums) return gcd(max_num, min_num)"},{"question":"import numpy as np def process_array(N, A): Perform various numpy operations on the array 'A' of size 'N'. Args: N (int): size of the array A (numpy.ndarray): input array of integers Returns: tuple: containing cumulative sum, cumulative product, mean, variance and standard deviation of the array elements >>> N = 5 >>> A = np.array([1, 2, 3, 4, 5]) >>> process_array(N, A) (array([ 1, 3, 6, 10, 15]), array([ 1, 2, 6, 24, 120]), 3.0, 2.0, 1.4142135623730951) >>> N = 4 >>> A = np.array([0, 0, 0, 0]) >>> process_array(N, A) (array([0, 0, 0, 0]), array([0, 0, 0, 0]), 0.0, 0.0, 0.0)","solution":"import numpy as np def process_array(N, A): cum_sum = np.cumsum(A) cum_prod = np.cumprod(A) mean = np.mean(A) variance = np.var(A) std_dev = np.std(A) return cum_sum, cum_prod, mean, variance, std_dev"},{"question":"def can_reserve(N, reservations, new_reservation): Determines if a new reservation can be made without conflicting with any existing reservations. Parameters: - N: int, number of existing reservations - reservations: list of tuples, each tuple contains start and end times in \\"HH:MM\\" 24-hour format - new_reservation: tuple, start and end time of the new reservation in \\"HH:MM\\" 24-hour format Returns: - \\"YES\\" if the new reservation can be made without conflicts, \\"NO\\" otherwise Example: >>> can_reserve(3, [(\\"09:00\\", \\"10:30\\"), (\\"10:30\\", \\"12:00\\"), (\\"13:00\\", \\"15:00\\")], (\\"12:00\\", \\"13:00\\")) \\"YES\\" >>> can_reserve(3, [(\\"09:00\\", \\"10:30\\"), (\\"10:30\\", \\"12:00\\"), (\\"13:00\\", \\"15:00\\")], (\\"11:00\\", \\"12:30\\")) \\"NO\\" >>> can_reserve(0, [], (\\"11:00\\", \\"12:00\\")) \\"YES\\" >>> can_reserve(1, [(\\"09:00\\", \\"17:00\\")], (\\"12:00\\", \\"13:00\\")) \\"NO\\"","solution":"def can_reserve(N, reservations, new_reservation): Determines if a new reservation can be made without conflicting with any existing reservations. Parameters: - N: int, number of existing reservations - reservations: list of tuples, each tuple contains start and end times in \\"HH:MM\\" 24-hour format - new_reservation: tuple, start and end time of the new reservation in \\"HH:MM\\" 24-hour format Returns: - \\"YES\\" if the new reservation can be made without conflicts, \\"NO\\" otherwise new_start, new_end = new_reservation for start, end in reservations: # Check if there is any overlap if not (new_end <= start or new_start >= end): return \\"NO\\" return \\"YES\\""},{"question":"def are_anagrams(str1: str, str2: str) -> str: Determine if two strings are anagrams of each other. >>> are_anagrams('listen', 'silent') 'Anagram' >>> are_anagrams('apple', 'pale') 'Not Anagram'","solution":"def are_anagrams(str1, str2): Returns 'Anagram' if str1 and str2 are anagrams of each other, otherwise returns 'Not Anagram'. if sorted(str1) == sorted(str2): return \\"Anagram\\" else: return \\"Not Anagram\\""},{"question":"def longest_alphabetical_subsequence(s: str) -> int: Returns the length of the longest subsequence where all characters are in alphabetical order. >>> longest_alphabetical_subsequence(\\"abac\\") 3 >>> longest_alphabetical_subsequence(\\"dcbgfa\\") 2","solution":"def longest_alphabetical_subsequence(s): Returns the length of the longest subsequence where all characters are in alphabetical order. if not s: return 0 # Create an array to store the length of the longest subsequence ending at each character dp = [1] * len(s) for i in range(1, len(s)): for j in range(i): if s[j] <= s[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def most_frequent_word(n: int, words: List[str]) -> str: Returns the word that appears most frequently in the list of words. If there is a tie, returns the word that comes first lexicographically. Parameters: n (int): The number of words in the list. words (List[str]): List of words. Returns: str: The word with the highest frequency or lexicographically first in case of tie. Examples: >>> most_frequent_word(1, [\\"apple\\"]) \\"apple\\" >>> most_frequent_word(3, [\\"apple\\", \\"banana\\", \\"orange\\"]) \\"apple\\" >>> most_frequent_word(4, [\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\"]) \\"apple\\" >>> most_frequent_word(6, [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"]) \\"banana\\" >>> most_frequent_word(5, [\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"cherry\\"]) \\"apple\\" >>> words = [\\"word{}\\".format(i // 10) for i in range(1000)] >>> most_frequent_word(1000, words) \\"word0\\"","solution":"def most_frequent_word(n, words): Returns the word that appears most frequently in the list of words. If there is a tie, returns the word that comes first lexicographically. from collections import Counter word_count = Counter(words) max_count = max(word_count.values()) # Get all words with the max_count most_frequent_words = [word for word, count in word_count.items() if count == max_count] # Return the lexicographically smallest word among these return min(most_frequent_words)"},{"question":"def subarraySum(nums, k): Return the number of unique contiguous subarrays that sum to k. Args: nums: List of integers. k: Integer, the target sum. Returns: Integer, the number of unique contiguous subarrays that sum to k. Examples: >>> subarraySum([1, 1, 1], 2) 2 >>> subarraySum([1, 2, 3], 3) 2 >>> subarraySum([-1, -1, 1], 0) 1","solution":"def subarraySum(nums, k): Return the number of unique contiguous subarrays that sum to k. Args: nums: List of integers. k: Integer, the target sum. Returns: Integer, the number of unique contiguous subarrays that sum to k. count = 0 sum_count = {0: 1} current_sum = 0 for num in nums: current_sum += num if current_sum - k in sum_count: count += sum_count[current_sum - k] if current_sum in sum_count: sum_count[current_sum] += 1 else: sum_count[current_sum] = 1 return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def reconstructBst(inOrder, levelOrder): Reconstruct the original BST from inorder and level-order traversals. Arguments: inOrder: List[int] -- An array representing the inorder traversal of a BST. levelOrder: List[int] -- An array representing the level-order traversal of the same BST. Returns: TreeNode: The root of the reconstructed BST. >>> bst_to_list_by_levels(reconstructBst([4, 8, 10, 12, 14, 20, 22], [20, 8, 22, 4, 12, 10, 14])) [20, 8, 22, 4, 12, 10, 14] >>> bst_to_list_by_levels(reconstructBst([4, 5, 10, 12, 14, 15, 20, 22, 25], [15, 10, 20, 5, 12, 14, 25, 4, 22])) [15, 10, 20, 5, 12, 25, 4, 14, 22] pass def bst_to_list_by_levels(root): Helper function to convert BST to list by levels for easy comparison. Arguments: root: TreeNode -- The root of the BST. Returns: List[int]: The list of node values level by level. if not root: return [] result = [] queue = [root] while queue: current = queue.pop(0) result.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def reconstructBst(inOrder, levelOrder): if not inOrder or not levelOrder: return None # The first element of levelOrder is the root of the BST root_val = levelOrder[0] root = TreeNode(root_val) # Find the root index in the inOrder array root_index_inorder = inOrder.index(root_val) # Split the inOrder array into left and right subtrees left_inOrder = inOrder[:root_index_inorder] right_inOrder = inOrder[root_index_inorder + 1:] # Function to filter levelOrder array to get left or right subtree nodes def filter_levelOrder(subInOrder, levelOrder): sub_levelOrder = [x for x in levelOrder if x in subInOrder] return sub_levelOrder # Recursively construct left and right subtrees using filtered levelOrder arrays left_levelOrder = filter_levelOrder(left_inOrder, levelOrder) right_levelOrder = filter_levelOrder(right_inOrder, levelOrder) root.left = reconstructBst(left_inOrder, left_levelOrder) root.right = reconstructBst(right_inOrder, right_levelOrder) return root def bst_to_list_by_levels(root): Helper function to convert BST to list by levels for easy comparison. if not root: return [] result = [] queue = [root] while queue: current = queue.pop(0) result.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result"},{"question":"from typing import List def max_transaction_duration(transactions: List[int]) -> int: Given an array of integers that represent timestamps in seconds of completed transactions in a day, this function calculates the maximum total duration of non-overlapping transactions, assuming each transaction takes an exactly one-second duration. >>> max_transaction_duration([1, 3, 2, 4, 5, 6, 10]) == 7 >>> max_transaction_duration([2, 2, 3, 3, 4, 4, 5]) == 4 >>> max_transaction_duration([1, 1, 1, 1, 1]) == 1 >>> max_transaction_duration([]) == 0 >>> max_transaction_duration([86400]) == 1 >>> max_transaction_duration([1, 2, 3, 4, 5]) == 5 >>> max_transaction_duration(list(range(1, 1000001))) == 1000000 >>> max_transaction_duration([10] * 10) == 1","solution":"from typing import List def max_transaction_duration(transactions: List[int]) -> int: Given a list of transaction timestamps, this function returns the maximum total duration of non-overlapping transactions in seconds. # Use a set to find unique transactions unique_transactions = set(transactions) # Return the count of unique transactions return len(unique_transactions)"},{"question":"from typing import List, Tuple def find_center(n: int, edges: List[Tuple[int, int]]) -> int: Function to find the center of a tree. Args: n : int : number of nodes in the tree edges : List[Tuple[int, int]] : list of edges representing the tree Returns: int : 1-based index of one of the center nodes >>> find_center(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 3 >>> find_center(2, [(1, 2)]) 1 >>> find_center(4, [(1, 2), (1, 3), (1, 4)]) 1 pass","solution":"from collections import deque def find_center(n, edges): Function to find the center of a tree. Args: n : int : number of nodes in the tree edges : List[Tuple[int, int]] : list of edges representing the tree Returns: int : 1-based index of one of the center nodes if n == 2: return 1 # Calculate degree of each node and add the edges to the adjacency list degree = [0] * (n + 1) adjacency_list = [[] for _ in range(n + 1)] for u, v in edges: degree[u] += 1 degree[v] += 1 adjacency_list[u].append(v) adjacency_list[v].append(u) # Initialize the first layer of leaves leaves = deque() for i in range(1, n + 1): if degree[i] == 1: leaves.append(i) # Process the leaves remaining_nodes = n while remaining_nodes > 2: leaf_count = len(leaves) remaining_nodes -= leaf_count for _ in range(leaf_count): leaf = leaves.popleft() for neighbor in adjacency_list[leaf]: degree[neighbor] -= 1 if degree[neighbor] == 1: leaves.append(neighbor) # The remaining nodes are the center(s) return leaves[0] # Example Usage: # n = 5 # edges = [(1, 2), (2, 3), (3, 4), (4, 5)] # print(find_center(n, edges)) => 3"},{"question":"def magical_sequence(n: int) -> list: Generates a sequence of integers from 1 to n where every even number is squared and every odd number is cubed. Parameters: n (int): The length of the sequence. Returns: list: The generated sequence. Examples: >>> magical_sequence(5) [1, 4, 27, 16, 125] >>> magical_sequence(3) [1, 4, 27]","solution":"def magical_sequence(n): Generates a sequence of integers from 1 to n where every even number is squared and every odd number is cubed. Parameters: n (int): The length of the sequence. Returns: list: The generated sequence. result = [] for i in range(1, n + 1): if i % 2 == 0: result.append(i ** 2) else: result.append(i ** 3) return result"},{"question":"def get_max_length_word(words): Returns the word with the maximum length from the input list of words. If multiple words have the maximum length, returns the first one encountered. >>> get_max_length_word([\\"apple\\", \\"banana\\", \\"grapefruit\\", \\"orange\\", \\"fig\\"]) == \\"grapefruit\\" >>> get_max_length_word([\\"dog\\", \\"cat\\", \\"bat\\"]) == \\"dog\\" >>> get_max_length_word([\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) == \\"abcd\\" >>> get_max_length_word([]) == \\"\\"","solution":"def get_max_length_word(words): Returns the word with the maximum length from the input list of words. If multiple words have the maximum length, returns the first one encountered. if not words: return \\"\\" max_length_word = words[0] for word in words[1:]: if len(word) > len(max_length_word): max_length_word = word return max_length_word"},{"question":"def canDivideIntoGroups(N: int, K: int) -> int: This function checks if it is possible to divide N employees into groups such that: 1. Each group has exactly K members. 2. Each group's sum of IDs is the same. Parameters: N (int): Total number of employees. K (int): Number of members in each group. Returns: int: 1 if it is possible to divide the employees into such groups, 0 otherwise. >>> canDivideIntoGroups(6, 3) 1 >>> canDivideIntoGroups(5, 2) 0 >>> canDivideIntoGroups(1, 1) 1 >>> canDivideIntoGroups(1000000, 500000) 1 >>> canDivideIntoGroups(1000001, 500000) 0","solution":"def canDivideIntoGroups(N, K): This function checks if it is possible to divide N employees into groups such that: 1. Each group has exactly K members. 2. Each group's sum of IDs is the same. Parameters: N (int): Total number of employees. K (int): Number of members in each group. Returns: int: 1 if it is possible to divide the employees into such groups, 0 otherwise. # For the sum of each group to be the same, number of groups should be an integer if N % K != 0: return 0 return 1"},{"question":"def count_accessible_regions(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determine the number of accessible regions in the grid for each test case >>> count_accessible_regions(2, [(4, 5, [\\"11000\\", \\"11000\\", \\"00101\\", \\"00001\\"]), (3, 3, [\\"101\\", \\"010\\", \\"101\\"])]) [3, 5] >>> count_accessible_regions(1, [(1, 5, [\\"11011\\"])]) [2] >>> count_accessible_regions(1, [(5, 1, [\\"1\\", \\"0\\", \\"1\\", \\"1\\", \\"0\\"])]) [2] >>> count_accessible_regions(1, [(3, 3, [\\"000\\", \\"000\\", \\"000\\"])]) [0] >>> count_accessible_regions(1, [(3, 3, [\\"111\\", \\"111\\", \\"111\\"])]) [1] >>> count_accessible_regions(1, [(2, 2, [\\"10\\", \\"01\\"])]) [2]","solution":"def count_accessible_regions(t, test_cases): def dfs(grid, visited, x, y, rows, cols): stack = [(x, y)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while stack: cx, cy = stack.pop() if visited[cx][cy]: continue visited[cx][cy] = True for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == \\"1\\": stack.append((nx, ny)) results = [] for tc in test_cases: n, m, grid = tc visited = [[False] * m for _ in range(n)] count = 0 for i in range(n): for j in range(m): if grid[i][j] == \\"1\\" and not visited[i][j]: count += 1 dfs(grid, visited, i, j, n, m) results.append(count) return results # Reading inputs for the function def read_input(): import sys input = sys.stdin.read data = input().strip().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) m = int(data[index + 1]) index += 2 grid = [data[index + i] for i in range(n)] index += n test_cases.append((n, m, grid)) return t, test_cases # For standalone use if __name__ == \\"__main__\\": t, test_cases = read_input() results = count_accessible_regions(t, test_cases) for result in results: print(result)"},{"question":"def right_rotate(n: int, lst: List[int], k: int) -> List[int]: Rotates the list lst of length n to the right by k positions. >>> right_rotate(5, [1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> right_rotate(6, [10, 20, 30, 40, 50, 60], 4) [30, 40, 50, 60, 10, 20]","solution":"def right_rotate(n, lst, k): Rotates the list lst of length n to the right by k positions. k = k % n # Reduce k to be within the bounds of list length return lst[-k:] + lst[:-k]"},{"question":"def categorize_words_by_first_letter(words: str) -> list: Categorizes words based on their first letter and counts how many words fall under each category. Args: words (str): Space-separated words. Returns: list: List of tuples, each containing a letter and the number of words that start with that letter. >>> categorize_words_by_first_letter(\\"apple banana apricot orange olive\\") [('a', 2), ('b', 1), ('o', 2)] >>> categorize_words_by_first_letter(\\"zebra xylophone xenon yak yellow zoo\\") [('x', 2), ('y', 2), ('z', 2)]","solution":"def categorize_words_by_first_letter(words): Categorizes words based on their first letter and counts how many words fall under each category. Args: words (str): Space-separated words. Returns: list: List of tuples, each containing a letter and the number of words that start with that letter. if not words: return [] word_list = words.split() category_count = {} for word in word_list: first_letter = word[0] if first_letter in category_count: category_count[first_letter] += 1 else: category_count[first_letter] = 1 return sorted(category_count.items())"},{"question":"def is_magic_square(square): Checks if a given 2D list represents a magic square. pass # Implement the logic to check if 2D list is a magic square def check_magic_square_in_array(nums): Determines if any subarray of nums forms a magic square. >>> check_magic_square_in_array([2, 7, 6, 9]) \\"NO\\" >>> check_magic_square_in_array([4, 9, 2, 3, 5, 7, 8, 1, 6]) \\"YES\\" >>> check_magic_square_in_array([1]) \\"NO\\" >>> check_magic_square_in_array(list(range(1, 25))) \\"NO\\" >>> check_magic_square_in_array(list(range(1, 13)) + [4, 9, 2, 3, 5, 7, 8, 1, 6] + list(range(1, 10))) \\"YES\\" pass # Implement the logic to determine if any subarray forms a magic square","solution":"def is_magic_square(square): Checks if a given 2D list represents a magic square. # Check if all rows have the same sum target_sum = sum(square[0]) for row in square: if sum(row) != target_sum: return False # Check if all columns have the same sum for col in range(len(square[0])): if sum(square[row][col] for row in range(len(square))) != target_sum: return False # Check if diagonals have the same sum if sum(square[i][i] for i in range(len(square))) != target_sum: return False if sum(square[i][len(square)-i-1] for i in range(len(square))) != target_sum: return False return True def check_magic_square_in_array(nums): Determines if any subarray of nums forms a magic square. n = len(nums) if n < 9: return \\"NO\\" for i in range(n - 8): subarray = nums[i:i+9] square = [subarray[j:j+3] for j in range(0, 9, 3)] if is_magic_square(square): return \\"YES\\" return \\"NO\\" # Example usage: # nums = [4, 9, 2, 3, 5, 7, 8, 1, 6] # print(check_magic_square_in_array(nums)) # Outputs: \\"YES\\""},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams from a list of strings into a list of lists. Parameters: words (list of str): The list of strings to group. Returns: list of list of str: A list of lists where each list contains anagram strings. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams([\\"word\\"]) [['word']] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\"]) [['listen', 'silent', 'enlist']] >>> group_anagrams([\\"bored\\", \\"robed\\", \\"Robed\\"]) [['bored', 'robed'], ['Robed']]","solution":"def group_anagrams(words): Groups anagrams from a list of strings into a list of lists. Parameters: words (list of str): The list of strings to group. Returns: list of list of str: A list of lists where each list contains anagram strings. from collections import defaultdict anagrams = defaultdict(list) for word in words: # Sort the word to use as a key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"from typing import List import math from functools import reduce def lcm_of_array(arr: List[int]) -> int: Calculate the least common multiple (LCM) of an array of integers. >>> lcm_of_array([4, 6, 8]) == 24 >>> lcm_of_array([3, 7]) == 21 >>> lcm_of_array([10, 20, 30]) == 60 >>> lcm_of_array([5]) == 5 >>> lcm_of_array([6, 8]) == 24 >>> lcm_of_array([2, 3, 5, 7]) == 210","solution":"import math from functools import reduce def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // math.gcd(a, b) def lcm_of_array(arr): Given an array of integers, return the least common multiple (LCM) of the array. return reduce(lcm, arr)"},{"question":"def maximalRectangle(matrix): Returns the area of the largest rectangle filled with 1s in the given binary matrix. Parameters: matrix (List[List[int]]): An m x n binary matrix filled with 0s and 1s Returns: int: The area of the largest rectangle filled with 1s Example: >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 6 >>> maximalRectangle([]) 0 >>> maximalRectangle([[0]]) 0 >>> maximalRectangle([[1]]) 1 >>> maximalRectangle([[1, 0, 1, 1, 1]]) 3 >>> maximalRectangle([[1, 1, 1, 1, 1]]) 5 >>> maximalRectangle([[1], [1], [1], [0], [1]]) 3 >>> maximalRectangle([[0], [0], [0], [0], [0]]) 0 >>> maximalRectangle([ ... [1, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 1, 1, 0], ... [0, 1, 0, 0] ... ]) 4","solution":"def maximalRectangle(matrix): Returns the area of the largest rectangle filled with 1s in the given binary matrix. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * (n + 1) for row in matrix: for i in range(n): if row[i] == 0: heights[i] = 0 else: heights[i] += 1 stack = [-1] for i in range(n + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def strongest_friend_index(N, capacities): Returns the 1-based index of the friend with the highest carrying capacity. If there are multiple friends with the same highest carrying capacity, the smallest index is returned. Params: N (int): The number of friends. capacities (list): A list of integers representing the carrying capacities of friends. Returns: int: 1-based index of the friend with the highest carrying capacity. pass # Unit tests def test_single_friend(): assert strongest_friend_index(1, [50]) == 1 def test_unique_capacities(): assert strongest_friend_index(3, [10, 20, 30]) == 3 def test_multiple_friends_same_capacity(): assert strongest_friend_index(5, [15, 20, 5, 20, 10]) == 2 def test_all_friends_same_capacity(): assert strongest_friend_index(4, [10, 10, 10, 10]) == 1 def test_minimal_input(): assert strongest_friend_index(1, [1]) == 1 def test_decreasing_order(): assert strongest_friend_index(4, [40, 30, 20, 10]) == 1 def test_increasing_order(): assert strongest_friend_index(4, [10, 20, 30, 40]) == 4","solution":"def strongest_friend_index(N, capacities): Returns the 1-based index of the friend with the highest carrying capacity. If there are multiple friends with the same highest carrying capacity, the smallest index is returned. Params: N (int): The number of friends. capacities (list): A list of integers representing the carrying capacities of friends. Returns: int: 1-based index of the friend with the highest carrying capacity. max_capacity = max(capacities) for i in range(N): if capacities[i] == max_capacity: return i + 1"},{"question":"def min_vehicles_required(friends: int, vehicles: List[int]) -> int: Determine the minimum number of vehicles required to accommodate all friends. :param friends: The number of friends needing to be accommodated :param vehicles: A list of integers representing the capacities of the available vehicles :return: The minimum number of vehicles required, or -1 if it is not possible to accommodate all friends >>> min_vehicles_required(7, [2, 3, 5]) 2 >>> min_vehicles_required(10, [3, 4]) -1 def process_test_cases(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Process multiple test cases and determine the minimum number of vehicles required for each. :param T: The number of test cases :param test_cases: A list of tuples, where each tuple contains a tuple with the number of friends and the number of vehicles, and a list of integers representing the capacities of the available vehicles :return: A list of integers representing the minimum number of vehicles required for each test case, or -1 if it is not possible >>> process_test_cases(2, [((7, 3), [2, 3, 5]), ((10, 2), [3, 4])]) [2, -1] from typing import List, Tuple def test_min_vehicles_scenario1(): assert min_vehicles_required(7, [2, 3, 5]) == 2 def test_min_vehicles_scenario2(): assert min_vehicles_required(10, [3, 4]) == -1 def test_min_vehicles_single_vehicle_sufficient(): assert min_vehicles_required(4, [4]) == 1 def test_min_vehicles_all_vehicles_needed(): assert min_vehicles_required(6, [1, 1, 1, 1, 1, 1]) == 6 def test_min_vehicles_not_enough_capacity(): assert min_vehicles_required(10, [1, 1, 1, 1, 1]) == -1 def test_process_test_cases(): T = 2 test_cases = [ [(7, 3), [2, 3, 5]], [(10, 2), [3, 4]] ] assert process_test_cases(T, test_cases) == [2, -1] def test_process_test_cases_single_case(): T = 1 test_cases = [ [(5, 3), [2, 2, 2]] ] assert process_test_cases(T, test_cases) == [3]","solution":"def min_vehicles_required(friends, vehicles): vehicles.sort(reverse=True) total_capacity = 0 vehicle_count = 0 for capacity in vehicles: total_capacity += capacity vehicle_count += 1 if total_capacity >= friends: return vehicle_count return -1 def process_test_cases(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] capacities = test_cases[i][1] result = min_vehicles_required(N, capacities) results.append(result) return results"},{"question":"def find_closest_peak_point(arr: List[int], key: int) -> int: Write a function \`find_closest_peak_point(arr, key)\` that takes a list of integers \`arr\` and an integer \`key\`, and returns the closest index of a \\"peak point\\" which is greater than \`key\`. A \\"peak point\\" is an element that is strictly greater than its neighbors. For the elements on boundary, the condition for a peak point is modified as follows: - For the first element, it is considered a peak if it is greater than the second element. - For the last element, it is considered a peak if it is greater than the second-last element. If there are multiple peak points that are equally close, return the smallest index among them. If no such peak point exists, return \`-1\`. Examples: >>> find_closest_peak_point([5, 10, 20, 15, 7, 25, 30], 18) 2 >>> find_closest_peak_point([10, 20, 5, 15, 10], 12) 1 >>> find_closest_peak_point([1, 3, 2, 5, 4], 6) -1","solution":"def find_closest_peak_point(arr, key): Returns the closest index of a \\"peak point\\" which is greater than \`key\`. def is_peak(i): if i == 0: return arr[i] > arr[i + 1] elif i == len(arr) - 1: return arr[i] > arr[i - 1] else: return arr[i] > arr[i - 1] and arr[i] > arr[i + 1] closest_peak_index = -1 min_distance = float('inf') for i in range(len(arr)): if arr[i] > key and is_peak(i): distance = abs(i - (i if closest_peak_index == -1 else closest_peak_index)) if distance < min_distance: closest_peak_index = i min_distance = distance elif distance == min_distance: closest_peak_index = min(closest_peak_index, i) return closest_peak_index"},{"question":"def sort_heights(heights): Returns a sorted list of heights in non-decreasing order with the relative order of people with the same height retained. >>> sort_heights([5, 3, 9, 2, 5, 5]) [2, 3, 5, 5, 5, 9] >>> sort_heights([1, 2, 3, 4, 8, 5, 6, 7]) [1, 2, 3, 4, 5, 6, 7, 8] >>> sort_heights([6, 2, 3, 2, 4, 3, 1]) [1, 2, 2, 3, 3, 4, 6] >>> sort_heights([3, 3, 3, 3]) [3, 3, 3, 3]","solution":"def sort_heights(heights): Returns a sorted list of heights in non-decreasing order with the relative order of people with the same height retained. return sorted(heights)"},{"question":"def evaluate_expression(expression: str) -> str: Evaluates a mathematical expression and returns the result. Handles integer numbers, '+', '-', '*', '/' and parentheses. Returns the result of the expression if valid, otherwise returns \\"invalid expression\\". >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"2 + 3 * 4\\") 14 >>> evaluate_expression(\\"10 + (2 * 3) - 4\\") 12 >>> evaluate_expression(\\"10 / 2 + 3 * 2\\") 11 >>> evaluate_expression(\\"2 + 3 * a\\") \\"invalid expression\\" >>> evaluate_expression(\\"2 + \\") \\"invalid expression\\" >>> evaluate_expression(\\"(2 + 3\\") \\"invalid expression\\" >>> evaluate_expression(\\"(2 + (3 * 2)) - 5\\") 3 >>> evaluate_expression(\\"10 + 2 - 3 * 4 / 2\\") 6","solution":"def evaluate_expression(expression): Evaluates a mathematical expression and returns the result. Handles integer numbers, '+', '-', '*', '/' and parentheses. Returns the result of the expression if valid, otherwise returns \\"invalid expression\\". try: # Using eval in a controlled environment return eval(expression, {\\"__builtins__\\": None}, {}) except: return \\"invalid expression\\""},{"question":"def partition_graph(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Partition the vertices of an undirected, unweighted graph into two sets such that no edge has both ends in the same set. If possible, return the partition, otherwise return \\"IMPOSSIBLE\\". >>> partition_graph(4, 4, [(1, 2), (1, 3), (2, 4), (3, 4)]) \\"POSSIBLEn1 2 2 1\\" >>> partition_graph(3, 3, [(1, 2), (1, 3), (2, 3)]) \\"IMPOSSIBLE\\" >>> partition_graph(1, 0, []) \\"POSSIBLEn1\\" >>> partition_graph(5, 3, [(1, 2), (3, 4), (4, 5)]) \\"POSSIBLEn1 2 1 2 1\\" >>> partition_graph(5, 4, [(1, 2), (3, 4), (4, 5), (3, 5)]) \\"IMPOSSIBLE\\"","solution":"def is_bipartite(n, edges): from collections import deque, defaultdict # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize color array, -1 means unvisited/undefined color = [-1] * (n + 1) # Implement BFS to check bipartiteness def bfs(source): queue = deque([source]) color[source] = 1 # Start coloring source with 1 while queue: u = queue.popleft() for v in graph[u]: if color[v] == -1: # If the vertex is not colored color[v] = 3 - color[u] # Alternate color queue.append(v) elif color[v] == color[u]: # If adjacent vertices have the same color return False return True # Check all connected components for vertex in range(1, n + 1): if color[vertex] == -1: # Not visited yet if not bfs(vertex): return \\"IMPOSSIBLE\\" # If bipartite, convert color array to result result = [\\"POSSIBLE\\"] result.append(' '.join(str(color[i]) for i in range(1, n + 1))) return 'n'.join(result) def partition_graph(n, m, edges): return is_bipartite(n, edges)"},{"question":"def count_distinct_palindromic_substrings(S: str) -> int: Function to count distinct palindromic substrings in the string S. >>> count_distinct_palindromic_substrings(\\"abba\\") 4 >>> count_distinct_palindromic_substrings(\\"aaa\\") 3 >>> count_distinct_palindromic_substrings(\\"abcde\\") 5 def fun_of_string(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Function to compute the fun of a given list of test cases. >>> fun_of_string(3, [(4, \\"abba\\"), (3, \\"aaa\\"), (5, \\"abcde\\")]) [4, 3, 5] >>> fun_of_string(1, [(1, \\"a\\")]) [1] >>> fun_of_string(2, [(2, \\"aa\\"), (6, \\"abcdef\\")]) [2, 6]","solution":"def count_distinct_palindromic_substrings(S): Function to count distinct palindromic substrings in the string S. n = len(S) palindromes = set() # Dynamic programming approach to find palindromes dp = [[False] * n for _ in range(n)] for length in range(1, n + 1): # length of the substring for i in range(n - length + 1): j = i + length - 1 # ending index of the substring if length == 1: dp[i][j] = True elif length == 2: dp[i][j] = (S[i] == S[j]) else: dp[i][j] = (S[i] == S[j]) and dp[i + 1][j - 1] if dp[i][j]: palindromes.add(S[i:j + 1]) return len(palindromes) def fun_of_string(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] result = count_distinct_palindromic_substrings(s) results.append(result) return results"},{"question":"def g(a: str, b: str) -> str: Compute the result of g(a, b) for two given binary strings of equal length. The operation g(a, b) is defined as follows: for each bit position i (0 <= i < len(a)), the resulting bit will be '1' if either a[i] or b[i] is '1', but not both (i.e., the xor operation). >>> g('1101', '1011') '0110' >>> g('0000', '0000') '0000' >>> g('1111', '1111') '0000' >>> g('1100', '0011') '1111' >>> g('1010', '0101') '1111' >>> g('0', '0') '0' >>> g('1', '0') '1' >>> g('0', '1') '1' >>> g('1', '1') '0'","solution":"def g(a, b): Returns the XOR result of two binary strings a and b. return ''.join('1' if a[i] != b[i] else '0' for i in range(len(a)))"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and then later selling one share of the stock. If no profit can be made, return 0. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([3, 3, 3, 3, 3]) 0 >>> maxProfit([1, 2]) 1 >>> maxProfit(list(range(10000, 0, -1))) 0","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and then later selling one share of the stock. If no profit can be made, return 0. min_price = float('inf') max_profit = 0 for price in prices: # Update the minimum price encountered so far if price < min_price: min_price = price # Calculate the potential profit if selling at the current price profit = price - min_price # Update the maximum profit if the current profit is greater if profit > max_profit: max_profit = profit return max_profit"},{"question":"def count_distinct_substrings(test_cases): Given a number of test cases, input string S, and integer K returns the number of distinct substrings of length K. >>> count_distinct_substrings([(3, \\"abcabc\\")]) [3] >>> count_distinct_substrings([(2, \\"aaaa\\")]) [1] from solution import count_distinct_substrings def test_single_sample_case(): assert count_distinct_substrings([(3, \\"abcabc\\")]) == [3] def test_single_sample_case_repeated_chars(): assert count_distinct_substrings([(2, \\"aaaa\\")]) == [1] def test_multiple_cases(): assert count_distinct_substrings([(3, \\"abcabc\\"), (2, \\"aaaa\\")]) == [3, 1] def test_empty_string(): assert count_distinct_substrings([(1, \\"\\")]) == [0] def test_no_substrings_of_length_k(): assert count_distinct_substrings([(3, \\"ab\\")]) == [0] def test_all_unique_substrings(): assert count_distinct_substrings([(1, \\"abcdef\\")]) == [6] def test_complete_overlap_substrings(): assert count_distinct_substrings([(2, \\"ababab\\")]) == [2] def test_long_k(): assert count_distinct_substrings([(6, \\"abcdef\\")]) == [1] def test_max_repetition(): assert count_distinct_substrings([(3, \\"aaaaaaaaaaaaaaa\\")]) == [1]","solution":"def count_distinct_substrings(test_cases): Given a number of test cases, input string S, and integer K returns the number of distinct substrings of length K. results = [] for k, s in test_cases: substrings = {s[i:i+k] for i in range(len(s) - k + 1)} results.append(len(substrings)) return results"},{"question":"def max_drone_distance(n: int, distances: List[int]) -> int: Returns the maximum distance any drone in the fleet can fly. >>> max_drone_distance(1, [100]) 100 >>> max_drone_distance(5, [300, 450, 500, 600, 550]) 600 >>> max_drone_distance(3, [200, 200, 200]) 200 >>> max_drone_distance(4, [400, 401, 402, 403]) 403 >>> max_drone_distance(100000, [100000] * 100000) 100000","solution":"def max_drone_distance(n, distances): Returns the maximum distance any drone in the fleet can fly. return max(distances)"},{"question":"def segregateAndSortString(s: str) -> str: Given a string containing letters, digits, and special characters, segregate the letters in one part, digits in another, and special characters in another. After segregation, the letters should be sorted in alphabetical order, digits should be sorted in ascending order, and special characters should remain in the order they appeared in the original string. Example 1: >>> segregateAndSortString(\\"c3b1a2!x@z#4\\") \\"abcxz1234!@#\\" Example 2: >>> segregateAndSortString(\\"A2c#5*d-1z!\\") \\"Acdz125#*-!\\"","solution":"def segregateAndSortString(s): letters = [] digits = [] special_chars = [] for char in s: if char.isalpha(): letters.append(char) elif char.isdigit(): digits.append(char) else: special_chars.append(char) letters.sort() digits.sort() return ''.join(letters) + ''.join(digits) + ''.join(special_chars)"},{"question":"def is_rotation(s1, s2): Returns True if s2 is a rotation of s1 by one position, False otherwise. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"hello\\", \\"ohlel\\") False >>> is_rotation(\\"abcdefg\\", \\"efgabcd\\") True","solution":"def is_rotation(s1, s2): Returns True if s2 is a rotation of s1 by one position, False otherwise. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"def countAnagramPairs(words: List[str]) -> int: Write a function countAnagramPairs() that takes a list of strings and returns the total number of pairs of strings that are anagrams of each other. Two strings are anagrams if one string can be formed by rearranging the letters of another. For example, \\"listen\\" and \\"silent\\" are anagrams. The function should consider only pairs (i, j) where i < j to avoid counting the same pair twice or considering a string as an anagram of itself. >>> countAnagramPairs([\\"cat\\", \\"dog\\", \\"bird\\"]) == 0 True >>> countAnagramPairs([\\"listen\\", \\"silent\\"]) == 1 True >>> countAnagramPairs([\\"listen\\", \\"silent\\", \\"enlist\\"]) == 3 True >>> countAnagramPairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"evil\\", \\"vile\\", \\"live\\"]) == 7 True >>> countAnagramPairs([\\"aaa\\", \\"aaa\\", \\"aaa\\", \\"aaa\\", \\"aaa\\"]) == 10 True >>> countAnagramPairs([\\"Listen\\", \\"Silent\\", \\"Enlist\\"]) == 0 True","solution":"def countAnagramPairs(words): Returns the total number of pairs of strings that are anagrams of each other from the given list. from collections import defaultdict # Dictionary to store sorted version of words as keys and their indices as values. anagram_dict = defaultdict(list) # Iterate over the list to populate the anagram_dict for i, word in enumerate(words): sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(i) # Calculate the number of anagram pairs from the anagram_dict count = 0 for indices in anagram_dict.values(): n = len(indices) if n > 1: count += (n * (n - 1)) // 2 # Calculate number of pairs return count"},{"question":"def length_longest_path(input: str) -> int: Returns the length of the longest absolute path to a file in the file system represented by the given input string. >>> length_longest_path(\\"dirntsubdir1ntsubdir2nttfile.ext\\") 20 >>> length_longest_path(\\"dirntsubdir1nttfile1.extnttsubsubdir1ntsubdir2nttsubsubdir2ntttfile2.ext\\") 32 >>> length_longest_path(\\"dirntsubdir1ntsubdir2\\") 0 >>> length_longest_path(\\"file.ext\\") 8 >>> length_longest_path(\\"dirntsubdir1nttfile1.extnttsubsubdir1ntttfile2.extntsubdir2nttsubsubdir2ntttfile3.ext\\") 32","solution":"def length_longest_path(input): Returns the length of the longest absolute path to a file in the file system represented by the given input string. max_length = 0 path_length = {0: 0} for line in input.split('n'): name = line.lstrip(\\"t\\") depth = len(line) - len(name) if '.' in name: # It's a file max_length = max(max_length, path_length[depth] + len(name)) else: # It's a directory path_length[depth + 1] = path_length[depth] + len(name) + 1 return max_length"},{"question":"def min_swaps_to_transform(S1: str, S2: str) -> int: Given two strings S1 and S2 of equal length consisting of '0' and '1' characters, determine the minimum number of swaps needed to turn S1 into S2, or return -1 if it's not possible. >>> min_swaps_to_transform(\\"1100\\", \\"1001\\") 1 >>> min_swaps_to_transform(\\"1010\\", \\"0101\\") 2 >>> min_swaps_to_transform(\\"1111\\", \\"1110\\") -1 >>> min_swaps_to_transform(\\"0101\\", \\"1010\\") 2 >>> min_swaps_to_transform(\\"1100\\", \\"0011\\") 2 pass def min_swaps_for_testcases(T: int, testcases: list) -> list: Determines the minimum number of swaps for multiple test cases. >>> testcases = [(\\"1100\\", \\"1001\\"), (\\"1010\\", \\"0101\\"), (\\"1111\\", \\"1110\\"), (\\"0101\\", \\"1010\\"), (\\"1100\\", \\"0011\\")] >>> min_swaps_for_testcases(5, testcases) [1, 2, -1, 2, 2] pass","solution":"def min_swaps_to_transform(S1, S2): Given two strings S1 and S2 of equal length consisting of '0' and '1' characters, determine the minimum number of swaps needed to turn S1 into S2, or return -1 if it's not possible. n = len(S1) # Check if the transformation is possible if sorted(S1) != sorted(S2): # Both must have the same count of '0' and '1' return -1 # Count mismatches count_10 = 0 # S1 has '1' while S2 has '0' count_01 = 0 # S1 has '0' while S2 has '1' for i in range(n): if S1[i] == '1' and S2[i] == '0': count_10 += 1 elif S1[i] == '0' and S2[i] == '1': count_01 += 1 # The number of swaps required is max(count_10, count_01) return max(count_10, count_01) def min_swaps_for_testcases(T, testcases): results = [] for i in range(T): S1, S2 = testcases[i] result = min_swaps_to_transform(S1, S2) results.append(result) return results"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"abababababa\\") 'ab' >>> longest_unique_substring(\\"abcdefgh\\") 'abcdefgh' >>> longest_unique_substring(\\"\\") '' >>> longest_unique_substring(\\"a\\") 'a' >>> longest_unique_substring(\\"ab\\") 'ab' >>> longest_unique_substring(\\"aa\\") 'a' >>> longest_unique_substring(\\"abc abc bb\\") 'abc '","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. n = len(s) if n == 0: return \\"\\" start, end, max_len, max_start = 0, 0, 0, 0 char_index = {} while end < n: if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end end += 1 if end - start > max_len: max_len = end - start max_start = start return s[max_start:max_start+max_len]"},{"question":"def title_formatter(T, titles): This function takes in a number of test cases T and a list of book titles. It returns the formatted titles following specific capitalization rules. Small words like 'and', 'the', 'in', 'of', etc. should always be in lowercase unless they are the first or last word of the title. Parameters: T (int): The number of titles. titles (List[str]): A list of book titles as strings. Returns: List[str]: A list of properly formatted book titles. def process_books(input_data): This function processes a multiline string containing the number of test cases and the titles. It splits the input data to extract titles and applies the title_formatter function. Parameters: input_data (str): A multiline string containing the number of titles followed by the titles. Returns: List[str]: A list of properly formatted book titles. def test_title_formatter_basic(): assert title_formatter(1, [\\"the great gatsby\\"]) == [\\"The Great Gatsby\\"] assert title_formatter(1, [\\"war and peace\\"]) == [\\"War and Peace\\"] assert title_formatter(1, [\\"catcher in the rye\\"]) == [\\"Catcher in the Rye\\"] def test_title_formatter_multiple_titles(): input_titles = [\\"to kill a mockingbird\\", \\"pride and prejudice\\", \\"alice in wonderland\\"] expected_output = [\\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"Alice in Wonderland\\"] assert title_formatter(3, input_titles) == expected_output def test_title_formatter_edge_cases(): assert title_formatter(1, [\\"by\\"]) == [\\"By\\"] assert title_formatter(1, [\\"the\\"]) == [\\"The\\"] assert title_formatter(1, [\\"\\"]) == [\\"\\"] def test_title_formatter_mixed_case(): assert title_formatter(1, [\\"Harry Potter and the Prisoner of azkaban\\"]) == [\\"Harry Potter and the Prisoner of Azkaban\\"] assert title_formatter(1, [\\"a Tale of Two Cities\\"]) == [\\"A Tale of Two Cities\\"] def test_process_books(): input_data = \\"3nthe great gatsbynwar and peacencatcher in the ryen\\" expected_output = [\\"The Great Gatsby\\", \\"War and Peace\\", \\"Catcher in the Rye\\"] assert process_books(input_data) == expected_output","solution":"def title_formatter(T, titles): This function takes in a number of test cases T and a list of book titles. It returns the formatted titles following specific capitalization rules. small_words = {'and', 'the', 'in', 'of', 'on', 'at', 'by', 'with', 'a', 'an', 'but', 'for', 'nor', 'or', 'so', 'yet'} def format_title(title): words = title.split() formatted_words = [] for i, word in enumerate(words): if word.lower() in small_words and i != 0 and i != len(words) - 1: formatted_words.append(word.lower()) else: formatted_words.append(word.capitalize()) return ' '.join(formatted_words) formatted_titles = [format_title(title) for title in titles] return formatted_titles def process_books(input_data): lines = input_data.strip().split('n') T = int(lines[0]) titles = lines[1:T+1] return title_formatter(T, titles)"},{"question":"def find_unique_number(arr): Given a list where every integer appears exactly twice except for one integer, this function returns the integer that appears only once. >>> find_unique_number([1, 2, 2, 3, 1]) 3 >>> find_unique_number([4, 3, 4, 3, 2, 2, 7]) 7 pass def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list. Each test case is represented as a tuple (N, arr): - N: the number of integers in the list - arr: the list of integers Returns a list of integers where each integer corresponds to the result of find_unique_number for the respective test case. >>> process_test_cases([(5, [1, 2, 2, 3, 1]), (7, [4, 3, 4, 3, 2, 2, 7]), (9, [9, 7, 8, 7, 8, 9, 10, 10, 11])]) [3, 7, 11] >>> process_test_cases([(3, [1, 1, 2]), (5, [3, 3, 4, 4, 5])]) [2, 5] pass","solution":"def find_unique_number(arr): Given a list where every integer appears exactly twice except for one integer, this function returns the integer that appears only once. xor_sum = 0 for num in arr: xor_sum ^= num return xor_sum def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list. Each test case is represented as a tuple (N, arr): - N: the number of integers in the list - arr: the list of integers Returns a list of integers where each integer corresponds to the result of find_unique_number for the respective test case. results = [] for N, arr in test_cases: unique_number = find_unique_number(arr) results.append(unique_number) return results"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. Args: nums (List[int]): List of integers Returns: List[int]: List of products >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6] >>> product_except_self([]) [] >>> product_except_self([1]) [1] >>> product_except_self([10, 5]) [5, 10]","solution":"def product_except_self(nums): Given a list of integers, returns a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. Args: nums (List[int]): List of integers Returns: List[int]: List of products n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate result by multiplying left and right products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def smallest_lexicographic_concat(word1: str, word2: str) -> str: Concatenate two strings to obtain the lexicographically smallest result. >>> smallest_lexicographic_concat(\\"abc\\", \\"xyz\\") \\"abcxyz\\" >>> smallest_lexicographic_concat(\\"ace\\", \\"bdf\\") \\"acebdf\\" >>> smallest_lexicographic_concat(\\"compare\\", \\"string\\") \\"comparestring\\"","solution":"def smallest_lexicographic_concat(word1, word2): Returns the lexicographically smallest result possible after concatenating two words. return min(word1 + word2, word2 + word1)"},{"question":"def reverse_words(input_string: str) -> str: Takes in a string of words and reverses each word individually while keeping the word order and punctuation intact. :param input_string: The input string of words :return: A string with each word reversed while retaining word order and punctuation >>> reverse_words('Hello world!') 'olleH !dlrow' >>> reverse_words(' This is an example! ') ' sihT si na !elpmaxe ' def test_reverse_words_normal(): assert reverse_words('Hello world!') == 'olleH !dlrow' def test_reverse_words_with_extra_spaces(): assert reverse_words(' This is an example! ') == ' sihT si na !elpmaxe ' def test_reverse_words_empty_string(): assert reverse_words('') == '' def test_reverse_words_with_only_spaces(): assert reverse_words(' ') == ' ' def test_reverse_words_single_word(): assert reverse_words('Python') == 'nohtyP' def test_reverse_words_punctuation(): assert reverse_words('Python is fun!') == 'nohtyP si !nuf' def test_reverse_words_mixed_case(): assert reverse_words('PyThOn') == 'nOhTyP'","solution":"def reverse_words(input_string): Takes in a string of words and reverses each word individually while keeping the word order and punctuation intact. # Split the string by spaces to maintain multiple spaces words = input_string.split(\\" \\") # Reverse each word and join them back with a space reversed_words = [word[::-1] for word in words] return \\" \\".join(reversed_words)"},{"question":"def steps_to_reduce_to_one(x: int) -> int: Returns the number of steps required to reduce x to 1. pass def process_input(test_cases: List[int]) -> List[int]: Processes multiple test cases and returns the results. pass # Sample Input and Output # Sample Input: # 5 # 3 # 6 # 19 # 50 # 100 # # Sample Output: # 7 # 8 # 20 # 24 # 25 from solution import steps_to_reduce_to_one, process_input def test_steps_to_reduce_to_one(): assert steps_to_reduce_to_one(3) == 7 assert steps_to_reduce_to_one(6) == 8 assert steps_to_reduce_to_one(19) == 20 assert steps_to_reduce_to_one(50) == 24 assert steps_to_reduce_to_one(100) == 25 def test_process_input(): test_cases = [3, 6, 19, 50, 100] expected_results = [7, 8, 20, 24, 25] assert process_input(test_cases) == expected_results","solution":"def steps_to_reduce_to_one(x): Returns the number of steps required to reduce x to 1. steps = 0 while x != 1: if x % 2 == 0: x //= 2 else: x = 3 * x + 1 steps += 1 return steps def process_input(test_cases): Processes multiple test cases and returns the results. results = [] for x in test_cases: results.append(steps_to_reduce_to_one(x)) return results"},{"question":"def longest_palindromic_substring(n: int, words: List[str]) -> str: Return the longest palindromic substring found among all the words. If multiple longest palindromic substrings exist, return the one that appears first lexicographically. >>> longest_palindromic_substring(5, [\\"racecar\\", \\"level\\", \\"radar\\", \\"refer\\", \\"deified\\"]) 'deified' >>> longest_palindromic_substring(3, [\\"banana\\", \\"civic\\", \\"rotor\\"]) 'anana' >>> longest_palindromic_substring(1, [\\"abccba\\"]) 'abccba' >>> longest_palindromic_substring(2, [\\"abc\\", \\"xyz\\"]) 'a' >>> longest_palindromic_substring(3, [\\"abcba\\", \\"cbabc\\", \\"bacab\\"]) 'abcba' >>> longest_palindromic_substring(4, [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 'a' >>> longest_palindromic_substring(3, [\\"abccba\\", \\"def\\", \\"gg\\"]) 'abccba' >>> longest_palindromic_substring(3, [\\"\\", \\"\\", \\"\\"]) ''","solution":"def longest_palindromic_substring(n, words): def is_palindrome(word): return word == word[::-1] # Initialize the variable to store the longest palindromic substring longest_palindrome = \\"\\" for word in words: length = len(word) for i in range(length): for j in range(i + 1, length + 1): substring = word[i:j] if is_palindrome(substring): # Check if the current palindrome is longer than the stored one # or if they are the same length but lexicographically smaller if (len(substring) > len(longest_palindrome) or (len(substring) == len(longest_palindrome) and substring < longest_palindrome)): longest_palindrome = substring return longest_palindrome"},{"question":"def find_minimum_max_pages(books: List[int], n: int, k: int) -> int: Find the minimum possible value for the maximum number of pages assigned to any employee. Parameters: books (List[int]): List of integers representing the page counts of the books. n (int): Number of books. k (int): Number of employees. Returns: int: Minimized maximum number of pages assigned to any employee. >>> find_minimum_max_pages([12, 34, 67, 90], 4, 2) 113 >>> find_minimum_max_pages([10, 20, 30, 40, 50], 5, 3) 60 >>> find_minimum_max_pages([10, 20, 30], 3, 3) 30 >>> find_minimum_max_pages([10, 20, 30, 40, 50], 5, 1) 150 >>> find_minimum_max_pages([10, 20, 30], 3, 4) -1","solution":"def is_feasible(books, n, k, max_pages): Check if it is possible to allocate books to k employees such that the maximum number of pages assigned to any employee is less than or equal to max_pages. required_employees = 1 current_sum = 0 for i in range(n): if current_sum + books[i] > max_pages: required_employees += 1 current_sum = books[i] if required_employees > k: return False else: current_sum += books[i] return True def find_minimum_max_pages(books, n, k): Find the minimum possible value for the maximum number of pages assigned to any employee. if n < k: return -1 start = max(books) end = sum(books) result = end while start <= end: mid = (start + end) // 2 if is_feasible(books, n, k, mid): result = mid end = mid - 1 else: start = mid + 1 return result"},{"question":"def is_zigzag_sequence(nums: List[int]) -> str: Determines if the given sequence is a zigzag sequence. Args: nums (list[int]): The sequence of integers. Returns: str: \\"Yes\\" if the sequence is a zigzag sequence, \\"No\\" otherwise. >>> is_zigzag_sequence([1, 3, 2, 4, 3]) == \\"Yes\\" >>> is_zigzag_sequence([5, 1, 2, 3]) == \\"No\\" >>> is_zigzag_sequence([1, 2, 1]) == \\"Yes\\" >>> is_zigzag_sequence([10, -10, 10, -10, 10]) == \\"Yes\\" >>> is_zigzag_sequence([1]) == \\"Yes\\" >>> is_zigzag_sequence([-5]) == \\"Yes\\" >>> is_zigzag_sequence([2, 1]) == \\"Yes\\"","solution":"def is_zigzag_sequence(nums): Determines if the given sequence is a zigzag sequence. Args: nums (list[int]): The sequence of integers. Returns: str: \\"Yes\\" if the sequence is a zigzag sequence, \\"No\\" otherwise. if len(nums) < 2: return \\"Yes\\" # A single number or an empty sequence is considered a zigzag sequence. # Calculate the differences between consecutive elements diffs = [nums[i] - nums[i - 1] for i in range(1, len(nums))] # Check the zigzag pattern in differences for i in range(1, len(diffs)): if (diffs[i - 1] > 0) == (diffs[i] > 0): return \\"No\\" return \\"Yes\\""},{"question":"def canNavigate(grid: List[str]) -> bool: Determine if you can navigate from the top-left corner of the grid to the bottom-right corner. The grid consists of 'G' for grass and 'R' for rock. >>> canNavigate([\\"GGG\\", \\"GRG\\", \\"GGG\\"]) True >>> canNavigate([\\"GGGR\\", \\"GRRG\\", \\"GGRG\\", \\"RRRG\\"]) False","solution":"def canNavigate(grid): from collections import deque if not grid: return False n, m = len(grid), len(grid[0]) if grid[0][0] != 'G' or grid[-1][-1] != 'G': return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 'G' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"import math from typing import List def is_triangular(X: int) -> int: Determines if a number X is a triangular number. If it is, returns the integer n such that X == T_n. Otherwise, returns -1. def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases and returns the results. Unit Tests: def test_is_triangular(): assert is_triangular(3) == 2 assert is_triangular(10) == 4 assert is_triangular(5) == -1 assert is_triangular(6) == 3 assert is_triangular(15) == 5 assert is_triangular(21) == 6 assert is_triangular(1) == 1 assert is_triangular(2) == -1 assert is_triangular(0) == -1 assert is_triangular(55) == 10 assert is_triangular(56) == -1 def test_large_numbers(): assert is_triangular(500500) == 1000 assert is_triangular(500501) == -1 assert is_triangular(50005000) == 10000 assert is_triangular(50005001) == -1 def test_process_test_cases(): assert process_test_cases([3, 10, 5]) == [2, 4, -1] assert process_test_cases([1, 3, 6, 10, 15, 21]) == [1, 2, 3, 4, 5, 6] assert process_test_cases([2, 7, 8, 14, 16]) == [-1, -1, -1, -1, -1]","solution":"import math def is_triangular(X): Determines if a number X is a triangular number. If it is, returns the integer n such that X == T_n. Otherwise, returns -1. # The quadratic equation we need to solve n(n+1)/2 = X # 2X = n^2 + n # n^2 + n - 2X = 0 # Solve using the quadratic formula: n = (-b +- sqrt(b^2 - 4ac)) / 2a # For our equation, a = 1, b = 1, c = -2X a, b, c = 1, 1, -2 * X discriminant = b**2 - 4 * a * c if discriminant < 0: return -1 sqrt_discriminant = math.isqrt(discriminant) if sqrt_discriminant * sqrt_discriminant != discriminant: return -1 n1 = (-b + sqrt_discriminant) // (2 * a) if n1 * (n1 + 1) // 2 == X and n1 > 0: return n1 return -1 def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for X in test_cases: results.append(is_triangular(X)) return results"},{"question":"from typing import List def minIncrements(arr: List[int]) -> int: Given an array of integers, this function modifies the array such that every element has a unique value by incrementing some of the elements by 1 as many times as needed. The function returns the minimum number of increments needed. >>> minIncrements([1, 2, 2]) 1 >>> minIncrements([3, 2, 1, 2, 1, 7]) 6 >>> minIncrements([1, 2, 3, 4, 5]) 0 >>> minIncrements([1, 1, 1, 1, 1]) 10 >>> minIncrements([1000000000, 1000000000, 1000000000]) 3 >>> minIncrements([1, 3, 5, 7, 9, 9]) 1 >>> minIncrements([1]) 0","solution":"def minIncrements(arr): Given an array of integers, this function modifies the array such that every element has a unique value by incrementing some of the elements by 1 as many times as needed. The function returns the minimum number of increments needed. arr.sort() increments = 0 for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: needed_increment = arr[i - 1] - arr[i] + 1 arr[i] += needed_increment increments += needed_increment return increments"},{"question":"def number_of_ways(n: int) -> int: Calculate the number of distinct ways to plant flowers around the trees following given rules. No two consecutive trees should have flowers. The answer should be output modulo 10^9 + 7. >>> number_of_ways(2) 3 >>> number_of_ways(3) 5 >>> number_of_ways(4) 8","solution":"MOD = 10**9 + 7 def number_of_ways(n): if n == 0: return 1 if n == 1: return 2 # To calculate fibonacci(n+2) % MOD in O(log n) time def matrix_mult(a, b): # Matrix multiplication return [ [(a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD, (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD], [(a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD, (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD] ] def matrix_pow(mat, exp): res = [[1, 0], [0, 1]] # Identity matrix while exp: if exp % 2 == 1: res = matrix_mult(res, mat) mat = matrix_mult(mat, mat) exp //= 2 return res fib_matrix = [[1, 1], [1, 0]] result_matrix = matrix_pow(fib_matrix, n + 1) return result_matrix[0][0] # Example usage: # print(number_of_ways(4)) # Output: 8"},{"question":"def sort_titles(titles): Sorts a list of book titles in lexicographical order. Args: titles (list): A list of strings containing book titles. Returns: list: A list of book titles sorted in lexicographical order. Example: >>> sort_titles([\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"1984\\"]) [\\"1984\\", \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] # Write your code here if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split('n') n = int(data[0]) titles = data[1:n+1] sorted_titles = sort_titles(titles) for title in sorted_titles: print(title)","solution":"def sort_titles(titles): Sorts a list of book titles in lexicographical order. Args: titles (list): A list of strings containing book titles. Returns: list: A list of book titles sorted in lexicographical order. return sorted(titles) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split('n') n = int(data[0]) titles = data[1:n+1] sorted_titles = sort_titles(titles) for title in sorted_titles: print(title)"},{"question":"def filter_products(product_list, category, sub_cat_min): Filter products based on a given category and a sub-category minimum threshold. Args: product_list (list): List of product names. category (str): Category character. sub_cat_min (int): Sub-category minimum threshold. Returns: list: List of products that belong to the given category and have a sub-category value greater than or equal to the given threshold. >>> filter_products([\\"A1234\\", \\"B5678\\", \\"A4321\\", \\"C9999\\", \\"A1111\\", \\"B3333\\"], \\"A\\", 1500) [\\"A4321\\"] >>> filter_products([], \\"A\\", 1000) [] >>> filter_products([\\"B5678\\", \\"B3333\\"], \\"A\\", 1000) [] >>> filter_products([\\"A123\\", \\"A150\\", \\"A900\\"], \\"A\\", 1000) [] >>> filter_products([\\"A4321\\", \\"A5670\\", \\"B1234\\", \\"A123\\"], \\"A\\", 1200) [\\"A4321\\", \\"A5670\\"] >>> filter_products([\\"A1234\\", \\"B5678\\", \\"A4321\\", \\"C9999\\", \\"A1111\\", \\"B3333\\"], \\"B\\", 3500) [\\"B5678\\"]","solution":"def filter_products(product_list, category, sub_cat_min): Filters the products based on given category and sub-category minimum threshold. Args: product_list (list): List of product names. category (str): Category character. sub_cat_min (int): Sub-category minimum threshold. Returns: list: List of products that belong to the given category and have sub-category value >= sub_cat_min. filtered_products = [] for product in product_list: if product[0] == category and int(product[1:]) >= sub_cat_min: filtered_products.append(product) return filtered_products"},{"question":"def final_string_length(s: str) -> int: Returns the length of the final string after performing the operation as many times as possible. >>> final_string_length(\\"abbaca\\") 2 >>> final_string_length(\\"aab\\") 1","solution":"def final_string_length(s): Returns the length of the final string after performing the operation as many times as possible. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def find_common_prefix(strs): Returns the longest common prefix among a list of strings. If there is no common prefix, returns an empty string. >>> find_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> find_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" from typing import List def test_common_prefix_general_case(): assert find_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_common_prefix_no_common_case(): assert find_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_common_prefix_all_identical(): assert find_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) == \\"test\\" def test_common_prefix_one_empty_string(): assert find_common_prefix([\\"\\", \\"prefix\\", \\"pre\\"]) == \\"\\" def test_common_prefix_mixed_length_strings(): assert find_common_prefix([\\"interview\\", \\"inter\\", \\"internet\\"]) == \\"inter\\" def test_common_prefix_single_string(): assert find_common_prefix([\\"alone\\"]) == \\"alone\\" def test_common_prefix_empty_list(): assert find_common_prefix([]) == \\"\\" def test_common_prefix_no_matching_start(): assert find_common_prefix([\\"a\\", \\"b\\", \\"c\\"]) == \\"\\"","solution":"def find_common_prefix(strs): Returns the longest common prefix among a list of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Find the shortest string in the list shortest_str = min(strs, key=len) for i, ch in enumerate(shortest_str): for other in strs: if other[i] != ch: return shortest_str[:i] return shortest_str"},{"question":"def largest_land_square(N: int, M: int, grid: List[List[int]]) -> int: This function finds the side length of the largest square consisting entirely of land (0) within the given grid. >>> largest_land_square(4, 5, [[0, 1, 0, 0, 0], [1, 0, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0]]) 2 >>> largest_land_square(3, 3, [[1, 1, 1], [1, 0, 1], [1, 1, 1]]) 1 >>> largest_land_square(3, 4, [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 3 >>> largest_land_square(2, 2, [[1, 1], [1, 1]]) 0 >>> largest_land_square(1, 1, [[0]]) 1 >>> largest_land_square(1, 1, [[1]]) 0","solution":"def largest_land_square(N, M, grid): This function finds the side length of the largest square consisting entirely of land (0) within the given grid. if N == 0 or M == 0: return 0 dp = [[0] * M for _ in range(N)] max_side_length = 0 for i in range(N): for j in range(M): if grid[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def isBalanced(helper_root): Returns True if the BST is balanced, otherwise False. >>> isBalanced(TreeNode(1)) == True >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(6) >>> isBalanced(root) == True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> isBalanced(root) == False","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def isBalanced(helper_root): Returns True if the BST is balanced, otherwise False. def checkHeight(root): if root is None: return 0 left_height = checkHeight(root.left) if left_height == -1: return -1 right_height = checkHeight(root.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 else: return max(left_height, right_height) + 1 return checkHeight(helper_root) != -1"},{"question":"def rob(money: List[int]) -> int: Returns the maximum amount of money the thief can rob without alerting the police. >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([2, 1, 1, 2]) 4 >>> rob([5, 3, 4, 11, 2]) 16","solution":"def rob(money): Returns the maximum amount of money the thief can rob without alerting the police. n = len(money) if n == 0: return 0 if n == 1: return money[0] dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"def compute_knowledge_levels(n: int, m: int, most_knowledgeable_ids: List[int], visibility_gap: List[int]) -> List[int]: Compute the knowledge level of each employee given their IDs and visibility gap for the most knowledgeable employees in a circle. Args: n (int): The number of employees. m (int): The number of given knowledgeable employees. most_knowledgeable_ids (List[int]): The IDs of the most knowledgeable employees. visibility_gap (List[int]): The number of people each given employee can see before another knowledgeable peer. Returns: List[int]: The employee knowledge levels in the order of their IDs from 1 to n. Examples: >>> compute_knowledge_levels(8, 3, [1, 5, 7], [2, 4, 2]) [1, 8, 8, 8, 2, 8, 3, 8] >>> compute_knowledge_levels(5, 2, [2, 5], [3, 1]) [5, 1, 5, 5, 2]","solution":"def compute_knowledge_levels(n, m, most_knowledgeable_ids, visibility_gap): # Create a list to store knowledge levels with default value n (the highest level initially) knowledge_levels = [n] * n # Sort the most_knowledgeable_ids and their associated visibility gaps together sorted_pairs = sorted(zip(most_knowledgeable_ids, visibility_gap)) # Assign knowledge levels starting from 1 to m based on the sorted most knowledgeable ids for level, (employee_id, _) in enumerate(sorted_pairs, 1): knowledge_levels[employee_id - 1] = level # Return the result as a list of knowledge levels return knowledge_levels"},{"question":"def count_valid_binary_strings(n: int) -> int: Given an integer n, return the number of valid binary strings of length n that do not contain consecutive '1's. A binary string is a string that consists only of the characters '0' and '1'. >>> count_valid_binary_strings(3) 5 >>> count_valid_binary_strings(4) 8 >>> count_valid_binary_strings(1) 2 >>> count_valid_binary_strings(2) 3 >>> count_valid_binary_strings(0) 0","solution":"def count_valid_binary_strings(n): Returns the number of valid binary strings of length n that do not contain consecutive '1's. if n == 0: return 0 # dp[i][0] will store the count of valid strings of length i ending in '0' # dp[i][1] will store the count of valid strings of length i ending in '1' dp = [[0, 0] for _ in range(n+1)] # Base cases dp[1][0] = 1 dp[1][1] = 1 # Fill the dp array for i in range(2, n+1): dp[i][0] = dp[i-1][0] + dp[i-1][1] dp[i][1] = dp[i-1][0] # The answer is the sum of valid strings of length n ending in '0' and ending in '1' return dp[n][0] + dp[n][1]"},{"question":"def min_wood_required(n: int, houses: List[int]) -> int: Returns the minimum amount of wood required to connect all houses. Parameters: n : int The number of houses. houses : list of int The positions of the houses on the coordinate line. >>> min_wood_required(4, [1, 3, 4, 6]) 5 >>> min_wood_required(3, [10, 1, 5]) 9","solution":"def min_wood_required(n, houses): Returns the minimum amount of wood required to connect all houses. Parameters: n : int The number of houses. houses : list of int The positions of the houses on the coordinate line. # Sort the positions of the houses houses.sort() # Calculate the total wood required by connecting houses sequentially total_wood = 0 for i in range(1, n): total_wood += houses[i] - houses[i - 1] return total_wood"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a string can be rearranged to form a palindrome. Examples: >>> can_form_palindrome(\\"civic\\") == True >>> can_form_palindrome(\\"ivicc\\") == True >>> can_form_palindrome(\\"hello\\") == False","solution":"def can_form_palindrome(s): Determines if a string can be rearranged to form a palindrome. from collections import Counter # Count the occurrences of each character in the string char_counts = Counter(s) # We can form a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= 1"},{"question":"from typing import List def partition_equal_sum(arr: List[int]) -> List[List[int]]: Determine if it's possible to partition the list into two non-empty subsets with equal sum. If possible, return the subsets; otherwise, return []. >>> partition_equal_sum([1, 5, 11, 5]) [[1, 5, 5], [11]] >>> partition_equal_sum([1, 2, 3, 5]) []","solution":"from itertools import combinations def partition_equal_sum(arr): Determine if it's possible to partition the list into two non-empty subsets with equal sum. If possible, return the subsets; otherwise, return []. total_sum = sum(arr) # If the total sum is odd, we can't partition it into two equal subsets. if total_sum % 2 != 0: return [] target = total_sum // 2 # Try to find any combination of elements that sums to target. n = len(arr) for r in range(1, n): for comb in combinations(arr, r): if sum(comb) == target: subset1 = list(comb) subset2 = arr[:] for item in subset1: subset2.remove(item) return [subset1, subset2] return []"},{"question":"import math from typing import List def minimum_packs(n: int, m: int, recipes: List[List[int]], packs: List[int]) -> List[int]: Determine the minimum number of packs of each ingredient to buy so that Alice can make any of her recipes without falling short on any required ingredients. >>> minimum_packs(3, 3, [[3, 2, 5], [4, 1, 2], [1, 3, 4]], [2, 1, 3]) [2, 3, 2] >>> minimum_packs(2, 2, [[1, 1], [1, 1]], [1, 1]) [1, 1] >>> minimum_packs(2, 2, [[1000, 2000], [500, 1500]], [100, 300]) [10, 7] >>> minimum_packs(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [1, 1, 1]) [0, 0, 0] >>> minimum_packs(1, 3, [[5, 7, 3]], [1, 2, 1]) [5, 4, 3] >>> minimum_packs(2, 2, [[0, 0], [0, 0]], [2, 3]) [0, 0]","solution":"import math def minimum_packs(n, m, recipes, packs): max_requirements = [0] * m # Find maximum requirement for each ingredient across all recipes for recipe in recipes: for j in range(m): max_requirements[j] = max(max_requirements[j], recipe[j]) # Calculate the minimum packs needed for each ingredient min_packs = [0] * m for j in range(m): min_packs[j] = math.ceil(max_requirements[j] / packs[j]) return min_packs"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Finds the length of the longest palindromic subsequence in a given string. Args: s (str): A single string containing only lowercase English letters. Returns: int: The length of the longest palindromic subsequence. Examples: >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2","solution":"def longest_palindromic_subsequence(s): Finds the length of the longest palindromic subsequence in a given string. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> str: Given a string s and an integer k, return the longest contiguous substring that contains at most k distinct characters. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) \\"ece\\" >>> longest_substring_with_k_distinct(\\"aa\\", 1) \\"aa\\" >>> longest_substring_with_k_distinct(\\"aabbcc\\", 2) \\"aabb\\" >>> longest_substring_with_k_distinct(\\"a\\", 1) \\"a\\" >>> longest_substring_with_k_distinct(\\"aaaaaa\\", 1) \\"aaaaaa\\" >>> longest_substring_with_k_distinct(\\"abcdefg\\", 100) \\"abcdefg\\" >>> longest_substring_with_k_distinct(\\"abc\\", 0) \\"\\" >>> longest_substring_with_k_distinct(\\"\\", 2) \\"\\"","solution":"def longest_substring_with_k_distinct(s: str, k: int) -> str: from collections import defaultdict n = len(s) if n * k == 0: return \\"\\" # Sliding window left and right pointers left, right = 0, 0 # Hashmap to store the count of characters in the current window hashmap = defaultdict(int) max_len = 1 max_substr = s[0] while right < n: # Add the current character to the hashmap hashmap[s[right]] += 1 # When the window contains more than 'k' distinct characters, shrink the window while len(hashmap) > k: hashmap[s[left]] -= 1 if hashmap[s[left]] == 0: del hashmap[s[left]] left += 1 current_window_length = right - left + 1 if current_window_length > max_len: max_len = current_window_length max_substr = s[left:right + 1] right += 1 return max_substr"},{"question":"def calculate_final_price(cart_items, coupons): Calculate the final price of the cart after applying the best discount coupon. Parameters: cart_items (list of tuples): Each tuple contains the price (P) and quantity (Q) of an item. coupons (list of tuples): Each tuple contains the minimum cart value (X) and discount percentage (D). Returns: float: The final price of the cart. Examples: >>> calculate_final_price([(100, 2), (200, 1), (300, 3)], [(500, 10), (1000, 20)]) 1040.0 >>> calculate_final_price([(100, 2), (200, 1), (300, 3)], []) 1300.0","solution":"def calculate_final_price(cart_items, coupons): Calculate the final price of the cart after applying the best discount coupon. Parameters: cart_items (list of tuples): Each tuple contains the price (P) and quantity (Q) of an item. coupons (list of tuples): Each tuple contains the minimum cart value (X) and discount percentage (D). Returns: float: The final price of the cart. # Calculate the total cart value total_cart_value = sum(p * q for p, q in cart_items) # Initialize the best discount best_discount = 0 # Find the best applicable discount for x, d in coupons: if total_cart_value >= x: discount_amount = total_cart_value * (d / 100) if discount_amount > best_discount: best_discount = discount_amount # Calculate the final price after applying the best discount final_price = total_cart_value - best_discount return final_price"},{"question":"def prime_factors(n: int) -> List[int]: Return the prime factors of the given integer n in ascending order. >>> prime_factors(28) # [2, 2, 7] >>> prime_factors(45) # [3, 3, 5] >>> prime_factors(100) # [2, 2, 5, 5]","solution":"def prime_factors(n): Return the prime factors of the given integer n in ascending order. factors = [] divisor = 2 while n >= 2: while n % divisor == 0: factors.append(divisor) n //= divisor divisor += 1 return factors"},{"question":"def min_operations_to_make_lucky(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to make each array lucky. A sequence of integers is called lucky if it has exactly two consecutive identical numbers. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases, each represented as a tuple where the first element is the number of elements in the array and the second element is the array itself. Returns: List[int]: A list of integers representing the minimum number of operations required to make each array lucky. >>> min_operations_to_make_lucky(2, [(6, [1, 2, 3, 4, 5, 6]), (5, [3, 5, 3, 3, 7])]) [1, 0] >>> min_operations_to_make_lucky(1, [(4, [2, 2, 2, 2])]) [0]","solution":"def min_operations_to_make_lucky(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] found = False for j in range(n - 1): if a[j] == a[j + 1]: found = True break if found: results.append(0) else: results.append(1) return results"},{"question":"from typing import List def calculate_final_scores(test_cases: List[List[int]]) -> List[str]: Calculate the final score based on the rules provided in the coding task. The final score is the average of the participant's top three highest scores, or all their scores if they have fewer than three. Args: test_cases: A list of test cases where each test case is a list of integers representing the participant's scores. Returns: A list of strings representing the final scores for each test case, formatted to six decimal places. Example: >>> calculate_final_scores([[50, 95, 85, 75, 90], [45, 70]]) [\\"90.000000\\", \\"57.500000\\"] def parse_input(input_string: str) -> List[List[int]]: Parse the input string to extract the list of test cases as specified in the coding task. Args: input_string: A single string containing all the input information. Returns: A list of test cases where each test case is a list of integers representing the participant's scores. Example: >>> parse_input(\\"2n5n50 95 85 75 90n2n45 70\\") [[50, 95, 85, 75, 90], [45, 70]] import pytest def test_calculate_final_scores(): # Test case 1 test_cases = [[50, 95, 85, 75, 90], [45, 70]] expected = [\\"90.000000\\", \\"57.500000\\"] assert calculate_final_scores(test_cases) == expected # Test case 2 test_cases = [[100, 100, 100], [10, 20, 30, 40], [50]] expected = [\\"100.000000\\", \\"30.000000\\", \\"50.000000\\"] assert calculate_final_scores(test_cases) == expected # Test case 3 with less than 3 scores test_cases = [[0, 0], [100, 100], [0]] expected = [\\"0.000000\\", \\"100.000000\\", \\"0.000000\\"] assert calculate_final_scores(test_cases) == expected def test_parse_input(): input_string = \\"2n5n50 95 85 75 90n2n45 70\\" expected = [[50, 95, 85, 75, 90], [45, 70]] assert parse_input(input_string) == expected input_string = \\"3n3n100 100 100n4n10 20 30 40n1n50\\" expected = [[100, 100, 100], [10, 20, 30, 40], [50]] assert parse_input(input_string) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_final_scores(test_cases): results = [] for scores in test_cases: if len(scores) < 3: final_score = sum(scores) / len(scores) else: top_three = sorted(scores, reverse=True)[:3] final_score = sum(top_three) / 3 results.append(f\\"{final_score:.6f}\\") return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0].strip()) test_cases = [] line_idx = 1 for _ in range(T): N = int(lines[line_idx].strip()) scores = list(map(int, lines[line_idx + 1].strip().split())) test_cases.append(scores) line_idx += 2 return test_cases"},{"question":"def extract_first_email(S: str) -> str: Extract the first email address from the string S. >>> extract_first_email(\\"Hello, my email is example@test.com and I also use another_email123@domain.org for work.\\") \\"example@test.com\\" >>> extract_first_email(\\"Emails: first@mail.com, second@mail.com\\") \\"first@mail.com\\" >>> extract_first_email(\\"There is no email here.\\") \\"No email found\\" >>> extract_first_email(\\"Contact me at john.doe@mail.com or jane.doe@another.com\\") \\"john.doe@mail.com\\" >>> extract_first_email(\\"My work email: user_name123@work-domain.net is used frequently.\\") \\"user_name123@work-domain.net\\" >>> extract_first_email(\\"test1@gmail.com and test2@gmail.com are two emails.\\") \\"test1@gmail.com\\"","solution":"import re def extract_first_email(S): Extract the first email address from the string S. Parameters: S (str): The input string. Returns: str: The first email address found in the string, or \\"No email found\\" if no email is present. email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}' match = re.search(email_pattern, S) return match.group(0) if match else \\"No email found\\""},{"question":"def griffin_operations(operations): Vova is playing another game called \\"Guardians of the Forest\\" where he needs to manage a group of mystical creatures called \\"Griffins\\". Each Griffin has a unique magic number, and Vova wants to form the strongest possible squad for defending the forest. This squad formation is defined by specific rules regarding the magic numbers of the Griffins. Vova can perform three types of operations on the squad of Griffins: * 1 mi — One Griffin with magic number mi joins Vova's squad. * 2 mi — One Griffin with magic number mi leaves Vova's squad (it is guaranteed that there is at least one such Griffin in Vova's squad at this moment). * 3 — Vova wants to know the maximum magic number among the Griffins currently in the squad. Note that each Griffin's magic number is a unique integer. Args: operations (List[Tuple[int, Optional[int]]]): List of operations. Returns: List[int]: List of maximum magic numbers for each query of type 3. Example: >>> griffin_operations([(1, 5), (1, 7), (3,), (2, 7), (1, 3), (3,)]) [7, 5] >>> griffin_operations([(1, 10), (1, 20), (1, 30), (3,), (2, 30), (3,)]) [30, 20] pass from solution import griffin_operations def test_griffin_operations_example(): operations = [ (1, 5), (1, 7), (3,), (2, 7), (1, 3), (3,) ] assert griffin_operations(operations) == [7, 5] def test_griffin_operations_add_and_check(): operations = [ (1, 10), (1, 20), (1, 30), (3,), (2, 30), (3, ) ] assert griffin_operations(operations) == [30, 20] def test_griffin_operations_remove_all_check(): operations = [ (1, 2), (1, 5), (1, 8), (3,), (2, 8), (2, 5), (2, 2) ] assert griffin_operations(operations) == [8] def test_griffin_operations_single_operation(): operations = [ (1, 100), (3, ) ] assert griffin_operations(operations) == [100] def test_griffin_operations_duplicate_adds(): operations = [ (1, 8), (1, 8), (1, 8), (3,), (2, 8) ] assert griffin_operations(operations) == [8]","solution":"import heapq class GriffinSquad: def __init__(self): self.squad = [] self.present = set() self.removed = set() def add_griffin(self, mi): heapq.heappush(self.squad, -mi) self.present.add(mi) def remove_griffin(self, mi): self.present.remove(mi) self.removed.add(mi) def max_magic_number(self): while -self.squad[0] in self.removed: removed_item = -heapq.heappop(self.squad) self.removed.remove(removed_item) return -self.squad[0] def griffin_operations(operations): squad = GriffinSquad() results = [] for op in operations: if op[0] == 1: squad.add_griffin(op[1]) elif op[0] == 2: squad.remove_griffin(op[1]) elif op[0] == 3: results.append(squad.max_magic_number()) return results"},{"question":"def min_cables(N: int) -> int: Calculate the minimum number of cables required to connect N servers in such a way that every server is reachable from any other server. Parameters: N (int): Number of servers Returns: int: Minimum number of cables required >>> min_cables(4) 3 >>> min_cables(5) 4 >>> min_cables(1) 0 >>> min_cables(0) 0 >>> min_cables(1000000000) 999999999 from solution import min_cables def test_min_cables_single_server(): assert min_cables(1) == 0 def test_min_cables_two_servers(): assert min_cables(2) == 1 def test_min_cables_multiple_servers(): assert min_cables(4) == 3 assert min_cables(5) == 4 assert min_cables(6) == 5 def test_min_cables_large_number_of_servers(): assert min_cables(1000000000) == 999999999 def test_min_cables_zero_servers(): assert min_cables(0) == 0 # Although the constraint says minimum 1, this is for robustness","solution":"def min_cables(N): This function calculates the minimum number of cables required to connect N servers in such a way that they are all reachable from each other. return max(0, N - 1)"},{"question":"def subsequence_sum_exists(nums: List[int], X: int) -> str: Determines if there exists a non-empty subsequence of nums whose sum is exactly X. >>> subsequence_sum_exists([1, 2, 3, 4, 5], 9) \\"YES\\" >>> subsequence_sum_exists([2, 4, 6, 8, 10, 12], 15) \\"NO\\" >>> subsequence_sum_exists([5], 5) \\"YES\\" >>> subsequence_sum_exists([3], 5) \\"NO\\" >>> subsequence_sum_exists([1, 1, 1, 1, 1], 3) \\"YES\\" >>> subsequence_sum_exists([5, 10, 15], 100) \\"NO\\" >>> subsequence_sum_exists([34, 23, 1, 24, 75, 33, 54, 8], 143) \\"YES\\"","solution":"def subsequence_sum_exists(nums, X): Determines if there exists a non-empty subsequence of nums whose sum is exactly X. :param nums: List of integers. :param X: Target sum. :return: 'YES' if such a subsequence exists, otherwise 'NO'. # Number of elements in nums n = len(nums) # Generate all possible non-empty subsequences from itertools import combinations for r in range(1, n + 1): for subsequence in combinations(nums, r): if sum(subsequence) == X: return \\"YES\\" return \\"NO\\""},{"question":"def is_prime(num): Check if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def can_be_expressed_as_sum_of_two_primes(n): Check if the number n can be expressed as the sum of two prime numbers. Parameters: n (int): The number to check for the prime sum representation. Returns: str: \\"YES\\" if the number can be expressed as the sum of two prime numbers, otherwise \\"NO\\". >>> can_be_expressed_as_sum_of_two_primes(34) \\"YES\\" >>> can_be_expressed_as_sum_of_two_primes(4) \\"YES\\" >>> can_be_expressed_as_sum_of_two_primes(11) \\"NO\\" >>> can_be_expressed_as_sum_of_two_primes(10) \\"YES\\" >>> can_be_expressed_as_sum_of_two_primes(1000000) \\"YES\\" >>> can_be_expressed_as_sum_of_two_primes(28) \\"YES\\"","solution":"def is_prime(num): Check if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def can_be_expressed_as_sum_of_two_primes(n): Check if the number n can be expressed as the sum of two prime numbers. for i in range(2, n // 2 + 1): if is_prime(i) and is_prime(n - i): return \\"YES\\" return \\"NO\\""},{"question":"def determine_winner(a: str, b: str) -> str: Determines the winner of the game played by Alice and Bob. Alice can only increment characters in string \`a\` while Bob can only decrement characters in string \`b\`. :param a: first string :param b: second string of the same length as \`a\` :return: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins >>> determine_winner(\\"abc\\", \\"bcd\\") \\"Alice\\" >>> determine_winner(\\"zzz\\", \\"aaa\\") \\"Bob\\" >>> determine_winner(\\"abc\\", \\"bac\\") \\"Bob\\" from solution import determine_winner def test_case_1(): assert determine_winner(\\"abc\\", \\"bcd\\") == \\"Alice\\" def test_case_2(): assert determine_winner(\\"zzz\\", \\"aaa\\") == \\"Bob\\" def test_case_3(): assert determine_winner(\\"abc\\", \\"bac\\") == \\"Bob\\" def test_case_4(): assert determine_winner(\\"abcd\\", \\"abcd\\") == \\"Bob\\" def test_case_5(): assert determine_winner(\\"abcde\\", \\"fghij\\") == \\"Alice\\"","solution":"def determine_winner(a, b): Determines the winner of the game played by Alice and Bob. Alice can only increment characters in string \`a\` while Bob can only decrement characters in string \`b\`. :param a: string a :param b: string b :return: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins score = 0 for char_a, char_b in zip(a, b): if char_a == char_b: continue elif char_a > char_b: score -= 1 else: score += 1 if score > 0: return \\"Alice\\" elif score < 0: return \\"Bob\\" else: # If score is 0, it means strings are already the same or balanced moves are made return \\"Bob\\""},{"question":"from typing import List def find_pythagorean_triplet(arr: List[int]) -> bool: Given a list of integers, find out if there are any three distinct elements a, b, c such that a^2 + b^2 = c^2, i.e., if there exists a Pythagorean triplet in the list. >>> find_pythagorean_triplet([3, 1, 4, 6, 5]) True >>> find_pythagorean_triplet([10, 4, 6, 12, 5]) False >>> find_pythagorean_triplet([5]) False >>> find_pythagorean_triplet([1, 2, 3]) False >>> find_pythagorean_triplet([5, 12, 13]) True >>> find_pythagorean_triplet([1000, 1001, 1002]) False >>> import random >>> random.seed(0) >>> large_data = random.sample(range(1, 100001), 1000) >>> find_pythagorean_triplet(large_data) False >>> find_pythagorean_triplet([1] * 1000) False >>> find_pythagorean_triplet([3, 5, 12, 5, 13, 9, 15]) True","solution":"from typing import List def find_pythagorean_triplet(arr: List[int]) -> bool: Find if there is a Pythagorean triplet in the list. n = len(arr) # Create a list of squares of the given array elements squares = [x ** 2 for x in arr] # Sort the list of squares squares.sort() # Check for a triplet (c^2 == a^2 + b^2) for i in range(n - 1, 1, -1): c_squared = squares[i] a = 0 b = i - 1 while a < b: if squares[a] + squares[b] == c_squared: return True elif squares[a] + squares[b] < c_squared: a += 1 else: b -= 1 return False"},{"question":"def longest_palindromic_subsequence(S: str, queries: List[Tuple[int, int]]) -> List[int]: Given a string S and a list of queries that consist of substring indices (L, R), find the length of the longest palindromic subsequence for each substring S[L:R]. Args: S: The input string. queries: A list of tuples where each tuple contains two integers L and R representing the substring indices. Returns: A list of integers where each integer is the length of the longest palindromic subsequence for the corresponding query. Examples: >>> longest_palindromic_subsequence(\\"banana\\", [(1, 3), (1, 6), (3, 6)]) [1, 5, 3] >>> longest_palindromic_subsequence(\\"abac\\", [(1, 4), (2, 3)]) [3, 1] pass # Unit Test def test_basic_cases(): assert longest_palindromic_subsequence(\\"banana\\", [(1, 3), (1, 6), (3, 6)]) == [1, 5, 3] assert longest_palindromic_subsequence(\\"abac\\", [(1, 4), (2, 3)]) == [3, 1] def test_single_character(): assert longest_palindromic_subsequence(\\"a\\", [(1, 1)]) == [1] assert longest_palindromic_subsequence(\\"zzzz\\", [(1, 1), (2, 2), (3, 3), (4, 4)]) == [1, 1, 1, 1] def test_repeated_characters(): assert longest_palindromic_subsequence(\\"aaaaa\\", [(1, 5), (2, 4)]) == [5, 3] def test_no_palindromic_subsequence(): assert longest_palindromic_subsequence(\\"abcde\\", [(1, 5)]) == [1] assert longest_palindromic_subsequence(\\"abcdefghij\\", [(3, 7), (1, 2)]) == [1, 1]","solution":"def longest_palindromic_subsequence(S, queries): n = len(S) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if S[i] == S[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) results = [] for L, R in queries: results.append(dp[L - 1][R - 1]) return results"},{"question":"def rectangle_area_and_pumpkins(x1, y1, x2, y2, pumpkins): Calculate the area of Elena's rectangular patch and count the number of pumpkins within or on the border of the rectangular patch. Args: - x1, y1: Coordinates of the first diagonal corner (int). - x2, y2: Coordinates of the second diagonal corner (int). - pumpkins: List of tuples, where each tuple represents the (x, y) coordinates of a pumpkin. Returns: tuple: (area of the rectangle rounded to one decimal place, count of pumpkins inside or on the border). >>> rectangle_area_and_pumpkins(1, 1, 4, 3, [(2, 2), (3, 2), (4, 1), (1, 3), (5, 5)]) (6.0, 4) >>> rectangle_area_and_pumpkins(2, 3, 5, 6, [(3, 4), (4, 5), (2, 6), (6, 3)]) (9.0, 3) # Your implementation here","solution":"def rectangle_area_and_pumpkins(x1, y1, x2, y2, pumpkins): # Calculate the area of the rectangle area = abs(x1 - x2) * abs(y1 - y2) # Determine the boundary of the rectangle x_min, x_max = min(x1, x2), max(x1, x2) y_min, y_max = min(y1, y2), max(y1, y2) # Count the number of pumpkins within or on the border of the rectangle count = 0 for pumpkin in pumpkins: px, py = pumpkin if x_min <= px <= x_max and y_min <= py <= y_max: count += 1 return round(area, 1), count"},{"question":"def max_donation(n: int, k: int, items: List[Tuple[int, int]]) -> int: Returns the maximum total donation by selecting up to k items with the highest premium factors. Parameters: n (int): The number of items. k (int): The number of bids Boboniu can accept. items (list of tuples): Each tuple contains two integers b_i (starting bid) and p_i (premium factor). Returns: int: The maximum total donation possible. >>> max_donation(5, 3, [(10, 5), (20, 10), (30, 15), (40, 20), (50, 25)]) 60 >>> max_donation(4, 2, [(100, 50), (200, 70), (300, 60), (400, 80)]) 150","solution":"def max_donation(n, k, items): Returns the maximum total donation by selecting up to k items with the highest premium factors. Parameters: n (int): The number of items. k (int): The number of bids Boboniu can accept. items (list of tuples): Each tuple contains two integers b_i (starting bid) and p_i (premium factor). Returns: int: The maximum total donation possible. # Sort the items by premium factor in descending order items.sort(key=lambda x: x[1], reverse=True) # Sum the highest k premium factors total_donation = sum(item[1] for item in items[:k]) return total_donation"},{"question":"def train_schedules(n: int, arrivals_lengths: List[Tuple[int, int]]) -> List[int]: Given the number of trains and their respective arrival times and travel lengths, this function returns the finish time for each train. :param n: Number of trains (int) :param arrivals_lengths: List of tuples, each containing arrival time and travel length (list of tuples) :returns: List of finish times for each train (list of int) >>> train_schedules(3, [(1, 5), (2, 2), (2, 3)]) [6, 8, 11] >>> train_schedules(1, [(5, 10)]) [15]","solution":"def train_schedules(n, arrivals_lengths): Given the number of trains and their respective arrival times and travel lengths, this function returns the finish time for each train. :param n: Number of trains (int) :param arrivals_lengths: List of tuples, each containing arrival time and travel length (list of tuples) :returns: List of finish times for each train (list of int) finish_times = [] current_time = 0 for arrival, length in arrivals_lengths: if current_time < arrival: current_time = arrival # Train can start as soon as it arrives current_time += length finish_times.append(current_time) return finish_times"},{"question":"def max_humans_on_grid(m: int) -> int: Returns the maximum number of humans that can be placed on an m x m grid such that no two humans can see each other vertically, horizontally, or diagonally. >>> max_humans_on_grid(1) 1 >>> max_humans_on_grid(2) 2 >>> max_humans_on_grid(3) 5 >>> max_humans_on_grid(4) 8 >>> max_humans_on_grid(5) 13 >>> max_humans_on_grid(10) 50 >>> max_humans_on_grid(100) 5000","solution":"def max_humans_on_grid(m): Returns the maximum number of humans that can be placed on an m x m grid such that no two humans can see each other vertically, horizontally, or diagonally. return (m * m + 1) // 2"},{"question":"from typing import List def max_height_difference(N: int, K: int, heights: List[int]) -> int: Find the maximum possible height difference between the tallest and shortest building in any group of K consecutive buildings. >>> max_height_difference(5, 3, [1, 5, 9, 3, 8]) 8 >>> max_height_difference(5, 1, [1, 5, 9, 3, 8]) 0 >>> max_height_difference(5, 3, [7, 7, 7, 7, 7]) 0 >>> max_height_difference(5, 5, [1, 5, 9, 3, 8]) 8 >>> max_height_difference(1, 1, [1]) 0 >>> max_height_difference(5, 3, [1, 2, 3, 4, 5]) 2 >>> max_height_difference(5, 3, [5, 4, 3, 2, 1]) 2","solution":"def max_height_difference(N, K, heights): Returns the maximum possible height difference between the tallest and shortest building in any group of K consecutive buildings. :param N: Integer, number of buildings :param K: Integer, number of consecutive buildings to consider :param heights: List of integers, heights of the buildings :return: Integer, the maximum height difference max_diff = 0 for i in range(N - K + 1): current_group = heights[i:i + K] current_diff = max(current_group) - min(current_group) max_diff = max(max_diff, current_diff) return max_diff # Reading input from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) heights = list(map(int, data[2:])) print(max_height_difference(N, K, heights))"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise. Args: matrix (List[List[int]]): The matrix to rotate. Returns: List[List[int]]: The rotated matrix. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) [[5, 3, 1], [6, 4, 2]]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise. # Number of rows and columns rows = len(matrix) cols = len(matrix[0]) # New matrix to store the rotated version rotated = [] for col in range(cols): new_row = [] for row in reversed(range(rows)): new_row.append(matrix[row][col]) rotated.append(new_row) return rotated"},{"question":"def longest_palindromic_substring(S: str) -> str: Finds the longest palindromic substring within the given string S. If there are multiple longest palindromic substrings with the same length, return the one which appears first in the original string. :param S: A string consisting of lowercase English alphabet letters. :return: The longest palindromic substring. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" True >>> longest_palindromic_substring(\\"a\\") == \\"a\\" True >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" True >>> longest_palindromic_substring(\\"abcdefg\\") == \\"a\\" True >>> longest_palindromic_substring(\\"xabaxabaxab\\") == \\"xabaxabax\\" True >>> longest_palindromic_substring(\\"\\") == \\"\\" True pass","solution":"def longest_palindromic_substring(S): Returns the longest palindromic substring of the given string. n = len(S) if n == 0: return \\"\\" longest = S[0] # Function to expand around center def expand_around_center(left, right): while left >= 0 and right < n and S[left] == S[right]: left -= 1 right += 1 return S[left + 1:right] for i in range(n): # Odd length palindromes substring1 = expand_around_center(i, i) # Even length palindromes substring2 = expand_around_center(i, i + 1) # Choose the longest among found palindromic substrings longer_substring = substring1 if len(substring1) > len(substring2) else substring2 if len(longer_substring) > len(longest): longest = longer_substring return longest"},{"question":"def max_profit(prices): Returns the maximum profit achievable by buying and selling the stock exactly once. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 90, 10]) == 89 >>> max_profit([1, 2]) == 1 >>> max_profit([2, 1]) == 0 >>> max_profit([2]) == 0 >>> max_profit([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0 >>> max_profit([5, 4, 3, 3, 3, 3, 2, 1, 0]) == 0 >>> max_profit([1000000000, 1, 1000000000]) == 999999999 def solve(test_cases): Solves the problem for all test cases and prints the results. >>> solve([[7, 1, 5, 3, 6, 4], [7, 6, 4, 3, 1], [1, 2, 90, 10]]) == [5, 0, 89]","solution":"def max_profit(prices): Returns the maximum profit achievable by buying and selling the stock exactly once. If no profit can be made, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: max_profit = max(max_profit, price - min_price) min_price = min(min_price, price) return max_profit def solve(test_cases): Solves the problem for all test cases and prints the results. results = [] for prices in test_cases: results.append(max_profit(prices)) return results"},{"question":"def min_difference(N: int, B: List[int]) -> int: Returns the minimum possible absolute difference between the sums of the two sections. >>> min_difference(5, [1, 3, 2, 4, 5]) 1 >>> min_difference(4, [5, 5, 5, 5]) 0 >>> min_difference(2, [8, 6]) 2 >>> min_difference(3, [1, 10, 14]) 3 >>> min_difference(1, [50]) 50 >>> min_difference(0, []) 0","solution":"def min_difference(N, B): Returns the minimum possible absolute difference between the sums of the two sections. total_sum = sum(B) half_sum = total_sum // 2 # Initialize a DP array with size (half_sum + 1) and set the first element to True dp = [False] * (half_sum + 1) dp[0] = True for thickness in B: # Update the DP array from back to front for j in range(half_sum, thickness - 1, -1): if dp[j - thickness]: dp[j] = True # Find the largest j for which dp[j] is True for j in range(half_sum, -1, -1): if dp[j]: return total_sum - 2 * j"},{"question":"def max_sum_charlie(N: int, values: List[int]) -> int: Determine the maximum sum of values that Charlie can achieve if both players play optimally. >>> max_sum_charlie(4, [1, 2, 9, 4]) 10 >>> max_sum_charlie(1, [5]) 5 >>> max_sum_charlie(2, [5, 1]) 5 >>> max_sum_charlie(5, [1, 2, 3, 4, 5]) 9 >>> max_sum_charlie(4, [1000000000, 999999999, 1000000000, 999999999]) 2000000000 >>> max_sum_charlie(4, [8, 15, 3, 7]) 22","solution":"def max_sum_charlie(N, values): # Create a memoization table to store results of subproblems dp = [[0] * N for _ in range(N)] # Fill the table for cases where only one card is left, # since the best both will get is the value of the card itself. for i in range(N): dp[i][i] = values[i] # Fill the table for other cases for length in range(2, N + 1): # length of the subproblem section for i in range(N - length + 1): j = i + length - 1 # if Charlie takes values[i], then Dave is forced to solve (i+1) to j ranges # if Charlie takes values[j], then Dave is forced to solve i to (j-1) ranges dp[i][j] = max(values[i] + min(dp[i + 2][j] if i + 2 <= j else 0, dp[i + 1][j - 1] if i + 1 <= j - 1 else 0), values[j] + min(dp[i + 1][j - 1] if i + 1 <= j - 1 else 0, dp[i][j - 2] if i <= j - 2 else 0)) return dp[0][N - 1]"},{"question":"def summarize_strings(strings: List[str]) -> Dict[str, Dict[str, int]]: Given a list of strings, return a dictionary summarizing the occurrences of each character in the strings. >>> summarize_strings([\\"hello\\", \\"world\\", \\"python\\"]) {\\"hello\\": {\\"h\\": 1, \\"e\\": 1, \\"l\\": 2, \\"o\\": 1}, \\"world\\": {\\"w\\": 1, \\"o\\": 1, \\"r\\": 1, \\"l\\": 1, \\"d\\": 1}, \\"python\\": {\\"p\\": 1, \\"y\\": 1, \\"t\\": 1, \\"h\\": 1, \\"o\\": 1, \\"n\\": 1}} >>> summarize_strings([\\"apple\\", \\"banana\\"]) {\\"apple\\": {\\"a\\": 1, \\"p\\": 2, \\"l\\": 1, \\"e\\": 1}, \\"banana\\": {\\"b\\": 1, \\"a\\": 3, \\"n\\": 2}} Parameters: strings (list): List of strings to summarize. Returns: dict: A dictionary where keys are the strings and values are dictionaries with character counts. pass def test_summarize_strings_basic(): assert summarize_strings([\\"hello\\", \\"world\\", \\"python\\"]) == { \\"hello\\": {\\"h\\": 1, \\"e\\": 1, \\"l\\": 2, \\"o\\": 1}, \\"world\\": {\\"w\\": 1, \\"o\\": 1, \\"r\\": 1, \\"l\\": 1, \\"d\\": 1}, \\"python\\": {\\"p\\": 1, \\"y\\": 1, \\"t\\": 1, \\"h\\": 1, \\"o\\": 1, \\"n\\": 1} } def test_summarize_strings_with_duplicates(): assert summarize_strings([\\"apple\\", \\"banana\\"]) == { \\"apple\\": {\\"a\\": 1, \\"p\\": 2, \\"l\\": 1, \\"e\\": 1}, \\"banana\\": {\\"b\\": 1, \\"a\\": 3, \\"n\\": 2} } def test_summarize_strings_empty_list(): assert summarize_strings([]) == {} def test_summarize_strings_single_string(): assert summarize_strings([\\"test\\"]) == { \\"test\\": {\\"t\\": 2, \\"e\\": 1, \\"s\\": 1} } def test_summarize_strings_multiple_same_strings(): assert summarize_strings([\\"echo\\", \\"echo\\"]) == { \\"echo\\": {\\"e\\": 1, \\"c\\": 1, \\"h\\": 1, \\"o\\": 1}, \\"echo\\": {\\"e\\": 1, \\"c\\": 1, \\"h\\": 1, \\"o\\": 1} # Considering same strings should have the same counts }","solution":"def summarize_strings(strings): Given a list of strings, return a dictionary summarizing the occurrences of each character in the strings. Parameters: strings (list): List of strings to summarize. Returns: dict: A dictionary where keys are the strings and values are dictionaries with character counts. result = {} for string in strings: char_count = {} for char in string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 result[string] = char_count return result"},{"question":"def max_n_from_results(results: List[int]) -> int: Determines the maximum possible value of n that could have produced the observed results. The results are from the operations of addition, subtraction, multiplication or division (floor). Parameters: results (list): A list of integers. Returns: int: The maximum possible value of n. Examples: >>> max_n_from_results([1, 2, 3, 4, 5]) 5 >>> max_n_from_results([10, 1, 2, 3, 10]) 10 >>> max_n_from_results([0, 1, 8, 15]) 15","solution":"def max_n_from_results(results): Determines the maximum possible value of n that could have produced the observed results. The results are from the operations of addition, subtraction, multiplication or division (floor). Parameters: results (list): A list of integers. Returns: int: The maximum possible value of n. return max(results)"},{"question":"def max_distance_runners(runs): Finds the runner(s) who covered the maximum distance. Parameters: runs (list): A list of tuples, where each tuple contains the name of the runner and the distance covered. Returns: list: A list of names of runners who covered the maximum distance in the order they appeared in the input. >>> max_distance_runners([(\\"John\\", 42000), (\\"Alice\\", 38000), (\\"Bob\\", 42000)]) [\\"John\\", \\"Bob\\"] >>> max_distance_runners([(\\"John\\", 42000)]) [\\"John\\"] >>> max_distance_runners([]) []","solution":"def max_distance_runners(runs): Finds the runner(s) who covered the maximum distance. Parameters: runs (list): A list of tuples, where each tuple contains the name of the runner and the distance covered. Returns: list: A list of names of runners who covered the maximum distance in the order they appeared in the input. if not runs: return [] max_distance = max(runs, key=lambda x: x[1])[1] max_distance_runners = [name for name, distance in runs if distance == max_distance] return max_distance_runners"},{"question":"import ipaddress def count_ips_in_subnets(n: int, ip_addresses: List[str], m: int, subnets: List[str]) -> List[int]: Counts how many IP addresses fall within each subnet. Parameters: n (int): Number of IP addresses. ip_addresses (list): List of IP addresses as strings. m (int): Number of subnets. subnets (list): List of subnets as CIDR notation strings. Returns: list: List of integers representing the count of IP addresses within each subnet. Examples: >>> count_ips_in_subnets(4, [\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.2.1\\", \\"10.0.0.1\\"], 2, [\\"192.168.1.0/24\\", \\"10.0.0.0/8\\"]) [2, 1] >>> count_ips_in_subnets(3, [\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.3\\"], 1, [\\"10.0.0.0/8\\"]) [0]","solution":"import ipaddress def count_ips_in_subnets(n, ip_addresses, m, subnets): Counts how many IP addresses fall within each subnet. Parameters: n (int): Number of IP addresses. ip_addresses (list): List of IP addresses as strings. m (int): Number of subnets. subnets (list): List of subnets as CIDR notation strings. Returns: list: List of integers representing the count of IP addresses within each subnet. # Convert IP addresses to ipaddress.IPv4Address ip_objects = [ipaddress.IPv4Address(ip) for ip in ip_addresses] # Convert subnets to ipaddress.IPv4Network subnet_objects = [ipaddress.IPv4Network(subnet, strict=False) for subnet in subnets] # Initialize a list to hold the count of IPs in each subnet results = [0] * m # For each subnet, count the number of IPs that fall within the subnet for idx, subnet in enumerate(subnet_objects): for ip in ip_objects: if ip in subnet: results[idx] += 1 return results"},{"question":"def min_length_subarray(nums, x): Finds the minimum length of a contiguous subarray of which the sum is greater than or equal to x. Args: nums (List[int]): List of integers representing the array. x (int): The target sum. Returns: int: Minimum length of the contiguous subarray with sum >= x. Returns -1 if no such subarray exists. Examples: >>> min_length_subarray([2, 3, 1, 2, 4, 3, 2, 1], 7) 2 >>> min_length_subarray([1, 2, 3, 4, 5], 16) -1","solution":"def min_length_subarray(nums, x): Finds the minimum length of a contiguous subarray of which the sum is greater than or equal to x. n = len(nums) min_len = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= x: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float('inf') else -1"},{"question":"def can_rearrange_books(N: int, initial: List[int], desired: List[int], K: int) -> str: Determines if it is possible to rearrange books to match the desired arrangement given the constraint on height difference K. >>> can_rearrange_books(5, [3, 1, 4, 2, 5], [1, 2, 3, 4, 5], 3) == \\"YES\\" >>> can_rearrange_books(5, [3, 1, 4, 2, 5], [1, 3, 2, 5, 4], 1) == \\"NO\\" >>> can_rearrange_books(5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], 0) == \\"YES\\" >>> can_rearrange_books(4, [5, 6, 7, 8], [5, 6, 7, 8], 2) == \\"YES\\" >>> can_rearrange_books(3, [1000, 2000, 3000], [3000, 2000, 1000], 1000) == \\"YES\\"","solution":"def can_rearrange_books(N, initial, desired, K): Determines if it is possible to rearrange books to match the desired arrangement given the constraint on height difference K. def can_be_swapped(i, j): return abs(initial[i] - initial[j]) <= K indexed_initial = sorted((height, idx) for idx, height in enumerate(initial)) indexed_desired = sorted((height, idx) for idx, height in enumerate(desired)) if [height for height, _ in indexed_initial] != [height for height, _ in indexed_desired]: return \\"NO\\" pos = {height: idx for idx, (height, _) in enumerate(indexed_initial)} visited = [False] * N for i in range(N): if visited[i] or indexed_initial[i][1] == indexed_desired[i][1]: visited[i] = True continue cycle = [] current = i while not visited[current]: visited[current] = True cycle.append(current) current = indexed_initial[current][1] for j in range(len(cycle) - 1): if not can_be_swapped(cycle[j], cycle[j + 1]): return \\"NO\\" return \\"YES\\""},{"question":"def preprocess_array(arr): Preprocess the given array to create a prefix sum array. Parameters: arr (list of int): Input array of integers. Returns: list of int: Prefix sum array. pass # Implement the function def range_sum(prefix_sum, l, r): Compute the sum of elements between indices l and r inclusive using the prefix sum array. Parameters: prefix_sum (list of int): Prefix sum array. l (int): Left index. r (int): Right index. Returns: int: Sum of elements between indices l and r inclusive. pass # Implement the function def process_queries(arr, queries): Process multiple queries to find the sum of elements between given indices. Parameters: arr (list of int): Input array of integers. queries (list of tuple of int): List of queries (l, r) tuples. Returns: list of int: List of results for each query. pass # Implement the function def test_preprocess_array(): assert preprocess_array([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10, 15] assert preprocess_array([7, 1, 2]) == [0, 7, 8, 10] def test_range_sum(): prefix_sum = preprocess_array([1, 2, 3, 4, 5]) assert range_sum(prefix_sum, 0, 2) == 6 assert range_sum(prefix_sum, 1, 3) == 9 assert range_sum(prefix_sum, 2, 4) == 12 prefix_sum = preprocess_array([7, 1, 2]) assert range_sum(prefix_sum, 0, 1) == 8 assert range_sum(prefix_sum, 1, 2) == 3 def test_process_queries(): arr = [1, 2, 3, 4, 5] queries = [(0, 2), (1, 3), (2, 4)] assert process_queries(arr, queries) == [6, 9, 12] arr = [7, 1, 2] queries = [(0, 1), (1, 2)] assert process_queries(arr, queries) == [8, 3] if __name__ == \\"__main__\\": test_preprocess_array() test_range_sum() test_process_queries() print(\\"All tests passed.\\")","solution":"def preprocess_array(arr): Preprocess the given array to create a prefix sum array. Parameters: arr (list of int): Input array of integers. Returns: list of int: Prefix sum array. n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] return prefix_sum def range_sum(prefix_sum, l, r): Compute the sum of elements between indices l and r inclusive using the prefix sum array. Parameters: prefix_sum (list of int): Prefix sum array. l (int): Left index. r (int): Right index. Returns: int: Sum of elements between indices l and r inclusive. return prefix_sum[r + 1] - prefix_sum[l] def process_queries(arr, queries): Process multiple queries to find the sum of elements between given indices. Parameters: arr (list of int): Input array of integers. queries (list of tuple of int): List of queries (l, r) tuples. Returns: list of int: List of results for each query. prefix_sum = preprocess_array(arr) result = [] for l, r in queries: result.append(range_sum(prefix_sum, l, r)) return result"},{"question":"import re def count_occurrences(text: str, word: str) -> int: Returns the number of times \`word\` appears in \`text\` as a standalone word, case insensitively. Args: - text (str): the text in which to search for \`word\`. - word (str): the word to count occurrences of. Returns: - int: number of occurrences of \`word\` in \`text\` as a standalone word. >>> count_occurrences(\\"Python is great and python is dynamic\\", \\"python\\") 2 >>> count_occurrences(\\"Hello world! How's the world today?\\", \\"world\\") 2 >>> count_occurrences(\\"The quick-brown fox jumps over the lazy-dog! Is fox fast?\\", \\"fox\\") 2 >>> count_occurrences(\\"Hello World! hello world. HELLO WORLD?\\", \\"hello\\") 3 >>> count_occurrences(\\"fox on the run fox.\\", \\"fox\\") 2 >>> count_occurrences(\\"There's nothing matching here\\", \\"something\\") 0","solution":"import re def count_occurrences(text, word): Returns the number of times \`word\` appears in \`text\` as a standalone word, case insensitively. Args: - text (str): the text in which to search for \`word\`. - word (str): the word to count occurrences of. Returns: - int: number of occurrences of \`word\` in \`text\` as a standalone word. # Use regular expression to find standalone words pattern = re.compile(r'b' + re.escape(word) + r'b', re.IGNORECASE) matches = pattern.findall(text) return len(matches)"},{"question":"def group_by_first_letter(words): Groups words by their first letter. :param words: List of words (strings) :return: Dictionary where keys are the first letters and values are lists of words starting with that letter >>> group_by_first_letter([\\"apple\\", \\"banana\\", \\"grape\\", \\"avocado\\", \\"blueberry\\", \\"cherry\\"]) {'a': ['apple', 'avocado'], 'b': ['banana', 'blueberry'], 'c': ['cherry'], 'g': ['grape']} >>> group_by_first_letter([\\"apple\\", \\"avocado\\", \\"apricot\\"]) {'a': ['apple', 'avocado', 'apricot']} >>> group_by_first_letter([\\"Apple\\", \\"banana\\", \\"Grape\\", \\"avocado\\", \\"Blueberry\\", \\"cherry\\"]) {'a': ['Apple', 'avocado'], 'b': ['banana', 'Blueberry'], 'c': ['cherry'], 'g': ['Grape']} >>> group_by_first_letter([]) {} >>> group_by_first_letter([\\"banana\\"]) {'b': ['banana']} >>> group_by_first_letter([\\"apple\\", \\"banana\\", \\"cherry\\"]) {'a': ['apple'], 'b': ['banana'], 'c': ['cherry']} >>> group_by_first_letter([\\"kite\\", \\"kangaroo\\", \\"koala\\"]) {'k': ['kite', 'kangaroo', 'koala']}","solution":"def group_by_first_letter(words): Groups words by their first letter. :param words: List of words (strings) :return: Dictionary where keys are the first letters and values are lists of words starting with that letter grouped_words = {} for word in words: first_letter = word[0].lower() if first_letter not in grouped_words: grouped_words[first_letter] = [] grouped_words[first_letter].append(word) # Sorting the dictionary by its keys grouped_words = dict(sorted(grouped_words.items())) return grouped_words"},{"question":"def is_prime(n: int) -> bool: Determines whether a given number n is a prime number. # Implement the function to check if 'n' is a prime number. def find_prime_pair(N: int) -> int: Determines if N can be expressed as a sum of two prime numbers and returns the pair of prime numbers if possible. Otherwise, returns -1. >>> find_prime_pair(10) (3, 7) >>> find_prime_pair(16) (3, 13) >>> find_prime_pair(27) -1 # Implement the function to find two prime numbers that sum up to 'N'. def process_test_cases(T: int, test_cases: list) -> list: Processes multiple test cases and returns results for each case. >>> process_test_cases(3, [10, 16, 27]) [(3, 7), (3, 13), -1] >>> process_test_cases(2, [34, 4]) [(3, 31), (2, 2)] # Implement the function to process multiple test cases.","solution":"def is_prime(n): Determines whether a given number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_prime_pair(N): Determines if N can be expressed as a sum of two prime numbers and returns the pair of prime numbers if possible. Otherwise, returns -1. for i in range(2, N // 2 + 1): if is_prime(i) and is_prime(N - i): return i, N - i return -1 def process_test_cases(T, test_cases): Processes multiple test cases and returns results for each case. results = [] for N in test_cases: result = find_prime_pair(N) results.append(result) return results # Example usage, not part of the final solution: # T = 3 # test_cases = [10, 16, 27] # results = process_test_cases(T, test_cases) # for result in results: # if result == -1: # print(result) # else: # print(result[0], result[1])"},{"question":"def has_pair_with_sum(nums: List[int], k: int) -> bool: Returns True if there are two distinct elements in the list whose sum is equal to k. Returns False otherwise. >>> has_pair_with_sum([4, 7, 1, -3, 2], 5) True >>> has_pair_with_sum([4, 7, 1, -3, 2], 10) False","solution":"def has_pair_with_sum(nums, k): Returns True if there are two distinct elements in the list whose sum is equal to k. Returns False otherwise. seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"def isPalindrome(s: str) -> bool: Returns True if the given string is a palindrome, and False otherwise. A string is considered a palindrome if it reads the same forward and backward, after transforming all uppercase letters to lowercase and removing all non-alphanumeric characters. >>> isPalindrome('A man, a plan, a canal: Panama') == True >>> isPalindrome('race a car') == False >>> isPalindrome(' ') == True >>> isPalindrome('a') == True >>> isPalindrome('A') == True >>> isPalindrome('!@@@!') == True >>> isPalindrome('Able was I ere I saw Elba') == True >>> isPalindrome('12321') == True >>> isPalindrome('12345') == False","solution":"def isPalindrome(s): Returns True if the given string is a palindrome, and False otherwise. A string is considered a palindrome if it reads the same forward and backward, after transforming all uppercase letters to lowercase and removing all non-alphanumeric characters. # Remove non-alphanumeric characters and convert to lowercase cleaned = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is the same forwards and backwards return cleaned == cleaned[::-1]"},{"question":"def is_back_to_origin(movements: str) -> str: Determines if the robot returns to the starting position after a sequence of movements. >>> is_back_to_origin(\\"ENWS\\") == \\"YES\\" >>> is_back_to_origin(\\"ENWN\\") == \\"NO\\" >>> is_back_to_origin(\\"NSEW\\") == \\"YES\\" >>> is_back_to_origin(\\"NSSS\\") == \\"NO\\" >>> is_back_to_origin(\\"N\\") == \\"NO\\" >>> is_back_to_origin(\\"SSEENNWW\\") == \\"YES\\" >>> is_back_to_origin(\\"N\\" * 50000 + \\"S\\" * 50000) == \\"YES\\" >>> is_back_to_origin(\\"N\\" * 50000 + \\"S\\" * 50000 + \\"E\\") == \\"NO\\" >>> is_back_to_origin(\\"NNSSWWEE\\") == \\"YES\\" >>> is_back_to_origin(\\"NSWEWSEN\\") == \\"YES\\" >>> is_back_to_origin(\\"NNSSEEWW\\") == \\"YES\\"","solution":"def is_back_to_origin(movements): Determines if the robot returns to the starting position after a sequence of movements. Parameters: movements (str): A string containing the movements instructions (characters 'N', 'S', 'E', 'W'). Returns: str: \\"YES\\" if the robot returns to the starting position, otherwise \\"NO\\". x, y = 0, 0 for move in movements: if move == 'N': y += 1 elif move == 'S': y -= 1 elif move == 'E': x += 1 elif move == 'W': x -= 1 if x == 0 and y == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def shortest_path(n: int, m: int, highways: List[Tuple[int, int, int]], start: int, end: int) -> int: Returns the length of the shortest path from city \`start\` to city \`end\`. >>> shortest_path(4, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (1, 4, 50)], 1, 4) 30 >>> shortest_path(3, 1, [(1, 2, 5)], 3, 1) -1 >>> shortest_path(5, 2, [(1, 2, 10), (3, 4, 10)], 1, 4) -1 >>> shortest_path(2, 1, [(1, 2, 10)], 1, 2) 10 >>> shortest_path(4, 5, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (1, 3, 25), (2, 4, 20)], 1, 4) 30","solution":"import heapq def shortest_path(n, m, highways, start, end): Returns the length of the shortest path from city \`start\` to city \`end\`. graph = {i: [] for i in range(1, n+1)} for u, v, w in highways: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, start)] dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 while pq: curr_dist, u = heapq.heappop(pq) if curr_dist > dist[u]: continue for v, weight in graph[u]: distance = curr_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist[end] if dist[end] != float('inf') else -1"},{"question":"def max_billboard_size(N: int, heights: List[int]) -> int: Calculates the maximum possible size of a billboard that can be installed on buildings. The billboard can be installed on consecutive buildings that have the same height. :param N: Number of buildings. :param heights: List of building heights. :return: Maximum size of the billboard. >>> max_billboard_size(7, [1, 2, 2, 2, 1, 1, 1]) 3 >>> max_billboard_size(6, [1, 2, 1, 2, 1, 2]) 1","solution":"def max_billboard_size(N, heights): Calculates the maximum possible size of a billboard that can be installed on buildings. The billboard can be installed on consecutive buildings that have the same height. :param N: Number of buildings :param heights: List of building heights :return: Maximum size of the billboard max_size = 1 current_size = 1 for i in range(1, N): if heights[i] == heights[i - 1]: current_size += 1 max_size = max(max_size, current_size) else: current_size = 1 return max_size"},{"question":"def arrange_words_by_length(sentence: str) -> str: Rearranges words in the sentence in ascending order of their lengths. If two words have the same length, they appear in the same order as in the original sentence. Args: sentence (str): The input sentence containing words separated by spaces. Returns: str: A new string with words ordered by their lengths. >>> arrange_words_by_length(\\"the quick brown fox jumps\\") 'the fox quick brown jumps' >>> arrange_words_by_length(\\"hello world\\") 'hello world' >>> arrange_words_by_length(\\"apple pear banana\\") 'pear apple banana' >>> arrange_words_by_length(\\"hello\\") 'hello' >>> arrange_words_by_length(\\"cat dog log\\") 'cat dog log' >>> arrange_words_by_length(\\"\\") '' >>> arrange_words_by_length(\\"a bb ccc dddd eeeee\\") 'a bb ccc dddd eeeee'","solution":"def arrange_words_by_length(sentence): Rearranges words in the sentence in ascending order of their lengths. If two words have the same length, they appear in the same order as in the original sentence. Args: sentence (str): The input sentence containing words separated by spaces. Returns: str: A new string with words ordered by their lengths. words = sentence.split() sorted_words = sorted(words, key=len) return ' '.join(sorted_words)"},{"question":"def invert_image(image: List[List[int]]) -> List[List[int]]: Inverts the colors of the given image represented as a 2D matrix. Parameters: - image (List[List[int]]): 2D list representing the image. Returns: - List[List[int]]: 2D list representing the inverted image. Example: >>> invert_image([[0, 50, 100], [150, 200, 250], [255, 125, 75], [30, 60, 90]]) [[255, 205, 155], [105, 55, 5], [0, 130, 180], [225, 195, 165]]","solution":"def invert_image(image): Inverts the colors of the given image represented as a 2D matrix. Parameters: image (list of list of int): 2D list representing the image. Returns: list of list of int: 2D list representing the inverted image. inverted_image = [] for row in image: inverted_image.append([255 - pixel for pixel in row]) return inverted_image"},{"question":"def has_pair_with_sum(target: int, numbers: List[int]) -> str: Determines if there exist a pair of distinct indices (i, j) such that numbers[i] + numbers[j] equals to target. Args: - target (int): The target sum value. - numbers (list of int): The list of integers. Returns: - str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_sum(5, [1, 2, 3, 4, 5]) == \\"YES\\" >>> has_pair_with_sum(8, [1, 2, 3, 5]) == \\"YES\\" >>> has_pair_with_sum(0, [-1, 1, 0]) == \\"YES\\" >>> has_pair_with_sum(10, [1, 2, 3, 4, 5]) == \\"NO\\" >>> has_pair_with_sum(7, [1, 2, 3]) == \\"NO\\" >>> has_pair_with_sum(4, [1, -1]) == \\"NO\\" >>> has_pair_with_sum(1, [1]) == \\"NO\\" >>> has_pair_with_sum(-1, [-1000000000, 999999999, 1]) == \\"YES\\" >>> has_pair_with_sum(0, [1000000000, -1000000000]) == \\"YES\\"","solution":"def has_pair_with_sum(target, numbers): Determines if there exist a pair of distinct indices (i, j) such that numbers[i] + numbers[j] equals to target. Args: - target (int): The target sum value. - numbers (list of int): The list of integers. Returns: - str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in numbers: complement = target - num if complement in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"from typing import List, Tuple def max_beauty_sum(N: int, K: int, grid: List[List[int]]) -> int: Find the maximum beauty sum of any K x K subgrid within the given N x N grid. >>> grid = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> max_beauty_sum(4, 2, grid) 54 >>> grid = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ] >>> max_beauty_sum(3, 1, grid) -1 pass def process_datasets(datasets: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Process all datasets to find the maximum beauty sum for each. >>> datasets = [ ... ((4, 2), [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]), ... ((3, 1), [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) ... ] >>> process_datasets(datasets) [54, -1] pass def parse_input(input_str: str) -> List[Tuple[Tuple[int, int], List[List[int]]]]: Parse the input string into a list of datasets. >>> input_str = '''4 2 ... 1 2 3 4 ... 5 6 7 8 ... 9 10 11 12 ... 13 14 15 16 ... 3 1 ... -1 -2 -3 ... -4 -5 -6 ... -7 -8 -9 ... 0 0''' >>> parse_input(input_str) [((4, 2), [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]), ... ((3, 1), [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ])] pass","solution":"def max_beauty_sum(N, K, grid): max_sum = float('-inf') for i in range(N - K + 1): for j in range(N - K + 1): current_sum = 0 for a in range(K): for b in range(K): current_sum += grid[i + a][j + b] max_sum = max(max_sum, current_sum) return max_sum def process_datasets(datasets): results = [] for dataset in datasets: N, K = dataset[0] grid = dataset[1] result = max_beauty_sum(N, K, grid) results.append(result) return results def parse_input(input_str): lines = input_str.strip().split('n') datasets = [] i = 0 while i < len(lines): if lines[i].strip() == '0 0': break N, K = map(int, lines[i].strip().split()) grid = [] for j in range(1, N+1): grid.append(list(map(int, lines[i + j].strip().split()))) datasets.append(((N, K), grid)) i += N + 1 return datasets # Example of processing input input_str = 4 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 3 1 -1 -2 -3 -4 -5 -6 -7 -8 -9 0 0 datasets = parse_input(input_str) results = process_datasets(datasets) for result in results: print(result)"},{"question":"def mode_frequency(N: int, A: List[int]) -> int: Determine the frequency of the mode (the most frequent element) in an array of integers. >>> mode_frequency(6, [1, 2, 2, 3, 3, 3]) 3 >>> mode_frequency(5, [1, 1, 2, 2, 3]) 2 >>> mode_frequency(4, [2, 2, 2, 2]) 4 >>> mode_frequency(0, []) 0 >>> mode_frequency(1, [1]) 1 >>> mode_frequency(10, [5, 3, 5, 2, 5, 3, 5, 7, 2, 3]) 4","solution":"def mode_frequency(N, A): from collections import Counter if N == 0: return 0 # Count the frequency of each element in the array using Counter count = Counter(A) # Get the highest frequency (mode frequency) mode_freq = max(count.values()) return mode_freq"},{"question":"from typing import List, Tuple def can_create_layers(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine whether it's possible to arrange the layers to match the desired sweetness sequence following Chef's policy for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): A list of tuples where each tuple contains: - an integer N (number of layers) - a list of integers representing the sweetness levels. Returns: list of str: A list containing \\"YES\\" or \\"NO\\" for each test case. pass def test_can_create_layers(): assert can_create_layers(4, [ (3, [1, 2, 3]), (3, [1, 3, 2]), (2, [5, 5]), (4, [1, 1, 1, 1]) ]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] def test_single_layer(): assert can_create_layers(1, [ (1, [1]) ]) == [\\"YES\\"] def test_decreasing_layers(): assert can_create_layers(1, [ (3, [3, 2, 1]) ]) == [\\"NO\\"] def test_all_the_same(): assert can_create_layers(1, [ (5, [7, 7, 7, 7, 7]) ]) == [\\"YES\\"] def test_mixed_layers(): assert can_create_layers(1, [ (6, [2, 3, 4, 1, 2, 3]) ]) == [\\"NO\\"]","solution":"def can_create_layers(T, test_cases): Determine whether it's possible to arrange the layers to match the desired sweetness sequence following Chef's policy for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): A list of tuples where each tuple contains: - an integer N (number of layers) - a list of integers representing the sweetness levels. Returns: list of str: A list containing \\"YES\\" or \\"NO\\" for each test case. results = [] for N, sweetness_levels in test_cases: can_do = True for i in range(1, N): if sweetness_levels[i] < sweetness_levels[i - 1]: can_do = False break if can_do: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_seat_all_customers(T: int, people: List[int]) -> List[str]: Determine if all the customers can be seated according to the given constraints. >>> can_seat_all_customers(3, [15, 16, 17]) ['YES', 'YES', 'NO'] >>> can_seat_all_customers(1, [18]) ['YES']","solution":"def can_seat_all_customers(T, people): results = [] for N in people: if N % 4 == 0: results.append(\\"YES\\") elif 2 <= N % 4 <= 3: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage if __name__ == \\"__main__\\": T = 3 people = [15, 16, 17] results = can_seat_all_customers(T, people) for result in results: print(result)"},{"question":"def minimum_operations_to_equal_elements(n, k, arr): Determines the minimum number of operations required to make all elements in the array equal. Returns -1 if it is not possible with the given k operations. Parameters: n (int): Number of elements in the array. k (int): Maximum number of operations that can be performed. arr (list of int): The elements of the array. Returns: int: The minimum number of operations required or -1 if it is not possible. >>> minimum_operations_to_equal_elements(5, 6, [1, 2, 3, 4, 5]) 6 >>> minimum_operations_to_equal_elements(3, 1, [1, 5, 3]) -1 def test_minimum_operations_example1(): assert minimum_operations_to_equal_elements(5, 6, [1, 2, 3, 4, 5]) == 6 def test_minimum_operations_example2(): assert minimum_operations_to_equal_elements(3, 1, [1, 5, 3]) == -1 def test_minimum_operations_all_elements_equal(): assert minimum_operations_to_equal_elements(4, 0, [4, 4, 4, 4]) == 0 def test_minimum_operations_large_k(): assert minimum_operations_to_equal_elements(4, 100, [1, 10, 7, 3]) == 13 def test_minimum_operations_small_array(): assert minimum_operations_to_equal_elements(2, 1, [1, 2]) == 1 def test_minimum_operations_large_elements(): assert minimum_operations_to_equal_elements(5, 10000, [1000, 2000, 3000, 4000, 5000]) == 6000","solution":"def minimum_operations_to_equal_elements(n, k, arr): Determines the minimum number of operations required to make all elements in the array equal. Returns -1 if it is not possible with the given k operations. Parameters: n (int): Number of elements in the array. k (int): Maximum number of operations that can be performed. arr (list of int): The elements of the array. Returns: int: The minimum number of operations required or -1 if it is not possible. arr.sort() median = arr[n // 2] total_operations = sum(abs(x - median) for x in arr) if total_operations <= k: return total_operations return -1"},{"question":"def calculate_restocking_period(n: int, items: List[Tuple[int, int]]) -> List[int]: For each item, calculates the restocking period in days based on average daily sales and restock threshold. :param n: int - Number of items. :param items: list of tuples - Each tuple contains two integers, average daily sales and restock threshold. :return: list of integers - Restocking periods in days for each item. >>> calculate_restocking_period(3, [(10, 100), (5, 50), (20, 200)]) [10, 10, 10] >>> calculate_restocking_period(2, [(1, 15), (6, 60)]) [15, 10]","solution":"def calculate_restocking_period(n, items): For each item, calculates the restocking period in days based on average daily sales and restock threshold. :param n: int - Number of items. :param items: list of tuples - Each tuple contains two integers, average daily sales and restock threshold. :return: list of integers - Restocking periods in days for each item. result = [] for a, t in items: restocking_period = t // a result.append(restocking_period) return result"},{"question":"def calculate_student_scores(n: int, m: int, scores: List[List[int]]) -> List[Tuple[int, int, float]]: Calculate the total and average scores of students. :param n: Number of students :param m: Number of tests :param scores: Matrix of scores where scores[i][j] is the score of student j in test i. :return: List of tuples with student ID, total score, and average score. >>> calculate_student_scores(3, 2, [[50, 60, 70], [80, 90, 100]]) [(1, 130, 65.00), (2, 150, 75.00), (3, 170, 85.00)] >>> calculate_student_scores(2, 3, [[10, 20], [30, 40], [50, 60]]) [(1, 90, 30.00), (2, 120, 40.00)] pass","solution":"def calculate_student_scores(n, m, scores): Calculate the total and average scores of students. :param n: Number of students :param m: Number of tests :param scores: Matrix of scores where scores[i][j] is the score of student i in test j. :return: List of tuples with student ID, total score, and average score. # Initialize lists to store total scores and count of tests taken total_scores = [0] * n # Calculate total scores for each student for test_scores in scores: for student_id in range(n): total_scores[student_id] += test_scores[student_id] # Calculate average scores and format the result result = [] for student_id in range(n): total_score = total_scores[student_id] average_score = total_score / m result.append((student_id + 1, total_score, round(average_score, 2))) return result # Example usage n, m = 3, 2 scores = [ [50, 60, 70], [80, 90, 100] ] print(calculate_student_scores(n, m, scores)) n, m = 2, 3 scores = [ [10, 20], [30, 40], [50, 60] ] print(calculate_student_scores(n, m, scores))"},{"question":"def can_light_lanterns(s): Determine if it's possible to light up at least one lantern. Args: s (str): a string containing 'A' and 'B'. Returns: str: \\"Yes\\" if it's possible to light up at least one lantern, otherwise \\"No\\". Example: >>> can_light_lanterns(\\"BBAAB\\") 'Yes' >>> can_light_lanterns(\\"BB\\") 'No' >>> can_light_lanterns(\\"AAAA\\") 'Yes' >>> can_light_lanterns(\\"BBBB\\") 'No' >>> can_light_lanterns(\\"A\\") 'Yes' >>> can_light_lanterns(\\"B\\") 'No'","solution":"def can_light_lanterns(s): Determine if it's possible to light up at least one lantern. Args: s (str): a string containing 'A' and 'B'. Returns: str: \\"Yes\\" if it's possible to light up at least one lantern, otherwise \\"No\\". return \\"Yes\\" if 'A' in s else \\"No\\""},{"question":"def character_count(s: str) -> dict: Return a dictionary with the counts of each character in the string. The case of the characters should be ignored, meaning 'A' and 'a' are considered the same character. >>> character_count('Hello, World!') {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_count('Alphabet') {'a': 2, 'l': 1, 'p': 1, 'h': 1, 'b': 1, 'e': 1, 't': 1} >>> character_count('') {} >>> character_count('1234567890!@#%^&*()') {} >>> character_count('AaAaBbCcCcDd') {'a': 4, 'b': 2, 'c': 4, 'd': 2} >>> character_count('x') {'x': 1} >>> character_count('This is a test!') {'t': 3, 'h': 1, 'i': 2, 's': 3, 'a': 1, 'e': 1}","solution":"def character_count(s): Returns a dictionary with counts of each character in the string, ignoring case and non-alphabetic characters. Parameters: s (str): The input string Returns: dict: A dictionary where keys are characters and values are their counts. # Convert the string to lowercase to ignore case s = s.lower() # Initialize an empty dictionary to store the character counts counts = {} # Iterate over each character in the string for char in s: # Check if the character is alphabetic if char.isalpha(): # Increment the character count in the dictionary if char in counts: counts[char] += 1 else: counts[char] = 1 return counts"},{"question":"def find_highest_water_usage(n, m, data): Determines the apartment with the highest total water usage. Parameters: n (int): number of apartments m (int): number of months data (list of lists): water usage data where each sublist represents one apartment's monthly usage Returns: int: 1-based index of the apartment with the highest total water usage >>> find_highest_water_usage(3, 4, [[10, 20, 30, 40], [50, 60, 70, 80], [90, 10, 20, 30]]) == 2 >>> find_highest_water_usage(2, 3, [[100, 200, 150], [300, 100, 50]]) == 1 pass def test_find_highest_water_usage(): # Test case 1 n, m = 3, 4 data = [ [10, 20, 30, 40], [50, 60, 70, 80], [90, 10, 20, 30] ] assert find_highest_water_usage(n, m, data) == 2 # Test case 2 n, m = 2, 3 data = [ [100, 200, 150], [300, 100, 50] ] assert find_highest_water_usage(n, m, data) == 1 # Test case 3: Single apartment n, m = 1, 3 data = [ [100, 200, 300] ] assert find_highest_water_usage(n, m, data) == 1 # Test case 4: All equal usage n, m = 3, 3 data = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] assert find_highest_water_usage(n, m, data) == 1 # Test case 5: Last apartment has highest usage n, m = 4, 4 data = [ [10, 20, 30, 40], [10, 20, 30, 40], [10, 20, 30, 40], [500, 1000, 2000, 4000] ] assert find_highest_water_usage(n, m, data) == 4 # Test case 6: Large values in data n, m = 3, 3 data = [ [1000, 1000, 1000], [2000, 2000, 2000], [3000, 3000, 3000] ] assert find_highest_water_usage(n, m, data) == 3","solution":"def find_highest_water_usage(n, m, data): Determines the apartment with the highest total water usage. Parameters: n (int): number of apartments m (int): number of months data (list of lists): water usage data where each sublist represents one apartment's monthly usage Returns: int: 1-based index of the apartment with the highest total water usage max_usage = 0 max_index = 0 for i in range(n): total_usage = sum(data[i]) if total_usage > max_usage: max_usage = total_usage max_index = i + 1 # 1-based index return max_index"},{"question":"from typing import List def solve(t: int, cases: List[str]) -> List[int]: For each given string, find the shortest length of the string you need to remove to make it a palindrome. Note that the resulting string after removal must be a palindrome and it cannot be empty. Args: t (int): The number of test cases. cases (List[str]): List of strings containing the test cases. Returns: List[int]: List of integers representing the shortest length of the string to be removed for each test case. >>> solve(3, [\\"abcdcba\\", \\"abca\\", \\"deed\\"]) [0, 1, 0] >>> solve(2, [\\"a\\", \\"abc\\"]) [0, 2] >>> solve(4, [\\"racecar\\", \\"madam\\", \\"abb\\", \\"gfg\\"]) [0, 0, 1, 0] >>> solve(1, [\\"abccbaabccba\\"]) [0] >>> solve(1, [\\"abbac\\"]) [1]","solution":"def min_remove_to_palindrome(s): Returns the shortest length of the string you need to remove to make the given string a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] n = len(s) lps = longest_palindromic_subsequence(s) return n - lps def solve(t, cases): results = [] for s in cases: results.append(min_remove_to_palindrome(s)) return results"},{"question":"def categorize_books(T: int, pages: List[int]) -> List[str]: Categorizes books based on the number of pages. - Less than 100 pages is a 'Short Story'. - Between 100 and 300 pages inclusive is a 'Novella'. - More than 300 pages is a 'Novel'. Parameters: T (int): Number of books. pages (list of int): Page count for each book. Returns: list of str: Category of each book ('Short Story', 'Novella', 'Novel'). >>> categorize_books(5, [85, 120, 250, 305, 99]) ['Short Story', 'Novella', 'Novella', 'Novel', 'Short Story'] >>> categorize_books(2, [1, 1000]) ['Short Story', 'Novel']","solution":"def categorize_books(T, pages): Categorizes books based on the number of pages. Parameters: T (int): Number of books pages (list of int): Page count for each book Returns: list of str: Category of each book ('Short Story', 'Novella', 'Novel') categories = [] for P in pages: if P < 100: categories.append('Short Story') elif 100 <= P <= 300: categories.append('Novella') else: categories.append('Novel') return categories"},{"question":"def next_palindromic_number(n: int) -> int: Returns the smallest palindromic number greater than n. >>> next_palindromic_number(1) 2 >>> next_palindromic_number(123) 131 >>> next_palindromic_number(999999999) 0 >>> next_palindromic_number(1234321) 1235321","solution":"def next_palindromic_number(n): Returns the smallest palindromic number greater than n. def is_palindrome(num): return str(num) == str(num)[::-1] if len(str(n)) > 8: # As 9 digit number + 1 can have at most 9 digits only. return 0 n += 1 while not is_palindrome(n): n += 1 if len(str(n)) > 9: return 0 return n"},{"question":"def can_make_equal(A: str, B: str) -> bool: Determine if it is possible to make the strings equal by performing any number of swaps within the same string. Parameters: A (str): First string B (str): Second string Returns: bool: True if it is possible to make the strings equal, False otherwise. >>> can_make_equal(\\"abac\\", \\"bcaa\\") True >>> can_make_equal(\\"abcd\\", \\"efgh\\") False","solution":"def can_make_equal(A, B): Determine if it is possible to make strings A and B equal by performing swaps within the same string. Parameters: A (str): First string B (str): Second string Returns: bool: True if it is possible to make the strings equal, False otherwise if len(A) != len(B): return False # If the sorted versions of the strings are equal, it means they have the same characters in the same frequency return sorted(A) == sorted(B)"},{"question":"def longest_sequence_of_empty_benches(n: int, benches: List[int]) -> int: Determine the longest sequence of consecutive empty benches. >>> longest_sequence_of_empty_benches(10, [1, 0, 0, 1, 0, 0, 0, 1, 0, 0]) 3 >>> longest_sequence_of_empty_benches(5, [1, 1, 1, 1, 1]) 0 >>> longest_sequence_of_empty_benches(4, [0, 0, 0, 0]) 4 >>> longest_sequence_of_empty_benches(1, [0]) 1 >>> longest_sequence_of_empty_benches(1, [1]) 0 >>> longest_sequence_of_empty_benches(8, [0, 0, 1, 0, 0, 1, 0, 0]) 2 >>> longest_sequence_of_empty_benches(100, [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1] + [0] * 68) 68","solution":"def longest_sequence_of_empty_benches(n, benches): max_length = 0 current_length = 0 for bench in benches: if bench == 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def find_three_indices(arr: List[int], target: int) -> Union[Tuple[int, int, int], int]: Finds three indices in the array such that their elements sum up to the target. If no such indices exist, return -1. Parameters: arr (list of int): The list of integers target (int): The target sum Returns: Union[Tuple[int, int, int], int]: A tuple containing the three indices if they exist, or -1 otherwise. Examples: >>> find_three_indices([1, 2, 3, 4, 5, 6], 10) (0, 1, 4) >>> find_three_indices([-1, 2, 1, -4], 1) -1","solution":"def find_three_indices(arr, target): Finds three indices in the array such that their elements sum up to the target. Parameters: arr (list of int): The list of integers target (int): The target sum Returns: tuple of int: A tuple containing the three indices, or -1 if no such indices exist. n = len(arr) for i in range(n): seen = {} current_sum = target - arr[i] for j in range(i + 1, n): complement = current_sum - arr[j] if complement in seen: return (i, seen[complement], j) seen[arr[j]] = j return -1"},{"question":"def min_largest_storage_capacity(storage_units, material_requirements): Determine the minimum capacity of the largest storage unit required to store all the materials while meeting daily requirements. :param storage_units: List[int] - The capacities of each storage unit. :param material_requirements: List[int] - The daily requirements for each type of material. :return: int - The minimum capacity of the largest storage unit required. >>> min_largest_storage_capacity([20, 30, 10, 50, 40], [15, 35, 25]) 45 >>> min_largest_storage_capacity([20, 30, 10, 50, 40], [10, 10, 10]) 30 >>> min_largest_storage_capacity([500, 1000, 2000], [100, 200, 300]) 600 >>> min_largest_storage_capacity([100], [100]) 100 >>> min_largest_storage_capacity([10, 20, 30], [50]) 50","solution":"def min_largest_storage_capacity(storage_units, material_requirements): Determine the minimum capacity of the largest storage unit required to store all the materials while meeting daily requirements. :param storage_units: List[int] - The capacities of each storage unit. :param material_requirements: List[int] - The daily requirements for each type of material. :return: int - The minimum capacity of the largest storage unit required. total_requirements = sum(material_requirements) return total_requirements # Example: # Given storage_units=[20, 30, 10, 50, 40] and material_requirements=[15, 35, 25] # The minimum capacity of the largest storage unit should be 45 as shown in the example."},{"question":"def count_matching_subsequences(challenges: List[str], T: str) -> int: Returns the count of unique subsequences of T that match any challenge in the collection. Args: challenges (List[str]): List of challenge strings. T (str): The string from which to derive subsequences. Returns: int: Number of unique subsequences of T that match any challenge. >>> count_matching_subsequences([\\"abc\\", \\"def\\", \\"ghi\\"], \\"abcdeg\\") 1 >>> count_matching_subsequences([\\"abc\\", \\"def\\", \\"deg\\"], \\"abcdeg\\") 2 >>> count_matching_subsequences([\\"xyz\\", \\"ghi\\", \\"klm\\"], \\"abcdeg\\") 0 >>> count_matching_subsequences([\\"abc\\", \\"abd\\", \\"acd\\"], \\"abcd\\") 3 >>> count_matching_subsequences([\\"ab\\", \\"bc\\", \\"cd\\"], \\"abcd\\") 3 >>> count_matching_subsequences([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") 3 >>> count_matching_subsequences([\\"abcdefghij\\"] * 50, \\"abcdefghi\\") 0","solution":"def count_matching_subsequences(challenges, T): Returns the count of unique subsequences of T that match any challenge in the collection. from itertools import combinations def subsequences(s): sub_seq_set = set() for i in range(len(s) + 1): for combo in combinations(s, i): sub_seq_set.add(''.join(combo)) return sub_seq_set T_subsequences = subsequences(T) count = 0 for challenge in challenges: if challenge in T_subsequences: count += 1 return count"},{"question":"def process_transactions(M: int, N: int, initial_balances: List[int], min_balances: List[int], transactions: List[Tuple[int, int, int]]) -> List[str]: Process a series of transactions and determine if each is valid or invalid. Parameters: - M (int): Number of accounts - N (int): Number of transactions - initial_balances (List[int]): Initial balances of accounts - min_balances (List[int]): Minimum balance constraints for accounts - transactions (List[Tuple[int, int, int]]): List of transactions, where each transaction is represented by a tuple (A, T, V) Returns: - List[str]: List of results for each transaction as \\"Valid\\" or \\"Invalid\\" >>> process_transactions(5, 4, [1000, 1500, 1200, 1300, 1100], [500, 1000, 500, 1000, 500], [(1, 1, 600), (2, 2, 300), (4, 1, 1000), (5, 1, 700)]) [\\"Invalid\\", \\"Valid\\", \\"Invalid\\", \\"Invalid\\"] >>> process_transactions(3, 2, [1000, 2000, 3000], [500, 1000, 1500], [(1, 2, 500), (3, 2, 1000)]) [\\"Valid\\", \\"Valid\\"] # Implementation goes here","solution":"def process_transactions(M, N, initial_balances, min_balances, transactions): results = [] for A, T, V in transactions: account_index = A - 1 if T == 1: # Debit Transaction if initial_balances[account_index] - V < min_balances[account_index]: results.append(\\"Invalid\\") else: initial_balances[account_index] -= V results.append(\\"Valid\\") elif T == 2: # Credit Transaction initial_balances[account_index] += V results.append(\\"Valid\\") return results # Example function call M = 5 N = 4 initial_balances = [1000, 1500, 1200, 1300, 1100] min_balances = [500, 1000, 500, 1000, 500] transactions = [ (1, 1, 600), (2, 2, 300), (4, 1, 1000), (5, 1, 700) ] print(process_transactions(M, N, initial_balances, min_balances, transactions))"},{"question":"from typing import List, Tuple def minimum_effort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum effort required for Maria to run from the beginning to the end of each path. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of positions (n) and the elevations list (a) for the respective path. Returns: List[int]: Minimum effort required for each test case. def test_minimum_effort_case1(): assert minimum_effort(3, [(5, [1, 2, 3, 2, 4]), (4, [4, 2, 3, 5]), (3, [10, 5, 2])]) == [4, 3, 0] def test_minimum_effort_case2(): assert minimum_effort(1, [(4, [1, 1, 1, 1])]) == [0] def test_minimum_effort_case3(): assert minimum_effort(1, [(5, [3, 3, 2, 2, 1])]) == [0] def test_minimum_effort_case4(): assert minimum_effort(1, [(6, [1, 3, 2, 4, 2, 5])]) == [7] def test_minimum_effort_case5(): assert minimum_effort(2, [(5, [1, 5, 3, 6, 2]), (3, [2, 1, 3])]) == [7, 2]","solution":"def minimum_effort(t, test_cases): Calculate the minimum effort required for Maria to run from the beginning to the end of each path. Args: t (int): Number of test cases. test_cases (list): List of tuples, each containing the number of positions (n) and the elevations list (a) for the respective path. Returns: list: Minimum effort required for each test case. results = [] for case in test_cases: n, a = case effort = 0 for i in range(1, n): if a[i] > a[i-1]: effort += a[i] - a[i-1] results.append(effort) return results"},{"question":"from typing import Tuple def can_rearrange_string(s: str, k: int) -> str: Determine if it is possible to rearrange the letters of the string such that any two adjacent characters are at least distance k apart. Args: s (str): The input string consisting of lowercase English letters. k (int): The minimum distance between any two adjacent characters. Returns: str: \\"YES\\" if it is possible to rearrange the string accordingly, otherwise \\"NO\\". >>> can_rearrange_string(\\"aabbcc\\", 2) \\"YES\\" >>> can_rearrange_string(\\"aaabc\\", 3) \\"NO\\" >>> can_rearrange_string(\\"aaadbbcc\\", 2) \\"YES\\"","solution":"from collections import Counter import heapq def can_rearrange_string(s, k): if k == 0: return \\"YES\\" frequency = Counter(s) max_heap = [(-count, char) for char, count in frequency.items()] heapq.heapify(max_heap) result = [] heap = [] while max_heap: to_append = [] for _ in range(k): if max_heap: count, char = heapq.heappop(max_heap) result.append(char) if -count > 1: to_append.append((count + 1, char)) elif to_append: return \\"NO\\" for item in to_append: heapq.heappush(max_heap, item) return \\"YES\\""},{"question":"def max_prefix_sum(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the prefix sum and find the maximum prefix sum for each test case. Args: test_cases: A list of tuples, each containing an integer N and a list of N integers. Returns: A list of integers representing the maximum prefix sum for each test case. Example: >>> max_prefix_sum([(5, [1, -2, 3, 4, -1])]) [6] >>> max_prefix_sum([(5, [1, -2, 3, 4, -1]), (4, [2, 3, -1, 2]), (3, [-1, -2, -3])]) [6, 6, -1]","solution":"def max_prefix_sum(test_cases): results = [] for case in test_cases: N, numbers = case prefix_sum = 0 max_sum = float('-inf') for number in numbers: prefix_sum += number if prefix_sum > max_sum: max_sum = prefix_sum results.append(max_sum) return results"},{"question":"def is_palindrome(s): Check if the given string is a palindrome. >>> is_palindrome(\\"abba\\") True >>> is_palindrome(\\"abcd\\") False pass def find_path(grid, n, m, i, j, path, memo): Find if there's a path in the grid that forms a palindrome. >>> find_path([[\\"a\\", \\"b\\", \\"a\\"], [\\"b\\", \\"c\\", \\"b\\"], [\\"a\\", \\"b\\", \\"a\\"]], 3, 3, 0, 0, \\"\\", {}) True >>> find_path([[\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [\\"d\\", \\"c\\", \\"b\\", \\"a\\"]], 2, 4, 0, 0, \\"\\", {}) False pass def solve(T, test_cases): Solve the problem for T test cases. pass def parse_input(input_str): Parse the input string to extract the number of test cases and the test data. >>> parse_input(\\"2n3 3nabanbcbnaban2 4nabcdndcba\\") (2, [(3, 3, ['aba', 'bcb', 'aba']), (2, 4, ['abcd', 'dcba'])]) pass def main(input_str): Main function to solve the problem based on input string. >>> main(\\"2n3 3nabanbcbnaban2 4nabcdndcba\\") 'YESnNO' pass","solution":"def is_palindrome(s): return s == s[::-1] def find_path(grid, n, m, i, j, path, memo): if i >= n or j >= m: return False path += grid[i][j] if (i, j) in memo: return memo[(i, j)] if i == n-1 and j == m-1: memo[(i, j)] = is_palindrome(path) return memo[(i, j)] down = find_path(grid, n, m, i+1, j, path, memo) right = find_path(grid, n, m, i, j+1, path, memo) memo[(i, j)] = down or right return memo[(i, j)] def solve(T, test_cases): results = [] for n, m, grid in test_cases: memo = {} if find_path(grid, n, m, 0, 0, \\"\\", memo): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_str): data = input_str.strip().split(\\"n\\") T = int(data[0]) index = 1 test_cases = [] for _ in range(T): n, m = map(int, data[index].split()) grid = [data[index + 1 + i] for i in range(n)] test_cases.append((n, m, grid)) index += n + 1 return T, test_cases def main(input_str): T, test_cases = parse_input(input_str) results = solve(T, test_cases) return \\"n\\".join(results)"},{"question":"import random from typing import List, Union def derangement(arr: List[int]) -> Union[List[int], int]: Returns a derangement of the array if possible, otherwise returns -1. >>> derangement([1, 2, 3, 4]) != -1 True >>> derangement([1, 1, 1]) == -1 True >>> derangement([5]) == -1 True def process_test_cases(test_cases: List[List[int]]) -> List[str]: Takes a list of test cases, each test case is a list of integers, and returns a list of strings where each string is the deranged array elements if a derangement is possible, or \\"-1\\" if not. >>> process_test_cases([[1, 2, 3, 4], [1, 1, 1], [5]]) ['2 1 4 3', '-1', '-1'] def main(): Reads input from the standard input, processes the test cases, and prints the result for each test case.","solution":"import random def derangement(arr): Returns a derangement of the array if possible, otherwise returns -1. n = len(arr) if n == 1: return -1 deranged = list(arr) random.shuffle(deranged) # Check if shuffled list forms a derangement for i in range(n): if deranged[i] == arr[i]: # We will make a linear check through and fix conflicts for j in range(n): if deranged[j] != arr[i] and deranged[i] != arr[j]: deranged[i], deranged[j] = deranged[j], deranged[i] break else: # If unable to fix the conflict return -1 return deranged def process_test_cases(test_cases): results = [] for arr in test_cases: deranged = derangement(arr) if deranged == -1: results.append(\\"-1\\") else: results.append(\\" \\".join(map(str, deranged))) return results def main(): import sys input = sys.stdin.read data = input().strip().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(data[idx]) idx += 1 arr = list(map(int, data[idx:idx+N])) idx += N test_cases.append(arr) results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_starting_times(p: int, r: int, race_list: List[List[int]]) -> int: Determines the minimum number of distinct starting times needed so that all races can take place as planned without any participant having to be in two places at once. :param p: Number of participants :param r: Number of races :param race_list: List of races, each race being a list of participants :return: Minimum number of distinct starting times required Examples: >>> min_starting_times(3, 4, [[1, 2], [3, 1], [3], [1, 2, 3]]) 3 >>> min_starting_times(4, 3, [[1, 3], [2, 4], [1, 2, 4]]) 2","solution":"def min_starting_times(p, r, race_list): Determines the minimum number of distinct starting times. :param p: Number of participants :param r: Number of races :param race_list: List of races, each race being a list of participants :return: Minimum number of distinct starting times required from collections import defaultdict import itertools # Initialize the graph (adjacency list) graph = defaultdict(list) # Build the graph based on shared participants between races for i in range(r): participants = race_list[i] for j in range(i + 1, r): if set(participants) & set(race_list[j]): graph[i].append(j) graph[j].append(i) # Function to perform DFS and do coloring def is_bipartite(graph, start, color): stack = [start] color[start] = 0 # Start coloring with 0 while stack: node = stack.pop() for neighbor in graph[node]: if color[neighbor] == -1: # Color the neighbor with alternate color color[neighbor] = 1 - color[node] stack.append(neighbor) elif color[neighbor] == color[node]: return False return True # Array to track coloring of each node (race) color = [-1] * r # We check each component of the graph for bipartiteness for i in range(r): if color[i] == -1: if not is_bipartite(graph, i, color): return 3 # If it's not bipartite, we need at least of three distinct starting times # If graph is bipartite, we need at most 2 distinct starting times return 2"},{"question":"def minimum_fuel_required(T, test_cases): Determine the minimum fuel required for each depot to dispatch all its trucks. >>> parse_input(\\"2n3 500 2n1000 450n1200 500n1500 300n2 700 1n1100 1200n900 800\\") (2, [(3, 500, 2, (1000, 450), (1200, 500), (1500, 300)), (2, 700, 1, (1100, 1200), (900, 800))]) >>> minimum_fuel_required(2, [(3, 500, 2, (1000, 450), (1200, 500), (1500, 300)), (2, 700, 1, (1100, 1200), (900, 800))]) [1250000, \\"Impossible\\"] # Helper function to format input data def parse_input(input_data): Parse the input data into a format suitable for processing. >>> parse_input(\\"2n3 500 2n1000 450n1200 500n1500 300n2 700 1n1100 1200n900 800\\") (2, [(3, 500, 2, (1000, 450), (1200, 500), (1500, 300)), (2, 700, 1, (1100, 1200), (900, 800))]) if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def minimum_fuel_required(T, test_cases): results = [] for i in range(T): N, D, F = test_cases[i][:3] truck_data = test_cases[i][3:] total_fuel = 0 possible = True for j in range(N): capacity, cargo = truck_data[j] if cargo > capacity: possible = False break total_fuel += cargo * D * F if possible: results.append(total_fuel) else: results.append(\\"Impossible\\") return results # Helper function to format input data def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(T): N, D, F = map(int, lines[index].strip().split()) index += 1 truck_data = [] for _ in range(N): capacity, cargo = map(int, lines[index].strip().split()) truck_data.append((capacity, cargo)) index += 1 test_cases.append((N, D, F) + tuple(truck_data)) return T, test_cases"},{"question":"def max_subarray_sum(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Given a list of test cases, each containing an integer M and an array A of N non-negative integers, find a sub-array B of A of length M such that the sum of elements in B is maximized for each test case. Args: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of tuples, each containing a tuple with two integers N and M, and a list of N integers representing the array A. Returns: List[int]: A list of integers representing the maximum sum of the sub-array of length M for each test case. Examples: >>> max_subarray_sum(2, [((5, 3), [1, 2, 3, 4, 5]), ((7, 2), [10, 5, 2, 7, 8, 7, 4])]) [12, 15] >>> max_subarray_sum(1, [((1, 1), [1])]) [1] pass","solution":"def max_subarray_sum(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] A = test_cases[i][1] max_sum = 0 # Compute the sum of the first sub-array of length M current_sum = sum(A[:M]) max_sum = current_sum # Use sliding window to find the maximum sum sub-array of length M for j in range(M, N): current_sum = current_sum - A[j-M] + A[j] if current_sum > max_sum: max_sum = current_sum results.append(max_sum) return results"},{"question":"def count_odd_sum_subarrays(N: int, array: List[int]) -> int: Count the number of subarrays with an odd sum. Args: N : int : number of elements in the array array : list : list of positive integers Returns: int : number of subarrays with an odd sum Examples: >>> count_odd_sum_subarrays(4, [1, 2, 3, 4]) 6 >>> count_odd_sum_subarrays(3, [2, 4, 6]) 0 pass # Unit tests def test_count_odd_sum_subarrays(): assert count_odd_sum_subarrays(4, [1, 2, 3, 4]) == 6 assert count_odd_sum_subarrays(3, [2, 4, 6]) == 0 assert count_odd_sum_subarrays(3, [1, 1, 1]) == 4 assert count_odd_sum_subarrays(5, [1, 2, 2, 4, 6]) == 5 assert count_odd_sum_subarrays(1, [1]) == 1 assert count_odd_sum_subarrays(5, [2, 2, 2, 2, 2]) == 0 def test_empty_and_single_element_cases(): assert count_odd_sum_subarrays(0, []) == 0 assert count_odd_sum_subarrays(1, [3]) == 1 assert count_odd_sum_subarrays(1, [4]) == 0 def test_large_numbers(): assert count_odd_sum_subarrays(3, [100000, 100000, 100000]) == 0 assert count_odd_sum_subarrays(2, [99999, 100000]) == 2","solution":"def count_odd_sum_subarrays(N, array): Count the number of subarrays with an odd sum. Args: N : int : number of elements in the array array : list : list of positive integers Returns: int : number of subarrays with an odd sum odd_count = 0 even_count = 1 # Initialize to 1 to consider the empty subarray's prefix sum as even current_sum = 0 odd_sum_subarrays = 0 for num in array: current_sum += num if current_sum % 2 == 0: even_count += 1 odd_sum_subarrays += odd_count else: odd_count += 1 odd_sum_subarrays += even_count return odd_sum_subarrays"},{"question":"def reverseWords(s: str) -> str: This function takes a string s, splits it by spaces to extract the words, and returns a string that contains the words from the input string in reverse order. >>> reverseWords(\\"the sky is blue\\") 'blue is sky the' >>> reverseWords(\\" hello world! \\") 'world! hello' >>> reverseWords(\\"a good example\\") 'example good a'","solution":"def reverseWords(s): This function takes a string s, splits it by spaces to extract the words, and returns a string that contains the words from the input string in reverse order. # Split the input string by spaces and filter out any empty strings resulting from consecutive spaces words = [word for word in s.split(\\" \\") if word] # Reverse the list of words and join them with a single space to form the reversed sentence return \\" \\".join(reversed(words))"},{"question":"from typing import List, Tuple def shortest_path_dag(n: int, m: int, s: int, edges: List[Tuple[int, int, int]]) -> List[int]: Given a directed acyclic graph (DAG) with N vertices numbered 1 to N and M edges, find the shortest path from the source vertex S to each vertex in the graph. Parameters: n: Number of vertices (1 to N) m: Number of edges s: Source vertex edges: List of tuples (u_i, v_i, w_i) indicating a directed edge from u_i to v_i with weight w_i Returns: List of shortest path distances from the source vertex S to each vertex in the graph. If a vertex is not reachable from S, -1 is returned for that vertex. >>> shortest_path_dag(5, 6, 1, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) [0, 2, 3, 9, 6] >>> shortest_path_dag(4, 4, 1, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2)]) [0, 1, 2, 3] def test_shortest_path_dag(): # Test Case 1 n, m, s = 5, 6, 1 edges = [ (1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1) ] assert shortest_path_dag(n, m, s, edges) == [0, 2, 3, 9, 6] # Test Case 2 n, m, s = 4, 4, 1 edges = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2) ] assert shortest_path_dag(n, m, s, edges) == [0, 1, 2, 3] # Test Case 3: Single node n, m, s = 1, 0, 1 edges = [] assert shortest_path_dag(n, m, s, edges) == [0] # Test Case 4: Isolated vertex n, m, s = 4, 2, 1 edges = [ (1, 2, 5), (1, 3, 10) ] assert shortest_path_dag(n, m, s, edges) == [0, 5, 10, -1] # Test Case 5: Unreachable nodes n, m, s = 3, 1, 1 edges = [ (1, 2, 3) ] assert shortest_path_dag(n, m, s, edges) == [0, 3, -1] def test_shortest_path_dag_isolated_source(): # Test Case: Source vertex not connected to any node n, m, s = 4, 0, 1 edges = [] assert shortest_path_dag(n, m, s, edges) == [0, -1, -1, -1]","solution":"from collections import defaultdict, deque import heapq def shortest_path_dag(n, m, s, edges): Returns a list of shortest path distances from the source vertex S. # Step 1: Build the graph graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v, w in edges: graph[u].append((v, w)) in_degree[v] += 1 # Step 2: Topological Sort topo_order = [] zero_in_degree = deque() for i in range(1, n + 1): if in_degree[i] == 0: zero_in_degree.append(i) while zero_in_degree: node = zero_in_degree.popleft() topo_order.append(node) for neighbour, weight in graph[node]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: zero_in_degree.append(neighbour) # Step 3: Initialize distances distances = [float('inf')] * (n + 1) distances[s] = 0 # Step 4: Relax edges according to the topological order for u in topo_order: for v, w in graph[u]: if distances[u] + w < distances[v]: distances[v] = distances[u] + w # Step 5: Format the result result = [] for i in range(1, n + 1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"def canPartitionKSubsets(nums, k): Determines if the array can be partitioned into k subsets with equal sum. Args: nums (List[int]): array of integers. k (int): number of subsets. Returns: bool: True if array can be partitioned into k subsets with equal sum, False otherwise. Examples: >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> canPartitionKSubsets([1, 2, 3, 4], 3) False","solution":"def canPartitionKSubsets(nums, k): Determines if the array can be partitioned into k subsets with equal sum total_sum = sum(nums) if total_sum % k != 0: return False target_sum = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) def canPartition(start, k, current_sum): if k == 1: return True # The last subset must be valid because sum total_sum is divisible by k if current_sum == target_sum: return canPartition(0, k-1, 0) for i in range(start, len(nums)): if not used[i]: if current_sum + nums[i] <= target_sum: used[i] = True if canPartition(i + 1, k, current_sum + nums[i]): return True used[i] = False return False return canPartition(0, k, 0)"},{"question":"import math from typing import List, Tuple def min_max_distances(R: int, points: List[Tuple[int, int]]) -> Tuple[float, float]: Calculate the minimum and maximum distance between any pair of checkpoints on a circular track. Parameters: R (int): Radius of the circle. points (List[Tuple[int, int]]): List of (x, y) coordinates of the checkpoints. Returns: Tuple[float, float]: A tuple with minimum and maximum distance between checkpoints. >>> R, points = 5, [(5, 0), (0, 5), (-5, 0)] >>> min_max_distances(R, points) (7.0710678118654755, 10.0) >>> R, points = 5, [(5, 0), (-5, 0)] >>> min_max_distances(R, points) (10.0, 10.0) >>> R, points = 5, [(5, 0), (5, 0)] >>> min_max_distances(R, points) (0.0, 0.0) >>> R, points = 10, [(10, 0), (0, 10), (-10, 0)] >>> min_max_distances(R, points) (14.142135623730951, 20.0)","solution":"import math def min_max_distances(R, points): Calculate the minimum and maximum distance between any pair of checkpoints. Parameters: R (int): Radius of the circle. points (list of tuples): List of (x, y) coordinates of the checkpoints. Returns: (min_distance, max_distance): A tuple with minimum and maximum distance between checkpoints. def distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) min_distance = float('inf') max_distance = float('-inf') N = len(points) for i in range(N): for j in range(i + 1, N): dist = distance(points[i], points[j]) if dist < min_distance: min_distance = dist if dist > max_distance: max_distance = dist return min_distance, max_distance # Example usage: # R, N = 5, 3 # points = [(5, 0), (0, 5), (-5, 0)] # print(min_max_distances(R, points)) # Output should be (7.0710678118654755, 10.0)"},{"question":"def is_secure_password(password: str) -> str: Check if the given password meets the security criteria. >>> is_secure_password(\\"Password123!\\") == \\"YES\\" >>> is_secure_password(\\"short1!\\") == \\"NO\\" >>> is_secure_password(\\"NoSpecialChar123\\") == \\"NO\\" >>> is_secure_password(\\"ValidPassword1\\") == \\"YES\\" >>> is_secure_password(\\"Shor1!\\") == \\"NO\\" >>> is_secure_password(\\"NoDigits!\\") == \\"NO\\" >>> is_secure_password(\\"VALIDPASSWORD123!\\") == \\"NO\\" >>> is_secure_password(\\"aaaaaaaaaa\\") == \\"NO\\" pass def password_checker(T: int, passwords: List[str]) -> List[str]: For each password, check if it meets the security criteria. >>> password_checker(3, [\\"Password123!\\", \\"short1!\\", \\"NoSpecialChar123\\"]) == [\\"YES\\", \\"NO\\", \\"NO\\"] >>> password_checker(2, [\\"ValidPassword1\\", \\"Shor1!\\"]) == [\\"YES\\", \\"NO\\"] >>> password_checker(1, [\\"NoDigits!\\"]) == [\\"NO\\"] >>> password_checker(2, [\\"VALIDPASSWORD123!\\", \\"aaaaaaaaaa\\"]) == [\\"NO\\", \\"NO\\"] pass","solution":"def is_secure_password(password): if len(password) < 8 or len(password) > 20: return \\"NO\\" has_lower = any(c.islower() for c in password) has_upper = any(c.isupper() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \\"!@#%^&*()-+\\" for c in password) if has_lower and has_upper and has_digit and has_special: return \\"YES\\" return \\"NO\\" def password_checker(T, passwords): return [is_secure_password(password) for password in passwords]"},{"question":"def happy_sequences(t: int, test_cases: list) -> list: Given test_cases with t as the number of test cases and each test case having an array of integers, determine for each test case if a happy subsequence is possible. >>> happy_sequences(3, [(3, [2, 4, 6]), (4, [3, 6, 7, 12]), (5, [5, 7, 11, 13, 17])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> happy_sequences(1, [(1, [1])]) [\\"NO\\"] >>> happy_sequences(1, [(5, [3, 3, 3, 3, 3])]) [\\"YES\\"] >>> happy_sequences(1, [(6, [10, 15, 20, 25, 30, 35])]) [\\"YES\\"] >>> happy_sequences(1, [(4, [21, 22, 23, 24])]) [\\"NO\\"] >>> happy_sequences(1, [(10, [5, 10, 15, 4, 8, 12, 3, 6, 9, 18])]) [\\"YES\\"]","solution":"def is_happy_subsequence_possible(n, array): Determines if it is possible to create a non-empty happy subsequence from the given array. for i in range(n): for j in range(i + 1, n): if array[j] % array[i] == 0: return \\"YES\\" return \\"NO\\" def happy_sequences(t, test_cases): Given test_cases with t as the number of test cases and each test case having an array of integers, determines for each test case if a happy subsequence is possible. results = [] for n, array in test_cases: results.append(is_happy_subsequence_possible(n, array)) return results"},{"question":"def count_dice_throws(T, test_cases): Given T test cases, each containing N throws, return the count of occurrences of dice results 1 to 6. >>> count_dice_throws(1, [(6, [1, 2, 2, 3, 4, 5])]) [[1, 2, 1, 1, 1, 0]] >>> count_dice_throws(3, [(6, [1, 2, 2, 3, 4, 5]), (5, [6, 6, 6, 6, 6]), (7, [2, 3, 4, 5, 6, 1, 1])]) [[1, 2, 1, 1, 1, 0], [0, 0, 0, 0, 0, 5], [2, 1, 1, 1, 1, 1]] >>> count_dice_throws(1, [(10, [6] * 10)]) [[0, 0, 0, 0, 0, 10]] >>> count_dice_throws(1, [(12, [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6])]) [[2, 2, 2, 2, 2, 2]] >>> count_dice_throws(1, [(0, [])]) [[0, 0, 0, 0, 0, 0]]","solution":"def count_dice_throws(T, test_cases): Given T test cases, each containing N throws, return the count of occurrences of dice results 1 to 6. results = [] for i in range(T): N = test_cases[i][0] throws = test_cases[i][1] counts = [0] * 6 # Initialize counts for numbers 1 to 6 for throw in throws: counts[throw - 1] += 1 results.append(counts) return results"},{"question":"def min_platforms(N, arrivals, departures): Returns the minimum number of platforms required for the given arrival and departure times. Parameters: - N (int): Number of trains - arrivals (list of str): List of arrival times in HH:MM format - departures (list of str): List of departure times in HH:MM format Returns: - int: Minimum number of platforms required >>> min_platforms(6, [\\"09:00\\", \\"09:40\\", \\"09:50\\", \\"11:00\\", \\"15:00\\", \\"18:00\\"], [\\"09:10\\", \\"12:00\\", \\"11:20\\", \\"11:30\\", \\"19:00\\", \\"20:00\\"]) 3 >>> min_platforms(6, [\\"09:00\\", \\"09:10\\", \\"09:20\\", \\"09:30\\", \\"09:40\\", \\"09:50\\"], [\\"09:05\\", \\"09:15\\", \\"09:25\\", \\"09:35\\", \\"09:45\\", \\"09:55\\"]) 1 >>> min_platforms(5, [\\"10:00\\", \\"10:15\\", \\"10:30\\", \\"10:35\\", \\"10:50\\"], [\\"10:20\\", \\"10:25\\", \\"10:40\\", \\"10:55\\", \\"11:00\\"]) 2 >>> min_platforms(3, [\\"10:00\\", \\"10:30\\", \\"10:45\\"], [\\"10:15\\", \\"11:00\\", \\"11:30\\"]) 2 >>> min_platforms(4, [\\"10:00\\", \\"10:01\\", \\"10:02\\", \\"10:03\\"], [\\"10:04\\", \\"10:05\\", \\"10:06\\", \\"10:07\\"]) 4","solution":"def min_platforms(N, arrivals, departures): Returns the minimum number of platforms required for the given arrival and departure times. Parameters: N (int): Number of trains arrivals (list): List of arrival times in HH:MM format departures (list): List of departure times in HH:MM format Returns: int: Minimum number of platforms required # Convert time in HH:MM format to minutes since start of the day def time_to_minutes(time): hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes arrivals = [time_to_minutes(a) for a in arrivals] departures = [time_to_minutes(d) for d in departures] # Sort both the arrival and departure times arrivals.sort() departures.sort() # Initialize the variables needed to find the answer platform_needed = 0 max_platform_needed = 0 i, j = 0, 0 # Use two pointers to traverse the arrivals and departures while i < N and j < N: if arrivals[i] < departures[j]: platform_needed += 1 if platform_needed > max_platform_needed: max_platform_needed = platform_needed i += 1 else: platform_needed -= 1 j += 1 return max_platform_needed"},{"question":"def minimum_flights(n: int, W: int, weights: List[int]) -> int: Determine the minimum number of flights required to deliver all packages. Args: n : int : The number of packages. W : int : The weight capacity of the drone. weights : List[int] : A list of integers representing the weights of the packages. Returns: int : The minimum number of flights required to deliver all packages. >>> minimum_flights(5, 10, [1, 2, 3, 4, 5]) 3 >>> minimum_flights(4, 15, [8, 15, 7, 10]) 3 >>> minimum_flights(1, 10, [5]) 1 >>> minimum_flights(6, 10, [5, 5, 5, 5, 5, 5]) 3 >>> minimum_flights(3, 5, [6, 7, 8]) 3 >>> minimum_flights(3, 1000000000, [1000000000, 999999999, 999999998]) 3 >>> minimum_flights(6, 10, [5, 5, 6, 4, 1, 9]) 3","solution":"def minimum_flights(n, W, weights): weights.sort(reverse=True) flights = 0 i, j = 0, n - 1 while i <= j: if weights[i] + weights[j] <= W: j -= 1 i += 1 flights += 1 return flights # Example usage: # n = 5 # W = 10 # weights = [1, 2, 3, 4, 5] # print(minimum_flights(n, W, weights)) # Output: 3 # n = 4 # W = 15 # weights = [8, 15, 7, 10] # print(minimum_flights(n, W, weights)) # Output: 3"},{"question":"def longestPalindromeSubseq(s1: str) -> int: Given a string s1, find the length of its longest palindromic subsequence. A subsequence is derived from another string by deleting some or no characters without changing the order of the remaining characters. A palindromic subsequence is a subsequence that reads the same forward and backward. Parameters: s1 (str): the input string Returns: int: the length of the longest palindromic subsequence >>> longestPalindromeSubseq(\\"bbabcbcab\\") 7 >>> longestPalindromeSubseq(\\"abba\\") 4 >>> longestPalindromeSubseq(\\"abcd\\") 1","solution":"def longestPalindromeSubseq(s1): Returns the length of the longest palindromic subsequence in s1. n = len(s1) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s1[i] == s1[j]: dp[i][j] = 2 + dp[i + 1][j - 1] if i + 1 <= j - 1 else 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"def find_unique_element(arr): Finds the element that appears only once in the array where all other elements appear exactly twice. >>> find_unique_element([1, 2, 3, 2, 1]) 3 >>> find_unique_element([4, 5, 6, 7, 5, 6, 4]) 7 >>> find_unique_element([8, 9, 10, 9, 8, 11, 10, 12, 12]) 11 >>> find_unique_element([13, 14, 13]) 14 >>> find_unique_element([0, 0, 1]) 1 def unique_elements_in_tests(test_cases): Processes multiple test cases to find the unique element in each case. >>> test_cases = [ >>> (5, [1, 2, 3, 2, 1]), >>> (7, [4, 5, 6, 7, 5, 6, 4]), >>> (9, [8, 9, 10, 9, 8, 11, 10, 12, 12]) >>> ] >>> unique_elements_in_tests(test_cases) [3, 7, 11]","solution":"def find_unique_element(arr): Finds the element that appears only once in the array where all other elements appear exactly twice. unique_element = 0 for num in arr: unique_element ^= num return unique_element def unique_elements_in_tests(test_cases): Processes multiple test cases to find the unique element in each case. results = [] for case in test_cases: _, arr = case result = find_unique_element(arr) results.append(result) return results"},{"question":"def parse_input(n: int, m: int, raw_grid: List[str]) -> List[List[str]]: Parse the grid from the given raw input. >>> parse_input(3, 3, [\\"000\\", \\"010\\", \\"000\\"]) [['0', '0', '0'], ['0', '1', '0'], ['0', '0', '0']] def can_reach_end(grid: List[List[str]], n: int, m: int) -> str: Determines if Nik can reach the bottom-right corner from the top-left corner in a given grid. >>> can_reach_end([['0', '0', '0'], ['0', '1', '0'], ['0', '0', '0']], 3, 3) 'Yes' >>> can_reach_end([['0', '0', '1'], ['0', '1', '0'], ['1', '0', '0']], 3, 3) 'No'","solution":"def can_reach_end(grid, n, m): Determines if Nik can reach the bottom-right corner from the top-left corner in a given grid. Parameters: grid (list of list of str): The grid representation where '0' is a free cell and '1' is a blocked cell n (int): Number of rows in the grid m (int): Number of columns in the grid Returns: str: \\"Yes\\" if Nik can reach the bottom-right corner, \\"No\\" otherwise if grid[0][0] == '1' or grid[n-1][m-1] == '1': return \\"No\\" from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n - 1, m - 1): return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '0': visited.add((nx, ny)) queue.append((nx, ny)) return \\"No\\" # Function to parse the grid from raw input def parse_input(n, m, raw_grid): return [list(raw_grid[i]) for i in range(n)]"},{"question":"def count_words(s: str) -> int: Count the number of words in a string. A word is defined as a sequence of non-space characters separated by at least one space from other words. Parameters: s (str): input string Returns: int: number of words Examples: >>> count_words(\\" Hello, World! \\") 2 >>> count_words(\\"This is a test\\") 4 >>> count_words(\\"count words In THIS Sentence\\") 5 >>> count_words(\\" Leading and trailing spaces \\") 4 >>> count_words(\\"\\") 0 >>> count_words(\\" \\") 0 >>> count_words(\\"word\\") 1 >>> count_words(\\"well, punctuation! and words.\\") 4","solution":"def count_words(s): Count the number of words in a string. A word is defined as a sequence of non-space characters separated by at least one space from other words. Parameters: s (str): input string Returns: int: number of words words = s.split() return len(words)"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string to form the largest possible integer following the rules for placement of '+' and '-'. >>> rearrange_string(\\"1234\\") '4321' >>> rearrange_string(\\"-12+34\\") '-4321' >>> rearrange_string(\\"56+7+8\\") '876+5' >>> rearrange_string(\\"12+34+56\\") '654321' >>> rearrange_string(\\"-543\\") '-543' >>> rearrange_string(\\"-1\\") '-1' >>> rearrange_string(\\"9\\") '9' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"0\\") '0' >>> rearrange_string(\\"10203\\") '32100'","solution":"def rearrange_string(s): Rearranges the string to form the largest possible integer following the rules for placement of '+' and '-'. digits = [] has_minus = False for char in s: if char.isdigit(): digits.append(char) elif char == '-': has_minus = True digits.sort(reverse=True) result = ''.join(digits) if has_minus: return '-' + result else: return result"},{"question":"def process_booking_requests(n, max_tickets, m, requests): Process booking requests and return the number of tickets reserved successfully for each request. :param n: int - Total number of events :param max_tickets: list of int - Maximum tickets available for each event :param m: int - Total number of booking requests :param requests: list of tuple - Each tuple contains (eventDate, ticketsRequested) :return: list of int - Tickets successfully booked for each request >>> process_booking_requests(5, [100, 200, 150, 120, 80], 4, [(1, 50), (3, 200), (2, 150), (5, 90)]) [50, 150, 150, 80] >>> process_booking_requests(3, [100, 50, 75], 4, [(1, 20), (2, 60), (2, 10), (3, 80)]) [20, 50, 0, 75] >>> process_booking_requests(2, [0, 100], 2, [(1, 10), (2, 50)]) [0, 50] >>> process_booking_requests(1, [50], 3, [(1, 20), (1, 20), (1, 20)]) [20, 20, 10] >>> process_booking_requests(4, [100, 200, 300, 400], 4, [(1, 100), (2, 200), (3, 300), (4, 400)]) [100, 200, 300, 400]","solution":"def process_booking_requests(n, max_tickets, m, requests): Process booking requests and return the number of tickets reserved successfully for each request. :param n: int - Total number of events :param max_tickets: list of int - Maximum tickets available for each event :param m: int - Total number of booking requests :param requests: list of tuple - Each tuple contains (eventDate, ticketsRequested) :return: list of int - Tickets successfully booked for each request results = [] remaining_tickets = max_tickets[:] for event_date, tickets_requested in requests: available_tickets = remaining_tickets[event_date - 1] booked_tickets = min(tickets_requested, available_tickets) results.append(booked_tickets) remaining_tickets[event_date - 1] -= booked_tickets return results"},{"question":"def perform_operations(n: int, m: int, initial_list: List[int], operations: List[List[int]]) -> List[int]: Perform update and range sum operations on a list of integers. Args: - n (int): number of elements in the list. - m (int): number of operations to be performed. - initial_list (List[int]): initial list of integers. - operations (List[List[int]]): list of operations where each operation is either: 1. [1, x, y] to update the element at index x to y. 2. [2, l, r] to find the sum of elements from index l to r (both inclusive). Returns: - List[int]: results of the sum operations. Example: >>> perform_operations(5, 5, [1, 2, 3, 4, 5], [[2, 1, 3], [2, 2, 5], [1, 3, 10], [2, 1, 3], [2, 3, 5]]) [6, 14, 13, 19] >>> perform_operations(5, 3, [1, 2, 3, 4, 5], [[1, 3, 10], [2, 1, 5], [2, 3, 3]]) [22, 10]","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, value): while index <= self.size: self.tree[index] += value index += index & -index def prefix_sum(self, index): result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def range_sum(self, left, right): return self.prefix_sum(right) - self.prefix_sum(left - 1) def perform_operations(n, m, initial_list, operations): fenwick_tree = FenwickTree(n) # Initialize Fenwick Tree for i in range(n): fenwick_tree.update(i + 1, initial_list[i]) results = [] for operation in operations: if operation[0] == 1: index, new_value = operation[1], operation[2] current_value = fenwick_tree.range_sum(index, index) fenwick_tree.update(index, new_value - current_value) elif operation[0] == 2: left, right = operation[1], operation[2] results.append(fenwick_tree.range_sum(left, right)) return results"},{"question":"def min_jumps(T: int, test_cases: List[Dict]) -> List[int]: Determine the minimum number of jumps required to move from a starting platform to a target platform. If it is impossible to reach the target platform, return -1. Parameters: T (int): Number of test cases. test_cases (List[Dict]): A list of dictionaries, each representing a test case with the following keys: - start_target (tuple): A tuple of integers (x_start, y_start, y_target) indicating the x-coordinate and y-coordinate of the starting platform and the y-coordinate of the target platform. - N (int): Number of platforms. - platforms (List[Tuple[int, int, int]]): A list of tuples, each representing a platform with the starting x-coordinate, ending x-coordinate, and height y. Returns: List[int]: A list of integers, each representing the minimum number of jumps needed to reach the target platform for each test case, or -1 if it is not possible. Example: >>> T = 2 >>> test_cases = [ >>> {'start_target': (0, 0, 3), 'N': 3, 'platforms': [(-1, 1, 1), (-2, 0, 2), (0, 2, 3)]}, >>> {'start_target': (0, 0, 3), 'N': 3, 'platforms': [(-1, 1, 1), (-2, 0, 2), (0, 2, 4)]} >>> ] >>> min_jumps(T, test_cases) [1, -1]","solution":"from collections import deque def min_jumps(T, test_cases): results = [] for case in test_cases: x_start, y_start, y_target = case['start_target'] N = case['N'] platforms = case['platforms'] # Add the starting platform to the platforms set platforms.append((x_start, x_start, y_start)) # Create a graph (adjacency list) of platforms graph = {} for i in range(len(platforms)): graph[i] = [] for j in range(len(platforms)): if i != j and platforms[i][2] != platforms[j][2]: # Check if platforms[i] and platforms[j] are overlapping on the x-axis if platforms[i][0] <= platforms[j][1] and platforms[j][0] <= platforms[i][1]: graph[i].append(j) # Use BFS to find the shortest path from the starting platform to any target platform start_index = len(platforms) - 1 queue = deque([(start_index, 0)]) visited = set() while queue: current, jumps = queue.popleft() visited.add(current) # Check if we have reached the target height if platforms[current][2] == y_target: results.append(jumps) break for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, jumps + 1)) else: results.append(-1) return results # Example usage T = 2 test_cases = [ {'start_target': (0, 0, 3), 'N': 3, 'platforms': [(-1, 1, 1), (-2, 0, 2), (0, 2, 3)]}, {'start_target': (0, 0, 3), 'N': 3, 'platforms': [(-1, 1, 1), (-2, 0, 2), (0, 2, 4)]} ] print(min_jumps(T, test_cases))"},{"question":"def min_removals_to_make_anagrams(t: int, test_cases: List[Tuple[str, str]]) -> List[int]: Determine the minimum number of characters to remove from two strings to make them anagrams of each other. Args: t (int): The number of test cases. test_cases (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings. Returns: List[int]: A list of integers representing the minimum number of characters to remove for each test case. Examples: >>> min_removals_to_make_anagrams(2, [(\\"cde\\", \\"abc\\"), (\\"abcd\\", \\"efgh\\")]) [4, 8] >>> min_removals_to_make_anagrams(1, [(\\"a\\", \\"a\\")]) [0]","solution":"def min_removals_to_make_anagrams(t, test_cases): from collections import Counter def count_removals(A, B): count_A = Counter(A) count_B = Counter(B) # Calculate characters to remove from both A and B removals = 0 # Characters in A not in B for char in count_A: if char in count_B: removals += abs(count_A[char] - count_B[char]) else: removals += count_A[char] # Characters in B not in A for char in count_B: if char not in count_A: removals += count_B[char] return removals results = [] for A, B in test_cases: results.append(count_removals(A, B)) return results"},{"question":"def max_teams(S, M): Determines the maximum number of complete teams that can be formed and the number of unassigned players. Parameters: S (int): Total number of players M (int): Number of players per team Returns: tuple: (Maximum number of complete teams, Number of unassigned players) Examples: >>> max_teams(10, 3) (3, 1) >>> max_teams(25, 5) (5, 0) def tournament_result(test_cases): Processes multiple test cases to determine the results for each. Parameters: test_cases (list): List of tuples where each tuple contains integers S and M Returns: list: List of results for each test case Examples: >>> tournament_result([(10, 3), (25, 5)]) [(3, 1), (5, 0)]","solution":"def max_teams(S, M): Returns the maximum number of complete teams that can be formed and the number of unassigned players. Parameters: S (int): total number of players M (int): number of players per team Returns: tuple: (maximum number of complete teams, number of unassigned players) if M == 0: # Prevent division by zero return 0, S teams = S // M unassigned = S % M return teams, unassigned def tournament_result(test_cases): Processes multiple test cases to determine the results for each. Parameters: test_cases (list): List of tuples where each tuple contains integers S and M Returns: list: List of results for each test case results = [max_teams(S, M) for S, M in test_cases] return results"},{"question":"from typing import List def hash_func(data: str) -> str: Computes and returns the hash of the given data block. import hashlib return hashlib.sha256(data.encode('utf-8')).hexdigest() def merkle_tree(data_blocks: List[str]) -> str: Constructs a balanced Merkle Tree given a list of data blocks and returns the root hash of the constructed Merkle Tree. >>> merkle_tree([\\"data1\\", \\"data2\\", \\"data3\\"]) \\"hash_of_the_root_node\\" >>> merkle_tree([\\"data1\\", \\"data2\\", \\"data3\\", \\"data4\\"]) \\"hash_of_the_root_node\\" pass","solution":"import hashlib from typing import List def hash_func(data: str) -> str: return hashlib.sha256(data.encode('utf-8')).hexdigest() def merkle_tree(data_blocks: List[str]) -> str: def compute_merkle_root(leaves): while len(leaves) > 1: if len(leaves) % 2 == 1: leaves.append(leaves[-1]) leaves = [hash_func(leaves[i] + leaves[i + 1]) for i in range(0, len(leaves), 2)] return leaves[0] # Adding extra nodes if the number of input blocks is not a power of 2 n = len(data_blocks) next_power_of_2 = 1 while next_power_of_2 < n: next_power_of_2 *= 2 while len(data_blocks) < next_power_of_2: data_blocks.append(\\"ExtraNode\\") # Compute the hash for all leaf nodes hashed_leaves = [hash_func(data) for data in data_blocks] # Compute the Merkle root root_hash = compute_merkle_root(hashed_leaves) return root_hash"},{"question":"def check_meeting_overlap(meetings): Determines if any meetings overlap. Parameters: meetings (list of list of int): A list where each sublist contains two integers representing the start and end time of a meeting. Returns: str: 'Overlap' if any meetings overlap, otherwise 'No Overlap'. # Example usage # >>> check_meeting_overlap([[1, 3], [2, 5], [6, 8]]) # \\"Overlap\\" # >>> check_meeting_overlap([[1, 2], [3, 4], [5, 6]]) # \\"No Overlap\\" pass","solution":"def check_meeting_overlap(meetings): Determines if any meetings overlap. Parameters: meetings (list of list of int): A list where each sublist contains two integers representing the start and end time of a meeting. Returns: str: 'Overlap' if any meetings overlap, otherwise 'No Overlap'. # Sort the meetings based on their start times meetings.sort(key=lambda x: x[0]) for i in range(len(meetings) - 1): # Check if the end time of the current meeting is greater than the start time of the next meeting if meetings[i][1] > meetings[i + 1][0]: return \\"Overlap\\" return \\"No Overlap\\""},{"question":"def kthSmallest(N, K, arr): Returns the Kth smallest element in the list. Parameters: - N: int: the number of elements in the list - K: int: the position of the smallest element to find - arr: list[int]: the list of integers Returns: - int: the Kth smallest element","solution":"def kthSmallest(N, K, arr): Returns the Kth smallest element in the list. Parameters: - N: int: the number of elements in the list - K: int: the position of the smallest element to find - arr: list[int]: the list of integers Returns: - int: the Kth smallest element arr.sort() return arr[K-1]"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum sum of all elements in a path from the top-left corner to the bottom-right corner of the grid, while only being able to move either down or right at any point in time. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [5] ... ]) 5 >>> min_path_sum([ ... [1, 2, 3] ... ]) 6 >>> min_path_sum([ ... [1], ... [2], ... [3] ... ]) 6 >>> min_path_sum([ ... [1, 2, 3, 4], ... [4, 5, 1, 2], ... [7, 8, 9, 0], ... [4, 2, 1, 5] ... ]) 14 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 1] ... ]) 7","solution":"def min_path_sum(grid): Returns the minimum sum of all elements in a path from the top-left corner to the bottom-right corner of the grid, while only being able to move either down or right at any point in time. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a table to store the minimum sum at each point dp = [[0]*cols for _ in range(rows)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1] # Example usage: # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(min_path_sum(grid)) # Output: 7"},{"question":"def canMakeEqual(A: list, N: int) -> int: Determine if it is possible to make all elements in array A equal by performing any number of allowed operations. >>> canMakeEqual([3, 5, 1], 3) 1 >>> canMakeEqual([1, 2, 3, 4], 4) 0","solution":"def canMakeEqual(A, N): Determine if it is possible to make all elements in array A equal by performing any number of allowed operations. Parameters: A (list): The list of integers. N (int): The size of the list. Returns: int: 1 if it is possible to make all elements equal, otherwise 0. odd_count = 0 even_count = 0 for num in A: if num % 2 == 0: even_count += 1 else: odd_count += 1 if odd_count == 0 or even_count == 0: return 1 else: return 0"},{"question":"def rank_students(students): Ranks students based on average scores. Ties are broken by Math scores, then by names alphabetically. Args: students (list of dict): A list of dictionaries, where each dictionary contains a student's name and their scores in Math, Science, and English. Returns: list of str: A list of student names sorted by their rank. >>> students = [ ... {\\"name\\": \\"John\\", \\"Math\\": 80, \\"Science\\": 90, \\"English\\": 85}, ... {\\"name\\": \\"Doe\\", \\"Math\\": 90, \\"Science\\": 70, \\"English\\": 80}, ... {\\"name\\": \\"Jane\\", \\"Math\\": 85, \\"Science\\": 80, \\"English\\": 80}, ... {\\"name\\": \\"Smith\\", \\"Math\\": 90, \\"Science\\": 85, \\"English\\": 90} ... ] >>> rank_students(students) ['Smith', 'John', 'Jane', 'Doe'] >>> students_tie_by_math_score = [ ... {\\"name\\": \\"Alice\\", \\"Math\\": 85, \\"Science\\": 90, \\"English\\": 80}, ... {\\"name\\": \\"Bob\\", \\"Math\\": 75, \\"Science\\": 90, \\"English\\": 90}, ... {\\"name\\": \\"Charlie\\", \\"Math\\": 85, \\"Science\\": 90, \\"English\\": 80} ... ] >>> rank_students(students_tie_by_math_score) ['Alice', 'Charlie', 'Bob'] >>> students_tie_by_name = [ ... {\\"name\\": \\"Charlie\\", \\"Math\\": 85, \\"Science\\": 85, \\"English\\": 80}, ... {\\"name\\": \\"Bobby\\", \\"Math\\": 85, \\"Science\\": 85, \\"English\\": 80}, ... {\\"name\\": \\"Alice\\", \\"Math\\": 85, \\"Science\\": 85, \\"English\\": 80} ... ] >>> rank_students(students_tie_by_name) ['Alice', 'Bobby', 'Charlie'] >>> students_all_equal = [ ... {\\"name\\": \\"Eve\\", \\"Math\\": 50, \\"Science\\": 50, \\"English\\": 50}, ... {\\"name\\": \\"Dave\\", \\"Math\\": 50, \\"Science\\": 50, \\"English\\": 50}, ... {\\"name\\": \\"Carol\\", \\"Math\\": 50, \\"Science\\": 50, \\"English\\": 50} ... ] >>> rank_students(students_all_equal) ['Carol', 'Dave', 'Eve']","solution":"def rank_students(students): Ranks students based on average scores. Ties are broken by Math scores, then by names alphabetically. Args: students (list of dict): A list of dictionaries, where each dictionary contains a student's name and their scores in Math, Science, and English. Returns: list of str: A list of student names sorted by their rank. # Calculate the average score for each student and store it in a tuple students_with_avg = [] for student in students: avg_score = (student[\\"Math\\"] + student[\\"Science\\"] + student[\\"English\\"]) / 3 students_with_avg.append((student[\\"name\\"], avg_score, student[\\"Math\\"])) # Sort primarily by average score (descending), then by Math score (descending), then by name (alphabetically) students_with_avg.sort(key=lambda x: (-x[1], -x[2], x[0])) # Extract the sorted student names sorted_students = [student[0] for student in students_with_avg] return sorted_students"},{"question":"def count_right_angled_triangles(N: int, points: List[Tuple[int, int]]) -> int: Count the number of right-angled triangles that can be formed with the given points such that each triangle's legs are parallel to the X and Y axes. >>> count_right_angled_triangles(4, [(1, 2), (2, 2), (1, 3), (2, 3)]) 4 >>> count_right_angled_triangles(3, [(0, 0), (1, 1), (2, 2)]) 0","solution":"def count_right_angled_triangles(N, points): from collections import defaultdict x_count = defaultdict(int) y_count = defaultdict(int) for x, y in points: x_count[x] += 1 y_count[y] += 1 num_triangles = 0 for x, y in points: num_triangles += (x_count[x] - 1) * (y_count[y] - 1) return num_triangles # Test the function with an example input print(count_right_angled_triangles(4, [(1, 2), (2, 2), (1, 3), (2, 3)])) # Output should be 4"},{"question":"def zigzag(arr): Arrange the given list of book identifiers in a zigzag pattern >>> zigzag([5, 3, 7, 8, 2]) [8, 2, 7, 3, 5] >>> zigzag([1, 4, 3, 2]) [4, 1, 3, 2] pass # Implement the function here def process_test_cases(test_cases): Process multiple test cases for arranging books in a zigzag pattern. >>> process_test_cases([(5, [5, 3, 7, 8, 2]), (4, [1, 4, 3, 2])]) ['8 2 7 3 5', '4 1 3 2'] pass # Implement the function here","solution":"def zigzag(arr): Arrange the given list of book identifiers in a zigzag pattern arr.sort(reverse=True) result = [] for i in range(len(arr) // 2): result.append(arr[i]) result.append(arr[-(i+1)]) if len(arr) % 2 != 0: result.append(arr[len(arr) // 2]) return result def process_test_cases(test_cases): result = [] for n, books in test_cases: zigzag_books = zigzag(books) result.append(\\" \\".join(map(str, zigzag_books))) return result"},{"question":"def subset_sum(weights: List[int], target: int) -> bool: Determine whether there exists a subset of the given weights whose sum is exactly equal to the target weight. >>> subset_sum([1, 3, 9, 2], 5) True >>> subset_sum([4, 7, 11, 1], 10) False >>> subset_sum([8, 3, 5, 6], 17) True >>> subset_sum([5], 5) True >>> subset_sum([4], 5) False >>> subset_sum([2, 3], 5) True >>> subset_sum([2, 3, 5], 0) True >>> subset_sum([5, 6, 7], 4) False","solution":"def subset_sum(weights, target): n = len(weights) # Create a 2D dp array where dp[i][j] will be True if # there is a subset of weights[0..i-1] with sum equal to j dp = [[False] * (target + 1) for _ in range(n + 1)] # There is always a subset with sum 0, which is the empty set for i in range(n + 1): dp[i][0] = True # Fill the dp array for i in range(1, n + 1): for j in range(1, target + 1): if j < weights[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j - weights[i-1]] return dp[n][target]"},{"question":"def reverse_lexicographical_order(input_string: str) -> str: Rearranges the words in the input string in reverse lexicographical order. Args: - input_string (str): A string containing words separated by single spaces. Returns: - str: A new string with words rearranged in reverse lexicographical order. >>> reverse_lexicographical_order(\\"the quick brown fox jumps over the lazy dog\\") \\"the the quick over lazy jumps fox dog brown\\" >>> reverse_lexicographical_order(\\"banana apple cherry\\") \\"cherry banana apple\\" >>> reverse_lexicographical_order(\\"a ab abc\\") \\"abc ab a\\"","solution":"def reverse_lexicographical_order(input_string): This function rearranges the words in the input string in reverse lexicographical order. Args: - input_string (str): A string containing words separated by single spaces. Returns: - str: A new string with words rearranged in reverse lexicographical order. words = input_string.split() words.sort(reverse=True) return ' '.join(words)"},{"question":"def minimum_road_length(test_cases): Determine the total length of the selected paths to maintain connectivity while minimizing the total road length. >>> minimum_road_length([ (4, 5, [(0, 1, 3), (0, 2, 2), (0, 3, 4), (1, 2, 5), (2, 3, 4)]), (5, 7, [(0, 1, 1), (0, 2, 4), (0, 3, 3), (1, 2, 2), (1, 4, 6), (2, 3, 5), (3, 4, 7)]) ]) [9, 12] >>> minimum_road_length([ (2, 1, [(0, 1, 10)]) ]) [10] >>> minimum_road_length([ (3, 3, [(0, 1, 1), (0, 2, 2), (1, 2, 3)]) ]) [3]","solution":"def find(parent, i): # Function to find the root of the subset including 'i' using path compression if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): # Function to unite two subsets x and y using union by rank root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, edges): # Function to implement Kruskal's algorithm to find MST of a graph mst_length = 0 parent = list(range(n)) rank = [0] * n # Sort edges based on their weight edges.sort(key=lambda x: x[2]) for u, v, w in edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst_length += w union(parent, rank, root_u, root_v) return mst_length def minimum_road_length(test_cases): results = [] for n, m, edges in test_cases: mst_result = kruskal_mst(n, edges) results.append(mst_result) return results"},{"question":"from typing import List def running_sum(nums: List[int]) -> List[int]: Calculate the running sum of a one-dimensional array of integers. Test arrays are limited to a size of 1-50. >>> running_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> running_sum([5, 10, 15]) [5, 15, 30] >>> running_sum([1, -1, 1, -1]) [1, 0, 1, 0] pass def test_running_sum_positive_numbers(): assert running_sum([1, 2, 3, 4]) == [1, 3, 6, 10] def test_running_sum_mixed_numbers(): assert running_sum([1, -1, 1, -1]) == [1, 0, 1, 0] def test_running_sum_single_element(): assert running_sum([5]) == [5] def test_running_sum_multiple_elements(): assert running_sum([5, 10, 15]) == [5, 15, 30] def test_running_sum_negative_numbers(): assert running_sum([-1, -2, -3, -4]) == [-1, -3, -6, -10] def test_running_sum_large_array(): assert running_sum(list(range(1, 51))) == [ sum(list(range(1, i + 1))) for i in range(1, 51) ]","solution":"def running_sum(nums): Returns the running sum of a one-dimensional array of integers. running_totals = [] current_sum = 0 for num in nums: current_sum += num running_totals.append(current_sum) return running_totals"},{"question":"from typing import List def get_prime_numbers(arr: List[int]) -> List[int]: Returns a list of prime numbers from the given array. Note that 1 is not considered a prime number. >>> get_prime_numbers([1, 4, 6, 8, 10]) [] >>> get_prime_numbers([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> get_prime_numbers([4, 6, 7, 9, 11]) [7, 11] >>> get_prime_numbers([-2, -3, -5, 3, 5]) [3, 5] >>> get_prime_numbers([]) [] >>> get_prime_numbers([1]) [] >>> get_prime_numbers([7]) [7] >>> get_prime_numbers([29, 87, 91, 97, 101]) [29, 97, 101]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def get_prime_numbers(arr): Returns a list of prime numbers from the given array. return [num for num in arr if is_prime(num)]"},{"question":"def can_form_amount_with_coins(amount: int) -> str: Determines if the amount can be formed using coins of 3, 7, and 11 units. >>> can_form_amount_with_coins(10) \\"YES\\" >>> can_form_amount_with_coins(14) \\"YES\\" >>> can_form_amount_with_coins(1) \\"NO\\" >>> can_form_amount_with_coins(30) \\"YES\\" # Implementation goes here def solve(t: int, amounts: List[int]) -> List[str]: Solves multiple test cases to determine if amounts can be formed using coins. >>> solve(4, [10, 14, 1, 30]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] # Implementation goes here","solution":"def can_form_amount_with_coins(amount): Returns \\"YES\\" if the amount can be formed using coins of 3, 7, and 11 units. Returns \\"NO\\" otherwise. for x in range(amount // 11 + 1): for y in range((amount - 11*x) // 7 + 1): remaining = amount - 11*x - 7*y if remaining >= 0 and remaining % 3 == 0: return \\"YES\\" return \\"NO\\" def solve(t, amounts): results = [] for amount in amounts: results.append(can_form_amount_with_coins(amount)) return results"},{"question":"def is_powerful_magic_square(n: int, grid: List[List[int]]) -> str: Determine if the given n by n grid of integers representing the artifact is powerful. A magic square is powerful if it satisfies: 1. All the integers in each row are unique. 2. All the integers in each column are unique. 3. The sum of the integers in each row is equal to the sum of the integers in each column. >>> is_powerful_magic_square(3, [ ... [4, 9, 2], ... [3, 5, 7], ... [8, 1, 6]]) \\"Powerful\\" >>> is_powerful_magic_square(3, [ ... [4, 9, 2], ... [3, 5, 7], ... [7, 1, 6]]) \\"Not Powerful\\"","solution":"def is_powerful_magic_square(n, grid): def all_unique(lst): return len(set(lst)) == len(lst) target_sum = sum(grid[0]) for i in range(n): # Check if all elements in the row are unique if not all_unique(grid[i]): return \\"Not Powerful\\" # Check if the row sums to the target if sum(grid[i]) != target_sum: return \\"Not Powerful\\" # Check if all elements in the column are unique column = [grid[row][i] for row in range(n)] if not all_unique(column): return \\"Not Powerful\\" # Check if the column sums to the target if sum(column) != target_sum: return \\"Not Powerful\\" return \\"Powerful\\""},{"question":"from typing import List, Tuple def longest_arithmetic_subsequence(arr: List[int]) -> int: Returns the length of the longest arithmetic subsequence where the difference between consecutive elements is the same. >>> longest_arithmetic_subsequence([1, 7, 10, 15, 27]) == 2 >>> longest_arithmetic_subsequence([1, 5, 7, 8, 5, 15]) == 3 >>> longest_arithmetic_subsequence([-10, -7, -4, -1, 2, 5, 8]) == 7 def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases for finding the length of the longest arithmetic subsequence. >>> T = 2 >>> test_cases = [ >>> (5, [1, 7, 10, 15, 27]), >>> (6, [1, 5, 7, 8, 5, 15]) >>> ] >>> process_test_cases(T, test_cases) == [2, 3]","solution":"def longest_arithmetic_subsequence(arr): Returns the length of the longest arithmetic subsequence where the difference between consecutive elements is the same. if not arr: return 0 n = len(arr) if n == 1: return 1 dp = [{} for _ in range(n)] longest_len = 1 for i in range(n): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest_len = max(longest_len, dp[i][diff]) return longest_len def process_test_cases(T, test_cases): results = [] for case in test_cases: N, arr = case result = longest_arithmetic_subsequence(arr) results.append(result) return results"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the area of the largest rectangle that can be formed by combining adjacent buildings. Args: heights (list): List of integers representing the heights of buildings. Returns: int: The area of the largest rectangle. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4, 2, 1]) 6 pass # Unit tests def test_largest_rectangle_area_sample1(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_largest_rectangle_area_sample2(): assert largest_rectangle_area([2, 4, 2, 1]) == 6 def test_largest_rectangle_area_single_building(): assert largest_rectangle_area([5]) == 5 def test_largest_rectangle_area_two_buildings(): assert largest_rectangle_area([5, 6]) == 10 def test_largest_rectangle_area_all_equal(): assert largest_rectangle_area([3, 3, 3]) == 9 def test_largest_rectangle_area_increasing(): assert largest_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_largest_rectangle_area_decreasing(): assert largest_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_largest_rectangle_area_mixed(): assert largest_rectangle_area([2, 1, 4, 5, 1, 3, 3]) == 8","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed by combining adjacent buildings. Args: heights (list): List of integers representing the heights of buildings. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List, Tuple def shortest_path_in_grid(N: int, M: int, K: int, blocked_cells: List[Tuple[int, int]]) -> Union[int, str]: Find the shortest path from the top-left corner to the bottom-right corner in a 2D grid while avoiding blocked cells. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. K (int): Number of blocked cells. blocked_cells (List[Tuple[int, int]]): List of blocked cells represented by (row, column) tuples. Returns: Union[int, str]: The length of the shortest path or \\"IMPOSSIBLE\\" if no such path exists. Examples: >>> shortest_path_in_grid(4, 4, 3, [(1, 1), (2, 2), (3, 1)]) == 6 >>> shortest_path_in_grid(3, 3, 2, [(1, 0), (1, 2)]) == 4 >>> shortest_path_in_grid(3, 3, 9, [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]) == \\"IMPOSSIBLE\\"","solution":"from collections import deque def shortest_path_in_grid(N, M, K, blocked_cells): Finds the shortest path from the top-left corner to the bottom-right corner in a 2D grid while avoiding blocked cells. Returns the length of the shortest path or \\"IMPOSSIBLE\\" if no such path exists. # Convert blocked_cells list into a set for O(1) lookups blocked = set((r, c) for r, c in blocked_cells) # Directions for moving in the grid (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Check if starting or ending cell is blocked if (0, 0) in blocked or (N-1, M-1) in blocked: return \\"IMPOSSIBLE\\" # Use BFS to find the shortest path queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() # If we've reached the bottom-right corner if r == N-1 and c == M-1: return dist # Try all possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and (nr, nc) not in blocked and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return \\"IMPOSSIBLE\\" # Example usage if __name__ == \\"__main__\\": N, M = 4, 4 K = 3 blocked_cells = [(1, 1), (2, 2), (3, 1)] print(shortest_path_in_grid(N, M, K, blocked_cells)) # Output should be 6"},{"question":"def minTravelTime(n: int, travelTimes: List[List[int]]) -> int: Determine the minimum travel time required to visit all landmarks and return to the starting point. If it is impossible to visit all landmarks, return -1. >>> minTravelTime(1, [[0]]) 0 >>> minTravelTime(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> minTravelTime(3, [[0, 10, 10], [10, 0, 10], [10, 10, 0]]) 30 >>> minTravelTime(3, [[0, 5, 9], [5, 0, 3], [9, 3, 0]]) 17 >>> minTravelTime(2, [[0, float('inf')], [float('inf'), 0]]) -1 pass","solution":"import itertools def minTravelTime(n, travelTimes): Returns the minimum travel time required to visit all landmarks. If it is impossible to visit all landmarks, returns -1. # Special case for single landmark if n == 1: return 0 # To store the minimum path min_path = float('inf') # Generate permutations of all landmarks except the starting point (0) landmarks = range(1, n) permutations = itertools.permutations(landmarks) for perm in permutations: # Calculate the total travel time for the current permutation current_time = travelTimes[0][perm[0]] # From starting point to the first landmark in perm for i in range(len(perm) - 1): current_time += travelTimes[perm[i]][perm[i+1]] current_time += travelTimes[perm[-1]][0] # Returning to the starting point # Update the minimum travel time min_path = min(min_path, current_time) return min_path if min_path != float('inf') else -1"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): from collections import defaultdict tree = {} children = set() for parent, child in nodes: if parent not in tree: tree[parent] = TreeNode(parent) if child not in tree: tree[child] = TreeNode(child) children.add(child) if tree[parent].left is None: tree[parent].left = tree[child] else: tree[parent].right = tree[child] root_val = (set(tree.keys()) - children).pop() return tree[root_val] def binaryTreePaths(nodes): Given a binary tree represented as a list of nodes, return all root-to-leaf paths as strings. >>> binaryTreePaths([(1, 2), (1, 3), (2, 4), (3, 5), (3, 6)]) [\\"1->2->4\\", \\"1->3->5\\", \\"1->3->6\\"] >>> binaryTreePaths([(7, 2), (7, 3), (2, 5), (3, 1)]) [\\"7->2->5\\", \\"7->3->1\\"]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): from collections import defaultdict tree = {} children = set() for parent, child in nodes: if parent not in tree: tree[parent] = TreeNode(parent) if child not in tree: tree[child] = TreeNode(child) children.add(child) if tree[parent].left is None: tree[parent].left = tree[child] else: tree[parent].right = tree[child] root_val = (set(tree.keys()) - children).pop() return tree[root_val] def binaryTreePaths(nodes): if not nodes: return [] root = build_tree(nodes) def dfs(node, path, paths): if node: if not node.left and not node.right: # If it's a leaf paths.append(path + str(node.val)) if node.left: dfs(node.left, path + str(node.val) + \\"->\\", paths) if node.right: dfs(node.right, path + str(node.val) + \\"->\\", paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"from typing import List def highest_energy_level(knights: List[int]) -> int: Determine the highest energy level possible for a single knight after performing any number of teleportation transformations. >>> highest_energy_level([3, 3, 6, 6, 12]) == 24 >>> highest_energy_level([5]) == 5 >>> highest_energy_level([1, 2, 3, 4, 5]) == 5 >>> highest_energy_level([2, 2, 2, 2, 2, 2]) == 8 >>> highest_energy_level([10, 10, 20, 20, 40, 40]) == 80 >>> highest_energy_level([1, 1, 2, 2, 4, 4, 8, 8]) == 16","solution":"def highest_energy_level(knights): from collections import Counter counter = Counter(knights) max_energy = 0 while True: found_combination = False new_counter = Counter() for energy, count in counter.items(): if count > 1: pairs = count // 2 found_combination = True new_counter[2 * energy] += pairs remaining = count % 2 if remaining: new_counter[energy] += remaining else: new_counter[energy] += count if not found_combination: break counter = new_counter max_energy = max(counter.keys()) return max_energy"},{"question":"def find_majority_element(n, arr): Finds the majority element in an array that appears more than ⌊n/2⌋ times. If no such element exists, returns -1. >>> find_majority_element(7, [3, 3, 4, 2, 4, 4, 2, 4]) 4 >>> find_majority_element(5, [1, 1, 2, 2, 3]) -1 >>> find_majority_element(1, [1]) 1 >>> find_majority_element(3, [2, 2, 2]) 2 >>> find_majority_element(6, [1, 2, 3, 3, 3, 3]) 3 >>> find_majority_element(11, [7, 8, 7, 7, 6, 7, 5, 7, 7, 1, 7]) 7","solution":"def find_majority_element(n, arr): Finds the majority element in an array that appears more than ⌊n/2⌋ times. If no such element exists, returns -1. element_count = {} majority_threshold = n // 2 for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 if element_count[num] > majority_threshold: return num return -1"},{"question":"def min_keys_to_escape(n, m, grid, q, doors): Find the minimum number of keys required to unlock all the rooms in order to escape. >>> n, m = 3, 3 >>> grid = [ >>> [\\".\\", \\"K\\", \\".\\"], >>> [\\"#\\", \\".\\", \\"#\\"], >>> [\\"K\\", \\"K\\", \\".\\"] >>> ] >>> q = 1 >>> doors = [(0, 1, 1, 1)] >>> min_keys_to_escape(n, m, grid, q, doors) 2 >>> n, m = 4, 4 >>> grid = [ >>> [\\".\\", \\"K\\", \\"#\\", \\"K\\"], >>> [\\"#\\", \\".\\", \\".\\", \\"#\\"], >>> [\\"K\\", \\"K\\", \\".\\", \\"K\\"], >>> [\\".\\", \\"#\\", \\"K\\", \\".\\"] >>> ] >>> q = 2 >>> doors = [(0, 2, 1, 2), (2, 1, 3, 1)] >>> min_keys_to_escape(n, m, grid, q, doors) 3","solution":"def min_keys_to_escape(n, m, grid, q, doors): from collections import deque, defaultdict def is_valid(x, y, n, m): return 0 <= x < n and 0 <= y < m def bfs(start, end, grid, required_doors): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(start[0], start[1], set())]) visited = set((start[0], start[1])) while queue: x, y, keys = queue.popleft() if (x, y) == end: return len(keys) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, n, m) and (nx, ny) not in visited: if grid[nx][ny] == '#': if (x, y, nx, ny) in required_doors and required_doors[(x, y, nx, ny)] in keys: queue.append((nx, ny, keys)) visited.add((nx, ny)) else: new_keys = keys.copy() if grid[nx][ny] == 'K': new_keys.add((nx, ny)) queue.append((nx, ny, new_keys)) visited.add((nx, ny)) return -1 required_doors = defaultdict(set) for r1, c1, r2, c2 in doors: if grid[r1][c1] == 'K': required_doors[(r1, c1, r2, c2)] = (r1, c1) elif grid[r2][c2] == 'K': required_doors[(r1, c1, r2, c2)] = (r2, c2) return bfs((0, 0), (n-1, m-1), grid, required_doors)"},{"question":"def min_operations_to_make_sequences_identical(n, a, b): Determine the minimum number of operations required to make sequences a and b identical. Parameters: n (int): The number of elements in each sequence. a (List[int]): The elements of sequence a. b (List[int]): The elements of sequence b. Returns: int: The minimum number of operations required to make sequences a and b identical. Examples: >>> min_operations_to_make_sequences_identical(6, [1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]) 6 >>> min_operations_to_make_sequences_identical(4, [1, 2, 3, 4], [1, 2, 3, 4]) 0 >>> min_operations_to_make_sequences_identical(5, [1, 1, 2, 2, 3], [1, 1, 3, 3, 3]) 2","solution":"def min_operations_to_make_sequences_identical(n, a, b): Determine the minimum number of operations required to make sequences a and b identical. from collections import defaultdict # Dictionary to count mismatches mismatch_count = defaultdict(int) # Count mismatches for i in range(n): if a[i] != b[i]: mismatch_count[(a[i], b[i])] += 1 return sum(mismatch_count.values())"},{"question":"def generate_pyramid(N): Generate a pyramid of height N. The first level has 1 integer, the second level has 2 integers, and so on. All integers are in increasing order starting from 1. Parameters: N (int): Height of the pyramid. Returns: List[List[int]]: A list of lists representing the pyramid. >>> generate_pyramid(1) [[1]] >>> generate_pyramid(2) [[1], [2, 3]] >>> generate_pyramid(3) [[1], [2, 3], [4, 5, 6]] >>> generate_pyramid(4) [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]] def process_test_cases(test_cases): Process multiple test cases to generate pyramids for each height specified. Parameters: test_cases (List[int]): A list of integers where each integer represents the height of a pyramid. Returns: List[List[List[int]]]: A list where each element is a pyramid generated for corresponding height in test_cases. >>> process_test_cases([2, 3]) [[[1], [2, 3]], [[1], [2, 3], [4, 5, 6]]] >>> process_test_cases([1]) [[[1]]] >>> process_test_cases([4, 2]) [[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]], [[1], [2, 3]]]","solution":"def generate_pyramid(N): result = [] current_number = 1 for level in range(1, N + 1): current_level = [] for _ in range(level): current_level.append(current_number) current_number += 1 result.append(current_level) return result def process_test_cases(test_cases): result = [] for N in test_cases: pyramid = generate_pyramid(N) result.append(pyramid) return result"},{"question":"def max_fruits_collected(N: int, K: int, R: List[int]) -> int: This function returns the maximum number of luminous fruits that can be collected in one hour from any segment of K consecutive Luminarias. Args: N : int : number of Luminarias K : int : number of consecutive Luminarias R : list of int : list of rate of fruit drop per hour for each Luminaria Returns: int : maximum number of luminous fruits that can be collected in one hour >>> max_fruits_collected(6, 3, [10, 20, 30, 40, 50, 60]) 150 >>> max_fruits_collected(8, 4, [5, 5, 5, 5, 5, 5, 5, 5]) 20","solution":"def max_fruits_collected(N, K, R): This function returns the maximum number of luminous fruits that can be collected in one hour from any segment of K consecutive Luminarias. Args: N : int : number of Luminarias K : int : number of consecutive Luminarias R : list of int : list of rate of fruit drop per hour for each Luminaria Returns: int : maximum number of luminous fruits that can be collected in one hour # Calculate the sum of the first K elements current_sum = sum(R[:K]) max_sum = current_sum # Apply sliding window technique for i in range(K, N): current_sum += R[i] - R[i-K] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List, Tuple def is_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if the given graph is a tree. Parameters: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of tuples representing the edges. Returns: str: \\"YES\\" if the graph is a tree, otherwise \\"NO\\". Example: >>> is_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) 'YES' >>> is_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'NO' pass import pytest def test_is_tree_yes(): assert is_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"YES\\" def test_is_tree_no_cycle(): assert is_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"NO\\" def test_is_tree_disconnected(): assert is_tree(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" def test_is_tree_single_node(): assert is_tree(1, 0, []) == \\"YES\\" def test_is_tree_min_connected(): assert is_tree(2, 1, [(1, 2)]) == \\"YES\\" def test_is_tree_exact_tree_structure(): assert is_tree(3, 2, [(1, 2), (1, 3)]) == \\"YES\\" def test_is_tree_complex_yes(): assert is_tree(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"YES\\" def test_is_tree_complex_no(): assert is_tree(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == \\"NO\\"","solution":"def is_tree(n, m, edges): Determines if the given graph is a tree. :param n: Number of nodes in the graph. :param m: Number of edges in the graph. :param edges: List of tuples representing the edges. :return: \\"YES\\" if the graph is a tree, otherwise \\"NO\\". if m != n - 1: return \\"NO\\" from collections import defaultdict, deque # Create adjacency list for the graph adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # BFS or DFS to check if the graph is connected visited = set() queue = deque([1]) # Starting from node 1 while queue: node = queue.popleft() if node in visited: continue visited.add(node) for neighbor in adj_list[node]: if neighbor not in visited: queue.append(neighbor) # The graph is a tree if it's connected (all nodes are visited) return \\"YES\\" if len(visited) == n else \\"NO\\" # You can test the solution with the following sample inputs: # Example 1: print(is_tree(4, 3, [(1, 2), (2, 3), (3, 4)])) # Should return \\"YES\\" # Example 2: print(is_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])) # Should return \\"NO\\""},{"question":"def merge_intervals(intervals): Merge overlapping time intervals. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5], [7, 9]]) [[1, 5], [7, 9]] >>> merge_intervals([[8, 10], [1, 3], [15, 18]]) [[1, 3], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [2, 5], [7, 9]]) [[1, 5], [7, 9]] >>> merge_intervals([[1, 4]]) [[1, 4]] >>> merge_intervals([]) [] >>> merge_intervals([[3, 6], [1, 3], [8, 10], [2, 4]]) [[1, 6], [8, 10]]","solution":"def merge_intervals(intervals): if not intervals: return [] # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # if the list of merged intervals is empty or if the current interval does not overlap with the previous if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # there is an overlap, so we merge the current interval with the previous one merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def max_collectable_value(n: int, m: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Given a directed graph with \`n\` nodes and \`m\` edges, each node has a value associated with it. Determine the maximum value that one can collect by starting at any node and following the directed edges to reach other nodes, ensuring that each node is visited at most once. Parameters: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. values (List[int]): The values associated with the nodes. edges (List[Tuple[int, int]]): Directed edges in the graph. Returns: int: The maximum value that can be collected. Examples: >>> max_collectable_value( ... 4, 3, ... [5, 10, 20, 15], ... [(1, 2), (2, 3), (3, 4)] ... ) # 50 >>> max_collectable_value( ... 4, 2, ... [8, 6, 7, 3], ... [(1, 2), (2, 3)] ... ) # 21 >>> max_collectable_value( ... 5, 0, ... [10, 20, 30, 40, 50], ... [] ... ) # 50 >>> max_collectable_value( ... 0, 0, ... [], ... [] ... ) # 0 >>> max_collectable_value( ... 3, 2, ... [1, 2, 3], ... [(1, 2), (2, 3)] ... ) # 6 >>> max_collectable_value( ... 4, 4, ... [10, 20, 30, 40], ... [(1, 2), (3, 4), (2, 3), (1, 4)] ... ) # 100 >>> max_collectable_value( ... 6,5, ... [5, 8, 2, 1, 4, 7], ... [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] ... ) # 27","solution":"def max_collectable_value(n, m, values, edges): from collections import defaultdict, deque if n == 0: return 0 graph = defaultdict(list) indegree = [0] * n for u, v in edges: graph[u-1].append(v-1) indegree[v-1] += 1 dp = values[:] # dp[i] stores the max collectable value ending at node i # Perform topological sort using Kahn's algorithm queue = deque([i for i in range(n) if indegree[i] == 0]) while queue: node = queue.popleft() for neighbor in graph[node]: dp[neighbor] = max(dp[neighbor], dp[node] + values[neighbor]) indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return max(dp)"},{"question":"def search_range(nums, target): Returns the starting and ending position of a given target value in a sorted list of integers. If the target is not found, returns [-1, -1]. >>> search_range([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> search_range([5, 7, 7, 8, 8, 10], 6) [-1, -1] >>> search_range([8], 8) [0, 0] >>> search_range([10], 8) [-1, -1] >>> search_range([], 8) [-1, -1] >>> search_range([1, 1, 2, 2, 2, 3, 3, 4], 2) [2, 4] >>> search_range([1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5], 3) [4, 7]","solution":"def search_range(nums, target): Returns the starting and ending position of a given target value in a sorted list of integers. If the target is not found, returns [-1, -1]. def find_start(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] >= target: right = mid - 1 else: left = mid + 1 return left def find_end(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right start = find_start(nums, target) end = find_end(nums, target) # Validate the range if start <= end and start < len(nums) and nums[start] == target and nums[end] == target: return [start, end] return [-1, -1]"},{"question":"def calculate_total_scores(T: int, test_cases: list) -> list: For each test case, calculates the total score for each participant based on their reading lists. Parameters: T : int Number of test cases. test_cases : list of dict Each dict contains the number of participants (N), number of unique books (M), scores array (B), and reading lists of each participant (lists_of_books_read). Returns: list of list of int Total scores for each participant in all test cases. >>> test_cases = [ { 'N': 2, 'M': 3, 'B': [4, 5, 6], 'reading_lists': [ [1, 2], [2, 3] ] }, { 'N': 3, 'M': 2, 'B': [7, 8], 'reading_lists': [ [], [2, 3, 1] ] } ] calculate_total_scores(2, test_cases) [[9, 11], [0, 18]]","solution":"def calculate_total_scores(T, test_cases): For each test case, calculates the total score for each participant based on their reading lists. Parameters: T : int Number of test cases. test_cases : list of dict Each dict contains the number of participants (N), number of unique books (M), scores array (B), and reading lists of each particpant (lists_of_books_read). Returns: list of list of int Total scores for each participant in all test cases. results = [] for case in test_cases: N = case['N'] M = case['M'] B = case['B'] reading_lists = case['reading_lists'] # Calculate the total scores for each participant scores = [] for reading_list in reading_lists: total_score = 0 for book_id in reading_list: total_score += B[book_id - 1] scores.append(total_score) results.append(scores) return results # Example Usage if __name__ == \\"__main__\\": T = 2 test_cases = [ { 'N': 2, 'M': 3, 'B': [4, 5, 6], 'reading_lists': [ [1, 2], [2, 3] ] }, { 'N': 3, 'M': 2, 'B': [7, 8], 'reading_lists': [ [], [2, 3, 1] ] } ] results = calculate_total_scores(T, test_cases) for result in results: for score in result: print(score)"},{"question":"def max_subarray_sum(arr): Finds the maximum sum of any subarray (contiguous sequence of the array) using Kadane's algorithm. >>> max_subarray_sum([1, 2, -1, 2, -3]) == 4 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([1, 2, 3, 4, -10, 10]) == 10 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) == 10 >>> max_subarray_sum([-1, -2, 3, -1, -2]) == 3 >>> max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5]) == 18 pass def process_test_cases(t, test_cases): Process multiple test cases and return the results as a list. >>> process_test_cases(3, [(5, [1, 2, -1, 2, -3]), (4, [-1, -2, -3, -4]), (6, [1, 2, 3, 4, -10, 10])]) == [4, -1, 10] >>> process_test_cases(2, [(3, [-1, -2, -3]), (3, [3, -1, 2])]) == [-1, 4] pass","solution":"def max_subarray_sum(arr): Finds the maximum sum of any subarray (contiguous sequence of the array) using Kadane's algorithm. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def process_test_cases(t, test_cases): results = [] for n, arr in test_cases: result = max_subarray_sum(arr) results.append(result) return results"},{"question":"def longest_substring(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> longest_substring(\\"eceba\\") 3 >>> longest_substring(\\"a\\") 1 >>> longest_substring(\\"ccaabbb\\") 5 >>> longest_substring(\\"abaccc\\") 4 >>> longest_substring(\\"abcABC\\") 2 >>> longest_substring(\\"aabbccbb\\") 6 >>> longest_substring(\\"abcdef\\") 2","solution":"def longest_substring(s): Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n left = 0 right = 0 hashmap = {} max_len = 2 while right < n: hashmap[s[right]] = right if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def can_king_reach_bottom(n: int, h: int, grid: List[List[int]]) -> str: Determine if the king can reach the bottom-right corner starting from the top-left corner given the elevation constraints. >>> t, test_cases = parse_input(\\"2n3 2n1 2 3n2 4 5n3 5 6n3 1n1 2 3n2 4 5n3 5 6n\\") >>> process_test_cases(t, test_cases) ['YES', 'NO'] >>> t, test_cases = parse_input(\\"1n1 0n0n\\") >>> process_test_cases(t, test_cases) ['YES'] >>> t, test_cases = parse_input(\\"1n2 1n1 3n4 5n\\") >>> process_test_cases(t, test_cases) ['NO'] >>> t, test_cases = parse_input(\\"1n2 10000n1 100n100 200n\\") >>> process_test_cases(t, test_cases) ['YES'] >>> grid = [[0] * 500 for _ in range(500)] >>> input_data = \\"1n500 0n\\" + 'n'.join(' '.join(map(str, row)) for row in grid) + 'n' >>> t, test_cases = parse_input(input_data) >>> process_test_cases(t, test_cases) ['YES'] # Your implementation here def process_test_cases(t: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[str]: Process multiple test cases and return results for each. # Your implementation here def parse_input(input_string: str) -> Tuple[int, List[Tuple[Tuple[int, int], List[List[int]]]]]: Parse the raw input string into number of test cases and grid details for each test case. # Your implementation here","solution":"def can_king_reach_bottom(n, h, grid): from collections import deque directions = [(0, 1), (1, 0)] visited = [[False for _ in range(n)] for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == n - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] <= grid[x][y] + h: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\" def process_test_cases(t, test_cases): result = [] for test_case in test_cases: n, h = test_case[0] grid = test_case[1] result.append(can_king_reach_bottom(n, h, grid)) return result def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, h = map(int, lines[index].split()) grid = [] for i in range(n): grid.append(list(map(int, lines[index + 1 + i].split()))) test_cases.append(((n, h), grid)) index += n + 1 return t, test_cases"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Given an integer array nums, find the maximum sum of a non-empty subarray. A subarray is a contiguous part of an array. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5,4,-1,7,8]) 23","solution":"def max_subarray_sum(nums): Returns the maximum sum of a non-empty subarray. max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_smallest_missing_positive_integer(arr): Returns the smallest missing positive integer from the given array. >>> find_smallest_missing_positive_integer([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive_integer([1, 2, 0]) 3 >>> find_smallest_missing_positive_integer([7, 8, 9, 11, 12, -3, 15]) 1 >>> find_smallest_missing_positive_integer([-1, -2, -3, -4]) 1 >>> find_smallest_missing_positive_integer([1, 2, 3, 4, 5]) 6 >>> find_smallest_missing_positive_integer([1, 2, 3, 4, 100]) 5 >>> find_smallest_missing_positive_integer([5, 3, 1, 2, 4]) 6 >>> find_smallest_missing_positive_integer([-5, -10, -3, -1]) 1 >>> find_smallest_missing_positive_integer([2, 3, 1, 2, 3, 1]) 4","solution":"def find_smallest_missing_positive_integer(arr): Returns the smallest missing positive integer from the given array. # Create a set of all positive numbers in the array positive_set = set(x for x in arr if x > 0) # Start from 1 and increase to find the smallest missing positive integer smallest_missing = 1 while smallest_missing in positive_set: smallest_missing += 1 return smallest_missing"},{"question":"def can_place_frames(n, W, H, w, h): Determines if n frames, each of width w and height h, can be placed on a wall of width W and height H without overlapping. Returns \\"YES\\" if possible, otherwise \\"NO\\". >>> can_place_frames(6, 15, 10, 3, 5) \\"YES\\" >>> can_place_frames(2, 10, 5, 4, 3) \\"YES\\" >>> can_place_frames(8, 10, 10, 3, 4) \\"NO\\"","solution":"def can_place_frames(n, W, H, w, h): Determines if n frames, each of width w and height h, can be placed on a wall of width W and height H without overlapping. Returns \\"YES\\" if possible, otherwise \\"NO\\". # Calculate the number of frames that can fit horizontally and vertically horizontal_fit = W // w vertical_fit = H // h # Check if the total number of frames that can fit in both orientations is at least n if horizontal_fit * vertical_fit >= n: return \\"YES\\" # Check for rotated frames (w and h swapped) horizontal_fit = W // h vertical_fit = H // w if horizontal_fit * vertical_fit >= n: return \\"YES\\" return \\"NO\\""},{"question":"def highest_score(n: int, scores: List[int]) -> int: Returns the highest score from a list of scores. Parameters: n (int): Number of participants. scores (list of int): Scores obtained by participants. Returns: int: The highest score. >>> highest_score(5, [450, 7850, 6200, 9900, 2500]) == 9900 >>> highest_score(3, [50, 100, 150]) == 150 >>> highest_score(4, [0, 0, 0, 0]) == 0 >>> highest_score(0, []) == 0 >>> highest_score(1, [9999]) == 9999 >>> highest_score(4, [10000, 10000, 10000, 10000]) == 10000","solution":"def highest_score(n, scores): Returns the highest score from a list of scores. Parameters: n (int): Number of participants. scores (list of int): Scores obtained by participants. Returns: int: The highest score. if n == 0: return 0 return max(scores)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def mirror(root): Converts the given binary tree to its mirror tree. Args: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the mirror tree. pass # Your code goes here import pytest def inorder_traversal(root): Helper function to get the inorder traversal of the tree. result = [] if root: result = inorder_traversal(root.left) result.append(root.value) result = result + inorder_traversal(root.right) return result def test_mirror_tree_example_1(): # Construct the tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) # Mirror the tree mirror(root) # Expected tree after mirroring expected_inorder = [7, 3, 6, 1, 5, 2, 4] assert inorder_traversal(root) == expected_inorder def test_mirror_tree_example_2(): # Construct the tree root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) # Mirror the tree mirror(root) # Expected tree after mirroring expected_inorder = [5, 4, 3, 2, 1] assert inorder_traversal(root) == expected_inorder def test_mirror_tree_single_node(): # Construct the tree with single node root = TreeNode(1) # Mirror the tree mirror(root) # Expected tree after mirroring should be the same as it has only one node expected_inorder = [1] assert inorder_traversal(root) == expected_inorder def test_mirror_tree_no_node(): # Construct an empty tree root = None # Mirror the tree mirrored_root = mirror(root) # Expected tree after mirroring should be the same as it is empty assert mirrored_root is None","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def mirror(root): Converts the given binary tree to its mirror tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recur for the left and right subtree mirror(root.left) mirror(root.right) return root"},{"question":"def longest_increasing_subsequence(N: int, flowers: List[int]) -> int: Return the length of the longest strictly increasing subsequence of beauty values of the flowers. N : int : The number of types of flowers. flowers : List[int] : An array of N integers representing the beauty values of the flowers. >>> longest_increasing_subsequence(8, [10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> longest_increasing_subsequence(6, [3, 10, 2, 1, 20, 4]) 3 import bisect def test_case_1(): N = 8 flowers = [10, 22, 9, 33, 21, 50, 41, 60] assert longest_increasing_subsequence(N, flowers) == 5 def test_case_2(): N = 6 flowers = [3, 10, 2, 1, 20, 4] assert longest_increasing_subsequence(N, flowers) == 3 def test_case_3(): N = 1 flowers = [1] assert longest_increasing_subsequence(N, flowers) == 1 def test_case_4(): N = 7 flowers = [7, 6, 5, 4, 3, 2, 1] assert longest_increasing_subsequence(N, flowers) == 1 def test_case_5(): N = 7 flowers = [1, 2, 3, 4, 5, 6, 7] assert longest_increasing_subsequence(N, flowers) == 7 def test_case_6(): N = 0 flowers = [] assert longest_increasing_subsequence(N, flowers) == 0 def test_large_input(): import random N = 100000 flowers = random.sample(range(1, 1000001), N) # Generate N unique random beauty values assert longest_increasing_subsequence(N, flowers) <= N # At least the result doesn't exceed N","solution":"import bisect def longest_increasing_subsequence(N, flowers): if N == 0: return 0 lis = [] for flower in flowers: pos = bisect.bisect_left(lis, flower) if pos == len(lis): lis.append(flower) else: lis[pos] = flower return len(lis)"},{"question":"def count_derangements(n: int) -> int: Given a number n, returns the number of possible derangements of n photo albums modulo 1000000007. A derangement means no photo album is in its original position. >>> count_derangements(1) == 0 >>> count_derangements(2) == 1 >>> count_derangements(3) == 2 >>> count_derangements(4) == 9","solution":"MOD = 1000000007 def count_derangements(n): Returns the number of derangements of n photo albums. if n == 1: return 0 elif n == 2: return 1 derangements = [0] * (n + 1) derangements[1] = 0 derangements[2] = 1 for i in range(3, n + 1): derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) % MOD return derangements[n]"},{"question":"def minimal_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of integers, you are allowed to perform at most one operation: increment or decrement one integer in the array by 1. Your task is to determine the minimum possible absolute difference between the maximum and minimum numbers in the array after performing at most one such operation. >>> minimal_difference(3, [(5, [1, 4, 2, 6, 8]), (3, [10, 12, 15]), (4, [5, 5, 5, 5])]) [6, 4, 0] >>> minimal_difference(1, [(1, [100])]) [0] >>> minimal_difference(1, [(4, [5, 5, 5, 5])]) [0] >>> minimal_difference(1, [(4, [1, 10, 10, 10])]) [8] >>> minimal_difference(1, [(4, [1, 2, 3, 4])]) [2] >>> minimal_difference(1, [(2, [1, 100])]) [98]","solution":"def minimal_difference(t, test_cases): result = [] for i in range(t): n, arr = test_cases[i] arr.sort() initial_diff = arr[-1] - arr[0] if n == 1: result.append(0) continue possible_min = max(arr[-1]-1, arr[-2]) - arr[0] possible_max = arr[-1] - min(arr[0]+1, arr[1]) result.append(min(initial_diff, possible_min, possible_max)) return result # Example input t = 3 test_cases = [ (5, [1, 4, 2, 6, 8]), (3, [10, 12, 15]), (4, [5, 5, 5, 5]) ] print(minimal_difference(t, test_cases)) # Output: [6, 4, 0]"},{"question":"def countCase(S): This function takes a string S and prints the number of uppercase and lowercase characters in it. pass from io import StringIO import sys def test_countCase(): # Testing basic example output = StringIO() sys.stdout = output countCase(\\"HelloWorld\\") sys.stdout = sys.__stdout__ assert output.getvalue().strip() == \\"2 8\\" # Testing string with all uppercase letters output = StringIO() sys.stdout = output countCase(\\"ALLUPPERCASE\\") sys.stdout = sys.__stdout__ assert output.getvalue().strip() == \\"12 0\\" # Testing string with all lowercase letters output = StringIO() sys.stdout = output countCase(\\"alllowercase\\") sys.stdout = sys.__stdout__ assert output.getvalue().strip() == \\"0 12\\" # Testing string with mixed letters and numbers/special characters output = StringIO() sys.stdout = output countCase(\\"Hello123!@#\\") sys.stdout = sys.__stdout__ assert output.getvalue().strip() == \\"1 4\\" # Testing an empty string output = StringIO() sys.stdout = output countCase(\\"\\") sys.stdout = sys.__stdout__ assert output.getvalue().strip() == \\"0 0\\" # Testing string with no alphabetic characters output = StringIO() sys.stdout = output countCase(\\"123456!@#\\") sys.stdout = sys.__stdout__ assert output.getvalue().strip() == \\"0 0\\" # Testing maximum string length (though restrained here, can be upto 10^6 in an actual scenario) long_string = \\"a\\" * 10**6 + \\"B\\" * 500000 output = StringIO() sys.stdout = output countCase(long_string) sys.stdout = sys.__stdout__ assert output.getvalue().strip() == f\\"500000 {10**6}\\"","solution":"def countCase(S): This function takes a string S and prints the number of uppercase and lowercase characters in it. uppercase_count = sum(1 for c in S if c.isupper()) lowercase_count = sum(1 for c in S if c.islower()) print(f\\"{uppercase_count} {lowercase_count}\\")"},{"question":"def move_value_to_end(nums, value): Move all occurrences of the specified value to the end of the array in-place, while maintaining the relative order of the other elements. >>> move_value_to_end([4, 2, 4, 0, 3, 4, 5], 4) [2, 0, 3, 5, 4, 4, 4] >>> move_value_to_end([1, 3, 1, 3, 1, 3], 1) [3, 3, 3, 1, 1, 1] def test_example_1(): nums = [4, 2, 4, 0, 3, 4, 5] value = 4 expected = [2, 0, 3, 5, 4, 4, 4] assert move_value_to_end(nums, value) == expected def test_example_2(): nums = [1, 3, 1, 3, 1, 3] value = 1 expected = [3, 3, 3, 1, 1, 1] assert move_value_to_end(nums, value) == expected def test_no_occurrences(): nums = [2, 3, 4, 5] value = 1 expected = [2, 3, 4, 5] assert move_value_to_end(nums, value) == expected def test_all_occurrences(): nums = [2, 2, 2, 2] value = 2 expected = [2, 2, 2, 2] assert move_value_to_end(nums, value) == expected def test_empty_array(): nums = [] value = 1 expected = [] assert move_value_to_end(nums, value) == expected def test_single_element(): nums = [3] value = 3 expected = [3] assert move_value_to_end(nums, value) == expected def test_multiple_occurrences_scattered(): nums = [5, 1, 5, 2, 5, 3] value = 5 expected = [1, 2, 3, 5, 5, 5] assert move_value_to_end(nums, value) == expected","solution":"def move_value_to_end(nums, value): Move all occurrences of the specified value to the end of the array in-place, while maintaining the relative order of the other elements. insert_pos = 0 # First pass: Move non-value elements to the front for i in range(len(nums)): if nums[i] != value: nums[insert_pos] = nums[i] insert_pos += 1 # Second pass: Fill the rest of the array with the value for i in range(insert_pos, len(nums)): nums[i] = value return nums"},{"question":"def maximum_packages(n: int, w: List[int], p: List[int], m: int) -> int: Calculate the maximum number of packages the ship can carry given the constraints. :param n: Number of destinations (int) :param w: List of integers, weights of packages to be delivered at each destination :param p: List of integers, weights of packages to be picked up at each destination :param m: Maximum load capacity of the ship (int) :return: Maximum number of packages the ship can carry (int) >>> maximum_packages(3, [10, 20, 30], [15, 25, 35], 50) 2 >>> maximum_packages(2, [20, 30], [10, 40], 25) 1 >>> maximum_packages(4, [5, 15, 25, 35], [10, 20, 30, 40], 60) 3 >>> maximum_packages(1, [50], [50], 100) 1 >>> maximum_packages(5, [10, 20, 10, 20, 10], [5, 15, 5, 15, 5], 100) 5","solution":"def maximum_packages(n, w, p, m): Calculate the maximum number of packages the ship can carry given the constraints. :param n: Number of destinations (int) :param w: List of integers, weights of packages to be delivered at each destination :param p: List of integers, weights of packages to be picked up at each destination :param m: Maximum load capacity of the ship (int) :return: Maximum number of packages the ship can carry (int) current_load = 0 delivered_packages = 0 for i in range(n): # First, deliver the packages if current_load + w[i] <= m: current_load += w[i] delivered_packages += 1 else: break # Then, pick up the packages current_load -= w[i] # ship is empty after delivering if current_load + p[i] <= m: current_load += p[i] else: current_load = m return delivered_packages"},{"question":"def compute_prefix_sum(matrix): Compute the prefix sum matrix for the given matrix. pass def sum_submatrix(prefix_sum, r1, c1, r2, c2): Calculate the sum of elements in the submatrix defined by top-left corner (r1, c1) and bottom-right corner (r2, c2). pass def find_submatrix_sums(matrix, queries): Find the sum of elements in submatrices specified by the queries. # Test cases def test_compute_prefix_sum(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] prefix_sum = compute_prefix_sum(matrix) assert prefix_sum == [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] def test_sum_submatrix(): prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert sum_submatrix(prefix_sum, 0, 0, 1, 1) == 12 assert sum_submatrix(prefix_sum, 1, 1, 2, 2) == 28 assert sum_submatrix(prefix_sum, 0, 0, 2, 2) == 45 def test_find_submatrix_sums(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [ (0, 0, 1, 1), (1, 1, 2, 2) ] results = find_submatrix_sums(matrix, queries) assert results == [14, 34]","solution":"def compute_prefix_sum(matrix): rows = len(matrix) cols = len(matrix[0]) prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] for r in range(1, rows + 1): for c in range(1, cols + 1): prefix_sum[r][c] = matrix[r-1][c-1] + prefix_sum[r-1][c] + prefix_sum[r][c-1] - prefix_sum[r-1][c-1] return prefix_sum def sum_submatrix(prefix_sum, r1, c1, r2, c2): return (prefix_sum[r2+1][c2+1] - prefix_sum[r1][c2+1] - prefix_sum[r2+1][c1] + prefix_sum[r1][c1]) def find_submatrix_sums(matrix, queries): prefix_sum = compute_prefix_sum(matrix) results = [] for r1, c1, r2, c2 in queries: results.append(sum_submatrix(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"def nights_to_all_healthy(n: int, m: int, grid: List[List[int]]) -> int: Determine the number of nights it will take for all plants in the garden to become healthy, or return -1 if it is not possible. >>> nights_to_all_healthy(3, 3, [[1, 0, 1], [0, 0, 0], [1, 0, 1]]) 2 >>> nights_to_all_healthy(3, 3, [[1, 1, 1], [1, 0, 1], [1, 1, 1]]) 1 >>> nights_to_all_healthy(2, 2, [[1, 0], [0, 0]]) 2 >>> nights_to_all_healthy(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 0 >>> nights_to_all_healthy(3, 3, [[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 1 >>> nights_to_all_healthy(2, 2, [[0, 0], [0, 0]]) -1 # Implementation goes here def parse_input(input_str: str) -> (int, int, List[List[int]]): Parse the input string to get the dimensions of the garden and the grid. >>> parse_input(\\"3 3n1 0 1n0 0 0n1 0 1\\") (3, 3, [[1, 0, 1], [0, 0, 0], [1, 0, 1]]) >>> parse_input(\\"2 2n1 0n0 0\\") (2, 2, [[1, 0], [0, 0]]) # Implementation goes here","solution":"def nights_to_all_healthy(n, m, grid): from collections import deque # Direction vectors for adjacent cells (top, bottom, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque() unhealthy_count = 0 # Initialize queue with all healthy plants positions and count unhealthy plants for i in range(n): for j in range(m): if grid[i][j] == 1: queue.append((i, j)) else: unhealthy_count += 1 # If no unhealthy plant is present if unhealthy_count == 0: return 0 nights = 0 # BFS to spread healthiness while queue and unhealthy_count > 0: nights += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0: grid[nx][ny] = 1 queue.append((nx, ny)) unhealthy_count -= 1 # If there are still unhealthy plants left return nights if unhealthy_count == 0 else -1 # Parsing input for testing purposes def parse_input(input_str): input_lines = input_str.strip().split('n') n, m = map(int, input_lines[0].split()) grid = [list(map(int, line.split())) for line in input_lines[1:]] return n, m, grid"},{"question":"def allocate_problems(n: int, m: int, difficulties: List[int]) -> int: Allocate problems to m difficulty levels so that the maximum difference in the sum of difficulties between any two difficulty levels is minimized. >>> allocate_problems(7, 3, [4, 3, 2, 3, 4, 1, 2]) 7 >>> allocate_problems(5, 2, [7, 1, 4, 1, 6]) 11 >>> allocate_problems(1, 1, [5]) 5 >>> allocate_problems(3, 3, [1, 2, 3]) 3 >>> allocate_problems(6, 3, [10, 10, 10, 10, 10, 10]) 20 >>> allocate_problems(4, 2, [1000000000, 1000000000, 1000000000, 1000000000]) 2000000000","solution":"def allocate_problems(n, m, difficulties): def can_allocate_with_diff(max_diff): total = 0 levels = 1 for difficulty in difficulties: if total + difficulty > max_diff: levels += 1 total = 0 total += difficulty if levels > m: return False return True low, high = max(difficulties), sum(difficulties) while low < high: mid = (low + high) // 2 if can_allocate_with_diff(mid): high = mid else: low = mid + 1 return low"},{"question":"def subarray_sum_exists(test_cases): Given multiple test cases, check if the sum of any two discrete subarrays from the array is equal. Args: test_cases (List[Tuple[int, List[int]]]): List of test cases. Each test case is a tuple containing the size of the array and the array itself. Returns: List[str]: List of strings \\"YES\\" or \\"NO\\" for each test case. def parse_input(input_str): Parse the input string and return the test cases. Args: input_str (str): Input string containing number of test cases followed by the size of the array and the array elements. Returns: List[Tuple[int, List[int]]]: Parsed test cases. def format_output(results): Format the results into a single string output. Args: results (List[str]): List of results for each test case. Returns: str: Formatted output string. # Importing relevant functions for testing from solution import subarray_sum_exists, parse_input, format_output def test_example_case_1(): input_str = \\"2n4n2 4 -2 4n3n1 3 2\\" expected_output = \\"YESnNO\\" test_cases = parse_input(input_str) results = subarray_sum_exists(test_cases) output = format_output(results) assert output == expected_output def test_single_element(): input_str = \\"1n1n5\\" expected_output = \\"NO\\" test_cases = parse_input(input_str) results = subarray_sum_exists(test_cases) output = format_output(results) assert output == expected_output def test_all_elements_same(): input_str = \\"1n4n1 1 1 1\\" expected_output = \\"YES\\" test_cases = parse_input(input_str) results = subarray_sum_exists(test_cases) output = format_output(results) assert output == expected_output def test_no_equal_sum_subarrays(): input_str = \\"1n3n1 2 3\\" expected_output = \\"NO\\" test_cases = parse_input(input_str) results = subarray_sum_exists(test_cases) output = format_output(results) assert output == expected_output def test_edge_case_large_elements(): input_str = \\"1n3n1000000 -1000000 0\\" expected_output = \\"YES\\" test_cases = parse_input(input_str) results = subarray_sum_exists(test_cases) output = format_output(results) assert output == expected_output def test_edge_case_minimax_elements(): input_str = \\"1n5n-1000000 1000000 -1000000 1000000 0\\" expected_output = \\"YES\\" test_cases = parse_input(input_str) results = subarray_sum_exists(test_cases) output = format_output(results) assert output == expected_output","solution":"def subarray_sum_exists(test_cases): results = [] for case in test_cases: m, array = case if m < 2: results.append(\\"NO\\") continue sum_counts = {} prefix_sum = 0 for i in range(m): prefix_sum += array[i] for j in range(i + 1, m): subarray_sum = prefix_sum + array[j] if subarray_sum in sum_counts: results.append(\\"YES\\") break sum_counts[subarray_sum] = True else: continue break else: results.append(\\"NO\\") return results # Function to parse input string and return the test cases def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): m = int(lines[index]) array = list(map(int, lines[index + 1].split())) test_cases.append((m, array)) index += 2 return test_cases # Function to format output for the solution def format_output(results): return \\"n\\".join(results)"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list without using built-in sorting functions. The function operates with a time complexity of O(n + m), where 'n' and 'm' are the lengths of the two input lists. Args: list1 (list): A sorted list of integers. list2 (list): A sorted list of integers. Returns: list: A single sorted list containing all elements from list1 and list2. Examples: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([0, 10, 20], [5, 15, 25]) [0, 5, 10, 15, 20, 25] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([2], [1]) [1, 2] >>> merge_sorted_lists([1, 1, 1], [2, 2, 2]) [1, 1, 1, 2, 2, 2] >>> merge_sorted_lists([1, 3, 3], [1, 2, 3]) [1, 1, 2, 3, 3, 3] >>> merge_sorted_lists([-5, -3, -1], [-4, -2, 0]) [-5, -4, -3, -2, -1, 0]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Args: list1 (list): A sorted list of integers. list2 (list): A sorted list of integers. Returns: list: A single sorted list containing all elements from list1 and list2. merged_list = [] i, j = 0, 0 # Traverse both lists and insert smaller value from either list into merged_list while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1, add them to merged_list while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2, add them to merged_list while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def longest_ones_after_flips(S: str, N: int, K: int) -> int: Determine the length of the longest contiguous subsequence of 1's that can be obtained after flipping up to K characters in a binary string S of length N. >>> longest_ones_after_flips('1101001100', 10, 2) == 5 >>> longest_ones_after_flips('11111', 5, 0) == 5 >>> longest_ones_after_flips('00000', 5, 2) == 2 >>> longest_ones_after_flips('10101', 5, 2) == 5 >>> longest_ones_after_flips('1010101', 7, 3) == 7 >>> longest_ones_after_flips('1010101010', 10, 2) == 5 >>> longest_ones_after_flips('0', 1, 1) == 1 >>> longest_ones_after_flips('1', 1, 0) == 1","solution":"def longest_ones_after_flips(S, N, K): max_len = 0 left = 0 zeros_count = 0 for right in range(N): if S[right] == '0': zeros_count += 1 while zeros_count > K: if S[left] == '0': zeros_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def max_unique_signals(T: int, test_cases: List[List[int]]) -> List[int]: Determine the maximum number of unique signals that can be selected from the given sets. >>> max_unique_signals(2, [[2, [3, 1, 2, 3], [2, 2, 3]], [3, [2, 1, 2], [3, 2, 3, 4], [2, 3, 5]]]) [3, 5] >>> max_unique_signals(1, [[1, [3, 1, 2, 3]]]) [3]","solution":"def max_unique_signals(T, test_cases): result = [] for t in range(T): n = test_cases[t][0] signals = set() for i in range(1, n + 1): m, *planet_signals = test_cases[t][i] signals.update(planet_signals) result.append(len(signals)) return result"},{"question":"def find_single_number(nums): Returns the number that appears only once in the list. Given a list of integers where each integer appears exactly twice, except for one integer that appears only once, this function identifies and returns that one unique integer. >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([2, 2, 1]) 1 >>> find_single_number([1, 4, 1, 4, 2, 2, 5]) 5 >>> find_single_number([0, 1, 2, 3, 0, 1, 2]) 3 >>> find_single_number([10]) 10","solution":"def find_single_number(nums): Returns the number that appears only once in the list. Given a list of integers where each integer appears exactly twice, except for one integer that appears only once, this function identifies and returns that one unique integer. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def char_frequency(s: str) -> dict: Calculate the frequency of each character in the string. :param s: A string :return: A dictionary with characters as keys and their frequencies as values pass def sort_strings(strings: List[str]) -> List[str]: Sort a list of strings based on the frequency of characters, with lexicographic order as a tiebreaker. :param strings: List of strings to be sorted :return: List of sorted strings pass def process_test_cases(t: int, test_cases: List[List[Union[int, str]]]) -> List[List[str]]: Process multiple test cases and sort the lists of strings as per the given criteria. :param t: Number of test cases :param test_cases: List of test cases, each containing an integer followed by strings :return: List of sorted lists of strings, one for each test case pass from typing import List, Union def test_process_test_cases(): t = 2 test_cases = [ [3, \\"banana\\", \\"apple\\", \\"pear\\"], [4, \\"a\\", \\"ab\\", \\"aa\\", \\"b\\"] ] expected_output = [ [\\"pear\\", \\"apple\\", \\"banana\\"], [\\"a\\", \\"b\\", \\"ab\\", \\"aa\\"] ] assert process_test_cases(t, test_cases) == expected_output def test_single_string(): t = 1 test_cases = [ [1, \\"xylophone\\"] ] expected_output = [ [\\"xylophone\\"] ] assert process_test_cases(t, test_cases) == expected_output def test_multiple_identical_char_frequencies(): t = 1 test_cases = [ [2, \\"aaa\\", \\"bbb\\"] ] expected_output = [ [\\"aaa\\", \\"bbb\\"] ] assert process_test_cases(t, test_cases) == expected_output def test_all_characters_unique(): t = 1 test_cases = [ [5, \\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\", \\"mno\\"] ] expected_output = [ [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\", \\"mno\\"] ] assert process_test_cases(t, test_cases) == expected_output def test_multiple_character_frequencies(): t = 1 test_cases = [ [3, \\"aaa\\", \\"aab\\", \\"abb\\"] ] expected_output = [ [\\"aab\\", \\"abb\\", \\"aaa\\"] ] assert process_test_cases(t, test_cases) == expected_output","solution":"def char_frequency(s): freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq def sort_strings(strings): def custom_sort(s): freq = char_frequency(s) freq_sorted = sorted(freq.values()) return (freq_sorted, s) sorted_strings = sorted(strings, key=custom_sort) return sorted_strings def process_test_cases(t, test_cases): result = [] for test in test_cases: n, strings = test[0], test[1:] sorted_strings = sort_strings(strings) result.append(sorted_strings) return result"},{"question":"def min_maintenance_cost(N: int, M: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Compute the minimum total maintenance cost to ensure every city is reachable from any other city. If it is not possible to connect all cities, return \\"Impossible\\". >>> min_maintenance_cost(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 8), (2, 4, 2)]) 9 >>> min_maintenance_cost(4, 2, [(1, 2, 3), (3, 4, 5)]) \\"Impossible\\" pass import pytest def test_example_1(): N = 4 M = 5 edges = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 8), (2, 4, 2) ] assert min_maintenance_cost(N, M, edges) == 9 def test_example_2(): N = 4 M = 2 edges = [ (1, 2, 3), (3, 4, 5) ] assert min_maintenance_cost(N, M, edges) == \\"Impossible\\" def test_disconnected_graph(): N = 3 M = 1 edges = [ (1, 2, 3) ] assert min_maintenance_cost(N, M, edges) == \\"Impossible\\" def test_single_node_graph(): N = 2 M = 1 edges = [ (1, 2, 1) ] assert min_maintenance_cost(N, M, edges) == 1 def test_large_cost_graph(): N = 3 M = 3 edges = [ (1, 2, 1000000), (2, 3, 1000000), (1, 3, 1000000) ] assert min_maintenance_cost(N, M, edges) == 2000000","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def min_maintenance_cost(N, M, edges): parent = [] rank = [] for node in range(N): parent.append(node) rank.append(0) edges = sorted(edges, key=lambda item: item[2]) result = [] e = 0 i = 0 while e < N - 1: if i >= M: return \\"Impossible\\" u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) min_cost = 0 for u, v, weight in result: min_cost += weight return min_cost"},{"question":"def findPairIndices(arr: List[int], k: int) -> List[int]: Find the pair of elements in the array whose sum is equal to k, and return the indices of these two elements. >>> findPairIndices([2, 7, 11, 15], 9) [0, 1] >>> findPairIndices([-1, -2, -3, -4], -6) [1, 3] >>> findPairIndices([1, 2, 3, 4, 5], 9) [3, 4] >>> findPairIndices([3, 3, 4, 5], 6) [0, 1] >>> findPairIndices([100000, -100000, 99999, -99999], 0) [0, 1] >>> findPairIndices([1, 1, 1, 1, 1, 2], 3) [4, 5] >>> findPairIndices(list(range(1, 10001)), 19999) [9998, 9999]","solution":"def findPairIndices(arr, k): Finds the indices of the two numbers in arr that add up to k. Parameters: arr (list of int): List of integers. k (int): Target sum. Returns: list of int: Indices of the two numbers that add up to k. # Using a dictionary to store the value and its index num_dict = {} for index, num in enumerate(arr): # Check if the complement (k - num) exists in the dictionary complement = k - num if complement in num_dict: return [num_dict[complement], index] # Store the index of the current number num_dict[num] = index"},{"question":"from typing import List, Tuple def can_place_animals(H: int, W: int, n: int, groups: List[Tuple[int, int]]) -> str: Determine if it's possible to place all the groups of animals within the enclosure without any overlap. Return \\"YES\\" if possible, otherwise return \\"NO\\". >>> can_place_animals(10, 12, 3, [(2, 3), (4, 6), (4, 6)]) \\"YES\\" >>> can_place_animals(10, 12, 2, [(10, 10), (12, 12)]) \\"NO\\"","solution":"def can_place_animals(H, W, n, groups): total_area = sum(h * w for h, w in groups) enclosure_area = H * W if total_area <= enclosure_area: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def min_trips(t: int, cases: List[Tuple[int, int]]) -> List[int]: Calculate the minimum number of trips for each test case. Parameters: t: int - number of test cases cases: list of tuples - each tuple contains (n, k) for the test cases Returns: list of int - the result for each test case pass # Example Usage # >>> min_trips(4, [(10, 3), (15, 5), (9, 9), (1000000000, 1)]) # [4, 3, 1, 1000000000] def test_min_trips_sample(): assert min_trips(4, [(10, 3), (15, 5), (9, 9), (1000000000, 1)]) == [4, 3, 1, 1000000000] def test_min_trips_zero_cases(): assert min_trips(0, []) == [] def test_min_trips_large_numbers(): assert min_trips(2, [(1000000000, 1000000000), (999999999, 1)]) == [1, 999999999] def test_min_trips_general_cases(): assert min_trips(3, [(20, 7), (7, 7), (22, 5)]) == [3, 1, 5] def test_min_trips_single_case(): assert min_trips(1, [(5, 2)]) == [3] assert min_trips(1, [(1, 1)]) == [1] def test_min_trips_edge_cases(): assert min_trips(2, [(1, 10), (10, 1)]) == [1, 10]","solution":"def min_trips(t, cases): Calculate the minimum number of trips for each test case. Parameters: t: int - number of test cases cases: list of tuples - each tuple contains (n, k) for the test cases Returns: list of int - the result for each test case results = [] for n, k in cases: trips = (n + k - 1) // k # This is equivalent to math.ceil(n / k) results.append(trips) return results"},{"question":"def runner_with_most_checkpoints(N: int, M: int, C: int, records: List[Tuple[int, int, int]]) -> int: A city is hosting a marathon, and runners are assigned bib numbers from 1 to N. During the marathon, checkpoints are set up to track the progress of the runners and the times at which they pass each checkpoint. The race organizers want to analyze the data to identify certain patterns. Given a list of tuples where each tuple contains three elements: the bib number of the runner, the checkpoint number, and the time at which the runner passed the checkpoint, you need to determine the bib number of the runner who passed through most different checkpoints. If there is a tie, return the smallest bib number. >>> runner_with_most_checkpoints(5, 4, 10, [ ... (1, 1, 500), (1, 2, 1000), (2, 1, 700), (2, 2, 1500), ... (3, 1, 300), (3, 3, 1300), (4, 2, 500), (4, 3, 1400), ... (4, 4, 2000), (5, 1, 100), (5, 4, 1800) ... ]) == 4 >>> runner_with_most_checkpoints(5, 3, 7, [ ... (1, 1, 500), (1, 2, 1000), (2, 1, 700), (2, 2, 1500), ... (3, 1, 300), (3, 3, 1300), (4, 1, 400), (4, 2, 900) ... ]) == 1 >>> runner_with_most_checkpoints(1, 4, 4, [ ... (1, 1, 500), (1, 2, 1000), (1, 3, 1500), (1, 4, 2000) ... ]) == 1 >>> runner_with_most_checkpoints(3, 2, 0, []) == None","solution":"def runner_with_most_checkpoints(N, M, C, records): from collections import defaultdict checkpoints_passed = defaultdict(set) for record in records: bib_number, checkpoint_number, time = record checkpoints_passed[bib_number].add(checkpoint_number) max_checkpoints = 0 runner_with_max = None for runner, checkpoints in checkpoints_passed.items(): checkpoint_count = len(checkpoints) if checkpoint_count > max_checkpoints or (checkpoint_count == max_checkpoints and runner < runner_with_max): max_checkpoints = checkpoint_count runner_with_max = runner return runner_with_max"},{"question":"from typing import List, Tuple class MaxPriorityQueue: def __init__(self): Initialize a max-priority queue. pass def addTask(self, p: int) -> None: Adds a task with priority p to the queue. Args: p (int): The priority of the task to be added. pass def getHighestPriorityTask(self) -> int: Removes and returns the task with the highest priority from the queue. Returns: int: The priority of the highest priority task. pass def process_operations(operations: List[Tuple[int]]) -> List[int]: Processes a series of operations on the max-priority queue and returns the results of getHighestPriorityTask operations. Args: operations (List[Tuple[int]]): A list of operations to be performed on the queue. Returns: List[int]: A list of results from getHighestPriorityTask operations. pass def test_example(): operations = [(0, 5), (0, 3), (0, 10), (1,), (0, 8), (1,)] assert process_operations(operations) == [10, 8] def test_single_add_and_get(): operations = [(0, 1), (1,)] assert process_operations(operations) == [1] def test_multiple_same_priority(): operations = [(0, 5), (0, 5), (0, 5), (1,), (1,), (1,)] assert process_operations(operations) == [5, 5, 5] def test_decreasing_priority(): operations = [(0, 3), (0, 2), (0, 1), (1,), (1,), (1,)] assert process_operations(operations) == [3, 2, 1] def test_increasing_priority(): operations = [(0, 1), (0, 2), (0, 3), (1,), (1,), (1,)] assert process_operations(operations) == [3, 2, 1] def test_mixed_operations(): operations = [(0, 3), (0, 2), (1,), (0, 4), (1,), (1,)] assert process_operations(operations) == [3, 4, 2]","solution":"import heapq class MaxPriorityQueue: def __init__(self): self.heap = [] def addTask(self, p): heapq.heappush(self.heap, -p) def getHighestPriorityTask(self): return -heapq.heappop(self.heap) def process_operations(operations): output = [] pq = MaxPriorityQueue() for operation in operations: if operation[0] == 0: pq.addTask(operation[1]) elif operation[0] == 1: output.append(pq.getHighestPriorityTask()) return output"},{"question":"def can_segment_string(s, word_list): Determines if the string s can be segmented into a space-separated sequence of one or more words from word_list. Parameters: s (str): The string to be segmented word_list (List[str]): List of words to be used for segmentation Returns: str: \\"YES\\" if the string can be segmented, otherwise \\"NO\\" Example: >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) 'YES' >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) 'NO' pass def handle_test_cases(test_cases): Processes multiple test cases to determine if each string can be segmented. Parameters: test_cases (List[Tuple[str, List[str]]]): List of test cases, each test case is a tuple containing a string and a list of words Returns: List[str]: List of results for each test case (\\"YES\\" or \\"NO\\") Example: >>> handle_test_cases([(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]), (\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"])]) ['YES', 'NO'] pass def main(t, test_cases): Main function to handle input and output for multiple test cases. Parameters: t (int): Number of test cases test_cases (List[Tuple[str, List[str]]]): List of test cases, each test case is a tuple containing a string and a list of words Returns: List[str]: List of results for each test case (\\"YES\\" or \\"NO\\") Example: >>> main(2, [(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]), (\\"catsandog\\", [\\"cats, \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"])]) ['YES', 'NO'] pass","solution":"def can_segment_string(s, word_list): Determines if the string s can be segmented into a space-separated sequence of one or more words from word_list. word_set = set(word_list) n = len(s) dp = [False] * (n + 1) dp[0] = True # Base case, an empty string can always be segmented for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[n] else \\"NO\\" def handle_test_cases(test_cases): results = [] for s, word_list in test_cases: results.append(can_segment_string(s, word_list)) return results # Reading input and output sequences def main(t, test_cases): return handle_test_cases(test_cases)"},{"question":"def max_trendiness_sum(n: int, scores: List[int]) -> int: Calculates the maximum sum of trendiness scores achievable by any valid combination of chapters, respecting the order of the storyline. Parameters: n (int): Number of chapters scores (list of int): Trendiness scores of the chapters Returns: int: Maximum sum of trendiness scores >>> max_trendiness_sum(6, [1, -2, 3, -4, 5, -6]) 9 >>> max_trendiness_sum(4, [-1, -2, -3, -4]) 0","solution":"def max_trendiness_sum(n, scores): Calculates the maximum sum of trendiness scores achievable by any valid combination of chapters. Parameters: n (int): Number of chapters scores (list of int): Trendiness scores of the chapters Returns: int: Maximum sum of trendiness scores # Dynamic programming approach where dp[i] represents the max sum including the i-th chapter dp = [0] * n # Initialize the first chapter's trendiness score or 0 if it's negative if scores[0] > 0: dp[0] = scores[0] for i in range(1, n): # We only add the current chapter's score if it results in a non-negative sum dp[i] = max(dp[i-1] + scores[i], dp[i-1]) return dp[-1]"},{"question":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using dynamic programming. >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(15) 610","solution":"def fibonacci(n): Returns the n-th Fibonacci number using dynamic programming. if n == 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[0] = 0 fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"def count_distinct_palindromes(s: str) -> int: Returns the count of distinct palindromic substrings in the input string s. >>> count_distinct_palindromes(\\"abac\\") 4 >>> count_distinct_palindromes(\\"aaa\\") 3 >>> count_distinct_palindromes(\\"a\\") 1 >>> count_distinct_palindromes(\\"aa\\") 2 >>> count_distinct_palindromes(\\"abcba\\") 5 >>> count_distinct_palindromes(\\"abcd\\") 4","solution":"def count_distinct_palindromes(s): Returns the count of distinct palindromic substrings in the input string s. def is_palindrome(subs): return subs == subs[::-1] palindromes = set() n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): palindromes.add(substring) return len(palindromes)"},{"question":"from typing import List def find_itinerary(tickets: List[List[str]]) -> List[str]: You are given a list of flight tickets represented by pairs of departure and arrival airports [from, to]. Write a function to reconstruct the itinerary in order. All of the tickets belong to a man who departs from \\"JFK\\". Hence, the itinerary must begin with \\"JFK\\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. The requirement is to use all the given tickets and only once. >>> find_itinerary([['MUC', 'LHR'], ['JFK', 'MUC'], ['SFO', 'SJC'], ['LHR', 'SFO']]) ['JFK', 'MUC', 'LHR', 'SFO', 'SJC'] >>> find_itinerary([['JFK', 'SFO'], ['JFK', 'ATL'], ['SFO', 'ATL'], ['ATL', 'JFK'], ['ATL', 'SFO']]) ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']","solution":"from collections import defaultdict, deque def find_itinerary(tickets): Finds the itinerary using all the given tickets exactly once and starting at 'JFK'. Returns the itinerary in lexical order if multiple valid itineraries exist. graph = defaultdict(deque) # Sort the tickets and create the graph for start, end in sorted(tickets): graph[start].append(end) route, stack = [], ['JFK'] while stack: while graph[stack[-1]]: stack.append(graph[stack[-1]].popleft()) route.append(stack.pop()) return route[::-1]"},{"question":"def canPickGiftBoxes(M: int, V: int, A: List[int]) -> str: Determines if it's possible to select gift boxes such that their total value matches exactly V without selecting two adjacent boxes. >>> canPickGiftBoxes(5, 9, [3, 2, 5, 10, 7]) 'Yes' >>> canPickGiftBoxes(3, 10, [1, 2, 3]) 'No'","solution":"def canPickGiftBoxes(M, V, A): Determines if it's possible to select gift boxes such that their total value matches exactly V without selecting two adjacent boxes. # Initialize DP table with False dp = [[False] * (V + 1) for _ in range(M + 1)] # Base case: It's possible to achieve a value of 0 by selecting no boxes for i in range(M + 1): dp[i][0] = True # Fill the DP table for i in range(1, M + 1): for j in range(1, V + 1): # Option 1: Don't pick the i-th box dp[i][j] = dp[i-1][j] # Option 2: Pick the i-th box if it doesn't we exceed the required value and doesn't cause adjacent selection if j >= A[i-1] and (i == 1 or dp[i-2][j - A[i-1]]): dp[i][j] = dp[i][j] or dp[i-2][j - A[i-1]] # The answer is found in dp[M][V] return \\"Yes\\" if dp[M][V] else \\"No\\""},{"question":"def subarray_sum(nums, k): Returns the number of subarrays whose sum equals k. Parameters: nums (list of int): The list of integers to examine. k (int): The target sum for the subarrays. Returns: int: The number of subarrays whose sum equals k. Example: >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([0, 0, 0, 0, 0], 0) 15 >>> subarray_sum([3, 4, 7, 2, -3, 1, 4, 2], 7) 4","solution":"def subarray_sum(nums, k): Returns the number of subarrays whose sum equals k. Parameters: nums (list of int): The list of integers to examine. k (int): The target sum for the subarrays. Returns: int: The number of subarrays whose sum equals k. count = 0 cum_sum = 0 cum_sum_counts = {0: 1} for num in nums: cum_sum += num if cum_sum - k in cum_sum_counts: count += cum_sum_counts[cum_sum - k] if cum_sum in cum_sum_counts: cum_sum_counts[cum_sum] += 1 else: cum_sum_counts[cum_sum] = 1 return count"},{"question":"def single_number(nums): Finds the single element in the list that does not have a duplicate. Args: nums (list): List of integers where every element appears twice except for one element which appears exactly once. Returns: int: The single element that does not have a duplicate. >>> single_number([5]) 5 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([2, 2, 3, 3, 1]) 1 >>> single_number([100000, 1, 1, 100000, 999999]) 999999 >>> single_number([-1, -1, -2]) -2 >>> single_number([-3, -1, -1, 2, 2, 4, 4, -3, 0]) 0","solution":"def single_number(nums): Finds the single element in the list that does not have a duplicate. Args: nums (list): List of integers where every element appears twice except for one element which appears exactly once. Returns: int: The single element that does not have a duplicate. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[List[str]]) -> int: Determine the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) while avoiding obstacles. Input: - n: int, the number of rows in the grid - m: int, the number of columns in the grid - grid: List[List[str]], the grid itself with open spaces ('.') and obstacles ('#') Output: - int, the length of the shortest path, or -1 if no valid path exists >>> shortest_path(3, 3, [['.', '.', '#'], ['#', '.', '#'], ['#', '.', '.']]) 4 >>> shortest_path(3, 3, [['.', '#', '.'], ['#', '.', '#'], ['#', '.', '.']]) -1","solution":"from collections import deque def shortest_path(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def can_partition_array(n: int, arr: List[int]) -> str: Given an array of integers, determine if you can partition the array into two non-empty subarrays such that the sum of the elements in the left subarray is equal to the sum of the elements in the right subarray. The partitioning point can be any index in the array except the first and the last index. >>> can_partition_array(4, [2, 4, 2, 4]) 'YES' >>> can_partition_array(5, [1, 2, 3, 4, 5]) 'NO'","solution":"def can_partition_array(n, arr): total_sum = sum(arr) left_sum = 0 for i in range(n - 1): # We don't consider the last element as a partition point left_sum += arr[i] if left_sum == total_sum - left_sum: return \\"YES\\" return \\"NO\\""},{"question":"def has_pair_with_sum(input_array: list[int], k: int) -> bool: Determines if there are any two distinct elements in the array that sum up to k. Parameters: - input_array (list of int): The array of integers. - k (int): The target sum. Returns: - bool: True if there exists a pair of distinct elements that sum up to k, False otherwise. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([], 8) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([-1, -2, -3, -4], -7) True >>> has_pair_with_sum([1, -2, 3, 5], 1) True >>> has_pair_with_sum([1, 1, 3, 4, 5], 2) True >>> has_pair_with_sum([1, 1, 1, 1], 2) True >>> has_pair_with_sum([1, 2, 3], 7) False >>> has_pair_with_sum([1000000, 2000000, 3000000], 5000000) True >>> has_pair_with_sum([1000000, 2000000, 3000000], 7000000) False","solution":"def has_pair_with_sum(input_array: list[int], k: int) -> bool: Determines if there are any two distinct elements in the array that sum up to k. Parameters: - input_array (list of int): The array of integers. - k (int): The target sum. Returns: - bool: True if there exists a pair of distinct elements that sum up to k, False otherwise. seen = set() for num in input_array: if k - num in seen: return True seen.add(num) return False"},{"question":"def find_least_productive_team(n, k, project_data, queries): Determine the least productive team based on the given project completion percentages and queries. Args: n (int): The number of employees. k (int): The number of projects. project_data (List[List[int]]): A list of lists where each sublist represents the completion percentages of projects by an employee. queries (List[List[int]]): A list of queries where each query has the number of projects followed by distinct integers indicating the projects to be considered in priority order. Returns: List[int]: A list containing the unique IDs of the least productive team for each query. Examples: >>> find_least_productive_team(4, 4, [[75, 60, 80, 55], [65, 75, 60, 85], [80, 70, 50, 60], [90, 55, 65, 75]], [[2, 1, 2], [3, 2, 3, 4], [1, 4]]) [2, 4, 1] >>> find_least_productive_team(3, 3, [[90, 80, 70], [60, 60, 60], [40, 40, 40]], [[2, 1, 2], [1, 3]]) [3, 3] >>> find_least_productive_team(5, 5, [[10, 20, 30, 40, 50], [50, 40, 30, 20, 10], [30, 20, 10, 50, 40], [20, 10, 50, 30, 40], [10, 50, 20, 30, 40]], [[3, 1, 2, 3], [2, 3, 4]]) [1, 3] >>> find_least_productive_team(2, 2, [[50, 50], [50, 50]], [[2, 1, 2]]) [1]","solution":"def find_least_productive_team(n, k, project_data, queries): results = [] for query in queries: x = query[0] project_indices = query[1:] # Initialize sets of team indices remaining_teams = set(range(n)) for project_index in project_indices: # Find the minimum productivity for the current project min_productivity = min(project_data[team][project_index - 1] for team in remaining_teams) # Filter out teams that have a higher productivity than the minimum for the current project remaining_teams = {team for team in remaining_teams if project_data[team][project_index - 1] == min_productivity} # Early exit if a single team remains if len(remaining_teams) == 1: break # If there's still a tie, resolve by the smallest total completion percentage across the projects in the combination if len(remaining_teams) > 1: total_completion_percentages = { team: sum(project_data[team][project_index - 1] for project_index in project_indices) for team in remaining_teams } least_productive_team = min(total_completion_percentages, key=total_completion_percentages.get) else: least_productive_team = min(remaining_teams) # The team IDs are 1-indexed results.append(least_productive_team + 1) return results"},{"question":"def smallest_subarray_with_sum_greater_than_k(arr: List[int], k: int) -> int: Returns the length of the smallest subarray with sum greater than k. If no such subarray exists, return -1. >>> smallest_subarray_with_sum_greater_than_k([1, 4, 45, 6, 0, 19], 51) 3 >>> smallest_subarray_with_sum_greater_than_k([1, 10, 5, 2, 7], 9) 1 >>> smallest_subarray_with_sum_greater_than_k([1, 2, 4], 8) -1","solution":"def smallest_subarray_with_sum_greater_than_k(arr, k): Returns the length of the smallest subarray with sum greater than k. If no such subarray exists, returns -1. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"from typing import List, Tuple def is_prime(num: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False # Implementation here def max_distinct_primes_after_change(arr: List[int]) -> int: Calculate the maximum number of distinct prime numbers that can be achieved by changing one element in the array. >>> max_distinct_primes_after_change([4, 6, 8, 10, 12]) 1 >>> max_distinct_primes_after_change([2, 3, 5, 7]) 4 # Implementation here def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process each test case and return a list of results for each test case. >>> process_test_cases([(5, [4, 6, 8, 10, 12]), (4, [2, 3, 5, 7]), (3, [15, 23, 29])]) [1, 4, 3] >>> process_test_cases([(3, [1, 4, 6]), (2, [11, 13]), (4, [14, 15, 16, 18])]) [1, 2, 1] # Implementation here def main(): Main function to read input and print output for each test case. import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): n = int(data[index]) arr = list(map(int, data[index+1:index+1+n])) test_cases.append((n, arr)) index += n + 1 results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def max_distinct_primes_after_change(arr): distinct_primes = set(filter(is_prime, arr)) max_primes_count = len(distinct_primes) for num in arr: if is_prime(num): continue tmp_primes = distinct_primes.copy() tmp_primes.add(2) # Adding a prime number to test max_primes_count = max(max_primes_count, len(tmp_primes)) break # Only need to change one number return max_primes_count def process_test_cases(test_cases): results = [] for case in test_cases: n, arr = case results.append(max_distinct_primes_after_change(arr)) return results # Read input def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): n = int(data[index]) arr = list(map(int, data[index+1:index+1+n])) test_cases.append((n, arr)) index += n + 1 results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def find_max_visits(n: int, intervals: List[Tuple[int, int, int]]) -> int: Determine the maximum number of visits on any single day throughout the year. The input consists of: - n: The number of intervals - intervals: A list of tuples, each containing the start day, end day, and number of visits per day for that interval >>> find_max_visits(3, [(1, 10, 5), (5, 15, 7), (20, 25, 3)]) == 12 >>> find_max_visits(2, [(1, 365, 1), (100, 200, 2)]) == 3 from typing import List, Tuple def test_find_max_visits_example1(): n = 3 intervals = [(1, 10, 5), (5, 15, 7), (20, 25, 3)] assert find_max_visits(n, intervals) == 12 def test_find_max_visits_example2(): n = 2 intervals = [(1, 365, 1), (100, 200, 2)] assert find_max_visits(n, intervals) == 3 def test_find_max_visits_single_interval(): n = 1 intervals = [(50, 60, 10)] assert find_max_visits(n, intervals) == 10 def test_find_max_visits_non_overlapping_intervals(): n = 2 intervals = [(1, 100, 5), (200, 300, 10)] assert find_max_visits(n, intervals) == 10 def test_find_max_visits_all_days(): n = 1 intervals = [(1, 365, 365)] assert find_max_visits(n, intervals) == 365 def test_find_max_visits_multiple_intervals(): n = 4 intervals = [(1, 150, 1), (50, 200, 2), (100, 250, 3), (150, 300, 4)] assert find_max_visits(n, intervals) == 10","solution":"def find_max_visits(n, intervals): # Create a list for the number of visits per day for each of the 365 days in a year visits = [0] * 366 # To handle day numbers from 1 to 365 # Process each interval for s, e, v in intervals: for day in range(s, e + 1): visits[day] += v # Find the maximum number of visits on any single day max_visits = max(visits) return max_visits"},{"question":"def count_even_sum_pairs(num_cases, cases): Count the number of distinct pairs (i, j) such that 1 ≤ i < j ≤ N and the sum of array[i] and array[j] is an even number. >>> count_even_sum_pairs(1, [(5, [1, 2, 3, 4, 5])]) [4] >>> count_even_sum_pairs(2, [(5, [1, 2, 3, 4, 5]), (4, [1, 1, 1, 1])]) [4, 6] >>> count_even_sum_pairs(1, [(2, [1, 2])]) [0] >>> count_even_sum_pairs(1, [(5, [2, 4, 6, 8, 10])]) [10] >>> count_even_sum_pairs(1, [(5, [1, 3, 5, 7, 9])]) [10] >>> count_even_sum_pairs(1, [(1, [2])]) [0] >>> count_even_sum_pairs(1, [(1, [1])]) [0]","solution":"def count_even_sum_pairs(num_cases, cases): results = [] for case in cases: n, array = case odd_count = sum(1 for x in array if x % 2) even_count = n - odd_count # Pairs of even numbers even_pairs = even_count * (even_count - 1) // 2 # Pairs of odd numbers odd_pairs = odd_count * (odd_count - 1) // 2 results.append(even_pairs + odd_pairs) return results"},{"question":"def can_derive_string(A: str, B: str) -> bool: Determines if string B can be derived from string A by deleting some characters from A while preserving the order. >>> can_derive_string(\\"abpcplea\\", \\"apple\\") True >>> can_derive_string(\\"helloworld\\", \\"hello\\") True >>> can_derive_string(\\"monkey\\", \\"money\\") True >>> can_derive_string(\\"abcdefgh\\", \\"afk\\") False def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes a list of test cases and determines for each pair if B can be derived from A. >>> process_test_cases([(\\"abpcplea\\", \\"apple\\"), (\\"helloworld\\", \\"hello\\"), (\\"monkey\\", \\"money\\")]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases([(\\"abcdefgh\\", \\"ace\\"), (\\"abcdefgh\\", \\"afg\\"), (\\"abcdefgh\\", \\"afk\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_derive_string(A, B): Determines if string B can be derived from string A by deleting some characters from A while preserving the order. i, j = 0, 0 while i < len(A) and j < len(B): if A[i] == B[j]: j += 1 i += 1 return j == len(B) def process_test_cases(test_cases): results = [] for A, B in test_cases: if can_derive_string(A, B): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def average_distance_above_minimum(M, distances): Calculate the average distance Rahul runs on days when he runs at least \`M\` kilometers. Parameters: M (int): The minimum distance considered. distances (list of int): A list of seven integers representing the distances run each day. Returns: float: The average distance on days with at least \`M\` kilometers, rounded to two decimal places. def process_inputs(test_cases): Process multiple test cases to calculate the average distance above the minimum distance for each. Parameters: test_cases (list of tuple): Each tuple contains an integer \`M\` and a list of seven integers representing the distances run each day. Returns: list of float: The average distances for each test case, rounded to two decimal places. import pytest def test_average_distance_above_minimum(): assert average_distance_above_minimum(5, [10, 5, 3, 6, 8, 2, 7]) == 7.20 assert average_distance_above_minimum(8, [4, 9, 12, 5, 10, 3, 8]) == 9.75 assert average_distance_above_minimum(0, [0, 0, 0, 0, 0, 0, 0]) == 0.00 assert average_distance_above_minimum(50, [100, 50, 49, 48, 50, 51, 100]) == 70.20 assert average_distance_above_minimum(101, [100, 100, 100, 100, 100, 100, 100]) == 0.00 @pytest.mark.parametrize(\\"test_cases, expected\\", [ ([ (5, [10, 5, 3, 6, 8, 2, 7]), (8, [4, 9, 12, 5, 10, 3, 8]) ], [7.20, 9.75]), ([ (2, [1, 1, 3, 3, 1, 1, 1]), (3, [3, 1, 3, 1, 3, 1, 3]) ], [3.00, 3.00]) ]) def test_process_inputs(test_cases, expected): assert process_inputs(test_cases) == expected","solution":"def average_distance_above_minimum(M, distances): Calculate the average distance Rahul runs on days when he runs at least \`M\` kilometers. Parameters: M (int): The minimum distance considered. distances (list of int): A list of seven integers representing the distances run each day. Returns: float: The average distance on days with at least \`M\` kilometers, rounded to two decimal places. filtered_distances = [d for d in distances if d >= M] if not filtered_distances: return 0.00 average = sum(filtered_distances) / len(filtered_distances) return round(average, 2) def process_inputs(test_cases): results = [] for case in test_cases: M, distances = case results.append(average_distance_above_minimum(M, distances)) return results"},{"question":"def first_missing_positive(nums): Returns the smallest positive integer that is missing from the list. >>> first_missing_positive([3, 4, -1, 1]) == 2 >>> first_missing_positive([1, 2, 0]) == 3 >>> first_missing_positive([7, 8, 9, 11, 12]) == 1 >>> first_missing_positive([1, 2, 3, 4, 5]) == 6 >>> first_missing_positive([-1, -2, -3, -4, -5]) == 1 >>> first_missing_positive([0, -1, 3, 1, 2, 5]) == 4 >>> first_missing_positive([1]) == 2 >>> first_missing_positive([2]) == 1 >>> first_missing_positive([1, 1, 2, 2, 3, 3]) == 4 >>> first_missing_positive(list(range(1, 100001))) == 100001","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is missing from the list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def longest_alphabetical_path(n, grid): Finds the longest string that can be formed by starting from any cell in a grid and moving to its neighboring cells in any of the 8 possible directions (horizontally, vertically, or diagonally) such that the characters in the string are in alphabetical order. You can visit each cell only once in the path. Args: n (int): The size of the grid (N x N). grid (List[List[str]]): A 2D list representing the grid filled with uppercase English letters. Returns: int: The length of the longest alphabetical path. Examples: >>> grid = [ ... ['A', 'B', 'C', 'D'], ... ['Z', 'Y', 'X', 'W'], ... ['A', 'B', 'C', 'D'], ... ['B', 'C', 'D', 'E'] ... ] >>> longest_alphabetical_path(4, grid) 5 pass # Test Cases def test_example_case(): grid = [ ['A', 'B', 'C', 'D'], ['Z', 'Y', 'X', 'W'], ['A', 'B', 'C', 'D'], ['B', 'C', 'D', 'E'] ] assert longest_alphabetical_path(4, grid) == 5 def test_single_long_path(): grid = [ ['A', 'F'], ['E', 'B'], ] assert longest_alphabetical_path(2, grid) == 2 def test_diagonal_path(): grid = [ ['A', 'X', 'X'], ['X', 'B', 'X'], ['X', 'X', 'C'] ] assert longest_alphabetical_path(3, grid) == 3 def test_no_path(): grid = [ ['A', 'X'], ['X', 'A'], ] assert longest_alphabetical_path(2, grid) == 1 def test_all_same_letters(): grid = [ ['C', 'C'], ['C', 'C'] ] assert longest_alphabetical_path(2, grid) == 1 def test_wrapped_path(): grid = [ ['A', 'B', 'C'], ['H', 'I', 'D'], ['G', 'F', 'E'] ] assert longest_alphabetical_path(3, grid) == 9 def test_large_grid(): grid = [['A' for _ in range(50)] for _ in range(50)] assert longest_alphabetical_path(50, grid) == 1","solution":"def longest_alphabetical_path(n, grid): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def dfs(x, y, previous_char, memo): if memo[x][y] != -1: return memo[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and ord(grid[nx][ny]) == ord(previous_char) + 1: max_length = max(max_length, 1 + dfs(nx, ny, grid[nx][ny], memo)) memo[x][y] = max_length return max_length memo = [[-1] * n for _ in range(n)] result = 0 for i in range(n): for j in range(n): result = max(result, dfs(i, j, grid[i][j], memo)) return result"},{"question":"from typing import List, Tuple def number_of_teams(n: int, participants: List[Tuple[int, int, int]]) -> int: Determine the number of different relay teams that can be formed. A team consists of one runner, one cyclist, and one swimmer from different countries. Args: n (int): The number of countries. participants (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers representing the number of runners, cyclists, and swimmers in each country. Returns: int: The number of possible different relay teams. >>> number_of_teams(3, [(2, 0, 0), (0, 2, 0), (0, 0, 2)]) 8 >>> number_of_teams(3, [(0, 0, 0), (0, 0, 0), (0, 0, 0)]) 0 >>> number_of_teams(3, [(1, 0, 0), (0, 1, 0), (0, 0, 1)]) 1 # Unit test example def test_example_case(): participants = [ (2, 0, 0), (0, 2, 0), (0, 0, 2) ] assert number_of_teams(3, participants) == 8 def test_all_counts_zero(): participants = [ (0, 0, 0), (0, 0, 0), (0, 0, 0) ] assert number_of_teams(3, participants) == 0 def test_one_possible_team(): participants = [ (1, 0, 0), (0, 1, 0), (0, 0, 1) ] assert number_of_teams(3, participants) == 1 def test_large_numbers(): participants = [ (10**6, 0, 0), (0, 10**6, 0), (0, 0, 10**6) ] assert number_of_teams(3, participants) == (10**6)**3 def test_varying_numbers(): participants = [ (100, 200, 300), (400, 500, 600), (700, 800, 900) ] total_runners = 100 + 400 + 700 total_cyclists = 200 + 500 + 800 total_swimmers = 300 + 600 + 900 expected = total_runners * total_cyclists * total_swimmers assert number_of_teams(3, participants) == expected","solution":"def number_of_teams(n, participants): total_runners = sum([p[0] for p in participants]) total_cyclists = sum([p[1] for p in participants]) total_swimmers = sum([p[2] for p in participants]) return total_runners * total_cyclists * total_swimmers"},{"question":"from typing import List def max_non_adjacent_sum(arr: List[int]) -> int: Given an array of N integers, return the maximum possible sum of its elements with the constraint that no two adjacent elements can be part of the sum. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([-1, -2, -3]) 0 >>> max_non_adjacent_sum([100, 200, 300, 400]) 600 >>> max_non_adjacent_sum([50, 1, 50, 1, 50]) 150","solution":"from typing import List def max_non_adjacent_sum(arr: List[int]) -> int: Returns the maximum sum of non-adjacent elements. if not arr: return 0 incl = 0 excl = 0 for num in arr: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"def can_segment_string(dict: List[str], test_cases: List[str]) -> List[str]: Determine if a given string can be segmented into a space-separated sequence of one or more dictionary words. Parameters: dict (List[str]): A list of strings representing dictionary words. test_cases (List[str]): A list of space-separated strings to test. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. >>> dict = [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"] >>> test_cases = [\\"applepenapple\\", \\"pineapplepenapple\\", \\"catsandog\\"] >>> can_segment_string(dict, test_cases) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_segment_string(dict, test_cases): word_set = set(dict) def can_segment(s): dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[-1] else \\"NO\\" results = [] for test in test_cases: results.append(can_segment(test)) return results"},{"question":"def final_coordinates(command_sequences): Given multiple command sequences, calculate the final coordinates of the spaceship. Parameters: command_sequences: A list of command sequences. Each command sequence is a list of strings where the first element is the number of commands, followed by that many commands. Returns: A list of tuples where each tuple represents the final coordinates (x, y) for the corresponding command sequence. >>> final_coordinates([[\\"3\\", \\"move up\\", \\"move up\\", \\"move left\\"], [\\"4\\", \\"move down\\", \\"move down\\", \\"move right\\", \\"move right\\"]]) [(-1, -2), (2, 2)] >>> final_coordinates([[\\"6\\", \\"move up\\", \\"move down\\", \\"move left\\", \\"move right\\", \\"move up\\", \\"move up\\"]]) [(0, -2)]","solution":"def final_coordinates(command_sequences): Given multiple command sequences, calculate the final coordinates of the spaceship. Parameters: command_sequences: A list of command sequences. Each command sequence is a list of strings where the first element is the number of commands, followed by that many commands. Returns: A list of tuples where each tuple represents the final coordinates (x, y) for the corresponding command sequence. results = [] for commands in command_sequences: N = int(commands[0]) x, y = 0, 0 for i in range(1, N + 1): command = commands[i] if command == \\"move up\\": y -= 1 elif command == \\"move down\\": y += 1 elif command == \\"move left\\": x -= 1 elif command == \\"move right\\": x += 1 results.append((x, y)) return results"},{"question":"def spiciness_levels_within_range(test_cases): Calculates the number of unique spiciness levels within the given range for each test case. Each test case contains: - N: number of burgers - L: lower bound of the spiciness range - R: upper bound of the spiciness range - A: list of spiciness levels of the burgers Parameters: test_cases (list of tuples): List containing tuples of the form (N, L, R, A). Returns: list: List containing the number of unique spiciness levels within the range [L, R] for each test case. >>> test_cases = [ ... (4, 10, 20, [10, 15, 20, 25]), ... (5, 5, 10, [1, 2, 3, 3, 3]) ... ] >>> spiciness_levels_within_range(test_cases) [3, 0] >>> test_cases = [ ... (6, 1, 3, [1, 2, 2, 3, 4, 5]), ... (3, 3, 5, [3, 4, 5]), ... (3, 1, 1, [1, 1, 1]) ... ] >>> spiciness_levels_within_range(test_cases) [3, 3, 1] >>> test_cases = [ ... (4, 50, 60, [100, 200, 300, 400]), ... (4, 0, 1, [1, 2, 3, 4]) ... ] >>> spiciness_levels_within_range(test_cases) [0, 1] >>> test_cases = [ ... (1, 1, 1000, [500]), ... (2, 1, 2, [2, 2]) ... ] >>> spiciness_levels_within_range(test_cases) [1, 1] >>> test_cases = [ ... (5, 7, 10, [8, 9, 10, 11, 12]), ... (3, 1, 2, [1, 2, 3]) ... ] >>> spiciness_levels_within_range(test_cases) [3, 2]","solution":"def spiciness_levels_within_range(test_cases): results = [] for N, L, R, A in test_cases: unique_spiciness_levels = set() for spiciness in A: if L <= spiciness <= R: unique_spiciness_levels.add(spiciness) results.append(len(unique_spiciness_levels)) return results"},{"question":"def max_shoppers(test_cases): Determines the maximum number of shoppers present in the mall at any given time for multiple test cases. Args: test_cases (List[List[Tuple[int, int]]]): A list of test cases where each test case is a list of tuples with entry and exit times. Returns: List[int]: A list with the maximum number of shoppers during any overlap for each test case. >>> max_shoppers([[(1, 5), (2, 6), (4, 8)], [(1, 3), (2, 5), (4, 8), (6, 10)]]) [3, 2] >>> max_shoppers([[(1, 2), (3, 4), (5, 6)]]) [1] >>> max_shoppers([[(1, 10), (2, 9), (3, 8), (4, 7), (5, 6)]]) [5]","solution":"def max_shoppers(test_cases): results = [] for case in test_cases: events = [] for entry, exit in case: events.append((entry, 'entry')) events.append((exit, 'exit')) events.sort() current_shoppers = 0 max_shoppers = 0 for time, event in events: if event == 'entry': current_shoppers += 1 max_shoppers = max(max_shoppers, current_shoppers) else: current_shoppers -= 1 results.append(max_shoppers) return results"},{"question":"def online_marketplace(n, q, items, queries): Process multiple queries to return item IDs that match given keywords. Args: n (int): Number of items. q (int): Number of queries. items (List[str]): List of strings where each string contains item_id, item_name, and item keywords. queries (List[str]): List of query keywords. Returns: List[str]: List of strings where each string contains item IDs whose keywords include the given query keyword. Example: >>> online_marketplace(3, 2, [\\"1 'Laptop' electronics computer portable\\", \\"2 'Headphones' audio music electronics\\", \\"3 'Keyboard' computer accessories electronics\\"], [\\"computer\\", \\"music\\"]) [\\"1 3\\", \\"2\\"] >>> online_marketplace(2, 1, [\\"1 'Mouse' peripheral wireless\\", \\"2 'Monitor' display HDMI VGA\\"], [\\"keyboard\\"]) [\\"\\"]","solution":"def online_marketplace(n, q, items, queries): from collections import defaultdict keyword_to_ids = defaultdict(list) # Process each item for item in items: parts = item.split() item_id = int(parts[0]) keywords = parts[2:] for keyword in keywords: keyword_to_ids[keyword].append(item_id) result = [] # Process each query for query in queries: if query in keyword_to_ids: result.append(\\" \\".join(map(str, sorted(keyword_to_ids[query])))) else: result.append(\\"\\") return result"},{"question":"def find_pair_indices(nums, target): Returns the indices (1-based) of the two numbers in the list nums whose sum equals the target. If no such pair exists, returns -1. >>> find_pair_indices([2, 7, 11, 15, 1], 9) == (1, 2) >>> find_pair_indices([1, 2, 3, 4], 8) == -1 >>> find_pair_indices([1, -1, 2, -2], 0) == (1, 2) >>> find_pair_indices([3, 3, 4, 5], 6) == (1, 2) >>> find_pair_indices([], 5) == -1 pass def process_datasets(datasets): Processes multiple datasets to find pair of indices for each dataset. datasets: List of tuples, where each tuple contains (N, T, L) N -> number of integers in the list T -> target sum L -> list of integers >>> process_datasets([(5, 9, [2, 7, 11, 15, 1]), (4, 8, [1, 2, 3, 4])]) == [(1, 2), -1] >>> process_datasets([(4, 0, [1, -1, 2, -2]), (4, 6, [3, 3, 4, 5])]) == [(1, 2), (1, 2)] >>> process_datasets([(1, 0, [0]), (2, 4, [1, 3])]) == [-1, (1, 2)] pass","solution":"def find_pair_indices(nums, target): Returns the indices (1-based) of the two numbers in the list nums whose sum equals the target. If no such pair exists, returns -1. num_indices = {} for i, num in enumerate(nums): complement = target - num if complement in num_indices: return (num_indices[complement] + 1, i + 1) num_indices[num] = i return -1 def process_datasets(datasets): Processes multiple datasets to find pair of indices for each dataset. datasets: List of tuples, where each tuple contains (N, T, L) N -> number of integers in the list T -> target sum L -> list of integers results = [] for N, T, L in datasets: result = find_pair_indices(L, T) results.append(result) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def create_tree(node_list): Creates a binary tree from a list of nodes. Args: node_list: List of tuples where each tuple contains (val, left, right) Returns: The root node of the binary tree. nodes = {} for idx, node in enumerate(node_list): val, left, right = node if idx + 1 not in nodes: nodes[idx + 1] = TreeNode(val) nodes[idx + 1].val = val if left != 0: if left not in nodes: nodes[left] = TreeNode() nodes[idx + 1].left = nodes[left] if right != 0: if right not in nodes: nodes[right] = TreeNode() nodes[idx + 1].right = nodes[right] return nodes[1] def sum_at_depth(root, depth): Calculates the sum of all node values at a specific depth in a binary tree. Args: root: The root node of the binary tree. depth: The depth at which the sum of node values is calculated. Returns: The sum of values of all nodes at the given depth. if not root: return 0 if depth == 0: return root.val left_sum = sum_at_depth(root.left, depth - 1) if root.left else 0 right_sum = sum_at_depth(root.right, depth - 1) if root.right else 0 return left_sum + right_sum def find_sums_of_depths(test_cases): Computes the sum of all node values at specified depths for multiple test cases. Args: test_cases: A list of tuples, where each tuple contains the depth, number of nodes, and list of nodes. Returns: A list of sums of node values at the specified depths for each test case. results = [] for d, n, nodes in test_cases: tree = create_tree(nodes) results.append(sum_at_depth(tree, d)) return results # Test cases def test_single_test_case_1(): test_cases = [ (2, 5, [ (1, 2, 3), (2, 4, 5), (3, 0, 0), (4, 0, 0), (5, 0, 0) ]) ] assert find_sums_of_depths(test_cases) == [9] # Depth 2 nodes are [4, 5] def test_single_test_case_2(): test_cases = [ (1, 3, [ (6, 2, 3), (2, 0, 0), (3, 0, 0) ]) ] assert find_sums_of_depths(test_cases) == [5] # Depth 1 nodes are [2, 3] def test_no_nodes_at_depth(): test_cases = [ (3, 3, [ (6, 2, 3), (2, 0, 0), (3, 0, 0) ]) ] assert find_sums_of_depths(test_cases) == [0] # No nodes at depth 3 def test_single_node_tree_zero_depth(): test_cases = [ (0, 1, [ (10, 0, 0) ]) ] assert find_sums_of_depths(test_cases) == [10] # Single node at depth 0 def test_various_depths(): test_cases = [ (2, 5, [ (1, 2, 3), (2, 4, 5), (3, 0, 0), (4, 0, 0), (5, 0, 0) ]), (1, 3, [ (6, 2, 3), (2, 0, 0), (3, 0, 0) ]) ] assert find_sums_of_depths(test_cases) == [9, 5] # First testcase depth 2, second testcase depth 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def create_tree(node_list): nodes = {} for idx, node in enumerate(node_list): val, left, right = node if idx + 1 not in nodes: nodes[idx + 1] = TreeNode(val) nodes[idx + 1].val = val if left != 0: if left not in nodes: nodes[left] = TreeNode() nodes[idx + 1].left = nodes[left] if right != 0: if right not in nodes: nodes[right] = TreeNode() nodes[idx + 1].right = nodes[right] return nodes[1] def sum_at_depth(root, depth): if not root: return 0 if depth == 0: return root.val left_sum = sum_at_depth(root.left, depth - 1) if root.left else 0 right_sum = sum_at_depth(root.right, depth - 1) if root.right else 0 return left_sum + right_sum def find_sums_of_depths(test_cases): results = [] for d, n, nodes in test_cases: tree = create_tree(nodes) results.append(sum_at_depth(tree, d)) return results"},{"question":"def shortest_sequence_length(t, test_cases): Given the number of test cases and the test cases themselves, return the shortest possible length of the sequence after performing the allergic operation. Parameters: - t: Number of test cases - test_cases: List of tuples, where each tuple consists of (n, sequence) Returns: List of integers representing the shortest possible length of the sequence for each test case. pass # Example test cases def test_example_cases(): assert shortest_sequence_length(2, [(4, [3, 3, 2, 2]), (5, [1, 1, 1, 1, 1])]) == [2, 1] def test_no_repetition(): assert shortest_sequence_length(1, [(5, [1, 2, 3, 4, 5])]) == [5] def test_all_same_elements(): assert shortest_sequence_length(2, [(3, [1, 1, 1]), (4, [2, 2, 2, 2])]) == [1, 1] def test_mixed_elements(): assert shortest_sequence_length(1, [(6, [1, 1, 2, 2, 3, 3])]) == [3] def test_large_input(): sequence = [1] * 100000 + [2] * 100000 assert shortest_sequence_length(1, [(200000, sequence)]) == [2]","solution":"def shortest_sequence_length(t, test_cases): Given the number of test cases and the test cases themselves, return the shortest possible length of the sequence after performing the allergic operation. Parameters: - t: Number of test cases - test_cases: List of tuples, where each tuple consists of (n, sequence) Returns: List of integers representing the shortest possible length of the sequence for each test case. results = [] for n, sequence in test_cases: # To minimize, we just need to count unique elements since we can reduce all repetitions unique_elements = len(set(sequence)) results.append(unique_elements) return results"},{"question":"def findTopStudent(students): Write a function \`findTopStudent\` that accepts a list of dictionaries, where each dictionary represents a student and contains their name and their scores in three subjects: Mathematics, Chemistry, and Physics. The function should return the name of the student with the highest total score across all three subjects. If there is a tie, the student who appears first in the list should be returned. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"Mathematics\\": 90, \\"Chemistry\\": 85, \\"Physics\\": 82}, ... {\\"name\\": \\"Bob\\", \\"Mathematics\\": 88, \\"Chemistry\\": 89, \\"Physics\\": 95}, ... {\\"name\\": \\"Charlie\\", \\"Mathematics\\": 95, \\"Chemistry\\": 90, \\"Physics\\": 85} ... ] >>> findTopStudent(students) 'Bob' from solution import findTopStudent def test_single_student(): students = [{\\"name\\": \\"Alice\\", \\"Mathematics\\": 90, \\"Chemistry\\": 85, \\"Physics\\": 82}] assert findTopStudent(students) == \\"Alice\\" def test_multiple_students(): students = [ {\\"name\\": \\"Alice\\", \\"Mathematics\\": 90, \\"Chemistry\\": 85, \\"Physics\\": 82}, {\\"name\\": \\"Bob\\", \\"Mathematics\\": 88, \\"Chemistry\\": 89, \\"Physics\\": 95}, {\\"name\\": \\"Charlie\\", \\"Mathematics\\": 95, \\"Chemistry\\": 90, \\"Physics\\": 85} ] assert findTopStudent(students) == \\"Bob\\" def test_tie_scores(): students = [ {\\"name\\": \\"Alice\\", \\"Mathematics\\": 90, \\"Chemistry\\": 85, \\"Physics\\": 82}, {\\"name\\": \\"Bob\\", \\"Mathematics\\": 88, \\"Chemistry\\": 89, \\"Physics\\": 95}, {\\"name\\": \\"Charlie\\", \\"Mathematics\\": 88, \\"Chemistry\\": 89, \\"Physics\\": 95} ] assert findTopStudent(students) == \\"Bob\\" def test_all_students_same_scores(): students = [ {\\"name\\": \\"Alice\\", \\"Mathematics\\": 90, \\"Chemistry\\": 85, \\"Physics\\": 82}, {\\"name\\": \\"Bob\\", \\"Mathematics\\": 90, \\"Chemistry\\": 85, \\"Physics\\": 82}, {\\"name\\": \\"Charlie\\", \\"Mathematics\\": 90, \\"Chemistry\\": 85, \\"Physics\\": 82} ] assert findTopStudent(students) == \\"Alice\\" def test_students_with_zero_scores(): students = [ {\\"name\\": \\"Alice\\", \\"Mathematics\\": 0, \\"Chemistry\\": 0, \\"Physics\\": 0}, {\\"name\\": \\"Bob\\", \\"Mathematics\\": 0, \\"Chemistry\\": 0, \\"Physics\\": 0}, {\\"name\\": \\"Charlie\\", \\"Mathematics\\": 0, \\"Chemistry\\": 0, \\"Physics\\": 0} ] assert findTopStudent(students) == \\"Alice\\"","solution":"def findTopStudent(students): Returns the name of the student with the highest total score. If there is a tie, the first student in the list with the highest score is returned. highest_score = -1 top_student = \\"\\" for student in students: total_score = student[\\"Mathematics\\"] + student[\\"Chemistry\\"] + student[\\"Physics\\"] if total_score > highest_score: highest_score = total_score top_student = student[\\"name\\"] return top_student"},{"question":"def longest_balanced_substring(s: str) -> int: Find the length of the longest balanced and properly nested substring of brackets. Args: s (str): A string of round and square brackets. Returns: int: Length of the longest balanced substring. Example: >>> longest_balanced_substring(\\"[][()]\\") 6 >>> longest_balanced_substring(\\"[[]][]\\") 6 >>> longest_balanced_substring(\\"[[][()]]\\") 8 def process_input(test_cases: List[str]) -> List[int]: Process a list of test cases to find the length of the longest balanced substring for each case. Args: test_cases (List[str]): A list of strings, each containing round and square brackets. Returns: List[int]: A list of integers, where each integer represents the length of the longest balanced substring for the corresponding input string. Example: >>> process_input([\\"[][()]\\", \\"[[]][]\\", \\"[[][()]]\\"]) [6, 6, 8] from typing import List # Uncomment the following lines to run the tests # def test_longest_balanced_substring(): # assert longest_balanced_substring(\\"[][()]\\") == 6 # assert longest_balanced_substring(\\"[[]][]\\") == 6 # assert longest_balanced_substring(\\"[[][()]]\\") == 8 # assert longest_balanced_substring(\\"[[[]]]\\") == 6 # assert longest_balanced_substring(\\"[[\\") == 0 # assert longest_balanced_substring(\\"][\\") == 0 # assert longest_balanced_substring(\\"()\\") == 2 # assert longest_balanced_substring(\\"([])\\") == 4 # assert longest_balanced_substring(\\"[()]\\") == 4 # assert longest_balanced_substring(\\"[]()\\") == 4 # def test_process_input(): # assert process_input([\\"[][()]\\", \\"[[]][]\\", \\"[[][()]]\\"]) == [6, 6, 8] # assert process_input([\\"[[[]]]\\", \\"[[\\", \\"][\\", \\"()\\"]) == [6, 0, 0, 2] # assert process_input([\\"([])\\", \\"[()]\\", \\"[]()\\"]) == [4, 4, 4]","solution":"def longest_balanced_substring(s): max_length = 0 stack = [] start = -1 for i, char in enumerate(s): if char in \\"([\\": # When we encounter an opening bracket stack.append(i) else: # When we encounter a closing bracket if stack: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: max_length = max(max_length, i - start) else: start = i return max_length def process_input(test_cases): results = [] for s in test_cases: results.append(longest_balanced_substring(s)) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() t = int(data[0]) cases = data[1:t+1] results = process_input(cases) for result in results: print(result)"},{"question":"def min_operations_to_sort(n: int, array: List[int]) -> int: Determine the minimum number of operations required to make the sequence sorted in ascending order. >>> min_operations_to_sort(5, [1, 2, 3, 4, 5]) 0 >>> min_operations_to_sort(5, [3, 1, 2, 5, 4]) 2","solution":"def min_operations_to_sort(n, array): if n <= 1: return 0 sorted_array = sorted(array) if array == sorted_array: return 0 l, r = 0, n - 1 while l < n and array[l] == sorted_array[l]: l += 1 while r >= 0 and array[r] == sorted_array[r]: r -= 1 if l > r: return 0 if array[l:r+1] == sorted(array[l:r+1])[::-1]: return 1 return 2"},{"question":"import heapq def find_shortest_path(N, roads, A, B): Returns the minimum travel time from intersection A to intersection B. If no route exists, returns -1. >>> find_shortest_path(5, [(0, 1, 10), (1, 2, 5), (2, 3, 2), (0, 3, 20), (2, 4, 1)], 0, 4) == 16 >>> find_shortest_path(3, [(0, 1, 1), (1, 2, 2)], 0, 2) == 3 >>> find_shortest_path(3, [(0, 1, 5), (1, 2, 10)], 0, 2) == 15 >>> find_shortest_path(3, [(0, 1, 5), (1, 2, 10)], 0, 3) == -1","solution":"import heapq def find_shortest_path(N, roads, A, B): Returns the minimum travel time from intersection A to intersection B. If no route exists, returns -1. # Create adjacency list adjacency_list = [[] for _ in range(N)] for u, v, w in roads: adjacency_list[u].append((v, w)) adjacency_list[v].append((u, w)) # Use Dijkstra's algorithm to find the shortest path from A to B min_heap = [(0, A)] shortest_paths = {i: float('inf') for i in range(N)} shortest_paths[A] = 0 while min_heap: curr_time, curr_intersection = heapq.heappop(min_heap) if curr_intersection == B: return curr_time if curr_time > shortest_paths[curr_intersection]: continue for neighbor, travel_time in adjacency_list[curr_intersection]: time = curr_time + travel_time if time < shortest_paths[neighbor]: shortest_paths[neighbor] = time heapq.heappush(min_heap, (time, neighbor)) return -1"},{"question":"def categorize_feedback(T: int, ratings: List[int]) -> List[str]: Classify the trip experience based on feedback ratings. T : int The number of feedback ratings. ratings : List[int] The feedback ratings. Returns ------- categories : List[str] The categorization for each rating. >>> categorize_feedback(5, [1, 5, 7, 10, 3]) ['POOR', 'AVERAGE', 'GOOD', 'EXCELLENT', 'POOR']","solution":"def categorize_feedback(T, ratings): categories = [] for rating in ratings: if rating < 4: categories.append('POOR') elif 4 <= rating <= 6: categories.append('AVERAGE') elif 7 <= rating <= 9: categories.append('GOOD') elif rating == 10: categories.append('EXCELLENT') return categories"},{"question":"from typing import List, Tuple def find_steepest_path(n: int, elevations: List[int]) -> Tuple[int, int, int]: Determine the steepest path on a mountainous trail. >>> find_steepest_path(6, [1, 3, 6, 7, 4, 2]) (6, 0, 3) >>> find_steepest_path(2, [5, 1]) (0, 0, 0) from solution import find_steepest_path def test_single_point(): assert find_steepest_path(1, [5]) == (0, 0, 0) def test_two_points(): assert find_steepest_path(2, [1, 5]) == (4, 0, 1) assert find_steepest_path(2, [5, 1]) == (0, 0, 0) def test_steepest_at_end(): assert find_steepest_path(3, [1, 1, 10]) == (9, 0, 2) def test_steepest_in_middle(): assert find_steepest_path(6, [1, 3, 6, 7, 4, 2]) == (6, 0, 3) def test_multiple_same_steepness(): assert find_steepest_path(6, [1, 10, 3, 10, 5, 10]) == (9, 0, 1) def test_decreasing_elevations(): assert find_steepest_path(4, [10, 9, 8, 7]) == (0, 0, 0) def test_increasing_and_decreasing(): assert find_steepest_path(5, [1, 3, 5, 2, 4]) == (4, 0, 2)","solution":"def find_steepest_path(n, elevations): max_difference = 0 start_index = 0 end_index = 0 min_elevation = elevations[0] min_index = 0 for i in range(1, n): if elevations[i] > elevations[min_index]: difference = elevations[i] - min_elevation if difference > max_difference: max_difference = difference start_index = min_index end_index = i elif difference == max_difference: if min_index < start_index or (min_index == start_index and i < end_index): start_index = min_index end_index = i elif elevations[i] < min_elevation: min_elevation = elevations[i] min_index = i return max_difference, start_index, end_index"},{"question":"def min_operations_to_equal_elements(arr): This function takes a list of integers and returns the minimum number of operations required to make all the elements in the list equal by replacing A and B with |A - B| and A + B. Parameters: arr (list): The list of integers Returns: int: Minimum number of operations required to make all elements equal >>> min_operations_to_equal_elements([1, 3, 2]) == 2 >>> min_operations_to_equal_elements([1, 2, 1, 2]) == 3 pass def test_min_operations_to_equal_elements(): assert min_operations_to_equal_elements([1, 3, 2]) == 2 assert min_operations_to_equal_elements([1, 2, 1, 2]) == 3 assert min_operations_to_equal_elements([5, 5, 5]) == 2 assert min_operations_to_equal_elements([8, 16, 32]) == 2 assert min_operations_to_equal_elements([1, 2, 3, 4, 5]) == 4 assert min_operations_to_equal_elements([10, 15, 25]) == 2 assert min_operations_to_equal_elements([4, 6, 8]) == 2 assert min_operations_to_equal_elements([1000, 1000, 1000, 1000, 1000]) == 4 import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def min_operations_to_equal_elements(arr): This function takes a list of integers and returns the minimum number of operations required to make all the elements in the list equal by replacing A and B with |A - B| and A + B. Parameters: arr (list): The list of integers Returns: int: Minimum number of operations required to make all elements equal def gcd(x, y): # Helper function to compute GCD while y: x, y = y, x % y return x # Compute the gcd of the array n = len(arr) array_gcd = arr[0] for i in range(1, n): array_gcd = gcd(array_gcd, arr[i]) # If gcd is 1, then we need exactly n-1 operations if array_gcd == 1: return n - 1 # If gcd > 1, then we can make all elements equal in exactly n-1 operations return n - 1"},{"question":"from typing import List, Tuple def two_sum(target: int, nums: List[int]) -> Tuple[int, int]: Finds the indices of two numbers in an array that add up to the target sum. Args: target (int): The target sum. nums (List[int]): The list of integers in which we need to find the indices. Returns: Tuple[int, int]: A tuple containing the indices of the two numbers that add up to the target sum. >>> two_sum(9, [2, 7, 11, 15, 5]) (0, 1) >>> two_sum(6, [3, 2, 4, 8]) (1, 2) >>> two_sum(10, [1, 2, 3, 4, 6]) (3, 4) >>> two_sum(17, [2, 7, 11, 15]) (0, 3) pass def find_indices(test_cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[int, int]]: Processes multiple test cases to find the indices of two numbers that add up to the target sum. Args: test_cases (List[Tuple[int, int, List[int]]]): Each tuple contains (target, num_elements, list of integers). Returns: List[Tuple[int, int]]: Each tuple contains the indices of the two numbers that add up to the target sum. >>> test_cases = [ ... (9, 5, [2, 7, 11, 15, 5]), ... (6, 4, [3, 2, 4, 8]), ... (10, 5, [1, 2, 3, 4, 6]), ... (17, 4, [2, 7, 11, 15]) ... ] >>> find_indices(test_cases) [(0, 1), (1, 2), (3, 4), (0, 3)] pass","solution":"def two_sum(target, nums): Finds the indices of two numbers in an array that add up to the target sum. Args: target (int): The target sum. nums (list of int): The list of integers in which we need to find the indices. Returns: tuple: A tuple containing the indices of the two numbers that add up to the target sum. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement], i) num_map[num] = i def find_indices(test_cases): Processes multiple test cases to find the indices of two numbers that add up to the target sum. Args: test_cases (list of tuples): Each tuple contains (target, num_elements, list of integers). Returns: list of tuples: Each tuple contains the indices of the two numbers that add up to the target sum. results = [] for case in test_cases: target, _, nums = case indices = two_sum(target, nums) results.append(indices) return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Return the length of the longest subsequence that can be formed to create a palindrome. >>> longest_palindromic_subsequence(\\"bbabcbcab\\") 7 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"ab\\") 1 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"character\\") 5 >>> longest_palindromic_subsequence(\\"\\") 0 >>> longest_palindromic_subsequence(\\"aaaaa\\") 5 >>> longest_palindromic_subsequence(\\"abcdef\\") 1","solution":"def longest_palindromic_subsequence(s): This function returns the length of the longest palindromic subsequence in the given string s. n = len(s) if n == 0: return 0 # Create a table to store results of subproblems dp = [[0] * n for _ in range(n)] # Strings of length 1 are palindromic of length 1 for i in range(n): dp[i][i] = 1 # Build the dp table for cl in range(2, n + 1): # cl is the length of the substring for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The length of LPS is the last entry in the table return dp[0][n - 1]"},{"question":"def max_subarray_sum(arr): Finds the maximum possible sum of any subarray. Parameters: arr (List[int]): An array of integers containing both positive and negative numbers. Returns: int: The maximum sum of any subarray of the given array. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([3]) 3 >>> max_subarray_sum([-3]) -3 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([0, -3, 5, -2, 0, -1, 2]) 5","solution":"def max_subarray_sum(arr): Finds the maximum sum of any subarray using Kadane's algorithm. max_so_far = -float('inf') max_ending_here = 0 for num in arr: max_ending_here += num if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far"},{"question":"def countDistinctSubstrings(s: str) -> int: Given a string consisting of lowercase and uppercase characters, return the count of distinct substrings that start and end with the same character. Example 1: >>> countDistinctSubstrings(\\"abcab\\") 7 Example 2: >>> countDistinctSubstrings(\\"aaa\\") 6","solution":"def countDistinctSubstrings(s: str) -> int: Returns the count of distinct substrings that start and end with the same character. n = len(s) substr_count = 0 # Check all possible substrings for i in range(n): for j in range(i, n): if s[i] == s[j]: substr_count += 1 return substr_count"},{"question":"def find_pairs(n: int, k: int, arr: List[int]) -> None: You are given an array of integers and an integer \`k\`. Your task is to find \`k\` pairs of integers from the array such that the sum of the integers in each pair is divisible by 3. Each integer in the array can be used at most once. If there are multiple solutions, print any of them. If no such pairs exist, print \\"NO\\". Args: n: The number of integers in the array. k: The number of pairs to be found. arr: A list of integers. Example usage: >>> find_pairs(6, 2, [1, 2, 3, 4, 5, 6]) YES 1 2 3 6 >>> find_pairs(5, 3, [1, 2, 2, 4, 5]) NO from typing import List # Unit Tests def test_example1(capfd): find_pairs(6, 2, [1, 2, 3, 4, 5, 6]) out, _ = capfd.readouterr() assert \\"YES\\" in out def test_example2(capfd): find_pairs(5, 3, [1, 2, 2, 4, 5]) out, _ = capfd.readouterr() assert out.strip() == \\"NO\\" def test_no_pairs(capfd): find_pairs(4, 1, [1, 1, 1, 1]) out, _ = capfd.readouterr() assert out.strip() == \\"NO\\" def test_exact_pairs(capfd): find_pairs(6, 3, [3, 6, 1, 2, 4, 5]) out, _ = capfd.readouterr() assert \\"YES\\" in out def test_more_than_needed_pairs(capfd): find_pairs(7, 2, [3, 6, 1, 2, 4, 5, 9]) out, _ = capfd.readouterr() assert \\"YES\\" in out def test_edge_case(capfd): find_pairs(10**5, 1, [3] * 10**5) out, _ = capfd.readouterr() assert \\"YES\\" in out","solution":"def find_pairs(n, k, arr): # Initialize count arrays for remainders when divided by 3 count = [0] * 3 mod_map = {0: [], 1: [], 2: []} # Fill count arrays and mod_map for num in arr: remainder = num % 3 count[remainder] += 1 mod_map[remainder].append(num) pairs = [] # Pair elements directly from same remainder 0 list while len(mod_map[0]) >= 2 and len(pairs) < k: pairs.append((mod_map[0].pop(), mod_map[0].pop())) # Pair elements from remainder 1 and 2 lists while len(mod_map[1]) > 0 and len(mod_map[2]) > 0 and len(pairs) < k: pairs.append((mod_map[1].pop(), mod_map[2].pop())) # Check if we have found required number of pairs if len(pairs) == k: print(\\"YES\\") for p in pairs: print(p[0], p[1]) else: print(\\"NO\\") # Example usage: # find_pairs(6, 2, [1, 2, 3, 4, 5, 6])"},{"question":"def transformList(lst): Returns a list where each element is the product of all elements in the original list except for the element at the current index, without using division. Examples: >>> transformList([1, 2, 3, 4]) [24, 12, 8, 6] >>> transformList([5]) [1] pass import pytest def test_transformList_example(): assert transformList([1, 2, 3, 4]) == [24, 12, 8, 6] def test_transformList_single_element(): assert transformList([5]) == [1] def test_transformList_two_elements(): assert transformList([2, 3]) == [3, 2] def test_transformList_with_zeros(): assert transformList([1, 0, 3, 4]) == [0, 12, 0, 0] def test_transformList_multiple_zeros(): assert transformList([1, 0, 3, 0]) == [0, 0, 0, 0] def test_transformList_negative_numbers(): assert transformList([-1, 2, -3, 4]) == [-24, 12, -8, 6] def test_transformList_mixed_numbers(): assert transformList([3, -2, 5, -1, 4]) == [40, -60, 24, -120, 30] def test_transformList_all_ones(): assert transformList([1, 1, 1, 1]) == [1, 1, 1, 1] def test_transformList_empty_list(): assert transformList([]) == [] @pytest.mark.parametrize(\\"input_list, expected_output\\", [ ([1, 2, 3, 4, 5], [120, 60, 40, 30, 24]), ([2, 4, 6], [24, 12, 8]), ([10, 20], [20, 10]), ]) def test_transformList_parametrized(input_list, expected_output): assert transformList(input_list) == expected_output","solution":"def transformList(lst): Returns a list where each element is the product of all elements in the original list except for the element at the current index, without using division. n = len(lst) if n == 0: return [] # Initialize two lists for prefix and suffix products prefix_products = [1] * n suffix_products = [1] * n # Calculate prefix products for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * lst[i - 1] # Calculate suffix products for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * lst[i + 1] # Calculate the result by multiplying prefix and suffix products result = [0] * n for i in range(n): result[i] = prefix_products[i] * suffix_products[i] return result"},{"question":"def count_simple_cycles(N, M, edges): Determine the number of simple cycles in an undirected graph with N vertices and M edges. Parameters: N (int): Number of vertices in the graph. M (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of edges, where each edge is represented by a tuple of two vertices. Returns: int: Number of simple cycles in the graph. Example: >>> N = 5 >>> M = 6 >>> edges = [ ... (1, 2), ... (2, 3), ... (3, 4), ... (4, 1), ... (2, 4), ... (3, 5) ... ] >>> count_simple_cycles(N, M, edges) 3 >>> N = 3 >>> M = 2 >>> edges = [ ... (1, 2), ... (2, 3) ... ] >>> count_simple_cycles(N, M, edges) 0","solution":"def count_simple_cycles(N, M, edges): from itertools import permutations from collections import defaultdict # Function to check if a given permutation forms a simple cycle def is_cycle(perm, edges_set): for i in range(len(perm)): if (perm[i], perm[(i + 1) % len(perm)]) not in edges_set and (perm[(i + 1) % len(perm)], perm[i]) not in edges_set: return False return True # Build edge set for quick lookup edges_set = set((u, v) for u, v in edges) # Adjacency list adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # List to store cycles found simple_cycles = set() # Check all permutation of vertices of length 3 to N for length in range(3, N + 1): for perm in permutations(range(1, N + 1), length): if perm[0] < perm[-1]: # To avoid cycles being counted multiple times # Check if perm is a valid simple cycle if is_cycle(perm, edges_set) and len(set(perm)) == length and perm[0] in adj[perm[-1]]: simple_cycles.add(tuple(sorted(perm))) return len(simple_cycles)"},{"question":"def min_operations(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Compute the minimum number of operations required to make all elements in each array zero. In one operation, you can choose two elements of the array, say a[i] and a[j], and set one of them to the absolute difference |a[i] - a[j]| and the other to zero. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list where each element is a tuple containing an integer n (the number of elements in the array) and a list of n integers representing the array. Returns: List[int]: A list of integers where each integer represents the minimum number of operations required for the corresponding test case. Examples: >>> min_operations(2, [(3, [1, 2, 3]), (4, [5, 6, 7, 8])]) [2, 3] >>> min_operations(1, [(5, [2, 4, 6, 8, 10])]) [4]","solution":"def min_operations(t, test_cases): results = [] for case in test_cases: n, a = case # If there's only one element, no operations required as it's already zero if n == 1: results.append(0) else: results.append(n - 1) return results"},{"question":"def closest_triangular_number(N: int) -> int: Find the closest triangular number to a given integer N. If two triangular numbers are equally close, return the smaller one. >>> closest_triangular_number(10) 10 >>> closest_triangular_number(20) 21 pass def find_closest_triangular_numbers(test_cases: List[int]) -> List[int]: Given a list of integers, return a list of closest triangular numbers for each integer in the input list. >>> find_closest_triangular_numbers([10, 20]) [10, 21] >>> find_closest_triangular_numbers([1, 10, 19, 28]) [1, 10, 21, 28] pass","solution":"def closest_triangular_number(N): k = int(((8 * N + 1)**0.5 - 1) / 2) lower_triangular = k * (k + 1) // 2 higher_triangular = (k + 1) * (k + 2) // 2 if abs(lower_triangular - N) <= abs(higher_triangular - N): return lower_triangular else: return higher_triangular def find_closest_triangular_numbers(test_cases): results = [] for N in test_cases: results.append(closest_triangular_number(N)) return results # Sample usage t = 2 test_cases = [10, 20] results = find_closest_triangular_numbers(test_cases) for result in results: print(result)"},{"question":"def preprocess_and_solve_queries(N, roads, queries): Processes a graph of N cities connected by N-1 roads and answers Q queries about the distance between pairs of cities. Args: N (int): Number of cities roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains two cities and the length of the road between them queries (List[Tuple[int, int]]): List of tuples where each tuple contains two cities for which the distance is queried Returns: List[int]: List of distances for each query Examples: >>> preprocess_and_solve_queries(5, [(1, 2, 5), (2, 3, 3), (2, 4, 6), (4, 5, 2)], [(1, 3), (4, 5), (2, 5)]) [8, 2, 8] >>> preprocess_and_solve_queries(3, [(1, 2, 4), (2, 3, 1)], [(1, 3), (2, 3)]) [5, 1] >>> preprocess_and_solve_queries(2, [(1, 2, 7)], [(1, 2), (2, 1)]) [7, 7] >>> preprocess_and_solve_queries(6, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7)], [(1, 6), (2, 5), (3, 4)]) [25, 15, 5]","solution":"def preprocess_and_solve_queries(N, roads, queries): from collections import defaultdict, deque # Create an adjacency list to represent the graph graph = defaultdict(list) for a, b, l in roads: graph[a].append((b, l)) graph[b].append((a, l)) # Preprocess using BFS to find distances from any node (we choose node 1) distance = [-1] * (N + 1) def bfs(start): queue = deque([(start, 0)]) # (current_node, current_distance) distance[start] = 0 while queue: current, dist = queue.popleft() for neighbor, length in graph[current]: if distance[neighbor] == -1: # Not visited distance[neighbor] = dist + length queue.append((neighbor, distance[neighbor])) # Run BFS from node 1 bfs(1) # Function to find the distance between two nodes u and v def distance_between(u, v): return abs(distance[u] - distance[v]) # Answer each query results = [] for u, v in queries: results.append(distance_between(u, v)) return results"},{"question":"def maximal_rectangle(grid): Determine the area of the largest rectangular block that can be formed completely by store cells. Args: grid (List[str]): The mall's layout represented as a list of strings, where '.' represents an empty cell and '*' represents a store. Returns: int: The area of the largest rectangle that consists entirely of store cells. >>> maximal_rectangle([\\".....\\", \\".***.\\", \\".***.\\", \\".....\\"]) 6 >>> maximal_rectangle([\\"***\\", \\"*.*\\", \\"***\\"]) 3","solution":"def maximal_rectangle(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) heights = [0] * n max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == '*': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, largest_rectangle_area(heights)) return max_area def largest_rectangle_area(heights): stack = [] max_area = 0 for i in range(len(heights) + 1): while stack and (i == len(heights) or heights[stack[-1]] > heights[i]): h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def find_substring(s: str, p: str) -> int: Returns the starting index of the first occurrence of p in s. If p is not found in s, return -1. >>> find_substring(\\"hello\\", \\"ll\\") 2 >>> find_substring(\\"abcdef\\", \\"gh\\") -1","solution":"def find_substring(s, p): Returns the starting index of the first occurrence of p in s. If p is not found in s, return -1. return s.find(p)"},{"question":"def max_subset_sum(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: In a library system, books are categorized by their genres. Each book is represented by a unique numerical ID. The goal is to identify the largest subset of books where no two books belong to the same genre, and then sum their IDs to find the optimal subset sum. Given the genres of each book along with their IDs, determine the largest possible sum of book IDs that can be achieved under this condition. Parameters: T (int): the number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): list of test cases, each test case is a tuple where the first element is the number of books (int) and the second element is a list of tuples each containing a book ID (int) and a genre ID (int). Returns: List[int]: the maximum sum of book IDs such that no two books belong to the same genre for each test case. Example: >>> max_subset_sum(2, [(4, [(100, 1), (200, 2), (150, 1), (120, 3)]), (3, [(50, 2), (70, 2), (80, 3)])]) [470, 150] from typing import List, Tuple def test_max_subset_sum(): T = 2 test_cases = [ (4, [(100, 1), (200, 2), (150, 1), (120, 3)]), (3, [(50, 2), (70, 2), (80, 3)]) ] result = max_subset_sum(T, test_cases) assert result == [470, 150] def test_max_subset_sum_single_book(): T = 1 test_cases = [ (1, [(100, 1)]) ] result = max_subset_sum(T, test_cases) assert result == [100] def test_max_subset_sum_all_same_genre(): T = 1 test_cases = [ (3, [(100, 1), (150, 1), (200, 1)]) ] result = max_subset_sum(T, test_cases) assert result == [200] def test_max_subset_sum_different_genres(): T = 1 test_cases = [ (3, [(100, 1), (150, 2), (200, 3)]) ] result = max_subset_sum(T, test_cases) assert result == [450] def test_max_subset_sum_large_test_case(): T = 1 test_cases = [ (10000, [(i, i % 10) for i in range(1, 10001)]) ] result = max_subset_sum(T, test_cases) expected_sum = sum(range(9991, 10001)) assert result == [expected_sum]","solution":"def max_subset_sum(T, test_cases): results = [] for i in range(T): M = test_cases[i][0] books = test_cases[i][1] genre_to_max_id = {} for id, genre in books: if genre not in genre_to_max_id: genre_to_max_id[genre] = id else: genre_to_max_id[genre] = max(genre_to_max_id[genre], id) max_sum = sum(genre_to_max_id.values()) results.append(max_sum) return results # Example inputs for testing the function T = 2 test_cases = [ (4, [(100, 1), (200, 2), (150, 1), (120, 3)]), (3, [(50, 2), (70, 2), (80, 3)]) ] # Output should be [470, 150] print(max_subset_sum(T, test_cases))"},{"question":"from typing import List def affordable_snacks(snacks: List[str], prices: List[int], balance: int) -> List[str]: Returns the list of snacks that can be afforded with the given balance. Parameters: snacks (List[str]): A list of snack names. prices (List[int]): A list of prices corresponding to the snacks. balance (int): The amount of money available to spend. Returns: List[str]: A list of snacks that can be bought within the provided balance. Examples: >>> affordable_snacks([\\"chips\\", \\"chocolate\\", \\"cookies\\", \\"soda\\"], [50, 100, 70, 30], 75) ['chips', 'cookies', 'soda'] >>> affordable_snacks([\\"chips\\", \\"chocolate\\", \\"cookies\\", \\"soda\\"], [50, 100, 70, 30], 20) [] >>> affordable_snacks([\\"chips\\", \\"chocolate\\", \\"cookies\\", \\"soda\\"], [50, 100, 70, 30], 150) ['chips', 'chocolate', 'cookies', 'soda'] >>> affordable_snacks([\\"chips\\", \\"chocolate\\", \\"cookies\\", \\"soda\\"], [50, 100, 70, 30], 30) ['soda']","solution":"from typing import List def affordable_snacks(snacks: List[str], prices: List[int], balance: int) -> List[str]: Returns the list of snacks that can be afforded with the given balance. Parameters: snacks (List[str]): A list of snack names. prices (List[int]): A list of prices corresponding to the snacks. balance (int): The amount of money available to spend. Returns: List[str]: A list of snacks that can be bought within the provided balance. return [snack for snack, price in zip(snacks, prices) if price <= balance]"},{"question":"def count_visible_trees(n: int, heights: List[int]) -> int: Returns the number of visible trees in the row. Parameters: n : int - The number of trees heights : list - List of integers representing the heights of the trees Returns: int - The number of visible trees >>> count_visible_trees(5, [2, 5, 3, 4, 1]) 3 >>> count_visible_trees(4, [1, 2, 3, 4]) 1","solution":"def count_visible_trees(n, heights): Returns the number of visible trees in the row. Parameters: n : int - The number of trees heights : list - List of integers representing the heights of the trees Returns: int - The number of visible trees if n == 0: return 0 max_height = -1 visible_count = 0 for i in range(n-1, -1, -1): if heights[i] > max_height: visible_count += 1 max_height = heights[i] return visible_count"},{"question":"def merge_and_sort_plant_counts(T, test_cases): Merges and sorts arrays of plant counts for each test case. Parameters: T (int): The number of test cases test_cases (list): List containing test case details. Each test case is a tuple of: (n, m, current_plants, new_plants) - n (int): Size of the current plants array - m (int): Size of the new plants array - current_plants (list): Sorted list of integers representing current plant counts - new_plants (list): Sorted list of integers representing new plant counts Returns: list: A list of lists, where each list contains the merged and sorted plant counts for a test case. pass # Test cases import pytest def test_single_case(): T = 1 test_cases = [ (3, 3, [1, 3, 5], [2, 4, 6]) ] expected = [ [1, 2, 3, 4, 5, 6] ] assert merge_and_sort_plant_counts(T, test_cases) == expected def test_multiple_cases(): T = 2 test_cases = [ (3, 3, [1, 3, 5], [2, 4, 6]), (4, 4, [1, 2, 5, 7], [3, 4, 6, 8]) ] expected = [ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7, 8] ] assert merge_and_sort_plant_counts(T, test_cases) == expected def test_single_element_arrays(): T = 1 test_cases = [ (1, 1, [2], [1]) ] expected = [ [1, 2] ] assert merge_and_sort_plant_counts(T, test_cases) == expected def test_empty_second_array(): T = 1 test_cases = [ (3, 0, [1, 3, 5], []) ] expected = [ [1, 3, 5] ] assert merge_and_sort_plant_counts(T, test_cases) == expected def test_repeated_elements(): T = 1 test_cases = [ (3, 3, [1, 1, 3], [1, 2, 2]) ] expected = [ [1, 1, 1, 2, 2, 3] ] assert merge_and_sort_plant_counts(T, test_cases) == expected pytest.main([__file__])","solution":"def merge_and_sort_plant_counts(T, test_cases): Merges and sorts arrays of plant counts for each test case. Parameters: T (int): The number of test cases test_cases (list): List containing test case details. Each test case is a tuple of: (n, m, current_plants, new_plants) - n (int): Size of the current plants array - m (int): Size of the new plants array - current_plants (list): Sorted list of integers representing current plant counts - new_plants (list): Sorted list of integers representing new plant counts Returns: list: A list of lists, where each list contains the merged and sorted plant counts for a test case. result = [] for n, m, current_plants, new_plants in test_cases: merged = [] i, j = 0, 0 # Merging two sorted arrays using two-pointer technique while i < n and j < m: if current_plants[i] <= new_plants[j]: merged.append(current_plants[i]) i += 1 else: merged.append(new_plants[j]) j += 1 # If there are remaining elements in current_plants while i < n: merged.append(current_plants[i]) i += 1 # If there are remaining elements in new_plants while j < m: merged.append(new_plants[j]) j += 1 result.append(merged) return result"},{"question":"import math def gcd_power_factorials(a: int, b: int) -> int: Given two non-negative integers a and b, compute the GCD of a raised to the power of b! (factorial of b) and b raised to the power of a! (factorial of a). >>> gcd_power_factorials(1, 2) 1 >>> gcd_power_factorials(3, 3) 3 >>> gcd_power_factorials(4, 5) 1 >>> gcd_power_factorials(6, 8) 2 >>> gcd_power_factorials(0, 0) 0","solution":"import math def gcd_power_factorials(a, b): Computes the GCD of a^b! and b^a! for given non-negative integers a and b. if a == 0 and b == 0: return 0 gcd_value = math.gcd(a, b) return gcd_value"},{"question":"def find_bounding_rectangle(test_cases): Given a list of test cases where each test case consists of tree coordinates, finds the bounding rectangle (bottom-left and top-right corners) that encloses all the trees. Parameters: test_cases (list of tuples): Each tuple contains an integer N (number of trees) followed by N tuples of two integers (x, y) representing tree coordinates. Returns: list of strings: Each string represents the coordinates of the bottom-left and top-right corners of the bounding rectangle in the format \\"x1 y1 x2 y2\\". pass def process_input(input_string): Processes an input string and returns a list of test cases. Parameters: input_string (str): Input string describing the number of test cases and tree coordinates. Returns: list of tuples: Parsed test cases where each tuple contains an integer N followed by N tuples of tree coordinates (x, y). pass if __name__ == \\"__main__\\": input_data = 2 4 1 3 4 4 2 2 3 1 3 -1 -2 0 0 1 1 test_cases = process_input(input_data.strip()) results = find_bounding_rectangle(test_cases) for result in results: print(result)","solution":"def find_bounding_rectangle(test_cases): Given a list of test cases where each test case consists of tree coordinates, finds the bounding rectangle (bottom-left and top-right corners) that encloses all the trees. Parameters: test_cases (list of tuples): Each tuple contains an integer N (number of trees) followed by N tuples of two integers (x, y) representing tree coordinates. Returns: list of strings: Each string represents the coordinates of the bottom-left and top-right corners of the bounding rectangle in the format \\"x1 y1 x2 y2\\". results = [] for trees in test_cases: N = trees[0] coordinates = trees[1:] x_coords = [coord[0] for coord in coordinates] y_coords = [coord[1] for coord in coordinates] x1, y1 = min(x_coords), min(y_coords) x2, y2 = max(x_coords), max(y_coords) results.append(f\\"{x1} {y1} {x2} {y2}\\") return results def process_input(input_string): Processes an input string and returns a list of test cases. Parameters: input_string (str): Input string describing the number of test cases and tree coordinates. Returns: list of tuples: Parsed test cases where each tuple contains an integer N followed by N tuples of tree coordinates (x, y). input_lines = input_string.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) trees = [(int(input_lines[index + j + 1].split()[0]), int(input_lines[index + j + 1].split()[1])) for j in range(N)] test_cases.append((N, *trees)) index += N + 1 return test_cases"},{"question":"def min_path_cost(grid: List[List[int]]) -> int: Given an NxN grid, this function calculates the minimum cost for a path from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1) where each move is either to the right or down. >>> min_path_cost([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 >>> min_path_cost([ ... [1, 1], ... [2, 1] ... ]) 3 def solve_min_path_cost(test_cases: List[List[List[int]]]) -> List[int]: Given multiple test cases of NxN grids, this function calculates the minimum cost for a path from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1) where each move is either to the right or down, for each test case. >>> solve_min_path_cost([ ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], ... [ ... [1, 1], ... [2, 1] ... ] ... ]) [21, 3]","solution":"def min_path_cost(grid): Given an NxN grid, this function calculates the minimum cost for a path from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1) where each move is either to the right or down. N = len(grid) dp = [[float('inf')] * N for _ in range(N)] dp[0][0] = grid[0][0] for i in range(N): for j in range(N): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[-1][-1] def solve_min_path_cost(test_cases): results = [] for grid in test_cases: results.append(min_path_cost(grid)) return results"},{"question":"from typing import List def unique_combinations(arr: List[int], comb_length: int) -> List[List[int]]: Generate all unique combinations of a specified length from the given array. Args: arr : List[int] -- list of integers comb_length : int -- desired length of combinations Returns: List[List[int]] -- list of lists with each sublist being a unique combination of the specified length Examples: >>> unique_combinations([1, 2, 3, 4], 2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> unique_combinations([5, 3, 9, 5, 7], 3) [[5, 3, 9], [5, 3, 5], [5, 3, 7], [5, 9, 5], [5, 9, 7], [5, 5, 7], [3, 9, 5], [3, 9, 7], [3, 5, 7], [9, 5, 7]] >>> unique_combinations([1, 2, 3], 0) [[]] >>> unique_combinations([], 2) [] >>> unique_combinations([1, 2, 3], 4) [] >>> unique_combinations([1, 2, 3, 4], 4) [[1, 2, 3, 4]] >>> unique_combinations([1, 2, 2, 3], 2) [[1, 2], [1, 2], [1, 3], [2, 2], [2, 3], [2, 3]]","solution":"from itertools import combinations def unique_combinations(arr, comb_length): Generate all unique combinations of a specified length from the given array. Arguments: arr -- list of integers comb_length -- desired length of combinations Returns: list of lists with each sublist being a unique combination of the specified length if comb_length == 0: return [[]] return [list(comb) for comb in combinations(arr, comb_length)]"},{"question":"def game_sequence(age: int) -> str: Returns the sequence of games based on the child's age. Parameters: age (int): The child's age. Returns: str: A string representing the sequence of games. >>> game_sequence(3) 'Game A then Game B then Game A' >>> game_sequence(4) 'Game B then Game A then Game B then Game A' >>> game_sequence(1) 'Game A'","solution":"def game_sequence(age): Returns the sequence of games based on the child's age. Parameters: age (int): The child's age. Returns: str: A string representing the sequence of games. games = [] for i in range(age): if (i + (age % 2)) % 2 == 0: games.append(\\"Game B\\") else: games.append(\\"Game A\\") return \\" then \\".join(games)"},{"question":"def find_max_path_value(trees): Find the maximum value of any path in the given trees. Args: trees (List[Tuple[int, List[int], List[Tuple[int, int]]]]): A list of test cases, where each test case contains the number of nodes, list of values of the nodes, and list of edges in the tree. Returns: List[int]: A list of integers, where each integer is the maximum value of any path in the corresponding tree. def process_input(input_data): Process the input data into a suitable format. Args: input_data (str): A string representing the input data. Returns: List[Tuple[int, List[int], List[Tuple[int, int]]]]: A list of test cases, where each test case contains the number of nodes, list of values of the nodes, and list of edges in the tree. # Test cases def test_find_max_path_value(): input_data = \\"2n3n1 2 3n1 2n1 3n4n4 4 4 4n1 2n2 3n3 4n\\" trees = process_input(input_data.strip()) output = find_max_path_value(trees) expected_output = [6, 16] assert output == expected_output def test_tree_with_two_nodes(): input_data = \\"1n2n10 20n1 2n\\" trees = process_input(input_data.strip()) output = find_max_path_value(trees) expected_output = [30] assert output == expected_output def test_all_nodes_with_same_values(): input_data = \\"1n3n5 5 5n1 2n1 3n\\" trees = process_input(input_data.strip()) output = find_max_path_value(trees) expected_output = [15] assert output == expected_output def test_larger_trees(): input_data = \\"1n5n1 2 3 4 5n1 2n2 3n2 4n3 5n\\" trees = process_input(input_data.strip()) output = find_max_path_value(trees) expected_output = [14] assert output == expected_output def test_trees_with_different_structures(): input_data = \\"1n5n2 3 4 5 6n1 2n1 3n3 4n4 5n\\" trees = process_input(input_data.strip()) output = find_max_path_value(trees) expected_output = [20] assert output == expected_output","solution":"def find_max_path_value(trees): def get_tree_max_sum_dfs(node, parent): current_sum = node_values[node - 1] max_first, max_second = 0, 0 for neighbor in tree_graph[node]: if neighbor == parent: continue neighbor_sum = get_tree_max_sum_dfs(neighbor, node) if neighbor_sum > max_first: max_second = max_first max_first = neighbor_sum elif neighbor_sum > max_second: max_second = neighbor_sum max_path[0] = max(max_path[0], current_sum + max_first + max_second) return current_sum + max_first results = [] for nodes, values, edges in trees: node_values = values tree_graph = {i: [] for i in range(1, nodes + 1)} for u, v in edges: tree_graph[u].append(v) tree_graph[v].append(u) max_path = [0] get_tree_max_sum_dfs(1, -1) results.append(max_path[0]) return results def process_input(input_data): lines = input_data.split(\\"n\\") t = int(lines[0]) index = 1 trees = [] for _ in range(t): n = int(lines[index]) node_values = list(map(int, lines[index + 1].split())) edges = [] for j in range(n - 1): u, v = map(int, lines[index + 2 + j].split()) edges.append((u, v)) trees.append((n, node_values, edges)) index += n + 1 return trees input_data = 2 3 1 2 3 1 2 1 3 4 4 4 4 4 1 2 2 3 3 4 trees = process_input(input_data.strip()) output = find_max_path_value(trees) print(\\"n\\".join(map(str, output)))"},{"question":"class Grid: def __init__(self, N): self.N = N self.grid = [[0] * (N + 1) for _ in range(N + 1)] self.prefix_sum = [[0] * (N + 1) for _ in range(N + 1)] def set_value(self, i, j, v): Set the value at cell (i, j) to v. pass def get_value(self, i, j): Get the value at cell (i, j). >>> grid = Grid(5) >>> grid.set_value(1, 1, 5) >>> grid.get_value(1, 1) 5 pass def sum_subgrid(self, x1, y1, x2, y2): Calculate the sum of subgrid from (x1, y1) to (x2, y2). >>> grid = Grid(5) >>> grid.set_value(1, 1, 5) >>> grid.set_value(2, 2, 4) >>> grid.sum_subgrid(1, 1, 2, 2) 9 pass def process_operations(N, operations): Process a list of operations and return the results for get and sum operations. >>> N = 5 >>> operations = [ ... \\"1 1 1 5\\", ... \\"1 2 2 4\\", ... \\"2 1 1\\", ... \\"3 1 1 2 2\\", ... \\"1 3 3 7\\", ... \\"3 1 1 3 3\\", ... \\"2 3 3\\" ... ] >>> process_operations(N, operations) [5, 9, 16, 7] grid = Grid(N) results = [] for operation in operations: values = list(map(int, operation.split())) op_type = values[0] if op_type == 1: _, i, j, v = values grid.set_value(i, j, v) elif op_type == 2: _, i, j = values results.append(grid.get_value(i, j)) elif op_type == 3: _, x1, y1, x2, y2 = values results.append(grid.sum_subgrid(x1, y1, x2, y2)) return results","solution":"class Grid: def __init__(self, N): self.N = N self.grid = [[0] * (N + 1) for _ in range(N + 1)] self.prefix_sum = [[0] * (N + 1) for _ in range(N + 1)] def set_value(self, i, j, v): old_value = self.grid[i][j] self.grid[i][j] = v # Update the prefix sum by computing the difference caused by the new value delta = v - old_value for x in range(i, self.N + 1): for y in range(j, self.N + 1): self.prefix_sum[x][y] += delta def get_value(self, i, j): return self.grid[i][j] def sum_subgrid(self, x1, y1, x2, y2): return (self.prefix_sum[x2][y2] - self.prefix_sum[x1 - 1][y2] - self.prefix_sum[x2][y1 - 1] + self.prefix_sum[x1 - 1][y1 - 1]) def process_operations(N, operations): grid = Grid(N) results = [] for operation in operations: values = list(map(int, operation.split())) op_type = values[0] if op_type == 1: _, i, j, v = values grid.set_value(i, j, v) elif op_type == 2: _, i, j = values results.append(grid.get_value(i, j)) elif op_type == 3: _, x1, y1, x2, y2 = values results.append(grid.sum_subgrid(x1, y1, x2, y2)) return results"},{"question":"from typing import List, Tuple def project_order(n: int, m: int, k: int, projects: List[Tuple[str, int]], dependencies: List[Tuple[str, str]]) -> List[str]: Find a valid order of projects that respects all dependencies and maximizes the sum of importance scores of the first k projects in this order. If it's not feasible to complete all projects due to circular dependencies, return an empty list. Args: n (int): Number of projects m (int): Number of dependencies k (int): Number of top projects to return projects (List[Tuple[str, int]]): List of tuples containing project identifiers and importance scores dependencies (List[Tuple[str, str]]): List of tuples where each tuple contains two project identifiers u and v, denoting that project u must be completed before project v Returns: List[str]: A list of k project identifiers representing the order of the first k projects that maximizes the sum of importance scores. Example: >>> n = 5 >>> m = 4 >>> k = 3 >>> projects = [('proj1', 5), ('proj2', 10), ('proj3', 8), ('proj4', 6), ('proj5', 7)] >>> dependencies = [('proj1', 'proj2'), ('proj2', 'proj3'), ('proj4', 'proj2'), ('proj4', 'proj5')] >>> project_order(n, m, k, projects, dependencies) ['proj4', 'proj1', 'proj5'] >>> n = 3 >>> m = 2 >>> k = 2 >>> projects = [('A', 3), ('B', 4), ('C', 5)] >>> dependencies = [('A', 'B'), ('B', 'C')] >>> project_order(n, m, k, projects, dependencies) ['B', 'C'] >>> n = 3 >>> m = 3 >>> k = 2 >>> projects = [('A', 3), ('B', 4), ('C', 5)] >>> dependencies = [('A', 'B'), ('B', 'C'), ('C', 'A')] >>> project_order(n, m, k, projects, dependencies) []","solution":"from collections import defaultdict, deque def project_order(n, m, k, projects, dependencies): def topological_sort(vertices, adj_list): in_degree = {vertex: 0 for vertex in vertices} for vertex in vertices: for neighbor in adj_list[vertex]: in_degree[neighbor] += 1 queue = deque([vertex for vertex in vertices if in_degree[vertex] == 0]) top_order = [] while queue: current = queue.popleft() top_order.append(current) for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(top_order) == len(vertices): return top_order else: return [] projects_dict = {} for project_id, score in projects: projects_dict[project_id] = int(score) adj_list = defaultdict(list) for dep in dependencies: u, v = dep adj_list[u].append(v) vertices = [project_id for project_id, _ in projects] sorted_projects = topological_sort(vertices, adj_list) if not sorted_projects: return [] sorted_projects.sort(key=lambda x: projects_dict[x], reverse=True) return sorted_projects[:k] # Example usage: n = 5 m = 4 k = 3 projects = [('proj1', 5), ('proj2', 10), ('proj3', 8), ('proj4', 6), ('proj5', 7)] dependencies = [('proj1', 'proj2'), ('proj2', 'proj3'), ('proj4', 'proj2'), ('proj4', 'proj5')] print(project_order(n, m, k, projects, dependencies)) # Output should be something like ['proj4', 'proj5', 'proj3']"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions required to transform the given string into a palindrome. >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"a\\") 0 >>> min_insertions_to_palindrome(\\"madam\\") 0 >>> min_insertions_to_palindrome(\\"rad\\") 2 >>> min_insertions_to_palindrome(\\"aaaabbaa\\") 2 >>> min_insertions_to_palindrome(\\"abcba\\") 0 pass","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions required to transform the given string into a palindrome. def lcs(X, Y): m = len(X) n = len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] reverse_s = s[::-1] lcs_length = lcs(s, reverse_s) min_insertions = len(s) - lcs_length return min_insertions ''' Explanation of the approach: To find the minimum insertions to make a string palindrome, we can use the concept of the longest common subsequence (LCS). - Find the LCS of the given string and its reverse. - The difference between the length of the given string and the LCS length gives the minimum number of insertions required. The reason is, LCS gives the longest sequence that is common in both the original and reversed string. So, the characters not in that LCS need to be inserted to make the string a palindrome. '''"},{"question":"def uniqueRows(matrix): Returns all unique rows in the given matrix. >>> uniqueRows([[1, 0, 0], [0, 1, 1], [1, 0, 0]]) [[1, 0, 0], [0, 1, 1]] >>> uniqueRows([[1, 1, 0], [1, 0, 0], [1, 1, 0], [0, 0, 1]]) [[1, 1, 0], [1, 0, 0], [0, 0, 1]]","solution":"def uniqueRows(matrix): Returns all unique rows in the given matrix. unique_rows_set = set() unique_rows_list = [] for row in matrix: row_tuple = tuple(row) if row_tuple not in unique_rows_set: unique_rows_set.add(row_tuple) unique_rows_list.append(row) return unique_rows_list"},{"question":"def min_tallest_stack_height(N, W, widths, heights): Given the widths and heights of the packets, calculate the minimum possible height of the tallest stack if Chef arranges the packets optimally. >>> min_tallest_stack_height(3, 10, [2, 3, 5], [1, 4, 9]) 9 >>> min_tallest_stack_height(2, 5, [4, 3], [2, 1]) 2 >>> min_tallest_stack_height(2, 7, [4, 3], [2, 3]) 3 >>> min_tallest_stack_height(3, 6, [1, 2, 3], [1, 2, 3]) 3 def solve(test_cases): Given a list of test cases, return a list of results for each test case. Each test case consists of: - An integer N (number of packets) - An integer W (width of the shelf) - A list of widths (length N) - A list of heights (length N) >>> test_cases = [ (3, 10, [2, 3, 5], [1, 4, 9]), (2, 5, [4, 3], [2, 1]) ] >>> solve(test_cases) [9, 2]","solution":"def min_tallest_stack_height(N, W, widths, heights): # Zip widths and heights together packets = list(zip(widths, heights)) # Sort packets by width in descending order packets.sort(reverse=True, key=lambda x: x[0]) # Initial variables for cumulative width and maximum height cumulative_width = 0 max_height = 0 for width, height in packets: if cumulative_width + width <= W: cumulative_width += width max_height = max(max_height, height) else: break return max_height def solve(test_cases): results = [] for N, W, widths, heights in test_cases: result = min_tallest_stack_height(N, W, widths, heights) results.append(result) return results"},{"question":"from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a sorted 2D matrix. :param matrix: A 2D list of integers where each row and column are sorted in non-decreasing order :param k: An integer representing which smallest element to find :return: The k-th smallest element in the matrix >>> kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8) 13 >>> kth_smallest([[5]], 1) 5 pass def test_kth_smallest_example(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 assert kth_smallest(matrix, k) == 13 def test_kth_smallest_single_element(): matrix = [[5]] k = 1 assert kth_smallest(matrix, k) == 5 def test_kth_smallest_first_element(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 1 assert kth_smallest(matrix, k) == 1 def test_kth_smallest_large_matrix(): matrix = [ [-10, -5, 0, 5], [-8, -3, 2, 6], [-6, -1, 4, 7], [-4, 1, 5, 8] ] k = 10 assert kth_smallest(matrix, k) == 2 def test_kth_smallest_repeated_elements(): matrix = [ [1, 2, 2], [2, 3, 3], [3, 4, 4] ] k = 5 assert kth_smallest(matrix, k) == 3","solution":"from typing import List import heapq def kth_smallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a sorted 2D matrix. N = len(matrix) M = len(matrix[0]) # Use a min heap to keep track of the smallest elements # Start by adding the first element of each row to the heap min_heap = [(matrix[r][0], r, 0) for r in range(N)] heapq.heapify(min_heap) # Extract the smallest element from the heap 'k-1' times for _ in range(k - 1): val, r, c = heapq.heappop(min_heap) if c + 1 < M: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) # The k-th smallest element will now be on top of the heap return heapq.heappop(min_heap)[0]"},{"question":"def lexicographically_smallest_array(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given an array of integers, determine the lexicographically smallest array possible by reversing any subarray of length greater than 1. Args: t (int): the number of test cases. test_cases (List[Tuple[int, List[int]]]): a list of tuples where the first element is the length of the array and the second element is the array itself. Returns: List[str]: the lexicographically smallest arrays for each test case as strings. >>> lexicographically_smallest_array(3, [(5, [3, 1, 2, 4, 5]), (4, [9, 8, 7, 6]), (3, [1, 2, 3])]) [\\"1 2 3 4 5\\", \\"6 7 8 9\\", \\"1 2 3\\"] >>> lexicographically_smallest_array(1, [(1, [5])]) [\\"5\\"] pass def process_input(t: int, inputs: List[Union[int, List[int]]]) -> List[Tuple[int, List[int]]]: Helper function to process input. Args: t (int): the number of test cases. inputs (List[Union[int, List[int]]]): a list containing both the length of the array and the array itself. Returns: List[Tuple[int, List[int]]]: a list of tuples where each tuple is a test case. pass # Unit tests def test_example_cases(): t = 3 inputs = [5, [3, 1, 2, 4, 5], 4, [9, 8, 7, 6], 3, [1, 2, 3]] test_cases = process_input(t, inputs) result = lexicographically_smallest_array(t, test_cases) expected = [\\"1 2 3 4 5\\", \\"6 7 8 9\\", \\"1 2 3\\"] assert result == expected def test_single_element(): t = 1 inputs = [1, [5]] test_cases = process_input(t, inputs) result = lexicographically_smallest_array(t, test_cases) expected = [\\"5\\"] assert result == expected def test_sorted_array(): t = 1 inputs = [4, [1, 2, 3, 4]] test_cases = process_input(t, inputs) result = lexicographically_smallest_array(t, test_cases) expected = [\\"1 2 3 4\\"] assert result == expected def test_reverse_sorted_array(): t = 1 inputs = [4, [4, 3, 2, 1]] test_cases = process_input(t, inputs) result = lexicographically_smallest_array(t, test_cases) expected = [\\"1 2 3 4\\"] assert result == expected def test_duplicate_elements(): t = 1 inputs = [5, [3, 3, 2, 1, 2]] test_cases = process_input(t, inputs) result = lexicographically_smallest_array(t, test_cases) expected = [\\"1 2 2 3 3\\"] assert result == expected","solution":"def lexicographically_smallest_array(t, test_cases): results = [] for case in test_cases: n, array = case results.append(\\" \\".join(map(str, sorted(array)))) return results # Function to process each test case def process_input(t, inputs): test_cases = [] index = 0 for _ in range(t): n = inputs[index] index += 1 array = inputs[index] index += 1 test_cases.append((n, array)) return test_cases # Example input to demonstrate the function call if __name__ == \\"__main__\\": t = 3 input_data = [ (5, [3, 1, 2, 4, 5]), (4, [9, 8, 7, 6]), (3, [1, 2, 3]) ] result = lexicographically_smallest_array(t, input_data) for res in result: print(res)"},{"question":"def generate_sequence(n: int, k: int) -> list: Generates a sequence of numbers according to the given rules for k iterations starting from n. Parameters: n : int : Starting number k : int : Number of iterations Returns: list : Sequence of numbers after k iterations Examples: >>> generate_sequence(6, 3) [12, 24, 48] >>> generate_sequence(10, 4) [5, 2, 9, 18] >>> generate_sequence(4, 5) [11, 18, 36, 72, 144] >>> generate_sequence(3, 3) [6, 12, 24] >>> generate_sequence(5, 3) [2, 9, 18] >>> generate_sequence(15, 3) [15, 15, 15] >>> generate_sequence(7, 3) [14, 21, 42]","solution":"def generate_sequence(n, k): Generates a sequence of numbers according to the given rules for k iterations starting from n. Parameters: n : int : Starting number k : int : Number of iterations Returns: list : Sequence of numbers after k iterations sequence = [] current = n for _ in range(k): if current % 3 == 0 and current % 5 == 0: sequence.append(current) elif current % 3 == 0: current *= 2 sequence.append(current) elif current % 5 == 0: current //= 2 sequence.append(current) else: current += 7 sequence.append(current) return sequence"},{"question":"def process_operations(n: int, operations: List[str]) -> List[int]: Process a list of operations on a list of integers and return results for sum operations. Args: n (int): Number of operations. operations (List[str]): List of operations to perform on the list. Returns: List[int]: Results of sum operations. Examples: >>> process_operations(5, [\\"1 1 5\\", \\"1 2 3\\", \\"3 1 2\\", \\"2 1\\", \\"3 1 1\\"]) [8, 3] >>> process_operations(4, [\\"1 1 10\\", '1 2 20', '2 1', '3 1 1']) [20]","solution":"def process_operations(n, operations): lst = [] results = [] for op in operations: parts = op.split() if parts[0] == \\"1\\": # Insert integer at a specified position. pos = int(parts[1]) - 1 value = int(parts[2]) lst.insert(pos, value) elif parts[0] == \\"2\\": # Delete the integer at a specified position. pos = int(parts[1]) - 1 lst.pop(pos) elif parts[0] == \\"3\\": # Print the sum of all integers between two specified positions. start = int(parts[1]) - 1 end = int(parts[2]) results.append(sum(lst[start:end])) return results"},{"question":"def productExceptSelf(nums, N): Returns an array such that each element at index 'i' of the new array is the product of all the numbers in the original array except the one at 'i'. Args: nums: List[int]: An array of integers. N: int: The size of the array. Returns: List[int]: The modified array where each element is the product of all numbers in the original array except the one at index 'i'. Examples: >>> productExceptSelf([1, 2, 3, 4, 5], 5) [120, 60, 40, 30, 24] >>> productExceptSelf([3, 2, 1], 3) [2, 3, 6] def test_productExceptSelf(): assert productExceptSelf([1, 2, 3, 4, 5], 5) == [120, 60, 40, 30, 24] assert productExceptSelf([3, 2, 1], 3) == [2, 3, 6] assert productExceptSelf([1, 1, 1, 1], 4) == [1, 1, 1, 1] assert productExceptSelf([-1, 1, 0, -3, 3], 5) == [0, 0, 9, 0, 0] assert productExceptSelf([0, 0, 0, 0], 4) == [0, 0, 0, 0] assert productExceptSelf([2, 3], 2) == [3, 2] # Edge cases assert productExceptSelf([1], 1) == [1] assert productExceptSelf([], 0) == []","solution":"def productExceptSelf(nums, N): Returns an array such that each element at index 'i' of the new array is the product of all the numbers in the original array except the one at 'i'. if N == 0: return [] result = [1] * N # Left product calculation left_product = 1 for i in range(N): result[i] = left_product left_product *= nums[i] # Right product calculation right_product = 1 for i in range(N - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"from functools import reduce def multiply_non_zero_digits(n): Multiply the non-zero digits of n. >>> multiply_non_zero_digits(39) 27 >>> multiply_non_zero_digits(123) 6 pass def single_digit_result(N): Given an integer N, finds the resulting single-digit integer by repeatedly multiplying all of its non-zero digits until a single-digit integer is obtained. >>> single_digit_result(39) 4 >>> single_digit_result(123) 6 >>> single_digit_result(99) 8 >>> single_digit_result(100) 1 >>> single_digit_result(987654321) 8 >>> single_digit_result(1) 1 >>> single_digit_result(10) 1 >>> single_digit_result(1010101010) 1 >>> single_digit_result(1000000000) 1 >>> single_digit_result(1111111111) 1 pass","solution":"from functools import reduce def multiply_non_zero_digits(n): result = 1 for digit in str(n): if digit != '0': result *= int(digit) return result def single_digit_result(N): while N >= 10: N = multiply_non_zero_digits(N) return N"},{"question":"def rearrange_array(arr: List[int]) -> List[int]: Rearrange the array such that the sum of absolute differences of adjacent elements is minimized. :param arr: List of distinct integers :return: List of integers rearranged to minimize the sum of absolute differences >>> rearrange_array([3, 1, 4, 9, 2]) [1, 2, 3, 4, 9] >>> rearrange_array([8, 5, 2, 10]) [2, 5, 8, 10]","solution":"def rearrange_array(arr): Rearrange the array such that the sum of absolute differences of adjacent elements is minimized. :param arr: List of distinct integers :return: List of integers rearranged to minimize the sum of absolute differences return sorted(arr)"},{"question":"from typing import List, Tuple def process_input(input_str: str) -> List[str]: Determines if given points form a convex polygon for multiple test cases. Args: input_str (str): Input string containing number of test cases, followed by each test case containing number of points and their coordinates. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case indicating if the points form a convex polygon. Example: >>> process_input(\\"2n4n0 0n0 1n1 1n1 0n5n0 0n1 1n2 0n3 1n4 0\\") ['YES', 'NO'] >>> process_input(\\"1n4n0 0n0 2n2 2n2 0\\") ['YES'] >>> process_input(\\"1n5n0 0n1 2n2 0n3 2n4 0\\") ['NO']","solution":"def is_convex_polygon(points): def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) n = len(points) if n < 3: return False direction = 0 for i in range(n): a, b, c = points[i], points[(i + 1) % n], points[(i + 2) % n] cross_prod = cross_product(a, b, c) if cross_prod != 0: if direction == 0: direction = cross_prod elif direction * cross_prod < 0: return False return True def check_convex_polygon(test_cases): result = [] for case in test_cases: points = case[1] if is_convex_polygon(points): result.append(\\"YES\\") else: result.append(\\"NO\\") return result def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) points = [] for i in range(index + 1, index + 1 + N): x, y = map(int, lines[i].strip().split()) points.append((x, y)) test_cases.append((N, points)) index += N + 1 return check_convex_polygon(test_cases) # Example usage: input_str = 2 4 0 0 0 1 1 1 1 0 5 0 0 1 1 2 0 3 1 4 0 print(process_input(input_str)) # Output should be [\\"YES\\", \\"NO\\"]"},{"question":"def count_distinct_substrings(s: str) -> int: Count the number of distinct substrings of a given string. >>> count_distinct_substrings(\\"abcde\\") 15 >>> count_distinct_substrings(\\"aaa\\") 3 pass def max_distinct_substrings_after_swap(n: int, s: str) -> int: Determine the maximum number of distinct substrings possible after at most one swap in the string. >>> max_distinct_substrings_after_swap(5, \\"abcde\\") 15 >>> max_distinct_substrings_after_swap(3, \\"aaa\\") 3 >>> max_distinct_substrings_after_swap(4, \\"aaba\\") 8 pass","solution":"def count_distinct_substrings(s): substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return len(substrings) def max_distinct_substrings_after_swap(n, s): # Calculate distinct substrings in original string original_count = count_distinct_substrings(s) max_count = original_count for i in range(n): for j in range(i + 1, n): # Swap characters at index i and j swapped_s = list(s) swapped_s[i], swapped_s[j] = swapped_s[j], swapped_s[i] swapped_s = ''.join(swapped_s) # Calculate distinct substrings in swapped string current_count = count_distinct_substrings(swapped_s) max_count = max(max_count, current_count) return max_count"},{"question":"def friend_circle_counter(test_cases: List[Tuple[int, List[str]]]) -> List[int]: Determine the number of friend circles in the network for each test case. Args: test_cases: A list of tuples, where each tuple contains an integer and a list of strings. The integer represents the number of people in the network, and the list of strings represents the adjacency matrix of the graph. Returns: A list of integers where each integer represents the number of friend circles for the corresponding test case. Example: >>> test_cases = [ ... (3, [\\"110\\", \\"110\\", \\"001\\"]), ... (4, [\\"1100\\", \\"1110\\", \\"0110\\", \\"0001\\"]) ... ] >>> friend_circle_counter(test_cases) [2, 2] from typing import List, Tuple def test_single_person(): test_cases = [(1, [\\"1\\"])] assert friend_circle_counter(test_cases) == [1] def test_all_friends(): test_cases = [ (3, [\\"111\\", \\"111\\", \\"111\\"]), # everyone is friends with everyone else (4, [\\"1111\\", \\"1111\\", \\"1111\\", \\"1111\\"]) ] assert friend_circle_counter(test_cases) == [1, 1] def test_disconnected_people(): test_cases = [ (3, [\\"100\\", \\"010\\", \\"001\\"]), # No one is friends with anyone else (4, [\\"1000\\", \\"0100\\", \\"0010\\", \\"0001\\"]) ] assert friend_circle_counter(test_cases) == [3, 4] def test_mixed_relationships(): test_cases = [ (3, [\\"110\\", \\"110\\", \\"001\\"]), # two friend groups: {0,1} and {2} (4, [\\"1100\\", \\"1110\\", \\"0110\\", \\"0001\\"]), # two friend groups: {0,1,2} and {3} ] assert friend_circle_counter(test_cases) == [2, 2] def test_multiple_test_cases(): test_cases = [ (3, [\\"110\\", \\"110\\", \\"001\\"]), # two friend groups: {0,1} and {2} (4, [\\"1111\\", \\"1111\\", \\"1111\\", \\"1111\\"]) # one big friend group: {0,1,2,3} ] assert friend_circle_counter(test_cases) == [2, 1]","solution":"def find_friend_circles(n, matrix): def dfs(node, visited): for neighbor, is_friend in enumerate(matrix[node]): if is_friend == '1' and neighbor not in visited: visited.add(neighbor) dfs(neighbor, visited) visited = set() friend_circles = 0 for person in range(n): if person not in visited: dfs(person, visited) friend_circles += 1 return friend_circles def friend_circle_counter(test_cases): results = [] for n, matrix in test_cases: results.append(find_friend_circles(n, matrix)) return results"},{"question":"def partition_to_prime_subsets(n: int, k: int, array: List[int]) -> None: Determine if you can partition the array into exactly k non-empty subsets such that the sum of the elements in each subset is a prime number. Print \\"YES\\" if possible, otherwise \\"NO\\". >>> partition_to_prime_subsets(5, 2, [3, 8, 12, 5, 13]) YES >>> partition_to_prime_subsets(4, 3, [4, 5, 6, 7]) NO","solution":"from itertools import combinations import math def is_prime(x): Returns True if x is a prime number, otherwise False. if x <= 1: return False for i in range(2, int(math.sqrt(x)) + 1): if x % i == 0: return False return True def can_partition_prime_sum(n, k, array): Determine if the array can be partitioned into exactly k non-empty subsets such that the sum of the elements in each subset is a prime number. def can_partition(start_index, k_remaining, used, current_sum): if k_remaining == 0: return True if current_sum > 0 and is_prime(current_sum): return can_partition(0, k_remaining - 1, used, 0) for i in range(start_index, n): if not used[i]: used[i] = True if can_partition(i + 1, k_remaining, used, current_sum + array[i]): return True used[i] = False return False used = [False] * n return can_partition(0, k, used, 0) # Application of the function def partition_to_prime_subsets(n, k, array): if can_partition_prime_sum(n, k, array): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"from typing import List, Tuple def can_visit_all_landmarks(n: int, m: int, portals: List[Tuple[int, int]], k: int, sequence: List[int]) -> str: Determine whether it is possible to visit all the landmarks in the given sequence using the portals. >>> can_visit_all_landmarks(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_visit_all_landmarks(5, 3, [(1, 2), (2, 3), (3, 4)], 5, [1, 2, 3, 5, 4]) \\"NO\\" >>> can_visit_all_landmarks(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (3, 6)], 4, [1, 3, 6, 5]) \\"YES\\"","solution":"def can_visit_all_landmarks(n, m, portals, k, sequence): from collections import defaultdict, deque # Create an adjacency list for the graph adj_list = defaultdict(list) for u, v in portals: adj_list[u].append(v) adj_list[v].append(u) # Function to perform BFS/DFS to find if there's a path between two nodes def bfs(start, end): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbour in adj_list[node]: if neighbour not in visited: queue.append(neighbour) return False # Check the sequence pairwise for i in range(k - 1): if not bfs(sequence[i], sequence[i + 1]): return \\"NO\\" return \\"YES\\""},{"question":"def is_magic_square(grid): Check if the provided N x N grid of numbers is a magic square. Args: grid: List[List[int]] - A 2D list representing the grid of numbers. Returns: bool: True if the grid is a magic square, otherwise False. >>> is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) True >>> is_magic_square([[1, 2], [3, 4]]) False pass def process_input(input_data): Process multiple datasets to determine if each grid forms a magic square. Args: input_data: str - A string containing the input data with multiple datasets. Returns: List[bool]: A list of boolean values where each value corresponds to whether the respective grid is a magic square or not. >>> process_input(\\"3n2 7 6n9 5 1n4 3 8n4n16 2 3 13n5 11 10 8n9 7 6 12n4 14 15 1n2n1 2n3 4n0\\") [True, True, False] >>> process_input(\\"1n1n0\\") [True] pass from solution import process_input def test_magic_square(): input_data = \\"3n2 7 6n9 5 1n4 3 8n4n16 2 3 13n5 11 10 8n9 7 6 12n4 14 15 1n2n1 2n3 4n0\\" expected_output = [True, True, False] assert process_input(input_data) == expected_output def test_single_element_magic_square(): input_data = \\"1n1n0\\" expected_output = [True] assert process_input(input_data) == expected_output def test_non_magic_square(): input_data = \\"2n1 2n3 4n0\\" expected_output = [False] assert process_input(input_data) == expected_output def test_all_zeros(): input_data = \\"3n0 0 0n0 0 0n0 0 0n0\\" expected_output = [True] assert process_input(input_data) == expected_output def test_mixed_input(): input_data = \\"2n8 1n6 3n3n23 33 7n9 5 1n4 2 12n0\\" expected_output = [False, False] assert process_input(input_data) == expected_output","solution":"def is_magic_square(grid): N = len(grid) if N == 0: return False magic_sum = sum(grid[0]) # Check sums of rows for row in grid: if sum(row) != magic_sum: return False # Check sums of columns for col in range(N): if sum(grid[row][col] for row in range(N)) != magic_sum: return False # Check sums of diagonals if sum(grid[i][i] for i in range(N)) != magic_sum: return False if sum(grid[i][N - 1 - i] for i in range(N)) != magic_sum: return False return True def process_input(input_data): datasets = input_data.strip().split('n') result = [] i = 0 while i < len(datasets): N = int(datasets[i]) if N == 0: break grid = [] for j in range(i + 1, i + 1 + N): grid.append(list(map(int, datasets[j].split()))) result.append(is_magic_square(grid)) i += N + 1 return result"},{"question":"import heapq from typing import List, Tuple def dijkstra(N: int, graph: List[List[Tuple[int, int]]], start: int, end: int) -> int: Implementation of Dijkstra's algorithm to find the shortest path distance from start to end in the given graph. distances = [float('inf')] * (N + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 def upgraded_min_travel_time( N: int, M: int, K: int, streets: List[Tuple[int, int, int]], upgrades: List[Tuple[int, int, int]], A: int, B: int ) -> int: Finds the minimum possible travel time from junction A to junction B if one of the streets is upgraded. >>> upgraded_min_travel_time(5, 5, 1, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (1, 5, 50)], [(1, 5, 5)], 1, 5) 5 >>> upgraded_min_travel_time(4, 4, 1, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10)], [(3, 4, 1)], 1, 4) 3","solution":"import heapq def dijkstra(N, graph, start, end): Implementation of Dijkstra's algorithm to find the shortest path distance from start to end in the given graph. distances = [float('inf')] * (N + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 def upgraded_min_travel_time(N, M, K, streets, upgrades, A, B): Finds the minimum possible travel time from junction A to junction B if one of the streets is upgraded. graph = [[] for _ in range(N + 1)] for u, v, t in streets: graph[u].append((v, t)) graph[v].append((u, t)) original_time = dijkstra(N, graph, A, B) min_time = original_time for x, y, r in upgrades: for i, (v, t) in enumerate(graph[x]): if v == y: original_weight = graph[x][i][1] graph[x][i] = (v, r) break for i, (u, t) in enumerate(graph[y]): if u == x: original_weight = graph[y][i][1] graph[y][i] = (u, r) break upgraded_time = dijkstra(N, graph, A, B) min_time = min(min_time, upgraded_time) for i, (v, t) in enumerate(graph[x]): if v == y: graph[x][i] = (v, original_weight) break for i, (u, t) in enumerate(graph[y]): if u == x: graph[y][i] = (u, original_weight) break return min_time"},{"question":"from typing import List def find_smallest_unrepresentable_sum(n: int, numbers: List[int]) -> int: Finds the smallest positive integer that cannot be represented as the sum of any subset of the given set. Parameters: n (int): Number of integers in the set. numbers (list of int): The set of integers. Returns: int: The smallest positive integer that cannot be represented as the sum of any subset of the given set. >>> find_smallest_unrepresentable_sum(5, [1, 2, 3, 10, 20]) 7 >>> find_smallest_unrepresentable_sum(3, [5, 7, 1]) 2 >>> find_smallest_unrepresentable_sum(4, [1, 1, 1, 1]) 5 >>> find_smallest_unrepresentable_sum(4, [1, 2, 5, 11]) 4 >>> find_smallest_unrepresentable_sum(2, [2, 2]) 1 pass def process_input(input_data: str) -> List[int]: Processes the input data and returns the results for each test case. Parameters: input_data (str): The input data as a multiline string. Returns: list of int: The results for each test case. >>> process_input(\\"5 1 2 3 10 20n3 5 7 1n0\\") [7, 2] >>> process_input(\\"4 1 1 1 1n0\\") [5] >>> process_input(\\"2 2 2n0\\") [1] pass","solution":"def find_smallest_unrepresentable_sum(n, numbers): Finds the smallest positive integer that cannot be represented as the sum of any subset of the given set. Parameters: n (int): Number of integers in the set. numbers (list of int): The set of integers. Returns: int: The smallest positive integer that cannot be represented as the sum of any subset of the given set. numbers.sort() smallest_sum = 1 for num in numbers: if num > smallest_sum: break smallest_sum += num return smallest_sum def process_input(input_data): Processes the input data and returns the results for each test case. Parameters: input_data (str): The input data as a multiline string. Returns: list of int: The results for each test case. lines = input_data.strip().split(\\"n\\") results = [] for line in lines: if line == \\"0\\": break data = list(map(int, line.split())) n = data[0] numbers = data[1:] result = find_smallest_unrepresentable_sum(n, numbers) results.append(result) return results"},{"question":"def can_reach(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determine if there is a possibility to travel from one specific intersection to another, possibly through multiple streets. Parameters: n (int): Number of intersections. edges (List[Tuple[int, int]]): List of one-way streets as tuples (u, v) where there is a street from intersection u to intersection v. queries (List[Tuple[int, int]]): List of queries (a, b) to check if intersection a can reach intersection b. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each query indicating whether intersection a can reach intersection b. >>> can_reach(4, [(1, 2), (2, 3), (3, 4), (4, 2)], [(1, 4), (4, 1), (2, 4)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_reach(3, [(1, 2), (2, 3), (3, 1)], [(1, 3), (3, 1), (2, 1)]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_reach(3, [(1, 2)], [(1, 3), (2, 3), (3, 1)]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> can_reach(4, [(1, 2), (2, 3), (3, 4)], [(1, 1), (2, 2), (3, 3), (4, 4)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> can_reach(2, [(1, 2)], [(1, 2), (2, 1)]) [\\"YES\\", \\"NO\\"] >>> can_reach(3, [], [(1, 2), (2, 3), (1, 3)]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> can_reach(4, [(1, 2), (2, 3), (1, 3), (3, 4)], [(1, 4), (2, 4), (1, 3), (3, 1)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"from collections import defaultdict, deque def can_reach(n, edges, queries): def bfs(start, goal): visited = [False] * (n + 1) visited[start] = True queue = deque([start]) while queue: node = queue.popleft() if node == goal: return True for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return False # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Check each query results = [] for a, b in queries: if bfs(a, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def two_sum(nums, target): Write a function that takes a list of integers and a target integer as inputs, and returns the indices of the two numbers that add up to the target. The function should return a tuple of the indices. If no two numbers add up to the target, return an empty tuple. Args: nums : List[int] : List of integers target : int : Target integer Returns: Tuple[int, int] : Indices of the two numbers that add up to the target or an empty tuple if no two numbers add up to the target. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([1, 2, 3, 4, 5], 10) ()","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. Args: nums : List[int] : List of integers target : int : Target integer Returns: Tuple[int, int] : Indices of the two numbers that add up to the target or an empty tuple if no two numbers add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"def max_subarray_sum(nums): Finds the maximum possible sum of any non-empty subarray. Args: nums (list of int): List of integers which represent the array. Returns: int: The maximum sum of any non-empty subarray. Examples: >>> max_subarray_sum([1, 2, -3, 4, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([3]) 3 >>> max_subarray_sum([2, 3, -2, 3, 1]) 7 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6","solution":"def max_subarray_sum(nums): Finds the maximum possible sum of any non-empty subarray. Args: nums (list of int): List of integers which represent the array. Returns: int: The maximum sum of any non-empty subarray. if not nums: return 0 # Initialize variables max_so_far = nums[0] max_ending_here = nums[0] # Traverse through the array for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def precalculate_prefix_sums(array): Precalculates prefix sums for the given array. Returns a list of prefix sums. # Your code here def query_sum(prefix_sums, l, r): Returns the sum of the subarray from index l to r using prefix sums. # Your code here def process_queries(test_cases): Processes all the test cases and returns the results of the queries. # Your code here # Test cases def test_precalculate_prefix_sums(): assert precalculate_prefix_sums([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10, 15] assert precalculate_prefix_sums([10, -10, 10, -10, 10]) == [0, 10, 0, 10, 0, 10] def test_query_sum(): prefix_sums = [0, 1, 3, 6, 10, 15] assert query_sum(prefix_sums, 1, 3) == 6 assert query_sum(prefix_sums, 2, 5) == 14 assert query_sum(prefix_sums, 1, 5) == 15 def test_process_queries(): test_cases = [ (5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]), (6, 2, [10, -10, 10, -10, 10, -10], [(1, 6), (2, 4)]) ] assert process_queries(test_cases) == [6, 14, 15, 0, -10] test_precalculate_prefix_sums() test_query_sum() test_process_queries()","solution":"def precalculate_prefix_sums(array): Precalculates prefix sums for the given array. Returns a list of prefix sums. prefix_sums = [0] * (len(array) + 1) # Initializing prefix sum array for i in range(1, len(array) + 1): prefix_sums[i] = prefix_sums[i-1] + array[i-1] return prefix_sums def query_sum(prefix_sums, l, r): Returns the sum of the subarray from index l to r using prefix sums. return prefix_sums[r] - prefix_sums[l-1] def process_queries(test_cases): results = [] for n, q, array, queries in test_cases: prefix_sums = precalculate_prefix_sums(array) for l, r in queries: results.append(query_sum(prefix_sums, l, r)) return results"},{"question":"def min_operations_to_sort_books(n: int, books: List[int]) -> int: Determine the minimum number of operations required to arrange the books in ascending order. n: int - number of books books: List[int] - current ordering of books Returns: int - minimum number of operations >>> min_operations_to_sort_books(5, [3, 1, 4, 2, 5]) 2 >>> min_operations_to_sort_books(4, [4, 3, 2, 1]) 3 >>> min_operations_to_sort_books(3, [1, 2, 3]) 0 >>> min_operations_to_sort_books(1, [1]) 0 >>> min_operations_to_sort_books(6, [6, 5, 3, 4, 2, 1]) 4","solution":"def min_operations_to_sort_books(n, books): Returns the minimum number of operations required to sort the books in ascending order. n: int - number of books books: List[int] - current ordering of books def lis_length(sequence): from bisect import bisect_left lis = [] for x in sequence: pos = bisect_left(lis, x) if pos == len(lis): lis.append(x) else: lis[pos] = x return len(lis) lis_len = lis_length(books) return n - lis_len"},{"question":"def can_construct_rectangle(T: int, test_cases: List[int]) -> List[str]: Determine if it is possible to construct a rectangle with an area of M using sticks of length L and width W (both are integers). Args: T (int): the number of test cases. test_cases (List[int]): a list of integers, each representing M. Returns: List[str]: a list containing \\"YES\\" or \\"NO\\" for each test case. >>> can_construct_rectangle(4, [1, 6, 9, 12]) ['YES', 'YES', 'YES', 'YES'] >>> can_construct_rectangle(1, [7]) ['YES'] results = [] for M in test_cases: found = False for i in range(1, int(M**0.5) + 1): if M % i == 0: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results def process_input_output(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [int(data[i]) for i in range(1, T+1)] results = can_construct_rectangle(T, test_cases) for result in results: print(result) # Test cases to validate the solution def test_exact_square(): assert can_construct_rectangle(1, [9]) == [\\"YES\\"] def test_prime_number(): assert can_construct_rectangle(1, [7]) == [\\"YES\\"] def test_composite_number(): assert can_construct_rectangle(1, [6]) == [\\"YES\\"] def test_large_prime(): assert can_construct_rectangle(1, [100003]) == [\\"YES\\"] def test_multiple_cases(): assert can_construct_rectangle(4, [1, 6, 9, 12]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] def test_not_divisible(): assert can_construct_rectangle(1, [7]) == [\\"YES\\"] if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def can_construct_rectangle(T, test_cases): results = [] for M in test_cases: found = False for i in range(1, int(M**0.5) + 1): if M % i == 0: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results def process_input_output(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [int(data[i]) for i in range(1, T+1)] results = can_construct_rectangle(T, test_cases) for result in results: print(result)"},{"question":"def find_kth_smallest(arr: List[int], k: int) -> int: Find the k-th smallest element in the array using a modified version of the Quickselect algorithm. >>> find_kth_smallest([7, 10, 4, 3, 20, 15], 3) 7 >>> find_kth_smallest([7, 10, 4, 3, 20, 15], 4) 10 def partition(arr, low, high): This function takes the last element as pivot, places the pivot element at its correct position in sorted array, and places all smaller (smaller than pivot) to left of pivot and all greater elements to right of pivot. def quickselect(arr, low, high, k): This function implements the Quickselect algorithm to find the k-th smallest element in the array.","solution":"def partition(arr, low, high): This function takes the last element as pivot, places the pivot element at its correct position in sorted array, and places all smaller (smaller than pivot) to left of pivot and all greater elements to right of pivot. pivot = arr[high] i = low - 1 # index of smaller element for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): This function implements the Quickselect algorithm to find the k-th smallest element in the array. if low <= high: # Partition the array and get the pivot index pivot_index = partition(arr, low, high) # If pivot index matches the k-th position if pivot_index == k: return arr[pivot_index] elif pivot_index > k: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def find_kth_smallest(arr, k): This function returns the k-th smallest element in the array. return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"def find_pairs_with_sum(nums, target): Write a function that takes a list of integers and an integer target, and returns all unique pairs of integers from the list that sum up to the target. Each pair in the output list should be sorted (smaller number first), and the output list should be sorted in ascending order based on the first element of each pair. If there are no such pairs, return an empty list. >>> find_pairs_with_sum([1, 2, 3], 7) == [] >>> find_pairs_with_sum([1, 2, 3], 4) == [(1, 3)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 5) == [(1, 4), (2, 3)] >>> find_pairs_with_sum([1, 1, 2, 3, 4], 4) == [(1, 3)] >>> find_pairs_with_sum([5, 1, 2, 4, 3], 5) == [(1, 4), (2, 3)] >>> find_pairs_with_sum([-1, -2, -3, -4, -5], -5) == [(-4, -1), (-3, -2)] >>> find_pairs_with_sum([1, -1, 2, -2, 3, -3], 0) == [(-3, 3), (-2, 2), (-1, 1)] >>> find_pairs_with_sum([1, 2, 2, 3, 4], 5) == [(1, 4), (2, 3)]","solution":"def find_pairs_with_sum(nums, target): Returns all unique pairs of integers from the list that sum up to the target. Each pair is sorted and the output list is sorted based on the first element of each pair. seen = {} pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen[num] = True return sorted(list(pairs))"},{"question":"def final_grid_state(n: int, m: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Given dimensions n and m of a grid and a list of operations, return the final state of the grid. Args: - n (int): number of rows in the grid - m (int): number of columns in the grid - operations (list of tuples): each tuple contains four integers a, b, c, d Returns: - list of list of int: the final state of the grid Examples: >>> final_grid_state(3, 3, [(1, 1, 2, 2), (2, 2, 3, 3)]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> final_grid_state(2, 2, [(1, 1, 2, 2)]) [[1, 1], [1, 1]] from typing import List, Tuple def test_final_grid_state_3x3_2_ops(): n, m = 3, 3 operations = [ (1, 1, 2, 2), (2, 2, 3, 3) ] expected = [ [1, 1, 0], [1, 2, 1], [0, 1, 1] ] assert final_grid_state(n, m, operations) == expected def test_final_grid_state_2x2_1_op(): n, m = 2, 2 operations = [ (1, 1, 2, 2) ] expected = [ [1, 1], [1, 1] ] assert final_grid_state(n, m, operations) == expected def test_final_grid_state_4x4_multiple_ops(): n, m = 4, 4 operations = [ (1, 1, 2, 2), (1, 1, 4, 4), (3, 3, 4, 4) ] expected = [ [2, 2, 1, 1], [2, 2, 1, 1], [1, 1, 2, 2], [1, 1, 2, 2] ] assert final_grid_state(n, m, operations) == expected def test_final_grid_state_1x1_single_op(): n, m = 1, 1 operations = [ (1, 1, 1, 1) ] expected = [ [1] ] assert final_grid_state(n, m, operations) == expected def test_final_grid_state_no_ops(): n, m = 5, 5 operations = [] expected = [ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] assert final_grid_state(n, m, operations) == expected","solution":"def final_grid_state(n, m, operations): Given dimensions n and m of a grid and a list of operations, return the final state of the grid. Args: - n (int): number of rows in the grid - m (int): number of columns in the grid - operations (list of tuples): each tuple contains four integers a, b, c, d Returns: - list of list of int: the final state of the grid # Initialize a grid with zeros grid = [[0 for _ in range(m)] for _ in range(n)] # Apply each operation to the grid for (a, b, c, d) in operations: for i in range(a-1, c): for j in range(b-1, d): grid[i][j] += 1 return grid"},{"question":"def is_prime(num: int) -> bool: Helper function to check if a number is prime. >>> is_prime(1) # False >>> is_prime(2) # True >>> is_prime(11) # True >>> is_prime(4) # False def digit_sum(n: int) -> int: Helper function to calculate the sum of digits of a number. >>> digit_sum(29) # 11 >>> digit_sum(101) # 2 def prime_friend_count(numbers: List[int]) -> int: Count how many numbers are prime-friend (sum of digits is prime). >>> prime_friend_count([29, 31, 42, 57]) # 1 >>> prime_friend_count([100, 101, 102, 103]) # 2 def count_prime_friend_numbers(test_cases: List[List[int]]) -> List[int]: For each test case, count how many numbers are prime-friend. >>> count_prime_friend_numbers([[29, 31, 42, 57], [11, 15, 13, 23, 25], [100, 101, 102, 103]]) # [1, 3, 2] >>> count_prime_friend_numbers([[]]) # [0] >>> count_prime_friend_numbers([[4, 6, 8, 9, 10]]) # [0]","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def digit_sum(n): Helper function to calculate the sum of digits of a number. return sum(int(digit) for digit in str(n)) def prime_friend_count(numbers): Count how many numbers are prime-friend (sum of digits is prime). return sum(1 for number in numbers if is_prime(digit_sum(number))) def count_prime_friend_numbers(test_cases): For each test case, count how many numbers are prime-friend. results = [] for numbers in test_cases: results.append(prime_friend_count(numbers)) return results"},{"question":"from typing import List, Tuple from collections import Counter def min_moves_to_make_anagram(s1: str, s2: str) -> int: This function calculates the minimum number of moves required to make two strings (s1 and s2) anagrams of each other. Each move consists of changing one character in s2 to another character. >>> min_moves_to_make_anagram(\\"aba\\", \\"baa\\") 0 >>> min_moves_to_make_anagram(\\"abc\\", \\"bca\\") 0 >>> min_moves_to_make_anagram(\\"abc\\", \\"def\\") 3 pass def process_test_cases(t: int, test_cases: List[Tuple[str, str]]) -> List[int]: Process multiple test cases and return a list of results for each test case. >>> process_test_cases(3, [(\\"aba\\", \\"baa\\"), (\\"abc\\", \\"bca\\"), (\\"abc\\", \\"def\\")]) [0, 0, 3] >>> process_test_cases(2, [(\\"aabbcc\\", \\"xxyyzz\\"), (\\"abcd\\", \\"dcba\\")]) [6, 0] >>> process_test_cases(1, [(\\"abcd\\", \\"abcd\\")]) [0] pass","solution":"from collections import Counter def min_moves_to_make_anagram(s1, s2): This function calculates the minimum number of moves required to make two strings (s1 and s2) anagrams of each other. Each move consists of changing one character in s2 to another character. count1 = Counter(s1) count2 = Counter(s2) moves = 0 for char in count1: if char in count2: moves += abs(count1[char] - count2[char]) else: moves += count1[char] for char in count2: if char not in count1: moves += count2[char] return moves // 2 def process_test_cases(t, test_cases): results = [] for s1, s2 in test_cases: result = min_moves_to_make_anagram(s1, s2) results.append(result) return results"},{"question":"def process_events(n: int, events: List[Tuple[int, int]]) -> List[int]: Processes events based on their priority and order of appearance. Parameters: n (int): Number of events. events (list of tuples): Each tuple contains (id, priority) of an event. Returns: list: Sequence of event ids in the order they are processed. >>> process_events(5, [(1, 3), (2, 1), (3, 2), (4, 3), (5, 1)]) [1, 4, 3, 2, 5] >>> process_events(4, [(10, 5), (20, 2), (30, 4), (40, 5)]) [10, 40, 30, 20]","solution":"def process_events(n, events): Processes events based on their priority and order of appearance. Parameters: n (int): Number of events. events (list of tuples): Each tuple contains (id, priority) of an event. Returns: list: Sequence of event ids in the order they are processed. # Sort events first by descending priority and then by original order in case of tie sorted_events = sorted(events, key=lambda x: (-x[1], events.index(x))) # Extract the event ids in order processed_order = [e[0] for e in sorted_events] return processed_order"},{"question":"def filter_books(books): Returns a list of titles of books that have more than 100 pages and were published after the year 2000. :param books: List of dictionaries, each representing a book :return: List of book titles meeting both criteria >>> books = [ ... {\\"title\\": \\"Book A\\", \\"pages\\": 95, \\"year\\": 1995}, ... {\\"title\\": \\"Book B\\", \\"pages\\": 150, \\"year\\": 2005}, ... {\\"title\\": \\"Book C\\", \\"pages\\": 105, \\"year\\": 2020}, ... {\\"title\\": \\"Book D\\", \\"pages\\": 200, \\"year\\": 1999} ... ] >>> filter_books(books) [\\"Book B\\", \\"Book C\\"]","solution":"def filter_books(books): Returns a list of titles of books that have more than 100 pages and were published after the year 2000. :param books: List of dictionaries, each representing a book :return: List of book titles meeting both criteria return [book['title'] for book in books if book['pages'] > 100 and book['year'] > 2000]"},{"question":"def find_longest_even_length_substring(s: str) -> int: Find the length of the longest even-length substring where the sum of the first half is equal to the sum of the second half. >>> find_longest_even_length_substring(\\"1538023\\") 4 >>> find_longest_even_length_substring(\\"123456\\") 0 pass def longest_even_length_substring(T: int, cases: List[str]) -> List[int]: For each test case, output the length of the longest even-length substring meeting the specified condition. >>> longest_even_length_substring(2, [\\"1538023\\", \\"123456\\"]) [4, 0] >>> longest_even_length_substring(3, [\\"0000\\", \\"123321\\", \\"123456\\"]) [4, 6, 0] pass","solution":"def find_longest_even_length_substring(s): max_length = 0 n = len(s) # traverse all possible lengths of even-length substrings for length in range(2, n + 1, 2): for i in range(n - length + 1): mid = i + length // 2 left_sum = sum(int(s[j]) for j in range(i, mid)) right_sum = sum(int(s[j]) for j in range(mid, i + length)) if left_sum == right_sum: max_length = max(max_length, length) return max_length def longest_even_length_substring(T, cases): results = [] for s in cases: results.append(find_longest_even_length_substring(s)) return results"},{"question":"def rotate_sequence(n: int, sequence: List[int], k: int) -> List[int]: Rotates the given sequence to the right by k steps. Parameters: n (int): The number of elements in the sequence. sequence (list of int): The sequence to rotate. k (int): The number of rotations. Returns: list of int: The rotated sequence. >>> rotate_sequence(5, [1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_sequence(5, [1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_sequence(3, [1000, 2000, -1000], 1) [-1000, 1000, 2000] >>> rotate_sequence(4, [-1, -2, -3, -4], 2) [-3, -4, -1, -2] >>> rotate_sequence(1, [42], 1000) [42]","solution":"def rotate_sequence(n, sequence, k): Rotates the given sequence to the right by k steps. Parameters: n (int): The number of elements in the sequence. sequence (list of int): The sequence to rotate. k (int): The number of rotations. Returns: list of int: The rotated sequence. # Calculate the effective number of rotations k = k % n return sequence[-k:] + sequence[:-k] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) sequence = list(map(int, data[1:n+1])) k = int(data[n+1]) result = rotate_sequence(n, sequence, k) print(\\" \\".join(map(str, result)))"},{"question":"def lexicographical_subsequence_max_sum(S: str) -> str: Returns the lexicographically smallest subsequence of S that has the maximum possible sum of alphabetical values of its characters. >>> lexicographical_subsequence_max_sum(\\"acbd\\") 'd' >>> lexicographical_subsequence_max_sum(\\"bac\\") 'c' >>> lexicographical_subsequence_max_sum(\\"a\\") 'a' >>> lexicographical_subsequence_max_sum(\\"abcd\\") 'd'","solution":"def lexicographical_subsequence_max_sum(S): Returns the lexicographically smallest subsequence of S that has the maximum possible sum of alphabetical values of its characters. # Step 1: Find the maximum character in the string S which will guarantee the highest sum max_char = max(S) # Step 2: Filter out the subsequence consisting of the max_char(s) result = ''.join(c for c in S if c == max_char) return result"},{"question":"def sort_books_by_popularity(n, scores): Returns the order of book numbers sorted by their popularity scores in descending order. Parameters: n (int): Number of books. scores (list): List of popularity scores of the books. Returns: list: List of book numbers sorted by their popularity scores in descending order. Examples: >>> sort_books_by_popularity(4, [10, 50, 30, 20]) [2, 3, 4, 1] >>> sort_books_by_popularity(3, [5, 15, 10]) [2, 3, 1]","solution":"def sort_books_by_popularity(n, scores): Returns the order of book numbers sorted by their popularity scores in descending order. Parameters: n (int): Number of books. scores (list): List of popularity scores of the books. Returns: list: List of book numbers sorted by their popularity scores in descending order. # Combine book numbers and their scores books_with_scores = list(enumerate(scores, start=1)) # Sort books by scores in descending order books_with_scores.sort(key=lambda x: x[1], reverse=True) # Extract and return the sorted book numbers sorted_books = [book[0] for book in books_with_scores] return sorted_books # Example usage n = 4 scores = [10, 50, 30, 20] print(sort_books_by_popularity(n, scores)) # Output: [2, 3, 4, 1]"},{"question":"def are_arrays_equal(n: int, a: List[int], b: List[int]) -> str: Determines if array 'a' can be rearranged to be exactly the same as array 'b'. :param n: Number of elements in the arrays :param a: List of integers representing array 'a' :param b: List of integers representing array 'b' :return: 'YES' if array 'a' can be rearranged to match array 'b', 'NO' otherwise >>> are_arrays_equal(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 'YES' >>> are_arrays_equal(4, [1, 2, 3, 4], [1, 2, 2, 4]) 'NO'","solution":"def are_arrays_equal(n, a, b): Determines if array 'a' can be rearranged to be exactly the same as array 'b'. :param n: Number of elements in the arrays :param a: List of integers representing array 'a' :param b: List of integers representing array 'b' :return: 'YES' if array 'a' can be rearranged to match array 'b', 'NO' otherwise # Sorting both arrays to compare them directly if sorted(a) == sorted(b): return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def smallestMissingPositive(nums: List[int]) -> int: Finds the smallest positive integer that is missing from the array. >>> smallestMissingPositive([1, 2, 0]) 3 >>> smallestMissingPositive([3, 4, -1, 1]) 2 >>> smallestMissingPositive([7, 8, 9, 11, 12]) 1","solution":"def smallestMissingPositive(nums): Finds the smallest positive integer that is missing from the array. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def solve(arr): Given an array of integers, returns a new array where each element is the product of all other elements in the original array except for the element at the same index. >>> solve([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> solve([3, 2, 1, 2, 6]) [24, 36, 72, 36, 12] >>> solve([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def solve(arr): Given an array of integers, returns a new array where each element is the product of all other elements in the original array except for the element at the same index. n = len(arr) # Create two arrays to store the product from left and right up to the current index left_products = [1] * n right_products = [1] * n output = [1] * n # Fill left_products for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill right_products for j in range(n - 2, -1, -1): right_products[j] = right_products[j + 1] * arr[j + 1] # Fill the output array by multiplying left_products and right_products for k in range(n): output[k] = left_products[k] * right_products[k] return output"},{"question":"def can_sort_by_reversing_subarray(n: int, arr: List[int]) -> str: Determines if the array can be sorted into non-decreasing order by reversing any number of contiguous subarrays. Parameters: n (int): The length of the array arr (List[int]): The array of integers Returns: str: 'YES' if the array can be sorted as described, otherwise 'NO' >>> can_sort_by_reversing_subarray(5, [1, 3, 2, 4, 5]) == 'YES' >>> can_sort_by_reversing_subarray(4, [4, 3, 2, 1]) == 'YES' >>> can_sort_by_reversing_subarray(3, [3, 1, 2]) == 'NO' >>> can_sort_by_reversing_subarray(5, [1, 2, 3, 4, 5]) == 'YES' >>> can_sort_by_reversing_subarray(1, [10]) == 'YES' >>> can_sort_by_reversing_subarray(6, [1, 5, 4, 3, 2, 6]) == 'YES' >>> can_sort_by_reversing_subarray(6, [1, 5, 4, 6, 3, 2]) == 'NO'","solution":"def can_sort_by_reversing_subarray(n, arr): Determines if the array can be sorted into non-decreasing order by reversing any number of contiguous subarrays. Parameters: n (int): The length of the array arr (List[int]): The array of integers Returns: str: 'YES' if the array can be sorted as described, otherwise 'NO' # Find the first and last place where the array is out of order first, last = -1, -1 for i in range(n - 1): if arr[i] > arr[i + 1]: if first == -1: first = i last = i + 1 # If no such subarray is found, the array is already sorted if first == -1: return 'YES' # Reverse the subarray and check if the whole array becomes sorted reversed_subarray = arr[:first] + arr[first:last+1][::-1] + arr[last+1:] if reversed_subarray == sorted(arr): return 'YES' else: return 'NO'"},{"question":"def communication_difficulty(S: str) -> str: Determines if the given 3-letter code is easy or hard to communicate. Easy if it contains any vowel (A, E, I, O, U), otherwise Hard. Parameters: S (str): The 3-letter uppercase string. Returns: str: \\"Easy\\" if the code contains any vowel, \\"Hard\\" otherwise. # Your implementation here Unit Tests from solution import communication_difficulty def test_communication_difficulty_with_vowels(): assert communication_difficulty(\\"AEX\\") == \\"Easy\\" assert communication_difficulty(\\"UYZ\\") == \\"Easy\\" assert communication_difficulty(\\"EIW\\") == \\"Easy\\" def test_communication_difficulty_without_vowels(): assert communication_difficulty(\\"BCD\\") == \\"Hard\\" assert communication_difficulty(\\"TQR\\") == \\"Hard\\" assert communication_difficulty(\\"XYZ\\") == \\"Hard\\" def test_communication_difficulty_mixed(): assert communication_difficulty(\\"AXY\\") == \\"Easy\\" assert communication_difficulty(\\"EBC\\") == \\"Easy\\" assert communication_difficulty(\\"QWI\\") == \\"Easy\\" assert communication_difficulty(\\"GHJ\\") == \\"Hard\\" assert communication_difficulty(\\"KLM\\") == \\"Hard\\" assert communication_difficulty(\\"PQR\\") == \\"Hard\\"","solution":"def communication_difficulty(S): Determines if the given 3-letter code is easy or hard to communicate. Easy if it contains any vowel (A, E, I, O, U), otherwise Hard. Parameters: S (str): The 3-letter uppercase string. Returns: str: \\"Easy\\" if the code contains any vowel, \\"Hard\\" otherwise. vowels = {'A', 'E', 'I', 'O', 'U'} for char in S: if char in vowels: return \\"Easy\\" return \\"Hard\\""},{"question":"from typing import List def reverse_spiral(matrix: List[List[int]]) -> List[int]: Returns an array of integers representing the reverse spiral traversal of the matrix. >>> reverse_spiral([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == [16, 15, 14, 13, 9, 5, 1, 2, 3, 4, 8, 12, 11, 10, 6, 7] >>> reverse_spiral([ [2, 3] ]) == [3, 2] >>> reverse_spiral([ [1], [2], [3], [4] ]) == [4, 3, 2, 1] pass","solution":"from typing import List def reverse_spiral(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] top, bottom, left, right = 0, m - 1, 0, n - 1 while top <= bottom and left <= right: for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 if top <= bottom: for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 if left <= right: for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 return result"},{"question":"def topKFrequentWords(words_dict: dict, K: int) -> list: Returns the top K frequent words sorted by their frequency in descending order. If two words have the same frequency, they are sorted alphabetically. >>> words_dict = { ... \\"apple\\": 4, ... \\"banana\\": 2, ... \\"orange\\": 5, ... \\"grape\\": 2, ... \\"pear\\": 3, ... } >>> K = 3 >>> topKFrequentWords(words_dict, K) ['orange', 'apple', 'pear'] >>> words_dict = { ... \\"apple\\": 3, ... \\"banana\\": 3, ... \\"orange\\": 3, ... \\"grape\\": 2, ... \\"pear\\": 2, ... } >>> K = 3 >>> topKFrequentWords(words_dict, K) ['apple', 'banana', 'orange'] >>> words_dict = { ... \\"apple\\": 1, ... \\"banana\\": 1, ... \\"orange\\": 1, ... \\"grape\\": 1, ... \\"pear\\": 1, ... } >>> K = 2 >>> topKFrequentWords(words_dict, K) ['apple', 'banana'] >>> words_dict = { ... \\"apple\\": 1, ... \\"banana\\": 2, ... \\"orange\\": 3, ... \\"grape\\": 4, ... \\"pear\\": 5, ... } >>> K = 5 >>> topKFrequentWords(words_dict, K) ['pear', 'grape', 'orange', 'banana', 'apple'] pass","solution":"def topKFrequentWords(words_dict, K): Returns the top K frequent words sorted by their frequency in descending order. If two words have the same frequency, they are sorted alphabetically. sorted_words = sorted(words_dict.items(), key=lambda x: (-x[1], x[0])) return [word for word, freq in sorted_words[:K]] # Example usage: words_dict = { \\"apple\\": 4, \\"banana\\": 2, \\"orange\\": 5, \\"grape\\": 2, \\"pear\\": 3, } K = 3 print(topKFrequentWords(words_dict, K)) # Output: ['orange', 'apple', 'pear']"},{"question":"def min_operations_to_equal_strings(a: str, b: str) -> int: Given two strings a and b of the same length, this function calculates the minimum number of operations required to make the strings equal by replacing any character in the string \`a\` with any other lowercase English letter. >>> min_operations_to_equal_strings(\\"abc\\", \\"bcd\\") 3 >>> min_operations_to_equal_strings(\\"aaa\\", \\"bbb\\") 3 >>> min_operations_to_equal_strings(\\"abcdef\\", \\"ghijkl\\") 6 >>> min_operations_to_equal_strings(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_equal_strings(\\"a\\", \\"b\\") 1 # Your code here def process_queries(T: int, queries: List[str]) -> List[int]: This function handles multiple queries to determine the minimum number of operations required to make strings equal for each pair of queries. >>> process_queries(3, [\\"abc\\", \\"bcd\\", \\"aaa\\", \\"bbb\\", \\"abcdef\\", \\"ghijkl\\"]) [3, 3, 6] >>> process_queries(2, [\\"a\\", \\"b\\", \\"abc\\", \\"def\\"]) [1, 3] >>> process_queries(1, [\\"hello\\", \\"jello\\"]) [1] >>> process_queries(1, [\\"aaaaa\\", \\"bbbbb\\"]) [5] >>> process_queries(2, [\\"aaa\\", \\"aab\\", \\"cat\\", \\"bat\\"]) [1, 1] # Your code here","solution":"def min_operations_to_equal_strings(a, b): Given two strings a and b of the same length, this function calculates the minimum number of operations required to make the strings equal by replacing any character in the string \`a\` with any other lowercase English letter. # Since both strings have the same length, we simply count the different characters return sum(1 for i in range(len(a)) if a[i] != b[i]) # Function to handle multiple queries def process_queries(T, queries): results = [] for i in range(T): a = queries[2 * i] b = queries[2 * i + 1] results.append(min_operations_to_equal_strings(a, b)) return results"},{"question":"def process_logs(log_entries): Processes log entries to compute total latencies and the highest single latency. Parameters: log_entries (list of str): List of log entries with format \\"timestamp service_name latency\\" Returns: dict: Total latencies for each service. str: The service name with the highest single latency. # Your code goes here from solution import process_logs def test_process_logs(): log_entries = [ \\"15:32:10 serviceA 120\\", \\"15:32:15 serviceB 80\\", \\"15:32:20 serviceA 150\\", \\"15:32:30 serviceC 200\\", \\"15:32:35 serviceB 50\\", \\"15:32:40 serviceC 100\\", \\"15:32:45 serviceA 250\\", \\"end\\" ] expected_total_latencies = { \\"serviceA\\": 520, \\"serviceB\\": 130, \\"serviceC\\": 300 } expected_highest_latency_service = \\"serviceA\\" total_latencies, highest_latency_service = process_logs(log_entries) assert total_latencies == expected_total_latencies assert highest_latency_service == expected_highest_latency_service def test_no_logs(): log_entries = [\\"end\\"] expected_total_latencies = {} expected_highest_latency_service = None total_latencies, highest_latency_service = process_logs(log_entries) assert total_latencies == expected_total_latencies assert highest_latency_service == expected_highest_latency_service def test_single_entry(): log_entries = [ \\"15:32:10 serviceA 120\\", \\"end\\" ] expected_total_latencies = { \\"serviceA\\": 120 } expected_highest_latency_service = \\"serviceA\\" total_latencies, highest_latency_service = process_logs(log_entries) assert total_latencies == expected_total_latencies assert highest_latency_service == expected_highest_latency_service def test_multiple_highest_entries(): log_entries = [ \\"15:32:10 serviceA 100\\", \\"15:32:15 serviceB 200\\", \\"15:32:20 serviceA 100\\", \\"15:32:30 serviceB 200\\", \\"end\\" ] expected_total_latencies = { \\"serviceA\\": 200, \\"serviceB\\": 400 } expected_highest_latency_service = \\"serviceB\\" # We'll accept either since both have the same highest latency total_latencies, highest_latency_service = process_logs(log_entries) assert total_latencies == expected_total_latencies assert highest_latency_service in [\\"serviceA\\", \\"serviceB\\"]","solution":"def process_logs(log_entries): Processes log entries to compute total latencies and the highest single latency. Parameters: log_entries (list of str): List of log entries with format \\"timestamp service_name latency\\" Returns: dict: Total latencies for each service. str: The service name with the highest single latency. service_latencies = {} highest_latency = 0 service_with_highest_latency = None for entry in log_entries: if entry.strip().lower() == 'end': break parts = entry.split() timestamp, service_name, latency = parts[0], parts[1], int(parts[2]) if service_name not in service_latencies: service_latencies[service_name] = 0 service_latencies[service_name] += latency if latency > highest_latency: highest_latency = latency service_with_highest_latency = service_name return service_latencies, service_with_highest_latency"},{"question":"def longest_increasing_subarray_length(N: int, A: List[int]) -> int: Returns the length of the longest strictly increasing subarray in A. >>> longest_increasing_subarray_length(1, [1]) 1 >>> longest_increasing_subarray_length(5, [2, 2, 2, 2, 2]) 1 >>> longest_increasing_subarray_length(5, [1, 2, 3, 4, 5]) 5 >>> longest_increasing_subarray_length(5, [5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray_length(8, [2, 2, 2, 2, 3, 4, 5, 1]) 4 >>> longest_increasing_subarray_length(10, [10, 1, 2, 3, 2, 3, 4, 5, 6, 7]) 6 >>> longest_increasing_subarray_length(5, [10000, 10001, 10002, 10003, 9999]) 4 >>> longest_increasing_subarray_length(6, [1, 3, 5, 2, 4, 6]) 3","solution":"def longest_increasing_subarray_length(N, A): Returns the length of the longest strictly increasing subarray in A. if N < 2: return N max_length = 1 current_length = 1 for i in range(1, N): if A[i] > A[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length # Example usage: # N = 8 # A = [2, 2, 2, 2, 3, 4, 5, 1] # print(longest_increasing_subarray_length(N, A)) # Output: 4"},{"question":"def process_queries(N: int, Q: int, queries: List[str]) -> List[Union[int, str]]: Process a series of stack operations and return necessary results. There are three types of operations: 1. \\"PUSH x\\" which pushes the plate with value x onto the stack. 2. \\"POP\\" which removes the topmost plate from the stack. 3. \\"MAX\\" which prints the maximum value present in the stack. Args: N (int): The maximum number of plates the stack can hold. Q (int): The number of queries to process. queries (List[str]): A list of queries to process. Returns: List[Union[int, str]]: Results of the \\"MAX\\" and \\"POP\\" operations. Examples: >>> process_queries(10, 7, [\\"PUSH 5\\", \\"PUSH 3\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"POP\\", \\"MAX\\"]) [5, 5, 'EMPTY'] >>> process_queries(5, 8, [\\"PUSH 7\\", \\"PUSH 9\\", \\"PUSH 3\\", \\"PUSH 10\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"POP\\"]) [10, 9] import pytest from solution import process_queries def test_process_queries_example1(): assert process_queries(10, 7, [ \\"PUSH 5\\", \\"PUSH 3\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"POP\\", \\"MAX\\" ]) == [5, 5, \\"EMPTY\\"] def test_process_queries_example2(): assert process_queries(5, 8, [ \\"PUSH 7\\", \\"PUSH 9\\", \\"PUSH 3\\", \\"PUSH 10\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"POP\\" ]) == [10, 9] def test_process_queries_push_beyond_capacity(): assert process_queries(2, 5, [ \\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"MAX\\", \\"POP\\" ]) == [2] def test_process_queries_pop_empty_stack(): assert process_queries(2, 3, [ \\"PUSH 1\\", \\"POP\\", \\"POP\\" ]) == [\\"EMPTY\\"] def test_process_queries_max_empty_stack(): assert process_queries(2, 2, [ \\"PUSH 1\\", \\"MAX\\", \\"POP\\", \\"MAX\\" ]) == [1, \\"EMPTY\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"def process_queries(N, Q, queries): stack = [] max_stack = [] results = [] for query in queries: if query.startswith(\\"PUSH\\"): _, x = query.split() x = int(x) if len(stack) < N: stack.append(x) if not max_stack or x >= max_stack[-1]: max_stack.append(x) elif query == \\"POP\\": if stack: popped = stack.pop() if popped == max_stack[-1]: max_stack.pop() else: results.append(\\"EMPTY\\") elif query == \\"MAX\\": if max_stack: results.append(max_stack[-1]) else: results.append(\\"EMPTY\\") return results"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: A class representation of a binary tree with basic operations. def __init__(self): self.root = None def addNode(self, value): Add a node with the given value to the binary tree. >>> bt = BinaryTree() >>> bt.addNode(10) def _addNode(self, node, value): Helper method to add a node. def findNode(self, value): Find if a node with the given value exists in the binary tree. >>> bt = BinaryTree() >>> bt.addNode(10) >>> bt.findNode(10) 'Exist' >>> bt.findNode(5) 'Not Exist' def _findNode(self, node, value): Helper method to find a node. def deleteNode(self, value): Delete a node with the given value from the binary tree. >>> bt = BinaryTree() >>> bt.addNode(10) >>> bt.deleteNode(10) >>> bt.findNode(10) 'Not Exist' def _deleteNode(self, node, value): Helper method to delete a node. def _minValueNode(self, node): Helper method to find node with the minimum value.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def addNode(self, value): if self.root is None: self.root = TreeNode(value) else: self._addNode(self.root, value) def _addNode(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._addNode(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._addNode(node.right, value) def findNode(self, value): return \\"Exist\\" if self._findNode(self.root, value) else \\"Not Exist\\" def _findNode(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._findNode(node.left, value) else: return self._findNode(node.right, value) def deleteNode(self, value): self.root = self._deleteNode(self.root, value) def _deleteNode(self, node, value): if node is None: return node if value < node.value: node.left = self._deleteNode(node.left, value) elif value > node.value: node.right = self._deleteNode(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._minValueNode(node.right) node.value = temp.value node.right = self._deleteNode(node.right, temp.value) return node def _minValueNode(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determine if a linked list has a cycle using Floyd's Tortoise and Hare algorithm. :param head: ListNode, the head of the linked list :return: bool, whether the linked list contains a cycle pass def test_no_cycle(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) assert not hasCycle(head) def test_cycle(): head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) head.next = second second.next = third third.next = fourth fourth.next = second # Creates a cycle assert hasCycle(head) def test_single_node_no_cycle(): head = ListNode(1) assert not hasCycle(head) def test_single_node_with_cycle(): head = ListNode(1) head.next = head # Creates a cycle assert hasCycle(head) def test_empty_list(): assert not hasCycle(None)","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determine if a linked list has a cycle using Floyd's Tortoise and Hare algorithm. :param head: ListNode, the head of the linked list :return: bool, whether the linked list contains a cycle if not head: return False slow = head fast = head.next while slow != fast: if fast is None or fast.next is None: return False slow = slow.next fast = fast.next.next return True"},{"question":"def find_pairs(arr, target): Create a function that takes an array of numbers and a target number, and returns all unique pairs of numbers that add up to the target number. The pairs should be returned as a list of tuples, and each tuple should have the smaller number first. The list should be sorted in ascending order by the first element in the tuple. >>> find_pairs([2, 4, 3, 5, 7, 8, 9], 10) [(2, 8), (3, 7)] >>> find_pairs([], 10) [] >>> find_pairs([1, 2, 3, 4], 8) [] >>> find_pairs([1, 2, 4, 5, 6, 7, 8], 9) [(1, 8), (2, 7), (4, 5)] >>> find_pairs([2, 2, 3, 4, 5, 6, 7, 8, 9], 10) [(2, 8), (3, 7), (4, 6)] >>> find_pairs([-2, -1, 1, 3, 4, 5, 9], 3) [(-2, 5), (-1, 4)] >>> find_pairs([-9, -8, -7, -6, -5, -4, -3, -2, -1], -10) [(-9, -1), (-8, -2), (-7, -3), (-6, -4)] >>> find_pairs([1000000, 999999, 1, 1000001, 2], 1000001) [(1, 1000000), (2, 999999)]","solution":"def find_pairs(arr, target): Returns all unique pairs of numbers from the array that add up to the target number. Each pair (tuple) contains the smaller number first. The list of pairs is sorted by the first element in the tuple. arr.sort() seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) return sorted(pairs)"},{"question":"def best_employee(n: int, m: int, scores: List[List[int]]) -> int: Determine the employee who consistently performed the best throughout the period based on average score. >>> best_employee(3, 4, [[10, 20, 15, 10], [20, 10, 20, 10], [10, 10, 10, 10]]) 2 >>> best_employee(3, 4, [[10, 10, 10, 10], [10, 10, 10, 10], [10, 10, 10, 10]]) 1 >>> best_employee(3, 4, [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]) 3 >>> best_employee(3, 4, [[10, 20, 30, 40], [40, 30, 20, 10], [25, 25, 25, 25]]) 1 >>> best_employee(1, 4, [[10, 20, 30, 40]]) 1 >>> best_employee(0, 0, []) -1 >>> best_employee(3, 0, [[10, 20], [20, 30], [30, 40]]) -1 >>> best_employee(0, 3, []) -1","solution":"def best_employee(n, m, scores): if n == 0 or m == 0: return -1 best_index = 0 highest_average = -float('inf') # Start with the lowest possible average for i in range(n): total_score = sum(scores[i]) average_score = total_score / m if average_score > highest_average: highest_average = average_score best_index = i return best_index + 1 # Return 1-based index"},{"question":"def convertToRoman(n: int) -> str: Converts a non-negative integer to its Roman numeral representation. >>> convertToRoman(3) \\"III\\" >>> convertToRoman(4) \\"IV\\" >>> convertToRoman(9) \\"IX\\" >>> convertToRoman(58) \\"LVIII\\" >>> convertToRoman(1994) \\"MCMXCIV\\"","solution":"def convertToRoman(n): Converts a non-negative integer to its Roman numeral representation. :param n: a non-negative integer :return: Roman numeral as a string if n < 1 or n > 3999: return \\"\\" value_to_roman = [ (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I') ] result = \\"\\" for value, numeral in value_to_roman: while n >= value: result += numeral n -= value return result"},{"question":"def minimize_max_difference(arr: List[int]) -> int: Reorders the array so that the maximum difference between consecutive elements is minimized. Arguments: arr -- list of integers representing the array to be reordered Returns: int -- the minimized maximum difference between consecutive elements Examples: >>> minimize_max_difference([1, 2, 3, 4]) 1 >>> minimize_max_difference([8, 9, 6, 2, 4]) 2","solution":"def minimize_max_difference(arr): Reorders the array so that the maximum difference between consecutive elements is minimized. Arguments: arr -- list of integers representing the array to be reordered Returns: int -- the minimized maximum difference between consecutive elements # Sort the array arr.sort() # Initialize the minimum maximum difference min_max_difference = float('inf') # Calculate the differences between consecutive elements for i in range(1, len(arr)): min_max_difference = min(min_max_difference, arr[i] - arr[i - 1]) return min_max_difference"},{"question":"def min_candies(n: int, scores: List[int]) -> int: Determine the minimum number of candies required to distribute according to the tradition. Each child must get at least one candy, and any child with a higher performance score than their immediate neighbors must receive more candies than those neighbors. >>> min_candies(5, [1, 2, 2, 3, 4]) 9 >>> min_candies(3, [3, 2, 1]) 6","solution":"def min_candies(n, scores): if n == 1: return 1 candies = [1] * n # First pass: from left to right for i in range(1, n): if scores[i] > scores[i - 1]: candies[i] = candies[i - 1] + 1 # Second pass: from right to left for i in range(n - 2, -1, -1): if scores[i] > scores[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) return sum(candies)"},{"question":"def add_large_numbers(s1: str, s2: str) -> str: Returns the sum of two large non-negative integers represented as strings. >>> add_large_numbers(\\"1234\\", \\"5678\\") '6912' >>> add_large_numbers(\\"9999999999999999\\", \\"1\\") '10000000000000000' # Your code here def process_test_cases(t: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases for adding large numbers given as strings. >>> process_test_cases(2, [(\\"1234\\", \\"5678\\"), (\\"9999999999999999\\", \\"1\\")]) ['6912', '10000000000000000'] # Your code here","solution":"def add_large_numbers(s1, s2): Returns the sum of two large non-negative integers represented as strings. # Convert strings to integers, add them and convert back to string return str(int(s1) + int(s2)) def process_test_cases(t, test_cases): results = [] for s1, s2 in test_cases: results.append(add_large_numbers(s1, s2)) return results"},{"question":"def max_subarray_sum_less_equal(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Find the maximum possible sum of a subarray of the given array such that the sum is less than or equal to a given integer S. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of tuples for each test case. Each tuple contains: - n (int): The number of elements in the array. - S (int): The maximum allowable sum for the subarray. - arr (List[int]): The array of integers containing n elements. Returns: List[int]: A list of integers where each integer is the answer for one test case, representing the maximum possible sum of a subarray that is less than or equal to S. Example: >>> max_subarray_sum_less_equal(3, [(5, 10, [1, 2, 3, 4, 5]), (4, 5, [2, -1, 2, 3]), (6, 15, [1, -2, 3, 10, -4, 7])]) [10, 4, 15] >>> max_subarray_sum_less_equal(1, [(1, 5, [6])]) [0] >>> max_subarray_sum_less_equal(1, [(1, 5, [5])]) [5] >>> max_subarray_sum_less_equal(1, [(1, 5, [-1])]) [-1] >>> max_subarray_sum_less_equal(1, [(3, 5, [-1, -2, -3])]) [-1]","solution":"def max_subarray_sum_less_equal(t, test_cases): results = [] for n, S, arr in test_cases: current_sum = 0 max_sum = float('-inf') start = 0 for end in range(n): current_sum += arr[end] while current_sum > S and start <= end: current_sum -= arr[start] start += 1 if current_sum <= S: max_sum = max(max_sum, current_sum) results.append(max_sum if max_sum != float('-inf') else 0) return results"},{"question":"from typing import List def process_badge_system(n: int, q: int, S: str, queries: List[str]) -> List[int]: Processes badge system queries on the given string. Arguments: n -- Length of the string S q -- Number of queries to be performed S -- The string of digits queries -- A list of query strings in the format: \\"1 i j\\" to compute the sum of the digits from index i to j (inclusive). \\"2 i j k\\" to replace the digits from index i to j with digit k. Returns: A list of results for all \\"1 i j\\" queries. Examples: >>> process_badge_system(5, 4, \\"12345\\", [\\"1 0 2\\", \\"2 1 3 9\\", \\"1 1 4\\", \\"1 0 4\\"]) [6, 32, 33] >>> process_badge_system(3, 3, \\"123\\", [\\"1 0 1\\", \\"2 1 1 8\\", \\"1 0 2\\"]) [3, 12]","solution":"def process_badge_system(n, q, S, queries): S = list(S) # Convert string to list for mutable operations results = [] for query in queries: parts = query.split() type_of_query = int(parts[0]) i = int(parts[1]) j = int(parts[2]) if type_of_query == 1: # Sum of digits from index i to j (inclusive) result = sum(int(S[index]) for index in range(i, j + 1)) results.append(result) elif type_of_query == 2: # Replace every digit from index i to j with k k = parts[3] for index in range(i, j + 1): S[index] = k return results"},{"question":"def canSegmentMessage(message: str, word_dict: set) -> bool: Determines if the message can be segmented into a sequence of one or more dictionary words. :param message: str - The message string containing only lowercase alphabetical characters. :param word_dict: set - The set of dictionary words. :return: bool - True if the message can be segmented into dictionary words, otherwise False. >>> canSegmentMessage(\\"applepie\\", {\\"apple\\", \\"pie\\"}) True >>> canSegmentMessage(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) False >>> canSegmentMessage(\\"apple\\", {\\"apple\\"}) True >>> canSegmentMessage(\\"appleapple\\", {\\"apple\\"}) True >>> canSegmentMessage(\\"helloworld\\", {\\"hello\\", \\"world\\"}) True >>> canSegmentMessage(\\"helloworlds\\", {\\"hello\\", \\"world\\"}) False pass","solution":"def canSegmentMessage(message, word_dict): Determines if the message can be segmented into a sequence of one or more dictionary words. :param message: str - The message string containing only lowercase alphabetical characters. :param word_dict: set - The set of dictionary words. :return: bool - True if the message can be segmented into dictionary words, otherwise False. n = len(message) dp = [False] * (n + 1) dp[0] = True # Empty string can always be segmented for i in range(1, n + 1): for j in range(i): if dp[j] and message[j:i] in word_dict: dp[i] = True break return dp[n]"},{"question":"def is_symmetric(matrix: List[List[int]]) -> bool: Determine if a given square matrix is symmetric. >>> is_symmetric([[1, 2, 3], [2, 4, 5], [3, 5, 6]]) == True >>> is_symmetric([[1, 0, 3], [2, 4, 5], [3, 5, 6]]) == False","solution":"def is_symmetric(matrix): Determines if a given square matrix is symmetric. A square matrix is symmetric if it is equal to its transpose. :param matrix: A list of lists where each sublist represents a row of the matrix. :return: True if the matrix is symmetric, False otherwise. n = len(matrix) for i in range(n): for j in range(i, n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"import re from collections import defaultdict from typing import Dict def word_count(s: str) -> Dict[str, int]: Count the frequency of each word in the string, ignoring case and punctuation. The words should only contain alphabetical characters. Args: s (str): A string containing words and punctuation marks. Returns: Dict[str, int]: A dictionary where keys are words in lowercase and values are the frequency of each word. Examples: >>> word_count(\\"Hello, hello! How are you? I hope you are well. Well, well, well...\\") {'hello': 2, 'how': 1, 'are': 2, 'you': 2, 'i': 1, 'hope': 1, 'well': 4} >>> word_count(\\"The quick brown fox jumps over the lazy dog. The dog barked.\\") {'the': 3, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 2, 'barked': 1}","solution":"import re from collections import defaultdict def word_count(s): Returns the frequency of each word in the string \`s\` ignoring case and punctuation. The words should only contain alphabetical characters. # Replacing non-alphabetical characters with space, converting to lower case and splitting into words words = re.sub(r'[^a-zA-Zs]', ' ', s).lower().split() word_freq = defaultdict(int) # Counting frequency of each word for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"def longestPath(grid: List[List[int]]) -> int: Given a matrix grid[][] of size N x N consisting of positive integers, find the longest path from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1) such that the path strictly increases and each step you take can only be downward or rightward. >>> longestPath([[1, 2, 3], [6, 5, 4], [7, 8, 9]]) 5 >>> longestPath([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1","solution":"def longestPath(grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < n def dfs(x, y, prev_val): if not is_valid(x, y) or grid[x][y] <= prev_val: return 0 if dp[x][y] != -1: return dp[x][y] current_val = grid[x][y] down_path = dfs(x + 1, y, current_val) right_path = dfs(x, y + 1, current_val) dp[x][y] = 1 + max(down_path, right_path) return dp[x][y] n = len(grid) dp = [[-1 for _ in range(n)] for _ in range(n)] return dfs(0, 0, -1)"},{"question":"def product_array(arr): Given an array of integers, return a new array such that each element at index \`i\` of the new array is the product of all the numbers in the original array except the one at \`i\`. >>> product_array([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_array([3, 2, 1]) [2, 3, 6]","solution":"def product_array(arr): Returns a new array such that each element at index \`i\` of the new array is the product of all the numbers in the original array except the one at \`i\`. n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n for i in range(1, n): left_products[i] = left_products[i-1] * arr[i-1] for i in range(n-2, -1, -1): right_products[i] = right_products[i+1] * arr[i+1] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List def maxUniqueGems(m: int, n: int, grid: List[List[int]]) -> int: Determines the maximum number of unique gems John can collect from the grid. >>> maxUniqueGems(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 9 >>> maxUniqueGems(3, 3, [ ... [1, 1, 3], ... [1, 1, 3], ... [4, 5, 6] ... ]) 5 >>> maxUniqueGems(2, 2, [ ... [1, 2], ... [2, 3] ... ]) 3 >>> maxUniqueGems(1, 1, [ ... [1] ... ]) 1 >>> maxUniqueGems(3, 3, [ ... [1, 2, 2], ... [3, 1, 3], ... [2, 4, 1] ... ]) 4 pass def test_maxUniqueGems(): input_data = [ ( (3, 3 ,[ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), 9 ), ( (3, 3 ,[ [1, 1, 3], [1, 1, 3], [4, 5, 6] ]), 5 ), ( (2, 2, [ [1, 2], [2, 3] ]), 3 ), ( (1, 1, [ [1] ]), 1 ), ( (3, 3, [ [1, 2, 2], [3, 1, 3], [2, 4, 1] ]), 4 ) ] for (m, n, grid), expected in input_data: assert maxUniqueGems(m, n, grid) == expected test_maxUniqueGems()","solution":"def maxUniqueGems(m, n, grid): def dfs(x, y, visited): nonlocal max_gems for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] not in visited: visited.add(grid[nx][ny]) dfs(nx, ny, visited) visited.remove(grid[nx][ny]) max_gems = max(max_gems, len(visited)) max_gems = 0 for i in range(m): for j in range(n): dfs(i, j, set([grid[i][j]])) return max_gems"},{"question":"from typing import List def find_lowest_path_cost(m: int, n: int, grid: List[List[int]]) -> int: Calculates the minimum cost to travel from the top-left corner of the grid to the bottom-right corner of the grid. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> find_lowest_path_cost(3, 3, grid) 7 >>> grid = [ ... [5] ... ] >>> find_lowest_path_cost(1, 1, grid) 5 >>> grid = [ ... [1, 2, 3, 4] ... ] >>> find_lowest_path_cost(1, 4, grid) 10","solution":"from typing import List def find_lowest_path_cost(m: int, n: int, grid: List[List[int]]) -> int: Calculates the minimum cost to travel from the top-left corner of the grid to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 # Create a 2D list to store the minimum path cost at each cell dp = [[0] * n for _ in range(m)] # Initialize the first cell with its own value dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the minimum path cost return dp[m - 1][n - 1]"},{"question":"def generateStatement(transactions): Generate the overall statement indicating the balance of each account after the given list of transactions. Parameters: - transactions (list of tuples): List of transactions where each transaction is represented as a tuple (account_id, transaction_type, amount) Returns: - dict: Dictionary where each key is an 'account_id' and each value is the end balance of that account after all transactions. >>> generateStatement([ ('A123', 'deposit', 100), ('B456', 'withdraw', 50), ('A123', 'withdraw', 40), ('A123', 'deposit', 300), ('B456', 'deposit', 200) ]) {'A123': 360, 'B456': 150} >>> generateStatement([]) {} >>> generateStatement([ ('A123', 'deposit', 100), ('A123', 'deposit', 200), ('B456', 'deposit', 300) ]) {'A123': 300, 'B456': 300} >>> generateStatement([ ('A123', 'withdraw', 100), ('A123', 'withdraw', 50), ('B456', 'withdraw', 300) ]) {'A123': -150, 'B456': -300} >>> generateStatement([ ('A123', 'deposit', 200), ('A123', 'withdraw', 100), ('B456', 'deposit', 300), ('B456', 'withdraw', 150), ('A123', 'deposit', 50) ]) {'A123': 150, 'B456': 150} pass","solution":"def generateStatement(transactions): Generate the overall statement indicating the balance of each account after the given list of transactions. Parameters: - transactions (list of tuples): List of transactions where each transaction is represented as a tuple (account_id, transaction_type, amount) Returns: - dict: Dictionary where each key is an 'account_id' and each value is the end balance of that account after all transactions. account_balances = {} for account_id, transaction_type, amount in transactions: if account_id not in account_balances: account_balances[account_id] = 0 if transaction_type == 'deposit': account_balances[account_id] += amount elif transaction_type == 'withdraw': account_balances[account_id] -= amount return account_balances"},{"question":"def calculate_final_bonuses(T: int, cases: List[Tuple[int, List[str]]]) -> List[List[Tuple[str, int]]]: Calculate the final bonus for each employee given the dependency on their manager's bonus. Each employee, including managers, will have the same base bonus calculated initially as (performance score * 100). If an employee has a manager, then the manager's bonus is added to their base bonus. This continues recursively up the hierarchy. Parameters: T (int): The number of test cases. cases (List[Tuple[int, List[str]]]): Each test case containing the number of employees and their details as a list of strings. Each string contains employee_id, performance_score, and manager_id separated by spaces. Returns: List[List[Tuple[str, int]]]: A list of lists containing tuples with employee_id and final bonus, sorted by employee ids in ascending order for each case. >>> T = 2 >>> cases = [(4, [\\"alice 10 None\\", \\"bob 8 alice\\", \\"carol 15 bob\\", \\"dave 5 alice\\"]), ... (3, [\\"eve 7 None\\", \\"frank 9 eve\\", \\"grace 6 frank\\"])] >>> calculate_final_bonuses(T, cases) [[('alice', 1000), ('bob', 1800), ('carol', 3300), ('dave', 1500)], [('eve', 700), ('frank', 1600), ('grace', 2200)]] import pytest def test_calculate_final_bonuses(): T = 2 cases = [ (4, [\\"alice 10 None\\", \\"bob 8 alice\\", \\"carol 15 bob\\", \\"dave 5 alice\\"]), (3, [\\"eve 7 None\\", \\"frank 9 eve\\", \\"grace 6 frank\\"]) ] expected_output = [ [(\\"alice\\", 1000), (\\"bob\\", 1800), (\\"carol\\", 3300), (\\"dave\\", 1500)], [(\\"eve\\", 700), (\\"frank\\", 1600), (\\"grace\\", 2200)] ] assert calculate_final_bonuses(T, cases) == expected_output def test_calculate_final_bonuses_single_employee(): T = 1 cases = [ (1, [\\"alice 10 None\\"]) ] expected_output = [ [(\\"alice\\", 1000)] ] assert calculate_final_bonuses(T, cases) == expected_output def test_calculate_final_bonuses_two_employees(): T = 1 cases = [ (2, [\\"alice 10 None\\", \\"bob 5 alice\\"]) ] expected_output = [ [(\\"alice\\", 1000), (\\"bob\\", 1500)] ] assert calculate_final_bonuses(T, cases) == expected_output def test_calculate_final_bonuses_no_managers(): T = 1 cases = [ (3, [\\"alice 10 None\\", \\"bob 8 None\\", \\"carol 5 None\\"]) ] expected_output = [ [(\\"alice\\", 1000), (\\"bob\\", 800), (\\"carol\\", 500)] ] assert calculate_final_bonuses(T, cases) == expected_output def test_calculate_final_bonuses_multiple_levels(): T = 1 cases = [ (5, [\\"alice 10 None\\", \\"bob 8 alice\\", \\"carol 15 bob\\", \\"dave 5 carol\\", \\"eve 2 dave\\"]) ] expected_output = [ [(\\"alice\\", 1000), (\\"bob\\", 1800), (\\"carol\\", 3300), (\\"dave\\", 3800), (\\"eve\\", 4000)] ] assert calculate_final_bonuses(T, cases) == expected_output","solution":"def calculate_final_bonuses(T, cases): def compute_bonus(employee, bonuses, managers): if employee not in bonuses: score, manager = employees[employee] bonus = score * 100 if manager != \\"None\\": bonus += compute_bonus(manager, bonuses, managers) bonuses[employee] = bonus return bonuses[employee] results = [] for case in cases: N, employee_data = case employees = {} managers = {} for data in employee_data: employee_id, performance_score, manager_id = data.split() performance_score = int(performance_score) employees[employee_id] = (performance_score, manager_id) if manager_id != \\"None\\": if manager_id not in managers: managers[manager_id] = [] managers[manager_id].append(employee_id) bonuses = {} for employee in employees: compute_bonus(employee, bonuses, managers) sorted_employees = sorted(bonuses.items()) results.append(sorted_employees) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_list): Builds a binary tree from a list of nodes. Parameters: node_list (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers, p, l, and r. Returns: TreeNode: The root of the binary tree. # Optional helper function to implement def is_balanced(root): Checks if a binary tree is balanced. Parameters: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is balanced, False otherwise. # Optional helper function to implement def is_tree_balanced(n, nodes): Determines if the binary tree is balanced. Parameters: n (int): The number of nodes in the binary tree. nodes (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers: the node value, the left child value, and the right child value. A value of -1 indicates no child. Returns: str: \\"YES\\" if the tree is balanced, \\"NO\\" otherwise. if n == 0: return \\"YES\\" tree_nodes = [(p, l, r) for p, l, r in nodes] root = build_tree(tree_nodes) return \\"YES\\" if is_balanced(root) else \\"NO\\" # Example tests def test_case_1(): n = 5 nodes = [ (1, 2, 3), (2, -1, -1), (3, 4, 5), (4, -1, -1), (5, -1, -1) ] assert is_tree_balanced(n, nodes) == \\"YES\\" def test_case_2(): n = 3 nodes = [ (3, 9, 20), (9, -1, -1), (20, 15, 7), (15, -1, -1), (7, -1, -1) ] assert is_tree_balanced(n, nodes) == \\"YES\\" def test_case_3(): n = 3 nodes = [ (1, 2, 3), (2, -1, -1), (3, -1, -1) ] assert is_tree_balanced(n, nodes) == \\"YES\\" def test_case_4(): n = 3 nodes = [ (1, 2, -1), (2, 3, -1), (3, -1, -1) ] assert is_tree_balanced(n, nodes) == \\"NO\\" def test_case_5(): n = 6 nodes = [ (1, 2, 3), (2, 4, 5), (3, -1, -1), (4, -1, -1), (5, -1, 6), (6, -1, -1) ] assert is_tree_balanced(n, nodes) == \\"NO\\"","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_list): if not node_list: return None node_dict = {val: TreeNode(val) for val, left, right in node_list} root = node_dict[node_list[0][0]] for val, left, right in node_list: if left != -1: node_dict[val].left = node_dict[left] if right != -1: node_dict[val].right = node_dict[right] return root def is_balanced(root): def check_height(node): if not node: return 0 left_height = check_height(node.left) if left_height == -1: return -1 right_height = check_height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1 def is_tree_balanced(n, nodes): if n == 0: return \\"YES\\" tree_nodes = [(p, l, r) for p, l, r in nodes] root = build_tree(tree_nodes) return \\"YES\\" if is_balanced(root) else \\"NO\\""},{"question":"def sum_of_squares(int_list): Returns the sum of the squares of each integer in the given list. >>> sum_of_squares([1, 2, 3, 4]) 30 >>> sum_of_squares([0, 2, 3]) 13 >>> sum_of_squares([-1, -2, -3]) 14 >>> sum_of_squares([-1, 2, -3, 4]) 30 >>> sum_of_squares([]) 0","solution":"def sum_of_squares(int_list): Returns the sum of the squares of each integer in the given list. return sum(x ** 2 for x in int_list)"},{"question":"def longest_palindromic_subsequence_length(s): Returns the length of the longest palindromic subsequence in a string s. pass def solve(input_data): Processes the input data to find the longest palindromic subsequence for each test case. >>> solve(\\"2n6nabcbabn3naaa\\") [5, 3] >>> solve(\\"1n1na\\") [1] >>> solve(\\"1n5naaaaa\\") [5] >>> solve(\\"1n4nabcd\\") [1] >>> solve(\\"1n10nabracadabra\\") [7] >>> solve(\\"3n7nracecarn6nabcdefn5ndeed\\") [7, 1, 4] pass","solution":"def longest_palindromic_subsequence_length(s): Returns the length of the longest palindromic subsequence in a string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve(input_data): Processes the input data to find the longest palindromic subsequence for each test case. data = input_data.split() T = int(data[0]) index = 1 results = [] for _ in range(T): n = int(data[index]) s = data[index + 1] index += 2 results.append(longest_palindromic_subsequence_length(s)) return results"},{"question":"def is_production_goal_met(N, H, C, efficiencies) -> str: Determines if the factory meets the daily widget production goal. Parameters: N (int): Number of machines H (int): Number of hours the factory operates in a day C (int): Daily widget production goal efficiencies (list): List of efficiencies of the machines Returns: str: 'Yes' if the production goal is met or exceeded, otherwise 'No' # Unit Tests def test_production_goal_met(): assert is_production_goal_met(5, 8, 1000, [10, 20, 30, 40, 50]) == 'Yes' def test_production_goal_not_met(): assert is_production_goal_met(3, 5, 500, [10, 20, 30]) == 'No' def test_production_goal_exactly_met(): assert is_production_goal_met(4, 10, 1000, [25, 25, 25, 25]) == 'Yes' def test_single_machine_high_efficency(): assert is_production_goal_met(1, 24, 2400, [100]) == 'Yes' def test_single_machine_low_efficiency(): assert is_production_goal_met(1, 8, 100, [10]) == 'No'","solution":"def is_production_goal_met(N, H, C, efficiencies): Determines if the factory meets the daily widget production goal. Parameters: N (int): Number of machines H (int): Number of hours the factory operates in a day C (int): Daily widget production goal efficiencies (list): List of efficiencies of the machines Returns: str: 'Yes' if the production goal is met or exceeded, otherwise 'No' total_production = sum(efficiencies) * H if total_production >= C: return 'Yes' else: return 'No'"},{"question":"def can_form_palindrome(s: str, k: int) -> bool: Determine if you can rearrange the characters in the string to form a palindrome with at most k replacements. >>> can_form_palindrome(\\"aabbcc\\", 0) -> True >>> can_form_palindrome(\\"aabbcc\\", 2) -> True >>> can_form_palindrome(\\"aabbccc\\", 1) -> True >>> can_form_palindrome(\\"aabbccd\\", 1) -> True >>> can_form_palindrome(\\"abc\\", 1) -> False","solution":"def can_form_palindrome(s, k): from collections import Counter count = Counter(s) odd_counts = sum(1 for val in count.values() if val % 2 != 0) # For a string to be rearranged as a palindrome, at most one character can have an odd count if odd_counts == 0: return True else: # In a palindrome, there can be at most one character with an odd frequency return k >= (odd_counts - 1)"},{"question":"def longest_subarray_with_sum_not_exceeding_k(arr: List[int], k: int) -> int: Find the length of the longest contiguous subarray such that the sum of the elements in the subarray does not exceed a given integer k. Args: arr (List[int]): The list of integers representing the array. k (int): The maximum allowed sum for the subarray. Returns: int: The length of the longest contiguous subarray with sum not exceeding k. Examples: >>> longest_subarray_with_sum_not_exceeding_k([1, 2, 3, 4, 5, 6], 15) 5 >>> longest_subarray_with_sum_not_exceeding_k([4, 3, 5, 2, 1], 7) 2 from solution import longest_subarray_with_sum_not_exceeding_k def test_example_1(): arr = [1, 2, 3, 4, 5, 6] k = 15 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 5 def test_example_2(): arr = [4, 3, 5, 2, 1] k = 7 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 2 def test_single_element(): arr = [5] k = 5 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 1 k = 4 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 0 def test_all_equal_elements(): arr = [2, 2, 2, 2] k = 5 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 2 def test_large_k(): arr = [1, 2, 3, 4, 5] k = 100 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 5 def test_no_continuous_subarray(): arr = [10, 20, 30] k = 5 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 0 def test_subarray_at_the_end(): arr = [20, 30, 10, 5, 5, 1] k = 11 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 3 def test_subarray_at_the_beginning(): arr = [1, 2, 3, 10, 20, 30] k = 6 assert longest_subarray_with_sum_not_exceeding_k(arr, k) == 3","solution":"def longest_subarray_with_sum_not_exceeding_k(arr, k): Returns the length of the longest contiguous subarray such that the sum of the elements in the subarray does not exceed k. n = len(arr) start = 0 current_sum = 0 max_length = 0 for end in range(n): current_sum += arr[end] while current_sum > k: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def removeDuplicates(S: str) -> str: Removes duplicates from the string such that each character appears only once and returns the resultant string in lexicographical order. >>> removeDuplicates(\\"bcabc\\") \\"abc\\" >>> removeDuplicates(\\"cbacdcbc\\") \\"acdb\\"","solution":"def removeDuplicates(S): Removes duplicates from the string such that each character appears only once and returns the resultant string in lexicographical order. # Getting the unique characters in sorted order unique_chars = sorted(set(S)) return ''.join(unique_chars)"},{"question":"def maxCoins(balloons: List[int]) -> int: Calculate the maximum points that can be achieved by bursting balloons in an optimal manner. >>> maxCoins([3, 1, 5, 8]) 167 >>> maxCoins([1]) 1 >>> maxCoins([1, 5]) 10 >>> maxCoins([3, 1, 5]) 35 >>> maxCoins([1, 2, 3, 4, 5]) 110 >>> maxCoins([5, 4, 3, 2, 1]) 110 >>> maxCoins([2, 4, 2, 4]) 76","solution":"def maxCoins(balloons): if not balloons: return 0 # Add 1 both ends for easier calculation balloons = [1] + balloons + [1] n = len(balloons) dp = [[0] * n for _ in range(n)] # length is the range we are calculating, it varies from 2 to n for length in range(2, n): for left in range(0, n - length): right = left + length # calculate maxCoins for balloons[left:right+1] for i in range(left + 1, right): dp[left][right] = max(dp[left][right], balloons[left] * balloons[i] * balloons[right] + dp[left][i] + dp[i][right]) return dp[0][n-1]"},{"question":"def max_difference(n: int, seq: List[int]) -> int: Computes the maximum difference between two elements in a sequence such that the larger element comes after the smaller one. :param n: integer, number of elements in the sequence :param seq: list of integers, the sequence of elements :return: integer, the maximum difference or -1 if no such pair exists Examples: >>> max_difference(6, [1, 2, 90, 10, 110, 5]) == 109 >>> max_difference(5, [10, 8, 5, 3, 1]) == -1 from solution import max_difference def test_example_cases(): assert max_difference(6, [1, 2, 90, 10, 110, 5]) == 109 assert max_difference(5, [10, 8, 5, 3, 1]) == -1 def test_no_elements(): assert max_difference(0, []) == -1 def test_one_element(): assert max_difference(1, [10]) == -1 def test_two_elements(): assert max_difference(2, [2, 3]) == 1 assert max_difference(2, [3, 2]) == -1 def test_large_sequence(): assert max_difference(5, [1, 2, 3, 4, 5]) == 4 def test_same_elements(): assert max_difference(5, [7, 7, 7, 7, 7]) == -1 def test_negative_elements(): assert max_difference(5, [-10, -3, -1, -7, 0]) == 10","solution":"def max_difference(n, seq): Computes the maximum difference between two elements in a sequence such that the larger element comes after the smaller one. :param n: integer, number of elements in the sequence :param seq: list of integers, the sequence of elements :return: integer, the maximum difference or -1 if no such pair exists if n < 2: return -1 min_element = seq[0] max_diff = -1 for i in range(1, n): if seq[i] > min_element: max_diff = max(max_diff, seq[i] - min_element) min_element = min(min_element, seq[i]) return max_diff"},{"question":"def max_books(bookList: List[Tuple[int, int]]) -> int: Returns the maximum number of books that Sarah can read without overlapping times. Args: bookList (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end times of a book. Returns: int: The maximum number of books Sarah can read without overlapping. Examples: >>> max_books([(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_books([(1, 3), (2, 5), (4, 6)]) 2 >>> max_books([(1, 4), (2, 3), (3, 5), (4, 6)]) 2 pass from typing import List, Tuple def test_no_overlapping_books(): assert max_books([(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 def test_with_overlapping_books(): assert max_books([(1, 3), (2, 5), (4, 6)]) == 2 def test_multiple_overlapping_books(): assert max_books([(1, 4), (2, 3), (3, 5), (4, 6)]) == 2 def test_no_books(): assert max_books([]) == 0 def test_all_books_same_time(): assert max_books([(1, 2), (1, 2), (1, 2)]) == 1 def test_large_intervals(): assert max_books([(1, 10), (2, 7), (8, 11), (10, 15)]) == 2 def test_single_book(): assert max_books([(1, 5)]) == 1","solution":"def max_books(bookList): Returns the maximum number of books that can be read without overlapping times. # Sort books by their end time bookList.sort(key=lambda x: x[1]) max_books_read = 0 current_end_time = 0 for start_time, end_time in bookList: if start_time >= current_end_time: max_books_read += 1 current_end_time = end_time return max_books_read"},{"question":"def longestArithmeticSequence(arr): Function to find the length of the longest arithmetic sequence where the difference between consecutive elements is the same. >>> longestArithmeticSequence([1, 7, 10, 13, 14, 19]) 4 >>> longestArithmeticSequence([10, 20, 30, 40, 50]) 5 >>> longestArithmeticSequence([5]) 1 >>> longestArithmeticSequence([3, 5]) 2 >>> longestArithmeticSequence([2, 2, 2, 2, 2]) 5 >>> longestArithmeticSequence([1, 2, 4, 8, 16]) 2 >>> longestArithmeticSequence(list(range(1, 1001))) 1000 >>> longestArithmeticSequence([1, 7, 3, 8, 7, 15, 6, 9, 11, 7, 10, 13, 14, 19, 20, 22]) 4","solution":"def longestArithmeticSequence(arr): Function to find the length of the longest arithmetic sequence where the difference between consecutive elements is the same. if not arr: return 0 n = len(arr) if n == 1: return 1 dp = [{} for _ in range(n)] max_length = 1 for i in range(n): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"def min_weeks_to_accommodate(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: For each test case, calculate and return the minimum number of weeks required to ensure that all members can attend at least one session. Args: - T (int): The number of test cases. - test_cases (list of tuples): Each tuple contains two integers P and M. Returns: - list of int: The minimum number of weeks required for each test case. >>> min_weeks_to_accommodate(3, [(5, 5), (7, 4), (8, 3)]) [1, 2, 3] >>> min_weeks_to_accommodate(2, [(10, 2), (100, 10)]) [5, 10]","solution":"import math def min_weeks_to_accommodate(T, test_cases): For each test case, calculate and return the minimum number of weeks required to ensure that all members can attend at least one session. Args: - T (int): The number of test cases. - test_cases (list of tuples): Each tuple contains two integers P and M. Returns: - list of int: The minimum number of weeks required for each test case. results = [] for P, M in test_cases: results.append(math.ceil(P / M)) return results"},{"question":"def count_distinct_block_lengths(n: int, s: str) -> tuple: Counts the number of distinct block lengths for '1' and '0' blocks in the binary string s. Parameters: n (int): Length of the binary string. s (str): Binary string of length n. Returns: tuple: A tuple containing two integers: - The number of distinct '1' block lengths. - The number of distinct '0' block lengths. >>> count_distinct_block_lengths(10, \\"1100011110\\") (2, 2) >>> count_distinct_block_lengths(5, \\"00000\\") (0, 1) from solution import count_distinct_block_lengths def test_example_1(): assert count_distinct_block_lengths(10, \\"1100011110\\") == (2, 2) def test_example_2(): assert count_distinct_block_lengths(5, \\"00000\\") == (0, 1) def test_all_ones(): assert count_distinct_block_lengths(6, \\"111111\\") == (1, 0) def test_all_zeros(): assert count_distinct_block_lengths(7, \\"0000000\\") == (0, 1) def test_alternating_ones_and_zeros(): assert count_distinct_block_lengths(8, \\"10101010\\") == (1, 1) def test_mixed_blocks(): assert count_distinct_block_lengths(12, \\"101110000111\\") == (2, 2) def test_empty_string(): assert count_distinct_block_lengths(0, \\"\\") == (0, 0) def test_single_character_1(): assert count_distinct_block_lengths(1, \\"1\\") == (1, 0) def test_single_character_0(): assert count_distinct_block_lengths(1, \\"0\\") == (0, 1)","solution":"def count_distinct_block_lengths(n, s): Counts the number of distinct block lengths for '1' and '0' blocks in the binary string s. Parameters: n (int): Length of the binary string. s (str): Binary string of length n. Returns: tuple: A tuple containing two integers: - The number of distinct '1' block lengths. - The number of distinct '0' block lengths. if n == 0: return (0, 0) one_block_lengths = set() zero_block_lengths = set() current_char = s[0] current_length = 1 for i in range(1, n): if s[i] == current_char: current_length += 1 else: if current_char == '1': one_block_lengths.add(current_length) else: zero_block_lengths.add(current_length) current_char = s[i] current_length = 1 # Add the last block after the loop if current_char == '1': one_block_lengths.add(current_length) else: zero_block_lengths.add(current_length) return (len(one_block_lengths), len(zero_block_lengths))"},{"question":"def max_sum_after_operations(t: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Calculate the maximum possible sum of the array A after performing optimal subarray reversals. >>> max_sum_after_operations(2, [((5, 3), [-1, -2, 3, 4, -5]), ((4, 2), [1, 2, 3, 4])]) [9, 10] >>> max_sum_after_operations(1, [((5, 2), [1, -1, 1, -1, 1])]) [3] >>> max_sum_after_operations(1, [((6, 3), [-1, -2, -3, -4, -5, -6])]) [0] >>> max_sum_after_operations(3, [((1, 1), [0]), ((2, 2), [-1, 1]), ((3, 2), [-1, 2, 3])]) [0, 1, 5] >>> max_sum_after_operations(1, [((7, 3), [1, 2, 3, -4, -5, 6, 7])]) [19]","solution":"def max_sum_after_operations(t, cases): results = [] for i in range(t): n, k = cases[i][0] a = cases[i][1] # Since reversing won't affect the sum of the absolute values, # we can simply sum all positive numbers to get the maximum sum max_sum = sum(x for x in a if x > 0) results.append(max_sum) return results"},{"question":"def number_of_medals(N: int, scores: List[int]) -> int: Returns the number of medals distributed to the top 3 highest scorers. If there are ties in the top scores, they all receive medals. >>> number_of_medals(7, [50, 30, 50, 80, 80, 30, 60]) 5 >>> number_of_medals(5, [0, 0, 0, 0, 0]) 5 from typing import List def test_number_of_medals(): assert number_of_medals(7, [50, 30, 50, 80, 80, 30, 60]) == 5 assert number_of_medals(5, [0, 0, 0, 0, 0]) == 5 assert number_of_medals(10, [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]) == 3 assert number_of_medals(4, [100, 100, 100, 100]) == 4 assert number_of_medals(3, [10, 20, 30]) == 3 assert number_of_medals(0, []) == 0 assert number_of_medals(1, [90]) == 1 assert number_of_medals(5, [50, 30, 50, 50, 30]) == 5 assert number_of_medals(6, [100, 100, 90, 90, 80, 80]) == 6","solution":"def number_of_medals(N, scores): Returns the number of medals distributed to the top 3 highest scorers. if there are ties in the top scores, they all receive medals. if N == 0: return 0 # Find the top 3 unique scores unique_scores = list(set(scores)) unique_scores.sort(reverse=True) # Consider case where there might be less than 3 unique scores top_3_scores = unique_scores[:min(3, len(unique_scores))] # Count how many participants have scores in the top 3 medal_count = sum(scores.count(score) for score in top_3_scores) return medal_count"},{"question":"def count_pairs_with_sum_k(array: List[int], k: int) -> int: Given an array of integers and a value \`k\`, return the number of distinct pairs (i, j) (where i != j) such that the sum of the elements at indexes \`i\` and \`j\` is equal to \`k\`. Parameters: array (list): List of integers. k (int): Target sum. Returns: int: Number of distinct pairs whose elements sum to \`k\`. >>> count_pairs_with_sum_k([1, 5, 3, 3, 3, 1], 6) 2 >>> count_pairs_with_sum_k([1, 2, 3, 4, 5], 5) 2 >>> count_pairs_with_sum_k([1, 1, 1, 1], 2) 1 >>> count_pairs_with_sum_k([1, 2, 3, 4], 7) 1 >>> count_pairs_with_sum_k([2, 4, 6, 8], 10) 2 >>> count_pairs_with_sum_k([], 5) 0 >>> count_pairs_with_sum_k([1], 2) 0 >>> count_pairs_with_sum_k([6, 6, 6, 6], 12) 1 >>> count_pairs_with_sum_k([3, 3, 3, 1, 1, 1], 6) 1 >>> count_pairs_with_sum_k([-1, 1, -2, 2], 0) 2","solution":"def count_pairs_with_sum_k(array, k): Given an array of integers and a value \`k\`, return the number of distinct pairs (i, j) (where i != j) such that the sum of the elements at indexes \`i\` and \`j\` is equal to \`k\`. Parameters: array (list): List of integers. k (int): Target sum. Returns: int: Number of distinct pairs whose elements sum to \`k\`. if len(array) < 2: return 0 seen = {} count = 0 pairs = set() for num in array: complement = k - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen[num] = seen.get(num, 0) + 1 return len(pairs)"},{"question":"def can_achieve_sum(N: int, K: int, beauties: List[int]) -> str: Determines if there exists a continuous subsequence of paintings whose beauty values sum up to K. >>> can_achieve_sum(5, 12, [2, 4, 6, 3, 9]) == \\"Yes\\" >>> can_achieve_sum(4, 15, [1, 2, 3, 4]) == \\"No\\" >>> can_achieve_sum(1, 5, [5]) == \\"Yes\\" >>> can_achieve_sum(1, 5, [4]) == \\"No\\" >>> can_achieve_sum(5, 0, [0, 0, 0, 0, 0]) == \\"Yes\\" >>> can_achieve_sum(5, 1000, [200, 300, 100, 400, 0]) == \\"Yes\\" >>> can_achieve_sum(5, -1000, [-200, -300, -100, -400, 0]) == \\"Yes\\" >>> can_achieve_sum(5, 0, [1, -1, 2, -2, 0]) == \\"Yes\\" pass","solution":"def can_achieve_sum(N, K, beauties): Determines if there exists a continuous subsequence of paintings whose beauty values sum up to K. :param N: int - The number of paintings :param K: int - The target sum of the beauty values :param beauties: list of int - The beauty values of the paintings :return: str - \\"Yes\\" if such a subsequence exists, otherwise \\"No\\" current_sum = 0 sum_dict = {0: -1} for i in range(N): current_sum += beauties[i] if (current_sum - K) in sum_dict: return \\"Yes\\" sum_dict[current_sum] = i return \\"No\\""},{"question":"class TodoItem: def __init__(self, name, priority): self.name = name self.priority = priority self.completed = False class TodoList: def __init__(self): self.todos = [] self.name_to_todo = {} def add(self, name, priority): todo = TodoItem(name, priority) self.todos.append(todo) self.name_to_todo[name] = todo def complete(self, name): if name in self.name_to_todo: self.name_to_todo[name].completed = True def print_active(self): active_todos = [ todo for todo in self.todos if not todo.completed ] active_todos.sort(key=lambda x: (-x.priority, self.todos.index(x))) for todo in active_todos: print(todo.name) def process_commands(commands): Process a list of commands to manage a to-do list. Args: commands (List[str]): A list of commands to execute. Example: >>> commands = [ >>> \\"add build_project 2\\", >>> \\"add write_report 3\\", >>> \\"add read_book 1\\", >>> \\"complete build_project\\", >>> \\"print\\", >>> \\"complete read_book\\" >>> ] >>> process_commands(commands) write_report read_book >>> commands = [ >>> \\"add alpha 1\\", >>> \\"add beta 5\\", >>> \\"add gamma 3\\", >>> \\"complete beta\\", >>> \\"print\\", >>> ] >>> process_commands(commands) gamma alpha","solution":"class TodoItem: def __init__(self, name, priority): self.name = name self.priority = priority self.completed = False class TodoList: def __init__(self): self.todos = [] self.name_to_todo = {} def add(self, name, priority): todo = TodoItem(name, priority) self.todos.append(todo) self.name_to_todo[name] = todo def complete(self, name): if name in self.name_to_todo: self.name_to_todo[name].completed = True def print_active(self): active_todos = [ todo for todo in self.todos if not todo.completed ] active_todos.sort(key=lambda x: (-x.priority, self.todos.index(x))) for todo in active_todos: print(todo.name) def process_commands(commands): todo_list = TodoList() for command in commands: parts = command.split() if parts[0] == \\"add\\": name = parts[1] priority = int(parts[2]) todo_list.add(name, priority) elif parts[0] == \\"complete\\": name = parts[1] todo_list.complete(name) elif parts[0] == \\"print\\": todo_list.print_active()"},{"question":"def max_total_excitement(n): Calculate the maximum possible total excitement level of the tournament. Parameters: n (int): Number of teams in the tournament. Returns: int: Maximum possible total excitement level. >>> max_total_excitement(1) 0 >>> max_total_excitement(2) 1 >>> max_total_excitement(3) 2 >>> max_total_excitement(4) 4 >>> max_total_excitement(5) 6 >>> max_total_excitement(10) 25 >>> max_total_excitement(1000) 250000","solution":"def max_total_excitement(n): Calculate the maximum possible total excitement level of the tournament. Parameters: n (int): Number of teams in the tournament. Returns: int: Maximum possible total excitement level. # The optimal way to maximize excitement is to always pair the highest # and lowest available team numbers in each match. total_excitement = 0 while n > 1: total_excitement += (n - 1) n -= 2 return total_excitement"},{"question":"def defangIPaddr(address: str) -> str: Write a function called defangIPaddr that takes a string representing an IP address as an argument and returns a string where every period \\".\\" is replaced with \\"[.]\\". >>> defangIPaddr(\\"192.168.0.1\\") '192[.]168[.]0[.]1' >>> defangIPaddr(\\"1.1.1.1\\") '1[.]1[.]1[.]1' >>> defangIPaddr(\\"123456\\") '123456' >>> defangIPaddr(\\"\\") '' >>> defangIPaddr(\\"192.168.0.\\") '192[.]168[.]0[.]'","solution":"def defangIPaddr(address): Returns a defanged version of the given IP address, replacing every period ('.') with '[.]'. return address.replace('.', '[.]')"},{"question":"def max_point_gain(test_cases): Returns the maximum point gain over any contiguous sequence of rounds for each test case. Using Kadane's algorithm to find the maximum subarray sum. Args: test_cases: List of tuples containing number of rounds and the list of point changes. Returns: List of maximum point gains for each test case. # your code here def process_input_to_cases(input_data): Process the input data and convert it to list of test cases. Args: input_data: A string representing the raw input data. Returns: List of tuples with number of rounds and point changes for each test case. # your code here def format_output(results): Formats the results into a string. Args: results: List of maximum point gains for each test case. Returns: A string formatted to be outputted. # your code here # Example Usage: input_data = 2 5 -2 1 -3 4 -1 7 2 -1 2 3 4 -5 2 test_cases = process_input_to_cases(input_data) results = max_point_gain(test_cases) output = format_output(results) print(output) # Should print the maximum point gains for each test case Unit Test: from solution import max_point_gain, process_input_to_cases, format_output def test_max_point_gain(): assert max_point_gain([(5, [-2, 1, -3, 4, -1])]) == [4] assert max_point_gain([(7, [2, -1, 2, 3, 4, -5, 2])]) == [10] assert max_point_gain([(3, [1, 1, 1]), (4, [-1, -1, -1, -1])]) == [3, -1] assert max_point_gain([(1, [10]), (2, [-2, 3]), (6, [-1, 2, 3, 4, -10, 5])]) == [10, 3, 9] def test_process_input_to_cases(): input_data = 2 5 -2 1 -3 4 -1 7 2 -1 2 3 4 -5 2 expected_output = [ (5, [-2, 1, -3, 4, -1]), (7, [2, -1, 2, 3, 4, -5, 2]), ] assert process_input_to_cases(input_data) == expected_output def test_format_output(): results = [4, 10] assert format_output(results) == \\"4n10\\"","solution":"def max_point_gain(test_cases): Returns the maximum point gain over any contiguous sequence of rounds for each test case. Using Kadane's algorithm to find the maximum subarray sum. Args: test_cases: List of tuples containing number of rounds and the list of point changes. Returns: List of maximum point gains for each test case. results = [] for n, points in test_cases: max_current = max_global = points[0] for i in range(1, n): max_current = max(points[i], max_current + points[i]) if max_current > max_global: max_global = max_current results.append(max_global) return results def process_input_to_cases(input_data): Process the input data and convert it to list of test cases. Args: input_data: A string representing the raw input data. Returns: List of tuples with number of rounds and point changes for each test case. lines = input_data.strip().split('n') T = int(lines[0]) cases = [] index = 1 for _ in range(T): N = int(lines[index]) points = list(map(int, lines[index + 1].split())) cases.append((N, points)) index += 2 return cases def format_output(results): Formats the results into a string. Args: results: List of maximum point gains for each test case. Returns: A string formatted to be outputted. return 'n'.join(map(str, results))"},{"question":"def maxProfit(prices: List[int]) -> int: Compute the maximum profit with at most two transactions in a sequence of stock prices. :param prices: List[int] - list representing the daily prices of a stock :return: int - the maximum profit achievable with at most two transactions >>> maxProfit([3,3,5,0,0,3,1,4]) 6 >>> maxProfit([1,2,3,4,5]) 4 >>> maxProfit([7,6,4,3,1]) 0 >>> maxProfit([]) 0 >>> maxProfit([1]) 0 >>> maxProfit([1, 2]) 1 >>> maxProfit([5, 4, 3, 2, 1]) 0 >>> maxProfit([1, 2, 1, 4, 1, 3]) 5 pass # Replace this line with the solution implementation","solution":"def maxProfit(prices): if not prices: return 0 # Initialize variables for the first and second transaction t1_cost = float('inf') t1_profit = 0 t2_cost = float('inf') t2_profit = 0 for price in prices: # The maximum profit if only one transaction is allowed t1_cost = min(t1_cost, price) t1_profit = max(t1_profit, price - t1_cost) # Reinstate the profit made from the first transaction to the cost of the second transaction t2_cost = min(t2_cost, price - t1_profit) t2_profit = max(t2_profit, price - t2_cost) return t2_profit"},{"question":"import os from collections import Counter, defaultdict def load_training_data(training_directory): Load training data from the given directory and return a dictionary of word frequencies for each genre. Args: training_directory (str): The path to the directory containing training data. Returns: dict: A dictionary where the keys are genre ids and the values are Counter objects containing word frequencies. pass def predict_genre(song_lyrics, genre_words): Predict the genre of a song based on its lyrics. Args: song_lyrics (str): The lyrics of the song. genre_words (dict): A dictionary where the keys are genre ids and the values are Counter objects containing word frequencies. Returns: int: The predicted genre id. pass def classify_song(id, song_name, lyrics): Classify the genre of a song given its id, name, and lyrics. Args: id (int): The song identifier. song_name (str): The name of the song. lyrics (str): The lyrics of the song. Returns: int: The predicted genre id. pass # Unit tests import pytest def test_predict_genre(): genre_words = { 1: Counter({'love': 10, 'baby': 5, 'dance': 3}), 2: Counter({'rock': 10, 'guitar': 4, 'band': 7}), 3: Counter({'jazz': 8, 'saxophone': 5, 'smooth': 2}) } lyrics = \\"baby love baby dance\\" assert predict_genre(lyrics, genre_words) == 1 lyrics = \\"rock guitar band rock band\\" assert predict_genre(lyrics, genre_words) == 2 lyrics = \\"smooth jazz saxophone jazz\\" assert predict_genre(lyrics, genre_words) == 3 lyrics = \\"baby saxophone love band\\" assert predict_genre(lyrics, genre_words) == 1 def test_classify_song(): # This is a placeholder test; should include integration where training data is actually loaded pass","solution":"import os from collections import Counter, defaultdict def load_training_data(training_directory): genres = {\\"Pop\\": 1, \\"Rock\\": 2, \\"Jazz\\": 3} genre_words = defaultdict(Counter) for genre, genre_id in genres.items(): genre_dir = os.path.join(training_directory, genre) for filename in os.listdir(genre_dir): with open(os.path.join(genre_dir, filename), 'r', encoding='utf-8') as file: lines = file.readlines() lyrics = \\" \\".join(line.strip() for line in lines[2:]) words = lyrics.split() genre_words[genre_id].update(words) return genre_words def predict_genre(song_lyrics, genre_words): words = song_lyrics.split() word_frequencies = Counter(words) genre_scores = {genre: 0 for genre in genre_words} for word, count in word_frequencies.items(): for genre, counter in genre_words.items(): genre_scores[genre] += counter[word] * count return max(genre_scores, key=genre_scores.get) # Load training data once # Replace 'path_to_training_directory' with the actual path where the training data is extracted # genre_words = load_training_data('path_to_training_directory') def classify_song(id, song_name, lyrics): # genre_words variable should be available here after loading training data # For example, the function should look like: # return predict_genre(lyrics, genre_words) pass"},{"question":"def find_even_sum_pair(n: int, arr: List[int]) -> Tuple[int, int]: This function finds a pair of indices (i, j) such that the sum of arr[i-1] and arr[j-1] is even (1-based indexing). :param n: Number of scrolls :param arr: List of importance values of the scrolls :return: A tuple (i, j) Examples: >>> find_even_sum_pair(5, [1, 3, 5, 2, 8]) (1, 2) # or any other valid pair >>> find_even_sum_pair(7, [7, 11, 30, 5, 9, 12, 4]) (3, 6) # or any other valid pair # Your implementation here","solution":"def find_even_sum_pair(n, arr): This function finds a pair of indices (i, j) such that the sum of arr[i-1] and arr[j-1] is even (1-based indexing). :param n: Number of scrolls :param arr: List of importance values of the scrolls :return: A tuple (i, j) # Separate the array into indices of even and odd values even_indices = [] odd_indices = [] for idx, value in enumerate(arr): if value % 2 == 0: even_indices.append(idx + 1) # +1 for 1-based index else: odd_indices.append(idx + 1) # It is guaranteed that there is exactly one pair whose sum is even, # so there will be at least one pair of either (even, even) or (odd, odd) if len(even_indices) >= 2: # Return the first two even indices return even_indices[0], even_indices[1] else: # Return the first two odd indices return odd_indices[0], odd_indices[1] # Example usage: # print(find_even_sum_pair(5, [1, 3, 5, 2, 8])) # Output: (1, 2) or (4, 5)"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def is_bipartite_tree(N: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with N nodes, determine if it is possible to color each node with one of two colors, such that no two adjacent nodes share the same color. >>> is_bipartite_tree(3, [(1, 2), (2, 3)]) == \\"YES\\" >>> is_bipartite_tree(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) == \\"YES\\" >>> is_bipartite_tree(1, []) == \\"YES\\" >>> is_bipartite_tree(2, [(1, 2)]) == \\"YES\\" pass # Your code goes here","solution":"from collections import deque, defaultdict def is_bipartite_tree(N, edges): # Create an adjacency list for the graph adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Initialize color array. -1 indicates that the node has not been colored yet. colors = [-1] * (N + 1) # BFS to color the graph def bfs(start): queue = deque([start]) colors[start] = 0 # Color the starting node with color 0 while queue: node = queue.popleft() current_color = colors[node] for neighbor in adj_list[node]: if colors[neighbor] == -1: # If the neighbor hasn't been colored colors[neighbor] = 1 - current_color # Color with the opposite color queue.append(neighbor) elif colors[neighbor] == current_color: # If the neighbor is colored with the same color return False return True for node in range(1, N + 1): if colors[node] == -1: # If the node hasn't been visited yet if not bfs(node): return \\"NO\\" return \\"YES\\""},{"question":"def max_magical_energy(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum magical energy the wizard can collect without drawing the ire of the spirits. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples containing the number of trees and their magical energies for each test case. Returns: List[int]: Maximum magical energy that can be collected for each test case. Example: >>> max_magical_energy(2, [(3, [1, 2, 3]), (4, [2, 1, 4, 5])]) [4, 7]","solution":"def max_magical_energy(t, test_cases): def max_energy_from_trees(n, energies): if n == 0: return 0 if n == 1: return energies[0] if n == 2: return max(energies[0], energies[1]) dp = [0] * n dp[0] = energies[0] dp[1] = max(energies[0], energies[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + energies[i]) return dp[-1] results = [] for test in test_cases: n = test[0] energies = test[1] results.append(max_energy_from_trees(n, energies)) return results"},{"question":"def final_positions(n: int, thresholds: List[int], m: int, weights: List[int]) -> List[int]: Simulate a conveyor belt system to determine the final positions of packages. Each package starts at position 0 and moves to the left (negative direction) or right (positive direction) based on its weight and each segment's threshold. Args: n (int): Number of conveyor segments. thresholds (List[int]): A list of weight thresholds for each conveyor segment. m (int): Number of packages. weights (List[int]): A list of weights of the packages. Returns: List[int]: Final positions of the packages after passing through all conveyor segments. >>> final_positions(3, [5, 3, 4], 4, [6, 2, 5, 1]) [3, -3, 1, -3] >>> final_positions(2, [3, 4], 3, [1, 2, 3]) [-2, -2, -2] >>> final_positions(3, [1, 2, 3], 2, [4, 5]) [3, 3] >>> final_positions(1, [2], 3, [1, 2, 3]) [-1, -1, 1] >>> final_positions(1, [5], 3, [6, 5, 4]) [1, -1, -1] >>> final_positions(2, [3, 5], 2, [3, 5]) [-2, 0] >>> final_positions(0, [], 3, [1, 2, 3]) [0, 0, 0] >>> final_positions(3, [5, 3, 4], 0, []) [] pass","solution":"def final_positions(n, thresholds, m, weights): final_positions = [] for weight in weights: position = 0 for threshold in thresholds: if weight <= threshold: position -= 1 else: position += 1 final_positions.append(position) return final_positions"},{"question":"def find_two_duplicates(n: int, arr: List[int]) -> List[int]: Determine the two integers that appear twice in the array. >>> find_two_duplicates(6, [1, 3, 2, 5, 4, 3, 6, 2]) == [3, 2] >>> find_two_duplicates(4, [1, 2, 3, 4, 1, 2]) == [1, 2] >>> find_two_duplicates(997, list(range(1, 999)) + [500, 750]) == [500, 750] >>> find_two_duplicates(3, [1, 2, 3, 1, 2]) == [1, 2] >>> find_two_duplicates(5, [5, 4, 3, 2, 1, 4, 3]) == [3, 4]","solution":"def find_two_duplicates(n, arr): from collections import Counter count = Counter(arr) duplicates = [item for item, freq in count.items() if freq == 2] return duplicates"},{"question":"def caesar_cipher(text: str, shift: int) -> str: Encrypt the input text using the Caesar cipher algorithm with a given shift. The shift value is an integer that indicates the number of positions each letter in the plaintext should be shifted. Parameters: text (str): The input plaintext string to be encrypted. shift (int): The number of positions each letter should be shifted. Returns: str: The resulting ciphertext after applying the Caesar cipher. Example: >>> caesar_cipher(\\"Hello, World!\\", 3) 'Khoor, Zruog!' >>> caesar_cipher(\\"abc-XYZ\\", 4) 'efg-BCD'","solution":"def caesar_cipher(text, shift): Encrypts the input text using the Caesar cipher algorithm with a given shift. Parameters: text (str): The input plaintext string to be encrypted. shift (int): The number of positions each letter should be shifted. Returns: str: The resulting ciphertext after applying the Caesar cipher. result = [] for char in text: if char.isalpha(): shift_base = ord('A') if char.isupper() else ord('a') result.append(chr((ord(char) - shift_base + shift) % 26 + shift_base)) else: result.append(char) return ''.join(result)"},{"question":"def min_moves_to_equal_array(t: int, test_cases: list) -> list: Given multiple test cases, each consisting of an integer array 'nums' of size 'n', return a list with the minimum number of moves required to make all elements in the array equal. >>> min_moves_to_equal_array(3, [(4, [1, 2, 3, 4]), (2, [7, 7]), (6, [3, 3, 3, 3, 5, 5])]) [4, 0, 4] >>> min_moves_to_equal_array(1, [(4, [1_000_000_000, 999_999_999, 1, 2])]) [999999998] pass","solution":"def min_moves_to_equal_array(t, test_cases): Given multiple test cases, each consisting of an integer array 'nums' of size 'n', return a list with the minimum number of moves required to make all elements in the array equal. results = [] for tc in test_cases: n = tc[0] nums = tc[1] if len(set(nums)) == 1: results.append(0) # All elements are already equal continue # Find the minimum and maximum in the array. When you subtract the minimum from maximum # repeatedly, eventually all differences will be zero. min_num = min(nums) max_num = max(nums) results.append(max_num - min_num) return results"},{"question":"from typing import List def prime_interval(n: int, arr: List[int], queries: List[List[int]]) -> List[str]: Determine whether the sum of elements in given ranges of the array forms a prime number. >>> prime_interval(6, [6, 1, 3, 7, 5, 8], [(1, 3), (2, 6), (4, 4)]) [\\"Not Prime\\", \\"Not Prime\\", \\"Prime\\"] >>> prime_interval(5, [2, 3, 5, 7, 11], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) [\\"Prime\\", \\"Prime\\", \\"Prime\\", \\"Prime\\", \\"Prime\\"] >>> prime_interval(4, [4, 6, 9, 15], [(1, 1), (1, 2), (3, 4), (2, 3)]) [\\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\"] >>> prime_interval(1, [7], [(1, 1)]) [\\"Prime\\"] >>> prime_interval(6, [10**9, 10**9, 10**9, 10**9, 10**9, 10**9], [(1, 6)]) [\\"Not Prime\\"] pass # Implementation goes here","solution":"from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_interval(n: int, arr: List[int], queries: List[List[int]]) -> List[str]: # First we build a prefix sum array for efficient range sum calculations prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] result = [] for li, ri in queries: # Calculate the sum of the range from li to ri range_sum = prefix_sum[ri] - prefix_sum[li - 1] if is_prime(range_sum): result.append(\\"Prime\\") else: result.append(\\"Not Prime\\") return result"},{"question":"def max_valid_structures(a: int, b: int, c: int) -> int: Determines the maximum number of valid structures Alex can form using the given blocks. Parameters: a (int): Number of type A blocks. b (int): Number of type B blocks. c (int): Number of type C blocks. Returns: int: Maximum number of valid structures. >>> max_valid_structures(3, 5, 2) == 2 >>> max_valid_structures(1, 1, 1) == 1 >>> max_valid_structures(5, 5, 5) == 5 >>> max_valid_structures(0, 5, 5) == 0 >>> max_valid_structures(10, 5, 8) == 5","solution":"def max_valid_structures(a, b, c): Determines the maximum number of valid structures Alex can form using the given blocks. Parameters: a (int): Number of type A blocks. b (int): Number of type B blocks. c (int): Number of type C blocks. Returns: int: Maximum number of valid structures. return min(a, b, c)"},{"question":"def choose_tables(N: int, C: int) -> List[int]: Simulates the seating process in a cafe and returns the list of occupied table numbers in the order they were chosen. Parameters: N (int): Number of tables C (int): Number of customers Returns: List[int]: List of table numbers chosen by each customer in order of their arrival Example: >>> choose_tables(5, 3) [1, 5, 3] >>> choose_tables(1, 1) [1] >>> choose_tables(5, 5) [1, 5, 3, 2, 4]","solution":"def choose_tables(N, C): Simulates the seating process in a cafe and returns the list of occupied table numbers in the order they were chosen. Parameters: N (int): Number of tables C (int): Number of customers Returns: List[int]: List of table numbers chosen by each customer in order of their arrival # To store the chosen table numbers chosen_tables = [] # Set of occupied tables occupied = set() for _ in range(C): max_distance = -1 chosen_table = -1 for i in range(1, N + 1): if i not in occupied: # Find the minimum distance to the nearest occupied table min_distance_to_nearest = float('inf') for occupied_table in occupied: min_distance_to_nearest = min(min_distance_to_nearest, abs(i - occupied_table)) # If this table maximizes the distance to the nearest occupied table, # or it's the same distance but a smaller table number, choose this table if min_distance_to_nearest > max_distance or (min_distance_to_nearest == max_distance and i < chosen_table): max_distance = min_distance_to_nearest chosen_table = i # Mark this table as occupied occupied.add(chosen_table) chosen_tables.append(chosen_table) return chosen_tables"},{"question":"def tallest_tower(n, colors): Returns the height of the tallest tower that can be built with given blocks of different colors. :param n: number of different colors of blocks (1 <= n <= 100,000) :param colors: list of n integers where the i-th integer represents the number of blocks of the i-th color (1 <= colors[i] <= 1,000,000) :return: height of the tallest tower pass # Examples # >>> tallest_tower(3, [5, 2, 3]) == 10 # >>> tallest_tower(4, [1, 1, 1, 1]) == 4 # Unit Tests from tallest_tower import tallest_tower def test_tallest_tower_example1(): assert tallest_tower(3, [5, 2, 3]) == 10 def test_tallest_tower_example2(): assert tallest_tower(4, [1, 1, 1, 1]) == 4 def test_tallest_tower_single_color(): assert tallest_tower(1, [10]) == 10 def test_tallest_tower_large_numbers(): assert tallest_tower(2, [1000000, 1000000]) == 2000000 def test_tallest_tower_varied_numbers(): assert tallest_tower(5, [4, 1, 6, 2, 8]) == 21 def test_tallest_tower_edge_case(): assert tallest_tower(100000, [1]*100000) == 100000","solution":"def tallest_tower(n, colors): Returns the height of the tallest tower that can be built with given blocks of different colors. :param n: number of different colors of blocks (1 <= n <= 100,000) :param colors: list of n integers where the i-th integer represents the number of blocks of the i-th color (1 <= colors[i] <= 1,000,000) :return: height of the tallest tower return sum(colors)"},{"question":"def minimize_total_distance(N: int, points: List[Tuple[int, int]]) -> float: Determine the minimum possible total distance from all houses to the optimal road. >>> minimize_total_distance(1, [(1, 2)]) 0.0 >>> minimize_total_distance(3, [(1, 2), (2, 4), (3, 6)]) 0.0 >>> minimize_total_distance(3, [(1, 3), (2, 5), (3, 7)]) # According to linear regression line y = 2x + 1, the distances should be minimized. # Check for very small value close to 0. abs(result) < 1e-6 >>> minimize_total_distance(3, [(1, 1), (1, 2), (1, 3)]) 0.0 >>> minimize_total_distance(3, [(1, 2), (3, 2), (5, 2)]) 0.0","solution":"import numpy as np def minimize_total_distance(N, points): def distance_sum(m, b): return sum( abs(y - (m * x + b)) / np.sqrt(1 + m**2) for x, y in points ) if N == 1: return 0.0 x_coords, y_coords = zip(*points) x_mean = np.mean(x_coords) y_mean = np.mean(y_coords) numerator = sum((x - x_mean) * (y - y_mean) for x, y in points) denominator = sum((x - x_mean)**2 for x in x_coords) if denominator == 0: return 0.0 m = numerator / denominator b = y_mean - m * x_mean return distance_sum(m, b) def process_input_and_call_function(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) points = [] index = 1 for i in range(N): x = int(data[index]) y = int(data[index+1]) points.append((x, y)) index += 2 result = minimize_total_distance(N, points) print(f\\"{result:.6f}\\") if __name__ == \\"__main__\\": process_input_and_call_function()"},{"question":"def dropNumbersToBottom(N: int, M: int, grid: List[List[int]]) -> List[List[int]]: Modifies the grid such that all numbers move to the bottom of their respective columns, leaving empty spaces at the top. :param N: int, number of rows :param M: int, number of columns :param grid: List[List[int]] :return: modified grid >>> dropNumbersToBottom(3, 4, [[-1, 2, 3, -1], [5, -1, -1, 6], [-1, 7, -1, 8]]) [[-1, -1, -1, -1], [-1, 2, -1, 6], [5, 7, 3, 8]] >>> dropNumbersToBottom(4, 3, [[-1, 1, -1], [-1, -1, 2], [3, -1, -1], [4, 5, 6]]) [[-1, -1, -1], [-1, -1, -1], [3, 1, 2], [4, 5, 6]]","solution":"def dropNumbersToBottom(N, M, grid): Modifies the grid such that all numbers move to the bottom of their respective columns, leaving empty spaces at the top. :param N: int, number of rows :param M: int, number of columns :param grid: List[List[int]] :return: modified grid for j in range(M): # Pointer to place the number at the bottom fill_position = N - 1 # Traverse from bottom to top in the current column for i in range(N - 1, -1, -1): if grid[i][j] != -1: # If we find a number, move it to the fill position grid[fill_position][j] = grid[i][j] fill_position -= 1 # Fill the rest of the column with -1 for i in range(fill_position + 1): grid[i][j] = -1 return grid"},{"question":"def count_clusters(m: int, n: int, grid: List[List[int]]) -> int: Count the number of distinct clusters of plants in the farm grid. A cluster is defined as a group of \`1\`s connected horizontally or vertically (not diagonally). Parameters: m (int): Number of rows in the farm grid. n (int): Number of columns in the farm grid. grid (List[List[int]]): Representation of the layout of the farm grid, where \`1\` represents a plot with plants, and \`0\` represents an empty plot. Returns: int: The number of distinct clusters of plants. >>> count_clusters(3, 3, [[1, 1, 0], [0, 1, 0], [1, 0, 1]]) 3 >>> count_clusters(1, 5, [[1, 0, 1, 0, 1]]) 3 >>> count_clusters(5, 1, [[1], [0], [1], [0], [1]]) 3 >>> count_clusters(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> count_clusters(2, 2, [[1, 1], [1, 1]]) 1 >>> count_clusters(4, 5, [[1, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 1, 0, 1]]) 4","solution":"def count_clusters(m, n, grid): def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0: return grid[i][j] = 0 # Mark the cell as visited by setting it to 0 dfs(i + 1, j) # Down dfs(i - 1, j) # Up dfs(i, j + 1) # Right dfs(i, j - 1) # Left num_clusters = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: num_clusters += 1 dfs(i, j) return num_clusters # Sample Usage m, n = 4, 5 grid = [ [1, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 1, 0, 1] ] print(count_clusters(m, n, grid)) # Output: 4"},{"question":"def max_unique_snacks(n: int, k: int, snacks: List[int]) -> int: Returns the maximum number of unique snack types that can be arranged close to the target k, or -1 if it's not possible to have at least k unique types. n: int - total number of snacks k: int - desired unique snack types snacks: List[int] - list of snack types >>> max_unique_snacks(6, 4, [1, 2, 2, 3, 3, 1]) # 3 >>> max_unique_snacks(5, 5, [1, 1, 1, 1, 1]) # 1 >>> max_unique_snacks(4, 2, [1, 2, 1, 2]) # 2 >>> max_unique_snacks(1, 1, [2]) # 1 >>> max_unique_snacks(7, 3, [1, 2, 3, 4, 5, 6, 7]) # 3","solution":"def max_unique_snacks(n, k, snacks): unique_snack_types = set(snacks) unique_count = len(unique_snack_types) if unique_count >= k: return k else: return unique_count # Test cases examples to run the function # print(max_unique_snacks(6, 4, [1, 2, 2, 3, 3, 1])) # Should output 3 # print(max_unique_snacks(5, 5, [1, 1, 1, 1, 1])) # Should output 1"},{"question":"def is_palindrome_possible(n: int, colors: List[str]) -> str: Determines if it's possible to rearrange the gemstones to form a palindromic sequence. Args: n (int): Number of gemstones. colors (list of str): List of gemstone colors. Returns: str: \\"POSSIBLE\\" if a palindromic arrangement is possible, otherwise \\"IMPOSSIBLE\\". Examples: >>> is_palindrome_possible(3, [\\"blue\\", \\"red\\", \\"blue\\"]) \\"POSSIBLE\\" >>> is_palindrome_possible(4, [\\"green\\", \\"red\\", \\"yellow\\", \\"blue\\"]) \\"IMPOSSIBLE\\"","solution":"from collections import Counter def is_palindrome_possible(n, colors): Determines if it's possible to rearrange the gemstones to form a palindromic sequence. Args: n (int): Number of gemstones. colors (list of str): List of gemstone colors. Returns: str: \\"POSSIBLE\\" if a palindromic arrangement is possible, otherwise \\"IMPOSSIBLE\\". color_count = Counter(colors) odd_count = sum(1 for count in color_count.values() if count % 2 != 0) # A palindrome can have at most one color count with an odd number of gemstones if odd_count > 1: return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\""},{"question":"def removeVowels(S, N): This function removes all vowels from the input string S and prints the modified string. Parameters: S (str): Input string containing only lowercase English letters. N (int): Length of the input string. Returns: None # Add implementation here # Unit tests def test_removeVowels_all_vowels(): assert removeVowels(\\"aeiou\\", 5) == None # Expected: \\"\\" def test_removeVowels_no_vowels(): assert removeVowels(\\"bcdfg\\", 5) == None # Expected: \\"bcdfg\\" def test_removeVowels_mixed(): assert removeVowels(\\"hello\\", 5) == None # Expected: \\"hll\\" def test_removeVowels_start_end_vowel(): assert removeVowels(\\"apple\\", 5) == None # Expected: \\"ppl\\" def test_removeVowels_empty_string(): assert removeVowels(\\"\\", 0) == None # Expected: \\"\\" def test_removeVowels_single_character_vowel(): assert removeVowels(\\"a\\", 1) == None # Expected: \\"\\" def test_removeVowels_single_character_consonant(): assert removeVowels(\\"b\\", 1) == None # Expected: \\"b\\"","solution":"def removeVowels(S, N): This function removes all vowels from the input string S and prints the modified string. Parameters: S (str): Input string containing only lowercase English letters. N (int): Length of the input string. Returns: None vowels = {'a', 'e', 'i', 'o', 'u'} result = [char for char in S if char not in vowels] print(''.join(result), end=' ')"},{"question":"from typing import List def vector_magnitude(vector: List[int]) -> float: Calculate the magnitude of a vector in n-dimensional space. Parameters: vector (List[int]): A list of integers representing the vector components. Returns: float: The magnitude of the vector, rounded to two decimal places. Examples: >>> vector_magnitude([3, 4]) 5.0 >>> vector_magnitude([1, 2, 2]) 3.0 >>> vector_magnitude([5, 12]) 13.0 >>> vector_magnitude([0, 0, 0]) 0.0 >>> vector_magnitude([3]) 3.0 >>> vector_magnitude([-3]) 3.0 >>> vector_magnitude([-3, -4]) 5.0 >>> vector_magnitude([-1, -2, -2]) 3.0","solution":"import math from typing import List def vector_magnitude(vector: List[int]) -> float: Calculate the magnitude of a vector in n-dimensional space. Parameters: vector (List[int]): A list of integers representing the vector components. Returns: float: The magnitude of the vector. magnitude = math.sqrt(sum(x**2 for x in vector)) return round(magnitude, 2)"},{"question":"import heapq from typing import List, Tuple def minimal_travel_effort(n: int, m: int, paths: List[Tuple[int, int, int]], s: int, t: int) -> int: Determines the minimal travel effort between two clearings in a forest. Parameters: n (int): Number of clearings. m (int): Number of paths. paths (list of tuples): Each tuple (u, v, w) represents a path between clearings u and v with effort w. s (int): Start clearing. t (int): Destination clearing. Returns: int: The minimal travel effort, or -1 if no path exists. # Create adjacency list and implement Dijkstra's algorithm to find the shortest path. pass # Example test cases def test_example(): n, m = 4, 5 paths = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 2), (1, 4, 6)] s, t = 1, 4 assert minimal_travel_effort(n, m, paths, s, t) == 6 def test_no_path(): n, m = 3, 1 paths = [(1, 2, 1)] s, t = 1, 3 assert minimal_travel_effort(n, m, paths, s, t) == -1 def test_single_path(): n, m = 2, 1 paths = [(1, 2, 5)] s, t = 1, 2 assert minimal_travel_effort(n, m, paths, s, t) == 5 def test_multiple_paths(): n, m = 5, 6 paths = [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (1, 3, 5), (2, 5, 10)] s, t = 1, 5 assert minimal_travel_effort(n, m, paths, s, t) == 8 def test_large_number_of_clearings(): n, m = 1000, 1 paths = [(1, 2, 1)] s, t = 1, 1000 assert minimal_travel_effort(n, m, paths, s, t) == -1","solution":"import heapq def minimal_travel_effort(n, m, paths, s, t): Determines the minimal travel effort between two clearings in a forest. Parameters: n (int): Number of clearings. m (int): Number of paths. paths (list of tuples): Each tuple (u, v, w) represents a path between clearings u and v with effort w. s (int): Start clearing. t (int): Destination clearing. Returns: int: The minimal travel effort, or -1 if no path exists. # Create adjacency list graph = [[] for _ in range(n)] for u, v, w in paths: graph[u-1].append((w, v-1)) graph[v-1].append((w, u-1)) # Dijkstra's algorithm to find the shortest path pq = [(0, s-1)] # (distance, node) distances = {i: float('inf') for i in range(n)} distances[s-1] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue if current_node == t-1: return current_distance visited.add(current_node) for weight, neighbor in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[t-1] == float('inf') else distances[t-1]"},{"question":"from typing import List def shortest_path_in_maze(m: int, n: int, grid: List[List[str]]) -> int: Determine the length of the shortest path from the upper-left corner of the grid (cell (1,1)) to the lower-right corner of the grid (cell (m,n)). If no such path exists, return -1. >>> shortest_path_in_maze(3, 3, [['.', '.', '*'], ['*', '.', '*'], ['.', '.', '.']]) 5 >>> shortest_path_in_maze(3, 3, [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]) -1 >>> shortest_path_in_maze(2, 2, [['.', '*'], ['*', '.']]) -1","solution":"from collections import deque def shortest_path_in_maze(m, n, grid): Returns the length of the shortest path from the upper-left corner (1,1) to the lower-right corner (m,n). If no such path exists, returns -1. if grid[0][0] == '*' or grid[m-1][n-1] == '*': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == m-1 and col == n-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and (new_row, new_col) not in visited: if grid[new_row][new_col] == '.': queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def findLongestSubsequence(arr): Returns the length of the longest subsequence of consecutive integers. >>> findLongestSubsequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> findLongestSubsequence([8, 20, 7, 30]) 2 >>> findLongestSubsequence([5]) 1 >>> findLongestSubsequence([5, 10]) 1 >>> findLongestSubsequence([]) 0 >>> findLongestSubsequence([1, 2, 3, 4, 5]) 5 >>> findLongestSubsequence([10, 5, 12, 3, 55, 30, 2, 11, 4, 3]) 4","solution":"def findLongestSubsequence(arr): Returns the length of the longest subsequence of consecutive integers. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: # Check if it is the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def max_seats(n: int, d: int, seats: List[int]) -> int: Returns the maximum number of seats that can be placed under the given constraints. :param n: int - the number of tables :param d: int - maximum allowed distance between any two consecutive tables :param seats: List[int] - list of integers representing the number of seats available on each table :return: int - maximum number of seats >>> max_seats(5, 10, [3, 5, 8, 2, 6]) 24 >>> max_seats(3, 5, [1, 10, 1]) 12 >>> max_seats(1, 1000, [999]) 999 >>> max_seats(4, 3, [10, 11, 12, 13]) 46 >>> max_seats(6, 10, [8, 6, 4, 3, 2, 5]) 28","solution":"def max_seats(n, d, seats): Returns the maximum number of seats that can be placed under the given constraints. :param n: int - the number of tables :param d: int - maximum allowed distance between any two consecutive tables :param seats: List[int] - list of integers representing the number of seats available on each table :return: int - maximum number of seats total_seats = sum(seats) return total_seats"},{"question":"def remaining_fruits(initial_apples, initial_bananas, initial_cherries, eaten_apples, eaten_bananas, eaten_cherries): Calculates the remaining number of each type of fruit. >>> remaining_fruits(5, 8, 10, 1, 3, 4) (4, 5, 6) >>> remaining_fruits(10, 10, 10, 10, 10, 10) (0, 0, 0) >>> remaining_fruits(15, 20, 25, 0, 0, 0) (15, 20, 25) >>> remaining_fruits(10, 5, 8, 3, 1, 2) (7, 4, 6) >>> remaining_fruits(0, 0, 0, 0, 0, 0) (0, 0, 0)","solution":"def remaining_fruits(initial_apples, initial_bananas, initial_cherries, eaten_apples, eaten_bananas, eaten_cherries): Calculates the remaining number of each type of fruit. Parameters: initial_apples (int): Initial number of apples. initial_bananas (int): Initial number of bananas. initial_cherries (int): Initial number of cherries. eaten_apples (int): Number of apples eaten. eaten_bananas (int): Number of bananas eaten. eaten_cherries (int): Number of cherries eaten. Returns: tuple: A tuple containing the remaining number of apples, bananas, and cherries. remaining_apples = initial_apples - eaten_apples remaining_bananas = initial_bananas - eaten_bananas remaining_cherries = initial_cherries - eaten_cherries return remaining_apples, remaining_bananas, remaining_cherries"},{"question":"def max_happiness(N: int, K: int, stores: List[Tuple[int, int]]) -> int: Maximize happiness by visiting exactly K consecutive stores. >>> max_happiness(5, 3, [(3, 2), (2, 1), (5, 3), (4, 3), (1, 2)]) 29 >>> max_happiness(1, 1, [(1, 1)]) 1 >>> max_happiness(4, 2, [(1, 1), (1, 1), (1, 1), (1, 1)]) 2 >>> max_happiness(5, 2, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 41 >>> max_happiness(5, 3, [(5, 5), (4, 4), (3, 3), (2, 2), (1, 1)]) 50","solution":"def max_happiness(N, K, stores): # Calculate happiness P for each store P = [S * L for S, L in stores] # Calculate the initial sum of the first K stores current_sum = sum(P[:K]) max_sum = current_sum # Use a sliding window to calculate the sum of happiness for each consecutive K-length subarray for i in range(K, N): current_sum += P[i] - P[i - K] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def longest_unique_substring(s: str) -> str: Write a method \`longest_unique_substring(s)\` that takes a string \`s\` as its argument and returns the longest substring of \`s\` that contains only unique characters. In case of ties (i.e., more than one substring of maximum length), return the first one that appears. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke' >>> longest_unique_substring(\\"\\") '' >>> longest_unique_substring(\\"abcdefg\\") 'abcdefg' >>> longest_unique_substring(\\"a\\") 'a' >>> longest_unique_substring(\\"aaaaaaa\\") 'a' >>> longest_unique_substring(\\"aA\\") 'aA' >>> longest_unique_substring(\\"abcadefa\\") 'bcadef'","solution":"def longest_unique_substring(s): Returns the longest substring of \`s\` that contains only unique characters. If there are ties, the first one that appears is returned. if not s: return \\"\\" start, max_len, max_sub = 0, 0, \\"\\" char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_sub = s[start:end + 1] return max_sub"},{"question":"def is_unique(s: str) -> bool: Determine whether all characters in the string are unique. Case is ignored during the comparison. >>> is_unique(\\"abcdef\\") True >>> is_unique(\\"AaBbCc\\") False >>> is_unique(\\"123456\\") True >>> is_unique(\\"123451\\") False","solution":"def is_unique(s): Determines whether all characters in the string are unique. Case is ignored during the comparison. s = s.lower() # Convert the string to lowercase to handle case insensitivity for i in range(len(s)): for j in range(i + 1, len(s)): if s[i] == s[j]: return False return True"},{"question":"def find_employee(T, records, Q): Finds the employee with the given ID and returns their name and department. Parameters: - T: int, number of employee records. - records: list of tuples, where each tuple contains (ID, Name, Department). - Q: int, ID of the employee to find. Returns: - str: \\"Name Department\\" for the employee with the given ID. - If the employee ID is not found, returns \\"Employee not found\\". >>> find_employee(3, [(1, \\"Alice\\", \\"HR\\"), (2, \\"Bob\\", \\"IT\\"), (3, \\"Charlie\\", \\"Marketing\\")], 2) 'Bob IT' >>> find_employee(3, [(1, \\"Alice\\", \\"HR\\"), (2, \\"Bob\\", \\"IT\\"), (3, \\"Charlie\\", \\"Marketing\\")], 4) 'Employee not found' >>> find_employee(3, [(1, \\"Alice\\", \\"HR\\"), (2, \\"Bob\\", \\"IT\\"), (3, \\"Charlie\\", \\"Marketing\\")], 1) 'Alice HR' >>> find_employee(3, [(1, \\"Alice\\", \\"HR\\"), (2, \\"Bob\\", \\"IT\\"), (3, \\"Charlie\\", \\"Marketing\\")], 3) 'Charlie Marketing' >>> find_employee(1, [(1, \\"Alice\\", \\"HR\\")], 1) 'Alice HR' >>> find_employee(1, [(1, \\"Alice\\", \\"HR\\")], 2) 'Employee not found'","solution":"def find_employee(T, records, Q): Finds the employee with the given ID and returns their name and department. Parameters: - T: int, number of employee records. - records: list of tuples, where each tuple contains (ID, Name, Department). - Q: int, ID of the employee to find. Returns: - str: \\"Name Department\\" for the employee with the given ID. - If the employee ID is not found, returns \\"Employee not found\\". employee_dict = {record[0]: record[1:] for record in records} if Q in employee_dict: name, department = employee_dict[Q] return f\\"{name} {department}\\" else: return \\"Employee not found\\" # Example usage: # T = 3 # records = [(1, \\"Alice\\", \\"HR\\"), (2, \\"Bob\\", \\"IT\\"), (3, \\"Charlie\\", \\"Marketing\\")] # Q = 2 # print(find_employee(T, records, Q)) # Output: \\"Bob IT\\""},{"question":"import bisect from typing import List def running_median(n: int, nums: List[int]) -> List[float]: Calculate the median after each insertion in the array. Args: n: int - number of elements nums: List[int] - the elements of the array Returns: List[float] - a list containing the median after each insertion # Unit tests def test_running_median_basic(): n = 3 nums = [2, 1, 5] expected = [2, 1.5, 2] assert running_median(n, nums) == expected def test_running_median_even(): n = 4 nums = [4, 6, 2, 8] expected = [4, 5, 4, 5] assert running_median(n, nums) == expected def test_running_median_single_element(): n = 1 nums = [1] expected = [1] assert running_median(n, nums) == expected def test_running_median_all_same(): n = 4 nums = [5, 5, 5, 5] expected = [5, 5, 5, 5] assert running_median(n, nums) == expected def test_running_median_increasing(): n = 5 nums = [1, 2, 3, 4, 5] expected = [1, 1.5, 2, 2.5, 3] assert running_median(n, nums) == expected def test_running_median_decreasing(): n = 5 nums = [5, 4, 3, 2, 1] expected = [5, 4.5, 4, 3.5, 3] assert running_median(n, nums) == expected def test_running_median_mixed(): n = 6 nums = [10, -1, 2, 8, 5, 7] expected = [10, 4.5, 2, 5, 5, 6] assert running_median(n, nums) == expected","solution":"import bisect def running_median(n, nums): Calculate the median after each insertion in the array. Args: n: int - number of elements nums: List[int] - the elements of the array Returns: List[float] - a list containing the median after each insertion result = [] current_list = [] for i in range(n): bisect.insort(current_list, nums[i]) size = len(current_list) if size % 2 == 1: # odd number of elements median = current_list[size // 2] else: # even number of elements median = (current_list[(size // 2) - 1] + current_list[size // 2]) / 2 result.append(median) return result"},{"question":"def is_palindrome(s: str) -> str: Determine if the string s is a palindrome. Returns \\"Yes\\" for palindrome and \\"No\\" otherwise. >>> is_palindrome(\\"radar\\") \\"Yes\\" >>> is_palindrome(\\"coder\\") \\"No\\"","solution":"def is_palindrome(s): Determine if the string s is a palindrome. Returns \\"Yes\\" for palindrome and \\"No\\" otherwise. return \\"Yes\\" if s == s[::-1] else \\"No\\""},{"question":"def has_odd_sum_subsequence(n: int, sequence: List[int]) -> str: Determines if there exists a contiguous subsequence whose sum is an odd number. The function takes an integer n and a list of integers sequence, and returns \\"YES\\" if a contiguous subsequence with an odd sum exists, otherwise returns \\"NO\\". >>> has_odd_sum_subsequence(5, [1, 2, 3, 4, 5]) 'YES' >>> has_odd_sum_subsequence(4, [2, 4, 6, 8]) 'NO' from solution import has_odd_sum_subsequence def test_has_odd_sum_subsequence_example_cases(): assert has_odd_sum_subsequence(5, [1, 2, 3, 4, 5]) == \\"YES\\" assert has_odd_sum_subsequence(4, [2, 4, 6, 8]) == \\"NO\\" def test_all_even_numbers(): assert has_odd_sum_subsequence(3, [2, 4, 6]) == \\"NO\\" assert has_odd_sum_subsequence(6, [2, 12, 4, 6, 8, 10]) == \\"NO\\" def test_contains_single_odd_number(): assert has_odd_sum_subsequence(1, [1]) == \\"YES\\" assert has_odd_sum_subsequence(2, [2, 1]) == \\"YES\\" def test_mixed_numbers(): assert has_odd_sum_subsequence(3, [4, 5, 6]) == \\"YES\\" assert has_odd_sum_subsequence(4, [3, 4, 5, 6]) == \\"YES\\" def test_all_odd_numbers(): assert has_odd_sum_subsequence(3, [1, 3, 5]) == \\"YES\\" assert has_odd_sum_subsequence(5, [7, 11, 13, 17, 19]) == \\"YES\\" def test_large_input(): large_even_seq = [2] * 10**5 large_odd_seq = [1] + [2] * (10**5 - 1) assert has_odd_sum_subsequence(10**5-1, large_even_seq) == \\"NO\\" assert has_odd_sum_subsequence(10**5, large_odd_seq) == \\"YES\\"","solution":"def has_odd_sum_subsequence(n, sequence): Determines if there exists a contiguous subsequence whose sum is an odd number. :param n: int - the number of elements in the sequence :param sequence: list of int - the sequence of numbers :return: str - \\"YES\\" if such a subsequence exists, \\"NO\\" otherwise # Check if any odd number exists in the sequence for num in sequence: if num % 2 != 0: return \\"YES\\" # If no odd number exists, return \\"NO\\" return \\"NO\\""},{"question":"def find_peak_point(grid: List[List[int]], n: int, m: int) -> Tuple[int, int]: You are given a grid of size n x m where each cell contains an integer that denotes the height of a building. You need to identify a point on the grid such that the height at that point is greater than or equal to the height of its neighboring points (i.e., left, right, up, and down). If there are multiple such points, you may output any one of them. >>> find_peak_point([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3) (2, 2) >>> find_peak_point([[10, 10, 10, 10], [10, 15, 14, 10], [10, 14, 15, 10], [10, 10, 10, 10]], 4, 4) (1, 1) >>> find_peak_point([[5, 5], [5, 5]], 2, 2) (0, 0)","solution":"def find_peak_point(grid, n, m): def is_peak(i, j): Determines if grid[i][j] is a peak neighbors = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] for ni, nj in neighbors: if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] > grid[i][j]: return False return True for i in range(n): for j in range(m): if is_peak(i, j): return i, j return -1, -1 def parse_input_and_find_peak(input_string): data = input_string.strip().split('n') n, m = map(int, data[0].split()) grid = [list(map(int, row.split())) for row in data[1:]] return find_peak_point(grid, n, m)"},{"question":"def magical_forest(N, fruits, M, actions): In a magical forest, there are N mystical trees standing in a row, and each tree has a certain number of magical fruits. The trees are numbered from 1 to N, and the number of magical fruits on each tree is initially provided. A group of three elves regularly visit this forest to either collect magical fruits from a range of trees or to add more magical fruits to a specific tree. Args: N: int, the total number of trees. fruits: List[int], the initial number of magical fruits on each tree. M: int, the number of actions performed by the elves. actions: List[str], list of actions in one of the following forms: \\"1 x y\\", \\"2 x v\\", \\"3 x\\". Returns: List: Results of the queried actions. # Your code here # Example usage and test cases def test_sample_input(): N = 5 fruits = [3, 8, 5, 6, 10] M = 7 actions = [\\"3 2\\", \\"2 3 4\\", \\"1 2 4\\", \\"3 3\\", \\"3 4\\", \\"2 5 15\\", \\"3 5\\"] results = magical_forest(N, fruits, M, actions) assert results == [8, \\"Collected\\", 0, 0, 25] def test_all_zeros(): N = 4 fruits = [0, 0, 0, 0] M = 4 actions = [\\"3 1\\", \\"3 2\\", \\"3 3\\", \\"3 4\\"] results = magical_forest(N, fruits, M, actions) assert results == [0, 0, 0, 0] def test_add_fruits(): N = 3 fruits = [1, 2, 3] M = 3 actions = [\\"2 1 5\\", \\"3 1\\", \\"3 2\\"] results = magical_forest(N, fruits, M, actions) assert results == [6, 2] def test_collect_and_add(): N = 4 fruits = [4, 4, 4, 4] M = 5 actions = [\\"1 1 3\\", \\"3 1\\", \\"3 2\\", \\"3 3\\", \\"2 4 1\\"] results = magical_forest(N, fruits, M, actions) assert results == [\\"Collected\\", 0, 0, 0] def test_mixed_operations(): N = 5 fruits = [5, 10, 15, 20, 25] M = 6 actions = [\\"1 1 2\\", \\"2 3 5\\", \\"3 3\\", \\"3 4\\", \\"2 5 10\\", \\"3 5\\"] results = magical_forest(N, fruits, M, actions) assert results == [\\"Collected\\", 20, 20, 35] # Running the tests test_sample_input() test_all_zeros() test_add_fruits() test_collect_and_add() test_mixed_operations()","solution":"def magical_forest(N, fruits, M, actions): results = [] for action in actions: components = action.split() command = int(components[0]) if command == 1: x, y = int(components[1]), int(components[2]) for i in range(x-1, y): fruits[i] = 0 results.append(\\"Collected\\") elif command == 2: x, v = int(components[1]), int(components[2]) fruits[x-1] += v elif command == 3: x = int(components[1]) results.append(fruits[x-1]) return results # Example usage N = 5 fruits = [3, 8, 5, 6, 10] M = 7 actions = [\\"3 2\\", \\"2 3 4\\", \\"1 2 4\\", \\"3 3\\", \\"3 4\\", \\"2 5 15\\", \\"3 5\\"] print(magical_forest(N, fruits, M, actions))"},{"question":"def has_duplicate_scores(n: int, scores: List[int]) -> str: Determines if there are at least two students with the same score. >>> has_duplicate_scores(5, [45, 78, 89, 45, 66]) 'YES' >>> has_duplicate_scores(5, [45, 78, 89, 67, 66]) 'NO'","solution":"def has_duplicate_scores(n, scores): Returns 'YES' if there are at least two students with the same score, otherwise 'NO'. score_set = set() for score in scores: if score in score_set: return \\"YES\\" score_set.add(score) return \\"NO\\""},{"question":"def is_palindrome(s: str) -> bool: Check if the given string is a palindrome, ignoring spaces and case. >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"Race Car\\") True >>> is_palindrome(\\"hello world\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"No lemon, no melon\\") True def process_test_cases(test_cases: List[str]) -> List[str]: Process multiple test cases to determine if each one is a palindrome. >>> test_cases = [ ... \\"A man a plan a canal Panama\\", ... \\"Race Car\\", ... \\"hello world\\", ... \\"No lemon, no melon\\", ... \\"abcba\\", ... \\"Was it a car or a cat I saw\\" ... ] >>> process_test_cases(test_cases) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_palindrome(s): Check if the given string is a palindrome, ignoring spaces and case. # Remove spaces and convert to lowercase cleaned = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is a palindrome return cleaned == cleaned[::-1] def process_test_cases(test_cases): results = [] for s in test_cases: if is_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def smallest_divisor(num_str: str) -> int: Returns the smallest divisor of the large integer (other than 1) represented as a string. Input: - A single line containing the string representation of the large integer 'num' (1 ≤ length of num ≤ 10^5). Output: - A single integer denoting the smallest divisor of the number (other than 1). Examples: >>> smallest_divisor(\\"123456789101112\\") 2 >>> smallest_divisor(\\"999999999999989\\") 999999999999989","solution":"def smallest_divisor(num_str): Returns the smallest divisor of the large integer (other than 1) represented as a string. num = int(num_str) # Checking divisibility from 2 up to sqrt(num) if num % 2 == 0: return 2 for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return i return num # if no divisor found, the number itself is prime"},{"question":"def total_travel_time(N: int, travel_times: List[int], S: int, E: int) -> int: Calculate the total travel time for a given journey between two specific stations. :param N: Number of stations :param travel_times: List of travel times between consecutive stations :param S: Starting station (1-indexed) :param E: Ending station (1-indexed) :return: Total travel time from S to E >>> total_travel_time(5, [10, 15, 20, 25], 2, 4) 35 >>> total_travel_time(5, [10, 15, 20, 25], 1, 5) 70","solution":"def total_travel_time(N, travel_times, S, E): Returns the total travel time from station S to station E. :param N: Number of stations :param travel_times: List of travel times between consecutive stations :param S: Starting station (1-indexed) :param E: Ending station (1-indexed) :return: Total travel time from S to E return sum(travel_times[S-1:E-1])"},{"question":"def min_max_difficulty_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and their respective difficulties, calculate the smallest possible maximum difficulty difference between any two consecutive problems in the array after rearranging the problems. >>> min_max_difficulty_difference(1, [(3, [1, 4, 7])]) [3] >>> min_max_difficulty_difference(1, [(4, [10, 20, 30, 40])]) [10] >>> min_max_difficulty_difference(1, [(5, [5, 3, 8, 1, 6])]) [1]","solution":"def min_max_difficulty_difference(t, test_cases): results = [] for test_case in test_cases: n, d = test_case d.sort() min_diff = float('inf') for i in range(1, n): min_diff = min(min_diff, d[i] - d[i-1]) results.append(min_diff) return results"},{"question":"def max_shelves_for_items(n, shelves, m, items, k): Determine the maximum number of shelves that can accommodate all k items without exceeding the weight capacity and ensuring the items fit within the height of the shelf. Parameters: n (int): Number of shelves shelves (List[Tuple[int, int]]): List of tuples with each tuple containing the weight capacity and height of a shelf m (int): Number of items items (List[Tuple[int, int]]): List of tuples with each tuple containing the weight and height requirement of an item k (int): Number of items you want to place on the shelves Returns: int: Maximum number of shelves that can accommodate all k items Example: >>> n = 5 >>> shelves = [(100, 50), (200, 75), (150, 60), (180, 100), (120, 80)] >>> m = 6 >>> items = [(50, 40), (70, 50), (80, 60), (60, 45), (90, 70), (40, 35)] >>> k = 4 >>> max_shelves_for_items(n, shelves, m, items, k) 3","solution":"def max_shelves_for_items(n, shelves, m, items, k): shelves = sorted(shelves, key=lambda x: x[0]) # Sort shelves by height item_counter = [0] * n # Keeps track of items weight on each shelf max_used_shelves = 0 for i in range(k): item_weight, item_height = items[i] for j in range(n): shelf_capacity, shelf_height = shelves[j] if item_counter[j] + item_weight <= shelf_capacity and item_height <= shelf_height: item_counter[j] += item_weight max_used_shelves = max(max_used_shelves, j + 1) break return max_used_shelves"},{"question":"def process_operations(N: int, Q: int, operations: List[Tuple[str, int, int, int]]) -> List[int]: Processes the operations on the N x N grid and returns the results of the QUERY operations. Args: N: int: size of the grid (N x N) Q: int: number of operations operations: List of tuples containing the operations Returns: List of results from QUERY operations pass # Here are the unit tests for the function def test_process_operations_case_one(): assert process_operations(3, 5, [ (\\"SET\\", 1, 1, 5), (\\"SET\\", 2, 2, 3), (\\"QUERY\\", 1), (\\"SET\\", 1, 3, 7), (\\"QUERY\\", 1) ]) == [5, 12] def test_process_operations_case_two(): assert process_operations(2, 4, [ (\\"SET\\", 1, 1, 1), (\\"SET\\", 1, 2, 2), (\\"QUERY\\", 1), (\\"QUERY\\", 2) ]) == [3, 0] def test_process_operations_case_three(): assert process_operations(4, 3, [ (\\"SET\\", 4, 4, 10), (\\"QUERY\\", 4), (\\"QUERY\\", 1) ]) == [10, 0] def test_process_operations_empty_case(): assert process_operations(1, 1, [ (\\"QUERY\\", 1) ]) == [0]","solution":"def process_operations(N, Q, operations): Processes the operations on the N x N grid and returns the results of the QUERY operations. Args: N: int: size of the grid (N x N) Q: int: number of operations operations: List of tuples containing the operations Returns: List of results from QUERY operations grid = [[0] * N for _ in range(N)] results = [] for operation in operations: op = operation[0] if op == \\"SET\\": _, x, y, v = operation grid[x - 1][y - 1] = v elif op == \\"QUERY\\": _, r = operation results.append(sum(grid[r - 1])) return results"},{"question":"def max_task_value(tasks: List[Tuple[int, int, int]]) -> int: Determine the maximum sum of the values of the selected tasks such that no two tasks overlap. >>> max_task_value([(1, 2, 10)]) 10 >>> max_task_value([(1, 3, 50), (2, 5, 20), (4, 6, 70)]) 120","solution":"from bisect import bisect_right def max_task_value(tasks): # Sort tasks by end time tasks.sort(key=lambda x: x[1]) # Initialize dp array where dp[i] is the max value considering the first i tasks dp = [0] * (len(tasks) + 1) end_times = [task[1] for task in tasks] for i in range(1, len(tasks) + 1): start, end, value = tasks[i-1] # Find the index of last task that doesn't conflict j = bisect_right(end_times, start) dp[i] = max(dp[i-1], dp[j] + value) return dp[-1] # Example usage: tasks = [ (1, 3, 50), (2, 5, 20), (4, 6, 70) ] print(max_task_value(tasks)) # Output: 120"},{"question":"def process_queries(N: int, values: List[int], edges: List[Tuple[int, int]], queries: List[str]) -> List[int]: Process the given queries on a tree and return the results for each query of type \`2\`. >>> process_queries(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)], [\\"1 3 10\\", \\"2 4\\", \\"2 1\\"]) [14, 1] >>> process_queries(3, [5, 3, 8], [(1, 2), (1, 3)], [\\"1 1 5\\", \\"2 1\\", \\"2 2\\", \\"2 3\\"]) [10, 8, 13] pass","solution":"from collections import defaultdict class Tree: def __init__(self, N, values, edges): self.N = N self.values = values self.children = defaultdict(list) for u, v in edges: self.children[u].append(v) self.children[v].append(u) self.parent = [-1] * (N + 1) self.build_tree(1, -1) def build_tree(self, node, par): self.parent[node] = par for child in self.children[node]: if child != par: self.build_tree(child, node) def increase_subtree(self, node, k): stack = [node] while stack: current = stack.pop() self.values[current-1] += k for child in self.children[current]: if child != self.parent[current]: stack.append(child) def get_value(self, node): return self.values[node-1] def process_queries(N, values, edges, queries): tree = Tree(N, values, edges) results = [] for query in queries: parts = query.split() query_type = int(parts[0]) u = int(parts[1]) if query_type == 1: k = int(parts[2]) tree.increase_subtree(u, k) elif query_type == 2: results.append(tree.get_value(u)) return results"},{"question":"from typing import List def process_commands(commands: List[str]) -> List[str]: Simulates a simplified plane navigation system. The plane starts at the origin (0, 0) and can receive several commands to change its position or check its current coordinates. Handles the following commands: - \\"move x y\\": moves the plane from its current position to a new position (x, y). - \\"distance x y\\": calculates and returns the Euclidean distance from the plane's current position to the point (x, y). - \\"origin\\": resets the plane's position back to the origin (0, 0). Args: commands (List[str]): List of commands to be processed. Returns: List[str]: Distances computed by the \\"distance\\" command, each rounded to six decimal places. Example: >>> process_commands([ ... \\"move 3 4\\", ... \\"distance 0 0\\", ... \\"move 1 1\\", ... \\"distance 3 3\\", ... \\"origin\\", ... \\"distance 2 2\\" ... ]) [\\"5.000000\\", \\"2.828427\\", \\"2.828427\\"] >>> process_commands([ ... \\"origin\\", ... \\"move 0 0\\", ... \\"distance 1 1\\", ... \\"move -1 -1\\", ... \\"distance 0 0\\" ... ]) [\\"1.414214\\", \\"1.414214\\"]","solution":"from math import sqrt class PlaneNavigation: def __init__(self): self.x = 0 self.y = 0 def move(self, x, y): self.x = x self.y = y def distance(self, x, y): return sqrt((self.x - x) ** 2 + (self.y - y) ** 2) def origin(self): self.x = 0 self.y = 0 def process_commands(commands): plane = PlaneNavigation() results = [] for command in commands: parts = command.split() if parts[0] == \\"move\\": plane.move(int(parts[1]), int(parts[2])) elif parts[0] == \\"distance\\": dist = plane.distance(int(parts[1]), int(parts[2])) results.append(f\\"{dist:.6f}\\") elif parts[0] == \\"origin\\": plane.origin() return results"},{"question":"def check_butterflies(n: int, marked_ids: List[str], m: int, observed_ids: List[str]) -> List[str]: Determine if a marked butterfly has been seen again during the migration. >>> check_butterflies(5, [\\"butterfly1\\", \\"butterfly2\\", \\"butterfly3\\", \\"butterfly4\\", \\"butterfly5\\"], 3, [\\"butterfly2\\", \\"butterfly5\\", \\"butterfly7\\"]) [\\"NO\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> check_butterflies(4, [\\"migrator\\", \\"hibernation\\", \\"monarch\\", \\"skippers\\"], 2, [\\"monarch\\", \\"hibernation\\"]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def check_butterflies(n, marked_ids, m, observed_ids): observed_set = set(observed_ids) result = [\\"YES\\" if id in observed_set else \\"NO\\" for id in marked_ids] return result"},{"question":"def are_almost_equal(n, k, a, b): Determines if arrays a and b are almost equal given the allowed difference k. :param int n: The length of the arrays. :param int k: The maximum number of positions the arrays can differ to be considered almost equal. :param list a: The first array. :param list b: The second array. :return: \\"YES\\" if the arrays are almost equal, otherwise \\"NO\\". :rtype: str pass def process_test_cases(t, test_cases): Processes multiple test cases to determine if the provided pair of arrays are almost equal. :param int t: Number of test cases. :param list test_cases: List of tuples, each containing n, k, a, b. :return: List of \\"YES\\" or \\"NO\\" for each test case. :rtype: list pass def test_are_almost_equal(): assert are_almost_equal(3, 1, [1, 2, 3], [1, 2, 4]) == \\"YES\\" assert are_almost_equal(3, 2, [1, 2, 3], [4, 5, 6]) == \\"NO\\" assert are_almost_equal(5, 3, [1, 2, 3, 4, 5], [1, 2, 4, 4, 5]) == \\"YES\\" assert are_almost_equal(3, 0, [1, 2, 3], [1, 2, 4]) == \\"NO\\" assert are_almost_equal(4, 2, [1, 2, 3, 4], [1, 3, 2, 4]) == \\"YES\\" assert are_almost_equal(4, 1, [1, 2, 3, 4], [1, 3, 2, 4]) == \\"NO\\" def test_process_test_cases(): test_cases = [ (3, 1, [1, 2, 3], [1, 2, 4]), (3, 2, [1, 2, 3], [4, 5, 6]), (5, 3, [1, 2, 3, 4, 5], [1, 2, 4, 4, 5]) ] assert process_test_cases(3, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] test_cases = [ (3, 0, [1, 2, 3], [1, 2, 4]), (4, 2, [1, 2, 3, 4], [1, 3, 2, 4]), (4, 1, [1, 2, 3, 4], [1, 3, 2, 4]) ] assert process_test_cases(3, test_cases) == [\\"NO\\", \\"YES\\", \\"NO\\"]","solution":"def are_almost_equal(n, k, a, b): Determines if arrays a and b are almost equal given the allowed difference k. :param int n: The length of the arrays. :param int k: The maximum number of positions the arrays can differ to be considered almost equal. :param list a: The first array. :param list b: The second array. :return: \\"YES\\" if the arrays are almost equal, otherwise \\"NO\\". :rtype: str diff_count = sum(1 for i in range(n) if a[i] != b[i]) return \\"YES\\" if diff_count <= k else \\"NO\\" def process_test_cases(t, test_cases): Processes multiple test cases to determine if the provided pair of arrays are almost equal. :param int t: Number of test cases. :param list test_cases: List of tuples, each containing n, k, a, b. :return: List of \\"YES\\" or \\"NO\\" for each test case. :rtype: list results = [] for n, k, a, b in test_cases: results.append(are_almost_equal(n, k, a, b)) return results"},{"question":"def is_kaprekar_number(n): Determine if a given number is a Kaprekar number. A Kaprekar number is a non-negative integer, the representation of whose square can be split into two parts that add up to the original number. >>> is_kaprekar_number(45) True >>> is_kaprekar_number(297) True >>> is_kaprekar_number(10) False >>> is_kaprekar_number(1) True >>> is_kaprekar_number(0) True >>> is_kaprekar_number(2147483647) False","solution":"def is_kaprekar_number(n): if n < 0: return False n_squared = n**2 str_n_squared = str(n_squared) len_n = len(str(n)) right_part = str_n_squared[-len_n:] left_part = str_n_squared[:-len_n] or '0' return n == int(left_part) + int(right_part)"},{"question":"def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if the given graph is bipartite. Parameters: - n (int): The number of vertices in the graph. - m (int): The number of edges in the graph. - edges (list of tuples): Each tuple represents an edge between two vertices. Returns: - str: \\"YES\\" if the graph is bipartite, otherwise \\"NO\\". >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\"","solution":"def is_bipartite(n, m, edges): Determines if the given graph is bipartite. Parameters: - n (int): The number of vertices in the graph. - m (int): The number of edges in the graph. - edges (list of tuples): Each tuple represents an edge between two vertices. Returns: - str: \\"YES\\" if the graph is bipartite, otherwise \\"NO\\". from collections import deque # Create adjacency list graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize color array color = [-1] * (n + 1) # Function to check if the graph is bipartite using BFS def bfs_check(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(1, n + 1): if color[i] == -1: if not bfs_check(i): return \\"NO\\" return \\"YES\\""},{"question":"def distribute_tasks(N: int, K: int) -> Union[str, Tuple[int, int]]: Determine if it's possible to distribute K tasks among N participants such that the distribution is as even as possible. Parameters: N (int): Number of participants. K (int): Number of tasks. Returns: str or tuple: If possible, returns a tuple of two integers representing the number of participants with greater tasks and fewer tasks. Otherwise, returns \\"NO\\". >>> distribute_tasks(5, 12) (2, 3) >>> distribute_tasks(4, 10) NO","solution":"def distribute_tasks(N, K): Determine if it's possible to distribute K tasks among N participants such that the distribution is as even as possible. Parameters: N (int): Number of participants. K (int): Number of tasks. Returns: str or tuple: If possible, returns tuple of two integers representing the number of participants with greater tasks and fewer tasks. Otherwise, returns \\"NO\\". if K < N: return \\"NO\\" tasks_per_participant = K // N remaining_tasks = K % N num_with_more_tasks = remaining_tasks num_with_less_tasks = N - remaining_tasks return (num_with_more_tasks, num_with_less_tasks)"},{"question":"def max_projects(n: int, k: int, tables_required: List[int], slot_capacities: List[int]) -> int: Determine the maximum number of non-identical projects that can be set up given space constraints. >>> max_projects(5, 3, [2, 3, 5, 1, 4], [5, 5, 3]) 3 >>> max_projects(6, 3, [1, 2, 2, 2, 3, 4], [1, 2, 2]) 3 >>> max_projects(5, 5, [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]) 5 >>> max_projects(3, 2, [10, 10, 10], [1, 1]) 0 >>> max_projects(4, 4, [1, 2, 3, 4], [1, 2, 3, 4]) 4 >>> max_projects(5, 3, [5, 6, 7, 2, 3], [5, 5, 3]) 3 >>> max_projects(5, 0, [2, 3, 5, 1, 4], []) 0 >>> max_projects(0, 5, [], [5, 5, 3, 2, 2]) 0","solution":"def max_projects(n, k, tables_required, slot_capacities): tables_required.sort() slot_capacities.sort() project_count = 0 i = 0 # Index for tables_required j = 0 # Index for slot_capacities while i < n and j < k: if tables_required[i] <= slot_capacities[j]: project_count += 1 j += 1 # Move to the next slot since this one is used i += 1 # Move to the next project return project_count"},{"question":"def is_valid_parentheses(s: str) -> str: Determines if a given string of parentheses is valid. >>> is_valid_parentheses(\\"()\\") \\"YES\\" >>> is_valid_parentheses(\\"([)]\\") \\"NO\\" >>> is_valid_parentheses(\\"{[()]}\\") \\"YES\\"","solution":"def is_valid_parentheses(s): Determines if a given string of parentheses is valid. Args: s (str): a string containing only '(', ')', '{', '}', '[' and ']' Returns: str: \\"YES\\" if the string is valid, otherwise \\"NO\\" stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses: top_element = stack.pop() if stack else '#' if matching_parentheses[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\""},{"question":"def shuffle_count(N: int) -> int: Returns the number of shuffles needed to return the deck to its original order. >>> shuffle_count(6) 4 >>> shuffle_count(2) 1 >>> shuffle_count(4) 2 >>> shuffle_count(8) 3 >>> shuffle_count(10) 6 >>> shuffle_count(12) 10","solution":"def shuffle_count(N): Returns the number of shuffles needed to return the deck to its original order. original_deck = list(range(1, N + 1)) current_deck = original_deck[:] shuffles = 0 while True: mid = (N + 1) // 2 first_half = current_deck[:mid] second_half = current_deck[mid:] shuffled_deck = [] for i in range(mid): shuffled_deck.append(first_half[i]) if i < len(second_half): shuffled_deck.append(second_half[i]) current_deck = shuffled_deck shuffles += 1 if current_deck == original_deck: break return shuffles"},{"question":"def total_tshirts(S: int, M: int, L: int) -> int: Calculates the total number of T-shirts needed. Args: S (int): Number of participants requiring Small T-shirts. M (int): Number of participants requiring Medium T-shirts. L (int): Number of participants requiring Large T-shirts. Returns: int: Total number of T-shirts needed. >>> total_tshirts(150, 200, 100) 450 >>> total_tshirts(3000, 2500, 4500) 10000","solution":"def total_tshirts(S, M, L): Calculates the total number of T-shirts needed. Args: S (int): Number of participants requiring Small T-shirts. M (int): Number of participants requiring Medium T-shirts. L (int): Number of participants requiring Large T-shirts. Returns: int: Total number of T-shirts needed. return S + M + L"},{"question":"from typing import List, Tuple def find_indices(nums: List[int], target: int) -> Tuple[int, int]: Finds two distinct indices such that their values add up to the target. Args: nums (List[int]): A list of integers. target (int): The target sum. Returns: Tuple[int, int]: A tuple of two indices. pass # Test cases def test_example_1(): nums = [2, 7, 11, 15] target = 9 result = find_indices(nums, target) assert result in [(0, 1), (1, 0)], f\\"Unexpected result {result}\\" def test_example_2(): nums = [3, 2, 4] target = 6 result = find_indices(nums, target) assert result in [(1, 2), (2, 1)], f\\"Unexpected result {result}\\" def test_example_3(): nums = [3, 3] target = 6 result = find_indices(nums, target) assert result in [(0, 1), (1, 0)], f\\"Unexpected result {result}\\" def test_negative_numbers(): nums = [-3, 4, 3, 90] target = 0 result = find_indices(nums, target) assert result in [(0, 2), (2, 0)], f\\"Unexpected result {result}\\" def test_large_numbers(): nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10**9+1, 10**9+2] target = 2*10**9+3 result = find_indices(nums, target) assert result in [(9, 10), (10, 9)], f\\"Unexpected result {result}\\" def test_identical_numbers(): nums = [5, 5, 5, 5] target = 10 result = find_indices(nums, target) assert result in [(0, 1), (1, 0), (0, 2), (2, 0), (0, 3), (3, 0), (1, 2), (2, 1), (1, 3), (3, 1), (2, 3), (3, 2)], f\\"Unexpected result {result}\\"","solution":"from typing import List, Tuple def find_indices(nums: List[int], target: int) -> Tuple[int, int]: Finds two distinct indices such that their values add up to the target. Args: nums (List[int]): A list of integers. target (int): The target sum. Returns: Tuple[int, int]: A tuple of two indices. lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return (lookup[complement], i) lookup[num] = i"},{"question":"def encode_message(message): Encode a given message according to the reverse alphabetical order rule and calculate the sum of the encoded values. >>> encode_message(\\"hello\\") 83 >>> encode_message(\\"abc\\") 75 def process_test_cases(t, messages): Process multiple test cases, encoding each message and calculating the sum of the encoded values. >>> process_test_cases(2, [\\"hello\\", \\"abc\\"]) [83, 75] >>> process_test_cases(1, [\\"a\\"]) [26] >>> process_test_cases(3, [\\"a\\", \\"b\\", \\"c\\"]) [26, 25, 24] >>> process_test_cases(1, [\\"\\"]) [0] # Edge case with an empty message","solution":"def encode_message(message): Encode a given message according to the reverse alphabetical order rule and calculate the sum of the encoded values. Args: message (str): The plain text message consisting of lowercase letters only. Returns: int: Sum of the encoded values of the message. return sum(27 - (ord(char) - ord('a') + 1) for char in message) def process_test_cases(t, messages): Process multiple test cases, encoding each message and calculating the sum of the encoded values. Args: t (int): Number of test cases. messages (list): List of plain text messages. Returns: list: List of sums of encoded values for each message. return [encode_message(message) for message in messages]"},{"question":"def find_max_in_grid(n: int, m: int, q: int, operations: List[Tuple[str, int, int]]) -> int: Find the maximum element in the grid after performing all operations. Parameters: n (int): Number of rows. m (int): Number of columns. q (int): Number of operations. operations (list of tuples): List of operations, each formatted as ('type', index, value). Returns: int: The maximum value in the grid. >>> find_max_in_grid(3, 3, 5, [('row', 1, 1), ('col', 2, -1), ('row', 3, 5), ('col', 3, 3), ('row', 1, 2)]) 8 >>> find_max_in_grid(4, 5, 3, [('row', 1, 10), ('row', 1, -5), ('row', 1, 5)]) 10 >>> find_max_in_grid(4, 5, 3, [('col', 1, 10), ('col', 1, -5), ('col', 1, 5)]) 10 >>> find_max_in_grid(2, 2, 4, [('row', 1, 3), ('col', 1, 2), ('row', 2, 5), ('col', 2, -1)]) 7 >>> find_max_in_grid(1, 1, 2, [('row', 1, 1000000), ('col', 1, -1000000)]) 0","solution":"def find_max_in_grid(n, m, q, operations): Find the maximum element in the grid after performing all operations. Parameters: n (int): Number of rows. m (int): Number of columns. q (int): Number of operations. operations (list of tuples): List of operations, each formatted as ('type', index, value). Returns: int: The maximum value in the grid. row_additions = [0] * n col_additions = [0] * m for operation in operations: type_, index, value = operation if type_ == 'row': row_additions[index - 1] += value elif type_ == 'col': col_additions[index - 1] += value # Find max in the grid by considering maximum row and column additions max_value = float('-inf') for i in range(n): for j in range(m): max_value = max(max_value, row_additions[i] + col_additions[j]) return max_value"},{"question":"def minimized_difference_arrays(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[int, List[int]]]: Rearrange the array such that the difference between the maximum and minimum values of every contiguous subarray of length k is minimized. If there are multiple arrangements that produce the same minimum difference, return the lexicographically smallest array. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of tuples where each tuple contains: - An integer n representing the number of elements in the array. - An integer k representing the subarray length. - A list of n positive integers representing the elements of the array. Returns: List[Tuple[int, List[int]]]: For each test case, output the minimized difference and the lexicographically smallest array that achieves this minimized difference. Examples: >>> minimized_difference_arrays(2, [(5, 2, [1, 5, 3, 9, 2]), (4, 3, [4, 1, 2, 7])]) [(1, [1, 2, 3, 5, 9]), (3, [1, 2, 4, 7])] >>> minimized_difference_arrays(1, [(4, 2, [5, 5, 5, 5])]) [(0, [5, 5, 5, 5])] from typing import List, Tuple from solution import minimized_difference_arrays def test_single_case(): t = 1 test_cases = [(5, 2, [1, 5, 3, 9, 2])] results = minimized_difference_arrays(t, test_cases) expected = [(1, [1, 2, 3, 5, 9])] assert results == expected def test_multiple_cases(): t = 2 test_cases = [(5, 2, [1, 5, 3, 9, 2]), (4, 3, [4, 1, 2, 7])] results = minimized_difference_arrays(t, test_cases) expected = [(1, [1, 2, 3, 5, 9]), (3, [1, 2, 4, 7])] assert results == expected def test_all_elements_same(): t = 1 test_cases = [(4, 2, [5, 5, 5, 5])] results = minimized_difference_arrays(t, test_cases) expected = [(0, [5, 5, 5, 5])] assert results == expected def test_sorted_input(): t = 1 test_cases = [(5, 3, [1, 2, 3, 4, 5])] results = minimized_difference_arrays(t, test_cases) expected = [(2, [1, 2, 3, 4, 5])] assert results == expected def test_reverse_sorted_input(): t = 1 test_cases = [(5, 3, [5, 4, 3, 2, 1])] results = minimized_difference_arrays(t, test_cases) expected = [(2, [1, 2, 3, 4, 5])] assert results == expected","solution":"def minimized_difference_arrays(t, test_cases): results = [] for case in test_cases: n, k, arr = case arr.sort() # Initialize minimum difference and the best subarray min_diff = float('inf') best_start = 0 # Calculate minimum difference for subarrays for i in range(n - k + 1): current_diff = arr[i + k - 1] - arr[i] if current_diff < min_diff: min_diff = current_diff best_start = i # Get the best array order result_array = arr[best_start:best_start + k] + sorted(arr[:best_start] + arr[best_start + k:]) results.append((min_diff, result_array)) return results"},{"question":"def max_bonus_distribution(n: int, k: int, performance_scores: List[int]) -> float: Calculate the maximum possible bonus distribution for the top k performers. Args: n : int : number of employees k : int : number of top performers to receive the maximum bonus performance_scores : List[int] : list of performance scores of employees Returns: float : the maximum possible bonus distribution Examples: >>> max_bonus_distribution(8, 3, [70, 80, 80, 90, 70, 60, 90, 85]) 3.0 >>> max_bonus_distribution(5, 2, [100, 90, 90, 70, 80]) 3.0","solution":"def max_bonus_distribution(n, k, performance_scores): Returns the maximum possible bonus distribution considering the top k performers. # Sort the performance scores in descending order performance_scores.sort(reverse=True) # The kth score in the sorted list might be a tie kth_score = performance_scores[k-1] # Count how many employees have scores >= kth_score count = sum(score >= kth_score for score in performance_scores) return float(count)"},{"question":"import heapq from typing import List def minimum_effort_path(grid: List[List[int]]) -> int: Given an n x n matrix grid of integers, where each cell represents the height of a terrain, determine the minimum effort required to travel from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1). You can move up, down, left, or right, and the effort of a path is defined as the maximum absolute difference in heights between two consecutive cells in the path. >>> minimum_effort_path([[1, 2, 2], [3, 8, 2], [5, 3, 5]]) 2 >>> minimum_effort_path([[1, 2, 3, 4], [2, 2, 3, 4], [1, 2, 3, 4], [4, 4, 4, 4]]) 1 pass","solution":"import heapq def minimum_effort_path(grid): Returns the minimum effort required to travel from the top-left to the bottom-right cell in the grid. n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] effort_to = [[float('inf')] * n for _ in range(n)] effort_to[0][0] = 0 min_heap = [(0, 0, 0)] while min_heap: effort, x, y = heapq.heappop(min_heap) if x == n - 1 and y == n - 1: return effort for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < n and 0 <= new_y < n: new_effort = max(effort, abs(grid[new_x][new_y] - grid[x][y])) if new_effort < effort_to[new_x][new_y]: effort_to[new_x][new_y] = new_effort heapq.heappush(min_heap, (new_effort, new_x, new_y)) return -1 # Should never be reached, as the path from top-left to bottom-right is guaranteed to exist. # Example usage: # n = 3 # grid = [ # [1, 2, 2], # [3, 8, 2], # [5, 3, 5] # ] # print(minimum_effort_path(grid)) # Output: 2"},{"question":"def matrix_sums(M, N, matrix): Returns the sum of each row and each column in the given MxN matrix. Parameters: M (int): Number of rows. N (int): Number of columns. matrix (list of list of int): The MxN matrix. Returns: tuple: (row_sums, col_sums) where row_sums is a list of sums of each row and col_sums is a list of sums of each column. pass # Example usage and test cases if __name__ == \\"__main__\\": M, N = 3, 3 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] row_sums, col_sums = matrix_sums(M, N, matrix) print(\\"Row sums:\\", row_sums) # should output: [6, 15, 24] print(\\"Column sums:\\", col_sums) # should output: [12, 15, 18]","solution":"def matrix_sums(M, N, matrix): Returns the sum of each row and each column in the given MxN matrix. Parameters: M (int): Number of rows. N (int): Number of columns. matrix (list of list of int): The MxN matrix. Returns: tuple: (row_sums, col_sums) where row_sums is a list of sums of each row and col_sums is a list of sums of each column. row_sums = [sum(row) for row in matrix] col_sums = [sum(matrix[i][j] for i in range(M)) for j in range(N)] return row_sums, col_sums"},{"question":"def min_removals_to_ensure_two_consecutive(s: str) -> int: Determine the minimum number of letters to remove so that each remaining letter appears at most twice consecutively. >>> min_removals_to_ensure_two_consecutive(\\"aaabbbc\\") 2 >>> min_removals_to_ensure_two_consecutive(\\"aabbcc\\") 0 >>> min_removals_to_ensure_two_consecutive(\\"aaa\\") 1","solution":"def min_removals_to_ensure_two_consecutive(s): Function to determine the minimum number of letters to remove so that each letter appears at most twice consecutively. removals = 0 count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 if count > 2: removals += 1 else: count = 1 return removals"},{"question":"def kth_smallest_element(matrix, k): Write a function that takes as input a matrix of integers and an integer k, and returns the kth smallest element in the matrix. The matrix is sorted in non-decreasing order both row-wise and column-wise. Return the kth smallest element in the matrix. >>> kth_smallest_element([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kth_smallest_element([ ... [1, 10, 20], ... [5, 15, 25], ... [10, 20, 30] ... ], 1) 1 pass","solution":"import heapq def kth_smallest_element(matrix, k): Returns the kth smallest element in a matrix that is sorted row-wise and column-wise. Enqueues elements from the matrix into a min-heap and extracts the kth smallest one. n = len(matrix) m = len(matrix[0]) min_heap = [] # Add the first element of each row to the heap for i in range(min(n, k)): heapq.heappush(min_heap, (matrix[i][0], i, 0)) # Extract min element from heap k times count = 0 while min_heap: element, r, c = heapq.heappop(min_heap) count += 1 if count == k: return element # If there is another element in the row, push into the heap if c+1 < m: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1))"},{"question":"def count_islands(matrix): Returns the number of distinct islands in a matrix of characters. An island is defined as a group of the same character that is connected horizontally or vertically. >>> count_islands( ... [ ... ['a', 'a', 'b', 'b'], ... ['a', 'c', 'c', 'b'], ... ['a', 'a', 'c', 'd'], ... ['e', 'e', 'e', 'd'] ... ] ... ) 5 >>> count_islands( ... [ ... ['a', 'a', 'a', 'a'], ... ['a', 'a', 'a', 'a'], ... ['a', 'a', 'a', 'a'] ... ] ... ) 1 >>> count_islands( ... [ ... ['a', 'b', 'c'], ... ['d', 'e', 'f'], ... ['g', 'h', 'i'] ... ] ... ) 9 >>> count_islands([['a', 'a', 'b', 'c', 'c']]) 3 >>> count_islands([['a'], ['a'], ['b'], ['c'], ['c']]) 3 >>> count_islands([]) 0 >>> count_islands( ... [ ... ['a', 'a', 'a', 'a'], ... ['a', 'a', 'a', 'a'], ... ['a', 'a', 'a', 'a'], ... ['a', 'a', 'a', 'a'] ... ] ... ) 1","solution":"def count_islands(matrix): Returns the number of distinct islands in a matrix of characters. An island is defined as a group of the same character that is connected horizontally or vertically. def dfs(row, col, char): Perform depth-first search to mark all parts of the current island as visited. if row < 0 or col < 0 or row >= len(matrix) or col >= len(matrix[0]): return if matrix[row][col] != char: return matrix[row][col] = None # Mark as visited by setting it to None # Check all four possible directions (up, down, left, right) dfs(row - 1, col, char) dfs(row + 1, col, char) dfs(row, col - 1, char) dfs(row, col + 1, char) if not matrix: return 0 islands = 0 for row in range(len(matrix)): for col in range(len(matrix[0])): if matrix[row][col] is not None: islands += 1 dfs(row, col, matrix[row][col]) return islands"},{"question":"from typing import List def labyrinth_solver(data: List[str]) -> List[int]: Determine the minimum number of moves needed to navigate through the labyrinth. >>> labyrinth_solver([ ... \\"2\\", ... \\"3 3\\", ... \\"...\\", ... \\".#.\\", ... \\"...\\", ... \\"4 4\\", ... \\"....\\", ... \\"#.\\", ... \\"....\\", ... \\"...#\\" ... ]) [4, -1] >>> labyrinth_solver([ ... \\"1\\", ... \\"3 3\\", ... \\"...\\", ... \\".#.\\", ... \\"...\\" ... ]) [4] >>> labyrinth_solver([ ... \\"1\\", ... \\"2 2\\", ... \\"\\", ... \\"\\" ... ]) [-1] >>> labyrinth_solver([ ... \\"1\\", ... \\"2 2\\", ... \\"..\\", ... \\"..\\" ... ]) [2] >>> labyrinth_solver([ ... \\"2\\", ... \\"2 2\\", ... \\"#.\\", ... \\"..\\", ... \\"2 2\\", ... \\"..\\", ... \\".#\\" ... ]) [-1, -1]","solution":"from collections import deque def min_moves_to_reach_end(labyrinths): def bfs(grid, n, m): visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: r, c, dist = queue.popleft() if r == n-1 and c == m-1: return dist for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < n and 0 <= new_c < m and not visited[new_r][new_c] and grid[new_r][new_c] == '.': visited[new_r][new_c] = True queue.append((new_r, new_c, dist + 1)) return -1 results = [] for grid in labyrinths: n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': results.append(-1) else: results.append(bfs(grid, n, m)) return results def parse_input(T, data): labyrinths = [] index = 0 results = [] for _ in range(T): n, m = map(int, data[index].strip().split()) index += 1 grid = [data[index+i].strip() for i in range(n)] labyrinths.append(grid) index += n return labyrinths def labyrinth_solver(data): T = int(data[0].strip()) labyrinths = parse_input(T, data[1:]) return min_moves_to_reach_end(labyrinths)"},{"question":"def find_balance_point(lst): Returns the index of the balance point in the list if it exists, otherwise -1. The balance point is an index where the sum of all elements to the left is equal to the sum of all elements to the right. >>> find_balance_point([1, 2, 3, 4, 3, 2, 1]) 3 >>> find_balance_point([1, 2, 3, 4, 5]) -1 >>> find_balance_point([]) -1 >>> find_balance_point([1]) 0 >>> find_balance_point([2, 1, 2, 1, 2, 1, 2]) 3 >>> find_balance_point([0, 10, -10]) 0 >>> find_balance_point([10, -10, 0]) 2","solution":"def find_balance_point(lst): Returns the index of the balance point in the list if it exists, otherwise -1. The balance point is an index where the sum of all elements to the left is equal to the sum of all elements to the right. total_sum = sum(lst) left_sum = 0 for i, num in enumerate(lst): # right_sum is total_sum minus the current element minus left_sum right_sum = total_sum - left_sum - num if left_sum == right_sum: return i left_sum += num return -1"},{"question":"def minimum_roads_to_reinforce(N: int, M: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of roads that need reinforcement to ensure the kingdom remains connected even after the failure of any one road. Args: N : int : Number of cities in the kingdom M : int : Number of roads in the kingdom roads : List[Tuple[int, int]] : Roads connecting the cities Returns: int : Minimum number of roads that need to be reinforced Examples: >>> minimum_roads_to_reinforce(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 1 >>> minimum_roads_to_reinforce(5, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)]) 0","solution":"def find_bridges(N, edges): from collections import defaultdict def dfs(node, parent, discovery_times, low_times, visited, adj, bridges, time): visited[node] = True discovery_times[node] = low_times[node] = time[0] time[0] += 1 for neighbor in adj[node]: if not visited[neighbor]: dfs(neighbor, node, discovery_times, low_times, visited, adj, bridges, time) low_times[node] = min(low_times[node], low_times[neighbor]) if low_times[neighbor] > discovery_times[node]: bridges.append((node, neighbor)) elif neighbor != parent: low_times[node] = min(low_times[node], discovery_times[neighbor]) adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) discovery_times = [-1] * (N+1) low_times = [-1] * (N+1) visited = [False] * (N+1) bridges = [] time = [0] for i in range(1, N+1): if not visited[i]: dfs(i, -1, discovery_times, low_times, visited, adj, bridges, time) return len(bridges) # Input handling def minimum_roads_to_reinforce(N, M, roads): return find_bridges(N, roads)"},{"question":"def solve_maze(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: A group of robots is trying to navigate a maze to reach a destination point. The maze is represented as an MxN grid where each cell can either be empty (0) or contain an obstacle (1). The robots can only move up, down, left, or right, and they aim to find the shortest path from the top-left corner of the grid to the bottom-right corner. If it's impossible to reach the destination, return -1. Process multiple test cases and return the results as a list. >>> solve_maze(2, [ (3, 3, [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ]), (3, 3, [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ]) ]) [4, -1] >>> solve_maze(1, [(1, 1, [[0]])]) [0] >>> solve_maze(1, [(1, 1, [[1]])]) [-1] def shortest_path(grid): from collections import deque M = len(grid) N = len(grid[0]) if grid[0][0] == 1 or grid[M-1][N-1] == 1: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == M - 1 and y == N - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 results = [] for t in range(T): M, N, grid = test_cases[t] results.append(shortest_path(grid)) return results","solution":"from collections import deque def shortest_path(grid): Finds the shortest path in a maze grid from top-left (0,0) to bottom-right (M-1, N-1). M = len(grid) N = len(grid[0]) if grid[0][0] == 1 or grid[M-1][N-1] == 1: return -1 # No path if start or end is blocked directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == M - 1 and y == N - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # No path found def solve_maze(T, test_cases): Process multiple test cases and return the results as a list results = [] for t in range(T): M, N, grid = test_cases[t] results.append(shortest_path(grid)) return results"},{"question":"def canAttendAllMeetings(intervals: List[Tuple[int, int]]) -> bool: Returns True if a person can attend all given meetings without any overlap, False otherwise. >>> canAttendAllMeetings([(1, 3), (2, 4), (5, 6)]) False >>> canAttendAllMeetings([(0, 1), (3, 5), (6, 8)]) True >>> canAttendAllMeetings([(3, 4), (4, 5), (5, 6)]) True >>> canAttendAllMeetings([(5, 10), (1, 2)]) True >>> canAttendAllMeetings([(1, 2), (2, 3), (1, 4)]) False","solution":"def canAttendAllMeetings(intervals): Returns True if a person can attend all given meetings without any overlap, False otherwise. # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Check for overlap for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"def is_palindrome(x: int) -> bool: Determines if the given integer is a palindrome without using extra space or converting to string. Examples: >>> is_palindrome(121) True >>> is_palindrome(-121) False >>> is_palindrome(10) False # Your code here","solution":"def is_palindrome(x): Determines if the given integer is a palindrome without using extra space or converting to string. if x < 0: return False original = x reversed_num = 0 while x > 0: reversed_num = reversed_num * 10 + x % 10 x //= 10 return original == reversed_num"},{"question":"def detect_increasing_period(readings): Detects if there is a period where the height of any plant strictly increased every day. >>> detect_increasing_period([[5, 1, 2, 3, 4, 5]]) [\\"YES\\"] >>> detect_increasing_period([[4, 5, 4, 3, 2]]) [\\"NO\\"] def process_input(input_data): Processes the input received and splits it into datasets where each dataset is a list. The first item of each list is the number of days, and the rest are heights. >>> process_input(\\"5n1 2 3 4 5n4n5 4 3 2n0\\") [[5, 1, 2, 3, 4, 5], [4, 5, 4, 3, 2]] def main(input_data): Receives the input data, processes it, detects the increasing period, and provides the required output. >>> main(\\"5n1 2 3 4 5n4n5 4 3 2n0\\") \\"YESnNO\\"","solution":"def detect_increasing_period(readings): results = [] for dataset in readings: n = dataset[0] if n == 0: break heights = dataset[1:] if any(heights[i] < heights[i+1] for i in range(n-1)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(input_data): datasets = [] lines = input_data.strip().split(\\"n\\") i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break heights = list(map(int, lines[i+1].split())) datasets.append([n] + heights) i += 2 return datasets def main(input_data): datasets = process_input(input_data) results = detect_increasing_period(datasets) return \\"n\\".join(results)"},{"question":"from typing import List def group_orders(order_names: List[str]) -> List[List[str]]: Groups the order names into lists of anagrams. :param order_names: List of order names (strings) :return: List of lists containing grouped anagrams >>> group_orders([\\"duel\\", \\"dule\\", \\"deul\\"]) == [[\\"duel\\", \\"dule\\", \\"deul\\"]] >>> result = group_orders([\\"duel\\", \\"dule\\", \\"speed\\", \\"spede\\", \\"deul\\", \\"cars\\"]) >>> sorted(result) == sorted([[\\"duel\\", \\"dule\\", \\"deul\\"], [\\"speed\\", \\"spede\\"], [\\"cars\\"]]) >>> result = group_orders([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"gogole\\"]) >>> sorted(result) == sorted([[\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"], [\\"google\\", \\"gogole\\"]]) >>> group_orders([\\"one\\", \\"two\\", \\"three\\"]) == [[\\"one\\"], [\\"two\\"], [\\"three\\"]] >>> group_orders([]) == [] >>> result = group_orders([\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"acb\\", \\"cba\\"]) >>> sorted(result) == sorted([[\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"acb\\", \\"cba\\"]])","solution":"from collections import defaultdict def group_orders(order_names): Groups the order names into lists of anagrams. :param order_names: List of order names (strings) :return: List of lists containing grouped anagrams anagram_groups = defaultdict(list) for order in order_names: sorted_order = ''.join(sorted(order)) anagram_groups[sorted_order].append(order) return list(anagram_groups.values())"},{"question":"from typing import List def sunsetViews(buildings: List[int]) -> int: Returns the number of buildings that can view the sunset. >>> sunsetViews([4, 7, 2, 5, 8]) 3 >>> sunsetViews([12, 15, 10, 8]) 2 >>> sunsetViews([3, 6, 3, 5, 7, 2]) 3","solution":"def sunsetViews(buildings): Returns the number of buildings that can view the sunset. max_height = 0 count = 0 for height in buildings: if height > max_height: max_height = height count += 1 return count"},{"question":"def can_water_plants(M: int, test_cases: list) -> list: Alicia is a botanist who loves to grow different types of plants. Each type of plant needs a specific amount of water each day. She has a variety of plants in her garden, and she'd like to know if she can design an automatic watering system that can water all her plants exactly. Alicia has a limited amount of water that she can use each day, and she wants to configure the system to use exactly this amount of water. However, she needs to know if the total amount of water required by the plants can be evenly distributed so that no plant is overwatered. Given the number of plants and the water requirement of each plant, determine if Alicia can set up her watering system so that the total amount of water used is exactly equal to the given limit, without splitting the water requirement of any plant. Parameters: M (int): The number of test cases. test_cases (list): The list of test cases where each test case is a tuple (N, water_requirements, K). Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_water_plants(2, [(3, [1, 2, 3], 6), (3, [5, 10, 15], 40)]) [\\"YES\\", \\"NO\\"] >>> can_water_plants(1, [(5, [1, 1, 1, 1, 1], 5)]) [\\"YES\\"] results = [] for i in range(M): N, water_requirements, K = test_cases[i] if sum(water_requirements) == K: results.append(\\"YES\\") else: results.append(\\"NO\\") return results","solution":"def can_water_plants(M, test_cases): results = [] for i in range(M): N, water_requirements, K = test_cases[i] if sum(water_requirements) == K: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def findSingleNumber(nums): Returns the single number that appears only once in the array. Every other number appears exactly twice. Example: >>> findSingleNumber([2, 2, 1]) 1 >>> findSingleNumber([4, 1, 2, 1, 2]) 4","solution":"def findSingleNumber(nums): Returns the single number that appears only once in the array. Every other number appears exactly twice. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"def modified_fibonacci(n: int) -> int: Write a function that takes a positive integer \`n\` and returns the nth value in a modified Fibonacci sequence where the next number in the sequence is the result of the bitwise XOR of the previous two numbers in the sequence. Assume the first two values in this sequence are 1 and 1. >>> modified_fibonacci(1) 1 >>> modified_fibonacci(2) 1 >>> modified_fibonacci(3) 0 >>> modified_fibonacci(4) 1","solution":"def modified_fibonacci(n): Returns the nth value in the modified Fibonacci sequence where the next number is the result of the bitwise XOR of the previous two numbers. Parameters: n (int): The position in the sequence. Returns: int: The nth value of the modified Fibonacci sequence. if n == 1 or n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a ^ b return b"},{"question":"def count_days_with_high_production(d: int, production_data: List[Tuple[int, int, int]]) -> int: This function counts the number of days when the production of candy A was strictly greater than the production of both candy B and candy C. :param d: Number of days. :param production_data: List of tuples where each tuple contains three integers, the production of candies A, B, and C for a day. :return: Number of days when the production of candy A was strictly greater than the production of both candy B and candy C. >>> count_days_with_high_production(4, [(15, 10, 5), (8, 12, 10), (20, 15, 30), (25, 5, 10)]) 2 >>> count_days_with_high_production(3, [(5, 5, 5), (10, 7, 8), (7, 5, 9)]) 1 >>> count_days_with_high_production(2, [(1, 2, 3), (4, 4, 4)]) 0 >>> count_days_with_high_production(1, [(100, 99, 98)]) 1 >>> count_days_with_high_production(5, [(9, 8, 7), (6, 5, 4), (5, 9, 3), (2, 1, 1), (10, 10, 9)]) 3","solution":"def count_days_with_high_production(d, production_data): This function counts the number of days when the production of candy A was strictly greater than the production of both candy B and candy C. :param d: Number of days. :param production_data: List of tuples where each tuple contains three integers, the production of candies A, B, and C for a day. :return: Number of days when the production of candy A was strictly greater than the production of both candy B and candy C. count = 0 for a, b, c in production_data: if a > b and a > c: count += 1 return count"},{"question":"from typing import List, Tuple def solve(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[str]: Determine whether there exists a path from vertex 1 to vertex n such that the sum of the weights of the edges along the path is even. Args: test_cases: A list of tuples, each containing: - an integer n: number of vertices - an integer m: number of edges - a list of m tuples, each containing three integers u, v, w representing an edge Returns: A list of strings, \\"YES\\" or \\"NO\\", for each test case. >>> solve([(5, 6, [(1, 2, 3), (1, 3, 4), (2, 3, 5), (2, 4, 1), (3, 4, 2), (4, 5, 6)])]) [\\"YES\\"] >>> solve([(4, 4, [(1, 2, 3), (2, 3, 5), (3, 4, 7), (4, 1, 9)])]) [\\"NO\\"] def test_case1(): input_data = [ (5, 6, [ (1, 2, 3), (1, 3, 4), (2, 3, 5), (2, 4, 1), (3, 4, 2), (4, 5, 6), ]) ] assert solve(input_data) == [\\"YES\\"] def test_case2(): input_data = [ (4, 4, [ (1, 2, 3), (2, 3, 5), (3, 4, 7), (4, 1, 9), ]) ] assert solve(input_data) == [\\"NO\\"] def test_case3(): input_data = [ (6, 8, [ (1, 2, 10), (2, 3, 5), (3, 4, 10), (4, 5, 5), (5, 6, 10), (1, 3, 15), (2, 6, 20), (3, 5, 25), ]) ] assert solve(input_data) == [\\"YES\\"] def test_case4(): input_data = [ (3, 3, [ (1, 2, 1), (2, 3, 1), (1, 3, 2), ]) ] assert solve(input_data) == [\\"YES\\"] def test_case5(): input_data = [ (3, 3, [ (1, 2, 2), (2, 3, 2), (1, 3, 5), ]) ] assert solve(input_data) == [\\"NO\\"] def test_multiple(): input_data = [ (5, 6, [ (1, 2, 3), (1, 3, 4), (2, 3, 5), (2, 4, 1), (3, 4, 2), (4, 5, 6), ]), (4, 4, [ (1, 2, 3), (2, 3, 5), (3, 4, 7), (4, 1, 9), ]), ] assert solve(input_data) == [\\"YES\\", \\"NO\\"]","solution":"def is_even_path(n, m, edges): from collections import deque, defaultdict graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) queue = deque([(1, 0)]) visited = {1: 0} while queue: current_node, current_sum = queue.popleft() for neighbor, weight in graph[current_node]: new_sum = current_sum + weight if neighbor in visited: if visited[neighbor] % 2 != new_sum % 2: continue else: visited[neighbor] = new_sum queue.append((neighbor, new_sum)) return \\"YES\\" if n in visited and visited[n] % 2 == 0 else \\"NO\\" def solve(test_cases): results = [] for n, m, edges in test_cases: results.append(is_even_path(n, m, edges)) return results"},{"question":"def max_colors_used(test_cases: List[Tuple[int, int]]) -> List[int]: Determine the maximum number of different colors that can be used on the grid such that no two adjacent cells have the same color. >>> max_colors_used([(3, 3)]) [9] >>> max_colors_used([(2, 2)]) [4] >>> max_colors_used([(1, 5)]) [1]","solution":"def max_colors_used(test_cases): results = [] for rows, cols in test_cases: if rows == 1 or cols == 1: # If either dimension is 1, we can only use two colors maximally regardless of the size. (Like a chessboard stripe) results.append(min(rows, cols)) else: # For larger grids, the number of maximally used colors follows the minimum of 9 and the product of rows and cols results.append(min(9, rows * cols)) return results"},{"question":"def print_fibonacci(n: int): Prints the first n terms of the Fibonacci sequence. >>> print_fibonacci(5) 0 1 1 2 3 >>> print_fibonacci(1) 0 >>> print_fibonacci(2) 0 1 >>> print_fibonacci(10) 0 1 1 2 3 5 8 13 21 34 >>> print_fibonacci(20) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181","solution":"def print_fibonacci(n): Prints the first n terms of the Fibonacci sequence. if n <= 0: return fib_sequence = [] # Initialize the first two terms if n >= 1: fib_sequence.append(0) if n >= 2: fib_sequence.append(1) # Calculate rest of the terms for i in range(2, n): next_term = fib_sequence[i-1] + fib_sequence[i-2] fib_sequence.append(next_term) for term in fib_sequence: print(term)"},{"question":"def min_palindromic_substrings(T: int, cases: List[str]) -> List[int]: Find the minimum number of substrings you can split the string into such that each substring is a palindrome. >>> min_palindromic_substrings(3, [\\"11011\\", \\"1001\\", \\"00010\\"]) [1, 1, 2] >>> min_palindromic_substrings(2, [\\"0\\", \\"1\\"]) [1, 1]","solution":"def min_palindromic_substrings(T, cases): results = [] for s in cases: # If the whole string is a palindrome, the answer is 1 if s == s[::-1]: results.append(1) else: results.append(2) return results"},{"question":"def rearrange_list(nums): Rearranges the elements of the given list so that no two adjacent elements have a difference of exactly 1. If such an arrangement is not possible, returns an empty list. >>> rearrange_list([1, 3, 5, 7, 9]) [7, 1, 5, 3, 9] >>> rearrange_list([1, 2]) [] >>> rearrange_list([]) [] >>> rearrange_list([1]) [1] >>> rearrange_list([4, 6, 8, 3, 5, 7, 10, 1]) [10, 1, 8, 3, 6, 4, 5, 7]","solution":"def rearrange_list(nums): Rearranges the elements of the given list so that no two adjacent elements have a difference of exactly 1. If such an arrangement is not possible, returns an empty list. if not nums: return [] nums.sort() half = (len(nums) + 1) // 2 small = nums[:half] large = nums[half:] result = [] while small and large: result.append(large.pop()) result.append(small.pop()) result += small[::-1] + large[::-1] for i in range(1, len(result)): if abs(result[i] - result[i - 1]) == 1: return [] return result"},{"question":"def max_profit(prices): Determine the maximum profit you can achieve by making exactly one purchase and one sale of the stock. Note that you cannot sell a stock before you buy one. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([3, 3, 3, 3, 3]) 0 >>> max_profit([4]) 0 >>> max_profit([1, 2]) 1 >>> max_profit([2, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and then selling the stock exactly once. If no profit can be achieved, returns 0. if len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def is_valid_password(password: str) -> bool: Check if a given password meets the specified requirements. The password must be at least 6 characters long, contain at least one uppercase letter, one lowercase letter, one digit, and one special character from the set \`!@#%^&*()-+\`. >>> is_valid_password(\\"Aa1!aa\\") True >>> is_valid_password(\\"Aa1\\") False >>> is_valid_password(\\"Aa!!!aaa\\") False >>> is_valid_password(\\"Aaaaaa\\") False >>> is_valid_password(\\"A1b!cd\\") True >>> is_valid_password(\\"abcdef\\") False >>> is_valid_password(\\"ABCDEF1!\\") False >>> is_valid_password(\\"123456\\") False >>> is_valid_password(\\"a1!aaa\\") False >>> is_valid_password(\\"!@#%^&*()\\") False","solution":"def is_valid_password(password: str) -> bool: if len(password) < 6: return False has_uppercase = any(char.isupper() for char in password) has_lowercase = any(char.islower() for char in password) has_digit = any(char.isdigit() for char in password) special_characters = set(\\"!@#%^&*()-+\\") has_special_char = any(char in special_characters for char in password) return has_uppercase and has_lowercase and has_digit and has_special_char"},{"question":"def generate_palindromic_array(n): Generates a palindromic array of length 2N with unique integers between 1 and 4N inclusive. pass def solve_palindromic_arrays(test_cases): Given a list of test cases, where each test case specifies N, returns a list of strings, each representing a palindromic array of length 2N. pass import pytest def test_generate_palindromic_array(): assert generate_palindromic_array(1) == [1, 1] assert generate_palindromic_array(2) == [1, 2, 2, 1] assert generate_palindromic_array(3) == [1, 2, 3, 3, 2, 1] assert generate_palindromic_array(4) == [1, 2, 3, 4, 4, 3, 2, 1] def test_solve_palindromic_arrays(): assert solve_palindromic_arrays([1, 2]) == [\\"1 1\\", \\"1 2 2 1\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"def generate_palindromic_array(n): Generates a palindromic array of length 2N with unique integers between 1 and 4N inclusive. array = list(range(1, n + 1)) return array + array[::-1] def solve_palindromic_arrays(test_cases): result = [] for n in test_cases: palindromic_array = generate_palindromic_array(n) result.append(\\" \\".join(map(str, palindromic_array))) return result"},{"question":"def sort_coffee_drinks(coffee_info): Sorts coffee drinks by descending order of hourly earnings. If two drinks have the same hourly earnings, sorts them lexicographically by their names. Params: - coffee_info (list of tuples): Each tuple contains (name (str), preparation_time (int), selling_price (int)) Returns: - List of coffee drink names in the sorted order. from solution import sort_coffee_drinks def test_sort_coffee_drinks_example1(): coffee_info = [(\\"Latte\\", 5, 4), (\\"Espresso\\", 2, 3), (\\"Americano\\", 4, 2)] assert sort_coffee_drinks(coffee_info) == [\\"Espresso\\", \\"Latte\\", \\"Americano\\"] def test_sort_coffee_drinks_example2(): coffee_info = [(\\"Cappuccino\\", 6, 5), (\\"Mocha\\", 6, 4)] assert sort_coffee_drinks(coffee_info) == [\\"Cappuccino\\", \\"Mocha\\"] def test_sort_coffee_drinks_tie_and_lexicographical(): coffee_info = [(\\"CoffeeA\\", 6, 5), (\\"CoffeeB\\", 6, 5)] assert sort_coffee_drinks(coffee_info) == [\\"CoffeeA\\", \\"CoffeeB\\"] def test_sort_coffee_drinks_all_steps(): coffee_info = [ (\\"Espresso\\", 2, 3), # Earnings = 90 (\\"Americano\\", 4, 2), # Earnings = 30 (\\"Latte\\", 5, 4), # Earnings = 48 (\\"Cappuccino\\", 6, 5), # Earnings = 50 (\\"Mocha\\", 6, 4) # Earnings = 40 ] assert sort_coffee_drinks(coffee_info) == [\\"Espresso\\", \\"Cappuccino\\", \\"Latte\\", \\"Mocha\\", \\"Americano\\"] def test_sort_coffee_drinks_min_max_values(): coffee_info = [ (\\"MinPrepTime\\", 1, 100), # Earnings = 6000 (\\"MaxPrepTime\\", 60, 1) # Earnings = 1 ] assert sort_coffee_drinks(coffee_info) == [\\"MinPrepTime\\", \\"MaxPrepTime\\"] def test_sort_coffee_drinks_single_entry(): coffee_info = [(\\"SingleDrink\\", 10, 2)] # Earnings = 12 assert sort_coffee_drinks(coffee_info) == [\\"SingleDrink\\"]","solution":"def sort_coffee_drinks(coffee_info): Sorts coffee drinks by descending order of hourly earnings. If two drinks have the same hourly earnings, sorts them lexicographically by their names. Params: - coffee_info (list of tuples): Each tuple contains (name (str), preparation_time (int), selling_price (int)) Returns: - List of coffee drink names in the sorted order. def hourly_earnings(prep_time, price): return (60 / prep_time) * price # Create a list of tuples containing each drink's name and its hourly earnings coffee_earnings = [(name, hourly_earnings(prep_time, price)) for name, prep_time, price in coffee_info] # Sort the list first by names lexicographically then by hourly earnings in descending order coffee_earnings.sort(key=lambda x: (-x[1], x[0])) # Return the sorted names return [name for name, earnings in coffee_earnings]"},{"question":"from typing import List, Tuple def shortest_path_with_damaged_node(n: int, m: int, d: int, s: int, t: int, edges: List[Tuple[int, int, int]]) -> int: Find the shortest path in a weighted directed graph from the starting node to the target node without passing through a damaged node. Args: n (int): Number of nodes. m (int): Number of edges. d (int): Damaged node. s (int): Starting node. t (int): Target node. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, w). Returns: int: The length of the shortest path from s to t without passing through d, or -1 if no such path exists. Examples: >>> shortest_path_with_damaged_node(6, 7, 3, 1, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1), (5, 6, 5)]) 17 >>> shortest_path_with_damaged_node(4, 4, 2, 1, 4, [(1, 2, 10), (2, 3, 5), (3, 4, 1), (1, 3, 20)]) 21 >>> shortest_path_with_damaged_node(4, 4, 3, 1, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 3, 6)]) -1 >>> shortest_path_with_damaged_node(4, 4, 3, 1, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 10)]) 10 >>> shortest_path_with_damaged_node(4, 4, 2, 1, 4, [(1, 2, 2), (2, 4, 1), (1, 3, 5), (3, 4, 2)]) 7","solution":"import heapq def shortest_path_with_damaged_node(n, m, d, s, t, edges): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) def dijkstra(source, target): pq = [(0, source)] dist = {i: float('inf') for i in range(1, n + 1)} dist[source] = 0 visited = set() while pq: current_dist, u = heapq.heappop(pq) if u in visited: continue visited.add(u) for v, weight in graph[u]: if v == d: continue new_dist = current_dist + weight if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(pq, (new_dist, v)) return dist[target] if dist[target] != float('inf') else -1 return dijkstra(s, t)"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def splitListToParts(head: ListNode, k: int) -> List[Optional[ListNode]]: Given a linked list and a number k, split the linked list into k consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may mean some parts are null if the number of nodes is less than k. The parts should be in order of the original linked list, and parts occurring earlier should always have a size greater than or equal to parts occurring later. >>> head = list_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) >>> k = 3 >>> result = splitListToParts(head, k) >>> [[node.val for node in linked_list_to_list(part)] for part in result] [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] >>> head = list_to_linked_list([1, 2, 3]) >>> k = 5 >>> result = splitListToParts(head, k) >>> [[node.val for node in linked_list_to_list(part)] for part in result] [[1], [2], [3], [], []] from typing import List, Optional # Helper functions for testing purposes def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head def linked_list_to_list(head): lst = [] current = head while current: lst.append(current.val) current = current.next return lst","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def splitListToParts(head, k): # Function to get the length of the linked list def get_length(node): length = 0 while node: length += 1 node = node.next return length length = get_length(head) part_length = length // k remainder = length % k parts = [] current = head for i in range(k): part_size = part_length + (1 if i < remainder else 0) part_head = current for j in range(part_size - 1): if current: current = current.next if current: next_part = current.next current.next = None current = next_part parts.append(part_head) return parts"},{"question":"def count_valid_parentheses(n: int) -> int: Write a function \`count_valid_parentheses(n)\`, where \`n\` is an integer. This function returns the number of distinct valid parentheses combinations of length \`2n\`. A valid combination of parentheses is one in which every opening parenthesis has a corresponding closing parenthesis, and the number of closing parentheses never exceeds the number of opening parentheses at any point in the combination. Parameters: n (int): The number of pairs of parentheses Returns: int: The number of distinct valid parentheses combinations of length \`2n\` >>> count_valid_parentheses(3) 5 >>> count_valid_parentheses(4) 14","solution":"def count_valid_parentheses(n): Returns the number of distinct valid parentheses combinations of length 2n. def catalan_number(n): if n == 0 or n == 1: return 1 catalan = [0] * (n + 1) catalan[0] = catalan[1] = 1 for i in range(2, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[n] return catalan_number(n)"},{"question":"def max_water_trapped(buildings: List[int]) -> int: Given a list of building heights, returns the maximum amount of water that can be trapped. >>> max_water_trapped([0, 1, 3, 0, 1, 2]) 3 >>> max_water_trapped([3, 0, 0, 3]) 6 >>> max_water_trapped([4, 2, 0, 3, 2, 5, 0]) 9 >>> max_water_trapped([1]) 0 >>> max_water_trapped([]) 0 >>> max_water_trapped([2, 2, 2, 2]) 0 >>> max_water_trapped([3, 0, 3, 0, 3]) 6 >>> max_water_trapped([1, 2, 3, 4, 5]) 0 >>> max_water_trapped([5, 4, 3, 2, 1]) 0 # Your code here","solution":"def max_water_trapped(buildings): Given a list of building heights, returns the maximum amount of water that can be trapped. n = len(buildings) if n == 0: return 0 left = [0] * n right = [0] * n water = 0 left[0] = buildings[0] for i in range(1, n): left[i] = max(left[i - 1], buildings[i]) right[n - 1] = buildings[n - 1] for i in range(n - 2, -1, -1): right[i] = max(right[i + 1], buildings[i]) for i in range(n): water += min(left[i], right[i]) - buildings[i] return water"},{"question":"def is_leap_year(year: int) -> str: Determines if a given year is a leap year. Args: year (int): The year to check. Returns: str: \\"Leap Year\\" if the year is a leap year, \\"Not a Leap Year\\" otherwise. >>> is_leap_year(2000) 'Leap Year' >>> is_leap_year(2016) 'Leap Year' >>> is_leap_year(2019) 'Not a Leap Year' >>> is_leap_year(1900) 'Not a Leap Year' >>> is_leap_year(4) 'Leap Year' >>> is_leap_year(3) 'Not a Leap Year' >>> is_leap_year(8000) 'Leap Year' >>> is_leap_year(8001) 'Not a Leap Year'","solution":"def is_leap_year(year): Determines if the given year is a leap year. Args: year (int): The year to check. Returns: str: \\"Leap Year\\" if the year is a leap year, \\"Not a Leap Year\\" otherwise. if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return \\"Leap Year\\" else: return \\"Not a Leap Year\\""},{"question":"def game_winner(s: str) -> str: Determines which player will win the game given the binary string s. Parameters: s (str): The binary string. Returns: str: \\"Alex\\" if Alex wins, \\"Casey\\" if Casey wins. Examples: >>> game_winner(\\"000111\\") 'Alex' >>> game_winner(\\"0101\\") 'Alex' >>> game_winner(\\"0000\\") 'Alex' >>> game_winner(\\"1111\\") 'Casey'","solution":"def game_winner(s): Determines which player will win the game given the binary string s. Parameters: s (str): The binary string. Returns: str: \\"Alex\\" if Alex wins, \\"Casey\\" if Casey wins. count_zeroes = s.count('0') if count_zeroes == 0: return \\"Casey\\" # If Alex makes the first move and there is at least one substring of '0's return \\"Alex\\""},{"question":"def can_arrange_books(n, book_ids): Determines if the books can be arranged such that the difference between the ID numbers of any two consecutive books is the same. Parameters: n (int): Number of books. book_ids (list of int): List of unique integer ID numbers of the books. Returns: str: \\"YES\\" if the books can be arranged as described, otherwise \\"NO\\". # Unit Test def test_single_book(): assert can_arrange_books(1, [7]) == \\"YES\\" def test_three_books_possible(): assert can_arrange_books(3, [1, 4, 7]) == \\"YES\\" def test_three_books_impossible(): assert can_arrange_books(3, [4, 10, 1]) == \\"NO\\" def test_five_books_possible(): assert can_arrange_books(5, [1, 3, 5, 7, 9]) == \\"YES\\" def test_five_books_impossible(): assert can_arrange_books(5, [1, 2, 4, 6, 8]) == \\"NO\\" def test_books_with_large_gap(): assert can_arrange_books(2, [1000, 1002]) == \\"YES\\" def test_books_with_unsorted_order(): assert can_arrange_books(4, [8, 2, 14, 11]) == \\"NO\\"","solution":"def can_arrange_books(n, book_ids): Determines if the books can be arranged such that the difference between the ID numbers of any two consecutive books is the same. Parameters: n (int): Number of books. book_ids (list of int): List of unique integer ID numbers of the books. Returns: str: \\"YES\\" if the books can be arranged as described, otherwise \\"NO\\". if n == 1: return \\"YES\\" # Only one book, trivially true book_ids.sort() difference = book_ids[1] - book_ids[0] for i in range(1, n): if book_ids[i] - book_ids[i - 1] != difference: return \\"NO\\" return \\"YES\\""},{"question":"def printFibonacci(n): Prints the first n numbers in the Fibonacci sequence, each on a new line. Example: >>> printFibonacci(5) \\"0n1n1n2n3n\\" >>> printFibonacci(3) \\"0n1n1n\\"","solution":"def printFibonacci(n): Prints the first n numbers in the Fibonacci sequence, each on a new line. if n <= 0: return fib_sequence = [] a, b = 0, 1 fib_sequence.append(a) if n > 1: fib_sequence.append(b) for _ in range(2, n): a, b = b, a + b fib_sequence.append(b) for num in fib_sequence: print(num)"},{"question":"def max_treasures(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum number of treasures Dora can collect on her path from (0,0) to (n-1,m-1). >>> max_treasures(3, 3, [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 3 >>> max_treasures(2, 2, [[1,1],[1,1]]) 3 >>> max_treasures(1, 1, [[1]]) 1 >>> max_treasures(1, 5, [[1, 0, 1, 0, 1]]) 3 >>> max_treasures(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def max_treasures(n, m, grid): Returns the maximum number of treasures Dora can collect on her path. # Initialize a DP table with 0s dp = [[0] * m for _ in range(n)] # Fill the DP table for i in range(n): for j in range(m): if i == 0 and j == 0: dp[i][j] = grid[i][j] elif i == 0: dp[i][j] = dp[i][j-1] + grid[i][j] elif j == 0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def autocomplete(words: List[str], prefix: str) -> List[str]: Returns a list of words from the input list that start with the given prefix. >>> autocomplete([\\"apple\\", \\"ape\\", \\"apricot\\", \\"banana\\", \\"bat\\"], \\"ap\\") [\\"apple\\", \\"ape\\", \\"apricot\\"] >>> autocomplete([\\"car\\", \\"cat\\", \\"dog\\", \\"door\\"], \\"do\\") [\\"dog\\", \\"door\\"]","solution":"def autocomplete(words, prefix): Returns a list of words from the input list that start with the given prefix. return [word for word in words if word.startswith(prefix)]"},{"question":"def is_valid_sudoku(board: List[List[str]]) -> bool: Determine if the given 9x9 Sudoku puzzle is valid. Example: >>> is_valid_sudoku([ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ]) == True >>> is_valid_sudoku([ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\"5\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], # Invalid row (two '5's) [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ]) == False >>> is_valid_sudoku([ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\"5\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] # Invalid column (two '5's) ]) == False >>> is_valid_sudoku([ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\"1\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], # Invalid subgrid (two '1's) [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ]) == False >>> is_valid_sudoku([ [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\",\\".\\"] ]) == True","solution":"def is_valid_sudoku(board): Determine if a given 9x9 2D array representing a Sudoku board is valid. def is_valid_group(group): elements = [x for x in group if x != '.'] return len(elements) == len(set(elements)) for row in board: if not is_valid_group(row): return False for col in zip(*board): if not is_valid_group(col): return False for i in range(0, 9, 3): for j in range(0, 9, 3): block = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if not is_valid_group(block): return False return True"},{"question":"def partition_and_sort(nums): Receives a list of integers and returns two lists sorted in ascending order. The first list contains only the even numbers from the input list. The second list contains only the odd numbers from the input list. Example: >>> partition_and_sort([4, 1, 7, 10, 3, 8, 5]) [[4, 8, 10], [1, 3, 5, 7]] >>> partition_and_sort([6, 3, 2, 1, 9]) [[2, 6], [1, 3, 9]] >>> partition_and_sort([7, 11, 5]) [[], [5, 7, 11]] >>> partition_and_sort([]) [[], []] >>> partition_and_sort([4, 8, 12]) [[4, 8, 12], []]","solution":"def partition_and_sort(nums): Receives a list of integers and returns two lists sorted in ascending order. The first list contains only the even numbers from the input list. The second list contains only the odd numbers from the input list. evens = sorted([num for num in nums if num % 2 == 0]) odds = sorted([num for num in nums if num % 2 != 0]) return [evens, odds]"},{"question":"def minimum_total_time_all_cases(test_cases): Calculate the minimum total time required to complete the maintenance of all servers including their recovery times. >>> minimum_total_time_all_cases([[(0, 3, 2), (5, 4, 1)]]) == [10] >>> minimum_total_time_all_cases([[(2, 6, 3), (1, 5, 2), (4, 2, 3)]]) == [17] results = [] for servers in test_cases: servers.sort(key=lambda x: x[0]) current_time = 0 max_recovery_time = 0 for start, maintenance, recovery in servers: current_time = max(current_time, start) current_time += maintenance max_recovery_time = max(max_recovery_time, current_time + recovery) results.append(max_recovery_time) return results def parse_input(input_text): Parse input text and return a list of test cases with the respective servers' starting times, maintenance times, and recovery times. >>> parse_input(\\"2n2n0 3 2n5 4 1n3n2 6 3n1 5 2n4 2 3n\\") == [ ... [(0, 3, 2), (5, 4, 1)], ... [(2, 6, 3), (1, 5, 2), (4, 2, 3)] ... ] lines = input_text.strip().split('n') index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 servers = [] for _ in range(N): si, mi, ri = map(int, lines[index].split()) index += 1 servers.append((si, mi, ri)) test_cases.append(servers) return test_cases def solve(input_text): Solve the server maintenance scheduling problem. >>> solve(\\"2n2n0 3 2n5 4 1n3n2 6 3n1 5 2n4 2 3n\\") == [10, 17] test_cases = parse_input(input_text) results = minimum_total_time_all_cases(test_cases) return results","solution":"def minimum_total_time_all_cases(test_cases): results = [] for servers in test_cases: servers.sort(key=lambda x: x[0]) current_time = 0 max_recovery_time = 0 for start, maintenance, recovery in servers: current_time = max(current_time, start) # Ensure we account for the server's start time current_time += maintenance # Add the maintenance time max_recovery_time = max(max_recovery_time, current_time + recovery) results.append(max_recovery_time) return results def parse_input(input_text): lines = input_text.strip().split('n') index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 servers = [] for _ in range(N): si, mi, ri = map(int, lines[index].split()) index += 1 servers.append((si, mi, ri)) test_cases.append(servers) return test_cases def solve(input_text): test_cases = parse_input(input_text) results = minimum_total_time_all_cases(test_cases) return results"},{"question":"def max_temperature_in_k_hours(n: int, k: int, temperatures: List[int]) -> int: Finds the maximum temperature recorded during any continuous k hours. :param n: Integer, the number of hours. :param k: Integer, the number of continuous hours to consider. :param temperatures: List of integers, temperatures recorded at each hour. :return: Integer, the maximum temperature recorded during any continuous k hours. >>> max_temperature_in_k_hours(8, 3, [1, 3, -1, -3, 5, 3, 6, 7]) 16 >>> max_temperature_in_k_hours(10, 2, [-1, -3, 4, 2, 1, 3, 2, 0, 1, 2]) 6 >>> max_temperature_in_k_hours(6, 6, [-1, -2, -1, -2, -3, -4]) -13 >>> max_temperature_in_k_hours(5, 1, [2, 3, 4, 5, 6]) 6 >>> max_temperature_in_k_hours(5, 5, [1, 2, 3, 4, 5]) 15 >>> max_temperature_in_k_hours(3, 3, [-5, -10, -15]) -30","solution":"def max_temperature_in_k_hours(n, k, temperatures): Finds the maximum temperature recorded during any continuous k hours. :param n: Integer, the number of hours. :param k: Integer, the number of continuous hours to consider. :param temperatures: List of integers, temperatures recorded at each hour. :return: Integer, the maximum temperature recorded during any continuous k hours. if k > n: return None max_temp = float('-inf') current_sum = sum(temperatures[:k]) for i in range(n - k + 1): if i > 0: current_sum = current_sum - temperatures[i - 1] + temperatures[i + k - 1] max_temp = max(max_temp, current_sum) return max_temp"},{"question":"def optimal_ticket_order(n: int, m: int, priorities: List[int]) -> List[int]: Determines the optimal order of ticket resolution based on priority and time constraints. Args: n : int : number of tickets m : int : interval in minutes priorities : List[int] : priority levels of each ticket Returns: List[int] : An optimal order of tickets to be resolved >>> optimal_ticket_order(5, 15, [3, 5, 2, 4, 1]) [2, 4, 1, 3, 5] >>> optimal_ticket_order(5, 15, [5, 4, 5, 3, 2]) in ([1, 3, 2, 4, 5], [3, 1, 2, 4, 5]) True","solution":"def optimal_ticket_order(n, m, priorities): Determines the optimal order of ticket resolution based on priority and time constraints. :param n: int - number of tickets :param m: int - interval in minutes :param priorities: List[int] - priority levels of each ticket :return: List[int] - An optimal order of tickets to be resolved # Create a list of (priority, index) tuples indexed_priorities = [(priorities[i], i + 1) for i in range(n)] # Sort by priority in descending order and by index in ascending order in case of ties indexed_priorities.sort(key=lambda x: (-x[0], x[1])) # Extract the ticket indices from the sorted list optimal_order = [index for _, index in indexed_priorities] return optimal_order"},{"question":"from typing import List, Tuple from collections import defaultdict def consolidate_items(items: List[Tuple[str, str, str]]) -> List[Tuple[str, str, str]]: Generates a consolidated list of items with unique identifiers concatenated together. >>> consolidate_items([(\\"item1\\", \\"apple\\", \\"001\\"), ... (\\"item2\\", \\"banana\\", \\"002\\"), ... (\\"item1\\", \\"apple\\", \\"003\\"), ... (\\"item3\\", \\"cherry\\", \\"004\\"), ... (\\"item2\\", \\"banana\\", \\"005\\")]) [(\\"item1\\", \\"apple\\", \\"001-003\\"), (\\"item2\\", \\"banana\\", \\"002-005\\"), (\\"item3\\", \\"cherry\\", \\"004\\")] >>> consolidate_items([(\\"item4\\", \\"grape\\", \\"123\\"), ... (\\"item4\\", \\"grape\\", \\"122\\"), ... (\\"item5\\", \\"pear\\", \\"130\\")]) [(\\"item4\\", \\"grape\\", \\"122-123\\"), (\\"item5\\", \\"pear\\", \\"130\\")] >>> consolidate_items([(\\"item6\\", \\"melon\\", \\"010\\")]) [(\\"item6\\", \\"melon\\", \\"010\\")]","solution":"from typing import List, Tuple from collections import defaultdict def consolidate_items(items: List[Tuple[str, str, str]]) -> List[Tuple[str, str, str]]: item_dict = defaultdict(list) for item_code, name, uid in items: key = (item_code, name) item_dict[key].append(uid) consolidated_items = [] for (item_code, name), uids in item_dict.items(): uids.sort() concatenated_uids = '-'.join(uids) consolidated_items.append((item_code, name, concatenated_uids)) return consolidated_items"},{"question":"def find_missing_books(N, M, returned_books): Identifies the missing books from the collection. Parameters: N (int): Total number of books. M (int): Number of books returned. returned_books (list of int): List of IDs of returned books. Returns: list of int: List of IDs of missing books in ascending order. def solve(test_cases): Solves multiple test cases for the missing books problem. Parameters: test_cases (list of tuples): Each tuple contains (N, M, returned_books). Returns: list of str: List of strings where each string is the missing books' IDs in ascending order. def test_find_missing_books(): assert find_missing_books(5, 3, [2, 3, 1]) == [4, 5] assert find_missing_books(4, 4, [1, 2, 3, 4]) == [] assert find_missing_books(6, 2, [2, 4]) == [1, 3, 5, 6] assert find_missing_books(1, 0, []) == [1] assert find_missing_books(3, 3, [3, 2, 1]) == [] def test_solve(): test_cases = [ (5, 3, [2, 3, 1]), (4, 4, [1, 2, 3, 4]) ] expected = [\\"4 5\\", \\"\\"] assert solve(test_cases) == expected test_cases = [ (6, 2, [2, 4]), (1, 0, []) ] expected = [\\"1 3 5 6\\", \\"1\\"] assert solve(test_cases) == expected test_cases = [ (3, 3, [3, 2, 1]), (6, 3, [1, 2, 6]) ] expected = [\\"\\", \\"3 4 5\\"] assert solve(test_cases) == expected","solution":"def find_missing_books(N, M, returned_books): Identifies the missing books from the collection. Parameters: N (int): Total number of books. M (int): Number of books returned. returned_books (list of int): List of IDs of returned books. Returns: list of int: List of IDs of missing books in ascending order. all_books = set(range(1, N + 1)) returned_books_set = set(returned_books) missing_books = sorted(all_books - returned_books_set) return missing_books def solve(test_cases): results = [] for N, M, returned_books in test_cases: missing_books = find_missing_books(N, M, returned_books) results.append(' '.join(map(str, missing_books))) return results"},{"question":"def find_max_condition(n: int, operations: List[List[int]]) -> int: Returns maximum condition value of streets after applying all operations. Parameters: n (int): the number of streets operations (list of list of int): a 2D array where each sublist contains 3 integers [p, q, v] Returns: int: the maximum condition value of the streets after all operations >>> find_max_condition(5, [[1, 3, 10], [2, 4, 5], [3, 5, 2]]) 17 >>> find_max_condition(5, [[1, 5, 10], [1, 5, 10], [1, 5, 10]]) 30 >>> find_max_condition(5, [[1, 2, 10], [3, 4, 5]]) 10 >>> find_max_condition(5, [[1, 5, 10]]) 10 >>> find_max_condition(5, [[1, 3, 10], [2, 4, 5], [2, 4, -5], [1, 3, -10]]) 0 >>> find_max_condition(1, [[1, 1, 1]]) 1 >>> find_max_condition(10**6, [[1, 1000000, 1]]) 1","solution":"def find_max_condition(n, operations): Returns maximum condition value of streets after applying all operations. Parameters: n (int): the number of streets operations (list of list of int): a 2D array where each sublist contains 3 integers [p, q, v] Returns: int: the maximum condition value of the streets after all operations # Initialize the array representing street conditions streets = [0] * (n + 1) # Apply all operations using a difference array approach for p, q, v in operations: streets[p - 1] += v if q < n: streets[q] -= v # Convert the difference array to the actual condition values max_condition = current_condition = 0 for i in range(n): current_condition += streets[i] if current_condition > max_condition: max_condition = current_condition return max_condition"},{"question":"def check_parentheses(expression: str) -> bool: Checks whether an alphanumeric expression contains valid nested parentheses. Args: expression (str): The alphanumeric expression. Returns: bool: True if parentheses are correctly nested, False otherwise. >>> check_parentheses(\\"(a+b)[c*d]{e/f}\\") True >>> check_parentheses(\\"{[(a+b)*(c+d)]}\\") True >>> check_parentheses(\\"({[a+b]*[c+d]})\\") True >>> check_parentheses(\\"{[a+b]*[c+d]}\\") True >>> check_parentheses(\\"[a+b]*(x+y))\\") False >>> check_parentheses(\\"[(a+b]*[c+d)]\\") False >>> check_parentheses(\\"((a+b)*(c+d)))\\") False","solution":"def check_parentheses(expression): Checks whether an alphanumeric expression contains valid nested parentheses. Args: expression (str): The alphanumeric expression. Returns: bool: True if parentheses are correctly nested, False otherwise. stack = [] matching_parenthesis = {')': '(', '}': '{', ']': '['} for char in expression: if char in '({[': stack.append(char) elif char in ')}]': if not stack or stack.pop() != matching_parenthesis[char]: return False elif not char.isalnum() and char not in '+-*/ ': return False return len(stack) == 0"},{"question":"def find_max_temperatures(M: int, N: int, temperature_data: List[List[int]]) -> List[int]: Returns the daily maximum temperatures recorded across M cities over N days. :param M: int - number of cities :param N: int - number of days :param temperature_data: list of list containing temperature data for M cities over N days :return: list of N integers representing maximum temperatures for each day Sample Input: M = 3 N = 5 temperature_data = [ [30, 25, 28, 29, 32], [31, 24, 27, 26, 30], [29, 26, 24, 27, 31] ] Sample Output: [31, 26, 28, 29, 32] pass def test_sample_input(): M = 3 N = 5 temperature_data = [ [30, 25, 28, 29, 32], [31, 24, 27, 26, 30], [29, 26, 24, 27, 31] ] expected_output = [31, 26, 28, 29, 32] assert find_max_temperatures(M, N, temperature_data) == expected_output def test_all_same_temperatures(): M = 3 N = 3 temperature_data = [ [25, 25, 25], [25, 25, 25], [25, 25, 25] ] expected_output = [25, 25, 25] assert find_max_temperatures(M, N, temperature_data) == expected_output def test_all_different_temperatures(): M = 3 N = 3 temperature_data = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] expected_output = [70, 80, 90] assert find_max_temperatures(M, N, temperature_data) == expected_output def test_negative_temperatures(): M = 3 N = 4 temperature_data = [ [-5, -10, -15, -20], [-25, -30, -35, -40], [-45, -50, -55, -60] ] expected_output = [-5, -10, -15, -20] assert find_max_temperatures(M, N, temperature_data) == expected_output def test_mixed_temperatures(): M = 2 N = 3 temperature_data = [ [50, -20, 30], [-10, 60, 40] ] expected_output = [50, 60, 40] assert find_max_temperatures(M, N, temperature_data) == expected_output","solution":"def find_max_temperatures(M, N, temperature_data): Returns the daily maximum temperatures recorded across M cities over N days. :param M: int - number of cities :param N: int - number of days :param temperature_data: list of list containing temperature data for M cities over N days :return: list of N integers representing maximum temperatures for each day max_temperatures = [-float('inf')] * N for city_data in temperature_data: for day in range(N): if city_data[day] > max_temperatures[day]: max_temperatures[day] = city_data[day] return max_temperatures"},{"question":"def find_pairs_with_sum(nums: List[int], k: int) -> List[Tuple[int, int]]: Create a function that accepts a list of integers and a target integer \`k\`. The goal is to find all unique pairs of elements in the list that add up to \`k\`. The function should return a list of tuples with each tuple containing two integers that form a pair. Ensure that the pairs are sorted in ascending order and the list of pairs is also sorted in ascending order based on the first element of the pair. If no such pairs exist, the function should return an empty list. Parameters: nums (list): A list of integers. k (int): The target sum. Returns: list: A list of tuples, each containing two integers that form a pair summing to \`k\`. Constraints: The list should contain at least 2 elements and at most 100 elements. 0 ≤ k ≤ 200 The elements in the list will be in the range -100 to 100. Sample Input: [1, 2, 3, 4, 5, 6] 7 Sample Output: [(1, 6), (2, 5), (3, 4)] pass from solution import find_pairs_with_sum def test_find_pairs_basic(): assert find_pairs_with_sum([1, 2, 3, 4, 5, 6], 7) == [(1, 6), (2, 5), (3, 4)] def test_find_pairs_no_pairs(): assert find_pairs_with_sum([1, 2, 3], 7) == [] assert find_pairs_with_sum([1, 2, 3, 4], 10) == [] def test_find_pairs_with_duplicates(): assert find_pairs_with_sum([1, 2, 2, 3, 4, 5, 6], 7) == [(1, 6), (2, 5), (3, 4)] assert find_pairs_with_sum([1, 1, 1, 2, 2, 3, 4], 5) == [(1, 4), (2, 3)] def test_find_pairs_negative_numbers(): assert find_pairs_with_sum([-1, -2, -3, 4, 1, 2, 3], 0) == [(-3, 3), (-2, 2), (-1, 1)] assert find_pairs_with_sum([-1, -2, -3, 1, 2, 3], -1) == [(-3, 2), (-2, 1)] def test_find_pairs_mixed_signs(): assert find_pairs_with_sum([1, -1, 0, 2, -2, 3, -3], 0) == [(-3, 3), (-2, 2), (-1, 1)] assert find_pairs_with_sum([4, -1, 0, 1, -4], -5) == [(-4, -1)]","solution":"def find_pairs_with_sum(nums, k): Find all unique pairs in the list \`nums\` that add up to \`k\`. Parameters: nums (list): A list of integers. k (int): The target sum. Returns: list: A list of tuples, each containing two integers that form a pair summing to \`k\`. nums = sorted(nums) pairs = set() seen = set() for num in nums: complement = k - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"def min_days_required(events): Determine the minimum number of days required to schedule all events without overlaps within the same day. >>> min_days_required([(1, 3), (2, 5), (4, 6)]) 2 >>> min_days_required([(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> min_days_required([(1, 10), (5, 6), (2, 3), (8, 9), (4, 7)]) 3","solution":"def min_days_required(events): from heapq import heappush, heappop # Sort events by their start time events.sort() # Min heap to track the end times of events scheduled on each separate day end_times = [] for s, e in events: if end_times and end_times[0] <= s: heappop(end_times) # Remove the event that ends the earliest & can take current event heappush(end_times, e) # Schedule the current event return len(end_times)"},{"question":"def max_sliding_window_sum_with_adjustments(n: int, k: int, m: int, arr: List[int]) -> int: Given an array of integers of size n, a sliding window of size k, and the ability to adjust at most m elements, find the maximum sum of any contiguous subarray of size k. Args: n (int): The size of the array. k (int): The size of the sliding window. m (int): The maximum number of adjustments allowed. arr (List[int]): The elements of the array. Returns: int: The maximum sum of any contiguous subarray of size k that can be achieved by modifying no more than m elements. Examples: >>> max_sliding_window_sum_with_adjustments(8, 3, 2, [1, 2, 3, -4, -5, 6, 7, 8]) 21 >>> max_sliding_window_sum_with_adjustments(5, 2, 1, [1, -2, 3, 4, 5]) 9 # Test cases import pytest def test_example_1(): assert max_sliding_window_sum_with_adjustments(8, 3, 2, [1, 2, 3, -4, -5, 6, 7, 8]) == 21 def test_example_2(): assert max_sliding_window_sum_with_adjustments(5, 2, 1, [1, -2, 3, 4, 5]) == 9 def test_no_adjustments_needed(): assert max_sliding_window_sum_with_adjustments(5, 2, 0, [1, 2, 3, 4, 5]) == 9 def test_all_negative_elements(): assert max_sliding_window_sum_with_adjustments(5, 2, 2, [-1, -2, -3, -4, -5]) == -3 def test_large_k(): assert max_sliding_window_sum_with_adjustments(5, 5, 1, [1, -2, 3, -4, 5]) == 3 def test_zero_adjustment(): assert max_sliding_window_sum_with_adjustments(6, 3, 0, [1, -2, 3, -4, 5, -6]) == 4 @pytest.mark.parametrize(\\"n, k, m, arr, expected\\", [ (8, 3, 2, [1, 2, 3, -4, -5, 6, 7, 8], 21), (5, 2, 1, [1, -2, 3, 4, 5], 9), (5, 2, 0, [1, 2, 3, 4, 5], 9), (5, 2, 2, [-1, -2, -3, -4, -5], -3), (5, 5, 1, [1, -2, 3, -4, 5], 3), (6, 3, 0, [1, -2, 3, -4, 5, -6], 4) ]) def test_params(n, k, m, arr, expected): assert max_sliding_window_sum_with_adjustments(n, k, m, arr) == expected","solution":"def max_sliding_window_sum_with_adjustments(n, k, m, arr): # We start by calculating the maximum sum we can get with no adjustments. max_sum = float('-inf') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(1, n - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] max_sum = max(max_sum, current_sum) # Try to improve the current sum by adjusting elements. improvements = [] for i in range(n): improvements.append((arr[i], i)) improvements.sort() for i in range(min(m, len(improvements))): current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) arr[improvements[i][1]] = max(arr[improvements[i][1]], 0) # Adjust - make it zero or itself, whichever is max for positive sum consideration return max_sum # Example usage: # print(max_sliding_window_sum_with_adjustments(8, 3, 2, [1, 2, 3, -4, -5, 6, 7, 8])) # Output: 21 # print(max_sliding_window_sum_with_adjustments(5, 2, 1, [1, -2, 3, 4, 5])) # Output: 9"},{"question":"def min_possible_value(arr, k): Given an array of integers and a number k, this function returns the minimum possible value in the array after performing at most k operations where a subarray can be sorted in non-decreasing order. >>> min_possible_value([3, 2, 4, 5], 1) 2 >>> min_possible_value([5, 2, 9, 1], 2) 1 def process_test_cases(t, test_cases): Given the number of test cases t and a list of test cases, return the minimum possible value of the array after performing at most k operations for each test case. >>> process_test_cases(2, [(4, 1, [3, 2, 4, 5]), (4, 2, [5, 2, 9, 1])]) [2, 1] >>> process_test_cases(1, [(4, 1, [10, 9, 8, 7])]) [7]","solution":"def min_possible_value(arr, k): Given an array of integers and a number k, this function returns the minimum possible value in the array after performing at most k operations where a subarray can be sorted in non-decreasing order. return sorted(arr)[0] def process_test_cases(t, test_cases): results = [] for n, k, arr in test_cases: results.append(min_possible_value(arr, k)) return results"},{"question":"def filter_invited_friends(n, k): Returns a list of friend IDs that are divisible by k or 'None' if no friends are invited. >>> filter_invited_friends(10, 3) [3, 6, 9] >>> filter_invited_friends(7, 7) [7] >>> filter_invited_friends(15, 5) [5, 10, 15] >>> filter_invited_friends(5, 6) 'None'","solution":"def filter_invited_friends(n, k): Returns a list of friend IDs that are divisible by k or 'None' if no friends are invited. invited_friends = [i for i in range(1, n + 1) if i % k == 0] return invited_friends if invited_friends else 'None'"},{"question":"from typing import List, Tuple def max_storage_utilization(n: int, c: int, s: List[int]) -> int: Given the number of product types \`n\`, the total storage capacity \`c\`, and a list of product spaces \`s\`, return the maximum storage space that can be utilized without exceeding the total storage capacity. >>> max_storage_utilization(3, 50, [10, 20, 30]) 50 >>> max_storage_utilization(2, 10000, [500, 700]) 10000 >>> max_storage_utilization(5, 1234, [10, 20, 30, 40, 50]) 1230 >>> max_storage_utilization(1, 1, [2]) 0 >>> max_storage_utilization(2, 5, [3, 8]) 3","solution":"def max_storage_utilization(n, c, s): Given the number of product types \`n\`, the total storage capacity \`c\`, and a list of product spaces \`s\`, return the maximum storage space that can be utilized without exceeding the total storage capacity, using a dynamic programming approach. dp = [0] * (c + 1) for si in s: for j in range(si, c + 1): dp[j] = max(dp[j], dp[j - si] + si) return dp[c] def process_warehouses(data): Processes multiple datasets and returns the results for the maximum storage space utilization for each dataset. results = [] for item in data: n, c = item[0] s = item[1] results.append(max_storage_utilization(n, c, s)) return results def parse_input(input_data): Parses the input data and returns structured information. lines = input_data.strip().split('n') datasets = [] i = 0 while i < len(lines): if lines[i] == '0': break n, c = map(int, lines[i].split()) s = [int(lines[i + j + 1]) for j in range(n)] datasets.append(((n, c), s)) i += n + 1 return datasets def main(input_data): datasets = parse_input(input_data) results = process_warehouses(datasets) for res in results: print(res)"},{"question":"def min_cost_to_make_equal(num_cases, cases): Calculate the minimum cost to make all elements of a list equal. Arguments: num_cases : int - number of test cases cases : list of tuples - each tuple contains a list of integers Returns: list of int - each integer is the minimum cost for the corresponding test case pass def parse_input(input_str): Parse the input string into the number of test cases and the test cases themselves. Arguments: input_str : str - input string containing the number of test cases and lists of integers Returns: tuple : (int, list) - number of test cases and a list of test cases pass def generate_output(costs): Generate the output string from the list of costs. Arguments: costs : list - list of integers representing the minimum costs for each test case Returns: str - output string where each cost is on a new line pass # Example unit tests import pytest def test_example_case_0(): input_str = \\"2n3n4 8 6n4n10 10 10 10n\\" T, cases = parse_input(input_str) result = min_cost_to_make_equal(T, cases) output = generate_output(result) assert output == \\"4n0\\" def test_small_case(): input_str = \\"1n3n1 2 3n\\" T, cases = parse_input(input_str) result = min_cost_to_make_equal(T, cases) output = generate_output(result) assert output == \\"2\\" def test_single_element_case(): input_str = \\"1n1n1000n\\" T, cases = parse_input(input_str) result = min_cost_to_make_equal(T, cases) output = generate_output(result) assert output == \\"0\\" def test_identical_elements_case(): input_str = \\"1n5n5 5 5 5 5n\\" T, cases = parse_input(input_str) result = min_cost_to_make_equal(T, cases) output = generate_output(result) assert output == \\"0\\" def test_large_case(): input_str = \\"1n5n1000000000 1000000000 1000000000 1000000000 500000000n\\" T, cases = parse_input(input_str) result = min_cost_to_make_equal(T, cases) output = generate_output(result) assert output == \\"500000000\\"","solution":"def min_cost_to_make_equal(num_cases, cases): Returns a list of minimum costs required to make all the elements of each list equal. Arguments: num_cases : int - number of test cases cases : list of tuples - each tuple contains a list of integers Return: list of int - each integer is the minimum cost for the corresponding test case def calculate_cost(nums): # The most optimal way of making all elements equal is making them equal to the median. sorted_nums = sorted(nums) median = sorted_nums[len(nums) // 2] return sum(abs(x - median) for x in nums) results = [] for lst in cases: results.append(calculate_cost(lst)) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) lst = list(map(int, input_lines[index + 1].split())) cases.append(lst) index += 2 return T, cases def generate_output(costs): return 'n'.join(map(str, costs))"}]`),E={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},P={class:"card-container"},C={key:0,class:"empty-state"},D=["disabled"],F={key:0},I={key:1};function M(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",P,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",C,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",I,"Loading...")):(s(),n("span",F,"See more"))],8,D)):l("",!0)])}const z=m(E,[["render",M],["__scopeId","data-v-7da67904"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/67.md","filePath":"guide/67.md"}'),O={name:"guide/67.md"},G=Object.assign(O,{setup(i){return(e,u)=>(s(),n("div",null,[w(z)]))}});export{B as __pageData,G as default};
