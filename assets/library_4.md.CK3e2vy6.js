import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function I(i,e,u,c,s,a){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const Y=m(k,[["render",I],["__scopeId","data-v-75fae20f"]]),A=JSON.parse('[{"question":"You are given an integer array `arr` and an integer `k`. Your task is to find the length of the longest subarray that contains at most `k` distinct integers. Implement the `Solution` class: * `int longestSubarrayWithKDistinct(int[] arr, int k)` - Returns the length of the longest subarray with at most `k` distinct integers. Example: ``` Input: arr = [1, 2, 1, 2, 3], k = 2 Output: 4 Explanation: The longest subarray with at most 2 distinct integers is [1, 2, 1, 2] with length 4. ``` Note: If `k` is zero or the input array is empty, the output should be 0.","solution":"from collections import defaultdict def longestSubarrayWithKDistinct(arr, k): if k == 0 or not arr: return 0 left = 0 max_length = 0 char_count = defaultdict(int) for right in range(len(arr)): char_count[arr[right]] += 1 while len(char_count) > k: char_count[arr[left]] -= 1 if char_count[arr[left]] == 0: del char_count[arr[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given a list of `n` integers, where each integer represents the height of a histogram bar, find the area of the largest rectangle that can be formed within the bounds of the histogram. Each bar has a width of `1`. Design an algorithm that solves this problem efficiently, ideally in `O(n)` time complexity.","solution":"def largest_rectangle_area(heights): Given a list of heights representing a histogram, return the area of the largest rectangle that can be formed within the bounds of the histogram. stack = [] # stack to store the indices of the histogram bars max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the shortest bar area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a string `s` containing only lowercase alphabetical characters. You need to partition the string into as few segments as possible such that each letter appears in at most one segment. Return _the list of integers representing the length of each segment_.","solution":"def partition_labels(s): Returns a list of integers representing the length of each segment such that each letter appears in at most one segment. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(end - start + 1) start = i + 1 return partitions"},{"question":"Implement a system to manage a parking lot. The parking lot has multiple levels, each level has multiple rows of spots, and each row has multiple spots. The parking lot can park motorcycles, cars, and buses. Design a class `ParkingLot` which has 4 methods: 1. `parkVehicle(vehicle)`: Parks the vehicle into the parking lot. The vehicle could be a motorcycle, car, or bus. Return `True` if the vehicle was successfully parked, otherwise return `False`. 2. `leaveVehicle(vehicle)`: Remove the vehicle from the parking lot. Return `True` if the vehicle was successfully removed, otherwise return `False`. 3. `getAvailableSpots()`: Returns the number of available spots in the parking lot. 4. `isFull()`: Returns `True` if the parking lot is full, otherwise `False`. Assume there are enough parking spots for the vehicles initially.","solution":"class Vehicle: def __init__(self, vehicle_type): self.vehicle_type = vehicle_type class ParkingLot: def __init__(self, levels, rows_per_level, spots_per_row): self.levels = levels self.parking_space = [[[None for _ in range(spots_per_row)] for _ in range(rows_per_level)] for _ in range(levels)] self.spots_per_row = spots_per_row self.rows_per_level = rows_per_level def parkVehicle(self, vehicle): for level in range(self.levels): for row in range(self.rows_per_level): for spot in range(self.spots_per_row): if self.parking_space[level][row][spot] is None: self.parking_space[level][row][spot] = vehicle return True return False def leaveVehicle(self, vehicle): for level in range(self.levels): for row in range(self.rows_per_level): for spot in range(self.spots_per_row): if self.parking_space[level][row][spot] == vehicle: self.parking_space[level][row][spot] = None return True return False def getAvailableSpots(self): available_spots = 0 for level in self.parking_space: for row in level: available_spots += row.count(None) return available_spots def isFull(self): return self.getAvailableSpots() == 0"},{"question":"A string is called a palindrome when it reads the same backward as forward. Given a non-empty string `str` containing only lowercase alphabetical characters, write a function to find the length of the longest palindromic substring. Formulate an efficient solution to handle large strings gracefully.","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in s. n = len(s) if n == 0: return 0 start, max_len = 0, 1 for i in range(1, n): # For odd length palindromes low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if (high - low + 1) > max_len: start = low max_len = high - low + 1 low -= 1 high += 1 # For even length palindromes low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if (high - low + 1) > max_len: start = low max_len = high - low + 1 low -= 1 high += 1 return max_len"},{"question":"A bakery supplies loaves of bread to local grocery stores. Each day, the bakery receives a report of the number of loaves sold at each store, represented by an array of integers where each element is the number of loaves sold at a specific store. If the loaf sales for any store exceed a predetermined threshold `k`, it triggers an overflow, and all loaves sold beyond `k` need to be resupplied the next day. Given an array `sales` and an integer `k`, return the total number of loaves that need to be resupplied the next day. [Example]: ```python sales = [12, 5, 8, 11, 6] k = 10 ``` Output: `3` In this example, the first store exceeds the threshold by 2 loaves and the fourth store by 1 loaf, requiring a total of `2 + 1 = 3` loaves to be resupplied.","solution":"def loaves_to_resupply(sales, k): Returns the total number of loaves that need to be resupplied the next day. Parameters: sales (list): List of integers representing the number of loaves sold at each store. k (int): The threshold number of loaves sold that triggers resupply. Returns: int: Total number of loaves to be resupplied. resupplied_loaves = 0 for sold in sales: if sold > k: resupplied_loaves += (sold - k) return resupplied_loaves"},{"question":"You are given a 2D list of integers `matrix` where the shape of the matrix is `mxn`. A **magic square** is a `3x3` grid of distinct integers from 1 to 9 where the sum of the numbers in each row, column, and diagonal is equal. Write a function to count all magic squares inside the given `m x n` matrix. * A magic square must be entirely contained within the given matrix. * A magic square inside the matrix is defined as a subgrid that meets the criteria mentioned above. Return the total number of unique 3x3 magic squares found within the matrix. Example: ``` Input: grid = [ [4,3,8,4], [9,5,1,9], [2,7,6,2] ] Output: 1 ```","solution":"def is_magic(square): Check if a 3x3 grid is a magic square. s = list(set([square[i][j] for i in range(3) for j in range(3)])) if sorted(s) != list(range(1, 10)): return False rows = [sum(square[i]) for i in range(3)] cols = [sum([square[i][j] for i in range(3)]) for j in range(3)] diag1 = sum([square[i][i] for i in range(3)]) diag2 = sum([square[i][2-i] for i in range(3)]) return len(set(rows + cols + [diag1] + [diag2])) == 1 def num_magic_squares_inside(grid): Count all 3x3 magic squares inside the given grid. m, n = len(grid), len(grid[0]) count = 0 for i in range(m - 2): for j in range(n - 2): square = [row[j:j+3] for row in grid[i:i+3]] if is_magic(square): count += 1 return count"},{"question":"You are given a list of `n` transactions that a bank customer has performed in chronological order. Each transaction is represented as a tuple `(amount, type)`, where `amount` is an integer representing the transaction amount, and `type` is a string that can either be `\\"deposit\\"` or `\\"withdrawal\\"`. Starting with an initial account balance of `0`, calculate the final balance after all transactions have been processed. Additionally, return an array of balances after each transaction. Ensure no transaction results in a negative balance. If a withdrawal causes the balance to go negative, discard that transaction and continue with the next one. Given a list `transactions`, return the final balance and the array of balances after each valid transaction.","solution":"def process_transactions(transactions): Process a list of transactions and return the final balance and the array of balances after each valid transaction. transactions: a list of tuples [(amount, type), ...] Returns a tuple (final_balance, balances) where: - final_balance (int) is the balance after processing all transactions - balances (list) is a list of balances after each valid transaction balance = 0 balances = [] for amount, trans_type in transactions: if trans_type == \\"deposit\\": balance += amount balances.append(balance) elif trans_type == \\"withdrawal\\": if balance >= amount: balance -= amount balances.append(balance) return balance, balances"},{"question":"You are given a list of `transactions` where each transaction is represented by a tuple `(sender, receiver, amount)`. Implement a function that detects possible fraudulent activities. A transaction is considered fraudulent if the `amount` exceeds a certain limit `L`. The function should return a list of tuples `(sender, receiver)` for all transactions that are considered fraudulent. The list should be sorted in lexicographical order.","solution":"def detect_fraudulent_transactions(transactions, limit): Returns a list of tuples (sender, receiver) for all transactions that are considered fraudulent. :param transactions: List of tuples (sender, receiver, amount) :param limit: Amount limit that defines a fraudulent transaction :return: List of tuples (sender, receiver) sorted in lexicographical order fraudulent_activities = [ (sender, receiver) for sender, receiver, amount in transactions if amount > limit ] return sorted(fraudulent_activities)"},{"question":"Given a matrix `matrix` where each row is sorted in **ascending** order, return _all elements of the matrix in sorted order_. The matrix is of size `r x c`, and the elements can be any integer. Ensure that the time complexity of your solution is better than O(r * c * log(r * c)).","solution":"from heapq import merge def sort_matrix(matrix): Returns all elements of the matrix in sorted order. Parameters: matrix (List[List[int]]): The 2D sorted matrix. Returns: List[int]: Sorted list of all elements in the matrix. if not matrix or not matrix[0]: return [] # Flatten the rows and merge them using heapq.merge for efficient sorted merging return list(merge(*matrix))"},{"question":"You are given a 2D grid of integers where each integer represents the time required to pass through that cell. The grid has dimensions `m x n`. You need to find a path from the top-left corner to the bottom-right corner such that the sum of the times along the path is minimized. You can only move either down or right at any point in time. Return the minimum sum of the times along the path.","solution":"def minPathSum(grid): Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time. :param grid: List[List[int]] - 2D grid of integers :return: int - minimum sum of the time along the path if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Initialize the top-left cell with its own value dp[0][0] = grid[0][0] # Initialize the first row (can only come from the left) for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Initialize the first column (can only come from above) for j in range(1, m): dp[j][0] = dp[j-1][0] + grid[j][0] # Fill in the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Given a list of integers `arr` representing a dataset, implement a function that returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to `k`. The function `longestSubarray(arr, k)` should be implemented as follows: - `longestSubarray(arr: List[int], k: int) -> int`: This function takes a list of integers `arr` and an integer `k`, and returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to `k`. Ensure your solution handles cases efficiently and considers edge cases.","solution":"from typing import List def longestSubarray(arr: List[int], k: int) -> int: Returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to k. Args: arr (List[int]): The list of integers representing the dataset. k (int): The maximum allowed absolute difference between any two elements in the subarray. Returns: int: The length of the longest contiguous subarray. if not arr: return 0 max_length = 1 left = 0 for right in range(len(arr)): while max(arr[left:right+1]) - min(arr[left:right+1]) > k: left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `path` representing a sequence of movements on a 2D grid. Each character in `path` is one of \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). Starting from the origin (0, 0), you need to determine if the path forms a closed loop, returning to the origin after all moves are executed. Implement a function that returns `True` if the path returns to the origin and `False` otherwise.","solution":"def is_path_closed_loop(path): Determines if the given path returns to the origin (0, 0). Args: path (str): A string representing the sequence of movements. Returns: bool: True if the path returns to the origin, False otherwise. x, y = 0, 0 for move in path: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"Given a matrix `mat` of integers, return the maximum sum of any hourglass formation in the matrix. For clarity, the definition of an hourglass is as follows, assuming all indices are valid: ``` a b c d e f g ``` where the sum is the sum of elements a, b, c, d, e, f, and g. The matrix will have at least 3 rows and 3 columns. If there are multiple hourglasses with the same maximum sum, you only need to return one of them.","solution":"def hourglassSum(mat): Returns the maximum hourglass sum in the matrix. rows = len(mat) cols = len(mat[0]) max_sum = float(\'-inf\') for i in range(rows - 2): for j in range(cols - 2): current_sum = ( mat[i][j] + mat[i][j+1] + mat[i][j+2] + mat[i+1][j+1] + mat[i+2][j] + mat[i+2][j+1] + mat[i+2][j+2] ) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"In a social networking application, each user can follow other users. You are given a directed acyclic graph where each node represents a user and a directed edge from node `u` to node `v` means the user `u` follows user `v`. Given the following: 1. A dictionary `followers` where the keys are user IDs and the values are lists of user IDs which the key user follows. 2. A list of user IDs `users`. Return _a list of user IDs from `users` who have the **maximum** number of followers, sorted in ascending order_. If there are no users with followers, return an empty list.","solution":"def get_users_with_max_followers(followers, users): Returns a list of user IDs from \'users\' who have the maximum number of followers. The result should be sorted in ascending order. :param followers: Dictionary where keys are user IDs and values are lists of IDs that the user follows :param users: List of user IDs to be checked :return: List of user IDs with the maximum number of followers, sorted in ascending order follower_count = {user: 0 for user in users} for key, values in followers.items(): for value in values: if value in follower_count: follower_count[value] += 1 if not follower_count: return [] max_followers = max(follower_count.values()) if max_followers == 0: return [] result = [user for user, count in follower_count.items() if count == max_followers] return sorted(result)"},{"question":"You are given a list of integers `nums` where each integer represents the number of occurrences of an element. Write a function to rearrange the elements of `nums` such that no two adjacent elements are the same if possible. If it is not possible, return an empty list. Implement the function `List<Integer> rearrange(List<Integer> nums)`: * `List<Integer> rearrange(List<Integer> nums)` Rearranges the elements to satisfy the conditions or returns an empty list if it\'s not possible. **Notes:** * Your solution should aim to rearrange the elements in a way that avoids adjacent duplicates. * If the input list cannot be rearranged to meet the requirements, your function should return an empty list.","solution":"from collections import Counter import heapq def rearrange(nums): Rearranges the elements of nums such that no two adjacent elements are the same if possible. If it is not possible, returns an empty list. if not nums: return [] counter = Counter(nums) max_heap = [(-count, num) for num, count in counter.items()] heapq.heapify(max_heap) result = [] prev_count, prev_num = 0, None while max_heap: count, num = heapq.heappop(max_heap) result.append(num) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_num)) # update the previous count and number prev_count, prev_num = count + 1, num if len(result) != len(nums): return [] return result"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of candies in each pile. Each day, you must consume half of the candies (rounded down) from the largest pile until you have consumed `k` candies in total. Return the minimum number of days it will take to consume `k` candies. If it is not possible to consume exactly `k` candies, return `-1`.","solution":"import heapq def min_days_to_consume_k_candies(nums, k): Returns the minimum number of days it takes to consume exactly k candies or -1 if it\'s not possible. :param nums: List[int] - list of integers representing the number of candies in each pile :param k: int - the total number of candies to consume :return: int - the minimum number of days or -1 if not possible max_heap = [-x for x in nums] # Using a max-heap to quickly access the largest element heapq.heapify(max_heap) days = 0 total_candies = 0 while total_candies < k and max_heap: largest_pile = -heapq.heappop(max_heap) total_candies += largest_pile days += 1 half_pile = largest_pile // 2 if half_pile > 0: heapq.heappush(max_heap, -half_pile) return days if total_candies >= k else -1"},{"question":"Given an integer array `nums`, return the length of the longest subarray consisting of distinct integers. If all integers in the array are the same, return `1`.","solution":"def longest_subarray_with_distinct_integers(nums): Given an integer array nums, return the length of the longest subarray consisting of distinct integers. If all integers in the array are the same, return 1. n = len(nums) if n == 0: return 0 max_len = 1 start = 0 seen = {} for end in range(n): if nums[end] in seen: start = max(start, seen[nums[end]] + 1) seen[nums[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a binary tree where each node contains an integer value. Implement the `BinaryTree` class with the following methods: * `void insert(int value)`: * Inserts a node with the given value into the binary tree following binary search tree properties. * `int findMaxWidth()`: * Returns the maximum width of the binary tree. The width of a tree is the maximum number of nodes at any level. For example, consider the following binary tree: ``` 1 / 2 3 /| | 4 5 6 7 ``` In this tree, the maximum width is `4`, which is the number of nodes at the level (4, 5, 6, 7). The binary tree can have any structure, and the nodes can have arbitrary integer values. The operations should handle typical cases gracefully and function efficiently even for larger trees.","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_rec(self.root, value) def _insert_rec(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_rec(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_rec(node.right, value) def findMaxWidth(self): if not self.root: return 0 maxWidth = 0 queue = [self.root] while queue: width = len(queue) maxWidth = max(maxWidth, width) for _ in range(width): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return maxWidth"},{"question":"You are given a circular array `nums` of positive integers where the next index after the last index is the first index, i.e., `nums[i]` and `nums[(i + 1) % n]` are adjacent in the array for all valid `i`. Your task is to split the array into multiple subarrays (including the possibility of using the entire array) such that the sum of integers in each subarray is even. Return the minimum number of subarrays required.","solution":"def min_subarrays_with_even_sum(nums): Returns the minimum number of subarrays required such that the sum of integers in each subarray is even. n = len(nums) current_sum = 0 odd_count = 0 # Count the number of odd elements in the array for num in nums: if num % 2 != 0: odd_count += 1 # If there are no odd numbers, we need only one subarray as the entire sum is even if odd_count == 0: return 1 return odd_count"},{"question":"Given an unordered list of integers `nums` and an integer `target_sum`, return the smallest non-negative integer `k` such that there exists at least one subsequence of `nums` (the sequence does not need to be contiguous) whose elements sum up to `k * target_sum`. Each element in the list `nums` can be used at most once. If no such `k` exists, return `-1`.","solution":"def smallest_k(nums, target_sum): if target_sum == 0: return 0 if 0 in nums else -1 nums = [num for num in nums if num > 0] nums.sort() possible_sums = {0} for num in nums: new_sums = possible_sums.copy() for s in possible_sums: new_sum = s + num new_sums.add(new_sum) possible_sums = new_sums k = 1 while k * target_sum in possible_sums: return k k += 1 return -1"},{"question":"You are given an integer array `nums`. An array is considered beautiful if there is no index `i` such that `nums[i]` is divisible by any preceding element `nums[j]` where `j < i`. Write a function that modifies the given array by rearranging elements to form a beautiful array if possible. If it is not possible, return an empty array. Return _the rearranged beautiful array_ or `_an empty array if no such rearrangement is possible_.","solution":"def beautiful_array(nums): def construct(l): if len(l) <= 1: return l odds = construct(l[::2]) evens = construct(l[1::2]) return odds + evens nums.sort() result = construct(nums) return result if is_beautiful(result) else [] def is_beautiful(nums): for i in range(len(nums)): for j in range(i): if nums[i] % nums[j] == 0: return False return True"},{"question":"You are given a binary tree where each node contains an integer value. Return the sum of the smallest value at each level of the tree. A level of the binary tree is defined as all nodes that are the same distance from the root. The binary tree is represented as follows: - `TreeNode` is a class that has attributes `val`, `left`, and `right`. - `val` contains the integer value of the node. - `left` and `right` are the children of the node, which can be either another `TreeNode` object or `None`. You need to traverse the binary tree level by level, and at each level, find the smallest value among all nodes at that level. Finally, return the sum of these smallest values. For example, for the following binary tree: ``` 4 / 2 7 / 1 3 6 ``` The smallest values at each level are: - Level 1: 4 - Level 2: 2 - Level 3: 1, 3, 6 (min is 1) So the sum of smallest values at each level is 4 + 2 + 1 = 7. Return this sum as the output.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_smallest_values_at_each_level(root): if not root: return 0 queue = deque([root]) sum_of_minimums = 0 while queue: level_size = len(queue) level_min = float(\'inf\') for _ in range(level_size): node = queue.popleft() level_min = min(level_min, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) sum_of_minimums += level_min return sum_of_minimums"},{"question":"You are given a list of `n` integers `arr`. Write a function to find the **minimum number of moves** required to make all array elements equal, where a **move** is incrementing **or** decrementing an element by `1`. You can assume that the answer always exists and is unique.","solution":"def min_moves_to_equal_elements(arr): Computes the minimum number of moves required to make all elements in the array equal. A move consists of incrementing or decrementing an element by 1. The optimal solution involves moving all elements to the median. arr.sort() median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"Given an array of digits `A` representing a large integer, increment the large integer by one and return the resulting array of digits. The digits in the input array are in non-decreasing order, and the input array can be of arbitrary length. Ensure that your solution handles the digit overflow correctly (e.g., adding one to `999` should result in `1000`).","solution":"def increment_large_integer(A): Increment the large integer represented by the array A by one. n = len(A) for i in range(n - 1, -1, -1): if A[i] < 9: A[i] += 1 return A A[i] = 0 # If we exit the loop from the start, it means we had a carry all through return [1] + A"},{"question":"You are given an array of positive integers `arr` and an integer `target`. You need to determine if there exists a subarray of `arr` such that the product of all the elements in this subarray is equal to `target`. Return `true` if such a subarray exists, and `false` otherwise. A subarray is defined as a contiguous sequence of elements within the array. The solution should efficiently handle large arrays with values that can potentially exceed integer limits when multiplied.","solution":"def subarray_product(arr, target): Determine if there exists a subarray of `arr` such that the product of all elements in this subarray is equal to `target`. The solution uses a sliding window approach to efficiently handle the problem. Args: arr (list of int): The array of positive integers. target (int): The target product to find in the subarray. Returns: bool: True if such a subarray exists, False otherwise. if target == 0: return False left = 0 current_product = 1 for right in range(len(arr)): current_product *= arr[right] while current_product > target and left <= right: current_product //= arr[left] left += 1 if current_product == target: return True return False"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer `num`. You need to form a new string by deleting exactly `num` characters from `s` such that the resulting string is the smallest possible string (lexicographically). Return _the lexicographically smallest string that can be formed by deleting exactly `num` characters from `s`_.","solution":"def smallest_lexicographical_string(s, num): This function returns the lexicographically smallest string by deleting exactly `num` characters from the given string `s`. stack = [] to_remove = num for char in s: while stack and char < stack[-1] and to_remove > 0: stack.pop() to_remove -= 1 stack.append(char) # If there are still characters to remove, remove from the end of the result final_stack = stack[:-to_remove] if to_remove else stack return \'\'.join(final_stack)"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. You need to determine if it is possible to rearrange the characters in `s` such that each adjacent character is different and the rearranged string has exactly `k` distinct characters. Return `true` if it is possible, otherwise return `false`.","solution":"from collections import Counter def can_rearrange_with_k_distinct(s, k): Determines if it is possible to rearrange the characters in s such that each adjacent character is different and the rearranged string has exactly `k` distinct characters. Parameters: s (str): The input string consisting of lowercase alphabets k (int): The required number of distinct characters in the rearranged string Returns: bool: True if it is possible, otherwise False if not s or k <= 0: return False # Count frequency of each character char_count = Counter(s) # Sort characters by frequency in descending order max_freq = max(char_count.values()) # Check if the highest frequency character can fit into the required positions if max_freq > (len(s) - max_freq + 1): return False # Check if the required distinct characters is achievable distinct_chars = len(char_count) return distinct_chars >= k # Example: # s = \\"aabbcc\\", k = 2 -> Possible true # s = \\"aaabbcc\\", k = 4 -> Not possible false"},{"question":"You are given a list of `n` unique integers `height` where `height[i]` represents the height of the `i-th` building. A building is **visible** if no building to its left has a greater or equal height. Write a function to return a list of indices representing buildings that are visible from the left. The indices should be in the original order they appear in the list.","solution":"def visible_buildings_from_left(height): Returns a list of indices of visible buildings from the left. A building is visible if no building to its left has a greater or equal height. :param height: List of unique integers representing heights of buildings :return: List of indices of visible buildings max_height = -1 visible_indices = [] for i in range(len(height)): if height[i] > max_height: visible_indices.append(i) max_height = height[i] return visible_indices"},{"question":"You are given a **binary tree** with `n` nodes where each node has a value. Your task is to perform a **depth-first search (DFS)** and return the sum of the values of all nodes, but only include the values if they are from the **left subtree** of their parent node. A left subtree node is defined as a node that exists in the left child position relative to its parent node. Write a function that computes this sum. Assume you are given the root node of the tree as input.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def dfs_sum_left_subtree_nodes(root): Perform a depth-first search and return the sum of the values of all nodes that are from the left subtree of their parent node. def dfs(node, is_left): if not node: return 0 left_sum = dfs(node.left, True) right_sum = dfs(node.right, False) # Include the node\'s value only if it is a left child if is_left: return node.value + left_sum + right_sum else: return left_sum + right_sum # Root node is not a left subtree node, so initial call is with is_left=False return dfs(root, False)"},{"question":"Given a binary tree, return the largest value in each row of the tree. The tree is represented using nodes, where each node contains an integer value, a left child, and a right child. Your solution should traverse the tree level-by-level and collect the largest value at each level, returning them in a list.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def largest_values_per_row(root): Given a binary tree, return the largest value in each row. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"Given two strings `s1` and `s2`, you need to transform `s1` into `s2` using the minimum number of operations. The allowed operations are: - Delete a character from `s1`. - Insert a character into `s1`. - Replace a character in `s1` with another character. Write a function `minDistance(s1, s2)` that calculates the minimum number of operations required to transform `s1` into `s2`.","solution":"def minDistance(s1, s2): Returns the minimum number of operations required to transform s1 into s2. The allowed operations are: - Insert a character into s1 - Delete a character from s1 - Replace a character in s1 with another character m, n = len(s1), len(s2) # Create a dp array with (m+1) x (n+1) size dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # s1 is empty, insert all characters of s2 elif j == 0: dp[i][j] = i # s2 is empty, delete all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Delete dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"You are given a **non-empty** string `s` consisting of lowercase alphabets. A duplicated-letter subsequence is a subsequence in which one or more letters appear more than once in the subsequence. Your task is to determine the length of the longest duplicated-letter subsequence in the given string `s`. A subsequence is obtained by deleting zero or more characters from a string without changing the order of the remaining characters. Return the length of the longest duplicated-letter subsequence.","solution":"def longest_duplicated_letter_subsequence(s): Returns the length of the longest duplicated-letter subsequence in the given string. from collections import Counter # Count the frequency of each character in the string frequency = Counter(s) # Calculate the length of the longest duplicated-letter subsequence length = sum(count for count in frequency.values() if count > 1) return length"},{"question":"You are given a string `s` and a list of strings `words`. All the strings in `words` are of the same length. We are also given that `s` consists of an exact concatenation of each word in `words` exactly once, but it is unknown in which order. Write a function to return the starting indices of all possible substrings in `s` that can be formed by concatenating each word in `words` exactly once, without any intervening characters. The order of the returned indices does not matter.","solution":"def findSubstring(s, words): if not s or not words or not words[0]: return [] word_length = len(words[0]) word_count = len(words) substring_length = word_length * word_count word_frequency = {} for word in words: if word in word_frequency: word_frequency[word] += 1 else: word_frequency[word] = 1 result_indices = [] for i in range(word_length): left = i window_words = {} word_used = 0 for j in range(i, len(s) - word_length + 1, word_length): current_word = s[j:j + word_length] if current_word in word_frequency: if current_word in window_words: window_words[current_word] += 1 else: window_words[current_word] = 1 if window_words[current_word] <= word_frequency[current_word]: word_used += 1 while window_words[current_word] > word_frequency[current_word]: left_word = s[left:left + word_length] window_words[left_word] -= 1 if window_words[left_word] < word_frequency[left_word]: word_used -= 1 left += word_length if word_used == word_count: result_indices.append(left) left_word = s[left:left + word_length] window_words[left_word] -= 1 word_used -= 1 left += word_length else: window_words.clear() word_used = 0 left = j + word_length return result_indices"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. In one operation, you can select any character in the string and replace it with any other character. Return the minimum number of operations needed to make the string contain `k` consecutive identical characters. If it is not possible to achieve, return `-1`.","solution":"def min_operations_to_k_consecutive(s, k): n = len(s) if k > n: return -1 min_operations = float(\'inf\') for target in set(s): left = 0 count = 0 for right in range(n): if s[right] != target: count += 1 if right - left + 1 == k: min_operations = min(min_operations, count) if s[left] != target: count -= 1 left += 1 return min_operations if min_operations != float(\'inf\') else -1"},{"question":"You are given an integer array `nums` of size `n` containing distinct numbers sorted in increasing order, and an integer `target`. Return _the index of the `target` in the array or the index where it would be if it were inserted in order_ using a **binary search** algorithm. You must write an efficient algorithm with a time complexity of `O(log n)`.","solution":"def binary_search_insert_position(nums, target): Returns the index of the target in the array or the index where it would be if it were inserted in order using a binary search algorithm. :param nums: List of distinct integers sorted in increasing order :param target: Integer target to find in the list :return: Integer index position left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"You are given a list of integers representing a **histogram** where the width of each bar is `1`. Design an algorithm to determine the **maximum rectangular area** that can be formed within the histogram. Return the maximum area.","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a matrix `matrix` of integers where each cell contains either a 1, representing a land unit, or a 0, representing a water unit. An island is a group of land units (1s) connected **4-directionally** (horizontally or vertically). You may assume all four edges of the matrix are surrounded by water. Write a function that returns _the **maximum perimeter** of an island in the matrix_. The perimeter of an island is the number of 0s or edges it touches. If there is no island, the function should return 0.","solution":"def max_island_perimeter(matrix): Returns the maximum perimeter of an island in the given matrix. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or matrix[r][c] == 0: return 1 if matrix[r][c] == -1: return 0 matrix[r][c] = -1 perimeter = 0 perimeter += dfs(r - 1, c) perimeter += dfs(r + 1, c) perimeter += dfs(r, c - 1) perimeter += dfs(r, c + 1) return perimeter max_perimeter = 0 for r in range(rows): for c in range(cols): if matrix[r][c] == 1: max_perimeter = max(max_perimeter, dfs(r, c)) return max_perimeter"},{"question":"Given a **non-negative integer** `num`, repeatedly add all its digits until the result has only one digit. The operation can be done as follows: 1. Convert the number to an array of its digits. 2. Sum the digits. 3. If the resulting sum has more than one digit, repeat the process with the new sum. Return _the final single-digit result_.","solution":"def add_until_one_digit(num): Repeatedly adds all digits of the input number until the result has only one digit. Parameters: num (int): The non-negative integer to be reduced to a single digit. Returns: int: The final single-digit result. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"An array `arr` of positive integers is said to be **cyclically balanced** if for each integer `x` that appears in `arr`, the number of occurrences of `x` in `arr` is exactly `x`. Assuming we start counting from an arbitrary position in the array and the array wraps around, cyclically. Given an array `arr`, return `true` if it is cyclically balanced, or `false` otherwise. The length of the array is guaranteed to be greater than 0 and less than or equal to 100.","solution":"def is_cyclically_balanced(arr): Given an array of positive integers, return True if the array is cyclically balanced, otherwise return False. from collections import Counter # Count occurrences of each element element_counts = Counter(arr) # Check if each element appears exactly as many times as its value for element, count in element_counts.items(): if element != count: return False return True"},{"question":"Given two integers, `x` and `y`, representing the number of rows and columns in a `x by y` grid, and a list of coordinates representing obstacles on the grid, find the number of unique paths from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. An obstacle and empty space are marked as `1` and `0` respectively in the grid matrix. Return the number of unique paths that avoid all obstacles. If there is no valid path, return `0`.","solution":"def unique_paths_with_obstacles(x, y, obstacles): Returns the number of unique paths from the top-left to bottom-right corner of a grid considering obstacles. Parameters: - x: number of rows in the grid - y: number of columns in the grid - obstacles: a list of tuples representing obstacles on the grid Returns: - Number of unique paths that avoid obstacles if not x or not y: return 0 # Initialize the grid with 0s grid = [[0] * y for _ in range(x)] # Set obstacles in the grid for (i, j) in obstacles: grid[i][j] = 1 # If the starting or ending points are obstacles, return 0 if grid[0][0] == 1 or grid[-1][-1] == 1: return 0 # Creating dp array dp = [[0] * y for _ in range(x)] # Initialize the start point dp[0][0] = 1 # Fill dp array considering obstacles for i in range(x): for j in range(y): if grid[i][j] == 1: # Obstacle dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[-1][-1]"},{"question":"You are given a binary string `s` containing only the characters \'0\' and \'1\'. We define a contiguous substring of `s` as \\"balanced\\" if it contains an equal number of \'0\'s and \'1\'s. Your task is to determine the maximum length of a balanced substring within `s`. If there are no balanced substrings, return `0`.","solution":"def max_balanced_substring_length(s): This function calculates the maximum length of a balanced substring within the given binary string `s`. A substring is balanced if it contains an equal number of \'0\'s and \'1\'s. max_length = 0 count = 0 counts = {0: -1} for index, char in enumerate(s): if char == \'0\': count -= 1 else: count += 1 if count in counts: max_length = max(max_length, index - counts[count]) else: counts[count] = index return max_length"},{"question":"You are given a list of unique integers `nums` and an integer `target`. Your task is to determine whether any three numbers from `nums` add up to exactly `target`. Return `true` if any such triplet exists and `false` otherwise. You may assume that all numbers in `nums` are distinct.","solution":"def three_sum(nums, target): Given a list of unique integers and a target integer, determine whether any three numbers from the list add up to exactly the target. Returns True if any such triplet exists, otherwise returns False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given a string `s` and an integer `k`, you are allowed to replace at most `k` characters in the string with any other character. Your task is to return the length of the longest substring containing only the same character after performing the replacements. Implement the function `int characterReplacement(String s, int k)`, which returns the desired maximum length.","solution":"def characterReplacement(s, k): Returns the length of the longest substring containing only the same character after replacing at most k characters. left = 0 max_count = 0 char_count = {} for right in range(len(s)): char = s[right] char_count[char] = char_count.get(char, 0) + 1 max_count = max(max_count, char_count[char]) if (right - left + 1) - max_count > k: char_count[s[left]] -= 1 left += 1 return len(s) - left"},{"question":"Given a list of non-negative integers `nums`, you need to divide them into two sets `A` and `B` such that the absolute difference between the sum of elements in `A` and the sum of elements in `B` is minimized. Return _the minimum possible absolute difference_. For example, given `nums = [1, 6, 11, 5]`, you can partition the list into sets `A = [1, 6, 5]` and `B = [11]`, or `A = [1, 11]` and `B = [6, 5]`, both resulting in the minimum possible absolute difference of `1`.","solution":"def minimumDifferenceSubsetSum(nums): Return the minimum possible absolute difference between the sums of two subsets of the given list of non-negative integers nums. # Calculate the total sum of the array total_sum = sum(nums) n = len(nums) # DP array to check partition sub-sums dp = [False] * (total_sum // 2 + 1) dp[0] = True # Process each number for num in nums: for j in range(total_sum // 2, num - 1, -1): if dp[j - num]: dp[j] = True # Find the largest j for which dp[j] is True for j in range(total_sum // 2, -1, -1): if dp[j]: return total_sum - 2 * j"},{"question":"You are tasked with implementing a function that takes a list of integers `nums` and an integer `k`, and returns the maximum average value of any contiguous subarray of length `k` within the list. The function should efficiently find this maximum average value. Note that the average of a subarray of length `k` is the sum of its elements divided by `k`. ```python def findMaxAverage(nums: List[int], k: int) -> float: # Your code here ```","solution":"def findMaxAverage(nums, k): Returns the maximum average value of any contiguous subarray of length k. Parameters: nums (List[int]): List of integers k (int): Length of the subarray Returns: float: Maximum average value of any subarray of length k. # Calculate the sum of the first window window_sum = sum(nums[:k]) max_sum = window_sum # Slide the window over the rest of the elements for i in range(k, len(nums)): window_sum = window_sum - nums[i - k] + nums[i] if window_sum > max_sum: max_sum = window_sum return max_sum / k"},{"question":"A company wants to build a new product that involves sending data packets from a main server to several client servers. The network of servers is represented by a directed graph where each server is a node, and each connection between servers is an edge with a positive weight representing the time taken to send a packet from one server to another. You are given an integer `n` representing the number of servers, and a 2D array `connections` where `connections[i] = [u, v, w]` indicates there is a directed connection from server `u` to server `v` with a transmission time of `w`. Your task is to find the shortest time required to send a data packet from the main server (node `0`) to all other client servers. If it is impossible to reach a client server from the main server, return `-1` for that server. Output an array with the shortest time to each client server in increasing order of server numbers.","solution":"import heapq def shortest_time(n, connections): Find the shortest time required to send a data packet from the main server (node 0) to all other client servers. Parameters: - n: int, number of servers. - connections: List[List[int]], a list of connections where each connection is represented as [u, v, w], indicating a directed edge from u to v with weight w. Returns: - List[int], list of shortest time to each client server in increasing order of server numbers. If a server is unreachable, return -1 for that server. # Create an adjacency list for the graph graph = [[] for _ in range(n)] for u, v, w in connections: graph[u].append((v, w)) # Initialize distances with \\"infinity\\" distances = [float(\'inf\')] * n distances[0] = 0 # Min-heap to store (current_distance, node) min_heap = [(0, 0)] while min_heap: current_distance, u = heapq.heappop(min_heap) # If this distance is already greater than the recorded distance, skip processing if current_distance > distances[u]: continue # Check all the neighbors for v, w in graph[u]: distance = current_distance + w # If a shorter path is found, update the distance and push it into the heap if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) # Convert unreachable nodes to -1 return [dist if dist != float(\'inf\') else -1 for dist in distances]"},{"question":"You are given two strings, `s` and `t`. You are allowed to rearrange the characters in `t` and you need to determine if `t` contains a permutation that is a substring of `s`. Return `true` if it is possible, otherwise return `false`.","solution":"from collections import Counter def check_inclusion(s: str, t: str) -> bool: Checks if t contains a permutation that is a substring of s. len_s, len_t = len(s), len(t) if len_s < len_t: return False count_t = Counter(t) count_window = Counter(s[:len_t]) if count_window == count_t: return True for i in range(len_t, len_s): count_window[s[i]] += 1 count_window[s[i - len_t]] -= 1 if count_window[s[i - len_t]] == 0: del count_window[s[i - len_t]] if count_window == count_t: return True return False"},{"question":"Given a string `s` and a dictionary of words `dict`, partition `s` into as few strings as possible such that each string is a palindrome and each string exists in the dictionary. Return _the minimum number of partitions required_. A string is a **palindrome** if it reads the same forwards and backwards.","solution":"def min_palindrome_partitions(s, word_dict): Given a string s and a dictionary of words, partition s into as few strings as possible such that each string is a palindrome and each string exists in the dictionary. Returns the minimum number of partitions required. n = len(s) # Check if a substring is a palindrome def is_palindrome(sub): return sub == sub[::-1] # DP to store minimum partitions for substring s[0:i] dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # Main DP loop for i in range(1, n + 1): for j in range(i): substring = s[j:i] if substring in word_dict and is_palindrome(substring): dp[i] = min(dp[i], dp[j] + 1) return dp[-1] if dp[-1] != float(\'inf\') else -1"},{"question":"Given a string `s` representing a binary number, return the number of substrings that are palindromic. A substring is defined as a contiguous sequence of characters within the string, and a string is palindromic if it reads the same backward as forward. The substrings must be non-empty. Write a function: ```python def count_palindromic_substrings(s: str) -> int: # your code here ``` Your function should return an integer representing the number of palindromic substrings in `s`.","solution":"def count_palindromic_substrings(s: str) -> int: Returns the count of palindromic substrings in the given binary string s. n = len(s) count = 0 # Helper function to check palindrome from the middle outwards def expand_around_center(left: int, right: int): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return count"},{"question":"You are developing a simple text editor with an auto-complete feature. The editor suggests completions of words based on a given **dictionary** of words. Given a string `input` and a list of strings `dictionary`, return a list of all words from the dictionary that start with `input`. The returned words should be in alphabetical order. If no words match, return an empty list. For example, given `input` = \\"ap\\" and `dictionary` = [\\"apple\\", \\"apply\\", \\"banana\\", \\"band\\", \\"bandage\\"], the function should return `[\\"apple\\", \\"apply\\"]`. Implement the function that follows the behavior described.","solution":"def auto_complete(input, dictionary): Returns a list of all words from the dictionary that start with the input string. The returned words are in alphabetical order. Parameters: input (str): The prefix to be matched. dictionary (list): The list of words to search in. Returns: list: A list of matched words sorted in alphabetical order. matched_words = [word for word in dictionary if word.startswith(input)] matched_words.sort() return matched_words"},{"question":"Write a function that, given a string `s` containing digits from `2` to `9` inclusive, returns all possible letter combinations that the number could represent on a phone keypad. The mapping of digits to letters is given below. Note that 1 does not map to any letters. - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Return the combinations in any order. If the input string is empty, return an empty array.","solution":"def letter_combinations(digits): Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent on a phone keypad. if not digits: return [] mapping = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = mapping[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"You are given an integer array `heights` where `heights[i]` represents the height of the `i-th` building. The problem is to find and return the number of buildings that have a sunset view. A building has a sunset view if it is not blocked to the west (meaning its height is greater than all the buildings to its left). The buildings are initially looking to the west (left side). Return the indices of the buildings that have a sunset view, in the same order as they appear in the input list.","solution":"def buildings_with_sunset_view(heights): Returns the indices of the buildings that have a sunset view. A building has a sunset view if it is not blocked to the west (meaning its height is greater than all the buildings to its left). :param heights: List[int] - Heights of the buildings :return: List[int] - Indices of buildings with sunset view max_height = float(\'-inf\') result = [] for i in range(len(heights)): if heights[i] > max_height: result.append(i) max_height = heights[i] return result"},{"question":"Consider a matrix `mat` of size `n x m` where each cell contains a non-negative integer. You can start from any cell in the first row and move to any cell in the next row that is directly below, below-left, or below-right (if they exist). The goal is to find a path from the first row to the last row such that the sum of the values in the cells along the path is minimized. Return the minimum sum path from the top row to the bottom row of the matrix.","solution":"def minFallingPathSum(mat): Find the minimum path sum from top to bottom of a matrix, moving to any cell directly below, below-left, or below-right. :param mat: List[List[int]] :return: int n = len(mat) m = len(mat[0]) for i in range(1, n): for j in range(m): if j == 0: mat[i][j] += min(mat[i - 1][j], mat[i - 1][j + 1]) elif j == m - 1: mat[i][j] += min(mat[i - 1][j], mat[i - 1][j - 1]) else: mat[i][j] += min(mat[i - 1][j], mat[i - 1][j - 1], mat[i - 1][j + 1]) return min(mat[-1])"},{"question":"You are given a string `s` consisting of lowercase English letters. You can transform the string by performing a series of moves. In each move, you can select any two adjacent characters of the string and swap them. The goal is to transform the string into its lexicographically smallest permutation. Return _the minimum number of moves required to achieve this_.","solution":"def min_moves_to_smallest_lexicographical_permutation(s): def merge_count_split_inv(arr): if len(arr) <= 1: return arr, 0 middle = len(arr) // 2 left, left_inv = merge_count_split_inv(arr[:middle]) right, right_inv = merge_count_split_inv(arr[middle:]) sorted_arr, split_inv = merge_and_count(left, right) return sorted_arr, left_inv + right_inv + split_inv def merge_and_count(left, right): sorted_arr = [] split_inv = 0 i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) split_inv += len(left) - i j += 1 sorted_arr += left[i:] sorted_arr += right[j:] return sorted_arr, split_inv sorted_s, inversions = merge_count_split_inv(list(s)) return inversions"},{"question":"You are given a binary string `s` which consists of only \'0\'s and \'1\'s. A substring of `s` is considered valid if it contains an **equal number of consecutive \'0\'s and \'1\'s** and all the \'0\'s and all the \'1\'s in the substring are grouped consecutively. For example, in \\"0011\\", the entire string is valid, but \\"0101\\" is not. Write a function that returns the total **number of valid substrings** of `s`. Substrings that overlap are counted multiple times. Note: Your solution should be optimal in terms of time complexity.","solution":"def countBinarySubstrings(s): Returns the total number of valid substrings of s. counts = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: counts.append(count) count = 1 counts.append(count) valid_substrings = 0 for i in range(1, len(counts)): valid_substrings += min(counts[i-1], counts[i]) return valid_substrings"},{"question":"You are given a binary tree in which each node has a `val` property and pointers to left and right children. Design an algorithm to find the largest sum of values starting from the root node and ending at any leaf node. Return the largest sum.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_path_sum(root): if not root: return 0 if not root.left and not root.right: return root.val left_sum = max_root_to_leaf_path_sum(root.left) right_sum = max_root_to_leaf_path_sum(root.right) return root.val + max(left_sum, right_sum)"},{"question":"You are given an array of integers `nums` and a target integer `target`. Return _the number of unique pairs in the array that sum up to `target`_. A pair (a, b) is considered unique if no other pair (c, d) exists with the same elements such that `a + b = target` and `c + d = target`, regardless of the order of a and b. Note that you cannot use the same element twice in a pair.","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs in the array that sum up to the target. A pair (a, b) is considered unique if no other pair (c, d) exists with the same elements such that `a + b = target` and `c + d = target`, regardless of the order of a and b. nums = sorted(nums) left, right = 0, len(nums) - 1 unique_pairs = set() while left < right: current_sum = nums[left] + nums[right] if current_sum == target: unique_pairs.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return len(unique_pairs)"},{"question":"Given an integer array `nums`, you need to find the length of the longest subsequence such that all elements of the subsequence are sorted in strictly increasing order. Return the length of this longest subsequence.","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in nums. :param nums: List[int] - list of integers to examine :return: int - length of the longest increasing subsequence if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given an array `nums` of integers, where each element is a non-negative integer representing the maximum number of steps you can jump forward from that position. Write a function to determine if you can reach the last index starting from the first index. Return _true_ if you can reach the last index, or _false_ otherwise. For example: - For the input `[2,3,1,1,4]`, the output should be `true`. - For the input `[3,2,1,0,4]`, the output should be `false`.","solution":"def can_jump(nums): Determines if you can reach the last index from the first index. :param nums: List[int] - List of non-negative integers representing jump steps. :return: bool - True if you can reach the last index, False otherwise. max_reachable = 0 n = len(nums) for i in range(n): if i > max_reachable: return False max_reachable = max(max_reachable, i + nums[i]) return max_reachable >= n - 1"},{"question":"Given a list of strings `words`, return the length of the **longest** word chain you can form. A word chain is a sequence of words `[w1, w2, ..., wn]` with `n >= 1`, such that for each `i`, `1 <= i < n`, `wi` is formed by inserting exactly one letter anywhere in `wi-1`. For example, if you have the words `[\\"a\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]`, the longest possible word chain is `\\"a\\" -> \\"ba\\" -> \\"bca\\" -> \\"bdca\\"` with a length of 4.","solution":"def longestStrChain(words): Function to return the length of the longest word chain. words.sort(key=len) dp = {} longest_chain_length = 1 for word in words: current_length = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in dp: current_length = max(current_length, dp[predecessor] + 1) dp[word] = current_length longest_chain_length = max(longest_chain_length, current_length) return longest_chain_length"},{"question":"You are given a 2D board `m` x `n` representing a **maze** and an array of integers `start` of length 2 representing the starting point of the maze (`start[0]` representing row and `start[1]` representing column) and another array of integers `destination` of length 2 representing the destination point. Each cell in the maze can either be a `0` (empty space) or a `1` (wall). You can only traverse through the empty spaces `0` and cannot move through walls `1`. You can move in four possible directions: left, right, up, or down, until you hit a wall or the boundary of the maze. Return _true_ if there is a path from `start` to `destination` and _false_ otherwise.","solution":"def has_path(maze, start, destination): Determines if there\'s a path from start to destination in the maze. :param maze: List[List[int]], a 2D board representing the maze :param start: List[int], the starting point of the maze :param destination: List[int], the destination point of the maze :return: bool, True if there is a path from start to destination, False otherwise from collections import deque def is_safe(x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0 def stop_point(x, y, dx, dy): while is_safe(x + dx, y + dy): x += dx y += dy return (x, y) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([tuple(start)]) visited = set() visited.add(tuple(start)) while queue: x, y = queue.popleft() if [x, y] == destination: return True for dx, dy in directions: new_x, new_y = stop_point(x, y, dx, dy) if (new_x, new_y) not in visited: queue.append((new_x, new_y)) visited.add((new_x, new_y)) return False"},{"question":"Given an integer array `nums` representing the elements of a binary search tree (BST) in its level order traversal, construct the BST and return its root. The BST constructed should properly reflect all the properties of a BST: for any node, the left child will hold a value less than its own and the right child will hold a value greater than its own. You are guaranteed that the input array represents a valid level order traversal of a BST. Implement the function `constructBST(nums)`, which takes the `nums` array as input and returns the root of the BST. If the input array is empty, return `None`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructBST(nums): Constructs a binary search tree (BST) from the given level order traversal list. :param nums: List[int] - A list of integers representing the level order traversal of a BST. :return: TreeNode - The root of the constructed BST. if not nums: return None root = TreeNode(nums[0]) queue = [(root, float(\'-inf\'), float(\'inf\'))] i = 1 while i < len(nums): node, lower, upper = queue.pop(0) # Insert to the left subtree if i < len(nums) and lower < nums[i] < node.val: node.left = TreeNode(nums[i]) queue.append((node.left, lower, node.val)) i += 1 # Insert to the right subtree if i < len(nums) and node.val < nums[i] < upper: node.right = TreeNode(nums[i]) queue.append((node.right, node.val, upper)) i += 1 return root"},{"question":"You are given a list of non-negative integers `nums` and a target integer `k`. Your task is to determine if there are two distinct numbers in the list that add up to `k`. Return `true` if there are such two distinct numbers, otherwise return `false`. For example, given the list `nums = [1, 4, 5, 7]` and target `k = 9`, you should return `true` as `4 + 5` equals `9`.","solution":"def two_sum(nums, k): Determines if there are two distinct numbers in the list that add up to k. Args: nums (List[int]): A list of non-negative integers. k (int): The target sum. Returns: bool: True if there are two distinct numbers that add up to k, False otherwise. seen = set() for num in nums: if (k - num) in seen: return True seen.add(num) return False"},{"question":"You are given an integer array `numbers` representing the heights of a group of people standing in a line. Each person must step forward so that the line appears in increasing order of height from front to back. In one step, a person can move to an adjacent position either to the left or right. Compute _the minimum number of steps required to arrange everyone in non-decreasing order of height_.","solution":"def min_steps_to_sort(numbers): Compute the minimum number of steps required to arrange the numbers in non-decreasing order. sorted_numbers = sorted(numbers) steps = 0 for i in range(len(numbers)): if numbers[i] != sorted_numbers[i]: steps += 1 # Each mismatch requires one step to fix return steps // 2"},{"question":"Given a binary tree, return _a list of its node values in **preorder traversal**_. The preorder traversal is a type of depth-first traversal where nodes are processed in the order `root`, `left`, `right`. You may assume the binary tree is given in the form of a class `TreeNode` with the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the function: ```python def preorder_traversal(root: TreeNode) -> List[int]: ```","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root: TreeNode) -> List[int]: def traverse(node: TreeNode): if node is None: return result.append(node.val) traverse(node.left) traverse(node.right) result = [] traverse(root) return result"},{"question":"[Question] 4: Given a **0-indexed** array of integers `nums` and an integer `k`, find the **maximum** sum of any contiguous subarray of length `k`. If the array has fewer than `k` elements, return 0. Compute the maximum possible sum of a subarray with exactly length `k`.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of any contiguous subarray of length k. If the array has fewer than k elements, return 0. if len(nums) < k: return 0 current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"A coding bootcamp wants to keep track of the students\' attendance and calculate their attendance percentage at the end of the course. Each student signs in with their `studentId` at the beginning of a class and signs out at the end of the class. Implement the `AttendanceSystem` class: * `void signIn(int studentId, string date)` * A student with `studentId` signs in on the specific `date`. * A student can only sign in once per day. * `void signOut(int studentId, string date)` * A student with `studentId` signs out on the specific `date`. * A student can only sign out once per day. * `double calculateAttendance(int studentId)` * Returns the attendance percentage of the student with `studentId`. * The attendance percentage is calculated based on the number of days the student attended, divided by the total number of class days so far, multiplied by 100. You may assume all calls to the `signIn` and `signOut` methods are consistent. If a student signs in on a specific date, then they must also sign out on the same date. All events happen in chronological order.","solution":"class AttendanceSystem: def __init__(self): self.attendance = {} self.total_days = set() self.attendance_record = {} def signIn(self, studentId, date): if studentId not in self.attendance: self.attendance[studentId] = set() self.attendance[studentId].add(date) self.total_days.add(date) def signOut(self, studentId, date): # Sign out operation for consistency, although we are only tracking sign in days for simplicity. if studentId not in self.attendance_record: self.attendance_record[studentId] = set() self.attendance_record[studentId].add(date) def calculateAttendance(self, studentId): attended_days = 0 if studentId in self.attendance and studentId in self.attendance_record: attended_days = len(self.attendance[studentId].intersection(self.attendance_record[studentId])) total_class_days = len(self.total_days) if total_class_days == 0: return 0.0 return (attended_days / total_class_days) * 100"},{"question":"You are given an array `height` representing the heights of `n` towers, where the `i`-th tower has a height of `height[i]`. In one operation, you can choose any two different towers `i` and `j` (i.e., `i != j`) and increase the shorter of the two towers by 1 (if there is a tie, you can choose either). Return _the minimum number of operations required to make all the towers have the same height_.","solution":"def min_operations_to_equal_heights(height): Returns the minimum number of operations required to make all towers have the same height. Parameters: height (list): A list of integers representing the heights of the towers. Returns: int: The minimum number of operations required. n = len(height) max_height = max(height) total_operations = sum(max_height - h for h in height) return total_operations"},{"question":"Given a binary tree, return the sum of node values at the deepest level. A binary tree is represented using the `TreeNode` class, which contains `val`, `left`, and `right` members. The deepest level of the tree is defined as the level with the most number of edges from the root node. If there are multiple deepest levels with equal depth, return the sum of nodes at that level.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"You are given an array of integers `nums` and an integer `k`. We call an integer `x` a **good number** if `x` is divisible by `k`. Your task is to make all elements of the array `nums` **good numbers** by performing the following operation any number of times: Choose an element of the array `nums` and replace it with any integer divisible by `k`. Return _the **minimum** number of operations needed to make all elements of `nums` good numbers_.","solution":"def min_operations_to_make_good(nums, k): Returns the minimum number of operations needed to make all elements of the array nums good numbers (divisible by k). operations = 0 for num in nums: if num % k != 0: operations += 1 return operations"},{"question":"You are given a list of `strings` and an integer `k`. You need to determine which string(s) in the list contain at least `k` unique characters. Return the strings that meet this criteria in the order they appear in the input list. # Example ``` Input: strings = [\\"apple\\", \\"banana\\", \\"cherry\\"], k = 3 Output: [\\"apple\\", \\"banana\\"] ``` # Explanation - \\"apple\\" has 4 unique characters: [\'a\', \'p\', \'l\', \'e\'] which is more than or equal to `k`=3 - \\"banana\\" has 3 unique characters: [\'b\', \'a\', \'n\'] which is more than or equal to `k`=3 - \\"cherry\\" has 4 unique characters: [\'c\', \'h\', \'e\', \'r\', \'y\'] which is more than or equal to `k`=3.","solution":"def strings_with_k_unique_chars(strings, k): Returns the strings that contain at least k unique characters. Args: strings (list): A list of strings. k (int): The minimum number of unique characters a string must have. Returns: list: A list of strings that contain at least k unique characters. result = [] for string in strings: if len(set(string)) >= k: result.append(string) return result"},{"question":"You are given a list of `n` integers, where each integer represents the height of a building in a skyline. Your task is to calculate the total area covered by the buildings when viewed from the side, considering that two adjacent buildings with the same height merge into a larger block. Each building is 1 unit wide. The buildings are represented by one end as the start of the skyline and the opposite end as the finish. Return the total area covered by the skyline.","solution":"def skyline_area(heights): Calculates the total area covered by the buildings in the skyline. Parameters: heights (list of int): A list of integers representing the heights of the buildings. Returns: int: The total area covered by the skyline. if not heights: return 0 total_area = 0 current_height = heights[0] for height in heights: if height == current_height: total_area += height else: total_area += height current_height = height return total_area"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a skyline from left to right. You are tasked with returning the lexicographically smallest sequence of building heights that preserves the relative heights of all buildings. Essentially, you can reorder the buildings such that the sequence is the smallest possible lexicographically while maintaining the given relative height comparisons between any two buildings. Return the resulting array of heights.","solution":"def smallest_skyline_sequence(heights): Function to return the lexicographically smallest sequence of building heights that preserves the relative heights of all buildings. Parameters: heights (List[int]): A list of integers representing heights of buildings. Returns: List[int]: A list of integers representing the lexicographically smallest sequence of building heights, preserving the relative order. return sorted(heights)"},{"question":"Given an undirected graph with `n` nodes labeled from `0` to `n-1` and an array `edges` where each `edges[i] = [ai, bi]` represents a bidirectional edge between nodes `ai` and `bi`. A node in the graph is considered critical if after removing it and its associated edges, the number of connected components in the remaining graph increases. Write a function to find all critical nodes in the graph. The function should return a list of all critical nodes in ascending order. If there are no critical nodes, return an empty list.","solution":"def find_critical_nodes(n, edges): from collections import defaultdict, deque def build_graph(n, edges): graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) return graph def bfs_count_components(graph, start, removed): visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited and neighbor != removed: visited.add(neighbor) queue.append(neighbor) return visited def count_components(n, graph, removed): visited = set() count = 0 for i in range(n): if i not in visited and i != removed: count += 1 visited.update(bfs_count_components(graph, i, removed)) return count graph = build_graph(n, edges) initial_components = count_components(n, graph, -1) critical_nodes = [] for i in range(n): if count_components(n, graph, i) > initial_components: critical_nodes.append(i) return sorted(critical_nodes)"},{"question":"You are given a string `s` consisting of lowercase English letters and an array `queries` where each query is represented by a pair of indices `(left, right)`. For each query, your task is to determine if the substring of `s` from index `left` to index `right` (inclusive) can be converted to a palindrome by changing **at most one** character. Return an array of booleans where each boolean corresponds to a query and is `true` if the substring can be converted to a palindrome through at most one modification, and `false` otherwise.","solution":"def can_be_palindrome(s, left, right): Determines if the substring of s from index left to right (inclusive) can be converted to a palindrome by changing at most one character. substring = s[left:right+1] mismatches = 0 i, j = 0, len(substring) - 1 while i < j: if substring[i] != substring[j]: mismatches += 1 if mismatches > 1: return False i += 1 j -= 1 return True def can_convert_to_palindrome(s, queries): Evaluates each query to determine if the substring can be converted to a palindrome through at most one modification. Args: s : str : input string consisting of lowercase English letters queries : list of tuples : each tuple contains two integers representing a query Returns: list of bool : each boolean corresponds to a query and is True if the substring can be converted to a palindrome with at most one change and False otherwise results = [] for left, right in queries: results.append(can_be_palindrome(s, left, right)) return results"},{"question":"You are given a string `s` consisting of lowercase English letters. A subsequence is derived by deleting some or no characters from `s` without changing the order of the remaining characters. Return the number of **distinct** subsequences that can be derived from `s`. If two subsequences are the same, they should be counted as one. The answer can be large, so return it modulo `10^9 + 7`.","solution":"def distinct_subsequences(s: str) -> int: MOD = 10**9 + 7 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # There is one way to have an empty subsequence last_occurrence = {} for i in range(1, n + 1): dp[i] = 2 * dp[i - 1] % MOD if s[i - 1] in last_occurrence: dp[i] = (dp[i] - dp[last_occurrence[s[i - 1]] - 1] + MOD) % MOD last_occurrence[s[i - 1]] = i return (dp[n] - 1 + MOD) % MOD # Subtract 1 to exclude the empty subsequence"},{"question":"You are given a string `s` containing only lowercase letters. Your task is to rearrange the string such that it does not contain any repeating characters that are adjacent to each other. If such an arrangement is not possible, return an empty string `\\"\\"`. If there are multiple valid arrangements, any one of them is acceptable. Write a function that implements this rearrangement.","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. Returns an empty string if such an arrangement is not possible. # Step 1: Count the frequency of each character char_freq = Counter(s) # Step 2: Push all characters with their frequency into a max-heap # Heap for negative frequency to simulate a max-heap using Python\'s min-heap max_heap = [(-freq, char) for char, freq in char_freq.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_char and -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # Reduce the frequency as we are using one instance of the char rearranged_s = \'\'.join(result) # If all characters used exactly once, the length should match if len(rearranged_s) == len(s): return rearranged_s else: return \\"\\""},{"question":"You are given two strings `s1` and `s2` of lengths `n` and `m` respectively and an integer `k`. Your task is to determine whether you can transform `s1` into `s2` using exactly `k` operations. In one operation, you can choose any character of `s1` and change it to any other character. Additionally, you can perform a swap between any two positions in `s1`. Return _`true` if `s1` can be transformed into `s2` using exactly `k` operations, and `false` otherwise_.","solution":"def can_transform(s1, s2, k): Determine if s1 can be transformed into s2 using exactly k operations. An operation can be: 1. Changing any character in s1 to any other character. 2. Swapping any two positions in s1. if len(s1) != len(s2): return False n = len(s1) diff_count = sum(1 for a, b in zip(s1, s2) if a != b) if diff_count > k: return False # if the number of difference is odd, it needs an even number of operations to match it, vice versa if (k - diff_count) % 2 != 0: return False return True"},{"question":"Given an array of integers `nums` representing a sliding window, an integer `k`, and a threshold value `t`, return `true` if there are `two distinct indices i and j` in the array such that the absolute difference between `nums[i]` and `nums[j]` is at most `t` and the absolute difference between `i` and `j` is at most `k`. Otherwise, return `false`.","solution":"def contains_nearby_almost_duplicate(nums, k, t): Returns true if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. Otherwise, return false. if t < 0: return False window = {} for i, num in enumerate(nums): bucket = num // (t + 1) if bucket in window: return True if bucket - 1 in window and abs(num - window[bucket - 1]) <= t: return True if bucket + 1 in window and abs(num - window[bucket + 1]) <= t: return True window[bucket] = num if i >= k: del window[nums[i - k] // (t + 1)] return False"},{"question":"Given a list of words, group all anagrams together and return the list of groups. Each group should contain at least two words and be sorted in ascending order. The list of groups should also be sorted lexicographically based on the first word of each group. An anagram is a word formed by rearranging the letters of another, such as \\"cinema\\" and \\"iceman\\". Implement the function `List<List<String>> groupAnagrams(List<String> words)`.","solution":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups all anagrams together, each group containing at least two words, sorted in ascending order within each group, and the list of groups sorted lexicographically based on the first word of each group. :param words: List of words to be grouped :return: List of groups of anagrams anagrams = defaultdict(list) # Group words by sorted tuple of characters for word in words: sorted_word = tuple(sorted(word)) anagrams[sorted_word].append(word) # Filter groups with at least two words and sort each group grouped_anagrams = [sorted(group) for group in anagrams.values() if len(group) > 1] # Sort groups lexicographically based on the first word of each group grouped_anagrams.sort(key=lambda x: x[0]) return grouped_anagrams"},{"question":"You are given a **binary tree** where each node contains an integer value. The depth of a node is the number of edges from the root to the node. The tree is represented by a `TreeNode` class, where `TreeNode.val` is the integer value, `TreeNode.left` is the left child, and `TreeNode.right` is the right child. You need to return the **sum of values** of all nodes with an **even-valued grandparent**. A grandparent of a node is the parent of its parent, if it exists. If there are no nodes with even-valued grandparents, return `0`. The function signature is: ``` int sumEvenGrandparent(TreeNode root) ``` **Example:** ``` Input: Tree structure: 6 / 7 8 / / 2 7 1 3 / / 9 1 4 5 Output: 18 Explanation: The nodes with even-valued grandparents are 9, 1, and 4. In total, their sum is 9 + 1 + 4 = 18. ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumEvenGrandparent(root: TreeNode) -> int: def dfs(node, parent_val, grandparent_val): if not node: return 0 total = 0 if grandparent_val % 2 == 0: total += node.val total += dfs(node.left, node.val, parent_val) total += dfs(node.right, node.val, parent_val) return total return dfs(root, 1, 1) # We start with odd values for non-existent parent/grandparent"},{"question":"You are given a singly-linked list and an integer `k`. The list nodes are indexed from `0` to `n - 1`, where `n` is the length of the linked list. Your task is to rotate the list to the right by `k` places. For example, if the list is `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, the result should be `4 -> 5 -> 1 -> 2 -> 3`. Return the head of the modified list after performing the rotation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Compute the length of the linked list and make it circular old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 old_tail.next = head # Form a circle # Find the new tail, which is (length - k % length - 1) steps from the old head new_tail = head steps_to_new_tail = length - k % length - 1 for _ in range(steps_to_new_tail): new_tail = new_tail.next new_head = new_tail.next # The new head is next of the new tail new_tail.next = None # Break the circle to get the new list return new_head"},{"question":"A classroom is organizing a line-up competition where students need to stand in a specific order according to their scores. Each student is identified by their unique ID. Given an array of integers `scores` where `scores[i]` represents the score of the student with `ID i`, and an array `order` containing the IDs arranged in a way such that `order[i]` is the ID of the student who should stand at position `i` in the final line-up. Write a function that returns an array of students\' scores in the required order. Note: - The length of `scores` and `order` will be the same. - Each ID in `order` corresponds to a valid index in the `scores` array. Example: ```python scores = [78, 92, 85, 88] order = [2, 1, 3, 0] ``` Output: ``` [85, 92, 88, 78] ```","solution":"def arrange_scores(scores, order): Returns the scores arranged according to the given order of IDs. Parameters: scores (list of int): The list of scores where scores[i] represents the score of the student with ID i. order (list of int): The list of IDs representing the desired arrangement. Returns: list of int: The list of scores arranged according to the given order of IDs. return [scores[ID] for ID in order]"},{"question":"You are given a string `s` and an integer `k`. You need to perform the following operation exactly `k` times: - Choose any character from the string `s` and remove it. Your goal is to maximize the **number of distinct characters** present in the resulting string after `k` operations. Return the maximum number of distinct characters possible in the resulting string. Note that the order of characters in the string matters when removing characters to ensure maximum distinct count in the end.","solution":"def max_distinct_chars(s, k): Returns the maximum number of distinct characters in the string after removing exactly k characters. :param s: input string :param k: number of characters to remove :return: maximum number of distinct characters in the resulting string from collections import Counter freq = Counter(s) # Convert the frequency dictionary to a list of (character, frequency) tuples freq = [(char, count) for char, count in freq.items()] # Sort characters by their frequencies in ascending order freq.sort(key=lambda x: x[1]) # Remove characters with the lowest frequencies first for char, count in freq: if k >= count: k -= count s = s.replace(char, \'\') else: break # Calculate remaining distinct characters remaining_distinct_chars = len(set(s)) return remaining_distinct_chars"},{"question":"You are given a list of `n` integers, `heights`, representing the heights of `n` buildings. The buildings form a skyline viewed from a distance, and each building has a uniform width of `1`. The goal is to determine the maximum area of a rectangle that can be formed in the skyline. The rectangle must be formed using the heights of consecutive buildings. Return _the **maximum area** of such a rectangle_. Note that a rectangle\'s height is determined by the shortest building in the range of buildings considered for that rectangle, and its width is the number of consecutive buildings in that range.","solution":"def max_histogram_area(heights): Returns the maximum area of a rectangle in the histogram represented by heights. :param heights: List of integers representing height of buildings. :return: Maximum area of the rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar \'h\' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area for each popped bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given an array of integers, find the maximum sum of any **non-empty subsequence** such that at least one element of the subsequence is even. If no such subsequence exists, return `0`. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.","solution":"def max_even_subsequence_sum(arr): Finds the maximum sum of any non-empty subsequence such that at least one element is even. If no such subsequence exists, return 0. even_found = False max_sum = float(\'-inf\') for value in arr: if value % 2 == 0: even_found = True max_sum = max(max_sum, value, max_sum + value) return max_sum if even_found else 0"},{"question":"**[Question 4]:** You are given a 2D grid containing `\'1\'`s (land) and `\'0\'`s (water). An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. The grid has borders that are always considered water. Write a function to determine the total number of distinct islands in the grid. Note that two islands are considered distinct if they are not connected, even if they have the same shape. **For example, the grid below contains 3 unique shapes of islands: ``` [ [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'0\',\'0\',\'0\',\'1\',\'1\'], [\'0\',\'0\',\'0\',\'1\',\'1\'] ] ``` The above grid contains three islands: - Two identical islands in the top-left corner. - One unique island in the bottom-right corner.","solution":"def num_islands(grid): def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # Mark this cell as visited # Check all adjacent cells (left, right, up, down) dfs(grid, i, j - 1) dfs(grid, i, j + 1) dfs(grid, i - 1, j) dfs(grid, i + 1, j) if not grid or not grid[0]: return 0 island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': # Start a DFS to mark all cells in this island dfs(grid, i, j) island_count += 1 return island_count"},{"question":"Given a `list` of integers and an integer `X`, partition the `list` such that all items less than `X` come before items greater than or equal to `X`. The relative order of items in each partition should stay the same. Return the partitioned list.","solution":"def partition_list(input_list, x): Partitions the input list such that all integers less than x come before integers greater than or equal to x while maintaining the relative order. less_than_x = [item for item in input_list if item < x] greater_or_equal_x = [item for item in input_list if item >= x] return less_than_x + greater_or_equal_x"},{"question":"You are given a matrix `board` representing a `m x n` tic-tac-toe board. The board is initially filled with the characters \'` ``, \'`X`\', and \'`O`\' where: - The character \'` ` `) represents an empty cell. - The character \'`X` `) represents a move by player X. - The character \'`O` `) represents a move by player O. You need to check if there is a winner in the game. The winner is the player who has three of their moves in a row, column, or diagonal. Return the character `\'X\'` if player X has won, `\'O\'` if player O has won, or an empty string `\\"\\"` if there is no winner. Evaluate the board and return the result according to the rules described.","solution":"def evaluate_tic_tac_toe(board): Evaluates a tic-tac-toe board to determine if there is a winner. Args: board (List[List[str]]): A 2D list representing the tic-tac-toe board. Returns: str: The character \'X\' if player X has won, \'O\' if player O has won, or an empty string \\"\\" if there is no winner. def check_winner(player): # Check rows and columns for i in range(3): if all(board[i][j] == player for j in range(3)) or all(board[j][i] == player for j in range(3)): return True # Check diagonals if (board[0][0] == player and board[1][1] == player and board[2][2] == player) or (board[0][2] == player and board[1][1] == player and board[2][0] == player): return True return False if check_winner(\'X\'): return \'X\' if check_winner(\'O\'): return \'O\' return \\"\\""},{"question":"You are given an array of integers `nums` and an integer `k`. Define a **k-segment** of the array to be any contiguous subarray of length `k`. The **balance** of a k-segment is defined as the absolute difference between the number of even integers and the number of odd integers within that subarray. Your task is to find the **balance** of the k-segment with the smallest balance value in the array `nums`. Return _the smallest balance value among all possible k-segments_.","solution":"def smallest_balance(nums, k): Returns the smallest balance value among all possible k-segments. if not nums or k <= 0 or k > len(nums): return -1 def balance_of_segment(segment): even_count = sum(1 for num in segment if num % 2 == 0) odd_count = len(segment) - even_count return abs(even_count - odd_count) min_balance = float(\'inf\') for i in range(len(nums) - k + 1): segment = nums[i:i+k] current_balance = balance_of_segment(segment) min_balance = min(min_balance, current_balance) return min_balance"},{"question":"You are given a **0-indexed** integer array `arr` representing the heights of students, where the height of the `i-th` student is `arr[i]`. A group of students is happy if there are exactly three students in the group and the height of the first student is less than the height of the second, and the height of the second student is less than the height of the third. Return _the number of happy groups_ you can choose from the array. Each student can participate in at most one group.","solution":"def count_happy_groups(arr): Count the number of happy groups of 3 students. A group is happy if arr[i] < arr[j] < arr[k] for 0 <= i < j < k < len(arr). Parameters: arr (List[int]): List of student heights. Returns: int: Number of happy groups. happy_groups = 0 n = len(arr) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if arr[i] < arr[j] < arr[k]: happy_groups += 1 return happy_groups"},{"question":"Given a binary tree root, return the maximum sum of values in a single path from any node to any other node in the tree. The path does not necessarily need to pass through the root, and the nodes in the path must be connected by edges in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum sum of values in a single path from any node to any other node in the tree. def dfs(node): nonlocal max_sum if not node: return 0 # Compute the maximum path sum with highest value for the left and right child left_max_sum = max(dfs(node.left), 0) right_max_sum = max(dfs(node.right), 0) # Compute the maximum path sum with the current node as the root of the path current_sum = node.val + left_max_sum + right_max_sum # Update the global max sum found max_sum = max(max_sum, current_sum) # Return the maximum path that can be extended to the parent return node.val + max(left_max_sum, right_max_sum) max_sum = float(\'-inf\') dfs(root) return max_sum"},{"question":"You are given two strings, `s` and `p`, both of which consist of lowercase English letters. You need to determine if `p` is a subsequence of `s`. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return _a boolean indicating whether_ `p` _is a subsequence of_ `s`. **Example**: - `s = \\"abcde\\"`, `p = \\"ace\\"` returns `true` since \'a\', \'c\', and \'e\' can be found in order in \\"abcde\\". - `s = \\"abcde\\"`, `p = \\"aec\\"` returns `false` since \'e\' cannot be found in the correct order following \'a\' and before \'c\'.","solution":"def is_subsequence(s, p): Returns True if p is a subsequence of s, otherwise False. s_index, p_index = 0, 0 while s_index < len(s) and p_index < len(p): if s[s_index] == p[p_index]: p_index += 1 s_index += 1 return p_index == len(p)"},{"question":"Given a binary tree, return the right side view of the tree. The right side view of a tree is a list of the nodes you can see when the tree is viewed from the right side. You have to return this list in the order from top to bottom. A binary tree is represented by its root node, and each node contains the integer value of that node, along with pointers to its left and right children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the right side view of the given binary tree. if not root: return [] right_view = [] queue = [root] while queue: level_length = len(queue) for i in range(level_length): node = queue.pop(0) if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"You are given a 2D grid of size `m x n` representing a map where \'1\' represents land and \'0\' represents water. Implement a function to count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Implement the `Solution` class: * `Solution(char[][] grid)` initializes the object with the grid map `grid`. * `numIslands()` returns the number of islands.","solution":"class Solution: def __init__(self, grid): self.grid = grid self.m = len(grid) self.n = len(grid[0]) if self.m > 0 else 0 def numIslands(self): if not self.grid: return 0 num_islands = 0 def dfs(i, j): if i < 0 or i >= self.m or j < 0 or j >= self.n or self.grid[i][j] == \'0\': return self.grid[i][j] = \'0\' dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) for i in range(self.m): for j in range(self.n): if self.grid[i][j] == \'1\': num_islands += 1 dfs(i, j) return num_islands"},{"question":"You are given an array `heights` representing the heights of a line of buildings. The city skyline viewed from the east is formed by considering the height of each building from right to left. Create a function `getSkylineView(heights)` that returns an array representing the skyline viewed from the east. The skyline should be expressed as a sequence of heights where each height corresponds to the highest remaining building at that position from the right. * `getSkylineView(heights)` should accept a single parameter: * `heights`: an array of positive integers where `heights[i]` represents the height of the `i-th` building. * Your implementation should return an array of integers representing the heights of buildings visible when viewed from the east.","solution":"def getSkylineView(heights): Returns the skyline view when observing the buildings from the east. Parameters: heights (list): A list of positive integers representing the heights of buildings. Returns: list: A list of integers representing the skyline viewed from the east. if not heights: return [] n = len(heights) skyline = [0] * n max_height = 0 # Traverse the buildings from right to left for i in range(n - 1, -1, -1): max_height = max(max_height, heights[i]) skyline[i] = max_height return skyline"},{"question":"You are tasked with developing a robot navigation system that helps a robot move through a 2D grid. The grid is filled with obstacles represented by \'1\' and empty spaces represented by \'0\'. The robot can move up, down, left, or right, but cannot move into a cell with an obstacle. The robot starts at the top-left corner of the grid (0,0) and must navigate to the bottom-right corner (n-1,m-1). Write a function that takes a 2D array `grid` as input and returns the length of the shortest path from the top-left to the bottom-right corner. If no such path exists, return -1. The grid is guaranteed to be rectangular, but it may not necessarily be square. The function signature is: `def shortest_path(grid: List[List[int]]) -> int:`","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left to the bottom-right corner of a 2D grid filled with obstacles (1) and empty spaces (0). If no such path exists, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # stores (row, col, distance) grid[0][0] = 1 # mark as visited by setting to 1 while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0: queue.append((new_row, new_col, dist + 1)) grid[new_row][new_col] = 1 # mark as visited return -1"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform the following operation any number of times: choose any character in the string and remove it, but you must also remove all contiguous occurrences of that character immediately to the left and right of the chosen character. Return _the minimum possible length of the string after performing the operation any number of times_.","solution":"def min_possible_length(s): Returns the minimum possible length of the string after performing the defined operations any number of times. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"You are given an integer array `nums` and an integer `k`. A **subarray** is a contiguous non-empty sequence of elements within an array. Return _the length of the shortest subarray that sums to at least `k`. If no such subarray exists, return_ `-1`. A **subarray** is a part of an array that consists of some or all of its elements between a specified start and end index.","solution":"from collections import deque def shortest_subarray(nums, k): Returns the length of the shortest subarray that sums to at least k. If no such subarray exists, return -1. n = len(nums) prefix_sum = [0] for num in nums: prefix_sum.append(prefix_sum[-1] + num) dq = deque() result = float(\'inf\') for i in range(n + 1): while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k: result = min(result, i - dq.popleft()) while dq and prefix_sum[i] <= prefix_sum[dq[-1]]: dq.pop() dq.append(i) return result if result != float(\'inf\') else -1"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements. Your task is to reorder the elements of the array such that all **odd-indexed** elements are moved to the beginning of the array in the same order they appeared, followed by all **even-indexed** elements in the same order they appeared. Return the reordered array. For example, given the array `nums = [10, 21, 32, 43, 54]`, the reordered array should be `[21, 43, 10, 32, 54]`.","solution":"def reorder_array(nums): Reorders the array such that all odd-indexed elements are first, followed by all even-indexed elements in their original order. Parameters: nums (List[int]): The input list of integers. Returns: List[int]: The reordered list of integers. odd_indexed_elements = [nums[i] for i in range(len(nums)) if i % 2 != 0] even_indexed_elements = [nums[i] for i in range(len(nums)) if i % 2 == 0] return odd_indexed_elements + even_indexed_elements"},{"question":"Given a matrix `mat` representing an image where each pixel value is an integer, define a pixel as a **peak** if it is not smaller than its 4-directionally (top, bottom, left, right) neighboring pixels. You need to find the peak element in the given image and return its coordinates as a tuple (row_index, col_index). If there are multiple peaks, return any one of them. Assume the matrix has at least one peak. Note: The outer edges of the matrix have fewer neighbors, but they can also be peaks.","solution":"def find_peak(mat): Find a peak element in the given matrix where a peak is a pixel not smaller than its 4-directional neighbors. Parameters: mat (list[list[int]]): 2D list of integers representing the matrix. Returns: tuple: coordinates of a peak element (row_index, col_index). def is_peak(mat, i, j): # Check 4 directional neighbors if i - 1 >= 0 and mat[i][j] < mat[i-1][j]: return False if i + 1 < len(mat) and mat[i][j] < mat[i+1][j]: return False if j - 1 >= 0 and mat[i][j] < mat[i][j-1]: return False if j + 1 < len(mat[0]) and mat[i][j] < mat[i][j+1]: return False return True for i in range(len(mat)): for j in range(len(mat[0])): if is_peak(mat, i, j): return (i, j)"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of only \'0\'s (water) and \'1\'s (land). An island is a maximal 4-directionally connected group of \'1\'s. You may assume all four edges of the grid are surrounded by water. Return _the number of **distinct islands**_. An island is considered distinct if it is not identical to another island (including rotation and reflection).","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, shape): if 0 <= x < m and 0 <= y < n and grid[x][y] == 1: grid[x][y] = 0 shape.append(direction) dfs(x+1, y, \'d\', shape) dfs(x-1, y, \'u\', shape) dfs(x, y+1, \'r\', shape) dfs(x, y-1, \'l\', shape) shape.append(\'b\') m, n = len(grid), len(grid[0]) unique_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1: shape = [] dfs(i, j, \'o\', shape) unique_islands.add(tuple(shape)) return len(unique_islands)"},{"question":"A warehouse has `n` stacks of boxes, with each stack having a certain number of boxes. The number of boxes in each stack is given by an integer array `boxes` of length `n`. The warehouse management wants to minimize the height difference between the tallest stack and the shortest stack by moving boxes between stacks. You are allowed to move boxes from any stack to any other stack, but you cannot create or destroy boxes. Your task is to return the minimum possible height difference that can be achieved after moving the boxes optimally. Write a function that takes an integer array `boxes` and returns the minimum possible height difference.","solution":"def minimize_height_difference(boxes): Returns the minimum possible height difference between the tallest stack and the shortest stack after moving boxes optimally. n = len(boxes) total_boxes = sum(boxes) # The average height we want to distribute across all stacks average_height = total_boxes // n # Calculate how many extra boxes we have after distributing evenly extra_boxes = total_boxes % n # We will have `extra_boxes` stacks with height `average_height + 1` and the rest with `average_height` min_height = average_height max_height = average_height + (1 if extra_boxes > 0 else 0) return max_height - min_height"},{"question":"You are given a list of `strings` where each string represents a word. Return the longest string `s` such that `s` can be constructed by concatenating one or more of the other strings in the list (each string in the list can be used exactly once). If there are multiple results with the same length, return the lexicographically smallest one. If no valid string exists, return an empty string.","solution":"def longest_concatenated_string(words): Returns the longest string that can be constructed by concatenating one or more of the other strings in the list. If multiple results with the same length, return the lexicographically smallest one. If no valid string exists, return an empty string. def can_form(word, words_set): if word in words_set: words_set.remove(word) dp = [True] + [False] * len(word) for i in range(1, len(word) + 1): for j in range(i): if dp[j] and word[j:i] in words_set: dp[i] = True break words_set.add(word) return dp[-1] words.sort(key=lambda x: (-len(x), x)) words_set = set(words) for word in words: if can_form(word, words_set): return word return \\"\\""},{"question":"Given a binary tree, implement a function to find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. You need to design the function in such a way that it computes the depth using a recursive approach. **Function Signature:** ```python def maxDepth(root: TreeNode) -> int: ``` **Example:** ```plaintext Input: root = [3,9,20,None,None,15,7] Output: 3 Input: root = [1,None,2] Output: 2 ``` **Evaluation Criteria:** 1. Correct identification of the base case(s) and recursive case. 2. Accurate calculation of the depth for both left and right subtrees. 3. Proper handling of edge cases (e.g., an empty tree).","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"You are given an integer array `heights` representing the heights of buildings. A building with height `heights[i]` can be seen if there is no building taller than or equal to `heights[i]` to its right. Return the number of buildings that can be seen when observing the skyline from the leftmost building to the rightmost.","solution":"def count_visible_buildings(heights): Returns the number of buildings that can be seen when observing the skyline from the leftmost building to the rightmost. if not heights: return 0 visible_count = 0 highest = 0 for height in heights: if height > highest: visible_count += 1 highest = height return visible_count"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find all **unique quadruplets** `[nums[a], nums[b], nums[c], nums[d]]` such that `a`, `b`, `c`, and `d` are different indices, and `nums[a] + nums[b] + nums[c] + nums[d] == target`. Return the list of all such unique quadruplets where the quadruplets are sorted in ascending order of their elements. You should write a function with the following signature: ```python def four_sum(nums: List[int], target: int) -> List[List[int]]: ``` # Additional Notes: - The solution set must not contain duplicate quadruplets. - You can assume that the input array will contain at most `200` integers. - The input array may have positive, negative, and zero values.","solution":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: nums.sort() result = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i-1]: continue # Avoid duplicates for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j-1]: continue # Avoid duplicates left, right = j + 1, length - 1 while left < right: sum_val = nums[i] + nums[j] + nums[left] + nums[right] if sum_val == target: result.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Avoid duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # Avoid duplicates left += 1 right -= 1 elif sum_val < target: left += 1 else: right -= 1 return result"},{"question":"Given a binary tree, return _the largest subtree sum_. The largest subtree sum is defined as the maximum sum of all the nodes in any subtree of the given binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_subtree_sum(root): def helper(node): if not node: return 0 left_sum = helper(node.left) right_sum = helper(node.right) current_sum = node.val + left_sum + right_sum max_subtree_sum.max_sum = max(max_subtree_sum.max_sum, current_sum) return current_sum max_subtree_sum.max_sum = float(\'-inf\') helper(root) return max_subtree_sum.max_sum"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a city. The array `heights` forms a skyline with each building having a rectangular shape and the width of each building being `1` unit. You want to compute the maximum rectangular area possible that can be formed from a contiguous subset of buildings. Return _the maximum rectangular area possible in the skyline represented by_ `heights`.","solution":"def largestRectangleArea(heights): Returns the largest rectangle area in the histogram defined by heights. n = len(heights) stack = [] max_area = 0 for i in range(n): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack: h = heights[stack.pop()] w = n if not stack else n - stack[-1] - 1 max_area = max(max_area, h * w) return max_area"},{"question":"Given an array of integers, determine whether the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Return `true` if such a partition is possible, otherwise return `false`. You must write an algorithm that runs in `O(n * sum(nums) / 2)` time and uses `O(sum(nums))` extra space, where `n` is the length of the array.","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. total_sum = sum(nums) # If total sum is odd, partitioning into two equal subsets is not possible if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a DP array to track achievable subset sums dp = [False] * (target + 1) dp[0] = True # We can always achieve sum 0 by taking no elements for num in nums: for t in range(target, num - 1, -1): if dp[t - num]: dp[t] = True return dp[target]"},{"question":"Given the head of a singly linked list, reverse the linked list and return the reversed list. Implement the `ListNode` class: - `class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; this.next = null; }}` And the `Solution` class with the method: - `public ListNode reverseList(ListNode head)`","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def reverseList(self, head: ListNode) -> ListNode: prev = None curr = head while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev"},{"question":"Given an integer array `nums`, find and return the largest sum of any non-empty subarray of `nums`. A **subarray** is a contiguous part of an array. You must find an efficient solution with a linear runtime complexity.","solution":"def max_subarray_sum(nums): Find the largest sum of any non-empty subarray of nums. Args: nums (List[int]): List of integers Returns: int: The largest sum of any non-empty subarray max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Given a binary tree, return the node with the maximum value in its level order traversal. If there are multiple nodes with the same maximum value, return the one which appears first in the level order traversal. Given the root of the binary tree, write a function to find and return the required node.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_value_in_level_order(root): if not root: return None from collections import deque queue = deque([root]) max_node = root while queue: node = queue.popleft() if node.val > max_node.val: max_node = node if node.left: queue.append(node.left) if node.right: queue.append(node.right) return max_node"},{"question":"You are given a list of integers `arr` and a target integer `k`. You need to count the number of continuous subarrays where the sum of the subarray is exactly `k`. A subarray is a contiguous non-empty sequence of elements within an array. Return the total count of such subarrays.","solution":"def count_subarrays_with_sum(arr, k): Counts the number of continuous subarrays where the sum of the subarray is exactly k. Args: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The count of subarrays which sum to k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in arr: current_sum += num count += prefix_sums.get(current_sum - k, 0) prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 return count"},{"question":"You are given a binary tree in which each node contains an integer value. Design an algorithm that returns the length of the **longest consecutive path** in the tree. This path refers to the sequence of parent-child connections where the values of the nodes are consecutive integers (either increasing by 1 or decreasing by 1). Note that the consecutive path does not necessarily have to pass through the root.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longestConsecutivePath(root): def dfs(node, parent_val, current_length, max_length): if not node: return max(current_length, max_length) if node.val == parent_val + 1 or node.val == parent_val - 1: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) max_length = dfs(node.left, node.val, current_length, max_length) max_length = dfs(node.right, node.val, current_length, max_length) return max_length if not root: return 0 return max(dfs(root, root.val, 0, 0), dfs(root, root.val, 0, 0))"},{"question":"You are developing a game where players need to find hidden treasures on a 2D grid. The grid `board` is represented by an `m x n` array where each cell contains either a `T` (treasure) or `E` (empty space). 1. A player can start from any treasure cell. 2. From a current cell, the player can move up, down, left, or right to an adjacent cell. 3. The player can only move to another treasure cell. Write a function to determine the maximum number of treasure cells that can be visited starting from any treasure cell. Return _the maximum number of connected treasure cells_ in the grid.","solution":"def max_connected_treasures(board): Find the maximum number of connected treasure cells in the 2D grid. Parameters: board (List[List[str]]): The 2D grid containing \'T\' and \'E\' characters. Returns: int: The maximum number of connected treasure cells. if not board or not board[0]: return 0 rows, cols = len(board), len(board[0]) max_treasures = 0 # Helper function for Depth-First Search def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != \'T\': return 0 # Mark the cell as visited board[r][c] = \'E\' size = 1 # Explore all four possible directions size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size # Iterate over the grid to find all treasure cells for i in range(rows): for j in range(cols): if board[i][j] == \'T\': max_treasures = max(max_treasures, dfs(i, j)) return max_treasures"},{"question":"You are given two integer arrays, `plants` and `capacity`, where `plants[i]` represents the number of flowers in the i-th plant and `capacity[j]` represents the watering capacity of the j-th bucket. Each bucket can water exactly one plant. Return `true` if it is possible to water all plants such that no bucket overflows and `false` otherwise. Note that each bucket can only water one plant and each plant requires exactly one bucket.","solution":"def can_water_all_plants(plants, capacity): Determines if all plants can be watered without any bucket overflowing. Args: plants (list of int): Number of flowers in each plant. capacity (list of int): Watering capacity of each bucket. Returns: bool: True if all plants can be watered without any bucket overflowing, False otherwise. plants_sorted = sorted(plants) capacity_sorted = sorted(capacity) for plant, bucket in zip(plants_sorted, capacity_sorted): if plant > bucket: return False return True"},{"question":"A retail store uses a point-of-sale system that logs all transactions made during the day. You are given a **0-indexed** integer array `transactions` representing the amount of each transaction. The store manager wants to find the **maximum profit** that can be obtained by combining a sequence of consecutive transactions. However, the sequence of combined transactions cannot include any transaction amount that is negative, as a negative transaction might indicate a refund or an error. Write a function `maxProfit(transactions)` that returns the largest sum of any subsequence of consecutive, non-negative transactions within the array. If all transactions are negative, return 0.","solution":"def maxProfit(transactions): Returns the maximum sum of any subsequence of consecutive, non-negative transactions within the array. max_profit = 0 current_profit = 0 for amount in transactions: if amount >= 0: current_profit += amount max_profit = max(max_profit, current_profit) else: current_profit = 0 return max_profit"},{"question":"You are given a `linked list` where the nodes are sorted in ascending order and contain a unique integer value. You need to detect and remove any nodes such that their values form a geometric progression, i.e., for every consecutive triplet `(a, b, c)`, it must satisfy the relation `b^2 = a * c`. You should maintain the order of the remaining nodes in the linked list. Write a function that returns the modified linked list after removing the nodes which are part of any geometric progression within triplets. Return _the head of the updated linked list_.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_geometric_triplets(head): Removes nodes from the linked list that form a geometric progression among triplets. :param head: ListNode - Head of the input linked list :return: ListNode - Head of the modified linked list # Dummy node to help easily handle edge cases dummy = ListNode(0, head) prev = dummy # Convert linked list to array for easier manipulation values = [] curr = head while curr: values.append(curr.val) curr = curr.next # Collect indices which are in geometric progression to_remove_set = set() n = len(values) for i in range(n - 2): if values[i] * values[i + 2] == values[i + 1] ** 2: to_remove_set.update([i, i + 1, i + 2]) # Remove nodes that are part of the geometric progression triplets curr = head idx = 0 while curr: if idx in to_remove_set: prev.next = curr.next else: prev = curr curr = curr.next idx += 1 return dummy.next"},{"question":"You are given a string `t` that consists of lowercase English letters and an integer `k`. You need to find the longest substring of `t` that contains at most `k` distinct characters. Return the length of this longest substring. If there is no such substring, return 0. The input parameters will follow these constraints: 1 <= |t| <= 2 * 10^4 and 1 <= k <= 26.","solution":"def longest_substring_with_k_distinct_chars(t, k): Returns the length of longest substring with at most k distinct characters. Parameters: t (str): The input string consisting of lowercase English letters. k (int): The maximum number of distinct characters allowed in the substring. Returns: int: The length of the longest substring with at most k distinct characters. from collections import defaultdict if k == 0: return 0 char_map = defaultdict(int) left = 0 max_length = 0 for right in range(len(t)): char_map[t[right]] += 1 while len(char_map) > k: char_map[t[left]] -= 1 if char_map[t[left]] == 0: del char_map[t[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given a binary tree, return the sum of the values of its deepest leaves. Implement a function `deepestLeavesSum(TreeNode root)` where `TreeNode` represents a node in the binary tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Return the sum of the values of the deepest leaves in the binary tree. if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_length = len(queue) for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"You are given an array of integers `arr` and a positive integer `k`. Write a function to determine the maximum product of `k` consecutive elements in the array. Return the maximum product. Note: - If the length of the array is less than `k`, return `-1`. - You may assume that the array contains only integers and may include negative numbers.","solution":"def max_product_k_consecutive(arr, k): Determines the maximum product of k consecutive elements in the array. Parameters: arr (list of int): The array of integers. k (int): The number of consecutive elements to consider. Returns: int: The maximum product of k consecutive elements or -1 if the array length is less than k. if len(arr) < k: return -1 max_product = float(\'-inf\') for i in range(len(arr) - k + 1): product = 1 for j in range(i, i + k): product *= arr[j] max_product = max(max_product, product) return max_product"},{"question":"Given a string `s` consisting of lowercase alphabets and an optional integer `n`, find and return the `n` most frequent characters in the string. If `n` is not provided, return the `1` most frequent character. If there are ties (characters with the same frequency), return the lexicographically smallest characters among them. Return the characters as a string in lexicographical order.","solution":"from collections import Counter def most_frequent_characters(s, n=1): Finds and returns the `n` most frequent characters in the string `s`. If `n` is not provided, returns the 1 most frequent character. In case of ties, returns the lexicographically smallest characters. The characters are returned as a string in lexicographical order. if not s: return \\"\\" # Count the frequency of each character in the string freq_counter = Counter(s) # Create a list of (character, frequency) and sort by frequency (desc) and char (asc) sorted_freq = sorted(freq_counter.items(), key=lambda x: (-x[1], x[0])) # Extract the top `n` most frequent characters most_frequent = sorted_freq[:n] # Get the characters from the tuples and sort them result_chars = sorted([char for char, freq in most_frequent]) return \'\'.join(result_chars)"},{"question":"Given a binary tree, write a function to check whether it is a mirror of itself (i.e., symmetric around its center). Implement a recursive approach to determine if the given binary tree is symmetric. The function should return `true` if the tree is symmetric, and `false` otherwise. Use the following class definition for the binary tree nodes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Checks whether a binary tree is a mirror of itself. if not root: return True def isMirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)) return isMirror(root.left, root.right)"},{"question":"Given an m x n binary matrix `mat`, return the length of the longest line of consecutive one’s in the matrix. The line could be horizontal, vertical, diagonal, or anti-diagonal. Implement the function `int longestLineOfConsecutiveOnes(vector<vector<int>>& mat)`.","solution":"def longestLineOfConsecutiveOnes(mat): if not mat or not mat[0]: return 0 rows, cols = len(mat), len(mat[0]) max_len = 0 # Initialize dp arrays dp_horizontal = [[0] * cols for _ in range(rows)] dp_vertical = [[0] * cols for _ in range(rows)] dp_diagonal = [[0] * cols for _ in range(rows)] dp_anti_diagonal = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): if mat[r][c] == 1: # Horizontal if c > 0: dp_horizontal[r][c] = dp_horizontal[r][c - 1] + 1 else: dp_horizontal[r][c] = 1 # Vertical if r > 0: dp_vertical[r][c] = dp_vertical[r - 1][c] + 1 else: dp_vertical[r][c] = 1 # Diagonal if r > 0 and c > 0: dp_diagonal[r][c] = dp_diagonal[r - 1][c - 1] + 1 else: dp_diagonal[r][c] = 1 # Anti-diagonal if r > 0 and c < cols - 1: dp_anti_diagonal[r][c] = dp_anti_diagonal[r - 1][c + 1] + 1 else: dp_anti_diagonal[r][c] = 1 # Update max_len found so far max_len = max(max_len, dp_horizontal[r][c], dp_vertical[r][c], dp_diagonal[r][c], dp_anti_diagonal[r][c]) return max_len"},{"question":"Given a string `s`, return _the number of distinct non-empty substrings of_ `s`. A **substring** is a contiguous sequence of characters within a string. For example, the substrings of \\"abc\\" are \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", and \\"abc\\".","solution":"def count_distinct_substrings(s): Returns the number of distinct non-empty substrings of s. substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"You are given an unsorted integer array `arr` and an integer `k`. Your task is to find the `k`-th largest element in the array without modifying the original array. You should solve this problem using the optimal O(n) time complexity algorithm. If there are multiple occurrences of the `k`-th largest element, return any one of them. Write a function that completes this task and returns the `k`-th largest element.","solution":"def kth_largest_element(arr, k): Find the k-th largest element in the array without modifying the original array. def quickselect(array, left, right, k_smallest): Quickselect helper function to find the k-th smallest number in the array. if left == right: return array[left] pivot_index = right pivot_index = partition(array, left, right, pivot_index) if k_smallest == pivot_index: return array[k_smallest] elif k_smallest < pivot_index: return quickselect(array, left, pivot_index - 1, k_smallest) else: return quickselect(array, pivot_index + 1, right, k_smallest) def partition(array, left, right, pivot_index): pivot = array[pivot_index] array[pivot_index], array[right] = array[right], array[pivot_index] store_index = left for i in range(left, right): if array[i] < pivot: array[store_index], array[i] = array[i], array[store_index] store_index += 1 array[right], array[store_index] = array[store_index], array[right] return store_index n = len(arr) if k < 1 or k > n: raise ValueError(\\"k is out of bounds\\") return quickselect(list(arr), 0, n - 1, n - k)"},{"question":"You are given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, where `nums1` has enough space to hold additional elements from `nums2`. Write a function that merges the two arrays into a single sorted array in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array `nums1`. Note: Modify `nums1` in place without using extra space for another array.","solution":"def merge(nums1, m, nums2, n): Given two sorted arrays nums1 and nums2 of size m and n respectively, merge nums2 into nums1 as one sorted array in non-decreasing order. Do not return anything, modify nums1 in-place instead. while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[m + n - 1] = nums1[m - 1] m -= 1 else: nums1[m + n - 1] = nums2[n - 1] n -= 1 # If any elements remain in nums2, copy them over nums1[:n] = nums2[:n]"},{"question":"You are given an integer array `nums` and an integer `k`. A **k-product subarray** is a subarray of length `k` from `nums` where the product of its elements is as large as possible. Return the maximum product of any **k-product subarray**. If there is no valid subarray of length `k`, return `-1`.","solution":"def max_k_product_subarray(nums, k): Returns the maximum product of any k-product subarray of length k. If there is no valid subarray of length k, returns -1. n = len(nums) if k > n: return -1 max_product = float(\'-inf\') for i in range(n - k + 1): product = 1 for j in range(k): product *= nums[i + j] max_product = max(max_product, product) return max_product"},{"question":"You are given a list of integers `nums` and an integer `target`. Return all unique pairs of integers from the list that add up to the target. Each pair should be represented as a tuple and the pairs should be listed in ascending order (ignoring the order within individual pairs). Ensure that no pair is repeated in the output.","solution":"def find_pairs(nums, target): Returns a list of unique pairs of integers from the list `nums` that add up to `target`. Each pair will be represented as a tuple and the pairs will be listed in ascending order. nums.sort() pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. The list may contain unique values. Return the rotated list in the same structure. For example, given the list `[1, 2, 3, 4, 5]` and `k = 2`, the rotated list would be `[4, 5, 1, 2, 3]`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or k == 0: return head # Count the number of nodes and find the tail old_tail = head n = 1 while old_tail.next: old_tail = old_tail.next n += 1 k = k % n if k == 0: return head # Find the new tail, which is (n - k - 1)th node from the beginning new_tail = head for _ in range(n - k - 1): new_tail = new_tail.next # Find the new head, which is (n - k)th node from the beginning new_head = new_tail.next # Rotate the list new_tail.next = None old_tail.next = head return new_head"},{"question":"Write a function that takes in an integer array `nums` and an integer `target`, and returns an array of all unique pairs `[nums[i], nums[j]]` such that `nums[i] + nums[j] == target`. Each pair should be sorted in ascending order, and the pairs themselves should be sorted in ascending order based on their first elements. If there are multiple pairs with the same first element, sort them by their second elements. Ensure that no duplicate pairs are present in the output.","solution":"def find_pairs(nums, target): Find all unique pairs in the array that sum up to the target. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: List[List[int]]: List of unique pairs. nums.sort() pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((complement, num)) seen.add(num) return [list(pair) for pair in sorted(pairs)]"},{"question":"Given a list of `strings`, return the list of strings after removing the duplicates and sorting them in lexicographical order. The comparison should be case-insensitive, but the returned list should preserve the original letter casing of the first occurrence in the input. If there is a tie on the first occurrence, keep the later one in the list. For example, given `strings` = `[\\"apple\\", \\"Banana\\", \\"Apple\\", \\"banana\\", \\"Cherry\\", \\"cherry\\"]`, the returned list should be `[\\"apple\\", \\"Cherry\\", \\"Banana\\"]`.","solution":"def remove_and_sort(strings): Removes duplicates from a list of strings and sorts them lexicographically, while preserving the case and order of first occurrence of each unique string. seen = {} for s in reversed(strings): seen[s.lower()] = s return sorted(seen.values(), key=lambda s: s.lower())"},{"question":"You are given a string `s` consisting of lowercase English letters and you need to perform a series of character replacement operations. You can replace characters at certain positions with any letter to achieve additional goals. Define a goal string `goal` which must be a substring of your final string. Determine the minimum number of replacements needed to change `s` so that it contains `goal` as a substring. Return the minimum number of changes required.","solution":"def min_replacements_to_substring(s, goal): Given a string s and a goal string, this function returns the minimum number of replacements needed to make goal a substring of s. n, m = len(s), len(goal) min_replacements = float(\'inf\') for i in range(n - m + 1): current_replacements = 0 for j in range(m): if s[i + j] != goal[j]: current_replacements += 1 min_replacements = min(min_replacements, current_replacements) return min_replacements if min_replacements != float(\'inf\') else -1"},{"question":"Given a binary tree, flatten it into a linked list in-place. For example, given the following tree: ``` 1 / 2 5 / 3 4 6 ``` The flattened tree should look like: ``` 1 2 3 4 5 6 ``` The resulting linked list should use the right child pointers as the next node in the list, and the left child pointers should all be null. Write an algorithm to perform this transformation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the tree into a linked list in-place. if not root: return None # Pointing to the current node current = root while current: if current.left: # Find the rightmost node of the left subtree. rightmost = current.left while rightmost.right: rightmost = rightmost.right # Reconnect nodes rightmost.right = current.right current.right = current.left current.left = None current = current.right"},{"question":"You are given an array of integers `arr` and an integer `target`. The array is **sorted in ascending order** and may contain duplicate integers. Your task is to determine if there are **two distinct indices** in the array such that the integers at those indices add up to the `target`. Return `true` if such a pair exists, otherwise return `false`. You must design an algorithm with a runtime complexity of `O(n)`.","solution":"def has_two_sum(arr, target): Determines if there are two distinct indices in the sorted array such that the integers at those indices add up to the target. :param arr: List[int] - Sorted array of integers :param target: int - Target sum :return: bool - True if such a pair exists, False otherwise left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a list of `n` items, each with an associated value. You need to implement a system to keep track of the top `k` highest values dynamically as items are added or updated. Specifically, you should support the following operations: - `add(item_id, value)`: Add a new item with the specified `item_id` and `value`. If the `item_id` already exists, update its value to the new `value`. - `top(k)`: Return the `k` highest values from the tracked items in descending order. Implement a class `TopKTracker` that supports these operations efficiently. For simplicity, you can assume all item values are unique.","solution":"import heapq class TopKTracker: def __init__(self): self.items = {} self.heap = [] def add(self, item_id, value): if item_id in self.items: # Update the item and its position in the heap self._remove_from_heap(item_id) self.items[item_id] = value heapq.heappush(self.heap, (value, item_id)) def _remove_from_heap(self, item_id): # Mark the existing item as removed in the items dictionary del self.items[item_id] # Remove the item from the heap by lazy deletion self.heap = [(v, id) for (v, id) in self.heap if id != item_id] heapq.heapify(self.heap) def top(self, k): top_items = heapq.nlargest(k, self.heap) return [item[1] for item in top_items]"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine the **smallest** substring of `s` (i.e., a substring with the minimum length) that contains at least one of each unique character present in `s`. Return _the length_ of _the smallest substring_ that meets this criterion.","solution":"def smallest_substring_length(s): from collections import Counter # Keep track of all unique characters in the original string unique_chars = set(s) required_chars_count = len(unique_chars) # Variables to keep track of the smallest substring left = 0 min_length = float(\'inf\') current_count = Counter() # Sliding window approach for right in range(len(s)): current_count[s[right]] += 1 # Check if the current window contains all unique characters while len(current_count) == required_chars_count: min_length = min(min_length, right - left + 1) current_count[s[left]] -= 1 if current_count[s[left]] == 0: del current_count[s[left]] left += 1 return min_length"},{"question":"You are given a grid of size `m x n` where each cell is either `0` (empty) or `1` (house). There are exactly `two` houses in the grid. You need to find the shortest distance between the two houses. The distance between two adjacent cells is `1`. You can move up, down, left, or right. Determine the shortest path distance between the two houses. Return the minimum distance between the two houses.","solution":"def shortest_distance_between_houses(grid): from collections import deque def bfs(start): queue = deque([start]) visited = set() visited.add(start) dist = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited: visited.add((nx, ny)) if grid[nx][ny] == 1: return dist + 1 queue.append((nx, ny)) dist += 1 house_positions = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 1] # There should be exactly two houses in the grid. if len(house_positions) != 2: raise ValueError(\\"There should be exactly two houses in the grid\\") # Start BFS from the first house and find the shortest path to the second house. return bfs(house_positions[0])"},{"question":"Given an array of positive integers `arr`, return the **maximum sum** of any **non-empty subsequence** such that all elements in the subsequence are strictly increasing. If there are multiple subsequences with the same maximum sum, return any one of them.","solution":"def max_sum_increasing_subsequence(arr): n = len(arr) # Initialize dp to keep the maximum sum of increasing subsequences ending at each index dp = arr[:] # To reconstruct the subsequence, keep track of previous indices prev = [-1] * n # Calculate dp values representing maximum sum of increasing subsequences for i in range(1, n): for j in range(i): if arr[j] < arr[i] and dp[j] + arr[i] > dp[i]: dp[i] = dp[j] + arr[i] prev[i] = j # Find the index of the maximum sum in dp max_sum_idx = dp.index(max(dp)) max_sum = dp[max_sum_idx] # Reconstruct the subsequence subsequence = [] while max_sum_idx != -1: subsequence.append(arr[max_sum_idx]) max_sum_idx = prev[max_sum_idx] subsequence.reverse() # To get the increasing order return max_sum, subsequence"},{"question":"You are given an n x n binary matrix `grid` representing a field of `0` (empty spaces) and `1` (obstacles). You can move up, down, left, or right from an empty space without moving out of the grid. Write a function to determine the minimum number of moves required to transform the grid into a fully traversable field with no obstacles, where every cell can be reached from any other cell by moving through empty spaces. If it is not possible, return -1.","solution":"from collections import deque def minimum_moves_to_full_traversable(grid): Returns the minimum number of moves required to transform the grid into a fully traversable field with no obstacles. If it is not possible, returns -1. n = len(grid) def neighbors(r, c): for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)): if 0 <= nr < n and 0 <= nc < n: yield nr, nc if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 # BFS to find the shortest path from top-left to bottom-right def bfs(): queue = deque([(0, 0, 0)]) # (row, column, distance) visited = {(0, 0)} while queue: r, c, d = queue.popleft() if (r, c) == (n-1, n-1): return d for nr, nc in neighbors(r, c): if (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, d+1)) return -1 return bfs()"},{"question":"Given a list of `n` unique integers, write a function to find all pairs of integers within the list that sum up to a given target value. Each pair should be represented as a list of two integers `[num1, num2]`, where `num1 <= num2`. The pairs should be returned in lexicographical order based on the first elements of the pairs, and if the first elements are the same, then based on the second elements. For example: Input: `nums = [1, 2, 3, 4, 5]`, `target = 5` Output: `[[1, 4], [2, 3]]` Return all the pairs of integers from the list that sum up to the target value. If no such pairs exist, return an empty list.","solution":"def find_pairs_with_target(nums, target): Returns a list of pairs from the list `nums` that sum up to the `target`. Each pair is represented as a list of two integers [num1, num2] where num1 <= num2. The pairs should be returned in lexicographical order. nums.sort() # Sort the numbers to help maintain order in the pairs found_pairs = [] num_set = set(nums) # Using a set for O(1) average time complexity in lookup for num in nums: complement = target - num if complement in num_set and complement > num: found_pairs.append([num, complement]) # Remove current number from set to avoid repetitive pairs num_set.remove(num) return found_pairs"},{"question":"You are given a list of strings `words` where each word is exactly the same length. Create a function that finds all pairs of indices `(i, j)` such that the concatenation of `words[i]` and `words[j]` forms a palindrome. Return a list of all the pairs of indices. A string is considered a palindrome if it reads the same forward and backward, including case-sensitivity and spaces.","solution":"def is_palindrome(s): Check if a given string s is a palindrome. return s == s[::-1] def palindrome_pairs(words): Finds all pairs of indices (i, j) such that the concatenation of words[i] and words[j] forms a palindrome. Parameters: words (list of str): A list of equal length strings. Returns: list of tuple: A list of tuples representing palindrome pairs. n = len(words) result = [] for i in range(n): for j in range(n): if i != j: if is_palindrome(words[i] + words[j]): result.append((i, j)) return result"},{"question":"You are given an array of integers `nums` representing the number of occurrences of each unique number in a list. Find the **second most frequent** number in the array. If there is no such element, return `-1`. Return the number itself, not its frequency. For example, given the array `[2, 3, 2, 4, 2, 4, 4, 5, 5]`, the output should be `4`, since `2` is the most frequent number with `3` occurrences and `4` is the second most frequent with `3` occurrences.","solution":"from collections import Counter def second_most_frequent(nums): Returns the second most frequent number in the nums list. If no such element exists, returns -1. if not nums: return -1 frequency = Counter(nums) most_common = frequency.most_common() if len(most_common) < 2: return -1 return most_common[1][0]"},{"question":"Given the `head` of a singly linked list, reverse the list and return the new head. A singly linked list is a data structure made up of nodes where each node contains a value and a reference (or link) to the next node in the sequence. The reversal must be done in-place, and you should not use any additional data structures. Ensure your solution has a time complexity of O(n), where n is the number of nodes in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head): Reverses the given singly linked list in-place and returns the new head. :param head: ListNode :return: ListNode prev = None current = head while current is not None: next_node = current.next # store the next node current.next = prev # reverse the current node\'s pointer prev = current # move the prev pointer to the current node current = next_node # move to the next node in the list return prev"},{"question":"You are given a string `s` representing an expression including integers and the plus and minus operators (`\'+\'` and `\'-\'`). The expression does not contain any spaces. For example, `\\"3+2-5\\"` represents the mathematical expression 3 plus 2 minus 5. Your task is to evaluate this expression and return the result as an integer. Implement a function that parses the given string and computes the result of the expression following the standard mathematical rules for addition and subtraction.","solution":"def evaluate_expression(s): Evaluates the given expression string that includes integers and plus and minus operators. Returns the result as an integer. total = 0 current_number = 0 sign = 1 # 1 for positive, -1 for negative i = 0 while i < len(s): if s[i].isdigit(): current_number = current_number * 10 + int(s[i]) elif s[i] == \'+\': total += sign * current_number current_number = 0 sign = 1 elif s[i] == \'-\': total += sign * current_number current_number = 0 sign = -1 i += 1 total += sign * current_number # Add the last accumulated number return total"},{"question":"You are given a list of integers `arr` of length `n`. You are tasked with finding the **maximum sum** of any **subarray** of length exactly `k` (where `1 <= k <= n`). Note that the subarray must consist of consecutive integers from `arr`. Return the maximum sum.","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of any subarray of length exactly k. n = len(arr) if k > n or k <= 0: raise ValueError(\\"k must be between 1 and the length of the array inclusive.\\") max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a binary tree, implement an iterator class `BSTIterator` that represents an in-order traversal of the tree. The iterator should support the following methods: - `BSTIterator(TreeNode root)`: Initializes an object of the `BSTIterator` class using the root of the binary tree. - `int next()`: Returns the next smallest number in the in-order traversal of the binary tree. - `boolean hasNext()`: Returns `true` if there are still nodes to be traversed, and `false` otherwise. You may assume that `next()` will always be called if `hasNext()` returns `true`. The objective is to write an efficient implementation of the `BSTIterator` class, making sure that both `next()` and `hasNext()` run in average O(1) time, and using O(h) memory, where h is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"You are given an array of non-negative integers `heights` representing the heights of pillars standing in a row. The width of each pillar is `1`. Rainwater can be trapped between the pillars if there are taller pillars on both the left and right sides of a current pillar. Compute the total volume of rainwater that can be trapped between the pillars after a rainstorm. Return the total amount of trapped rainwater.","solution":"def trap_rainwater(heights): Compute the total volume of rainwater that can be trapped between the pillars. Parameters: heights (List[int]): A list of non-negative integers representing the heights of pillars. Returns: int: The total volume of trapped rainwater. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"You are given an integer array `arr` representing the height of buildings, where `arr[i]` is the height of the building at position `i`. You need to return the number of buildings that have an unobstructed view to the west (left side). A building has an unobstructed view if and only if all buildings to its left are shorter in height. Write a function that takes an integer array `arr` and returns the number of buildings with an unobstructed view to the west. For example, given the height array `[3, 7, 8, 3, 6, 1]`, the function should return `3`, because the buildings with heights `3`, `7`, and `8` have an unobstructed view to the west.","solution":"def unobstructed_view_buildings(arr): Returns the number of buildings that have an unobstructed view to the west. if not arr: return 0 count = 0 max_height = -1 for height in arr: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given a string `str` consisting of lowercase English letters. Return _the length of the longest substring that contains exactly two distinct characters_. A substring is a contiguous sequence of characters within a string.","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains exactly two distinct characters. from collections import defaultdict if len(s) < 2: return len(s) left = 0 right = 0 max_len = 0 char_map = defaultdict(int) while right < len(s): char_map[s[right]] += 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given a list of strings `words` and another string `target`. You need to form the `target` string using a sequence of words from the list. Each word from the list can be used multiple times. Return the minimum number of words needed to form the `target` string, or `-1` if it is not possible to form the `target`. Implement the function: ```python def minWordsToFormTarget(words: List[str], target: str) -> int: # Implementation here ``` **Example:** ```python words = [\\"a\\", \\"aa\\", \\"aaa\\"] target = \\"aaaaa\\" minWordsToFormTarget(words, target) # Returns 2 because \\"a\\" (x5) or \\"aa\\" (x2) + \\"a\\" (x1) are both valid solutions words = [\\"cat\\", \\"bat\\", \\"rat\\"] target = \\"catbat\\" minWordsToFormTarget(words, target) # Returns 2 because \\"cat\\" + \\"bat\\" forms \\"catbat\\" words = [\\"cat\\", \\"bat\\"] target = \\"rat\\" minWordsToFormTarget(words, target) # Returns -1 because \\"rat\\" cannot be formed by any combination of \\"cat\\" and \\"bat\\" ```","solution":"from typing import List from collections import deque def minWordsToFormTarget(words: List[str], target: str) -> int: def bfs(): queue = deque([(target, 0)]) # (remaining target string, number of words used) seen = set() while queue: current_target, steps = queue.popleft() if current_target == \\"\\": return steps if current_target in seen: continue seen.add(current_target) for word in words: if current_target.startswith(word): next_target = current_target[len(word):] queue.append((next_target, steps + 1)) return -1 return bfs()"},{"question":"You are given an array `prices` where `prices[i]` is the price of the `ith` item. You can buy at most one item each day, but you have a special coupon that lets you buy one item for exactly `0` dollars on any given day. Write a function to maximize the total profit you can achieve by using the coupon on the day with the highest price and buying one other item each day. Return the maximum profit possible.","solution":"def maximize_profit(prices): Return the maximum profit possible by using the coupon on the highest price day and buying one item on other days. :param prices: List[int] :return: int if not prices: return 0 max_price = max(prices) total_sum = sum(prices) # Use the coupon on the day with the highest price max_profit = total_sum - max_price return max_profit"},{"question":"You have been given a class `Graph` that represents a directed graph using an adjacency list. The `Graph` class has the following methods: 1. `add_edge(u, v)`: Adds a directed edge from vertex `u` to vertex `v`. 2. `get_adjacency_list()`: Returns the adjacency list representation of the graph. Your task is to implement a method `find_strongly_connected_components()` in the `Graph` class that finds **strongly connected components** (SCCs) in the given graph. A graph is said to be strongly connected if every vertex is reachable from every other vertex. A strongly connected component is a maximal strongly connected subgraph. The method should return a list of lists, where each sublist contains the vertices of one SCC, sorted in ascending order. The list of SCCs should also be sorted based on the smallest vertex in each component. ```python class Graph: def __init__(self, vertices): self.vertices = vertices # Initialize other required data structures def add_edge(self, u, v): # Implement the method to add an edge from `u` to `v` def get_adjacency_list(self): # Implement the method to get the adjacency list representation of the graph def find_strongly_connected_components(self): # Implement the method to find all SCCs pass ```","solution":"from collections import defaultdict, deque class Graph: def __init__(self, vertices): self.vertices = vertices self.graph = defaultdict(list) def add_edge(self, u, v): self.graph[u].append(v) def get_adjacency_list(self): return dict(self.graph) def _dfs(self, v, visited, result): visited[v] = True result.append(v) for neighbor in self.graph[v]: if not visited[neighbor]: self._dfs(neighbor, visited, result) def _fill_order(self, v, visited, stack): visited[v] = True for neighbor in self.graph[v]: if not visited[neighbor]: self._fill_order(neighbor, visited, stack) stack = stack.append(v) def _transpose(self): g_t = Graph(self.vertices) for i in self.graph: for j in self.graph[i]: g_t.add_edge(j, i) return g_t def find_strongly_connected_components(self): stack = [] visited = [False] * self.vertices for i in range(self.vertices): if not visited[i]: self._fill_order(i, visited, stack) transposed_graph = self._transpose() visited = [False] * self.vertices sccs = [] while stack: v = stack.pop() if not visited[v]: scc = deque() transposed_graph._dfs(v, visited, scc) sccs.append(sorted(scc)) return sorted(sccs, key=lambda x: x[0])"},{"question":"You are given a **0-indexed** 2D integer array `rectangles`, where `rectangles[i] = [li, wi]` represent the length and width of the `ith` rectangle. Define a rectangle\'s aspect ratio as `li / wi`. A rectangle is considered \\"good\\" if its aspect ratio is greater than or equal to a given threshold `ratio`. Write a function `int countGoodRectangles(int[][] rectangles, float ratio)` which returns the number of \\"good\\" rectangles in the given array. Note: You may assume all rectangle dimensions and the ratio are positive non-zero values.","solution":"def countGoodRectangles(rectangles, ratio): Returns the number of rectangles with aspect ratio greater than or equal to the given ratio. :param rectangles: List of lists, where each sub-list contains two integers [li, wi]. :param ratio: Float, aspect ratio threshold. :return: Integer, count of \\"good\\" rectangles. count = 0 for l, w in rectangles: if l / w >= ratio: count += 1 return count"},{"question":"You are given a list of integers `arr` representing the height of blocks stacked sequentially. A building on each block provides shelter such that it prevents water from accumulating above this block and extends to adjacent lower blocks. Any block with a height greater than or equal to its neighboring blocks will prevent water from accumulating on top of it. With this arrangement, compute the total volume of water that can be trapped between the blocks after a rain. Return the total water volume as an integer.","solution":"def trap_rain_water(arr): Returns the total volume of water trapped between the blocks after rain. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n water = 0 left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) for i in range(n): water += min(left_max[i], right_max[i]) - arr[i] return water"},{"question":"[Question]: You are given a string `s` and an array of integers `indices` of the same length. The array `indices` is a permutation of the integers from `0` to `len(s) - 1`. Write a function to return a string `shuffled` such that `shuffled[i] == s[indices[i]]`.","solution":"def shuffle_string(s, indices): Returns the shuffled string such that shuffled[i] == s[indices[i]]. # Initialize a list of characters with the same length as s shuffled = [\'\'] * len(s) # Iterate through the indices and place each character in its new position for i, index in enumerate(indices): shuffled[index] = s[i] # Join the list into a string and return return \'\'.join(shuffled)"},{"question":"You are given a binary tree with `n` nodes, labeled from `0` to `n-1`. Each node has a value represented by an array `values` where `values[i]` is the value of the `i-th` node. You need to find the sum of values of all nodes at a given distance `k` from the root node. A distance of `k` from the root node means there are exactly `k` edges between the root node and the target nodes. Return the sum of the values of all such nodes.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_at_distance_k(root, k): Returns the sum of the values of nodes at distance k from the root node. if not root: return 0 current_level = [root] current_distance = 0 while current_level: if current_distance == k: return sum(node.value for node in current_level) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level current_distance += 1 return 0 # If k is larger than the height of the tree # Sample usage to create a binary tree and test the function def create_sample_tree(values): Helper function to create a binary tree from a list of values. nodes = [TreeNode(value=v) for v in values] for i in range(len(values)): left_index = 2 * i + 1 right_index = 2 * i + 2 if left_index < len(values): nodes[i].left = nodes[left_index] if right_index < len(values): nodes[i].right = nodes[right_index] return nodes[0] # Return the root node"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting only of `\'1\'`s (land) and `\'0\'`s (water). An island is a maximal group of `\'1\'`s connected 4-directionally (horizontal or vertical). There may be multiple islands in the grid, and each island is surrounded by water. The grid may have edges at the boundary, but islands cannot wrap around them. Write a function that returns the number of distinct islands in the grid. Each island represents a distinct set of cells and no two islands can share any cell.","solution":"def num_islands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != \'1\': return grid[i][j] = \'0\' dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\': dfs(i, j) island_count += 1 return island_count"},{"question":"You are given a linked list, where each node contains an integer value. Write a function to remove all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. The definition for the linked list node is below: class ListNode { public int val; public ListNode next; public ListNode(int val = 0, ListNode next = null) { this.val = val; this.next = next; } }","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_and_sort(head): if not head: return None value_count = {} # First pass: count all values current = head while current: value_count[current.val] = value_count.get(current.val, 0) + 1 current = current.next # Filter out nodes with duplicates dummy = ListNode(0) current = dummy for val, count in sorted(value_count.items()): if count == 1: current.next = ListNode(val) current = current.next return dummy.next def list_to_linked(lst): dummy = ListNode(0) current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linked_to_list(node): result = [] while node: result.append(node.val) node = node.next return result"},{"question":"Write a function that receives a string `s` and a list of pairs of indices `pairs` where `pairs[i] = [a, b]` indicates that the characters at indices `a` and `b` can be swapped. Return the lexicographically smallest string that `s` can be transformed into after using the allowed swaps. Note that you can use each swap any number of times. For example, given the string `s = \\"dcab\\"` and the pairs `pairs = [[0, 3], [1, 2]]`, possible transformations include swapping the characters at indices 0 and 3, and at indices 1 and 2, eventually producing the lexicographically smallest string \\"bacd\\".","solution":"def smallestStringWithSwaps(s, pairs): Returns the lexicographically smallest string that can be obtained by using the allowed swaps. from collections import defaultdict # Helper function to perform DFS and find all characters in the connected component def dfs(node, adj_list, visited, component): stack = [node] while stack: v = stack.pop() if not visited[v]: visited[v] = True component.append(v) for neighbor in adj_list[v]: if not visited[neighbor]: stack.append(neighbor) n = len(s) adj_list = defaultdict(list) # Create adjacency list for a, b in pairs: adj_list[a].append(b) adj_list[b].append(a) visited = [False] * n components = [] # Find connected components using DFS for i in range(n): if not visited[i]: component = [] dfs(i, adj_list, visited, component) components.append(component) s_list = list(s) # Sort components and assign the smallest characters to the positions for component in components: chars = sorted(s_list[i] for i in component) component.sort() for i, char in zip(component, chars): s_list[i] = char return \'\'.join(s_list)"},{"question":"You are given an array of strings `words` and a string `pattern`. Each string in `words` can be transformed into another string by replacing all occurrences of each letter with another letter while preserving the order of characters. Return _a list of all strings from `words` that match the given `pattern`._ You may assume that no two characters in the `pattern` map to the same character but a character may map to itself.","solution":"def find_and_replace_pattern(words, pattern): Finds all strings in words that match the given pattern. def match(word, pattern): if len(word) != len(pattern): return False word_to_pat = {} pat_to_word = {} for w_char, p_char in zip(word, pattern): if w_char not in word_to_pat: word_to_pat[w_char] = p_char if p_char not in pat_to_word: pat_to_word[p_char] = w_char if (word_to_pat[w_char], pat_to_word[p_char]) != (p_char, w_char): return False return True return [word for word in words if match(word, pattern)]"},{"question":"Calculate the sum of two integers without using the plus or minus operators. Implement the function `int getSum(int a, int b)` which returns the sum of `a` and `b`.","solution":"def get_sum(a, b): Calculate the sum of two integers without using the + or - operators. MAX = 0x7FFFFFFF mask = 0xFFFFFFFF while b != 0: # ^ gets the sum without carry # & gets the carry, and << shifts it left to add to the answer in the next iteration a, b = (a ^ b) & mask, ((a & b) << 1) & mask # If a is negative, convert a to a positive representation using ~a & mask return a if a <= MAX else ~(a ^ mask)"},{"question":"You are given a string `s` and an array of intervals `intervals`. Each interval represents a pair of integer indices `[start, end]` with `0 <= start <= end < len(s)`. Merge overlapping intervals and use them to extract a combined substring from `s`. Return _the lexicographically smallest substring that can be obtained by merging and extracting from the intervals_.","solution":"def merge_intervals(intervals): Merges overlapping intervals. intervals.sort() merged = [] for interval in intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1][1] = max(merged[-1][1], interval[1]) return merged def extract_substrings(s, intervals): Extracts substrings from the merged intervals and returns the lexicographically smallest substring. merged_intervals = merge_intervals(intervals) substrings = [s[start:end+1] for start, end in merged_intervals] return min(substrings) def get_lexicographically_smallest_substring(s, intervals): Returns the lexicographically smallest substring that can be obtained by merging and extracting from the intervals. return extract_substrings(s, intervals)"},{"question":"You are given a list of integers `arr` where each element appears exactly three times, except for one element which appears exactly once. Write a function to find this unique element. You must implement a solution with a linear runtime complexity and use only constant extra space.","solution":"def single_number(arr): Returns the element that appears only once in the array, where every other element appears exactly three times. The function runs in linear time and uses constant extra space. ones, twos = 0, 0 for num in arr: # First, add `num` to `twos` if it\'s already in `ones` twos |= ones & num # Toggle `num` in `ones` ones ^= num # Remove any numbers that appear in both `ones` and `twos` from both common_bits = ones & twos ones &= ~common_bits twos &= ~common_bits return ones"},{"question":"A peak element in an array is one that is greater than its neighbors. Given a **0-indexed** integer array `nums`, your task is to find the index of a peak element. You can assume the array contains at least one peak element. If the array contains multiple peaks, return the index to **any** one of the peaks. # Note: - `nums[-1]` and `nums[n]` are considered to be negative infinity (`-∞`), where `n` is the length of the array. # Example: ``` Input: nums = [1, 2, 3, 1] Output: 2 Explanation: 3 is a peak element (num[2] = 3) because it is greater than both its neighbors num[1] = 2 and num[3] = 1. Input: nums = [1, 2, 1, 3, 5, 6, 4] Output: 5 Explanation: 6 is a peak element (num[5] = 6) because it is greater than both its neighbors num[4] = 5 and num[6] = 4. Note: - Your solution should run in `O(log n)` time.","solution":"def find_peak_element(nums): Find a peak element in the list `nums` and return its index. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given a list of integers `nums` representing scores of participants in a competition. Each participant\'s score can either be positive or negative. A participant is said to be \\"exceptional\\" if their score is greater than or equal to the average score of the entire list. Return _the number of **exceptional** participants_.","solution":"def count_exceptional_participants(nums): Returns the number of exceptional participants. A participant is exceptional if their score is greater than or equal to the average score of the entire list. :param nums: List of integers representing scores. :return: Integer count of exceptional participants. if not nums: return 0 average_score = sum(nums) / len(nums) exceptional_count = sum(1 for score in nums if score >= average_score) return exceptional_count"},{"question":"Design a library management system that tracks books by their unique ISBN numbers and allows librarians to check in and check out books. Implement the `LibrarySystem` class: * `LibrarySystem()` Initializes the library system. * `void addBook(int isbn, String title, String author)` Adds a book to the system or updates an existing book\'s information. * `bool checkOutBook(int isbn)` Marks a book as checked out if it is currently available, returns `true` if successful, `false` otherwise. * `bool checkInBook(int isbn)` Marks a book as checked in, returns `true` if successful, `false` otherwise. * `String getBookInfo(int isbn)` Returns the title and author of the book in the format `\\"Title by Author\\"` if the book exists in the system, otherwise returns `null`.","solution":"class LibrarySystem: def __init__(self): # Dictionary to hold book ISBN as key and another dictionary as value to store details self.books = {} def addBook(self, isbn, title, author): # Add or update book information self.books[isbn] = {\'title\': title, \'author\': author, \'available\': True} def checkOutBook(self, isbn): # Check if the book exists and is available if isbn in self.books and self.books[isbn][\'available\']: self.books[isbn][\'available\'] = False return True return False def checkInBook(self, isbn): # Check if the book exists and is not available if isbn in self.books and not self.books[isbn][\'available\']: self.books[isbn][\'available\'] = True return True return False def getBookInfo(self, isbn): # Return the book\'s title and author if the book exists, else return None if isbn in self.books: return f\\"{self.books[isbn][\'title\']} by {self.books[isbn][\'author\']}\\" return None"},{"question":"Given an array of integers representing the amount of water stored in each container, calculate the maximum amount of water you can collect by selecting one container and optionally skipping one container after it. In other words, you want to select a container and then you can either take the next container or skip it to take the one after that. Return the maximum amount of water collected. Note that the containers must be selected in sequence from left to right. If no such sequence exists, return 0.","solution":"def max_water_collected(containers): Given an array of integers representing the amount of water stored in each container, calculate the maximum amount of water you can collect by selecting one container and optionally skipping one container after it. Args: containers (list of int): A list of integers representing the water in each container. Returns: int: The maximum amount of water that can be collected. n = len(containers) if n == 0: return 0 if n == 1: return containers[0] max_collect = [0] * n max_collect[0] = containers[0] max_collect[1] = max(containers[0], containers[1]) for i in range(2, n): max_collect[i] = max(max_collect[i-1], containers[i] + max_collect[i-2]) return max_collect[-1]"},{"question":"You are given an array of integers `arr` of length `n`, where `n` is even. You have to perform the following operations exactly `n/2` times: choose two elements from the array, remove them and insert the sum of those two elements back into the array. After performing all the operations, you will have only one element remaining in the array. Return _the **maximum possible value** of the last remaining element_.","solution":"import heapq def max_last_element(arr): Returns the maximum possible value of the last remaining element in the array after performing the defined operations. if len(arr) == 2: return sum(arr) # Convert to max heap by using negative values max_heap = [-x for x in arr] heapq.heapify(max_heap) while len(max_heap) > 1: # Pop two largest elements (smallest in terms of negative values) first = -heapq.heappop(max_heap) second = -heapq.heappop(max_heap) # Compute the sum of the two elements and push it into the heap new_element = first + second heapq.heappush(max_heap, -new_element) # Return the last remaining element (negate it to convert back to positive) return -max_heap[0]"},{"question":"You are given an array of integers `nums` and an integer `k`. In one move, you can pick any two integers from the array and replace their values with their sum. Your task is to determine whether it is possible to reach a state where all values in the array are divisible by `k` after a certain number of moves. If it is possible, return the minimum number of moves required; otherwise, return -1.","solution":"def min_moves_to_divisible_by_k(nums, k): Determine whether it is possible to reach a state where all values in the array `nums` are divisible by `k` after a certain number of moves. Return the minimum number of moves required; otherwise, return -1. remainder_set = {num % k for num in nums} # If the remainder_set contains only 0, all numbers are already divisible by k. if remainder_set == {0}: return 0 # If the remainder_set contains non-zero values, let\'s analyze further. if len(remainder_set) > 1 and 0 in remainder_set: return -1 return -1"},{"question":"Given an integer array `arr` of size `n`, find the number of **distinct triplets** `(i, j, k)` such that `0 <= i < j < k < n` and `arr[i] + arr[j] + arr[k]` is divisible by `m`. Return the number of such triplets.","solution":"def count_distinct_triplets(arr, n, m): Returns the number of distinct triplets (i, j, k) such that 0 <= i < j < k < n and arr[i] + arr[j] + arr[k] is divisible by m. Parameters: arr (list): The input list of integers. n (int): The size of the list. m (int): The divisor. Returns: int: The number of distinct triplets. count = 0 for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if (arr[i] + arr[j] + arr[k]) % m == 0: count += 1 return count"},{"question":"You are given an integer array `nums` where `nums[i]` is the value at the `i-th` index. You want to perform a series of operations to make all the elements in `nums` equal. In one operation, you can increment or decrement an element of the array by `1`. Return the minimum number of operations required to make all the elements in the array equal.","solution":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations required to make all elements in the array equal by incrementing or decrementing any element by `1`. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"You are given an array of integers `nums` and an integer `target`. You need to find two distinct integers in the array that add up to the `target` sum. The function should return the indices of the two numbers such that they add up to the given `target`. Assume that each input would have exactly one solution, and you may not use the same element twice. The solution should aim for an optimal time complexity.","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target sum. Args: nums (list): List of integers. target (int): Target sum. Returns: (int, int): Tuple of indices of the two numbers. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return num_to_index[complement], i num_to_index[num] = i"},{"question":"You are given an array of integers `arr` and an integer `x`. An operation involves inserting the integer `x` at any position in `arr` exactly once. Return _the **minimum** possible value of the mean (average) of the resulting array after performing the operation_. Remember, the mean of an array is the sum of its elements divided by the number of its elements.","solution":"def min_possible_mean(arr, x): Returns the minimum possible value of the mean (average) of the array after inserting x. original_sum = sum(arr) original_length = len(arr) min_mean = (original_sum + x) / (original_length + 1) return min_mean"},{"question":"You are given a list of strings `words` and a target string `target`. Each string in `words` consists of lowercase English letters. The goal is to determine the minimum number of words from the list `words` that need to be concatenated in any order to form the target string exactly. If it is not possible to form the target string using the given words, return `-1`. Return the minimum number of words needed or `-1` if it\'s not possible.","solution":"from collections import defaultdict, deque def min_words_to_form_target(words, target): Returns the minimum number of words from the list `words` that need to be concatenated in any order to form the target string exactly, or -1 if it\'s not possible. word_count = defaultdict(int) for word in words: word_count[word] += 1 # Create a queue for BFS, initialized with the target string queue = deque([(target, 0)]) visited = set() while queue: current_target, steps = queue.popleft() if current_target == \\"\\": return steps for word in words: if current_target.startswith(word): reduced_target = current_target[len(word):] if word_count[word] > 0: if reduced_target not in visited: visited.add(reduced_target) queue.append((reduced_target, steps + 1)) return -1"},{"question":"Implement a caching mechanism using the Least Recently Used (LRU) policy. Your implementation should support the following operations: `get` and `put`. The `get(int key)` operation retrieves the value of the key if the key exists in the cache; otherwise, it returns -1. The `put(int key, int value)` operation updates the value of the key if the key exists. Otherwise, it inserts the key-value pair into the cache. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. Implement the `LRUCache` class: * `LRUCache(int capacity)` initializes the LRU cache with positive size capacity. * `int get(int key)` retrieves the value of the key if the key exists, otherwise returns -1. * `void put(int key, int value)` updates the value of the key if the key exists, otherwise inserts the key-value pair. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. Your implementation should be such that the `get` and `put` operations run in `O(1)` time complexity.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) # Mark as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Remove least recently used item"},{"question":"**You are given two strings `s1` and `s2`, both of which consist of lowercase English letters. Determine whether `s2` can be formed by reordering the characters of `s1` and optionally adding one additional character. Return a boolean indicating whether it is possible.**","solution":"from collections import Counter def can_form_by_reordering_with_extra_char(s1, s2): Determines if s2 can be formed by reordering the characters of s1 and optionally adding one additional character. :param s1: The source string. :param s2: The target string. :return: Boolean indicating if s2 can be formed using s1 and optionally one additional character. if len(s1) + 1 < len(s2): # If s2 is longer than s1 + 1, it\'s impossible return False count_s1 = Counter(s1) count_s2 = Counter(s2) differences = count_s2 - count_s1 return len(differences) <= 1 and sum(differences.values()) <= 1"},{"question":"You are given a binary tree represented as a list where the parent-child relationships are determined based on the list indices (i.e., for an element at index `i`, its left child is at index `2*i + 1` and its right child is at index `2*i + 2`). Implement a function that returns a list of lists, where each sublist contains the nodes at each level of the binary tree starting from the root level. If a level has no nodes, it should be represented as an empty list in the output. For example, given the list `[3, 9, 20, None, None, 15, 7]`, the binary tree looks like: ``` 3 / 9 20 / 15 7 ``` The output should be `[[3], [9, 20], [15, 7]]`. Return _the list of lists representing the nodes at each level of the binary tree._","solution":"def binary_tree_levels(tree): if not tree: return [] from collections import deque result = [] queue = deque([(0, 0)]) # (index, level) current_level = 0 current_level_nodes = [] while queue: index, level = queue.popleft() if index >= len(tree) or tree[index] is None: continue if level != current_level: result.append(current_level_nodes) current_level_nodes = [] current_level = level current_level_nodes.append(tree[index]) queue.append((2 * index + 1, level + 1)) queue.append((2 * index + 2, level + 1)) if current_level_nodes: result.append(current_level_nodes) return result"},{"question":"You are given a string `steps` that represents the movements of a robot, where each character belongs to the set `{\'U\', \'D\', \'L\', \'R\'}` representing up, down, left, and right, respectively. The robot starts at the origin point `(0, 0)` on a 2D plane. The robot needs to determine if it eventually returns to the origin after completing its movements. The movements in the string are sequential, and each character denotes a single step in the respective direction. Return `true` _if the robot returns to the starting point after all movements. Otherwise, return_ `false`.","solution":"def does_robot_return_to_origin(steps): Determines if the robot returns to the origin after completing the movements. Parameters: steps (str): A string representing the movements of the robot. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for step in steps: if step == \'U\': y += 1 elif step == \'D\': y -= 1 elif step == \'L\': x -= 1 elif step == \'R\': x += 1 return x == 0 and y == 0"},{"question":"Given a string `s` consisting of lowercase English letters, you need to **cut** the string into as many parts as possible such that each letter appears in a maximum of one part. Return a list of integers representing the length of each part after the cuts. Each part should be contiguous. For example, for the input string `\\"ababcbacadefegdehijhklij\\"`, the output should be `[9,7,8]`.","solution":"def partition_labels(s): Given a string `s`, partitions the string into as many parts as possible such that each letter appears in a maximum of one part. Returns a list of integers representing the length of each part. :param s: string of lowercase English letters :return: list of integers of each part\'s length # Record the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(end - start + 1) start = i + 1 return partitions"},{"question":"Given a matrix `mat` of size `m x n` consisting of non-negative integers, you are allowed to perform the following operation any number of times: - Choose any submatrix of size `k x k` and add 1 to each of its elements. Return the minimum number of operations required to make all the elements of the matrix equal. If it\'s not possible to make all elements of the matrix equal, return `-1`. Note: A submatrix is a contiguous block within the matrix defined by its top-left and bottom-right corners.","solution":"def minOperationsToEqualMatrix(mat, k): Returns the minimum number of operations required to make all elements of the matrix equal. If it\'s not possible, returns -1. m = len(mat) n = len(mat[0]) def isPossible(mat, k): Checks if it is possible to make all matrix elements equal with operations of size `k x k`. ref = mat[0][0] % k for row in mat: for val in row: if val % k != ref: return False return True if not isPossible(mat, k): return -1 # Flatten matrix to sort and find median flat_mat = [elem for row in mat for elem in row] flat_mat.sort() median = flat_mat[(m * n) // 2] operations = 0 for row in mat: for val in row: operations += abs(val - median) // k return operations"},{"question":"Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, write a function `findElement(matrix, target)` that searches for a given target value in the matrix. If the target value exists in the matrix, return a pair of indices (row, column). If the target does not exist in the matrix, return `(-1, -1)`. Your algorithm should have a time complexity better than O(n^2).","solution":"def findElement(matrix, target): Searches for the given target in the matrix. If the target is found, returns a pair of indices (row, column). If the target is not found, returns (-1, -1). if not matrix or not matrix[0]: return (-1, -1) n = len(matrix) row, col = 0, n - 1 while row < n and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"You are given two integer arrays `source` and `target`, both consisting of **distinct** integers. Convert `source` into `target` by performing a series of operations. In each operation, you can pick any integer from `source` and move it to the end of the array without changing the order of the other elements. Return _the **minimum** number of such operations required to make_ `source` _identical to_ `target`_. If it is not possible to convert `source` into `target`, return `-1`.","solution":"def min_operations_to_convert(source, target): Returns the minimum number of operations required to convert source into target by moving elements to the end of the array while maintaining the order. If it is not possible to convert, returns -1. if sorted(source) != sorted(target): return -1 source_index_map = {val: idx for idx, val in enumerate(source)} max_len = 0 current_len = 0 prev_index = -1 for val in target: if source_index_map[val] > prev_index: current_len += 1 prev_index = source_index_map[val] else: max_len = max(max_len, current_len) current_len = 1 prev_index = source_index_map[val] max_len = max(max_len, current_len) return len(source) - max_len"},{"question":"You are given a string `s` consisting only of letters `\'a\'` and `\'b\'`. You can delete the string\'s characters to create a new string. However, there must not be any two consecutive characters that are the same in the resulting string. Write a function to return the minimum number of deletions needed to achieve this.","solution":"def min_deletions_to_avoid_consecutive_chars(s): Returns the minimum number of deletions needed to avoid any two consecutive characters being the same in the resulting string. if not s: # If the string is empty, no deletions are needed return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"You are given a string `t` consisting of lowercase English letters. You can choose to remove zero or more consecutive characters from the beginning or end of the string to make the remaining string a palindrome. A string is a palindrome if it reads the same backward as forward. Return _the length of the longest palindromic substring_ that can be obtained this way.","solution":"def longest_palindromic_substring(t): Returns the length of the longest palindromic substring that can be obtained by removing zero or more consecutive characters from the beginning or end of the string `t`. def is_palindrome(s): return s == s[::-1] n = len(t) max_length = 0 # Check all substrings that can be forms by removing characters from the beginning or the end for start in range(n): for end in range(start, n): substring = t[start:end+1] if is_palindrome(substring): max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an integer array `nums`, find the maximum length of a subarray where the absolute difference between any two elements is less than or equal to 1. If there are multiple subarrays with the same length, return the length of any one of them. The array `nums` could be empty, in which case the result should be `0`.","solution":"def find_max_length_subarray(nums): Find the maximum length of a subarray where the absolute difference between any two elements is ≤ 1. Args: nums : List[int] - The input integer array. Returns: int: The length of the longest such subarray. if not nums: return 0 max_length = 0 freqs = {} for num in nums: freqs[num] = freqs.get(num, 0) + 1 for num in freqs: current_length = freqs[num] if num + 1 in freqs: current_length += freqs[num + 1] max_length = max(max_length, current_length) return max_length"},{"question":"Given a matrix `mat` of integers, you are allowed to change **at most** `k` elements to any value. Return the maximum possible sum of the matrix elements after making the changes. Note that you can only change the elements within the matrix `k` times.","solution":"def max_matrix_sum(mat, k): Returns the maximum possible sum of the matrix elements after making at most k changes. Parameters: - mat (list of list of int): The matrix of integers. - k (int): The maximum number of elements that can be changed. Returns: - int: The maximum possible sum of the matrix elements after the changes. # Flatten the matrix into a list flat_list = [item for sublist in mat for item in sublist] # Sort list so we can easily pick out the smallest elements to replace flat_list.sort() # Change the smallest k elements to a very high value (infinity for simplicity) for i in range(min(k, len(flat_list))): flat_list[i] = float(\'inf\') # Return the sum of elements return sum(flat_list)"},{"question":"Given a binary tree, determine if it is a height-balanced binary tree. In this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Write a function: ```python def is_balanced(root: Optional[TreeNode]) -> bool: # Your code goes here ``` # Example: ```python Input: root = [3,9,20,None,None,15,7] Output: True ``` ```python Input: root = [1,2,2,3,3,None,None,4,4] Output: False ``` # Explanation: - For the first example: The tree [3,9,20,None,None,15,7] is a height-balanced binary tree. - For the second example: The tree [1,2,2,3,3,None,None,4,4] is not a height-balanced binary tree because the left subtree of the root node (with value 1) has a maximum depth of 3, while the right subtree has a maximum depth of 1. The difference in depths is greater than 1. # Constraints: - The number of nodes in the tree is in the range `[0, 5000]`. - The value of each node is an integer.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_balanced = abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, left_balanced and right_balanced and current_balanced return check_balance(root)[1]"},{"question":"Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \\"\\". You are given an array of strings `strs`. For an input of n strings, the output should be the longest common prefix shared among all the strings. Implement the function `longestCommonPrefix(String[] strs)`. The function should take an array of strings `strs` as input and return a string which is the longest common prefix. If there is no common prefix, return an empty string \\"\\".","solution":"def longestCommonPrefix(strs): Function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. if not strs: return \\"\\" # Initialize the prefix as the first string in the list prefix = strs[0] # Compare the prefix with each string in the list for string in strs[1:]: while string[:len(prefix)] != prefix: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"Given an array of integers representing data packets arriving in a network, all packets must be processed in a continuous sequence without any gaps. You are given an array `packets` where each element is a unique integer representing the unique ID of a packet. Determine if it is possible to reorder the array such that all packet IDs form a consecutive sequence, without any gaps. Return `true` if it is possible, and `false` otherwise.","solution":"def can_form_consecutive_sequence(packets): Returns True if the packets can be re-ordered to form a consecutive sequence without any gaps. if not packets: return False min_packet = min(packets) max_packet = max(packets) # Check if the length matches the range of numbers (max_packet - min_packet + 1) return max_packet - min_packet + 1 == len(packets)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to perform at most `k` replace operations on `s` where you can replace any character in the string with any other lowercase English letter. Your goal is to return the length of the longest substring containing the same letter you can get after performing the replace operations. Implement a function `int longestSubstringWithKReplacements(String s, int k)` that returns the length of the longest possible substring.","solution":"def longestSubstringWithKReplacements(s, k): Returns the length of the longest substring containing the same letter, after performing at most k replace operations on the string s. max_len = 0 max_count = 0 count = {} left = 0 for right in range(len(s)): count[s[right]] = count.get(s[right], 0) + 1 max_count = max(max_count, count[s[right]]) while (right - left + 1) - max_count > k: count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a binary tree root, return _the level order traversal of its nodes\' values._ (i.e., from left to right, level by level). The binary tree is represented using a TreeNode class that contains an integer value and pointers to its left and right children.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"Given an array of integers `nums`, a **peak element** is an element that is strictly greater than its neighbors. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that `nums[-1]` and `nums[nums.length]` are negative infinity. Write a function to find a peak element. Your solution should achieve logarithmic complexity.","solution":"def find_peak_element(nums): Find a peak element in an array and return its index. A peak element is an element that is strictly greater than its neighbors. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given a 2D grid of size `m x n` where each cell is either `0` (an empty cell) or `1` (a land cell). A move is considered valid if it\'s one step to an adjacent cell either in the horizontal or vertical direction but not diagonal. You need to find the shortest distance from the top-left corner (cell `(0, 0)`) to the bottom-right corner (cell `(m-1, n-1)`), traversing only through empty cells (`0`). If such a path does not exist, return `-1`. The distance is the number of moves required to reach the destination from the start. You can assume `1 <= m, n <= 100`.","solution":"from collections import deque def shortest_path(grid): Find the shortest path from the top-left corner to the bottom-right corner in a 2D grid using BFS. Traverses only through \'0\' cells, returns the number of moves. If no path exists, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == m-1 and col == n-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"A string `s` is considered nice if it contains an equal number of uppercase and lowercase letters. Given two integers `n` and `k`, and a string of length `n`, determine whether it is possible to rearrange the characters of the string so that every contiguous substring of length `k` is nice. If possible, return `true`; otherwise, return `false`. Implement the function `bool isNiceStringPossible(string s, int k)` that takes a string `s` and an integer `k`, and returns a boolean value indicating whether the string can be rearranged such that every contiguous substring of length `k` contains an equal number of uppercase and lowercase letters.","solution":"def isNiceStringPossible(s, k): Determine if it is possible to rearrange the string s so that every contiguous substring of length k contains an equal number of uppercase and lowercase letters. Parameters: s (str): The string to check. k (int): The length of the contiguous substrings. Returns: bool: True if possible, False otherwise. n = len(s) # If k is odd, it\'s impossible to have equal number of uppercase and lowercase letters if k % 2 != 0: return False # Count the number of uppercase and lowercase letters in the string uppercase_count = sum(1 for char in s if char.isupper()) lowercase_count = n - uppercase_count # For the string to be nice for substrings of length k, # there should be an equal number of uppercase and lowercase letters needed_each = k // 2 if min(uppercase_count, lowercase_count) >= needed_each * (n // k): return True return False"},{"question":"You are given a **non-empty** string `s` consisting of lowercase English letters. A **substring** is a contiguous sequence of characters within a string. Return _the **length** of the **smallest** substring of `s` that contains **at least k** distinct characters_. If there is no such substring, return `-1`.","solution":"def smallest_substring_with_k_distinct(s, k): Returns the length of the smallest substring of \'s\' that contains at least \'k\' distinct characters. If no such substring exists, return -1. if k > len(set(s)): return -1 n = len(s) min_length = n + 1 left = 0 char_map = {} for right in range(n): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) >= k: min_length = min(min_length, right - left + 1) char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 return min_length if min_length <= n else -1"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. Your task is to determine whether there are **two distinct indices** `i` and `j` in the array such that `nums[i] + nums[j] == k`. If such indices exist, return `true`; otherwise, return `false`. Write an algorithm that efficiently determines the presence of such a pair.","solution":"def has_pair_with_sum(nums, k): Returns True if there are two distinct indices i and j in the array such that nums[i] + nums[j] == k, otherwise returns False. seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"You are given an array of `n` integers `arr`, where `arr[i]` represents the number of steps required to jump to another position. Each element in the array can be positive or negative, where a positive value means jumping to the right and a negative value means jumping to the left. Starting from the first element, return _the minimum number of jumps required to reach the last element of the array_. If it is not possible to reach the last element, return `-1`. Implement a function `minJumps(arr: List[int]) -> int` to solve the problem.","solution":"from typing import List import sys def minJumps(arr: List[int]) -> int: n = len(arr) if n == 1: return 0 if arr[0] == 0: return -1 maxReach = arr[0] steps = arr[0] jumps = 1 for i in range(1, n): if i == n-1: return jumps maxReach = max(maxReach, i + arr[i]) steps -= 1 if steps == 0: jumps += 1 if i >= maxReach: return -1 steps = maxReach - i return -1"},{"question":"Given an `m x n` integer matrix `grid`, return the maximum sum of values in any path from the top-left corner to the bottom-right corner. You can only move either right or down at any point in time.","solution":"def max_path_sum(grid): Returns the maximum sum of values from the top-left corner to the bottom-right corner, moving only right or down. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row and the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given a 2D grid of size `m x n` representing a battlefield where: - Each cell contains an integer representing the number of enemy soldiers present in that cell. - A drone can be deployed to bomb a rectangular subgrid and eliminate all enemy soldiers in that subgrid. Given `m` and `n` and the grid of integers, determine the maximum number of enemy soldiers that can be eliminated in a single bombing. Return _the **maximum number** of enemy soldiers that can be eliminated._","solution":"def max_enemies_eliminated(grid): Returns the maximum number of enemy soldiers that can be eliminated in a single bombing. Parameters: grid (list of list of int): The 2D grid representing the battlefield where each cell contains an integer representing the number of enemy soldiers in that cell. Returns: int: The maximum number of enemy soldiers that can be eliminated. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_eliminated = 0 # Initialize auxiliary sum array prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] # Calculate prefix sums for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = grid[i][j] + prefix_sum[i + 1][j] + prefix_sum[i][j + 1] - prefix_sum[i][j] # Iterate over all possible subgrids for i1 in range(m): for j1 in range(n): for i2 in range(i1, m): for j2 in range(j1, n): current_sum = prefix_sum[i2 + 1][j2 + 1] - prefix_sum[i1][j2 + 1] - prefix_sum[i2 + 1][j1] + prefix_sum[i1][j1] max_eliminated = max(max_eliminated, current_sum) return max_eliminated"},{"question":"You are given a list of non-negative integers `arr`. Your task is to find if there exists a triplet (i, j, k) such that `i < j < k` and `arr[i] < arr[j] < arr[k]`. Return `true` if such a triplet exists, otherwise, return `false`.","solution":"def increasing_triplet(arr): Returns True if there exists a triplet (i < j < k) such that arr[i] < arr[j] < arr[k], otherwise False. :param arr: List of non-negative integers :return: Boolean if len(arr) < 3: return False first = float(\'inf\') second = float(\'inf\') for num in arr: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"You are given a string `s`, and you need to decode it. The decoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets well-formed, etc. Additionally, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. Return the decoded string.","solution":"def decode_string(s): Decodes the given encoded string \'s\' using the rule k[encoded_string]. stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append(current_str) stack.append(current_num) current_str = \'\' current_num = 0 elif char == \']\': num = stack.pop() prev_str = stack.pop() current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"You are given an array of strings `words` and an integer `k`. Each string represents a word and `k` represents the number of rows in a grid. The `words` array contains exactly `n` words which are to be placed in a grid with `k` rows such that: - Each row contains one or more words separated by a single space. - The arrangement should aim to balance the number of words in each row as evenly as possible, while maintaining the order. Return a list of strings where each string represents a row in the grid. Example: If `words = [\\"coding\\", \\"is\\", \\"fun\\", \\"and\\", \\"challenging\\"]` and `k = 2`, the output should be `[\\"coding is fun\\", \\"and challenging\\"]`.","solution":"def distribute_words(words, k): Distributes words into k rows as evenly as possible. Args: words : List[str] - List of words to be arranged. k : int - Number of rows in the grid. Returns: List[str] - List of strings where each string represents a row in the grid. n = len(words) avg = n // k extra = n % k result = [] index = 0 for i in range(k): count = avg + (1 if i < extra else 0) row = \\" \\".join(words[index:index+count]) result.append(row) index += count return result"},{"question":"You are given a string `s` and an integer `k`. You need to find the longest substring of `s` that contains at most `k` distinct characters. If there are multiple such substrings of the same length, return the one that appears first. Implement the method: ```python def longestSubstringWithKDistinct(s: str, k: int) -> str: ``` Your implementation should return a string representing the longest substring with at most `k` distinct characters.","solution":"def longestSubstringWithKDistinct(s: str, k: int) -> str: Finds the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The number of distinct characters allowed. Returns: str: The longest substring with at most k distinct characters. if k == 0 or not s: return \\"\\" char_map = {} left = 0 max_len = 0 longest_substr = \\"\\" for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 if right - left + 1 > max_len: max_len = right - left + 1 longest_substr = s[left:right + 1] return longest_substr"},{"question":"You are given a list of `n` processes, where each process is represented as a tuple `(start, end)` denoting its start time and end time. Your task is to determine the minimum number of machines required to run all the processes without any overlap. Implement a function `minMachines` that takes a list of tuples `processes` and returns the minimum number of machines needed. Each process must run uninterrupted on a single machine, but different processes can be run on different machines. Example: - Input: `processes = [(1, 4), (2, 5), (9, 12), (5, 9)]` - Output: `2` In this example, the first two processes overlap in time and must run on separate machines, while the third and fourth processes can share a machine and run sequentially.","solution":"def minMachines(processes): if not processes: return 0 start_times = sorted([process[0] for process in processes]) end_times = sorted([process[1] for process in processes]) max_machines = 0 current_machines = 0 i = 0 j = 0 while i < len(start_times) and j < len(end_times): if start_times[i] < end_times[j]: current_machines += 1 max_machines = max(max_machines, current_machines) i += 1 else: current_machines -= 1 j += 1 return max_machines"},{"question":"You are given a **0-indexed** integer array `scores` where `scores[i]` represents the score of the `i`th student. You are also given an integer `k` representing the number of students that need to be selected. Return the **maximum** possible sum of the scores of the `k` selected students. The constraint is that no two selected students should have adjacent indexes. For example, if `scores = [10, 5, 20, 15, 5, 10]` and `k = 3`, the maximum sum is `40` by selecting the students with scores `10`, `20`, and `10`.","solution":"def max_score_sum(scores, k): Returns the maximum possible sum of the scores of the k selected students such that no two selected students are adjacent. n = len(scores) if k == 0: return 0 if k > (n + 1) // 2: return None # not enough students to choose without selecting adjacent ones # dp[i][j] means the maximum sum we can get by selecting j students from the first i scores dp = [[0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, k + 1): # Option 1: Don\'t take the i-th student dp[i][j] = dp[i-1][j] if i > 1: # Option 2: Take the i-th student (ensure not taking the (i-1)th student) dp[i][j] = max(dp[i][j], dp[i-2][j-1] + scores[i-1]) elif j == 1: dp[i][j] = max(dp[i][j], scores[i-1]) return dp[n][k]"},{"question":"You are given a string `s` consisting of lowercase letters. A subsequence is called **special** if it can be rearranged to form a palindrome. Return _the length of the longest special subsequence in_ `s`. Note that a subsequence is a sequence that can be derived from `s` by deleting some or no characters without changing the order of the remaining elements.","solution":"def longest_special_subsequence(s): Returns the length of the longest special subsequence in s. from collections import Counter count = Counter(s) length = 0 odd_found = False for freq in count.values(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_found = True # If there is at least one odd frequency, we can place one odd character in the middle if odd_found: length += 1 return length"},{"question":"You are given a string `s` containing only lowercase alphabets and an integer `k`. You need to create a subsection with the following properties: - The subsection should be of length `k`. - The subsection should have the highest lexicographical value among all possible subsections of length `k` in the string. Return *the highest lexicographical subsection of length `k` from the string `s`.*","solution":"def highest_lexicographical_subsection(s, k): Returns the highest lexicographical subsection of length k from the string s. max_subsection = s[:k] for i in range(1, len(s) - k + 1): current_subsection = s[i:i+k] if current_subsection > max_subsection: max_subsection = current_subsection return max_subsection"},{"question":"Given an array of integers `nums` and an integer `k`, return the **length of the longest subarray** whose sum is equal to `k`. If there isn\'t one, return `0`. Note: - The subarray should be **continuous**. - The difference between the indices of the last element and the first element of the subarray should be maximal among all possible answers.","solution":"def max_subarray_len(nums, k): Returns the length of the longest subarray whose sum is equal to k. sum_indices = {0: -1} # Dictionary to store sum indices current_sum = 0 max_len = 0 for i, num in enumerate(nums): current_sum += num if current_sum - k in sum_indices: max_len = max(max_len, i - sum_indices[current_sum - k]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_len"},{"question":"You are given an integer array `cards` where `cards[i]` represents the value of the `i-th` card. A pair of cards `(i, j)` is called **beautiful** if the sum of `cards[i]` and `cards[j]` is divisible by `k`. Return _the maximum number of beautiful pairs you can form from the array `cards`_. Note that each card can be used at most once in forming a pair.","solution":"def max_beautiful_pairs(cards, k): Returns the maximum number of beautiful pairs that can be formed from the given list of card values and k. A pair (i, j) is considered beautiful if the sum of cards[i] and cards[j] is divisible by k. Each card can be used at most once. from collections import Counter remainder_counts = Counter(card % k for card in cards) pairs = 0 # Iterate over possible remainders for rem in range((k + 1) // 2): complement = (k - rem) % k if rem == complement: # When rem == 0 or rem is exactly half of k pairs += remainder_counts[rem] // 2 else: pairs += min(remainder_counts[rem], remainder_counts[complement]) return pairs"},{"question":"Given a matrix of `n` rows and `m` columns, where each cell contains an integer value representing the height of a terrain, write a function to find the number of \\"pits\\" in the matrix. A pit is defined as a cell whose height is strictly less than all of its 4 neighboring cells (up, down, left, right). The cells on the boundary do not count as pits because they do not have enough neighbors. Return the number of pits in the given matrix.","solution":"def count_pits(matrix): Count the number of pits in a given matrix. A pit is defined as a cell whose height is strictly less than all of its 4 neighboring cells (up, down, left, right). Boundary cells do not count as pits. Args: matrix (list of list of int): The matrix of terrain heights. Returns: int: The number of pits in the matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) pits_count = 0 for i in range(1, n - 1): for j in range(1, m - 1): if (matrix[i][j] < matrix[i-1][j] and matrix[i][j] < matrix[i+1][j] and matrix[i][j] < matrix[i][j-1] and matrix[i][j] < matrix[i][j+1]): pits_count += 1 return pits_count"},{"question":"You are given an array of integers `arr` where each element represents a speed limit on a section of a road. The police is trying to catch a speeding driver who is traveling at a constant speed along the road sections. At each section, if the driver\'s speed exceeds the speed limit of that section, the driver incurs a fine. The fine for each section is calculated as `(speed - limit)²`. Given the driver\'s speed `v` and the array `arr` of speed limits, return the total fine the driver incurs for the entire trip. If the driver does not exceed the speed limit on any section, the fine for that section is 0. Example: Given speed `v = 60` and `arr = [55, 60, 70, 50]`, the total fine would be calculated as follows: - Section 1: limit = 55, fine = (60 - 55)² = 25 - Section 2: limit = 60, fine = (60 - 60)² = 0 - Section 3: limit = 70, fine = (60 - 70)² = 0 (since the driver does not exceed the limit) - Section 4: limit = 50, fine = (60 - 50)² = 100 Return the total fine: 125","solution":"def total_fine(v, arr): Calculate the total fine for exceeding the speed limit across different road sections. Args: v (int): The constant speed of the driver. arr (list): A list of integers representing the speed limits on each section of the road. Returns: int: The total fine incurred by the driver. total_fine = 0 for limit in arr: if v > limit: total_fine += (v - limit) ** 2 return total_fine"},{"question":"Given a 2D grid of integers `grid` representing a map where each element represents the height at that point, write a function to determine the largest value that can be obtained by walking from any cell to any other cell by only moving up or right, starting at any cell `(i, j)` and ending at any cell `(x, y)`. The value obtained by a path is the sum of the heights of the cells included in the path. Return the maximum value path sum. You are not allowed to step off the boundaries of the grid.","solution":"def max_path_sum(grid): Returns the maximum path sum from any cell to any other cell in the grid moving only up or right. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"Given an integer array `arr`, return _the length of the **longest subarray**_ with elements that form an increasing sequence. An increasing sequence is one where `arr[i] < arr[i+1]` for every `i` in the subarray. If there are multiple subarrays with the same length, return the length of the first one encountered.","solution":"def longest_increasing_subarray_length(arr): Returns the length of the longest subarray with elements that form an increasing sequence. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given a list of non-negative integers `nums`. Build a binary tree such that: - Each node\'s value is the maximum value of the elements in the subarray to which the node corresponds. - The left child of the node corresponds to the subarray on the left of the maximum element. - The right child of the node corresponds to the subarray on the right of the maximum element. Return the root of the resulting binary tree. For example, given `nums = [3,2,1,6,0,5]`, the resulting binary tree should have root value `6` with left subtree `[3,2,1]` and right subtree `[0,5]`. Define a function `constructMaximumBinaryTree(nums: List[int]) -> TreeNode:` to solve this problem.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums: List[int]) -> Optional[TreeNode]: if not nums: return None max_index = nums.index(max(nums)) root = TreeNode(nums[max_index]) root.left = constructMaximumBinaryTree(nums[:max_index]) root.right = constructMaximumBinaryTree(nums[max_index+1:]) return root"},{"question":"You are given an integer array `nums`. A subsequence of `nums` is a sequence that can be derived from `nums` by deleting some or no elements without changing the order of the remaining elements. A subsequence is called **beautiful** if it is possible to reorder its elements such that the difference between every two adjacent elements is at most `k`, where `k` is a given integer. Return _the length of the longest beautiful subsequence_ in `nums`.","solution":"def longest_beautiful_subsequence(nums, k): Returns the length of the longest beautiful subsequence in the array nums where the difference between every two adjacent elements is at most k. n = len(nums) if n == 0: return 0 nums.sort() longest = 1 current_length = 1 for i in range(1, n): if nums[i] - nums[i - 1] <= k: current_length += 1 else: longest = max(longest, current_length) current_length = 1 longest = max(longest, current_length) return longest"},{"question":"Given an integer `n`, generate all possible unique combinations of balanced parentheses. Each combination should contain `n` pairs of parentheses. Return a list of all unique combinations in any order. Implement the function `generateParentheses(int n)`: * `List<String> generateParentheses(int n)` - which returns a list of strings, each string representing a valid combination of `n` pairs of balanced parentheses. **Example:** ``` Input: n = 3 Output: [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] Input: n = 1 Output: [\\"()\\"] ``` **Notes:** - A valid combination of parentheses is one where every opening parenthesis has a corresponding closing parenthesis and they are properly nested. - You may assume that the input `n` is a non-negative integer.","solution":"def generateParenthesis(n): Generates all combinations of n pairs of balanced parentheses. def backtrack(S = \'\', left = 0, right = 0): if len(S) == 2 * n: result.append(S) return if left < n: backtrack(S + \'(\', left + 1, right) if right < left: backtrack(S + \')\', left, right + 1) result = [] backtrack() return result"},{"question":"You are given an integer array `A` of length `n` where each element represents the quantity of apples collected by `i-th` farmer. You are also given an integer array `B` of length `m` where each element represents the quantity of apples required by the `i-th` buyer. Both arrays are sorted in non-decreasing order. Each farmer can sell apples to only one buyer, and each buyer can buy apples from only one farmer. A buyer can only buy apples from a farmer if the farmer has at least the quantity of apples the buyer requires. Return the maximum number of buyers that can be satisfied. **Note:** Both arrays `A` and `B` are not necessarily of the same length.","solution":"def max_satisfied_buyers(A, B): Returns the maximum number of buyers that can be satisfied given the quantity of apples collected by farmers and the quantity required by buyers. Parameters: A (list of int): The quantity of apples collected by each farmer, sorted in non-decreasing order. B (list of int): The quantity of apples required by each buyer, sorted in non-decreasing order. Returns: int: The maximum number of buyers that can be satisfied. i, j = 0, 0 satisfied_buyers = 0 while i < len(A) and j < len(B): if A[i] >= B[j]: satisfied_buyers += 1 j += 1 i += 1 return satisfied_buyers"},{"question":"Given an integer array `nums`, return _all possible unique permutations_ of the array. A permutation of an array is an arrangement of its elements in a specific order. Note that if there are duplicate elements in the input array, each unique permutation should appear only once. Write a function: ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` The function should take an array of integers as input and return a list of lists, where each sublist is a unique permutation of the input array.","solution":"from typing import List from itertools import permutations def permute_unique(nums: List[int]) -> List[List[int]]: Returns all possible unique permutations of the input list `nums`. unique_permutations = set(permutations(nums)) return [list(permutation) for permutation in unique_permutations]"},{"question":"You are given a series of integers in the form of a list where each integer represents the size of a file in bytes. Each file can be uploaded either by itself or grouped with other files. However, each upload has a maximum limit of bytes that can be handled. Given the list of file sizes and the maximum upload limit, return the **minimum number of uploads** required to upload all the files with each upload not exceeding the maximum limit. Implement the `FileUploader` class: * `FileUploader(int limit)` Initializes the object with the given maximum upload limit. * `int minUploads(List<Integer> fileSizes)` Returns the minimum number of uploads required to upload all the files based on their sizes and the maximum upload limit.","solution":"from typing import List class FileUploader: def __init__(self, limit: int): self.limit = limit def minUploads(self, fileSizes: List[int]) -> int: fileSizes.sort(reverse=True) uploads = 0 while fileSizes: current_upload_size = 0 i = 0 while i < len(fileSizes): if current_upload_size + fileSizes[i] <= self.limit: current_upload_size += fileSizes.pop(i) else: i += 1 uploads += 1 return uploads"},{"question":"You are given a string `s` and a string `t`. Write a function that determines if `t` is an anagram of a substring of `s`. An anagram of a string is another string that contains the same characters, only the order of characters can be different. Your function should return `true` if `t` is an anagram of any substring of `s`, and `false` otherwise. Note: A substring is a contiguous sequence of characters within a string.","solution":"from collections import Counter def is_anagram_of_substring(s, t): Determines if t is an anagram of any substring of s. len_s, len_t = len(s), len(t) if len_t > len_s: return False t_counter = Counter(t) window_counter = Counter(s[:len_t]) for i in range(len_t, len_s): if t_counter == window_counter: return True window_counter[s[i]] += 1 window_counter[s[i - len_t]] -= 1 if window_counter[s[i - len_t]] == 0: del window_counter[s[i - len_t]] # Check the last window if t_counter == window_counter: return True return False"},{"question":"You are given two strings `s1` and `s2`, each consisting of lowercase letters and each of length `n`. We can describe a **transformation** from one string to another using a sequence of operations, where in each operation you can choose an index `i` (0 <= i < n) and increment the character at this index (i.e., changing \'a\' to \'b\', \'b\' to \'c\', and so on up to \'z\' to \'a\'). Write a function to determine whether it is possible to transform `s1` into `s2`. If it is possible, return the **minimum number** of operations required to achieve this transformation. If it is not possible, return `-1`. Each character can be incremented any number of times, but the total number of operations across all characters should be minimized.","solution":"def min_operations_to_transform(s1, s2): n = len(s1) operations_needed = 0 for i in range(n): if s1[i] == s2[i]: continue diff = (ord(s2[i]) - ord(s1[i])) % 26 operations_needed += diff return operations_needed"},{"question":"You are given a string `s` representing a run-length encoded sequence where each character is followed by an integer representing the number of times the character appears consecutively. For example, the string `s = \\"a2b3c1\\"` should be decoded to \\"aabbbbc\\". You need to implement a function that, given `s`, returns the decoded string. Consider `s` will always be valid and in the correct format. For instance, for the input `\\"a2b3c1\\"`, the output should be `\\"aabbbc\\"`.","solution":"def decode_run_length(s): Decodes a run-length encoded string. Parameters: s (str): The run-length encoded string, e.g., \\"a2b3c1\\". Returns: str: The decoded string, e.g., \\"aabbbbc\\". decoded_string = \\"\\" i = 0 while i < len(s): char = s[i] count = int(s[i+1]) decoded_string += char * count i += 2 return decoded_string"},{"question":"You are given a binary tree where each node contains a positive integer. The binary tree has the following properties: - The root node is at level 1. - Every node at level `i` has exactly two children at level `i+1`, unless it\'s a leaf node. Your task is to implement a function that returns the **largest sum** of values of nodes at any **single level** in the binary tree. For example, in the tree where each level\'s nodes contain values `[1]`, `[2, 3]`, and `[4, 5, 6, 7]` respectively, the maximum sum of values at any single level would be `4 + 5 + 6 + 7 = 22`. Write a function that takes the root of the binary tree as input and returns _an integer denoting the largest sum of values of nodes at any single level_.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_level_sum(root): if not root: return 0 max_sum = float(\'-inf\') queue = deque([(root, 1)]) # tuple of node and level current_level_sum = 0 current_level = 1 while queue: node, level = queue.popleft() if level > current_level: max_sum = max(max_sum, current_level_sum) current_level_sum = node.value current_level = level else: current_level_sum += node.value if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) # Check the last level\'s sum max_sum = max(max_sum, current_level_sum) return max_sum"},{"question":"A balanced binary tree is a type of binary tree in which the left and right subtrees of every node differ in height by no more than 1. Given a binary tree, determine if it is height-balanced. A binary tree node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function that takes the root of a binary tree and returns `True` if the tree is balanced, and `False` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Returns True if the binary tree is balanced, False otherwise. def check_balanced(node): if not node: return 0, True left_height, left_balanced = check_balanced(node.left) right_height, right_balanced = check_balanced(node.right) current_balance = abs(left_height - right_height) <= 1 current_height = max(left_height, right_height) + 1 return current_height, left_balanced and right_balanced and current_balance _, balanced = check_balanced(root) return balanced"},{"question":"You are given an array `arr` of integers of length `n`. A \\"Mountain Array\\" is defined as an array that has elements strictly increasing until it reaches a peak (highest value) and then strictly decreasing. A peak element is an element that is not smaller than its neighbors. You need to find all indices of the peaks in the array. Return an array containing the indices of all peak elements sorted in **ascending** order. Note: * If the array has less than 3 elements, then it can\'t form a mountain. * The peak cannot be the first or the last element in the array.","solution":"def find_peak_indices(arr): Finds all the peak indices in a given array. Args: arr: List[int] - the input array Returns: List[int] - the list of indices that are peak elements if len(arr) < 3: return [] peak_indices = [] for i in range(1, len(arr) - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peak_indices.append(i) return peak_indices"},{"question":"There is a rectangular board consisting of `m` rows and `n` columns. Each cell contains a character representing one of the following: - `\'B\'` for a bat - `\'F\'` for a fly - `\'O\'` for an obstacle - `\'.\'` for an empty cell A bat can move to an adjacent cell (left, right, up, or down) if the cell is empty or contains a fly. The bat can eat the fly and move into that cell in the same move. The bat cannot move into cells containing obstacles or other bats. You are initially given the positions of 1 bat and multiple flies on the board. Your goal is to determine whether the bat can eat all the flies on the board. Return `true` if it is possible for the bat to eat all the flies and `false` otherwise.","solution":"def can_bat_eat_all_flies(board): m, n = len(board), len(board[0]) flies = 0 bat_position = None for i in range(m): for j in range(n): if board[i][j] == \'F\': flies += 1 elif board[i][j] == \'B\': bat_position = (i, j) if not bat_position: return False # No bat is present def dfs(x, y): stack = [(x, y)] visited = set(stack) flies_eaten = 0 while stack: curr_x, curr_y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = curr_x + dx, curr_y + dy if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited: if board[new_x][new_y] in {\'.\', \'F\'}: visited.add((new_x, new_y)) if board[new_x][new_y] == \'F\': flies_eaten += 1 stack.append((new_x, new_y)) return flies_eaten == flies bat_x, bat_y = bat_position return dfs(bat_x, bat_y)"},{"question":"You are given a `matrix` of integers `grid` of dimensions `n x m`. You need to find the number of distinct integers that can be collected by starting at the top-left corner of the matrix and moving to the bottom-right corner. You are only allowed to move either down or right at any point in time. Return _the number of distinct integers that can be collected along any path from the top-left to the bottom-right corner_.","solution":"def distinct_numbers_in_path(grid): Given a matrix `grid` of dimensions n x m, return the number of distinct integers that can be collected along any path from the top-left to the bottom-right corner. You are only allowed to move either down or right at any point in time. Parameters: grid (list[list[int]]): 2D list of integers Returns: int: Number of distinct integers collected along any path from functools import lru_cache n = len(grid) m = len(grid[0]) @lru_cache(None) def dfs(x, y): if x == n - 1 and y == m - 1: return {grid[x][y]} values = set() if x < n - 1: values.update(dfs(x + 1, y)) if y < m - 1: values.update(dfs(x, y + 1)) values.add(grid[x][y]) return values return len(dfs(0, 0))"},{"question":"You are designing a warehouse inventory system, where each item in the inventory is represented by a unique identifier (`item_id`). The inventory is stored as a list of tuples, where each tuple consists of the `item_id` and the corresponding quantity. Implement a class `InventoryManagement` with the following methods: * `InventoryManagement(List[Tuple[int, int]] inventory)` - Initializes the inventory with the provided list of items and their quantities. * `void add_item(int item_id, int quantity)` - Adds the specified quantity of the given `item_id` to the inventory. If `item_id` does not exist, it is added to the inventory with the given quantity. * `void remove_item(int item_id, int quantity)` - Removes the specified quantity of the given `item_id` from the inventory. If the quantity to be removed exceeds the available quantity, remove all the available quantity. * `int get_quantity(int item_id)` - Returns the current quantity of the given `item_id` in the inventory. If the `item_id` does not exist, return 0. * `List[Tuple[int, int]] get_inventory()` - Returns the current state of the inventory, sorted by `item_id` in ascending order.","solution":"from typing import List, Tuple class InventoryManagement: def __init__(self, inventory: List[Tuple[int, int]]): Initializes the inventory with the provided list of items and their quantities. self.inventory = {} for item_id, quantity in inventory: self.inventory[item_id] = self.inventory.get(item_id, 0) + quantity def add_item(self, item_id: int, quantity: int): Adds the specified quantity of the given item_id to the inventory. If item_id does not exist, it is added to the inventory with the given quantity. self.inventory[item_id] = self.inventory.get(item_id, 0) + quantity def remove_item(self, item_id: int, quantity: int): Removes the specified quantity of the given item_id from the inventory. If the quantity to be removed exceeds the available quantity, remove all the available quantity. if item_id in self.inventory: if self.inventory[item_id] <= quantity: del self.inventory[item_id] else: self.inventory[item_id] -= quantity def get_quantity(self, item_id: int) -> int: Returns the current quantity of the given item_id in the inventory. If the item_id does not exist, return 0. return self.inventory.get(item_id, 0) def get_inventory(self) -> List[Tuple[int, int]]: Returns the current state of the inventory, sorted by item_id in ascending order. return sorted(self.inventory.items())"},{"question":"Implement a class `StockPrice` that supports monitoring and querying the price of a stock at different timestamps. The class should have the following methods: * `void update(int timestamp, int price)`: Update the price of the stock at a given timestamp. * `int current()`: Return the **latest** price of the stock. * `int maximum()`: Return the **maximum** price of the stock. * `int minimum()`: Return the **minimum** price of the stock. Note: - Timestamps are strictly increasing. - The first call to `update` will set the initial state of the stock price. ```python class StockPrice: def __init__(self): # Initialization code here def update(self, timestamp: int, price: int) -> None: # Update method implementation def current(self) -> int: # Current method implementation def maximum(self) -> int: # Maximum method implementation def minimum(self) -> int: # Minimum method implementation ```","solution":"class StockPrice: def __init__(self): self.price_map = {} self.latest_timestamp = 0 def update(self, timestamp: int, price: int) -> None: self.price_map[timestamp] = price self.latest_timestamp = max(self.latest_timestamp, timestamp) def current(self) -> int: return self.price_map[self.latest_timestamp] def maximum(self) -> int: return max(self.price_map.values()) def minimum(self) -> int: return min(self.price_map.values())"},{"question":"You are given a sorted array of integers `arr` of size `n` and an integer `target`. Return the indices of the two numbers such that when added together they equal `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. The indices returned must be in ascending order.","solution":"def two_sum(arr, target): Given a sorted array of integers `arr` and a target integer `target`, returns the indices of the two numbers such that they add up to `target`. :param arr: List[int] - A sorted list of integers. :param target: int - The target sum. :return: Tuple[int, int] - A tuple of indices of the two numbers that add up to `target`. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return left, right elif current_sum < target: left += 1 else: right -= 1 # Since the array is sorted, the indices returned will naturally be in ascending order."},{"question":"You are given a 2D grid of size `m x n` representing a map of \'1\'s (land) and \'0\'s (water). An island is a group of `1\'s` (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The task is to find the maximum area of an island in the given 2D grid. Use an efficient algorithm to calculate the size of any island, and return the size of the largest island. Would it be possible to write an efficient solution that reduces excess computations?","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(i, j): if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark visited by sinking the island area = 1 # current island\'s cell area += dfs(i - 1, j) area += dfs(i + 1, j) area += dfs(i, j - 1) area += dfs(i, j + 1) return area max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` representing the heights of a series of consecutive buildings. A rooftop is defined as a building from which you can see the sunset if and only if there are no higher buildings to its right. Calculate the number of rooftops from which you can see the sunset when viewed from left to right. Return _the number of rooftops with a sunset view_.","solution":"def count_rooftops_with_sunset_view(nums): Returns the number of rooftops with a sunset view. A rooftop has a sunset view if there are no buildings taller to its right. n = len(nums) if n == 0: return 0 count = 1 max_height_to_right = nums[-1] # Traverse the list from right to left for i in range(n-2, -1, -1): if nums[i] > max_height_to_right: count += 1 max_height_to_right = nums[i] return count"},{"question":"You are given a string `s` consisting of lowercase letters, and an integer array `indices` of the same length. The string `s` is an encryption of some book with shuffled letters. The `indices` array represents the positions of each character in the original string (i.e., `indices[i]` is the position of the character `s[i]` in the original string). Return the decoded original string.","solution":"def restore_string(s, indices): Returns the decoded original string by using the provided indices array to shuffle the characters of s. Parameters: s (str): The encoded string. indices (list of int): The list of indices representing the positions of each character in the original string. Returns: str: The decoded original string. n = len(s) decoded = [\'\'] * n for i, index in enumerate(indices): decoded[index] = s[i] return \'\'.join(decoded)"},{"question":"You are given a list of tuples where each tuple contains two integers `(start, end)`, representing the start and end times of meetings. Write a function to determine the minimum number of conference rooms required to hold all the meetings. Each meeting will be represented by the half-open interval `[start, end)` (where `start` is inclusive and `end` is exclusive). The function should return an integer representing the number of conference rooms needed.","solution":"def minMeetingRooms(intervals): Returns the minimum number of conference rooms required to hold all the given meetings. :param intervals: List of tuples where each tuple consists of two integers (start, end), representing the start and end times of meetings. :return: Integer representing the number of conference rooms needed. if not intervals: return 0 # Separate out the start and end times of meetings. starts = sorted([i[0] for i in intervals]) ends = sorted([i[1] for i in intervals]) start_ptr, end_ptr = 0, 0 used_rooms = 0 # Iterate through all the meetings to find the minimum number of rooms required. while start_ptr < len(intervals): # If there\'s a meeting that has started by the time the previous one ends, need a new room. if starts[start_ptr] < ends[end_ptr]: used_rooms += 1 start_ptr += 1 else: # A meeting ended, free up a room. end_ptr += 1 start_ptr += 1 return used_rooms"},{"question":"You are tasked with implementing an e-commerce system that manages stock levels for various products. Each product has a unique name and a current stock level. The system should support the following operations: 1. **Add a product**: Add a new product to the system with a given name and initial stock level. If the product already exists, update its stock level. 2. **Remove a product**: Remove a product from the system by its name. 3. **Restock a product**: Increase the stock level of a product by a given amount. 4. **Sell a product**: Decrease the stock level of a product by a given amount. If the stock level is insufficient, do not perform the sale and return an error. 5. **Get stock level**: Return the current stock level of a product by its name. Write a function `ecommerce_system(operations, data)` that performs the specified operations and returns the desired outcomes. `operations` is a list of strings representing the operations, and `data` is a list of lists where each sublist contains the necessary parameters for the corresponding operation. The function should return a list of results for the `sell` and `get stock level` operations, in the order they are performed. If an invalid operation is requested, return an appropriate error message.","solution":"def ecommerce_system(operations, data): products = {} results = [] for op, params in zip(operations, data): if op == \\"add_product\\": name, stock_level = params products[name] = stock_level elif op == \\"remove_product\\": name = params[0] if name in products: del products[name] elif op == \\"restock_product\\": name, amount = params if name in products: products[name] += amount elif op == \\"sell_product\\": name, amount = params if name in products and products[name] >= amount: products[name] -= amount else: results.append(\\"error\\") elif op == \\"get_stock_level\\": name = params[0] if name in products: results.append(products[name]) else: results.append(\\"error\\") else: results.append(\\"invalid operation\\") return results"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped above each bar after it rains. Write a function to compute the total amount of rainwater trapped. The list represents the elevation map where the width of each bar is 1. Return the _total_ amount of rainwater that can be trapped.","solution":"def trap_rainwater(height): Calculate the total amount of rainwater that can be trapped. :param height: List[int] - list of non-negative integers representing the elevation map. :return: int - total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a square matrix `mat` of size `n x n` where each cell contains an integer value. Write a function to find the **maximum sum** of any hourglass-shaped pattern in the matrix. An hourglass-shaped pattern is defined as follows: ``` a b c d e f g ``` Write an algorithm that takes this `n x n` matrix as input and returns the maximum hourglass sum. Note that `n` must be at least 3 to form an hourglass.","solution":"def max_hourglass_sum(mat): Given an n x n matrix `mat`, find the maximum sum of any hourglass-shaped pattern in the matrix. An hourglass-shaped pattern can be visualized as follows: a b c d e f g Parameters: mat (list of list of int): The n x n matrix containing integer values. Returns: int: The maximum sum of any hourglass-shaped pattern. n = len(mat) if n < 3: raise ValueError(\\"Matrix must be at least 3x3 in size\\") max_sum = float(\'-inf\') for i in range(n - 2): for j in range(n - 2): hourglass_sum = ( mat[i][j] + mat[i][j+1] + mat[i][j+2] + mat[i+1][j+1] + mat[i+2][j] + mat[i+2][j+1] + mat[i+2][j+2] ) if hourglass_sum > max_sum: max_sum = hourglass_sum return max_sum"},{"question":"You are given an array of integers `arr` and an integer `k`. You can choose any subarray of `arr` (contiguous elements) and flip exactly `k` 0s to 1s. Return the length of the longest subarray containing only 1s after flipping exactly `k` 0s. If it is impossible to flip `k` 0s, return 0.","solution":"def longest_ones_after_flipping(arr, k): left = 0 max_len = 0 zero_count = 0 for right in range(len(arr)): if arr[right] == 0: zero_count += 1 while zero_count > k: if arr[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len if zero_count <= k else 0"},{"question":"A social media platform logs user activities, where each activity is represented by its `id`, `timestamp`, and `type`. The `id` is a **unique** string among all activities, the `timestamp` is an integer representing the time when the activity occurred, and the `type` is a string representing the type of activity (e.g., \\"post\\", \\"comment\\", \\"like\\"). You are tasked with creating a system that tracks the most recent activities of a specific type. The system should support: * **Adding** user activities, **one at a time**. * **Querying** the most recent `k` activities of a specific `type`. Implement the `ActivityTracker` class: * `ActivityTracker()` Initializes the tracker system. * `void addActivity(string id, int timestamp, string type)` Adds a user activity with `id`, `timestamp`, and `type`. * `List<string> getActivities(string type, int k)` Queries and returns a list of `id`s of the most recent `k` activities of the specified `type`. The activities should be sorted by their `timestamp` in descending order. If there are fewer than `k` activities of the specified type, return all available activities.","solution":"class ActivityTracker: def __init__(self): self.activities = {} def addActivity(self, id, timestamp, type): if type not in self.activities: self.activities[type] = [] self.activities[type].append((id, timestamp)) self.activities[type].sort(key=lambda x: x[1], reverse=True) def getActivities(self, type, k): if type not in self.activities: return [] return [activity[0] for activity in self.activities[type][:k]]"},{"question":"Given a 2-dimensional grid of integers with `m` rows and `n` columns, where each cell in the grid represents the altitude at that point, determine if there is a path from the top-left corner to the bottom-right corner. The path can only proceed in four directions: up, down, left, and right. However, the altitude difference between any two consecutive cells in the path must not exceed a given integer `k`. Return _true_ if such a path exists, otherwise return _false_.","solution":"def is_path_possible(grid, k): from collections import deque rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows-1, cols-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: if (nx, ny) not in visited and abs(grid[nx][ny] - grid[x][y]) <= k: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"Given a string `s` consisting of lowercase alphabets, you need to determine if it is possible to rearrange the characters of `s` such that no two adjacent characters are the same. If possible, return the rearranged string. If not possible, return an empty string. Your algorithm should be efficient in terms of both time and space complexity.","solution":"from collections import Counter import heapq def reorganize_string(s): Rearranges the characters of the string `s` such that no two adjacent characters are the same. If it is not possible to achieve this, returns an empty string. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: str: The rearranged string or an empty string if rearrangement is not possible. # Count frequency of each character char_counts = Counter(s) max_heap = [(-count, char) for char, count in char_counts.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged = \'\'.join(result) if len(rearranged) != len(s): return \\"\\" return rearranged"},{"question":"[A sequence `x1, x2, ..., xn` is _Fibonacci-like_ if: * `n >= 3` * `xi + xi+1 == xi+2` for all `i + 2 <= n` Given a **strictly increasing** array `arr` of positive integers forming a sequence, return _the **length** of the longest Fibonacci-like subsequence of_ `arr`. If one does not exist, return `0`. A **subsequence** is derived from another sequence `arr` by deleting any number of elements (including none) from `arr`, without changing the order of the remaining elements. For example, `[3, 5, 8]` is a subsequence of `[3, 4, 5, 6, 7, 8]`. [Question 2]: You are given a **0-indexed** string `s` and are tasked with finding two **non-intersecting palindromic** substrings of **odd** length such that the product of their lengths is maximized. More formally, you want to choose four integers `i`, `j`, `k`, `l` such that `0 <= i <= j < k <= l < s.length` and both the substrings `s[i...j]` and `s[k...l]` are palindromes and have odd lengths. `s[i...j]` denotes a substring from index `i` to index `j` **inclusive**. Return _the **maximum** possible product of the lengths of the two non-intersecting palindromic substrings._ A **palindrome** is a string that is the same forward and backward. A **substring** is a contiguous sequence of characters in a string. [Question 3]: You are given a string `s` and a **positive** integer `k`. Select a set of **non-overlapping** substrings from the string `s` that satisfy the following conditions: * The **length** of each substring is **at least** `k`. * Each substring is a **palindrome**. Return _the **maximum** number of substrings in an optimal selection_. A **substring** is a contiguous sequence of characters within a string. [Question 4]: Given a **0-indexed** array of integers `nums`, determine if it is possible to partition `nums` into two or more **non-empty** subsets such that the sum of the numbers in each subset is a **perfect square**. Return _`true` if such a partition exists and `false` if it does not_. A **perfect square** is an integer that is the square of another integer, e.g., 1, 4, 9, 16, etc.","solution":"def lenLongestFibSubseq(arr): arr_set = set(arr) longest = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): x, y = arr[i], arr[j] length = 2 while x + y in arr_set: x, y = y, x + y length += 1 longest = max(longest, length) return longest if longest >= 3 else 0"},{"question":"You are given a binary tree where each node has a `value` representing an integer, and each node has zero, one, or two child nodes. The height of the tree is defined as the longest path from the root node to a leaf node. Write a function to return the height of the given binary tree. The binary tree is represented using a TreeNode class as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Implement the function: ```python def tree_height(root: TreeNode) -> int: pass ``` **Example:** ```python # Example tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert tree_height(root) == 3 ``` Explanation: The longest path from the root node to a leaf node is 3 -> 20 -> 15 or 3 -> 20 -> 7, both have a length of 3. Hence, the height of the tree is 3.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def tree_height(root: TreeNode) -> int: if root is None: return 0 left_height = tree_height(root.left) right_height = tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"Given an integer array `nums`, partition it into two (possibly empty) subsequences such that the sum of the elements in the first subsequence is **strictly greater** than the sum of the elements in the second subsequence. Return _the minimum number of elements that should be included in the first subsequence to achieve this partition_. If there are multiple valid partitions, return the one where the first subsequence contains the smallest number of elements.","solution":"def min_elements_to_partition(nums): Returns the minimum number of elements that should be included in the first subsequence to achieve the partition such that the sum of the elements in the first subsequence is strictly greater than the sum of the elements in the second subsequence. nums.sort(reverse=True) total_sum = sum(nums) first_subseq_sum = 0 for i, num in enumerate(nums): first_subseq_sum += num if first_subseq_sum > (total_sum - first_subseq_sum): return i + 1 return len(nums)"},{"question":"Write a function that takes a string containing only uppercase alphabets and returns the **length of the longest palindrome** that can be built with those letters. Letters are case sensitive, so \\"A\\" is treated differently than \\"a\\". A palindrome is a string that reads the same forward and backward. For example, given the string \\"ABAB\\", the longest palindrome that can be built is \\"ABBA\\" with a length of 4. If it is not possible to build a palindrome, the function should return 0.","solution":"def longest_palindrome(s: str) -> int: Given a string containing only uppercase alphabets, returns the length of the longest palindrome that can be built with those letters. from collections import Counter # Count occurrences of each character char_count = Counter(s) length = 0 odd_count_present = False for count in char_count.values(): # Add the even part of the count to length length += count // 2 * 2 # Check if there is an odd count of characters if count % 2 == 1: odd_count_present = True # If there\'s any character with an odd count, we can add one in the center of the palindrome if odd_count_present: length += 1 return length"},{"question":"You are given an integer array `arr` of length `n` and two integers `x` and `y`. Your task is to find the minimum absolute difference between the indices of the elements `x` and `y` in the array. If either `x` or `y` is not present in the array, return `-1`. The array can contain duplicate elements. For example, given `arr = [3, 5, 1, 9, 2, 5, 1]`, `x = 5`, and `y = 1`, the minimum absolute difference between the indices of `5` and `1` is `1` because the closest `5` and `1` are at indices `1` and `2` (or `5` and `6`), respectively. Return the minimum absolute difference. Return _the minimum absolute difference between the indices of `x` and `y` in the array_. If either `x` or `y` is not present in the array, return `-1`.","solution":"def min_absolute_difference_indices(arr, x, y): x_indices = [i for i, val in enumerate(arr) if val == x] y_indices = [i for i, val in enumerate(arr) if val == y] if not x_indices or not y_indices: return -1 min_diff = float(\'inf\') for ix in x_indices: for iy in y_indices: min_diff = min(min_diff, abs(ix - iy)) return min_diff"},{"question":"You are given a list of integers `nums` and a target integer `target`. Write a function that finds the three distinct indices `i`, `j`, and `k` (0 ≤ i < j < k < len(nums)) such that `nums[i] + nums[j] + nums[k]` is closest to the `target value`. Return the sum of the three integers. If there are multiple solutions, return any of them.","solution":"def three_sum_closest(nums, target): Returns the sum of the three integers in nums such that the sum is closest to the target. nums.sort() closest_sum = float(\'inf\') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return closest_sum return closest_sum"},{"question":"Given an array of integers `arr`, return the smallest positive integer that is missing from the array. The array can contain duplicates and negative numbers as well. The function should have a time complexity of `O(n)` and use `O(1)` extra space. Example: - Input: `[3, 4, -1, 1]` - Output: `2` - Input: `[1, 2, 0]` - Output: `3` - Input: `[7, 8, 9, 11, 12]` - Output: `1`","solution":"def first_missing_positive(arr): Returns the smallest positive integer that is missing from the array. n = len(arr) # Step 1: Mark elements which are out of range and convert negatives and zeros for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Step 2: Use index as a hash key and number sign as a presence detector for i in range(n): num = abs(arr[i]) if num <= n: arr[num - 1] = -abs(arr[num - 1]) # Step 3: Find the first cell which isn\'t negative (i.e., the missing integer) for i in range(n): if arr[i] > 0: return i + 1 # If no positive numbers were added, then the array contains all numbers 1 to n return n + 1"},{"question":"You are given a list of meeting time intervals `intervals` where each interval is represented as a tuple `(start, end)`, indicating the start and end times of the meeting. Your task is to determine if a person can attend all the meetings without any overlap. Write a function that returns `True` if a person can attend all the given meetings, or `False` otherwise. [Example]: ```python Input: intervals = [(0, 30), (5, 10), (15, 20)] Output: False Input: intervals = [(7, 10), (2, 4)] Output: True ```","solution":"def can_attend_all_meetings(intervals): Determine if a person can attend all given meetings without any overlap. Args: intervals (list of tuple): A list of meeting intervals represented as tuples of (start, end). Returns: bool: True if a person can attend all meetings without overlap, False otherwise. # First, sort intervals based on the start time intervals.sort(key=lambda x: x[0]) # Compare each meeting end time with the next meeting start time for i in range(len(intervals) - 1): if intervals[i][1] > intervals[i + 1][0]: return False return True"},{"question":"You are given a string `s` and an array of pairs `indices` where each pair represents the start and end indices of a substring within `s`. For each pair in `indices`, compute the frequency of each character in the specified substring. Return the results as a list of dictionaries where each dictionary corresponds to a substring and contains the frequency of each character in that substring.","solution":"def character_frequency_in_substrings(s, indices): Compute the frequency of each character in the specified substrings. :param s: A string :param indices: A list of pairs where each pair represents the start and end indices of a substring :return: A list of dictionaries where each dictionary contains the frequency of characters in the substring result = [] for start, end in indices: substring = s[start:end+1] freq_dict = {} for char in substring: if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 result.append(freq_dict) return result"},{"question":"Given a list of `blueprints` and an integer `paint_quantity`, where each blueprint in `blueprints` is represented as a tuple `(width, height, layers)`, with `width` and `height` denoting the dimensions of the wall and `layers` denoting the number of layers of paint required. Your task is to calculate and return the maximum number of blueprints that can be fully painted with the given `paint_quantity`. Each layer of paint covers an area of 1 square unit, meaning the total paint required for a blueprint is `width * height * layers`. You can select the blueprints in any order.","solution":"def max_painted_blueprints(blueprints, paint_quantity): Returns the maximum number of blueprints that can be fully painted. :param blueprints: List of tuples, each representing (width, height, layers) of a blueprint. :param paint_quantity: Integer representing the total quantity of paint available. :return: Integer representing the maximum number of blueprints that can be fully painted. # Calculate the amount of paint required for each blueprint paint_requirements = [(width * height * layers) for width, height, layers in blueprints] # Sort the paint requirements in ascending order paint_requirements.sort() # Try to paint the blueprints with the available paint quantity count = 0 for paint_required in paint_requirements: if paint_quantity >= paint_required: paint_quantity -= paint_required count += 1 else: break return count"},{"question":"You have a 2D grid of size `m x n` where each cell is initially filled with water. A cell is represented by the character `\\"W\\"` for water and `\\"L\\"` for land. You are given an array `positions` where `positions[i] = [ri, ci]` represents the location where land should be converted from water in two iterative operations. After each addition of land, if a new piece of land is directly connected to others by horizontal or vertical directions, they will form a contiguous piece of land (island). Return _an array containing the number of islands after each operation_. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def set_parent(self, x): self.parent[x] = x self.count += 1 def get_count(self): return self.count def numIslands2(m, n, positions): def get_index(r, c): return r * n + c uf = UnionFind(m * n) grid = [[\'W\'] * n for _ in range(m)] res = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r, c in positions: if grid[r][c] == \'L\': # Ignore if land already there res.append(uf.get_count()) continue grid[r][c] = \'L\' index = get_index(r, c) uf.set_parent(index) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == \'L\': uf.union(index, get_index(nr, nc)) res.append(uf.get_count()) return res"},{"question":"You are given a string `s` and an integer `k`. Your task is to reverse the first `k` characters of the string and then repeat the process for the next `k` characters, and so on until the end of the string. If there are fewer than `k` characters left when you reach the end of the string, reverse all the remaining characters. Return the modified string after all reversals.","solution":"def reverse_k_characters(s, k): Returns a new string where the first k characters of the string are reversed, then the next k characters are reversed, and so on. result = [] for i in range(0, len(s), k): segment = s[i:i+k] result.append(segment[::-1]) return \'\'.join(result)"},{"question":"Given a string `s` consisting of letters and digits, rearrange the string in such a way that all letters come before any digits. Moreover, retain the original relative order of the letters and digits. Return the modified string as the result.","solution":"def rearrange_string(s): Returns a string where all letters come before any digits while retaining the original relative order. letters = [c for c in s if c.isalpha()] digits = [c for c in s if c.isdigit()] return \'\'.join(letters + digits)"},{"question":"You are tasked with developing a voting system in which voters cast their votes by submitting a list of their ranked preferences. Each voter ranks the candidates in order from most preferred to least preferred. Rank the candidates according to the following method: The candidate with the most number of first-preference votes wins. If there is a tie, the candidate with the next highest number of second-preference votes among the tied candidates wins, and so on. If at any level, no candidate can be disqualified based on preferences, apply the same tiebreaker rules to the next preference level and continue until a winner is determined or exhaust all preferences. You need to implement the `RankedChoiceVoting` class: * `RankedChoiceVoting(String[] candidates)` Initializes the object with the array of candidate names. * `boolean castVote(String[] preferences)` Submits a new vote with an array of ranked preferences for the candidates. Returns `true` if the vote is successfully cast, `false` otherwise. * `String determineWinner()` Calculates and returns the name of the candidate who wins the election according to the ranked-choice voting system. Ensure that the class handles scenarios where votes and preferences might not be well-formed or when votes contain invalid candidate names.","solution":"from collections import defaultdict class RankedChoiceVoting: def __init__(self, candidates): self.candidates = candidates self.votes = [] def castVote(self, preferences): # Ensure that each vote is a well-formed subset of candidates, without duplicates. if len(set(preferences)) != len(preferences): return False if not all(candidate in self.candidates for candidate in preferences): return False # Cast the vote self.votes.append(preferences) return True def determineWinner(self): if not self.votes: return None preferences_map = defaultdict(int) # Count first-preference votes for vote in self.votes: if vote: preferences_map[vote[0]] += 1 while preferences_map: # Find the candidates with the highest number of first-preference votes highest_vote = max(preferences_map.values()) candidates_with_highest_vote = [candidate for candidate, vote_count in preferences_map.items() if vote_count == highest_vote] # If there\'s a tie, recount considering the next preferences if len(candidates_with_highest_vote) == 1: return candidates_with_highest_vote[0] else: next_level_votes = defaultdict(int) for vote in self.votes: for preference in vote: if preference in candidates_with_highest_vote: next_level_votes[preference] += 1 break preferences_map = next_level_votes return None"},{"question":"You are given a **0-indexed** array of integers `heights` representing the heights of buildings along a street. **Rainwater** trapped between buildings is determined by the heights of the buildings from left to right. Calculate the total amount of rainwater trapped after the rain has stopped. Return _the **total** units of rainwater trapped._","solution":"def trap_rainwater(heights): Calculate the total amount of rainwater trapped between buildings. :param heights: List[int] - list representing the heights of buildings :return: int - total units of rainwater trapped if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Implement the `RandomizedSet` class: * `RandomizedSet()` Initializes the `RandomizedSet` object. * `bool insert(int val)` Inserts the item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise. * `bool remove(int val)` Removes the item `val` from the set if present. Returns `true` if the item was present, `false` otherwise. * `int getRandom()` Returns a random element from the current set of elements. Each element must have the same probability of being returned. You must implement the functions of the `RandomizedSet` class such that each function works in average `O(1)` time complexity.","solution":"import random class RandomizedSet: def __init__(self): self.vals = [] self.idx_map = {} def insert(self, val: int) -> bool: if val in self.idx_map: return False self.idx_map[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: if val not in self.idx_map: return False last_val = self.vals[-1] idx = self.idx_map[val] self.vals[idx] = last_val self.idx_map[last_val] = idx self.vals.pop() del self.idx_map[val] return True def getRandom(self) -> int: return random.choice(self.vals)"},{"question":"You are given an array of integers `arr` and a target integer `target`. Your task is to determine if there are two distinct indices `i` and `j` in the array such that the absolute difference between `arr[i]` and `arr[j]` is equal to `target`. Return _a boolean value_ `true` _if such a pair exists, and_ `false` _otherwise_.","solution":"def has_pair_with_difference(arr, target): Determines if there are two distinct indices i and j in the array such that the absolute difference between arr[i] and arr[j] is equal to target. seen = set() for number in arr: if (number + target) in seen or (number - target) in seen: return True seen.add(number) return False"},{"question":"You are given a tree with `n` nodes numbered from `0` to `n-1` represented by a 2D integer array `edges`, where `edges[i] = [ui, vi]` indicates that there is an edge between nodes `ui` and `vi`. Each node `i` has a value `val[i]`. You need to calculate the **maximum** sum of values that can be obtained by selecting a path in the tree. A path is defined as a sequence of nodes such that every consecutive pair of nodes in the sequence is connected by an edge. Return _the maximum sum of values of nodes on any path in the tree_.","solution":"def max_sum_path(n, edges, val): from collections import defaultdict import sys def dfs(node, parent): max_single_path_sum = 0 max_sum = -sys.maxsize for neighbor in adj[node]: if neighbor == parent: continue subpath_sum = dfs(neighbor, node) max_sum = max(max_sum, max_single_path_sum + subpath_sum + val[node]) max_single_path_sum = max(max_single_path_sum, subpath_sum) return max_single_path_sum + val[node] adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) max_path_sum = -sys.maxsize for i in range(n): max_path_sum = max(max_path_sum, dfs(i, -1)) return max_path_sum"},{"question":"You are given an integer array `grid` where `grid[i]` represents the height of a stack of blocks at position `i`. You can perform two types of operations: - **Increment**: Choose any position `i` and add one block to the stack at that position. - **Decrement**: Choose any position `i` and remove one block from the stack at that position. The cost of adding or removing a block is 1 unit each. Your goal is to make all the stacks equal in height with the minimum cost. Return the minimum cost required to make all stacks equal in height.","solution":"def min_cost_to_equal_heights(grid): Returns the minimum cost required to make all stacks equal in height. :param grid: List of integers representing the heights of stacks. :return: Minimum cost to equalize the heights of all stacks. median_height = sorted(grid)[len(grid) // 2] return sum(abs(height - median_height) for height in grid)"},{"question":"Given an integer array `arr` representing the number of apples in each basket, find the maximum sum of apples in any contiguous subarray of length `k`. If the size of `arr` is less than `k`, return 0. You should implement an efficient algorithm that solves the problem in linear time.","solution":"def max_apples_in_subarray(arr, k): Returns the maximum sum of apples in any contiguous subarray of length `k`. If the size of `arr` is less than `k`, returns 0. n = len(arr) if n < k: return 0 # Calculate the sum of the first subarray of length k max_sum = current_sum = sum(arr[:k]) # Slide the window over the array for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an integer array `heights`, where `heights[i]` represents the height of the `i-th` building, return _the maximum area of water that can be contained between two buildings_. The area of water is calculated as the minimum of the two building heights multiplied by the distance between the buildings.","solution":"def max_area(heights): Returns the maximum area of water that can be contained between two buildings. :param heights: List[int] - list of building heights. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) current_area = width * height max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given an array of integers `nums` and an integer `k`. An operation consists of changing any integer in `nums` to any integer between `1` and `k`, inclusive. Return _the minimum number of operations required to make all the integers in the array equal_. If it is not possible to make all values in `nums` the same, return `-1`.","solution":"def min_operations(nums, k): Determine the minimum number of operations required to make all integers in the array equal, by changing any integer to any value between 1 and k (inclusive). If it is not possible to make all values in \'nums\' the same, return -1. Parameters: nums (list of int): The array of integers. k (int): The range (1 to k inclusive) within which we can change the integers. Returns: int: The minimum number of operations or -1 if it is not possible. # If the array is already uniform or empty if not nums or nums.count(nums[0]) == len(nums): return 0 # Track the frequency of each number in the range (1 to k) freq = [0] * (k + 1) for num in nums: if 1 <= num <= k: freq[num] += 1 else: return -1 # It is impossible if there\'s a value out of the 1 to k range # Find the maximum frequency max_freq = max(freq) # Length of the array n = len(nums) # Minimum operations to make all elements the most frequent element min_operations = n - max_freq return min_operations"},{"question":"Given an m x n matrix of integers `mat`, return _the length of the longest common subpath found amongst all the rows of the matrix_. A **subpath** is a contiguous sequence of elements within a row. Note that the order of elements in the matrix row is important and must be maintained. You are not allowed to rearrange the elements within the rows.","solution":"def longest_common_subpath(mat): Returns the length of the longest common subpath found amongst all the rows of the matrix. if not mat: return 0 def is_common_subpath(length): # To check if all rows contain a common subpath of given length seen = set() for i in range(len(mat[0]) - length + 1): seen.add(tuple(mat[0][i:i+length])) for row in mat[1:]: current_seen = set() for i in range(len(row) - length + 1): subpath = tuple(row[i:i+length]) if subpath in seen: current_seen.add(subpath) if not current_seen: return False seen = current_seen return True left, right = 0, min(len(row) for row in mat) result = 0 while left <= right: mid = (left + right) // 2 if is_common_subpath(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":": You are given an undirected connected graph with `n` nodes labeled from `0` to `n-1` and an integer array `edges` where `edges[i] = [u_i, v_i, w_i]` indicates that there is an edge between nodes `u_i` and `v_i` with a weight of `w_i`. You are also given two integers `start` and `end`. Your task is to find the path from `start` to `end` such that the maximum edge weight in this path is minimized. If multiple such paths exist, return any one of them. If no path exists, return an empty list. # Function Signature: ```python def find_min_max_edge_path(n: int, edges: List[List[int]], start: int, end: int) -> List[int]: ```","solution":"from typing import List, Tuple from heapq import heappop, heappush import collections def find_min_max_edge_path(n: int, edges: List[List[int]], start: int, end: int) -> List[int]: def dijkstra_modified(): heap = [(0, start, [])] # (max_edge_weight, current_node, path_taken) visited = {} while heap: max_weight, node, path = heappop(heap) path = path + [node] if node in visited and visited[node] <= max_weight: continue visited[node] = max_weight if node == end: return path for neighbor, weight in graph[node]: heappush(heap, (max(max_weight, weight), neighbor, path)) return [] graph = collections.defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) return dijkstra_modified()"},{"question":"You are given a sequence of integers `nums` which represents the heights of buildings in a row from left to right. A building is considered **visible** if there are no taller buildings to its right. Return the number of visible buildings. For example, given a list of `[4, 2, 3, 1]`, the buildings 4, 3, and 1 would be considered visible because there are no taller buildings to the right of each one. Thus, the output should be 3.","solution":"def count_visible_buildings(nums): Returns the number of visible buildings. A building is considered visible if there are no taller buildings to its right. The function iterates from right to left, keeping track of the tallest building seen so far. n = len(nums) if n == 0: return 0 visible_count = 1 # The rightmost building is always visible tallest = nums[-1] # Traverse the list from the second last element to the first for i in range(n - 2, -1, -1): if nums[i] > tallest: visible_count += 1 tallest = nums[i] return visible_count"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `value` which may or may not be present in `nums`. Your task is to partition the array such that all elements equal to `value` come before all elements not equal to `value`. The relative order of the elements in each partition should be preserved. Return the modified array after partitioning.","solution":"def partition_array(nums, value): Partitions the array such that all elements equal to `value` come before all elements not equal to `value`. The relative order of the elements in each partition is preserved. Parameters: nums (list): The list of integers to be partitioned. value (int): The partition value. Returns: list: The partitioned list. left_partition = [x for x in nums if x == value] right_partition = [x for x in nums if x != value] return left_partition + right_partition"},{"question":"Implement a data structure `LRUCache` that supports `int get(int key)` and `void put(int key, int value)` operations. The LRUCache class should be initialized with a positive integer `capacity`, indicating the maximum number of items it can hold. * The `get(int key)` function retrieves the value of the `key` if it exists in the cache, otherwise returns `-1`. * The `put(int key, int value)` function updates the value of the `key` if it exists, otherwise adds the `key-value` pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item. The functions must each run in O(1) average time complexity.","solution":"class ListNode: def __init__(self, key=None, value=None, prev=None, next=None): self.key = key self.value = value self.prev = prev self.next = next class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = ListNode() self.tail = ListNode() self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: node = self.cache[key] node.value = value self._remove(node) self._add(node) else: if len(self.cache) == self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key] new_node = ListNode(key, value) self._add(new_node) self.cache[key] = new_node def _remove(self, node: ListNode): prev = node.prev next = node.next prev.next = next next.prev = prev def _add(self, node: ListNode): prev = self.tail.prev prev.next = node node.prev = prev node.next = self.tail self.tail.prev = node"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements, where `n` is even. You need to partition the array into pairs `(a1, b1), (a2, b2), ..., (an/2, bn/2)` such that the sum of `min(ai, bi)` for all `i` is maximized. Return the maximized sum after partitioning the array.","solution":"def arrayPairSum(nums): Returns the maximum sum of min(ai, bi) for pairs (ai, bi) from the array nums. # Sort the array nums.sort() # Initialize the result sum max_sum = 0 # Iterate over the sorted array taking every second element # Adding min(ai, bi) to the result (which is actually nums[i] after sorting) for i in range(0, len(nums), 2): max_sum += nums[i] return max_sum"},{"question":"You are given two strings `s1` and `s2` that represent two sequences of lowercase English letters. Determine if `s2` is a **subsequence** of `s1`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. Return _`true` if `s2` is a subsequence of `s1`, and `false` otherwise_.","solution":"def is_subsequence(s1, s2): Determines if s2 is a subsequence of s1. Parameters: s1 (str): The original string. s2 (str): The string to check as a subsequence. Returns: bool: True if s2 is a subsequence of s1, False otherwise. it = iter(s1) return all(char in it for char in s2)"},{"question":"A researcher is studying virus transmission between people. The interaction network is represented by an **undirected graph** where each node represents a person and an edge between two persons indicates direct contact that could result in virus transmission. Given a person `start` (represented by a node), find the minimum number of interactions (edges) required for the virus to reach every other person in the network. If some persons cannot be reached from the start node, they should be discarded (treated as isolated individuals). Implement a function `virusSpread` that takes the following parameters: - `n` (integer) - the number of people (nodes). - `edges` (list of tuples) - the list of direct interactions (edges) between people. - `start` (integer) - the person (node) where the virus starts spreading. Return the total number of interactions (edges) needed for the virus to spread to all reachable people from the start node. # Example: ``` Input: n = 4, edges = [(0, 1), (1, 2), (2, 3)], start = 0 Output: 3 Input: n = 4, edges = [(0, 1), (1, 2)], start = 3 Output: 0 ``` # Constraints: - `2 <= n <= 100` - `0 <= edges.length <= n * (n - 1) / 2` - `0 <= start < n` - There are no duplicate edges in the graph.","solution":"from collections import deque, defaultdict def virusSpread(n, edges, start): Determine the minimum number of interactions (edges) needed for the virus to reach every other person starting from the given node. Parameters: n : Integer - Number of nodes edges : List[Tuple] - List of edges representing interactions start : Integer - Starting node Returns: Integer - Total minimum number of interactions needed if n <= 1: return 0 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * n queue = deque([start]) visited[start] = True interaction_count = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) interaction_count += 1 return interaction_count"},{"question":"You are given two integers `x` and `y`, representing the coordinates of a point on a 2D plane. Each time you can move the point one step to the left, right, up, or down. You must determine the minimum number of steps required to reach the origin (0, 0) from the point `(x, y)`. Write a function `minStepsToOrigin(x, y)` that returns the minimum number of steps needed.","solution":"def minStepsToOrigin(x, y): Returns the minimum number of steps to reach the origin (0, 0) from the point (x, y). # The minimum number of steps required is the sum of the absolute values of the coordinates return abs(x) + abs(y)"},{"question":"You are given a binary tree in which each node contains an integer value. Design a class `BinaryTreeModifier` that supports the following operations: * `BinaryTreeModifier(TreeNode root)` - Initialize the object with the root of the binary tree. * `void incrementEvenValues(int increment)` - Increment all the nodes in the tree that contain an even value by the given `increment`. * `List<Integer> getLevelOrder()` - Return the level order traversal of the tree as a list of integers. The level order traversal is a breadth-first traversal where nodes at each level are visited from left to right. Note: `TreeNode` is a class that represents each node in the binary tree. Each `TreeNode` has three attributes: `int val`, `TreeNode left`, and `TreeNode right`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeModifier: def __init__(self, root): self.root = root def incrementEvenValues(self, increment): def dfs(node): if not node: return if node.val % 2 == 0: node.val += increment dfs(node.left) dfs(node.right) dfs(self.root) def getLevelOrder(self): if not self.root: return [] queue = [self.root] level_order = [] while queue: current = queue.pop(0) level_order.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return level_order"},{"question":"You are given a list of strings `words` and another string `target`. Each string in `words` is a scrambled version of some word. Your task is to determine if you can form the `target` by concatenating two words from the list `words` (each word can be used only once). Return a boolean indicating whether it is possible to form `target` by concatenating any two words from the list.","solution":"def can_form_target(words, target): Determines if the target can be formed by concatenating two words from the list. Args: words (list of str): List of scrambled words. target (str): The target string to be formed by concatenating two words. Returns: bool: True if target can be formed by any concatenation of two different words from the list, else False. word_set = set(words) for word in words: rest = target[len(word):] if target.startswith(word) and rest in word_set: if rest != word or words.count(word) > 1: return True return False"},{"question":"Given a list of non-negative integers `nums`, and an integer `target`, find if it is possible to partition the array into `k` subsets such that the sum of elements in each subset is equal to `target`. You should return a boolean value indicating whether this partition is possible or not. Note that each element of the array must be included in exactly one subset.","solution":"def can_partition_k_subsets(nums, k, target): def backtrack(index, k, subset_sum, visited): if k == 0: return True if subset_sum == target: return backtrack(0, k-1, 0, visited) if subset_sum > target: return False for i in range(index, len(nums)): if not visited[i]: visited[i] = True if backtrack(i+1, k, subset_sum + nums[i], visited): return True visited[i] = False return False if not nums: return False total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k visited = [False] * len(nums) nums.sort(reverse=True) # Helps to terminate earlier return backtrack(0, k, 0, visited)"},{"question":"Given a linked list, reverse the nodes of the list `k` at a time and return its modified list. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as they are. **Custom testing:** 1. The input data will be provided as a list of integers representing the linked list and a positive integer `k`. 2. The driver code will convert the list of integers into a linked list and pass the head of the linked list and `k` to the function `reverseKGroup`. 3. The function should process the linked list and return the head of the modified linked list. 4. The driver code will take the returned linked list, convert it back to a list of integers, and compare it with the expected output. If they match, the test passes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): prev, curr = None, head for _ in range(k): nxt = curr.next curr.next = prev prev = curr curr = nxt return prev count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"In a binary tree, a **univalued path** is a path in which all the nodes have the same value. A **path** can be a single node or any sequence of nodes in the tree, where every adjacent pair of nodes in the sequence has an edge connecting them. Given the root of a binary tree, return the length of the **longest univalued path** in the tree. The length of a path is represented by the number of edges between its first and last node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_univalued_path(root): def helper(node): nonlocal longest if not node: return 0 left_length = helper(node.left) right_length = helper(node.right) left_max = right_max = 0 if node.left and node.left.val == node.val: left_max = left_length + 1 if node.right and node.right.val == node.val: right_max = right_length + 1 longest = max(longest, left_max + right_max) return max(left_max, right_max) longest = 0 helper(root) return longest"},{"question":"You are given an `n x n` grid where each cell has a certain amount of gold in it. You start collecting gold from the first cell of any row in the grid. You can only move to the right, right-up (diagonally up to the right), or right-down (diagonally down to the right). Your task is to figure out the maximum amount of gold you can collect by the time you reach any cell in the last column of the grid. Write a function `maxGold` that takes the grid as input and returns the maximum gold collected.","solution":"def maxGold(grid): Returns the maximum gold collected when starting from the first cell of any row and only moving right, right-up, or right-down. if not grid or not grid[0]: return 0 rowCount = len(grid) colCount = len(grid[0]) dp = [[0]*colCount for _ in range(rowCount)] for row in range(rowCount): dp[row][0] = grid[row][0] for col in range(1, colCount): for row in range(rowCount): # Move right from the same row right = dp[row][col - 1] # Move right-up from the previous row if not at the first row if row > 0: right_up = dp[row - 1][col - 1] else: right_up = 0 # Move right-down from the next row if not at the last row if row < rowCount - 1: right_down = dp[row + 1][col - 1] else: right_down = 0 dp[row][col] = grid[row][col] + max(right, right_up, right_down) return max(dp[row][colCount - 1] for row in range(rowCount))"},{"question":"Given an integer array `arr`, return _an array of the length of the largest non-decreasing subsequence ending at each index of `arr`_. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Example: ``` Input: arr = [1, 3, 5, 4, 7] Output: [1, 2, 3, 3, 4] Explanation: For index 0, the largest non-decreasing subsequence ending here is [1] (length 1). For index 1, the largest non-decreasing subsequence ending here is [1, 3] (length 2). For index 2, the largest non-decreasing subsequence ending here is [1, 3, 5] (length 3). For index 3, the largest non-decreasing subsequence ending here is [1, 3, 4] (length 3). For index 4, the largest non-decreasing subsequence ending here is [1, 3, 4, 7] (length 4). ```","solution":"def lengths_of_largest_non_decreasing_subsequence(arr): Returns an array of the length of the largest non-decreasing subsequence ending at each index of `arr`. if not arr: # If the array is empty, return an empty list return [] n = len(arr) lengths = [1] * n # Initialize lengths array with 1s because each element is a subsequence of length 1 for i in range(1, n): for j in range(i): if arr[j] <= arr[i]: lengths[i] = max(lengths[i], lengths[j] + 1) return lengths"},{"question":"You are given a string `s` that contains only lowercase English letters. Your task is to determine if it is possible to rearrange the characters of `s` such that no two adjacent characters are the same. If such an arrangement is possible, return any valid rearrangement of the string. Otherwise, return an empty string. In the example input `s = \\"aab\\"`, a possible valid rearrangement is `\\"aba\\"`, because no two adjacent characters are the same. In the example input `s = \\"aaab\\"`, there is no valid rearrangement, so the output should be an empty string. **Follow up:** Can you solve this problem in linear time and explain why your solution is optimal?","solution":"import heapq from collections import Counter def reorganize_string(s): This function rearranges the characters of the input string such that no two adjacent characters are the same. If it is not possible to form such a string, the function returns an empty string. # Count frequencies of each character counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \'\' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) freq += 1 prev_freq, prev_char = freq, char reorganized = \'\'.join(result) if len(reorganized) != len(s): return \\"\\" return reorganized"},{"question":"Given a string `s` representing a valid parenthesis expression, calculate the score of the string based on the following rules: - `()` has a score of 1. - `AB` has a score of `A + B`, where `A` and `B` are valid parenthesis strings. - `(A)` has a score of `2 * A`, where `A` is a valid parenthesis string. You need to return the score of the parenthesis string `s`. **Example**: - Input: `s = \\"()\\"`, Output: `1` - Input: `s = \\"(())\\"`, Output: `2` - Input: `s = \\"()()\\"`, Output: `2` - Input: `s = \\"(()(()))\\"`, Output: `6` **Constraints**: - `s` consists only of `\'(\'` and `\')\'`. - The length of `s` is at least 2 and at most 50. - `s` is a valid parenthesis string.","solution":"def score_of_parentheses(s): Calculate the score of a valid parenthesis string based on the given rules. stack = [0] # The score of the current frame for char in s: if char == \'(\': stack.append(0) # Start a new frame else: v = stack.pop() stack[-1] += max(2 * v, 1) return stack[0]"},{"question":": You are given a string `s` and an integer `k`. The string `s` consists of lowercase English letters only. A substring of `s` is called a **good substring** if it contains at most `k` distinct characters. Return the number of **distinct** good substrings of `s`. Note that the substrings do not need to be contiguous, but the order must be maintained. If the number of good substrings is too large, return it modulo `10^9 + 7`.","solution":"def count_good_substrings(s, k): MOD = 10**9 + 7 n = len(s) substring_set = set() for i in range(n): distinct_chars = set() for j in range(i, n): distinct_chars.add(s[j]) if len(distinct_chars) > k: break substring_set.add(s[i:j+1]) return len(substring_set) % MOD"},{"question":"You are given a string `s` consisting only of digits. Your task is to partition this string into the minimum number of contiguous substrings such that each substring is a palindrome. A **palindrome** is a sequence of characters that reads the same forward and backward. _None of the characters in `s` should be ignored, and the partition should use the fewest number of substrings possible._ Return _the minimum number of palindromic substrings needed to partition the string `s`_.","solution":"def is_palindrome(x): return x == x[::-1] def min_palindrome_partition(s): n = len(s) dp = [0] * n pal = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): pal[i][i] = True for to in range(1, n): for from_ in range(to, -1, -1): if s[from_] == s[to] and (to - from_ <= 2 or pal[from_ + 1][to - 1]): pal[from_][to] = True for to in range(n): if pal[0][to]: dp[to] = 0 else: dp[to] = float(\'inf\') for from_ in range(to): if pal[from_ + 1][to]: dp[to] = min(dp[to], dp[from_] + 1) return dp[n - 1] + 1"},{"question":"You are given a string `s` of length `n` consisting of lowercase English letters and the character `*`, which acts as a wildcard that can replace any single letter from \'a\' to \'z\'. Your task is to find the **smallest lexicographical** string possible by replacing all the `*` characters in `s`. The resulting string should maintain the relative order of the characters in the original string `s`. * For example, given `s = \\"b*d\\"`, you could replace `*` with \'a\' to get `\\"bad\\"`, which would be the lexicographically smallest string. Return _the smallest lexicographical string possible after replacing all the `*` characters_ in `s`.","solution":"def smallest_lexicographical_string(s): Given a string s of length n consisting of lowercase English letters and the character \'*\', returns the smallest lexicographical string possible by replacing all the \'*\' characters in s. return s.replace(\'*\', \'a\')"},{"question":"Given an integer array `arr`, return the length of the shortest continuous subarray, such that rearranging the elements of this subarray in non-decreasing order makes the whole array non-decreasing. If the array is already sorted, return `0`. For example: - Input: `arr = [1, 3, 2, 4, 5]` - Output: `2` **Note:** The given array can contain duplicates, and the solution must handle both positive and negative integers.","solution":"def find_unsorted_subarray(arr): Returns the length of the shortest continuous subarray such that rearranging the elements of this subarray in non-decreasing order makes the whole array non-decreasing. If the array is already sorted, returns 0. if not arr or len(arr) == 1: return 0 # Find the start of the unsorted subarray n = len(arr) start, end = 0, -1 max_seen, min_seen = arr[0], arr[-1] for i in range(1, n): max_seen = max(max_seen, arr[i]) if arr[i] < max_seen: end = i for i in range(n - 2, -1, -1): min_seen = min(min_seen, arr[i]) if arr[i] > min_seen: start = i return end - start + 1 if end != -1 else 0"},{"question":"Given an integer array `nums` of length `n` and an integer `k`, your task is to find the maximum sum of `k` consecutive elements in the array. For example, if `nums = [2, 1, 5, 1, 3, 2]` and `k = 3`, the maximum sum of 3 consecutive elements is `5 + 1 + 3 = 9`. You need to implement a function that returns this maximum sum. Note that the input array can contain negative integers as well.","solution":"def max_sum_of_k_consecutive_elements(nums, k): Returns the maximum sum of k consecutive elements in the array nums. Parameters: - nums: List[int], the list of integers. - k: int, number of consecutive elements to consider. Returns: - int, the maximum sum of k consecutive elements in nums. if len(nums) < k: raise ValueError(\\"The length of the array must be at least k.\\") # Compute the sum of the first \'k\' elements max_sum = sum(nums[:k]) current_sum = max_sum # Use a sliding window to find the maximum sum of \'k\' consecutive elements for i in range(k, len(nums)): current_sum = current_sum + nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given an integer array `nums`, find the largest product of any three distinct elements in the array. Return the result as an integer. Note that the array can include both positive and negative numbers, and you must consider all possible combinations of three elements.","solution":"def largest_product_of_three(nums): Finds the largest product of any three distinct elements in the array. nums.sort() # The largest product of three numbers could be either # 1. The product of the three largest numbers. # 2. The product of the two smallest numbers (which might be negative) and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"Given a string `s` that consists of only digits and lowercase English letters, return the length of the longest substring that contains only unique characters. The input string `s` has a maximum length of 10,000. The characters of the substring must appear in the same order as they appear in the input string `s`.","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring that contains only unique characters in the given string s. :param s: str :return: int char_index_map = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"Given a string `text`, return the length of the longest substring without repeating characters. This substring must be contiguous, and the characters within it cannot be repeated. If no such substring exists, return `0`.","solution":"def longest_substring_without_repeating_characters(text): Returns the length of the longest substring without repeating characters. n = len(text) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if text[end] in char_index_map and char_index_map[text[end]] >= start: start = char_index_map[text[end]] + 1 char_index_map[text[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a binary array `nums` and an integer `k`. A binary array is an array that consists of only `0s` and `1s`. You need to flip exactly `k` 0s to 1s to maximize the length of the contiguous subarray of 1s. Return _the length of the longest (maximum) contiguous subarray of 1s after flipping k `0s`_.","solution":"def longestOnes(nums, k): Returns the maximum length of contiguous subarray containing 1s after flipping exactly k 0s to 1s. :param nums: List[int] - Binary array :param k: int - Number of 0s to flip :return: int - Maximum length of contiguous 1s left = 0 max_length = 0 zeros_count = 0 for right in range(len(nums)): if nums[right] == 0: zeros_count += 1 while zeros_count > k: if nums[left] == 0: zeros_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`, where `n` is an **odd** number. Each element in the array is a positive integer. You are required to find and return the median of this array. The median is the middle element in a sorted, ascending, `nums` array. If you are given the array `[5, 3, 1, 2, 4]`, the sorted array would be `[1, 2, 3, 4, 5]` and thus the median would be `3`. Return the median of the array.","solution":"def find_median(nums): Returns the median of the given odd-length list of positive integers. Parameters: nums (list): A list of odd-length containing positive integers. Returns: int: The median value. nums.sort() mid_index = len(nums) // 2 return nums[mid_index]"},{"question":"Given an integer array `nums` and an integer `k`, return the maximum number of visible distinct numbers you can observe if you select exactly `k` continuous numbers from `nums`. Note that a number is considered visible if it appears in the selected subarray.","solution":"def max_visible_distinct_numbers(nums, k): Returns the maximum number of visible distinct numbers you can observe by selecting exactly k continuous numbers from `nums`. if k > len(nums): return 0 max_distinct = 0 for i in range(len(nums) - k + 1): subarray = nums[i:i + k] distinct_count = len(set(subarray)) max_distinct = max(max_distinct, distinct_count) return max_distinct"},{"question":"Given an integer `x`, return the square root of `x`. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. **You must implement a solution with a time complexity of O(log x)**.","solution":"def mySqrt(x): Computes the integer part of the square root of x using binary search. :param x: An integer the square root of which is to be computed :return: Integer part of the square root of x if x < 2: return x left, right = 2, x // 2 while left <= right: mid = (left + right) // 2 num = mid * mid if num == x: return mid elif num < x: left = mid + 1 else: right = mid - 1 return right"},{"question":"Given an array of integers `arr`, you are to paint each element of the array such that no two adjacent elements have the same color. Each element can be painted using one of `k` colors. Return _the minimum number of colors required_ from `k` such that the painting condition is satisfied.","solution":"def min_colors_required(arr, k): Returns the minimum number of colors required from k such that no two adjacent elements of the array have the same color. Parameters: arr (list): list of integers k (int): number of colors available Returns: int: minimum number of colors required # If the array is empty, no colors are needed if not arr: return 0 # Only one color is needed if there\'s a single element if len(arr) == 1: return 1 # At least two colors are always needed if there are at least two different elements # and they are adjacent required_colors = 1 for i in range(1, len(arr)): if arr[i] != arr[i-1]: required_colors = 2 break return min(required_colors, k)"},{"question":"Given an array of integers `arr` where each element represents the cost of hiring a worker, you are also given an integer `k` which is the number of workers you need to hire. Select exactly `k` workers such that the total cost is minimized. You must hire at least one worker from both ends (i.e., the first and the last position) of the array. Return _the minimum cost to hire exactly `k` workers from the array, satisfying the given constraints_.","solution":"def min_cost_to_hire_workers(arr, k): Returns the minimum cost to hire exactly k workers from the array, while hiring at least one worker from both ends. if k > len(arr): return -1 # Not possible to hire more workers than there are in the array # One worker from each end cost = arr[0] + arr[-1] remaining_workers = k - 2 if remaining_workers <= 0: return cost # Middle workers (excluding the first and last element) middle_costs = arr[1:-1] middle_costs.sort() cost += sum(middle_costs[:remaining_workers]) return cost"},{"question":"[Question] 4: You are given a **0-indexed** integer array `houses` representing the positions of houses along a street. Additionally, you are given an integer array `heaters` where each heater\'s position is represented as an integer. A heater can warm any house within its radius. Return _the minimum radius_ required for all houses to be covered by at least one heater. If it is impossible to cover all houses with the given heaters, return **-1**.","solution":"def find_minimum_radius(houses, heaters): Finds the minimum radius required for all houses to be covered by the heaters. Parameters: houses (List[int]): List of house positions. heaters (List[int]): List of heater positions. Returns: int: Minimum radius required for all houses to be covered, or -1 if it is impossible. if not houses: return 0 if not heaters: return -1 houses.sort() heaters.sort() def binary_search(target): Helper function to perform binary search to find the closest heater position. left, right = 0, len(heaters) - 1 while left < right: mid = (left + right) // 2 if heaters[mid] < target: left = mid + 1 else: right = mid return left max_radius = 0 for house in houses: pos = binary_search(house) left_heater_dist = float(\'inf\') if pos > 0: left_heater_dist = abs(house - heaters[pos - 1]) right_heater_dist = float(\'inf\') if pos < len(heaters): right_heater_dist = abs(house - heaters[pos]) house_radius = min(left_heater_dist, right_heater_dist) max_radius = max(max_radius, house_radius) return max_radius"},{"question":"Write a function `findSafePaths` that takes a grid of size `m x n` where each cell contains either a `0` (representing an empty space) or a `#` (representing an obstacle). You need to find all paths from the top-left corner (0,0) to the bottom-right corner (m-1,n-1) such that the path does not cross obstacles. A valid path can only move right or down at each step. Return the total number of such valid paths. Output an integer `z` which represents the number of safe paths.","solution":"def findSafePaths(grid): Returns the number of safe paths in the given grid from the top-left to the bottom-right corner. m = len(grid) n = len(grid[0]) # If start or end is an obstacle, return 0 if grid[0][0] == \'#\' or grid[m-1][n-1] == \'#\': return 0 dp = [[0] * n for _ in range(m)] # Initialize the starting position dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == \'#\': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given an array of integers `nums` and an integer `target`, return _a list of pairs of integers from the array whose sum equals the `target`_. Each pair should be returned in a list. If no such pairs exist, return an empty list. Ensure that each pair is listed in non-descending order, and the list of pairs is sorted in lexicographical order. Note that each number from the array can be used only once in a pair.","solution":"def find_pairs(nums, target): Returns a list of pairs of integers from the array whose sum equals the target. Each pair is in non-descending order, and the list of pairs is sorted in lexicographical order. Each number from the array can be used only once in a pair. nums.sort() pairs = [] used = set() for i in range(len(nums)): if nums[i] in used: continue for j in range(i + 1, len(nums)): if nums[j] in used: continue if nums[i] + nums[j] == target: pairs.append([nums[i], nums[j]]) used.add(nums[i]) used.add(nums[j]) break return pairs"},{"question":"You are given a list of words where each word consists of lowercase English letters. Two words `word1` and `word2` are considered \\"similar\\" if they have the same set of distinct characters. For example, \\"abc\\" and \\"cab\\" are similar, \\"abc\\" and \\"acb\\" are similar, but \\"abc\\" and \\"def\\" are not similar. Given the list of words, determine the total number of distinct groups of similar words. For example, given the input list `[\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\", \\"acd\\"]`, the output should be `3` because there are three groups of similar words: [\\"abc\\", \\"bca\\", \\"cab\\"], [\\"xyz\\", \\"zyx\\"], and [\\"acd\\"].","solution":"def count_similar_groups(words): Returns the number of distinct groups of similar words. seen_sets = set() for word in words: char_set = frozenset(word) seen_sets.add(char_set) return len(seen_sets)"},{"question":"You are given an integer array `height` of length `n`, representing the height of buildings aligned in a row. You are also given an integer `k` representing the maximum allowable height difference between adjacent buildings where `|height[i] - height[i+1]| <= k` for all valid i. In one operation, you can increase or decrease the height of any building by 1 unit. Return the **minimum number of operations** required to make the array meet the given height difference condition.","solution":"def min_operations(height, k): Returns the minimum number of operations required to make the array meet the given height difference condition. n = len(height) operations = 0 for i in range(1, n): diff = abs(height[i] - height[i-1]) if diff > k: operations += diff - k return operations"},{"question":"You are given an array of integers `arr` and an integer `k`. Modify the array such that each element appearing more than `k` times is removed entirely. Return the modified array in the same order in which elements appear originally, without any occurrences of elements that appear more than `k` times. Ensure the resulting array does not contain duplicates that violate the given constraint.","solution":"def remove_elements(arr, k): Modify the array such that each element appearing more than k times is removed entirely. Args: arr (list): List of integers. k (int): The maximum allowed frequency of any element. Returns: list: The modified array with elements removed as per the given criteria. from collections import Counter # Count the occurrence of each element element_count = Counter(arr) # Filter elements that appear more than k times return [element for element in arr if element_count[element] <= k]"},{"question":"Given a string `s` consisting of lowercase English letters, return the length of the longest palindromic substring in `s`. A substring is defined as a contiguous sequence of characters within the string. [Question] 5:","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string `s`. if not s: return 0 n = len(s) longest_length = 1 # Every string has at least one character which is a palindrome in itself # Create a 2D array to store whether s[i...j] is a palindrome dp = [[False] * n for _ in range(n)] # Initialize all substrings of length 1 to be palindrome for i in range(n): dp[i][i] = True # Check for substring of length 2 start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i longest_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > longest_length: start = i longest_length = length return longest_length"},{"question":"Given a binary tree where each node contains an integer value, find the length of the longest path consisting of nodes with consecutive values in any direction (either parent-child or child-parent). The length of a path is the number of nodes in it. **Note:** - The tree is represented by `TreeNode` where each node has an integer value `val` and two child nodes `left` and `right`. - A single node is considered a valid path of length 1. Return the length of the longest consecutive value path in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_consecutive_path(root): if not root: return 0 def dfs(node, parent, length): if not node: return length if parent and node.val == parent.val + 1: length += 1 else: length = 1 left_length = dfs(node.left, node, length) right_length = dfs(node.right, node, length) return max(length, left_length, right_length) return dfs(root, None, 0)"},{"question":"You are given an array of integers `arr` where each element represents the height of a block. By stacking some of these blocks together vertically, you can form a solid tower of blocks. However, you cannot place a block on top of another block if it is shorter in height. Determine the **minimum number of towers** needed to stack all the blocks while adhering to the height constraint. In other words, you should partition the array into the minimum number of subsequences such that in each subsequence, the heights of the blocks are in non-decreasing order. Return _the minimum number of towers needed to stack all the blocks in non-decreasing order of height_.","solution":"def min_number_of_towers(arr): Returns the minimum number of towers needed to stack all the blocks such that the heights of the blocks in each tower are in non-decreasing order. if not arr: return 0 towers = [] for height in arr: placed = False for tower in towers: if tower[-1] <= height: tower.append(height) placed = True break if not placed: towers.append([height]) return len(towers)"},{"question":"You are given a list of positive integers `weights` representing the weights of `n` people standing in a line. You need to divide these people into two groups such that each group has the **same number of people** and the **absolute difference** between the total weights of the two groups is as small as possible. Return _the minimum absolute difference of the total weights between the two groups._ If it is impossible to divide the people into two equal groups, return `-1`.","solution":"from itertools import combinations def min_weight_diff(weights): # Check if it is possible to divide into two equal groups if len(weights) % 2 != 0: return -1 n = len(weights) half_n = n // 2 total_weight = sum(weights) min_diff = float(\'inf\') # Generate all possible combinations of half_n elements from weights for combo in combinations(weights, half_n): group1_weight = sum(combo) group2_weight = total_weight - group1_weight min_diff = min(min_diff, abs(group1_weight - group2_weight)) return min_diff"},{"question":"Given a collection of `n` distinct integers, return all possible permutations. You must write a function that takes in a list of distinct integers and returns a list of lists, where each list is a possible permutation of the input list. The order of the permutations in the output list does not matter. The solution should generate permutations via backtracking.","solution":"def permute(nums): Generate all permutations of a list of distinct integers. :param nums: List[int] - List of distinct integers :return: List[List[int]] - List of all possible permutations def backtrack(start=0): if start == len(nums): result.append(nums[:]) for i in range(start, len(nums)): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1) nums[start], nums[i] = nums[i], nums[start] result = [] backtrack() return result"},{"question":"You are given a binary matrix `mat` of size `m x n`. Each cell is either `0` or `1`. A cell is called a peak if it is not along the border of the matrix and its value is greater than that of any of its 4 immediate neighbors (left, right, top, bottom). Note that only cells within the matrix boundaries are considered. Return the number of peaks in the matrix `mat`. If there are no peaks, return `0`.","solution":"def count_peaks(mat): if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) peaks_count = 0 for i in range(1, m-1): for j in range(1, n-1): if (mat[i][j] > mat[i-1][j] and mat[i][j] > mat[i+1][j] and mat[i][j] > mat[i][j-1] and mat[i][j] > mat[i][j+1]): peaks_count += 1 return peaks_count"},{"question":"Given a collection of `n` distinct integers, return all possible permutations. You can return the answer in any order. For example, if the input list is `[1, 2, 3]`, then the function should return all permutations of this list such as `[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]`.","solution":"from itertools import permutations def get_permutations(nums): Returns all possible permutations of a list of distinct integers. Args: nums (list): A list of distinct integers. Returns: list of list: A list of all possible permutations. return list(permutations(nums))"},{"question":"Design a data structure that efficiently manages a collection of intervals. Implement the `IntervalCollection` class with the following methods: * `IntervalCollection()` Initializes the data structure. * `void addInterval(int start, int end)` Adds the interval `[start, end]` to the collection, where `start <= end`. * `int queryPoint(int point)` Returns the number of intervals in the collection that contain the point `point`. * `int queryRange(int start, int end)` Returns the number of intervals in the collection that overlap with any point in the range `[start, end]` inclusive. For example: - Adding the interval `[1, 3]` and `[5, 8]` to the collection. - Querying the point `6` would return `1` as it is contained in the interval `[5, 8]`. - Querying the range `[2, 6]` would return `2` as it overlaps with both intervals `[1, 3]` and `[5, 8]`.","solution":"class IntervalCollection: def __init__(self): self.intervals = [] def addInterval(self, start, end): self.intervals.append((start, end)) def queryPoint(self, point): count = sum(1 for start, end in self.intervals if start <= point <= end) return count def queryRange(self, start, end): count = sum(1 for s, e in self.intervals if max(start, s) <= min(end, e)) return count"},{"question":"Given an array of integers `arr`, your task is to modify the array in such a way that each element is replaced by the product of all elements in the array except itself, without using the division operation. Return the modified array. For example, if the input array is `[1, 2, 3, 4]`, the output should be `[24, 12, 8, 6]`, because: - The product of all elements except the first is `2 * 3 * 4 = 24`. - The product of all elements except the second is `1 * 3 * 4 = 12`. - The product of all elements except the third is `1 * 2 * 4 = 8`. - The product of all elements except the fourth is `1 * 2 * 3 = 6`.","solution":"def product_except_self(arr): Returns an array where each element is replaced by the product of all elements in the array except itself. Division operation is not used. # Initialize the length of the array length = len(arr) # Create two auxiliary arrays to store the left and right products left_products = [1] * length right_products = [1] * length # Fill the left_products array for i in range(1, length): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill the right_products array for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Create the result array by multiplying left and right products result = [left_products[i] * right_products[i] for i in range(length)] return result"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of non-negative integers, where `grid[i][j]` represents the height of a point `(i, j)` in a certain area. You can start from any point in the first row and try to reach any point in the last row. At each step, you can move to the cell directly below, to the cell diagonally left below, or to the cell diagonally right below, if such a cell exists. You can only move to a cell with a height less than or equal to the height of the current cell. Your goal is to find the maximum height you can start from in the first row such that there\'s at least one path to reach the last row following the aforementioned rules. Return _the maximum height from which you can start in the first row and reach any point in the last row_. If it\'s not possible to reach the last row from any start point in the first row, return `-1`.","solution":"def can_reach_last_row(grid, m, n, row, col, prev_height): if row >= m: return False if grid[row][col] > prev_height: return False if row == m - 1: return True down = right_diag = left_diag = False if row + 1 < m: down = can_reach_last_row(grid, m, n, row + 1, col, grid[row][col]) if row + 1 < m and col + 1 < n: right_diag = can_reach_last_row(grid, m, n, row + 1, col + 1, grid[row][col]) if row + 1 < m and col - 1 >= 0: left_diag = can_reach_last_row(grid, m, n, row + 1, col - 1, grid[row][col]) return down or right_diag or left_diag def max_height_to_reach_last_row(grid): if not grid or not grid[0]: return -1 m = len(grid) n = len(grid[0]) max_height = -1 for col in range(n): if can_reach_last_row(grid, m, n, 0, col, grid[0][col]): max_height = max(max_height, grid[0][col]) return max_height"},{"question":"You are given a string `s` of length `n` and an integer `k`. The string consists of uppercase English letters (\'A\' to \'Z\') only. You need to perform exactly `k` operations on this string. In each operation, you can choose any character of the string and replace it with any other uppercase English letter. Return the maximum possible length of a substring with repeating characters after performing `k` operations.","solution":"def characterReplacement(s, k): This function returns the maximum possible length of a substring with repeating characters after performing exactly `k` operations on the given string `s`. max_count = 0 max_length = 0 count = [0] * 26 start = 0 for end in range(len(s)): count[ord(s[end]) - ord(\'A\')] += 1 max_count = max(max_count, count[ord(s[end]) - ord(\'A\')]) if end - start + 1 - max_count > k: count[ord(s[start]) - ord(\'A\')] -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an integer array `arr` of length `n`. In one **move**, you can select any subarray of `arr` and reverse it. Return the **minimum number of moves** needed to make `arr` sorted in non-decreasing order. **Note** that the input will be generated such that `arr` can always be sorted using the given operation.","solution":"def min_moves_to_sort(arr): Returns the minimum number of moves needed to sort the array in non-decreasing order. n = len(arr) sorted_arr = sorted(arr) # Finding the length of the longest subsequence that is already sorted l, r = 0, n - 1 while l < n and arr[l] == sorted_arr[l]: l += 1 while r >= 0 and arr[r] == sorted_arr[r]: r -= 1 # If the array is already sorted if l >= r: return 0 # The minimum number of moves required to sort the array is 1 return 1"},{"question":"You are given an integer array `operations` where each element represents a certain type of operation to be performed on a numerical value, starting at zero. The operations are described by the following convention: - \\"ADD x\\" means adding `x` to the current value. - \\"MULTIPLY x\\" means multiplying the current value by `x`. - \\"SUBTRACT x\\" means subtracting `x` from the current value. - \\"DIVIDE x\\" means dividing the current value by `x`, assuming `x` is always non-zero. Write a function that takes in the `operations` array and returns the final value after performing all the given operations sequentially starting from zero. The operations are given as strings in the format described above.","solution":"def perform_operations(operations): Perform a series of operations on a starting value of 0. Parameters: operations (list): A list of strings representing the operations. Returns: int or float: The final result after performing all operations. value = 0 for operation in operations: op_parts = operation.split() command = op_parts[0] num = int(op_parts[1]) if command == \\"ADD\\": value += num elif command == \\"MULTIPLY\\": value *= num elif command == \\"SUBTRACT\\": value -= num elif command == \\"DIVIDE\\": value /= num return value"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to partition the string into as few parts as possible so that each letter appears in at most one part. Return a list of integers representing the lengths of these parts. For example, given `s = \\"ababcbacadefegdehijhklij\\"`, one possible partition would be `[\\"ababcbaca\\", \\"defegde\\", \\"hijhklij\\"]` and your output should be `[9, 7, 8]`. Your task is to implement an algorithm to achieve this in `O(n)` time complexity where `n` is the length of the string `s`.","solution":"def partition_labels(s): Partition the string into as few parts as possible so that each letter appears in at most one part. Return a list of integers representing the lengths of these parts. # Result list to store the lengths of each part result = [] # Dictionary to store the last occurrence of each character last_occurrences = {char: index for index, char in enumerate(s)} # Initialize the starting index of the current part start, end = 0, 0 # Iterate through the string characters for index, char in enumerate(s): # Update the end index of the current part based on the last occurrence of the current character end = max(end, last_occurrences[char]) # If the current index reaches the end of the current part if index == end: # Append the length of the current part to the result list result.append(end - start + 1) # Update the starting index of the next part start = index + 1 return result"},{"question":"Given the root of a binary search tree (BST), return a balanced BST that has the same node values. A balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. If there are multiple solutions, return any of them.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Converts a sorted array to a balanced BST. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid + 1:]) return root def inorder_traversal(root): Performs in-order traversal of a BST and returns a sorted array of node values. return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def balance_bst(root): Returns a balanced BST with the same node values as the input BST. sorted_nodes = inorder_traversal(root) return sorted_array_to_bst(sorted_nodes)"},{"question":"A company wants to create an internal messaging system where each message can be replied to, creating a conversation thread. Each message has a unique integer `id`, and a `parent_id` that indicates the message it is replying to. If a message is a root message, its `parent_id` is -1. Given a list of messages represented by an array of objects where each object contains an `id` and a `parent_id`, your task is to write a function that returns the height of the deepest conversation thread. The height of a thread is the number of messages in the longest path from a root message to its deepest reply. Ensure that the function handles circular references and disconnected messages correctly.","solution":"def find_deepest_thread_height(messages): from collections import defaultdict, deque # Build the adjacency list for the tree of messages tree = defaultdict(list) indegree = defaultdict(int) for message in messages: id = message[\'id\'] parent_id = message[\'parent_id\'] if parent_id != -1: tree[parent_id].append(id) indegree[id] += 1 else: indegree[id] += 0 # To make sure root messages are counted # Detect and handle cycles def has_cycle(node, visited, rec_stack): visited.add(node) rec_stack.add(node) children = tree[node] for child in children: if child not in visited: if has_cycle(child, visited, rec_stack): return True elif child in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in indegree: if node not in visited: if has_cycle(node, visited, rec_stack): return -1 # Indicates that there\'s a cycle # Perform BFS to get the height of the deepest thread def bfs_height(root): queue = deque([(root, 1)]) # (node, height) max_height = 1 while queue: current_node, current_height = queue.popleft() for child in tree[current_node]: queue.append((child, current_height + 1)) max_height = max(max_height, current_height + 1) return max_height max_thread_height = 0 # Consider all root nodes for node in indegree: if indegree[node] == 0: # It\'s a root node max_thread_height = max(max_thread_height, bfs_height(node)) return max_thread_height"},{"question":"You are given a list of `n` distinct positive integers and an integer `k`. Find the `kth` largest element in the list. Implement a function to return the `kth` largest element by only modifying the original list. You may assume `k` is valid (1 ≤ k ≤ n).","solution":"def kth_largest(nums, k): Returns the kth largest element in the list nums. It modifies the original list nums. :param nums: List of distinct positive integers :param k: Integer representing the kth position :return: The kth largest element in the list nums.sort(reverse=True) return nums[k-1]"},{"question":"You are given a sorted array `arr` of distinct integers and a target value `target`. Write a function that finds the two distinct elements in the array that sum up to the target value. Return the indices of the two numbers in a tuple `(i, j)`, where `i` and `j` are the indices of the elements in `arr`, and `i < j`. If no such pair exists, return `(-1, -1)`. You must accomplish this in O(n) time complexity.","solution":"def two_sum(arr, target): Finds two distinct elements in the sorted array that sum up to the target value. Returns the indices of the two numbers in a tuple (i, j), or (-1, -1) if no such pair exists. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return (left, right) elif current_sum < target: left += 1 else: right -= 1 return (-1, -1)"},{"question":"A company\'s security system records entry and exit times of employees. Each record in the system is represented as a tuple `(employee_id, event, time)`, where `employee_id` is a unique identifier for the employee, `event` is either \\"entry\\" or \\"exit\\", and `time` is the time in minutes since the start of the day when the event occurred. Given a list of such records for a single day, return a dictionary where the keys are `employee_id`s and the values are the total time each employee spent in the office during that day. Assume that for every entry event there is a corresponding exit event. If an employee has multiple entry and exit events, sum up all the periods they spent in the office.","solution":"def calculate_time_in_office(records): Returns a dictionary where keys are employee_ids and values are the total time spent in the office. time_in_office = {} entry_times = {} for record in records: employee_id, event, time = record if event == \\"entry\\": entry_times[employee_id] = time elif event == \\"exit\\": if employee_id in entry_times: entry_time = entry_times.pop(employee_id) if employee_id in time_in_office: time_in_office[employee_id] += time - entry_time else: time_in_office[employee_id] = time - entry_time return time_in_office"},{"question":"Given an array of integers `nums`, return the length of **the longest** subarray containing only `1`\'s after deleting **one element** from `nums`. If all the elements in `nums` are `0`, return `0`. Note: The deletion operation can only be performed once, and the result should be the maximum possible length of a subarray of `1`\'s you can achieve.","solution":"def longest_subarray(nums): Finds the length of the longest subarray of 1\'s after deleting one element. Parameters: nums (list of int): The input list of integers, consisting of 0\'s and 1\'s. Returns: int: The length of the longest subarray of 1\'s after deleting one element. max_len = 0 left = 0 zero_count = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given a **0-indexed** integer array `changes` representing the change in altitude at each step of a hike. The altitude starts at `0`. You can assume that every element in the array `changes` is non-zero. A valley is defined as a sequence of consecutive steps where you go below sea level (altitude < 0) and then back up to sea level. Return _the total number of **valleys** encountered during the hike_. A valley starts when you first step below sea level and ends when you return to sea level.","solution":"def count_valleys(changes): Count the total number of valleys based on changes in altitude. A valley starts when you step below sea level and ends when you return to sea level. Args: changes (list of int): list representing the change in altitude at each step. Returns: int: the total number of valleys encountered during the hike. altitude = 0 valleys = 0 in_valley = False for change in changes: prev_altitude = altitude altitude += change if prev_altitude >= 0 and altitude < 0: in_valley = True if in_valley and altitude == 0: valleys += 1 in_valley = False return valleys"},{"question":"Given an array of integers `nums` representing the digits of a large integer, add one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. Return the resulting array of digits after adding one to the integer.","solution":"def plus_one(nums): Given an array of integers representing the digits of a large integer, add one to the integer and return the resulting array of digits. n = len(nums) for i in range(n-1, -1, -1): if nums[i] < 9: nums[i] += 1 return nums nums[i] = 0 return [1] + nums"},{"question":"You are given a list of `n` integers, where each integer can be either positive, negative, or zero. Your task is to find out the length of the longest contiguous subarray that contains at least one positive integer, one negative integer, and one zero. If no such subarray exists, return `0`. Please write a function `int longestSubarray(int[] nums)` that accomplishes this task.","solution":"def longestSubarray(nums): Find the length of the longest contiguous subarray that contains at least one positive integer, one negative integer, and one zero. Parameters: nums (list): List of integers. Returns: int: Length of the longest subarray or 0 if no such subarray exists. n = len(nums) max_len = 0 for i in range(n): has_positive = has_negative = has_zero = False for j in range(i, n): if nums[j] > 0: has_positive = True elif nums[j] < 0: has_negative = True elif nums[j] == 0: has_zero = True if has_positive and has_negative and has_zero: max_len = max(max_len, j - i + 1) return max_len"},{"question":"A company is developing a new social media platform and wants to implement a feature that identifies \\"key influencers\\". You are given a 2D list `followers`, where `followers[i][j] = 1` indicates that user `i` follows user `j`, and `followers[i][j] = 0` indicates that they do not. The platform considers a user an influencer if they have the following properties: - They are followed by everyone else except themselves. - They do not follow anyone. Return the _index of the influencer_ if there is one, else return `-1`. If there are multiple influencers, return the index of the first one found. Users are labeled from `0` to `n-1`. ```python def find_influencer(followers): pass # Your implementation here ```","solution":"def find_influencer(followers): Finds the index of the influencer in the given followers matrix. An influencer is: - Followed by everyone else except themselves. - Does not follow anyone. :param followers: 2D list indicating who follows whom :return: Index of the influencer or -1 if there is none n = len(followers) for i in range(n): if all(followers[j][i] == 1 for j in range(n) if j != i) and all(followers[i][j] == 0 for j in range(n)): return i return -1"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of each person in a line. The heights are distinct integers. You are allowed to swap any two adjacent persons in the line any number of times. However, the cost of swapping two people with heights `a` and `b` is `|a - b|`. Calculate the minimum total cost required to arrange the people in non-decreasing order of their heights. Return the minimum total cost as an integer.","solution":"def min_cost_to_sort_heights(heights): Returns the minimum total cost to sort the array of heights in non-decreasing order. The cost of swapping two people with heights a and b is |a - b|. n = len(heights) sorted_heights = sorted(heights) total_cost = 0 # Create a map of original indices index_map = {value: index for index, value in enumerate(heights)} for i in range(n): original_index = i sorted_value = sorted_heights[i] while heights[original_index] != sorted_value: target_index = index_map[sorted_value] # Swap the two heights heights[original_index], heights[target_index] = heights[target_index], heights[original_index] index_map[heights[original_index]], index_map[heights[target_index]] = original_index, target_index # Calculate the cost of swapping swap_cost = abs(heights[original_index] - heights[target_index]) total_cost += swap_cost return total_cost"},{"question":"You are given a **0-indexed** integer array `nums` representing the amount of money of each house, and you are a thief who plans to rob houses. Each house has a certain amount of money stashed, and you can steal from as many houses as you like, with the constraint that you cannot steal from two adjacent houses on the same night. Determine the maximum amount of money you can rob in one night. Return _the maximum amount of money you can rob_ without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] rob_prev_prev = 0 # max amount if we rob two houses before rob_prev = nums[0] # max amount if we rob the last house before this house for money in nums[1:]: current = max(rob_prev, rob_prev_prev + money) rob_prev_prev = rob_prev rob_prev = current return rob_prev"},{"question":"Given a string `s` containing only lowercase letters, determine if it can be rearranged to form a palindrome. A palindrome is a word that reads the same forward and backward. Implement the function `canFormPalindrome(s: str) -> bool`. Return `True` if it\'s possible to rearrange the string to form a palindrome; otherwise, return `False`.","solution":"def canFormPalindrome(s: str) -> bool: Determine if a string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one of its characters has an odd count. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"Given an array `nums` of integers and an integer `k`, return the **number of unique** `k`-length subarrays in `nums` that have an average of exactly `k`. A subarray is a contiguous non-empty sequence of elements within an array. The result should count each unique subarray only once, regardless of how many times it appears in `nums`. For example, given `nums = [1, 2, 3, 4, 5]` and `k = 2`, the subarrays `[1, 3]` and `[4, 5]` have an average of `2`. So the function should return `2`.","solution":"def count_unique_subarrays_with_k_average(nums, k): Returns the number of unique k-length subarrays that have an average of exactly k. Parameters: nums (List[int]): List of integers. k (int): Length and target average of subarrays. Returns: int: Number of unique k-length subarrays with average k. if k <= 0 or len(nums) < k: return 0 unique_subarrays = set() n = len(nums) for i in range(n - k + 1): subarray = tuple(nums[i:i + k]) if sum(subarray) == k * k: # k-length subarray with exact average k unique_subarrays.add(subarray) return len(unique_subarrays)"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` is a jumbled version of another string where each character in `s` has been shifted to a new position based on the corresponding value in the `indices` array. Write a function to reconstruct the original string from the given jumbled string `s` and `indices`. Return the reconstructed string.","solution":"def restore_string(s, indices): Given a jumbled string `s` and an integer array `indices`, this function reconstructs the original string by arranging the characters in `s` to the positions indicated by `indices`. :param s: A jumbled string. :param indices: A list of integers. :return: The reconstructed original string. # Initialize an empty list with the length of the string result = [\'\'] * len(s) # Place each character in its correct position for i, char in enumerate(s): result[indices[i]] = char # Join the list into a string and return return \'\'.join(result)"},{"question":"You are given an array of `n` integers representing the heights of buildings. A painter can paint all buildings between two given indices `(i, j)` inclusive and it costs the height of the tallest building between indices `i` and `j`. Your task is to find the minimum cost to paint all buildings from index `0` to `n-1`. You cannot paint a building more than once. Given the array `heights` representing the building heights, return the minimum cost to paint all these buildings.","solution":"def min_cost_to_paint(heights): n = len(heights) dp = [float(\'inf\')] * n for i in range(n): tallest = 0 for j in range(i, -1, -1): tallest = max(tallest, heights[j]) if j == 0: dp[i] = min(dp[i], tallest) else: dp[i] = min(dp[i], dp[j - 1] + tallest) return dp[-1]"},{"question":"You are given an array of unique integers `arr` and two integers `x` and `y`. Your task is to find the smallest subarray that contains at least one occurrence of both `x` and `y`. If such a subarray does not exist, return an empty array. If there are multiple such subarrays of the same minimum length, return the one that appears first.","solution":"def smallest_subarray_with_elements(arr, x, y): Finds the smallest subarray that contains at least one occurrence of both x and y. :param arr: List of unique integers. :param x: Integer to be included in the subarray. :param y: Integer to be included in the subarray. :return: List representing the smallest subarray containing both x and y. Returns an empty list if no such subarray exists. if x not in arr or y not in arr: return [] n = len(arr) index_x, index_y = -1, -1 min_len = float(\'inf\') start, end = 0, 0 for i in range(n): if arr[i] == x: index_x = i if arr[i] == y: index_y = i if index_x != -1 and index_y != -1: current_len = abs(index_x - index_y) + 1 if current_len < min_len: min_len = current_len start = min(index_x, index_y) end = max(index_x, index_y) if min_len == float(\'inf\'): return [] return arr[start:end + 1]"},{"question":"You are given a 2D grid of size `m x n` where each cell represents collection points of water, denoted by `1`, and empty spaces, denoted by `0`. The water can only move horizontally and vertically between adjacent cells. A water cell can absorb other water cells connected directly and indirectly to it to form a single connected water body. Return the size of the largest connected water body.","solution":"def largest_water_body(grid): Returns the size of the largest connected water body in the grid. :param grid: List[List[int]] - The input 2D grid. :return: int - The size of the largest connected water body. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark this cell as visited size = 1 # Current cell size # Explore all 4 possible directions size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: water_body_size = dfs(i, j) max_size = max(max_size, water_body_size) return max_size"},{"question":"You are given two integer arrays `arr1` and `arr2` of equal length. Each array represents the set of digits for two separate numbers. Your task is to determine if it is possible to rearrange the digits of `arr1` to form a number greater than or equal to the number formed by arranging the digits of `arr2` in the non-decreasing order. Return `true` if possible, otherwise return `false`.","solution":"def can_rearrange_to_form_number(arr1, arr2): Determines if it is possible to rearrange the digits of arr1 to form a number greater than or equal to the number formed by arranging the digits of arr2 in non-decreasing order. Parameters: arr1 (list of int): The first array of digits. arr2 (list of int): The second array of digits. Returns: bool: True if possible, otherwise False. # Sort arr1 in non-increasing order to get the largest possible number arr1_sorted_desc = sorted(arr1, reverse=True) # Sort arr2 in non-decreasing order arr2_sorted_asc = sorted(arr2) # Compare each digit starting from the left for digit1, digit2 in zip(arr1_sorted_desc, arr2_sorted_asc): if digit1 > digit2: return True elif digit1 < digit2: return False # If all digits are equal, return True return True"},{"question":"You are given two arrays `nums1` and `nums2` of equal length, both containing integers. You need to transform `nums1` into a permutation of itself such that it maximizes the sum of the minimum values between the corresponding pairs of elements from `nums1` and `nums2`. That is, for each `i`, you choose the smallest number between `nums1[i]` and `nums2[i]` and aim to maximize the sum of these chosen values. Return _the maximum possible sum of the minimum values_.","solution":"def max_sum_of_mins(nums1, nums2): Return the maximum possible sum of the minimum values between two arrays. # Sort both arrays nums1.sort() nums2.sort() # Initialize the sum max_sum = 0 # Iterate over the pairs and accumulate the sum of minimum values for a, b in zip(nums1, nums2): max_sum += min(a, b) return max_sum"},{"question":"Given a list of `n` integers, return the length of the longest subsequence such that every element in the subsequence is divisible by every other element in the subsequence. A subsequence is a sequence derived by deleting some or no elements from the list while keeping the order of the remaining elements. For example, given the list `[1, 3, 6, 24]`, a valid longest subsequence would be `[1, 3, 6, 24]` and its length is `4`.","solution":"def longest_divisible_subsequence(arr): if not arr: return 0 arr.sort() dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] % arr[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to find the **kth largest** element in the list. Note that it is the kth largest element in the sorted order, not the kth distinct element. Return the _kth largest element_.","solution":"import heapq def kth_largest(nums, k): Returns the kth largest element in the list nums. return heapq.nlargest(k, nums)[-1]"},{"question":"Given an integer array `nums` of length `n`, return the smallest positive integer that is **missing** from the array. The array contains unique numbers ranging from `-1000000` to `1000000`. For example, if `nums = [3, 4, -1, 1]`, the first missing positive integer is `2`, and for `nums = [1, 2, 0]`, the first missing positive integer is `3`. Return _the smallest missing positive integer_.","solution":"def first_missing_positive(nums): Given an integer array nums, returns the smallest positive integer that is missing from the array. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]: nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"You are designing a voting system for a large organization. Each vote consists of a voter\'s ID and the candidate they voted for. The system must support the following functionality: * Recording a new vote, given a valid voter\'s ID and the candidate\'s name. * Retracting a vote, given a valid voter\'s ID. Only the most recent vote by that voter is retracted. * Retrieving the current vote count for a particular candidate. Implement the `VotingSystem` class: * `VotingSystem()` Initializes an empty voting system. * `void vote(string voterId, string candidate)` Records a vote from the voter with ID `voterId` for the candidate `candidate`. * `void retractVote(string voterId)` Retracts the most recent vote from the voter with ID `voterId`. If the voter has not voted, do nothing. * `int getVoteCount(string candidate)` Returns the current vote count for the candidate `candidate`. If the candidate has no votes, return 0. Ensure the system efficiently handles multiple votes and retractions.","solution":"class VotingSystem: def __init__(self): self.votes = {} self.candidates = {} def vote(self, voterId, candidate): if voterId in self.votes: previous_candidate = self.votes[voterId] self.candidates[previous_candidate] -= 1 if self.candidates[previous_candidate] == 0: del self.candidates[previous_candidate] self.votes[voterId] = candidate if candidate in self.candidates: self.candidates[candidate] += 1 else: self.candidates[candidate] = 1 def retractVote(self, voterId): if voterId in self.votes: candidate = self.votes.pop(voterId) self.candidates[candidate] -= 1 if self.candidates[candidate] == 0: del self.candidates[candidate] def getVoteCount(self, candidate): if candidate in self.candidates: return self.candidates[candidate] else: return 0"},{"question":"Given a linked list, reorder it so that the nodes are rearranged such that the node at the head is followed by the node at the tail, then the second node, then the one before the tail, and so on. Specifically, given a singly linked list `L: L0 -> L1 -> ... -> Ln-1 -> Ln`, reorder it to: `L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...`. **You may not modify the values in the list\'s nodes, only nodes may be changed.**","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorders the list such that the node at the head is followed by the node at the tail, then the second node, and the one before the tail, and so on. if not head or not head.next: return # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the list prev = None curr = slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Step 3: Merge the two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first = temp1 second = temp2"},{"question":"Given a string `s` containing only lowercase English letters and an integer `k`, return the length of the longest subsequence of `s` such that the difference between the indices of any two consecutive characters in the subsequence is at least `k`. A subsequence is a sequence that can be derived from `s` by deleting some or no characters without changing the order of the remaining characters.","solution":"def longest_subsequence_with_k_difference(s, k): Given a string `s` containing only lowercase English letters and an integer `k`, returns the length of the longest subsequence of `s` such that the difference between the indices of any two consecutive characters in the subsequence is at least `k`. n = len(s) if n == 0 or k == 0: return 0 dp = [1] * n for i in range(n): for j in range(i): if i - j >= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a **0-indexed** array `heights` of size `n`, where `heights[i]` represents the height of the `i`-th building. You are standing on the ground and can jump from one building to another. Each jump takes you from building `i` to building `j` with the cost of `|heights[i] - heights[j]|`. You can start your jump from any building and end at any building. Your task is to find the minimum total cost required to visit all buildings. Implement a function: ```python def minJumpCost(heights: List[int]) -> int: ``` where: * `heights` - a list of integers representing the heights of the buildings. Return the minimum total cost to visit all buildings.","solution":"from typing import List def minJumpCost(heights: List[int]) -> int: Given a list of building heights, compute the minimum total cost to visit all buildings. n = len(heights) if n < 2: return 0 sorted_heights = sorted(heights) min_cost = 0 for i in range(1, n): min_cost += abs(sorted_heights[i] - sorted_heights[i - 1]) return min_cost"},{"question":"You are given a matrix `matrix` of dimensions `m x n`, where each cell contains either a `0` or a `1`. A cell containing a `1` is part of an island of land, while a cell containing `0` is water. An island consists of all `1`s connected in 4-direction (horizontal or vertical). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. A cell contains at most one land. Return the largest single island size found in the matrix.","solution":"def largest_island(matrix): Return the largest single island size found in the matrix. :param matrix: List[List[int]] - A 2D matrix containing 0s and 1s :return: int - The size of the largest island if not matrix: return 0 m, n = len(matrix), len(matrix[0]) visited = [[False for _ in range(n)] for _ in range(m)] max_island_size = 0 def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size for i in range(m): for j in range(n): if matrix[i][j] == 1 and not visited[i][j]: island_size = dfs(i, j) max_island_size = max(max_island_size, island_size) return max_island_size"},{"question":"Given a list of non-negative integers `nums`, you are tasked with finding the maximum sum you can obtain by selecting non-adjacent elements from the list. Return the maximum sum. Note that this sum must be obtained by selecting elements that are not directly next to each other in the original list.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the nums list. if not nums: return 0 elif len(nums) == 1: return nums[0] incl = nums[0] excl = 0 for num in nums[1:]: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"Given two strings, `start` and `end`, and a list of strings called `wordList`, return the **length of the shortest transformation sequence** from `start` to `end`, such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the wordList. Note that `start` is not a transformed word and all words in the list are of the same length. If there is no such transformation sequence, return 0.","solution":"from collections import deque def ladderLength(start, end, wordList): if end not in wordList: return 0 wordList.add(end) queue = deque([(start, 1)]) while queue: word, length = queue.popleft() if word == end: return length for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = word[:i] + c + word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append((next_word, length + 1)) return 0"},{"question":"A **palindromic subsequence** is a subsequence of a string that reads the same forward and backward. Given a string `s`, return the length of the longest palindromic subsequence in `s`. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, given the string `s = \\"bbbab\\"`, the longest palindromic subsequence is `\\"bbbb\\"`, so you should return `4`.","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the given string s. n = len(s) # dp[i][j] will be the length of the longest palindromic subsequence in s[i:j+1] dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the dp array from shorter subsequences to longer ones for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"You are given a **connected** and **undirected** graph with `n` nodes labeled from `0` to `n-1` and an array `edges` where `edges[i] = [ai, bi]` represents an undirected edge between nodes `ai` and `bi`. You need to determine if the graph contains a **cycle**. A cycle is defined as a path of edges and vertices wherein a vertex is reachable from itself through just more than one edge, without traversing the same edge more than once. Return `true` _if the graph contains a cycle_, otherwise return `false`.","solution":"def contains_cycle(n, edges): def dfs(node, parent, visited, adj_list): visited[node] = True for neighbor in adj_list[node]: if not visited[neighbor]: if dfs(neighbor, node, visited, adj_list): return True elif neighbor != parent: return True return False adj_list = [[] for _ in range(n)] for edge in edges: adj_list[edge[0]].append(edge[1]) adj_list[edge[1]].append(edge[0]) visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, -1, visited, adj_list): return True return False"},{"question":"You are given a **0-indexed** 2D matrix `matrix` of `n` rows and `m` columns where matrix[i][j] represents the number of distinct characters in the cell at the ith row and jth column. You are also given a **non-empty** string `pattern` consisting of lowercase English letters. You need to find if it is possible to traverse the matrix starting from any cell in such a way that the characters along the traversal path form the same sequence as the given `pattern`. You can only move either **right** or **down** from any cell. Return _true if such a path exists, otherwise, return false_.","solution":"def does_pattern_exist(matrix, pattern): Determines if the given pattern can be traversed in the matrix. Parameters: matrix (List[List[int]]): 2D matrix of characters. pattern (str): The pattern to be searched. Returns: bool: True if pattern exists, False otherwise. rows = len(matrix) cols = len(matrix[0]) pattern_length = len(pattern) def dfs(r, c, pi): if pi == pattern_length: return True if r < 0 or r >= rows or c < 0 or c >= cols: return False if matrix[r][c] != pattern[pi]: return False # Move right if dfs(r, c + 1, pi + 1): return True # Move down if dfs(r + 1, c, pi + 1): return True return False for row in range(rows): for col in range(cols): if dfs(row, col, 0): return True return False"},{"question":"You are given a grid of `n x m` size, filled with integers, where each cell contains a certain number of apples. You start from the top-left corner of the grid and aim to reach the bottom-right corner. You can only move right or down at any point in time. Your objective is to collect the maximum number of apples possible along your path to the destination. Return _the maximum number of apples you can collect from the top-left to the bottom-right corner of the grid._","solution":"def max_apples(grid): Returns the maximum number of apples that can be collected from the top-left to the bottom-right corner of the grid, moving only right or down. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"Given a `2D` integer matrix, where each element represents the cost of stepping into that cell, return _the minimum cost path from the top-left corner to the bottom-right corner_. You can only move down or to the right at any point in time. The objective is to navigate through the matrix obtaining the lowest possible cost by considering the sum of all numbers along the path.","solution":"def min_path_sum(cost_grid): Compute the minimum cost path from the top-left to the bottom-right of the grid. :param cost_grid: List[List[int]] - 2D list with each cell representing the cost :return: int - the minimum cost to reach the bottom-right cell if not cost_grid or not cost_grid[0]: return 0 rows = len(cost_grid) cols = len(cost_grid[0]) # Initialize a DP table with the same dimensions as cost_grid dp = [[0] * cols for _ in range(rows)] # Start from the top-left corner dp[0][0] = cost_grid[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + cost_grid[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + cost_grid[i][0] # Fill the rest of the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost_grid[i][j] # The bottom-right cell contains the minimum cost return dp[rows-1][cols-1]"},{"question":"Given an integer array `nums`, move all `0\'s` to the end of it while maintaining the relative order of the non-zero elements. Implement a function `moveZeroes` that modifies the array in-place. **Definition of moveZeroes:** Parameters: `int[] nums` Returns: `void` **Example:** ```python nums = [0,1,0,3,12] moveZeroes(nums) # After calling moveZeroes, nums should be [1, 3, 12, 0, 0] ```","solution":"def moveZeroes(nums): Moves all the zeroes to the end of the list while maintaining the relative order of the non-zero elements. n = len(nums) position = 0 # position to place the next non-zero element for i in range(n): if nums[i] != 0: nums[position] = nums[i] position += 1 for i in range(position, n): nums[i] = 0"},{"question":"You have a grid of size `m x n` and you are given an integer `k`. Each cell in the grid has either a `0` (representing an empty cell) or a `1` (representing a cell containing an obstacle). You can move up, down, left, or right from and to an empty cell in one step. Return the minimum number of steps to walk from the top-left corner `[0, 0]` to the bottom-right corner `[m-1, n-1]`, considering you can remove at most `k` obstacles on the way. If it is not possible to find such a route, return `-1`.","solution":"from collections import deque def min_steps_with_k_obstacles(grid, k): Returns the minimum number of steps to walk from [0, 0] to [m-1, n-1] considering at most k obstacles removal. m, n = len(grid), len(grid[0]) if m == 1 and n == 1: return 0 if grid[0][0] == 0 else -1 def is_valid(x, y): return 0 <= x < m and 0 <= y < n directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0, 0)]) # (x, y, steps, obstacles_removed) visited = {(0, 0, 0)} while queue: x, y, steps, obstacles_removed = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): new_obstacles_removed = obstacles_removed + grid[nx][ny] if new_obstacles_removed <= k and (nx, ny, new_obstacles_removed) not in visited: if nx == m - 1 and ny == n - 1: return steps + 1 queue.append((nx, ny, steps + 1, new_obstacles_removed)) visited.add((nx, ny, new_obstacles_removed)) return -1"},{"question":"Given a 2D grid of characters representing a **maze** and a pair of coordinates representing the start and end positions `(x_start, y_start)` and `(x_end, y_end)`, write an algorithm to determine if there is a path from start to end. Each character in the grid is either a `\' \'`, meaning an open cell, or a `\'#\'`, meaning a wall. You can move up, down, left, or right but cannot move through walls. Return `true` if there is a path from the start to the end, and `false` otherwise.","solution":"def is_valid_move(maze, x, y): Check if the move is within the maze and on an open cell. return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == \' \' def find_path(maze, x_start, y_start, x_end, y_end): Returns whether there is a path from (x_start, y_start) to (x_end, y_end). from collections import deque # Directions for moving: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Create a queue to hold the positions to explore, starting with the start position queue = deque([(x_start, y_start)]) # Keep track of visited positions to avoid revisiting visited = set() visited.add((x_start, y_start)) while queue: x, y = queue.popleft() # If we have reached the end position, return True if (x, y) == (x_end, y_end): return True # Explore all possible directions for direction in directions: new_x, new_y = x + direction[0], y + direction[1] # If the move is valid and the cell has not been visited if is_valid_move(maze, new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y)) # If we have exhausted all options and did not reach the end, return False return False"},{"question":"Given an array of integers `nums`, you are tasked to find the maximum length of a subarray that contains at most two distinct numbers such that the two distinct numbers appear consecutively. For example, in the array `[1, 2, 1, 2, 3]`, the subarray `[1, 2, 1, 2]` has two distinct numbers (1 and 2) appearing consecutively. Return _the length of the longest such subarray_.","solution":"def max_subarray_with_two_distinct(nums): Returns the length of the longest subarray that contains at most two distinct numbers such that the two distinct numbers appear consecutively. if not nums: return 0 max_length = 0 left = 0 num_count = {} for right in range(len(nums)): num = nums[right] if num in num_count: num_count[num] += 1 else: num_count[num] = 1 while len(num_count) > 2: left_num = nums[left] num_count[left_num] -= 1 if num_count[left_num] == 0: del num_count[left_num] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given two strings `s` and `t`, and both strings consist of only lowercase English letters. Your task is to determine if `t` can be obtained from `s` by deleting at most one character from `s` and re-arranging the remaining characters. Return _True_ if possible, otherwise return _False_. For example, given `s = \\"abcdef\\"` and `t = \\"bcadef\\"`, the function should return `True` since `t` can be obtained from `s` by removing the character `\'a\'` and rearranging the remaining characters to form `t`. However, for `s = \\"abcdef\\"` and `t = \\"bbcdef\\"`, the function should return `False` since there is no possibility to remove just one character and rearrange the remaining ones to form `t`.","solution":"def can_form_by_deleting_one(s, t): Determine if `t` can be obtained from `s` by deleting at most one character from `s` and rearranging the remaining characters. # If the length difference is more than 1, it\'s not possible if len(s) != len(t) + 1: return False # Check if `t` + one extra character can make `s` by counting characters from collections import Counter count_s = Counter(s) count_t = Counter(t) # `count_t` should be equal to `count_s` with one extra character for char, count in count_s.items(): if char in count_t: if count_t[char] != count: extra_char = char else: extra_char = char count_s[extra_char] -= 1 if count_s[extra_char] == 0: del count_s[extra_char] return count_s == count_t"},{"question":"You are given a string containing only characters `(` and `)` representing a balanced parenthesis expression. Your task is to determine the depth of the nested parentheses. The depth is the maximum number of nested parentheses in the expression. For instance, in the expression `\\"((()))\\"`, the depth is `3` since there are three opening parentheses before encountering a closing parenthesis. Return the depth of the nested parentheses in the string.","solution":"def max_depth(s): Returns the maximum depth of nested parentheses in the expression s. Args: s (str): A string containing only characters \'(\' and \')\'. Returns: int: The maximum depth of nested parentheses. current_depth = 0 max_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"You are given a list of strings `words` and a string `letters`. Each string in `words` can only be formed using the characters from `letters`, with each character from `letters` being used at most once per string. Design an algorithm to find the list of words that can be formed using the maximum number of characters from `letters`. If there are multiple such lists, return the list that comes first in lexicographic order. Implement the `Solution` class: * `Solution(String[] words, String letters)` - Initializes the object with the given list of words and letters. * `List<String> getMaxWords()` - Returns a list of words that can be formed using the maximum number of characters from `letters`, following the rules mentioned above.","solution":"from collections import Counter from typing import List class Solution: def __init__(self, words: List[str], letters: str): self.words = words self.letters = letters def can_form_word(self, word, letters_count): word_count = Counter(word) for char in word_count: if word_count[char] > letters_count.get(char, 0): return False return True def getMaxWords(self) -> List[str]: letters_count = Counter(self.letters) max_length = 0 result = None for word in self.words: if self.can_form_word(word, letters_count): if len(word) > max_length: max_length = len(word) result = [word] elif len(word) == max_length: result.append(word) if result: result.sort() return result else: return []"},{"question":"You are given an array of integers `nums` and an integer `threshold`. Your task is to find the **minimum** possible value of the largest sum after dividing the array into `m` non-empty contiguous subarrays such that for any one of these subarrays, the sum of its elements does not exceed the `threshold`. To accomplish this, you need to determine how many such subarrays can be created, each with a sum that is less than or equal to the `threshold`. Return the **minimum** possible value of the largest sum of these subarrays.","solution":"def split_array(nums, threshold): Returns the minimum possible value of the largest sum after dividing array into m non-empty contiguous subarrays. def valid(mid): total, count = 0, 1 for num in nums: if total + num > mid: total = num count += 1 if count > threshold: return False else: total += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if valid(mid): right = mid else: left = mid + 1 return left"},{"question":"Given an integer `x`, return the square root of `x`. If `x` is not a perfect square, return the floor value of the square root. Implement the `int mySqrt(int x)` function, which computes and returns the square root of `x` without using any built-in square root functions. Your solution should achieve a time complexity of O(log x).","solution":"def mySqrt(x): Computes and returns the floor value of the square root of x. if x < 2: return x left, right = 0, x while left <= right: mid = (left + right) // 2 if mid * mid == x: return mid elif mid * mid < x: left = mid + 1 else: right = mid - 1 return right"},{"question":"You are given an array of integers `arr` and an integer `target`. You need to count the number of pairs in the array whose sum is equal to the `target`. Each element in the array can only be used once for forming a pair. Return _the number of such pairs in the array_.","solution":"def count_pairs_with_sum(arr, target): Returns the number of pairs in the array `arr` whose sum is equal to `target`. Each element in the array can be used only once. count = 0 seen = set() for num in arr: complement = target - num if complement in seen: count += 1 seen.remove(complement) # remove the complement to ensure it\'s not reused else: seen.add(num) return count"},{"question":"You are given an array of integers `height` representing the heights of buildings, where `height[i]` is the height of the `i-th` building. Assume that it is raining, and the buildings form a histogram chart. Calculate how much water will be trapped after raining. Return the total amount of water that will be trapped. ---","solution":"def trap(height): Returns the total amount of water that will be trapped after raining. :param height: List[int], the heights of the buildings :return: int, the total amount of water trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill the left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill the right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the water trapped at each index for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"A palindrome is a string that reads the same backward as forward. Given a string `s`, you can rearrange the characters of `s` to create a palindrome by removing one character at most. Determine if it\'s possible to rearrange the string in such a way and return _the rearranged palindrome string_. If there are multiple possible solutions, return any one of them. If it\'s not possible to rearrange the string into a palindrome, return an empty string.","solution":"from collections import Counter def rearrange_palindrome(s): Rearranges the characters of the string s to create a palindrome by removing one character at most. Returns the rearranged palindrome string if possible, otherwise returns an empty string. # Count the occurrences of each character count = Counter(s) # Check how many characters have an odd count odd_count_chars = [char for char, cnt in count.items() if cnt % 2 != 0] # If there is more than one character with an odd count, it\'s not possible # to form a palindrome by removing at most one character if len(odd_count_chars) > 1: return \\"\\" # Construct the first half of the palindrome first_half = [] middle_char = \\"\\" for char, cnt in count.items(): if cnt % 2 != 0: middle_char = char first_half.extend(char * (cnt // 2)) # Form the palindrome by combining first half, middle character (if any), # and the reverse of the first half first_half_str = \'\'.join(first_half) palindrome = first_half_str + middle_char + first_half_str[::-1] return palindrome"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. Each node in the linked list contains a single integer value. For example, rotating the list `[1 -> 2 -> 3 -> 4 -> 5]` to the right by 2 places results in `[4 -> 5 -> 1 -> 2 -> 3]`. **Example 1:** **Input:** head = `[1 -> 2 -> 3 -> 4 -> 5]`, k = 2 **Output:** `[4 -> 5 -> 1 -> 2 -> 3]` **Example 2:** **Input:** head = `[0 -> 1 -> 2]`, k = 4 **Output:** `[2 -> 0 -> 1]` **Example 3:** **Input:** head = `[]`, k = 1 **Output:** `[]` **Constraints:** * The number of nodes in the list is in the range `[0, 500]`. * `-100 <= Node.val <= 100` * `0 <= k <= 2 * 10^9`","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotates the given linked list to the right by k places. if not head or k == 0: return head # Determine the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Calculate the effective rotations needed k = k % length if k == 0: return head # Find the new end and the new head new_end = head for _ in range(length - k - 1): new_end = new_end.next new_head = new_end.next new_end.next = None tail.next = head return new_head def list_to_linkedlist(lst): Converts a list to a linked list. if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linkedlist_to_list(head): Converts a linked list to a list. lst = [] current = head while current: lst.append(current.val) current = current.next return lst"},{"question":"You are given a string `s` consisting only of characters `a`, `b`, and `c`. You can delete any number of characters from `s` to create a new string. Return the **length** of the longest possible substring that contains the same number of occurrences of the characters `a`, `b`, and `c`.","solution":"def longest_equal_substring(s): Returns the length of the longest possible substring that contains the same number of occurrences of the characters \'a\', \'b\', and \'c\'. count = {\'a\': 0, \'b\': 0, \'c\': 0} # Ensure string has equal characters in starting for char in s: if char in count: count[char] += 1 min_count = min(count.values()) return min_count * 3"},{"question":"A frog is attempting to cross a river by jumping on stones arranged in a one-dimensional line. The frog starts at position `0` and wants to reach the last stone. You are given an array `stones` where `stones[i]` represents the position of the `ith` stone. The frog can jump a maximum distance of `k` units initially, but can increase its jump distance by `1` unit with each subsequent stone it jumps on (i.e., if it jumps `j` units to reach the next stone, it can then jump `j+1` units to reach the following stone). Write a function to determine if the frog can reach the last stone. Return _`true` if the frog can reach the last stone, otherwise return `false`_.","solution":"def can_cross(stones, k): Determines if the frog can cross the river by jumping on stones Parameters: stones (List[int]): Positions of the stones in a one-dimensional array k (int): Maximum distance the frog can jump initially Returns: bool: True if the frog can reach the last stone, False otherwise def can_reach(stones, pos, jump, memo): if (pos, jump) in memo: return memo[(pos, jump)] idx = stones.index(pos) if idx == len(stones) - 1: return True for next_jump in range(jump - 1, jump + 2): if next_jump > 0 and pos + next_jump in stones: if can_reach(stones, pos + next_jump, next_jump, memo): memo[(pos, jump)] = True return True memo[(pos, jump)] = False return False return can_reach(stones, stones[0], k, {}) # Example call # stones = [0,1,3,5,6,8,12,17], k = 1 # Output should be True since the frog can jump to reach the last stone"},{"question":"You are given a list of integers representing the widths of consecutive shelves on a wall, and another list representing the heights of those shelves. The amount of books that can be held by a shelf is determined by its width. Each book has a width of 1 unit and a height that doesn\'t matter, so the number of books that can fit on each shelf is equal to the width of the shelf. Given the list of shelf widths and shelf heights, you need to arrange the shelves such that the overall height occupied by all shelves on the wall is minimized. You are allowed to rearrange the shelves in any order. Return the minimum overall height of the shelves when they are rearranged optimally. Example: - Input: widths = [7, 5, 6], heights = [1, 3, 2] - Output: 6","solution":"def min_shelf_height(widths, heights): Returns the minimum overall height of the shelves when rearranged optimally. :param widths: List of integers indicating the widths of the shelves. :param heights: List of integers indicating the heights of the shelves. :return: Integer representing the minimum overall height of the shelves. # Combine widths and heights into pairs and sort based on widths in descending order shelves = sorted(zip(widths, heights), key=lambda x: x[0], reverse=True) # Use the sorted heights to calculate the overall height occupied by all shelves total_height = sum(height for width, height in shelves) return total_height"},{"question":"Given a binary tree, you are required to find the **deepest leaves sum**. The deepest leaves are the leaves that are located farthest from the root of the tree. Return the sum of the values of these deepest leaves. **Note:** - Each node in the tree has an integer value. - The tree structure is defined using the `TreeNode` class, where `TreeNode` has attributes `val`, `left`, and `right`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): from collections import deque if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Given an array of integers `arr`, determine if it is a valid mountain array. An array `arr` is a mountain array if and only if: - `arr.length >= 3` - There exists some index `i` (0 < i < arr.length - 1) such that: - `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]` - `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` Return `true` if `arr` is a mountain array, or `false` otherwise.","solution":"def is_valid_mountain_array(arr): Determines if the given array is a valid mountain array. n = len(arr) if n < 3: return False i = 1 # Walk up while i < n and arr[i] > arr[i - 1]: i += 1 # Peak can\'t be first or last if i == 1 or i == n: return False # Walk down while i < n and arr[i] < arr[i - 1]: i += 1 return i == n"},{"question":"Given a string `s` and an array of strings `words`, return _the number of times the concatenation of every string in_ `words` _appears as a substring in_ `s`. The strings in `words` must be concatenated in any order and without any intervening characters. Note that an empty sequence in `words` should return `0`. For instance, if `s = \\"barfoothefoobarman\\"` and `words = [\\"foo\\",\\"bar\\"]`, `the concatenated substrings are \\"foobar\\" and \\"barfoo\\"`, and their appearances in `s` are counted.","solution":"from itertools import permutations def find_substring_count(s, words): Returns the number of times the concatenation of every string in words appears as a substring in s. The strings in words can be concatenated in any order. if not s or not words: return 0 word_permutations = [\'\'.join(p) for p in permutations(words)] count = 0 for perm in word_permutations: count += s.count(perm) return count"},{"question":"You are given a list of `stockPrices` where `stockPrices[i]` represents the price of a given stock on the `i-th` day, and an integer `k` representing the maximum number of transactions allowed. A transaction is defined as buying and then selling one share of the stock. Design an algorithm to find the maximum profit you can achieve with at most `k` transactions. **Note**: - You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you can buy again). - If no profit can be achieved, return 0. Implement the function: ```python def maxProfit(k: int, stockPrices: List[int]) -> int: ```","solution":"def maxProfit(k, stockPrices): Returns the maximum profit from at most k transactions. n = len(stockPrices) if n == 0 or k == 0: return 0 # If k is greater than half of the number of days, it\'s equivalent to unlimited transactions. if k >= n // 2: return sum(max(stockPrices[i + 1] - stockPrices[i], 0) for i in range(n - 1)) # Initialize the DP table dp = [[0] * (k + 1) for _ in range(n)] for j in range(1, k + 1): max_diff = -stockPrices[0] for i in range(1, n): dp[i][j] = max(dp[i-1][j], stockPrices[i] + max_diff) max_diff = max(max_diff, dp[i][j-1] - stockPrices[i]) return dp[-1][-1]"},{"question":"You are given an array `nums` of size `n`, where each element is an integer in the range `1` to `n` (inclusive). There is exactly one duplicate element in the array. Write a function to find this duplicate number without modifying the original array and using only constant extra space.","solution":"def find_duplicate(nums): Function to find the duplicate number in an array where each element is in the range 1 to n, inclusive. The array has exactly one duplicate. # Using Floyd\'s Tortoise and Hare (Cycle Detection) algorithm slow = nums[0] fast = nums[0] # First phase to find the intersection point in the cycle while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Second phase to find the entrance to the cycle slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow"},{"question":"Given an integer `n`, find all prime numbers less than or equal to `n` and return them as a list. Each returned prime number should be in the sorted order of ascending integers. Note that `n` is guaranteed to be a non-negative integer. Return _a list of all prime numbers less than or equal to_ `n`. Use efficient algorithms to ensure your solution has a reasonable run time for large values of `n`.","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] prime = [True] * (n + 1) prime[0] = prime[1] = False p = 2 while p * p <= n: if prime[p]: for i in range(p * p, n + 1, p): prime[i] = False p += 1 return [p for p in range(n + 1) if prime[p]]"},{"question":"You are given a **0-indexed** integer array `hours`, where `hours[i]` represents the number of hours worked by an employee on the `i`th day of a given week. We consider a day to be a **productive day** if and only if the number of hours worked on that day is **strictly greater** than `8`. An employee is considered to have a **productive week** if more than half of the days in their week are productive days. Return `true` if the employee had a productive week, otherwise return `false`.","solution":"def productive_week(hours): Determines if an employee had a productive week, based on the number of hours worked each day. Arguments: hours -- List of integers, where each integer represents hours worked in a day. Returns: bool -- True if the employee had a productive week, False otherwise. productive_days = sum(1 for h in hours if h > 8) return productive_days > len(hours) // 2"},{"question":"You are given two integers `num1` and `num2` representing two non-negative binary numbers. The binary numbers are given as strings. You need to calculate the sum of these two binary numbers and return the result as a binary string. Ensure that the returned string has no leading zeros except when the string is `\\"0\\"`.","solution":"def add_binary(num1, num2): Returns the sum of two binary numbers represented as strings. # Convert binary strings to integers, add them, then convert the sum back to binary string sum_int = int(num1, 2) + int(num2, 2) return bin(sum_int)[2:] # Remove the \'0b\' prefix"},{"question":"You are given an array of integers `arr` and another integer `threshold`. A subarray of `arr` is called **stable** if the difference between the maximum and minimum elements in the subarray is less than or equal to `threshold`. Return the length of the longest **stable** subarray. A **subarray** is a contiguous part of an array.","solution":"def longest_stable_subarray(arr, threshold): Returns the length of the longest stable subarray in which the difference between the maximum and minimum elements is less than or equal to threshold. n = len(arr) if n == 0: return 0 start = 0 max_len = 1 current_max = arr[0] current_min = arr[0] for end in range(1, n): current_max = max(current_max, arr[end]) current_min = min(current_min, arr[end]) while current_max - current_min > threshold: start += 1 current_max = max(arr[start:end + 1]) current_min = min(arr[start:end + 1]) max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a connected undirected graph with `n` nodes and `m` edges. Each node has a label represented by a unique integer from `1` to `n`, and each edge has a weight represented by a positive integer. You need to find the minimum cost to connect all nodes in the graph. The cost of connecting two nodes is defined as the sum of the weights of the edges used in the connection. Return the minimum cost if it is possible to connect all the nodes, otherwise return -1.","solution":"def min_cost_to_connect_nodes(n, edges): Returns the minimum cost to connect all nodes in the graph using Kruskal\'s algorithm. If it is not possible to connect all the nodes, it returns -1. parent = list(range(n)) rank = [0] * n # A utility function to find the set of an element i def find(i): if parent[i] != i: parent[i] = find(parent[i]) return parent[i] # A function that does union of two sets of x and y def union(x, y): xroot = find(x) yroot = find(y) if xroot != yroot: if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 edges.sort(key=lambda x: x[2]) mst_cost = 0 mst_edges = 0 for u, v, weight in edges: if find(u - 1) != find(v - 1): union(u - 1, v - 1) mst_cost += weight mst_edges += 1 if mst_edges == n - 1: break # If we did not use all n-1 edges, it means we couldn\'t connect all the nodes if mst_edges != n - 1: return -1 return mst_cost"},{"question":"Given two strings `s1` and `s2`, determine the length of the shortest string that has both `s1` and `s2` as subsequences. The problem can be solved by finding the length of the shortest common supersequence (SCS) of `s1` and `s2`. A string `t` is a subsequence of a string `s` if `t` can be obtained from `s` by deleting zero or more characters without changing the order of the remaining characters. Return the length of the shortest common supersequence of `s1` and `s2`.","solution":"def shortest_common_supersequence_length(s1, s2): Returns the length of the shortest common supersequence of s1 and s2. m, n = len(s1), len(s2) # Create a DP table to store lengths of longest common subsequences. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, insert all characters of first string elif s1[i - 1] == s2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given an array `arr` consisting of `n` integers and a positive integer `k`. A **window** is a contiguous subarray of length `k` within `arr`. Your task is to find the maximum sum of any window in the array. Return the maximum sum obtained from any of these windows. If the array length is less than `k`, return `-1`.","solution":"def max_sum_window(arr, k): Returns the maximum sum of any window of length k in the array arr. Parameters: arr (list): List of integers representing the array. k (int): Length of the window. Returns: int: Maximum sum of any window of length k, or -1 if the array length is less than k. if len(arr) < k: return -1 max_sum = float(\'-inf\') current_sum = sum(arr[:k]) for i in range(len(arr) - k + 1): if i != 0: current_sum = current_sum - arr[i - 1] + arr[i + k - 1] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a `rows x cols` grid, where each cell contains an integer representing a quantity of gold. A miner can start from any cell in the first column and can only move to the cell directly right (→), right-up (↗), or right-down (↘) from their current position. The miner tries to collect as much gold as possible along the way until reaching any cell in the last column. Return the maximum amount of gold the miner can collect.","solution":"def get_max_gold(grid): Returns the maximum amount of gold collected by the miner. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize a dp array dp = [[0] * cols for _ in range(rows)] # Fill the dp array for col in range(cols-1, -1, -1): for row in range(rows): # Gold if the miner stays in the same row right = grid[row][col] if col == cols-1 else grid[row][col] + dp[row][col+1] # Gold if the miner moves to the right-up cell right_up = grid[row][col] if (row == 0 or col == cols-1) else grid[row][col] + dp[row-1][col+1] # Gold if the miner moves to the right-down cell right_down = grid[row][col] if (row == rows-1 or col == cols-1) else grid[row][col] + dp[row+1][col+1] # Set the maximum of possible moves dp[row][col] = max(right, right_up, right_down) # Find the maximum gold collected starting from any cell in the first column max_gold = max(dp[row][0] for row in range(rows)) return max_gold"},{"question":"You are given an integer array `nums` that contains `n` integers where `n` is even. The elements of `nums` represent pairs of negative and positive numbers. Your task is to return an array of integers where each pair of numbers (one positive and one negative) is grouped together. The positive number should appear before the corresponding negative number in each pair. The order of these pairs should follow the order of their first occurrence in the original array. For example, if `nums = [3, -3, 1, -1, 2, -2]`, the output should be `[3, -3, 1, -1, 2, -2]`. Return _an array with the grouped pairs following the order of their first occurrence in the array_ `nums`.","solution":"def group_pairs(nums): Groups pairs of positive and negative numbers in the input array \'nums\'. Parameters: nums (list): List of integers with each pair of positive and negative numbers. Returns: list: List where positive numbers are paired with their corresponding negative numbers. pairs = {} result = [] for num in nums: if num > 0: pairs[num] = None else: pairs[-num] = num for num in nums: if num > 0 and pairs[num] is not None: result.append(num) result.append(pairs[num]) pairs[num] = None # Mark the pair as processed return result"},{"question":"You are given a binary tree in which each node contains an integer value. Determine whether the binary tree is a **sum tree**. A sum tree is a binary tree where the value of each node is equal to the sum of the values of its left and right subtrees. An empty tree is considered a sum tree, and the sum of an empty tree is considered 0. Return `true` if the given tree is a sum tree, otherwise return `false`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_sum_tree(node): Returns True if the binary tree rooted at `node` is a sum tree, otherwise False. def sum_and_check(node): if node is None: return 0, True if node.left is None and node.right is None: return node.value, True left_sum, is_left_sum_tree = sum_and_check(node.left) right_sum, is_right_sum_tree = sum_and_check(node.right) total_sum = left_sum + right_sum is_current_sum_tree = (node.value == total_sum) return node.value + total_sum, is_left_sum_tree and is_right_sum_tree and is_current_sum_tree _, is_sum_tree_root = sum_and_check(node) return is_sum_tree_root"},{"question":"You are given a list of `dicts`, where each dict contains information about a student, including their `name` and a list of `scores` for various subjects. Write a function to return a list of names of the students who have the highest average score across all subjects. ```python students = [ {\\"name\\": \\"Alice\\", \\"scores\\": [85, 90, 92]}, {\\"name\\": \\"Bob\\", \\"scores\\": [88, 94, 70]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [91, 85, 87]}, ] # Your function should return [\'Alice\', \'Charlie\'] ``` Return _the **list of names** of the students with the highest average score._","solution":"def students_with_highest_average(students): Returns the list of names of students with the highest average score. highest_avg = float(\'-inf\') top_students = [] for student in students: avg_score = sum(student[\'scores\']) / len(student[\'scores\']) if avg_score > highest_avg: highest_avg = avg_score top_students = [student[\'name\']] elif avg_score == highest_avg: top_students.append(student[\'name\']) return top_students"},{"question":"You are given a list of integers representing the positions of markers on a number line. The goal is to partition the list into the maximum number of non-overlapping sublists such that each sublist contains consecutive integers without gaps. Return the maximum number of such sublists. * For example, if the list is `[1, 2, 4, 5, 6, 8, 9, 10]`, the partitions can be `[1, 2]`, `[4, 5, 6]`, and `[8, 9, 10]`, resulting in `3` sublists.","solution":"def max_partitions(lst): Given a list of integers representing positions, return the maximum number of non-overlapping sublists such that each sublist contains consecutive integers without gaps. if not lst: return 0 lst.sort() # Sort the list partitions = 1 # Iterate over the list and count partitions for i in range(1, len(lst)): if lst[i] != lst[i - 1] + 1: partitions += 1 return partitions"},{"question":"Given an integer `n`, return the smallest prime number that is greater than `n`. To solve the problem, you need to implement a function that efficiently checks for the next prime number beyond the given integer `n`. A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself. Your solution should be optimized to handle relatively large values of `n`. You must ensure the correctness and efficiency of your prime-checking algorithm, potentially utilizing mathematical concepts such as the Sieve of Eratosthenes or trial division up to the square root of the candidate numbers.","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): Returns the smallest prime number that is greater than n. candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"You are given an integer array `nums` representing a sequence of operations where each element is either a positive integer (indicating an add operation) or -1 (indicating a remove operation). Initially, there is an empty set. In each add operation, the corresponding positive integer is added to the set. For each remove operation, if the set is not empty, the largest element is removed. Return an integer array `results` with the same length as `nums` where the i-th element is the maximum element in the set after the i-th operation, or -1 if the set is empty at that point.","solution":"def max_after_operations(nums): Given a list of operations where each element is either a positive integer (indicating an add operation) or -1 (indicating a remove operation), return an array where each element represents the maximum element in the set after each operation, or -1 if the set is empty. result = [] current_set = [] sorted_set = [] for num in nums: if num > 0: # Add the number to the set current_set.append(num) sorted_set = sorted(current_set, reverse=True) elif num == -1: # Remove the largest element if the set is not empty if current_set: current_set.remove(sorted_set[0]) sorted_set.pop(0) # Append the maximum element or -1 if sorted_set: result.append(sorted_set[0]) else: result.append(-1) return result"},{"question":"You are given a positive integer `num` and an integer array `arr` where each element represents the number of units a person needs. You can distribute units to the persons under the following rules: * You have unlimited stock of free units. * Each person gets units in increments of their unique number only. * No two persons should end up with the same number of units. Your task is to find the minimum number of unique units required to meet the needs of all the persons given the distribution rules. Return the minimum number of unique units required. If it\'s impossible to meet the conditions, return `-1`.","solution":"def min_unique_units(num, arr): Returns the minimum number of unique units required to meet the needs of all the persons under the given distribution rules. :param num: a positive integer representing the number of persons. :param arr: List of integers where each element represents the number of units a person needs. :return: Minimum number of unique units required or -1 if impossible. if num != len(arr): return -1 arr.sort() unique_units = set() for units in arr: if units in unique_units: return -1 unique_units.add(units) return len(unique_units)"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to generate a new array where each element at index `i` is the maximum element within the subarray `[arr[i], arr[i+1], ..., arr[i+k-1]]`. If there are fewer than `k` elements remaining after index `i`, consider only the elements up to the end of the array. Implement the function `list<int> getMaxValues(vector<int>& arr, int k)` that returns the new array of maximum values.","solution":"def get_max_values(arr, k): Returns a new array where each element at index `i` is the maximum element within the subarray `[arr[i], arr[i+1], ..., arr[i+k-1]]`. if not arr or k <= 0: return [] n = len(arr) max_values = [] for i in range(n): # Determine the bounds of the subarray subarray_end = min(i + k, n) # Slice the subarray and find the maximum element subarray = arr[i:subarray_end] max_values.append(max(subarray)) return max_values"},{"question":"Given an integer `n`, return the sum of all positive divisors of `n` excluding `n` itself. If `n` is less than or equal to 1, return 0.","solution":"def sum_of_divisors(n): Returns the sum of all positive divisors of n excluding n itself. If n is less than or equal to 1, return 0. if n <= 1: return 0 total = 0 for i in range(1, n): if n % i == 0: total += i return total"},{"question":"You are given a string `s` which only consists of characters \'a\', \'b\', and \'c\'. You can replace any character in `s` with any other character \'a\', \'b\', or \'c\' at most once. Return the length of the longest substring of `s` that contains at most one distinct character after performing any allowed transformation.","solution":"def longest_substring_with_one_distinct_char(s): Returns the length of the longest substring with at most one distinct character after performing at most one character replacement in the input string. max_length = 0 for i in range(len(s)): for char in \'abc\': modified_s = s[:i] + char + s[i+1:] curr_length = max(longest_one_char_segment(modified_s, ch) for ch in \'abc\') max_length = max(max_length, curr_length) return max_length def longest_one_char_segment(s, ch): Returns the length of the longest segment in string `s` that consists of the given character `ch`. max_len = 0 current_len = 0 for char in s: if char == ch: current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"Given an array of integers `nums`, return a new array `result` where each element in `result` is equal to the product of all the elements in `nums` except the one at the corresponding index. You must solve it **without using division** and in linear time complexity.","solution":"def product_except_self(nums): Returns an array where each element is the product of all other elements except the one at that index. :param nums: List[int] - List of integers :return: List[int] - Resultant list n = len(nums) result = [1] * n # Compute the prefix products prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= nums[i] # Compute the suffix products and multiply with the prefix products suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= nums[i] return result"},{"question":"You are given a 2D integer array `grid` where each element of the grid is either `0` (an empty cell) or `1` (a filled cell). A **region** consists of all cells that are connected horizontally or vertically (but not diagonally) that are `1`. Two cells are said to be connected if they share a side. A region is considered **bound�ed** if it is fully surrounded by empty cells or the edges of the grid. Return _the number of distinct **bounded regions** in the grid._","solution":"def num_bounded_regions(grid): Returns the number of bounded regions in the grid. def dfs(i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]: dfs(i + x, j + y) rows, cols = len(grid), len(grid[0]) # Mark all boundary regions for i in range(rows): for j in [0, cols - 1]: if grid[i][j] == 1: dfs(i, j) for j in range(cols): for i in [0, rows - 1]: if grid[i][j] == 1: dfs(i, j) # Count and remove remaining regions bounded_regions = 0 for i in range(1, rows - 1): for j in range(1, cols - 1): if grid[i][j] == 1: bounded_regions += 1 dfs(i, j) return bounded_regions"},{"question":"You are given an integer array `arr` of size `n`. A number `a` is defined to be an **elementary number** if there exists at least one other number `b` in the array such that `a % b == 0`. Return an array of all elementary numbers in `arr`. You may return the answer in **any order**.","solution":"def elementary_numbers(arr): Returns an array of all elementary numbers in arr. An elementary number a in arr is defined to be an elementary number if there exists at least one other number b in arr such that a % b == 0. n = len(arr) elementary_nums = [] for i in range(n): a = arr[i] for j in range(n): if i != j and a % arr[j] == 0: elementary_nums.append(a) break return elementary_nums"},{"question":"Given an input string `s` and a pattern `p`, implement a function to check if `s` matches `p`. The pattern may contain the special character `.` which matches any single character and the special character `*` which matches zero or more of the preceding element. The matching should cover the entire input string (not partial). **Example:** - Input: s = \\"aa\\", p = \\"a\\" - Output: false - Input: s = \\"aa\\", p = \\"a*\\" - Output: true - Input: s = \\"ab\\", p = \\".*\\" - Output: true","solution":"def is_match(s, p): Returns True if the string \'s\' matches the pattern \'p\', False otherwise. # Base Case: if pattern is empty, s should also be empty if not p: return not s # Check if the first character of s matches the first character of p or if p starts with \'.\' first_match = bool(s) and p[0] in {s[0], \'.\'} # Handle the \'*\' in the pattern if len(p) >= 2 and p[1] == \'*\': # * means zero or more of the preceding element # We have two choices: # 1. We ignore the \\".*\\" and move the pointer in p by two (not including the \\"*\\") # 2. if first characters match, we keep the \\"*\\" OR \\"*\\" means we move ahead in s by one return (is_match(s, p[2:]) or (first_match and is_match(s[1:], p))) else: # Move on to the rest of the characters return first_match and is_match(s[1:], p[1:])"},{"question":"You are given an array of integers `arr` where each element represents the height of a building. We want to calculate the total amount of water that can be trapped between the buildings after it rains. You are required to return the _total units of water trapped_. For example, given `arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the total amount of water trapped is 6 units. Write a function that determines the total units of water that can be trapped.","solution":"def trap_rain_water(arr): Calculates the total amount of water that can be trapped between the buildings after it rains. :param arr: List[int], heights of the buildings. :return: int, total units of water trapped. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) # Fill right_max array right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"Given a string `s` representing a student’s performance record consisting of characters \'A\' (absent), \'L\' (late), and \'P\' (present), rewrite the string to represent the student\'s attendance such that a student is rewarded if they have no more than one \'A\' and no more than two consecutive \'L\'. Return a boolean indicating if the student can be rewarded.","solution":"def check_record(s): Returns True if the student can be rewarded based on their attendance record \'s\'. A student can be rewarded if they have no more than one \'A\' (absent) and no more than two consecutive \'L\' (late). return s.count(\'A\') <= 1 and \'LLL\' not in s"},{"question":"Given a square matrix `matrix`, return _the sum of the matrix diagonals_. - The **primary diagonal** runs from the top-left to the bottom-right corner. - The **secondary diagonal** runs from the top-right to the bottom-left corner. **Example:** ``` Input: matrix = [[1,2,3], [4,5,6], [7,8,9]] Output: 25 Explanation: Sum of primary diagonal (1 + 5 + 9) + sum of secondary diagonal (3 + 5 + 7) = 15 + 10 = 25.","solution":"def diagonal_sum(matrix): Returns the sum of the matrix diagonals. For a given square matrix, this function will compute the sum of both primary and secondary diagonals. Args: matrix (list of list of int): A square matrix of integers. Returns: int: The sum of the primary and secondary diagonals. n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - i - 1] # If the matrix size is odd, subtract the middle element once since # it has been added twice if n % 2 != 0: middle_index = n // 2 secondary_diagonal_sum -= matrix[middle_index][middle_index] return primary_diagonal_sum + secondary_diagonal_sum"},{"question":"You are given a string `s` and a list of strings `words` where `words` contains only unique strings, each representing a valid word. Your task is to implement a data structure that supports the following operations: * **AddWord:** Adds a word to the list of valid words. If the word already exists in the list, the operation has no effect. * **DeleteWord:** Deletes a word from the list of valid words. If the word does not exist, the operation has no effect. * **FindSubstring:** Finds the starting index of the first occurrence of any word from the list `words` in the string `s`. If no such substring is found, return `-1`. Implement the `WordManager` class: * `WordManager(String s, List<String> words)` Initializes the data structure with the string `s` and the list of words `words`. * `addWord(String word)` Adds the word to the list of valid words. * `deleteWord(String word)` Deletes the word from the list of valid words. * `findSubstring()` Returns the starting index of the first occurrence of any word in `words` in the string `s`, or `-1` if no valid word is found in `s`.","solution":"class WordManager: def __init__(self, s, words): Initializes the data structure with the string `s` and the list of words `words`. self.s = s self.words = set(words) def addWord(self, word): Adds the word to the list of valid words. self.words.add(word) def deleteWord(self, word): Deletes the word from the list of valid words. self.words.discard(word) def findSubstring(self): Returns the starting index of the first occurrence of any word in `words` in the string `s`. If no valid word is found in `s`, return `-1`. for i in range(len(self.s)): for word in self.words: if self.s.startswith(word, i): return i return -1"},{"question":"Given an integer array `nums`, find a subarray that has the maximum product of its elements, and return the maximum product. A subarray is a contiguous portion of the array. Implement a function `maxProductSubarray(nums: List[int]) -> int` that takes in an array of integers and returns an integer representing the maximum product of a contiguous subarray. For example, given the input array `nums = [2, 3, -2, 4]`, the function should return `6` as the subarray `[2, 3]` has the maximum product `2 * 3 = 6`.","solution":"from typing import List def maxProductSubarray(nums: List[int]) -> int: if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"You are given an integer `n` which represents the number of houses located in a straight line. Each house `i` (where `0 <= i < n`) has a certain amount of money, which is represented by a non-negative integer `money[i]`. Thieves want to rob the houses while avoiding alerting the police. If two adjacent houses are robbed, the police will be alerted. Return _the maximum amount of money that can be robbed without alerting the police._","solution":"def rob_houses(money): Returns the maximum amount of money that can be robbed without alerting the police. :param money: List[int] - A list of non-negative integers representing the amount of money in each house. :return: int - The maximum amount of money that can be robbed. n = len(money) if n == 0: return 0 if n == 1: return money[0] dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"You are given a string `s` that contains an expression with nested parentheses. Your task is to find the maximum depth of the nested parentheses in the given string. The depth of a set of parentheses is represented by the number of pairs of parentheses that contain it. Implement a function `int maxDepth(string s)` that returns the maximum depth of nested parentheses in the string `s`. For example, given the string `s = \\"((1+(2*3))+((8)/4))+1\\"`, the maximum depth is `3`. Return _the maximum depth of nested parentheses in the given string_.","solution":"def maxDepth(s): Returns the maximum depth of nested parentheses in the given string s. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 max_depth = max(max_depth, current_depth) elif char == \')\': current_depth -= 1 return max_depth"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to implement a data structure that supports the following two operations: * `addNode(int value, int parentValue, bool isLeft)` which adds a node with a given `value` as a child of the node with the `parentValue`. If `isLeft` is `true`, the new node becomes the left child; otherwise, it becomes the right child. It\'s guaranteed that the parent node exists. * `int getSum(int X)` which returns the sum of all node values in the subtree rooted at the node with value `X`. It\'s guaranteed that node `X` exists. Implement the `Tree` class: * `Tree(int rootValue)` Initializes the tree with a single node with `rootValue`. * `void addNode(int value, int parentValue, bool isLeft)` Adds a node following the rules defined above. * `int getSum(int X)` Returns the sum of the subtree rooted at the node with value `X`.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class Tree: def __init__(self, rootValue): self.root = TreeNode(rootValue) self.nodes = {rootValue: self.root} def addNode(self, value, parentValue, isLeft): parentNode = self.nodes.get(parentValue) if parentNode: newNode = TreeNode(value) if isLeft: parentNode.left = newNode else: parentNode.right = newNode self.nodes[value] = newNode def getSum(self, X): startNode = self.nodes.get(X) return self._getSubtreeSum(startNode) def _getSubtreeSum(self, node): if node is None: return 0 return node.value + self._getSubtreeSum(node.left) + self._getSubtreeSum(node.right)"},{"question":"You are given a list of integers `nums` and an integer `threshold`. Your task is to return _the length of the longest subsequence of_ `nums` _where the sum of its elements is less than or equal to_ `threshold`. Note: - A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. - The elements in the subsequence may appear in the same order as they do in `nums`.","solution":"def longest_subsequence_with_limit(nums, threshold): Returns the length of the longest subsequence where the sum of elements is less than or equal to threshold. :param nums: List of integers :param threshold: Integer threshold value :returns: Length of the longest subsequence meeting the criteria nums.sort() current_sum = 0 longest_length = 0 for num in nums: if current_sum + num <= threshold: current_sum += num longest_length += 1 else: break return longest_length"},{"question":"Given a string `s` consisting of lowercase English letters, you are tasked with dividing this string into as many parts as possible such that each letter appears in at most one part. Return a list of integers representing the lengths of these parts in order. The division must maximize the number of parts. Each part must be a contiguous substring of `s`.","solution":"def partition_labels(s): Given a string s consisting of lowercase English letters, divide the string into as many parts as possible such that each letter appears in at most one part. Return a list of integers representing the lengths of these parts in order. The division must maximize the number of parts. Each part must be a contiguous substring of s. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] size, end = 0, 0 for idx, char in enumerate(s): size += 1 end = max(end, last_occurrence[char]) if idx == end: partitions.append(size) size = 0 return partitions"},{"question":"Given a string `s` consisting of lowercase alphabets, repeatedly remove adjacent duplicate characters from the string. Return _the final string after all such duplicate removals have been made_. You must ensure that after removing the adjacent duplicates, if any new adjacent duplicates are formed, they are also removed until no more adjacent duplicates are present. **Example:** - Input: s = \\"abbaca\\" - Output: \\"ca\\" **Example:** - Input: s = \\"azxxzy\\" - Output: \\"ay\\" In the first example, \\"abbaca\\" -> \\"aaca\\" -> \\"ca\\". In the second example, \\"azxxzy\\" -> \\"azzy\\" -> \\"ay\\".","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicate characters iteratively until no such duplicates remain. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: str: The final string after all adjacent duplicate removals. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the last character if it\'s the same as the current one else: stack.append(char) # Add the current character to the stack return \'\'.join(stack)"},{"question":"Given an array of integers `arr` and an integer `k`, return the maximum sum of a non-empty subarray of `arr` contained within a window of size `k`. The window can move from the start of the array to the end, and a subarray must fit entirely within this window.","solution":"def max_sum_within_window(arr, k): Given an array of integers arr and an integer k, return the maximum sum of a non-empty subarray of arr contained within a window of size k. n = len(arr) if k > n: return \\"Window size k cannot be greater than the array length\\" max_sum = float(\'-inf\') # Calculate sum of initial window current_window_sum = sum(arr[:k]) for i in range(n - k + 1): current_window_sum = sum(arr[i:i+k]) max_sub_sum = float(\'-inf\') for j in range(1, k + 1): for l in range(i, i + k - j + 1): current_sub_sum = sum(arr[l:l+j]) max_sub_sum = max(max_sub_sum, current_sub_sum) max_sum = max(max_sum, max_sub_sum) return max_sum"},{"question":"You are given an integer array `arr` of length `n`. Write a function that returns a new array `answer` such that `answer[i]` is the **product** of all the elements of `arr` except `arr[i]`. You must solve the problem **without using division** and in **O(n)** time complexity. For example, given `arr = [1, 2, 3, 4]`, the function should return `[24, 12, 8, 6]`. **Constraints**: - The length of `arr` will be in the range `[2, 10^5]`. - Each element `arr[i]` will be in the range `[-30, 30]`. - The product of any prefix or suffix of `arr` is guaranteed to fit in a 32-bit integer.","solution":"def product_except_self(arr): Returns an array where each element at index i is the product of all the elements of arr except arr[i]. n = len(arr) # Initialize arrays to store the prefix and suffix products prefix_products = [1] * n suffix_products = [1] * n answer = [0] * n # Calculate the prefix products for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * arr[i - 1] # Calculate the suffix products for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * arr[i + 1] # Calculate the result by multiplying prefix and suffix products for i in range(n): answer[i] = prefix_products[i] * suffix_products[i] return answer"},{"question":"You are given an array of integers `arr` representing the arrival times of trains at a station, and an integer `k` representing the maximum number of platforms available at the station simultaneously. Each train leaves the station after exactly one unit of time. Return _the maximum number of trains that can be successfully accommodated on the given platforms_.","solution":"def max_trains_accommodated(arr, k): Returns the maximum number of trains that can be successfully accommodated on k platforms given their arrival times in arr. if len(arr) == 0 or k == 0: return 0 # Sort the arrival times to simulate the train arrivals in order arr.sort() # A list to maintain the number of platforms occupied at each time platforms = [0] * (max(arr) + 1) max_trains = 0 for arrival_time in arr: # Each train leaves after exactly one unit of time for time in range(arrival_time, arrival_time + 1): platforms[time] += 1 max_trains = max(max_trains, platforms[time]) # Ensure we don\'t exceed the number of available platforms if platforms[arrival_time] > k: return k return min(max_trains, k)"},{"question":"You are given a **linked list** of integers `head`. Each node contains an integer value and a reference to the next node. Return a **new linked list** where each node contains the _sum of all the values from the start of the list up to that node_. For example, given 1 -> 2 -> 3, the new linked list should be 1 -> 3 -> 6, because - 1 is the sum of the first node, - 3 is the sum of the first and second nodes (1 + 2), - 6 is the sum of the first, second, and third nodes (1 + 2 + 3). Return the head of the new linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def cumulativeSumLinkedList(head: ListNode) -> ListNode: if not head: return None dummy = ListNode(0) curr, cumulative_sum = dummy, 0 while head: cumulative_sum += head.val curr.next = ListNode(cumulative_sum) curr = curr.next head = head.next return dummy.next"},{"question":"You are given a robot that can only move in a grid. The robot is initially at position `(0, 0)`. The grid size is `m x n` and each cell in the grid can either be empty (`0`) or an obstacle (`1`). The robot can only move right (`R`), left (`L`), up (`U`), or down (`D`). Implement a function `bool canReachDestination(int[][] grid)` that determines if the robot can reach the bottom-right corner of the grid, i.e., position `(m-1, n-1)`, starting from `(0, 0)` given the placement of obstacles. Return `true` if the robot can successfully reach the destination, and `false` otherwise. The robot cannot pass through the cells with obstacles and cannot move outside the grid boundaries.","solution":"def canReachDestination(grid): if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 1 or visited[x][y]: return False if x == m - 1 and y == n - 1: return True visited[x][y] = True return dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1) return dfs(0, 0)"},{"question":"You are given an array of integers `arr`. You need to find the maximum sum of elements you can obtain in `arr` subject to the constraint that no two elements are adjacent in the array. Your task is to return this maximum sum.","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of elements in arr such that no two elements are adjacent. if not arr: return 0 if len(arr) == 1: return arr[0] include = arr[0] exclude = 0 for i in range(1, len(arr)): new_exclude = max(include, exclude) include = exclude + arr[i] exclude = new_exclude return max(include, exclude)"},{"question":"You are given a string `s` consisting of only lowercase English letters. You need to determine the **first** character that **repeats** in the string. If there are multiple characters that repeat, return the one that appears **first** in the string. If no character repeats, return an empty string. For example, given `s = \\"swiss\\"`, the function should return `\\"s\\"`, as `\\"s\\"` is the first character that repeats in the string.","solution":"def first_repeating_character(s): Returns the first repeating character in the string s. If no character repeats, returns an empty string. seen = set() for char in s: if char in seen: return char seen.add(char) return \'\'"},{"question":"You are given a **0-indexed** integer array `nums` representing the scores of different students in a class. The school intends to reward students with a grade based on their scores. The grading system works as follows: * A student with the highest score receives an \\"A\\". * If there is more than one student with the highest score, all such students receive a \\"A\\". * If there are remaining students with more scores after giving all \\"A\\" grades, the next highest score receives a \\"B\\". * Again, if there are ties, all such students receive a \\"B\\". * Continue this pattern with grades \\"C\\", \\"D\\", etc., until all students are graded. Return _a list where each element at index `i` is the grade of the student with the score `nums[i]`. For example, given `nums = [50, 80, 60, 70, 60]`, the function should return `[\\"A\\", \\"A\\", \\"C\\", \\"B\\", \\"C\\"]`._","solution":"def assign_grades(nums): This function assigns grades to students based on their scores. if not nums: return [] sorted_scores = sorted(set(nums), reverse=True) grade_mapping = {score: chr(65 + i) for i, score in enumerate(sorted_scores)} return [grade_mapping[score] for score in nums]"},{"question":"Given a list of non-negative integers sorted in an increasing order, and a target value, write a function to find the start and end indices of a target value in the list. If the target is not found in the list, return `[-1, -1]`. You must implement an algorithm with O(log n) runtime complexity.","solution":"def find_start_end_indices(nums, target): Finds the start and end indices of a target value in a sorted list. If the target is not found, returns [-1, -1]. Parameters: nums (List[int]): A list of non-negative integers sorted in increasing order. target (int): The target value to find. Returns: List[int]: A list containing the start and end indices of the target value. def binary_search_left(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def binary_search_right(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right start = binary_search_left(nums, target) end = binary_search_right(nums, target) if start <= end: return [start, end] else: return [-1, -1]"},{"question":"Implement the function `minCostConnectPoints(points)` that takes a list of `n` points `points`[i][0], `points`[i][1] that represents the coordinates of `n` points on a 2D plane. You need to connect all the points, such that the total cost of connecting all the points is minimized. You can only connect two points directly with an edge, and the cost of connecting two points is the Manhattan distance between them. The Manhattan distance between two points (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|. Return the minimum cost to connect all the given points.","solution":"import heapq def minCostConnectPoints(points): n = len(points) # To keep a track of visited points visited = [False] * n # Min heap to get the edge with smallest weight minHeap = [(0, 0)] # (cost, point) result = 0 edges_used = 0 while edges_used < n: cost, i = heapq.heappop(minHeap) if visited[i]: continue visited[i] = True result += cost edges_used += 1 for j in range(n): if not visited[j]: # Calculate the Manhattan distance dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) heapq.heappush(minHeap, (dist, j)) return result"},{"question":"You are given a 2D matrix `grid` of size `m x n` consisting of **non-negative** integers. Each cell in the matrix represents the altitude at that point. Your task is to find the **minimum** altitude path from the top-left corner (0,0) to the bottom-right corner (m-1,n-1). A path is defined as a sequence of adjacent cells (left, right, up, down) that moves from the top-left to the bottom-right corner. The altitude of a path is the **maximum** altitude cell in that path. Return the minimum altitude among all possible paths.","solution":"from heapq import heappop, heappush def minimum_altitude_path(grid): Returns the minimum altitude path from the top-left corner to the bottom-right corner of the grid. m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] pq = [(grid[0][0], 0, 0)] max_altitude = [[float(\'inf\')] * n for _ in range(m)] max_altitude[0][0] = grid[0][0] while pq: cur_max_alt, x, y = heappop(pq) if (x, y) == (m-1, n-1): return cur_max_alt for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: next_max_alt = max(cur_max_alt, grid[nx][ny]) if next_max_alt < max_altitude[nx][ny]: max_altitude[nx][ny] = next_max_alt heappush(pq, (next_max_alt, nx, ny)) return max_altitude[m-1][n-1]"},{"question":"You are given a binary tree with `n` nodes, each uniquely labeled from `1` to `n`. Each node also has a value assigned to it. Write a function to modify the tree such that each node contains the **sum of the values** of its **subtree nodes** including itself. The subtree of a node is defined as that node plus every node that descends from it. Return the root of the modified tree. The input tree is given as a `TreeNode`, where `TreeNode` is a class with properties `val` (integer), `left` (TreeNode or None), and `right` (TreeNode or None).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def modify_tree_to_subtree_sum(root): Modify the tree such that each node contains the sum of the values of its subtree nodes including itself. Args: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the modified binary tree. def subtree_sum(node): if not node: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) node.val += left_sum + right_sum return node.val subtree_sum(root) return root"},{"question":"Given an integer array `nums`, your task is to partition the array into multiple contiguous subarrays such that each subarray contains the same number of distinct integers. Return the minimum number of such subarrays. Note: A contiguous subarray is a continuous segment of the array, and the number of distinct integers in each subarray should be equal.","solution":"def min_subarrays_with_equal_distinct_integers(nums): Finds the minimum number of contiguous subarrays such that each subarray contains the same number of distinct integers. from collections import Counter # finding the total number of distinct integers in the entire array total_distinct = len(set(nums)) # Initialize variables min_subarrays = len(nums) # maximize # of subarrays current_distinct = 0 counter = Counter() left, right = 0, 0 while right < len(nums): if current_distinct < total_distinct: if counter[nums[right]] == 0: current_distinct += 1 counter[nums[right]] += 1 right += 1 while current_distinct == total_distinct: min_subarrays = min(min_subarrays, right - left) counter[nums[left]] -= 1 if counter[nums[left]] == 0: current_distinct -= 1 left += 1 return min_subarrays"},{"question":"You are given an `m x n` 2D grid initialized with these three possible values: - `-1` - A wall or an obstacle. - `0` - A gate. - `INF` (2^31 - 1) - An empty room. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the room filled with `INF`. Note that you can only move up, down, left, or right to each step.","solution":"from collections import deque def walls_and_gates(rooms): if not rooms: return m, n = len(rooms), len(rooms[0]) INF = 2**31 - 1 queue = deque() # Initialize queue with all gates for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j, 0)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Process the queue while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = dist + 1 queue.append((nx, ny, dist + 1))"},{"question":"You are given a binary tree where each node has a `boolean` value, either `true` or `false`. Each path in this tree (from the root to a leaf node) corresponds to a boolean expression formed by **AND**ing the values of the nodes along the path. Return the number of **true** expressions (paths) in the tree.","solution":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def count_true_paths(root): Returns the number of true expressions (paths) in the binary tree. A path is considered true if all nodes along the path have value True. if not root: return 0 if not root.left and not root.right: return 1 if root.value else 0 left_count = count_true_paths(root.left) right_count = count_true_paths(root.right) if root.value: return left_count + right_count else: return 0"},{"question":"Given an integer `n` representing the number of stones and an array `positions` representing the position of each stone on a river, you need to determine if a frog can jump to the last stone. The frog starts at the first stone and is initially able to jump `1` unit. If the frog is at position `x`, it can jump to positions `x + k - 1`, `x + k`, or `x + k + 1` where `k` is the length of the frog\'s last jump. The frog can only make jumps to stones that are in the `positions` array. The input array `positions` is sorted in ascending order. Implement a function that returns `true` if the frog can reach the last stone, and `false` otherwise.","solution":"def can_cross(n, positions): if n == 0 or len(positions) == 0: return False stone_positions = {pos: set() for pos in positions} stone_positions[positions[0]].add(0) for pos in positions: for last_jump in stone_positions[pos]: for jump in [last_jump - 1, last_jump, last_jump + 1]: if jump > 0 and (pos + jump) in stone_positions: stone_positions[pos + jump].add(jump) return len(stone_positions[positions[-1]]) > 0"},{"question":"You are given a list of integers `nums` and an integer `k`. Implement a function `List<List<Integer>> subsetsWithDup(List<Integer> nums, int k)` that returns all possible subsets of `nums` of size `k` such that no subset contains duplicate integers and the subsets are arranged in non-descending order. The solution set must not contain duplicate subsets. For example, given the list `nums = [1, 2, 2]` and `k = 2`, the possible subsets are `[[1, 2], [2, 2]]`. Ensure the subsets are sorted in lexicographical (non-descending) order.","solution":"from typing import List def subsetsWithDup(nums: List[int], k: int) -> List[List[int]]: Given a list of integers `nums` and an integer `k`, returns all unique subsets of `nums` of length `k` such that no subset contains duplicate integers, sorted in non-descending order. def backtrack(start, path): if len(path) == k: result.append(path[:]) return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() result = [] backtrack(0, []) return result"},{"question":"John has collected cards numbered from 1 to `n`. He wants to arrange them in a square grid (i.e., `m x m` where `m` is the integer square root of `n`) such that all numbers from 1 to `n` appear exactly once. Given an integer `n`, return the 2D array representation of the cards arranged in ascending order from top-left to bottom-right. If `n` is not a perfect square, return an empty list. **Function signature:** ```python def arrange_cards(n: int) -> List[List[int]]: ```","solution":"import math from typing import List def arrange_cards(n: int) -> List[List[int]]: Returns a 2D array of cards arranged in ascending order if n is a perfect square. If n is not a perfect square, returns an empty list. sqrt_n = int(math.isqrt(n)) if sqrt_n * sqrt_n != n: return [] grid = [] for i in range(sqrt_n): row = [j for j in range(i * sqrt_n + 1, (i + 1) * sqrt_n + 1)] grid.append(row) return grid"},{"question":"You are given a string `pattern` and a string `str`. The string `pattern` contains only lowercase letters, and the string `str` contains words separated by spaces. Your task is to determine if `str` follows the same pattern as `pattern`, where each word in `str` maps to exactly one character in `pattern` and vice versa. Return _`true` if `str` follows the pattern and `false` otherwise_. For example, given `pattern = \\"abba\\"` and `str = \\"dog cat cat dog\\"`, the output should be `true` because each distinct character in `pattern` maps to a distinct word in `str` and vice versa.","solution":"def word_pattern(pattern, str): pattern_list = list(pattern) words = str.split() if len(pattern_list) != len(words): return False char_to_word = {} word_to_char = {} for c, w in zip(pattern_list, words): if c in char_to_word: if char_to_word[c] != w: return False else: char_to_word[c] = w if w in word_to_char: if word_to_char[w] != c: return False else: word_to_char[w] = c return True"},{"question":"Given an array of integers `arr`, return _the length of the longest subarray with a sum less than or equal to_ `k`. You are allowed to remove at most one element from the subarray to achieve this sum.","solution":"def longest_subarray_with_sum_limit(arr, k): Finds the length of the longest subarray with sum less than or equal to k, where at most one element can be removed. n = len(arr) max_len = 0 # Iterate over each possible subarray for i in range(n): for j in range(i, n): subarray = arr[i:j + 1] subarray_sum = sum(subarray) if subarray_sum <= k: max_len = max(max_len, j - i + 1) else: # Check if removing one element helps for m in range(len(subarray)): temp = subarray[:m] + subarray[m + 1:] if sum(temp) <= k: max_len = max(max_len, len(temp)) return max_len"},{"question":"You are given an integer array `tasks` where `tasks[i]` represents the difficulty level of the `i-th` task, and an integer `w`, which represents the maximum allowed difficulty difference between any two tasks that can be performed consecutively. You are also given a positive integer `n`, representing the number of tasks that can be performed in a day. Determine a way to partition the tasks into the minimum number of days required such that: - Each day you perform exactly `n` tasks, - The difference in difficulty between the easiest and hardest task performed on the same day does not exceed `w`. Return _the minimum number of days needed to complete all the tasks using the conditions described above_.","solution":"def min_days_to_complete_tasks(tasks, w, n): tasks.sort() days = 0 i = 0 while i < len(tasks): days += 1 max_difficulty = tasks[i] + w j = i while j < len(tasks) and tasks[j] <= max_difficulty: j += 1 i = j return max(days, (len(tasks) + n - 1) // n)"},{"question":"You are given a rectangular cake represented by a grid of cells with dimensions `n x m`. Each cell of the grid has a positive integer that represents the height of the cell. You are also given an array `queries` where `queries[k] = [r1, c1, r2, c2]` represents a query to find the minimum height within the rectangular sub-grid that starts at row `r1` and column `c1`, and ends at row `r2` and column `c2`. Return _an integer array_ `answer` _where_ `answer[k]` _is the answer to the_ `kth` _query._","solution":"def minHeightGrid(grid, queries): Returns the minimum height within the rectangular sub-grid for each query. Parameters: grid (List[List[int]]): 2D array representing the grid with heights. queries (List[List[int]]): List of queries where each query is [r1, c1, r2, c2]. Returns: List[int]: Minimum height in the sub-grid for each query. answer = [] for r1, c1, r2, c2 in queries: min_height = float(\'inf\') for i in range(r1, r2+1): for j in range(c1, c2+1): min_height = min(min_height, grid[i][j]) answer.append(min_height) return answer"},{"question":"You are given a string `s` consisting only of lowercase English letters. Your task is to create a function that partitions the string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. Implement the function `partitionLabels(String s): List<Integer>`.","solution":"def partition_labels(s): Partitions the string s into as many parts as possible so that each letter appears in at most one part. Returns a list of integers representing the size of these parts. # Find the last occurrence of each character in the string last_occurrence = {char: idx for idx, char in enumerate(s)} # List to store the sizes partitions = [] # Initialize pointers start, end = 0, 0 for idx, char in enumerate(s): # Update the end pointer to the last occurrence of the character end = max(end, last_occurrence[char]) # If the current index equals the end pointer, we found a partition if idx == end: # Add the partition size to the list partitions.append(end - start + 1) # Move the start pointer to the next index start = idx + 1 return partitions"},{"question":"A **CustomStack** is a data structure that supports the following operations: * `CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack. * `void push(int x)` Adds `x` to the top of the stack if the stack has not reached `maxSize`. * `int pop()` Removes and returns the element on the top of the stack. If the stack is empty, return `-1`. * `void inc(int k, int val)` Increments the bottom `k` elements of the stack by `val`. If there are less than `k` elements in the stack, increment all the elements in the stack. Implement the `CustomStack` class, ensuring it follows the constraints and operations as described.","solution":"class CustomStack: def __init__(self, maxSize): Initializes the object with maxSize which is the maximum number of elements in the stack. self.stack = [] self.maxSize = maxSize def push(self, x): Adds x to the top of the stack if the stack has not reached maxSize. if len(self.stack) < self.maxSize: self.stack.append(x) def pop(self): Removes and returns the element on the top of the stack. If the stack is empty, return -1. if self.stack: return self.stack.pop() else: return -1 def inc(self, k, val): Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack. for i in range(min(k, len(self.stack))): self.stack[i] += val"},{"question":"Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. The trees are given in the form of two root nodes, `p` and `q`. Example: ``` Input: p = [1,2,3], q = [1,2,3] Output: true Input: p = [1,2], q = [1,null,2] Output: false Input: p = [1,2,1], q = [1,1,2] Output: false ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_same_tree(p, q): Checks if two binary trees are the same. Parameters: p (TreeNode): root of the first binary tree q (TreeNode): root of the second binary tree Returns: bool: True if the trees are the same, False otherwise # If both nodes are None, they are the same if not p and not q: return True # If one of the nodes is None, they are not the same if not p or not q: return False # Check if the current nodes values are the same and recursively check left and right subtrees return (p.value == q.value) and is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"},{"question":"You are given a binary tree where each node contains an integer value. Determine if the binary tree is a \\"balanced\\" binary tree. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Return _true_ if the binary tree is balanced, or _false_ otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, balanced = check_balance(root) return balanced"},{"question":"There is a biotechnological lab that keeps records of bacteria samples. Each sample is a string made up of letters `\'A\'`, `\'T\'`, `\'C\'`, and `\'G\'`, each representing different types of bacteria. Given a list of these sample strings, your task is to find the longest common prefix among all sample strings in the list. If there is no common prefix, return an empty string. Write a function that takes in a list of strings and returns the longest common prefix shared by these strings.","solution":"def longest_common_prefix(samples): Returns the longest common prefix among a list of bacteria samples. Args: samples: List of bacteria sample strings Returns: The longest common prefix string. If no common prefix, returns an empty string. if not samples: return \\"\\" # Sort the list, the common prefix of the whole list would also be a common prefix of the first and last string samples.sort() first = samples[0] last = samples[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"You are given an array `heights` representing the heights of a group of people standing in a line. A new line is formed by sorting these people in non-decreasing order of their heights. Your task is to determine the minimum number of people who are not standing in their correct positions relative to their heights in the newly formed line. Return _the minimum number of people standing in incorrect positions_. For example, given `heights = [1,1,4,2,1,3]`, the correct order is `[1,1,1,2,3,4]`, and the number of people who are not standing in their correct positions is 3.","solution":"def height_checker(heights): Returns the minimum number of people standing in incorrect positions. :param heights: List of integers representing the heights of people. :return: Integer representing the number of people not in the correct positions. expected = sorted(heights) return sum(h1 != h2 for h1, h2 in zip(heights, expected))"},{"question":"Given a list of `n` integers representing the heights of people in a row, arrange them in a way such that each person has at least one neighbour who is either of equal height or taller. If multiple such arrangements are possible, return any of them. If no such arrangement exists, return an empty list. Write a function: ```python def arrange_heights(heights: List[int]) -> List[int]: pass ```","solution":"from typing import List def arrange_heights(heights: List[int]) -> List[int]: Arrange the heights such that each person has at least one neighbor who is either of equal height or taller. if not heights: return [] # Sort the heights list heights.sort() # For a valid arrangement, the smallest value must be at the ends. # Therefore, we can simply return the sorted list. return heights"},{"question":"Given an array of integers `arr` and an integer `k`, implement a function to return the top `k` frequent elements. The frequency of elements is determined by how many times they appear in the array. If there are multiple answers, return any valid result. For example, if `arr = [1,1,1,2,2,3]` and `k = 2`, the result could be `[1, 2]` or `[2, 1]`.","solution":"from collections import Counter import heapq def top_k_frequent_elements(arr, k): Returns the top k frequent elements in the array. :param arr: List of integers :param k: Integer, number of top frequent elements to return :return: List of integers, top k frequent elements if not arr or k <= 0: return [] # Count the frequency of each element count = Counter(arr) # Use a heap to get the top k elements return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of sparks at different positions, find the **maximum** width of the spark that can be caught by the firefighter. You are given an integer `waterLevel` representing the maximum height up to which the firefighter can catch the sparks. The firefighter can catch the sparks if their height is less than or equal to the `waterLevel`. Return _the **maximum** width of the contiguous subarray of `heights` where each element is less than or equal to_ `waterLevel`.","solution":"def max_width_spark(heights, waterLevel): Returns the maximum width of the contiguous subarray where each element is less than or equal to waterLevel. :param heights: List[int] - List of heights of the sparks :param waterLevel: int - The maximum height up to which the firefighter can catch the sparks :return: int - The maximum width of the contiguous subarray max_width = 0 current_width = 0 for height in heights: if height <= waterLevel: current_width += 1 max_width = max(max_width, current_width) else: current_width = 0 return max_width"},{"question":"You are given two integers `x` and `y`, and a list of `points` where each point is represented as a list of two integers `[xi, yi]` denoting its coordinates. A point is said to be a **valid** point if it shares the same x-coordinate or the same y-coordinate as the given point `(x, y)`. Return the index of the **valid** point with the smallest Euclidean distance to `(x, y)`. If there are multiple points with the same distance, return the index of the one that appears first in the list. If there are no valid points, return `-1`.","solution":"def nearestValidPoint(x, y, points): Returns the index of the valid point with the smallest Euclidean distance to (x, y). If there are multiple points with the same distance, returns the index of the first one. If there are no valid points, returns -1. min_distance = float(\'inf\') min_index = -1 for i, (xi, yi) in enumerate(points): if xi == x or yi == y: distance = abs(x - xi) + abs(y - yi) if distance < min_distance: min_distance = distance min_index = i return min_index"},{"question":"You are given an array of integers `arr` representing the heights of plants in a straight line. Each plant either grows taller or stays the same height every day. On each day, a plant will grow to be as tall as the tallest plant to its left. Your task is to calculate the minimum number of days required for all plants to become the same height, given that some plants may already be taller or equal to the maximum height to their left. Return _an integer_ that represents the minimum number of days needed for all plants to become the same height.","solution":"def min_days_to_equal_height(arr): Returns the minimum number of days required for all plants to become the same height. Parameters: arr (list): List of integers representing the heights of the plants. Returns: int: Minimum number of days required for all plants to become the same height. days = 0 max_height_so_far = arr[0] for height in arr: if height > max_height_so_far: max_height_so_far = height days += 1 return days"},{"question":"You are given an integer array `nums` and a positive integer `x`. In one operation, you can remove any element from `nums` and decrease the value of `x` by the value of the removed element. The goal is to reduce `x` to exactly `0`. Return the _minimum number of operations needed to achieve this_. If it is not possible to reduce `x` to `0`, return `-1`.","solution":"def min_operations(nums, x): This function returns the minimum number of operations needed to reduce x to exactly 0 by removing any element from nums and decreasing x by the value of the removed element. If it is not possible to reduce x to 0, it returns -1. target = sum(nums) - x if target < 0: return -1 if target == 0: return len(nums) max_length = -1 current_sum = 0 left = 0 for right in range(len(nums)): current_sum += nums[right] while current_sum > target and left <= right: current_sum -= nums[left] left += 1 if current_sum == target: max_length = max(max_length, right - left + 1) return len(nums) - max_length if max_length != -1 else -1"},{"question":"You are given an integer array `nums` and an integer `target`. You need to determine if there are four distinct elements in `nums` such that their sum is equal to `target`. Return `true` if such a quadruplet exists, and `false` otherwise.","solution":"def four_sum(nums, target): Determines if there are four distinct elements in nums such that their sum is equal to target. Arguments: nums -- list of integers target -- integer target sum Returns: bool -- True if such a quadruplet exists, False otherwise nums.sort() n = len(nums) for i in range(n - 3): for j in range(i + 1, n - 2): left, right = j + 1, n - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. You can remove any number of characters from `s` to create a new string. Return _the length of the longest substring that can be obtained which contains no more than two distinct alternating characters._","solution":"def longest_alternating_substring(s): Returns the length of the longest substring with no more than two distinct alternating characters (\'a\' and \'b\'). max_len = 0 current_len = 0 last_char = None for char in s: if char == last_char: current_len += 1 else: current_len = 1 last_char = char max_len = max(max_len, current_len) return max_len"},{"question":"Given a `2D` integer array representing the initial state of a **game of life** grid of size `m x n`, where each cell is either `0` (dead) or `1` (alive), implement the next generation of the grid using the following rules: 1. Any live cell with fewer than two live neighbors dies, as if caused by under-population. 2. Any live cell with two or three live neighbors lives on to the next generation. 3. Any live cell with more than three live neighbors dies, as if by over-population. 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Return the grid after calculating the next generation.","solution":"def game_of_life(board): Given a 2D integer array representing the initial state of a game of life grid, this function calculates and returns the next generation of the grid. :param board: List[List[int]] representing the initial state of the grid :return: List[List[int]] representing the next state of the grid def count_neighbors(board, row, col): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < len(board) and 0 <= c < len(board[0]): count += board[r][c] return count rows, cols = len(board), len(board[0]) next_state = [[0] * cols for _ in range(rows)] for row in range(rows): for col in range(cols): live_neighbors = count_neighbors(board, row, col) if board[row][col] == 1: # Live cell if live_neighbors < 2 or live_neighbors > 3: next_state[row][col] = 0 # Dies else: next_state[row][col] = 1 # Lives else: # Dead cell if live_neighbors == 3: next_state[row][col] = 1 # Becomes live return next_state"},{"question":"Given a string `s` consisting of lowercase letters, return _the length of the most commonly occurring contiguous substring_. In other words, find the maximum length of any contiguous substring where all characters are the same. If there are multiple such substrings with the same maximum length, return the length of any of them.","solution":"def max_contiguous_substring_length(s): Returns the length of the most commonly occurring contiguous substring where all characters are the same. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length)"},{"question":"You are given a rectangle grid of size `n x m` represented as a 2D integer array `grid`. Each cell in the grid contains either a 0 or a 1. A group of adjacent cells containing 1s (horizontally or vertically) forms an island. You need to find the size of the largest island (i.e., the maximum number of 1s connected) in the grid. Implement the `GridAnalyzer` class: * `GridAnalyzer(int[][] grid)` Initializes the `GridAnalyzer` object with the given grid. * `int largestIslandSize()` Returns the size of the largest island in the grid.","solution":"class GridAnalyzer: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if grid else 0 def largestIslandSize(self): def dfs(x, y): if x < 0 or x >= self.rows or y < 0 or y >= self.cols or self.grid[x][y] == 0: return 0 self.grid[x][y] = 0 # mark as visited size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(self.rows): for j in range(self.cols): if self.grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"Given a list of `n` integers where each integer represents the number of votes a candidate received, determine if a candidate has received more than half of the total votes. Return the candidate id if there is one who received more than half of the votes, otherwise return `-1`. The candidate ids are numbered from `0` to `n-1`. Implement a function: ```python def findMajorityCandidate(votes: List[int]) -> int: # Your implementation here ``` Constraints: - The list `votes` will have at least `1` and at most `10^5` elements. - Each vote count will be a non-negative integer.","solution":"from typing import List def findMajorityCandidate(votes: List[int]) -> int: Returns the candidate id if there is one who received more than half of the votes, otherwise returns -1. total_votes = sum(votes) half_votes = total_votes // 2 for candidate_id, vote_count in enumerate(votes): if vote_count > half_votes: return candidate_id return -1"},{"question":"You are given a **0-indexed** integer array `score` where `score[i]` represents the score of the `ith` player in a game. Return _the number of players who have a score that is strictly greater than the **average score** of all the players in the array_. The average score is defined as the total sum of all the scores divided by the number of players.","solution":"def count_above_average(score): Returns the number of players who have a score that is strictly greater than the average score. average_score = sum(score) / len(score) count = sum(1 for s in score if s > average_score) return count"},{"question":"You are given an array of integers `arr` and an integer `m`. Your task is to determine if you can split the array into two non-empty subarrays such that the sum of the elements in each subarray is divisible by `m`. Return `true` if such a split is possible, and `false` otherwise. For example, given the array `arr = [3, 6, 5, 1, 8]` and `m = 5`, you can split the array into `[3, 6, 5]` and `[1, 8]` because both `14 % 5 == 4` and `9 % 5 == 4` are not zero. Another example is `arr = [1, 2, 3, 4]` and `m = 2`, where a valid split would be `[1, 2, 3]` and `[4]` because `6 % 2 == 0` and `4 % 2 == 0`. Thus you should return `true`. Your task is to implement the function `isSplittable(arr, m)` which returns a boolean value based on the criteria described above.","solution":"def isSplittable(arr, m): Determines if an array can be split into two non-empty subarrays such that the sum of the elements in each subarray is divisible by m. :param arr: List[int] - The input array of integers :param m: int - The divisor :return: bool - True if the array can be split as described, False otherwise for i in range(1, len(arr)): left_sum = sum(arr[:i]) right_sum = sum(arr[i:]) if left_sum % m == 0 and right_sum % m == 0: return True return False"},{"question":"Given a 2D grid `board` representing a game of life, return the next state of the board according to the following rules: 1. Any live cell with fewer than two live neighbors dies, as if caused by under-population. 2. Any live cell with two or three live neighbors lives on to the next generation. 3. Any live cell with more than three live neighbors dies, as if by over-population. 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. The input is a `m x n` 2D array representing the board. Expect to return a `m x n` 2D array representing the next state. Your function should return the new state of the `board`.","solution":"def game_of_life(board): Update the \'board\' to the next state according to the rules of the Game of Life. rows, cols = len(board), len(board[0]) next_state = [[0] * cols for _ in range(rows)] def count_live_neighbors(r, c): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] == 1: live_neighbors += 1 return live_neighbors for r in range(rows): for c in range(cols): live_neighbors = count_live_neighbors(r, c) if board[r][c] == 1 and (live_neighbors < 2 or live_neighbors > 3): next_state[r][c] = 0 elif board[r][c] == 1 and (live_neighbors == 2 or live_neighbors == 3): next_state[r][c] = 1 elif board[r][c] == 0 and live_neighbors == 3: next_state[r][c] = 1 return next_state"},{"question":"Given a string `s` containing only lowercase letters, you need to find and return all possible **palindrome partitions** of `s`. A palindrome partitioning of a string is a decomposition of the string into substrings such that each substring is a palindrome. Each substring must be a contiguous block of characters from the original string. The function should return the partitions in any order, as long as it returns all unique partitions.","solution":"def is_palindrome(s): Determines if a given string s is a palindrome. return s == s[::-1] def backtrack(start, s, path, result): Uses backtracking to find all palindrome partitions from the start index. if start == len(s): result.append(path[:]) return for end in range(start + 1, len(s) + 1): substring = s[start:end] if is_palindrome(substring): path.append(substring) backtrack(end, s, path, result) path.pop() def palindrome_partitions(s): Returns all possible palindrome partitions of the input string s. result = [] backtrack(0, s, [], result) return result"},{"question":"You are given a list of strings `words` containing lowercase English letters. A word is called **universal** if all the letters in a given string `chars` appear in it at least as many times as they appear in `chars`. Return _a list of all **universal** words in_ `words`. The output list should be sorted in lexicographical order.","solution":"from collections import Counter def is_universal_word(word, chars_count): word_count = Counter(word) for char, count in chars_count.items(): if word_count[char] < count: return False return True def universal_words(words, chars): chars_count = Counter(chars) universal_list = [word for word in words if is_universal_word(word, chars_count)] return sorted(universal_list)"},{"question":"Implement a function `longestSubarray(nums, limit)` that returns the length of the longest continuous subarray such that the absolute difference between any two elements in this subarray is less than or equal to `limit`. The function takes an integer array `nums` and an integer `limit` as input. The array `nums` contains at least one element. The subarray is continuous, meaning elements are taken in order they appear in `nums`.","solution":"from collections import deque def longestSubarray(nums, limit): Returns the length of the longest continuous subarray such that the absolute difference between any two elements in this subarray is less than or equal to limit. max_d = deque() # Deque to store the max elements min_d = deque() # Deque to store the min elements left = 0 max_len = 0 for right in range(len(nums)): # Maintain the decreasing order in max_d while max_d and nums[right] > max_d[-1]: max_d.pop() max_d.append(nums[right]) # Maintain the increasing order in min_d while min_d and nums[right] < min_d[-1]: min_d.pop() min_d.append(nums[right]) # While the absolute difference is greater than the limit while max_d[0] - min_d[0] > limit: if nums[left] == max_d[0]: max_d.popleft() if nums[left] == min_d[0]: min_d.popleft() left += 1 # Update the maximum length max_len = max(max_len, right - left + 1) return max_len"},{"question":"**Given a matrix `grid` of size `m x n` consisting of only non-negative integers, you are allowed to choose any single cell and start a traversal. From each cell `(i, j)`, you can move to an adjacent cell `(i-1, j)`, `(i+1, j)`, `(i, j-1)`, or `(i, j+1)` as long as the adjacent cell\'s value is greater than the current cell\'s value. Determine the length of the longest increasing path in the matrix.**","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 def dfs(i, j): if dp[i][j]: return dp[i][j] value = matrix[i][j] dp[i][j] = 1 + max( dfs(i-1, j) if i > 0 and matrix[i-1][j] > value else 0, dfs(i+1, j) if i < len(matrix) - 1 and matrix[i+1][j] > value else 0, dfs(i, j-1) if j > 0 and matrix[i][j-1] > value else 0, dfs(i, j+1) if j < len(matrix[0]) - 1 and matrix[i][j+1] > value else 0 ) return dp[i][j] dp = [[0] * len(matrix[0]) for _ in range(len(matrix))] return max(dfs(i, j) for i in range(len(matrix)) for j in range(len(matrix[0])))"},{"question":"A company wants to host a team-building event and needs to divide its employees into two non-empty teams. Given an integer array `skills` where `skills[i]` is the skill level of the i-th employee, divide the array into two teams such that the difference between the sum of skill levels of both teams is minimized. Return the minimum possible absolute difference between the sum of skill levels of the two teams. Write a function `minimumDifference(skills: List[int]) -> int` that takes an array of integers `skills` and returns an integer representing the minimum possible difference between the sum of skill levels of the two teams.","solution":"from typing import List def minimumDifference(skills: List[int]) -> int: Returns the minimum possible absolute difference between the sum of skill levels of the two teams created from the skill levels array. total_sum = sum(skills) n = len(skills) dp = [0] * (total_sum // 2 + 1) for skill in skills: for j in range(total_sum // 2, skill - 1, -1): dp[j] = max(dp[j], dp[j - skill] + skill) return total_sum - 2 * dp[total_sum // 2]"},{"question":"You are tasked with organizing a conference and need to assign rooms to a list of attendees. Given an array of integers `arr` where `arr[i]` represents the number of attendees needing a room in the `i-th` hour, and an integer `k` representing the capacity of each room, return the minimum number of rooms required to accommodate all attendees each hour. Note that attendees only stay for the hour they arrive and do not overlap into other hours.","solution":"def min_rooms_required(arr, k): Given an array of integers arr where arr[i] represents the number of attendees needing a room in the ith hour, and an integer k representing the capacity of each room, return the minimum number of rooms required to accommodate all attendees each hour. :param arr: List[int] - list of integers representing the number of attendees per hour :param k: int - the capacity of each room :return: int - minimum number of rooms required if k == 0: raise ValueError(\\"Room capacity must be greater than 0\\") # Calculate the number of rooms needed for each hour and take the maximum return max((attendees + k - 1) // k for attendees in arr)"},{"question":"Given an array of integers `arr`, you are allowed to perform exactly one operation where you can choose any element and change its value to any integer. Determine if it is possible to make `arr` strictly increasing with this single modification. Return `true` if it is possible, otherwise return `false`.","solution":"def canBeIncreasing(arr): Determine if it is possible to make the array strictly increasing by changing at most one element. def isStrictlyIncreasing(after_removal): for i in range(1, len(after_removal)): if after_removal[i] <= after_removal[i - 1]: return False return True # Check the array by trying to remove each element once (simulating the modification). for i in range(len(arr)): if isStrictlyIncreasing(arr[:i] + arr[i + 1:]): return True return False"},{"question":"Write a function that determines whether a string contains valid parentheses. A string containing just the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'` is considered valid if the parentheses are closed in the correct order. For example, `\\"()\\"`, `\\"()[]{}\\"`, and `\\"{[]}\\"` are all valid but `\\"(]\\"`, `\\"([)]\\"`, and `\\"{[}\\"` are not. Your function should take a single input string and return a boolean indicating whether it is valid or not. The function should aim for `O(n)` time complexity, where `n` is the length of the input string.","solution":"def is_valid_parentheses(s): Returns True if the input string s contains valid parentheses, otherwise False. stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_parentheses: top_element = stack.pop() if stack else \'#\' if matching_parentheses[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given a binary tree with `n` nodes. Each node has a unique value in the range `[1, n]`. You need to perform the following operations on the tree: 1. Query the number of nodes in the subtree rooted at a given node. 2. Compute the depth of a given node in the tree. Implement a function that accepts the tree structure and processes multiple queries of the two operations mentioned above. Return a list of results for each query in the order they are presented.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_subtree_nodes(root): if not root: return 0 return 1 + count_subtree_nodes(root.left) + count_subtree_nodes(root.right) def find_node(root, val, depth=0): if not root: return None, 0 if root.val == val: return root, depth left_result = find_node(root.left, val, depth + 1) if left_result[0]: return left_result return find_node(root.right, val, depth + 1) def process_queries(root, queries): results = [] for query in queries: query_type, node_val = query if query_type == 1: node, _ = find_node(root, node_val) if node: results.append(count_subtree_nodes(node)) else: results.append(0) elif query_type == 2: _, depth = find_node(root, node_val) results.append(depth) return results"},{"question":"You are given two strings, `s` and `t`. The string `t` is a scrambled version of string `s` if it can be derived by recursively swapping any non-empty substring of `s`. Determine if `t` is a scrambled version of `s`. For instance, `great` can be transformed into `rgeat` by swapping the two substrings `gr` and `eat`, and further swapping `g` and `r` in the substring `gr`. Return `true` if `t` is a scrambled version of `s`, and `false` otherwise.","solution":"def isScramble(s, t): Determines if string t is a scrambled version of string s. if len(s) != len(t): return False if s == t: return True n = len(s) # dp[i][j][len] will be True if s[i:i+len] is a scrambled string of t[j:j+len] dp = [[[False] * (n + 1) for _ in range(n)] for _ in range(n)] # Initialize when substrings are of length 1 for i in range(n): for j in range(n): dp[i][j][1] = s[i] == t[j] # Build the solution for substrings of length > 1 for length in range(2, n + 1): for i in range(n - length + 1): for j in range(n - length + 1): for k in range(1, length): # split the substring into two parts if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]): dp[i][j][length] = True break return dp[0][0][n]"},{"question":"Given a matrix `mat` where each element in the matrix represents the height of a tower, find the maximum height difference you can obtain between two different towers in the same column. The height difference between two different towers is defined as the absolute difference between their heights. You need to return a list of integers `max_diff` where `max_diff[i]` is the maximum height difference in the `i`th column of the matrix. If a column contains fewer than two towers, the maximum height difference for that column should be considered as 0.","solution":"def max_height_difference(mat): Given a matrix mat where each element represents the height of a tower, returns a list of integers max_diff where max_diff[i] is the maximum height difference in the i-th column of the matrix. if not mat or not mat[0]: return [] num_columns = len(mat[0]) max_diff = [0] * num_columns for col in range(num_columns): column_values = [mat[row][col] for row in range(len(mat)) if mat[row][col] is not None] if len(column_values) < 2: max_diff[col] = 0 else: max_diff[col] = max(column_values) - min(column_values) return max_diff"},{"question":"Given a string `s`, split it into the minimum number of substrings such that each substring contains only one distinct character. Return _the minimum number of substrings needed_.","solution":"def min_substrings_with_one_distinct_char(s): Splits the string into the minimum number of substrings such that each substring contains only one distinct character. Parameters: s (str): The input string. Returns: int: The minimum number of substrings needed. if not s: return 0 count = 1 current_char = s[0] for char in s[1:]: if char != current_char: count += 1 current_char = char return count"},{"question":"You are given an integer array `arr` of length `n` where `n` is even. We want to create a new array of length `n/2` by pairing consecutive elements of `arr` and taking the sum of each pair. More specifically, the first element of the new array should be the sum of the first two elements of `arr`, the second element should be the sum of the third and fourth elements of `arr`, and so on. Write a function that takes in the array `arr` and returns the new array formed by the sum of consecutive pairs. If `arr` has an odd length, return an empty array.","solution":"def sum_consecutive_pairs(arr): Returns a new array consisting of sums of consecutive pairs of elements in the input array `arr`. If the length of `arr` is odd, returns an empty array. n = len(arr) if n % 2 != 0: return [] result = [] for i in range(0, n, 2): result.append(arr[i] + arr[i + 1]) return result"},{"question":"You are given a list of `n` files where each file is represented by its path as a string in a list called `files`. Each file contains a string of lowercase alphabets. Two files are said to be **similar** if they have at least one common subsequence of length `k` (where `k` is a given positive integer). Your task is to find out the number of **connected groups** of similar files. Suppose two files are similar, and one of these files is similar to a third file, then all three files are considered members of the same connected group. Return the number of such connected groups.","solution":"from collections import defaultdict import itertools def find_common_subsequences(s1, s2, length): Returns True if there is at least one common subsequence of given length `length` between strings `s1` and `s2`. s1_subsequences = {s1[i:i+length] for i in range(len(s1) - length + 1)} s2_subsequences = {s2[i:i+length] for i in range(len(s2) - length + 1)} return not s1_subsequences.isdisjoint(s2_subsequences) def find_group_count(files, k): Returns the number of connected groups of files based on similarity defined by common subsequence of length `k`. n = len(files) if n == 0: return 0 adj_list = defaultdict(list) for i, j in itertools.combinations(range(n), 2): if find_common_subsequences(files[i], files[j], k): adj_list[i].append(j) adj_list[j].append(i) visited = [False] * n def dfs(file_index): stack = [file_index] while stack: node = stack.pop() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) group_count = 0 for i in range(n): if not visited[i]: group_count += 1 visited[i] = True dfs(i) return group_count"},{"question":"Design an algorithm to convert a sorted array into a height-balanced binary search tree (BST). A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Implement the `SortedArrayToBST` class: * `TreeNode sortedArrayToBST(int[] nums)` - Given a sorted array `nums`, convert it into a height-balanced BST and return the root of that tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class SortedArrayToBST: def sortedArrayToBST(self, nums): Converts a sorted array into a height-balanced binary search tree (BST). :param nums: List[int], a sorted array :return: TreeNode, the root of the height-balanced BST if not nums: return None def convertListToBST(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = convertListToBST(left, mid - 1) node.right = convertListToBST(mid + 1, right) return node return convertListToBST(0, len(nums) - 1)"},{"question":"Given an integer array `nums` and an integer `x`, return `true` if `nums` has a pair of integers that sums up to `x`. The function should have an average time complexity of O(n).","solution":"def has_pair_with_sum(nums, x): Returns `True` if there are two distinct numbers in nums that sum up to x, otherwise `False`. The function uses a set to track the complement of each number. :param nums: List of integers :param x: Integer sum to find :return: Boolean indicating if a pair with sum x exists seen = set() for num in nums: if x - num in seen: return True seen.add(num) return False"},{"question":"You are given an integer array `arr` of size `n`. You need to perform the following operation repeatedly until you cannot: choose any two indices `i` and `j` (1 <= i != j <= n) and decrease `arr[i]` by `arr[j]`. Return _the minimized value that can be obtained in the array after performing the operation optimally_. For example, given the array `[4, 7, 10, 12]`, the optimal sequence of operations would be: 1. Choose indices `1` and `2` (4 -> 0) 2. Choose indices `3` and `4` (10 -> 2) 3. Choose indices `2` and `4` (7 -> 5) 4. Continuing this process until no further operations can reduce the array further. The minimized value will then be `1`.","solution":"def minimize_array(arr): Returns the minimized value that can be obtained in the array after performing the operations. def gcd(x, y): while y: x, y = y, x % y return x from functools import reduce return reduce(gcd, arr)"},{"question":"You are given an array `heights` representing the heights of buildings along a straight road where the `i-th` building has a height `heights[i]`. The city has decided to install a new series of solar panels on the roofs of these buildings. However, the efficiency of each panel is dependent on the amount of sunlight it receives. A building will block the sunlight to all buildings to its right that are shorter in height. Return _an array_ `result` _where_ `result[i]` _is the index of the nearest building to the right that is taller than_ `heights[i]`, _or_ `-1` _if there is no such building_.","solution":"def nearest_taller_building(heights): Given an array heights, return an array result where result[i] is the index of the nearest building to the right that is taller than heights[i], or -1 if there is no such building. n = len(heights) result = [-1] * n stack = [] for i in range(n): while stack and heights[i] > heights[stack[-1]]: index = stack.pop() result[index] = i stack.append(i) return result"},{"question":"A company has a number of employees represented by an integer array `importance` where `importance[i]` is the importance value of the i-th employee. Each employee has **at most one** direct manager represented by an integer array `manager` where `manager[i]` is the direct manager of the i-th employee (employee `i` has no direct manager if `manager[i] == -1`). An employee with importance value `x` also adds to the total importance of their direct manager\'s importance. If a manager has no direct reports, their final importance remains unchanged. Write a function `calculateImportance` that takes the two arrays `importance` and `manager` and returns a new array such that `result[i]` represents the total importance of the i-th employee after including the importance of all their direct reports recursively.","solution":"def calculateImportance(importance, manager): Calculates the total importance for each employee by including the importance of all their direct reports. :param importance: List[int] - Importance values of employees. :param manager: List[int] - Direct manager of each employee. :return: List[int] - Total importance values after including the importance of direct reports. from collections import defaultdict, deque # Create a dictionary to hold each employee and their direct reports reports = defaultdict(list) for i, m in enumerate(manager): if m != -1: reports[m].append(i) # Function to recursively calculate the total importance def dfs(employee): total_importance = importance[employee] for report in reports[employee]: total_importance += dfs(report) return total_importance # Calculate total importance for each employee result = [dfs(i) for i in range(len(importance))] return result"},{"question":"You are given an integer array `tasks` of length `n` where `tasks[i]` represents the duration of the `i-th` task. You are also given an integer `sessionTime` which represents the maximum duration of a single working session. You need to allocate the tasks to multiple working sessions such that the sum of task durations in each session does not exceed `sessionTime`, and the number of sessions used is minimized. Return _the minimum number of working sessions required to complete all the tasks_.","solution":"def min_sessions(tasks, sessionTime): Returns the minimum number of sessions required to complete all tasks n = len(tasks) max_mask = 1 << n dp = [float(\'inf\')] * max_mask dp[0] = 0 for mask in range(max_mask): current_sum = 0 for i in range(n): if mask & (1 << i): current_sum += tasks[i] for j in range(n): if not (mask & (1 << j)): new_mask = mask | (1 << j) if current_sum % sessionTime + tasks[j] <= sessionTime: dp[new_mask] = min(dp[new_mask], dp[mask] + (1 if current_sum % sessionTime == 0 else 0)) else: dp[new_mask] = min(dp[new_mask], dp[mask] + 1) return dp[max_mask - 1]"},{"question":"You are implementing a text editor that supports the following two operations: * `void addText(string text)`: Adds the given `text` to the end of the current document. * `string deleteText(int k)`: Deletes the last `k` characters from the current document and returns the deleted string. * `string getText()`: Returns the current document as a string. Write a class `TextEditor` to implement the text editor.","solution":"class TextEditor: def __init__(self): self.document = \\"\\" def addText(self, text: str) -> None: self.document += text def deleteText(self, k: int) -> str: deleted_text = self.document[-k:] self.document = self.document[:-k] return deleted_text def getText(self) -> str: return self.document"},{"question":"Given a list of words, each word consisting of lowercase English letters, return the length of the **longest possible chain** of words. A word `w1` can be followed by another word `w2` in the chain if and only if adding exactly one letter to `w1` in one of the positions makes it equal to `w2`. For example, given the words `[\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]`, one of the longest chains can be `[\\"a\\", \\"ba\\", \\"bda\\", \\"bdca\\"]`. Return _an integer representing the length of the longest possible chain of words._","solution":"def longestStrChain(words): Returns the length of the longest possible chain of words. A word w1 can be followed by another word w2 in the chain if adding exactly one letter to w1 in one of the positions makes it equal to w2. words.sort(key=len) longest_chain = {} max_length = 0 for word in words: current_length = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in longest_chain: current_length = max(current_length, longest_chain[predecessor] + 1) longest_chain[word] = current_length max_length = max(max_length, current_length) return max_length"},{"question":"You are given a string `tasks` consisting of lowercase English letters where each letter represents a different type of task. Each task can be completed in one unit of time. You are also given an integer `n` that represents the cooldown period between two same tasks. You need to determine the **minimum time** required to complete all tasks. The cooldown period means that there must be at least `n` units of time between two executions of the same task. Return the minimum time needed to finish all the tasks while adhering to the cooldown requirement.","solution":"def leastInterval(tasks, n): Returns the minimum time required to complete all tasks with the given cooldown period. :param tasks: List of characters representing tasks. :param n: Integer representing the cooldown period. :return: Integer representing the minimum time to complete all tasks. from collections import Counter task_counts = Counter(tasks) max_freq = max(task_counts.values()) max_freq_tasks = list(task_counts.values()).count(max_freq) part_count = max_freq - 1 empty_slots = part_count * (n - (max_freq_tasks - 1)) available_tasks = len(tasks) - max_freq * max_freq_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"You are given a string `num` representing a **non-negative integer** and a positive integer `k`. You are allowed to remove up to `k` digits from `num` to form a new number, which should be the **smallest possible**. Return _the smallest number_ that can be formed by removing up to `k` digits.","solution":"def removeKdigits(num, k): Given a string representing a non-negative integer num and an integer k, this function removes k digits from num to produce the smallest possible number. stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still k digits to remove, remove from the end stack = stack[:-k] if k else stack # Convert the list to a string and strip leading zeros return \'\'.join(stack).lstrip(\'0\') or \\"0\\""},{"question":"You are given a matrix of integers `mat` where every row is sorted in non-decreasing order. Write a program to find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element.","solution":"import heapq def kthSmallest(matrix, k): Returns the kth smallest element in a sorted matrix. # Extract the dimension of the matrix n = len(matrix) # Min-heap to store the values min_heap = [] # Initialize the heap with the first element of each row for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k-1 times while k > 1: val, r, c = heapq.heappop(min_heap) if c < n - 1: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1)) k -= 1 # The smallest item now at heap top return heapq.heappop(min_heap)[0]"},{"question":"Given a string `s` containing only characters `\'a\'` and `\'b\'`, return the minimum number of operations required to make the string alternating, starting with either `\'a\'` or `\'b\'`. An **alternating** string is defined as a string with no two adjacent characters being the same. In one operation, you can change a character from `\'a\'` to `\'b\'` or vice versa.","solution":"def min_operations_to_alternate(s): Returns the minimum number of operations required to make the string \'s\' alternately starting with either \'a\' or \'b\'. # Check two patterns: starting with \'a\' and starting with \'b\' def count_operations(starting_char): count = 0 expected_char = starting_char for char in s: if char != expected_char: count += 1 expected_char = \'a\' if expected_char == \'b\' else \'b\' return count return min(count_operations(\'a\'), count_operations(\'b\'))"},{"question":"Given a list of non-negative integers `nums`, where each integer represents the number of stones in a pile, you can take any number of stones from a single pile (but at least one). Calculate the `nim-sum` (xor of all the stones) and determine if the first player can force a win with optimal play. Return `true` if the first player can guarantee a win; otherwise, return `false`.","solution":"def can_first_player_win(nums): Determines if the first player can force a win in the game. :param nums: List of non-negative integers representing piles of stones. :return: Boolean indicating whether the first player can guarantee a win or not. nim_sum = 0 for num in nums: nim_sum ^= num return nim_sum != 0"},{"question":"You are given an integer array `nums` and an integer `target`. Find the number of different pairs `(i, j)` where `i < j` such that `nums[i] + nums[j] == target`. Return the number of pairs that satisfy this condition. The solution should have a time complexity of O(n).","solution":"def count_pairs(nums, target): Returns the number of different pairs (i, j) where i < j such that nums[i] + nums[j] equals target. # Dictionary to store the number of occurrences of each number in nums counts = {} # To keep track of the number of valid pairs pair_count = 0 for num in nums: # Find the complement number needed to reach the target complement = target - num # If the complement is in the dictionary, it means we can form a pair. if complement in counts: pair_count += counts[complement] # Update the counts dictionary if num in counts: counts[num] += 1 else: counts[num] = 1 return pair_count"},{"question":"A logistics company is planning to build a network of delivery routes. The company has `n` delivery points, and each delivery point is connected to one or more other delivery points via a road. Each road has an associated travel time. You are given an integer `n`, an array `times` where `times[i] = [u, v, t]` represents a road between delivery points `u` and `v` with travel time `t`, and an integer `hq` representing the headquarters delivery point. Your task is to find the shortest travel time from the headquarters to all other delivery points. Return an array where the `i-th` element represents the shortest travel time from the headquarters to delivery point `i`. If a delivery point is not reachable from the headquarters, include `-1` for that delivery point.","solution":"import heapq def shortest_travel_time(n, times, hq): Find the shortest travel time from the headquarters to all other delivery points. :param n: int - number of delivery points :param times: List[List[int]] - list of edges with travel times :param hq: int - headquarters delivery point :return: List[int] - shortest travel times from headquarters to each delivery point graph = {i: [] for i in range(n)} for u, v, t in times: graph[u].append((v, t)) graph[v].append((u, t)) # Assuming the roads are bidirectional # Dijkstra\'s algorithm to find shortest paths min_heap = [(0, hq)] visited = set() shortest_times = [float(\'inf\')] * n shortest_times[hq] = 0 while min_heap: curr_time, u = heapq.heappop(min_heap) if u in visited: continue visited.add(u) for v, t in graph[u]: if v not in visited: new_time = curr_time + t if new_time < shortest_times[v]: shortest_times[v] = new_time heapq.heappush(min_heap, (new_time, v)) return [time if time != float(\'inf\') else -1 for time in shortest_times]"},{"question":"Given an array of non-negative integers `arr`, you are tasked with finding the maximum sum you can obtain by picking non-adjacent elements from the array. Return this maximum sum. Note that two elements are considered adjacent if they are next to each other in the array.","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent elements in the array. if not arr: return 0 elif len(arr) == 1: return arr[0] # Initialize include and exclude include = 0 exclude = 0 for num in arr: # Current max excluding the current element new_exclude = max(include, exclude) # Current max including the current element include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"**[Question 4]:** Write a function to determine if a given string can be transformed into a **palindrome** by rearranging its characters. You should return `true` if it is possible to rearrange the letters of the string to form a palindrome, and `false` otherwise. A string is a palindrome if it reads the same forward and backward. The input string will contain only lowercase letters.","solution":"def can_form_palindrome(s): Returns true if the input string can be rearranged to form a palindrome, otherwise returns false. from collections import Counter counter = Counter(s) odd_count = sum(1 for count in counter.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"You are given an `m x n` grid of characters representing a **field of mines** (each cell is either a `\'M\'` representing a mine, or an empty `\'.\'`). You need to implement the `MinesweeperGame` class which creates the grid and exposes the following features: - `MinesweeperGame(char[][] field)`: Initializes the game with the specified `field`. - `int[] click(int row, int col)`: Reveals the cell at position `(row, col)`. If it is a mine, returns `[-1, -1]`. If it is not a mine, returns an array of two integers `[total_mines, adjacent_mines]`, where: - `total_mines` is the total number of mines in the grid. - `adjacent_mines` is the number of mines adjacent to the clicked cell, including diagonally adjacent cells. Implement the `MinesweeperGame` class ensuring the grid is properly managed and the rules of Minesweeper are followed.","solution":"class MinesweeperGame: def __init__(self, field): self.field = field self.m = len(field) self.n = len(field[0]) if self.m > 0 else 0 self.total_mines = sum(row.count(\'M\') for row in field) def click(self, row, col): if self.field[row][col] == \'M\': return [-1, -1] adjacent_mines = 0 directions = [ (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) ] for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < self.m and 0 <= c < self.n and self.field[r][c] == \'M\': adjacent_mines += 1 return [self.total_mines, adjacent_mines]"},{"question":"Given an array of integers `nums`, return _true_ if there exists a subsequence of `nums` that forms a geometric progression, otherwise return _false_. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For any sequence in geometric progression, the ratio between consecutive terms is constant.","solution":"def has_geometric_subsequence(nums): Returns True if there exists a subsequence of nums that forms a geometric progression, otherwise return False. if not nums or len(nums) < 3: return False # To check every triplets to see if they form a geometric progression n = len(nums) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if nums[j] ** 2 == nums[i] * nums[k]: return True return False"},{"question":"A 2D grid is represented as a list of strings. Each string represents a row in the grid and contains only characters \'1\' (land) and \'0\' (water). An island is defined as a group of \'1\'s (land) connected 4-directionally (horizontal or vertical.) Write a function that takes such a grid and returns the number of islands. An island is surrounded by water with at least one water cell around its edge, and each cell is either part of an island or water, but exactly one island.","solution":"def num_islands(grid): Returns the number of islands in the given 2D grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. if not grid: return 0 rows = len(grid) cols = len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): Perform depth-first search to mark all cells in the current island. if r < 0 or r >= rows or c < 0 or c >= cols or visited[r][c] or grid[r][c] == \'0\': return visited[r][c] = True # Check all 4 directions dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\' and not visited[r][c]: island_count += 1 dfs(r, c) return island_count"},{"question":"You are given a list of non-negative integers `capacities` where `capacities[i]` represents the capacity of the i-th bucket. You are also given a list of non-negative integers `quantity` where `quantity[i]` represents the amount of water that needs to be poured into the i-th bucket in the given order. Write a function that determines if it is possible to fill each bucket in such a way that no bucket overflows. Return `true` if it is possible to fill all the buckets, otherwise return `false`.","solution":"def can_fill_buckets(capacities, quantity): Determines if it is possible to fill each bucket with the given quantity without causing any bucket to overflow. Parameters: - capacities: a list of non-negative integers representing the capacity of each bucket. - quantity: a list of non-negative integers representing the amount of water to be poured into each bucket in the given order. Returns: - True if it is possible to fill all the buckets without overflow, otherwise False. for i in range(len(capacities)): if quantity[i] > capacities[i]: return False return True"},{"question":"You are given a grid with `n` rows and `m` columns, representing a field of crops. Each cell in the grid either contains a \'C\' indicating a crop or a \'.\' indicating an empty spot. Crops can spread to directly adjacent cells (up, down, left, right) if they are currently empty. Write a function that simulates the spread of crops for a given number of days and returns the final state of the grid. On each day, all crops spread simultaneously to the adjacent cells. Your function should take three arguments: 1. `grid`: a list of lists containing \'C\' and \'.\' representing the initial state of the field. 2. `rows`: an integer representing the number of rows in the grid. 3. `columns`: an integer representing the number of columns in the grid. 4. `days`: an integer representing the number of days over which the crops should spread. Return the grid after simulating the crop spread for the given number of days.","solution":"def spread_crops(grid, rows, columns, days): Simulates the spread of crops for a given number of days and returns the final state of the grid. :param grid: List[List[str]] - initial grid of crops and empty spots :param rows: int - number of rows in the grid :param columns: int - number of columns in the grid :param days: int - number of days to simulate the spread :return: List[List[str]] - final state of the grid from copy import deepcopy directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right for _ in range(days): # Deepcopy to store the new state after current day\'s crop spread new_grid = deepcopy(grid) for r in range(rows): for c in range(columns): if grid[r][c] == \'C\': for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < columns and grid[nr][nc] == \'.\': new_grid[nr][nc] = \'C\' # Update grid to the new state after simulating the current day\'s spread grid = new_grid return grid"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped after it rains over a series of bars, where each element represents a bar\'s elevation on a 2D grid. Write a function that calculates the total amount of rainwater trapped. * For example, given the list `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the function should return `6` as the total representation of rainwater trapped between the bars. The total rainwater trapped can be found by analyzing the elevation map and summing up the trapped water for all positions. Return the _total amount of rainwater trapped_.","solution":"def trap_rainwater(height): Returns the total amount of rainwater trapped given a list of bar elevations. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Consider a 2D `grid` of size `m x n` filled with non-negative integers. You can move either right or down from a cell to the adjacent cell. Starting from the top-left cell (0, 0), return _the **minimum sum** of the path to reach the bottom-right cell (m-1, n-1)_.","solution":"def min_path_sum(grid): Returns the minimum sum of the path to reach the bottom-right cell from the top-left cell. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"Given an integer `n`, generate a list of the first `n` prime numbers in ascending order.","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def generate_primes(n): Generates a list of the first `n` prime numbers in ascending order. primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return primes"},{"question":"Given an array of integers `nums`, write a function that finds the shortest subarray whose sum is greater than or equal to a given target value `target` and returns the length of this subarray. If no such subarray exists, return `0`. The function signature is: * `int minSubArrayLen(int target, int[] nums)` where `target` is the target sum and `nums` is the array of integers.","solution":"def minSubArrayLen(target, nums): Finds the length of the shortest subarray with a sum greater than or equal to target. If no such subarray exists, returns 0. n = len(nums) min_length = float(\'inf\') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] # Shrink the window to find the minimum length subarray while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"Given a list of non-negative integers `nums`, arrange them such that they form the largest possible number and return it as a string. Each number in `nums` contributes digits to form the final number, retaining their relative order from the `nums` list. If the largest number is `0` (i.e., all elements are zero), you should return \\"0\\".","solution":"from functools import cmp_to_key def largest_number(nums): Arrange a list of non-negative integers such that they form the largest possible number and return it as a string. if not nums: return \\"0\\" nums_str = list(map(str, nums)) def compare(x, y): if x + y > y + x: return -1 else: return 1 nums_str.sort(key=cmp_to_key(compare)) largest_num = \'\'.join(nums_str) if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"You are given two strings `s1` and `s2` containing only lowercase alphabetical characters. Your task is to determine if `s1` can be made equal to `s2` by performing any number of **replacements**. A **replacement** involves choosing any character in `s1` and replacing it with any other character. If it is possible to make `s1` equal to `s2` through replacements, return `true`; otherwise, return `false`. *Note: The frequency of characters in `s1` and `s2` must match exactly for the strings to be made equal through replacements.*","solution":"def can_be_made_equal(s1, s2): Determines if s1 can be made equal to s2 by performing any number of replacements. :param s1: The first string. :param s2: The second string. :return: True if s1 can be made equal to s2, otherwise False. if len(s1) != len(s2): return False # Create frequency dictionaries for both strings freq_s1 = {} freq_s2 = {} for char in s1: if char in freq_s1: freq_s1[char] += 1 else: freq_s1[char] = 1 for char in s2: if char in freq_s2: freq_s2[char] += 1 else: freq_s2[char] = 1 # Compare frequency dictionaries return freq_s1 == freq_s2"},{"question":"A company has a network that consists of a mixture of wired and wireless connections between servers. Each connection between two servers has a latency (in milliseconds). You are given a list of connections, where each connection is represented as a tuple `(server1, server2, latency)`. A network administrator wants to find the minimum latency required to connect all the servers in such a way that there is a path from any server to any other server in the network. If it is impossible to connect all servers, you should return `-1`. Implement a function `minimumLatency` that takes in an integer `n` (the number of servers) and a list of tuples `connections` representing the connections, and returns the minimum total latency of the connections to achieve full connectivity, or `-1` if it is not possible.","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimumLatency(n, connections): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) connections.sort(key=lambda x: x[2]) result = [] e = 0 i = 0 while e < n - 1 and i < len(connections): u, v, w = connections[i] i += 1 x = find(parent, u) y = find(parent, v) if x != y: e += 1 result.append(w) union(parent, rank, x, y) if e != n - 1: return -1 return sum(result)"},{"question":"You are given an array of integers `arr` where each element is distinct and sorted in ascending order. Your task is to transform the array into a balanced binary search tree (BST) and return the root of this BST. A balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Write a function `TreeNode sortedArrayToBST(int[] arr)` to accomplish this.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(arr): Converts a sorted array to a balanced binary search tree (BST). :param arr: List[int] - A list of integers sorted in ascending order. :return: TreeNode - The root node of the balanced BST. def helper(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(arr[mid]) node.left = helper(left, mid - 1) node.right = helper(mid + 1, right) return node return helper(0, len(arr) - 1)"},{"question":"You are given a string `s` consisting of lowercase English letters. A **substring** is a contiguous non-empty sequence of characters within a string. The **frequency** of a character in a substring is the number of occurrences of that character in the substring. The **minimum frequency** of a substring is the frequency of the least frequently occurring character in that substring. To find the **maximum value** of the minimum frequency among all substrings of the given string `s`, you must iterate through all possible substrings and determine their minimum frequencies. Return _the **maximum value** of the minimum frequency among all substrings of `s`_.","solution":"def max_min_frequency(s): Returns the maximum value of the minimum frequency among all substrings of the given string s. max_min_freq = 0 n = len(s) # Iterate over all possible starting points of substrings for i in range(n): frequency = {} # Dictionary to store frequency of characters in current substring # Iterate over all possible ending points for the current starting point for j in range(i, n): char = s[j] if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Calculate the minimum frequency in the current substring min_freq = min(frequency.values()) # Update the maximum of minimum frequencies max_min_freq = max(max_min_freq, min_freq) return max_min_freq"},{"question":"You are given a list of `n` integers representing the daily temperatures. Implement an algorithm to find out, for each day, how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead. Return _an array `answer` such that `answer[i]` is the number of days you have to wait after day `i` to get a warmer temperature_.","solution":"def dailyTemperatures(T): This function takes a list of integers representing daily temperatures and returns a list where the value at each index is the number of days until a warmer temperature. If there is no future day with a warmer temperature, the value at that index is 0. n = len(T) answer = [0] * n stack = [] for i in range(n): while stack and T[i] > T[stack[-1]]: j = stack.pop() answer[j] = i - j stack.append(i) return answer"},{"question":"You are given an array of integers `arr` where each integer represents the height of a stack of boxes. You can perform a move by picking up a single box from any stack and placing it on top of any other stack. Determine the minimum number of moves required to make all the stacks of equal height. Return the minimum number of moves.","solution":"def min_moves_to_equal_height(arr): Determine the minimum number of moves required to make all stacks of boxes equal in height. Parameters: arr (list[int]): List of integers representing the heights of stacks. Returns: int: Minimum number of moves to make all stacks equal in height. max_height = max(arr) min_moves = sum(max_height - height for height in arr) return min_moves"},{"question":"You are given a **square grid** with `n x n` cells, where each cell can either be empty or occupied by a barrier. You must find the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(n-1, n-1)` while avoiding barriers. You are allowed to move in four possible directions: up, down, left, and right, but cannot move diagonally or through barriers. If there isn\'t a valid path, return `-1`. The grid is represented by a 2D binary array `grid` of size `n x n`, where `0` represents an empty cell and `1` represents a barrier. Return the length of the shortest path from the top-left corner to the bottom-right corner of the grid, or `-1` if no such path exists.","solution":"from collections import deque def shortest_path_in_grid(grid): Returns the length of the shortest path from top-left to bottom-right of the grid. If no path exists, returns -1. :param grid: List[List[int]] A square grid with 0s (empty cell) and 1s (barrier). :return: int The length of the shortest path or -1 if no path exists. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given two integers `n` and `k`, return the _k-th permutation sequence of_ `n`. The potential sequences are listed in lexicographical order and are made up of the integers from `1` to `n`. For example, given `n` = 3, the possible sequences in lexicographical order are: \\"123\\", \\"132\\", \\"213\\", \\"231\\", \\"312\\", \\"321\\".","solution":"import math def get_permutation(n, k): Returns the k-th permutation sequence of n. The sequence is determined in lexicographical order of digits 1 to n. numbers = list(range(1, n + 1)) permutation = [] k -= 1 # convert k to zero-indexed while n > 0: n -= 1 # Determine which number should be at the current position index, k = divmod(k, math.factorial(n)) permutation.append(str(numbers.pop(index))) return \'\'.join(permutation)"},{"question":"You are given an array of integers `arr` where each element is at most `k` positions away from its target position in a sorted order. Implement an efficient algorithm to sort the array in ascending order. Return the sorted array.","solution":"import heapq def sort_k_sorted_array(arr, k): Given an array where each element is at most k positions away from its target position, sort the array in ascending order. Parameters: arr (List[int]): The k-sorted array. k (int): The maximum distance an element can be from its target position. Returns: List[int]: The sorted array. if not arr: return [] # Initialize result array result = [] # Create a min heap min_heap = [] # Build initial heap for i in range(min(k+1, len(arr))): heapq.heappush(min_heap, arr[i]) for i in range(k+1, len(arr)): heapq.heappush(min_heap, arr[i]) # Append the smallest element from the heap to the result result.append(heapq.heappop(min_heap)) # Add remaining elements from the heap to result while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"You are given a string `s` which consists of lowercase alphabets and a pattern string `p` which also consists of lowercase alphabets. You need to find the minimum window substring in `s` which contains all the characters of `p` including duplicates. If there is no such window in `s` that covers all characters in `p`, return an empty string `\\"\\"`. If there are multiple such minimum length windows, return the one which starts first. Return the substring that you found, or `\\"\\"` if no such substring exists.","solution":"from collections import Counter def min_window_substring(s, p): Returns the minimum window substring in `s` which contains all the characters of `p` including duplicates. If there is no such window, returns an empty string. if not s or not p: return \\"\\" dict_p = Counter(p) required = len(dict_p) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(s): char = s[r] window_counts[char] = window_counts.get(char, 0) + 1 if char in dict_p and window_counts[char] == dict_p[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[char] -= 1 if char in dict_p and window_counts[char] < dict_p[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[1] is None else s[ans[1]: ans[2] + 1]"},{"question":"You are tasked with implementing an online stock price tracking system. The system should be able to handle the following operations efficiently: 1. `StockPrice()`: Initializes the tracking system. 2. `void update(int timestamp, int price)`: Updates the price of the stock at the given timestamp. If the same timestamp is provided again, the previous price associated with that timestamp will be overwritten. 3. `int current()`: Returns the current price of the stock. The current price is defined as the latest price updated based on the highest timestamp. 4. `int maximum()`: Returns the maximum stock price recorded so far. 5. `int minimum()`: Returns the minimum stock price recorded so far. You are to implement the `StockPrice` class that supports these operations. Note that timestamps will be provided in strictly increasing order during the `update` calls.","solution":"class StockPrice: def __init__(self): self.timestamp_price = {} self.prices = [] def update(self, timestamp, price): if timestamp in self.timestamp_price: old_price = self.timestamp_price[timestamp] self.prices.remove(old_price) self.timestamp_price[timestamp] = price self.prices.append(price) def current(self): latest_timestamp = max(self.timestamp_price.keys()) return self.timestamp_price[latest_timestamp] def maximum(self): return max(self.prices) def minimum(self): return min(self.prices)"},{"question":"Write a function that simulates the stock market by calculating the maximum possible profit from a list of stock prices. You are given an array `prices` where `prices[i]` is the price of a given stock on the `i-th` day. You are only allowed to complete **one** transaction (i.e., buy one and sell one share of the stock). Note that you cannot sell a stock before you buy one. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.","solution":"def max_profit(prices): Calculate the maximum possible profit from a list of stock prices. Parameters: prices (List[int]): List of stock prices on different days. Returns: int: Maximum profit possible from one transaction. If no profit, returns 0. if not prices: return 0 min_price = float(\'inf\') max_prof = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_prof: max_prof = price - min_price return max_prof"},{"question":"Given a string `s` which consists of lowercase letters \'a\' and \'b\' only, return the minimum number of moves required to make the string alternating. A string is called alternating if no two adjacent characters are the same. In one move, you can change any character to \'a\' or \'b\'. For example, the strings `\\"abab\\"` and `\\"baba\\"` are alternating, while the strings `\\"aa\\"` and `\\"abba\\"` are not. Return the minimum number of moves required to make the string alternating.","solution":"def min_moves_to_alternate(s): Returns the minimum number of moves required to make the string alternating. # Two possible alternating patterns pattern1 = \\"ab\\" * (len(s) // 2 + 1) pattern2 = \\"ba\\" * (len(s) // 2 + 1) # Count number of moves to match each pattern changes_p1 = sum(c1 != c2 for c1, c2 in zip(s, pattern1)) changes_p2 = sum(c1 != c2 for c1, c2 in zip(s, pattern2)) # Return the minimum number of changes return min(changes_p1, changes_p2)"},{"question":"You are given two arrays of integers `arr1` and `arr2` of length `n`. You need to merge these two arrays into a single sorted array without using any built-in sort function. The merging process should maintain the relative order of elements from both `arr1` and `arr2`. Write a function that returns the merged and sorted array. (Note: The arrays are already sorted in non-decreasing order.)","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array while maintaining the relative order of elements from both arrays. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged and sorted array. merged_array = [] i, j = 0, 0 n1, n2 = len(arr1), len(arr2) while i < n1 and j < n2: if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < n1: merged_array.append(arr1[i]) i += 1 while j < n2: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"Given a string `s` containing only lowercase letters, recursively eliminate all adjacent duplicate characters until no such adjacent duplicates remain. Return the final string after all possible eliminations have been performed. For example, given the input \\"abbaca\\", the output should be \\"ca\\" after eliminating \\"bb\\" and \\"aa\\" successively.","solution":"def remove_adjacent_duplicates(s): Recursively eliminate all adjacent duplicate characters from the string until no such adjacent duplicates remain. :param s: Input string containing only lowercase letters :return: String after all adjacent duplicates have been removed stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an integer array `heights` representing the heights of buildings on a landscape. The width of each building is 1. It is raining, and water collects between the buildings. Compute how much water is able to collect after the rain. Return the total amount of water that can be trapped between the buildings represented in the `heights` array. Example: ```python heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] # A representation of the landscape can be visualized as follows: # # # # # # # # # # # # # # # # # #--------- # The total amount of trapped water is 6 units. ``` Analyze and implement a function `trap_water(heights)` that solves the problem efficiently.","solution":"def trap_water(heights): Calculates the total amount of water trapped between buildings after the rain. Args: heights (List[int]): A list of integers representing the heights of the buildings. Returns: int: The total amount of trapped water. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. * Implement a function: ```python def generateParenthesis(n: int) -> List[str]: ``` * This function should return a list of strings containing all combinations of well-formed parentheses for the given number of pairs n.","solution":"from typing import List def generateParenthesis(n: int) -> List[str]: def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s+\'(\', left+1, right) if right < left: backtrack(s+\')\', left, right+1) result = [] backtrack() return result"},{"question":"You are organizing a coding competition where participants submit solutions to a set of problems. Each solution is evaluated and given a score. Some scores are tied, and some scores are unique. You need to rank the participants based on their scores such that participants with higher scores get better ranks, and ties are given the same rank. Additionally, the rank should not have any gaps (e.g., if two participants are tied for 2nd place, the next rank should be 3rd place). Implement the `CompetitionRanking` class: * `CompetitionRanking()` Initializes the object. * `void addScore(int participantId, int score)` Adds a score for the participant with the given `participantId`. If the participant ID already exists, update the score to the new value. * `int getRank(int participantId)` Returns the rank of the participant with the given `participantId`. If the participant does not exist, return -1. * `List<Integer> getTopKParticipants(int k)` Returns a list of the top `k` participants\' IDs based on their ranks. If there are ties, include the tied participants up to the `k` limit. If there are fewer than `k` participants, return all participant IDs in ranked order. Maintain the uniqueness of participant IDs and handle duplicate scores by giving the same rank to tied scores.","solution":"from collections import defaultdict class CompetitionRanking: def __init__(self): self.scores = {} def addScore(self, participantId, score): self.scores[participantId] = score def getRank(self, participantId): if participantId not in self.scores: return -1 sorted_scores = sorted(set(self.scores.values()), reverse=True) rank_dict = {score: rank + 1 for rank, score in enumerate(sorted_scores)} return rank_dict[self.scores[participantId]] def getTopKParticipants(self, k): sorted_participants = sorted(self.scores.items(), key=lambda x: (-x[1], x[0])) result = [] rank = 0 last_score = None for idx, (participantId, score) in enumerate(sorted_participants): if score != last_score: rank = idx + 1 last_score = score result.append(participantId) if len(result) >= k: break return result"},{"question":"You are given an integer array `nums` where each element is unique. You want to construct a binary search tree (BST) from `nums` where the following two conditions are met: * The root node is `nums[0]`. * If there is a node in the tree with a value `nums[j]`, then `nums[j]` appears in the right subtree of `nums[j-1]` if `nums[j] > nums[j-1]` and in the left subtree of `nums[j-1]` if `nums[j] < nums[j-1]`. Construct the BST by inserting elements in the order given in `nums`. Then return the inorder traversal of the BST. Write a function `constructBST(nums: List[int]) -> List[int]` that returns the inorder traversal as a list of integers. **Example:** ``` Input: nums = [8, 5, 10, 1, 7, 12] Output: [1, 5, 7, 8, 10, 12] ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def inorder_traversal(root): if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def constructBST(nums): if not nums: return [] root = TreeNode(nums[0]) for num in nums[1:]: insert_into_bst(root, num) return inorder_traversal(root)"},{"question":"Given an `n x n` grid containing integers, where each cell represents the maximum number of steps you can move from that cell in the four directions (up, down, left, right) to another cell, determine the minimum number of steps required to move from the top-left cell to the bottom-right cell. Return the minimum number of steps if it is possible to move to the bottom-right cell, otherwise return `-1`. Complete the function `minSteps(grid)` that takes in a 2D list `grid` and returns the minimum number of steps or `-1` if the bottom-right cell is not reachable.","solution":"from collections import deque def minSteps(grid): n = len(grid) if n == 0 or grid[0][0] == 0: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False] * n for _ in range(n)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited[0][0] = True while queue: x, y, steps = queue.popleft() if x == n-1 and y == n-1: return steps max_steps = grid[x][y] for dx, dy in directions: for i in range(1, max_steps + 1): nx, ny = x + dx * i, y + dy * i if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"Given a binary tree, implement a function that returns the maximum width of the tree. The maximum width of a tree is the maximum number of nodes present at any level of the binary tree. The width of one level is defined as the length between the end nodes (the leftmost and rightmost non-null nodes), including any null nodes in between. If the tree is empty, return `0`. A binary tree node is represented by a `TreeNode` class, which has `int val`, `TreeNode left`, and `TreeNode right` fields.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def widthOfBinaryTree(root): if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # Elements are (node, index) while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) # Current level\'s width is the difference between the first and last index + 1 _, last_index = queue[-1] if queue else (None, first_index) max_width = max(max_width, last_index - first_index + 1) return max_width"},{"question":"You are given an `n x n` 2D matrix. Rotate the matrix 90 degrees clockwise without using any additional matrix for temporary storage. The rotation must happen in-place. Return the 2D matrix after rotation. Your function should work for any arbitrary `n x n` matrix, not just simple examples.","solution":"def rotate_matrix(matrix): Rotates an n x n 2D matrix 90 degrees clockwise in place. Args: matrix (list[list[int]]): 2D list representing an n x n matrix. Returns: list[list[int]]: The in-place rotated matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"Given the root of a binary search tree (BST) and an integer value `k`, return `true` if there exist two distinct nodes in the BST such that their sum equals `k`. Otherwise, return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target(root, k): Given the root of a binary search tree and an integer k, return True if there exist two distinct nodes in the BST such that their sum equals k. Otherwise, return False. seen = set() def dfs(node): if not node: return False if k - node.val in seen: return True seen.add(node.val) return dfs(node.left) or dfs(node.right) return dfs(root)"},{"question":"You are given an array `arr` of `n` integers. An operation involves choosing a subarray and adding `1` to every element of the subarray. You are to perform a series of such operations to make every element of the array equal. Return the _minimum number of operations_ required to achieve this.","solution":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations required to make all elements of the array equal. Each operation involves adding 1 to every element of a chosen subarray. max_element = max(arr) min_element = min(arr) return max_element - min_element"},{"question":"You are given an integer array `arr` of length `n` where `arr[i]` represents the score of the ith student in a class. You need to implement a grading system based on the following rules: 1. Each student\'s grade is based on their rank in the class. The highest score receives the rank 1, the second highest score receives the rank 2, and so on. 2. If two or more students have the same score, they should receive the same rank, and the next rank should be adjusted accordingly. For example, if two students are tied for the highest score, they both receive rank 1, and the next highest score would receive rank 3. 3. Return an array `grades` where `grades[i]` is the rank of the ith student in the class.","solution":"def find_grades(arr): Given an array of scores, return the ranks for each score. # Create a sorted version of the array with indexes sorted_scores_with_index = sorted([(score, index) for index, score in enumerate(arr)], reverse=True, key=lambda x: x[0]) # Initialize the grades array grades = [0] * len(arr) # Initialize the rank and previous score rank = 1 prev_score = sorted_scores_with_index[0][0] for i, (score, index) in enumerate(sorted_scores_with_index): if score != prev_score: rank = i + 1 grades[index] = rank prev_score = score return grades"},{"question":"Given an integer array `nums` consisting of `n` non-negative integers, you have to perform a series of operations. In each operation, you can choose any two elements of the array and remove them from the array, and then add their sum back into the array. The goal is to minimize the value of the last remaining element in the array. Return _the minimum value of the last remaining element after performing the specified operations_.","solution":"import heapq def minimize_last_element(nums): Minimize the value of the last remaining element in the array after performing operations. Args: nums (list): a list of non-negative integers. Returns: int: the minimum possible value of the last remaining element. if len(nums) == 1: return nums[0] # Convert nums to a min-heap nums = [-num for num in nums] heapq.heapify(nums) while len(nums) > 1: # Pop the two largest elements first = heapq.heappop(nums) second = heapq.heappop(nums) # Combine them and push the sum back into the heap combined = first + second heapq.heappush(nums, combined) return -heapq.heappop(nums)"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine the frequency of each character present in the string and then return a list of tuples, where each tuple contains a character and its frequency. The characters in the list should be sorted in descending order based on their frequencies. If two characters have the same frequency, they should appear in alphabetical order. Return the list of tuples representing the characters and their frequencies as described.","solution":"from collections import Counter def character_frequency(s): Determine the frequency of each character in the string s and return a list of tuples. Each tuple contains a character and its frequency. The list is sorted in descending order of frequencies and alphabetically for characters with the same frequency. Parameters: s (str): A string of lowercase English letters. Returns: List[Tuple[str, int]]: A list of tuples sorted as described. # Count the frequency of each character freq_count = Counter(s) # Sort by frequency (in descending order) and then alphabetically by character sorted_freq = sorted(freq_count.items(), key=lambda item: (-item[1], item[0])) return sorted_freq"},{"question":"You are given a string `logs` where each element represents a log entry containing an IP address and a status code, separated by a space. A status code of `\\"200\\"` indicates a successful request, while any other status code indicates a failure. Your task is to return the IP address that has the highest number of successful requests. If there is a tie, return the lexicographically smallest IP address among them. [Question 4]: ``` Example: logs = [\\"192.168.1.1 200\\", \\"192.168.1.1 404\\", \\"10.0.0.1 200\\", \\"192.168.1.1 200\\", \\"10.0.0.1 200\\"] Output: \\"10.0.0.1\\" ```","solution":"def highest_successful_ip(logs): Returns the IP address that has the highest number of successful requests (status code 200). In the event of a tie, it returns the lexicographically smallest IP address among them. from collections import defaultdict success_count = defaultdict(int) for log in logs: ip, status = log.split() if status == \\"200\\": success_count[ip] += 1 if not success_count: return None max_requests = max(success_count.values()) ips_with_max_requests = [ip for ip, count in success_count.items() if count == max_requests] return min(ips_with_max_requests)"},{"question":"You are given a string `s` which consists of only lowercase English letters. You are to perform a specific transformation on `s` repeatedly until you cannot perform it anymore. In one transformation, you can remove any two adjacent characters if they are the same. After doing this, the remaining characters will shift left to close the gap. You are to find the final string after it cannot be transformed further. Return _the final string after transformation_.","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicates from the string s until no more adjacent duplicates exist. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the last character because it\'s a duplicate else: stack.append(char) # Convert stack back to string and return return \'\'.join(stack)"},{"question":"You are given a list of non-negative integers `nums` and a target sum `target`. Write a function that determines if there are three distinct elements in `nums` which add up to the `target`. Return `true` if such a combination exists, otherwise return `false`.","solution":"def three_sum(nums, target): Determines if there are three distinct elements in nums which add up to the target. Parameters: nums (list of int): List of non-negative integers. target (int): The target sum. Returns: bool: True if there are three distinct elements in nums that add up to target, otherwise False. nums.sort() n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i-1]: # Avoid duplicate processing continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given a list of airline ticket prices represented by a 2D array `prices` where `prices[i] = [from_i, to_i, price_i]` represents a flight from city `from_i` to city `to_i` with a cost of `price_i`. You are also given two integers, `src` representing your starting city, and `dst` representing your destination city, along with an integer `k` representing the maximum number of stops allowed on the way. Your task is to find the cheapest price from `src` to `dst` with at most `k` stops. Return the cheapest price, or `-1` if there is no such route.","solution":"from collections import defaultdict, deque import heapq def findCheapestPrice(n, flights, src, dst, k): Returns the cheapest price from src to dst with at most k stops. Parameters: n (int): number of cities flights (List[List[int]]): list of flights where each flight is represented as [from_i, to_i, price_i] src (int): source city dst (int): destination city k (int): maximum number of stops allowed Returns: int: cheapest price, or -1 if there is no such route graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) # (cost, current city, stops left) min_heap = [(0, src, k + 1)] while min_heap: cost, u, stops = heapq.heappop(min_heap) if u == dst: return cost if stops > 0: for v, w in graph[u]: heapq.heappush(min_heap, (cost + w, v, stops - 1)) return -1"},{"question":"Given a **0-indexed** integer array `heights` of length `n` representing the heights of buildings, you\'re tasked with determining how many buildings have a view of the sunset. A building has a view of the sunset if all the buildings to its right are shorter. Return _the indices of these buildings in order from left to right_. You can assume that the buildings have unique heights. **Note**: The array `heights` is not necessarily sorted.","solution":"def buildings_with_sunset_view(heights): Returns the indices of the buildings that have a view of the sunset. A building has a view of the sunset if all buildings to its right are shorter. n = len(heights) result = [] if n == 0: return result max_height = heights[-1] result.append(n - 1) for i in range(n - 2, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"You are given a binary tree. Write a function to check whether this binary tree is balanced. In a balanced tree, the depth of the two subtrees of every node never differ by more than 1.","solution":"class TreeNode: A TreeNode class for a binary tree node with left and right children. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Returns True if the binary tree is balanced, otherwise False. def check_height(node): if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"You are given two strings `s` and `t` of the same length containing only lowercase English letters. You need to construct a string `result` by performing a series of transformations on `s`. In each transformation, you can take any character from `s` and replace it with any character from `t` that has the same index. The goal is to make `result` lexicographically smallest among all possible transformations. Return the resulting string.","solution":"def construct_lexicographically_smallest_string(s, t): Construct the lexicographically smallest string by transforming s using characters from t. Args: s (str): The original string. t (str): The transformation string. Returns: str: The lexicographically smallest string that can be obtained. result = [] for i in range(len(s)): if s[i] < t[i]: result.append(s[i]) else: result.append(t[i]) return \'\'.join(result)"},{"question":"Given a string `str` consisting of lowercase alphabets, you need to determine the length of the longest substring that can be made by deleting at most one character from `str`. A substring is a contiguous sequence of characters within a string. Return _the length of the longest possible substring_ after deleting at most one character from the original string.","solution":"def longest_substring_after_deletion(s): n = len(s) if n == 0: return 0 max_len = 0 for i in range(n): left_len = 0 if i == 0 else i right_len = n-i-1 current_len = left_len + right_len max_len = max(max_len, current_len) return max_len"},{"question":"In a game, there are `n` types of balloons. Each balloon is either red, yellow, or blue. You are given an array `balloons` of length `n` where `balloons[i]` is the color of the `i-th` balloon. You are also given an integer `m`. You can perform up to `m` operations where in each operation you can pick two adjacent balloons and merge them into one balloon. The color of the merged balloon will be the color of the majority of the selected balloons in that operation. If both the selected balloons have the same color, the merged balloon\'s color will not change. Return the minimum number of operations required to make all the balloons the same color. If it is not possible, return -1. Example: ``` Input: balloons = [\\"red\\", \\"yellow\\", \\"blue\\", \\"red\\"], m = 2 Output: 1 Explanation: Merge the first and second balloons to get [\\"red\\", \\"yellow\\", \\"red\\"] in one operation. ```","solution":"def min_operations_to_same_color(balloons, m): Determines the minimum number of operations required to make all balloons the same color. If not possible, returns -1. :param balloons: List of strings representing the colors of the balloons :param m: Integer representing the maximum number of operations allowed :return: Integer representing the minimum number of operations required or -1 if not possible from collections import Counter # If balloons are already the same color if len(set(balloons)) == 1: return 0 # Frequency counter of colors freq = Counter(balloons) max_color_count = max(freq.values()) # Total balloons total_balloons = len(balloons) # Minimum operations required to make the most frequent color dominate min_operations = total_balloons - max_color_count # Check if we have enough operations allowed to achieve the goal if min_operations <= m: return min_operations else: return -1"},{"question":"You are given a string `s` consisting of lowercase English letters and an array of integers `indices`. The string `s` is **shuffled** such that the character at the `i-th` position of `s` was originally at the position `indices[i]`. Write a function that reconstructs and returns the original string before it was shuffled.","solution":"def restore_string(s, indices): Returns the original string before it was shuffled. Parameters: s (str): a shuffled string of lowercase English letters. indices (List[int]): an array of indices representing the original positions of characters. Returns: str: the original string. original = [\'\'] * len(s) for i, idx in enumerate(indices): original[idx] = s[i] return \'\'.join(original)"},{"question":"Given a list of `n` integers, where each integer represents the height of a building, find the number of pairs of buildings `(i, j)` such that `i < j` and the height of building `i` is less than the height of building `j`. Return the total number of such pairs.","solution":"def count_increasing_pairs(buildings): This function returns the number of pairs (i, j) where i < j and buildings[i] < buildings[j]. :param buildings: List of integers where each integer represents the height of a building :return: The total number of pairs (i, j) where i < j and buildings[i] < buildings[j] n = len(buildings) count = 0 for i in range(n): for j in range(i + 1, n): if buildings[i] < buildings[j]: count += 1 return count"},{"question":"You are given a sorted integer array `nums` and an integer `target`. The task is to determine if there exists a pair of elements in the array whose sum is equal to `target`. Return a list of the indices of the two numbers such that they add up to `target`. The returned indices must be in ascending order. Each input would have exactly one solution, and you may not use the same element twice. You can assume that the array contains only unique numbers. For example, given `nums = [1, 2, 3, 4, 6]` and `target = 6`, the output should be `[1, 3]` because `nums[1] + nums[3] == 2 + 4 == 6`.","solution":"def two_sum(nums, target): Given a sorted array nums and a target, find the indices of two numbers such that they add up to the target. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 # If no solution is found (the problem guarantees exactly one solution, so this line should never be hit) return []"},{"question":"You are given two binary strings `a` and `b`. You need to write a function that finds the longest binary string that is a subsequence of both `a` and `b`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the longest common subsequence of the given binary strings as a string. If there are multiple longest subsequences, return any of them.","solution":"def longest_common_subsequence(a, b): Returns the longest common subsequence of binary strings a and b. m, n = len(a), len(b) dp = [[\\"\\"] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + a[i - 1] else: if len(dp[i - 1][j]) > len(dp[i][j - 1]): dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i][j - 1] return dp[m][n]"},{"question":"You are given an array of strings `arr` and a string `pattern`. Your task is to return the number of strings in `arr` that can be formed by rearranging the characters of `pattern` (including the original `pattern` itself). Each string in `arr` should be compared independently, and the frequency of each character in the string must match the frequency of each character in `pattern`.","solution":"from collections import Counter def count_rearranged_strings(arr, pattern): Returns the number of strings in \'arr\' that can be formed by rearranging the characters of \'pattern\'. pattern_counter = Counter(pattern) count = 0 for string in arr: if Counter(string) == pattern_counter: count += 1 return count"},{"question":"You are given an **array of n integers** representing an elevation map where the width of each bar is 1. Assume that the sides of the elevation map are extended upwards infinitely. Compute the total water it can trap after raining. Return _the **maximum amount of water** that can be trapped in_ `n` _by using the elevation map_.","solution":"def trap_water(height): Given n non-negative integers representing an elevation map where the width of each bar is 1, computes how much water it can trap after raining. :param height: List[int] - list of integers representing the height of bars :return: int - total water trapped if not height: return 0 n = len(height) water = 0 # Arrays to store the maximum heights to the left and right of each element left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the water trapped for i in range(n): water += min(left_max[i], right_max[i]) - height[i] return water"},{"question":"You are given an array of `n` integers `arr` and an integer `d`. You can perform the following operation on the array any number of times: Select a subarray and increment every element of the subarray by `d`. Return the minimum number of operations required to make all the elements of the array equal. Note that the subarrays selected can be of varying lengths and can intersect or overlap.","solution":"def min_operations_to_equalize(arr, d): Returns the minimum number of operations required to make all the elements of the array equal. Parameters: arr (list of int): The array of integers. d (int): The increment value. Returns: int: The minimum number of operations, or -1 if it is not possible. min_value = min(arr) operations = 0 for val in arr: diff = val - min_value if diff % d != 0: return -1 operations += diff // d return operations"},{"question":"Given a **2D binary grid** of size `m x n`, you need to count the number of distinct **islands**. An island is a group of `1`\'s (representing land) connected **4-directionally** (horizontal or vertical.) You can assume all four edges of the grid are surrounded by water. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other. Implement the `countDistinctIslands` method: * `int countDistinctIslands(int[][] grid)` - This method returns the number of distinct islands in the grid. **Note**: The islands are distinct if they have different shapes, considering that two identical islands can be overlapped by a translation.","solution":"def countDistinctIslands(grid): def dfs(x, y, pos, shape): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0): return grid[x][y] = 0 shape.append(pos) dfs(x + 1, y, (pos[0] + 1, pos[1]), shape) dfs(x - 1, y, (pos[0] - 1, pos[1]), shape) dfs(x, y + 1, (pos[0], pos[1] + 1), shape) dfs(x, y - 1, (pos[0], pos[1] - 1), shape) shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, (0, 0), shape) shapes.add(tuple(shape)) return len(shapes)"},{"question":"You are given an **m x n** binary grid called `grid` that represents a map of **1\'s** (land) and **0\'s** (water). An **island** is a maximal group of connected **1\'s** (land) where a cell is considered connected if it is horizontally or vertically adjacent to another cell. You need to find the **smallest island** by its total land cells. If no island exists, return `0`. Write a function `smallestIsland(grid: List[List[int]]) -> int` to solve this problem.","solution":"from typing import List def smallestIsland(grid: List[List[int]]) -> int: Returns the size of the smallest island on the grid. If no island, returns 0. def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark this cell as visited return 1 + dfs(x+1, y) + dfs(x-1, y) + dfs(x, y+1) + dfs(x, y-1) smallest = float(\'inf\') found_island = False for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: found_island = True size = dfs(i, j) if size < smallest: smallest = size return smallest if found_island else 0"},{"question":"You are given a matrix `mat` of size `m x n` consisting of **positive** integers. You can **rotate** the matrix 90 degrees clockwise. Return _the **maximum** sum of the elements in any row of the matrix after performing any number of rotations._","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotate the matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def max_row_sum_after_rotations(matrix): Return the maximum sum of the elements in any row of the matrix after performing any number of 90 degrees clockwise rotations. max_sum = 0 # There are only 4 possible rotations (0, 90, 180, 270 degrees) for _ in range(4): row_sums = [sum(row) for row in matrix] max_sum = max(max_sum, max(row_sums)) matrix = rotate_matrix_90_degrees_clockwise(matrix) return max_sum"},{"question":"Given an integer array `nums`, return _the **minimum number** of increments required to make all the elements of the array unique_. An incrementing operation consists of incrementing any element of the array by 1 (i.e., nums[i] += 1). If an element\'s increment makes it equal to another existing element in the `nums` array, you must continue incrementing until all elements in the array are unique. Ensuring minimum increments, return the total count of such increment operations.","solution":"def min_increment_for_unique(nums): Returns the minimum number of increments required to make all array elements unique. :param nums: List of integers :return: Integer representing the total count of increment operations if not nums: return 0 nums.sort() moves = 0 for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: increment_needed = nums[i - 1] - nums[i] + 1 nums[i] += increment_needed moves += increment_needed return moves"},{"question":"You are given a string `s` consisting of lowercase English letters. In one move, you can choose any letter `s[i]` and change it to any other lowercase English letter. Return _the minimum number of moves required to make all the characters in the string the same_.","solution":"def min_moves_to_make_all_chars_same(s): Returns the minimum number of moves required to make all characters in the string the same. :param s: A string consisting of lowercase English letters. :return: Minimum number of moves to make all characters in the string the same. # Count the frequency of each character in the string char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the character with the maximum frequency max_freq = max(char_count.values()) # The minimum number of moves required is the length of the string minus the maximum frequency return len(s) - max_freq"},{"question":"You are given a string `text` consisting of lowercase English letters and an integer array `indices` of the same length. You need to reconstruct the string by rearranging the characters in `text` such that the character originally at the `i-th` position moves to `indices[i]` in the new string. Return the reconstructed string.","solution":"def restore_string(text, indices): Reconstruct the string by rearranging the characters in \'text\' such that the character originally at the i-th position moves to indices[i] in the new string. Parameters: text (str): The original string to be rearranged. indices (list): A list of target indices for each character in the string. Returns: str: The reconstructed string after rearranging the characters. n = len(text) result = [\'\'] * n for i, idx in enumerate(indices): result[idx] = text[i] return \'\'.join(result)"},{"question":"You are given two arrays, `nums1` and `nums2`, each consisting of unique integers. Your task is to find the smallest index `i` in `nums1` such that `nums1[i]` is present in `nums2`. If there are multiple answers, return the one with the smallest value of `nums1[i]`. If no such index exists, return `-1`. Your solution should run in `O(n + m)` time complexity, where `n` is the length of `nums1` and `m` is the length of `nums2`.","solution":"def find_min_index(nums1, nums2): nums2_set = set(nums2) # Converting nums2 to set to check presence min_index = -1 min_value = float(\'inf\') for i, num in enumerate(nums1): if num in nums2_set: if min_index == -1 or num < min_value: min_index = i min_value = num return min_index"},{"question":"Given an integer array `tasks` where each element represents the duration of a task in minutes, and a positive integer `sessionTime` representing the maximum duration of a work session, determine the **minimum number of sessions** required to complete all the tasks where you can work on any number of non-overlapping tasks within each session, but the total duration of tasks in each session should not exceed `sessionTime`. Each task must be assigned to exactly one session. Return _the **minimum number of sessions** needed to complete all tasks_.","solution":"def min_sessions(tasks, sessionTime): Returns the minimum number of sessions required to complete all tasks so that the sum of task durations in each session doesn\'t exceed sessionTime. Uses a dynamic programming approach to solve the problem efficiently. Args: tasks: List[int] - List of task durations. sessionTime: int - Maximum time of a single session. Returns: int - Minimum number of sessions required to complete all tasks. # Importing required module from itertools import combinations # Memoization dictionary memo = {} def dp(state): if state == 0: return 0 if state in memo: return memo[state] # Initiate the minimum to infinity min_sessions_needed = float(\\"inf\\") # Iterate over each possible combination of tasks that could fit into a session substate = state while substate: total = sum(tasks[i] for i in range(len(tasks)) if substate & (1 << i)) if total <= sessionTime: min_sessions_needed = min(min_sessions_needed, dp(state ^ substate) + 1) substate = (substate - 1) & state # Store the computed result in memo memo[state] = min_sessions_needed return min_sessions_needed # Call dp function with all tasks (state represented by (1 << len(tasks)) - 1) return dp((1 << len(tasks)) - 1)"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine the **minimum** number of contiguous substrings into which you can split the string such that each substring contains **at most** one unique character. Return an integer representing this minimum number of substrings. For example, given the input `s = \\"aaabbbccc\\"`, you would return `3` because you can split the string into `[\\"aaa\\", \\"bbb\\", \\"ccc\\"]`, each of which contains only one unique character.","solution":"def min_substrings_with_unique_chars(s): Returns the minimum number of contiguous substrings into which the input string can be split such that each substring contains at most one unique character. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Minimum number of such substrings. if not s: return 0 count = 1 # We always have at least one substring for i in range(1, len(s)): if s[i] != s[i - 1]: count += 1 return count"},{"question":"You are given an integer array `heights` representing the height of trees at different positions and an integer `d` representing the maximum distance you can jump from one tree to another. Starting from any tree, you can jump to any other tree within distance `d` to collect more fruits, but you can only jump to a tree that is taller than your current tree. Your task is to find the maximum number of trees you can visit starting from any tree and following these rules. Write a function: ```python def max_trees_to_visit(heights: List[int], d: int) -> int: ```","solution":"from typing import List def max_trees_to_visit(heights: List[int], d: int) -> int: n = len(heights) dp = [1] * n # Sort index based on heights for easier calculation index = list(range(n)) index.sort(key=lambda x: heights[x]) for i in index: for jump in range(1, d + 1): if i + jump < n and heights[i + jump] > heights[i]: dp[i + jump] = max(dp[i + jump], dp[i] + 1) if i - jump >= 0 and heights[i - jump] > heights[i]: dp[i - jump] = max(dp[i - jump], dp[i] + 1) return max(dp)"},{"question":"Given a string `s` consisting of lowercase letters, you need to return the **length of the shortest subsequence** that contains all the distinct characters of the string. A subsequence is derived by deleting some or none of the characters without changing the order of the remaining characters.","solution":"def shortest_subsequence_length(s): Returns the length of the shortest subsequence that contains all the distinct characters of the string s. # Convert the input string to a set to get all distinct characters distinct_characters = set(s) # The length of the shortest subsequence that contains all distinct characters # is simply the number of distinct characters return len(distinct_characters)"},{"question":"You are given a **0-indexed** integer array `weights` of length `n`, where `weights[i]` represents the weight of the `i-th` package. You need to divide the array into two groups such that the absolute difference between the sums of the two groups is minimized. Return _an integer_ that represents this minimum absolute difference. The length of each group must be at least `1`.","solution":"def minimum_difference(weights): Returns the minimum absolute difference between the sums of two groups of weights. Each group must contain at least one element. total_weight = sum(weights) n = len(weights) # Getting the half of the total weight for the knapsack problem target = total_weight // 2 # Initializing dp array dp = [0] * (target + 1) # Knapsack approach to find the best possible sum we can achieve close to target for weight in weights: for j in range(target, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) sum_close_to_half = dp[target] return abs(total_weight - 2 * sum_close_to_half)"},{"question":"Given an array of integers `prices` representing the daily prices of a stock, print the maximum profit you can achieve by performing at most two transactions. A transaction consists of buying and then selling one share of the stock. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy it again). Complete the function `maxProfit` to perform this task.","solution":"def maxProfit(prices): Computes the maximum profit with at most two transactions. :param prices: List[int] - List of daily prices of a stock :return: int - Maximum achievable profit with at most two transactions if not prices: return 0 n = len(prices) # Initialize the dp arrays sell1, sell2 = 0, 0 buy1, buy2 = float(\'-inf\'), float(\'-inf\') for price in prices: # Update the states for buy1, sell1, buy2 and sell2 buy1 = max(buy1, -price) # Buy the first stock sell1 = max(sell1, buy1 + price) # Sell the first stock buy2 = max(buy2, sell1 - price) # Buy the second stock sell2 = max(sell2, buy2 + price) # Sell the second stock return sell2"},{"question":"You are given a **0-indexed** integer array `bins` of size `n` where `bins[i]` is the number of items present in the `i^th` bin. You are also given a **0-indexed** integer array `operations` of size `n` where `operations[i]` can be either `\'+\'` or `\'-\'`. - `\'+\'` means a bin can either increase the number of items it contains by 1 or leave it unchanged. - `\'-\'` means a bin can either decrease the number of items it contains by 1 or leave it unchanged. Determine if it is possible to make all bins contain an equal number of items by applying zero or more operations as defined by the `operations` array. Return `true` if it is possible, otherwise, return `false`.","solution":"def can_make_bins_equal(bins, operations): Determines if it is possible to make all bins contain an equal number of items with the specified operations. Parameters: bins (list): A list of integers representing the number of items in each bin. operations (list): A list of strings where each element is either \'+\' or \'-\'. Returns: bool: True if it\'s possible to make all bins contain an equal number of items, False otherwise. max_items = max(bins) + 1 min_items = min(bins) - 1 for items_to_set in range(min_items, max_items + 1): can_make_all_bins_equal = True for i in range(len(bins)): if operations[i] == \'+\': if not (bins[i] <= items_to_set <= bins[i] + 1): can_make_all_bins_equal = False break elif operations[i] == \'-\': if not (bins[i] - 1 <= items_to_set <= bins[i]): can_make_all_bins_equal = False break if can_make_all_bins_equal: return True return False"},{"question":"You are given a list of non-negative integers representing the heights of columns of water in a histogram where the width of each column is 1. Compute how much water can be trapped after raining. The list will have at least one column. Return the total amount of trapped water.","solution":"def trap(height): Computes the total amount of trapped water in the histogram. :param height: List of non-negative integers representing the heights of the columns :return: Integer amount of trapped water if not height or len(height) < 2: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given an array `heights` representing the heights of buildings, where `heights[i]` is the height of the `i-th` building. Each building casts a shadow to its right that extends to the next building that is taller. Return _an array_ `shadow` _such that_ `shadow[i]` _is the index of the closest taller building to the right of building `i`, or `-1` if there is no such building._","solution":"def find_closest_taller_building(heights): Returns an array where each element is the index of the closest taller building to the right. If there is no such building, the element is -1. n = len(heights) shadow = [-1] * n stack = [] for i in range(n): while stack and heights[stack[-1]] < heights[i]: shadow[stack.pop()] = i stack.append(i) return shadow"},{"question":"You are given a list of strings `words` and a string `order` that represents the new lexicographical order of the alphabet. Return `true` if and only if the given `words` are sorted lexicographically in this new order. The order is given as a string of lowercase letters, where each letter is unique and all are present in the order.","solution":"def is_alien_sorted(words, order): Determine if the list of words is sorted lexicographically according to a new order of the alphabet. Args: words (List[str]): List of strings to be checked. order (str): A string representing the new order of the alphabet. Returns: bool: True if words are sorted according to the new order, False otherwise. order_index = {char: index for index, char in enumerate(order)} def is_valid_order(word1, word2): Check if word1 is correctly ordered before word2 based on the alien dictionary order. for char1, char2 in zip(word1, word2): if order_index[char1] < order_index[char2]: return True elif order_index[char1] > order_index[char2]: return False return len(word1) <= len(word2) for i in range(len(words) - 1): if not is_valid_order(words[i], words[i+1]): return False return True"},{"question":"You are given an integer array `data` representing the number of visitors in a shopping mall for `n` consecutive days. An integer `k` represents a window of consecutive days. Return _the minimum number of days within that window that needs to record more visitors than a given integer `threshold` to consider that window a successful promotional period_. If no such window exists, return -1.","solution":"def min_days_to_succeed(data, k, threshold): Returns the minimum number of days within that window that needs to record more visitors than the threshold to consider that window a successful promotional period. If no such window exists, return -1. n = len(data) if n < k: return -1 def days_with_more_visitors(window): return sum(1 for x in window if x > threshold) min_days = float(\'inf\') for i in range(n - k + 1): window = data[i:i + k] days = days_with_more_visitors(window) if days > 0: min_days = min(min_days, days) return min_days if min_days != float(\'inf\') else -1"},{"question":"Given a string `colors` where each character represents the color of a balloon, you can remove two consecutive balloons of different colors and gain `1 point` for each pair removed. Return the _maximum points_ you can gain by removing pairs of consecutive balloons of different colors until no more such pairs can be removed.","solution":"def max_points(colors): stack = [] points = 0 for color in colors: if stack and stack[-1] != color: stack.pop() points += 1 else: stack.append(color) return points"},{"question":"You are given two integer arrays `arr1` and `arr2` of size `n` and `m` respectively. An _increasing subsequence_ is a subsequence that appears in the same order as the array and each of its elements is greater than its predecessor. We define a _common increasing subsequence_ of `arr1` and `arr2` as an increasing subsequence that is present in both arrays (not necessarily at the same indices). Write a function to find the length of the longest common increasing subsequence of `arr1` and `arr2`. Return the length of this subsequence.","solution":"def LCIS(arr1, arr2): Function to find the length of the longest common increasing subsequence of arr1 and arr2. Parameters: arr1 (list of int): The first array arr2 (list of int): The second array Returns: int: The length of the longest common increasing subsequence. n = len(arr1) m = len(arr2) # Create a table to store lengths of longest common increasing subsequence dp = [0] * m # Iterate through each element in arr1 for i in range(n): current_length = 0 for j in range(m): # If elements are same, update the dp table if arr1[i] == arr2[j]: if current_length + 1 > dp[j]: dp[j] = current_length + 1 # Update current_length to the length of longest subsequence found so far if arr1[i] > arr2[j]: if dp[j] > current_length: current_length = dp[j] # The length of longest common increasing subsequence will be the maximum value in dp table return max(dp) # Example usage # arr1 = [1, 2, 3, 4] # arr2 = [2, 3, 5, 6] # print(LCIS(arr1, arr2)) # Output should be 2 (\'2\' and \'3\')"},{"question":"You are given two strings `s` and `p`, containing only lowercase English letters. You need to write a function that checks if `p` is a permutation of a substring in `s`. In other words, find out if there is a substring in `s` that is an anagram of `p`. Return `true` if such a substring exists in `s`, otherwise return `false`. An anagram of a string is another string that contains the same characters, only the order of characters can be different. For example, given `s = \\"cbaebabacd\\"` and `p = \\"abc\\"`, return `true` since `cba`, `bac`, and `abc` are all permutations of `p` that appear in `s`. If `s = \\"af\\"` and `p = \\"be\\"`, return `false` since no permutation of `be` appears in `af`.","solution":"def is_permutation_of_substring(s, p): from collections import Counter p_counter = Counter(p) s_len = len(s) p_len = len(p) if p_len > s_len: return False for i in range(s_len - p_len + 1): if Counter(s[i:i+p_len]) == p_counter: return True return False"},{"question":"Create a function that, given a string `s` of lowercase letters and a list of queries, returns the answer for each query. Each query is represented by a list of two integers `[l, r]`, where `l` and `r` correspond to the indices (0-indexed) of the string `s`. The answer to each query is the number of distinct characters in the substring of `s` from index `l` to index `r`, inclusive. For example, given `s = \\"abca\\"` and `queries = [[0, 2], [1, 3], [2, 3]]`, the function should return `[3, 3, 2]`.","solution":"def distinct_characters_in_substrings(s, queries): Returns a list of the number of distinct characters in the substring of s from index l to index r inclusive for each query. :param s: A string of lowercase letters. :param queries: A list of queries, where each query is a list of two integers [l, r]. :return: A list of integers representing the number of distinct characters for each query. result = [] for l, r in queries: substring = s[l:r+1] distinct_chars = set(substring) result.append(len(distinct_chars)) return result"},{"question":"Given a positive integer `n`, return _the smallest positive integer that is a multiple of both 2 and `n`_. The solution should work efficiently even for larger values of `n`.","solution":"def smallest_multiple_of_2_and_n(n): Returns the smallest positive integer that is a multiple of both 2 and n. return n if n % 2 == 0 else n * 2"},{"question":"Given a **0-indexed** array of integers `heights` representing the heights of buildings, calculate the amount of water trapped between the buildings after it rains. Implement a method: * `int trap(int[] heights)` which returns the total amount of rainwater trapped. Note: Water is trapped if there are buildings higher on both sides of the current building. The amount of water trapped on top of such a building is determined by the shortest height of the taller buildings on either side minus the height of the current building.","solution":"def trap(heights): Calculates the amount of water trapped between the buildings after it rains. Parameters: heights (list of int): A list of non-negative integers representing the heights of buildings. Returns: int: The total amount of rainwater trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total water trapped total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"Given a matrix `grid` of size `m x n` consisting of only `0`s and `1`s, you need to find the largest square containing only `1`s and return its area. The square must be formed by `1`s in the matrix and cannot include any `0`. Write a function `maximalSquare` that takes in `grid` and returns the area of the largest square containing only `1`s. Your function should efficiently compute the largest possible square by leveraging dynamic programming to track the maximum length of a square ending at each cell in the matrix. Example: ``` Input: grid = [ [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ] Output: 4 ``` Explanation: The largest square containing only `1`s has an area of 4.","solution":"def maximalSquare(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if grid[i - 1][j - 1] == \'1\': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given an array of integers `nums`. For each integer in the array, you can choose to either double it or keep it unchanged. Additionally, you can perform exactly one replacement operation, where you replace any integer in the array with any integer of your choice. Return `true` if it is possible to make the array strictly increasing by following the mentioned operations and `false` otherwise.","solution":"def can_make_strictly_increasing(nums): Returns whether it is possible to make the array strictly increasing by doubling elements or performing one replacement operation. def is_strictly_increasing(arr): return all(arr[i] < arr[i+1] for i in range(len(arr) - 1)) def with_one_change(nums): for i in range(len(nums)): original = nums[i] for replacement in [max(nums) + 1, min(nums) - 1]: # considering values outside the current array nums[i] = replacement if is_strictly_increasing(nums): return True nums[i] = original return False if is_strictly_increasing(nums): return True original = nums[:] doubled_attempts = [ [num * 2 if i == j else num for i, num in enumerate(nums)] for j in range(len(nums)) ] for attempt in doubled_attempts: if is_strictly_increasing(attempt): return True return with_one_change(nums)"},{"question":"Given an `m x n` matrix of integers representing the heights of buildings in a city, where the value at each cell represents the height of the building at that location, determine how many buildings have an unobstructed view of the skyline. A building has an unobstructed view if all buildings to the left, right, above, and below it are shorter. Implement a function `int countUnobstructedBuildings(int[][] heights)` that takes the matrix of building heights and returns the count of buildings with an unobstructed view. **Note:** - A building at location (i, j) has an unobstructed view if for all k in the range [0, n-1], heights[i][k] < heights[i][j] (for rows) and for all k in the range [0, m-1], heights[k][j] < heights[i][j] (for columns).","solution":"def countUnobstructedBuildings(heights): Returns the count of buildings with an unobstructed view. if not heights or not heights[0]: return 0 m, n = len(heights), len(heights[0]) unobstructed_count = 0 for i in range(m): for j in range(n): height = heights[i][j] unobstructed = all(heights[i][k] < height for k in range(n) if k != j) and all(heights[k][j] < height for k in range(m) if k != i) if unobstructed: unobstructed_count += 1 return unobstructed_count"},{"question":"Consider a singly linked list where each node contains a unique positive integer as its value. Write a function to detect and return the starting node of the cycle in the linked list if a cycle exists. If there is no cycle, return `null`. You are required to solve this problem using O(1) (constant) space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detects the starting node of the cycle in a linked list. If no cycle is present, returns None. Uses Floyd\'s Tortoise and Hare algorithm for cycle detection. if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle detected if not fast or not fast.next: return None # Find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Write a function that takes in a string containing an arithmetic expression with parenthesis, and returns the result of the evaluation. The string can contain the characters \'+\', \'-\', \'*\', \'/\', \'(\', \')\' and whitespace. It is assured that the given string is a valid arithmetic expression. **Note:** You are **not** allowed to use any built-in function which evaluates expressions such as `eval()`.","solution":"def evaluate_expression(expression): def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_operation(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return a // b if a * b > 0 else -(-a // b) def compute(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue elif tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while ops and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_operation(val1, val2, op)) ops.pop() else: while (ops and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_operation(val1, val2, op)) ops.append(tokens[i]) i += 1 while ops: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_operation(val1, val2, op)) return values[0] return compute(expression)"},{"question":"Given an array of integers `nums` and an integer `k`, return the length of the longest contiguous subarray that contains at most `k` distinct integers. If there are multiple subarrays with the same maximum length, return the length of any one of them. For example: - Input: `nums = [1, 2, 1, 2, 3, 3, 4], k = 2` - Output: `4` Explanation: The longest subarray with at most 2 distinct integers is `[1, 2, 1, 2]` or `[2, 1, 2, 3]`. Note: Your solution should have a time complexity better than O(n^2).","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest contiguous subarray that contains at most `k` distinct integers. from collections import defaultdict count = defaultdict(int) max_len = 0 left = 0 for right in range(len(nums)): count[nums[right]] += 1 while len(count) > k: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an `m x n` matrix `mat` where every cell represents the height of the terrain at that point, return all the points (i.e., coordinates) that can flow water to both the Pacific and Atlantic oceans. The Pacific Ocean touches the left and top edges of the matrix, and the Atlantic Ocean touches the right and bottom edges. Water can flow from a cell to any of its four adjacent cells with height equal to or lower than the current cell.","solution":"def pacific_atlantic(mat): if not mat or not mat[0]: return [] def dfs(matrix, visited, i, j): visited.add((i, j)) for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)): if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (x, y) not in visited and matrix[x][y] >= matrix[i][j]: dfs(matrix, visited, x, y) m, n = len(mat), len(mat[0]) pacific_reachable = set() atlantic_reachable = set() for i in range(m): dfs(mat, pacific_reachable, i, 0) dfs(mat, atlantic_reachable, i, n - 1) for j in range(n): dfs(mat, pacific_reachable, 0, j) dfs(mat, atlantic_reachable, m - 1, j) return list(pacific_reachable & atlantic_reachable)"},{"question":"Given an array of positive integers `arr`, you can perform the following operation on the array: Choose any two adjacent elements and replace them with their sum. This operation reduces the number of elements in the array by one. Your task is to output the minimum sum that can be obtained by repeatedly performing the described operation until only one element remains in the array. Write a function `min_final_sum(arr)` that takes an array of positive integers as input and returns the minimum sum that can be achieved.","solution":"def min_final_sum(arr): Returns the minimum sum that can be obtained by repeatedly performing the operation of replacing any two adjacent elements with their sum until only one element remains. # The minimum sum that can be obtained is actually the sum of all elements in the array. return sum(arr)"},{"question":"You are given an **0-indexed** array of integers `nums` of length `n` and an integer `k`. A subarray is called balanced if its minimum and maximum elements differ by at most `k`. Return the number of balanced subarrays contained in `nums`. A subarray is a contiguous part of an array. Subarrays that differ only in their starting or ending positions but not in the sequence of elements they contain are counted as different subarrays.","solution":"def count_balanced_subarrays(nums, k): from collections import deque def count_windows_subarrays(arr, k): min_deque, max_deque = deque(), deque() left = 0 count = 0 for right, value in enumerate(arr): while min_deque and arr[min_deque[-1]] >= value: min_deque.pop() while max_deque and arr[max_deque[-1]] <= value: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() count += right - left + 1 return count return count_windows_subarrays(nums, k)"},{"question":"Given a list of integers `nums`, sorted in non-decreasing order, and an integer `target`, return _the starting and ending position of the target value in the list_. If the target is not found, return _[-1, -1]_. Optimize the algorithm to run in O(log n) time.","solution":"def search_range(nums, target): Searches for the starting and ending positions of the target in the list. :param nums: List of integers sorted in non-decreasing order :param target: Integer value to search for :return: List with starting and ending positions of target or [-1, -1] if not found def find_left_most(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right_most(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_most = find_left_most(nums, target) right_most = find_right_most(nums, target) if left_most <= right_most and left_most < len(nums) and nums[left_most] == target: return [left_most, right_most] else: return [-1, -1]"},{"question":"You are given a **binary** string `s` consisting of only `0` and `1`. A subsequence is called **stable** if it contains an **equal** number of `0`s and `1`s. The **stability** of the binary string `s` is the length of the longest stable subsequence in `s`. Return an integer representing the **stability** of the given binary string.","solution":"def binary_string_stability(s): Finds the stability of the binary string \'s\' which is the length of the longest subsequence with an equal number of \'0\'s and \'1\'s. Parameters: s (str): The binary string consisting of \'0\' and \'1\'. Returns: int: The length of the longest stable subsequence. count_0 = s.count(\'0\') count_1 = s.count(\'1\') return 2 * min(count_0, count_1)"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to find the two distinct elements in the list that sum up to the `target` integer. If there are multiple pairs that sum up to the target, return the pair with the smallest index for the first number in the pair; if there are multiple pairs with the same index for the first number, return the pair with the smallest index for the second number. Return the indices of these two numbers in a list. You may assume that each input would have exactly one solution, and you may not use the same element twice.","solution":"def two_sum(nums, target): Find two distinct elements in the list that sum up to the target and return their indices. If there are multiple pairs, return the pair with the smallest index for the first number, and if there are ties, the smallest index for the second number. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"You are given an array of integers `arr` and an integer `x`. Your task is to determine if there exists a subset of `arr` such that the sum of its elements is exactly `x`. Return `true` if such a subset exists, and `false` otherwise. Each element in `arr` can only be used once in the subset. For example: - If `arr = [3, 34, 4, 12, 5, 2]` and `x = 9`, the function should return `true` because there is a subset `[4, 5]` which sums up to `9`. - If `arr = [1, 2, 3, 7, 8]` and `x = 14`, the function should return `true` because there is a subset `[7, 7]` which sums up to `14`. - If `arr = [1, 2, 5]` and `x = 10`, the function should return `false` because there is no subset that sums up to `10`.","solution":"def subset_sum(arr, x): Determines if there is a subset of `arr` that sums up to `x`. Parameters: arr (List[int]): The list of integers to check. x (int): The target sum. Returns: bool: True if there is a subset of `arr` that sums to `x`, False otherwise. n = len(arr) dp = [[False] * (x + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, x + 1): if j < arr[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] return dp[n][x]"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` where `n` is even. The array is composed of pairs of integers, where the integer at index `2i` represents the number of **buyers** interested in a particular product, and the integer at index `2i+1` represents the number of **sellers** for the same product. Each product can only be bought or sold by one entity at a time, and a buyer cannot buy from multiple sellers for the same product. Your task is to determine the maximum number of successful transactions that can be made. Return _the **maximum number** of successful transactions possible_.","solution":"def max_successful_transactions(nums): Determines the maximum number of successful transactions that can be made. Parameters: nums (list of int): A list of integers where even indices represent buyers and odd indices represent sellers. Returns: int: The maximum number of successful transactions possible. max_transactions = 0 for i in range(0, len(nums), 2): buyers = nums[i] sellers = nums[i + 1] max_transactions += min(buyers, sellers) return max_transactions"},{"question":"Company XYZ is planning a project that involves completing a series of tasks. Each task is represented as a node in a directed acyclic graph (DAG). The edges between nodes indicate dependencies where a task must be completed before another can begin. The company wants a schedule that ensures all tasks are completed as early as possible while respecting task dependencies. You are given: - `n` representing the number of tasks, labeled from `1` to `n`. - A 2D integer array `dependencies`, where `dependencies[i] = [a, b]` indicates that task `a` must be completed before task `b`. Implement a function `taskOrder` that returns an integer array representing an order in which to complete the tasks such that all task dependencies are respected. If there are multiple valid orders, return any of them. If it\'s impossible to complete all tasks due to cyclic dependencies, return an empty array. **Details:** - `1 <= n <= 10^5` - `edges.length <= 10^5` - Each task can have zero or more dependencies.","solution":"from collections import defaultdict, deque def taskOrder(n, dependencies): Returns an order in which to complete the tasks such that all task dependencies are respected. If there are cycle dependencies, returns an empty list. :param n: int - Number of tasks :param dependencies: List[List[int]] - List of dependencies :return: List[int] - Order of task completion # Initialize graph and indegree count graph = defaultdict(list) indegree = {i: 0 for i in range(1, n+1)} # Build the graph and populate indegree counts for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Initialize the queue with tasks having no dependencies queue = deque([node for node in indegree if indegree[node] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If order contains all tasks, return the order. # Otherwise, there is a cycle, and we return an empty list. if len(order) == n: return order else: return []"},{"question":"You are given an array of integers `nums`. We define a slicing operation that operates on a subarray of `nums` to reverse the order of the elements within that subarray. Return the minimum number of slicing operations required to make the entire array sorted in non-decreasing order. Note that you can perform slicing operations on subarrays of any length, including length one (which effectively does nothing), but the smaller the number of operations, the better.","solution":"def min_slicing_operations(nums): Returns the minimum number of slicing operations required to sort nums in non-decreasing order. if not nums: return 0 sorted_nums = sorted(nums) n = len(nums) start, end = None, None for i in range(n): if nums[i] != sorted_nums[i]: if start is None: start = i end = i if start is None: return 0 # Already sorted if nums[start:end+1] == sorted_nums[start:end+1][::-1]: return 1 return 2"},{"question":"You are given the head of a singly linked list. The nodes in the linked list are numbered sequentially from `1` to `n`, where `n` is the total number of nodes. A node in the linked list can be represented by an object containing two fields: an integer value and a pointer to the next node. Implement the function `removeNthFromEnd` which takes the head of the list and an integer `n`, and removes the `n`-th node from the end of the list and returns the head of the modified list. Consider the following prototype: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: # Your implementation here ``` Example: - Given linked list: `1->2->3->4->5`, and `n = 2`. - After removing the 2nd node from the end, the linked list becomes `1->2->3->5`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: # Create a dummy node which acts as a predecessor of the head node dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first pointer n+1 steps ahead for _ in range(n + 1): first = first.next # Move first to the end, maintaining the gap between first and second while first is not None: first = first.next second = second.next # Now second pointer is just before the node to be removed second.next = second.next.next return dummy.next"},{"question":"Given a string `s`, your goal is to form a palindrome by removing at most one character from the string. Return _a boolean indicating whether it is possible to make the string a palindrome by removing at most one character._","solution":"def valid_palindrome(s): Check if the string can become a palindrome by removing at most one character. def is_palindrome_range(i, j): Check if the substring s[i:j] is a palindrome. return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing one character either left or right return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). For example, if `x = 123`, then the result should be `321`. If `x = -123`, then the result should be `-321`. If `x = 120`, then the result should be `21`.","solution":"def reverse(x): Reverses the digits of a signed 32-bit integer. If the reverse causes the value to fall outside the signed 32-bit integer range, returns 0. negative = x < 0 x = abs(x) reversed_x = int(str(x)[::-1]) # Apply the negative sign if the original number was negative if negative: reversed_x = -reversed_x # Check if the reversed number falls outside the signed 32-bit integer range if reversed_x < -2**31 or reversed_x > 2**31 - 1: return 0 return reversed_x"},{"question":"You are given a sorted array `nums` of integers and an integer `target`. Your task is to determine the number of unique triplets in the array that can form the triplet sum closest to `target`. If there are multiple triplet sums equally close to the `target`, return the number of those triplets. Each triplet should be considered only once, even if similar triplets exist in different positions in the array.","solution":"def count_unique_triplets(nums, target): Determine the number of unique triplets in the array that can form the triplet sum closest to the target. If there are multiple triplet sums equally close to the target, return the number of those triplets. nums.sort() n = len(nums) closest_sum = float(\'inf\') closest_triplets = set() for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return len(set([(nums[i], nums[left], nums[right])])) if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum closest_triplets = {(nums[i], nums[left], nums[right])} elif abs(target - current_sum) == abs(target - closest_sum): closest_triplets.add((nums[i], nums[left], nums[right])) if current_sum < target: left += 1 else: right -= 1 return len(closest_triplets)"},{"question":"You are given an array of strings `words` and a string `pattern`. Return _a list of all the strings in_ `words` _that match the pattern_. A string follows the same pattern if there is a permutation of letters such that `words[i]` can match the given `pattern`. You may assume that both input strings and patterns only contain lowercase letters. # Example: ``` Input: words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], pattern = \\"abb\\" Output: [\\"mee\\", \\"aqq\\"] ``` # Explanation: ``` \\"mee\\" matches the pattern because if you map \'m\' -> \'a\', \'e\' -> \'b\', \'e\' -> \'b\', you get \\"abb\\". \\"aqq\\" matches the pattern because if you map \'a\' -> \'a\', \'q\' -> \'b\', \'q\' -> \'b\', you get \\"abb\\". ```","solution":"def find_and_replace_pattern(words, pattern): def matches(word): if len(word) != len(pattern): return False char_map = {} reverse_char_map = {} for w, p in zip(word, pattern): if w not in char_map: char_map[w] = p if p not in reverse_char_map: reverse_char_map[p] = w if char_map[w] != p or reverse_char_map[p] != w: return False return True return [word for word in words if matches(word)]"},{"question":"You are given a string `text` comprising lowercase English letters and an integer `k`. Your task is to return the `k`-th distinct substring of `text` when the substrings are sorted in lexicographical order. If there are fewer than `k` distinct substrings, return an empty string. A substring is defined as a contiguous sequence of characters within the string. For example, in the string `\\"abc\\"`, the distinct substrings are `\\"a\\"`, `\\"b\\"`, `\\"c\\"`, `\\"ab\\"`, `\\"bc\\"`, and `\\"abc\\"`.","solution":"def kth_distinct_substring(text, k): Returns the k-th distinct substring sorted in lexicographical order. If there are fewer than k distinct substrings, return an empty string. substrings = set() for i in range(len(text)): for j in range(i + 1, len(text) + 1): substrings.add(text[i:j]) sorted_substrings = sorted(substrings) if k-1 < len(sorted_substrings): return sorted_substrings[k-1] else: return \\"\\""},{"question":"Given an integer array `arr`, return the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to `1`.","solution":"def longest_subarray(arr): if not arr: return 0 max_len = 0 for i in range(len(arr)): min_elem = arr[i] max_elem = arr[i] for j in range(i, len(arr)): min_elem = min(min_elem, arr[j]) max_elem = max(max_elem, arr[j]) if max_elem - min_elem <= 1: max_len = max(max_len, j - i + 1) else: break return max_len"},{"question":"A sequence of integers is called an **Arithmetic Array** if the difference between consecutive elements is the same. Given an integer array `nums` of length `n`, return the length of the longest arithmetic subarray. An arithmetic subarray is a contiguous subarray of `nums` that forms an arithmetic sequence. For example, in the array `nums = [10, 7, 4, 6, 8, 10, 11]`, the longest arithmetic subarray is `[4, 6, 8, 10]`, with a length of 4. If there are multiple answers, return the length of any one of them.","solution":"def longest_arithmetic_subarray(nums): Returns the length of the longest arithmetic subarray. if len(nums) < 2: return len(nums) max_length = 0 current_length = 1 last_diff = None for i in range(1, len(nums)): current_diff = nums[i] - nums[i - 1] if current_diff == last_diff: current_length += 1 else: last_diff = current_diff current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"Given a `linked list` where each node contains a single digit, write a function to add the two numbers and return the sum as a linked list. Each input linked list contains non-negative numbers stored such that the `most significant digit` comes first. The digits are stored in `reverse order`, and each of their nodes contain a single digit. You may assume the two numbers do not contain any leading zero, except the number `0` itself.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented by linked lists l1 and l2, and returns the sum as a linked list. dummy = ListNode() current = dummy carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy.next"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to return the maximum sum of a subarray of size `k`. A subarray is a contiguous portion of an array. **Note:** If the length of `nums` is less than `k`, return `0`. Implement the function `maxSubarraySum(nums, k)`: ```python def maxSubarraySum(nums, k): # your code goes here ``` **Example:** ```python # Example 1: nums = [2, 1, 5, 1, 3, 2] k = 3 Output: 9 # Explanation: The subarray with maximum sum is [5, 1, 3]. ``` ```python # Example 2: nums = [2, 3] k = 3 Output: 0 # Explanation: Since the length of nums is less than k, return 0. ```","solution":"def maxSubarraySum(nums, k): Returns the maximum sum of a subarray of size k. n = len(nums) if n < k: return 0 max_sum = float(\'-inf\') current_sum = 0 # Compute the sum of the first `k` elements for i in range(k): current_sum += nums[i] max_sum = current_sum # Slide the window from start to end in array for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a 2D integer matrix `grid`, where each integer represents the height of a building at that location, calculate the total increase in building height while keeping the city skyline visible from top/bottom and left/right unchanged. The skyline is the maximum heights of buildings viewed from each direction. Adjust the heights of buildings in `grid` only if they do not alter these skylines. For example, given the following `grid`: [[3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0]] The new grid with heights adjusted to maintain the original skyline is: [[3, 3, 8, 4], [2, 4, 5, 7], [9, 4, 6, 3], [3, 3, 3, 3]] Return the **total increase** in building height after making these adjustments.","solution":"def max_increase_keeping_skyline(grid): Calculates the total increase in building heights while keeping the city skyline unchanged. :param grid: List[List[int]], a 2D integer matrix representing the heights of buildings. :return: int, total increase in building height. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) max_row = list(map(max, grid)) max_col = list(map(max, zip(*grid))) total_increase = 0 for i in range(n): for j in range(m): new_height = min(max_row[i], max_col[j]) total_increase += new_height - grid[i][j] return total_increase"},{"question":"Given an array of integers `heights` representing the heights of columns of water containers, calculate the maximum amount of water that can be trapped between the columns after it rains. The water cannot overflow the columns, and it is trapped between the higher columns. Return the total trapped water amount.","solution":"def trap(heights): Calculate the maximum amount of water that can be trapped between the columns after it rains. :param heights: List of integers representing the heights of columns. :return: Integer representing the total trapped water amount. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"You are given an integer `k` and an integer array `arr` of length `n`. You need to determine whether you can rearrange the elements of `arr` such that the sum of every contiguous subarray of length `k` is the same. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_rearrange_subarray_sum_k(arr, k): Determine if elements of arr can be rearranged such that the sum of every contiguous subarray of length k is the same. :param arr: List[int], list of integers :param k: int, length of the subarrays :return: bool, True if possible, False otherwise # The length of array n = len(arr) # Early exit: If k is larger than n, it\'s impossible to have any subarray of length k if k > n: return False # Total sum of all the elements in the array total_sum = sum(arr) # Check if the total sum is divisible by number of subarrays of length k (n // k) our_target_total_sum = total_sum / (n // k) if int(our_target_total_sum) != our_target_total_sum: return False our_target_total_sum = int(our_target_total_sum) # Potentially try converting this to a complete mathematical problem # and solve for party sums. # Sort the array arr.sort() subarray_sum = sum(arr[:k]) # Check if sum of every contiguous subarray of length k is equal to target_sum if subarray_sum != our_target_total_sum: return False sliding_window_sum = subarray_sum for i in range(1, n - k + 1): # Sliding window sum sliding_window_sum = sliding_window_sum - arr[i-1] + arr[i + k - 1] if sliding_window_sum != our_target_total_sum: return False # If all the checks passed, return True return True"},{"question":"Given a binary string `s`, you need to find the length of the longest contiguous substring that contains an equal number of `0s` and `1s`. The binary string consists only of the characters `0` and `1`. Write a function `int findMaxLength(String s)` that takes the binary string `s` as input and returns the length of the longest contiguous substring with equal count of `0s` and `1s`.","solution":"def findMaxLength(s): Finds the length of the longest contiguous substring with equal number of 0s and 1s. count = 0 max_length = 0 count_map = {0: -1} for i, char in enumerate(s): count += 1 if char == \'1\' else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"You are given a list of `n` courses to be completed, represented by an array `courses` where `courses[i] = [durationi, endTimei]`. Each `durationi` represents the number of days it takes to complete course `i`, and `endTimei` represents the last day by which the course must be finished (inclusive). You need to determine the maximum number of courses that can be taken. You can only take one course at a time, and you may only enroll in a course if you can complete it by its endTime. Return _the maximum number of courses that can be taken_.","solution":"import heapq def schedule_courses(courses): # Sort courses by their end time courses.sort(key=lambda x: x[1]) total_time = 0 max_courses = [] for duration, end_time in courses: if total_time + duration <= end_time: heapq.heappush(max_courses, -duration) total_time += duration elif max_courses and -max_courses[0] > duration: total_time += duration + heapq.heappop(max_courses) heapq.heappush(max_courses, -duration) total_time -= -max_courses[0] return len(max_courses)"},{"question":"**[Question 4]:** You are given an array of positive integers `arr` representing the heights of columns of coins. A column at position `i` can have `arr[i]` coins stacked on top of each other. Each time you can choose any one of the non-empty columns and remove exactly one coin from the top of that column. Calculate the minimum number of rounds required to make two or more columns have the same number of coins. A round consists of choosing any one non-empty column and removing one coin. If it is not possible to achieve this configuration, return `-1`.","solution":"def min_rounds_to_equal_columns(arr): Returns the minimum number of rounds required to make two or more columns have the same number of coins. If it is not possible to achieve this configuration, return -1. # Create a dictionary to count frequency of each height height_freq = {} for height in arr: if height in height_freq: height_freq[height] += 1 else: height_freq[height] = 1 # Check if there are already any two columns with the same number of coins for freq in height_freq.values(): if freq >= 2: return 0 # Find the smallest difference between any two different column heights height_list = sorted(height_freq.keys()) min_diff = float(\'inf\') for i in range(1, len(height_list)): min_diff = min(min_diff, height_list[i] - height_list[i-1]) # If no min_diff found or min_diff is infinite, return -1 if min_diff == float(\'inf\'): return -1 # Return the min_diff as the minimum number of rounds required return min_diff"},{"question":"You are given an integer array `nums`. An array is called \\"nice\\" if there are no three consecutive integers in it. Your task is to modify the array without changing the order of the elements by removing the minimum number of elements needed to make the array \\"nice\\". Return _the minimum number of elements you need to remove from `nums` to make it \\"nice\\"_.","solution":"def make_nice(nums): Removes the minimum number of elements from nums to ensure there are no three consecutive integers in the array. if len(nums) <= 2: return 0 removals = 0 i = 2 while i < len(nums): if nums[i] == nums[i-1] == nums[i-2]: removals += 1 i += 1 i += 1 return removals"},{"question":"You are given a list of `n` integers `arr`, where each integer represents the number of votes a candidate received in an election. Candidates are labeled from `1` to `n`. Your task is to determine if there is a candidate who received strictly more than half of the total votes. If such a candidate exists, return their label. If no such candidate exists, return `-1`. Return _the label of the candidate who received more than half of the total votes, or `-1` if no such candidate exists._","solution":"def find_majority_candidate(arr): Returns the label of the candidate who received strictly more than half of the total votes, or -1 if no such candidate exists. n = len(arr) total_votes = sum(arr) half_votes = total_votes / 2 for i in range(n): if arr[i] > half_votes: return i + 1 # Candidate labels are 1-based (1 to n) return -1"},{"question":"Given a binary tree, return the **right side view** of the tree. The right side view of a binary tree is the set of nodes visible when the tree is viewed from the right side. Note that this description assumes a binary tree defined by the standard TreeNode class, where each node has a value, a left child, and a right child. Return _an array of the values visible from the right side view_.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the right side view of the binary tree rooted at root. if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"You are given a binary tree where each node has a value `val` from `0` to `4`. Each step, you can choose one or multiple nodes at the current level and swap their subtrees. Distance between two nodes is the number of edges along the shortest path connecting them. Your task is to determine the minimum number of swaps required so that all nodes\' subtrees are in increasing order of their `val` starting from the root. Return the minimum number of swaps required.","solution":"def min_swaps_to_sort(arr): Helper function to count the minimum number of swaps required to sort an array. n = len(arr) arrpos = [(val, idx) for idx, val in enumerate(arr)] arrpos.sort() visited = {k: False for k in range(n)} ans = 0 for i in range(n): if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][1] cycle_size += 1 if cycle_size > 0: ans += cycle_size - 1 return ans def level_order_traversal(node): Helper function to get the level order traversal values of a binary tree. from collections import deque if not node: return [] q = deque([node]) result = [] while q: level_size = len(q) current_level = [] for _ in range(level_size): current_node = q.popleft() current_level.append(current_node.val) if current_node.left: q.append(current_node.left) if current_node.right: q.append(current_node.right) result.append(current_level) return result def min_swaps_binary_tree(root): Function to calculate the minimum number of swaps required so that all nodes\' subtrees are in increasing order of their `val`. levels = level_order_traversal(root) total_swaps = 0 for level in levels: total_swaps += min_swaps_to_sort(level) return total_swaps class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right"},{"question":"You are given an array of integers `nums` and an integer `k`. A continuous subarray of `nums` is defined to be good if its length is at least `k` and the sum of the subarray is greater than or equal to the sum of any preceding subarray of length `k`. Return the length of the shortest good subarray. If no such subarray exists, return `-1`.","solution":"def shortest_good_subarray(nums, k): Return the length of the shortest good subarray. If no such subarray exists, return -1. n = len(nums) if n < k: return -1 max_sum_k = sum(nums[:k]) current_sum = max_sum_k min_length = float(\'inf\') for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum >= max_sum_k: max_sum_k = current_sum min_length = k current_sum = sum(nums[:k]) for start in range(1, n - k + 1): end = start + k current_sum += nums[end - 1] - nums[start - 1] if current_sum == max_sum_k: min_length = min(min_length, end - start + 1) for end in range(start + k, n): current_sum += nums[end] - nums[end - k] if current_sum >= max_sum_k and (end - start + 1) > k: min_length = min(min_length, end - start + 1) break return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of stones in various piles. In one move, you can choose any pile of stones and divide it into two smaller heaps. The resulting two heaps are added to the list of piles. Your goal is to minimize the largest pile of stones possible after performing exactly `k` moves. Return the minimum possible value of the largest pile after exactly `k` moves.","solution":"import heapq def minimize_largest_pile(nums, k): Minimizes the largest pile of stones possible after performing exactly k moves. max_heap = [-x for x in nums] heapq.heapify(max_heap) for _ in range(k): largest_pile = -heapq.heappop(max_heap) half_1 = largest_pile // 2 half_2 = largest_pile - half_1 heapq.heappush(max_heap, -half_1) heapq.heappush(max_heap, -half_2) return -max_heap[0]"},{"question":"You are given an integer array `heights` that represents the heights of buildings in a cityscape, where the width of each building is 1. The skyline is viewed from the left, and each building blocks the view of any shorter buildings behind it. Write a function `visibleBuildings` that takes an array `heights` and returns an array where each element indicates whether the corresponding building in `heights` is visible from the left. A building is considered visible if there are no taller buildings before it. For example, given the input `heights = [3, 5, 4, 2, 6, 1]`, your function should return `[True, True, False, False, True, False]`.","solution":"def visibleBuildings(heights): This function returns a list of booleans indicating whether the buildings are visible from the left. :param heights: List of integers representing the heights of the buildings. :return: List of booleans indicating visibility of buildings from the left. if not heights: return [] n = len(heights) visible = [False] * n max_height = 0 for i in range(n): if heights[i] > max_height: visible[i] = True max_height = heights[i] return visible"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of students standing in a line. The students are allowed to rearrange themselves but must maintain non-decreasing order in terms of their assigned id. Each student has a unique id from `0` to `n-1` where `n` is the length of the array. The id of each student is implicitly given by their position in the array (i.e., `heights[i]` represents the height of the student with id `i`). A team is defined as a contiguous segment of the array where the heights of the students are in non-decreasing order. Return _the length of the **longest team** that can be formed by rearranging the students while maintaining their assigned ids._","solution":"def longest_non_decreasing_team(heights): n = len(heights) # Initialize dp array where dp[i] represents the length of the longest team ending at index i dp = [1] * n for i in range(1, n): if heights[i] >= heights[i - 1]: dp[i] = dp[i - 1] + 1 # The result is the maximum value in dp array return max(dp)"},{"question":"You are given an integer array `heights` representing the heights of buildings along a line. The buildings have the same width of `1`. The goal is to find the volume of water it can trap after raining. The water is trapped by building heights looking like a histogram with bars. Return the total volume of water that can be trapped between the buildings. For example, given the array `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the total volume of trapped water is `6`. Write a function: ```python def trap(heights: List[int]) -> int: # Your code here ``` You may assume that: - `1 <= len(heights) <= 1000` - `0 <= heights[i] <= 1000`","solution":"from typing import List def trap(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Given a list of integers `nums` consisting of `n` elements, and an integer target `k`, return the **minimum sum of any contiguous subarray** of length `k` in `nums`. If the array has less than `k` elements, return -1.","solution":"def min_sum_subarray(nums, k): Returns the minimum sum of any contiguous subarray of length k in nums. If the array has less than k elements, returns -1. n = len(nums) if n < k: return -1 min_sum = sum(nums[:k]) current_sum = min_sum for i in range(k, n): current_sum += nums[i] - nums[i - k] min_sum = min(min_sum, current_sum) return min_sum"},{"question":"A **binary tree** is a tree data structure in which each node has at most two children, referred to as the left child and the right child. Given the `root` of a binary search tree (BST) and a `node` in it, find the **in-order successor** of that node in the BST. The in-order successor of a node `p` is the node with the smallest key greater than `p.val`. If the given node has no in-order successor in the tree, return `null`. The best solution should be efficient with respect to both time and space complexity. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderSuccessor(root: TreeNode, p: TreeNode) -> Optional[TreeNode]: pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderSuccessor(root: TreeNode, p: TreeNode) -> \'TreeNode\': successor = None while root: if p.val >= root.val: root = root.right else: successor = root root = root.left return successor"},{"question":"Given an `m x n` grid containing only characters `\'A\'` and `\'B\'`, where you can move right or down from any cell to another cell containing the same character, return the total number of distinct connected groups of characters in the grid. A **connected group** is a collection of cells containing the same character, where each cell is adjacent to at least one other cell in the same group by either being directly to the left, right, above, or below.","solution":"def count_connected_groups(grid): This function returns the number of distinct connected groups of characters (\'A\' or \'B\') in the grid. def dfs(x, y, char): if (x < 0 or x >= len(grid)) or (y < 0 or y >= len(grid[0])) or (grid[x][y] != char): return grid[x][y] = \'#\' for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, char) if not grid or not grid[0]: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] in \'AB\': dfs(i, j, grid[i][j]) count += 1 return count"},{"question":"You are given an array of integers `nums` representing coordinates on a line, where each integer denotes a position occupied by a person. A person can move to any adjacent position (i.e., position+1 or position-1) in a single step. Determine the minimum number of steps required for all persons to meet at a single position. Return _the minimum number of steps required for all persons to converge at a single position_.","solution":"def min_steps_to_converge(nums): Given an array of integers `nums` representing coordinates on a line, returns the minimum number of steps required for all persons to converge at a single position. The optimal meeting point in one dimension is the median of the coordinates. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"You are given two integer arrays, `arr1` and `arr2`, both of the same length. The task is to form a new array (`result`) where each element `result[i]` is the **maximum** value of `arr1[i]` and `arr2[i]`. Return the `result` array.","solution":"def max_array_elements(arr1, arr2): Returns an array where each element is the maximum value between the corresponding elements of arr1 and arr2. Parameters: arr1 (list of int): The first input array. arr2 (list of int): The second input array. Returns: list of int: An array containing the maximum values between arr1 and arr2. return [max(a, b) for a, b in zip(arr1, arr2)]"},{"question":"You are given an array `heights` representing the heights of buildings in a city where the width of each building is `1`. It starts from the leftmost building. The goal is to paint the skyline twice, once from the left and once from the right. The skyline is the outline formed by these buildings when viewed from a distance. Determine the height of the skyline at each position, after both paintings. To do this, you need to return an array `skyline` of the same length as `heights`. For every position `i`, `skyline[i]` should be the height of the tallest building seen so far from both directions (left and right). For example, given `heights` = [4, 2, 3, 1], the skyline heights seen from the left are [4, 4, 4, 4], and seen from the right are [4, 3, 3, 1]. Therefore, the final `skyline` array will be [4, 4, 4, 4]. Another example, if `heights` = [1, 3, 2, 4], the skyline heights seen from the left are [1, 3, 3, 4], and seen from the right are [4, 4, 4, 4]. Therefore, the final `skyline` array will be [4, 4, 4, 4]. Given `heights`, return the array `skyline`.","solution":"def compute_skyline(heights): n = len(heights) left_skyline = [0] * n right_skyline = [0] * n # Compute the skyline from the left left_max = 0 for i in range(n): left_max = max(left_max, heights[i]) left_skyline[i] = left_max # Compute the skyline from the right right_max = 0 for i in range(n - 1, -1, -1): right_max = max(right_max, heights[i]) right_skyline[i] = right_max # Combine the two skylines skyline = [max(left_skyline[i], right_skyline[i]) for i in range(n)] return skyline"},{"question":"You are given a 2D grid of size `m x n` representing a map of land and water cells. An island is a group of connected `1`s (land cells) separated by `0`s (water cells). Cells are connected horizontally or vertically (not diagonally). The number of distinct islands is represented by the number of distinct shapes of connected 1\'s. Two islands are considered distinct if and only if one island shape cannot be rotated or flipped to equal the other. Given the 2D grid `grid`, return _the total number of distinct island shapes_.","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, shape): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 shape.append(direction) dfs(x + 1, y, \'D\', shape) # Down dfs(x - 1, y, \'U\', shape) # Up dfs(x, y + 1, \'R\', shape) # Right dfs(x, y - 1, \'L\', shape) # Left shape.append(\'B\') # Backtrack shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, \'S\', shape) # Start a new island shape shapes.add(tuple(shape)) return len(shapes)"},{"question":"Given a `2D` integer array `points` where `points[i] = [x_i, y_i]` represents the coordinates of `points` on a plane, return _the number of pairs of points `(i, j)` such that the Manhattan distance between the two points is exactly `d`._ The Manhattan distance between two points `(x1, y1)` and `(x2, y2)` is defined as `|x1 - x2| + |y1 - y2|`.","solution":"def count_pairs_with_manhattan_distance(points, d): if not points: return 0 count = 0 n = len(points) for i in range(n): for j in range(i + 1, n): x1, y1 = points[i] x2, y2 = points[j] if abs(x1 - x2) + abs(y1 - y2) == d: count += 1 return count"},{"question":"Given a string `s` consisting of lowercase letters, you need to find the length of the longest substring with all unique characters. Return an integer representing the length of such substring.","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_len = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a binary tree, with each node having an integer value. Implement a function `findLongestConsecutiveSequence(root)` that returns the length of the longest sequence of consecutive integers (no matter the difference is +1 or -1) present in the path from the root to any leaf. Consecutive integers can be in any order (+1 or -1) but must be connected directly in the path. If the tree is empty, return 0. For example, given the binary tree: ``` 1 / 2 3 / 2 4 / / 3 5 ``` The longest consecutive sequence is `3-2-3` or `2-3-4-5`, and the function should return 4.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLongestConsecutiveSequence(root): def dfs(node): if not node: return 0, 0 inc, dec = 1, 1 left_inc, left_dec = dfs(node.left) right_inc, right_dec = dfs(node.right) if node.left: if node.val + 1 == node.left.val: inc = left_inc + 1 elif node.val - 1 == node.left.val: dec = left_dec + 1 if node.right: if node.val + 1 == node.right.val: inc = max(inc, right_inc + 1) elif node.val - 1 == node.right.val: dec = max(dec, right_dec + 1) longest[0] = max(longest[0], inc + dec - 1) return inc, dec longest = [0] dfs(root) return longest[0]"},{"question":"You are given an array of integers `arr` representing the amount of time required to prepare `n` dishes. You can prepare multiple dishes simultaneously, but only if their total time doesn\'t exceed a given `timeLimit`. Return the maximum number of dishes you can prepare within the `timeLimit` without exceeding it. If no dishes can be prepared without exceeding the `timeLimit`, return `0`.","solution":"def maxDishes(arr, timeLimit): Returns the maximum number of dishes that can be prepared without exceeding the timeLimit. arr.sort() total_time = 0 count = 0 for time in arr: if total_time + time <= timeLimit: total_time += time count += 1 else: break return count"},{"question":"Given an integer array `prices` representing the price of various items in a store, and another integer `budget` representing the amount of money you have. You want to buy two distinct items such that the total cost of the items is as close as possible to your budget but does not exceed it. Return the indices of the two items you should buy. If there are multiple pairs of items that satisfy this condition, return any pair. If no such pair exists, return `[-1, -1]`.","solution":"def find_two_items(prices, budget): Finds two distinct items such that the total cost does not exceed the budget and is as close as possible to the budget. Parameters: prices (list of int): List of prices of items. budget (int): Amount of money available. Returns: list of int: Indices of the two items to buy. If no such pair exists, returns [-1, -1]. best_pair = [-1, -1] best_sum = float(\'-inf\') for i in range(len(prices)): for j in range(i + 1, len(prices)): total = prices[i] + prices[j] if total <= budget and total > best_sum: best_sum = total best_pair = [i, j] return best_pair"},{"question":"You are given a list of events represented by a string `events` of length `n`, where each character represents a type of event occurring at a specific time unit. There are three types of events: \'A\', \'B\', and \'C\'. You need to process these events and determine the maximum number of non-overlapping subsequences that are each formed by consecutive occurrences of the same event type. Return _the count of such non-overlapping subsequences_. For example, given the input string `events = \\"AAABBBCCCABAB\\"`, the maximum number of non-overlapping subsequences would be 7. (Subsequences: \\"AAA\\", \\"BBB\\", \\"CCC\\", \\"A\\", \\"B\\", \\"A\\", \\"B\\").","solution":"def count_non_overlapping_subsequences(events): Returns the maximum number of non-overlapping subsequences of consecutive occurrences of the same event type. Args: events (str): A string of length `n` representing the events. Returns: int: The count of non-overlapping subsequences. if not events: return 0 count = 1 for i in range(1, len(events)): if events[i] != events[i-1]: count += 1 return count"},{"question":"You are given a **directed acyclic graph (DAG)** represented by a 2D integer array `edges` where `edges[i] = [fromi, toi]` indicates a directed edge from node `fromi` to node `toi`. There are `n` nodes labeled from `0` to `n-1`. You are also given an integer `start` and an integer `end`. Your task is to find the **longest path** from node `start` to node `end`. If there are multiple longest paths, you can return any of them. If there is no path from `start` to `end`, return an empty list. Return the list of nodes representing the longest path from `start` to `end`.","solution":"from collections import defaultdict, deque def longest_path_dag(n, edges, start, end): Finds the longest path in a directed acyclic graph (DAG) from start to end. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): List of directed edges in the graph. start (int): Starting node. end (int): Ending node. Returns: List[int]: A list of nodes representing the longest path from start to end. If there is no path, return an empty list. adj_list = defaultdict(list) in_degree = [0] * n distances = [-float(\'inf\')] * n predecessors = [-1] * n for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 distances[start] = 0 queue = deque([u for u in range(n) if in_degree[u] == 0]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if distances[node] + 1 > distances[neighbor]: distances[neighbor] = distances[node] + 1 predecessors[neighbor] = node in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if distances[end] == -float(\'inf\'): return [] path = [] current = end while current != -1: path.append(current) current = predecessors[current] return path[::-1]"},{"question":"Given a **0-indexed** array of integers `heights` representing the height of students standing in a line, return the **minimum number of students** that must be moved to create a non-decreasing order of heights. A move consists of taking a student from one position in the list and inserting them at another position. The relative order of the remaining students must be maintained.","solution":"def min_students_to_move(heights): Returns the minimum number of students that must be moved to create a non-decreasing order of heights. Parameters: heights (List[int]): List of integers representing the heights of students. Returns: int: Minimum number of students that must be moved. if not heights: return 0 n = len(heights) lis_length = [1] * n # Initialize the length of the longest increasing subsequence ending at each index # Calculate the length of the longest increasing subsequence for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: lis_length[i] = max(lis_length[i], lis_length[j] + 1) # The minimum number of moves required will be the total number of students minus # the length of the longest increasing subsequence return n - max(lis_length)"},{"question":"Given a string `s`, find the length of the smallest substring that contains at least one occurrence of each character in a given string `t`. If it is impossible to do so, return 0.","solution":"def min_window_substring(s, t): from collections import Counter if not s or not t: return 0 dict_t = Counter(t) required = len(dict_t) # Left and right pointers l = 0 r = 0 # Formed is used to keep track of how many unique characters in t are present in the current window in desired frequency. formed = 0 # Dictionary to keep a count of all the unique characters in the current window. window_counts = {} # (window length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): # Add one character from the right to the window character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 # If the frequency of the current character added equals to the desired count in t then increment the formed count by 1. if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 # Try and contract the window till the point where it ceases to be \'desirable\'. while l <= r and formed == required: character = s[l] # Save the smallest window until now. if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) # The character at the position pointed by the `left` pointer is no longer a part of the window. window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 # Move the left pointer ahead, this would help to look for a new window. l += 1 # Keep expanding the window once we are done contracting. r += 1 return ans[0] if ans[0] != float(\\"inf\\") else 0"},{"question":"Given an integer array `nums` of length `n`, return the smallest index `i` such that the sum of the elements to the left of `i` is equal to the sum of the elements to the right of `i`. If no such index exists, return `-1`. If there are multiple correct answers, return the leftmost one. Note that the element at index `i` is not included in either the left or right sum. For example, given `nums = [1, 7, 3, 6, 5, 6]`, the answer is `3`, because the sum of the elements to the left of index `3` (`[1, 7, 3]`) is `11`, which is equal to the sum of the elements to the right of index `3` (`[5, 6]`).","solution":"def pivot_index(nums): Returns the smallest index i such that the sum of the elements to the left of i is equal to the sum of the elements to the right of i. If no such index exists, returns -1. total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"You are given an array of integers `nums`, and you can perform a series of operations. In each operation, you can choose two elements `nums[i]` and `nums[j]` (where `i ≠ j`) and replace them with their sum (`nums[i] + nums[j]`). Each operation effectively reduces the array size by 1. Your task is to find the minimal number of operations required so that all elements in the array become equal.","solution":"def minimal_operations_to_equal_elements(nums): Returns the minimal number of operations required to make all elements equal. return len(nums) - 1"},{"question":"You are given an n-ary tree represented by a root node. Each node in the n-ary tree contains a value and a list of its children. Implement a function to perform level-order traversal on the n-ary tree and return a list of lists representing the node values at each level of the tree. **Example:** Given the n-ary tree: ``` 1 / | 3 2 4 / 5 6 ``` The level order traversal of the tree should return: ``` [ [1], [3, 2, 4], [5, 6] ] ```","solution":"from collections import deque class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def levelOrder(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) queue.extend(node.children) result.append(current_level) return result"},{"question":"Given an integer `n`, generate the `n`-th term of the count-and-say sequence. The count-and-say sequence is a sequence of digit strings defined by the recursive formula: - `countAndSay(1) = \\"1\\"` - `countAndSay(n)` is generated by reading the previous term and counting the number of digits in groups of the same digit. For example, the first few terms are: 1. 1 2. 11 (one 1) 3. 21 (two 1s) 4. 1211 (one 2 followed by one 1) 5. 111221 (one 1, one 2, and two 1s) Write a function `countAndSay(int n)` that returns the `n`-th term of the count-and-say sequence.","solution":"def countAndSay(n): Generates the n-th term of the count-and-say sequence. def next_number(s): result = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 result.append(str(count) + s[i]) i += 1 return \'\'.join(result) current = \\"1\\" for _ in range(1, n): current = next_number(current) return current"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to find a continuous subarray within `nums` whose sum equals to `target`. If such a subarray exists, return the starting and ending indices of the subarray (0-indexed). If no such subarray exists, return `[-1, -1]`. Ensure that the solution has a time complexity better than O(n^2).","solution":"def find_subarray_with_target_sum(nums, target): Finds a continuous subarray within nums whose sum is equal to target. If such a subarray exists, returns the starting and ending indices. Otherwise, returns [-1, -1]. current_sum = 0 sum_indices = {0: -1} for index, num in enumerate(nums): current_sum += num if current_sum - target in sum_indices: return [sum_indices[current_sum - target] + 1, index] sum_indices[current_sum] = index return [-1, -1]"},{"question":"You are given the head of a singly linked list and an integer `k`. Write a function to reverse the nodes of the list `k` at a time and return its modified list. `k` is always a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes in the end should remain as it is. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, you should return `2 -> 1 -> 4 -> 3 -> 5`. If `k = 3` and the list is `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8`, the output should be `3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverseLinkedList(head, k): prev, curr = None, head while k: next_node = curr.next curr.next = prev prev = curr curr = next_node k -= 1 return prev count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversedHead = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversedHead return head"},{"question":"You are given an array of integers `heights` representing the height of students in a line. Each student wants to know how many students in front of them are taller. Write a function that returns an array where the `ith` element is the number of students in front of the `i-th` student who are taller than `heights[i]`. The input array can be quite large, so consider optimizing the solution for performance.","solution":"def count_taller_students(heights): Returns an array where the ith element is the number of students in front of the ith student who are taller than heights[i]. :param heights: List of integers representing the heights of students. :return: List of integers representing the number of taller students in front of each student. n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i): if heights[j] > heights[i]: count += 1 result[i] = count return result"},{"question":"You are given an array of integers `arr` and an integer `k`. The array represents a **circle** such that the first element is adjacent to the last element. Your task is to determine the maximum sum of any contiguous subarray of length `k` that can be formed by tracing around the circle once. Return the maximum sum of such subarray.","solution":"def max_circular_subarray_sum(arr, k): Returns the maximum sum of any contiguous subarray of length k in a circular array. n = len(arr) if n == 0 or k > n: return 0 # Calculate the sum of the first k elements current_sum = sum(arr[:k]) max_sum = current_sum # Perform sliding window to get the sum of each k consecutive elements for i in range(1, n): # Remove the element that goes out of the window and add the new element current_sum = current_sum - arr[i-1] + arr[(i+k-1) % n] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a `rows x cols` binary matrix `mat` representing a maze where `0` represents an open space and `1` represents a wall. You are also given two points `start` and `target` within the maze. You need to find the shortest path from `start` to `target` such that you only move through open spaces. Return _the length of the shortest path_. If there is no such path, return `-1`. The function should take the binary matrix `mat`, the starting point `start`, and the target point `target` as input and return the length of the shortest path or `-1` if the path does not exist.","solution":"from collections import deque def shortest_path(mat, start, target): Finds the shortest path in a binary matrix from start to target. Args: - mat (list of list of int): The binary matrix representation of the maze. - start (tuple of int, int): The starting coordinates (row, col). - target (tuple of int, int): The target coordinates (row, col). Returns: - int: The length of the shortest path, or -1 if no path exists. rows, cols = len(mat), len(mat[0]) sr, sc = start tr, tc = target if mat[sr][sc] == 1 or mat[tr][tc] == 1: return -1 def is_valid(r, c): return 0 <= r < rows and 0 <= c < cols and mat[r][c] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sr, sc, 0)]) # (row, col, distance) visited = set() visited.add((sr, sc)) while queue: r, c, dist = queue.popleft() if (r, c) == (tr, tc): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc) and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given a `0-indexed` 2D integer array `flavors` where `flavors[i]` = `[sweetness, bitterness]` indicates the sweetness and bitterness levels of the `i-th` ice cream flavor. You are also given two integer values `minSweetness` and `maxBitterness`. Return the **minimum** difference between the sweetness and bitterness levels among all flavors that satisfy the condition: sweetness >= `minSweetness` and bitterness <= `maxBitterness`. If no such flavor exists, return `-1`.","solution":"def min_difference(flavors, minSweetness, maxBitterness): Returns the minimum difference between sweetness and bitterness of flavors that meet the condition: sweetness >= minSweetness and bitterness <= maxBitterness. :param flavors: List[List[int]]: a 2D list of flavors where each flavor is represented as [sweetness, bitterness] :param minSweetness: int: minimum sweetness level a flavor must have :param maxBitterness: int: maximum bitterness level a flavor must not exceed :return: int: minimum difference between sweetness and bitterness that meets the condition, or -1 if no such flavor exists min_diff = float(\'inf\') found_valid = False for sweetness, bitterness in flavors: if sweetness >= minSweetness and bitterness <= maxBitterness: found_valid = True min_diff = min(min_diff, abs(sweetness - bitterness)) return min_diff if found_valid else -1"},{"question":"Given an integer array `arr` of size `n`, find and return the length of the longest subarray in which the absolute difference between any two elements is less than or equal to `d`. A subarray is defined as a contiguous segment of the array.","solution":"def longest_subarray_with_diff(arr, d): Given an integer array `arr`, returns the length of the longest subarray in which the absolute difference between any two elements is <= d. if not arr: return 0 n = len(arr) max_length = 1 start = 0 for end in range(1, n): if max(arr[start:end+1]) - min(arr[start:end+1]) <= d: max_length = max(max_length, end - start + 1) else: start += 1 while start < end and (max(arr[start:end+1]) - min(arr[start:end+1]) > d): start += 1 return max_length"},{"question":"Given a **balanced binary search tree** (BST), write a function to transform it into a **summation tree** where each node\'s value is updated to be the sum of all values greater than or equal to the original node\'s value in the BST. A balanced BST is maintained when: 1. The left subtree of a node contains only nodes with values less than the node\'s value. 2. The right subtree of a node contains only nodes with values greater than the node\'s value. 3. Both the left and right subtrees are balanced themselves. The function should return the root of the transformed summation tree. **Example:** Input: Balanced BST with structure: 4 / 2 6 / / 1 3 5 7 Output: Summation tree with structure: 22 / 27 13 / / 28 25 18 7 **Note:** * You may assume that the given BST does not contain duplicate values. * The summation tree must maintain the original BST structure, but with updated values according to the sum condition.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_to_summation_tree(root): Converts the given balanced BST to a summation tree where each node\'s value is updated to the sum of all values greater than or equal to it in the BST. def reverse_inorder_traversal(node, acc_sum): if not node: return acc_sum acc_sum = reverse_inorder_traversal(node.right, acc_sum) node.val += acc_sum acc_sum = node.val acc_sum = reverse_inorder_traversal(node.left, acc_sum) return acc_sum reverse_inorder_traversal(root, 0) return root def bst_to_list_inorder(root): Helper function to convert BST to list (in-order). if not root: return [] return bst_to_list_inorder(root.left) + [root.val] + bst_to_list_inorder(root.right)"},{"question":"You are given a list of positive integers `heights` representing the heights of plants in a garden, and an integer `k` representing the maximum number of plants you can water in a single operation. You need to determine the minimum number of operations required to water all the plants such that in each operation, the tallest plant among those watered receives the most water. In one operation, you can select any `k` consecutive plants to water. Return the _minimum number of watering operations needed to water all the plants_.","solution":"def min_watering_operations(heights, k): Returns the minimum number of watering operations needed to water all the plants. Parameters: heights (list of int): List of plant heights. k (int): Maximum number of plants that can be watered in a single operation. Returns: int: Minimum number of watering operations. n = len(heights) if k >= n: return 1 # Determine the number of operations based on the jump size k operations = 0 position = 0 while position < n: # Move the window the maximum possible size while possible operations += 1 position += k return operations"},{"question":"You are given a 1-indexed integer array `nums` of length `n`. Initially, you start with a score of 0. You want to perform exactly `n` operations such that on the `i-th` operation (1-indexed), you either add `nums[i]` or subtract `nums[i]` from your score. At the end of all operations, your score must be equal to a given target value `T`. Return _a boolean value denoting whether it is possible to achieve the target score `T`._","solution":"def can_achieve_target(nums, T): Returns whether it is possible to achieve the target score T by adding or subtracting each element in nums. :param nums: 1-indexed list of integers. :param T: Target score. :return: Boolean value indicating if target score is achievable. n = len(nums) dp = [set() for _ in range(n + 1)] dp[0].add(0) for i in range(1, n + 1): for prev_sum in dp[i-1]: dp[i].add(prev_sum + nums[i-1]) dp[i].add(prev_sum - nums[i-1]) return T in dp[n]"},{"question":"In a binary tree, the **depth** of a node is the number of edges from the root to the node. The **diameter** of a binary tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. You are given the `root` of a binary tree. Return _the diameter of the binary tree_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Returns the diameter of the binary tree. def depth(node): nonlocal diameter if not node: return 0 left = depth(node.left) right = depth(node.right) diameter = max(diameter, left + right) return max(left, right) + 1 diameter = 0 depth(root) return diameter"},{"question":"You are given a matrix `grid` of size `m x n` and an integer `k`. Each cell of the grid contains an integer. You need to find the largest possible sum of a square sub-matrix of size `k x k` within the `grid`. If there are multiple sub-matrices with the same largest sum, return the sum of any one of them.","solution":"def largest_sum_submatrix(grid, k): m = len(grid) n = len(grid[0]) if k > m or k > n: return None # Handle edge case where k is larger than the grid size max_sum = float(\'-inf\') # Pre-compute the cumulative sum sum_matrix = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): sum_matrix[i][j] = grid[i-1][j-1] + sum_matrix[i-1][j] + sum_matrix[i][j-1] - sum_matrix[i-1][j-1] # Compute the sum of all k x k sub-matrices and find the maximum sum for i in range(k, m + 1): for j in range(k, n + 1): curr_sum = sum_matrix[i][j] - sum_matrix[i-k][j] - sum_matrix[i][j-k] + sum_matrix[i-k][j-k] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"Design a function that finds and returns all the subsets of a given list of integers. The answer must not contain duplicate subsets. Implement the `findSubsets` function: * `List<List<Integer>> findSubsets(List<Integer> nums)` - a function that takes a list of integers `nums` and returns a list of lists containing all possible subsets of the input list. Each subset should be sorted in non-descending order, and the list of subsets should be sorted lexicographically based on their content. Note: The input list `nums` might contain duplicates.","solution":"def findSubsets(nums): Finds and returns all subsets of a given list of integers without duplicates, sorted lexicographically. def backtrack(start, path): res.append(path[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() res = [] backtrack(0, []) return sorted(res)"},{"question":"You are given a grid where each cell is initially either empty (`0`) or filled with an obstacle (`1`). You need to find the number of unique paths from the top-left cell (grid[0][0]) to the bottom-right cell (grid[m-1][n-1]), but the path must avoid obstacles. You can only move either down or right at any point in time. Return the number of unique paths that avoid the obstacles. If no such path exists, return `0`.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right of the grid that avoid obstacles. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Initialize the first column for i in range(1, m): if grid[i][0] == 0: dp[i][0] = dp[i - 1][0] # Initialize the first row for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j - 1] for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[-1][-1]"},{"question":"Given an array of integers `nums` representing the cost of jumping to each index, return the minimum cost of reaching from the first index to the last index. From any index `i`, you can jump to index `i+1` or index `i+2`. The cost of jumping to an index is the value of the element at that index.","solution":"def min_cost_jump(nums): Returns the minimum cost to reach from the first index to the last index. Args: nums (List[int]): A list of integers where each integer represents the cost of jumping to that index. Returns: int: Minimum cost to reach the last index. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = nums[1] for i in range(2, n): dp[i] = nums[i] + min(dp[i-1], dp[i-2]) return dp[-1]"},{"question":"Given a class schedule which consists of `n` intervals `(start, end)` where `start[i]` and `end[i]` denote the start and end times of the `i-th` class, determine if a student can attend all classes without any conflicts. Write a function `bool canAttendClasses(vector<pair<int, int>>& intervals)` that returns `true` if the student can attend all classes, otherwise `false`. The intervals may not be sorted.","solution":"def can_attend_classes(intervals): Determine if a student can attend all classes without any conflicts. Parameters: intervals (list of tuples): A list of intervals where each interval is a tuple (start, end). Returns: bool: True if the student can attend all classes, otherwise False. # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Check for overlapping intervals for i in range(1, len(intervals)): if intervals[i][0] < intervals[i - 1][1]: return False return True"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on a 2D plane. A line segment is formed by any two points. The length of a line segment between two points `[xi, yi]` and `[xj, yj]` is the Euclidean distance between them, which is calculated as `sqrt((xi - xj)^2 + (yi - yj)^2)`. Return _the length of the **longest** line segment that can be formed by any two points in the array_.","solution":"import math def longest_line_segment(points): Returns the length of the longest line segment that can be formed by any two points. def euclidean_distance(point1, point2): return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) max_distance = 0 for i in range(len(points)): for j in range(i + 1, len(points)): dist = euclidean_distance(points[i], points[j]) if dist > max_distance: max_distance = dist return max_distance"},{"question":"You are given a list of points in a 2D plane `points` where `points[i] = [xi, yi]` represents a point in the plane. An integer `k` is also given. You need to find the `k` closest points to the origin (0, 0). The distance between two points `[xi, yi]` and `[0, 0]` is calculated as `sqrt(xi^2 + yi^2)`. If there are multiple points with the same distance, any of them can be included in the result. Return _the list of the_ `k` _closest points to the origin_. The answer should be sorted by their distance to the origin in non-decreasing order. If two points have the same distance, their order relative to each other does not matter.","solution":"import heapq from typing import List def k_closest_points(points: List[List[int]], k: int) -> List[List[int]]: Finds the k closest points to the origin (0, 0). # Calculate the distances and use a heap to get the closest points heap = [] for (x, y) in points: distance = x ** 2 + y ** 2 heapq.heappush(heap, (distance, [x, y])) # Extract the k closest points result = [heapq.heappop(heap)[1] for _ in range(k)] return result"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, return _a new array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must solve it without using division and in O(n) time complexity._","solution":"def product_except_self(nums): Given an array nums, returns an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. :param nums: List[int] :returns: List[int] n = len(nums) if n == 0: return [] # Step 1: Initialize the resultant array with 1s answer = [1] * n # Step 2: Calculate the products of elements to the left of each index left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] # Step 3: Calculate the products of elements to the right of each index right_product = 1 for i in range(n-1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"Given a string `s`, return the length of the longest substring that does not contain repeating characters. Write an efficient algorithm to solve this problem and ensure your solution handles the edge cases effectively.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You have a list of `n` integers, `nums`, and an integer `target`. Your task is to return the indices of two distinct elements from `nums` that add up to `target`. If there are multiple pairs, return any of them. If no such pair exists, return an empty list. The function should return a list of two indices, `[index1, index2]`, with `index1 < index2`. Note that the return indices should be zero-based.","solution":"def two_sum(nums, target): Returns indices of two distinct elements in `nums` that add up to `target`. If no such pair exists, return an empty list. Parameters: nums (list): List of integers. target (int): Target sum of two elements. Returns: list: Indices of the two elements that add up to the target sum. index_map = {} for index, num in enumerate(nums): difference = target - num if difference in index_map: return [index_map[difference], index] index_map[num] = index return []"},{"question":"You are given a 2D grid of dimensions `m x n` representing a land map where `1` represents land and `0` represents water. An island is a collection of contiguous `1`s connected 4-directionally (horizontally or vertically). You need to determine the size of the largest island. Return _the size of the largest island on the map_. Given grid: ```python grid = [ [0,0,1,0,0], [0,1,1,0,0], [0,0,0,1,1], [1,1,0,0,0] ] ``` The largest island has a size of `3`.","solution":"def largest_island(grid): Returns the size of the largest island in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or visited[i][j]: return 0 visited[i][j] = True size = 1 size += dfs(i + 1, j) size += dfs(i - 1, j) size += dfs(i, j + 1) size += dfs(i, j - 1) return size max_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given an array of integers `nums` that represents a sequence of operations, where each element in the array can either increase, decrease, or maintain the value of a counter. The counter starts at zero, and for each element `nums[i]`, if it is positive, you increase the counter by `nums[i]`; if it is negative, you decrease the counter by `|nums[i]|`; and if it is zero, the counter remains the same. Return the maximum value that the counter reaches throughout the operations. Note that the counter cannot go below zero at any point.","solution":"def max_counter_value(nums): Returns the maximum value that the counter reaches throughout the operations. The counter starts at zero and cannot go below zero. counter = 0 max_value = 0 for num in nums: if num > 0: counter += num elif num < 0: counter = max(0, counter + num) if counter > max_value: max_value = counter return max_value"},{"question":"Given a string `s` of lowercase English letters, you need to determine if you can split the string into two non-empty parts such that each part contains at least one vowel (`\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, `\'u\'`) and the number of vowels in the two parts are equal. Return `true` if you can split the string in such a way, otherwise return `false`.","solution":"def can_split_string(s): Determine if the string can be split into two non-empty parts such that each part contains at least one vowel and the number of vowels in the two parts are equal. if len(s) < 2: return False vowels = set(\'aeiou\') total_vowels = sum(1 for char in s if char in vowels) if total_vowels < 2 or total_vowels % 2 != 0: return False left_vowel_count = 0 for i in range(len(s) - 1): if s[i] in vowels: left_vowel_count += 1 if left_vowel_count == total_vowels // 2: return True return False"},{"question":"Implement a basic calculator to evaluate a simple expression string. The expression string may contain open `(` and close `)` parentheses, the non-negative integers, and the `+` and `-` operators. The integer division should truncate toward zero. You may assume that the given expression is always valid. Some examples: \\"1 + 1\\", \\" 2-1 + 2 \\", \\"(1+(4+5+2)-3)+(6+8)\\". The output should be the result of the evaluated string expression.","solution":"def calculate(expression): Evaluates a simple arithmetic expression string containing non-negative integers, \'+\', \'-\', \'(\', \')\' operators. Parameters: expression (str): The expression string to evaluate. Returns: int: The result of the evaluated expression. def helper(s, index): stack = [] num = 0 sign = 1 while index < len(s): if s[index].isdigit(): num = num * 10 + int(s[index]) elif s[index] == \'+\': stack.append(sign * num) num = 0 sign = 1 elif s[index] == \'-\': stack.append(sign * num) num = 0 sign = -1 elif s[index] == \'(\': num, next_index = helper(s, index + 1) index = next_index - 1 elif s[index] == \')\': stack.append(sign * num) return sum(stack), index + 1 index += 1 stack.append(sign * num) return sum(stack), index return helper(expression.replace(\' \', \'\'), 0)[0]"},{"question":"In a competition, there are `n` participants, each assigned a unique ID from `1` to `n`. Participants form teams to compete, and each team consists of either one or two participants. You are given an array `participants` of length `m` where `participants[i] = [a, b]` represents a team of participants with IDs `a` and `b` (if `a == b`, it means the team consists of only one participant). There is exactly one \\"winning team,\\" and you know that this team scored the highest in all rounds. Your task is to identify the winning team based on the following information: - Each participant\'s skill level is recorded in an array `skills` of length `n`, where `skills[i]` represents the skill level of the participant with ID `i+1`. - The score of a team is the sum of the skill levels of its members. Return the IDs of the participants in the winning team. If multiple teams have the highest score, return the team that appears first in the input list. If there are no teams, return an empty list.","solution":"def find_winning_team(participants, skills): Find the winning team based on participants\' skill levels. :param participants: List of teams. Each team is a list containing 1 or 2 participant IDs. :param skills: List of skill levels of participants. :return: List of participant IDs of the winning team. if not participants: return [] max_score = -1 winning_team = [] for team in participants: score = sum(skills[participant - 1] for participant in team) if score > max_score: max_score = score winning_team = team return winning_team"},{"question":"You are given an array of integers `heights` representing the heights of students standing in a row. A new student with a given height `new_height` wants to join the row such that the row remains sorted in non-decreasing order. Write a function that returns the index at which the new student should be inserted. If there are multiple valid positions, return the leftmost index. Your algorithm should run in `O(log n)` time complexity.","solution":"def find_insert_index(heights, new_height): Returns the index at which the new_height should be inserted in heights to keep it sorted. This function uses binary search to achieve O(log n) time complexity. left, right = 0, len(heights) while left < right: mid = (left + right) // 2 if heights[mid] < new_height: left = mid + 1 else: right = mid return left"},{"question":"You are given the heads of two singly linked-lists `headA` and `headB`, which initially merge at some point and become a single linked list. Unfortunately, due to corruption, part of the data structure after the merge point is missing. Your task is to detect the node at which the two linked lists merge, if they do, and return it. Implement the function `ListNode getIntersectionNode(ListNode headA, ListNode headB)` that determines the node at which the intersection of two singly linked lists begins. If the two linked lists have no intersection at all, return `null`. - Implement the ListNode class with: - An integer property `val` representing the node\'s value. - A ListNode property `next` pointing to the next node in the list. Note: It is guaranteed that there are no cycles anywhere in the entire linked structure.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def getIntersectionNode(headA, headB): This function returns the node where the two linked lists intersect. If the two linked lists don\'t intersect, return None. if not headA or not headB: return None pointerA, pointerB = headA, headB # Traverse both lists until the pointers meet or reach the end of both lists while pointerA != pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"Implement a function that takes an integer array and an integer `k` and returns the `k`th largest element in the array. Note that it is the `k`th largest element in sorted order, not the `k`th distinct element. You may assume `k` is always valid, 1 ≤ k ≤ array\'s length.","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the array nums. # Sort the array in descending order nums.sort(reverse=True) # kth largest element is at index k-1 after sorting return nums[k-1]"},{"question":"You are given a string `s` consisting of lowercase English letters, and you need to perform operations to transform it into its lexicographically smallest form. In one operation, you can choose a character `c` in `s` and move `c` to the beginning of `s`. Return the lexicographically smallest string you can obtain after applying the operations optimally.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string by optimally applying operations. if not s: return s min_char = min(s) min_index = s.rindex(min_char) return s[min_index] + s[:min_index] + s[min_index+1:]"},{"question":"You are given a string `s` containing lowercase English letters, and a string `part` containing a distinct substring. You are tasked with removing all occurrences of `part` from `s`, one at a time, until there is no occurrence of `part` in `s`. Implement a function `removeOccurrences` that returns the final string after all such removals have been made. For example, given the string `s = \\"daabcbaabcbc\\"` and the substring `part = \\"abc\\"`, the function should remove \\"abc\\" from `s` iteratively as follows: 1. Removing the first \\"abc\\" results in `dabaabcbc`. 2. Removing the next \\"abc\\" results in `dabcbc`. 3. Removing the final \\"abc\\" results in `dc`. Thus, the final string returned will be `\\"dab\\"`.","solution":"def removeOccurrences(s, part): Removes all occurrences of the substring `part` from the string `s` iteratively until none remain. Parameters: s (str): The original string. part (str): The substring to be removed from the original string. Returns: str: The final string after all occurrences of `part` have been removed. while part in s: s = s.replace(part, \'\', 1) return s"},{"question":"You are given a binary tree where each node contains a positive integer value. You need to determine the maximum sum of values starting from the root node and ending at any leaf node. Each node in the tree has two pointers, `left` and `right`, which point to its left and right child respectively. A leaf node is a node with no children. Return the maximum sum path from the root to any leaf node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root: TreeNode) -> int: Returns the maximum sum of values starting from the root node and ending at any leaf node. if root is None: return 0 if root.left is None and root.right is None: return root.val left_sum = max_sum_path(root.left) if root.left else 0 right_sum = max_sum_path(root.right) if root.right else 0 return root.val + max(left_sum, right_sum)"},{"question":"You are given an array of integers `nums` and two integers `x` and `y`. You need to determine if it is possible to partition the array into two non-empty parts such that the sum of elements in the first part equals `x` and the sum of elements in the second part equals `y`. Return _true_ if such a partition exists, otherwise return _false_.","solution":"def can_partition(nums, x, y): Determines if it is possible to partition the array into two non-empty parts such that one part has sum x and the other part has sum y. Args: nums (list): List of integers. x (int): Desired sum for the first part. y (int): Desired sum for the second part. Returns: bool: True if such a partition exists, otherwise False. n = len(nums) total = sum(nums) if total != x + y: return False current_sum = 0 for i in range(n - 1): # n-1 to ensure two non-empty parts current_sum += nums[i] if current_sum == x: return True return False"},{"question":"You are given a list of `n` integers `nums` and an integer `target`. Your task is to determine the number of unique quadruplets `(a, b, c, d)` in the list such that `a + b + c + d` is equal to `target`. Each quadruplet should be represented as a tuple of integers in non-decreasing order. Return the number of such unique quadruplets.","solution":"def four_sum_count(nums, target): Returns the number of unique quadruplets (a, b, c, d) in nums such that a + b + c + d equals target. Each quadruplet is represented as a tuple in non-decreasing order. :param nums: List[int] - List of integers :param target: int - target sum :return: int - number of unique quadruplets from collections import defaultdict nums.sort() n = len(nums) quadruplets = set() for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: quadruplets.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return len(quadruplets)"},{"question":"You are given a **0-indexed** integer array `arr` of length `n` sorted in **non-decreasing** order. Your task is to determine if there exists a triple of indices ( (i, j, k) ) such that: - ( 0 leq i < j < k < n ) - ( arr[i] ), ( arr[j] ), and ( arr[k] ) form an **arithmetic progression**. Return `true` if such indices exist, otherwise return `false`. An arithmetic progression is defined as a sequence of numbers such that the difference between consecutive elements is constant.","solution":"def contains_arithmetic_progression(arr): Determines if there are three indices (i, j, k) with 0 <= i < j < k < len(arr) such that arr[i], arr[j], and arr[k] form an arithmetic progression. :param arr: List of sorted integers. :return: Boolean indicating the existence of such an arithmetic progression. n = len(arr) if n < 3: return False for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[j] - arr[i] == arr[k] - arr[j]: return True return False"},{"question":"A company wants to send a set of gifts to its employees. The gifts are represented as an array of integers where each integer represents the value of a gift. Each employee can only receive one gift. The company wants to ensure that the difference between the highest and the lowest value gift received by any two employees is minimized. To achieve this, write a function that, given an integer array `gifts` and an integer `k` representing the number of employees, returns the minimized difference between the highest and lowest value gift received by any two employees after distributing the gifts. [Question 4]:","solution":"def minimized_gift_difference(gifts, k): This function returns the minimized difference between the highest and lowest value gift received by any two employees after distributing the gifts. :param gifts: List[int], list of integers representing the values of gifts :param k: int, number of employees :return: int, minimized difference if k == 0 or len(gifts) < k: return 0 gifts.sort() min_diff = float(\'inf\') for i in range(len(gifts) - k + 1): current_diff = gifts[i + k - 1] - gifts[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"Given an array of integers `nums` where each element appears either once or twice, return an array of all the integers that appear twice. Your solution should have a linear runtime complexity and use only constant extra space.","solution":"def find_duplicates(nums): Given an array of integers `nums`, return an array of all the integers that appear twice. The solution has a linear runtime complexity and uses only constant extra space. :param nums: List[int] :return: List[int] duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) else: nums[index] = -nums[index] return duplicates"},{"question":"A developer is working on a project management tool where they need to track the progress of tasks in different projects. Each project is composed of multiple tasks, and each task can either be incomplete or complete. The developer wants to implement a class `ProjectManager` where: - `ProjectManager(String[] tasks)` initializes the project manager with an array of tasks, each represented by a unique identifier (string). - `void completeTask(String taskId)` marks the task with the given `taskId` as complete. If the taskId does not exist, it should be ignored. - `boolean allTasksCompleted()` returns `true` if all tasks in the project are completed, otherwise returns `false`. Implement the `ProjectManager` class to achieve the requirements mentioned above.","solution":"class ProjectManager: def __init__(self, tasks): Initializes the ProjectManager with an array of tasks, each represented by a unique identifier (string). self.tasks = {task: False for task in tasks} def completeTask(self, taskId): Marks the task with the given taskId as complete. If the taskId does not exist, it should be ignored. if taskId in self.tasks: self.tasks[taskId] = True def allTasksCompleted(self): Returns True if all tasks in the project are completed, otherwise returns False. return all(self.tasks.values())"},{"question":"You are given an integer array `temps` representing the daily temperatures for a week, where `temps[i]` is the temperature on the `ith` day. Determine the maximum number of consecutive days with a strictly increasing temperature trend. A strictly increasing trend means each day\'s temperature is greater than the previous day\'s temperature. Return _the maximum number of consecutive days with a strictly increasing temperature trend_ in the week.","solution":"def max_consecutive_increasing_temps(temps): Returns the maximum number of consecutive days with a strictly increasing temperature trend. if not temps: return 0 max_length = 0 current_length = 1 # at least one day itself is an increasing sequence for i in range(1, len(temps)): if temps[i] > temps[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # reset the current length max_length = max(max_length, current_length) # final check for the last sequence return max_length"},{"question":"You are given an integer array `nums` of length `n`, where all the integers of `nums` are in the range `[1, n]` inclusive. Each integer appears once or twice. Return an array of all the integers that appear twice.","solution":"def find_duplicates(nums): Returns a list of all integers that appear twice in the array nums. Args: nums (list): List of integers where each integer is in the range [1, n] inclusive. Returns: list: A list of integers that appear twice in nums. result = [] for num in nums: if nums[abs(num) - 1] < 0: result.append(abs(num)) else: nums[abs(num) - 1] *= -1 return result"},{"question":"Given a 2D grid of dimensions `m x n` with `1` representing land and `0` representing water, an island is formed by connecting adjacent lands horizontally or vertically. Consider the diagonals as water. Return _the number of islands_ in the grid.","solution":"def numIslands(grid): def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' dfs(grid, i - 1, j) dfs(grid, i + 1, j) dfs(grid, i, j - 1) dfs(grid, i, j + 1) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': count += 1 dfs(grid, i, j) return count"},{"question":"You are given a 2D grid `grid` of size `m x n` representing a map where: - `1` represents land, - `0` represents water. Any two adjacent cells of the same type are considered connected (adjacent means horizontally or vertically). An **island** is a maximal group of connected `1`s. You can transform an island into water by changing any `1` to `0`. Return the minimum number of operations required to make the entire grid a `water` grid (all `0`s). # Function Signature: ```python def min_operations_to_water_grid(grid: List[List[int]]) -> int: pass ``` # Examples: ```python Example 1: Input: grid = [[0,1,0],[1,1,1],[0,1,0]] Output: 1 Example 2: Input: grid = [[1,1,0,0],[1,0,0,1],[0,0,1,1]] Output: 2 Example 3: Input: grid = [[1]] Output: 1 ``` # Notes: - You can assume grid is always a non-empty 2D matrix. - `m` and `n` are up to 100. - Operations must be minimized.","solution":"from typing import List def min_operations_to_water_grid(grid: List[List[int]]) -> int: def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) islands_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: islands_count += 1 dfs(i, j) return islands_count"},{"question":"You are given an `n x n` chessboard where `n` is an odd integer. The board is initially empty except for a queen placed at the center of the board. Your task is to find all possible ways to place `n - 1` additional queens on the board so that no two queens can attack each other. A queen can attack another queen if it is on the same row, column, or diagonal. Return all distinct solutions to the n-queens problem. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens\' placement, where \'Q\' and \'.\' both represent a queen and an empty space respectively.","solution":"def solve_n_queens(n): Solve the N-Queens problem and return all possible configurations. if n % 2 == 0 or n < 3: return [] # The problem constraint mentioned that n is odd def is_safe(board, row, col): # Check for a queen on the same column for i in range(row): if board[i] == col: return False # Check for a queen on the upper left diagonal for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)): if board[i] == j: return False # Check for a queen on the upper right diagonal for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)): if board[i] == j: return False return True def solve(row, board): if row == n: result = [] for i in range(n): row_result = [\'.\'] * n row_result[board[i]] = \'Q\' result.append(\\"\\".join(row_result)) solutions.append(result) return for col in range(n): if is_safe(board, row, col): board[row] = col solve(row + 1, board) board[row] = -1 solutions = [] initial_board = [-1] * n # Placing the initial queen at the center initial_board[n // 2] = n // 2 solve(0, initial_board) return solutions"},{"question":"Given a list of `n` words, each word consists of lowercase English letters. Two words `word1` and `word2` are considered similar if they have the same frequency of characters. Return all the groups of words that are similar, with each group containing at least two words. Each group should be sorted in lexicographical order and the groups themselves should be sorted lexicographically by their first word. For example, given the input `[\\"rats\\", \\"arts\\", \\"star\\", \\"tars\\", \\"car\\", \\"arc\\"]`, the method should return the list `[[\\"arc\\", \\"car\\"], [\\"arts\\", \\"rats\\", \\"star\\", \\"tars\\"]]`.","solution":"from collections import defaultdict def group_similar_words(words): Groups words that have the same frequency of characters. Parameters: words (list): A list of words. Returns: list: A list of groups of similar words, each group sorted lexicographically. def char_frequency(word): return tuple(sorted(word)) freq_map = defaultdict(list) for word in words: freq_map[char_frequency(word)].append(word) result = [] for key in freq_map: if len(freq_map[key]) > 1: result.append(sorted(freq_map[key])) return sorted(result, key=lambda x: x[0])"},{"question":"You are given a grid of size `m x n` representing a maze, where 0 represents a passable cell and 1 represents an impassable cell. You start at the top-left corner of the grid (position `(0, 0)`) and need to reach the bottom-right corner (position `(m-1, n-1)`). You can move up, down, left, or right from a cell, but you cannot move through impassable cells. Determine the **shortest path** from the top-left corner to the bottom-right corner. If there is no such path, return -1. Return _the length of the shortest path as an integer_.","solution":"from collections import deque def shortest_path_maze(grid): Find the shortest path in the maze from (0, 0) to (m-1, n-1). Parameters: - grid: A list of lists where 0 represents a passable cell and 1 represents an impassable cell. Returns: - The length of the shortest path from (0, 0) to (m-1, n-1). If there is no path, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # store (x, y, distance) grid[0][0] = 1 # mark as visited while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) grid[nx][ny] = 1 # mark as visited return -1"},{"question":"Given a linked list, reorder the list so that it interlaces the first half and the reversed second half. You should not modify the values in the nodes, only the order of nodes themselves. For example, for the linked list: ``` L0 → L1 → L2 → ... → Ln-1 → Ln ``` reorder it to: ``` L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ... ``` Return _the head of the modified list._","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): if not head or not head.next: return head # Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Merge the two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first, second = temp1, temp2 return head"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. Our goal is to construct a new string `t` by reordering the characters in `s` so that no two adjacent characters in `t` are the same. However, each character in `t` must appear at least `k` positions apart from the same character. If it is not possible to create such a string `t`, return an empty string. If multiple valid strings exist, return any one of them.","solution":"from collections import Counter, deque import heapq def rearrange_string_k_distance(s, k): Constructs a new string by reordering the characters in `s` so that no two adjacent characters in the new string are the same and each character appears at least `k` positions apart from the same character. If it is not possible, it returns an empty string. Args: s (str): The input string consisting of lowercase letters. k (int): The required minimum distance between same characters. Returns: str: The rearranged string or an empty string if not possible. if k <= 1: return s counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] wait_list = deque() # To keep track of characters which need to wait for k positions while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # Add this character with updated frequency to wait list wait_list.append((char, freq + 1)) # Increase the freq by 1 (since it is negative in heap) # If wait list has reached k items, we can re-add the front item back to heap if len(wait_list) < k: continue front_char, front_freq = wait_list.popleft() if front_freq < 0: # Still has remaining count heapq.heappush(max_heap, (front_freq, front_char)) return \'\'.join(result) if len(result) == len(s) else \'\'"},{"question":"You are given an array `nums` of positive integers. Consider an operation where you remove a subarray of any length `k` starting at index `i` (0 <= i < nums.length) such that after removal, the sum of the remaining elements equals a given integer `target`. Return the minimum length `k` of the subarray that needs to be removed in order to achieve this target sum. If there is no such subarray, return `-1`. **Note**: - A **subarray** is a contiguous part of an array. - The sum of the remaining elements refers to the sum of elements of the original array excluding those in the removed subarray.","solution":"def min_subarray_length_to_target(nums, target): Finds the minimum length of a subarray that can be removed such that the sum of the remaining elements equals the target. Parameters: nums (List[int]): A list of positive integers. target (int): The target sum to be achieved by the remaining elements after removal. Returns: int: The minimum length of the subarray to be removed to achieve the target sum. If no such subarray exists, returns -1. total_sum = sum(nums) n = len(nums) target_sum = total_sum - target if target_sum < 0: return -1 curr_sum = 0 min_len = float(\'inf\') start = 0 for end in range(n): curr_sum += nums[end] while curr_sum > target_sum and start <= end: curr_sum -= nums[start] start += 1 if curr_sum == target_sum: min_len = min(min_len, end - start + 1) return min_len if min_len != float(\'inf\') else -1"},{"question":"Given a string `s` that consists of lowercase letters and a list of indices `indices` where `indices` is a permutation of the string length, [0, 1, 2, ..., len(s)-1], shuffle the string such that the character at the `i`-th position moves to `indices[i]` in the shuffled string. Return the shuffled string.","solution":"def shuffle_string(s, indices): Shuffle the string such that the character at the i-th position moves to indices[i] in the shuffled string. :param s: str - The input string :param indices: List[int] - The list of indices representing the target positions :return: str - The shuffled string n = len(s) shuffled = [\'\'] * n for i in range(n): shuffled[indices[i]] = s[i] return \'\'.join(shuffled)"},{"question":"You are given a **matrix** representing an image where each element is a pixel value from 0 to 255. Implement an algorithm to **rotate** the image 90 degrees clockwise. You need to modify the input matrix **in-place**. For instance, if the input matrix is a 3x3 matrix like: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The output should be: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates the input matrix by 90 degrees clockwise in place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp return matrix"},{"question":"You are given an array of integers `heights`, where `heights[i]` represents the height of the `i-th` building. The width of each building is `1`. Two buildings `i` and `j` can be connected by a rectangular billboard if there are no taller buildings between the `i-th` and `j-th` buildings, inclusive. Return the largest possible rectangular billboard area that can be constructed between any two buildings in the `heights` array.","solution":"def largestRectangleArea(heights): Given an array of integers `heights`, where `heights[i]` represents the height of the `i-th` building. The function returns the largest possible rectangular billboard area that can be constructed between any two buildings in the `heights` array. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a list of integers `heights` representing the heights of buildings in a row. Each building has a width of 1. Calculate the amount of water trapped between the buildings after a rainstorm. The water trapped inbetween two buildings is defined as the minimum of the heights of the tallest buildings on the left and right side minus the height of the current building. Return the total amount of trapped water.","solution":"def trap(heights): Calculates the total amount of trapped water between buildings. Parameters: heights (list of int): List of building heights. Returns: int: Total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Calculate left max for each position left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Calculate right max for each position right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water total_water = 0 for i in range(n): water = min(left_max[i], right_max[i]) - heights[i] if water > 0: total_water += water return total_water"},{"question":"Given an array of integers `nums` and an integer `target`, return _an array of unique pairs of indices_ `[i, j]` _(i != j)_ from the array such that the sum of the elements at these indices equals the `target`. Ensure that the pairs are listed in ascending order of their first index, and each pair `[i, j]` is in ascending order (i < j). If no such pairs exist, return an empty array.","solution":"def two_sum_pairs(nums, target): pairs = [] seen = {} for i, num in enumerate(nums): diff = target - num if diff in seen: for index in seen[diff]: pairs.append([index, i]) if num in seen: seen[num].append(i) else: seen[num] = [i] return sorted(pairs)"},{"question":"You are given a grid consisting of `m` rows and `n` columns, where each cell contains a certain amount of gold. You start at the top-left corner (cell `(0, 0)`), and you can move to the right, down, or diagonally to the right-down cell. You are allowed to make multiple moves to collect the gold in each cell until reaching the bottom-right corner (cell `(m-1, n-1)`). Write a function to find the maximum amount of gold you can collect when starting from the top-left corner and reaching the bottom-right corner. You are given an integer matrix `grid` representing the amount of gold in each cell. Return _the maximum amount of gold you can collect_.","solution":"def max_gold(grid): Returns the maximum amount of gold that can be collected starting from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a 2D dp array to store the maximum gold collected upto each cell dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(m): for j in range(n): if i == 0 and j == 0: continue if i > 0 and j > 0: dp[i][j] = max(dp[i][j], dp[i-1][j-1] + grid[i][j]) if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[m-1][n-1]"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to split `s` into the maximum number of subsequences such that each subsequence is in non-decreasing order. Return the maximum number of subsequences you can obtain. _A **subsequence** is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements._","solution":"def max_non_decreasing_subsequences(s): Returns the maximum number of non-decreasing subsequences that can be obtained from the given string s. if not s: return 0 max_char = s[0] subsequences_count = 1 for char in s: if char < max_char: subsequences_count += 1 else: max_char = char return subsequences_count"},{"question":"You are given two integer arrays `nums1` and `nums2` of the same length `n`. Your task is to merge the two arrays into a single array of size `2n` such that the merged array maintains the relative order of the elements as they appear in `nums1` and `nums2`. However, the merged array should be formed by alternating elements from `nums1` and `nums2`. Specifically, the merged array should be of the form `[nums1[0], nums2[0], nums1[1], nums2[1], ..., nums1[n-1], nums2[n-1]]`. Return the merged array.","solution":"def merge_alternately(nums1, nums2): Merge two arrays alternately. :param nums1: List of integers :param nums2: List of integers :return: Merged list of integers merged_array = [] for i in range(len(nums1)): merged_array.append(nums1[i]) merged_array.append(nums2[i]) return merged_array"},{"question":"Given a string `s` containing only lowercase letters, find the length of the longest substring that can be rearranged to form a palindrome. The length of the input string will not exceed 1000 characters. Your function should return an integer representing the length of the longest palindromic substring that can be formed.","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest substring that can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Initialize length of the longest palindromic substring max_length = 0 odd_found = False # Loop through the count of each character for count in char_count.values(): # If the count is even, it can fully contribute to the palindrome length if count % 2 == 0: max_length += count else: # If the count is odd, we can use count - 1 characters to fully contribute max_length += count - 1 odd_found = True # Add one to the length if there was at least one character with an odd frequency if odd_found: max_length += 1 return max_length"},{"question":"Given a `matrix` of integers where rows are sorted in non-decreasing order and columns are sorted in non-decreasing order, write a function to find a specific integer `target`. Return _a boolean value indicating whether the target exists in the matrix_.","solution":"def search_matrix(matrix, target): Returns True if the target exists in the sorted matrix, False otherwise. Args: matrix (list of list of int): A 2D matrix of integers. target (int): The integer to search for in the matrix. Returns: bool: True if the target exists in the matrix, False otherwise. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"You are given the head of a singly linked list where each node contains an integer value. Write a function to group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, and the second node is even, and so on. Note that the indexing is based on 1-based index for the purposes of this problem.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): Function to reorder a linked list so that all nodes with odd indices come before all nodes with even indices. if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head def linked_list_to_list(head): Helper function to convert a linked list to a Python list for easier comparison in tests. result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(lst): Helper function to convert a Python list to a linked list for easier setup in tests. if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head"},{"question":"**[Question 4]:** You are given a binary tree root. A binary tree is composed of nodes that contain an integer value, a left child, and a right child. Your task is to perform a **level order traversal** (breadth-first traversal) on the tree and return the largest value found at each level of the tree in the correct order from top to bottom. If the tree is empty, return an empty list. **Example:** Given the binary tree: ``` 1 / 3 2 / 5 3 9 ``` The level-order traversal results in: ``` [ [1], [3, 2], [5, 3, 9] ] ``` So the largest values at each level are: `[1, 3, 9]`. **Note:** - A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def largest_values_per_level(root): Returns the largest value found at each level of the tree from top to bottom. If the tree is empty, returns an empty list. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"Given a string `s` and an integer `n`, return a new string such that each character in the original string `s` is shifted forward in the alphabet by `n` positions. The alphabet is considered to be circular, so if shifting a character forward by `n` positions moves it past \'z\', it wraps around to the beginning of the alphabet. The function should preserve the case of each character (i.e., \'a\' to \'z\' and \'A\' to \'Z\'). Non-alphabet characters should remain unchanged in the result.","solution":"def shift_string(s, n): Shifts each character in the string `s` forward by `n` positions in the alphabet. The alphabet is considered circular. Non-alphabet characters remain unchanged. result = [] for char in s: if char.islower(): result.append(chr((ord(char) - ord(\'a\') + n) % 26 + ord(\'a\'))) elif char.isupper(): result.append(chr((ord(char) - ord(\'A\') + n) % 26 + ord(\'A\'))) else: result.append(char) return \'\'.join(result)"},{"question":"Given a directed graph represented as an adjacency list, where each node has a unique character label, and a starting node `start`, find the longest path in terms of the number of nodes visited that forms a strictly increasing sequence of characters. Return the list of node labels in this path. If there are multiple paths with the same length, return the lexicographically smallest one. If no such path exists, return an empty list. # Example: ```python graph = { \'a\': [\'b\', \'c\'], \'b\': [\'d\'], \'c\': [\'d\'], \'d\': [] } start = \'a\' ``` Output: ```python [\'a\', \'b\', \'d\'] ``` Explanation: The paths from the starting node \'a\' that form strictly increasing sequences are [\'a\', \'b\', \'d\'] and [\'a\', \'c\', \'d\']. Both have the same length, but \'a\' -> \'b\' -> \'d\' is lexicographically smaller.","solution":"def find_longest_increasing_path(graph, start): Finds the longest path in terms of nodes visited that forms a strictly increasing sequence of characters in the directed graph. :param graph: Dict, adjacency list representation of the directed graph :param start: String, starting node label :return: List of node labels in the longest path memo = {} def dfs(node, path): if node in memo: return memo[node] max_path = [] for neighbor in graph.get(node, []): if neighbor > node: current_path = dfs(neighbor, path + [neighbor]) if len(current_path) > len(max_path): max_path = current_path elif len(current_path) == len(max_path) and current_path < max_path: max_path = current_path result_path = [node] + max_path memo[node] = result_path return result_path return dfs(start, [])"},{"question":"Given an integer array `arr`, return _the length of the shortest subarray that needs to be removed to make the remaining array sorted in non-decreasing order_. If the array is already sorted, return `0`. A subarray is a contiguous portion of an array. For example: - Input: `arr = [1,2,3,10,4,2,3,5]` - Output: `3` Explanation: By removing the subarray `[10,4,2]`, the resulting array `[1,2,3,3,5]` is sorted in non-decreasing order. Thus, the shortest subarray length that needs to be removed is 3.","solution":"def findLengthOfShortestSubarray(arr): Returns the length of the shortest subarray to remove to make remaining array sorted in non-decreasing order. n = len(arr) # Find the longest non-decreasing prefix left = 0 while left < n-1 and arr[left] <= arr[left+1]: left += 1 # If the array is already non-decreasing if left == n-1: return 0 # Find the longest non-decreasing suffix right = n-1 while right > 0 and arr[right] >= arr[right-1]: right -= 1 # Initial removal candidates res = min(n-left-1, right) # Try to find a better removal by combining prefix and suffix i = 0 j = right while i <= left and j < n: if arr[i] <= arr[j]: res = min(res, j-i-1) i += 1 else: j += 1 return res"},{"question":"You are given a list of non-negative integers representing heights of walls where the width of each wall is 1 unit. The walls form a histogram. Your task is to find the area of the largest rectangle that can be formed within the bounds of the histogram. The rectangle must be formed by combining contiguous walls. Given an integer array `heights` where each element represents the height of a wall, return _the area of the largest rectangle in the histogram_.","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the histogram represented by \'heights\'. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array `candies` where `candies[i]` represents the number of candies that the `i-th` child has. Each child must have at least as many candies as the child directly before them and altogether no more than `totalCandies` candies should be allocated. The minimum number of candies each child can have is `1`. Determine if it\'s possible to allocate the candies according to the given constraints. Return `true` if it is possible to distribute candies to meet the criteria, otherwise return `false`.","solution":"def can_distribute_candies(candies, totalCandies): n = len(candies) # Allocate a minimum of 1 candy to each child initially distributed = [1] * n # Iterate from left to right to ensure each child has at least as many as the previous child for i in range(1, n): if candies[i] > candies[i-1]: distributed[i] = distributed[i-1] + 1 # Iterate from right to left to ensure each child has at least as many as the next child for i in range(n-2, -1, -1): if candies[i] > candies[i+1]: distributed[i] = max(distributed[i], distributed[i+1] + 1) # Calculate the total number of candies distributed total_distributed = sum(distributed) # Check if the total number of distributed candies is within the limit return total_distributed <= totalCandies"},{"question":"Given the head of a singly linked list, reverse the list, and return the reversed list. A singly linked list is a data structure that contains a sequence of nodes. Each node has a `value` and a pointer to the next node in the sequence. The `next` pointer of the last node is `null`. ``` class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; this.next = null; } } ``` Write a function that takes the head of a singly linked list and reverses the list. Example: ``` Input: 1 -> 2 -> 3 -> 4 -> 5 -> null Output: 5 -> 4 -> 3 -> 2 -> 1 -> null ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"A company has a list of flight tickets represented by pairs of departure and arrival airports `[from, to]`. Given an arbitrary list of tickets where the route for every ticket is represented as from-to, reconstruct the itinerary in such a way that the itinerary starts at \\"JFK\\" airport and visits all the airports in lexicographical order after departing from \\"JFK\\". Return the itinerary in order as an array of airports. *Example:* *Input tickets:* [[\\"MUC\\", \\"LHR\\"], [\\"JFK\\", \\"MUC\\"], [\\"SFO\\", \\"SJC\\"], [\\"LHR\\", \\"SFO\\"]] *Output itinerary:* [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] Note: 1. If there are multiple valid itineraries, return the lexicographically smallest one. 2. All airports are represented by three-letter codes. 3. The problem guarantees at least one valid itinerary exists.","solution":"from collections import defaultdict import heapq def find_itinerary(tickets): Reconstruct the itinerary from a list of flight tickets represented as pairs of departure and arrival airports. Arguments: tickets -- List[Tuple[str, str]] : a list of [from, to] pairs representing the flight tickets Returns: List[str] : the reconstructed itinerary starting from \\"JFK\\" airport graph = defaultdict(list) for frm, to in tickets: heapq.heappush(graph[frm], to) itinerary = [] def dfs(airport): while graph[airport]: next_airport = heapq.heappop(graph[airport]) dfs(next_airport) itinerary.append(airport) dfs(\\"JFK\\") return itinerary[::-1]"},{"question":"You are given a string `s` consisting of lowercase English letters and an array of operations `operations`. Each operation is represented by an array of two elements `[i, c]`, where `i` is a valid index in the string `s`, and `c` is a character which `s[i]` should be replaced with. Perform all the operations in the given order on the string `s` and return the resultant string. If two operations modify the same index, apply the operations in the given order.","solution":"def apply_operations(s, operations): Applies a series of operations to a string, each replacing a character at a specific index. Parameters: s (str): The initial string. operations (list): A list of operations, each a list containing an index and a character. Returns: str: The resulting string after applying all operations. s = list(s) # Convert string to a list to allow mutation for i, c in operations: s[i] = c # Perform the replacement return \'\'.join(s) # Convert list back to string and return"},{"question":"You are given an integer array `arr` of length `n`. You need to determine if you can partition the array into two non-empty subarrays `left` and `right` such that: - The sum of elements in `left` is equal to the sum of elements in `right`. - Both subarrays are contiguous and non-empty. Return `true` if such a partition exists, or `false` otherwise.","solution":"def can_partition(arr): Determines if the array can be partitioned into two non-empty subarrays with equal sum. :param arr: List[int] - The input array :return: bool - True if such a partition exists, otherwise False total_sum = sum(arr) left_sum = 0 for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total_sum - left_sum if left_sum == right_sum: return True return False"},{"question":"You are given an integer array `height` of length `n` where `height[i]` represents the height of the `i-th` building. There are `n` buildings in a row and they can either be painted or left unpainted. You can paint any building, but you need to paint buildings such that you form the **most** number of **contiguous segments** where all buildings in each segment have a **higher** height than the buildings in the segment to its left. Return the **maximum number of such contiguous segments** you can form by painting buildings.","solution":"def max_contiguous_segments(height): Returns the maximum number of contiguous segments where each segment has a height greater than the previous segment. if not height: return 0 segments = 1 for i in range(1, len(height)): if height[i] > height[i-1]: segments += 1 return segments"},{"question":"You are given a directed graph represented as an adjacency list, where `n` is the number of nodes, and each node is labeled from `0` to `n-1`. The graph may contain self-loops and multi-edges. You need to find the shortest path from a given start node `start` to each other node in the graph. Return an array `shortestPaths` where `shortestPaths[i]` is the length of the shortest path from the start node to node `i`. If there is no path from `start` to node `i`, `shortestPaths[i]` should be `-1`. Create a function `shortestPathInGraph(int n, List<List<Integer>> adjList, int start)` which returns the `shortestPaths` array. - `int n`: the number of nodes in the graph. - `List<List<Integer>> adjList`: the adjacency list of the graph. - `int start`: the starting node for the paths computation. Use BFS (Breadth-First Search) to compute the shortest paths as the graph is unweighted.","solution":"from collections import deque def shortestPathInGraph(n, adjList, start): Returns the shortest paths from the start node to each other node in the graph. Parameters: n (int): The number of nodes in the graph. adjList (List[List[int]]): The adjacency list of the graph. start (int): The starting node for the paths computation. Returns: List[int]: An array where shortestPaths[i] is the length of the shortest path from the start node to node i. If there is no path from start to node i, shortestPaths[i] should be -1. shortestPaths = [-1] * n # Initialize shortest paths array with -1 shortestPaths[start] = 0 # The shortest path to the start node is 0 queue = deque([start]) # Initialize queue with the start node while queue: current = queue.popleft() for neighbor in adjList[current]: if shortestPaths[neighbor] == -1: # If the neighbor hasn\'t been visited shortestPaths[neighbor] = shortestPaths[current] + 1 queue.append(neighbor) return shortestPaths"},{"question":"Given a `matrix` of `n` x `m` dimensions filled with positive integers, implement a function to find the maximum sum of any rectangle inside the matrix. The rectangle inside the matrix is defined by selecting a row pair and a column pair that forms a contiguous sub-matrix. Return the highest possible sum of any such sub-matrix.","solution":"def max_sum_submatrix(matrix): Finds the maximum sum of any rectangle inside the given matrix. :param matrix: List of List of positive integers representing the matrix :return: Maximum sum of sub-matrix if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left_col in range(m): row_sum = [0] * n for right_col in range(left_col, m): for i in range(n): row_sum[i] += matrix[i][right_col] max_sum = max(max_sum, kadane(row_sum)) return max_sum def kadane(arr): Helper function to find the maximum sum contiguous subarray using Kadane\'s algorithm. :param arr: List of integers :return: Maximum sum of the contiguous subarray max_end_here = max_so_far = arr[0] for x in arr[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far"},{"question":"Given an integer array `nums` containing `n` positive integers, you need to find a contiguous subarray that has the largest sum, and return its sum. A subarray is a contiguous part of an array. Your solution should have a time complexity of O(n).","solution":"def max_subarray_sum(nums): Finds the contiguous subarray within an array, nums, which has the largest sum. Args: nums (List[int]): List of positive integers. Returns: int: The sum of the largest contiguous subarray. if not nums: return 0 max_so_far = nums[0] max_ending_here = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"You are given a string `s` representing a mathematical expression containing digits `0-9`, the plus `+` sign, and the minus `-` sign. There are no parentheses and the input string will always be valid. Implement a function to evaluate the expression and return the result. The input expression will be in the form of an integer followed by an alternating sequence of operators and operands. Return the calculated result as an integer.","solution":"def evaluate_expression(s): Evaluates a mathematical expression containing digits, plus and minus signs. :param s: str, a mathematical expression :return: int, result of the evaluation total, number, sign = 0, 0, 1 for char in s: if char.isdigit(): number = number * 10 + int(char) elif char == \'+\': total += sign * number number = 0 sign = 1 elif char == \'-\': total += sign * number number = 0 sign = -1 total += sign * number return total"},{"question":"Given a string `s` representing a **sentence** where each word is separated by a single space, return the **reversed** sentence such that the words appear in reverse order but the words themselves are not reversed. For example, given `s` = \\"hello world\\", the output should be \\"world hello\\".","solution":"def reverse_sentence(s): Returns the sentence with words in reverse order. Parameters: s (str): A string representing a sentence where each word is separated by a single space. Returns: str: The reversed sentence where words appear in reverse order but the words themselves are not reversed. return \' \'.join(s.split()[::-1])"},{"question":"You are given a string `word` and an integer `k`. You need to divide the string into exactly `k` non-overlapping substrings such that the lexicographical order of the concatenated substrings forms the smallest possible string. Return the list of `k` non-overlapping substrings. If there are multiple ways to divide the string, return the lexicographically smallest list of substrings. The substrings in the list must also be in order as they appear in the original string.","solution":"def smallest_lexicographical_substrings(word, k): Divides the string into exactly `k` non-overlapping substrings such that the concatenation of the substrings forms the smallest possible lexicographical string. Parameters: word (str): The input string. k (int): The number of non-overlapping substrings. Returns: list: A list of k non-overlapping substrings. n = len(word) if k > n: # If k is greater than length of word, we cannot split further return [] result = [] part_size = n // k # This is the minimum size each part can be remainder = n % k # This tells us how many parts should be 1 character longer start = 0 for i in range(k): if remainder > 0: # Give this part an extra character end = start + part_size + 1 remainder -= 1 else: end = start + part_size result.append(word[start:end]) start = end return result"},{"question":"Given two integer arrays `nums1` and `nums2` representing sets, return _an array of their intersection_. Each element in the result must be unique and the result can be in any order. For example, if `nums1 = [1, 2, 2, 1]` and `nums2 = [2, 2]`, the function should return `[2]`. If there are no common elements, return an empty array.","solution":"def intersection(nums1, nums2): Returns the intersection of two integer arrays as a new array. Each element in the result must be unique. Args: nums1: List[int] - First list of integers. nums2: List[int] - Second list of integers. Returns: List[int] - A list representing the intersection of nums1 and nums2, with unique elements. set1 = set(nums1) set2 = set(nums2) return list(set1 & set2)"},{"question":"Given an array of integers `heights` representing the heights of plants in a garden, return _the number of_ `segments` _where each segment consists of plants of consecutive indexes with heights in **non-decreasing** order._ A plant in the same segment must be taller than or equal to the plant immediately before it. Your task is to identify and count these segments in the array.","solution":"def count_non_decreasing_segments(heights): Returns the number of segments where the heights are in non-decreasing order. Parameters: heights (list of int): List representing the heights of plants in the garden. Returns: int: Number of non-decreasing segments. if not heights: return 0 n = len(heights) segments_count = 1 # The first element starts the first segment for i in range(1, n): if heights[i] < heights[i - 1]: segments_count += 1 return segments_count"},{"question":"Given a list of accounts where each element `accounts[i]` is a list of strings, where the first element is the name of the account holder and the rest are email addresses. Merge and return the accounts such that each account contains all the email addresses of the same person. Note: Two accounts belong to the same person if there is some common email address, even if the first name is different. Return the merged accounts in any order. For example, given: ``` accounts = [ [\\"John\\", \\"johnsmith@mail.com\\", \\"john00@mail.com\\"], [\\"John\\", \\"johnnybravo@mail.com\\"], [\\"John\\", \\"johnsmith@mail.com\\", \\"john_newyork@mail.com\\"], [\\"Mary\\", \\"mary@mail.com\\"] ] ``` The output should be: ``` [ [\\"John\\", \\"johnnybravo@mail.com\\"], [\\"John\\", \\"john00@mail.com\\", \\"john_newyork@mail.com\\", \\"johnsmith@mail.com\\"], [\\"Mary\\", \\"mary@mail.com\\"] ] ```","solution":"def accountsMerge(accounts): from collections import defaultdict def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): parent[find(x)] = find(y) # Map all emails to unique IDs and initialize the parent array email_to_id = {} parent = {} email_to_name = {} idx = 0 for account in accounts: name = account[0] for email in account[1:]: if email not in email_to_id: email_to_id[email] = idx parent[idx] = idx idx += 1 email_to_name[email] = name union(email_to_id[account[1]], email_to_id[email]) # Group emails by their root parent id_to_emails = defaultdict(list) for email, id_ in email_to_id.items(): root_id = find(id_) id_to_emails[root_id].append(email) # Build the output merged_accounts = [] for emails in id_to_emails.values(): emails.sort() name = email_to_name[emails[0]] merged_accounts.append([name] + emails) return merged_accounts"},{"question":"You are given a binary tree where each node contains a value of `0` or `1`. Each path from the root to any leaf forms a binary number when traversing, where the value at the root represents the most significant bit. Your task is to calculate the sum of all these binary numbers formed by all possible paths from the root to any leaf node. Return the sum of these binary numbers modulo `10^9 + 7`. For example, if a binary tree is as follows: ``` 1 / 0 1 / 0 1 0 ``` The paths from the root to the leaves represent the binary numbers `100`, `101`, and `110`, respectively. The sum of these binary numbers is calculated as: `4 + 5 + 6 = 15`. Return the sum of these binary numbers modulo `10^9 + 7`. (In this case, you\'d return `15`.) Note: - The number of nodes in the binary tree is between `1` and `10^4`. - The value of each node is either `0` or `1`. Define the TreeNode class as follows if needed: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf(root): MOD = 10**9 + 7 def dfs(node, current_val): if not node: return 0 current_val = (current_val << 1) | node.val if not node.left and not node.right: # if it is a leaf return current_val left_sum = dfs(node.left, current_val) right_sum = dfs(node.right, current_val) return (left_sum + right_sum) % MOD return dfs(root, 0)"},{"question":"Given two integers `a` and `b`, find the maximum number of consecutive integers that can be evenly divided by either `a` or `b`. Note that the integers must be positive and start from 1. Return the maximum count of such consecutive integers.","solution":"def max_divisible_sequence(a, b): Returns the maximum number of consecutive integers that can be evenly divided by either a or b starting from 1. if a <= 0 or b <= 0: raise ValueError(\\"Both a and b should be positive integers.\\") lcm_ab = (a * b) // gcd(a, b) return lcm_ab def gcd(x, y): Computes the greatest common divisor (GCD) of x and y. while y: x, y = y, x % y return x"},{"question":"Given an array of integers `arr`, where each integer represents a letter\'s position in the alphabet (1 for \'a\', 2 for \'b\', ..., 26 for \'z\'), return the longest substring of unique letters that can be formed by concatenating elements from `arr`. You should return the substring in its alphabetical form. If there are multiple solutions, return the one which appears first in the alphabetical order. For example, given `arr = [1, 2, 1, 3, 2, 4]`, the longest substring of unique letters is \\"abcd\\". Note: The input array will only contain valid numbers from 1 to 26.","solution":"def longest_unique_substring(arr): Returns the longest substring of unique letters formed by concatenating elements from `arr`. Each integer in `arr` ranges from 1 to 26, representing \'a\' to \'z\'. seen = set() longest = [] for num in arr: # Convert number to corresponding character char = chr(num + 96) if char not in seen: seen.add(char) longest.append(char) return \\"\\".join(longest)"},{"question":"You are given an array `prices` representing the price of a single stock on various days in a chronological order. You are allowed to complete at most one transaction (i.e., buy one and sell one share of the stock). Note that you cannot sell a stock before you buy one. Write a function that determines the maximum profit you can achieve, or returns 0 if no profit can be made. Example: `prices = [7,1,5,3,6,4]` Return `5`, because buying at price `1` and selling at price `6` makes a profit of `6-1 = 5`. `prices = [7,6,4,3,1]` Return `0`, because no profit can be made.","solution":"def max_profit(prices): Returns the maximum profit that can be achieved with at most one transaction. If no profit can be made, returns 0. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Given an **n x n grid** containing only values `0` and `1`, return the length of the longest horizontal, vertical, diagonal, or anti-diagonal line of consecutive `1`s. For a line to be counted, it must be composed solely of contiguous `1`s and may not contain `0`s in between them.","solution":"def longest_line(grid): Returns the length of the longest horizontal, vertical, diagonal, or anti-diagonal line of consecutive 1s. if not grid or not grid[0]: return 0 n = len(grid) max_length = 0 # Initialize DP arrays hor = [[0] * n for _ in range(n)] ver = [[0] * n for _ in range(n)] diag = [[0] * n for _ in range(n)] anti_diag = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): if grid[i][j] == 1: hor[i][j] = hor[i][j-1] + 1 if j > 0 else 1 ver[i][j] = ver[i-1][j] + 1 if i > 0 else 1 diag[i][j] = diag[i-1][j-1] + 1 if i > 0 and j > 0 else 1 anti_diag[i][j] = anti_diag[i-1][j+1] + 1 if i > 0 and j < n-1 else 1 max_length = max(max_length, hor[i][j], ver[i][j], diag[i][j], anti_diag[i][j]) return max_length"},{"question":"You are given an array `arr` consisting of integers, where each element in the array represents the length of a line segment. Your task is to determine if these segments can form a non-degenerate triangle. A non-degenerate triangle is one where the sum of the lengths of any two sides is greater than the length of the remaining side. Return `true` if it is possible to form at least one non-degenerate triangle with the given segments, and `false` otherwise.","solution":"def can_form_triangle(arr): Determines if any three segments in the array can form a non-degenerate triangle. arr.sort() n = len(arr) for i in range(n - 2): if arr[i] + arr[i + 1] > arr[i + 2]: return True return False"},{"question":"You are given a list of `n` integers `nums`, where each integer represents a candle\'s height. You can extinguish any candle to remove it from the list. Your goal is to maximize the total height of the remaining candles after removing a number of candles equal to `k`. Write a function to find the maximum total height of the remaining candles after removing exactly `k` candles. The function should return the maximum possible sum of the heights of the remaining candles.","solution":"def max_remaining_height(nums, k): Returns the maximum total height of the remaining candles after removing k candles. :param nums: List of integers representing the height of the candles :param k: Number of candles to remove :return: Maximum possible sum of the heights of the remaining candles if k >= len(nums): return 0 nums.sort() return sum(nums[k:]) # Example usage # nums = [4, 7, 1, 2, 3] # k = 2 # The result should be 4 + 7 = 11 (after removing the smallest two candles: 1 and 2)"},{"question":"Given a list of events where each event is represented as a tuple (start_time, end_time), determine if a person can attend all events without any overlap. Implement the function `canAttendAllEvents(events)`, which takes a list of events as input and returns a boolean indicating if it is possible to attend all events. For example, given the input `[(1,3), (2,4), (5,6)]`, the function should return `False`, because the events (1,3) and (2,4) overlap. However, given the input `[(1,2), (3,4), (5,6)]`, the function should return `True` because none of the events overlap.","solution":"def canAttendAllEvents(events): Determines if a person can attend all events without any overlap. :param events: List of tuples, where each tuple represents an event with (start_time, end_time). :return: Boolean indicating if it is possible to attend all events without overlap. # Sort events by their start time events.sort(key=lambda x: x[0]) for i in range(1, len(events)): # Check if current event\'s start time is less than the previous event\'s end time if events[i][0] < events[i - 1][1]: return False return True"},{"question":"Given a string `s`, a string `t`, and an integer `k`, determine whether you can transform `s` into `t` by performing exactly `k` operations. In one operation, you can: - Choose any character of `s` and change it to any other character. Return `true` if it is possible to transform `s` into `t` exactly in `k` operations, otherwise return `false`.","solution":"def can_transform(s, t, k): Determines if string s can be transformed into string t with exactly k operations. Parameters: s (str): The original string. t (str): The target string. k (int): The exact number of operations allowed. Returns: bool: True if the transformation is possible in exactly k operations, False otherwise. # Check if lengths of s and t are the same if len(s) != len(t): return False # Count the number of different characters diff_count = sum(1 for sc, tc in zip(s, t) if sc != tc) # Check if the exact number of changes needed is achievable with exactly k operations return diff_count == k"},{"question":"You have been tasked with implementing a simplified version of a spell checker. Given a list of words in a dictionary and a string containing a single word, determine whether the given word is spelled correctly. A word is considered correctly spelled if it exactly matches one of the words in the dictionary (case-sensitive). If the word is not found in the dictionary, your function should identify the closest match by returning the first lexicographically minimal word from the dictionary that has the shortest edit distance to the given word. The edit distance considers the number of single-character edits (insertions, deletions, or substitutions) required to transform one string into the other. Your function should return the input word if it’s correctly spelled or the closest match otherwise.","solution":"def edit_distance(word1, word2): Compute the edit distance between two words. len1, len2 = len(word1), len(word2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): for j in range(len2 + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[len1][len2] def spell_checker(dictionary, word): Check the spelling of a given word against a dictionary. if word in dictionary: return word min_distance = float(\'inf\') closest_word = None for dict_word in dictionary: current_distance = edit_distance(dict_word, word) if current_distance < min_distance or (current_distance == min_distance and dict_word < closest_word): min_distance = current_distance closest_word = dict_word return closest_word"},{"question":"You are given a data structure that simulates a dynamic, resizable array of integers. This data structure supports basic operations such as inserting elements, deleting elements, and retrieving the current state of the array. Additionally, it maintains an internal versioning system, where each modification to the array (insertion or deletion) is associated with a unique version number. A user should be able to retrieve the state of the array at any given version. Implement the `VersionedArray` class: * `VersionedArray()` Initializes the object. * `int add(int value)` Inserts an integer `value` at the end of the array. The array length is increased by `1` and a new version number is returned. * `int remove()` Removes the last element from the array if the array is non-empty, decreases the array length by `1`, and returns a new version number. If the array is empty, this operation should not be performed and return `-1`. * `List<Integer> getArrayAtVersion(int version)` Returns the state of the array at the specified `version`. If the version does not exist, return an empty list. Example: ``` VersionedArray va = new VersionedArray(); int version1 = va.add(3); // Initially, the array is [3] int version2 = va.add(5); // Now, the array is [3, 5] int version3 = va.remove(); // Now, the array is [3] List<Integer> arrayVersion1 = va.getArrayAtVersion(version1); // Returns [3] List<Integer> arrayVersion2 = va.getArrayAtVersion(version2); // Returns [3, 5] List<Integer> arrayVersion3 = va.getArrayAtVersion(version3); // Returns [3] ``` Note: - The version numbers should start from `1` and increment sequentially with each operation. - Each operation\'s complexity should be optimal regarding time and space efficiency.","solution":"class VersionedArray: def __init__(self): self.versions = [] self.current_array = [] self.version_number = 0 def add(self, value): self.current_array.append(value) self.version_number += 1 self.versions.append(list(self.current_array)) return self.version_number def remove(self): if not self.current_array: return -1 self.current_array.pop() self.version_number += 1 self.versions.append(list(self.current_array)) return self.version_number def getArrayAtVersion(self, version): if 1 <= version <= len(self.versions): return self.versions[version - 1] return []"},{"question":"Given a list of integers `arr`, return a list containing all the elements of `arr` that appear more than once, sorted in ascending order. Each element in the resulting list should appear only once.","solution":"def find_duplicates(arr): Returns a sorted list of elements that appear more than once in \'arr\'. Each element in the resulting list appears only once. from collections import Counter counter = Counter(arr) duplicates = [item for item, count in counter.items() if count > 1] return sorted(duplicates)"},{"question":"Given a `2D` matrix `matrix` of dimensions `n x n` where each cell contains an integer, write a function to rotate the matrix `90` degrees clockwise *in-place*. The rotation must be done without using an additional matrix, and you should modify the input matrix directly.","solution":"def rotate_matrix(matrix): Rotates the n x n matrix 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given an integer array `heights` representing the heights of students standing in a line in non-decreasing order. A set of rules allows for adjusting the height of only one student. Specifically, you can add any positive integer value to the height of exactly one student in one move. Return _the minimum number of moves required such that all students are standing in strictly increasing order of their heights_. If it is impossible to achieve this configuration, return `-1`.","solution":"def min_moves_to_strictly_increasing(heights): Given an integer array heights representing the heights of students standing in a line in non-decreasing order, determine the minimum number of moves required to make all students\' heights strictly increasing. :param heights: List[int], array of non-decreasing integers representing heights :return: int, number of moves required, or -1 if impossible n = len(heights) # Iterate through the heights and find any non-strictly increasing parts for i in range(n - 1): if heights[i] >= heights[i + 1]: # We can fix it by adding any positive integer to heights[i] # To make sure heights[i] < heights[i + 1], we can set heights[i + 1] to heights[i] + 1 heights[i + 1] = heights[i] + 1 return 1 # If the array was strictly increasing from the start return 0"},{"question":"You are given a matrix of `n` rows and `m` columns that contains integers. Find the size of the largest square sub-matrix that contains all equal elements. If there are multiple sub-matrices with the same size, return the size of any one of them. The size of a square sub-matrix is the number of elements it contains (not its side length).","solution":"def largest_equal_submatrix(matrix): Find the size of the largest square sub-matrix that contains all equal elements. :param matrix: List[List[int]] - the matrix of integers :return: int - size of the largest square sub-matrix with all equal elements if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) # dp[i][j] will store the side length of the largest square sub-matrix # whose bottom-right corner is at (i, j) and all elements are equal. dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if i == 0 or j == 0: dp[i][j] = 1 elif matrix[i][j] == matrix[i-1][j] == matrix[i][j-1] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side_length = max(max_side_length, dp[i][j]) # The size of the largest square sub-matrix is the square of its side length return max_side_length ** 2"},{"question":"You are given an integer array `arr` where each element is a **positive integer**. You need to sort the array in non-decreasing order, but the sorting criteria is based on the number of **1s** in the binary representation of each element. If two elements have the same number of 1s, they should appear in the same order as they do in the original array. Return _the sorted array_. # Example: ```plaintext Input: arr = [3, 7, 8, 6] Output: [8, 3, 6, 7] Explanation: - 8 in binary is 1000, which has 1 one. - 3 in binary is 11, which has 2 ones. - 6 in binary is 110, which has 2 ones. - 7 in binary is 111, which has 3 ones. Sorting by the number of 1s we get: [8, 3, 6, 7]. Since both 3 and 6 have the same number of 1s, they should retain their original order. ```","solution":"def sort_by_binary_ones(arr): Sorts the array in non-decreasing order based on the number of 1s in the binary representation of each element. If two elements have the same number of 1s, they will appear in the same order as in the original array. return sorted(arr, key=lambda x: (bin(x).count(\'1\'), arr.index(x)))"},{"question":"You are given a string `s` representing a sequence of characters and a list of words `words` that need to be formed from distinct characters in `s`. Each word in `words` must be formed by extracting characters in `s` in their given order, but the characters do not need to be contiguous. Determine if it is possible to form all the words in `words` from `s` using the distinct character rule and return a list of booleans, where each boolean corresponds to whether the respective word in `words` can be formed.","solution":"def can_form_words(s, words): def can_form(word, s): it = iter(s) return all(char in it for char in word) return [can_form(word, s) for word in words]"},{"question":"Given a matrix of integers `grid` where each cell may have a max of three possible values: `0` representing an empty cell, `1` representing a fresh orange, or `2` representing a rotten orange. We can rot adjacent fresh oranges from a rotten orange in one unit time. Rotten oranges can affect up, down, left, and right adjacent cells. Your task is to determine the minimum time required to rot all the fresh oranges. If it is not possible to rot all the fresh oranges, return `-1`.","solution":"from collections import deque def orangesRotting(grid): Returns the minimum time required to rot all the fresh oranges. If not all oranges can be rotted, returns -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) if grid[r][c] == 1: fresh_count += 1 max_minutes = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: r, c, minutes = queue.popleft() max_minutes = max(max_minutes, minutes) for dr, dc in directions: rr, rc = r + dr, c + dc if 0 <= rr < rows and 0 <= rc < cols and grid[rr][rc] == 1: grid[rr][rc] = 2 fresh_count -= 1 queue.append((rr, rc, minutes + 1)) return max_minutes if fresh_count == 0 else -1"},{"question":"You are given a string `s` consisting of lowercase letters and the character `\'*\'`. You must replace every `\'*\'` with a lowercase letter such that no two adjacent characters are the same. You are guaranteed that it is always possible to do so. Return _the modified string_.","solution":"def replace_asterisks(s): Replaces every \'*\' in the input string `s` with a lowercase letter such that no two adjacent characters are the same. s = list(s) n = len(s) for i in range(n): if s[i] == \'*\': for c in \'abcdefghijklmnopqrstuvwxyz\': if (i > 0 and s[i - 1] == c) or (i < n - 1 and s[i + 1] == c): continue s[i] = c break return \'\'.join(s)"},{"question":"Given an integer array `nums`, you need to find a contiguous subarray (containing at least one number) which has the **maximum product**, and return the product. Your task is to complete the function that takes in `nums` and returns this maximum product. The implementation should handle both positive and negative integers as elements of the array. For example, given the array `nums = [2, 3, -2, 4]`, the contiguous subarray `[2, 3]` has the largest product `6`. ---","solution":"def max_product(nums): if not nums: return 0 current_max = current_min = global_max = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) global_max = max(global_max, current_max) return global_max"},{"question":"A company is scheduling interviews for a list of applicants. Each applicant has a start time and an end time represented by a pair of integers `[start, end]`, where `start` is the time the interview starts and `end` is the time the interview ends. The goal is to determine the maximum number of non-overlapping interviews that can be scheduled. Two interviews `[start1, end1]` and `[start2, end2]` are considered non-overlapping if `end1 <= start2` or `end2 <= start1`. Given a list of `n` interviews represented as `intervals`, where `intervals[i] = [start_i, end_i]`, return _the maximum number of non-overlapping interviews that can be scheduled from this list_. Example: ``` Input: intervals = [[1,3], [2,4], [3,5]] Output: 2 Explanation: The maximum number of non-overlapping interviews is 2 ([[1,3], [3,5]]). ```","solution":"def maxNonOverlappingIntervals(intervals): Returns the maximum number of non-overlapping intervals. # Sort intervals by end time intervals.sort(key=lambda x: x[1]) count = 0 end_time = float(\'-inf\') for interval in intervals: if interval[0] >= end_time: count += 1 end_time = interval[1] return count"},{"question":"Given an integer array `nums` and an integer `k`, return _the maximum number of distinct elements in any subarray of length `k`_. A **subarray** is a contiguous sequence of elements within an array. If `k` is larger than the length of the array, return `-1`.","solution":"def max_distinct_in_subarray(nums, k): if k > len(nums): return -1 from collections import defaultdict # Dictionary to count the frequency of elements in the current window count = defaultdict(int) distinct_count = 0 max_distinct = 0 for i in range(k): if count[nums[i]] == 0: distinct_count += 1 count[nums[i]] += 1 max_distinct = distinct_count for i in range(k, len(nums)): if count[nums[i - k]] == 1: distinct_count -= 1 count[nums[i - k]] -= 1 if count[nums[i]] == 0: distinct_count += 1 count[nums[i]] += 1 max_distinct = max(max_distinct, distinct_count) return max_distinct"},{"question":"You are given an **0-indexed** integer array `arr` of size `n`. An important property of `arr` is that it contains exactly `k` inversion pairs. An inversion pair in the array is a pair `arr[i] > arr[j]` where `0 <= i < j < n`. You need to determine the minimum possible value of `k` and the maximum possible value of `k` for any permutations of `arr`. Return _a tuple containing these two values_, with the first element representing the minimum possible value of `k` and the second element representing the maximum possible value of `k`.","solution":"def inversion_limits(n): Returns a tuple containing the minimum possible value of k and the maximum possible value of k for an array of size n. # Minimum inversions (k) is always 0, achieved when the array is sorted in ascending order. min_k = 0 # Maximum inversions (k) is achieved when the array is sorted in descending order. # This would result in the sum of the first (n-1) natural numbers. max_k = n * (n - 1) // 2 return (min_k, max_k)"},{"question":"You are given the head of a singly linked list and an integer `k`. Rotate the list to the right by `k` places. Implement the `rotateRight` function: * `ListNode rotateRight(ListNode head, int k)` This function rotates the linked list to the right by `k` places and returns the new head of the rotated list. Your implementation should handle cases where the list has zero or one node without breaking. Ensure that your solution adjusts if `k` is greater than the length of the list. Define the `ListNode` class as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Determine the length of the linked list tail, length = head, 1 while tail.next: tail = tail.next length += 1 # Find the effective number of rotations k = k % length if k == 0: return head # Identify the new tail (length - k)th node new_tail_position = length - k new_tail = head for _ in range(new_tail_position - 1): new_tail = new_tail.next # New head is the next node after new_tail new_head = new_tail.next # Break the list new_tail.next = None # Old tail connects to the original head tail.next = head return new_head"},{"question":"Design an algorithm that manages a real-time leaderboard, where players can submit their scores. Implement the `Leaderboard` class: * `Leaderboard()` Initializes the leaderboard object. * `void addScore(int playerId, int score)` Updates the score of the player with `playerId` by adding the `score` to their current score. If the player does not exist, they are added to the leaderboard with the given `score`. * `int top(int K)` Returns the sum of the scores of the top `K` players. * `void reset(int playerId)` Resets the score of the player with `playerId` to `0` (i.e., removes their score from the leaderboard).","solution":"class Leaderboard: def __init__(self): Initializes the leaderboard object. self.scores = {} def addScore(self, playerId, score): Updates the score of the player with `playerId` by adding the `score` to their current score. If the player does not exist, they are added to the leaderboard with the given `score`. if playerId not in self.scores: self.scores[playerId] = 0 self.scores[playerId] += score def top(self, K): Returns the sum of the scores of the top `K` players. top_scores = sorted(self.scores.values(), reverse=True)[:K] return sum(top_scores) def reset(self, playerId): Resets the score of the player with `playerId` to `0`. if playerId in self.scores: self.scores[playerId] = 0"},{"question":"You are given an array of positive integers `heights` representing the heights of students in a class. A group of students is considered valid if the students can be arranged in a non-decreasing order of their heights. You are also given an integer `k`, which represents the maximum difference allowed between the highest and the lowest height in any valid group. Return _the maximum number of valid groups_ of students that can be formed from the given heights array such that each group meets the height difference constraint. Each student can belong to at most one group.","solution":"def max_valid_groups(heights, k): Returns the maximum number of valid groups of students that can be formed such that the height difference within each group does not exceed k. :param heights: List[int] - List of student heights :param k: int - Maximum allowed height difference within a group :return: int - Maximum number of valid groups # Sort the heights array heights.sort() groups = 0 i = 0 while i < len(heights): start = heights[i] while i < len(heights) and heights[i] - start <= k: i += 1 groups += 1 return groups"},{"question":"You are given a string `s` consisting of only lowercase English letters. A **substring** is any contiguous sequence of characters within the string. A **good substring** is defined as a substring which contains exactly `k` distinct characters. Return _the **length** of the longest good substring_ in `s`. If there is no such substring, return `-1`.","solution":"def length_of_longest_good_substring(s, k): Return the length of the longest good substring with exactly k distinct characters. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The required number of distinct characters in the substring. Returns: int: The length of the longest good substring with exactly k distinct characters, or -1 if no such substring exists. from collections import defaultdict n = len(s) if n == 0 or k == 0: return -1 char_count = defaultdict(int) left = 0 max_len = -1 for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an integer array `arr` and an integer `x`. Find the starting and ending position of `x` in the array. If `x` is not found in the array, return `[-1, -1]`. The starting position is the first occurrence of `x`, and the ending position is the last occurrence of `x`. Ensure your solution has a linear time complexity. Return the result as an array of two integers.","solution":"def find_start_end(arr, x): Finds the starting and ending position of x in the array. If x is not found, returns [-1, -1]. start = -1 end = -1 for i in range(len(arr)): if arr[i] == x: if start == -1: start = i end = i return [start, end]"},{"question":"Given an array of `n` integers `nums`, where `nums[i]` represents the amount of money of the `i-th` house. You are a thief who plans to rob houses, but you cannot rob two adjacent houses because the police will be alerted. Your goal is to maximize the amount of money you can rob tonight without alerting the police. Return the maximum amount of money you can rob without robbing two adjacent houses.","solution":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses. if not nums: return 0 elif len(nums) == 1: return nums[0] # Initialize an array to store the maximum money robbed up to each house max_robbed = [0] * len(nums) # The first house\'s money is the only option if only one house is considered max_robbed[0] = nums[0] # For the second house, choose the maximum between robbing first house or second house max_robbed[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): # For each house, check if robbing this house plus the amount robbed till (i-2) house is greater # than the amount robbed up to the (i-1) house max_robbed[i] = max(max_robbed[i-1], nums[i] + max_robbed[i-2]) return max_robbed[-1]"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to determine the **k-th** smallest element in the array after sorting it in non-decreasing order. Your solution should aim to achieve an average time complexity of `O(n log n)`. Return the `k-th` smallest element from the array. If `k` is larger than the length of the array, return `-1`.","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the sorted array. If k is larger than the length of the array, return -1. if k > len(arr) or k <= 0: return -1 arr.sort() return arr[k - 1]"},{"question":"You are given an array of integers `arr` representing the height of buildings, where `arr[i]` represents the height of the i-th building. The buildings form a skyline viewed from left to right. A building is **visible** if it is not completely shadowed by taller buildings to its left. Return the number of visible buildings.","solution":"def count_visible_buildings(arr): Returns the number of visible buildings given an array of building heights. A building is visible if it is not completely shadowed by taller buildings to its left. :param arr: List[int] - heights of the buildings :return: int - the number of visible buildings if not arr: return 0 visible_count = 1 max_height = arr[0] for height in arr[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a list of integers `nums` where each integer represents the number of books in a specific pile. Each day, you can choose any number of books from any one pile to read. The next day, you must read exactly one book more than you read the previous day from the same pile, continuing this pattern each subsequent day. If, at any point, a pile does not have enough books for the required number of reads, you must stop reading from that pile. Return the maximum number of books you can read in total from any single pile.","solution":"def max_books_from_pile(pile): Given a pile of books represented by a list of integers, return the maximum number of books that can be read consecutively following the rule: read one book the first day, one more than the day before on each subsequent day from the same pile. total_books = 0 day = 1 while total_books + day <= pile: total_books += day day += 1 return total_books"},{"question":"Given a string `s` that represents an arithmetic expression containing only non-negative integers, the addition operator \'+\', the multiplication operator \'*\', and parentheses \'(\' and \')\', write a function that evaluates the expression and returns its value. The input string is guaranteed to be a valid arithmetic expression. You can assume that the operator precedence is the usual precedence for arithmetic expressions.","solution":"def evaluate_expression(s: str) -> int: Evaluates a given arithmetic expression string containing non-negative integers, the addition operator \'+\', the multiplication operator \'*\', and parentheses \'(\', \')\'. def helper(tokens): stack = [] num = 0 sign = \'+\' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \'(\': num = helper(tokens) if token in \'+*)\' or not tokens: if sign == \'+\': stack.append(num) elif sign == \'*\': stack[-1] *= num if token == \')\': break sign = token num = 0 return sum(stack) tokens = [] i = 0 while i < len(s): if s[i].isdigit(): num = \'\' while i < len(s) and s[i].isdigit(): num += s[i] i += 1 tokens.append(num) else: tokens.append(s[i]) i += 1 return helper(tokens)"},{"question":"Given a string `s` representing a sorted sequence of **distinct** lowercase letters and an integer `n`, return the list of all possible combinations of `n` letters chosen from the string `s`. The combinations should be returned in lexicographical order.","solution":"from itertools import combinations def letter_combinations(s, n): Returns a list of all possible combinations of `n` letters chosen from the string `s`, in lexicographical order. :param s: A string representing a sorted sequence of distinct lowercase letters :param n: An integer representing the number of letters in each combination :return: A list of combinations return [\'\'.join(combo) for combo in combinations(s, n)]"},{"question":"You are given an integer array `measurements` representing the water levels recorded hourly in a reservoir for `n` consecutive hours. Calculate the number of times the water level increased compared to the previous hour. For example, if `measurements` is `[5, 3, 6, 7, 8, 3, 4]`, the water level increases at `measurements[2]`, `measurements[3]`, `measurements[4]`, and `measurements[6]`. Return _the total number of water level increases_.","solution":"def count_increases(measurements): Returns the number of times the water level increased compared to the previous hour. :param measurements: List of integers representing water levels for n consecutive hours. :return: Integer count of increases in water level compared to the previous hour. increases = 0 for i in range(1, len(measurements)): if measurements[i] > measurements[i - 1]: increases += 1 return increases"},{"question":"You are given an array of `n` integers, `arr`, and an integer `k`. Construct a new array `result` of length `n`, where `result[i]` is equal to the sum of elements in the subarray `arr[i]` to `arr[min(i+k-1, n-1)]`. Return the `result` array.","solution":"def construct_sum_subarray(arr, k): Returns a new array where each element i is the sum of elements from i to min(i+k-1, n-1) in the input array arr. n = len(arr) result = [0] * n for i in range(n): # Calculate the sum of elements from arr[i] to arr[min(i+k-1, n-1)] end = min(i + k, n) result[i] = sum(arr[i:end]) return result"},{"question":"You are given a string `s` consisting only of lowercase English letters and the space character `\' \'`. You need to implement a class `WordFrequency` that tracks the frequency of each word in the string and can manage updates and queries efficiently. Implement the `WordFrequency` class: * `WordFrequency(String s)` Initializes the object with the input string `s`. * `void addWord(String word)` Adds a word to the string `s` and updates the frequency count. * `int getFrequency(String word)` Returns the frequency of the given word in the string `s`. For example, given `s = \\"the quick brown fox jumps over the lazy dog\\"`, calling `getFrequency(\\"the\\")` would return `2`, and `addWord(\\"quick\\")` would increment the frequency of \\"quick\\" to `2`.","solution":"from collections import defaultdict class WordFrequency: def __init__(self, s): Initializes the object with the input string `s`. self.freq = defaultdict(int) self.process_string(s) def process_string(self, s): Processes the input string and updates the frequency count of each word. words = s.split() for word in words: self.freq[word] += 1 def addWord(self, word): Adds a word to the string and updates the frequency count. self.freq[word] += 1 def getFrequency(self, word): Returns the frequency of the given word in the string. return self.freq[word]"},{"question":"You are given an integer array `nums` and an integer `k`. You need to form a sum of `k` elements from `nums` such that the sum is as large as possible, and then return the maximum sum. If `k` is greater than the length of `nums`, return -1. Given an array `nums = [4, 1, 7, 16, 9]` and `k = 3`, the maximum sum of `k` elements would be `16 + 9 + 7 = 32`. Implement the function: ```python def max_k_sum(nums: List[int], k: int) -> int: # Your implementation here ``` # Example: **Input:** nums = [1, 23, 12, 9, 30, 2, 50], k = 3 **Output:** 103 Explanation: The maximum sum from 3 elements would be `50 + 30 + 23 = 103`.","solution":"def max_k_sum(nums, k): Returns the maximum sum of `k` elements from the list `nums`. If `k` is greater than the length of `nums`, returns -1. if k > len(nums): return -1 # Sort the list in descending order nums.sort(reverse=True) # Sum the first `k` elements return sum(nums[:k])"},{"question":"You are given an integer array `nums` of length `n` and an integer `k`. You need to determine if there is a contiguous subarray of length exactly `k` such that the sum of the elements in the subarray is maximized. If multiple subarrays have the same maximum sum, return the first one. Return a list containing the elements of that subarray.","solution":"def max_subarray_of_length_k(nums, k): Find the contiguous subarray of length exactly k with the maximum sum. If multiple subarrays have the same maximum sum, return the first one. :param nums: List[int] - list of integers :param k: int - length of the subarray :return: List[int] - subarray of length k with the maximum sum if len(nums) < k: return [] # Initialize the sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) max_start_idx = 0 # Iterate through the array to find the maximum subarray sum for i in range(k, len(nums)): # Slide the window to the right by subtracting the element going out of the window # and adding the next element coming into the window current_sum = current_sum - nums[i - k] + nums[i] if current_sum > max_sum: max_sum = current_sum max_start_idx = i - k + 1 return nums[max_start_idx:max_start_idx + k]"},{"question":"You are given a list of non-negative integers representing the amount of money of each house, arranged in a circular manner. Each house is adjacent to two others. A thief wants to maximize the amount of money stolen, but cannot rob two adjacent houses. Write a function `robCircular(nums: List[int]) -> int` that returns the maximum amount of money the thief can steal without alerting the police. The circular arrangement means that the first house is adjacent to the last house. The function should handle edge cases where the input list is of length 0 or 1. Your solution should have a linear runtime complexity. Example: ```python robCircular([2,3,2]) -> 3 robCircular([1,2,3,1]) -> 4 ```","solution":"from typing import List def robCircular(nums: List[int]) -> int: Returns the maximum amount of money the thief can steal from houses in a circular arrangement. if not nums: return 0 if len(nums) == 1: return nums[0] def rob(nums: List[int]) -> int: prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1 # Case 1: Rob houses from 0 to n-2 (exclude the last house) # Case 2: Rob houses from 1 to n-1 (exclude the first house) return max(rob(nums[:-1]), rob(nums[1:]))"},{"question":"Given an m x n matrix `grid` of integers representing a landscape in which `0` represents water and `1` represents land, find the number of distinct islands. An island is defined as a group of `1`s connected horizontally or vertically (not diagonally) and surrounded by `0`s. You may assume all four edges of the grid are surrounded by water. Implement the `Solution` class: * `int numIslands(char[][] grid)` - this method receives a matrix `grid` and returns the number of distinct islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.","solution":"def numIslands(grid): if not grid: return 0 def dfs(grid, r, c): if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] == \'0\': return grid[r][c] = \'0\' # Mark as visited dfs(grid, r + 1, c) dfs(grid, r - 1, c) dfs(grid, r, c + 1) dfs(grid, r, c - 1) islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': islands += 1 dfs(grid, i, j) return islands"},{"question":"You are given a string `s` consisting of lowercase English letters. A subsequence of `s` is called a **perfect subsequence** if all the letters in the subsequence are the same. Return _the maximum length of a perfect subsequence that can be derived from `s`_. For instance, given the string \\"abcabcabcc\\", the maximum length of a perfect subsequence is `4` because the subsequence \\"cccc\\" can be derived from `s`.","solution":"def max_perfect_subsequence_length(s): Returns the maximum length of a perfect subsequence that can be derived from s. A perfect subsequence is a subsequence where all the characters are the same. from collections import Counter # Count the frequency of each character in the string frequency = Counter(s) # The maximum length of a perfect subsequence is the highest frequency of any character return max(frequency.values()) if frequency else 0"},{"question":"You are given an array of integers `nums` and an integer `target`. Find two distinct integers in the array such that their sum is closest to the `target`. If there are multiple pairs with the same closest sum, return any one of them. Return the two integers in the order they appear in the array. For instance, if `nums` is `[4, 2, 6, 1, 5]` and `target` is `8`, the pair `[6, 2]` has a sum closest to `8`, and should be returned. If `nums` is `[10, 22, 28, 29, 30, 40]` and `target` is `54`, either `[22, 30]` or `[28, 29]` could be returned since both pairs have sums equally close to `54`.","solution":"def closest_sum_pair(nums, target): Returns a pair of integers from nums such that their sum is closest to the target. If there are multiple pairs with the same closest sum, any one of them is returned. if len(nums) < 2: return [] closest_pair = [] closest_diff = float(\'inf\') for i in range(len(nums)): for j in range(i + 1, len(nums)): current_sum = nums[i] + nums[j] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = [nums[i], nums[j]] return closest_pair"},{"question":"You have a list of integers `nums` and an integer `k`. Write a function to determine if you can divide the list into `k` non-empty subsets whose sums are all equal. Return `true` if such partition is possible, otherwise return `false`.","solution":"def can_partition_k_subsets(nums, k): Determine if the list nums can be partitioned into k non-empty subsets with equal sums. total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) def backtrack(k, start, current_sum): if k == 0: return True if current_sum == target: return backtrack(k-1, 0, 0) for i in range(start, len(nums)): if not used[i] and current_sum + nums[i] <= target: used[i] = True if backtrack(k, i+1, current_sum + nums[i]): return True used[i] = False return False return backtrack(k, 0, 0)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`, where `n` is even. You need to split the array into two equal parts and find a contiguous subarray from each part such that the sums of these two subarrays are as close as possible. The selected subarrays can have different lengths and can start at any index within their respective halves, but they must not overlap from one half to another. Return _the minimum difference between the sums of the chosen subarrays_.","solution":"def min_subarray_difference(nums): Returns the minimum difference between the sums of chosen subarrays from two halves. n = len(nums) half = n // 2 left_part = nums[:half] right_part = nums[half:] # Function to calculate all possible subarray sums in a given part def subarray_sums(arr): sums = [] for i in range(len(arr)): current_sum = 0 for j in range(i, len(arr)): current_sum += arr[j] sums.append(current_sum) return sums left_sums = subarray_sums(left_part) right_sums = subarray_sums(right_part) left_sums.sort() right_sums.sort() # Find the minimum possible difference using two sorted lists of subarray sums min_diff = float(\'inf\') i, j = 0, 0 while i < len(left_sums) and j < len(right_sums): diff = abs(left_sums[i] - right_sums[j]) min_diff = min(min_diff, diff) if left_sums[i] < right_sums[j]: i += 1 else: j += 1 return min_diff"},{"question":"You are given a `chain of ropes` represented as an array of integers `lengths`, where each element represents the length of a rope. You need to perform the following operation until only one rope remains: Choose the two ropes with the smallest lengths, tie them together to form a new rope, and the cost of this operation is equal to the sum of the lengths of the two ropes. The new rope will then replace the two ropes in the array. Return the minimum total cost to tie all the ropes into one single rope.","solution":"import heapq def min_cost_to_tie_ropes(lengths): Calculate the minimum cost to tie all ropes into one single rope. Parameters: lengths (list of int): The lengths of the ropes. Returns: int: The minimum total cost to tie all ropes together. if len(lengths) == 1: return 0 heapq.heapify(lengths) total_cost = 0 while len(lengths) > 1: first = heapq.heappop(lengths) second = heapq.heappop(lengths) cost = first + second total_cost += cost heapq.heappush(lengths, cost) return total_cost"},{"question":"You are given an m x n binary matrix grid, where `0` represents a sea cell and `1` represents a land cell. An island is a group of connected `1`s (land cells) that can be connected in one of the four possible directions (horizontal or vertical). You may assume all four edges of the grid are surrounded by sea. Find the maximum area of an island in the given grid. An island\'s area is the number of land cells in the island. Write a function: ```python def max_area_of_island(grid: List[List[int]]) -> int: # your code here ```","solution":"def max_area_of_island(grid): def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark the land cell as visited area = 1 # explore all 4 directions area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. A valid subsequence is defined as a subsequence that contains no more than `k` distinct numbers. Return _the length of the longest valid subsequence that can be formed from_ `nums`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_valid_subsequence(nums, k): Returns the length of the longest valid subsequence that contains no more than k distinct numbers. from collections import defaultdict max_len = 0 current_subseq = [] distinct_count = defaultdict(int) left = 0 for right in range(len(nums)): distinct_count[nums[right]] += 1 current_subseq.append(nums[right]) while len(distinct_count) > k: distinct_count[current_subseq[left]] -= 1 if distinct_count[current_subseq[left]] == 0: del distinct_count[current_subseq[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an integer array `nums` representing coordinates of houses. A robber has to rob at least one house, but he cannot rob two adjacent houses due to the security system in place. Return the maximum amount of money the robber can rob without triggering the alarm. Each house `i` will have an amount of money represented by `nums[i]`.","solution":"def rob(nums): Returns the maximum amount of money the robber can rob without triggering the alarm. :param nums: List[int] representing money at each house. :return: int maximum amount of money that can be robbed. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize dp array dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a binary tree where each node has an integer value. Define a path in the binary tree as a sequence of nodes starting from the root node and ending at any leaf node. The **depth sum** of a path is defined as the sum of the values of the nodes multiplied by their respective depths along that path. Write a function that returns an integer representing the maximum **depth sum** observed among all paths in the binary tree. The depth of the root node is 1, its children are at depth 2, and so on.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth_sum(root): def helper(node, depth): if not node: return 0 current_sum = node.val * depth if not node.left and not node.right: return current_sum left_sum = helper(node.left, depth + 1) right_sum = helper(node.right, depth + 1) return max(current_sum + left_sum, current_sum + right_sum) return helper(root, 1)"},{"question":"You are given a positive integer `n` representing the number of rows of a square matrix populated row-wise with the first `n^2` positive integers in sequence. Your task is to transform this matrix into a **spiral order** matrix and return the resulting matrix. A matrix is said to be in spiral order if the elements are arranged in a clockwise spiral pattern starting from the top-left element. The matrix should be represented as a 2D list (list of lists) where each sublist represents a row of the matrix.","solution":"def generate_spiral_matrix(n): Generates an n x n matrix populated with the first n^2 positive integers in spiral order. :param n: The number of rows and columns of the square matrix. :return: A 2D list representing the n x n matrix in spiral order. matrix = [[0] * n for _ in range(n)] num = 1 top, bottom = 0, n - 1 left, right = 0, n - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left along the bottom row if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Traverse from bottom to top along the left column if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"Given a string `s`, return the longest substring that contains at most two distinct characters. If there are multiple substrings with the same length, return the one which appears first. You may assume that `s` consists only of lowercase English letters. For example, given the string `s = \\"eceba\\"`, the function should return `\\"ece\\"` since that is the longest substring with at most two distinct characters.","solution":"def longest_substr_two_distinct(s): Returns the longest substring that contains at most two distinct characters. If there are multiple substrings with the same length, returns the one which appears first. :param s: str - the input string :return: str - the longest substring with at most two distinct characters if not s: return \\"\\" n = len(s) left = 0 right = 0 max_len = 0 max_substr = \\"\\" char_map = {} while right < n: char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 if max_len < (right - left + 1): max_len = right - left + 1 max_substr = s[left:right+1] right += 1 return max_substr"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to mathematically encode this string into another string `encoded` using the following rules: 1. Each letter in the string represents its position in the English alphabet where \'a\' is 1, \'b\' is 2, ..., and \'z\' is 26. 2. The encoded string should be calculated by converting each character to its respective number and then concatenating these numbers in the same order as they appear in the original string. Write a function that takes the string `s` as input and returns the encoded string `encoded`. The function should maintain the order of the characters and should not include any separators between the numbers.","solution":"def encode_string(s: str) -> str: Encodes the input string by converting each character to its respective position in the alphabet and concatenates these numbers. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The encoded string composed of numbers representing each character\'s position. # Create a lambda to get the position in alphabet for a given character. get_pos = lambda char: str(ord(char) - ord(\'a\') + 1) # Use list comprehension to convert each character and join them without separators. encoded = \'\'.join(get_pos(char) for char in s) return encoded"},{"question":"Given a string `text`, you need to form a new string such that each character can only appear in the new string if the following conditions are met: - The character must appear in the original `text` an even number of times. Write a function that returns the new string formed by following these conditions. The characters in the new string should appear in the same order as they appear in the original `text`. If no characters qualify, the function should return an empty string.","solution":"def form_even_string(text): Takes a string and returns a new string containing only characters that appear an even number of times in the original string. Characters in the new string are in the same order as they appear in the original string. from collections import Counter # Count the occurrences of each character in the text char_count = Counter(text) # Form the new string including only characters with even occurrences result = \'\'.join([char for char in text if char_count[char] % 2 == 0]) return result"},{"question":"You are given a list of strings `words` and a string `chars`. Each string in `words` is composed of lowercase English letters. You are also given a string `chars` containing distinct lowercase English letters. Your task is to determine if you can form each string in `words` using the characters in `chars`. You can use each character in `chars` only once per word. Return the sum of the lengths of all the strings in `words` that can be formed.","solution":"def countCharacters(words, chars): Determines if each string in `words` can be formed using the characters in `chars`. Returns the sum of the lengths of all the strings in `words` that can be formed. from collections import Counter chars_count = Counter(chars) def can_form(word): word_count = Counter(word) for char, count in word_count.items(): if count > chars_count.get(char, 0): return False return True total_length = 0 for word in words: if can_form(word): total_length += len(word) return total_length"},{"question":"You are given a string `s` consisting of `n` lowercase English letters. You need to determine the number of substrings of `s` that are **anagrams** of the string `\\"abc\\"`. A substring is an anagram of `\\"abc\\"` if it contains exactly one \'a\', one \'b\', and one \'c\' with no other characters included. Return _the number of substrings that are anagrams of_ `\\"abc\\"`.","solution":"def count_abc_anagrams(s): Returns the number of anagram substrings of \'abc\' in the given string s. target = {\'a\': 1, \'b\': 1, \'c\': 1} count = 0 for i in range(len(s) - 2): substring = s[i:i+3] if len(substring) == 3: if {char: substring.count(char) for char in \'abc\'} == target: count += 1 return count"},{"question":"You are given an m x n integer grid `grid` where each cell is either `water` (represented by `0`) or `land` (represented by `1`). An island is a maximal group of `1`s connected horizontally or vertically (but not diagonally). The size of an island is the number of cells with the value `1` in the island. Return the size of the largest island in the grid. If there is no island, return `0`. **Example:** ``` Input: grid = [[0,0,1,0], [1,1,1,0], [0,1,0,0], [1,0,0,0]] Output: 5 ``` In the example above, the largest island is formed by 5 connected `1`s.","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # Mark the cell as visited size = 1 # Current cell counts as 1 size += dfs(i + 1, j) # Explore down size += dfs(i - 1, j) # Explore up size += dfs(i, j + 1) # Explore right size += dfs(i, j - 1) # Explore left return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"Given a string `s`, determine whether it can be rearranged to form a palindrome. A string is considered a palindrome if it reads the same forward and backward. For example, \\"racecar\\" and \\"noon\\" are palindromes. You need to return `true` if it\'s possible to rearrange the letters of `s` to form a palindrome, otherwise return `false`. To form a palindrome, at most one character can have an odd frequency, while all other characters must have an even frequency.","solution":"def can_form_palindrome(s): Determine if the string s can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. Parameters: - s: str : input string Returns: - bool : True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be rearranged to form a palindrome, at most one character can have an odd frequency return odd_count <= 1"},{"question":"You are given a string `sentence` that consists of a sequence of words separated by spaces. Each word is a run of contiguous characters of English letters. You need to write a function that returns the number of words in the `sentence` that contain at least one vowel (a, e, i, o, u). Vowels can be either lowercase or uppercase.","solution":"def count_words_with_vowel(sentence): Returns the number of words in the sentence that contain at least one vowel. Parameters: sentence (str): A string consisting of a sequence of words separated by spaces. Returns: int: The count of words that contain at least one vowel. vowels = set(\'aeiouAEIOU\') words = sentence.split() count = 0 for word in words: if any(char in vowels for char in word): count += 1 return count"},{"question":"You are given an integer array `nums` which contains even and odd numbers. You are tasked with sorting the array such that all even numbers appear before all the odd numbers, while maintaining the relative order of even and even, odd and odd numbers. For example, given `nums = [3,1,2,4]`, the sorted array should be `[2,4,3,1]`. Return the sorted array.","solution":"def sort_array_by_parity(nums): Sorts the array so all even numbers come before all odd numbers, maintaining the relative order of even numbers and odd numbers. Parameters: nums (list): List of integers containing both even and odd numbers Returns: list: Sorted list with all even numbers before odd numbers. evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 == 1] return evens + odds"},{"question":"Given a list of airline tickets represented by pairs of departure and arrival airports `[from, to]`, reconstruct the itinerary in order. **All of the tickets form at least one valid itinerary.** You must use all the tickets once and only once. **Note**: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. Implement the following method: - `List<String> findItinerary(List<List<String>> tickets)`: This method should return the itinerary by listing the airports in the order of your journey.","solution":"from collections import defaultdict, deque def findItinerary(tickets): Finds the itinerary from a list of given airline tickets. Each ticket is a pair [from, to] representing a flight from the \'from\' airport to the \'to\' airport. :param tickets: List of tickets :return: Itinerary in lexicographical order graph = defaultdict(list) for start, end in sorted(tickets): graph[start].append(end) itinerary = [] stack = [\'JFK\'] while stack: while graph[stack[-1]]: stack.append(graph[stack[-1]].pop(0)) itinerary.append(stack.pop()) return itinerary[::-1]"},{"question":"You are given a list of strings `fruits` where each string represents the name of a fruit. You need to group these fruit names into categories such that all fruit names in each category are anagrams of each other. Return a list of lists where each list contains fruit names that are anagrams of each other. The order of the lists and the order of strings in each list do not matter. Example: ``` Input: fruits = [\\"ate\\", \\"tea\\", \\"bat\\", \\"tab\\", \\"eat\\", \\"apple\\"] Output: [[\\"ate\\", \\"tea\\", \\"eat\\"], [\\"bat\\", \\"tab\\"], [\\"apple\\"]] ```","solution":"from collections import defaultdict def group_anagrams(fruits): Group fruit names that are anagrams of each other. Args: fruits (list of str): List of fruit names. Returns: list of list of str: List of grouped anagrams. anagram_map = defaultdict(list) for fruit in fruits: # Sort the characters in the fruit name and use as key sorted_fruit = \\"\\".join(sorted(fruit)) anagram_map[sorted_fruit].append(fruit) return list(anagram_map.values())"},{"question":"You are given an array of integers `heights` of size `n` representing the heights of people standing in a line. Another given array `k` contains the number of people in front of the corresponding person who have a height greater than or equal to theirs. Your task is to reconstruct the original order of people in the line. Return the list of heights in their correct order. If multiple valid reconstructions are possible, return any of them. An input guarantee is that a valid solution always exists.","solution":"def reconstructQueue(heights, k): :param heights: List[int], heights of people. :param k: List[int], number of people in front of the corresponding person who have greater or equal height. :return: List[int], original order of people. # Combine heights and k into a list of tuples people = list(zip(heights, k)) # Sort the list first by height in descending order, and by k in ascending order people.sort(key=lambda x: (-x[0], x[1])) # Initialize an empty list for the reconstructed queue queue = [] # Place each person in the list using the k values for person in people: queue.insert(person[1], person) # Extract the heights from the reconstructed queue return [person[0] for person in queue] # Example usage: # heights = [7, 4, 7, 5, 6] # k = [0, 4, 1, 2, 1] # reconstructQueue(heights, k)"},{"question":"You are given a list of `n` meetings where each meeting is represented by a pair of integers `[starti, endi]` that represent its start and end times. Your task is to find out the minimum number of meeting rooms required to hold all the meetings. Note that if a meeting ends at time `t`, another meeting can start at the same time `t`. Implement a function `minMeetingRooms(meetings)` that returns an integer indicating the minimum number of meeting rooms required. For example: * `[[0, 30], [5, 10], [15, 20]]` requires 2 meeting rooms. * `[[7, 10], [2, 4]]` requires 1 meeting room.","solution":"import heapq def minMeetingRooms(meetings): if not meetings: return 0 # Sort the meetings by start time meetings.sort(key=lambda x: x[0]) # Use a min-heap to keep track of the end times of meetings min_heap = [] # Add the end time of the first meeting heapq.heappush(min_heap, meetings[0][1]) # Iterate over the remaining meetings for meeting in meetings[1:]: # If the current meeting starts after or when the earliest meeting ends, remove the end time if meeting[0] >= min_heap[0]: heapq.heappop(min_heap) # Add the end time of the current meeting heapq.heappush(min_heap, meeting[1]) return len(min_heap)"},{"question":"You are given a 2D grid of binary values (0s and 1s) where 0 represents water and 1 represents land. Your task is to count the number of distinct islands in the grid. An island is formed by connecting adjacent lands horizontally or vertically. Diagonally connected lands do not form islands. The edge of the grid is surrounded by water. Return the number of distinct islands in the grid.","solution":"def num_islands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) num_islands = 0 def dfs(row, col): if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == \'0\': return grid[row][col] = \'0\' # Mark as visited dfs(row - 1, col) # Up dfs(row + 1, col) # Down dfs(row, col - 1) # Left dfs(row, col + 1) # Right for i in range(rows): for j in range(cols): if grid[i][j] == \'1\': # Found an unvisited island num_islands += 1 dfs(i, j) return num_islands"},{"question":"You are given an array of integers `nums` where each integer represents a different colored marble, and an integer `k` which represents the number of swaps you can perform. Each swap allows you to interchange the positions of any two marbles in the array. Your goal is to find the **minimum possible number of unique colors** after performing at most `k` swaps. Return the minimum possible number of unique colors in the array after performing the swaps.","solution":"def min_unique_colors(nums, k): Returns the minimum possible number of unique colors after performing at most k swaps. Parameters: nums (list of int): The array of integers representing different colored marbles. k (int): The number of swaps that can be performed. Returns: int: The minimum possible number of unique colors. from collections import Counter # Count the frequency of each color freq_counter = Counter(nums) # If k is 0, no swaps can be performed, so return the number of unique colors if k == 0: return len(freq_counter) # Get the frequency counts sorted in ascending order freq_values = sorted(freq_counter.values()) # Minimize the unique colors starting by removing the least frequent colors for i in range(len(freq_values)): if k <= 0: break # Remove the least frequent color by reducing its count to 0, decreasing k by the count of removed color if freq_values[i] <= k: k -= freq_values[i] else: break # The minimum number of unique colors is the total initial unique colors minus the number of fully removed color groups return len(freq_values) - i"},{"question":"You have several projects, each described by a term with a number of skill points `points[i]` needed to complete it. You are given an integer `k` representing the initial skill points available. Each project either increases or decreases your total skill points based on its requirement. If the skill points needed for a project is more than your available points at any time, that project cannot be undertaken, and it is skipped. Return _the **maximum number of projects** you can complete with the initial skill points_ `k`.","solution":"def max_projects(points, k): Calculate the maximum number of projects that can be completed with initial skill points k. Parameters: points (List[int]): List of skill points needed for each project. k (int): Initial skill points available. Returns: int: Maximum number of projects that can be completed. points.sort() completed_projects = 0 for point in points: if k >= point: k -= point completed_projects += 1 else: break return completed_projects"},{"question":"Given an `n x n` matrix where each of the elements is 0 or 1, consider it represents a forest with 1s being trees and 0s being empty land. Two trees are considered to be in the same forest if they are adjacent horizontally or vertically. Your task is to determine the number of distinct forests in the matrix. Return the number of forests.","solution":"def count_forests(matrix): if not matrix or not matrix[0]: return 0 def dfs(matrix, visited, i, j): stack = [(i, j)] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while stack: ci, cj = stack.pop() for di, dj in directions: ni, nj = ci + di, cj + dj if 0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and not visited[ni][nj] and matrix[ni][nj] == 1: visited[ni][nj] = True stack.append((ni, nj)) rows = len(matrix) cols = len(matrix[0]) visited = [[False] * cols for _ in range(rows)] count = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1 and not visited[i][j]: dfs(matrix, visited, i, j) count += 1 return count"},{"question":"You are given two arrays `words1` and `words2`. A string `b` is a **universal string** of an array of strings `words` if for every string `a` in `words`, every letter in `a` appears in `b` at least as many times as it appears in `a`. For example, \\"abca\\" is a universal string for [\\"a\\", \\"abc\\"], but \\"abc\\" is not because the second \'a\' in \\"a\\" is missing. Return an array of strings `words2` such that each string in `words2` is a **universal string** for `words1`.","solution":"from collections import Counter def is_universal(b, words): Helper function to determine if string b is a universal string for the array words. b_counter = Counter(b) for word in words: word_counter = Counter(word) for char, count in word_counter.items(): if b_counter[char] < count: return False return True def universal_strings(words1, words2): Returns an array of strings in words2 that are universal strings for words1. result = [] for b in words2: if is_universal(b, words1): result.append(b) return result"},{"question":"Given a string `s` consisting of lowercase letters and a dictionary of words `dict`, determine if `s` can be segmented into a space-separated sequence of one or more dictionary words. The segmented words should appear in the same order as in the dictionary. Implement the `Solution` class with the following methods: - `Solution(String s, List<String> dict)` initializes the object with the string and the dictionary of words. - `boolean canSegment()` returns true if `s` can be segmented into a sequence of one or more dictionary words, otherwise returns false. For example, given `s = \\"applepenapple\\"` and `dict = [\\"apple\\", \\"pen\\"]`, the output should be true because \\"applepenapple\\" can be segmented as \\"apple pen apple\\". If `s = \\"catsandog\\"` and `dict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]`, the output should be false because there is no way to segment \\"catsandog\\" into a sequence of one or more dictionary words.","solution":"from typing import List class Solution: def __init__(self, s: str, dict: List[str]): self.s = s self.dict = set(dict) # Use a set for faster lookups self.memo = {} def canSegment(self) -> bool: return self._canSegment(self.s) def _canSegment(self, s: str) -> bool: if not s: return True if s in self.memo: return self.memo[s] for i in range(1, len(s) + 1): prefix = s[:i] if prefix in self.dict and self._canSegment(s[i:]): self.memo[s] = True return True self.memo[s] = False return False"},{"question":"Given a string `s`, find the length of the longest substring without repeating characters. Return the length of the longest substring. The function should handle both upper-case and lower-case Latin characters and account for their uniqueness separately. For example: - For the input `\\"abcabcbb\\"`, the output should be `3`, corresponding to the substring `\\"abc\\"`. - For the input `\\"bbbbb\\"`, the output should be `1`, corresponding to the substring `\\"b\\"`. - For the input `\\"pwwkew\\"`, the output should be `3`, corresponding to the substring `\\"wke\\"`.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given an array of integers `events` where each element represents a specific event that has happened at a certain time. Your task is to implement a class `EventCounter` that allows you to add new events and find the number of events that occurred within a specific time range. Implement the `EventCounter` class: * `EventCounter()`: Initializes the event counter. * `void addEvent(int t)`: Records a new event at time `t`. * `int countEvents(int start, int end)`: Returns the number of events that occurred in the inclusive range `[start, end]`. Note that you may assume the events are added in a strictly increasing order of time.","solution":"class EventCounter: def __init__(self): Initializes the event counter. self.events = [] def addEvent(self, t): Records a new event at time t. :param t: Time of the event. self.events.append(t) def countEvents(self, start, end): Returns the number of events that occurred in the inclusive range [start, end]. :param start: Start time of the range. :param end: End time of the range. :return: Number of events in the range [start, end]. count = 0 for event in self.events: if start <= event <= end: count += 1 return count"},{"question":"You are given a string `s` where each character represents a type of flower (e.g., \'a\' for rose, \'b\' for lily, etc.). You are also given an integer `k` that represents the maximum distance within which you can plant the same type of flower. Your task is to rearrange the characters in the string `s` such that no two identical flowers are within `k` indices of each other, or return an empty string if it\'s not possible. Return _the rearranged string or an empty string if the arrangement is not feasible_.","solution":"from collections import Counter from heapq import heapify, heappop, heappush def rearrangeFlowers(s, k): if k == 0: return s # Count the frequency of each flower type flower_counts = Counter(s) # Create a max heap based on the frequency of characters max_heap = [(-count, flower) for flower, count in flower_counts.items()] heapify(max_heap) queue = [] result = [] while max_heap: count, flower = heappop(max_heap) result.append(flower) # Appending the flower to the queue with its next valid index queue.append((flower, count + 1)) # Increment count since it\'s negative if len(queue) >= k: recyclable_flower, recyclable_count = queue.pop(0) if recyclable_count < 0: heappush(max_heap, (recyclable_count, recyclable_flower)) if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"You are given an array of integers `heights` representing the building heights along a street. Calculate the number of buildings that have a sunset view, assuming the sun sets to the west (to the right). A building has a sunset view if all the buildings to its right are shorter. Return the indexes of buildings with a sunset view, in the order of their appearance in the array.","solution":"def sunset_views(heights): Returns the indexes of buildings that have a sunset view. Parameters: heights (list of int): A list of building heights. Returns: list of int: The indexes of the buildings that have a sunset view. sunset_buildings = [] max_height = float(\'-inf\') for i in range(len(heights)): if heights[i] > max_height: sunset_buildings.append(i) max_height = max(max_height, heights[i]) return sunset_buildings"},{"question":"You are given a **0-indexed** integer array `prices` representing the prices of a product on a series of days. You are allowed to complete at most two non-overlapping transactions to maximize your profit, where each transaction consists of buying and then selling one share of the product. Return the maximum profit you can achieve from these transactions. A transaction is defined by choosing two indices `i` and `j` (0 <= i < j < n) such that the profit is `prices[j] - prices[i]`. **Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).","solution":"def max_profit(prices): if not prices: return 0 n = len(prices) max_profit_after_second_sell = 0 # Step 1: Calculating max profit achievable after the first transaction by each day. left_profits = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i - 1], prices[i] - min_price) # Step 2: Calculating max profit achievable with the second transaction in reverse order. max_price = prices[n - 1] right_profits = [0] * n for j in range(n - 2, -1, -1): max_price = max(max_price, prices[j]) right_profits[j] = max(right_profits[j + 1], max_price - prices[j]) # Combine left and right profits to get maximum profit with two transactions for k in range(n): max_profit_after_second_sell = max(max_profit_after_second_sell, left_profits[k] + right_profits[k]) return max_profit_after_second_sell"},{"question":"You are developing a game application and need to create a reward system for players. Each player has an integer score. You want to distribute prizes such that each player has a unique prize amount and players with a higher score than others should receive a higher prize amount. Given an integer array `scores` representing the scores of all players, return _an integer array of the same length where each element represents the prize amount corresponding to each player\'s score_. Players with equal scores should receive the same prize amount. The prize amounts should start from 1 and increase by 1 for each subsequent unique score.","solution":"def distribute_prizes(scores): Distributes prizes such that each player has a unique prize amount based on their score. Players with higher scores get higher prize amounts starting from 1 for the lowest score. Args: scores (list): List of integer scores of players. Returns: list: List of integer prizes corresponding to each player\'s score. # Get sorted unique scores sorted_unique_scores = sorted(set(scores)) # Create a dictionary with score as key and prize amount as value score_to_prize = {score: index + 1 for index, score in enumerate(sorted_unique_scores)} # Distribute prizes based on the score_to_prize mapping prizes = [score_to_prize[score] for score in scores] return prizes"},{"question":"A railway network is represented by a 2D integer array `trainTimes`, where `trainTimes[i]` is a list of `i` train schedules. Each schedule `trainTimes[i][j]` represents the time at which a train departs from station `i` and reaches the next station (in a fixed direction). You are tasked with finding the earliest possible time you can reach the final station starting from station `0`. You can assume the train travels immediately from each station. Write a function that takes the `trainTimes` array as input and returns the earliest arrival time at the final station. If it is not possible to reach the final station, return `-1`.","solution":"from queue import PriorityQueue def earliest_arrival_time(trainTimes): Returns the earliest arrival time at the final station starting from station 0. If it is not possible to reach the final station, returns -1. n = len(trainTimes) if n == 0: return -1 pq = PriorityQueue() pq.put((0, 0)) # (time, station) visited = [False] * n while not pq.empty(): current_time, current_station = pq.get() if current_station == n - 1: return current_time if visited[current_station]: continue visited[current_station] = True for departure_time in trainTimes[current_station]: arrival_time = current_time + departure_time pq.put((arrival_time, current_station + 1)) return -1"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row, where `heights[i]` is the height of the `i-th` building. A building has a **solar panel** if and only if it receives sunlight. A building receives sunlight if there are no taller buildings to its left. Find out the number of buildings that will have a solar panel installed. Return _the number of buildings that receive sunlight_.","solution":"def count_buildings_with_solar_panels(heights): Returns the number of buildings that receive sunlight (no taller buildings to their left). Parameters: heights (list of int): List of building heights. Returns: int: Number of buildings that receive sunlight. if not heights: return 0 count = 1 # The first building always gets sunlight max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"Write a function that takes a string `s` representing a valid Roman numeral and converts it to an integer. Roman numerals are represented by the following symbols: `I, V, X, L, C, D, M`. For example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X` + `II`. The Roman numeral system follows these rules: - `I` can be placed before `V` (5) and `X` (10) to make `4` and `9`. - `X` can be placed before `L` (50) and `C` (100) to make `40` and `90`. - `C` can be placed before `D` (500) and `M` (1000) to make `400` and `900`. Given a Roman numeral, convert it to an integer.","solution":"def roman_to_int(s): roman_numerals = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_numerals[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"You are given an array of integers `arr` of length `n` and an integer `x`. Your task is to find the longest contiguous subarray, such that the sum of its elements is less than or equal to `x`. If there are multiple answers, return the one that appears first. Return the length of this subarray. If no valid subarray exists, return `0`.","solution":"def longest_subarray_with_sum_leq_x(arr, n, x): Returns the length of the longest contiguous subarray with sum <= x. max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > x: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an array of integers `arr` of length `n`, find the maximum sum of any contiguous subarray. The subarray must contain at least one number. Return the maximum sum.","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray. Parameters: arr (list of int): The input array of integers. Returns: int: The maximum sum of any contiguous subarray. if not arr: return 0 # Assuming empty list should return 0. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Given a list of non-negative integers `nums`, arrange them such that they form the largest number. Return the largest number you can form as a string. **Example:** ```python Input: nums = [10, 2] Output: \\"210\\" ``` **Example:** ```python Input: nums = [3, 30, 34, 5, 9] Output: \\"9534330\\" ``` **Note:** - The result may be very large, so you need to return a string instead of an integer. - You are not allowed to sort the integers by converting them to strings directly. You need to implement a custom comparator to determine the order.","solution":"from functools import cmp_to_key def custom_compare(x, y): Custom comparator function which compares two strings a and b by comparing the concatenated result in both possible orders. if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_number(nums): Given a list of non-negative integers, arrange them such that they form the largest number. :param nums: List[int] :return: str # Convert integers to strings for comparison str_nums = map(str, nums) # Sort the numbers using the custom comparator sorted_nums = sorted(str_nums, key=cmp_to_key(custom_compare)) # Join sorted numbers to form the largest number largest_num = \'\'.join(sorted_nums) # Edge case: if the result starts with \'0\', the numbers were all zeros if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"You are given a binary tree in which each node contains an integer value. Nodes can also have an arbitrary pointer to any other node in the binary tree. Develop a function to perform a **deep copy** of this binary tree. The deep copy must preserve the tree structure as well as the arbitrary pointer assignments. The function should return the root node of the deep-copied tree. class Node { public int val; public Node left; public Node right; public Node arb; public Node() {} public Node(int _val, Node _left, Node _right, Node _arb) { val = _val; left = _left; right = _right; arb = _arb; } }","solution":"class Node: def __init__(self, val=0, left=None, right=None, arb=None): self.val = val self.left = left self.right = right self.arb = arb def deep_copy_binary_tree(root): if not root: return None old_to_new = {} def copy_node(node): if not node: return None if node in old_to_new: return old_to_new[node] copied_node = Node(node.val) old_to_new[node] = copied_node copied_node.left = copy_node(node.left) copied_node.right = copy_node(node.right) copied_node.arb = copy_node(node.arb) return copied_node return copy_node(root)"},{"question":"Write an algorithm to find and return all paths in a given graph that start at a source node `s` and end at a destination node `d`. The graph is represented by an adjacency list where `graph[i]` is a list of all nodes `i` is connected to. The result should be a list of all possible paths, where each path is represented as a list of nodes. Ensure that no node is repeated within a single path and that each node can only be used once in each path. * Example: ``` Input: graph = [[1, 2], [3], [3], []], start = 0, end = 3 Output: [[0, 1, 3], [0, 2, 3]] ``` * You may assume that the graph is a Directed Acyclic Graph (DAG) and no node appears more than once in any path.","solution":"def all_paths_source_target(graph, start, end): Returns all paths from start node \'s\' to end node \'d\' in the given graph. Each path is represented as a list of nodes. :param graph: List of lists. The graph adjacency list where graph[i] is a list of nodes i connects to. :param start: Integer. The starting node \'s\'. :param end: Integer. The destination node \'d\'. :return: List of lists. All paths from start to end. def dfs(node, path, all_paths): # If the current node is the end, add the path to the results if node == end: all_paths.append(list(path)) return # Explore each neighbor for neighbor in graph[node]: if neighbor not in path: # Ensure no node is repeated in the current path path.append(neighbor) dfs(neighbor, path, all_paths) # Recursively build the path path.pop() # Backtrack all_paths = [] dfs(start, [start], all_paths) return all_paths"},{"question":"You are given an undirected graph represented as an integer matrix `graph`, where `graph[i][j] = 1` indicates there\'s an edge between vertices `i` and `j`, and `graph[i][j] = 0` indicates there\'s no edge. Each vertex represents a course, and an edge represents a prerequisite relationship between the two courses. You need to determine whether it\'s possible to complete all courses given these prerequisites. Return `true` if you can complete all courses, otherwise return `false`.","solution":"def can_finish_courses(graph): Determines if it\'s possible to complete all courses given the prerequisite relationships in the graph. Parameters: - graph: List[List[int]]: A square matrix representing the graph. Returns: - bool: True if all courses can be completed, False otherwise. def has_cycle(v, visited, rec_stack): # Mark the current node as visited and add it to recursion stack visited[v] = True rec_stack[v] = True # Recur for all vertices adjacent to this vertex for i in range(len(graph[v])): if graph[v][i] == 1: if not visited[i]: if has_cycle(i, visited, rec_stack): return True elif rec_stack[i]: return True # Remove the vertex from recursion stack rec_stack[v] = False return False num_courses = len(graph) visited = [False] * num_courses rec_stack = [False] * num_courses # Check for cycles in the graph for course in range(num_courses): if not visited[course]: if has_cycle(course, visited, rec_stack): return False return True"},{"question":"You are given a string `s` and an integer `k`. Find the longest substring of `s` such that the frequency of each character in this substring is at most `k`. The length of the string `s` will not exceed `10^5`, and the value of `k` will not exceed `10^5`. Return the length of the longest valid substring. If there are multiple substrings with the same maximum length, return the length of any one of them.","solution":"def longest_substring_max_freq(s, k): Returns the length of the longest substring of `s` such that the frequency of each character in this substring is at most `k`. from collections import defaultdict n = len(s) # left and right pointers left, right = 0, 0 # dictionary to keep the count of characters in the current window freq = defaultdict(int) # variable to store the result max_length = 0 while right < n: # include the current character in the window freq[s[right]] += 1 # check if the current window is valid while any(count > k for count in freq.values()): freq[s[left]] -= 1 if freq[s[left]] == 0: del freq[s[left]] left += 1 # update the result max_length = max(max_length, right - left + 1) # move the right pointer to the right right += 1 return max_length"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. Rotating the list to the right by 1 place means moving the last node of the list to the front, repeatedly, `k` times. Return the head of the modified linked list after the rotation. **Note**: Try to solve this problem with linear complexity in both time and space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Find the length of the list current = head length = 1 while current.next: current = current.next length += 1 # Make the last node point to the head, making it a circular list current.next = head # Find the new tail and new head of the rotated list new_tail_position = length - k % length - 1 new_tail = head for _ in range(new_tail_position): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"You are given a 2D matrix `matrix` of size `m x n` containing non-negative integers. Find the minimum cost path from the top left to the bottom right corner of the matrix. The cost of a path is the sum of the values of the cells visited along the path. You can only move either down or right at any point in time. Return _an integer_ denoting the minimum cost path through the matrix.","solution":"def min_cost_path(matrix): Returns the minimum cost path from top left to bottom right of the matrix. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Create a 2D dp array with the same dimensions as matrix. dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = matrix[0][0] # Initialize the first row. for j in range(1, n): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Initialize the first column. for i in range(1, m): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the dp array. for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[m - 1][n - 1]"},{"question":"Given a string `s` and an integer `k`, your task is to rearrange the string such that none of the same characters are adjacent to each other and the relative order of characters is maintained as much as possible. If it is not possible to rearrange the string in such a way that no two identical characters are adjacent, return an empty string. The rearranged string should have all characters grouped such that each group\'s length is at most `k`. The length requirement for each group should not compromise the condition of non-adjacent identical characters. Return the rearranged string if possible, otherwise, return an empty string.","solution":"def rearrange_string(s, k): if k == 0: # if k is 0, no need to rearrange return s from collections import Counter, deque import heapq # Count the occurrence of each character counter = Counter(s) max_heap = [(-cnt, char) for char, cnt in counter.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: cnt, char = heapq.heappop(max_heap) result.append(char) queue.append((cnt + 1, char)) # push it to the waiting queue if len(queue) >= k: # wait until the k interval is reached prev_cnt, prev_char = queue.popleft() if -prev_cnt > 0: # reinsert into heap only if there\'s remaining count heapq.heappush(max_heap, (prev_cnt, prev_char)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"You are given two strings `s1` and `s2`. Your task is to determine if `s2` can be formed by the characters of `s1` shuffled or permuted in any order. The characters from `s1` can only be used once, and `s2` must contain exactly the same characters as `s1`, just possibly in a different order. Return `True` if `s2` can be formed from `s1`, otherwise return `False`.","solution":"def can_form_by_permutation(s1, s2): Returns True if s2 can be formed by the characters of s1 shuffled or permuted in any order. Otherwise, return False. return sorted(s1) == sorted(s2)"},{"question":"You are given a string `s` and an integer `k`. You need to determine if you can break the string into **k** non-overlapping subsequences such that each subsequence is a palindrome. Return _true_ if it is possible, and _false_ otherwise. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def can_partition_into_palindrome_subsequences(s, k): Determine if the string s can be broken into k non-overlapping subsequences such that each subsequence is a palindrome. :param s: String to be checked for partitioning. :param k: Number of required palindrome subsequences. :return: True if it is possible to partition into k palindrome subsequences, False otherwise. # Helper function to determine if a string is a palindrome def is_palindrome(sub): return sub == sub[::-1] # Length of the given string n = len(s) # Base case if k > n: return False # More subsequences than characters is impossible if k == 1: return is_palindrome(s) # Single subsequence must be the entire string and a palindrome if k == n: return True # Each character can be a palindrome subsequence # For any other general case min_required_palindromes = 0 count = {} for char in s: count[char] = count.get(char, 0) + 1 for value in count.values(): min_required_palindromes += value % 2 return min_required_palindromes <= k"},{"question":"You are given an integer array `nums` representing scores of students in an exam. We define a student as being **successful** if their score is strictly greater than the average score of all students. Write a function that returns the count of successful students. The function should return `0` if no student is successful.","solution":"def count_successful_students(nums): Returns the number of students with scores strictly greater than the average score. if not nums: return 0 average_score = sum(nums) / len(nums) count = sum(1 for score in nums if score > average_score) return count"},{"question":"Given an integer array `heights` representing the heights of students in a class, you are tasked with rearranging the students in non-decreasing order of their heights. However, you want to determine the minimum number of students that are currently in the correct position (relative to the non-decreasing order). Return _the minimum number of students that are already in the correct position_.","solution":"def min_students_in_correct_position(heights): Return the minimum number of students that are already in the correct position when the list is sorted in non-decreasing order. :param heights: List[int] - the heights of the students :return: int - the minimum number of students already in the correct position sorted_heights = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] == sorted_heights[i]: count += 1 return count"},{"question":"A city has several bus routes represented by a 2D array `routes`, where each `routes[i]` is an array of bus stops that route `i` goes through in order. Implement the `BusRoutes` class: * `BusRoutes(int[][] routes)` Initializes the object with the given bus routes. * `int numBusesToDestination(int start, int destination)` Returns the fewest number of buses you need to take to travel from the `start` bus stop to the `destination` bus stop. If it is not possible to travel from `start` to `destination` using the given bus routes, return `-1`.","solution":"from collections import deque, defaultdict class BusRoutes: def __init__(self, routes): self.routes = routes self.bus_stop_to_routes = defaultdict(set) for i, route in enumerate(routes): for stop in route: self.bus_stop_to_routes[stop].add(i) def numBusesToDestination(self, start, destination): if start == destination: return 0 visited_stops = set() visited_routes = set() queue = deque([(start, 0)]) # (current stop, buses taken so far) while queue: current_stop, buses_taken = queue.popleft() if current_stop in visited_stops: continue visited_stops.add(current_stop) for route_index in self.bus_stop_to_routes[current_stop]: if route_index in visited_routes: continue visited_routes.add(route_index) for next_stop in self.routes[route_index]: if next_stop == destination: return buses_taken + 1 queue.append((next_stop, buses_taken + 1)) return -1"},{"question":"Given an array of integers `nums` and an integer `k`, determine the number of **subarrays** whose sum is exactly equal to `k`. A **subarray** is a contiguous sequence of elements within an array. The length of the subarray can vary, but it should contain at least one element. If the total number of such subarrays is very large, return the answer **modulo** `10^9 + 7`.","solution":"def subarray_sum(nums, k): Returns the number of subarrays whose sum equals k modulo 10^9 + 7. MOD = 10**9 + 7 sum_count = {0: 1} current_sum = 0 result = 0 for num in nums: current_sum += num if current_sum - k in sum_count: result += sum_count[current_sum - k] if current_sum in sum_count: sum_count[current_sum] += 1 else: sum_count[current_sum] = 1 return result % MOD"},{"question":"Implement a function that takes a string containing just the characters \'(\' and \')\', and returns the minimum number of parentheses needed to make the string valid. A string is valid if and only if it forms a valid sequence of balanced parentheses. For instance, given the input string \\"())\\", the function should return 1, since adding a \'(\' at the beginning makes the string valid. Given the input string \\"(((\\", the function should return 3, as three \')\' need to be added to balance out the three \'(\'. Note: Your solution should consider various edge cases and aim for an optimal time complexity.","solution":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of parentheses needed to make the string valid. left_balance = 0 right_balance = 0 for char in s: if char == \'(\': left_balance += 1 elif char == \')\': if left_balance > 0: left_balance -= 1 else: right_balance += 1 return left_balance + right_balance"},{"question":"Given an array of integers `arr`, and an integer `target`, return _the number of pairs_ `(i, j)` _in the array such that_ `arr[i] + arr[j] == target` _and_ `i < j`. _The pairs should be unique and you should not use the same element twice._ Your solution should have a time complexity of O(n).","solution":"def count_pairs_with_sum(arr, target): Returns the number of unique pairs (i, j) such that arr[i] + arr[j] == target and i < j. Time complexity should be O(n). count = 0 seen = {} for number in arr: complement = target - number if complement in seen: count += seen[complement] if number in seen: seen[number] += 1 else: seen[number] = 1 return count"},{"question":"Write a function that receives a string composed of only ‘a’, ‘b’, and ‘*’ characters. The \'*\' characters are acting as wildcards that can be replaced with either \'a\' or \'b\' to form different strings. Your task is to determine if it\'s possible to replace the \'*\' characters in such a way that the resulting string is a palindrome. Return `true` if it\'s possible to create a palindrome string, otherwise return `false`. Keep in mind that the function should work efficiently even for large input strings.","solution":"def is_palindrome_possible(s): Check if it\'s possible to replace \'*\' characters in the string `s` to make it a palindrome. :param s: Input string composed of \'a\', \'b\', and \'*\' characters. :return: True if it\'s possible to form a palindrome, False otherwise. left = 0 right = len(s) - 1 while left <= right: if s[left] == s[right]: # Both are equal (both can also be \'*\') left += 1 right -= 1 elif s[left] == \'*\': # Replace \'*\' at left with character at right left += 1 right -= 1 elif s[right] == \'*\': # Replace \'*\' at right with character at left left += 1 right -= 1 else: # Characters are different and none are \'*\', cannot form a palindrome return False return True"},{"question":"Given a list of strings `words`, you need to find the string that appears most frequently. If there are multiple strings with the same highest frequency, return the lexicographically smallest string among them. Write a function to achieve this.","solution":"from collections import Counter def most_frequent_string(words): Returns the most frequent string in a list of strings. If there are multiple strings with the same highest frequency, returns the lexicographically smallest string among them. if not words: return \\"\\" word_count = Counter(words) max_count = max(word_count.values()) most_frequent = [word for word, count in word_count.items() if count == max_count] return min(most_frequent)"},{"question":"You are given an array of integers `nums`. You can perform the following operation any number of times: - Choose any subarray of `nums` (a subarray is a contiguous part of the array) and increase every element by `1`. Return _the minimum number of operations required to make all the elements of the array equal_. For example, if `nums = [3, 8, 5]`, you can choose the subarray `[8, 5]` and increase both elements by `1` to get `[3, 9, 6]`; repeating this process as needed until all elements are equal.","solution":"def min_operations_to_make_equal(nums): Given an array of integers `nums`, this function returns the minimum number of operations required to make all the elements of the array equal. if not nums: return 0 max_num = max(nums) operations = 0 for num in nums: operations += (max_num - num) return operations"},{"question":"You are given a string `s` consisting of letters \'a\' and \'b\' only. You need to find the minimum number of operations required to transform the string into a string in which no two adjacent characters are the same. In one operation, you can change any \'a\' to \'b\' or any \'b\' to \'a\'. Return the minimum number of operations needed to achieve such a transformation.","solution":"def min_operations(s): Returns the minimum number of operations required to transform the string into a string in which no two adjacent characters are the same. # Generate alternating patterns pattern1 = \'\'.join(\'a\' if i % 2 == 0 else \'b\' for i in range(len(s))) pattern2 = \'\'.join(\'b\' if i % 2 == 0 else \'a\' for i in range(len(s))) # Count differences with the original string for each pattern ops1 = sum(1 for i in range(len(s)) if s[i] != pattern1[i]) ops2 = sum(1 for i in range(len(s)) if s[i] != pattern2[i]) # Return the minimum of both counts return min(ops1, ops2)"},{"question":"You are given an integer array `nums` and an integer `val`. You need to remove all occurrences of `val` in `nums` in-place. The relative order of the elements may be changed. It doesn\'t matter what you leave beyond the new length. Implement a function `int removeElement(int[] nums, int val)` that returns the new length of the array after removing all occurrences of `val`. You must write an algorithm that uses only constant extra space.","solution":"def remove_element(nums, val): Removes all occurrences of val in nums in-place and returns the new length of nums. :param nums: List of integers. :param val: Integer value to be removed. :return: New length of nums after all occurrences of val are removed. k = 0 # Pointer for the next position to place the non-val element for i in range(len(nums)): if nums[i] != val: nums[k] = nums[i] k += 1 return k"},{"question":"You are given an integer array `arr` and an integer `k`. Elements in the array can be negative, zero, or positive. Your task is to determine whether there are three distinct elements in the array whose sum equals `k`. Return `true` if there exist such elements, otherwise return `false`.","solution":"def three_sum(arr, k): Determines if there are three distinct elements in the array whose sum equals k. Args: arr (list of int): The input array containing integers. k (int): The target sum. Returns: bool: True if there are three distinct elements whose sum equals k, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"Write a function `findDuplicates(nums)` that takes an array of integers, `nums`, where `nums[i]` is in the range `[1, n]` (`n` is the length of the array), and some elements appear twice while others appear once. Your task is to return an array of all the elements that appear twice in this array. **Note:** - You must implement the function with an (O(n)) time complexity and use only constant extra space.","solution":"def findDuplicates(nums): Finds all the elements that appear twice in the array nums. The input array nums contains elements in the range [1, n] where n is the length of the array. Args: nums (list): An array of integers. Returns: list: A list containing all elements that appear twice in nums. duplicates = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: duplicates.append(index + 1) nums[index] = -nums[index] return duplicates"},{"question":"You are given an integer array `nums` that represents n unique elements and an integer k. Find the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. You must solve it in O(n log n) time complexity.","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the nums array. :param nums: List[int] - List of integers :param k: int - The k-th position to find the largest element :return: int - The k-th largest element # Sort the array in descending order nums.sort(reverse=True) # Return the k-th largest element (k-1 because of zero-indexing) return nums[k - 1]"},{"question":"You are given `n` stacks of coins, each represented by an integer array `stacks`, where `stacks[i]` is the number of coins in the `i-th` stack. You are also given an integer array `targetStacks` where `targetStacks[i]` is the target number of coins you want in the `i-th` stack. In one move, you can choose any two stacks, say `stack i` and `stack j` (`i != j`), and apply one of the following operations: - Move one coin from `stack i` to `stack j`. - Move one coin from `stack j` to `stack i`. Return `true` if it\'s possible to transform the `stacks` array into the `targetStacks` array using any number of moves (possibly zero). Otherwise, return `false`.","solution":"def can_transform(stacks, targetStacks): Returns true if it\'s possible to transform the \'stacks\' array into the \'targetStacks\' array using the allowed operations. return sum(stacks) == sum(targetStacks)"},{"question":"You are given a **0-indexed** integer array `heights` where `heights[i]` represents the height of the `i-th` building. Your task is to determine the number of **valid** scenic viewpoints. A building is considered a **scenic viewpoint** if and only if there exists at least one taller building at both its left and right sides. * For example, given `heights = [3, 7, 8, 3, 6, 1, 4]`, the `3rd` building (height 3) and the `5th` building (height 6) are valid scenic viewpoints as they have taller buildings on both sides. Return _the total number of **scenic viewpoints** in the array._","solution":"def scenic_viewpoints(heights): Return the number of scenic viewpoints in the array. A scenic viewpoint is defined as a building with at least one taller building to its left and at least one taller building to its right. :param heights: List of integers representing the heights of buildings. :return: Integer number of scenic viewpoints. n = len(heights) if n < 3: return 0 scenic_count = 0 for i in range(1, n - 1): left_taller = any(heights[j] > heights[i] for j in range(i)) right_taller = any(heights[j] > heights[i] for j in range(i + 1, n)) if left_taller and right_taller: scenic_count += 1 return scenic_count"},{"question":"You are given an array `heights` representing the heights of buildings in a city skyline from left to right. The array element `heights[i]` indicates the height of the building at index `i`. Your goal is to calculate the total area of water that can be trapped between the buildings after a rain. Return the total units of trapped water. Example: ``` Input: heights = [4,2,0,3,2,5] Output: 9 ```","solution":"def trap(heights): Calculate the total area of water that can be trapped between the buildings after a rain. :param heights: List[int] - array representing the heights of buildings :return: int - total units of trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given two strings `s` and `t` consisting of lowercase English letters. Your task is to determine if `t` can be formed by rearranging the letters of `s` and then adding exactly one additional character. In other words, check if `t` is an anagram of `s` with an extra letter. Return `true` if `t` can be formed this way and `false` otherwise.","solution":"def can_form_with_one_extra_char(s, t): Returns true if t can be formed by rearranging the letters of s and adding exactly one extra character. # If lengths don\'t match for a simple rearrangement plus one character, return false immediately if len(t) != len(s) + 1: return False # Create character count dictionaries for both strings count_s = {} count_t = {} for char in s: count_s[char] = count_s.get(char, 0) + 1 for char in t: count_t[char] = count_t.get(char, 0) + 1 extra_char_found = False for char in count_t: if char not in count_s: if count_t[char] == 1 and not extra_char_found: extra_char_found = True else: return False elif count_t[char] != count_s[char]: if count_t[char] == count_s[char] + 1 and not extra_char_found: extra_char_found = True else: return False return extra_char_found"},{"question":"You are given an integer array `nums` and an integer `k`. You need to find the length of the shortest contiguous subarray that, when sorted, results in the entire array being sorted in ascending order. If the array is already sorted, return `0`. If no such subarray exists, return `-1`.","solution":"def find_shortest_subarray(nums): Find the length of the shortest contiguous subarray that, when sorted, results in the entire array being sorted in ascending order. If the array is already sorted, return 0. If no such subarray exists, return -1. n = len(nums) if n == 0: return 0 start, end = 0, -1 max_seen, min_seen = float(\'-inf\'), float(\'inf\') # Traverse from left to right and find the end of the needed subarray for i in range(n): if nums[i] < max_seen: end = i max_seen = max(max_seen, nums[i]) # Traverse from right to left and find the start of the needed subarray for i in range(n-1, -1, -1): if nums[i] > min_seen: start = i min_seen = min(min_seen, nums[i]) # If end is not updated from initial value -1, return 0, the array is already sorted. if end == -1: return 0 return end - start + 1"},{"question":"Given a string `s`, you need to determine whether it is possible to split the string into a number of continuous substrings such that each substring has the same character. For instance, the string `\\"aaabbbccc\\"` can be split into the substrings `[\\"aaa\\", \\"bbb\\", \\"ccc\\"]`, each containing only one type of character. If it is possible to split the string in such a way, return the list of substrings. Otherwise, return an empty list.","solution":"def split_string_into_same_char_substrings(s): Determine if a string can be split into continuous substrings of the same character. :param s: Input string :type s: str :return: List of substrings if possible, otherwise an empty list :rtype: list if not s: return [] substrings = [] current_char = s[0] current_substring = current_char for char in s[1:]: if char == current_char: current_substring += char else: substrings.append(current_substring) current_char = char current_substring = char substrings.append(current_substring) return substrings"},{"question":"You are given two non-empty binary trees `t1` and `t2`. Imagine that when you put one of them to cover another, some nodes of the two trees overlap while others do not. The overlap nodes will be summed up, and the nodes that do not overlap will retain their original values. You need to merge these two trees into a new binary tree. Write a function `TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2)` that returns the merged tree. The merged tree should be constructed according to the following rule: If two nodes overlap, then sum the values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; ``` The function signature is: ```cpp TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2); ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def mergeTrees(t1, t2): Merges two binary trees by the defined rules and returns the new tree. if not t1: return t2 if not t2: return t1 t1.val += t2.val t1.left = mergeTrees(t1.left, t2.left) t1.right = mergeTrees(t1.right, t2.right) return t1"},{"question":"Given a binary tree, implement a function that returns the **inorder traversal** of its nodes\' values. The binary tree is represented by a class `TreeNode` that has `val`, `left`, and `right` properties. An inorder traversal is a type of depth-first traversal that visits the left subtree, followed by the root node, and finally the right subtree. Return the values as a list. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> List[int]: # implement your solution here ```","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> List[int]: result = [] def _inorder(node: TreeNode): if node: _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(root) return result"},{"question":"You are given a **directed acyclic graph (DAG)** with `n` nodes, numbered from `0` to `n-1`, and an array `entries` of length `n` where `entries[i]` represents the number of incoming edges (dependencies) to the `i-th` node. You are also provided with a 2D integer array `edges`, where `edges[i] = [ui, vi]` denotes a directed edge from node `ui` to node `vi`. Each task can only be started if all of its dependencies are completed. Write a function to find the minimum number of steps required to complete all nodes in the graph. In each step, multiple nodes that are available (having no remaining dependencies) can be completed simultaneously. Return the minimum number of steps needed to finish all tasks if it is possible, otherwise, return `-1` if there exists a cycle which prevents the completion of all tasks.","solution":"from collections import deque, defaultdict def min_number_of_steps(n, entries, edges): Returns the minimum number of steps required to complete all nodes in the graph, or -1 if there is a cycle. # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) # Initialize a queue with nodes having 0 incoming edges queue = deque([i for i in range(n) if entries[i] == 0]) # Perform BFS steps = 0 processed_nodes = 0 while queue: current_level_size = len(queue) for _ in range(current_level_size): node = queue.popleft() processed_nodes += 1 for neighbor in adj_list[node]: entries[neighbor] -= 1 if entries[neighbor] == 0: queue.append(neighbor) steps += 1 # If all nodes are processed, return steps, else return -1 (cycle exists) return steps if processed_nodes == n else -1"},{"question":"Given a 2D integer matrix `grid` of size `m x n` and an integer `k`, write a function to shift the matrix `k` times. Each shift operation moves the last element of the matrix to the first position and shifts all the remaining elements to the right by one. Return the 2D shifted matrix.","solution":"def shift_grid(grid, k): Shifts the elements of the matrix `k` times. Args: grid (List[List[int]]): 2D list representing the matrix. k (int): Number of times to shift the matrix. Returns: List[List[int]]: The shifted matrix. if not grid or not grid[0]: return grid m, n = len(grid), len(grid[0]) total = m * n k = k % total if k == 0: return grid flat_list = [cell for row in grid for cell in row] flat_list = flat_list[-k:] + flat_list[:-k] new_grid = [] for i in range(0, total, n): new_grid.append(flat_list[i:i+n]) return new_grid"},{"question":"You are given a list of events, where each event is represented as a list `[start, end]` with `start` as the start time and `end` as the end time. Two events are considered to be conflicting if they overlap. Your task is to find and return _the maximum number of non-conflicting events that you can attend_ given the list of events. Each event is represented by a tuple `(start, end)` where `start` and `end` are non-negative integers.","solution":"def max_non_conflicting_events(events): Given a list of events with start and end times, returns the maximum number of non-conflicting events that can be attended. if not events: return 0 # Sort events by their end times events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = -1 for start, end in events: if start >= last_end_time: max_events += 1 last_end_time = end return max_events"},{"question":"A specialized social media company is setting up a new algorithm to identify active users. Given an integer array `likes` where `likes[i]` represents the number of posts liked by the `i-th` user, you need to determine the **minimum** number of users required such that the total number of likes they have collectively made is at least half of the total likes made by all users combined. If it\'s not possible, return `-1`. Write a function `min_users(likes)` that returns this value.","solution":"def min_users(likes): Returns the minimum number of users required such that the total number of likes they have collectively made is at least half of the total likes made by all users combined. If it\'s not possible, return -1. if not likes: return -1 total_likes = sum(likes) half_total_likes = total_likes / 2 # Sort likes in descending order likes.sort(reverse=True) current_likes = 0 user_count = 0 for like in likes: current_likes += like user_count += 1 if current_likes >= half_total_likes: return user_count return -1"},{"question":"You are given an integer array `arr` and an integer `k`. Implement a function to find the `k`-th largest element in the array. Note that it is the `k`-th largest element in sorted order, not the `k`-th distinct element. **Method Signature**: ```python def find_kth_largest(arr: List[int], k: int) -> int ``` **Input**: - `arr`: a list of integers representing the array. - `k`: an integer representing the position (1-indexed) of the largest element to find. **Output**: - Returns the `k`-th largest element in the array. **Example**: ```plaintext Input: arr = [3, 2, 1, 5, 6, 4], k = 2 Output: 5 Input: arr = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4 Output: 4 ``` **Constraints**: - You must solve it in O(n log n) time complexity.","solution":"from typing import List def find_kth_largest(arr: List[int], k: int) -> int: Returns the k-th largest element in the array. arr.sort(reverse=True) return arr[k - 1]"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to perform **k** queries on this string. Each query consists of two integers `(i, j)` where you need to find the count of distinct characters in the substring `s[i:j+1]`. Return the list of results for all queries. Note that the indices are 0-based.","solution":"def distinct_characters_in_substrings(s, k, queries): Returns the count of distinct characters for each query\'s specified substring. Args: s (str): The input string consisting of lowercase letters. k (int): The number of queries. queries (list of tuples): A list of queries, where each query is a tuple (i, j). Returns: list of int: A list of results for each query representing the count of distinct characters. results = [] for query in queries: i, j = query substring = s[i:j+1] distinct_char_count = len(set(substring)) results.append(distinct_char_count) return results"},{"question":"You are given an array of integers `arr` representing the values of nodes in a potentially unbalanced binary search tree (BST). You need to reconstruct the BST from the given array such that the tree maintains the properties of a binary search tree: the left subtree of a node contains only nodes with values less than the node\'s value, and the right subtree only nodes with values greater than the node\'s value. Write a function to perform the reconstruction and return the root of the reconstructed BST. The input array does not contain any duplicates.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): Reconstructs a binary search tree (BST) from the given preorder traversal array. :param preorder: List[int], the preorder traversal of the BST :return: TreeNode, the root of the reconstructed BST if not preorder: return None # Helper function to insert a new value in the BST def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root # Initialize the root of the BST with the first value in preorder traversal root = TreeNode(preorder[0]) for value in preorder[1:]: insert_into_bst(root, value) return root"},{"question":"You are given an n-ary tree where each node contains a unique integer value. Each node in the tree has a variable number of children. You need to implement a method that finds the diameter of the tree. The diameter of an n-ary tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. The tree is represented as a list of `Node` objects, where each `Node` object has an integer `val` and a list of child `Node` objects. Write a function that takes the root node of the tree and returns the diameter of the tree.","solution":"class Node: def __init__(self, val): self.val = val self.children = [] def diameter_of_n_ary_tree(root): Finds the diameter of an n-ary tree. :param root: Node, root of the n-ary tree :return: int, diameter of the tree def dfs(node): if not node: return 0, 0 # height, diameter max_height = 0 second_max_height = 0 max_diameter = 0 for child in node.children: child_height, child_diameter = dfs(child) if child_height > max_height: second_max_height = max_height max_height = child_height elif child_height > second_max_height: second_max_height = child_height max_diameter = max(max_diameter, child_diameter) current_diameter = max(max_diameter, max_height + second_max_height) return max_height + 1, current_diameter return dfs(root)[1]"},{"question":"You are given a list of `n` integers representing the stock prices of a company in chronological order. You can perform a single transaction, which consists of buying one stock at a given day and selling one stock at a later day. Return the maximum profit you can achieve from this transaction. If no profit can be made, return 0. For example, given the array `[7, 1, 5, 3, 6, 4]`, the maximum profit you can achieve is `5` by buying on day 2 (price = 1) and selling on day 5 (price = 6). However, for the array `[7, 6, 4, 3, 1]`, no transaction is possible to make a profit, hence the output should be `0`.","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single transaction of buying and selling stock. :param prices: List[int] :return: int if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given an array of integers `heights` representing the heights of students in a class in a queue. You need to return an array representing the indices of the students in the queue after sorting them by their heights in non-decreasing order. Your task is to implement a function that determines the new positions of the students in the queue based on their heights and returns the indices of their new positions. Do not sort the original array, only provide their new sorted positions.","solution":"def sorted_positions(heights): Given an array of heights, return an array representing the indices of the students after sorting them by their heights in non-decreasing order. # Pair the heights with their original indices indexed_heights = list(enumerate(heights)) # Sort based on the heights sorted_indexed_heights = sorted(indexed_heights, key=lambda x: x[1]) # Extract the indices corresponding to the sorted order of heights sorted_positions = [index for index, height in sorted_indexed_heights] return sorted_positions"},{"question":"You are given a rope of length `n` and you need to cut it into pieces such that the product of the lengths of the pieces is maximized. You can cut the rope into as many pieces as you like (the pieces must have integer lengths), but each cut has to result in a piece that is at least length 1. Return _the maximum product you can achieve by cutting the rope_. For example, if you are given a rope of length 8, you can cut it into pieces of lengths 3, 3, and 2 to get the maximum product 3 * 3 * 2 = 18.","solution":"def max_product(n): Returns the maximum product of lengths of pieces you can achieve by cutting the rope of length n into pieces. if n <= 1: return 0 # Create a dp list where dp[i] represents the maximum product for rope length i. dp = [0] * (n + 1) dp[1] = 1 for i in range(2, n + 1): for j in range(1, i): dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j])) return dp[n]"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to return all the **unique pairs** of integers from the array that add up to `target`. Each pair should be a list of two integers `[num1, num2]`, where `num1 <= num2`. The pairs should be sorted in ascending order, based on the first number of each pair, and if the first numbers are the same, then by the second number. The numbers in the array can appear in any order, and the same number may not be used twice in a pair. If no such pairs exist, return an empty list. *For example, given `nums = [1, 2, 3, 4, 2, 3, 5, -1]` and `target = 4`, the valid pairs are `[(1, 3), (2, 2), (-1, 5)]`. The pairs should be returned as `[(1, 3), (2, 2), (-1, 5)]`.","solution":"def find_pairs(nums, target): nums.sort() pairs = set() lookup = {} for num in nums: complement = target - num if complement in lookup: pairs.add((min(num, complement), max(num, complement))) lookup[num] = lookup.get(num, 0) + 1 return sorted(list(pairs))"},{"question":"You are given a `k x n` binary matrix `matrix` where 0 represents a passable cell and 1 represents an obstacle. You are also given an integer `k` representing the maximum number of obstacles you are allowed to remove. Return the minimum number of steps required to move from the top-left corner `(0,0)` to the bottom-right corner `(k-1, n-1)` while removing at most `k` obstacles. If it\'s not possible to reach the bottom-right corner, return `-1`. Consider the following rules: - You can move up, down, left, or right from any cell. - Removal of an obstacle counts as a move. Try to find a solution with `O(k * n)` complexity.","solution":"from collections import deque def min_steps_with_obstacle_removal(matrix, k): rows, cols = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS Queue, each entry is (row, col, steps, remaining obstacle removals) queue = deque([(0, 0, 0, k)]) visited = set([(0, 0, k)]) while queue: r, c, steps, remaining_k = queue.popleft() if r == rows - 1 and c == cols - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: # Check bounds new_remaining_k = remaining_k - matrix[nr][nc] if new_remaining_k >= 0 and (nr, nc, new_remaining_k) not in visited: visited.add((nr, nc, new_remaining_k)) queue.append((nr, nc, steps + 1, new_remaining_k)) return -1 # If no path found"},{"question":"You are given a list of non-negative integers `nums` that are ordered by their `lexicographic order` as strings. You can perform a sequence of operations where in each operation, you can choose any element and increment it by 1. Return _the minimum number of operations required to make `nums` sorted in non-decreasing order_.","solution":"def min_operations_to_sort(nums): Returns the minimum number of operations required to make nums sorted in non-decreasing order. :param nums: List of non-negative integers ordered lexicographically as strings. :return: int, the minimum number of increment operations needed. operations = 0 for i in range(1, len(nums)): if nums[i] < nums[i-1]: diff = nums[i-1] - nums[i] operations += diff nums[i] = nums[i-1] return operations"},{"question":"You are given two strings s1 and s2 of equal length consisting of lowercase letters only. You want to rearrange the characters in both strings in such a way as to make the strings as similar as possible. The similarity between two strings is defined as the number of positions at which the characters are the same. Return the maximum similarity you can achieve after rearranging the characters in both strings. Note: You are allowed to rearrange the characters in the strings but not swap characters between the strings.","solution":"from collections import Counter def max_similarity(s1, s2): Returns the maximum similarity between two strings of equal length when rearranged to be as similar as possible. count1 = Counter(s1) count2 = Counter(s2) similarity = 0 # Iterate through each character in count1 for char in count1: if char in count2: similarity += min(count1[char], count2[char]) return similarity"},{"question":"You are given a list of positive integers `heights` representing the heights of buildings. A building is considered a \\"peak\\" if it is taller than both the buildings immediately adjacent to it. Your task is to determine the number of peaks in the list. Write a function `countPeaks(heights)` that takes in the list of building heights and returns the number of peak buildings. For example, given the list `[1, 3, 2, 4, 1, 5]`, the peaks are the buildings with heights `3` and `4` (the buildings adjacent to `3` have heights `1` and `2`, and the buildings adjacent to `4` have heights `2` and `1`), so the function should return 2.","solution":"def countPeaks(heights): Returns the number of peak buildings in the list of heights. A building is considered a \\"peak\\" if it is taller than both the buildings immediately adjacent to it. Parameters: heights (list of int): List of building heights. Returns: int: The number of peak buildings. if len(heights) < 3: return 0 peak_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peak_count += 1 return peak_count"},{"question":"Given a list of non-negative integers `coins` where `coins[i]` represents the number of coins of the `i-th` denomination and another integer `amount`, return the _minimum number of coins_ that you need to make up that `amount`. If that amount cannot be made up by any combination of the coins, return `-1`. You may assume that you have an infinite number of each denomination of coin.","solution":"def coin_change(coins, amount): Returns the minimum number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the coins, returns -1. # Initialize dp array with amount + 1 which signifies amount is not possible with given coins dp = [amount + 1] * (amount + 1) dp[0] = 0 # Loop through each amount up to the given amount for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"You are given a list of integers `nums` representing the prices of different items in a store. You are also given an integer `target` representing the amount of money you plan to spend. Write a function that determines the maximum number of items you can buy without exceeding the `target`. Each item can only be bought once. To solve this problem, you need to: 1. Consider all subsets of the `nums` list. 2. Calculate the sum of each subset. 3. Identify the subset with the maximum number of elements whose sum does not exceed the `target`. Write a function `maxItems(nums, target)` that returns the maximum number of items you can buy.","solution":"def maxItems(nums, target): Returns the maximum number of items whose sum does not exceed the target. # Sort nums in ascending order to consider cheaper items first nums.sort() total_sum = 0 count = 0 for price in nums: if total_sum + price <= target: total_sum += price count += 1 else: break return count"},{"question":"Given an integer array `heights` representing the heights of buildings, find the maximum area of a rectangular plot that can be formed with any set of contiguous buildings. The area is calculated considering the height of the shortest building in the selected contiguous buildings and the number of buildings in that selection. Return _the maximum rectangular area_ that can be formed.","solution":"def max_rectangle_area(heights): Given an integer array `heights` representing the heights of buildings, find the maximum area of a rectangular plot that can be formed with any set of contiguous buildings. Args: heights (list): List of integers representing the heights of buildings. Returns: int: The maximum rectangular area that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an undirected graph with `n` nodes labeled from `0` to `n - 1`, and an integer `k`. The graph is represented as a 2D integer array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi`. You need to determine if it is possible to partition the nodes into `k` non-empty subsets such that no two nodes within the same subset are directly connected by an edge. Return `true` if such a partition is possible, and `false` otherwise.","solution":"def is_possible_to_partition(n, edges, k): from collections import defaultdict, deque if k > n: return False graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) color = [-1] * n def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for node in range(n): if color[node] == -1: if not bfs(node): return False return True"},{"question":"You are given a binary string `s` of length `n`. You are allowed to perform at most `k` operations on the string. In one operation, you can choose any character of the string and flip it (a \'0\' becomes \'1\' and a \'1\' becomes \'0\'). Your goal is to maximize the length of the longest contiguous substring containing only \'1\'s. Return the length of the longest contiguous substring of \'1\'s you can obtain after performing at most `k` operations. If no operations are needed, return the length of the longest contiguous substring of \'1\'s in the original string.","solution":"def longest_ones(s, k): Returns the length of the longest contiguous substring containing only \'1\'s that can be obtained after performing at most k flips (converting \'0\' to \'1\') on the given binary string s. n = len(s) left = 0 max_length = 0 zeros_count = 0 for right in range(n): if s[right] == \'0\': zeros_count += 1 while zeros_count > k: if s[left] == \'0\': zeros_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `s` which consists of lowercase English letters and a pattern string `p`. You need to check if there is a permutation of the pattern string `p` that is a substring of `s`. If such a permutation exists, return `true`, otherwise, return `false`. A permutation of a string is any arrangement of its characters.","solution":"def check_inclusion(s, p): Check if there is a permutation of the pattern string `p` that is a substring of `s`. :param s: The input string s :param p: The pattern string p :return: True if a permutation of p is a substring of s, otherwise False from collections import Counter len_s, len_p = len(s), len(p) if len_p > len_s: return False p_count = Counter(p) window_count = Counter() for i in range(len_p): window_count[s[i]] += 1 if window_count == p_count: return True for i in range(len_p, len_s): window_count[s[i]] += 1 window_count[s[i - len_p]] -= 1 if window_count[s[i - len_p]] == 0: del window_count[s[i - len_p]] if window_count == p_count: return True return False"},{"question":"Given an array of integers `heights` representing the heights of students standing in a line, return the minimum number of students that must be removed so that the remaining students are standing in non-decreasing order of height. **Note** that the order of the students cannot be changed; only students can be removed to achieve the desired sequence.","solution":"def min_students_to_remove(heights): Returns the minimum number of students that must be removed to make the remaining students stand in non-decreasing order of height. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) longest_increasing_subsequence = max(dp) return n - longest_increasing_subsequence"},{"question":"Given a binary tree, implement a function `averageOfLevels` to return the average value of the nodes on each level in the form of an array. The binary tree is represented using the following `TreeNode` class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The function should have the following signature: ```python def averageOfLevels(root: TreeNode) -> List[float]: ``` # Example 1: Input: ``` 3 / 9 20 / 15 7 ``` Output: `[3.0, 14.5, 11.0]` # Example 2: Input: ``` 1 / 2 3 / 4 5 6 ``` Output: `[1.0, 2.5, 5.0]` # Constraints: * The number of nodes in the tree is in the range [1, 10^4]. * The value of nodes is in the range [-10^4, 10^4].","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def averageOfLevels(root: Optional[TreeNode]) -> List[float]: if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_length) return result"},{"question":"You are given a `1-indexed` array of integers `tasks` where `tasks[i]` represents the amount of time required to complete the `i-th` task. You are also given an integer `sessions` which represents the number of sessions you can have. Each session can accommodate a maximum of `k` units of time. Return the _minimum_ number of tasks that you would have left incomplete after attempting to fit as many tasks as possible into the given sessions. Note: You can only place whole tasks into the sessions, and a session can have remaining time once you place a task into it. You cannot split a task between sessions.","solution":"def min_incomplete_tasks(tasks, sessions, k): Returns the minimum number of tasks left incomplete after attempting to fit as many tasks as possible into the given sessions. Parameters: tasks (list of int): The array of tasks where tasks[i] is the time required for the (i+1)-th task. sessions (int): The number of sessions available. k (int): The maximum units of time each session can accommodate. Returns: int: The minimum number of tasks left incomplete. tasks.sort(reverse=True) completed_tasks = 0 remaining_time = [k] * sessions for task in tasks: for i in range(sessions): if task <= remaining_time[i]: remaining_time[i] -= task completed_tasks += 1 break return len(tasks) - completed_tasks"},{"question":"Given an array of integers `arr`, write a function that rearranges the elements in the array such that every second element of the rearranged array is greater than or equal to the elements directly before and after it. Return the modified array. Note: the elements should form a \\"wave\\" pattern where `arr[1] >= arr[0] <= arr[2] >= arr[3] <= arr[4] ...` and so on.","solution":"def wave_array(arr): Rearranges the elements in the array such that: arr[1] >= arr[0] <= arr[2] >= arr[3] <= arr[4] ... n = len(arr) if n < 2: return arr arr.sort() for i in range(1, n, 2): if i < n - 1: arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr"},{"question":"You are given a **0-indexed** array `heights` representing the heights of buildings in a city skyline in a line. A building `i` can see the sunset if all the buildings to its right have a smaller height than this building. Return an array of **indices** of buildings that can see the sunset, in the order from left to right. Example: ``` Input: heights = [4, 2, 3, 1] Output: [0, 2, 3] ``` Explanation: - Building at index 0 sees the sunset because there are no taller buildings to its right. - Building at index 1 cannot see the sunset because building at index 2 is taller. - Building at index 2 sees the sunset because building at index 3 is shorter. - Building at index 3 sees the sunset because there are no taller buildings to its right.","solution":"def sunset_views(heights): Returns the indices of buildings that can see the sunset. n = len(heights) result = [] max_height = 0 for i in range(n - 1, -1, -1): # Traverse from right to left. if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1] # reversed result to return in order from left to right."},{"question":"You are given a matrix `mat` of size `m x n` where each element is either `0` or `1`. You are also given an integer `k`. Return the maximum size of a square submatrix in `mat` that contains at most `k` `0`\'s. A square submatrix is a submatrix that has the same number of rows and columns.","solution":"def maxSquareSubmatrix(mat, k): m, n = len(mat), len(mat[0]) def count_zeros(matrix, x1, y1, x2, y2): return sum(matrix[x][y] == 0 for x in range(x1, x2) for y in range(y1, y2)) def can_construct(size): for i in range(m - size + 1): for j in range(n - size + 1): if count_zeros(mat, i, j, i + size, j + size) <= k: return True return False lo, hi = 0, min(m, n) while lo < hi: mid = (hi - lo + 1) // 2 + lo if can_construct(mid): lo = mid else: hi = mid - 1 return lo"},{"question":"Implement a class `UndirectedGraph` that supports the following operations on an undirected graph with no more than `100` nodes: * `void addEdge(int node1, int node2)`: Adds an edge between `node1` and `node2`. * `void removeEdge(int node1, int node2)`: Removes the edge between `node1` and `node2` if it exists. * `boolean hasEdge(int node1, int node2)`: Returns `true` if there is an edge between `node1` and `node2`, otherwise returns `false`. * `List<Integer> getNeighbors(int node)`: Returns a list of all the nodes that are directly connected to `node`. * `boolean isConnected(int node1, int node2)`: Returns `true` if there is a path connecting `node1` and `node2`, otherwise returns `false`. Note: - `addEdge` and `removeEdge` should operate in constant or logarithmic time. - `getNeighbors` should return the neighbors of a node sorted in ascending order. - The graph does not allow parallel edges or self-loops.","solution":"class UndirectedGraph: def __init__(self): self.adjacency_list = {i: set() for i in range(100)} def addEdge(self, node1, node2): if node1 != node2: self.adjacency_list[node1].add(node2) self.adjacency_list[node2].add(node1) def removeEdge(self, node1, node2): self.adjacency_list[node1].discard(node2) self.adjacency_list[node2].discard(node1) def hasEdge(self, node1, node2): return node2 in self.adjacency_list[node1] def getNeighbors(self, node): return sorted(self.adjacency_list[node]) def isConnected(self, node1, node2): visited = set() return self._dfs(node1, node2, visited) def _dfs(self, current, target, visited): if current == target: return True visited.add(current) for neighbor in self.adjacency_list[current]: if neighbor not in visited: if self._dfs(neighbor, target, visited): return True return False"},{"question":"Design and implement an `LRUCache` class. The class should support the following operations: `get(int key)` and `put(int key, int value)`. - `get(int key)`: Retrieve the value of the key if the key exists in the cache, otherwise return -1. - `put(int key, int value)`: Update the value of the key if the key already exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key. Implement the `LRUCache` class: ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRUCache with a positive size capacity. pass def get(self, key: int) -> int: Return the value of the key if the key exists, otherwise return -1. pass def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. pass ``` _Your implementation should be as efficient as possible in terms of time complexity._","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRUCache with a positive size capacity. self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: Return the value of the key if the key exists, otherwise return -1. if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"You are given a **0-indexed** integer array `ratings` of length `n` where `ratings[i]` denotes the rating of the `ith` product. You want to distribute rewards to the products such that products with higher ratings get strictly more rewards than their neighboring products with lower ratings. Each product must receive at least one reward. Return _the **minimum** number of rewards you need to distribute to satisfy the condition._","solution":"def minimum_rewards(ratings): n = len(ratings) rewards = [1] * n # Forward pass: ensure each rating is greater than the previous one gets more rewards for i in range(1, n): if ratings[i] > ratings[i - 1]: rewards[i] = rewards[i - 1] + 1 # Backward pass: ensure each rating is greater than the next one gets more rewards for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: rewards[i] = max(rewards[i], rewards[i + 1] + 1) return sum(rewards)"},{"question":"Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, write a function `kthSmallest(matrix, k)` which returns the k-th smallest element in the matrix. Note that it is the k-th smallest element in the sorted order, not the k-th distinct element. Example: Input: ``` matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8 ``` Output: 13 Explanation: The sorted result of the matrix elements is [1, 5, 9, 10, 11, 12, 13, 13, 15]. The 8-th smallest element is 13.","solution":"import heapq def kthSmallest(matrix, k): Function to find the k-th smallest element in a sorted n x n matrix. :param matrix: 2D List of integers representing the matrix :param k: Integer representing the k-th position :return: k-th smallest integer in the matrix # Initialize the min-heap n = len(matrix) min_heap = [] # Populate the heap with the first element of each row for r in range(min(n, k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k-1 times for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"Given a string `word`, return _the minimum number of insertions needed to make `word` a palindrome_. A palindrome is a string that reads the same forward and backward. You are allowed to insert any characters at any positions within the string. For example, for the string `\\"race\\"`, you can insert three characters to form the palindrome `\\"ecarace\\"` (insert `e` at the beginning and `eca` at the end).","solution":"def min_insertions_to_palindrome(word): Returns the minimum number of insertions needed to make the word a palindrome. n = len(word) # Create a 2D array to store the minimum insertions needed for substrings dp = [[0] * n for _ in range(n)] # Fill the table for length in range(2, n + 1): # length of the substring for i in range(n - length + 1): # starting index of the substring j = i + length - 1 # ending index of the substring if word[i] == word[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"You are given a matrix with `m` rows and `n` columns consisting of only the numbers `0` and `1`. You can flip any row of the matrix (i.e., change all `0`s in the row to `1`s, and all `1`s to `0`s). The goal is to maximize the number of rows that are all `1`s after performing any number of row flips. Write a function that, given the matrix, returns the maximum number of rows with all `1`s possible.","solution":"def max_all_ones_rows(matrix): Returns the maximum number of rows with all 1\'s possible after performing any number of row flips. if not matrix: return 0 from collections import defaultdict row_patterns = defaultdict(int) for row in matrix: # Get both the row and its flipped version row_tuple = tuple(row) flipped_row_tuple = tuple(1 - x for x in row) # Increase count for the pattern seen row_patterns[max(row_tuple, flipped_row_tuple)] += 1 # The maximum count of any pattern will give us the max rows with all 1\'s after optimal flips return max(row_patterns.values())"},{"question":"You are given an array of `students` where each element is a dictionary containing two keys, `\\"name\\"` and `\\"grade\\"`. The `\\"name\\"` is a string representing the student\'s name and the `\\"grade\\"` is an integer representing the student\'s grade. Your task is to group the students by their grades. Return a dictionary where the keys are the unique grades and the values are lists of names of students who have that grade. The lists should be sorted in ascending order of the students\' names.","solution":"from collections import defaultdict def group_students_by_grade(students): Groups students by their grades. :param students: List[Dict[str, Any]] - a list of dictionaries with \'name\' and \'grade\' keys :return: Dict[int, List[str]] - a dictionary with grades as keys and lists of student names as values grouped_students = defaultdict(list) for student in students: name = student[\'name\'] grade = student[\'grade\'] grouped_students[grade].append(name) # Sorting the student names for each grade for grade in grouped_students: grouped_students[grade].sort() return dict(grouped_students)"},{"question":"Given an integer array `nums`, return an array `result` where `result[i]` consists of the count of smaller elements to the right of `nums[i]`. This is, for each `nums[i]`, count the number of elements to its right that are smaller than `nums[i]`.","solution":"def count_smaller_elements_to_the_right(nums): Given an integer array nums, return an array result where result[i] consists of the count of smaller elements to the right of nums[i]. result = [0] * len(nums) for i in range(len(nums)): count = 0 for j in range(i + 1, len(nums)): if nums[j] < nums[i]: count += 1 result[i] = count return result"},{"question":"You are working on a project that involves processing of meeting schedules. Each meeting has a start time and an end time. Given an array of meeting intervals `intervals` where each interval is represented as `[start, end]`, determine if a person can attend all meetings without any overlap. Return `true` if there are no overlapping meetings, otherwise return `false`.","solution":"def can_attend_meetings(intervals): Determines if a person can attend all meetings without any overlap. :param intervals: List of meeting intervals where each interval is [start, end]. :return: Boolean value, True if there are no overlapping meetings, False otherwise. # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # Check if the current meeting starts before the previous one ends if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"Given a string `str` consisting of lowercase English letters and an integer `k`, find the longest substring of `str` that contains at most `k` distinct characters. If there are multiple substrings with the same maximum length, return the leftmost one. Return _the longest substring that meets these conditions_.","solution":"def longest_substring_with_k_distinct_characters(s, k): Returns the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The number of maximum distinct characters. Returns: str: The longest substring with at most k distinct characters. if k == 0 or not s: return \\"\\" # Initialize window pointers and a dictionary to count character frequency left = 0 right = 0 char_count = {} max_length = 0 max_length_start = 0 while right < len(s): # Add the character at the right pointer to the window current_char = s[right] if current_char in char_count: char_count[current_char] += 1 else: char_count[current_char] = 1 # If more than k distinct characters, contract the window from the left while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 # Adjust maximum length and start index of the result current_length = right - left + 1 if current_length > max_length: max_length = current_length max_length_start = left # Expand the window to the right right += 1 return s[max_length_start:max_length_start + max_length]"},{"question":"A sequence of positive integers `nums` is called **Arithmetic** if it satisfies the following condition: For all valid `i`, `nums[i+1] - nums[i]` is the same as `nums[1] - nums[0]`. Given a list of numbers, return _the length of the longest arithmetic subsequence_ in the list. An arithmetic subsequence is derived from the original list by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_arith_seq_length(nums): if len(nums) <= 1: return len(nums) longest = 0 dp = [{} for _ in range(len(nums))] for i in range(1, len(nums)): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest = max(longest, dp[i][diff]) return longest"},{"question":"Given a list of integers `arr`, you are required to split `arr` into two subarrays `A` and `B` such that the sum of elements in `A` is equal to the sum of elements in `B`, and `A` is non-empty and `B` is non-empty. Return `true` if such a split is possible, and `false` otherwise. Note that the elements in the original array must maintain their original order in their respective subarrays.","solution":"def can_split_array(arr): Determines if the array can be split into two subarrays with equal sum. :param arr: List[int] - list of integers :return: bool - True if array can be split as required, otherwise False total_sum = sum(arr) # If the total sum is odd, it cannot be split into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 # Iterate through the array and track the running sum for num in arr: current_sum += num # If the running sum equals the target sum, the array can be split if current_sum == target_sum: return True return False"},{"question":"Given a list of strings `words`, where each string consists only of lowercase alphabets, write a function to determine the minimum number of transformations needed to convert all strings to the same string. A transformation involves changing a single character in any string to any other character. Return the minimum number of transformations. Note: If it\'s impossible to convert all strings to the same string, return -1. * Example: For the input `[\\"cat\\", \\"bat\\", \\"rat\\"]`, the minimum number of transformations is 2 to convert all strings to \\"cat\\" (or \\"bat\\" or \\"rat\\"). The transformations are: \\"bat\\" to \\"cat\\" (1 change) and \\"rat\\" to \\"cat\\" (1 change).","solution":"def min_transformations_to_same_string(words): from collections import Counter if not words: return -1 n = len(words) word_length = len(words[0]) # Check if all words have the same length for word in words: if len(word) != word_length: return -1 # Min transformations needed to convert each character in position i transformations = [0] * word_length for i in range(word_length): char_count = Counter(word[i] for word in words) max_occurrences = max(char_count.values()) # Min transformations needed = Total words - Max occurrences of the most common character in position i transformations[i] = n - max_occurrences return sum(transformations)"},{"question":"Given a string `s` consisting of brackets `(` and `)`, and an integer `k`, you can remove `k` characters from the string. Return _the length of the longest subsequence of `s` that is a well-formed bracket sequence_ (i.e., every opening bracket has a corresponding closing bracket).","solution":"def longest_well_formed_subsequence(s, k): Returns the length of the longest subsequence of `s` that is well-formed after removing at most `k` characters. # Initialize balance variables open_brackets = 0 close_brackets = 0 removable = k # Count unmatched brackets for char in s: if char == \'(\': open_brackets += 1 elif char == \')\': if open_brackets > 0: open_brackets -= 1 else: close_brackets += 1 # Total unmatched characters to possibly remove unmatched_brackets = open_brackets + close_brackets # If we can remove all unmatched brackets if unmatched_brackets <= k: return len(s) - unmatched_brackets # Otherwise, we need to balance remaining removals max_pairs_can_form = (len(s) - unmatched_brackets) // 2 return max_pairs_can_form * 2"},{"question":"You are given an `n x n` 2D matrix `matrix` representing a completed Sudoku puzzle. Your task is to determine if the Sudoku puzzle is valid. The rules of Sudoku are: 1. Each row must contain the digits from 1 to 9 without repetition. 2. Each column must contain the digits from 1 to 9 without repetition. 3. Each of the nine 3 x 3 sub-grids must contain the digits from 1 to 9 without repetition. Return `true` if the given `matrix` represents a valid Sudoku puzzle, otherwise return `false`. Note that a Sudoku puzzle solution must adhere to the aforementioned rules. If the matrix does not contain all the required digits or the rules are violated in any row, column, or sub-grid, then the puzzle is considered invalid.","solution":"def is_valid_sudoku(matrix): Determines if the given n x n matrix is a valid Sudoku puzzle. def is_valid_block(block): Checks if a block (row, column or sub-grid) contains unique numbers from 1 to 9 (no repetition). block = [num for num in block if num != \'.\'] return len(block) == len(set(block)) size = len(matrix) subgrid_size = 3 # Check each row and each column for i in range(size): if not is_valid_block(matrix[i]) or not is_valid_block([matrix[r][i] for r in range(size)]): return False # Check each 3x3 sub-grid for r in range(0, size, subgrid_size): for c in range(0, size, subgrid_size): block = [matrix[r + i][c + j] for i in range(subgrid_size) for j in range(subgrid_size)] if not is_valid_block(block): return False return True"},{"question":"Given a sorted array of distinct integers `nums` and a target integer `target`, return an array of the two indices of the numbers that add up to the target. If there are no such numbers, return an empty array. You may assume that each input would have exactly one solution. For example, given `nums = [2, 7, 11, 15]` and `target = 9`, the output should be `[0, 1]` because `nums[0] + nums[1] = 2 + 7 = 9`.","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. Args: nums: List[int] - A list of sorted distinct integers. target: int - The target to find the sum. Returns: List[int] - The indices of the two numbers if found, otherwise an empty list. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to return the value of the node with the maximum depth in the tree. If there are multiple nodes with the maximum depth, return the sum of their values. A tree’s root node is at depth 0, its children are at depth 1, and so on. The function should return _an integer value_ representing either the maximum depth node\'s value or the sum of values of nodes at the maximum depth.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_deepest_nodes_sum(root): Returns the sum of values of nodes at the maximum depth in the binary tree. if not root: return 0 from collections import deque max_depth = -1 current_depth = 0 queue = deque([(root, 0)]) level_map = {} while queue: node, depth = queue.popleft() if depth not in level_map: level_map[depth] = [] level_map[depth].append(node.value) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) max_depth = max(max_depth, depth) return sum(level_map[max_depth])"},{"question":"You are given a `directory` represented as a nested dictionary where the keys are folder names and the values can either be an empty dictionary (if the folder contains no subfolders) or another dictionary (representing the subfolders). Write a function that accepts this `directory` dictionary and returns a flattened list of folder paths. Each path should be a string where folder names are separated by a forward slash `/`, starting from the outermost folder to the innermost. For example, given the directory structure: ```python directory = { \\"root\\": { \\"subdir1\\": { \\"subsubdir1\\": {} }, \\"subdir2\\": {} } } ``` The function should return the list: ``` [\\"root/subdir1/subsubdir1\\", \\"root/subdir2\\"] ```","solution":"def flatten_directory(directory, parent_path=\\"\\"): Returns a flattened list of folder paths. paths = [] for folder, subfolders in directory.items(): current_path = parent_path + \\"/\\" + folder if parent_path else folder if subfolders: paths.extend(flatten_directory(subfolders, current_path)) else: paths.append(current_path) return paths # Example usage: directory = { \\"root\\": { \\"subdir1\\": { \\"subsubdir1\\": {} }, \\"subdir2\\": {} } } print(flatten_directory(directory)) # Output: [\\"root/subdir1/subsubdir1\\", \\"root/subdir2\\"]"},{"question":"Given an array of integers, write a function to _find the length of the longest subarray with an equal number of 0s and 1s_.","solution":"def longest_subarray_equal_0s_1s(arr): Finds the length of the longest subarray with an equal number of 0s and 1s. Args: arr (list): A list of integers where integers are either 0 or 1. Returns: int: The length of the longest subarray with an equal number of 0s and 1s. # Replace 0 with -1 arr = [-1 if x == 0 else 1 for x in arr] prefix_sum = 0 prefix_sum_map = {0: -1} max_length = 0 for i in range(len(arr)): prefix_sum += arr[i] if prefix_sum in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[prefix_sum]) else: prefix_sum_map[prefix_sum] = i return max_length"},{"question":"Given a string `s` containing only lowercase letters, determine the largest substring where every character appears an even number of times. If there are multiple substrings with maximum length, return any one of them. Return _the largest substring with even frequency characters_.","solution":"def largest_even_frequency_substring(s): from collections import defaultdict def get_frequency(s): freq = defaultdict(int) for char in s: freq[char] += 1 return freq def all_even(freq): for count in freq.values(): if count % 2 != 0: return False return True max_len = 0 max_sub = \\"\\" for i in range(len(s)): for j in range(i, len(s)): sub_str = s[i:j + 1] freq = get_frequency(sub_str) if all_even(freq): if len(sub_str) > max_len: max_len = len(sub_str) max_sub = sub_str return max_sub"},{"question":"You are given a list of integers `nums` representing the heights of buildings arranged in a line. A building is considered an **ocean view** building if all the buildings to its right do not block its view to the ocean. In other words, a building has an ocean view if it is strictly taller than all the buildings to its right. Return a list of the indices of all buildings that have an ocean view, in ascending order.","solution":"def findBuildingsWithOceanView(nums): Given a list of integers representing the heights of buildings, return a list of the indices of all buildings that have an ocean view. A building has an ocean view if it is strictly taller than all the buildings to its right. n = len(nums) result = [] max_height = float(\'-inf\') for i in range(n - 1, -1, -1): if nums[i] > max_height: result.append(i) max_height = nums[i] return sorted(result)"},{"question":"Given the head of a singly linked list, group all nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is considered even, and so on. Note that the relative order inside both the odd and even groups should remain as it was in the input. For example, if the input linked list is `1 -> 2 -> 3 -> 4 -> 5 -> NULL`, the output should be `1 -> 3 -> 5 -> 2 -> 4 -> NULL`. The algorithm should run in O(n) time and use O(1) space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): if not head: return head # Initialize pointers for odd and even odd = head even = head.next even_head = even # Save the start of the even list while even and even.next: odd.next = odd.next.next even.next = even.next.next odd = odd.next even = even.next # Link the end of odd list to the head of even list odd.next = even_head return head"},{"question":"You are designing a **stock price tracker** that keeps track of the last known price of several stocks and allows for querying the current price of a stock and updating the stock\'s price. Implement the `StockPriceTracker` class with the following methods: * `StockPriceTracker()` Initializes the tracker object. * `void update(String stockSymbol, int price)` Updates the current price of the stock with the given `stockSymbol` to `price`. If the stock\'s price does not exist yet, it keeps the initial price as `price`. * `int current(String stockSymbol)` Returns the current price of the stock with the given `stockSymbol`. You can assume that all stock symbols provided will be valid non-empty strings, and the prices will be positive integers.","solution":"class StockPriceTracker: def __init__(self): Initializes the StockPriceTracker with an empty dictionary to store stock prices. self.stocks = {} def update(self, stockSymbol, price): Updates the price of the stock identified by stockSymbol. :param stockSymbol: str, the stock symbol to be updated :param price: int, the new price of the stock self.stocks[stockSymbol] = price def current(self, stockSymbol): Returns the current price of the stock identified by stockSymbol. :param stockSymbol: str, the stock symbol to be queried :return: int, the current price of the stock return self.stocks.get(stockSymbol, 0)"},{"question":"Given an array of `n` integers where `n > 1`, construct an array `output` such that `output[i]` is equal to the product of all the elements of `input` except `input[i]`. Solve it without using division and in O(n) time complexity. For example, given `[1,2,3,4]`, the return should be `[24,12,8,6]`.","solution":"def product_except_self(nums): Constructs an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. n = len(nums) if n <= 1: raise ValueError(\\"Input array must have more than 1 element\\") left_products = [1] * n right_products = [1] * n output = [1] * n # Calculate left products left_running_product = 1 for i in range(n): left_products[i] = left_running_product left_running_product *= nums[i] # Calculate right products right_running_product = 1 for i in range(n - 1, -1, -1): right_products[i] = right_running_product right_running_product *= nums[i] # Calculate output for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"Given a string `s` of parentheses `(` and `)`, return the minimum number of parentheses to be added to make the string valid. A string is considered valid if: * Open brackets are closed by a corresponding number of close brackets. * Open brackets must be closed in the correct order. Provide a function named `minAddToMakeValid` that accepts the string `s` and returns the minimum number of parentheses to be added.","solution":"def minAddToMakeValid(s: str) -> int: Returns the minimum number of parentheses to be added to make the string s valid. balance = 0 # Keeps track of balance of parentheses add_needed = 0 # Counts the minimum additions needed for char in s: if char == \'(\': balance += 1 elif char == \')\': balance -= 1 if balance < 0: add_needed += 1 balance = 0 return add_needed + balance"},{"question":"Given a list of integers `lst`, return the length of the longest subarray where the absolute difference between any two elements is less than or equal to `k`.","solution":"def longest_subarray_with_diff_less_than_k(lst, k): Returns the length of the longest subarray where the absolute difference between any two elements is less than or equal to k. if not lst: return 0 lst.sort() start = 0 max_len = 0 for end in range(len(lst)): while lst[end] - lst[start] > k: start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an array of positive integers `arr` representing the heights of a stack of blocks. You can remove any two adjacent blocks of the same height and receive points equal to the height of these blocks. The goal is to maximize the total points you can earn by repeatedly removing pairs of adjacent blocks of the same height. Return the maximum points you can achieve.","solution":"def max_points(arr): Returns the maximum points by removing pairs of adjacent blocks of the same height. Parameters: arr (list of int): The heights of the stack of blocks. Returns: int: The maximum points achievable. stack = [] points = 0 for height in arr: if stack and stack[-1] == height: points += height stack.pop() else: stack.append(height) return points"},{"question":"A binary matrix `grid` is considered medium if each zero in the matrix has at least one adjacent one. An element is adjacent to another if they are horizontally or vertically neighboring. Given a `m x n` binary matrix `grid`, return `true` if the matrix is medium. Otherwise, return `false`.","solution":"def is_medium(grid): Determine if the binary matrix is medium. A binary matrix is medium if each zero in the matrix has at least one adjacent one. :param grid: List[List[int]], the m x n binary matrix :return: boolean, True if the matrix is medium, otherwise False rows = len(grid) cols = len(grid[0]) def has_adjacent_one(r, c): if r > 0 and grid[r-1][c] == 1: return True if r < rows - 1 and grid[r+1][c] == 1: return True if c > 0 and grid[r][c-1] == 1: return True if c < cols - 1 and grid[r][c+1] == 1: return True return False for r in range(rows): for c in range(cols): if grid[r][c] == 0: if not has_adjacent_one(r, c): return False return True"},{"question":"Design a class called `MyHashMap` without using any built-in hash table libraries. Implement the following methods: * `MyHashMap()` Initializes the `MyHashMap` object. * `void put(int key, int value)` Inserts a `(key, value)` pair into the HashMap. If the `key` already exists in the map, update the corresponding `value`. * `int get(int key)` Returns the `value` to which the specified `key` is mapped, or -1 if this map contains no mapping for the `key`. * `void remove(int key)` Removes the `key` and its corresponding `value` if the map contains the specified key.","solution":"class MyHashMap: def __init__(self): Initialize your data structure here. self.size = 1000 self.map = [[] for _ in range(self.size)] def _hash(self, key: int) -> int: Generate a hash for a given key return key % self.size def put(self, key: int, value: int) -> None: Value will always be non-negative. h = self._hash(key) for i, (k, v) in enumerate(self.map[h]): if k == key: self.map[h][i] = (key, value) return self.map[h].append((key, value)) def get(self, key: int) -> int: Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key h = self._hash(key) for (k, v) in self.map[h]: if k == key: return v return -1 def remove(self, key: int) -> None: Removes the mapping of the specified value key if this map contains a mapping for the key h = self._hash(key) for i, (k, v) in enumerate(self.map[h]): if k == key: del self.map[h][i] return"},{"question":"Given a binary string `s`, you are allowed to perform at most one swap operation on `s`: choose any two bits in the string and swap their positions. Return the maximum possible binary number that can be obtained by performing at most one swap operation on `s`. If the string is already the largest possible binary number, return the string as-is.","solution":"def max_binary_string(s): Returns the maximum possible binary number that can be obtained by performing at most one swap operation on s. s_list = list(s) n = len(s_list) # Find the first occurrence of \'0\' from the left (if any) first_zero_index = -1 for i in range(n): if s_list[i] == \'0\': first_zero_index = i break # If there are no \'0\'s or the string is made up of contiguous \'1\'s, # then the string is already the largest possible binary number. if first_zero_index == -1 or first_zero_index == n - 1: return s # Look for the \'1\' after the first \'0\' which would give us a greater number when swapped for j in range(first_zero_index + 1, n): if s_list[j] == \'1\': # Swap the \'1\' found with the first \'0\' s_list[first_zero_index], s_list[j] = s_list[j], s_list[first_zero_index] break return \'\'.join(s_list)"},{"question":"You\'re given two non-empty integer arrays `A` and `B`, both of which are sorted in **non-decreasing order**. Find the **median** of the two sorted arrays. The overall run-time complexity should be `O(log(min(n, m)))`, where `n` is the size of array `A` and `m` is the size of array `B`. The median of two sorted arrays is the middle element if the combined length is odd, or the average of the two middle elements if the combined length is even. Return _the median of the two sorted arrays_.","solution":"def findMedianSortedArrays(A, B): def find_kth_smallest(a, b, k): if len(a) > len(b): a, b = b, a if not a: return b[k - 1] if k == 1: return min(a[0], b[0]) part_a = min(len(a), k // 2) part_b = k - part_a if a[part_a - 1] < b[part_b - 1]: return find_kth_smallest(a[part_a:], b, k - part_a) else: return find_kth_smallest(a, b[part_b:], k - part_b) total_length = len(A) + len(B) if total_length % 2 == 1: return find_kth_smallest(A, B, total_length // 2 + 1) else: return (find_kth_smallest(A, B, total_length // 2) + find_kth_smallest(A, B, total_length // 2 + 1)) / 2"},{"question":"You are given a string `s` representing a sequence of parentheses. A **valid parentheses sequence** is one that can be perfectly matched, meaning every opening parenthesis `\'(\'` has a corresponding closing parenthesis `\')\'` and the pairs of parentheses are well-nested. For instance, `\\"(())\\"` and `\\"()()\\"` are valid sequences, while `\\")(\\"`, `\\"(()\\"`, and `\\"(())(\\"` are not. Your task is to return the **minimum number of parentheses** you must add to make the given string `s` valid. Implement the `ParenthesesValidator` class: * `ParenthesesValidator()` Initializes the object of the class. * `int minAddToMakeValid(String s)` Returns the minimum number of parentheses needed to make the string `s` a valid parentheses sequence. Examples: * Input: `s = \\"())\\"` Output: 1 Explanation: By adding one opening parentheses before the sequence, it becomes a valid sequence `\\"()())\\"`. * Input: `s = \\"(((\\"` Output: 3 Explanation: By adding three closing parentheses after the sequence, it becomes a valid sequence `\\"((()))\\"`.","solution":"class ParenthesesValidator: def __init__(self): pass def minAddToMakeValid(self, s: str) -> int: # Initialize counters for unbalanced opening and closing parentheses open_count = 0 close_count = 0 # Traverse the string for char in s: if char == \'(\': open_count += 1 elif char == \')\': if open_count > 0: open_count -= 1 else: close_count += 1 # The total corrections needed is the sum of unbalanced \'(\' and \')\' return open_count + close_count"},{"question":"You are given a list of integers `arr` representing the daily stock prices of a company over a period of days. You can perform at most one transaction (i.e., you can buy one and sell one share of the stock). Design an algorithm to find the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. The algorithm should have a time complexity of `O(n)`, where `n` is the length of the list `arr`. _Return the maximum profit you can achieve from the transaction._","solution":"def max_profit(arr): Returns the maximum profit that can be achieved from one transaction of buying and selling stock. If no profit can be achieved, returns 0. if not arr: return 0 min_price = float(\'inf\') max_profit = 0 for price in arr: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given a string `s` consisting of lowercase English letters, a string `t`, and an integer `k`. In one move, you can choose a non-empty substring of `s` and a character `c` in `t` and replace that substring with `c`. Return _the minimum number of moves required to convert `s` into `t` using at most `k` moves_. If it\'s not possible to convert `s` into `t`, return `-1`.","solution":"def min_moves_to_convert(s, t, k): Returns the minimum number of moves required to convert string s into string t using at most k moves. If it\'s not possible, returns -1. # Initial checks for quick returns if len(s) != len(t): return -1 differing_positions = [] for i in range(len(s)): if s[i] != t[i]: differing_positions.append(i) required_moves = len(differing_positions) if required_moves <= k: return required_moves else: return -1"},{"question":"Write a function `canPartition(nums)` that determines whether a given list of positive integers `nums` can be partitioned into two subsets such that the sum of elements in both subsets is equal. Return `True` if such a partition is possible, otherwise return `False`.","solution":"def canPartition(nums): Determine if the input list can be partitioned into two subsets with equal sum. :param nums: List of positive integers :return: True if such a partition is possible, otherwise False total_sum = sum(nums) # If the total sum is odd, it can\'t be partitioned into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Using a set to store subset sums possible_sums = {0} for num in nums: new_sums = set() for s in possible_sums: if s + num == target: return True new_sums.add(s + num) possible_sums.update(new_sums) return target in possible_sums"},{"question":"You are given an integer array `arr` and an integer `k`, representing the maximum number of operations you can perform. In one operation, you can choose any element of the array and increment or decrement it by 1. You need to maximize the minimum value in the array after performing at most `k` operations. Write a function that returns this maximum possible minimum value.","solution":"def maximize_min_value(arr, k): Returns the maximum possible minimum value after at most k operations where each operation increments or decrements an element in the array by 1. def canAchieve(minVal): Helper function to determine if we can achieve a minimum value of minVal with at most k operations. total_operations = 0 for val in arr: if val < minVal: total_operations += (minVal - val) return total_operations <= k low, high = min(arr), max(arr) + k best_min_val = low while low <= high: mid = (low + high) // 2 if canAchieve(mid): best_min_val = mid low = mid + 1 else: high = mid - 1 return best_min_val"},{"question":"Given a string `s` consisting of `+` and `-` symbols, return the _minimum number of operations required to make all the symbols in the string the same_. In one operation, you can flip any single symbol (`+` to `-` or `-` to `+`). The answer is guaranteed to fit into a signed 32-bit integer.","solution":"def min_operations_to_make_uniform(s): Returns the minimum number of operations required to make all the symbols in the string the same. count_plus = s.count(\'+\') count_minus = s.count(\'-\') return min(count_plus, count_minus)"},{"question":"You are given an integer array `heights` representing the heights of buildings in a line. The ocean is to the right of the buildings. A building has a scenic view if it can see the ocean, meaning there are no buildings taller than or equal to it to its right. Return a list of indices of buildings that have a scenic view, ordered from left to right.","solution":"def find_buildings_with_scenic_view(heights): Returns the list of indices of buildings that have a scenic view. n = len(heights) result = [] max_height = float(\'-inf\') for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1] # reverse to get the indices in left to right order"},{"question":"You are given an array of integers `heights` representing the heights of flowers in a garden. You need to design a watering system that ensures every flower receives enough water. The watering system operates in rounds, and in each round, you can water the flowers in any continuous subarray. Every time you water a subarray, every flower in that subarray grows by one unit in height. Determine the minimum number of rounds needed to make all the flowers the same height. Return the minimum number of watering rounds needed.","solution":"def min_watering_rounds(heights): if not heights: return 0 rounds = 0 for i in range(1, len(heights)): if heights[i] > heights[i - 1]: rounds += 1 return rounds"},{"question":"Given a string `text` consisting of lowercase letters and an integer `k`, return the length of the **longest substring** of `text` that contains at most `k` distinct characters. A **substring** is a contiguous sequence of characters within the string. Ensure the algorithm runs in `O(n)` time complexity, where `n` is the length of the `text`.","solution":"def longest_substring_k_distinct(text, k): Returns the length of the longest substring with at most k distinct characters. n = len(text) if k == 0 or n == 0: return 0 left = 0 right = 0 max_len = 0 char_count = {} while right < n: char = text[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = text[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given two strings, `s` and `t`. You need to transform `s` into `t` by performing the following operations any number of times: - Swap any two characters in `s`. - Reverse any substring of `s`. Return _the minimum number of such operations required to make `s` equal to `t`_. If it is impossible to make `s` equal to `t`, return `-1`.","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform string s into string t using swaps of any two characters or reversing any substring. If it\'s not possible, returns -1. # Check if both strings have same characters with the same frequency if sorted(s) != sorted(t): return -1 # If strings are already equal if s == t: return 0 return 1"},{"question":"You are given a 2D grid of integers `grid` representing a structured city layout, where each cell within the grid represents a building with a specific height. Each building has a unique height and the city authorities want to construct skybridges between the buildings. A skybridge can only be constructed between two adjacent buildings (horizontally or vertically) if the height difference between the two buildings is at most `k`. Given an integer `k`, return the total number of possible skybridges that can be constructed in the city.","solution":"def count_skybridges(grid, k): Returns the total number of possible skybridges that can be constructed in the city grid. Parameters: grid (List[List[int]]): 2D list of integers representing the height of buildings. k (int): Maximum allowable height difference for constructing skybridges. Returns: int: Total number of possible skybridges. rows = len(grid) cols = len(grid[0]) total_skybridges = 0 for i in range(rows): for j in range(cols): if i + 1 < rows and abs(grid[i][j] - grid[i+1][j]) <= k: total_skybridges += 1 if j + 1 < cols and abs(grid[i][j] - grid[i][j+1]) <= k: total_skybridges += 1 return total_skybridges"},{"question":"You are given an array of integers `arr` and an integer `m`. Your task is to: * Find the number of distinct pairs `(i, j)` such that `0 <= i < j < arr.length` and `(arr[i] + arr[j]) % m == 0`. Return _the number of such pairs_.","solution":"def count_pairs(arr, m): Returns the number of distinct pairs (i, j) such that 0 <= i < j < len(arr) and (arr[i] + arr[j]) % m == 0. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % m == 0: count += 1 return count"},{"question":"You are given two non-negative integers represented as strings, `num1` and `num2`. Multiply the two numbers and return the product as a string. You must implement this without using any built-in library functions for handling large integers (such as `BigInteger` or `long long` in some languages). For example, given `num1 = \\"123\\"` and `num2 = \\"456\\"`, the output should be `\\"56088\\"`. ---","solution":"def multiply_strings(num1, num2): Multiplies two non-negative integers represented as strings and returns the product as a string. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) product = [0] * (len1 + len2) num1, num2 = num1[::-1], num2[::-1] for i in range(len1): for j in range(len2): product[i + j] += int(num1[i]) * int(num2[j]) product[i + j + 1] += product[i + j] // 10 product[i + j] %= 10 while len(product) > 1 and product[-1] == 0: product.pop() return \'\'.join(map(str, product[::-1]))"},{"question":"You are given a **0-indexed** string `s` consisting of lowercase English letters and a **pattern** string `pattern` also consisting of lowercase English letters. A **substring** of `s` is said to **match the pattern** if the frequency of each character in the substring is exactly the same as the frequency of each character in the pattern. Return the number of such **matching substrings** in `s`. A **substring** is a contiguous non-empty sequence of characters within a string.","solution":"def count_matching_substrings(s, pattern): from collections import Counter len_s = len(s) len_pattern = len(pattern) pattern_counter = Counter(pattern) if len_s < len_pattern: return 0 current_counter = Counter(s[:len_pattern]) matching_count = 0 if current_counter == pattern_counter: matching_count += 1 for i in range(len_pattern, len_s): current_counter[s[i - len_pattern]] -= 1 if current_counter[s[i - len_pattern]] == 0: del current_counter[s[i - len_pattern]] current_counter[s[i]] += 1 if current_counter == pattern_counter: matching_count += 1 return matching_count"},{"question":"You are given an array of integers `arr` representing the capacity of storage units in a warehouse. Additionally, you are provided an array `boxes`, where each element represents the size of a box that needs to be stored. You are required to place each box into a storage unit such that no storage unit\'s capacity is exceeded. Each storage unit can hold only one box and each box can only be placed in one storage unit. Return the maximum number of boxes that can be placed in the storage units.","solution":"def max_boxes_that_fit(arr, boxes): Determines the maximum number of boxes that can be placed in the storage units without exceeding capacities. :param arr: List of integers representing the capacity of storage units. :param boxes: List of integers representing the size of boxes. :return: Maximum number of boxes that can be placed in the storage units. if not arr or not boxes: return 0 arr.sort() boxes.sort() i, j, max_boxes = 0, 0, 0 while i < len(arr) and j < len(boxes): if boxes[j] <= arr[i]: max_boxes += 1 j += 1 i += 1 return max_boxes"},{"question":"You are given two strings `pattern` and `source`, where `pattern` consists of distinct lowercase English letters and `source` consists of lowercase English letters. Find the length of the smallest substring in `source` that contains all the characters in `pattern`. Return _the length of the smallest substring in `source` that contains all the characters in `pattern`_. If no such substring exists, return 0.","solution":"from collections import defaultdict def min_window_substring_length(pattern, source): Finds the length of the smallest substring in `source` that contains all the characters in `pattern`. :param pattern: String with distinct lowercase English letters :param source: String with lowercase English letters :return: Length of the smallest substring containing all characters in `pattern`, else 0 if not pattern or not source or len(pattern) > len(source): return 0 dict_pattern = defaultdict(int) for char in pattern: dict_pattern[char] += 1 required = len(dict_pattern) left, right = 0, 0 formed = 0 window_counts = defaultdict(int) min_length = float(\'inf\') ans = (0, 0) while right < len(source): char = source[right] window_counts[char] += 1 if char in dict_pattern and window_counts[char] == dict_pattern[char]: formed += 1 while left <= right and formed == required: char = source[left] if right - left + 1 < min_length: min_length = right - left + 1 ans = (left, right) window_counts[char] -= 1 if char in dict_pattern and window_counts[char] < dict_pattern[char]: formed -= 1 left += 1 right += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given a grid of size `n x m` filled with non-negative integers. Your task is to find the minimum path sum from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. Write a function: ```python def min_path_sum(grid: List[List[int]]) -> int: # ... your code return result ``` The function should return the minimum path sum. The grid will be non-empty and will contain positive integer values.","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Initialize dp array dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"Given an array of positive integers `heights` representing the heights of buildings, you are asked to determine the maximum area of a rectangular region that can be contained within the skyline. A rectangle formed between `heights[i]` and `heights[j]` (i < j) has an area defined by the smaller height of the two buildings multiplied by the distance between them (i.e., `(j - i)`). Return _the maximum possible area of any such rectangular region._","solution":"def max_area(heights): Returns the maximum area of a rectangular region that can be contained within the skyline. Args: heights: List[int] - list of positive integers representing the heights of buildings Returns: int - maximum area of the rectangular region max_area = 0 left = 0 right = len(heights) - 1 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a string `s` consisting of only the characters \'a\' and \'b\'. You can transform `s` using the following operation any number of times: choose any character in `s` and change it to either \'a\' or \'b\'. Your goal is to make the string a palindrome with the minimum number of operations. Return the _minimum number of operations_ required to make `s` a palindrome.","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to make the string s a palindrome. Parameters: s (str): The input string consisting of characters \'a\' and \'b\'. Returns: int: The minimum number of operations to make s a palindrome. # Calculate the length of the string n = len(s) # Initialize the number of operations to 0 operations = 0 # Iterate over the first half of the string for i in range(n // 2): # Compare the character and its corresponding character from the end if s[i] != s[n - 1 - i]: operations += 1 return operations"},{"question":"Given a matrix `grid` of size `m x n` consisting of only integers `0` and `1`, return the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), such that you can only move up, down, left, or right and you can travel only through cells that contain `1`. If there is no such path, return `-1`. * `int shortestPath(int[][] grid)` - This function should take a 2D array `grid` as input and return the length of the shortest path, or `-1` if no such path exists.","solution":"from collections import deque def shortestPath(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a given 2D grid where we can only move in cells with \'1\' and move up, down, left, or right. If no such path exists, returns \'-1\'. if not grid or grid[0][0] != 1 or grid[-1][-1] != 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"Given a binary tree root, return the values of nodes you can see ordered from top to bottom if you look at the tree from the right side. * Each node in the tree has a unique value. * A node is visible if no other node is present to its right at the same level. Return an array of the visible nodes\' values. # Example: - Input: root = [1, 2, 3, null, 5, null, 4] - Output: [1, 3, 4] Explanation: - When viewed from the right side, the visible nodes are: - From level 0: 1 - From level 1: 3 - From level 2: 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the right side view of the binary tree. if root is None: return [] from collections import deque queue = deque([(root, 0)]) # (node, level) right_view = {} while queue: node, level = queue.popleft() # Update the most right node at each level right_view[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) # Extract the values in order of levels return [right_view[level] for level in range(len(right_view))]"},{"question":"You are given a 2D integer grid representing a map of a city, where `1` represents a building and `0` represents an empty space. Each building can be connected to another building in four possible directions (up, down, left, right). Write a function to find the largest area covered by connected buildings (a group of `1`s). You must return the size of this area. Note that the buildings have to be connected directly (diagonally connected buildings should not be counted as a connected area).","solution":"def find_largest_connected_area(grid): Finds the largest area covered by connected buildings in the grid. :param grid: List of List of integers, where 1 represents a building and 0 represents an empty space. :return: Integer representing the size of the largest area covered by connected buildings. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return 0 visited[r][c] = True area = 1 for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]: area += dfs(r + dr, c + dc) return area max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"There is a robot on a `m x n` grid. The robot is initially located at the top-left corner (i.e., `(0, 0)`). The robot tries to move to the bottom-right corner (i.e., `(m - 1, n - 1)`). The robot can only move right or down at any point in time. Each cell contains an integer that represents the cost of entering that cell. Return _the minimum cost path sum to get to the bottom-right corner of the grid_.","solution":"def min_path_sum(grid): Returns the minimum cost path sum to reach the bottom-right corner of the given grid. :param grid: List of lists, where each sublist represents a row in the grid and each element a cell\'s cost :return: Integer, minimum cost path sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a new grid to store the minimal cost path sums dp = [[0] * n for _ in range(m)] # Fill the dp grid, starting from the top-left corner dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Populate the rest of the dp grid for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given a non-negative integer `num`, represented as a string. Remove k digits from the number so that the new number is the smallest possible. Return the new number as a string with no leading zeros. If the resulting string is empty, return \\"0\\" instead. For example: * If `num` = \\"1432219\\" and `k` = 3, you should return \\"1219\\". * If `num` = \\"10200\\" and `k` = 1, you should return \\"200\\". The input constraints are as follows: * The length of `num` is between 1 and 10^5. * k is between 0 and the length of `num`.","solution":"def removeKdigits(num, k): Remove k digits from the number so that the new number is the smallest possible. Parameters: num (str): A non-negative integer represented as a string. k (int): The number of digits to remove. Returns: str: The smallest possible number after removing k digits, without leading zeros. stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k is still greater than 0, remove the remaining digits from the end while k > 0: stack.pop() k -= 1 # Convert to string and strip leading zeros result = \'\'.join(stack).lstrip(\'0\') return result if result else \\"0\\""},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a city. Two buildings are said to have a \\"clear view\\" of each other if, and only if, there are no buildings of greater or equal height between them when looking from left to right. Return _an integer array containing the **indices** of buildings that have a clear view to the right_. For example, if `heights` = `[3, 7, 8, 3, 6, 1]`, the buildings at indices `[2, 4, 5]` have a clear view to the right.","solution":"def buildings_with_clear_view(heights): Returns indices of buildings that have a clear view to the right. n = len(heights) clear_view_indices = [] max_height_to_right = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height_to_right: clear_view_indices.append(i) max_height_to_right = heights[i] return clear_view_indices[::-1]"},{"question":"You are given an integer array `arr` of length `n`. A sub-sequence of `arr` is an array that can be derived by deleting some (possibly zero) elements from `arr` without changing the order of the remaining elements. Return `true` if there exists a sub-sequence of `arr` whose elements sum up to a given integer target `t`, otherwise return `false`.","solution":"def is_subsequence_sum_possible(arr, t): Returns true if there exists a sub-sequence of `arr` whose sum is equal to `t`, otherwise false. n = len(arr) # Using a set to store sums of sub-sequences dp = {0} for num in arr: new_dp = dp.copy() for sum_in_dp in dp: new_sum = sum_in_dp + num if new_sum == t: return True new_dp.add(new_sum) dp = new_dp return t in dp"},{"question":"You are given an array of strings `words` and a string `pattern`. Each string in `words` can be transformed into the `pattern` if it follows the same mapping of characters. In other words, there should be a one-to-one correspondence between the characters in the words and the characters in the pattern\'s positions. Return a list of all the strings in `words` that can be transformed into the `pattern`. For example, given `words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"]` and `pattern = \\"abb\\"`, the output should be `[\\"mee\\", \\"aqq\\"]` because the characters in these words can be uniquely mapped to the characters in \\"abb\\".","solution":"def find_and_replace_pattern(words, pattern): Returns a list of all strings in `words` that can be transformed into the `pattern`. def matches(word, pattern): if len(word) != len(pattern): return False char_map_word_to_pattern = {} char_map_pattern_to_word = {} for w_char, p_char in zip(word, pattern): if w_char not in char_map_word_to_pattern: char_map_word_to_pattern[w_char] = p_char if p_char not in char_map_pattern_to_word: char_map_pattern_to_word[p_char] = w_char if char_map_word_to_pattern[w_char] != p_char or char_map_pattern_to_word[p_char] != w_char: return False return True return [word for word in words if matches(word, pattern)]"},{"question":"Given an array of integers `nums` where some of the elements appear twice and others appear once, return _an array of all the integers that appear twice_. You must write an algorithm that runs in `O(n)` time and uses `O(1)` space. (Note: The returned array should be in ascending order.)","solution":"def find_duplicates(nums): Finds all elements that appear twice in the array \'nums\'. The algorithm modifies the original array to encode frequency information and achieves O(n) time complexity with O(1) additional space. Args: nums (List[int]): The list of integers where some elements appear twice and others appear once. Returns: List[int]: A list of integers that appear twice in \'nums\' sorted in ascending order. duplicates = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: duplicates.append(abs(nums[i])) else: nums[index] = -nums[index] return sorted(duplicates)"},{"question":"You are given an array of `n` integers `arr`, and an integer `target`. Your task is to find two integers in `arr` such that their sum is equal to `target`. If such a pair exists, return their indices as a list of the form `[index1, index2]` where `index1` < `index2`. If no such pair exists, return an empty list. You may assume that each input would have exactly one solution. Each element in the array appears only once. Write a function `twoSum(arr, target)` that takes as input an array of integers `arr` and an integer `target`, and returns a list of two indices where the sum of their corresponding values in `arr` equals `target`. Example: ``` Input: arr = [2, 7, 11, 15], target = 9 Output: [0, 1] ``` Explanation: Because `arr[0] + arr[1] == 9`.","solution":"def twoSum(arr, target): Finds two indices in the array such that their values add up to the target. Parameters: arr (list of int): List of integers. target (int): The target sum. Returns: list: List of two indices where the sum of arr[index1] + arr[index2] equals target. If no such pair exists, returns an empty list. index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: return [index_map[complement], i] index_map[num] = i return []"},{"question":"You are given an array of integers `nums`, and you need to perform a series of operations according to the following rules: - In each operation, you can select any two elements from the array and remove them. - After removing the two elements, you add their sum to the array. You need to perform these operations until only one element remains in the array. Return that final element. For example, given `nums = [1, 2, 3, 4]`, you can perform the following operations: - Remove `1` and `2`, resulting in `nums = [3, 4, 3]`. - Remove `3` and `3`, resulting in `nums = [4, 6]`. - Remove `4` and `6`, resulting in `nums = [10]`. In this example, the final element will be `10`. Return the final element after performing all operations.","solution":"def final_element(nums): Perform operations on the list `nums` until only one element remains. Each operation involves selecting any two elements, removing them, and adding their sum back to the array. while len(nums) > 1: # Sort the array nums.sort() # Remove the two smallest elements a = nums.pop(0) b = nums.pop(0) # Add their sum back to the array nums.append(a + b) return nums[0]"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents a point on the 2D plane. A line is considered to be made by two points `(a, b)` and `(c, d)` if their coordinates create a straight line. Determine the maximum number of points from the given array that can all lie on the same straight line. Return _the maximum number of points that can all lie on the same straight line._","solution":"def max_points_on_line(points): from collections import defaultdict from fractions import Fraction def gcd(a, b): while b: a, b = b, a % b return a def slope(p1, p2): dx = p2[0] - p1[0] dy = p2[1] - p1[1] if dx == 0: return \'inf\' if dy == 0: return \'0\' divisor = gcd(dx, dy) return (dy // divisor, dx // divisor) n = len(points) if n < 3: return n max_points = 0 for i in range(n): slopes = defaultdict(int) for j in range(n): if i != j: s = slope(points[i], points[j]) slopes[s] += 1 max_points = max(max_points, max(slopes.values(), default=0) + 1) return max_points"},{"question":"You are given an `m x n` binary matrix `grid`. An island is a group of `1`s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. An island is considered to be a **cluster** if the island is connected without any `0`s separating any part of it. Implement the `NumberOfClusters` class: * `NumberOfClusters(int[][] grid)` constructs the `NumberOfClusters` object and initializes it with the grid. * `int countIslands()` returns the total number of isolated clusters of land in the grid. * `void update(int row, int col, int val)` updates the value at position `(row, col)` to be `val` (either `0` or `1`). Note: Be sure that `update` can potentially alter the number of clusters in the grid and the result of `countIslands` should reflect this.","solution":"class NumberOfClusters: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 def countIslands(self): visited = [[False for _ in range(self.cols)] for _ in range(self.rows)] def dfs(r, c): if r < 0 or c < 0 or r >= self.rows or c >= self.cols or self.grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) count = 0 for row in range(self.rows): for col in range(self.cols): if self.grid[row][col] == 1 and not visited[row][col]: dfs(row, col) count += 1 return count def update(self, row, col, val): if row < 0 or col < 0 or row >= self.rows or col >= self.cols: raise ValueError(\\"Invalid grid coordinates\\") self.grid[row][col] = val"},{"question":"You are given a connected graph with `n` vertices and `m` edges represented as an edge list `connections`. Each edge in the graph has a weight denoted by `connections[i] = [u, v, w]` where `u` and `v` are vertices and `w` is the weight of the edge connecting them. The graph is **not guaranteed to be simple**, meaning it can have multiple edges between the same pair of vertices, and it may contain cycles. Your task is to find the **minimum spanning tree (MST)** of the graph. Return _the total weight of the MST_. If there are multiple MSTs with the same total weight, any of them will be considered acceptable.","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskals_mst(n, connections): connections.sort(key=lambda x: x[2]) # sort the edges by weight parent = [i for i in range(n)] rank = [0] * n mst_weight = 0 edges_used = 0 for u, v, w in connections: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += w edges_used += 1 # If we\'ve already used n-1 edges, we can stop if edges_used == n - 1: break return mst_weight"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. Write a function to _rotate the array_ to the right by `k` steps, where `k` is non-negative. Rotation means that each element of the array is shifted to its right, and the last element of the array is moved to the first position cyclically. Return the rotated array.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. :param arr: List[int] - List of integers to be rotated. :param k: int - Number of steps to rotate the array. :return: List[int] - The rotated array. n = len(arr) if n == 0: return arr k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"You are given an array `arr` containing `n` integers, and a 2D array `operations` where each element of `operations` is `[i, j, k]`. There are two types of operations: 1. For an operation `[1, i, j]`, reverse the subarray of `arr` starting at index `i` and ending at index `j` (inclusive). Note that `i` and `j` are 0-indexed. 2. For an operation `[2, i, k]`, increment the value at index `i` of `arr` by `k`. After performing all operations in the given order, return the modified array `arr`.","solution":"def modify_array(arr, operations): Modifies the input array based on the given list of operations. The operations can be of two types: - [1, i, j]: Reverse the subarray from index i to j inclusive - [2, i, k]: Increment the value at index i by k Parameters: arr (list of int): The input array of integers. operations (list of list of int): A list of operations to be applied on the array. Returns: list of int: The modified array after performing all operations. for op in operations: if op[0] == 1: # Reverse subarray from index op[1] to op[2] i, j = op[1], op[2] arr[i:j+1] = arr[i:j+1][::-1] elif op[0] == 2: # Increment the value at index op[1] by op[2] i, k = op[1], op[2] arr[i] += k return arr"},{"question":"You are given an integer array `arr` of length `n`, where each element represents the cost of a particular item. You have a budget `k` and you wish to purchase as many items from the array as possible without exceeding your budget. Return the **maximum number of items** you can buy with the given budget `k`. Note that you can only purchase each item once and cannot split the cost of any item.","solution":"def max_items_within_budget(arr, budget): Returns the maximum number of items that can be bought without exceeding the given budget. Parameters: arr (list of int): List of item costs. budget (int): Available budget to spend. Returns: int: Maximum number of items that can be bought. arr.sort() count = 0 current_sum = 0 for cost in arr: if current_sum + cost <= budget: current_sum += cost count += 1 else: break return count"},{"question":"Given a list of `n` non-negative integers `nums` representing the amount of money of each house, determines the maximum amount of money you can rob tonight without alerting the police. Each house in the neighborhood is put along a street and each house can have security systems connected to its adjacent houses, which means if you rob one house, you cannot rob its immediate neighbor. * For example, given `nums = [2, 3, 2]`, the maximum amount of money you can rob is `3`. * For example, given `nums = [1, 2, 3, 1]`, the maximum amount of money you can rob is `4`. Implement the function `int rob(vector<int>& nums)` that returns the maximum amount of money you can rob tonight without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money you can rob tonight without alerting the police. if not nums: return 0 if len(nums) <= 2: return max(nums) def rob_line(houses): prev1, prev2 = 0, 0 for house in houses: new_rob = max(prev1, prev2 + house) prev2 = prev1 prev1 = new_rob return prev1 # Special case for circular houses return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"You are given a list of non-negative integers representing the heights of buildings in an urban skyline. Each building is represented by a pair of integers `[x, H]` where `x` is the x-coordinate of the building and `H` is the height of the building at that point. The buildings form a skyline. Write a function to merge these buildings into a list of \\"skyline key points,\\" representing the outline of the skyline formed by these buildings. A skyline key point is represented by a pair of integers `[x, H]`, where `x` is the x-coordinate and `H` is the height at that x-coordinate. Implement the function `mergeSkyline(buildings: List[List[int]]) -> List[List[int]]`: * `buildings` is a list of lists, where each inner list represents a building. * The function should return a list of lists, where each inner list represents a skyline key point. Example: ```python buildings = [[1, 3, 8], [2, 4, 6], [5, 6, 7]] print(mergeSkyline(buildings)) # Output: [[1, 3], [3, 4], [4, 0], [5, 6], [6, 0], [7, 8]] ``` The input list `buildings` is guaranteed to be well-formed, with each building represented by three integers: `[x_start, x_end, H]`, where `x_start` and `x_end` are the starting and ending x-coordinates, and `H` is the height. The output list should represent the merged skyline formed by all buildings, listing the key points from left to right.","solution":"from typing import List from heapq import heappop, heappush def mergeSkyline(buildings: List[List[int]]) -> List[List[int]]: The function merges the given buildings into a list of skyline key points. Each building is given as [x_start, x_end, height]. events = [] for x_start, x_end, height in buildings: events.append((x_start, -height)) events.append((x_end, height)) events.sort() result = [] heap = [0] prev_height = 0 for x, height in events: if height < 0: heappush(heap, height) else: heap.remove(-height) heap.sort() current_height = -heap[0] if current_height != prev_height: result.append([x, current_height]) prev_height = current_height return result"},{"question":"You are given an array `target` where `target[i]` represents the desired final value at position `i`. You are also given an integer `n`, representing the length of another array `arr` that is initially filled with zeros. Your task is to write a function that generates a sequence of operations to transform `arr` to `target`. You are allowed to perform the following operations: - **Increase:** Increment any element in the array. - **Decrease:** Decrement any element in the array. Return _an array of operations_ that will transform `arr` to `target` in minimal steps. Each operation should be represented by a string formatted as `\\"Increase <index>\\"` or `\\"Decrease <index>\\"` where `<index>` is the element\'s position in the array.","solution":"def transform_array(target, n): operations = [] arr = [0] * n for i in range(len(target)): while arr[i] < target[i]: operations.append(f\\"Increase {i}\\") arr[i] += 1 while arr[i] > target[i]: operations.append(f\\"Decrease {i}\\") arr[i] -= 1 return operations"},{"question":"You are given a string `s` that represents a sequence of characters, which may include letters, digits, and special characters. Write a function that removes all the duplicate characters from the string and returns the resulting string in the same order as the first occurrence of each character. Maintain the relative order of the characters in the original string. For instance, given the input string `\\"abcabc\\"`, the function should return `\\"abc\\"`.","solution":"def remove_duplicates(s): Removes duplicate characters from the string s and returns the resulting string with the first occurrence of each character in the same order as they appeared. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a `n x n` matrix of integers `matrix` where each row and each column is sorted in ascending order. Your task is to return the `k`-th smallest element in the matrix. Note that it is the `k`-th smallest element **in the sorted order**, not the `k`-th distinct element.","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in the matrix. Args: matrix : List[List[int]] : n x n matrix of integers sorted in ascending order by row and column k : int : the k-th smallest element to find Returns: int : k-th smallest element in the matrix # Implementing min-heap for better time efficiency n = len(matrix) min_heap = [(matrix[0][0], 0, 0)] # (value, row, col) visited = set((0, 0)) while k > 0: val, r, c = heapq.heappop(min_heap) k -= 1 if k == 0: return val # Push the next element in the current column to the heap if r + 1 < n and (r + 1, c) not in visited: heapq.heappush(min_heap, (matrix[r + 1][c], r + 1, c)) visited.add((r + 1, c)) # Push the next element in the current row to the heap if c + 1 < n and (r, c + 1) not in visited: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) visited.add((r, c + 1))"},{"question":"Given an array of strings `products` and a string `searchWord`, implement a function that returns a list of lists. For each character in `searchWord` from the first to the last character, you need to find the products in `products` which contain that prefix and return up to the first three matching products in lexicographical order. If fewer than three products exist with the given prefix, return all of them. Return an empty list if there are no products starting with that prefix. For example, given `products = [\\"mobile\\", \\"mouse\\", \\"moneypot\\", \\"monitor\\", \\"mousepad\\"]` and `searchWord = \\"mouse\\"`, the output should be: ``` [ [\\"mobile\\", \\"moneypot\\", \\"monitor\\"], [\\"mobile\\", \\"moneypot\\", \\"monitor\\"], [\\"mouse\\", \\"mousepad\\"], [\\"mouse\\", \\"mousepad\\"], [\\"mouse\\", \\"mousepad\\"] ] ```","solution":"def suggested_products(products, searchWord): Returns a list of lists, where each list contains up to three products that match prefixes of \'searchWord\', sorted lexicographically. products.sort() result = [] prefix = \\"\\" for char in searchWord: prefix += char matches = [product for product in products if product.startswith(prefix)] result.append(matches[:3]) return result"},{"question":"You are given an integer array `arr` consisting of `n` positive integers and an integer `k`. Your task is to split the array into `k` non-empty contiguous subarrays. The score of a single subarray is defined as the maximum element in that subarray. The score of a split is the sum of scores of all `k` subarrays. Return _the **minimum** possible score of a split._","solution":"def minMaxSplit(arr, k): This function returns the minimum possible score of a split by dividing the array into k non-empty contiguous subarrays. Parameters: arr (list): List of positive integers. k (int): Number of non-empty contiguous subarrays. Returns: int: Minimum possible score of the split. def can_split(max_sum): current_sum = 0 num_subarrays = 1 for num in arr: if current_sum + num > max_sum: num_subarrays += 1 current_sum = num if num_subarrays > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"Implement a data structure that supports the following operations on a set of integers: * `addElement(int value)` - Adds the value to the set. If the value already exists in the set, do nothing. * `removeElement(int value)` - Removes the value from the set. If the value does not exist in the set, do nothing. * `getRandomElement()` - Returns a random element from the set. Each element must have the same probability of being returned. If the set is empty, throw an exception or return a specific value indicating that the set is empty. * `getSize()` - Returns the number of elements in the set. Implement the class `RandomizedSet` to support these operations. Use the most efficient approach to ensure that each operation is performed in average O(1) time complexity.","solution":"import random class RandomizedSet: def __init__(self): self.set_elements = {} self.list_elements = [] def addElement(self, value: int) -> None: if value not in self.set_elements: self.set_elements[value] = len(self.list_elements) self.list_elements.append(value) def removeElement(self, value: int) -> None: if value in self.set_elements: index_to_remove = self.set_elements[value] last_element = self.list_elements[-1] self.list_elements[index_to_remove] = last_element self.set_elements[last_element] = index_to_remove self.list_elements.pop() del self.set_elements[value] def getRandomElement(self) -> int: if not self.list_elements: raise Exception(\\"The set is empty\\") return random.choice(self.list_elements) def getSize(self) -> int: return len(self.set_elements)"},{"question":"You are given an integer array `nums` of size `n` representing the power of each player, where `n` is an even number and `nums` contains unique elements. You are required to form teams of two players each with the constraint that the absolute difference in their power levels is minimized. Return _the sum of the absolute differences in power levels for all teams_. Each player can only be in one team.","solution":"def min_difference_sum(nums): Returns the sum of the absolute differences in power levels for all teams, where the absolute differences are minimized. Args: nums (List[int]): The power levels of players. Returns: int: The sum of the absolute differences in power levels for all teams. nums.sort() sum_diffs = 0 for i in range(0, len(nums), 2): sum_diffs += abs(nums[i] - nums[i+1]) return sum_diffs"},{"question":"You are given a string `s` containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and a string `t` that is a potential permutation of `s`. Determine if `t` is a valid permutation such that all parentheses in `t` are properly closed and nested. Return `true` if `t` is a valid permutation, and `false` otherwise.","solution":"def is_valid_permutation(t): Determines if the string t, which is a permutation of some given string s, has valid and properly nested parentheses. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in t: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return False return stack == []"},{"question":"Given a 2D grid of characters `board` and a string `word`, return `true` if `word` exists in the grid, and `false` otherwise. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Implement a function `bool exist(vector<vector<char>>& board, string word)` that performs the operation as described. **Example**: ```python board = [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ] word = \\"ABCCED\\" exist(board, word) # returns True word = \\"SEE\\" exist(board, word) # returns True word = \\"ABCB\\" exist(board, word) # returns False ``` **Constraints**: - `board` and `word` will consist only of uppercase and lowercase English letters.","solution":"def exist(board, word): Returns True if the word exists in the board by moving horizontally or vertically. def dfs(board, word, i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False temp = board[i][j] board[i][j] = \'#\' found = (dfs(board, word, i + 1, j, word_index + 1) or dfs(board, word, i - 1, j, word_index + 1) or dfs(board, word, i, j + 1, word_index + 1) or dfs(board, word, i, j - 1, word_index + 1)) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given a binary tree where each node has an integer value and each path from the root to the leaf has a corresponding \\"path sum\\". Define the path sum as the sum of each value along the path from the root node to a leaf. A binary tree is considered **balanced** if the difference between the path sums of any two leaf nodes is at most 1. Write a function that takes the root of a binary tree and returns whether the tree is **balanced**. If the tree is balanced, return `true`; otherwise, return `false`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_tree(root): Check if a binary tree is balanced based on the defined path sum condition. Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is balanced, False otherwise. def dfs(node): if not node: return (True, 0, float(\'inf\'), float(\'-inf\')) left_balanced, left_sum, left_min_leaf, left_max_leaf = dfs(node.left) right_balanced, right_sum, right_min_leaf, right_max_leaf = dfs(node.right) current_sum = node.value if node.left is None and node.right is None: return (True, current_sum, current_sum, current_sum) current_balanced = (left_balanced and right_balanced and (abs(left_min_leaf - right_min_leaf) <= 1 if node.left and node.right else True) and (abs(left_max_leaf - right_max_leaf) <= 1 if node.left and node.right else True)) min_leaf = min(left_min_leaf, right_min_leaf) max_leaf = max(left_max_leaf, right_max_leaf) return (current_balanced, current_sum, min_leaf, max_leaf) balanced, _, _, _ = dfs(root) return balanced"},{"question":"You are given a list of integers `nums` and an integer `target`. Return `true` if there exist four distinct indices `a, b, c, d` such that `nums[a] + nums[b] + nums[c] + nums[d]` is equal to `target`, otherwise return `false`.","solution":"def four_sum_exists(nums, target): Returns True if there exist four distinct indices `a, b, c, d` such that `nums[a] + nums[b] + nums[c] + nums[d]` is equal to `target`, otherwise returns False. if len(nums) < 4: return False nums.sort() n = len(nums) for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: s = nums[i] + nums[j] + nums[left] + nums[right] if s == target: return True elif s < target: left += 1 else: right -= 1 return False"},{"question":"You are given an array of integers `temperatures` representing the daily temperatures of a city for `n` consecutive days, where `n` is the length of the array. Implement a method that returns an array `result` such that `result[i]` contains the number of days you would have to wait after the `i-th` day to get a warmer temperature. If there is no future day for which this is possible, put `0` in `result[i]`. **Function signature:** ```python def days_until_warmer(temperatures: List[int]) -> List[int]: ``` **Example:** ```python temperatures = [73, 74, 75, 71, 69, 72, 76, 73] print(days_until_warmer(temperatures)) # Output should be [1, 1, 4, 2, 1, 1, 0, 0] ```","solution":"from typing import List def days_until_warmer(temperatures: List[int]) -> List[int]: Returns an array where each element is the number of days until a warmer temperature. If no warmer temperature is forthcoming, the value is 0. n = len(temperatures) result = [0] * n stack = [] # This will store indices of the `temperatures` list for i in range(n): # As long as the stack is not empty and the current temperature # is warmer than the temperature at index of the last element # of the stack (which means there\'s a warmer temperature on the current day). while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"You are given a binary tree with `n` nodes. Each node is uniquely identified by an integer value from `1` to `n`. The tree is represented as a **0-indexed** integer array `parents`, where `parents[i]` is the parent of node `i`. For the root of the tree, `parents[i] = -1`. You need to determine the **longest path** in the tree where each node has **unique** values. Return the length of this longest path.","solution":"from collections import defaultdict def longest_unique_path(parents): def dfs(node, visited): longest = 0 for child in tree[node]: if child not in visited: visited.add(child) longest = max(longest, dfs(child, visited)) visited.remove(child) return 1 + longest n = len(parents) if n == 0: return 0 # Build the tree using adjacency list representation tree = defaultdict(list) root = None for child, parent in enumerate(parents): if parent == -1: root = child else: tree[parent].append(child) if root is None: return 0 # To handle possible edge cases where root is not found visited = set([root]) return dfs(root, visited)"},{"question":"You are given a list of non-negative integers representing the heights of a set of buildings. The width of each building is `1`. Given this list, compute the **maximum amount of water** that can be trapped between the buildings, following a rainstorm. You may assume that the ends of the list are **not** closed, meaning water trapped should only be calculated between buildings and not beyond the ends of the list. Return the total amount of water trapped in **square units**.","solution":"def trap(height): Calculate the total area of trapped rainwater between the buildings. :param height: List[int], a list of non-negative integers representing the heights of a set of buildings. :return: int, total water trapped between the buildings. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water total_water = 0 for i in range(n): water = min(left_max[i], right_max[i]) - height[i] total_water += max(water, 0) return total_water"},{"question":"Given an array of integers `heights` representing the height of students in a line, and an array `expected` representing the expected order of heights after sorting, return the number of indices where `heights[i]` is not equal to `expected[i]`. This indicates the number of students that are not in the correct position according to the sorted order.","solution":"def height_checker(heights): Returns the number of indices where heights[i] is not equal to expected[i]. Args: heights (list): List of integers representing the height of students. Returns: int: Number of indices where heights[i] does not match expected[i]. expected = sorted(heights) mismatch_count = 0 for i in range(len(heights)): if heights[i] != expected[i]: mismatch_count += 1 return mismatch_count"},{"question":"You are given an array `nums` consisting of `n` integers, where `nums[i]` represents the value at the `i-th` position. The array can be rotated by placing an element from the back to the front. For example, rotating `[1, 2, 3]` once would result in `[3, 1, 2]`. You are also given a positive integer `k`, which denotes the number of times you can rotate the array. Define `maxSubarraySum` to be the maximum sum of a subarray of `nums`. Your task is to return the maximum value of `maxSubarraySum` after performing the rotation operation at most `k` times. Note that you are allowed to rotate the array zero times.","solution":"def max_subarray_sum(nums): Helper function that returns the maximum sum of a subarray using Kadane\'s Algorithm. max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def max_value_after_rotations(nums, k): Returns the maximum value of maxSubarraySum after performing at most k rotations. n = len(nums) if k == 0: return max_subarray_sum(nums) possible_results = [] # First, calculate the maxSubarraySum without any rotations. possible_results.append(max_subarray_sum(nums)) # Perform rotations and calculate the maxSubarraySum for each rotation for i in range(1, k+1): # Perform one rotation nums = [nums[-1]] + nums[:-1] possible_results.append(max_subarray_sum(nums)) # Get the maximum of all stored results return max(possible_results)"},{"question":"Given an array of integers `nums`, return _the **minimum** number of **operations** required to make the array elements **unique**_. In one operation, you can _increment any element by `1`_.","solution":"def min_increment_for_unique(nums): Given an array of integers `nums`, return the minimum number of operations required to make the array elements unique. In one operation, you can increment any element by `1`. # Sort the array to bring duplicates next to each other nums.sort() # Initialize the count of increments needed increments = 0 # Iterate over the array to ensure all elements are unique for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: increment_needed = nums[i - 1] - nums[i] + 1 nums[i] += increment_needed increments += increment_needed return increments"},{"question":"Given a binary tree, root-to-leaf paths are paths from the root node to any leaf node. A leaf node is defined as a node with no children. Write a function that returns _the number of distinct root-to-leaf paths in which the sum of the values of the nodes on the path is equal to a given target sum_. Your function should accept the `root` of the binary tree and an integer `targetSum` as input and output the number of distinct paths that satisfy the condition.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum_helper(node, targetSum, current_sum): if node is None: return 0 current_sum += node.val # If it\'s a leaf node and sum matches the targetSum, count this path if node.left is None and node.right is None: return 1 if current_sum == targetSum else 0 # Recur for left and right subtrees return (path_sum_helper(node.left, targetSum, current_sum) + path_sum_helper(node.right, targetSum, current_sum)) def count_paths_with_sum(root, targetSum): if root is None: return 0 # Count paths from the root paths_from_root = path_sum_helper(root, targetSum, 0) # Try the left and right subtrees as new roots paths_on_left = count_paths_with_sum(root.left, targetSum) paths_on_right = count_paths_with_sum(root.right, targetSum) return paths_from_root + paths_on_left + paths_on_right"},{"question":"Given the `root` of a binary tree, return the _right side view_ of the tree. The right side view of a tree is the set of nodes visible when the tree is viewed from the right side, from top to bottom.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the right side view of a binary tree. Args: root (TreeNode): root of the binary tree. Returns: List[int]: the right side view of the tree. if not root: return [] right_view = [] queue = deque([root]) # Initialize a queue for level order traversal while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # If it\'s the rightmost element of this level if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"You are given two non-empty strings `word1` and `word2`, representing two sequences of characters. Your goal is to merge these two strings into a single word such that the merged word preserves the relative order of characters from each original string. More formally, the merged word should be formed by alternating characters from `word1` and `word2`, starting with the first character of `word1`. If one of the strings runs out of characters before the other, append the remaining characters from the other string to the merged word. Return _the resulting merged word_.","solution":"def merge_alternately(word1, word2): Merges two strings by alternating characters from each original string. Args: word1: First input string. word2: Second input string. Returns: A merged string formed by alternating characters of word1 and word2. merged = [] len1, len2 = len(word1), len(word2) i, j = 0, 0 while i < len1 and j < len2: merged.append(word1[i]) merged.append(word2[j]) i += 1 j += 1 # Append the remaining characters if i < len1: merged.append(word1[i:]) if j < len2: merged.append(word2[j:]) return \'\'.join(merged)"},{"question":"Given an array of integers `arr`, find all elements in the array that appear more than once and return an array of these duplicate elements in ascending order. If no such elements exist, return an empty array.","solution":"def find_duplicates(arr): Finds all elements in the array that appear more than once and returns an array of these duplicate elements in ascending order. Args: arr (list of int): The input array of integers. Returns: list of int: The list of duplicate elements in ascending order, or an empty list if no duplicates exist. from collections import Counter # Count the frequencies of each element in the array counter = Counter(arr) # Find elements that appear more than once duplicates = [num for num, count in counter.items() if count > 1] # Return the duplicates in ascending order return sorted(duplicates)"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer array `indices` of the same length. Each character in the string `s` needs to be rearranged according to the given array `indices`, where the character originally at the `i-th` position should be moved to `indices[i]` in the rearranged string. Return the rearranged string after the specified shuffle.","solution":"def shuffle_string(s, indices): Returns a rearranged string after shuffling the characters according to the given indices. :param s: String consisting of lowercase alphabets. :param indices: List of integers where indices[i] indicates the new position of the character at i in s. :return: A new string after shuffling. shuffled = [\'\'] * len(s) for i, char in enumerate(s): shuffled[indices[i]] = char return \'\'.join(shuffled)"},{"question":"You are given an integer array `nums` and an integer `target`. You want to find the **length of the longest contiguous subarray** within `nums` that has a sum equal to `target`. If no such subarray exists, return `0`. The test cases are generated such that the length of the array `nums` is between 1 and 10<sup>4</sup> and each element of `nums` is between -10<sup>4</sup> and 10<sup>4</sup>.","solution":"def max_subarray_length(nums, target): Returns the length of the longest contiguous subarray that sums to target. If no such subarray exists, returns 0. prefix_sum = {} current_sum = 0 max_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum == target: max_length = i + 1 if (current_sum - target) in prefix_sum: max_length = max(max_length, i - prefix_sum[current_sum - target]) if current_sum not in prefix_sum: prefix_sum[current_sum] = i return max_length"},{"question":"**Design a Stack Data Structure** allowing operations to push elements, pop the top element, and retrieve the maximum element in the stack in constant time. Implement the `MaxStack` class: * `MaxStack()` Initializes the object. * `void push(int x)` Pushes element `x` onto the stack. * `int pop()` Removes the element on the top of the stack and returns it. * `int top()` Gets the top element of the stack without removing it. * `int getMax()` Retrieves the maximum element in the stack without removing it.","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self): if not self.stack: raise IndexError(\\"pop from empty stack\\") popped = self.stack.pop() if popped == self.max_stack[-1]: self.max_stack.pop() return popped def top(self): if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def getMax(self): if not self.max_stack: raise IndexError(\\"getMax from empty max stack\\") return self.max_stack[-1]"},{"question":"You are given two strings, `s1` and `s2`, both consisting of lowercase English letters. You want to determine if you can make two strings equal by deleting some characters from both strings. More formally, return `true` if you can delete some characters from both strings such that both strings become **anagrams** of each other; otherwise, return `false`. Two strings are anagrams if they contain the same characters with the same frequency.","solution":"def can_become_anagrams(s1, s2): Determines if two strings can become anagrams by deleting some characters from both. Args: s1 (str): First input string. s2 (str): Second input string. Returns: bool: True if the strings can become anagrams, False otherwise. from collections import Counter # Count frequency of each character in both strings count1 = Counter(s1) count2 = Counter(s2) # For each unique character in the union of the strings for char in set(count1.keys()).union(set(count2.keys())): # If the character count does not match in both strings, return False if count1[char] != count2[char]: return False return True"},{"question":"You are tasked with implementing a simplified version of a multi-user task management system. Each task has a specific priority level, and multiple users can be assigned to a single task. The system must support the following operations: - `addTask(int taskId, int priority)`: Adds a new task with a given `taskId` and `priority`. If a task with the same `taskId` already exists, do nothing. - `assignUserToTask(int taskId, int userId)`: Assigns a user with `userId` to the task with `taskId`. If the task does not exist, do nothing. If the user is already assigned to the task, do nothing. - `getUsersAssignedToTask(int taskId)`: Returns a list of user IDs assigned to the task with `taskId`. If the task does not exist, return an empty list. - `getTasksByPriority(int priority)`: Returns a list of task IDs that have the specified `priority`. If no tasks have the given `priority`, return an empty list. Implement the `TaskManager` class: - `class TaskManager`: Contains the four methods described above. Use appropriate data structures to ensure that the operations are efficient.","solution":"class TaskManager: def __init__(self): self.tasks = {} self.tasks_by_priority = {} def addTask(self, taskId, priority): if taskId not in self.tasks: self.tasks[taskId] = { \'priority\': priority, \'users\': set() } if priority not in self.tasks_by_priority: self.tasks_by_priority[priority] = [] self.tasks_by_priority[priority].append(taskId) def assignUserToTask(self, taskId, userId): if taskId in self.tasks and userId not in self.tasks[taskId][\'users\']: self.tasks[taskId][\'users\'].add(userId) def getUsersAssignedToTask(self, taskId): if taskId in self.tasks: return list(self.tasks[taskId][\'users\']) return [] def getTasksByPriority(self, priority): if priority in self.tasks_by_priority: return self.tasks_by_priority[priority] return []"},{"question":"You are given an integer array `arr` and an integer `target`. Return _the number of **unique pairs** of numbers in the array that sum up to `target`_. Each pair should be counted only once, even if they appear in different orders in the array. Ensure that your solution operates efficiently on large datasets.","solution":"def count_unique_pairs(arr, target): Returns the number of unique pairs of numbers in the array that sum up to target. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"Given an integer `array` of positive integers representing the height of bars where the width of each bar is `1`, return *the maximum amount of water* that can be trapped after raining. The array represents a histogram where the width of each bar is `1`. The water is trapped between the bars and it is assumed that the top of the histogram will not be breached.","solution":"def trap(height): Calculates the maximum amount of water that can be trapped after raining. Arguments: height : list[int] -- an array of positive integers representing the height of bars Returns: int -- the maximum amount of water that can be trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a matrix `grid` of `m x n` integers where each cell represents the height of a terrain, find a cell `(i, j)` such that the water flowing from this cell can reach both the Pacific and Atlantic oceans. Water can flow from a cell to any of its four adjacent cells with height less than or equal to the current cell. The Pacific Ocean touches the left and top edges of the matrix, and the Atlantic Ocean touches the right and bottom edges of the matrix. Return an _array of cells_ where water can flow to both the Pacific and Atlantic oceans_. * For example, in a `5 x 5` grid: ``` [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]] ``` The cells where water can flow to both the Pacific and Atlantic oceans are `[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]`.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) pacific = [[False for _ in range(n)] for _ in range(m)] atlantic = [[False for _ in range(n)] for _ in range(m)] def dfs(r, c, visited, prev_height): if (r < 0 or r >= m or c < 0 or c >= n or visited[r][c] or matrix[r][c] < prev_height): return visited[r][c] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc, visited, matrix[r][c]) # Start DFS from Pacific Ocean (top and left edges) for i in range(m): dfs(i, 0, pacific, matrix[i][0]) dfs(i, n - 1, atlantic, matrix[i][n - 1]) for j in range(n): dfs(0, j, pacific, matrix[0][j]) dfs(m - 1, j, atlantic, matrix[m - 1][j]) result = [] for i in range(m): for j in range(n): if pacific[i][j] and atlantic[i][j]: result.append([i, j]) return result"},{"question":"You are given a string `s` representing a series of lowercase alphanumeric characters with no spaces and an integer `k`. Your task is to determine if the string `s` can be rearranged such that the same character does not appear more than once in any `k` consecutive positions. If such a rearrangement is possible, return one possible rearranged string. If it is not possible, return an empty string.","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s, k): if k == 0: return s counter = Counter(s) max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) queue = [] result = [] while max_heap: freq, char = heappop(max_heap) freq = -freq result.append(char) queue.append((char, freq - 1)) if len(queue) >= k: front_char, front_freq = queue.pop(0) if front_freq > 0: heappush(max_heap, (-front_freq, front_char)) return \\"\\".join(result) if len(result) == len(s) else \\"\\" # Example usage # s = \\"aabbcc\\", k = 3, Output: \\"abcabc\\" or \\"acabcb\\" print(rearrange_string(\\"aabbcc\\", 3)) # s = \\"aaabc\\", k = 3, Output: \\"\\" print(rearrange_string(\\"aaabc\\", 3))"},{"question":"You are given an integer array `nums` sorted in non-decreasing order, and an integer `target`. Your task is to determine if `target` is a majority element in `nums`. An element is considered a majority element if it appears more than `n // 2` times, where `n` is the length of the array. Return `true` if `target` is a majority element in `nums`, and `false` otherwise. You must design an algorithm with a time complexity of O(log n). Example: ```python Input: nums = [2, 4, 4, 4, 4, 6, 8], target = 4 Output: true Explanation: The element `4` appears 4 times in the array, which is more than 7 // 2 = 3 times. ```","solution":"from bisect import bisect_left, bisect_right def is_majority_element(nums, target): Determines if target is a majority element in nums. Parameters: nums (list): A list of integers sorted in non-decreasing order. target (int): The target value to check for majority element status. Returns: bool: True if target is a majority element, False otherwise. n = len(nums) left = bisect_left(nums, target) right = bisect_right(nums, target) return (right - left) > (n // 2)"},{"question":"You are given a binary tree in the form of a `TreeNode` object where each node contains an integer value. Your task is to return the **diameter** of the binary tree. The diameter of a binary tree is the length of the **longest path** between any two nodes in a tree. This path may or may not pass through the root. The length is defined as the number of edges on the path.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Returns the diameter of the binary tree. def height_and_diameter(node): if not node: return (0, 0) # (height, diameter) left_height, left_diameter = height_and_diameter(node.left) right_height, right_diameter = height_and_diameter(node.right) current_height = 1 + max(left_height, right_height) current_diameter = max(left_diameter, right_diameter, left_height + right_height) return (current_height, current_diameter) _, diameter = height_and_diameter(root) return diameter"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to find how many pairs of integers in the array have a **difference** equal to the `target`. A pair `(nums[i], nums[j])` is considered valid if `i != j` and `nums[i] - nums[j] == target`. Return _the number of valid pairs in the array_. The array may contain duplicate elements.","solution":"def count_pairs_with_difference(nums, target): This function returns the number of pairs (i, j) such that nums[i] - nums[j] == target and i != j. count = 0 nums_map = {} for num in nums: if num in nums_map: nums_map[num] += 1 else: nums_map[num] = 1 for num in nums: complement = num - target if complement in nums_map: count += nums_map[complement] if complement == num: # adjust for self-pairing cases count -= 1 return count"},{"question":"You are given an array of integers \'weights\' representing the weights of `n` items and a positive integer `capacity` representing the maximum weight the knapsack can carry. You need to pack the knapsack to achieve the maximum total weight without exceeding the capacity. Each item can be used only once. Return the **maximum weight** that can be achieved by packing the knapsack.","solution":"def knapsack(weights, capacity): Returns the maximum total weight that can be achieved without exceeding the knapsack\'s capacity. n = len(weights) # Create a DP table to store the maximum values at each capacity up to \'capacity\' dp = [0] * (capacity + 1) for weight in weights: for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + weight) return dp[capacity]"},{"question":"Given a binary string `s`, you can perform at most one flip operation to convert a `\'0\'` to a `\'1\'` or a `\'1\'` to a `\'0\'`. After performing at most one flip (or no flip at all), _return the length of the longest contiguous substring of all `1`s_ in the resulting string.","solution":"def longest_contiguous_ones(s): Returns the length of the longest contiguous substring of all 1s after performing at most one flip operation. n = len(s) max_count, zero_count, left = 0, 0, 0 for right in range(n): if s[right] == \'0\': zero_count += 1 while zero_count > 1: if s[left] == \'0\': zero_count -= 1 left += 1 max_count = max(max_count, right - left + 1) return max_count"},{"question":"You are given a string `s` which represents a sequence of characters. Write a function that finds the longest substring of `s` that contains at most `k` distinct characters and returns its length. The function should handle both lowercase and uppercase letters. Test your function on various inputs to ensure it performs efficiently and correctly identifies the length of the longest substring under the given constraint.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. if k == 0 or not s: return 0 left = 0 max_length = 0 char_count = {} for right in range(len(s)): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given a list of words `words` and an integer `k`, return the `k` most frequent words in the list. If two words have the same frequency, order them lexicographically.","solution":"from collections import Counter import heapq def top_k_frequent(words, k): Returns the k most frequent words in the given list. If two words have the same frequency, they are ordered lexicographically. # Counter to count frequency of words count = Counter(words) # Heap to get the k most frequent elements heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) # Get the top k elements result = [heapq.heappop(heap)[1] for _ in range(k)] return result"},{"question":"Given an array of integers `nums`, write a function to return the length of the longest consecutive elements sequence. Your algorithm should run in `O(n)` complexity. Example: ```plaintext Input: nums = [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. ```","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Check if it\'s the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a binary tree where each node contains an integer value. Design a class `BinaryTree` that can do the following: 1. Insert a new node into the binary tree with the given value. 2. Return the maximum depth of the binary tree. Implement the `BinaryTree` class: * `BinaryTree()` Initializes the `BinaryTree` object. * `void insert(int value)` Inserts a new node with the specified `value` into the binary tree. * `int maxDepth()` Returns the maximum depth of the binary tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, value): new_node = TreeNode(value) if self.root is None: self.root = new_node else: queue = [self.root] while queue: current = queue.pop(0) if not current.left: current.left = new_node break else: queue.append(current.left) if not current.right: current.right = new_node break else: queue.append(current.right) def maxDepth(self): def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self.root)"},{"question":"You are given a `m x n` grid filled with non-negative numbers representing the number of cookies in each cell. Write a function to find a path from the top-left corner to the bottom-right corner that collects the maximum number of cookies. You can only move either down or right at any point in time. Return the maximum number of cookies you can collect.","solution":"def max_cookies(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Write a function to find all the unique triplets in an array that gives the sum of zero. The function should return an array of arrays of triplets. Each triplet should appear only once in the output, and the order of the triplets in the result does not matter. Note: The solution set must not contain duplicate triplets.","solution":"def three_sum(nums): Find all unique triplets in the array which gives the sum of zero. :param nums: List[int] :return: List[List[int]] nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: sum_ = nums[i] + nums[left] + nums[right] if sum_ < 0: left += 1 elif sum_ > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return result"},{"question":"You are given a number `n` representing the nth Fibonacci number to be calculated using a recursive approach with memoization to optimize efficiency. The Fibonacci sequence starts from 0 and 1, where each subsequent number is the sum of the previous two. Specifically, `F(0) = 0`, `F(1) = 1`, and `F(n) = F(n-1) + F(n-2)` for `n > 1`. Implement a function `fibonacci(int n)` that returns _the nth Fibonacci number_. Use a dictionary or any other suitable data structure to store intermediary results and avoid redundant calculations.","solution":"def fibonacci(n, memo=None): Returns the nth Fibonacci number using a recursive approach with memoization. if memo is None: memo = {} if n in memo: return memo[n] if n == 0: return 0 elif n == 1: return 1 else: memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo) return memo[n]"},{"question":"You are given an m x n 2D grid of characters representing a map with the characters \'1\' representing land and \'0\' representing water. An island is a group of \'1\'s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Given the grid map, return _the number of islands_. An island is formed by connecting adjacent lands vertically or horizontally. You may assume all four edges of the grid are surrounded by water.","solution":"def num_islands(grid): Returns the number of islands in the given 2D grid where \'1\' represents land and \'0\' represents water. if not grid: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # mark as visited dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': count += 1 dfs(i, j) return count"},{"question":"Given a string `s`, find the length of the longest substring without repeating characters. Write an efficient algorithm that processes the input string and returns the length of the longest substring with all unique characters.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: input string :return: length of the longest substring with all unique characters char_index_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array `preferences` where `preferences[i]` is a list of integers representing the 1-based ranking of the `i-th` student for `n` colleges. Each college has exactly one slot available, and each student has to be assigned to exactly one college. Your task is to find a stable matching using the Deferred Acceptance algorithm (Gale-Shapley algorithm) where each student ends up in just one college that they prefer. Return a list where the `i-th` element is the college which the `i-th` student is assigned to. A stable matching is where there is no pair of students and colleges such that they both prefer each other over their currently assigned college or student.","solution":"def stable_matching(preferences): n = len(preferences) student_preference_lists = preferences college_preference_lists = [[] for _ in range(n)] for i in range(n): for j in range(n): college_preference_lists[j].append(i) free_students = list(range(n)) student_proposals = {i: 0 for i in range(n)} student_assignments = [-1] * n college_assignments = [-1] * n while free_students: student = free_students.pop(0) college = student_preference_lists[student][student_proposals[student]] student_proposals[student] += 1 if college_assignments[college] == -1: college_assignments[college] = student student_assignments[student] = college else: current_assigned_student = college_assignments[college] current_preference_index = college_preference_lists[college].index(current_assigned_student) new_preference_index = college_preference_lists[college].index(student) if new_preference_index < current_preference_index: college_assignments[college] = student student_assignments[student] = college free_students.append(current_assigned_student) student_assignments[current_assigned_student] = -1 else: free_students.append(student) return student_assignments"},{"question":"You are given a string `s` representing a mathematical expression containing numbers, addition and subtraction operations, and parentheses `(` and `)`. The expression is **well-formed**. Implement a function to evaluate the expression and return the result as an integer. For example, given the string `s = \\"1 + (2 - (3 + 4))\\"`, the function should return `-4` since that is the result of evaluating the expression.","solution":"def evaluate_expression(s): Evaluate a string mathematical expression containing numbers, +, -, and parentheses. Parameters: s (str): A well-formed mathematical expression Returns: int: The result of evaluating the expression def helper(index): stack = [] num = 0 sign = 1 while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) elif char in \'+-\': stack.append(sign * num) num = 0 sign = 1 if char == \'+\' else -1 elif char == \'(\': num, index = helper(index + 1) elif char == \')\': stack.append(sign * num) return sum(stack), index index += 1 stack.append(sign * num) return sum(stack), index result, _ = helper(0) return result"},{"question":"You are given a **0-indexed** integer array `stockPrices` of size `n`, where `stockPrices[i]` represents the price of a particular stock on day `i`. You are also given an integer `d`, which represents the maximum number of consecutive days you are allowed to hold the stock before you must sell it to avoid regulatory issues. Your task is to determine the **maximum profit** you can achieve if you are allowed to execute exactly **one** buy and exactly **one** sell transaction within the given constraints. The buy and sell transactions must be executed on different days, and you must ensure that the stock is sold before or exactly on the `d`th day from the buying day but not exceed `d` days. Return _the **maximum profit** you can achieve, or `0` if no profit can be made within the given constraints_.","solution":"def maxProfitWithinDays(stockPrices, d): n = len(stockPrices) if n < 2: return 0 max_profit = 0 for i in range(n): for j in range(i + 1, min(i + d + 1, n)): profit = stockPrices[j] - stockPrices[i] if profit > max_profit: max_profit = profit return max_profit"},{"question":"You are given an integer array `weights` where `weights[i]` is the weight of the `i-th` item. Your goal is to distribute all the items into two groups such that the absolute difference of the sum of the weights between the two groups is minimized. Return _the minimum possible absolute difference_.","solution":"def canPartition(weights): Determines if the weights can be partitioned in two subsets with minimum absolute difference. total_sum = sum(weights) n = len(weights) target = total_sum // 2 # dp[i][j] will be True if we can have sum j using the first i items. dp = [[False] * (target + 1) for _ in range(n + 1)] # A sum of 0 is always possible with any set of weights. for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if weights[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weights[i - 1]] else: dp[i][j] = dp[i - 1][j] # The largest j such that dp[n][j] is true for j in range(target, -1, -1): if dp[n][j]: return total_sum - 2 * j"},{"question":"You are given a string `s` and an integer `k`. The string consists of lowercase English letters and cannot contain any spaces. A substring is defined as a contiguous sequence of characters within the string. You need to find the length of the longest substring of `s` that can be rearranged to form at most `k` distinct characters. Return _an integer_ representing the length of such a substring.","solution":"def length_of_longest_substring_k_distinct(s, k): Find the length of the longest substring that can be rearranged to form at most k distinct characters. if k == 0: return 0 n = len(s) if n == 0: return 0 left, right = 0, 0 char_count = {} max_len = 0 while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given two strings `s1` and `s2`, each containing only lowercase characters. You need to check if you can make `s2` by rearranging the characters of `s1` and adding exactly one extra character, which can be any lowercase letter. Return `true` if it\'s possible, and `false` otherwise. Note that the extra character must be added to `s1`.","solution":"def can_form_by_adding_one_char(s1, s2): Given two strings s1 and s2, check if you can make s2 by rearranging the characters of s1 and adding exactly one extra character. from collections import Counter # Count the characters in both strings count_s1 = Counter(s1) count_s2 = Counter(s2) # Check if s2 has exactly one more character than s1 if len(s1) + 1 != len(s2): return False # Calculate the difference in counts diff = 0 for char in count_s2: if count_s2[char] > count_s1.get(char, 0): diff += count_s2[char] - count_s1.get(char, 0) # If the sum of the differences is exactly one, return True return diff == 1"},{"question":"You are given a **0-indexed** integer array `arr` which is sorted in **non-decreasing** order and contains `n` unique integers. Your task is to find the **minimum absolute difference** between any two elements of the array and return _all pairs of elements that have this minimum absolute difference_. Return the pairs in any order.","solution":"def minimum_abs_difference(arr): Returns all pairs of elements from a sorted array that have the minimum absolute difference. Parameters: arr (list of int): A sorted list of unique integers in non-decreasing order. Returns: list of list of int: List of pairs with the minimum absolute difference. min_diff = float(\'inf\') result = [] # Iterate through the array to find the minimum absolute difference for i in range(len(arr) - 1): diff = arr[i+1] - arr[i] if diff < min_diff: min_diff = diff result = [[arr[i], arr[i+1]]] elif diff == min_diff: result.append([arr[i], arr[i+1]]) return result"},{"question":"You are given a string `s` consisting of lowercase alphabets. A substring of `s` is called a **good substrings** if all the characters of the substring are distinct. Calculate _the number of good substrings of length `n`_ in the given string `s`. If no such substring exists, return `0`. Test cases are generated so that the answer fits in a **32-bit** integer.","solution":"def count_good_substrings(s, n): Returns the number of good substrings of length n in the string s. A good substring has all distinct characters. if n > len(s): return 0 count = 0 for i in range(len(s) - n + 1): substring = s[i:i + n] if len(set(substring)) == n: count += 1 return count"},{"question":"You are given an integer array `nums` and an integer `target`. The task is to find a continuous subarray whose sum equals the target and return the subarray. If there are multiple such subarrays, return the one with the smallest starting index. If there are still multiple, return the one with the smallest ending index. If no such subarray exists, return an empty array. Note that the subarray must contain at least one element.","solution":"def find_subarray_with_sum(nums, target): Given an integer array `nums` and an integer `target`, find a continuous subarray whose sum equals the target. Returns the subarray. :param nums: List[int], the list of integers :param target: int, the target sum :return: List[int], the subarray that sums to the target, or empty array if no such subarray exists sum_to_index = {0: -1} # Maps cumulative sum to index cumulative_sum = 0 for i, num in enumerate(nums): cumulative_sum += num if cumulative_sum - target in sum_to_index: start_index = sum_to_index[cumulative_sum - target] + 1 return nums[start_index:i+1] sum_to_index[cumulative_sum] = i return []"},{"question":"Given a non-empty array of integers `arr`, a **peak element** is an element that is strictly greater than its neighbors. If an element is at the ends of the array, it is considered to have only one neighbor. Return _the index of any peak element_. The array may contain multiple peaks, in which case return the index to any one of the peaks. You may assume the array does not contain duplicates.","solution":"def find_peak_element(arr): Finds the index of any peak element in the given array. A peak element is an element that is strictly greater than its neighbors. For elements at the ends of the array, they are considered to have only one neighbor. :param arr: List[int] - The input array of integers :return: int - The index of any peak element # If the array has only one element, it\'s the peak by default if len(arr) == 1: return 0 left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"Given an array of integers, return the length of the longest contiguous subarray that has an equal number of 1\'s and -1\'s. If there are no such subarrays, return 0. The input array only contains 1\'s and -1\'s.","solution":"def find_max_length(nums): Finds the length of the longest contiguous subarray with an equal number of 1\'s and -1\'s. :param nums: List[int] :return: int count = 0 max_length = 0 count_map = {0: -1} for i, num in enumerate(nums): if num == 1: count += 1 else: count -= 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"You are given a **0-indexed** 2D integer array `points` where `points[i] = [xi, yi]` represents the coordinates of the ith point. Design an algorithm to find the smallest rectangle that can be formed from any four of these points. Each rectangle sides must be parallel to the `x` and `y` axes. Return _the **minimum area** of such a rectangle or `-1` if no rectangle can be formed_ using the given points_.","solution":"def min_area_rect(points): This function takes a 2D list of integer points and returns the minimum area of a rectangle that can be formed from the given points with sides parallel to x and y axes. Points are represented as [xi, yi]. point_set = set(map(tuple, points)) min_area = float(\'inf\') for i, (x1, y1) in enumerate(points): for j in range(i + 1, len(points)): x2, y2 = points[j] if x1 != x2 and y1 != y2 and (x1, y2) in point_set and (x2, y1) in point_set: min_area = min(min_area, abs((x2 - x1) * (y2 - y1))) return min_area if min_area != float(\'inf\') else -1"},{"question":"You are given an integer array `arr` and an integer `target`. Implement a function to determine if two numbers from the array add up to the `target`. Assume that each input would have exactly one solution, and you may not use the same element twice. Return the indices of the two numbers in the form of a tuple `(index1, index2)`, such that `index1 < index2`. For example, given `arr = [2, 7, 11, 15]` and `target = 9`, since `arr[0] + arr[1] = 2 + 7 = 9`, the function should return `(0, 1)`.","solution":"def two_sum(arr, target): Determine if two numbers from the array add up to the target. Return the indices of the two numbers in the form of a tuple (index1, index2). seen = {} for i, num in enumerate(arr): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None # There should always be a solution, so this should not be reached."},{"question":"You are given two strings `s` and `t` consisting of lowercase English letters. A substring of `s` is called a **copy** substring if it can be rearranged to form `t` or any anagram of `t`. Return the total number of **copy** substrings in `s`. Each substring should be counted as many times as it appears in `s`. **Note** that: * A **substring** is a contiguous sequence of characters within a string. * An **anagram** of a string is another string that contains the same characters, only the order of characters can be different. For example, the strings `\\"abc\\"` and `\\"cba\\"` are anagrams of each other.","solution":"from collections import Counter def count_copy_substrings(s, t): Returns the total number of substrings in `s` that are anagrams of `t`. len_s, len_t = len(s), len(t) if len_s < len_t: return 0 t_counter = Counter(t) current_counter = Counter(s[:len_t]) total_copies = 0 if current_counter == t_counter: total_copies += 1 for i in range(len_t, len_s): current_counter[s[i]] += 1 current_counter[s[i-len_t]] -= 1 if current_counter[s[i-len_t]] == 0: del current_counter[s[i-len_t]] if current_counter == t_counter: total_copies += 1 return total_copies"},{"question":"You are given a string `s` containing only the characters `\'a\'` and `\'b\'`. You wish to rearrange the characters in the string such that every `\'a\'` is not next to another `\'a\'`. If it is possible to rearrange the string in such a way, return any possible rearrangement. If it is not possible, return an empty string.","solution":"def rearrange_string(s): Rearranges the given string such that no two \'a\' characters are adjacent to each other. Returns the rearranged string or an empty string if it\'s not possible. a_count = s.count(\'a\') b_count = s.count(\'b\') if a_count > (b_count + 1): return \\"\\" result = [] i = 0 while a_count > 0 and b_count > 0: if len(result) == 0 or result[-1] != \'a\': result.append(\'a\') a_count -= 1 else: result.append(\'b\') b_count -= 1 result.extend([\'a\'] * a_count) result.extend([\'b\'] * b_count) return \'\'.join(result)"},{"question":"You are given a list of strings `words` and a string `s`. Find and return _all the strings in_ `words` _that are subsequences of_ `s`. A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.","solution":"def is_subsequence(s, subseq): it = iter(s) return all(c in it for c in subseq) def find_subsequences(words, s): Finds and returns all the strings in `words` that are subsequences of `s`. return [word for word in words if is_subsequence(s, word)]"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is defined as a contiguous sequence of characters in the string. Return _the number of distinct substrings of `s`_. Your function should run with a time complexity better than O(n^2), where `n` is the length of the string.","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of `s`. Implemented using a rolling hash and a set to achieve linearithmic time complexity. n = len(s) base = 26 mod = 2**61 - 1 power = [1] * (n + 1) for i in range(1, n + 1): power[i] = (power[i - 1] * base) % mod hashes = set() for length in range(1, n + 1): curr_hash = 0 for i in range(length): curr_hash = (curr_hash * base + (ord(s[i]) - ord(\'a\') + 1)) % mod hashes.add(curr_hash) for i in range(1, n - length + 1): curr_hash = (curr_hash - (ord(s[i - 1]) - ord(\'a\') + 1) * power[length - 1]) % mod curr_hash = (curr_hash * base + (ord(s[i + length - 1]) - ord(\'a\') + 1)) % mod curr_hash = (curr_hash + mod) % mod # ensuring non-negative hash value hashes.add(curr_hash) return len(hashes)"},{"question":"Write a function that takes a list of integers as input and returns the sum of all the unique elements in the list. An element is considered unique if it appears exactly once in the list.","solution":"def sum_of_unique_elements(lst): Returns the sum of all unique elements in the list. An element is considered unique if it appears exactly once in the list. from collections import Counter element_counts = Counter(lst) return sum(element for element, count in element_counts.items() if count == 1)"},{"question":"You are given an array of integers `nums` and an integer `k`. You can choose an integer from the array and remove it if it is divisible by `k`. Your task is to find the maximum number of integers you can remove from the array following this rule. The removal should be done in such a way that for every integer removed, the integers remaining still maintain a non-increasing order. Return the maximum number of integers you can remove from the array.","solution":"def max_removals(nums, k): Finds the maximum number of integers that can be removed from the array `nums` such that each element removed is divisible by `k`. Additionally, the array should maintain a non-increasing order after the removals. :param nums: List of integers :param k: Integer by which divisibility is checked :return: Maximum number of integers that can be removed nums.sort(reverse=True) removals = 0 for num in nums: if num % k == 0: removals += 1 return removals"},{"question":"Given a `words` array of strings, where a word can be transformed into a target word if it can be obtained by changing exactly one character, determine the shortest transformation sequence from a start word to an end word. You need to return the length of the sequence if such a transformation sequence exists, otherwise, return 0. For example: Given: - `start = \\"hit\\"` - `end = \\"cog\\"` - `words = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]` Return: _The length of the shortest transformation sequence._ **Note:** - Each intermediate word in the transformation sequence must exist in the words list. - All intermediate words must be valid transformations (by changing exactly one character).","solution":"from collections import deque def is_one_letter_diff(word1, word2): Check if word1 can be transformed to word2 by changing exactly one character. diff_count = sum(1 for a, b in zip(word1, word2) if a != b) return diff_count == 1 def shortest_transformation_sequence(start, end, words): Returns the length of the shortest transformation sequence from start to end word by changing exactly one character each step. If no such sequence exists, return 0. if end not in words: return 0 queue = deque([(start, 1)]) # (current_word, current_length) visited = set(start) while queue: current_word, current_length = queue.popleft() for word in list(words): if is_one_letter_diff(current_word, word): if word == end: return current_length + 1 if word not in visited: visited.add(word) queue.append((word, current_length + 1)) return 0"},{"question":"You are given a string `s` which represents a sequence of characters and a non-negative integer `k`. The task is to reverse the order of the first `k` characters for every `2k` characters counting from the start of the string. - If there are fewer than `k` characters left, reverse all of them. - If there are between `k` and `2k` characters, reverse the first `k` characters and leave the rest as is. Return the modified string after performing the given operations. For example, given `s = \\"abcdefg\\"` and `k = 2`, the function should return `\\"bacdfeg\\"`.","solution":"def reverseStr(s, k): Reverses the order of the first k characters for every 2k characters counting from the start of the string. result = [] for i in range(0, len(s), 2 * k): result.append(s[i:i+k][::-1] + s[i+k:i+2*k]) return \'\'.join(result)"},{"question":"You are given an integer array `heights` representing the heights of students in a class. Two students are considered a \\"team\\" if their heights differ by at most `d`, where `d` is a given integer. A student can be part of only one team. Your task is to form the maximum number of teams from the given `heights` array. Return _an integer_ `max_teams` _representing the maximum number of teams that can be formed_.","solution":"def max_teams(heights, d): Returns the maximum number of teams that can be formed from the given list of heights where the height difference between students in a team does not exceed d. heights.sort() max_teams = 0 i = 0 while i < len(heights) - 1: if heights[i + 1] - heights[i] <= d: max_teams += 1 i += 2 # Both students are used in a team else: i += 1 # Move to the next student return max_teams"},{"question":"You are given a string `s` and an integer `k`. You need to perform the following operation exactly `k` times: Choose any `1`-index position `i` in the string, and remove the character at that position. Your goal is to minimize the resulting string lexicographically after performing the given operation exactly `k` times. Return the lexicographically smallest string you can get after removing `k` characters from the original string `s`.","solution":"def remove_characters_minimize_lexicographically(s, k): Remove k characters from string s to get the lexicographically smallest string. :param s: Original string :param k: Number of characters to remove :return: Lexicographically smallest string after removing k characters stack = [] for char in s: while k and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If we still have k characters to remove after going through the string, # we simply remove from the end of the result stack. return \'\'.join(stack[:-k] if k else stack)"},{"question":"You are given a sorted integer array `arr` of length `n` and an integer `x`. You need to find the pair of elements in `arr` whose sum is closest to `x`. If there are multiple pairs with the same sum, return the pair with the smallest first element. If multiple pairs have the same first element, return the pair with the smallest second element. Return the pair as an array of two elements.","solution":"def closest_pair(arr, x): Finds the pair of elements in the sorted array `arr` whose sum is closest to `x`. n = len(arr) left, right = 0, n - 1 closest_sum = float(\'inf\') closest_pair = [] while left < right: current_sum = arr[left] + arr[right] if abs(current_sum - x) < abs(closest_sum - x) or ( abs(current_sum - x) == abs(closest_sum - x) and (closest_pair == [] or arr[left] < closest_pair[0] or (arr[left] == closest_pair[0] and arr[right] < closest_pair[1])) ): closest_sum = current_sum closest_pair = [arr[left], arr[right]] if current_sum < x: left += 1 else: right -= 1 return closest_pair"},{"question":"You are given an array of integers `nums`. A new array is formed by adding each element of the array to its corresponding index in the array (i.e., the element at index `i` becomes `nums[i] + i`). Your task is to return the maximum value from the newly formed array. Implement the function `int maxIndexedArray(int[] nums)` that accepts an array of integers `nums` and returns the maximum value from the array formed by adding each element to its index.","solution":"def max_indexed_array(nums): Returns the maximum value from the array formed by adding each element to its index. :param nums: List of integers :return: Maximum value from the transformed array max_value = float(\'-inf\') for i in range(len(nums)): max_value = max(max_value, nums[i] + i) return max_value"},{"question":"Design a function that takes an integer array `nums`, rearranges them into a new array `answer` such that: - `answer[0] <= answer[1] >= answer[2] <= answer[3] >= answer[4]` and so on. Return _the array_ `answer`. For example, given `nums = [3, 5, 2, 1, 6, 4]`, a valid answer would be `[3, 5, 1, 6, 2, 4]`.","solution":"def rearrange(nums): Rearranges an integer array into a zigzag pattern such that: nums[0] <= nums[1] >= nums[2] <= nums[3] >= nums[4] ... nums.sort() for i in range(1, len(nums) - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"question":"You are given an integer array `arr` of length `n`. Your task is to perform a series of operations to make all the elements in the array equal. In one operation, you can select an index `i` (1 ≤ `i` < `n`) and increment or decrement `arr[i]` by 1. You cannot perform any operation on the first element `arr[0]`. Return _the minimum number of operations needed to make all the elements in the array equal to `arr[0]`_.","solution":"def min_operations_to_equalize(arr): Returns the minimum number of operations needed to make all elements in arr equal to arr[0]. Each operation consists of incrementing or decrementing any element (except arr[0]) by 1. Parameters: arr (list of int): The input array of integers Returns: int: The minimum number of operations target = arr[0] operations = 0 for i in range(1, len(arr)): operations += abs(arr[i] - target) return operations"},{"question":"Given an array of integers `arr` and an integer `k`, return the number of distinct pairs `(i, j)` where `arr[i] + arr[j] == k` and `i != j`. Each pair should be counted only once, regardless of the order of the numbers in the pair. For example, if the input array is `[1, 1, 2, 2, 3, 3]` and `k` is `4`, the function should return `2` since there are two distinct pairs that sum to `4`, which are `(1, 3)` and `(2, 2)`.","solution":"def count_pairs_with_sum(arr, k): Returns the number of distinct pairs (i, j) where arr[i] + arr[j] == k and i != j. Each pair should be counted only once, regardless of the order of the numbers in the pair. seen = set() complements = set() count = 0 for num in arr: complement = k - num if complement in complements: pair = tuple(sorted((num, complement))) if pair not in seen: seen.add(pair) count += 1 complements.add(num) return count"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` where all values are unique. A binary tree `T` is generated in the following way: 1. Use `nums[0]` as the root node. 2. Repeat the following steps for each `element` in `nums` following the order of the array: - Insert `element` as a child of the deepest node following the left-to-right rule if it doesn\'t already exist in the tree. - If necessary, switch to the next deepest node until `element` is placed. Return _the in-order traversal of the binary tree `T`._","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_node(root, value): from collections import deque queue = deque([root]) while queue: node = queue.popleft() if node.left is None: node.left = TreeNode(value) break else: queue.append(node.left) if node.right is None: node.right = TreeNode(value) break else: queue.append(node.right) def build_tree(nums): if not nums: return None root = TreeNode(nums[0]) for num in nums[1:]: insert_node(root, num) return root def in_order_traversal(root, result = None): if result is None: result = [] if root is not None: in_order_traversal(root.left, result) result.append(root.value) in_order_traversal(root.right, result) return result def inorder_traversal(nums): Generates the binary tree T from the nums array and returns its in-order traversal. Args: nums (List[int]): List of unique integers. Returns: List[int]: In-order traversal of the binary tree. root = build_tree(nums) return in_order_traversal(root)"},{"question":"You are given a string `s` that consists of only digits and a list of strings `dictionary` that contains a collection of non-empty words. Find the word from the dictionary such that after deleting some digits from the string `s`, it forms the chosen word. You need to find the longest such word. If there is more than one possible word with the same length, choose the one that comes first in lexicographical order. Return the longest word from the dictionary that can be formed, or an empty string if no valid word can be formed.","solution":"def find_longest_word(s, dictionary): def is_subsequence(word): it = iter(s) return all(c in it for c in word) longest_word = \\"\\" for word in dictionary: if is_subsequence(word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"Given a binary matrix `grid` of size `m x n` where each cell contains either `0` (representing water) or `1` (representing land), and you need to find the length of the shortest path from the top-left cell (0,0) to the bottom-right cell (m-1,n-1) such that you only traverse cells containing `1` and you can move only in the four cardinal directions (up, down, left, right). If no such path exists, return `-1`. Implement the function `int shortestPath(int[][] grid)`, which takes a 2D array `grid` as input and returns the length of the shortest path as an integer, or `-1` if no such path exists.","solution":"from collections import deque def shortestPath(grid): Returns the length of the shortest path from the top-left cell to the bottom-right cell that contains only 1s. If no such path exists, return -1. if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, path_length) visited = set([(0, 0)]) while queue: row, col, path_length = queue.popleft() if row == rows - 1 and col == cols - 1: return path_length for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, path_length + 1)) return -1"},{"question":"You are given a list of flights represented as pairs of cities `[from, to]` and a `source` city. A flight from `A` to `B` means you can travel from city `A` to city `B` in one flight. You need to determine the smallest number of flights required to travel from the `source` city to all other cities that can be reached, and return a list where the `i-th` index represents the minimum flights needed to reach city `i` from the `source` city. If a city cannot be reached, the value should be `-1`. Assume the cities are represented as integers from `0` to `n-1` where `n` is the number of cities.","solution":"from collections import deque, defaultdict def find_min_flights(flights, n, source): Function to determine the smallest number of flights required to reach each city from the source city. :param flights: List[List[int]] - list of flights represented as pairs of cities [from, to] :param n: int - number of cities :param source: int - the source city :return: List[int] - a list where the i-th index represents the minimum flights needed to reach city i from the source city # Create the graph graph = defaultdict(list) for frm, to in flights: graph[frm].append(to) # Initialize distances with -1 min_flights = [-1] * n min_flights[source] = 0 # BFS to find shortest path queue = deque([source]) while queue: city = queue.popleft() for neighbour in graph[city]: if min_flights[neighbour] == -1: # if the city hasn\'t been visited yet min_flights[neighbour] = min_flights[city] + 1 queue.append(neighbour) return min_flights"},{"question":"Given a binary tree, determine the largest value in each row and return them as a list in the order of their corresponding rows. The tree is represented using the same structure, where each node contains an integer value, a left child, and a right child. Implement a function that takes the root of the binary tree and returns a list of integers, each reflecting the largest value in each row of the tree. For example, given the binary tree: ``` 1 / 3 2 / 5 3 9 ``` The function should return the list `[1, 3, 9]`, since 1 is the largest value in the first row, 3 is the largest value in the second row, and 9 is the largest value in the third row.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_each_row(root): Function to find the largest value in each row of a binary tree. Parameters: root (TreeNode): The root of the binary tree. Returns: List[int]: A list of the largest values in each row of the tree. if not root: return [] results = [] queue = deque([root]) while queue: level_size = len(queue) level_max = float(\'-inf\') for _ in range(level_size): node = queue.popleft() level_max = max(level_max, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) results.append(level_max) return results"},{"question":"Given a **0-indexed** integer array `arr` of length `n` and an integer `x`, you are allowed to choose any subarray of `arr` and replace each element in the subarray with the minimal value of that subarray. After performing this operation, return the maximum length of a strictly increasing subarray in the modified array. For example, if `arr = [3, 4, 2, 1, 5]` and `x = 2`, after performing the optimal operation by choosing the subarray `[2, 1]`, the new array becomes `[3, 4, 1, 1, 5],` and the longest strictly increasing subarray is `[3, 4]` of length 2.","solution":"def max_strictly_increasing_subarray_length(arr, x): Finds the maximum length of strictly increasing subarray after replacing each element in one chosen subarray with the minimal value of that subarray. :param arr: List of integers, the array. :param x: integer, not used in this solution. :return: integer, the maximum length of strictly increasing subarray. n = len(arr) # Initialize the lengths of the current subarray and the maximum length found current_length = 1 max_length = 1 for i in range(1, n): if arr[i] > arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"Implement a class `Library` which can perform the following operations: * **Add a book** to the library system with a title and a genre. * **Remove a book** from the library system by its title. * **Find the most popular book** for a specific genre based on borrow frequency. The `Library` class should have the following methods: * `Library()` Initializes the library system. * `void addBook(String title, String genre)` Adds a book with the given `title` and `genre` to the system. * `void removeBook(String title)` Removes the book with the given `title` from the system. * `void borrowBook(String title)` Increases the borrow count of the book with the given `title`. * `String mostPopularBook(String genre)` Returns the title of the book with the highest borrow count for the given `genre`. If there is a tie, return the book with the **lexicographically smallest** title.","solution":"class Library: def __init__(self): self.books = {} self.borrow_count = {} def addBook(self, title, genre): if title not in self.books: self.books[title] = genre self.borrow_count[title] = 0 def removeBook(self, title): if title in self.books: del self.books[title] del self.borrow_count[title] def borrowBook(self, title): if title in self.books: self.borrow_count[title] += 1 def mostPopularBook(self, genre): max_count = -1 popular_book = None for title, book_genre in self.books.items(): if book_genre == genre: if self.borrow_count[title] > max_count or (self.borrow_count[title] == max_count and title < popular_book): max_count = self.borrow_count[title] popular_book = title return popular_book"},{"question":"You are given a list of integers, `nums`, and an integer `k`. Your task is to implement a function that finds the maximum sum of a subarray of size `k` from the list `nums`. A subarray is a contiguous part of an array. Implement a function with the following signature: ```python def maxSubarraySum(nums: List[int], k: int) -> int: ``` Your function should return the maximum sum of any subarray of size `k`. For example, given the list `nums = [2, 1, 5, 1, 3, 2]` and `k = 3`, the function should return `9`, since `[5, 1, 3]` is the subarray of size `k` with the maximum sum of `9`.","solution":"def maxSubarraySum(nums, k): Returns the maximum sum of any subarray of size k. Parameters: nums (List[int]): List of integers k (int): Size of subarray Returns: int: Maximum sum of subarray of size k if not nums or k <= 0 or k > len(nums): return 0 # Compute the sum of the first window max_sum = sum(nums[:k]) current_sum = max_sum # Slide the window across the list while updating sums for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a `m x n` binary matrix `matrix` where each element is either `0` or `1`. You need to find the largest square containing only `1`s and return its area. The square can be formed by selecting any subset of rows and columns such that all the elements within the defined square boundary are `1`. If there\'s no such square, return `0`. For example, in the matrix `[[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]`, the largest square containing only `1`s has an area of `4` since the biggest square is of size `2x2`. Return the area of the largest square.","solution":"def maximal_square(matrix): if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_square_length = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i - 1][j - 1] == 1: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_square_length = max(max_square_length, dp[i][j]) return max_square_length ** 2"},{"question":"You are given an integer array `nums` representing the number of balloons in different piles. Each balloon takes 1 second to burst. You can choose any pile and burst all the balloons in that pile in one go (one consecutive second). However, once you burst all the balloons in a pile, you cannot do any operation in the same pile in the future. Write a function to determine the minimum number of seconds required to burst all the balloons. Implement the `Solution` class: * `Solution(int[] nums)` Initializes the object with the number of balloons in each pile. * `int minBursts()` Returns the minimum number of seconds required to burst all the balloons.","solution":"class Solution: def __init__(self, nums): Initializes the object with the number of balloons in each pile. :param nums: List[int] - list of the number of balloons in each pile self.nums = nums def minBursts(self): Returns the minimum number of seconds required to burst all the balloons. :return: int - minimum number of seconds required to burst all balloons # Each pile can be burst in 1 second return len(self.nums)"},{"question":"Given a list of integers `nums`, your task is to find the length of the longest consecutive elements sequence. The consecutive sequence must be composed of elements that appear consecutively in the list, but the actual order in the list doesn\'t matter. Return the length of this longest sequence. A consecutive sequence is a subset of integers where each element is exactly one unit larger than the previous element in the sequence. For example, the sequence [100, 4, 200, 1, 3, 2] has a longest consecutive sequence [1, 2, 3, 4]. Example: Input: nums = [100, 4, 200, 1, 3, 2] Output: 4 (because the longest consecutive sequence is [1, 2, 3, 4]) Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 (because the longest consecutive sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8]) Input: nums = [] Output: 0 Input: nums = [1,2,0,1] Output: 3 (because the longest consecutive sequence is [0, 1, 2])","solution":"def longest_consecutive(nums): Finds the length of the longest consecutive elements sequence. Args: nums: List of integers. Returns: Length of the longest consecutive elements sequence. num_set = set(nums) longest_sequence = 0 for num in num_set: if num - 1 not in num_set: # only check starting points current_num = num current_sequence = 1 while current_num + 1 in num_set: current_num += 1 current_sequence += 1 longest_sequence = max(longest_sequence, current_sequence) return longest_sequence"},{"question":"You are given a string `s` which consists of only lowercase alphabetical characters. Your task is to analyze the string and return the length of the longest substring that contains at most `k` distinct characters where `k` is a given integer. If there are multiple substrings with the same length, return the length of the earliest such substring found. For example, given `s = \\"eceba\\"` and `k = 2`, the longest substring with at most 2 distinct characters is `\\"ece\\"`, which has a length of 3.","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. Parameters: s (str): Input string consisting of lowercase alphabetical characters. k (int): Maximum number of distinct characters allowed in the substring. Returns: int: The length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 n = len(s) left = 0 right = 0 max_len = 0 char_map = {} while right < n: char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"Given a `m x n` board of characters and a list of strings `words`, find all the words on the board that are constructed from sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word on the board. Return the list of words found in the board. Example: ``` Input: board = [[\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\']], words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] Output: [\\"oath\\",\\"eat\\"] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def findWords(board, words): def dfs(node, i, j, path, res): if node.end_of_word: res.add(path) node.end_of_word = False # to avoid duplicate entries if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return if board[i][j] not in node.children: return char = board[i][j] board[i][j] = \\"#\\" # mark the cell as visited next_node = node.children[char] dfs(next_node, i+1, j, path+char, res) dfs(next_node, i-1, j, path+char, res) dfs(next_node, i, j+1, path+char, res) dfs(next_node, i, j-1, path+char, res) board[i][j] = char # unmark the cell trie = Trie() for word in words: trie.insert(word) res = set() for i in range(len(board)): for j in range(len(board[0])): dfs(trie.root, i, j, \\"\\", res) return list(res)"},{"question":"Given a string `s`, you need to decode it in the following way: - Start with an empty string `result`. - Iterate through each character in `s`. - If the character is a lowercase letter (a to z), append it to `result`. - If the character is an opening bracket `[`, find the corresponding closing bracket `]` that pairs with this opening bracket. Assume all brackets in `s` are properly paired. - Within the brackets, there is a substring that specifies a numerical value (k) followed by a lowercase letter sequence to be repeated `k` times. Decode this sequence and append it to `result`. For example, if the input string is `3[a2[bc]]`, the decoded string is `abcbcabcbcabcbc`. Return the fully decoded string.","solution":"def decode_string(s: str) -> str: def decode_segment(segment: str) -> str: stack = [] current_num = 0 current_str = \\"\\" for char in segment: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_num = 0 current_str = \\"\\" elif char == \']\': prev_str, num = stack.pop() current_str = prev_str + current_str * num else: current_str += char return current_str return decode_segment(s)"},{"question":"You are working on a text editor that allows users to type in a document. The document is represented as a string `s`. Besides the normal insertions and deletions, you want to implement a special format operation that can invert the case of all the letters in a given range of the document. You need to support the following operations: - **Insert:** Inserts a given character or substring at a specified position in the document. - **Delete:** Deletes a specified number of characters starting from a given position in the document. - **InvertCase:** Inverts the case (i.e., switches lowercase letters to uppercase and uppercase letters to lowercase) of all the characters in a specified range (from index `start` to index `end` inclusive) in the document. Implement the `TextEditor` class: - `TextEditor(String s)`: Initializes the text editor with the initial string `s`. - `insert(int pos, String input)`: Inserts the characters in `input` at position `pos`. - `delete(int pos, int length)`: Deletes `length` number of characters starting from position `pos`. - `invertCase(int start, int end)`: Inverts the case of all characters in the range from `start` to `end` inclusive. - `getText()`: Returns the current state of the document as a string.","solution":"class TextEditor: def __init__(self, s: str): self.s = s def insert(self, pos: int, input: str): self.s = self.s[:pos] + input + self.s[pos:] def delete(self, pos: int, length: int): self.s = self.s[:pos] + self.s[pos + length:] def invertCase(self, start: int, end: int): inverted_segment = [ c.upper() if c.islower() else c.lower() for c in self.s[start:end + 1] ] self.s = self.s[:start] + \'\'.join(inverted_segment) + self.s[end + 1:] def getText(self) -> str: return self.s"},{"question":"A university library needs to manage book lending efficiently. Implement a `LibrarySystem` class with the following functionalities: - `LibrarySystem(int n)` initializes the library with `n` available books (numbered from 1 to `n`). - `boolean borrowBook(int bookId)` attempts to borrow the book with the given `bookId`. Returns `true` if the book was successfully borrowed (i.e., it was not already borrowed by someone else), and `false` otherwise. - `void returnBook(int bookId)` returns the book with the given `bookId` to the library, making it available for borrowing again. - `boolean isBorrowed(int bookId)` checks if the book with the given `bookId` is currently borrowed. Returns `true` if the book is borrowed, and `false` if it is available. The system should maintain adequate records to handle these operations efficiently.","solution":"class LibrarySystem: def __init__(self, n): Initializes the library with `n` available books (numbered from 1 to `n`). self.books = [False] * (n + 1) # index 0 is unused def borrowBook(self, bookId): Attempts to borrow the book with the given `bookId`. Returns `True` if the book was successfully borrowed, and `False` if it was already borrowed. if self.books[bookId]: return False self.books[bookId] = True return True def returnBook(self, bookId): Returns the book with the given `bookId` to the library. self.books[bookId] = False def isBorrowed(self, bookId): Checks if the book with the given `bookId` is currently borrowed. Returns `True` if the book is borrowed, and `False` if it is available. return self.books[bookId]"},{"question":"Given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. **Do not** allocate another 2D matrix and do the rotation. Write a function `rotate(image: List[List[int]]) -> None:` that takes an `n x n` matrix `image` as input and modifies it. For example: ``` Input: [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] Input: [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] Output: [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ```","solution":"from typing import List def rotate(image: List[List[int]]) -> None: Rotates the matrix (image) by 90 degrees clockwise. Modifies the input matrix in-place. n = len(image) # Transpose the matrix for i in range(n): for j in range(i, n): image[i][j], image[j][i] = image[j][i], image[i][j] # Reverse each row for i in range(n): image[i].reverse()"},{"question":"You are given a string `word` and an integer `k`. A k-gram is defined as a substring of `word` that is exactly `k` characters long. Your task is to find the most frequent k-gram in `word`. If there are multiple k-grams with the same highest frequency, return the lexicographically smallest one. If `word` is shorter than or equal to `k`, return `word`. In other words, find the k-gram that appears the most frequently in the given string. If no k-gram exists, consider the entire string as the answer.","solution":"def most_frequent_kgram(word, k): Returns the most frequent k-gram in the given word. If there are multiple with the same frequency, returns the lexicographically smallest one. If `word` is shorter than or equal to `k`, returns `word`. if len(word) <= k: return word kgram_freq = {} # Create a frequency dictionary for all k-grams for i in range(len(word) - k + 1): kgram = word[i:i+k] if kgram in kgram_freq: kgram_freq[kgram] += 1 else: kgram_freq[kgram] = 1 # Find the most frequent k-gram, breaking ties lexicographically most_frequent_kgram = min(sorted(kgram_freq), key=lambda x: (-kgram_freq[x], x)) return most_frequent_kgram"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to determine if there exists a subset of `arr` whose sum is equal to `k`. If such a subset exists, return `True`; otherwise, return `False`. The elements in the subset must be distinct and can be selected in any order. For example, given the array `arr = [1, 2, 3, 4, 5]` and `k = 9`, a possible subset that adds up to `9` is `[4, 5]`. Hence, the function should return `True`. If `k` were `20`, there is no such subset, and the function should return `False`.","solution":"def subset_sum_to_k(arr, k): Determines if there exists a subset of the array \'arr\' whose sum is equal to \'k\'. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: bool: True if a subset with sum \'k\' exists, False otherwise. n = len(arr) # dp[i][j] will be True if there is a subset of the first i items with a sum equal to j. dp = [[False] * (k + 1) for _ in range(n + 1)] # A sum of 0 can always be achieved with an empty subset for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, k + 1): if j < arr[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]] return dp[n][k]"},{"question":"Given a list of non-negative integers `arr` and an integer `m`, partition the list into `m` non-empty contiguous subarrays such that the difference between the largest sum of any subarray and the smallest sum of any subarray is minimized. Return the minimum difference.","solution":"def can_partition(arr, m, max_sum): Helper function to check if the array can be partitioned into m subarrays with the given max_sum or not. current_sum = 0 count = 1 # Starting with one subarray for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True def minimize_max_subarray_sum_difference(arr, m): Function to partition the array into m subarrays such that the difference between the largest sum of any subarray and the smallest sum of any subarray is minimized. left = max(arr) right = sum(arr) while left < right: mid = (left + right) // 2 if can_partition(arr, m, mid): right = mid else: left = mid + 1 return left"},{"question":"Given two strings `start` and `goal`, both of the same length, you can change `start` into `goal` by performing some number of operations. In each operation, you can swap any two characters in `start`. Return the minimum number of swaps required to transform `start` into `goal`. If it is impossible to transform `start` into `goal`, return `-1`.","solution":"def min_swaps_to_transform(start, goal): Returns the minimum number of swaps required to transform \'start\' into \'goal\'. If it is impossible, return -1. if sorted(start) != sorted(goal): return -1 def count_swaps(s1, s2): swaps = 0 s1, s2 = list(s1), list(s2) for i in range(len(s1)): if s1[i] != s2[i]: swap_index = s1.index(s2[i], i) s1[i], s1[swap_index] = s1[swap_index], s1[i] swaps += 1 return swaps return count_swaps(start, goal)"},{"question":"You are given an integer array `arr` and an integer `d`. A **jump** from index `i` to index `j` is valid if: - `i` and `j` are within bounds, - `arr[i] > arr[j]`, and - `|i - j| <= d`. You can make any number of jumps, and you start from any index. Return _the maximum number of indices you can visit_. **Note:** You can visit the same index more than once in different sequences of jumps, but the maximum count should consider each index as a unique node visited overall.","solution":"def max_jumps(arr, d): def dfs(i, dp): if dp[i] != -1: return dp[i] max_reach = 1 for direction in [-1, 1]: for j in range(1, d + 1): new_index = i + direction * j if new_index < 0 or new_index >= len(arr) or arr[new_index] >= arr[i]: break max_reach = max(max_reach, 1 + dfs(new_index, dp)) dp[i] = max_reach return dp[i] n = len(arr) dp = [-1] * n return max(dfs(i, dp) for i in range(n))"},{"question":"You are designing a system to handle a queue of customers at a bank. Each customer has a unique ID and a certain service time duration. The bank has two counters, and each counter can serve only one customer at a time. Implement a class `BankQueue` with the following methods: - `BankQueue()`: Initializes the queue with no customers. - `void addCustomer(int id, int serviceTime)`: Adds a new customer with the given `id` and `serviceTime` to the queue. - `int serveNextCustomer()`: Simulates serving the next customer. The customer with the shortest service time should be served first. If two customers have the same service time, the customer who joined the queue earlier should be served first. This method returns the `id` of the served customer. - `int nextServingTime()`: Returns the service time of the next customer to be served. If no customers are waiting, returns `-1`. This system should always assign a counter to a customer if one is available, by selecting the customer based on the described prioritization rules.","solution":"import heapq class BankQueue: def __init__(self): self.queue = [] self.timestamp = 0 def addCustomer(self, id, serviceTime): heapq.heappush(self.queue, (serviceTime, self.timestamp, id)) self.timestamp += 1 def serveNextCustomer(self): if not self.queue: return -1 next_customer = heapq.heappop(self.queue) return next_customer[2] def nextServingTime(self): if not self.queue: return -1 next_customer = self.queue[0] return next_customer[0]"},{"question":"You are given an array of strings `words` and an integer `k`. Each string in `words` represents a key with unique characters. Two keys can be concatenated if they have no common characters. Your task is to return the length of the longest concatenation of any `k` keys from the array such that each key in the concatenation meets the criterion. If it is not possible to concatenate `k` keys without repeating characters, return `0`.","solution":"from itertools import combinations def max_length_of_concatenated_keys(words, k): Returns the length of the longest concatenation of any k keys from the array such that each key in the concatenation has unique characters and no two keys have any common characters. def has_unique_characters(s): Check if all characters in the string are unique. return len(s) == len(set(s)) def can_concatenate(s1, s2): Check if two strings have no common characters. return set(s1).isdisjoint(set(s2)) valid_combinations = [] for word_list in combinations(words, k): concatenated = \\"\\".join(word_list) if all(has_unique_characters(word) for word in word_list): if all(can_concatenate(word_list[i], word_list[j]) for i in range(len(word_list)) for j in range(i + 1, len(word_list))): valid_combinations.append(concatenated) return max(len(combo) for combo in valid_combinations) if valid_combinations else 0"},{"question":"Given an array of integers `tasks` where `tasks[i]` represents the time taken to complete the `i-th` task, and an integer `k` representing the number of available workers, return _the minimum number of rounds of assigning tasks such that all tasks are completed_. Each worker can only handle one task at a time in a round. If it is not possible to complete all tasks, return `-1`.","solution":"def min_rounds(tasks, k): Returns the minimum number of rounds to complete all tasks by k workers. If it is not possible, return -1. :param tasks: List of integers where each integer represents the time to complete a task :param k: Integer representing the number of available workers :return: Integer representing minimum number of rounds, or -1 if not possible if not tasks or k <= 0: return -1 n = len(tasks) if k >= n: return 1 # All tasks can be handled by k or more workers in one round # We need at least this many rounds from math import ceil rounds = ceil(n / k) return rounds"},{"question":"Given a matrix of integers `grid` representing a battlefield, where `grid[i][j]` can be: - `1` - representing a soldier of your army, - `0` - representing empty land, and - `-1` - representing an obstacle. Your task is to find the maximum number of soldiers that can be placed on the battlefield in a single row such that they are not adjacent to each other. Two soldiers are considered adjacent if they are horizontally, vertically, or diagonally next to each other. Return the maximum number of non-adjacent soldiers that can be placed in a single row of the battlefield.","solution":"def max_soldiers_in_row(grid): Returns the maximum number of non-adjacent soldiers that can be placed in a single row of the battlefield. max_soldiers = 0 for row in grid: dp = [0] * (len(row) + 1) for i in range(1, len(row) + 1): if row[i - 1] == 1: dp[i] = max(dp[i - 1], (dp[i - 2] + 1 if i - 2 >= 0 else 1)) else: dp[i] = dp[i - 1] max_soldiers = max(max_soldiers, dp[-1]) return max_soldiers"},{"question":"You are given a string `s` containing only three types of characters: `\'(\'`, `\')\'`, and `\'*\'`. Return _true if `s` could be a valid string_. A string is considered valid if: - Any left parenthesis `\'(\'` must have a matching right parenthesis `\')\'`. - Any right parenthesis `\')\'` must have a matching left parenthesis `\'(\'`. - Left parenthesis `\'(\'` must go before the corresponding right parenthesis `\')\'`. - `\'*\'` can be treated as a single right parenthesis `\')\'`, a single left parenthesis `\'(\'`, or an empty string.","solution":"def checkValidString(s): left_min = left_max = 0 for char in s: if char == \'(\': left_min += 1 left_max += 1 elif char == \')\': left_min = max(left_min - 1, 0) left_max -= 1 else: # char == \'*\' left_min = max(left_min - 1, 0) left_max += 1 if left_max < 0: return False return left_min == 0"},{"question":"Given a 2D integer grid of size `m x n`, where each cell represents an `elevation`, return the length of the longest increasing path in the grid. From each cell, you can move in four possible directions: left, right, up, or down. You may not move diagonally or move outside the boundary of the grid. The path must be strictly increasing.","solution":"def longest_increasing_path(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[-1] * n for _ in range(m)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > grid[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) dp[x][y] = max_path return dp[x][y] result = 0 for i in range(m): for j in range(n): result = max(result, dfs(i, j)) return result"},{"question":"You are given an array of positive integers `arr` where each integer represents the height of a building. A building with a certain height blocks the view of another building if it is located to its left and has a height greater than or equal to the building in question. Return an array `result` such that `result[i]` contains the number of buildings that block the view of the building at index `i`.","solution":"def buildings_blocked_view(arr): Returns a list where each element corresponds to the number of buildings that block the view of the building at the respective index in the input list. result = [0] * len(arr) for i in range(len(arr)): for j in range(i): if arr[j] >= arr[i]: result[i] += 1 return result"},{"question":"Given a list of version numbers represented as strings, write a function to sort them in ascending order. A version number is in the format \\"x.y.z\\" where x, y, and z are non-negative integers (x, y, and z do not have leading zeros). If two version numbers are equal when considered as tuples of integers x, y, and z, their relative order in the input list should be preserved. Return the sorted list of version numbers.","solution":"def sort_versions(version_list): Sorts a list of version numbers in ascending order. Parameters: - version_list (list of str): list of version numbers represented as strings in the format \\"x.y.z\\" Returns: - list of str: sorted list of version numbers return sorted(version_list, key=lambda v: tuple(map(int, v.split(\'.\'))))"},{"question":"You are given a binary tree with `n` nodes. Each node has an integer value. A path in the binary tree is defined as a sequence of nodes starting from any node and ending at any node, following the parent-child connections. The **weight** of a path is the sum of the values of the nodes in the path. Determine the maximum weight of any path in the binary tree. Return the maximum weight as an integer.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum weight of any path in the binary tree. :param root: TreeNode, the root of the binary tree :return: int, maximum weight of any path def helper(node): nonlocal max_sum if not node: return 0 left_sum = max(helper(node.left), 0) # max gain if we include left subtree right_sum = max(helper(node.right), 0) # max gain if we include right subtree # max path sum including the current node current_path_sum = node.val + left_sum + right_sum # update global max_sum max_sum = max(max_sum, current_path_sum) # return max gain if we continue the same path including the current node return node.val + max(left_sum, right_sum) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"You are given an integer array `heights` representing the heights of buildings in a street, where `heights[i]` is the height of the ith building. A building can see the ocean if there are no taller buildings to its right. Implement a function that returns a list of indices of buildings that can see the ocean from left to right. The buildings are considered to be standing in a row, and you need to return these indices in the order of their appearance in the `heights` array.","solution":"def find_buildings_with_ocean_view(heights): Returns a list of indices representing buildings that can see the ocean. Args: heights (List[int]): List of building heights. Returns: List[int]: List of indices of buildings that can see the ocean. result = [] max_height = 0 for index, height in enumerate(heights): if height > max_height: result.append(index) max_height = height return result"},{"question":"You are given an integer array `arr` consisting of positive numbers. A number `k` is called a **peak element** if it is greater than its immediate neighbors. If the element is at the start or end of the array, it only needs to be greater than its single neighbor. Write a function to return the **index** of any peak element in `arr`. If there are multiple peak elements, you can return the index of any one of them. The time complexity of your solution should be better than O(n).","solution":"def find_peak_element(arr): Returns the index of any peak element in the array. A peak element is greater than its neighbors. If the element is at the start or end, it only needs to be greater than its single neighbor. Uses a binary search approach to achieve better than O(n) time complexity. Parameters: arr (list): A list of positive integers Returns: int: The index of any peak element left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"Given an integer `n`, generate all unique combinations of `n` pairs of well-formed parentheses. Each pair of parentheses is denoted as `()`. Return an array of all possible valid combinations. The order of the combinations in the array does not matter, but the combinations themselves must be distinct. For example, given `n = 3`, one of the valid combinations would be `\\"((()))\\"`. Ensure to include every possible combination without repeating any.","solution":"def generate_parentheses(n): Generate all unique combinations of n pairs of well-formed parentheses. :param n: An integer representing the number of pairs of parentheses. :return: A list of unique combinations of well-formed parentheses. def backtrack(remaining_left, remaining_right, current_combination, results): if remaining_left == 0 and remaining_right == 0: results.append(current_combination) return if remaining_left > 0: backtrack(remaining_left - 1, remaining_right, current_combination + \\"(\\", results) if remaining_right > remaining_left: backtrack(remaining_left, remaining_right - 1, current_combination + \\")\\", results) results = [] backtrack(n, n, \\"\\", results) return results"},{"question":"Given a list of tasks where each task is represented by a letter and an integer interval `n`, representing the cooldown period between two same tasks, return the least number of intervals the CPU will take to complete all the given tasks. Each interval could be either an idle interval or interval with an execution of a task. For example, given the tasks `[\'A\', \'A\', \'A\', \'B\', \'B\', \'B\']` and `n = 2`, the CPU could schedule the tasks as follows: The intervals would be organized so that the tasks with the same type have at least `n` intervals in between them. Therefore, the output would be the minimum necessary intervals to complete the tasks with the given cooldown.","solution":"from collections import Counter def least_interval(tasks, n): Returns the least number of intervals needed to complete all tasks with a cooling period of n. task_counts = Counter(tasks) max_task_count = max(task_counts.values()) tasks_with_max_count = list(task_counts.values()).count(max_task_count) min_intervals = (max_task_count - 1) * (n + 1) + tasks_with_max_count return max(min_intervals, len(tasks))"},{"question":"A binary tree is defined as an acyclic connected graph where each node has up to two children. Implement the function `findLeaves` which, given the root of a binary tree, returns all leaves of the tree and removes them. You must repeat this process until the tree is empty. A leaf is a node without any children. The function should return a list of lists where each inner list contains the leaves removed at each step. The tree nodes are defined as: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findLeaves(root): Given the root of a binary tree, this function returns all leaves of the tree and removes them. The process is repeated until the tree is empty. Arguments: root -- TreeNode, the root of the binary tree. Returns: result -- List of lists of integers, where each inner list contains the leaves removed at each step. Example: Input: root = [1,2,3,4,5] 1 / 2 3 / 4 5 Output: [[4, 5, 3], [2], [1]] result = [] def removeLeaves(node): if not node: return None, [] if not node.left and not node.right: return None, [node.value] left, left_leaves = removeLeaves(node.left) right, right_leaves = removeLeaves(node.right) node.left = left node.right = right return node, left_leaves + right_leaves while root: root, leaves = removeLeaves(root) result.append(leaves) return result"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to select a contiguous substring of `s` such that it contains **exactly** `k` distinct characters. Return _the **length** of the **longest** such substring_. If there is no such substring, return `-1`.","solution":"def longest_substring_with_k_distinct(s, k): Finds the length of the longest substring that contains exactly k distinct characters. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The number of distinct characters required. Returns: int: The length of the longest substring with exactly k distinct characters, or -1 if there is no such substring. if k == 0: return -1 n = len(s) max_length = -1 char_count = {} left = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a binary tree rooted at `root` with `n` nodes. Each node has a `value` associated with it. The **value sum** of a node is defined as the sum of its own value and the values of all its descendants. A subtree rooted at a given node is considered **valid** if its value sum is greater than or equal to a given threshold `T`. Return the number of valid subtrees in the binary tree. For example, given the binary tree: ``` 5 / 3 8 /| | 2 4 6 1 ``` and a threshold `T = 14`, the valid subtrees are rooted at nodes with values `5` and `8`, since the value sums are `5+3+2+4+8+6+1=29` and `8+6+1=15` respectively, which are both greater than or equal to `14`. Thus, the result would be `2`. If there are no valid subtrees, return `0`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_valid_subtrees(root, T): Returns the number of valid subtrees where the sum of values in the subtree is greater than or equal to T. def subtree_value_sum(node): if not node: return 0, 0 # sum is 0, valid subtree count is 0 left_sum, left_count = subtree_value_sum(node.left) right_sum, right_count = subtree_value_sum(node.right) total_sum = node.value + left_sum + right_sum is_valid = 1 if total_sum >= T else 0 return total_sum, left_count + right_count + is_valid _, valid_subtree_count = subtree_value_sum(root) return valid_subtree_count"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. Your task is to divide the array into exactly `k` non-empty contiguous subarrays such that the maximum sum of all subarrays is minimized. If there are multiple possible solutions, return the lexicographically smallest one. Return _a 2D integer array_ `result` _where_ `result[i]` _represents the_ `i-th` _subarray. Each subarray should be non-empty and contiguous._ **Example:** ``` Input: arr = [7, 2, 5, 10, 8], k = 2 Output: [[7, 2, 5], [10, 8]] Input: arr = [1, 2, 3, 4, 5], k = 2 Output: [[1, 2, 3], [4, 5]] ```","solution":"def splitArray(arr, k): def canSplit(mid): current_sum = 0 subarrays = 1 for num in arr: if current_sum + num > mid: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True def findMinimizedMaxSum(): left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left minimized_max_sum = findMinimizedMaxSum() result = [] current_sum, current_partition = 0, [] for num in arr: if current_sum + num > minimized_max_sum: result.append(current_partition) current_partition = [num] current_sum = num else: current_partition.append(num) current_sum += num if current_partition: result.append(current_partition) return result"},{"question":"Given a weighted, directed graph with `n` nodes and `edges` where `edges[i] = [ui, vi, weighti]` represents a directed edge from node `ui` to node `vi` with weight `weighti`, implement the `ShortestPathFinder` class: * `ShortestPathFinder(int n, int[][] edges)` initializes the class with a directed graph. * `int getShortestPath(int start, int end)` returns the shortest path distance from node `start` to node `end`. If there is no path, return `-1`.","solution":"import heapq import sys class ShortestPathFinder: def __init__(self, n, edges): self.graph = {i: [] for i in range(n)} for u, v, weight in edges: self.graph[u].append((v, weight)) def getShortestPath(self, start, end): # Using Dijkstra\'s algorithm to find the shortest path pq = [(0, start)] distances = {i: sys.maxsize for i in self.graph} distances[start] = 0 visited = set() while pq: curr_dist, curr_node = heapq.heappop(pq) if curr_node in visited: continue visited.add(curr_node) if curr_node == end: return curr_dist for neighbor, weight in self.graph[curr_node]: distance = curr_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[end] == sys.maxsize else distances[end]"},{"question":"You are given a string `s` containing only lowercase English letters, and an integer `k`. A substring is called **special** if it contains at most `k` distinct characters. Return _the length of the longest **special** substring of `s`_.","solution":"def longest_special_substring(s, k): Returns the length of the longest special substring of s which contains at most k distinct characters. from collections import defaultdict n = len(s) if k == 0 or n == 0: return 0 left = 0 max_length = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a 2D integer array `matrix` of size `m x n` where each element is either `0` or `1`. You can flip any cell (change `1` to `0` or vice versa) and return the maximum number of rows that contain **at least one `1`** after any number of flips. Only consider the rows in the original matrix that contain at least one `1`. Return the maximum number of rows with at least one `1`.","solution":"def max_rows_with_one(matrix): Returns the maximum number of rows with at least one \'1\' after any number of flips. Only consider rows that already contain at least one \'1\'. rows_with_one = [row for row in matrix if 1 in row] return len(rows_with_one)"},{"question":"A company is hosting a party and wants to distribute gift bags to its employees. There are `n` different types of gift bags, and you are given an integer array `bags` where `bags[i]` represents how many gift bags of type `i` are available. Each of the employees wants exactly one gift bag, and the company wants to maximize the number of satisfied employees. However, each employee has a preference list represented by a list of lists `preferences`, where `preferences[i]` is a list of gift bag types that the `i-th` employee prefers in the order of preference. Implement a function that returns the maximum number of employees that can get a gift bag they prefer.","solution":"def max_satisfied_employees(bags, preferences): n = len(preferences) m = len(bags) # Preference to employee list mapping pref_to_emp = [[] for _ in range(m)] for emp, prefs in enumerate(preferences): for bag in prefs: pref_to_emp[bag].append(emp) satisfied = 0 assigned = [False] * n for bag_type, employees in enumerate(pref_to_emp): available_bags = bags[bag_type] for emp in employees: if available_bags > 0 and not assigned[emp]: assigned[emp] = True satisfied += 1 available_bags -= 1 if available_bags == 0: break return satisfied"},{"question":"You are given a binary tree in which each node contains an integer value. Write a function that flattens the binary tree into a linked list in-place. The linked list should use the right child pointers to point to the next node in the list and should be in the same order as a pre-order traversal of the tree. For example, given the following tree: ``` 1 / 2 5 / 3 4 6 ``` The flattened tree should look like: ``` 1 2 3 4 5 6 ``` Implement a function with the following signature: ```python def flatten(root: TreeNode) -> None: ``` Where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root: TreeNode) -> None: Flattens the binary tree into a linked list in-place. # Helper function to perform pre-order traversal and re-link nodes def flatten_tree(node): if not node: return None left_tail = flatten_tree(node.left) right_tail = flatten_tree(node.right) if node.left: if left_tail: left_tail.right = node.right node.right = node.left node.left = None return right_tail or left_tail or node flatten_tree(root)"},{"question":"You are given two arrays `words1` and `words2` consisting of lowercase English letters. Implement a function that returns an array of strings from `words1` that are **universal** with respect to `words2`. A word `a` from `words1` is considered universal with respect to `words2` if for every word `b` in `words2`, `b` is a subset of `a`. In other words, every letter in `b` must appear in `a` at least as many times as it appears in `b`. Return _the list of all universal words_ in `words1`.","solution":"from collections import Counter from typing import List def word_subsets(words1: List[str], words2: List[str]) -> List[str]: Returns the list of all universal words in words1 with respect to words2. def count_max_chars(words): max_count = Counter() for word in words: word_count = Counter(word) for char in word_count: max_count[char] = max(max_count[char], word_count[char]) return max_count bmax = count_max_chars(words2) def is_universal(word): count = Counter(word) for char in bmax: if count[char] < bmax[char]: return False return True result = [word for word in words1 if is_universal(word)] return result"},{"question":"You are given a string `s` which represents a text document. You must find the length of the longest subsequence that can be formed by deleting some (or no) characters from `s` such that the subsequence is a palindrome. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return _the length of the longest palindromic subsequence_.","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in string s. n = len(s) if n == 0: return 0 # Create a 2D array to store lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # All substrings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Check for subsequences of length 2 to n for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # Length of the longest palindromic subsequence return dp[0][n - 1]"},{"question":"You are given a string `s` and an integer `k`. The string `s` can be partitioned into multiple substrings such that each substring has exactly `k` characters. Count the number of distinct substrings that can be formed with exactly `k` characters. If the total number of characters in the string is less than `k`, return `0`. For example, given the string \\"abcdefabc\\" and k = 3, the distinct substrings are \\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\", resulting in an output of 4 distinct substrings.","solution":"def count_distinct_substrings(s, k): Returns the number of distinct substrings of length `k` in `s`. :param s: The input string. :param k: The length of substrings to consider. :return: The number of distinct substrings of length `k`. if len(s) < k: return 0 substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i+k]) return len(substrings)"},{"question":"You are given a string `s` that contains only lowercase English letters. You need to determine the length of the longest substring that can be formed by deleting at most `k` characters from `s` such that every character of the substring appears at least `m` times. Implement a function `longestValidSubstring(s: str, k: int, m: int) -> int` that returns this length.","solution":"def longestValidSubstring(s, k, m): from collections import Counter def validSubstring(s, m): count = Counter(s) for char in count: if count[char] < m: return False return True n = len(s) max_len = 0 for i in range(n): for j in range(i, n): substr = s[i:j+1] if validSubstring(substr, m): max_len = max(max_len, len(substr)) return max_len"},{"question":"You are given a dice rolling simulation where a die has six faces numbered from 1 to 6. The function `simulateRolls(n)` rolls the die `n` times and returns a list of the outcomes. Write the function `simulateRollsProbabilities(n)` that returns a dictionary with the face values (1 through 6) as keys and their respective probabilities (as floats rounded to two decimal places) of appearing in the `n` rolls as values. _Ensure the probabilities add up to 1.00._","solution":"import random def simulateRolls(n): Rolls the die n times and returns a list of the outcomes. return [random.randint(1, 6) for _ in range(n)] def count_occurrences(results, face_value): Counts how many times a face value appears in the results list. return results.count(face_value) def simulateRollsProbabilities(n): Simulates rolling the die n times and computes the probabilities of each face value (1 to 6) appearing, rounded to two decimal places. if n <= 0: return {i: 0.00 for i in range(1, 7)} results = simulateRolls(n) probabilities = {} for i in range(1, 7): occurrences = count_occurrences(results, i) probabilities[i] = round(occurrences / n, 2) return probabilities"},{"question":"You are given a `n x n` binary matrix `grid` where `0` represents an empty cell and `1` represents a blocked cell. You are currently at the top-left corner of the grid (i.e., `grid[0][0]`) and you need to reach the bottom-right corner (i.e., `grid[n-1][n-1]`). In one move, you can go up, down, left, or right, but you cannot move diagonally. Return the minimum number of steps required to reach the bottom-right corner from the top-left corner. If there is no possible way to reach the destination, return `-1`. Note: `n` is the length of `grid`, and the top-left and bottom-right corners are always empty cells (`0`).","solution":"from collections import deque def min_steps_to_reach_bottom_right(grid): Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner, or -1 if there is no possible way to reach the destination. Parameters: grid (List[List[int]]): The n x n binary matrix where 0 represents an empty cell and 1 represents a blocked cell. Returns: int: The minimum number of steps to reach the bottom-right corner or -1 if unreachable. n = len(grid) if not grid or grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == n-1 and col == n-1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: queue.append((new_row, new_col, steps+1)) visited.add((new_row, new_col)) return -1"},{"question":"Given a matrix `matrix`. Imagine starting from the top-left corner and moving to the bottom-right corner, calculating the sum of the elements along the path. You can only move either down or right at any point in time. Your task is to compute the minimum path sum from the top left to bottom right by only moving right or down. For example, given the following matrix: ``` [ [1,3,1], [1,5,1], [4,2,1] ] ``` The minimum path sum is `7`, which is obtained by following the path `1→3→1→1→1`. Implement a function ``` def minPathSum(matrix: List[List[int]]) -> int ```","solution":"from typing import List def minPathSum(matrix: List[List[int]]) -> int: Computes the minimum path sum from the top left to bottom right corner of the matrix. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) # Initialize the dynamic programming table with the same size as the matrix dp = [[0] * cols for _ in range(rows)] # Set the starting point dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1]"},{"question":"Given a list of strings `words`, find the longest string `s` that is a universal subsequence for all strings in the list. A string `s` is a universal subsequence of another string `t` if `s` can be formed by deleting some (or none) characters of `t` without changing the order of the remaining characters. If there are multiple possible results, return any of them. If there is no universal subsequence, return an empty string.","solution":"def is_subsequence(s, t): Helper function to check if s is a subsequence of t. it = iter(t) return all(char in it for char in s) def find_longest_universal_subsequence(words): Finds the longest string that is a universal subsequence for all strings in the list. Parameters: words (list): List of strings Returns: str: The longest universal subsequence or an empty string if none exists if not words: return \\"\\" # Check candidates from the smallest string candidate = min(words, key=len) candidate_len = len(candidate) # Check from longest possible subsequence to the smallest for length in range(candidate_len, 0, -1): for i in range(candidate_len - length + 1): subseq = candidate[i:i+length] if all(is_subsequence(subseq, word) for word in words): return subseq return \\"\\""},{"question":"You are given an array of integers `nums` and an integer `target`. You need to find the **quadruplets** (four numbers) in `nums` that add up to the `target` value. Return _all unique quadruplets_ in any order. *Note that the solution set must not contain duplicate quadruplets.*","solution":"def four_sum(nums, target): Finds all unique quadruplets in nums that add up to target. :param nums: List[int] - List of integers. :param target: int - Target sum for the quadruplets :return: List[List[int]] - List of unique quadruplets. nums.sort() quadruplets = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left = j + 1 right = length - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"You are given a 2D grid of size `m x n` filled with non-negative integers representing a height map. The task is to calculate the amount of water that can be trapped after raining. The water trapped in each cell is determined by the difference in height between the current cell and the minimum height of its neighboring cells. You need to return the total volume of trapped water. For example, for the grid: ``` [ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ] ``` The output would be `4` because the water can be trapped in the following cells: - Cell [1][2] can trap 1 unit of water, - Cell [1][3] can trap 1 unit of water, - Cell [1][4] can trap 1 unit of water, - Cell [2][3] can trap 1 unit of water. Return the total volume of trapped water.","solution":"import heapq def trap_rain_water(height_map): if not height_map or not height_map[0]: return 0 m, n = len(height_map), len(height_map[0]) visited = [[False] * n for _ in range(m)] heap = [] for i in range(m): heapq.heappush(heap, (height_map[i][0], i, 0)) heapq.heappush(heap, (height_map[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(heap, (height_map[0][j], 0, j)) heapq.heappush(heap, (height_map[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True water_trapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: trapped = max(0, height - height_map[nx][ny]) water_trapped += trapped visited[nx][ny] = True heapq.heappush(heap, (max(height, height_map[nx][ny]), nx, ny)) return water_trapped"},{"question":"Implement a function that takes in an integer array `arr` and an integer `k`, and returns the maximum sum of `k` consecutive elements in the array. If there are fewer than `k` elements in the array, return 0.","solution":"def max_sum_k_consecutive(arr, k): Returns the maximum sum of k consecutive elements in arr. If there are fewer than k elements in arr, returns 0. n = len(arr) if n < k: return 0 # Calculate the sum of the first k elements max_sum = current_sum = sum(arr[:k]) # Use sliding window to calculate the remaining sums for i in range(k, n): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers `arr` and an integer `target`, return _indices of the two numbers_ such that they add up to `target`. You may assume that each input would have **exactly one solution**, and you may not use the same element twice. Your answer should be in the form of a tuple of indices `(i, j)` where `i` and `j` are the indices of the two numbers in `arr`. The indices in the returned tuple should be sorted in ascending order. You must solve the problem with an algorithm that runs in `O(n)` time.","solution":"def two_sum(arr, target): Returns the indices of the two numbers in the array `arr` that add up to the `target`. The indices are returned as a tuple in ascending order. # Dictionary to store the number and its corresponding index num_to_index = {} # Iterate through the array for i, num in enumerate(arr): # Calculate the complement complement = target - num # Check if the complement exists in the dictionary if complement in num_to_index: # Return the indices sorted in ascending order return tuple(sorted((num_to_index[complement], i))) # Store the number and its index in the dictionary num_to_index[num] = i # In case no solution exists, though the problem guarantees one return None"},{"question":"Given a 2D grid of integers where each cell represents a unit of water, you are tasked to determine the **maximum quantity of water** that can be trapped in between the cells after it rains. Each cell will store water based on the heights of the surrounding cells. Water is trapped according to the following criteria: - For any cell, the amount of water trapped is determined by the minimum of the maximum heights of the cells in the four orthogonal directions (left, right, up, down) minus the height of the current cell. You need to return an integer representing the total amount of trapped water. For example, given the 2D grid: ``` [ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ] ``` The total amount of trapped water would be 4. Note: Cells on the boundary of the grid cannot trap any water.","solution":"import heapq def trap_rain_water(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False for _ in range(n)] for _ in range(m)] heap = [] for i in range(m): heapq.heappush(heap, (heightMap[i][0], i, 0)) heapq.heappush(heap, (heightMap[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(heap, (heightMap[0][j], 0, j)) heapq.heappush(heap, (heightMap[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True total_water = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True total_water += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return total_water"},{"question":"You are given a **0-indexed** integer array `temperatures` representing the daily temperatures for a given city. Your goal is to determine for each day how many days you have to wait until a warmer temperature. If there is no future day for which this is possible, return `0` for that day. Return _an array of integers where each element in the result array represents the number of days you have to wait to get a warmer temperature, or `0` if no warmer temperature is available_.","solution":"def dailyTemperatures(temperatures): Given a list of daily temperatures, returns a list of the number of days until a warmer temperature for each day. If there are no future warmer temperatures, returns 0 for that day. :param temperatures: List[int] - A list of integers representing daily temperatures :return: List[int] - A list of integers representing the number of days to wait for a warmer temperature n = len(temperatures) result = [0] * n stack = [] for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"Given a string `s` and an integer `k`, you need to split the string into `k` non-empty palindromic substrings. Return _a list of_ `k` _palindromic substrings if such a split is possible, or an empty list if it is not._ A string is a **palindrome** if it reads the same forward and backward.","solution":"def is_palindrome(s): return s == s[::-1] def split_into_palindromes(s, k): n = len(s) result = [] def backtrack(start, cut): if cut == 0: if start == n: return True return False for end in range(start + 1, n + 1): sub_str = s[start:end] if is_palindrome(sub_str): result.append(sub_str) if backtrack(end, cut - 1): return True result.pop() return False if backtrack(0, k): return result else: return []"},{"question":"You are given a list of `n` integers, where each integer represents the position of a checkpoint in a one-dimensional race. A runner starts from the first checkpoint (first element in the list) and wants to reach the last checkpoint (last element in the list). The runner can move from the current checkpoint to any other checkpoint that comes after it, but the runner incurs a penalty equal to the difference in positions between these two checkpoints. Return _the minimum total penalty the runner can incur to reach the last checkpoint from the first checkpoint_.","solution":"def min_total_penalty(checkpoints): Returns the minimum total penalty the runner can incur to reach the last checkpoint from the first checkpoint. n = len(checkpoints) dp = [float(\'inf\')] * n dp[0] = 0 # Starting point, no penalty for i in range(n): for j in range(i + 1, n): dp[j] = min(dp[j], dp[i] + abs(checkpoints[j] - checkpoints[i])) return dp[-1]"},{"question":"Given an array `arr` of integers, you are allowed to perform the following operation any number of times: - Choose any two adjacent elements and add their absolute difference to the smaller element. Return the maximum possible value of the element at the last position after performing the above operation any number of times. Note that you are only allowed to perform operations on consecutive elements in the array.","solution":"def max_possible_last_element(arr): Returns the maximum possible value of the element at the last position after performing the allowed operations any number of times. n = len(arr) if n == 0: return 0 # If the array is empty # The idea is to keep increasing the value of the last element by making # the second last element smaller in each step. # We iterate from the second last element backwards to the first element. for i in range(n-2, -1, -1): arr[i] = min(arr[i], arr[i + 1]) return arr[-1]"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. Consider `num_segments` as the number of contiguous subarrays (segments) where each segment\'s elements are sorted in strictly increasing order. Return an integer `answer`, the number of such valid segments. For example, the array `[1, 2, 6, 5, 4, 7, 8]` has three valid increasing segments: `[1, 2, 6]`, `[5]`, `[4, 7, 8]`.","solution":"def count_increasing_segments(nums): Returns the number of contiguous subarrays (segments) where each segment\'s elements are sorted in strictly increasing order. if not nums: return 0 count = 1 for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: count += 1 return count"},{"question":"You are given two strings, `s` and `t`, where `s` consists of lowercase English letters and is the source string, and `t` is the target string that may contain any characters. You need to insert the minimum number of wildcard characters (`\'*\'`) into `s` such that `t` can be formed as a subsequence from `s`. Return the _minimum number of wildcard characters that need to be inserted in `s` or `-1` if it\'s not possible to form `t` from `s`_. A subsequence of a string is a new string generated from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.","solution":"def min_wildcards_to_form_subsequence(s, t): Returns the minimum number of wildcard characters (\'*\') needed to be inserted into s to make t a subsequence of s, or -1 if it’s not possible to form t from s. :param s: Source string consisting of lowercase English letters :param t: Target string :return: Minimum number of wildcard characters to be inserted into s, or -1 if not possible m, n = len(s), len(t) # If t is empty, no wildcards are needed if n == 0: return 0 # Two pointers approach i, j = 0, 0 wildcards_needed = 0 while i < m and j < n: if s[i] == t[j]: j += 1 else: wildcards_needed += 1 i += 1 # If we\'ve traversed through t, check how many characters are left in s if j == n: wildcards_needed += m - i return wildcards_needed else: return -1"},{"question":"You are given an integer array `arr` and an integer `x`. Your task is to find out if there exists a **subarray** whose sum is exactly equal to `x`. A subarray is a contiguous part of the array. Return `true` if such a subarray exists, otherwise return `false`. Note: The array can contain negative numbers as well.","solution":"def subarray_sum(arr, x): Returns True if there exists a subarray whose sum is exactly equal to x, otherwise returns False. current_sum = 0 sum_dict = {0: -1} # Initialize the dictionary with 0: -1 to handle the case desire to get the sum from the start for i in range(len(arr)): current_sum += arr[i] if (current_sum - x) in sum_dict: return True sum_dict[current_sum] = i return False"},{"question":"You are given an integer array `nums` and an integer `k`. We call an element in the array a **peak** if it is greater than its neighbors. An element at index `i` is considered a peak if `nums[i] > nums[i-1]` and `nums[i] > nums[i+1]` for `1 <= i <= n-2`. Elements at the boundaries are not considered peaks. Write a function to find the **k-th** peak element in the array. If there are fewer than `k` peak elements, return `-1`. The input is such that it is guaranteed that `k` is always a positive integer. **Example:** ``` nums = [1, 3, 2, 4, 1, 6, 5], k = 2 Output: 4 ```","solution":"def find_kth_peak(nums, k): Returns the k-th peak element in the array if exists, otherwise returns -1. peaks = [] for i in range(1, len(nums) - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: peaks.append(nums[i]) if len(peaks) >= k: return peaks[k - 1] else: return -1"},{"question":"Given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image **in-place**, which means you have to modify the input 2D matrix directly. **Do not** allocate another 2D matrix and do the rotation. # Example: Input: ``` matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output: ``` matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Constraints: * `n == matrix.length == matrix[i].length` * `1 <= n <= 20` * `-1000 <= matrix[i][j] <= 1000`","solution":"def rotate_image(matrix): Rotates the given n x n 2D matrix (image) by 90 degrees clockwise in-place. :param matrix: List[List[int]], the n x n 2D matrix representing the image n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Given an array of integers where each element represents the height of a building, the width of each building is 1 unit. You need to find the largest rectangular area that can be formed using contiguous buildings. Return the area of the largest rectangle that can be formed.","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed using contiguous buildings. :param heights: List[int], heights[i] is the height of the i-th building. :return: int, the area of the largest rectangle. stack = [] max_area = 0 heights.append(0) # Append a zero to make sure we empty the stack at the end for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) return max_area"},{"question":"You are given a list of `n` integers representing the heights of students standing in a row. The students are standing in the order of their heights from left to right. Each student wants to know the number of students who are taller than themselves and are standing to their right. Return an integer list where the `i-th` element is the number of students taller than the `i-th` student and to their right.","solution":"def count_students_taller(heights): Returns a list of integers where the i-th element is the number of students who are taller than the i-th student and are standing to their right. :param heights: List[int] : A list of integers representing the heights of the students. :return: List[int] : A list of integers as described. n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] > heights[i]: count += 1 result[i] = count return result"},{"question":"You are given two non-empty binary trees `root1` and `root2`. Imagine that when you overlay these two trees, some nodes of `root2` might appear on top of the nodes of `root1`, and some might be missing. Your task is to **merge the two trees** into a single binary tree by taking the sum of overlapping nodes of `root1` and `root2`. If a node is only present in one of the trees, the corresponding node in the merged tree should have the same value as that node. Implement a function `TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2)` that returns the root of the merged binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(root1, root2): Merges two binary trees into one by summing overlapping nodes. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged = TreeNode(root1.val + root2.val) merged.left = mergeTrees(root1.left, root2.left) merged.right = mergeTrees(root1.right, root2.right) return merged"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. Your task is to split the string into `k` non-empty substrings such that the sum of the lengths of the longest common prefixes (LCP) for all pairs of these substrings is minimized. Write a function to find this minimum sum of LCP. A substring\'s prefix encompasses the starting characters of the substring. The **longest common prefix (LCP)** of two strings is the longest substring from the start in which the two strings match exactly.","solution":"def find_min_lcp_sum(s, k): This function splits the string s into k non-empty substrings such that the sum of the lengths of the longest common prefixes (LCP) for all pairs of these substrings is minimized. n = len(s) if k == 1: return 0 if k == n: return 0 # Use Dynamic Programming approach to solve this problem dp = [[float(\'inf\')] * (k+1) for _ in range(n+1)] dp[0][0] = 0 for i in range(1, n + 1): for j in range(1, k + 1): for x in range(i): lcp = 0 while lcp < x and lcp < i - x and s[x + lcp] == s[x - (i - x) + lcp]: lcp += 1 dp[i][j] = min(dp[i][j], dp[x][j-1] + lcp) return dp[n][k]"},{"question":"You are given the `head` of a singly linked list where each node contains an integer value. Determine if the linked list is a palindrome. A singly linked list is a palindrome if it reads the same forward and backward. Implement the `Solution` class with the following method: * `boolean isPalindrome(ListNode head)`: Returns `true` if the linked list is a palindrome, otherwise returns `false`. **Example:** ``` Input: head = [1,2,2,1] Output: true Input: head = [1,2] Output: false ``` **Constraints:** * The number of nodes in the list is in the range [1, 10^5]. * `0 <= Node.val <= 9` **Note:** The solution should run in O(n) time and use O(1) space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def isPalindrome(self, head: ListNode) -> bool: if not head: return True # Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev = None while slow: next_node = slow.next slow.next = prev prev = slow slow = next_node # Compare the first half and the reversed second half left, right = head, prev while right: # only need to compare till right finishes, because it\'s the shorter one or equal. if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"Implement a class `MiniParser` that can deserialize a string representing a nested list of integers. Each element is either an integer, or a list - whose elements may also be integers or other lists. Nested lists are represented as strings with square brackets `[]` containing integers or other nested lists separated by commas. For example, the string `\\"[123,[456,[789]]]\\"` represents the nested list with two elements: integer `123`, and a nested list `[456,[789]]`. Implement the following method: * `public NestedInteger deserialize(String s)`: Given a nested list `s`, deserialize it to a `NestedInteger` object that contains integers or other nested `NestedInteger` objects. For simplicity, assume input is always valid and follows the rules of nested lists as described.","solution":"class NestedInteger: def __init__(self, value=None): Initialize with value, or an empty list if no value is provided. if value is None: self._list = [] self._value = None else: self._list = None self._value = value def isInteger(self): Return True if this NestedInteger holds a single integer, rather than a nested list. return self._value is not None def add(self, elem): Add a NestedInteger to this NestedInteger list. if self._list is not None: self._list.append(elem) else: raise ValueError(\\"This NestedInteger currently holds a single integer\\") def setInteger(self, value): Set this NestedInteger to hold a single integer. self._value = value def getInteger(self): Return the single integer that this NestedInteger holds, or None if it holds a nested list. return self._value def getList(self): Return the nested list that this NestedInteger holds, or None if it holds a single integer. return self._list class MiniParser: def deserialize(self, s: str) -> NestedInteger: Deserialize a string representing a nested list of integers. stack = [] num = \'\' for char in s: if char == \'[\': stack.append(NestedInteger()) elif char == \']\': if num: stack[-1].add(NestedInteger(int(num))) num = \'\' if len(stack) > 1: nested = stack.pop() stack[-1].add(nested) elif char == \',\': if num: stack[-1].add(NestedInteger(int(num))) num = \'\' else: num += char if num: return NestedInteger(int(num)) return stack[0] # Providing a helper function to print NestedInteger structure, useful for debugging def printNestedInteger(nested): if nested.isInteger(): return nested.getInteger() else: return [printNestedInteger(elem) for elem in nested.getList()]"},{"question":"Given two arrays `arr1` and `arr2`, write a function that returns _a list of integers representing their intersection_. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.","solution":"from collections import Counter def intersect(arr1, arr2): Returns the intersection of two arrays including repeated elements. count1 = Counter(arr1) count2 = Counter(arr2) intersection = [] for element in count1: if element in count2: num_occurrences = min(count1[element], count2[element]) intersection.extend([element] * num_occurrences) return intersection"},{"question":"You are given an array of integers `nums` where each integer represents a position on a number line. Your task is to find the minimal number of jumps you need to make to reach the end of the array (last position). You can assume that you always start from the first position of the array, and you can move to any position within `nums[i]` steps forward from the position `i`. Return the minimal number of jumps needed to reach the last position. If it is not possible to reach the end of the array, return `-1`.","solution":"def min_jumps(nums): Returns the minimal number of jumps needed to reach the last position in the array. If not possible, return -1. if len(nums) <= 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(len(nums)): # Update farthest we can reach farthest = max(farthest, i + nums[i]) # Check if we need to make a jump if i == current_end: jumps += 1 current_end = farthest # If we reached the end or beyond, return the jumps if current_end >= len(nums) - 1: return jumps # If we get here, it means we couldn\'t reach the end return -1"},{"question":"Given a binary tree, where each node contains a single digit (0-9). Every root-to-leaf path in the tree represents a number formed by concatenating the digits along the path. Write a function that returns the sum of all root-to-leaf numbers. A leaf is a node with no children. The binary tree is represented by the TreeNode class, which has properties `val`, `left`, and `right`. For example, given the binary tree: ``` 1 / 2 3 ``` The numbers would be 12 (from path 1->2) and 13 (from path 1->3), and the sum should be 25.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Returns the sum of all root-to-leaf numbers in the binary tree. def dfs(node, current_sum): if not node: return 0 current_sum = current_sum * 10 + node.val if not node.left and not node.right: # if it\'s a leaf node return current_sum # else traverse both subtrees return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"You are given an array `quotes`, where each element is a string representing a famous quote. Also, you are given another array `sentences`, where each element is a string representing a sentence. You need to count how many sentences match any of the quotes in a case-insensitive manner. Return _the number of sentences that match at least one quote_. For example, if `quotes = [\\"To be or not to be\\", \\"A penny for your thoughts\\"]` and `sentences = [\\"to Be or Not To Be\\", \\"A Dime for your thoughts\\", \\"A penny for your Thoughts\\", \\"Live and let live\\"]`, the sentences that match the quotes would be \\"to Be or Not To Be\\" and \\"A penny for your Thoughts\\", so the function should return 2.","solution":"def count_matching_sentences(quotes, sentences): This function counts how many sentences match any of the quotes in a case-insensitive manner. :param quotes: List of strings representing famous quotes. :param sentences: List of strings representing sentences to be matched against the quotes. :return: Integer count of sentences matching at least one quote in a case-insensitive manner. quotes_set = set(quote.lower() for quote in quotes) match_count = 0 for sentence in sentences: if sentence.lower() in quotes_set: match_count += 1 return match_count"},{"question":"You are given a `n x n` matrix containing integers, where negative values represent obstacles and non-negative values represent valid cells. A robot starts at the top-left corner of the matrix (position `(0, 0)`) and aims to reach the bottom-right corner (position `(n - 1, n - 1)`). The robot can only move right or downwards in the matrix. Determine the maximum sum of the values collected along any valid path from the top-left corner to the bottom-right corner. If there is no valid path, return `-1`.","solution":"def max_path_sum(matrix): if not matrix or not matrix[0] or matrix[0][0] < 0 or matrix[-1][-1] < 0: return -1 n = len(matrix) dp = [[-1] * n for _ in range(n)] # Initialize the starting cell dp[0][0] = matrix[0][0] # Fill in the dp table for i in range(n): for j in range(n): if matrix[i][j] < 0: dp[i][j] = -1 else: if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + matrix[i][j]) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + matrix[i][j]) return dp[-1][-1] if dp[-1][-1] != -1 else -1"},{"question":"Given a string `s` consisting only of characters `\'a\'` and `\'b\'`, you can delete any two adjacent characters if they are different. Your goal is to repeatedly delete characters until you can no longer perform any deletions. Return the length of the final string after all possible deletions have been made.","solution":"def final_string_length(s): Reduces the string by repeatedly deleting any two adjacent characters if they are different and returns the length of the final string. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"You are given a string `s` and an array of strings `dict`. The array of strings `dict` contains a list of words. Your task is to determine the **longest** word in `dict` that can be formed by deleting some characters of the given string `s`. If there is more than one possible result, return the word that appears first in the array `dict`. If no valid word exists, return an empty string `\\"\\"`.","solution":"def is_subsequence(str1, str2): it = iter(str1) return all(char in it for char in str2) def find_longest_word(s, dictionary): longest_word = \\"\\" for word in dictionary: if is_subsequence(s, word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and dictionary.index(word) < dictionary.index(longest_word)): longest_word = word return longest_word"},{"question":"Given a string `s`, return the longest substring of `s` that contains at most 2 distinct characters. If there are multiple longest substrings with the same length, return the one that appears first. # Example: ```plaintext Input: s = \\"eceba\\" Output: \\"ece\\" ``` ```plaintext Input: s = \\"ccaabbb\\" Output: \\"aabbb\\" ```","solution":"def longest_substring_with_two_distinct(s): Returns the longest substring of s that contains at most 2 distinct characters. If there are multiple longest substrings with the same length, return the one that appears first. if len(s) <= 2: return s max_len = 0 max_substr = \\"\\" left = 0 char_map = {} for right, char in enumerate(s): if char in char_map: char_map[char] += 1 else: char_map[char] = 1 while len(char_map) > 2: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 if right - left + 1 > max_len: max_len = right - left + 1 max_substr = s[left:right + 1] return max_substr"},{"question":"You are given a `k`-ary tree where each node has at most `k` children and a value. The leaves of the tree contain the values which represent the results of `N` tasks. Write a function that takes the root of the `k`-ary tree and returns the sum of all leaf values, i.e., the sum of results from all `N` tasks. Each node is represented by the following class: ``` class Node { int value; List<Node> children; } ``` Return the sum of all leaf node values in the given `k`-ary tree.","solution":"class Node: def __init__(self, value, children=None): self.value = value self.children = children if children is not None else [] def sum_of_leaf_nodes(root): Returns the sum of all leaf node values in a k-ary tree. :param root: The root node of the k-ary tree :return: The sum of all leaf node values def dfs(node): if not node.children: return node.value return sum(dfs(child) for child in node.children) if root is None: return 0 return dfs(root)"},{"question":"You are given an array of strings `words` and a string `order` that represents the alphabetical order of an alien language. Return _true_ if and only if the given `words` are sorted lexicographically in this alien language. To determine if the words are sorted, you need to compare words pairwise according to the alien dictionary order specified. If the characters of a word are in the same order relative to the alien dictionary as in the words array, then the words are correctly sorted. If at any point the order is violated, return _false_. Example considerations: - If `order` is `\\"worldabcefghijkmnpqstuvxyz\\"` and `words` is `[\\"word\\", \\"world\\", \\"row\\"]`, then the order is violated because `\\"world\\"` should come after `\\"row\\"`. - If `order` is `\\"abcdefghijklmnopqrstuvwxyz\\"` and `words` is `[\\"apple\\", \\"app\\"]`, despite matching with the normal alphabetical order, it is not correctly sorted as `\\"app\\"` should come before `\\"apple\\"`.","solution":"def isAlienSorted(words, order): Determines if the words are sorted lexicographically according to the given alien dictionary order. Parameters: words (list of str): List of words to be verified. order (str): The string representing the order of characters in the alien dictionary. Returns: bool: True if words are sorted according to the alien dictionary order, False otherwise. # Create a mapping of each character in \'order\' to its index order_index = {char: idx for idx, char in enumerate(order)} def is_in_order(word1, word2): Check if word1 is lexicographically less than or equal to word2 according to the alien dictionary order. i, j = 0, 0 while i < len(word1) and j < len(word2): if word1[i] != word2[j]: return order_index[word1[i]] < order_index[word2[j]] i += 1 j += 1 # If all characters are the same in the compared range, then the shorter word should come first return len(word1) <= len(word2) # Compare each word with the next word in the list for k in range(len(words) - 1): if not is_in_order(words[k], words[k + 1]): return False return True"},{"question":"Given a list of `n` intervals where each interval is represented as a tuple of two integers `(start, end)`, merge all overlapping intervals and return the merged list of intervals. Each `start` and `end` value of the intervals meets the following conditions: `0 <= start < end <= 10^4`. The intervals are not initially sorted. Example: - Input: `[(1, 3), (2, 4), (5, 7), (6, 8)]` - Output: `[(1, 4), (5, 8)]`","solution":"def merge_intervals(intervals): Merges overlapping intervals. Args: intervals (list of tuples): List of intervals represented as tuples of two integers. Returns: list of tuples: List of merged intervals. if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # Check if there is an overlap if current[0] <= last_merged[1]: # Merge the intervals merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"You are given a string `s` which consists of lowercase letters and underscores. A valid transformation on the string is defined as follows: you can select any underscore character and move it to any position in the string. You aim to find the lexicographically smallest string possible after performing any number of valid transformations. Return the resulting smallest string.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string possible after performing any number of transformations where underscores can be moved to any position. # Extract characters and underscores characters = [char for char in s if char != \'_\'] underscores = s.count(\'_\') # Sort the characters array characters.sort() # The smallest string would have all underscores at the front smallest_string = \'_\' * underscores + \'\'.join(characters) return smallest_string"},{"question":"Consider a matrix `matrix` of size `m x n` consisting of non-negative integers. You are allowed to perform at most one operation where you increment any element of the matrix by `1`. Your goal is to make the sum of the elements in each row different from the sum of the elements in every other row. Return `true` if it\'s possible to achieve this goal by performing at most one increment operation, otherwise return `false`.","solution":"def is_possible_to_differentiate_rows(matrix): Determines if it is possible to make the sum of the elements in each row different from the sum of the elements in every other row by performing at most one increment operation. Parameters: matrix (List[List[int]]): The m x n matrix of non-negative integers. Returns: bool: True if it can be done, False otherwise. row_sums = [sum(row) for row in matrix] unique_sums = set(row_sums) if len(unique_sums) == len(row_sums): return True # All row sums are already unique for i in range(len(row_sums)): for j in range(len(matrix[i])): new_sums = row_sums[:] new_sums[i] += 1 if len(new_sums) == len(set(new_sums)): return True return False"},{"question":"A city is represented by a directed graph with `n` nodes and `m` edges where nodes represent locations and edges represent one-way roads between these locations. Each edge is associated with a travel time in minutes. You are given the number of nodes `n`, the list of edges `edges`, where `edges[i] = [u, v, time]` indicates a road from node `u` to node `v` taking `time` minutes, and a starting node `start`. Return _the **minimum** travel time from the starting node `start` to **all** other nodes_ in the city. If a node is unreachable from the starting node, return `-1` for that node\'s travel time.","solution":"import heapq def dijkstra(n, edges, start): # Setup adjacency list adj = {i: [] for i in range(n)} for u, v, time in edges: adj[u].append((v, time)) # Setup distance array distances = [float(\'inf\')] * n distances[start] = 0 # Priority queue for the minimum distances pq = [(0, start)] while pq: current_distance, u = heapq.heappop(pq) if current_distance > distances[u]: continue for v, weight in adj[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) # Convert distances to -1 for unreachable nodes for i in range(n): if distances[i] == float(\'inf\'): distances[i] = -1 return distances"},{"question":"You are given a string `expression` consisting of numbers and operators (\'+\' and \'*\') only. Return _the **minimum value** that can be obtained by adding parentheses in any order to the expression_ following the usual order of operations. For example, given the expression `2+3*4`, adding parentheses in different orders can yield different results: - ((2+3)*4) = 20 - (2+(3*4)) = 14 Return the smallest result from all possible parenthesizations.","solution":"def min_value(expression): def dfs(nums, ops): if not ops: return nums[0] min_val = float(\'inf\') for i in range(len(ops)): left = dfs(nums[:i+1], ops[:i]) right = dfs(nums[i+1:], ops[i+1:]) if ops[i] == \'+\': current_val = left + right else: current_val = left * right min_val = min(min_val, current_val) return min_val nums, ops = [], [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 nums.append(num) else: ops.append(expression[i]) i += 1 return dfs(nums, ops)"},{"question":"Write a function that accepts a list of strings `words` and returns a list of lists, where each inner list contains all anagrams from the input list. Each inner list should contain strings that are anagrams of each other, and the inner lists should be in no particular order. An anagram is a word or phrase formed by rearranging the letters of another, using all the original letters exactly once.","solution":"from collections import defaultdict def group_anagrams(words): Returns a list of lists, where each inner list contains anagrams from the input list of words. anagrams = defaultdict(list) for word in words: # sort the word and use it as a key sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"You are given an array of integers `arr` and an integer `k`. Determine if there is a pair of elements in the array whose sum is exactly `k`. Return `True` if such a pair exists, otherwise return `False`. **Note:** You are required to implement the solution with a time complexity of O(n).","solution":"def has_pair_with_sum(arr, k): Determines if there is a pair of elements in arr whose sum is k. seen = set() for number in arr: if k - number in seen: return True seen.add(number) return False"},{"question":"You are given a rectangular grid of `m` rows and `n` columns represented by a 2D integer array `grid`. Each cell in the grid contains either a `0` or a `1`. You can move up, down, left, or right from a cell, but you can only step on cells containing `1`. Your task is to find the largest area (number of cells) of connected `1`s (a region of connected cells is formed by moving horizontally or vertically between adjacent cells, without visiting the same cell more than once). Return _the size of the largest region of connected `1`s in the grid_.","solution":"def largest_region(grid): def dfs(grid, i, j, visited): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0 or (i, j) in visited: return 0 visited.add((i, j)) size = 1 # count the current cell # explore all four directions (up, down, left, right) size += dfs(grid, i + 1, j, visited) size += dfs(grid, i - 1, j, visited) size += dfs(grid, i, j + 1, visited) size += dfs(grid, i, j - 1, visited) return size if not grid: return 0 max_region_size = 0 visited = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: region_size = dfs(grid, i, j, visited) max_region_size = max(max_region_size, region_size) return max_region_size"},{"question":"You are given an array of non-negative integers representing the amount of money of each house, and a thief who plans to rob houses along the street. The constraint is that adjacent houses cannot be robbed on the same night (since this will alert the police). Implement a function `rob(nums)` that will return the maximum amount of money the thief can rob tonight without alerting the police.","solution":"def rob(nums): This function returns the maximum amount of money that can be robbed from a list of houses, where adjacent houses cannot be robbed on the same night. :param nums: List[int] - Array of non-negative integers representing the amount of money in each house. :return: int - Maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] prev1 = 0 prev2 = 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"You are given a string `s` containing only lowercase letters. You need to group the characters of `s` such that each group contains only identical characters and the number of groups formed is maximized. Return _the minimum number of characters you need to delete_ from `s` to achieve this grouping.","solution":"def min_deletions_to_group(s): Returns the minimum number of characters that need to be deleted from s so that each group contains only identical characters and the number of groups is maximized. from collections import Counter # Count frequency of each character count = Counter(s) # If a character appears more than once, we need to keep only one instance per group deletions = sum(freq - 1 for freq in count.values()) return deletions"},{"question":"You are given an unsorted array of integers, where every element appears twice except for one. Find that single element. Your algorithm should have a linear runtime complexity. Can you implement this without using extra memory?","solution":"def find_single_element(arr): Find the single element in an array where every element appears twice except for one. :param arr: List[int], the input list of integers :return: int, the single element that appears only once single_element = 0 for num in arr: single_element ^= num return single_element"},{"question":"You are given a list of `n` integers representing the heights of `n` buildings in a city. The goal is to alter the heights of the buildings such that the city skyline is visually aesthetic from a distance. In one operation, you can increase the height of any building by `1`. However, after every operation, the height of each building must be less than or equal to the height of the buildings to its right. Return the minimum number of operations required to achieve this city skyline configuration.","solution":"def min_operations_to_reduce_heights(buildings): Given a list of `n` integers representing the heights of `n` buildings, return the minimum number of operations required to make each building\'s height less than or equal to the height of the building to its right. n = len(buildings) operations = 0 for i in range(n - 2, -1, -1): if buildings[i] > buildings[i + 1]: operations += (buildings[i] - buildings[i + 1]) buildings[i] = buildings[i + 1] return operations"},{"question":"Given a list of integers `nums` where each integer represents a vote for a candidate, return _a list of candidate(s) who received the highest number of votes_. If there is a tie, include all candidates with the highest number of votes in ascending order.","solution":"def get_winners(nums): Returns a list of candidate(s) who received the highest number of votes. If there is a tie, include all candidates with the highest number of votes in ascending order. Args: nums: List[int] - a list of integers representing votes for candidates Returns: List[int] - a list of candidate(s) with the highest number of votes, in ascending order from collections import Counter if not nums: return [] vote_count = Counter(nums) max_votes = max(vote_count.values()) winners = [candidate for candidate, votes in vote_count.items() if votes == max_votes] return sorted(winners)"},{"question":"Given an array of integers `arr`, determine if it\'s possible to rearrange the elements of `arr` such that the absolute difference between any two consecutive elements is never greater than 1. Return `true` if such a rearrangement exists, and `false` otherwise.","solution":"def can_rearrange(arr): Determines if it\'s possible to rearrange the array elements such that the absolute difference between any two consecutive elements is never greater than 1. :param arr: List of integers :return: Boolean indicating if such a rearrangement is possible if not arr: return True arr.sort() for i in range(len(arr) - 1): if abs(arr[i] - arr[i + 1]) > 1: return False return True"},{"question":"You are given a list of integers `nums` representing a set of scores. The task is to determine how many unique sets of scores have a subset sum that is equal to a target value `T`. Return the count of such unique subsets. A subset is considered unique if no two subsets contain the exact same combination of scores, regardless of their order in the original list. Note that the sets should not have any duplicated values within them.","solution":"from itertools import combinations def count_unique_subsets(nums, target): Count the number of unique subsets of `nums` that sum to `target`. nums = list(set(nums)) # Remove any duplicated values within the list count = 0 unique_subsets = set() for r in range(1, len(nums) + 1): for subset in combinations(nums, r): if sum(subset) == target and subset not in unique_subsets: unique_subsets.add(subset) count += 1 return count"},{"question":"You are given a string `s` that consists of only lowercase English letters. A **substring** is defined as a contiguous sequence of characters within the string. Write a function that returns the length of the smallest contiguous substring of `s` that contains all the distinct characters of `s`. For example, if the string is \\"aabcbcdbca\\", the smallest substring containing all distinct characters is \\"dbca\\", with a length of 4.","solution":"def smallest_substring_with_all_distinct_characters(s): from collections import defaultdict distinct_chars = set(s) char_count = defaultdict(int) total_distinct = len(distinct_chars) start = 0 min_len = float(\'inf\') current_total = 0 for end in range(len(s)): if char_count[s[end]] == 0: current_total += 1 char_count[s[end]] += 1 while current_total == total_distinct: min_len = min(min_len, end - start + 1) char_count[s[start]] -= 1 if char_count[s[start]] == 0: current_total -= 1 start += 1 return min_len"},{"question":"You are given a directed graph represented by an adjacency list, where the graph contains `n` nodes labeled from `0` to `n-1`. Implement a method to determine if there is a path from node `start` to node `end` such that all nodes in the path have distinct values. The adjacency list is provided as a list of lists. Write a function `boolean isPath(int[][] graph, int start, int end)` that returns `true` if such a path exists, otherwise returns `false`.","solution":"def isPath(graph, start, end): Determines if there is a path from start to end in the directed graph such that all nodes in the path have distinct values. :param graph: List of lists representing the adjacency list of the graph :param start: Starting node :param end: Ending node :return: Boolean value indicating if such a path exists def dfs(node, visited): if node == end: return True visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, visited): return True visited.remove(node) return False return dfs(start, set())"},{"question":"Given an integer array `operations` where each element represents an operation to be performed on a running total. The operation can be one of three types: * 0: Add the current running total to a result list. * 1: Double the current running total. * 2: Reset the current running total to 0. Return the list of results obtained from all type 0 operations. The initial value of the running total is 1.","solution":"def perform_operations(operations): Given an integer array `operations` where each element represents an operation to be performed on a running total. The operation can be one of three types: * 0: Add the current running total to a result list. * 1: Double the current running total. * 2: Reset the current running total to 0. Return the list of results obtained from all type 0 operations. The initial value of the running total is 1. running_total = 1 result = [] for op in operations: if op == 0: result.append(running_total) elif op == 1: running_total *= 2 elif op == 2: running_total = 0 return result"},{"question":"You are given an array of integers `nums` and an integer `target`. The aim is to find the **minimum length** of a contiguous subarray of `nums` such that the **sum** of the subarray is at least `target`. If there isn\'t one, return `0` instead. You should write a function `minSubArrayLen(target, nums)` that takes in: - `target`: an integer representing the sum we want the subarray to be at least. - `nums`: an array of integers. Return an integer representing the minimum length of a contiguous subarray of which the sum is at least `target`. If no such subarray exists, return `0`.","solution":"def minSubArrayLen(target, nums): Returns the minimum length of a contiguous subarray for which the sum is at least target. If no such subarray exists, return 0. n = len(nums) min_length = float(\'inf\') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given a matrix `m` of size `n x n` representing a digital image. You need to rotate the matrix 90 degrees clockwise. Your function should modify the input matrix in-place. Implement the function `void rotateMatrix(vector<vector<int>>& m)` that takes the matrix and performs the rotation. The modification must be done in place, meaning you cannot use any additional matrix structure to conduct the rotation. Your result should be the modified matrix `m`.","solution":"def rotateMatrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. Args: matrix (list of list of int): The n x n matrix to be rotated. Returns: None n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[last - offset][first] # Move bottom element to left matrix[last - offset][first] = matrix[last][last - offset] # Move right element to bottom matrix[last][last - offset] = matrix[i][last] # Move top element to right matrix[i][last] = top"},{"question":"You are given an integer array `heights` representing the heights of students standing in a line. Every student wants to see the parade ahead, but their view can be blocked by taller students standing in front of them. A student\'s view is considered \\"unblocked\\" if there is no taller student directly in front of them, otherwise it is \\"blocked\\". You are allowed to remove at most `m` students from the line to maximize the number of students with an unblocked view of the parade. Return the maximum number of students with an unblocked view of the parade after removing at most `m` students.","solution":"def max_unblocked_students(heights, m): Returns the maximum number of students with an unblocked view of the parade after removing at most `m` students. Parameters: heights (list[int]): List of heights of students. m (int): Maximum number of students that can be removed. Returns: int: Maximum number of students with an unblocked view. n = len(heights) if m >= n - 1: return n dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) max_students = max(dp) if m > 0: max_students = min(n, max_students + m) return max_students"},{"question":"You are given a binary tree where each node can have either 0, 1, or 2 children. Each node is represented as a class `TreeNode` that has an integer value and two child pointers (`left` and `right`). Write a function that determines if the given binary tree is symmetric around its center (i.e., it is a mirror of itself). The function should return `true` if the tree is symmetric, or `false` otherwise.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_symmetric(root): Returns True if the binary tree is symmetric, False otherwise. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.value == right.value) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right)"},{"question":"You are given an array of integers `nums` representing the values of a binary tree in level-order traversal, where `null` represents a missing node. Your task is to determine if the binary tree is a complete binary tree. A binary tree is complete if all levels except possibly the last are completely filled, and all nodes in the last level are as far left as possible. Implement a function `boolean isCompleteBinaryTree(Integer[] nums)` that returns `true` if the binary tree is complete, otherwise returns `false`.","solution":"def is_complete_binary_tree(nums): Determine if the binary tree represented by nums is complete. :param nums: List of integers representing the level-order traversal of the binary tree. :return: True if the binary tree is complete, otherwise False. if not nums: return True n = len(nums) for i in range(n): if nums[i] is None: if any(nums[j] is not None for j in range(i + 1, n)): return False return True"},{"question":"Given a linked list and two integers `left` and `right` such that `1 <= left <= right <= n` (where `n` is the length of the linked list), _reverse the nodes of the list from position `left` to position `right`, and return the modified list_. Do this in one pass through the linked list without using recursion.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head, left, right): if not head or left == right: return head dummy = ListNode(0) dummy.next = head prev = dummy for _ in range(left - 1): prev = prev.next current = prev.next reverse = None for _ in range(right - left + 1): next_node = current.next current.next = reverse reverse = current current = next_node prev.next.next = current prev.next = reverse return dummy.next"},{"question":"You are given a string `s` consisting of lowercase alphabets. You need to remove the minimum number of characters from the string so that the remaining string does not contain any consecutive repeating characters. Return the resulting string after the minimum number of deletions. If there are multiple results that require the same number of deletions, return the lexicographically smallest one.","solution":"def remove_consecutive_repeats(s): Remove the minimum number of characters from the string so that the remaining string does not contain any consecutive repeating characters. Return the resulting string. if not s: return \\"\\" result = [s[0]] for i in range(1, len(s)): if s[i] != s[i-1]: result.append(s[i]) return \'\'.join(result)"},{"question":"Given a string `s` and an integer `n`, return a new string where each character in `s` is shifted `n` positions down the alphabet. If shifting a character beyond \'z\', it wraps around to the start of the alphabet. The letter transformations should maintain their respective cases without other characters being altered.","solution":"def caesar_cipher(s, n): Shifts each alphabet character in the string `s` by `n` positions down the alphabet. Maintains the case of the letters and ignores non-alphabet characters. def shift_char(c, n): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + n) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + n) % 26 + ord(\'A\')) else: return c return \'\'.join(shift_char(c, n) for c in s)"},{"question":"You are given a binary tree where each node\'s value is an integer. Implement a function to determine the smallest level of the binary tree where the sum of values of nodes at that level is the maximum. If there are multiple levels with the same sum, return the smallest level number. The level of the root is 1.","solution":"from collections import deque, defaultdict class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_level_sum(root): if not root: return 0 level_sum = defaultdict(int) queue = deque([(root, 1)]) while queue: node, level = queue.popleft() level_sum[level] += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) max_sum = max(level_sum.values()) for level in sorted(level_sum.keys()): if level_sum[level] == max_sum: return level"},{"question":"You are given an array of integers `prices` where `prices[i]` represents the price of a stock on the `i`th day, and a positive integer `d` representing the duration. Assume you are allowed to complete at most `1` transaction. A transaction is defined as buying and then selling one share of the stock. You can only sell stocks on or after `d` days from the buy date. Return _the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`_.","solution":"def max_profit(prices, d): Calculate the maximum profit from buying and selling stocks where sale happens only after d days from buy date. prices: List[int] - list of stock prices. d: int - duration (number of days after buying stock). Return: int - maximum profit. if len(prices) < d + 1: return 0 max_profit = 0 for i in range(len(prices) - d): for j in range(i + d, len(prices)): max_profit = max(max_profit, prices[j] - prices[i]) return max_profit"},{"question":"Given a string `s` consisting of lowercase alphabets, you need to **reorganize** the string such that no two adjacent characters are the same. If it is possible to reorganize the string in this way, return any possible reorganized string. Otherwise, return an empty string.","solution":"from collections import Counter import heapq def reorganize_string(s): Reorganizes the string `s` so that no two adjacent characters are the same. If it is not possible, returns an empty string. if not s: return \\"\\" counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_char = \\"\\" prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 reorganized_string = \\"\\".join(result) if len(reorganized_string) != len(s): return \\"\\" return reorganized_string"},{"question":"You are given an array of integers `nums` representing the values of nodes in a circular doubly-linked list, where each node has pointers to the previous and next nodes. The list does not have a defined starting node. Write a function to find the node with the maximum value in the circular list and return its value.","solution":"class ListNode: def __init__(self, value=0): self.value = value self.next = None self.prev = None def find_max_in_circular_list(node): Given a node in a circular doubly linked list, find and return the node with the maximum value. if not node: return None # If the node is None, return None as there is no list to traverse max_value = node.value current = node.next while current != node: if current.value > max_value: max_value = current.value current = current.next return max_value"},{"question":"You are given a binary tree with `n` nodes, each node having a value. Your task is to find the maximum sum of nodes in a subtree. A subtree is defined as any node and all its descendants in the binary tree. Return the maximum sum of nodes in any subtree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_subtree_sum(root): Returns the maximum sum of nodes in any subtree of the given binary tree. def helper(node): if not node: return 0, float(\'-inf\') left_sum, left_max_sum = helper(node.left) right_sum, right_max_sum = helper(node.right) current_sum = node.val + left_sum + right_sum current_max_sum = max(left_max_sum, right_max_sum, current_sum) return current_sum, current_max_sum _, max_sum = helper(root) return max_sum"},{"question":"You are given a 0-indexed integer array `salaries` where each element represents the salary of an employee. Calculate the total number of employees whose salary is above the median salary of the array. Note that the median is the middle element when the array is sorted in non-decreasing order. If the number of elements is even, the median is the average of the two middle elements. Return _the total number of employees whose salary is above the median salary_.","solution":"def count_above_median(salaries): Returns the number of employees whose salary is above the median salary. :param salaries: List[int] - A list of salaries of employees. :return: int - The number of employees whose salary is above the median. salaries.sort() n = len(salaries) # Calculate the median if n % 2 == 0: median = (salaries[n // 2 - 1] + salaries[n // 2]) / 2 else: median = salaries[n // 2] # Count the number of employees with salary above the median count = sum(1 for salary in salaries if salary > median) return count"},{"question":"Given a string `s` which represents a binary number, determine if it is a multiple of 3. Write a function `isMultipleOfThree(s: str) -> bool` which returns `True` if the binary number represented by the string `s` is a multiple of 3, otherwise return `False`. Note that the string `s` will only contain characters \'0\' and \'1\' and will have at least one character.","solution":"def isMultipleOfThree(s: str) -> bool: Determines if the binary number represented by the string s is a multiple of 3. Args: s (str): A string representation of a binary number. Returns: bool: True if the binary number is a multiple of 3, otherwise False. # Convert the binary string to an integer num = int(s, 2) # Check if the number is divisible by 3 return num % 3 == 0"},{"question":"You are given an integer array `nums` and an integer `k`. Find the maximum sum of a non-empty subarray of `nums` with at most `k` elements. A subarray is a contiguous portion of an array. Implement the function `maxSumWithKElements` which takes the integer array `nums` and the integer `k` as input parameters and returns the maximum sum. ```python def maxSumWithKElements(nums: List[int], k: int) -> int: # Your code here ```","solution":"def maxSumWithKElements(nums: list[int], k: int) -> int: Finds the maximum sum of a non-empty subarray of nums with at most k elements. n = len(nums) if not nums or k < 1: return 0 max_sum = float(\'-inf\') for i in range(n): current_sum = 0 for j in range(i, min(i + k, n)): current_sum += nums[j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to perform queries on this string to determine the count of a specific character within a given substring. Implement the `StringQuery` class: - `StringQuery(String s)` Initializes the object with the string `s`. - `int queryCharCount(int left, int right, char target)` Returns the count of the character `target` in the substring of `s` from index `left` to index `right` (inclusive). Ensure that the class handles multiple queries efficiently.","solution":"class StringQuery: def __init__(self, s): Initialize the object with the string s. Precompute frequency of each character at each position. self.s = s self.prefix_counts = {} for char in set(s): self.prefix_counts[char] = [0] * (len(s) + 1) for i, char in enumerate(s): for key in self.prefix_counts: self.prefix_counts[key][i + 1] = self.prefix_counts[key][i] self.prefix_counts[char][i + 1] += 1 def queryCharCount(self, left, right, target): Return the count of the character target in the substring of s from index left to index right (inclusive). if target not in self.prefix_counts: return 0 return self.prefix_counts[target][right + 1] - self.prefix_counts[target][left]"},{"question":"You are given a list of `n` tasks, where each task has a start time and an end time represented by two arrays, `startTime` and `endTime` respectively. A task `i` starts at `startTime[i]` and ends at `endTime[i]`. Each task also has a positive integer `profit[i]` associated with it. You can only select non-overlapping tasks. Return _the maximum profit you can achieve by selecting a subset of non-overlapping tasks._","solution":"def maxProfit(startTime, endTime, profit): Returns the maximum profit by selecting a subset of non-overlapping tasks. n = len(startTime) tasks = sorted(zip(startTime, endTime, profit), key=lambda x: x[1]) # Sorting tasks by end time dp = [0] * (n + 1) end_times = [task[1] for task in tasks] def latestNonConflict(i): lo, hi = 0, i - 1 while lo <= hi: mid = (lo + hi) // 2 if tasks[mid][1] <= tasks[i][0]: if tasks[mid + 1][1] <= tasks[i][0]: lo = mid + 1 else: return mid else: hi = mid - 1 return -1 for i in range(1, n + 1): include_profit = tasks[i - 1][2] l = latestNonConflict(i - 1) if l != -1: include_profit += dp[l + 1] dp[i] = max(dp[i - 1], include_profit) return dp[n]"},{"question":"You are given an array of integers `arr` representing the heights of students standing in a line, and a value `d` representing the maximum distance at which students can form special groups. A group of students is considered special if the height difference between the tallest and shortest student in the group is no more than d. Find the maximum number of special groups you can form from the given array, where each student belongs to exactly one group. Return _the maximum number of special groups that can be formed._","solution":"def max_special_groups(arr, d): arr.sort() # Sort the array to facilitate grouping n = len(arr) i = 0 groups = 0 while i < n: start = i while i < n and arr[i] - arr[start] <= d: i += 1 groups += 1 return groups"},{"question":"Given a string `s` and an integer `k`, you need to split the string into substrings such that each substring contains at most `k` unique characters. Return the maximum number of such substrings you can obtain. A substring is defined as a contiguous sequence of characters in the string.","solution":"def max_substrings_with_k_unique_chars(s, k): Returns the maximum number of substrings with at most k unique characters. if k == 0: return 0 n = len(s) start = 0 end = 0 max_substrings = 0 unique_chars = {} while end < n: unique_chars[s[end]] = unique_chars.get(s[end], 0) + 1 while len(unique_chars) > k: unique_chars[s[start]] -= 1 if unique_chars[s[start]] == 0: del unique_chars[s[start]] start += 1 max_substrings = max(max_substrings, end - start + 1) end += 1 return max_substrings"},{"question":"You are given two strings, `s` and `t`, both of which are of the same length `n`. You need to transform string `s` into string `t` using the following operation: choose any character in `s` and replace it with any other character. This operation can be performed any number of times. Firstly, determine if it is possible to transform `s` into `t`. If it is possible, return the **minimum number of operations** required to transform `s` into `t`. If it is not possible, return `-1`.","solution":"def min_operations_to_transform(s, t): Determines if it\'s possible to transform string s into string t using minimum number of operations where each operation involves replacing a character in s with any other character. Returns the minimum number of operations if possible, otherwise returns -1. if len(s) != len(t): return -1 operations_needed = 0 for i in range(len(s)): if s[i] != t[i]: operations_needed += 1 return operations_needed"},{"question":"You are given a list of `logs`, where each log is a string with the format \\"timestamp action\\" and each action is either \\"start\\" or \\"end\\". Each log represents an event of a process starting or ending, with the timestamp indicating when the event happened. The logs are unordered. Write a function that takes `logs` and returns a list of tuples representing the intervals during which the process was active. Each tuple in the return list should be of the form (start_timestamp, end_timestamp), and the intervals should be sorted by the start timestamp.","solution":"def get_active_intervals(logs): Given a list of logs, each in the format \\"timestamp action\\", return a list of intervals during which the process was active. Args: logs (list of str): List of logs, e.g. [\\"1 start\\", \\"3 end\\", \\"2 start\\", \\"4 end\\"] Returns: list of tuples: List of tuples representing the intervals (start_timestamp, end_timestamp) # Parse logs into timestamp-action pairs parsed_logs = [] for log in logs: timestamp, action = log.split() parsed_logs.append((int(timestamp), action)) # Sort logs by timestamp parsed_logs.sort() # Find intervals intervals = [] stack = [] for timestamp, action in parsed_logs: if action == \\"start\\": stack.append(timestamp) elif action == \\"end\\": if stack: start_time = stack.pop() intervals.append((start_time, timestamp)) return intervals"},{"question":"You are given a **0-indexed** integer array `experience` where `experience[i]` represents the number of years of experience the ith employee has. You are also given an integer `threshold` and an integer `X`. For a team of employees to be considered experienced, the average experience of its members must be at least `threshold` years. Find and return the number of contiguous subarrays of size `X` where the subarray\'s average experience is greater than or equal to the `threshold`.","solution":"def number_of_experienced_teams(experience, X, threshold): Returns the number of contiguous subarrays of size X where the subarray\'s average experience is greater than or equal to the threshold. n = len(experience) required_sum = threshold * X count = 0 # Calculate sum of first window of size X current_sum = sum(experience[:X]) # Check if the first window meets the condition if current_sum >= required_sum: count += 1 # Slide the window across the array for i in range(1, n - X + 1): current_sum = current_sum - experience[i - 1] + experience[i + X - 1] if current_sum >= required_sum: count += 1 return count"},{"question":"Given a list of strings `words`, determine if all the strings in the list can form a circle. A circle is formed if the last character of each string matches the first character of the next string in the list. For instance, given the list `[\\"abc\\", \\"cde\\", \\"efa\\", \\"a\\"]`, the strings can form a circle as follows: `\\"abc\\"` ends with `\'c\'`, `\\"cde\\"` ends with `\'e\'`, `\\"efa\\"` ends with `\'a\'`, and `\\"a\\"` ends with `\'a\'`, forming a circular sequence. Return `True` if such a circle can be formed, otherwise return `False`.","solution":"from collections import defaultdict def can_form_circle(words): Determines if the given list of words can form a circle. Each word\'s last character must match the first character of the next word, and it should form a cycle. if not words: return False # Create graph structures graph = defaultdict(list) in_degree = defaultdict(int) out_degree = defaultdict(int) # Build the graph and track in-degrees and out-degrees for word in words: first, last = word[0], word[-1] graph[first].append(last) out_degree[first] += 1 in_degree[last] += 1 # Check if in-degrees == out-degrees for each character for char in set(in_degree.keys()).union(out_degree.keys()): if in_degree[char] != out_degree[char]: return False # Helper function - Depth First Search def dfs(char, visited): for neighbor in graph[char]: if neighbor not in visited: visited.add(neighbor) dfs(neighbor, visited) # Start DFS from the first character of the first word start_char = words[0][0] visited = set([start_char]) dfs(start_char, visited) # Check if every character in the graph is visited unique_chars = set(in_degree.keys()).union(out_degree.keys()) return visited == unique_chars"},{"question":"Given an encoded string, return its decoded string. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer. You may assume that the input string is always valid, containing only digits, square brackets, and lowercase letters. For example: - `s = \\"3[a]2[bc]\\"` returns `\\"aaabcbc\\"`. - `s = \\"3[a2[c]]\\"` returns `\\"accaccacc\\"`. - `s = \\"2[abc]3[cd]ef\\"` returns `\\"abcabccdcdcdef\\"`.","solution":"def decode_string(s): Decodes the encoded string s according to the rule k[encoded_string]. Args: s (str): The encoded string. Returns: str: The decoded string. stack = [] cur_num = 0 cur_string = \'\' for char in s: if char.isdigit(): cur_num = cur_num * 10 + int(char) elif char == \'[\': stack.append((cur_string, cur_num)) cur_string = \'\' cur_num = 0 elif char == \']\': prev_string, num = stack.pop() cur_string = prev_string + cur_string * num else: cur_string += char return cur_string"},{"question":"You are given a list of `logs` where each log is a string with the format `\\"id1:id2:timestamp\\"`. Each log represents a communication event between two users identified by `id1` and `id2` at a certain `timestamp`. Return _an integer representing the number of unique users who have communicated with at least one other user_. A user is considered to have communicated with another user if there is at least one log involving both their ids.","solution":"def count_unique_users(logs): Returns the number of unique users who have communicated with at least one other user. Parameters: logs (list): A list of strings where each string represents a log in the format \\"id1:id2:timestamp\\". Returns: int: The number of unique users. unique_users = set() for log in logs: id1, id2, _ = log.split(\':\') unique_users.add(id1) unique_users.add(id2) return len(unique_users)"},{"question":"You are given a sorted integer array `arr` which is rotated at an unknown pivot index. For example, `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`. Your task is to write a function that takes this sorted, rotated array and a target value, and returns the index of the target value if it is present in the array. If it is not present, return `-1`. Your algorithm should have a runtime complexity of O(log n). Can you achieve this?","solution":"def search_rotated_array(arr, target): Searches for a target value in a sorted and rotated array. :param arr: List[int] - A list of integers sorted and rotated at an unknown pivot. :param target: int - The target value to find in the list. :return: int - The index of the target value or -1 if not found. if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which part is sorted if arr[left] <= arr[mid]: # Left part is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Given a string `expression` representing a **mathematical expression** containing only non-negative integers, the operators `+`, `-`, and `*`, and empty spaces, implement a function to evaluate the expression and return its result. The valid operators have the **usual precedence**: multiplication has higher precedence than addition and subtraction. Assume the input is always a valid expression. Note that the `expression` may include multiple digits for a number (e.g., `12` instead of `1` and `2`), and it is guaranteed that no overflow will occur in the result.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and the operators +, -, *. :param expression: str, a string containing the mathematical expression :return: int, the result of the evaluated expression def apply_operator(operators, values): Apply the operator on top of stack to the top two elements in the values stack operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) # To hold operators and operands operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] in \'0123456789\': num = 0 while i < len(expression) and expression[i] in \'0123456789\': num = num * 10 + int(expression[i]) i += 1 values.append(num) i -= 1 # Correct for extra increment in the previous loop elif expression[i] in \'+-*\': while (operators and operators[-1] in \'*\'): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"Given a rucksack containing items, each with a weight and a value, find the maximum value achievable without exceeding a given weight limit. You are provided with an integer `maxWeight` representing the maximum weight the rucksack can hold, an integer array `weights` representing the weights of each item, and an integer array `values` representing the values of each item. Return the maximum value you can achieve within the weight constraint. Each item can only be included once, and you cannot divide the item.","solution":"def knapsack(maxWeight, weights, values): Returns the maximum value achievable without exceeding the weight limit using the knapsack algorithm. :param maxWeight: Maximum weight the rucksack can hold :param weights: List of weights of the items :param values: List of values of the items :return: Maximum value attainable within the weight constraint n = len(weights) dp = [[0] * (maxWeight + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(maxWeight + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][maxWeight]"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to return _the number of **distinct pairs** of numbers in the array that add up to the `target` sum_. Note that each pair should be counted only once, regardless of the order of the numbers in the pair.","solution":"def count_pairs_with_sum(nums, target): Returns the number of distinct pairs in nums that add up to the target sum. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"Given an array of integers `nums`, you need to find the **maximum product** of three numbers in the array. Return the maximum product you can get. * For example, given the array `nums = [-10, -10, 5, 2]`, the maximum product would be `500` since `-10 * -10 * 5` equals `500`. Return `500`. The array will have at least three integers.","solution":"def maximum_product_of_three_numbers(nums): Returns the maximum product of three numbers in the array. :param nums: List[int] - Array of integers :return: int - Maximum product of three numbers from the array # Sort the array nums.sort() # The maximum product can either be from the three largest numbers or from the two smallest numbers (which can be negative) and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"You are given a string `s` representing a series of obstacle heights on a certain path, where each character is a digit representing the height of the obstacle in that position. You need to determine the maximum number of consecutive positions the character can jump to without exceeding a specified maximum jump height `j`. Note that the character starts at the first position and can only move forward. Return _the maximum number of consecutive positions that can be jumped to under the given constraints._","solution":"def max_consecutive_jump_positions(s, j): max_consecutive = 0 current_consecutive = 0 for height in s: if int(height) <= j: current_consecutive += 1 if current_consecutive > max_consecutive: max_consecutive = current_consecutive else: current_consecutive = 0 return max_consecutive"},{"question":"You are given a list of words and a list of characters called `allowed`. A word is considered consistent if all its characters are present in the `allowed` list. Return _the number of consistent words_. Example: - If `allowed = \\"ab\\"` and `words = [\\"ad\\",\\"bd\\",\\"aaab\\",\\"baa\\",\\"badab\\"]`, then the consistent words are `\\"aaab\\"` and `\\"baa\\"`, so the output should be `2`. Note: - The input list of words and the allowed characters are case-sensitive. - The allowed characters may be in any order and without duplicates.","solution":"def count_consistent_strings(allowed, words): Returns the number of consistent strings from the list of words. A word is considered consistent if all characters in the word are in the allowed characters list. allowed_set = set(allowed) consistent_word_count = 0 for word in words: if all(char in allowed_set for char in word): consistent_word_count += 1 return consistent_word_count"},{"question":"You are given a **0-indexed** array of positive integers `nums`. The array represents the profit from selling cookies on different days. You want to maximize your profit by choosing a subarray that consists of consecutive days, but you can only select at most one subarray for the entire selection. Return _the maximum possible profit that can be obtained from such a selection_. For example, given `nums = [3, -2, 5, -1, 6, -3]`, the maximum subarray could be `[3, -2, 5, -1, 6]`, which sums up to `11`. Hence the output should be `11`.","solution":"def max_profit(nums): Returns the maximum possible profit by choosing a subarray max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a list of integers `arr` representing the heights of towers. You need to perform a series of operations to reduce the height differences between the tallest and the shortest towers. In each operation, you can either increase the height of any tower by 1 or decrease the height of any tower by 1. Return the minimum number of operations required so that the height difference between the tallest and the shortest tower is no more than `k`.","solution":"def min_operations(arr, k): Returns the minimum number of operations required so that the height difference between the tallest and the shortest tower is no more than k. Parameters: arr (list): List of integers representing the heights of towers. k (int): Maximum allowed difference between the tallest and shortest tower. Returns: int: Minimum number of operations required. min_height = min(arr) max_height = max(arr) diff = max_height - min_height if diff <= k: return 0 return diff - k"},{"question":"You are given a list of `n` integers where each integer represents the amount of money in a house. Each house is arranged linearly and you cannot rob two adjacent houses because the police will be alerted. Write a function to determine the maximum amount of money you can rob tonight without alerting the police. Return the maximum amount of money you can rob.","solution":"def rob(nums): Determines the maximum amount of money you can rob without alerting the police. :param nums: List[int] - List of integers where each integer represents the money in a house :return: int - Maximum amount of money that can be robbed if not nums: return 0 if len(nums) == 1: return nums[0] prev1 = 0 prev2 = 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"Implement a class called `SparseVector` to represent a sparse vector, which is a vector that has many zero elements. The class should include the following methods: - `SparseVector(int[] nums)`: Initializes the object with the vector `nums`. - `int dotProduct(SparseVector vec)`: Returns the dot product of the current `SparseVector` instance and another `SparseVector` instance. A sparse vector dot product is calculated as the sum of the products of corresponding elements with the same index: [ text{dotProduct}(vec1, vec2) = sum_{i=0}^{n-1} (vec1[i] times vec2[i]) ] To optimize efficiency, store only the non-zero elements for the vector. Example: ```python v1 = SparseVector([1, 0, 0, 2, 3]) v2 = SparseVector([0, 3, 0, 4, 0]) dotProduct = v1.dotProduct(v2) # Output: 8 (because 2*4 + 3*0 = 8) ```","solution":"class SparseVector: def __init__(self, nums): Initializes the object with the vector `nums`. self.non_zero_elements = {i: num for i, num in enumerate(nums) if num != 0} def dotProduct(self, vec): Returns the dot product of the current SparseVector instance and another SparseVector instance. result = 0 for i, num in self.non_zero_elements.items(): if i in vec.non_zero_elements: result += num * vec.non_zero_elements[i] return result"},{"question":"You are given an array of integers `arr` and an integer `k`. An operation is defined as removing one element from `arr` and appending it at the end of the array. You want to determine the minimum number of operations required to make the first `k` elements of `arr` all distinct. If it is not possible, return `-1`. Return the minimum number of operations needed to achieve this goal.","solution":"def min_operations_to_make_k_distinct(arr, k): Calculates the minimum number of operations required to make the first `k` elements of `arr` all distinct. An operation is defined as removing one element from `arr` and appending it at the end of the array. :param arr: List[int] - The input array of integers. :param k: int - The number of elements from the start of the array that should be distinct. :return: int - The minimum number of operations required, or -1 if it is not possible. if k > len(arr): return -1 from collections import defaultdict, deque seen = set() need = deque() for i in range(k): if arr[i] in seen: need.append(arr[i]) seen.add(arr[i]) if len(need) == 0: return 0 for i in range(k, len(arr)): if arr[i] not in seen: seen.add(arr[i]) need.popleft() if len(need) == 0: return i - k + 1 return -1"},{"question":"A company wants to organize a team-building activity involving `n` employees. They have a list of pairs of employees that do not get along with each other. The goal is to split the employees into two distinct teams such that no pair of employees who do not get along are on the same team. You are given an integer `n`, representing the number of employees, and an array `dislikes` where `dislikes[i] = [a_i, b_i]` represents that employees `a_i` and `b_i` do not get along. Return `true` if it is possible to split all the employees into two teams in such a way, or `false` otherwise.","solution":"from collections import defaultdict, deque def can_be_split(n, dislikes): Determines if it\'s possible to split `n` employees into two teams such that no pair of employees who do not get along are on the same team. Args: - n (int): The number of employees. - dislikes (List[List[int]]): List of pairs of employees that do not get along. Returns: - bool: True if it is possible to split the employees, False otherwise. def bfs(source): queue = deque([source]) color[source] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in color: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True graph = defaultdict(list) for a, b in dislikes: graph[a].append(b) graph[b].append(a) color = {} for node in range(1, n+1): if node not in color: if not bfs(node): return False return True"},{"question":"Given a list of strings, where each string represents a file path, return a list of duplicate file paths. Each file path string contains the directory path and the file name with its content in parentheses. A file is a duplicate if it has the same content as another file. The file paths will be in the format \\"root/d1/d2/.../dn filename(content)\\". For example, given: ``` [ \\"root/a 1.txt(abcd) 2.txt(efgh)\\", \\"root/c 3.txt(abcd)\\", \\"root/c/d 4.txt(efgh)\\", \\"root 4.txt(efgh)\\" ] ``` The output should be: ``` [ [\\"root/a/1.txt\\", \\"root/c/3.txt\\"], [\\"root/a/2.txt\\", \\"root/c/d/4.txt\\", \\"root/4.txt\\"] ] ```","solution":"from collections import defaultdict def find_duplicate(paths): Given a list of strings, where each string represents a file path, returns a list of duplicate file paths. Args: - paths (List[str]): List of file path strings. Returns: - List[List[str]]: List of lists of duplicate file paths. content_to_paths = defaultdict(list) for path in paths: parts = path.split() root = parts[0] for file in parts[1:]: name, content = file.split(\'(\') content = content[:-1] # remove the closing parenthesis full_path = f\\"{root}/{name}\\" content_to_paths[content].append(full_path) result = [group for group in content_to_paths.values() if len(group) > 1] return result"},{"question":"Given a list of `n` integers, write a function to determine if it is possible to reorder the list in such a way that for every element `x` in the list, there is another element `y` in the list such that `y = 2x`. If such an ordering exists, return `true`; otherwise, return `false`. You may assume all elements in the list are unique.","solution":"from collections import Counter def can_reorder_doubled(arr): Determines if it\'s possible to reorder the list so that each pair of elements (2x, x) can be formed. count = Counter(arr) for x in sorted(count, key=abs): if count[x * 2] < count[x]: return False count[x * 2] -= count[x] return True"},{"question":"Given a `rows x cols` integer matrix `matrix`, return the number of \\"special\\" positions in the matrix. A position `(i, j)` is called \\"special\\" if `matrix[i][j]` is `1` and all the elements in the `i-th` row and the `j-th` column are `0` except for `matrix[i][j]`.","solution":"def numSpecial(matrix): Return the number of special positions in the matrix. A position (i, j) is called \\"special\\" if matrix[i][j] is 1 and all the elements in the i-th row and j-th column are 0 except for matrix[i][j]. rows = len(matrix) cols = len(matrix[0]) row_count = [sum(row) for row in matrix] col_count = [sum(matrix[r][c] for r in range(rows)) for c in range(cols)] special_count = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1 and row_count[i] == 1 and col_count[j] == 1: special_count += 1 return special_count"},{"question":"You are given a string `s` which consists of lowercase letters and a non-empty string `p` which also consists of lowercase letters. You need to find all the start indices of `p`\'s anagrams in `s`. The order of output does not matter, and the returned result should not contain duplicate indices. Return an array of all starting indices where the substring of `s` is an anagram of `p`.","solution":"def find_anagrams(s, p): from collections import Counter p_counter = Counter(p) s_counter = Counter(s[:len(p) - 1]) result = [] for i in range(len(p) - 1, len(s)): s_counter[s[i]] += 1 start_index = i - len(p) + 1 if s_counter == p_counter: result.append(start_index) s_counter[s[start_index]] -= 1 if s_counter[s[start_index]] == 0: del s_counter[s[start_index]] return result"},{"question":"Write a function `isMonotonic(nums)` that takes an array of integers `nums` and returns `true` if and only if the array is monotonic. An array is monotonic if it is either entirely non-increasing or non-decreasing.","solution":"def isMonotonic(nums): Returns true if the array is monotonic (either entirely non-increasing or non-decreasing). if len(nums) <= 2: return True increasing = decreasing = True for i in range(1, len(nums)): if nums[i] > nums[i - 1]: decreasing = False if nums[i] < nums[i - 1]: increasing = False return increasing or decreasing"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of only `0`s (empty cell) and `1`s (occupied cell). An island is a maximal 4-directionally connected group of `1`s. Write a function to find the smallest island in `grid`. Return the size of the smallest island. If there is no island, return 0.","solution":"def find_smallest_island(grid): if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark as visited size = 1 size += dfs(x - 1, y) size += dfs(x + 1, y) size += dfs(x, y - 1) size += dfs(x, y + 1) return size smallest_island_size = float(\'inf\') found_island = False for i in range(len(grid)): for j in range(len(grid[i])): if grid[i][j] == 1: found_island = True island_size = dfs(i, j) if island_size > 0: smallest_island_size = min(smallest_island_size, island_size) return smallest_island_size if found_island else 0"},{"question":"Given a `root` of a binary tree, each node in the tree has a unique value. You are to choose `k` nodes from the tree such that the sum of their values is minimized and the chosen nodes cover all levels of the tree. A node is said to cover a level if there exists a path from the node to any other node at that level without leaving the tree. Each node can be counted towards covering one or more levels. Return the minimum sum of the values of the selected `k` nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def dfs(node, depth, nodes_by_level): if not node: return if depth in nodes_by_level: nodes_by_level[depth].append(node.val) else: nodes_by_level[depth] = [node.val] dfs(node.left, depth + 1, nodes_by_level) dfs(node.right, depth + 1, nodes_by_level) def min_sum_covering_levels(root, k): Return the minimum sum of values of k nodes that cover all levels. if not root: return 0 nodes_by_level = {} dfs(root, 0, nodes_by_level) all_nodes = sorted([node for level in nodes_by_level.values() for node in level]) return sum(all_nodes[:k])"},{"question":"You are given an array `arr` of integers and an integer `x`. In one operation, you can replace any element in the array with the sum of that element and `x`. Your goal is to make all elements in the array equal to the same value using the minimum number of operations. Return the minimum number of operations required to achieve this.","solution":"def min_operations_to_make_equal(arr, x): Returns the minimum number of operations required to make all elements in the array equal. Parameters: arr: List[int] - the input array of integers x: int - the value to be added to any element in one operation Returns: int - the minimum number of operations required # To make all elements equal, the difference between any two elements should be a multiple of x. # Calculate the minimum operations required to achieve this. diff_set = set() for i in range(1, len(arr)): diff_set.add(abs(arr[i] - arr[0]) % x) if len(diff_set) == 1: return 0 else: return -1 # Indicates that it\'s not possible to make all elements equal"},{"question":"You are given a grid representing a map where each cell can be either water (\'0\') or land (\'1\'). An island is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write an algorithm to find the number of islands. The grid is represented by a 2D array, where \'1\' represents land, and \'0\' represents water. Two lands are connected if they are adjacent horizontally or vertically. For example: ``` Input: grid = [ [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'0\',\'0\',\'1\',\'0\',\'0\'], [\'0\',\'0\',\'0\',\'1\',\'1\'] ] Output: 3 ```","solution":"def numIslands(grid): if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' dfs(grid, i-1, j) dfs(grid, i+1, j) dfs(grid, i, j-1) dfs(grid, i, j+1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': count += 1 dfs(grid, i, j) return count"},{"question":"You are given an array `events` where `events[i] = [startDayi, endDayi]`. Each event represents a meeting that starts on `startDayi` and ends on `endDayi`, both inclusive. You can attend only one event per day. Determine the maximum number of events you can attend. Return _the maximum number of events you can attend_.","solution":"import heapq def maxEvents(events): Returns the maximum number of events that can be attended. :param events: List[List[int]] where events[i] = [startDayi, endDayi] :return: int events.sort(key=lambda x: x[0]) max_events = 0 min_heap = [] day = 0 i = 0 n = len(events) while i < n or min_heap: if not min_heap: day = events[i][0] while i < n and events[i][0] <= day: heapq.heappush(min_heap, events[i][1]) i += 1 if min_heap: heapq.heappop(min_heap) max_events += 1 day += 1 while min_heap and min_heap[0] < day: heapq.heappop(min_heap) return max_events"},{"question":"Given an integer `n`, representing the number of cities numbered from `0` to `n-1`, and a 2D array `roads` where `roads[i] = [city1, city2, distance]` represents a bidirectional road between `city1` and `city2` with a distance of `distance`. Suppose an additional road can be built that connects any two cities directly, with any arbitrary positive distance. Return the shortest distance required to build a new road such that the network becomes fully connected, meaning there exists a path between any two cities. If the network is already fully connected, return `0`. If it\'s impossible to connect all cities with one additional road, return `-1`.","solution":"def find_shortest_new_road(n, roads): Given a number of cities and existing roads, returns the shortest distance required to build a new road such that all cities are connected. Returns 0 if already connected and -1 if no single new road can connect all cities. from heapq import heappop, heappush import itertools # Disjoint Set Union (DSU)/Union-Find structure for detecting connected components class DSU: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): xr = self.find(x) yr = self.find(y) if xr == yr: return False if self.rank[xr] < self.rank[yr]: xr, yr = yr, xr self.parent[yr] = xr if self.rank[xr] == self.rank[yr]: self.rank[xr] += 1 return True if n == 1: return 0 dsu = DSU(n) for city1, city2, _ in roads: dsu.union(city1, city2) all_components = {} for city in range(n): root = dsu.find(city) if root not in all_components: all_components[root] = [] all_components[root].append(city) if len(all_components) == 1: return 0 # Calculate shortest distance between different components if len(all_components) > 2: return -1 # Get all nodes that are in each component comp1 = list(all_components.values())[0] comp2 = list(all_components.values())[1] min_distance = float(\'inf\') for u, v in itertools.product(comp1, comp2): min_distance = min(min_distance, abs(u - v)) return min_distance"},{"question":"You are given a list of `events`, where each event is represented by a pair of integers `[start_time, end_time]`. Each event covers the time period from `start_time` to `end_time` (inclusive). You are also given an integer `duration`, representing the maximum duration you can attend events in total. Your goal is to attend a subset of events such that the total duration attended does not exceed `duration`. Return _the **maximum number of non-overlapping events** you can attend from the provided list while respecting the total duration constraint_. Note: Two events overlap if their time periods intersect. For example, events `[1, 5]` and `[5, 10]` are overlapping because they share time point `5`. Events `[1, 4]` and `[5, 8]` are non-overlapping.","solution":"def max_non_overlapping_events(events, duration): Returns the maximum number of non-overlapping events that can be attended, without exceeding the given duration, from the provided list of events. Args: events (List[List[int]]): List of events where each event is represented by [start_time, end_time]. duration (int): The maximum total duration that can be attended. Returns: int: The maximum number of non-overlapping events that can be attended. # Sort events by end time to use a greedy approach events.sort(key=lambda x: x[1]) total_duration = 0 count = 0 last_end_time = -1 for start, end in events: event_duration = end - start + 1 if start > last_end_time and total_duration + event_duration <= duration: # Attend this event total_duration += event_duration last_end_time = end count += 1 return count"},{"question":"You are given a list of strings `words` where each string consists of lowercase English letters and represents a word. Each word in the list has a unique starting letter that determines its position in the alphabetical order. You need to sort the words alphabetically based on their unique starting letter, while maintaining the original order of words with the same starting letter. Return the list of words sorted by the unique starting letter. For instance, if `words = [\\"apple\\", \\"banana\\", \\"apricot\\", \\"blueberry\\", \\"cherry\\"]`, a possible output is `[\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\"]` as \'a\' comes before \'b\' and \'c\'.","solution":"def sort_by_starting_letter(words): Sort a list of words based on their unique starting letter. Parameters: words (list of str): The list of words to be sorted. Returns: list of str: The sorted list of words. return sorted(words, key=lambda word: word[0])"},{"question":"You are given a string `s` consisting of lowercase alphabets. In one operation, you can perform the following: - Choose a character `c` from the string `s`. - Remove all occurrences of the character `c` from the string. Your goal is to determine the minimum number of operations required to make the string empty. Return _the minimum number of operations required to make the string_ `s` _empty_.","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations required to make the string empty. Each operation consists of removing all occurrences of a chosen character. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: int: The minimum number of operations required to make the string empty. # Convert the input string to a set of unique characters unique_characters = set(s) # The minimum number of operations is equal to the number of unique characters in the string return len(unique_characters)"},{"question":"You are given a binary tree with `n` nodes. Each node in the tree has a unique value that ranges from `1` to `n`. You are also given a list of `queries` where each query represents a node value in the tree. For each query, return the deepest node value in the subtree rooted at the queried node. If there are multiple nodes at the deepest level, return the one with the smallest value. The depth of a node is defined as the number of edges from the root to the node. Return an array of integers where each integer corresponds to the result of each query.","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_node(root: TreeNode, queries): def bfs_deepest_node(subtree_root): queue = deque([(subtree_root, 0)]) max_depth = -1 deepest_nodes = [] while queue: current_node, current_depth = queue.popleft() if current_depth > max_depth: max_depth = current_depth deepest_nodes = [current_node.val] elif current_depth == max_depth: deepest_nodes.append(current_node.val) if current_node.left: queue.append((current_node.left, current_depth + 1)) if current_node.right: queue.append((current_node.right, current_depth + 1)) return min(deepest_nodes) node_map = {} def build_map(node): if node: node_map[node.val] = node build_map(node.left) build_map(node.right) build_map(root) result = [] for q in queries: subtree_root = node_map[q] result.append(bfs_deepest_node(subtree_root)) return result"},{"question":"You are given a **0-indexed** integer array `strength` of length `n`, where `strength[i]` represents the strength of the `i-th` soldier. An army is considered **balanced** if and only if the strength of any two soldiers in the army does not differ by more than 1. Return _the minimum number of soldiers that need to be either added or removed to make the army **balanced**_.","solution":"def min_operations_to_balance_army(strength): Returns the minimum number of soldiers that need to be either added or removed to make the army balanced. :param strength: List[int] : A list of integers representing the strength of each soldier :return: int : The minimum number of operations required to balance the army from collections import Counter strength_counter = Counter(strength) max_count = 0 for key in strength_counter: current_count = strength_counter[key] + strength_counter.get(key - 1, 0) + strength_counter.get(key + 1, 0) max_count = max(max_count, current_count) return len(strength) - max_count"},{"question":"You are given a list of non-negative integers `nums` that represents the amount of time a certain task takes to complete. You are also given an integer `k` which represents the number of workers available to complete these tasks. A worker can only work on one task at a time. Your goal is to assign the tasks to the workers such that the maximum time any worker spends on their assigned tasks is minimized. Return the minimized maximum time. Example: Input: `nums = [3, 2, 3], k = 3` Output: `3` Explanation: Each worker is assigned one task: worker 1 gets task 3, worker 2 gets task 2, and worker 3 gets task 3. The maximum time any worker spends is 3.","solution":"def minimize_max_time(nums, k): def can_complete_in_time(limit): workers = 1 current_time = 0 for task in nums: if current_time + task <= limit: current_time += task else: workers += 1 current_time = task if workers > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_complete_in_time(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array of integers `arr` of size `n` and an integer `x`. Your task is to determine if there exists a **subsequence** of `arr` such that the sum of its elements is exactly `x`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return `true` if such a subsequence exists, or `false` otherwise.","solution":"def does_subsequence_sum_exist(arr, x): Determines if there exists a subsequence in arr such that the sum of its elements equals x. n = len(arr) dp = [False] * (x + 1) dp[0] = True for num in arr: for j in range(x, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[x]"},{"question":"You are given a 2D grid of characters representing a word search puzzle and a string `word`. The goal is to determine if the `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. The function should return `True` if the word exists in the grid, and `False` otherwise. The grid is represented as a list of lists of characters and the word is a string of length between 1 and 10^3. The grid dimensions range from 1x1 to 100x100. Write a function that implements this logic and returns the correct boolean value.","solution":"def exist(board, word): rows, cols = len(board), len(board[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[i]: return False tmp, board[r][c] = board[r][c], \\"#\\" # mark as visited found = dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1) board[r][c] = tmp # unmark visited return found for row in range(rows): for col in range(cols): if dfs(row, col, 0): return True return False"},{"question":"You are given an array of integers `heights` representing the heights of a lineup of people standing in a queue. You need to write a function that returns an array of the form `[a, b]`, where `a` is the number of people who have a clear view of the stage, and `b` is the total number of people who do not have a clear view. A person has a clear view of the stage if there is no one taller than them standing to their left in the queue. For all the people who do not have a clear view of the stage, they need to know the height of the first person standing to their left who is taller than them. Return the result in a tuple as described.","solution":"def view_of_stage(heights): Returns a tuple containing: - count of people with a clear view of the stage - count of people without a clear view of the stage clear_view_count = 0 no_view_count = 0 max_height_to_left = float(\'-inf\') for height in heights: if height > max_height_to_left: clear_view_count += 1 max_height_to_left = height else: no_view_count += 1 return (clear_view_count, no_view_count)"},{"question":"You are given a list of integers, `heights`, representing the heights of buildings in a city. The city has been experiencing frequent earthquakes and therefore, the city administration decides to check the stability of buildings. A building is considered unstable if the height difference between any two adjacent buildings is greater than a given threshold `k`. Your task is to return the indices of all unstable buildings. If there are no unstable buildings, return an empty list. The input consists of the list `heights` of length `n` with heights of the buildings and an integer `k` which denotes the maximum allowed height difference for stability. Return _the list of indices of all unstable buildings_.","solution":"def find_unstable_buildings(heights, k): Returns the indices of all unstable buildings. Parameters: heights (list): List of integers representing the heights of the buildings. k (int): Maximum allowed height difference for stability. Returns: list: List of indices of all unstable buildings. unstable_indices = [] for i in range(1, len(heights)): if abs(heights[i] - heights[i - 1]) > k: if (i - 1) not in unstable_indices: unstable_indices.append(i - 1) if i not in unstable_indices: unstable_indices.append(i) return unstable_indices"},{"question":"You are given an `n x n` 2D matrix representing a grid of values. A path from the top-left to bottom-right grid cell can only move to the right or down at each step. Each cell in the grid contains a value that represents the cost of moving through that cell. Find and return the minimum sum of values along a path from the top-left to the bottom-right cell. Implement the method `int minPathSum(int[][] grid)` that returns the minimum path sum.","solution":"def minPathSum(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given a list of strings `wordlist`. A person types a word and misses out on some (possibly zero) letters, and types the remaining letters in order. A typed word qualifies to match `wordlist[i]` if and only if `wordlist[i]` is a subsequence of the typed word. Find all words in `wordlist` that are subsequences of the typed word. Return a list of these matching words in the same order as they appear in `wordlist`.","solution":"def is_subsequence(word, typed_word): Helper function to check if `word` is a subsequence of `typed_word`. it = iter(typed_word) return all(char in it for char in word) def find_matching_words(wordlist, typed_word): Find all words in `wordlist` that are subsequences of the `typed_word`. return [word for word in wordlist if is_subsequence(word, typed_word)]"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to determine if there are three distinct elements in `nums` whose sum is exactly equal to `target`. Implement a function `threeSumTarget(nums, target)` that returns `true` if such a triplet exists, and `false` otherwise. Ensure your solution is efficient in terms of time and space complexity._","solution":"def threeSumTarget(nums, target): Determines if there are three distinct elements in nums whose sum is equal to target. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: bool: True if such a triplet exists, False otherwise. nums.sort() # Sort the array first n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You need to manage a library system where books are arranged in a single-row bookshelf. Each book has a unique identifier. The system must support the following operations: - `void addBook(int bookId, int position)`: Adds the book with the given `bookId` at the specified `position` in the bookshelf. If the `position` is greater than the number of books currently in the bookshelf, place the book at the end. - `void removeBook(int position)`: Removes the book at the specified `position` in the bookshelf. If the `position` is out of range, no action should be taken. - `List<Integer> findBooks(int[] bookIds)`: Returns a list containing the positions of the books specified in the `bookIds` array. If a book is not found, return -1 for its position. Implement the `Library` class to support these operations. The operations should maintain the integrity of the bookshelf such that books are always in the correct order according to their positions.","solution":"class Library: def __init__(self): self.bookshelf = [] def addBook(self, bookId, position): if position < len(self.bookshelf): self.bookshelf.insert(position, bookId) else: self.bookshelf.append(bookId) def removeBook(self, position): if 0 <= position < len(self.bookshelf): self.bookshelf.pop(position) def findBooks(self, bookIds): result = [] for bookId in bookIds: try: result.append(self.bookshelf.index(bookId)) except ValueError: result.append(-1) return result"},{"question":"You are given a list of `n` strings, where each string represents a player\'s name and rank in the format \\"name_rank\\". The rank is an integer ranging from 1 to `k`. You want to regroup the players such that each subgroup contains exactly `k` different ranks. A subgroup is defined as a set of `k` players with all unique ranks. Return the maximum number of such subgroups you can form from the given list of player strings. If it is not possible to form any such subgroup, return `0`.","solution":"from collections import defaultdict def max_subgroups(players, k): Calculate the maximum number of subgroups with exactly `k` different ranks. Args: players: List of strings where each string is in the format \\"name_rank\\". k: Integer, the distinct number of ranks required in each subgroup. Returns: The maximum number of subgroups that can be formed. rank_count = defaultdict(int) # Count occurrences of each rank for player in players: rank = player.split(\'_\')[-1] rank_count[rank] += 1 # Find the minimum count among the ranks, as the subgroup is limited by the least frequent rank if len(rank_count) < k: return 0 return min(rank_count.values()) # Example # players = [\\"john_1\\", \\"jack_2\\", \\"jake_1\\", \\"luke_2\\", \\"paul_3\\", \\"mike_3\\"] # k = 3 # Should return 2 since we can form 2 subgroups each with ranks 1, 2, and 3."},{"question":"A company needs to schedule a series of meetings. Each meeting has a start time and an end time represented by the intervals `meetings[i] = [start_i, end_i]`. If a person can attend only one meeting at a time, return _the maximum number of meetings_ that a person can attend. If there are multiple optimal solutions, any will be accepted. **Note** that two meetings are considered to overlap if the start time of one meeting is less than the end time of the other meeting.","solution":"def max_meetings(meetings): Returns the maximum number of meetings that a person can attend. Parameters: meetings (list of list): A list of [start, end] representing the meeting times. Returns: int: The maximum number of meetings that a person can attend. if not meetings: return 0 # Sort meetings by end time meetings.sort(key=lambda x: x[1]) # Initialize the count of meetings and the end time of the last selected meeting count = 0 last_end_time = 0 for start, end in meetings: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"You are given a list of non-negative integers `nums` representing the number of flowers planted in each garden. Every garden can have at most one type of flowers (same species). You also have a list of pairs `restrictions` where each pair `[x, y]` means that garden `x` (0-indexed) is directly connected to garden `y` and flowers in garden `x` and `y` cannot be of the same type. You need to plant flowers in each garden such that no two directly connected gardens have the same type of flowers. Return _the minimum number of flower types_ required to achieve this. If it is not possible, return `-1`.","solution":"def min_flower_types(nums, restrictions): from collections import defaultdict def is_bipartite(graph): color = {} for node in graph: if node not in color: stack = [node] color[node] = 0 while stack: node = stack.pop() for neighbor in graph[node]: if neighbor not in color: stack.append(neighbor) color[neighbor] = color[node] ^ 1 elif color[neighbor] == color[node]: return False return True # Create the graph from restrictions graph = defaultdict(list) for x, y in restrictions: graph[x].append(y) graph[y].append(x) # Check if the graph is bipartite if not is_bipartite(graph): return -1 # If bipartite, at most 2 flower types are required return 2"},{"question":"Alice has an `m x n` grid filled with non-negative integers where the value at each cell represents the amount of gold in that cell. She can start collecting gold from any cell in the grid and can move to any adjacent cell (left, right, up, or down) to collect more gold. However, she cannot visit the same cell more than once. Return _the **maximum amount of gold** she can collect starting from any cell in the grid_.","solution":"def get_maximum_gold(grid): def dfs(x, y, visited): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or (x, y) in visited or grid[x][y] == 0: return 0 visited.add((x, y)) max_gold = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: max_gold = max(max_gold, dfs(x + dx, y + dy, visited)) visited.remove((x, y)) return max_gold + grid[x][y] max_gold = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] != 0: max_gold = max(max_gold, dfs(i, j, set())) return max_gold"},{"question":"Given an array of integers `heights` representing the heights of students standing in a line, the teacher wants to rearrange the students such that every student is at least as tall as the one in front of them when looking from left to right. After rearranging them, the teacher wants to know how many students stood in a different position from the original position. _Return the number of students that are not in the same position in the final arrangement as they were before._","solution":"def height_checker(heights): Returns the number of students that are not in the same position in the final arrangement. sorted_heights = sorted(heights) count = 0 for original, sorted_height in zip(heights, sorted_heights): if original != sorted_height: count += 1 return count"},{"question":"Given a list of non-negative integers `nums`, arrange them such that they form the largest number. You should concatenate the numbers in such a way that the resulting string is the largest possible. Return the string representation of the largest number.","solution":"from functools import cmp_to_key def largest_number(nums): Arrange a list of non-negative integers such that they form the largest number. Concatenate the numbers in such a way that the resulting string is the largest possible. Args: nums (List[int]): a list of non-negative integers Returns: str: the largest number represented as a string if not nums: return \\"\\" # Convert numbers to strings for easy concatenation nums_str = [str(num) for num in nums] # Comparator to decide the order based on their combination def compare(x, y): return -1 if x + y > y + x else 1 if x + y < y + x else 0 # Sort array with custom comparator nums_str.sort(key=cmp_to_key(compare)) # Edge case: If the largest number is \\"0\\", then all numbers are \\"0\\" if nums_str[0] == \\"0\\": return \\"0\\" # Join sorted list to form the largest number return \\"\\".join(nums_str)"},{"question":"You are given an integer array `arr`, where each element represents the height of a vertical line in a histogram. The width of each line is 1. Assume the histogram is grounded on the x-axis. Write a function that determines the area of the largest rectangle that can be formed within the bounds of the histogram. Return _the **maximum** rectangular area_ that can be formed.","solution":"def largestRectangleArea(heights): Determine the largest rectangle that can be formed in a histogram. :param heights: List[int], a list where each element represents the height of a vertical line in a histogram. :return: int, the maximum rectangular area that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings along a street. If the difference in heights between any two adjacent buildings is more than a given integer `maxHeightDiff`, you can install a ramp between those buildings. The ramp should have a height equal to the height of the taller building such that you can move from one building to the other. Given the integer `maxHeightDiff` and `heights` array, return _the minimum number of ramps needed to traverse the entire street from the first building to the last building._","solution":"def min_ramps(heights, maxHeightDiff): Return the minimum number of ramps needed to traverse the entire street from the first building to the last building according to the maxHeightDiff constraint. min_ramps_needed = 0 # Traverse through the array and calculate the number of ramps needed for i in range(len(heights) - 1): if abs(heights[i + 1] - heights[i]) > maxHeightDiff: min_ramps_needed += 1 return min_ramps_needed"},{"question":"You are given a binary tree with `n` nodes and each node has a value assigned to it. You are also given two integer arrays `queries` and `k_values`. For each query `queries[i]`, you need to find the sum of all node values in the subtree rooted at the node with index `queries[i]` such that the depth of the nodes in the subtree is less than or equal to `k_values[i]` from the depth of `queries[i]`. Return an array `results` where `results[i]` is the sum of node values satisfying the condition for the i-th query.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_subtree_at_depth_k(root, queries, k_values): def find_node_and_depth(tree, val, depth=0): if not tree: return None, -1 if tree.val == val: return tree, depth left_result = find_node_and_depth(tree.left, val, depth + 1) if left_result[0]: return left_result return find_node_and_depth(tree.right, val, depth + 1) def sum_at_max_depth(tree, max_depth, current_depth=0): if not tree: return 0 if current_depth > max_depth: return 0 return tree.val + sum_at_max_depth(tree.left, max_depth, current_depth + 1) + sum_at_max_depth(tree.right, max_depth, current_depth + 1) results = [] for query, k in zip(queries, k_values): node, depth = find_node_and_depth(root, query) if node is None: results.append(0) else: results.append(sum_at_max_depth(node, depth + k)) return results"},{"question":"You are given a matrix representing an image, where each element is a pixel value. Implement an algorithm to perform image rotation by 90 degrees clockwise in place. The rotation should be performed by making changes directly to the matrix without using extra space for another matrix. Return the rotated matrix after the operation.","solution":"def rotate_image(matrix): Rotates the given NxN matrix by 90 degrees clockwise in place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given an array of integers `arr` and an integer `k`. Write a function to find the `k`th **smallest** element in the `array` within **linear time** using the **Quickselect** algorithm. If the array has fewer than `k` elements, return `-1`. Implement the function `int kthSmallestElement(int[] arr, int k)`.","solution":"def kth_smallest_element(arr, k): Finds the k-th smallest element in the array using the Quickselect algorithm. Returns -1 if the array has fewer than k elements. :param arr: List of integers :param k: Integer representing which smallest element to find (1-based) :return: The k-th smallest element in the array, or -1 if array has fewer than k elements. if not arr or len(arr) < k or k <= 0: return -1 def quickselect(left, right, k_smallest): if left == right: return arr[left] pivot_index = partition(left, right) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) def partition(left, right): pivot_index = left pivot_value = arr[right] for i in range(left, right): if arr[i] < pivot_value: arr[pivot_index], arr[i] = arr[i], arr[pivot_index] pivot_index += 1 arr[pivot_index], arr[right] = arr[right], arr[pivot_index] return pivot_index return quickselect(0, len(arr) - 1, k - 1)"},{"question":"**You are given two integer arrays `nums1` and `nums2` representing the number of day’s temperatures recorded in two different cities. A **day’s temperature** is represented by an integer where a higher value indicates a hotter day and lower value indicates a colder day. Return a list of integers `result` such that `result[i]` is the number of days you would have to wait until a warmer day in `nums1`, or `null` if there is no future day for which this is possible in `nums1`. The same rule applies for `nums2`. Note: You must implement the solution that has O(n) complexity.**","solution":"def dailyTemperatures(nums): Returns a list indicating the number of days you have to wait until a warmer day for the given temperatures. :param nums: List[int] :return: List[int] result = [0] * len(nums) stack = [] for i, temperature in enumerate(nums): while stack and nums[stack[-1]] < temperature: previous_day = stack.pop() result[previous_day] = i - previous_day stack.append(i) return result"},{"question":"You are given a string `s` and an integer `k`. The string `s` can be manipulated by changing exactly `k` characters to any other character in the string. Return the length of the longest substring that contains all repeating letters after performing the replacements.","solution":"def character_replacement(s, k): Finds the length of the longest substring that contains all repeating letters after performing k replacements. max_length = 0 start = 0 max_count = 0 counts = {} for end in range(len(s)): letter = s[end] if letter in counts: counts[letter] += 1 else: counts[letter] = 1 max_count = max(max_count, counts[letter]) if (end - start + 1) - max_count > k: counts[s[start]] -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"In a binary tree, we define a \\"good\\" node as a node that is larger than or equal to all the nodes in the path from the root to that node. Given the `root` of a binary tree, return the number of good nodes in the tree. A tree node is defined as having the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Example: ``` Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes 3, 3, 4, and 5 are good nodes. ``` Note: The binary tree is implemented as an array where the `root` is the first element, and each node\'s children are positioned at indices `2*i + 1` for the left child and `2*i + 2` for the right child respectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def goodNodes(root): def dfs(node, max_val): if not node: return 0 good = 1 if node.val >= max_val else 0 max_val = max(max_val, node.val) left_good = dfs(node.left, max_val) right_good = dfs(node.right, max_val) return good + left_good + right_good return dfs(root, root.val)"},{"question":"A planet is represented as a 2D grid of size `m x n` where each cell can either be land (`1`) or water (`0`). Each cell is part of one island or water. An island is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Your task is to find the size of the largest island (i.e., the number of cells it covers). If no island exists, return `0`. Given the 2D grid `grid`, return _the size of the largest island_.","solution":"def largest_island(grid): Returns the size of the largest island in a 2D grid of size m x n. Each cell of the grid is either land (1) or water (0). if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_island_size = 0 def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the cell as visited by sinking the island size = 1 # Current cell # Visit all 4 adjacent cells size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size for i in range(m): for j in range(n): if grid[i][j] == 1: current_island_size = dfs(i, j) max_island_size = max(max_island_size, current_island_size) return max_island_size"},{"question":"You are given a list of integers `nums` and an integer `k`. A continuous subarray is called \\"interesting\\" if the sum of its elements is divisible by `k`. Your task is to find the total number of \\"interesting\\" subarrays in the given list. Return this count as an integer.","solution":"def count_interesting_subarrays(nums, k): Returns the count of interesting subarrays in nums where the sum of elements in the subarray is divisible by k. :param nums: List of integers :param k: Integer :return: Integer count of interesting subarrays count = 0 prefix_sum = 0 prefix_count = {0: 1} # Dict to store the frequency of prefix sums mod k for num in nums: prefix_sum += num mod_value = prefix_sum % k # Adjust mod_value to be positive if mod_value < 0: mod_value += k # Check if there is a prefix sum that gives mod_value if mod_value in prefix_count: count += prefix_count[mod_value] # Increment the frequency of the current mod_value if mod_value in prefix_count: prefix_count[mod_value] += 1 else: prefix_count[mod_value] = 1 return count"},{"question":"Given an integer array `nums`, return _the maximum difference between the increasing pairs `nums[j] - nums[i]` for `i < j`_, such that `nums[j] > nums[i]`. If no such pair exists, return `-1`. **Note:** You must solve it using an algorithm with a time complexity of O(n). Example 1: Input: nums = [7, 1, 5, 4] Output: 4 Explanation: The maximum difference is 4, achieved by the pair (5, 1). Example 2: Input: nums = [9, 4, 3, 2] Output: -1 Explanation: No pair exists that satisfies the conditions.","solution":"def maximum_difference(nums): Returns the maximum difference between the increasing pairs nums[j] - nums[i] for i < j, such that nums[j] > nums[i]. If no such pair exists, return -1. min_num = float(\'inf\') max_diff = -1 for num in nums: if num > min_num: max_diff = max(max_diff, num - min_num) min_num = min(min_num, num) return max_diff"},{"question":"Given two strings `s1` and `s2`, write a function to determine if `s1` can be converted to `s2` by performing at most one edit. An edit is defined as either inserting a character, deleting a character, or replacing a character. Return `true` if `s1` can be converted to `s2` with at most one edit, and `false` otherwise.","solution":"def is_one_edit_away(s1, s2): Determines if s1 can be converted to s2 by performing at most one edit. An edit is defined as inserting a character, deleting a character, or replacing a character. len1, len2 = len(s1), len(s2) if abs(len1 - len2) > 1: return False # Identify the shorter and the longer string if len1 > len2: s1, s2 = s2, s1 len1, len2 = len2, len1 # Started pointers for comparison index1 = index2 = 0 found_difference = False while index1 < len1 and index2 < len2: if s1[index1] != s2[index2]: if found_difference: return False found_difference = True if len1 == len2: index1 += 1 else: index1 += 1 index2 += 1 return True"},{"question":"David has `n` tasks to complete, each with a certain deadline. You are given two arrays `tasks` and `deadlines` where `tasks[i]` is the time (in hours) required to complete the `i-th` task and `deadlines[i]` is the deadline in hours by which the `i-th` task must be completed. David cannot work on more than one task at a time. If David starts working on the tasks from time `0`, determine the maximum number of tasks he can complete without missing any deadlines. *Return the maximum number of tasks David can complete on time.*","solution":"def max_tasks_on_time(tasks, deadlines): Determines the maximum number of tasks David can complete without missing any deadlines. :param tasks: List of integers where tasks[i] is the time required for the i-th task. :param deadlines: List of integers where deadlines[i] is the deadline for the i-th task. :return: Maximum number of tasks David can complete on time. # Combine tasks and deadlines into a list of tuples (task_time, deadline) task_with_deadline = list(zip(tasks, deadlines)) # Sort the tasks based on their deadlines in ascending order task_with_deadline.sort(key=lambda x: x[1]) current_time = 0 completed_tasks = 0 # Iterate through the sorted tasks for task_time, deadline in task_with_deadline: # If the current time plus task time does not exceed the deadline if current_time + task_time <= deadline: # David can complete this task current_time += task_time completed_tasks += 1 return completed_tasks"},{"question":"You are given an array of integers `heights` representing the heights of students in a class. A student `i` can see another student `j` if `j` is to the right of `i` and all students between `i` and `j` are shorter than both `i` and `j`. Return the total number of students that each student can see to their right. The result should be an array where each element represents the number of students that the corresponding student can see to their right.","solution":"def can_see(heights): Returns an array where each element represents the number of students that the corresponding student can see to their right. n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] < heights[i]: count += 1 else: break result[i] = count return result"},{"question":"You are given a **0-indexed** integer array `nums`. Move all occurrences of a specified integer `target` to the end of the array while maintaining the relative order of the other elements. Do this in-place using constant extra space. _Hint: You may assume that the number of occurrences of `target` will be less than or equal to `nums.length`._ _Return the modified array._","solution":"def move_target_to_end(nums, target): Move all occurrences of target to the end of the array while maintaining the relative order of the other elements. Do this in-place using constant extra space. Args: nums (list of int): The list of integers. target (int): The integer to be moved to the end. Returns: list of int: The modified list with all occurrences of target moved to the end. insert_pos = 0 for i in range(len(nums)): if nums[i] != target: nums[insert_pos] = nums[i] insert_pos += 1 while insert_pos < len(nums): nums[insert_pos] = target insert_pos += 1 return nums"},{"question":"Given an unsorted integer array `nums` with `n` elements, find the length of the longest continuous subarray that contains only unique elements. Return the length of this subarray. For example, for the input array `nums = [1, 2, 3, 4, 2, 5]`, the function should return `4`, corresponding to the subarray `[1, 2, 3, 4]`.","solution":"def length_of_longest_unique_subarray(nums): Returns the length of the longest continuous subarray that contains only unique elements. if not nums: return 0 n = len(nums) unique_elements = set() max_length = 0 left = 0 for right in range(n): while nums[right] in unique_elements: unique_elements.remove(nums[left]) left += 1 unique_elements.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a square matrix `matrix` of integers where each row and column is sorted in ascending order. You need to find an element `target` in the matrix. Write a function that returns a pair of integers representing the row and column indices of the `target` in the matrix. If the `target` does not exist, return `[-1, -1]`. The function should achieve this in `O(n)` or `O(log n)` time complexity where `n` is the number of rows (or columns) of the matrix.","solution":"def search_matrix(matrix, target): Searches for a target value in a sorted 2D matrix. Args: matrix (List[List[int]]): 2D list of integers where each row and column is sorted. target (int): The target integer to search for. Returns: List[int]: A list containing the row and column indices of the target, or [-1, -1] if not found. if not matrix or not matrix[0]: return [-1, -1] rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return [row, col] elif matrix[row][col] > target: col -= 1 else: row += 1 return [-1, -1]"},{"question":"You are given an integer array `nums` and an integer `target`. Find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution. Write a function called `threeSumClosest` that accepts the following parameters: - `int[] nums`: An array of integers. - `int target`: An integer representing the target sum. Return the closest sum of the three integers from the array. In case of ties, return any of the closest sums. The function signature is: ```python def threeSumClosest(nums: List[int], target: int) -> int: pass ```","solution":"from typing import List def threeSumClosest(nums: List[int], target: int) -> int: nums.sort() closest_sum = float(\'inf\') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"A company is planning an event that involves arranging tables in a specific manner. Each table can seat a fixed number of people, determined by the event planner. You are given an integer array `seats`, where `seats[i]` represents the number of people table `i` can accommodate. You are also given an integer `total`, representing the total number of guests invited. Write a function that returns the minimum number of tables needed to accommodate all the guests. If it is not possible to seat all guests with the given tables, return -1.","solution":"def min_tables(seats, total): Returns the minimum number of tables needed to accommodate all the guests. If it is not possible to seat all guests with the given tables, return -1. Parameters: seats (list): A list where each element represents the number of people a table can accommodate. total (int): The total number of guests. Returns: int: The minimum number of tables needed, or -1 if not possible. # Sort the seats array in descending order for optimal table usage seats.sort(reverse=True) guests_seated = 0 table_count = 0 for table in seats: if guests_seated >= total: break guests_seated += table table_count += 1 if guests_seated >= total: return table_count else: return -1"},{"question":"Implement a class `FileSystem` which supports `create`, `read`, and `update` operations on a virtual file system. The virtual file system should mimic a simplified hierarchical file system structure with directories and files. Each file has a unique path and contains text data. The `/` root directory will initially be empty. Implement the `FileSystem` class with the following methods: * `FileSystem()` Initializes the file system with an empty root directory. * `boolean create(String path, String content)` Creates a file at the given path with the provided content. Returns `true` if the file was created successfully and `false` if the file already exists or if any directory in the path does not exist. * `String read(String path)` Returns the content of the file at the specified path. If the file does not exist, returns an empty string. * `boolean update(String path, String content)` Updates the content of the file at the specified path. Returns `true` if the file was updated successfully, and `false` if the file does not exist. **Example:** ```python fs = FileSystem() print(fs.create(\\"/a\\", \\"hello\\")) # returns True print(fs.read(\\"/a\\")) # returns \\"hello\\" print(fs.update(\\"/a\\", \\"world\\")) # returns True print(fs.read(\\"/a\\")) # returns \\"world\\" print(fs.create(\\"/b/a\\", \\"nested\\")) # returns False (because directory /b does not exist) print(fs.read(\\"/b/a\\")) # returns \\"\\" (file does not exist) ```","solution":"class FileSystem: def __init__(self): self.files = {} def create(self, path, content): if path in self.files: return False # Check if all directories exist directories = path.split(\'/\')[:-1] current_path = \\"\\" for directory in directories: if directory: current_path += \\"/\\" + directory if current_path not in self.files: return False self.files[path] = content return True def read(self, path): return self.files.get(path, \\"\\") def update(self, path, content): if path not in self.files: return False self.files[path] = content return True"},{"question":"You are given two lists of integers, `list1` and `list2`, where each integer represents the unique ID of a person. Each person either belongs to group `A` or group `B`. Write a function to determine if it is possible to partition the people into two groups such that: 1. Every person in `list1` is in one group. 2. Every person in `list2` is in the other group. Return _True if such a partition is possible, otherwise return False_.","solution":"def can_partition(list1, list2): Returns True if it\'s possible to partition people into two groups such that: - Every person in list1 is in one group. - Every person in list2 is in the other group. Otherwise, returns False. # Convert lists to sets for fast membership testing set1 = set(list1) set2 = set(list2) # Check for any common elements return set1.isdisjoint(set2)"},{"question":"You are given a string `s` and an array of integers `indices`. Write a function to shuffle the characters in `s` such that the character at the `i-th` position moves to `indices[i]` in the shuffled string. Return the shuffled string. The `indices` array will contain all the valid indices of the string `s`, guaranteeing that no index is missing or duplicated.","solution":"def restore_string(s, indices): Return the shuffled string where character at the i-th position of `s` moves to `indices[i]` position in the shuffled string. :param s: A string to be shuffled :param indices: A list of integers indicating the new positions :return: a shuffled string based on the indices # Create a list of the same length as the input string shuffled = [\'\'] * len(s) # Place each character in its respective position for char, idx in zip(s, indices): shuffled[idx] = char # Join the list to form the shuffled string return \'\'.join(shuffled)"},{"question":"**[Question 4]:** Given an array of integers `arr` and an integer `limit`, design a function that calculates the minimum number of subarrays into which the initial array can be divided, such that the sum of each subarray is less than or equal to the given `limit`. Subarrays must be contiguous non-empty parts of the original array. Return the minimum number of such subarrays.","solution":"def min_subarrays_with_limit(arr, limit): Returns the minimum number of subarrays such that the sum of each subarray is less than or equal to the given limit. :param arr: List of integers :param limit: Integer, limit that the sum of each subarray should not exceed :return: Integer, minimum number of subarrays if not arr: return 0 count = 1 current_sum = 0 for num in arr: if num > limit: return -1 # if any single element is greater than limit, it\'s impossible to form valid subarrays if current_sum + num > limit: count += 1 current_sum = num else: current_sum += num return count"},{"question":"Given an integer array `arr`, determine the minimum number of moves required to make all elements in the array equal. In one move, you can increment or decrement any element of the array by 1. Return the minimum number of moves needed to make all elements the same. For example, for the input `arr = [1, 10, 2, 9]`, the output should be `16` since it takes a total of `16` moves to make all the elements equal to `5` (or any other value between 5 and 6 which are the median values): - Increment `1` to `5` requires 4 moves. - Decrement `10` to `5` requires 5 moves. - Increment `2` to `5` requires 3 moves. - Decrement `9` to `5` requires 4 moves. Thus, total moves = 4 + 5 + 3 + 4 = 16.","solution":"def min_moves_to_equal_elements(arr): Determines the minimum number of moves required to make all elements in the array equal. In one move, you can increment or decrement any element of the array by 1. arr.sort() median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"You are given an array of `n` integers, `arr`, and an integer `d`. Your task is to find the maximum sum possible of any contiguous subarray of length `d` within `arr`. If there are multiple such subarrays with the same sum, return the first one found from the left. If the array has less than `d` elements, return `0`. The function should return an integer representing the maximum sum of any contiguous subarray of length `d`.","solution":"def max_sum_contiguous_subarray(arr, d): Returns the maximum sum of any contiguous subarray of length `d` within `arr`. If the array has less than `d` elements, return 0. n = len(arr) if n < d: return 0 # Calculate the sum of the first window max_sum = sum(arr[:d]) current_sum = max_sum # Slide the window across the array and compute the sum for each subarray of length d for i in range(d, n): current_sum = current_sum - arr[i-d] + arr[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given a list of integers `nums`, where each integer represents a unique frequency count of elements, and an integer `k`, return _the **k** most frequent elements_ in `nums`. You may return the answer in **any order**. You must solve the problem in less than `O(n log n)` time complexity where `n` is the number of elements in `nums`.","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Return the k most frequent elements in nums. if not nums: return [] # Count the frequencies of each element in nums count = Counter(nums) # Use a heap to keep track of the top k frequent elements # heapq.nlargest returns the n largest elements in a list return [item for item, frequency in heapq.nlargest(k, count.items(), key=lambda item: item[1])]"},{"question":"Given an integer array `arr` of length `n` and an integer `m`, you need to **rearrange** the elements of `arr` in such a way that the sum of elements in every contiguous subarray of size `m` is maximized. Return _the rearranged array_. For example, if `arr = [1, 3, 2, 5, 4]` and `m = 3`, the rearranged array could be `[5, 3, 4, 2, 1]` because this arrangement provides the maximum sum for any contiguous subarray of size `m = 3`.","solution":"def rearrange_for_max_sum(arr, m): This function rearranges the elements of \'arr\' such that the sum of elements in every contiguous subarray of size \'m\' is maximized. Parameters: arr (list of int): The input array. m (int): Contiguous subarray size. Returns: list of int: Rearranged array for maximum sum in every subarray of size \'m\'. # Sort the array in descending order arr_sorted = sorted(arr, reverse=True) return arr_sorted"},{"question":"Given an integer array `nums`, you need to find a subarray of `nums` of length `k` that has the maximum possible sum. Return the sum of this subarray.","solution":"def max_subarray_sum(nums, k): Returns the maximum possible sum of a subarray of length k. if len(nums) < k: return 0 # Compute the sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) # Iterate through the array, updating the sum by sliding the window for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given a list of `n` unique integers, return an integer array of the same size where each element is replaced by its ranking when the list is sorted in ascending order. The smallest number should have a rank of 1, the second smallest number should have a rank of 2, and so on. If multiple elements have the same value, they should have the same rank. For example, given the array `[40, 10, 20, 30]`, the output should be `[4, 1, 2, 3]`.","solution":"def rank_elements(lst): Given a list of n unique integers, return an integer array of the same size where each element is replaced by its ranking when the list is sorted in ascending order. sorted_lst = sorted(lst) rank_dict = {value: rank + 1 for rank, value in enumerate(sorted_lst)} return [rank_dict[element] for element in lst]"},{"question":"You are given a linked list `head` where each node contains a positive integer value. Your task is to reorder the list such that the nodes appear in an alternating pattern of high and low values. Specifically, the first node should be the largest value, the second node should be the smallest value, the third node should be the second largest value, the fourth node should be the second smallest value, and so on. Return the reordered linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_linked_list(head): Reorders the linked list such that nodes appear in an alternating pattern of high and low values. if not head or not head.next: return head # Convert linked list to list of values values = [] current = head while current: values.append(current.val) current = current.next # Sort values values.sort() # Rebuild the list in the specific order high = 0 # Index for the largest values low = len(values) - 1 # Index for the smallest values current = head toggle = False # Start with largest value while high <= low: if toggle: current.val = values[high] high += 1 else: current.val = values[low] low -= 1 toggle = not toggle current = current.next return head"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine and return the number of unique palindromic substrings in the string `s`. A palindromic substring is a sequence of characters that reads the same forward and backward. Implement a function `uniquePalindromicSubstrings(String s)` that returns an integer representing the count of unique palindromic substrings in the given string.","solution":"def uniquePalindromicSubstrings(s): Returns the number of unique palindromic substrings in the given string s. def expandAroundCenter(left, right): Expand around center and add palindrome substrings to the set. while left >= 0 and right < len(s) and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 palindromes = set() for i in range(len(s)): # odd length palindromes expandAroundCenter(i, i) # even length palindromes expandAroundCenter(i, i + 1) return len(palindromes)"},{"question":"Given a circular array `nums` of positive and negative integers, check if there exists a cycle in the array such that: 1. The cycle must have length greater than 1. 2. The cycle must consist of a single direction (i.e., all steps must be either all forward or all backward). 3. Return `true` if such a cycle exists. Otherwise, return `false`. You may use the following definition for `nums`: - The array is circular: the element after `nums[nums.length - 1]` is `nums[0]`, and the element before `nums[0]` is `nums[nums.length - 1]`. A `forward` cycle means moving from an index `i` to `((i + nums[i]) % nums.length)`, and a `backward` cycle means moving from an index `i` to `((i + nums.length - nums[i]) % nums.length)`.","solution":"def circularArrayLoop(nums): def next_index(i): return (i + nums[i]) % len(nums) n = len(nums) for i in range(n): if nums[i] == 0: continue slow, fast = i, i while nums[i] * nums[next_index(slow)] > 0 and nums[i] * nums[next_index(next_index(fast))] > 0: slow = next_index(slow) fast = next_index(next_index(fast)) if slow == fast: if slow == next_index(slow): break return True slow = i val = nums[i] while nums[slow] * val > 0: next_i = next_index(slow) nums[slow] = 0 slow = next_i return False"},{"question":"You are building an application that tracks users\' exercise activities. Each exercise activity has a unique activity ID, the user\'s ID, the start time, and the end time in minutes. You need to analyze the activities and provide summaries for each user. Implement the `ExerciseTracker` class: * `ExerciseTracker()`: Initializes the `ExerciseTracker` object. * `void recordActivity(String activityId, String userId, int startTime, int endTime)`: Records an activity for the given user with the specified activity ID, start time, and end time. * `Map<String, Integer> getUserTotalExerciseTime(String userId, int startTime, int endTime)`: Returns a summary for the given user within the specified time period `[startTime, endTime]`. The summary should include the total exercise time for each activity performed by the user in minutes. Each activity time period can be overlapping, so you should accumulate overlapping times accurately for each activity. You can assume start and end times are inclusive and valid. For example, if user `U1` has activities: - `A1` from 10 to 20 minutes, - `A2` from 15 to 25 minutes, The total exercise time for `A1` from 10 to 20 minutes and `A2` from 15 to 25 minutes would be calculated accordingly for the period `[10, 25]`.","solution":"from collections import defaultdict from typing import Dict class ExerciseTracker: def __init__(self): self.activities = defaultdict(list) def recordActivity(self, activityId: str, userId: str, startTime: int, endTime: int): self.activities[userId].append((activityId, startTime, endTime)) def getUserTotalExerciseTime(self, userId: str, startTime: int, endTime: int) -> Dict[str, int]: totalTimes = defaultdict(int) user_activities = self.activities.get(userId, []) for activityId, a_startTime, a_endTime in user_activities: # Calculate overlapping time period overlap_start = max(startTime, a_startTime) overlap_end = min(endTime, a_endTime) if overlap_start <= overlap_end: totalTimes[activityId] += (overlap_end - overlap_start + 1) return dict(totalTimes)"},{"question":"Write a function that takes a list of strings and a word as input and returns a list of integers where each integer represents the frequency of the word in the corresponding string from the list. Ignore case while counting the frequency. For example, given a list `[\\"Hello world\\", \\"world Hello Hello\\", \\"WORLD\\"]` and the word `\\"hello\\"`, the function should return `[1, 2, 0]`.","solution":"def word_frequency_in_sentences(sentences, word): Returns a list of integers where each integer represents the frequency of the word in the corresponding string from the list of sentences. The function is case-insensitive. word = word.lower() frequency_list = [] for sentence in sentences: words = sentence.lower().split() frequency_list.append(words.count(word)) return frequency_list"},{"question":"You are given an array `arr` of integers and an integer `target`. Your task is to find all pairs of distinct indices `(i, j)` such that `arr[i] + arr[j] = target`. Each pair should be presented in the format `[(i1, j1), (i2, j2), ...]`, sorted by the first index, and then second index if the first indices are the same. * The same index cannot be used twice in a pair. * Return an empty list if no such pairs exist. __Example__ ```python arr = [1, 2, 3, 4, 3] target = 6 ``` __Output__ ```python [(1, 3), (2, 4)] ```","solution":"def find_pairs_with_sum(arr, target): Finds all pairs of distinct indices (i, j) such that arr[i] + arr[j] = target. Parameters: arr (list): List of integers. target (int): Target sum. Returns: list: List of pairs (tuples) where the sum of elements at the indices equals the target. pairs = [] index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: pairs.extend([(prev_index, i) for prev_index in index_map[complement]]) if num in index_map: index_map[num].append(i) else: index_map[num] = [i] pairs.sort() return pairs"},{"question":"You are given a **0-indexed** integer array `heights` where `heights[i]` represents the height of the `ith` student in a line. A group of students, all standing in an increasing sequence of heights, will be called a \\"height-group\\". Find the length of the **longest height-group** that can be formed by removing some (or none) of the students from the line. Return _the **maximum length** of such groups_.","solution":"def longest_height_group(heights): Function to find the length of the longest subsequence such that all items of the subsequence are sorted in increasing order. Args: heights (List[int]): List of heights representing the students. Returns: int: Length of the longest increasing subsequence. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence return max(dp)"},{"question":"Given an `n x n` grid where some of the squares are land (`1`) and some are water (`0`), return the length of the shortest bridge. A bridge is defined as a series of `1`s (land) connected either horizontally, vertically, or diagonally. Two islands are considered separated if they are connected only by water. You need to find the shortest path of `0`s (water) that connects the two islands.","solution":"def shortestBridge(grid): import collections def bfs(): BFS to find and mark all the lands of the first island found. queue = collections.deque() found = False # Find first island and mark it with -1 for i in range(len(grid)): if found: break for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j, queue) found = True break return queue def dfs(i, j, queue): DFS to mark a full island starting from (i, j) and add it to queue. if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1: return grid[i][j] = -1 queue.append((i, j)) dfs(i + 1, j, queue) dfs(i - 1, j, queue) dfs(i, j + 1, queue) dfs(i, j - 1, queue) queue = bfs() steps = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Expand from the island marked as -1 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): if grid[nx][ny] == 1: return steps if grid[nx][ny] == 0: grid[nx][ny] = -1 queue.append((nx, ny)) steps += 1 return -1 # Placeholder, should never happen if input guarantees two islands."},{"question":"You are given a list of `n` non-negative integers representing the height of each wall section. Assume it is going to rain and water will be trapped between these walls, forming two-dimensional puddles. Write a function that calculates the total amount of water trapped. You should return an integer representing the total volume of water trapped between the walls. For example, given the list [0,1,0,2,1,0,1,3,2,1,2,1], your function should return 6.","solution":"def trap(height): Given a list of non-negative integers height representing the height of each wall section, return the total amount of water trapped between the walls. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given an `n x n` matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image **in-place**, which means you have to modify the input matrix directly. Do not allocate another matrix to do the rotation. Return _the modified matrix_ after rotating it by 90 degrees. Example: Input: matrix = [[1,2,3], [4,5,6], [7,8,9]] Output: [[7,4,1], [8,5,2], [9,6,3]]","solution":"def rotate(matrix): Rotates the given n x n matrix representing an image by 90 degrees (clockwise) in-place. Parameters: matrix (list of list of int): The n x n matrix to be rotated. Returns: list of list of int: The rotated n x n matrix. n = len(matrix) # First step, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step, reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"Given a string `s` representing a valid parentheses sequence and an integer `k`, determine if it\'s possible to remove exactly `k` characters from `s` to make it a valid parentheses sequence again. A valid parentheses sequence is either empty, or can be written as `AB` (where `A` and `B` are valid parentheses sequences), or can be written as `(A)` (where `A` is a valid parentheses sequence). Return _a boolean_ indicating whether `k` characters can be removed to make `s` valid again.","solution":"def can_remove_k_to_make_valid(s, k): Determine if it\'s possible to remove exactly k characters from s to make it a valid parentheses sequence again. :param s: string representing a valid parentheses sequence :param k: integer, number of characters to remove :return: boolean, True if it\'s possible, False otherwise open_count = 0 close_count = 0 # Step through each character in the string for char in s: if char == \'(\': open_count += 1 elif char == \')\': if open_count > 0: open_count -= 1 else: close_count += 1 # The number of invalid parentheses total_invalid = open_count + close_count # Check if the total invalid parentheses can be reduced to exactly k removals return total_invalid == k or (k < len(s) and (len(s) - k) % 2 == 0) # Examples for quick manual testing print(can_remove_k_to_make_valid(\\"(()())\\", 2)) # Expected: True print(can_remove_k_to_make_valid(\\"((())\\", 1)) # Expected: True print(can_remove_k_to_make_valid(\\"((())\\", 2)) # Expected: False"},{"question":"You are given a list of integers `nums` sorted in **non-decreasing** order, and you are required to remove some elements to make the remaining elements **unique** (no duplicates are allowed). You need to perform the removal with the **minimum possible cost**. The cost of removing an element is given in another list `cost`, where `cost[i]` is the cost of removing the element `nums[i]`. Return _the minimum cost to make all elements in the list unique_.","solution":"def min_cost_to_make_unique(nums, cost): total_cost = 0 n = len(nums) for i in range(1, n): if nums[i] == nums[i - 1]: # Found a duplicate total_cost += cost[i] return total_cost"},{"question":"You are given two strings, `word1` and `word2`. Your task is to merge these strings into a single string consisting of alternating characters from `word1` and `word2`. If one string is longer than the other, append the additional characters from the longer string to the end of the merged string. For example: - `word1 = \\"abc\\"`, `word2 = \\"pqr\\"` should return `\\"apbqcr\\"`. - `word1 = \\"ab\\"`, `word2 = \\"pqrs\\"` should return `\\"apbqrs\\"`. Write a function `mergeAlternately(word1: str, word2: str) -> str` to accomplish this task.","solution":"def mergeAlternately(word1: str, word2: str) -> str: Merges two strings into a single string consisting of alternating characters. If one string is longer than the other, append the additional characters from the longer string to the end of the merged string. Parameters: word1 (str): The first string to merge. word2 (str): The second string to merge. Returns: str: The merged string. merged_string = [] len1, len2 = len(word1), len(word2) min_len = min(len1, len2) # Alternating characters for i in range(min_len): merged_string.append(word1[i]) merged_string.append(word2[i]) # Append the remaining characters from the longer string if len1 > len2: merged_string.extend(word1[min_len:]) else: merged_string.extend(word2[min_len:]) return \'\'.join(merged_string)"},{"question":"Given an integer array `nums`, return the length of the longest subsequence where the absolute difference between adjacent elements is `1`. For example, given the input array `nums = [1, 2, 3, 2, 3, 4, 3, 4, 5]`, the longest subsequence with absolute differences of `1` between each pair of adjacent elements is `[1, 2, 3, 2, 3, 4, 3, 4, 5]`, and the expected output is `9`.","solution":"def longest_subsequence_length(nums): if not nums: return 0 dp = [1] * len(nums) max_len = 1 for i in range(1, len(nums)): for j in range(i): if abs(nums[i] - nums[j]) == 1: dp[i] = max(dp[i], dp[j] + 1) max_len = max(max_len, dp[i]) return max_len # Example usage nums = [1, 2, 3, 2, 3, 4, 3, 4, 5] print(longest_subsequence_length(nums)) # Output should be 9"},{"question":"Given an integer array `nums` and an integer `k`, return the maximum sum of a subarray of size `k`. If there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. A subarray is a contiguous section of an array. For example, `[1, 2, 3]` is a subarray of `[1, 2, 3, 4, 5]` but `[1, 3, 4]` is not. The input constraints are guaranteed such that `k` is always less than or equal to the length of `nums` and `nums` always contains at least one element.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of size k. If there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. n = len(nums) max_sum = float(\'-inf\') current_sum = sum(nums[:k]) max_sum = current_sum start_index = 0 for i in range(1, n - k + 1): current_sum = current_sum - nums[i-1] + nums[i+k-1] if current_sum > max_sum: max_sum = current_sum start_index = i return nums[start_index:start_index+k]"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine the first and last non-repeating characters in the string. If there is no such character, return `-1` for both. Implement a function that returns a tuple `(first_non_repeat, last_non_repeat)` representing the first and last non-repeating characters respectively. If there are no non-repeating characters, both values in the tuple should be `-1`.","solution":"def first_and_last_non_repeating(s): Returns a tuple with the first and last non-repeating characters in the string s. If there are no non-repeating characters, returns (-1, -1). from collections import Counter char_count = Counter(s) first_non_repeat = -1 last_non_repeat = -1 for char in s: if char_count[char] == 1: first_non_repeat = char break for char in reversed(s): if char_count[char] == 1: last_non_repeat = char break return (first_non_repeat, last_non_repeat)"},{"question":"You are given an array of strings `words` representing different words in a certain language. A word is considered \\"beautiful\\" if it contains all the vowels (\'a\', \'e\', \'i\', \'o\', \'u\') at least once. Return the number of \\"beautiful\\" words in the array. Each word consists of lowercase English letters only.","solution":"def count_beautiful_words(words): Returns the number of \\"beautiful\\" words in the array. A word is considered beautiful if it contains all the vowels (\'a\', \'e\', \'i\', \'o\', \'u\') at least once. Args: words (list of str): Array of words to be checked. Returns: int: Number of beautiful words. vowels = set(\'aeiou\') def is_beautiful(word): return vowels.issubset(set(word)) return sum(1 for word in words if is_beautiful(word))"},{"question":"Given an integer `n`, return _the number of structurally unique BST\'s (binary search trees) that store values `1` ... `n`_. A structurally unique BST is defined as a arrangement of the BST nodes such that the overall shape or structure of the tree is unique. For example, two BSTs with nodes `1, 2, 3` might look like: ``` 1 1 2 3 3 / / / 2 3 1 3 2 1 / / 3 2 1 2 2 ``` All of these BSTs are structurally unique. Hence, for `n = 3`, the answer is `5` since there are five structurally unique BSTs. Return the total count, encapsulating the uniqueness in structure irrespective of the node values.","solution":"def num_trees(n): Returns the number of structurally unique BSTs that store values 1 to n. if n == 0: return 1 # Dynamic programming table to store the count of unique BSTs dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 # Fill the dp table for nodes in range(2, n + 1): total_trees = 0 for root in range(1, nodes + 1): left_trees = dp[root - 1] right_trees = dp[nodes - root] total_trees += left_trees * right_trees dp[nodes] = total_trees return dp[n]"},{"question":"You are given an integer array `arr` and an integer `x`. Write a function that finds the **maximum length** of a subarray with sum equal to `x`. If there isn\'t one, return 0 instead.","solution":"def max_subarray_len(arr, x): Finds the maximum length of a subarray with sum equal to x. If there isn\'t one, returns 0. sum_map = {} current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == x: max_length = i + 1 if (current_sum - x) in sum_map: max_length = max(max_length, i - sum_map[current_sum - x]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"Given a `dividend` and a `divisor`, implement a function that returns the result of `dividend` divided by `divisor` without using multiplication, division, and the mod operator. The integer division should truncate toward zero, which means losing the fractional part. For example, the integer division of `7` divided by `-3` should be `-2`. You can assume that both the dividend and divisor are integers and that the divisor is not zero. The result should fit within the range of a 32-bit signed integer.","solution":"def divide(dividend, divisor): Divides dividend by divisor without using multiplication, division or mod operator. Returns the quotient after truncating towards zero. # Handle special case for overflow MAX_INT = 2**31 - 1 MIN_INT = -2**31 if dividend == MIN_INT and divisor == -1: return MAX_INT # Determine the sign of the result sign = -1 if (dividend < 0) ^ (divisor < 0) else 1 # Work with positive values dividend, divisor = abs(dividend), abs(divisor) quotient = 0 while dividend >= divisor: temp_divisor, num_divisors = divisor, 1 while dividend >= temp_divisor: dividend -= temp_divisor quotient += num_divisors # Double the temporary divisor and the count of divisors for efficiency temp_divisor <<= 1 num_divisors <<= 1 return sign * quotient"},{"question":"You are given two sorted arrays, `arr1` and `arr2`, each of distinct integers. Your task is to find and return a list of elements common to both arrays without using any library functions for intersection. Ensure the resulting list is also sorted in ascending order. [Question] 4","solution":"def find_common_elements(arr1, arr2): Returns a list of common elements in both arr1 and arr2. The resulting list is sorted in ascending order. common_elements = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: i += 1 elif arr1[i] > arr2[j]: j += 1 else: common_elements.append(arr1[i]) i += 1 j += 1 return common_elements"},{"question":"You are given a string `s` containing only letters \'a\' and \'b\'. You can delete any number of characters from the string to make it a palindrome. A palindrome is a string that reads the same forwards as backwards. Return _the length of the longest palindromic subsequence you can obtain by deleting characters from `s`._","solution":"def longest_palindromic_subsequence(s): Return the length of the longest palindromic subsequence you can obtain by deleting characters from s. n = len(s) if n == 0: return 0 dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"You are given a list of integers `nums` where each number represents the height of a building. The buildings are placed adjacent to each other. If it starts raining, the water will be trapped between the buildings. Return _the total amount of water that can be trapped after it rains_.","solution":"def trap_rain_water(nums): Returns the total amount of water that can be trapped after it rains. :param nums: List[int] - List of integers where each number represents the height of a building :return: int - Total amount of trapped water if not nums: return 0 n = len(nums) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = nums[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], nums[i]) # Fill right_max array right_max[n - 1] = nums[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], nums[i]) # Calculate the trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - nums[i] return total_water"},{"question":"You are given an integer array `arr` and an integer `k`. You need to find the **kth** largest element in the array. Implement a function that returns this element without using any built-in sorting algorithms. You can assume that `k` is always a valid index in the context of the array. Example: ``` arr = [3,2,1,5,6,4] k = 2 Result: 5 ```","solution":"def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] >= pivot: # Changed to >= to find kth largest instead of kth smallest i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low < high: pi = partition(arr, low, high) if pi == k: return arr[pi] elif pi > k: return quickselect(arr, low, pi - 1, k) else: return quickselect(arr, pi + 1, high, k) return arr[low] def find_kth_largest(arr, k): return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"You are given a positive integer `n` representing the number of courses a student needs to complete to obtain a degree. You are also given a list `prerequisites` where each element is a pair of courses `[a, b]` indicating that course `a` must be taken before course `b`. Determine if it is possible for the student to finish all the courses given these prerequisites. Return `true` if it is possible to finish all courses, and `false` otherwise.","solution":"def can_finish_courses(n, prerequisites): Determines if it\'s possible to finish all courses given the prerequisites. :param n: Number of courses :param prerequisites: List[List[int]] - A list of pairs [a, b] indicating that course a must be taken before course b. :return: bool - True if it is possible to finish all courses, otherwise False. from collections import defaultdict, deque # Create an adjacency list and in-degree list adj_list = defaultdict(list) in_degree = [0] * n # Build the graph and fill in-degrees for dest, src in prerequisites: adj_list[src].append(dest) in_degree[dest] += 1 # Queue for nodes with no incoming edges zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) # Number of courses that have no prerequisites count = 0 while zero_in_degree_queue: node = zero_in_degree_queue.popleft() count += 1 # Decrease the in-degree for all the neighbors for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If count of courses with no remaining prerequisites equals number of courses, we can complete all courses return count == n"},{"question":"You are designing a text editor application that includes an auto-save feature. The auto-save mechanism should save a copy of the user\'s current document every `n` minutes. Write a class `AutoSave` that supports the following operations: - `AutoSave(int n)` - Initializes the auto-save timer to save the document every `n` minutes. - `void openDocument(String document, int t)` - Opens a new document at time `t`. If there\'s already a document open, save it before opening the new one. - `List<String> saveDocument(int t)` - Performs an auto-save at time `t`, saving the document and returning a list of versions of the document saved so far. - `int getMinutesToNextSave(int t)` - Returns the number of minutes remaining until the next auto-save, given the current time `t`. Assume time `t` is given in minutes and starts from zero. The documents are represented as strings, and new versions should be appended to the list of saved documents at every save event.","solution":"class AutoSave: def __init__(self, n): Initializes the auto-save timer to save the document every `n` minutes. Args: n (int): Interval in minutes to perform auto-save operation. self.interval = n self.documents = [] self.current_document = None self.last_save_time = 0 def openDocument(self, document, t): Opens a new document at time `t`. Saves the current document before opening if there\'s already a document open. Args: document (str): The new document to be opened. t (int): The current time in minutes. if self.current_document is not None: self.saveDocument(t) self.current_document = document self.last_save_time = t def saveDocument(self, t): Performs an auto-save at time `t`, saving the document and returning a list of versions of the document saved so far. Args: t (int): The current time in minutes. Returns: List[str]: List of document versions saved so far. if self.current_document is not None and (t - self.last_save_time) >= self.interval: self.documents.append(self.current_document + f\\" (saved at {t} mins)\\") self.last_save_time = t return self.documents def getMinutesToNextSave(self, t): Returns the number of minutes remaining until the next auto-save, given the current time `t`. Args: t (int): The current time in minutes. Returns: int: Minutes remaining until the next auto-save. elapsed_time = t - self.last_save_time time_to_next_save = self.interval - (elapsed_time % self.interval) return time_to_next_save"},{"question":"Given a **0-indexed** integer array `prices` representing the prices of products on different days, and an integer `fee` representing a transaction fee, return _the maximum profit you can achieve_. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: * After you sell your stock, you must pay a transaction fee for each transaction.","solution":"def maximum_profit(prices, fee): Given a list of prices and a transaction fee, this function calculates the maximum profit that can be achieved by buying and selling with the transaction fee applicable. :param prices: List[int], list of product prices on different days :param fee: int, transaction fee for each transaction :return: int, maximum profit n = len(prices) if n == 0: return 0 # Initialize states cash = 0 hold = -prices[0] # Holding the first stock for i in range(1, n): # Transition states cash = max(cash, hold + prices[i] - fee) # Max of selling today or doing nothing hold = max(hold, cash - prices[i]) # Max of buying today or doing nothing return cash"},{"question":"You are given an integer array `nums` and an integer `k`. You need to distribute all the integers into `k` baskets such that the maximum sum of the integers in any basket is minimized. Return _the minimized maximum sum of the integers in the `k` baskets_. Each basket must contain at least one integer, and the sum of the integers in each basket must be as balanced as possible to achieve the minimized maximum sum.","solution":"def canDistribute(nums, k, maxSum): baskets = 1 currentSum = 0 for num in nums: if currentSum + num > maxSum: baskets += 1 currentSum = num if baskets > k: return False else: currentSum += num return True def minimize_max_sum(nums, k): nums.sort(reverse=True) # Sort in descending order to speed up the process low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if canDistribute(nums, k, mid): high = mid else: low = mid + 1 return low"},{"question":"Given an array of integers `nums` and an integer `k`, return the maximum number of unique elements among all possible contiguous subarrays of length `k` in `nums`. A contiguous subarray is defined as a non-empty sequence of elements within `nums` such that the elements appear consecutively. If the subarray length is less than `k`, it is not considered a valid subarray.","solution":"def max_unique_elements(nums, k): Returns the maximum number of unique elements among all possible contiguous subarrays of length `k` in `nums`. if len(nums) < k: return 0 max_unique = 0 for i in range(len(nums) - k + 1): subarray = nums[i:i + k] unique_elements = len(set(subarray)) if unique_elements > max_unique: max_unique = unique_elements return max_unique"},{"question":"Given a non-negative integer array `nums`, you are allowed to perform one operation on the array where you can remove any single element. Return _the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1_ after performing the operation.","solution":"def longest_subarray(nums): if not nums: return 0 # Dictionary to store the frequency of each element freq = {} # Traverse the array to count the frequency of each element for num in nums: if num in freq: freq[num] += 1 else: freq[num] = 1 keys = sorted(freq.keys()) max_length = 0 # Calculate the possible length of subarrays by removing one element for i in range(len(keys)): if i > 0 and keys[i] - keys[i - 1] <= 1: current_length = freq[keys[i]] + freq[keys[i - 1]] max_length = max(max_length, current_length) # consider subarray without any removal max_length = max(max_length, freq[keys[i]]) return max_length"},{"question":"Given an array of integers `arr`, you are tasked with finding a contiguous subarray that has the largest sum. If there are multiple such subarrays, return the one which starts with the smallest index. Your function should return the sum of this subarray. You should implement the function: ```python def max_subarray_sum(arr: List[int]) -> int: # implementation details ``` **Note**: The array may contain both positive and negative numbers. A subarray is a contiguous part of an array.","solution":"def max_subarray_sum(arr): Returns the sum of the contiguous subarray with the largest sum. If there are multiple such subarrays, the one starting with the smallest index is returned. if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a list of `n` non-negative integers representing the **amount of money** of each house, arranged in a circular manner. In a single day, you can choose to rob any two houses, but you cannot rob two consecutive houses or the house immediately next to the ones you have already robbed due to the circular arrangement. Return _the **maximum amount of money** you can rob without robbing two consecutive houses in a circular list_.","solution":"def max_rob(nums): Returns the maximum amount of money you can rob without robbing two consecutive houses in a circular list. def rob_linear(nums): prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr n = len(nums) if n == 1: return nums[0] # Two cases: exclude first house or exclude last house return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"You are given an `n`-length integer array `arr` representing a jump sequence. Each element in the array `arr[i]` denotes the maximum number of positions you can move forward from index `i`. You start at index `0`. Return the minimum number of jumps needed to reach the end of the array (index `n-1`). If it is not possible to reach the end of the array, return `-1`.","solution":"def min_jumps(arr): Returns the minimum number of jumps needed to reach the end of the array. If it is not possible to reach the end, returns -1. n = len(arr) if n == 0 or arr[0] == 0 and n > 1: return -1 jumps = 0 farthest = 0 end_reached = 0 for i in range(n - 1): farthest = max(farthest, i + arr[i]) if i == end_reached: jumps += 1 end_reached = farthest if end_reached >= n - 1: return jumps return -1 if end_reached < n - 1 else jumps"},{"question":"You are given a list of `n` integers representing the amount of time each task takes. The tasks are to be processed by two machines. Your goal is to distribute the tasks between the two machines such that the difference in the total processing time of the two machines is minimized. Return _the minimum possible difference between the total processing times of the two machines_.","solution":"def min_diff_partition(tasks): Returns the minimum possible difference between the total processing times of the two machines by partitioning the tasks. total_sum = sum(tasks) target = total_sum // 2 dp = [0] * (target + 1) for task in tasks: for j in range(target, task - 1, -1): dp[j] = max(dp[j], dp[j - task] + task) machine1_time = dp[target] machine2_time = total_sum - machine1_time return abs(machine2_time - machine1_time)"},{"question":"Given a 2D matrix `mat` of size `m x n`, return _the number of **unique paths** from the top-left corner to the bottom-right corner_. You can only move either down or right at any point in time. **Note:** - **Do not include any obstacles.** - `1 <= m, n <= 100`.","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n matrix. # Create a 2D list to store the number of ways to reach each cell dp = [[1] * n for _ in range(m)] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the answer return dp[m-1][n-1]"},{"question":"A **linked list cycle** is defined as a situation where a node\'s next pointer points back to a previous node in the list. Given the head of a linked list, return `true` if the linked list has a cycle in it, or `false` otherwise. _You should try to accomplish this in_ O(n) _time complexity using O(1) extra space._","solution":"class ListNode: Definition for a singly-linked list node. def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head): Detects if a linked list has a cycle. Args: head: The head node of the linked list. Returns: bool: True if there is a cycle, False otherwise. if head is None: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. An array is called **k-divisible** if every element in the array is divisible by `k`. Write a function to determine if there exists a contiguous subarray of `arr` whose sum is divisible by `k`. Return `true` _if such a subarray exists_, or `false` _otherwise_.","solution":"def subarray_sum_divisible_by_k(arr, k): Determines if there exists a contiguous subarray of `arr` whose sum is divisible by `k`. Parameters: arr (list): The integer array. k (int): The divisor. Returns: bool: True if there exists a subarray whose sum is divisible by `k`, False otherwise. current_sum = 0 mods = {0} for num in arr: current_sum += num mod = current_sum % k if mod in mods: return True mods.add(mod) return False"},{"question":"You are given a list of strings `words`. A **concatenated word** is a string that is formed by concatenating two or more strings from the list `words` such that each string used in the concatenation is distinct and is present in `words`. Return _the length of the longest **concatenated word** that can be formed from the list **words**_. If no concatenated word can be formed, return `0`.","solution":"def findLongestConcatenatedWordLength(words): Returns the length of the longest concatenated word that can be formed from the list words. def can_form(word, word_set): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in word_set and (suffix in word_set or can_form(suffix, word_set)): memo[word] = True return True memo[word] = False return False word_set = set(words) memo = {} max_length = 0 for word in words: if can_form(word, word_set): max_length = max(max_length, len(word)) return max_length"},{"question":"You are given a binary tree where each node has either 0 or 2 children. A node is considered full if both its children are non-empty. A **full path** is a path from the root node to a leaf node that only passes through full nodes. Given the root of a binary tree, return _the length of the longest full path_ in the tree. The length of a path is the number of nodes along that path, including the root and leaf nodes. If there is no full path, return 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_full_path(root): def dfs(node): if not node: return 0 if (node.left and not node.right) or (node.right and not node.left): return 0 left_length = dfs(node.left) right_length = dfs(node.right) return 1 + max(left_length, right_length) if not root: return 0 return dfs(root)"},{"question":"Given a string `s` consisting of lowercase English letters, your task is to remove the minimum number of characters from `s` so that no two adjacent characters are the same. - Return the resulting string after the removal. If there are multiple results, return the lexicographically smallest one. For example, given input `\\"aaabccddd\\"`, the possible resulting strings could be `\\"abccd\\"`, `\\"bcddd\\"`, etc. The lexicographically smallest one is `\\"abccd\\"`.","solution":"def minimize_adjacent_duplicates(s): Removes the minimum number of characters from the given string to ensure that no two adjacent characters are the same. If there are multiple results, returns the lexicographically smallest one. :param s: A string consisting of lowercase English letters :type s: str :return: A string with minimized adjacent duplicates :rtype: str stack = [] for char in s: if stack and stack[-1] == char: continue stack.append(char) return \'\'.join(stack)"},{"question":"You are given an unsorted array of integers `arr` and an integer `k`. Your task is to find the `k`th smallest element in the array. Note that it is the `k`th smallest element in the sorted order, not the `k`th distinct element. Write a function that returns the `k`th smallest element.","solution":"def kth_smallest_element(arr, k): Returns the kth smallest element in the array. :param arr: List of integers. :param k: The position of the smallest element to find. :return: The kth smallest element. # Sort the array sorted_arr = sorted(arr) # Return the kth smallest element (1-based index, so subtract 1 for 0-based index) return sorted_arr[k-1]"},{"question":"You are given an array of integers `arr` and an integer `k`. You can perform one type of operation on the array: choose an integer `x` and replace every occurrence of `x` in the array with `x + 1` or `x - 1`. You are allowed to perform this operation at most `k` times. Your goal is to make as many elements of the array equal as possible. Return the maximum number of equal elements you can get after performing at most `k` operations.","solution":"from collections import defaultdict def max_equal_elements(arr, k): Returns the maximum number of equal elements that can be made in the array by performing at most k operations of incrementing or decrementing elements by 1. # Frequency dictionary to store counts of elements freq = defaultdict(int) # Frequency counter for num in arr: freq[num] += 1 # Converting to sorted list of (element, frequency) freq_items = sorted(freq.items()) max_equal = 0 n = len(freq_items) # Loop through each element for i in range(n): count = 0 remaining_k = k # Check if we can make all elements from i to j equal by using operations for j in range(i, n): if j == i: count += freq_items[j][1] else: diff = freq_items[j][0] - freq_items[j-1][0] needed_operations = diff * (freq_items[j][1]) if needed_operations <= remaining_k: remaining_k -= needed_operations count += freq_items[j][1] else: count += remaining_k // diff remaining_k = 0 max_equal = max(max_equal, count) return max_equal"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to return the character that appears the most frequently in `s`. If there are multiple characters that appear with the same highest frequency, return the lexicographically smallest one. Write a function `mostFrequentChar(s: str) -> str` that returns the most frequent character in `s` as specified.","solution":"def mostFrequentChar(s: str) -> str: Returns the most frequent character in the string \'s\'. If multiple characters have the highest frequency, returns the lexicographically smallest one. from collections import Counter # Count the frequency of each character freq = Counter(s) # Determine the highest frequency highest_freq = max(freq.values()) # Collect characters with the highest frequency most_frequent_chars = [char for char, count in freq.items() if count == highest_freq] # Return the lexicographically smallest character among the most frequent return min(most_frequent_chars)"},{"question":"You are given an array `points` representing the positions of `n` cars on a number line. The `i-th` car is initially at position `points[i]`. Each car can drive to any position in front of (or behind) it with a constant speed, but at a cost per unit distance traveled. The goal is for all cars to meet at a common position with the minimum total cost. Implement the function `minCostToMeet(int[] points, int costPerUnit)` that returns the minimum total cost for all cars to converge at a single position. For example, if `points = [1, 2, 3]` and `costPerUnit = 1`, the function should return `2` because the optimal meeting point is at position `2` (or any integer between `1` and `3`), and the total cost is `1 + 0 + 1 = 2`.","solution":"def minCostToMeet(points, costPerUnit): Returns the minimum total cost for all cars to meet at a single position. points.sort() median = points[len(points) // 2] total_cost = sum(abs(p - median) * costPerUnit for p in points) return total_cost"},{"question":"You are given an n x n 2D matrix representing an image, where each cell contains an integer value representing the pixel\'s color intensity. Rotate the image clockwise by 90 degrees in place, meaning you have to modify the input 2D matrix directly. Do not allocate another 2D matrix for the rotation. Return the modified 2D matrix after the rotation.","solution":"def rotate(matrix): Rotates the given n x n 2D matrix clockwise by 90 degrees in place. Parameters: matrix (list[list[int]]): 2D list representing the image with integer values. Returns: list[list[int]]: The rotated matrix. n = len(matrix) # Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer array `modifications`. The array `modifications` contains the indices of the string `s`, indicating the positions in the string where the characters can be changed to any other lowercase English letters. Your task is to determine the minimum number of operations required to make `s` a palindrome by only modifying the characters at the indices specified in the `modifications` array. If it is not possible to make `s` a palindrome, return `-1`.","solution":"def min_operations_to_palindrome(s, modifications): s_list = list(s) n = len(s) # Convert modifications to a set for quick lookup mod_set = set(modifications) def is_modifiable(index): return index in mod_set operations = 0 i, j = 0, n - 1 while i < j: if s_list[i] != s_list[j]: if is_modifiable(i) or is_modifiable(j): operations += 1 else: return -1 i += 1 j -= 1 return operations"},{"question":"Given a binary tree, where each node contains a value, return the sum of all left leaves in the tree. A leaf is a node with no children, and a left leaf is a leaf that is the left child of its parent. Use the following definition for the TreeNode class: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Write a function: ```python def sumOfLeftLeaves(root: TreeNode) -> int: ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sumOfLeftLeaves(root: TreeNode) -> int: Returns the sum of all left leaves in the given binary tree. if not root: return 0 def is_leaf(node): return node and not node.left and not node.right sum_left_leaves = 0 if root.left and is_leaf(root.left): sum_left_leaves += root.left.val else: sum_left_leaves += sumOfLeftLeaves(root.left) sum_left_leaves += sumOfLeftLeaves(root.right) return sum_left_leaves"},{"question":"You are given an encoded string where each letter is followed by a digit representing the number of times it should appear. For example, the string \\"a2b3\\" should be decoded to \\"aabbb\\". Write a program to decode such a string. Implement a function `decodeString` that takes the encoded string as input and returns the decoded string.","solution":"def decodeString(encoded): Decodes the given encoded string where each letter is followed by a digit representing the number of times it should appear. :param encoded: str - Encoded string :return: str - Decoded string decoded_str = [] i = 0 while i < len(encoded): char = encoded[i] count = int(encoded[i + 1]) decoded_str.append(char * count) i += 2 return \'\'.join(decoded_str)"},{"question":"Given a sorted array of integers `arr` and a threshold value `k`, you are tasked with modifying the array such that the absolute difference between any two elements in the array does not exceed `k`. To achieve this, you are allowed to decrease any of the elements, but not increase them, as many times as necessary. Find the maximum possible value of the smallest element in the resulting modified array. Return this value as the result.","solution":"def max_possible_smallest_element(arr, k): Finds the maximum possible value of the smallest element in the array after modification such that the absolute difference between any two elements does not exceed k. :param arr: List[int] - Sorted array of integers :param k: int - Threshold value for the absolute difference :return: int - Maximum possible value of the smallest element # The largest element in the array after modification can be at most arr[-1] max_elem = arr[-1] # We need to make sure that all elements are within k units of each other # So the minimum element in the modified array should be at least # max_elem - k return max_elem - k"},{"question":"Given a string `s` representing a mathematical expression with **integers** and the operators `+`, `-`, `*`, and `/`, implement a function to evaluate this expression and return its result. The expression must be evaluated following the standard order of operations: parentheses `()`, followed by multiplication `*` and division `/`, and finally addition `+` and subtraction `-`. Both multiplication and division operations should be performed using integer arithmetic. You may assume that the divisor in any division operation will never be zero. Additionally, you can assume that the given expression is always valid.","solution":"def evaluate_expression(s): Evaluates a mathematical expression with integers and the operators +, -, *, and /. The expression is evaluated following the standard order of operations. def compute(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Use integer division def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operators = [] values = [] i = 0 while i < len(s): if s[i] == \' \': i += 1 continue if s[i].isdigit(): val = 0 while i < len(s) and s[i].isdigit(): val = val * 10 + int(s[i]) i += 1 values.append(val) i -= 1 elif s[i] == \'(\': operators.append(s[i]) elif s[i] == \')\': while operators and operators[-1] != \'(\': compute(operators, values) operators.pop() else: while operators and precedence(operators[-1]) >= precedence(s[i]): compute(operators, values) operators.append(s[i]) i += 1 while operators: compute(operators, values) return values[-1]"},{"question":"Given an array of positive integers `arr` and an integer `target`, return **all unique combinations** of `arr`\'s sums where each number in `arr` is used **exactly once** and the combination adds up to `target`. Each combination should be returned in any order as a list of integers. Implement the method `List<List<Integer>> combinationSum(int[] arr, int target)`. The solution set must not contain duplicate combinations, and the integers in each combination must be in a non-descending order.","solution":"def combinationSum(arr, target): def backtrack(start, target, path, result): if target == 0: result.append(path) return elif target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i-1]: continue backtrack(i+1, target - arr[i], path + [arr[i]], result) arr.sort() result = [] backtrack(0, target, [], result) return result"},{"question":"Implement a function that takes a list of integers and returns a new list containing only the integers that appear more than once in the original list. The returned list should be in the same order as they first appeared in the original list and without duplicates.","solution":"def find_duplicates(nums): Returns a list of integers that appear more than once in the original list. The returned list maintains the same order as they first appeared in the original list without duplicates. from collections import Counter counts = Counter(nums) seen = set() duplicates = [] for num in nums: if counts[num] > 1 and num not in seen: duplicates.append(num) seen.add(num) return duplicates"},{"question":"Given a list of integers `rooms` where each integer represents the number of keys in that room, some rooms might be empty (having 0 keys). You start in room `0`, and each key in a room opens another room. Return _the minimum number of rooms you need to enter to unlock all rooms_. If it\'s not possible to unlock all rooms, return `-1`. For instance, if `rooms = [1, 0, 3, 0]`, it means: - Room 0 has 1 key to open another room. - Room 1 is empty. - Room 2 has 3 keys. - Room 3 is empty.","solution":"from collections import deque def min_rooms_to_unlock_all(rooms): Returns the minimum number of rooms you need to enter to unlock all rooms. If it\'s not possible to unlock all rooms, return -1. n = len(rooms) visited = [False] * n queue = deque([0]) visited[0] = True rooms_visited = 1 room_count = 0 while queue: current_room = queue.popleft() room_count += 1 for i in range(rooms[current_room]): next_room = (current_room + 1 + i) % n if not visited[next_room]: queue.append(next_room) visited[next_room] = True rooms_visited += 1 return room_count if rooms_visited == n else -1"},{"question":"Given a string `s` consisting only of characters \'a\', \'b\', and \'c\', you can perform operations to transform the string. In one operation, you can choose any non-empty substring consisting of the same character and remove it. Your goal is to make the string empty by performing a minimum number of operations. Return the minimum number of operations needed to achieve this.","solution":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations needed to make the given string empty. if not s: return 0 # Initialize the count of operations operations = 0 i = 0 while i < len(s): start = i # Traverse the substring of the same character while i < len(s) and s[i] == s[start]: i += 1 # Increment operations for each identified substring of the same character operations += 1 return operations"},{"question":"You are given a 2D grid of size `m x n` where each cell represents an elevation map. The elevation indicates the height at that particular point. You can move from any cell to another if it is adjacent and the elevation difference between the two cells is at most 1. Return the minimum number of steps required to go from the top-left cell to the bottom-right cell. If it is not possible to reach the bottom-right cell, return -1.","solution":"from collections import deque def min_steps(grid): def is_valid(x, y): return 0 <= x < m and 0 <= y < n m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, column, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= 1: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given two strings `s1` and `s2`, both consisting of lowercase letters. You need to determine whether `s2` can be obtained from `s1` by deleting some (possibly zero) characters without reordering the remaining characters. In other words, return `true` if `s2` is a subsequence of `s1`, and `false` otherwise. Implement a function `bool isSubsequence(string s1, string s2)` that returns `true` if `s2` can be derived from `s1` by deleting some characters without changing the order of the remaining characters, and `false` otherwise.","solution":"def isSubsequence(s1, s2): Determine whether s2 is a subsequence of s1. Args: s1 (str): The string to be checked if it contains s2 as a subsequence. s2 (str): The string which we need to check as subsequence in s1. Returns: bool: True if s2 is a subsequence of s1, False otherwise. if not s2: return True if not s1: return False it = iter(s1) return all(char in it for char in s2)"},{"question":"A **linked list** is a linear data structure in which each element is a separate object called a node. Each node contains two fields: data and a reference (or link) to the next node in the sequence. Given the head of a singly linked list, reverse the list and return the reversed list. Implement the following method: - `ListNode reverseList(ListNode head)` which takes the head node of a singly linked list and returns the node of the reversed list. Note: `ListNode` is defined as: ``` public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } } ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head): Reverses the given singly linked list and returns its new head. :param head: ListNode :return: ListNode prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to find a pair of indices `(i, j)` such that `arr[i] + arr[j]` is closest to the `target`. If there are multiple pairs with the same closest sum, return any one of them. Return the indices as a list `[i, j]` in ascending order of indices. If there are no such pairs, return an empty list.","solution":"def find_closest_pair(arr, target): Finds a pair of indices (i, j) such that arr[i] + arr[j] is closest to the target. :param arr: List of integers :param target: Target integer :return: A list of two indices [i, j] in ascending order if found, otherwise an empty list if not arr or len(arr) < 2: return [] closest_pair = [] closest_diff = float(\'inf\') for i in range(len(arr) - 1): for j in range(i + 1, len(arr)): current_sum = arr[i] + arr[j] current_diff = abs(target - current_sum) if current_diff < closest_diff: closest_diff = current_diff closest_pair = [i, j] return closest_pair"},{"question":"You are given a binary tree in which each node contains an integer value. Design an algorithm to find the lowest common ancestor (LCA) of two given nodes in the tree. The LCA of two nodes p and q in a binary tree is the deepest node that is an ancestor of both p and q. A node can be its own ancestor. Implement the `TreeNode` class where each node contains three attributes: `val` (integer value of the node), `left` (reference to the left child node), and `right` (reference to the right child node). Then, implement the `Solution` class with the method `TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)` which returns a pointer to the LCA of nodes `p` and `q`. Example: ``` 3 / 5 1 / / 6 2 0 8 / 7 4 ``` In the above tree, the LCA of nodes 5 and 1 is 3. The LCA of nodes 5 and 4 is 5.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def lowestCommonAncestor(self, root, p, q): if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right"},{"question":"Given a **sorted** integer array `nums` and an integer `k`, return the maximum sum of three non-overlapping subarrays of length `k` that can be found in `nums`. The function should also return the three starting indices of these subarrays as a list. In case of multiple answers with the same maximum sum, return the lexicographically smallest list of starting indices.","solution":"def max_sum_of_three_subarrays(nums, k): Return the maximum sum of three non-overlapping subarrays of length k, and the starting indices of these subarrays. n = len(nums) sum_k = [0] * (n - k + 1) current_sum = sum(nums[:k]) sum_k[0] = current_sum for i in range(1, n - k + 1): current_sum = current_sum - nums[i - 1] + nums[i + k - 1] sum_k[i] = current_sum left = [0] * len(sum_k) right = [0] * len(sum_k) best_left = 0 best_right = len(sum_k) - 1 for i in range(len(sum_k)): if sum_k[i] > sum_k[best_left]: best_left = i left[i] = best_left for i in range(len(sum_k) - 1, -1, -1): if sum_k[i] >= sum_k[best_right]: best_right = i right[i] = best_right max_sum = 0 result = [0, 0, 0] for j in range(k, len(sum_k) - k): i, l = left[j - k], right[j + k] current_sum = sum_k[i] + sum_k[j] + sum_k[l] if current_sum > max_sum: max_sum = current_sum result = [i, j, l] return max_sum, result"},{"question":"You are given a binary tree where each node has an integer value. Design an algorithm to find the maximum sum of values starting from any node and visiting each node exa`ctly once (i.e., an acyclic path). You can start and end at any node, but you must visit each node only once during the traversal. _Return the maximum path sum_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum path sum in the binary tree. def dfs(node): if not node: return (0, float(\'-inf\')) # (path sum, max path sum seen so far) left_sum, left_max = dfs(node.left) right_sum, right_max = dfs(node.right) # Max path sum including current node (path cannot split here) current_sum = max(left_sum + node.val, right_sum + node.val, node.val) # Max path sum for the current subtree subtree_sum = max(left_max, right_max, current_sum, left_sum + node.val + right_sum) return current_sum, subtree_sum return dfs(root)[1]"},{"question":"You are given a string `s` consisting of lowercase alphabets and parentheses. You need to determine if the parentheses are **balanced** and **nested correctly**. In `s`, parentheses can exist both independently or within substrings of alphabetic characters. Write a function `isValidParentheses(s: str) -> bool` that returns `True` if the parentheses are balanced and nested correctly, and `False` otherwise. For example: - `isValidParentheses(\\"(a)(b(c)d)e)\\")` should return `False` because the last parenthesis is not opened. - `isValidParentheses(\\"(a(b)(c)d)\\")` should return `True` as all parentheses are balanced and correctly nested.","solution":"def isValidParentheses(s: str) -> bool: Returns True if the parentheses in the given string are balanced and nested correctly, else False. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"You are given an integer array `heights` representing the heights of students in a line. The array `heights` is **0-indexed** and sorted in **non-decreasing** order. Your task is to form the **smallest** number of groups of students such that the height difference between the tallest and shortest student in each group is no more than `k`. Return the number of groups formed. Note that each student should be included in exactly one group.","solution":"def min_groups(heights, k): Returns the minimum number of groups formed such that the height difference between the tallest and shortest student in each group is no more than k. if not heights: return 0 groups = 1 min_height = heights[0] for height in heights: if height - min_height > k: groups += 1 min_height = height return groups"},{"question":"You are given a string `s` which represents a valid mathematical expression. The expression contains only non-negative integers, arithmetic operators `+`, `-`, `*`, and `(`, `)`. The task is to design a function to evaluate this expression and return its result. The integer division should be truncated towards zero. The expression will be a valid string that follows standard mathematical notations and does not contain any invalid characters. For example: - If `s = \\"3+(2*2)\\"`, the output should be `7`. - If `s = \\" 3/2 \\"`, the output should be `1`. - If `s = \\" 3+5 / 2 \\"`, the output should be `5`. Write a function that takes the string `s` as input and returns the result of evaluating the expression as an integer.","solution":"def calculate(s): def evaluate_expression(tokens): stack = [] num, sign = 0, 1 op_priorities = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} operators = [] def apply_operator(op, b, a): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': return int(a / b) i = 0 while i < len(tokens): token = tokens[i] if token.isdigit(): num = int(token) while i + 1 < len(tokens) and tokens[i + 1].isdigit(): i += 1 num = num * 10 + int(tokens[i]) stack.append(num) elif token in op_priorities: while (operators and operators[-1] in op_priorities and op_priorities[operators[-1]] >= op_priorities[token]): stack.append(apply_operator(operators.pop(), stack.pop(), stack.pop())) operators.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': stack.append(apply_operator(operators.pop(), stack.pop(), stack.pop())) operators.pop() i += 1 while operators: stack.append(apply_operator(operators.pop(), stack.pop(), stack.pop())) return stack[0] tokens = [] i = 0 while i < len(s): if s[i].isdigit(): start = i while i < len(s) and s[i].isdigit(): i += 1 tokens.append(s[start:i]) continue elif s[i] in \'+-*/()\': tokens.append(s[i]) i += 1 return evaluate_expression(tokens)"},{"question":"You are given a string `expression` that represents a mathematical expression containing only non-negative integers and the operators `\'+\'`, `\'-\'`, and `\'*\'`. You need to add parentheses to the expression to change its computation order in all possible ways and return the distinct results of all possible valid expressions. You may return the answer in any order. For example, given the expression `\\"2-1-1\\"`, by adding parentheses in different ways, we get different results: `((2-1)-1) = 0` and `(2-(1-1)) = 2`. Return _a list of all possible results obtained by adding parentheses in all possible ways to_ `expression`.","solution":"def diffWaysToCompute(expression): This function computes all possible results from computing all the different possible ways to group numbers and operators in the input expression. # Base case if expression.isdigit(): return [int(expression)] results = [] for index, char in enumerate(expression): if char in \\"+-*\\": left_results = diffWaysToCompute(expression[:index]) right_results = diffWaysToCompute(expression[index+1:]) for left in left_results: for right in right_results: if char == \'+\': results.append(left + right) elif char == \'-\': results.append(left - right) elif char == \'*\': results.append(left * right) return results"}]'),N={name:"App",components:{PoemCard:Y},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},L={class:"card-container"},z={key:0,class:"empty-state"},C=["disabled"],S={key:0},E={key:1};function D(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):l("",!0)]),t("div",L,[(n(!0),r(y,null,v(a.displayedPoems,(o,g)=>(n(),w(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",z,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",E,"Loading...")):(n(),r("span",S,"See more"))],8,C)):l("",!0)])}const G=m(N,[["render",D],["__scopeId","data-v-38bf53a0"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/4.md","filePath":"library/4.md"}'),P={name:"library/4.md"},M=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{B as __pageData,M as default};
