import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-03c26d87"]]),S=JSON.parse('[{"question":"# Tic-Tac-Toe Validator Context You are tasked with creating a validator for a game of Tic-Tac-Toe. The game is played on a 3x3 grid, and the players take turns marking a cell with either \'X\' or \'O\'. The objective is for a player to place three of their marks in a horizontal, vertical, or diagonal row to win the game. If all cells are filled and no player has achieved this, the game is a draw. Task Implement a class `TicTacToe` in Python that supports the following operations: 1. Initialization of an empty Tic-Tac-Toe board. 2. Adding a move to the board. 3. Checking the current state of the game (win, draw, or ongoing). 4. Retrieving the current state of the board as a string. Requirements 1. **Initialization**: - The constructor should initialize an empty 3x3 board. ```python def __init__(self) -> None: ``` 2. **Make a Move**: - The method should take the row and column numbers (0-based) and the player\'s mark (\'X\' or \'O\'). - Raise a `ValueError` if the cell is already occupied or if the row/column numbers are out of bounds. ```python def make_move(self, row: int, col: int, player: str) -> None: ``` 3. **Check Game State**: - The method should return \'X\' if player \'X\' has won, \'O\' if player \'O\' has won, \'Draw\' if all cells are filled and there\'s no winner, or \'Ongoing\' if the game is still in progress. ```python def get_game_state(self) -> str: ``` 4. **String Representation**: - The method should return a string representation of the current board state. ```python def __str__(self) -> str: ``` Example: ```python game = TicTacToe() print(game) # Should display an empty Tic-Tac-Toe board game.make_move(0, 0, \'X\') print(game) # Should display the board with \'X\' in the top-left corner game.make_move(1, 1, \'O\') print(game) # Should display the board with \'O\' in the center state = game.get_game_state() print(state) # Should return \'Ongoing\' game.make_move(0, 1, \'X\') game.make_move(0, 2, \'X\') state = game.get_game_state() print(state) # Should return \'X\' after the winning move ``` Constraints: - Ensure that only valid moves are accepted. - The board state should be correctly updated after each move. - The game should correctly identify all possible winning states (horizontal, vertical, diagonal). Input and Output Formats: - **Initialization**: `TicTacToe()` initializes an empty board. - **Make a Move**: `game.make_move(0, 0, \'X\')` updates the board with \'X\' at position (0, 0). - **Check Game State**: `game.get_game_state()` returns \'X\', \'O\', \'Draw\', or \'Ongoing\'. - **String Representation**: `print(game)` returns a string showing the current board. By adhering to these guidelines, create and verify the `TicTacToe` class to ensure its functionality. Using this set, expand on supplemental concepts such as game-state validation logic, user error handling, and clear encapsulation of game mechanics.","solution":"class TicTacToe: def __init__(self): self.board = [[\' \' for _ in range(3)] for _ in range(3)] self.moves_count = 0 def make_move(self, row: int, col: int, player: str) -> None: if player not in [\'X\', \'O\']: raise ValueError(\\"Player must be \'X\' or \'O\'\\") if not (0 <= row < 3 and 0 <= col < 3): raise ValueError(\\"Row and column must be between 0 and 2\\") if self.board[row][col] != \' \': raise ValueError(\\"Cell already occupied\\") self.board[row][col] = player self.moves_count += 1 def get_game_state(self) -> str: # Check rows for row in self.board: if row[0] == row[1] == row[2] != \' \': return row[0] # Check columns for col in range(3): if self.board[0][col] == self.board[1][col] == self.board[2][col] != \' \': return self.board[0][col] # Check diagonals if self.board[0][0] == self.board[1][1] == self.board[2][2] != \' \': return self.board[0][0] if self.board[0][2] == self.board[1][1] == self.board[2][0] != \' \': return self.board[0][2] # Check draw if self.moves_count == 9: return \'Draw\' # Game ongoing return \'Ongoing\' def __str__(self) -> str: return \'n\'.join([\' \'.join(row) for row in self.board])"},{"question":"# Basic Statistical Functions Package You are tasked with implementing a small package that provides basic statistical functions. Your package should include functions for computing the mean, median, and standard deviation of a list of numbers. Ensure your implementations are efficient and handle edge cases appropriately. Objective Create a Python package with three functions: `mean`, `median`, and `std_dev`. These functions should compute the respective statistical measures for a given list of numerical values. # Tasks 1. **mean(values)**: - Computes the average of the provided list of numbers. - Handles empty lists by returning `None`. 2. **median(values)**: - Returns the median value of the provided list of numbers. - Ensures the function handles both even and odd list lengths. - Handles empty lists by returning `None`. 3. **std_dev(values)**: - Computes the standard deviation of the list. - Uses the sample standard deviation formula. - Handles lists with fewer than two elements by returning `None`. # Input/Output - **mean function**: - **Input**: - `values`: A list of numerical values. - **Output**: A single floating-point number representing the mean or `None` for an empty list. - **median function**: - **Input**: - `values`: A list of numerical values. - **Output**: A single floating-point number representing the median or `None` for an empty list. - **std_dev function**: - **Input**: - `values`: A list of numerical values. - **Output**: A single floating-point number representing the standard deviation or `None` for lists of length less than two. # Constraints - The input list contains only numerical values (integers or floats). - The functions should handle edge cases such as empty lists or small list lengths gracefully. # Sample Usage ```python values = [2, 5, 1, 3, 4] print(mean(values)) # Expected output: 3.0 print(median(values)) # Expected output: 3.0 print(std_dev(values)) # Expected output: 1.58 (approximately) empty_list = [] print(mean(empty_list)) # Expected output: None print(median(empty_list)) # Expected output: None print(std_dev(empty_list)) # Expected output: None ``` # Considerations - Ensure that your functions are efficient and handle various edge cases. - Avoid using external libraries; rely on core Python functionality. - Ensure appropriate error handling and input validation. Write your implementation of the `mean`, `median`, and `std_dev` functions below.","solution":"def mean(values): Computes the mean (average) of a list of numbers. :param values: List of numerical values :return: Mean of the values or None for an empty list if not values: return None return sum(values) / len(values) def median(values): Computes the median of a list of numbers. :param values: List of numerical values :return: Median of the values or None for an empty list if not values: return None sorted_values = sorted(values) length = len(sorted_values) midpoint = length // 2 if length % 2 == 0: return (sorted_values[midpoint - 1] + sorted_values[midpoint]) / 2.0 else: return sorted_values[midpoint] def std_dev(values): Computes the sample standard deviation of a list of numbers. :param values: List of numerical values :return: Standard deviation of the values or None for lists of length less than two if len(values) < 2: return None mean_val = mean(values) variance = sum((x - mean_val) ** 2 for x in values) / (len(values) - 1) return variance ** 0.5"},{"question":"# URL Shortener You are tasked with creating a URL shortener function. The function should generate a short unique URL for a given long URL and store the mapping of the short URL to the long URL. You should also provide a way to retrieve the original long URL given a short URL. For simplicity, assume you can use an in-memory dictionary to store the mappings. # Function Signatures ```python def shorten_url(long_url: str) -> str: ... def retrieve_long_url(short_url: str) -> str: ... ``` # Input Descriptions 1. `long_url` (str): The original URL that needs to be shortened. 2. `short_url` (str): The shortened URL that was previously generated. # Output Descriptions 1. `shorten_url(long_url: str) -> str`: Returns the shortened URL. 2. `retrieve_long_url(short_url: str) -> str`: Returns the original long URL that corresponds to the given short URL. # Constraints 1. If the provided long URL is already shortened, return the existing short URL. 2. If the provided short URL does not exist in the storage, the function should raise a `ValueError` with an appropriate message. 3. Assume the short URL will have a base domain of `http://short.url/` followed by a unique identifier. # Example ```python shortened = shorten_url(\\"https://www.example.com\\") print(shortened) # Expected output: \\"http://short.url/abc123\\" original = retrieve_long_url(\\"http://short.url/abc123\\") print(original) # Expected output: \\"https://www.example.com\\" # Querying an unknown short URL try: retrieve_long_url(\\"http://short.url/unknown\\") except ValueError as e: print(e) # Expected output: \\"Short URL does not exist.\\" ``` # Additional Information 1. Use a suitable algorithm to generate unique identifiers for the short URLs. 2. You may use the `hashlib` module to create hashes if desired. 3. Ensure that your implementation efficiently handles multiple long URLs and provides fast retrieval times. 4. Include necessary error handling for invalid URLs. If the input for long_url is not a valid URL format, the function should raise a `ValueError`. # Expected Implementation ```python import hashlib url_mapping = {} reverse_mapping = {} def shorten_url(long_url: str) -> str: # Validate the URL format (simplified check just for illustration) if not long_url.startswith((\'http://\', \'https://\')): raise ValueError(\'Invalid URL format\') if long_url in reverse_mapping: return reverse_mapping[long_url] # Generate a short identifier using hashing (e.g., MD5 or SHA256) hasher = hashlib.md5(long_url.encode()) short_id = hasher.hexdigest()[:6] # e.g., \\"abc123\\" short_url = f\\"http://short.url/{short_id}\\" url_mapping[short_url] = long_url reverse_mapping[long_url] = short_url return short_url def retrieve_long_url(short_url: str) -> str: if short_url not in url_mapping: raise ValueError(\\"Short URL does not exist.\\") return url_mapping[short_url] ``` This question challenges the applicant to implement a URL shortener utility which involves string processing, dictionary management, and basic hashing techniques. It tests their ability to handle mappings and error conditions, ensuring the robustness of their solution.","solution":"import hashlib url_mapping = {} reverse_mapping = {} def shorten_url(long_url: str) -> str: Generate a short unique URL for a given long URL and store the mapping of the short URL to the long URL. # Validate the URL format (simplified check) if not long_url.startswith((\'http://\', \'https://\')): raise ValueError(\'Invalid URL format\') # Return the existing short URL if the long URL was already shortened if long_url in reverse_mapping: return reverse_mapping[long_url] # Generate a short identifier using hashing (MD5) hasher = hashlib.md5(long_url.encode()) short_id = hasher.hexdigest()[:6] # e.g., \\"abc123\\" short_url = f\\"http://short.url/{short_id}\\" # Store the mappings url_mapping[short_url] = long_url reverse_mapping[long_url] = short_url return short_url def retrieve_long_url(short_url: str) -> str: Retrieve the original long URL given a short URL. if short_url not in url_mapping: raise ValueError(\\"Short URL does not exist.\\") return url_mapping[short_url]"},{"question":"# Circular Buffer Implementation You are tasked with implementing a circular buffer (or ring buffer) data structure in Python. A circular buffer is a fixed-size data structure that works as a FIFO (first-in, first-out) queue but optimizes space by riding over the oldest elements when new elements are added to the buffer that is already full. # Input Your task is to write a class `CircularBuffer` with the following methods: 1. **__init__(self, size)**: Initializes the buffer with a given size. 2. **insert(self, value)**: Inserts an element into the buffer. If the buffer is full, it should overwrite the oldest element. 3. **get(self)**: Retrieves and removes the oldest element from the buffer. Returns `None` if the buffer is empty. 4. **__str__(self)**: Returns a string representation of the buffer contents in the insertion order, from oldest to newest. # Constraints * The size of the buffer is a positive integer (1 <= size <= 1000). * The values inserted into the buffer are integers. * Ensure efficient utilization of computational resources and minimize unnecessary operations. # Example ```python # Create a circular buffer of size 3 buffer = CircularBuffer(3) # Insert elements into the buffer buffer.insert(10) buffer.insert(20) buffer.insert(30) # The buffer is now [10, 20, 30] print(str(buffer)) # Output: \\"10, 20, 30\\" # Get the oldest element (10) print(buffer.get()) # Output: 10 # Insert a new element, overwriting the oldest element (20) buffer.insert(40) # The buffer is now [20, 30, 40] print(str(buffer)) # Output: \\"20, 30, 40\\" # Continue getting elements print(buffer.get()) # Output: 20 print(buffer.get()) # Output: 30 print(buffer.get()) # Output: 40 # The buffer is now empty print(buffer.get()) # Output: None ``` # Implementation Hints * Use a fixed-size list to represent the buffer and maintain pointers/indexes to track the start and end positions for insertion and retrieval. * Be sure to handle edge cases, such as inserting into a full buffer and retrieving from an empty buffer, efficiently. Write a `CircularBuffer` class with the specified methods ensuring the buffer operates as described.","solution":"class CircularBuffer: def __init__(self, size): Initializes the buffer with a given size. self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.count = 0 def insert(self, value): Inserts an element into the buffer. If the buffer is full, it overwrites the oldest element. if self.count == self.size: self.start = (self.start + 1) % self.size else: self.count += 1 self.buffer[self.end] = value self.end = (self.end + 1) % self.size def get(self): Retrieves and removes the oldest element from the buffer. Returns None if the buffer is empty. if self.count == 0: return None value = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.size self.count -= 1 return value def __str__(self): Returns a string representation of the buffer contents in the insertion order, from oldest to newest. elements = [] index = self.start for _ in range(self.count): elements.append(self.buffer[index]) index = (index + 1) % self.size return \\", \\".join(str(e) for e in elements)"},{"question":"# Coding Question **Context**: A logistics company tracks the delivery status of packages in various cities. For internal reporting, they need to calculate the average delivery time for each city. However, they occasionally need to correct errors in the data, such as incorrect delivery times. **Task**: Write a Python function `update_and_calculate_average` that: 1. Receives a dictionary containing city names as keys and lists of delivery times (in hours) as values. 2. Allows updating the delivery time for a particular package in a specific city. 3. Calculates and returns the updated average delivery time for that city. **Function Signature**: ```python def update_and_calculate_average(delivery_data: dict[str, list[int]], city: str, package_index: int, new_time: int) -> float: Updates the delivery time for a specific package in a city and returns the updated average delivery time for that city. :param delivery_data: dict - a dictionary with city names as keys and lists of delivery times as values :param city: str - the name of the city for which to update the delivery time :param package_index: int - the index of the package in the city\'s delivery time list :param new_time: int - the new delivery time to be set for the package :return: float - the updated average delivery time for the specified city pass ``` **Constraints**: * If the `city` or `package_index` does not exist in the dictionary, the function should raise an appropriate exception. * Ensure the function handles negative delivery times appropriately (e.g., by raising an exception as they are not valid). * The function should handle edge cases such as empty lists and provide meaningful feedback. **Example**: Given the `delivery_data` dictionary with initial values: ```python delivery_data = { \\"New York\\": [9, 5, 8, 6], \\"Los Angeles\\": [7, 4, 7, 10], \\"Chicago\\": [10, 12, 8] } ``` When calling `update_and_calculate_average(delivery_data, \\"Los Angeles\\", 2, 8)`, the `delivery_data` dictionary will be updated to: ```python { \\"New York\\": [9, 5, 8, 6], \\"Los Angeles\\": [7, 4, 8, 10], \\"Chicago\\": [10, 12, 8] } ``` The function should return `7.25` as the updated average delivery time for \\"Los Angeles\\". Ensure your implementation is efficient and considers edge cases, such as trying to update non-existent cities or package indices.","solution":"def update_and_calculate_average(delivery_data, city, package_index, new_time): Updates the delivery time for a specific package in a city and returns the updated average delivery time for that city. :param delivery_data: dict - a dictionary with city names as keys and lists of delivery times as values :param city: str - the name of the city for which to update the delivery time :param package_index: int - the index of the package in the city\'s delivery time list :param new_time: int - the new delivery time to be set for the package :return: float - the updated average delivery time for the specified city if city not in delivery_data: raise ValueError(\\"City not found in delivery data\\") if package_index < 0 or package_index >= len(delivery_data[city]): raise IndexError(\\"Package index out of range\\") if new_time < 0: raise ValueError(\\"Delivery time cannot be negative\\") # Update the delivery time delivery_data[city][package_index] = new_time # Calculate the updated average delivery time for the city total_time = sum(delivery_data[city]) number_of_deliveries = len(delivery_data[city]) average_time = total_time / number_of_deliveries return average_time"},{"question":"# Problem Statement In a robotic system, robots are arranged in a grid of size `n x m`. Each cell in the grid contains either a `1` (robot) or `0` (empty space). The robots are trained to clean adjacent cells but they cannot move to diagonally adjacent cells. Your objective is to compute the total number of distinct groups of robots. A group is defined as one or more robots that are connected directly vertically or horizontally. # Task Implement function `count_robot_groups(grid: List[List[int]]) -> int` which takes a 2D list `grid` as input and returns the number of distinct groups of robots. # Requirements * The function must efficiently identify and count all robot groups within the grid. * Validate the input to ensure it is a proper 2D list. # Function Signature ```python from typing import List def count_robot_groups(grid: List[List[int]]) -> int: Args: grid (List[List[int]]): 2D grid of robots and empty spaces. Returns: int: Number of distinct groups of robots. Raises: ValueError: If grid contains elements other than 0 or 1, or if it isn\'t a proper 2D list. ``` # Constraints * `1 <= len(grid) <= 1000` * `1 <= len(grid[0]) <= 1000` * Each cell in the grid will be either `0` or `1`. # Example ```python # Example 1 assert count_robot_groups([[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 0], [0, 1, 1, 0]]) == 3 # Example 2 assert count_robot_groups([[1, 0, 0], [0, 1, 1], [1, 1, 0]]) == 2 # Example 3 assert count_robot_groups([[1]]) == 1 # Example 4 assert count_robot_groups([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 ``` # Explanation In each example: - **Example 1**: There are three groups of robots: two individual groups (top-left, bottom-right) and one cluster (bottom-left). - **Example 2**: There are two groups of robots: one horizontal cluster and one larger vertical cluster. - **Example 3**: Only one robot exists, so there is one group. - **Example 4**: No robots exist, so there are no groups.","solution":"from typing import List def count_robot_groups(grid: List[List[int]]) -> int: def dfs(x: int, y: int): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != 1: return grid[x][y] = -1 # Mark as visited # Move in 4 possible directions: up, down, left, right dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) if not grid or not isinstance(grid, list) or not all(isinstance(row, list) for row in grid): raise ValueError(\\"Input must be a 2D list\\") n_rows = len(grid) n_cols = len(grid[0]) # Validate input for row in grid: if len(row) != n_cols or any(cell not in (0, 1) for cell in row): raise ValueError(\\"Each cell in grid must be either 0 or 1 and all rows must have the same length\\") robot_groups = 0 for i in range(n_rows): for j in range(n_cols): if grid[i][j] == 1: robot_groups += 1 dfs(i, j) return robot_groups"},{"question":"# Image Compression with Run-Length Encoding **Context:** Image compression is a crucial technique for reducing the storage space and transmission time of images. One simple and effective method for compressing simple binary images (images composed of only two colors) is Run-Length Encoding (RLE). **Objective:** Write a function `compress_image(image: List[List[int]]) -> List[List[Tuple[int, int]]]` that compresses a binary image using RLE. Each row of the image should be compressed separately and returned as a list of tuples, where each tuple represents a segment of consecutive pixels of the same color with its length. **Function Signature:** ```python from typing import List, Tuple def compress_image(image: List[List[int]]) -> List[List[Tuple[int, int]]]: pass ``` **Inputs:** * `image` (List[List[int]]): A binary image represented as a list of lists of integers (0s and 1s), where each list represents a row of pixels. (1 ≤ len(image), len(image[0]) ≤ 1000). **Outputs:** * List of lists of tuples: A list where each sublist contains tuples representing the run-length encoding of the corresponding row in the input image. Each tuple (color, length) denotes a segment\'s color and length. **Example:** ```python >>> image = [ ... [1, 1, 0, 0, 0, 1], ... [1, 1, 1, 1, 0, 0], ... [0, 0, 1, 1, 1, 1] ... ] >>> compress_image(image) [[(1, 2), (0, 3), (1, 1)], [(1, 4), (0, 2)], [(0, 2), (1, 4)]] >>> image = [ ... [0, 0, 0], ... [1, 1, 1] ... ] >>> compress_image(image) [[(0, 3)], [(1, 3)]] ``` **Challenge:** Implement the function `compress_image` to efficiently handle images with the maximum number of rows and columns while providing an accurate run-length encoding for each row.","solution":"from typing import List, Tuple def compress_image(image: List[List[int]]) -> List[List[Tuple[int, int]]]: Compresses a binary image using Run-Length Encoding (RLE). Args: image (List[List[int]]): The 2D binary image to compress. Returns: List[List[Tuple[int, int]]]: The RLE compressed image. compressed_image = [] for row in image: compressed_row = [] current_color = row[0] current_length = 0 for pixel in row: if pixel == current_color: current_length += 1 else: compressed_row.append((current_color, current_length)) current_color = pixel current_length = 1 # Don\'t forget to append the last segment compressed_row.append((current_color, current_length)) compressed_image.append(compressed_row) return compressed_image"},{"question":"# Coding Assessment Question Problem Statement You are tasked with writing a function that simulates an elevator system in a building with multiple floors. The elevator follows a series of requests to move up or down and stops at requested floors to pick up or drop off passengers. Input Format - An integer `N` representing the total number of floors in the building. - An integer `initial_floor` representing the starting floor of the elevator (0-indexed). - A list of tuples `requests` where each tuple contains two integers `(start_floor, destination_floor)` defining a request from a `start_floor` to a `destination_floor`. Output Format - An integer representing the total number of stops the elevator makes to fulfill all requests. Constraints - 1 <= N <= 100 - 0 <= initial_floor < N - 0 <= start_floor, destination_floor < N for all requests Example ```python N = 10 initial_floor = 0 requests = [(0, 5), (2, 8), (4, 3), (7, 6)] print(simulate_elevator(N, initial_floor, requests)) # Expected Output: 6 ``` Function Signature ```python def simulate_elevator(N: int, initial_floor: int, requests: list[tuple[int, int]]) -> int: pass ``` Requirements 1. Implement the `simulate_elevator` function that follows the above description. 2. Optimize the solution to handle a large number of requests efficiently. 3. Ensure the output is the minimum number of stops required to satisfy all requests.","solution":"def simulate_elevator(N: int, initial_floor: int, requests: list[tuple[int, int]]) -> int: Simulates an elevator system given the total number of floors, the initial floor, and a list of requests. Returns the total number of stops the elevator makes to fulfill all requests. # Collect all distinct stops, starting from the initial floor stops = {initial_floor} # Iterate through each request for start_floor, destination_floor in requests: stops.add(start_floor) stops.add(destination_floor) return len(stops)"},{"question":"# Context You are tasked with implementing a simple dictionary-based spell checker that verifies the accuracy of a given list of words. The spell checker should support adding words to its dictionary, checking if words are spelled correctly, and suggesting possible correct spellings based on a prefix match. # Task Design a class `SpellChecker` that supports the following operations: 1. **Add a word**: Insert a word into the spell checker’s dictionary. 2. **Check if a word is correct**: Verify if a word exists in the dictionary. 3. **Suggest words**: Given a prefix, suggest all dictionary words that start with this prefix. Words in the dictionary are case-insensitive. Implement methods with the following signatures: ```python class SpellChecker: def add_word(self, word: str) -> None: pass def check_word(self, word: str) -> bool: pass def suggest_words(self, prefix: str) -> List[str]: pass ``` # Requirements 1. Implement the dictionary using an appropriate data structure that allows efficient prefix-matching operations. 2. Your `add_word` method should have an average-case time complexity of O(1). 3. The `check_word` method should have an average-case time complexity of O(1). 4. The `suggest_words` method should have an average-case time complexity of O(k + m), where k is the length of the prefix and m is the number of words that match the prefix. # Constraints * Words are lowercased and contain only alphabetical characters. * The spell checker should ignore case when checking words and suggesting words (case-insensitive). * The dictionary can contain up to 10^5 words. * Each word has a maximum length of 50 characters. # Example ```python checker = SpellChecker() checker.add_word(\\"hello\\") checker.add_word(\\"hell\\") checker.add_word(\\"helium\\") print(checker.check_word(\\"hello\\")) # Output: True print(checker.check_word(\\"helloo\\")) # Output: False print(checker.suggest_words(\\"hel\\")) # Output: [\\"hello\\", \\"hell\\", \\"helium\\"] print(checker.suggest_words(\\"heaven\\")) # Output: [] ``` Submission Submit a class `SpellChecker` implemented in Python, ensuring it manages the dictionary and performs the specified operations efficiently as described.","solution":"from typing import List class SpellChecker: def __init__(self): self.dictionary = set() self.prefix_dict = {} def add_word(self, word: str) -> None: word = word.lower() self.dictionary.add(word) for i in range(1, len(word) + 1): prefix = word[:i] if prefix in self.prefix_dict: if word not in self.prefix_dict[prefix]: self.prefix_dict[prefix].append(word) else: self.prefix_dict[prefix] = [word] def check_word(self, word: str) -> bool: return word.lower() in self.dictionary def suggest_words(self, prefix: str) -> List[str]: prefix = prefix.lower() return self.prefix_dict.get(prefix, [])"},{"question":"**Context**: You need to develop a class for a simplified in-memory database that can handle a predefined set of SQL-like commands to interact with tabular data. The in-memory database should support dynamic management of data and structures. **Objective**: Implement a class `InMemoryDB` that provides basic functionalities to create tables, insert rows, fetch rows and update records using specified criteria. # Requirements: 1. **Class Structure**: Your `InMemoryDB` class should provide methods for creating tables, inserting data, fetching data, and updating records: * `create_table`: Create a new table with specified columns. * `insert_row`: Insert a row into a specified table. * `fetch_rows`: Fetch rows from a specified table based on criteria. * `update_rows`: Update rows in a specified table based on criteria. # Define Class Structure ```python class InMemoryDB: def __init__(self): self.tables = {} # Dictionary to store tables def create_table(self, table_name: str, columns: list): Create a new table with the specified columns. # Implement table creation logic def insert_row(self, table_name: str, row: dict): Insert a row into the specified table. # Implement row insertion logic def fetch_rows(self, table_name: str, criteria: dict) -> list: Fetch rows from the specified table based on criteria. # Implement row fetching logic def update_rows(self, table_name: str, criteria: dict, updates: dict): Update rows in the specified table based on criteria. # Implement row updating logic ``` # Instructions 1. **Initialization**: Initialize the `InMemoryDB` class with an empty dictionary to store tables. 2. **Table Creation**: * `create_table` method should take a table name and a list of column names. * Create a table as a dictionary of column names to an empty list. 3. **Row Insertion**: * `insert_row` method should take a table name and a dictionary representing a row. * Insert the row by appending values to the corresponding columns. 4. **Fetching Rows**: * `fetch_rows` method should take a table name and a dictionary of criteria (column-value pairs). * Return all rows that match the criteria. 5. **Updating Rows**: * `update_rows` method should take a table name, a dictionary of criteria, and another dictionary of updates. * Update rows that match the criteria with new values from the updates dictionary. # Constraints * `table_name` is always a string. * `columns` is a list of non-empty strings. * `row`, `criteria`, and `updates` are dictionaries with string keys. # Example ```python # Example usage db = InMemoryDB() db.create_table(\'users\', [\'id\', \'name\', \'email\']) db.insert_row(\'users\', {\'id\': 1, \'name\': \'Alice\', \'email\': \'alice@example.com\'}) db.insert_row(\'users\', {\'id\': 2, \'name\': \'Bob\', \'email\': \'bob@example.com\'}) print(db.fetch_rows(\'users\', {\'id\': 1})) # Fetch row where id is 1 db.update_rows(\'users\', {\'id\': 2}, {\'email\': \'bob@newdomain.com\'}) # Update email for id 2 ```","solution":"class InMemoryDB: def __init__(self): self.tables = {} # Dictionary to store tables def create_table(self, table_name: str, columns: list): Create a new table with the specified columns. if table_name in self.tables: raise ValueError(f\\"Table {table_name} already exists.\\") self.tables[table_name] = {col: [] for col in columns} def insert_row(self, table_name: str, row: dict): Insert a row into the specified table. if table_name not in self.tables: raise ValueError(f\\"Table {table_name} does not exist.\\") table = self.tables[table_name] for col in table: if col in row: table[col].append(row[col]) else: table[col].append(None) # Add None if column value is missing def fetch_rows(self, table_name: str, criteria: dict) -> list: Fetch rows from the specified table based on criteria. if table_name not in self.tables: raise ValueError(f\\"Table {table_name} does not exist.\\") table = self.tables[table_name] rows = [] num_rows = len(next(iter(table.values()))) for i in range(num_rows): match = True row = {col: table[col][i] for col in table} for col, value in criteria.items(): if row.get(col) != value: match = False break if match: rows.append(row) return rows def update_rows(self, table_name: str, criteria: dict, updates: dict): Update rows in the specified table based on criteria. if table_name not in self.tables: raise ValueError(f\\"Table {table_name} does not exist.\\") table = self.tables[table_name] num_rows = len(next(iter(table.values()))) for i in range(num_rows): match = True for col, value in criteria.items(): if table[col][i] != value: match = False break if match: for col, value in updates.items(): if col in table: table[col][i] = value"},{"question":"# Problem Description You are tasked with implementing a function to order the processing of tasks based on their dependencies. This is a common problem in scenarios like build systems, project management, and task scheduling. The tasks and their dependencies are represented as a directed acyclic graph. # Objective Implement the following function: ```python def find_task_order(num_tasks: int, dependencies: list[tuple[int, int]]) -> list[int]: Determines the order in which tasks should be completed given their dependencies. Parameters: num_tasks (int): The total number of tasks, numbered from 0 to num_tasks - 1. dependencies (list of tuple of int): A list of dependencies where each tuple (a, b) means task a depends on task b. Returns: list of int: A list representing the order in which tasks can be completed. If no valid order exists, return an empty list. ``` # Input * `num_tasks`: an integer representing the total number of tasks. * `dependencies`: a list of tuples, where each tuple `(a, b)` indicates that task `a` depends on task `b` (task `b` must be done before task `a`). # Output * A list of integers representing a valid task order. If no valid order exists, return an empty list. # Constraints * 1 <= `num_tasks` <= 10^3 * 0 <= len(`dependencies`) <= 10^4 * Each task is represented by a unique integer from 0 to `num_tasks` - 1. * No duplicate dependencies are given. # Example ```python # Example 1 num_tasks = 4 dependencies = [(1, 0), (2, 1), (3, 1), (3, 2)] # Function call result = find_task_order(num_tasks, dependencies) # Expected output could be # [0, 1, 2, 3] or [0, 1, 3, 2] # Example 2 num_tasks = 2 dependencies = [(1, 0), (0, 1)] # Function call result = find_task_order(num_tasks, dependencies) # Expected output # [] ``` Implement the `find_task_order` function to complete the task.","solution":"from collections import deque, defaultdict def find_task_order(num_tasks: int, dependencies: list[tuple[int, int]]) -> list[int]: Determines the order in which tasks should be completed given their dependencies. Parameters: num_tasks (int): The total number of tasks, numbered from 0 to num_tasks - 1. dependencies (list of tuple of int): A list of dependencies where each tuple (a, b) means task a depends on task b. Returns: list of int: A list representing the order in which tasks can be completed. If no valid order exists, return an empty list. # Initialize in-degree array and adjacency list in_degree = [0] * num_tasks adj_list = defaultdict(list) # Build the graph for a, b in dependencies: adj_list[b].append(a) in_degree[a] += 1 # Initialize the queue with nodes having 0 in-degree queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If the order size is not equal to num_tasks, there was a cycle if len(order) != num_tasks: return [] return order"},{"question":"# Movie Recommendation System You have been tasked with writing a function that recommends a list of movies based on a given genre. The function should read a CSV file containing movie data, filter the movies by the specified genre, and return the titles of the top five movies sorted by their user ratings. Function Signature ```python def recommend_movies(genre: str) -> List[str]: ``` Input: - `genre` (str): A string representing the genre of movies to filter by (e.g., \\"Action\\", \\"Comedy\\", \\"Drama\\"). Output: - Returns a list of strings, each representing the title of a recommended movie. The length of the list should be at most five. Constraints: - You may assume the CSV file `movies.csv` is available in the working directory. The CSV file has the following columns: - `title` (str): The title of the movie. - `genre` (str): The genre of the movie. A movie can belong to multiple genres separated by commas (e.g., \\"Action,Thriller\\"). - `rating` (float): The user rating of the movie (between 0 and 10). - If there are fewer than five movies available in the specified genre, return only the available movies. - If no movies match the specified genre, return an empty list. Example Given a `movies.csv` file with the following content: ``` title,genre,rating Inception,Action,Sci-Fi,8.8 The Dark Knight,Action,Drama,9.0 Fight Club,Drama,8.8 Forrest Gump,Romance,Drama,8.8 Pulp Fiction,Crime,Drama,8.9 ``` Then, ```python recommend_movies(\\"Action\\") ``` Should return: ```python [\\"The Dark Knight\\", \\"Inception\\"] ``` Notes: - You may use libraries such as `pandas` to handle the CSV file reading and filtering process. - Ensure that the function works efficiently, especially when dealing with large datasets. - Handle potential errors, such as file not found or incorrect CSV formatting, gracefully.","solution":"import pandas as pd def recommend_movies(genre: str) -> list: Recommends up to five movies based on the given genre, sorted by user rating. Parameters: genre (str): The genre to filter movies by. Returns: list: List of recommended movie titles. try: # Read the CSV file into a DataFrame movies_df = pd.read_csv(\'movies.csv\') # Filter movies by the specified genre genre_filter = movies_df[\'genre\'].str.contains(genre, case=False, na=False) filtered_movies = movies_df[genre_filter] # Sort the filtered movies by rating in descending order sorted_movies = filtered_movies.sort_values(by=\'rating\', ascending=False) # Select the top five movies top_movies = sorted_movies.head(5) # Extract the titles of the recommended movies recommended_titles = top_movies[\'title\'].tolist() return recommended_titles except Exception as e: print(f\\"An error occurred: {e}\\") return []"},{"question":"# Scenario and Task You are tasked with developing a feature for a text processing application. A common requirement is to identify and extract named entities such as names of people, organizations, locations, dates, and more from a block of text. For this task, you will implement a simplified version of this, called \\"keyword extraction,\\" based on the presence of a pre-defined set of keywords. # Problem Statement Implement a function `extract_keywords` that extracts keywords from a given text based on a list of predefined keywords. # Function Signature ```python def extract_keywords(text: str, keywords: List[str]) -> List[str]: Extract keywords from the given text. Parameters: text (str): The input text from which to extract keywords. keywords (List[str]): A list of keywords to be extracted if found in the text. Returns: List[str]: A list of keywords found in the text. pass ``` # Input - `text`: A string representing the input text. - `keywords`: A list of strings representing the keywords to be extracted from the text. # Output - Returns a list of strings containing the keywords found in the text. # Constraints - The function should be case-insensitive. - The order of the keywords in the output list should follow the order they appear in the input text. - Each keyword should be included only once in the output, even if it appears multiple times in the text. # Example ```python # Example input text = \\"Python is a powerful programming language that is used in web development, data analysis, artificial intelligence, and more.\\" keywords = [\\"python\\", \\"development\\", \\"artificial intelligence\\", \\"data\\"] output = extract_keywords(text, keywords) print(output) # Expected output: [\'python\', \'development\', \'artificial intelligence\', \'data\'] ``` # Commentary - This problem assesses your ability to process text data and implement keyword extraction. - Handling text case-insensitivity and ensuring efficiency in keyword search are essential for this task. By developing the `extract_keywords` function, you will help build a foundational feature for a text processing application, enhancing its ability to analyze and categorize text data based on specified keywords.","solution":"from typing import List def extract_keywords(text: str, keywords: List[str]) -> List[str]: Extract keywords from the given text. Parameters: text (str): The input text from which to extract keywords. keywords (List[str]): A list of keywords to be extracted if found in the text. Returns: List[str]: A list of keywords found in the text. text_lower = text.lower() extracted_keywords = [] for keyword in keywords: keyword_lower = keyword.lower() if keyword_lower in text_lower and keyword_lower not in extracted_keywords: extracted_keywords.append(keyword_lower) return extracted_keywords"},{"question":"# Question You have been provided with a partially implemented **GCD (Greatest Common Divisor) Finder** in Python. Your task is to complete the implementation by adding an additional method called `find_common_divisors_count`. This method should return the count of common divisors of two given integers. **Function Signature**: ```python def find_common_divisors_count(self, a: int, b: int) -> int: pass ``` # Instructions 1. **Function Details**: - **Input**: Two integers `a` and `b` - **Output**: Returns the number of common divisors of the two integers. - **Constraints**: - The integers `a` and `b` will always be greater than zero. 2. **Examples**: ```python gcd_finder = GCDFinder() # Example 1 assert gcd_finder.find_common_divisors_count(12, 15) == 2 # Divisors: 1, 3 # Example 2 assert gcd_finder.find_common_divisors_count(100, 200) == 9 # Divisors: 1, 2, 4, 5, 10, 20, 25, 50, 100 # Example 3 assert gcd_finder.find_common_divisors_count(7, 13) == 1 # Divisors: 1 ``` # Additional Notes: - Focus on achieving the correct functionality within the specified constraints. - You may use helper methods if needed but ensure they are encapsulated within the `GCDFinder` class. - Make sure to handle edge cases, such as when both numbers are prime. Implement the `find_common_divisors_count` method in the `GCDFinder` class: # Code to Implement ```python class GCDFinder: def find_common_divisors_count(self, a: int, b: int) -> int: # Your code here pass ```","solution":"class GCDFinder: def find_common_divisors_count(self, a: int, b: int) -> int: def gcd(x, y): while y: x, y = y, x % y return x gcd_ab = gcd(a, b) count = 0 for i in range(1, gcd_ab + 1): if gcd_ab % i == 0: count += 1 return count"},{"question":"# Context Sorting algorithms are fundamental to understanding computational complexity and data organization. Among the various sorting methods, the Quick Sort algorithm is notable for its efficiency and performance on average cases. # Task You are required to implement the Quick Sort algorithm that sorts an input list of integers in ascending order. # Requirements Write a function `quick_sort(arr: list) -> list` that: 1. Takes in a list of integers `arr`. 2. Returns a new list with the integers sorted in ascending order. **Input Constraints**: - The input `arr` will be a list of integers where each integer is within the range of a standard 32-bit signed integer. - The input list can have a length between 0 and 10^5. **Output Format**: - Return a new list with integers sorted in ascending order. # Examples ```python >>> quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quick_sort([1, 2, 3, -2, -1, 0]) [-2, -1, 0, 1, 2, 3] >>> quick_sort([]) [] >>> quick_sort([5]) [5] >>> quick_sort([5, -3, 0, 9, -8, 3]) [-8, -3, 0, 3, 5, 9] ``` # Notes - Implement the Quick Sort algorithm recursively, choosing the last element as the pivot. - Ensure your implementation considers edge cases, such as an empty list or a list with a single element. - Aim to achieve an average-case time complexity of O(n log n) with your solution. Implement this function considering both correctness and performance.","solution":"def quick_sort(arr): Sorts a list of integers in ascending order using the Quick Sort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) - 1] less_than_pivot = [x for x in arr[:-1] if x <= pivot] greater_than_pivot = [x for x in arr[:-1] if x > pivot] return quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)"},{"question":"# Question You have been tasked to create a simple file compression algorithm for a text file. Your algorithm should use the Run-Length Encoding (RLE) technique that compresses sequences of the same character. Implement two functions, `compress` and `decompress`, to handle the compression and decompression of the text content. Function 1: `compress` * **Input**: A string `text` containing the content of the text file. * **Output**: A string representing the run-length encoded version of the input text. * **Constraints**: - The input string can contain uppercase and lowercase English letters, digits, and special characters. - Each run is represented by the character followed by the number of times it repeats consecutively. Function 2: `decompress` * **Input**: A string `data` containing the run-length encoded version of the text. * **Output**: A string representing the original text before compression. * **Constraints**: - The input string will be properly formatted as a run-length encoded string. **Example Usage**: ```python assert compress(\\"AAAABBBCCDAA\\") == \'A4B3C2D1A2\' assert decompress(\\"A4B3C2D1A2\\") == \\"AAAABBBCCDAA\\" assert compress(\\"Hello World!!\\") == \'H1e1l2o1 1W1o1r1l1d1!2\' assert decompress(\'H1e1l2o1 1W1o1r1l1d1!2\') == \\"Hello World!!\\" ``` Create these functions and demonstrate their usage by implementing the `main` function.","solution":"def compress(text): Compresses the input text using Run-Length Encoding (RLE). Parameters: text (str): The input string to be compressed. Returns: str: The run-length encoded version of the input text. if not text: return \\"\\" compressed = [] count = 1 previous = text[0] for char in text[1:]: if char == previous: count += 1 else: compressed.append(f\'{previous}{count}\') previous = char count = 1 compressed.append(f\'{previous}{count}\') # appending the last character run return \'\'.join(compressed) def decompress(data): Decompresses the input RLE text to its original form. Parameters: data (str): The run-length encoded string. Returns: str: The original string before compression. if not data: return \\"\\" decompressed = [] i = 0 n = len(data) while i < n: char = data[i] j = i + 1 count = 0 while j < n and data[j].isdigit(): count = count * 10 + int(data[j]) j += 1 decompressed.append(char * count) i = j return \'\'.join(decompressed)"},{"question":"# Problem Statement Write a function `longest_consecutive_subsequence(nums: List[int]) -> int` that returns the length of the longest consecutive elements subsequence. A consecutive elements subsequence is a sequence of numbers that can be obtained by selecting some elements from the list and rearranging them in any order such that they form a consecutive sequence. # Context This problem revolves around finding the longest sequence of consecutive integers in an unsorted list of integers, which can be solved efficiently using appropriate data structures and algorithms. # Input * `nums` - A list of integers representing the unsorted sequence of numbers. # Output * An integer representing the length of the longest consecutive elements subsequence. # Constraints * The solution should run in O(n) time. * The length of the list `nums` will be between 0 and 100,000. * The elements of `nums` will be between -10^9 and 10^9. # Example ```python assert longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 assert longest_consecutive_subsequence([0, -1, 2, -2, 1]) == 5 assert longest_consecutive_subsequence([1, 2, 0, 1]) == 3 assert longest_consecutive_subsequence([]) == 0 ``` # Hints 1. Use a HashSet to keep track of elements and ensure lookups are O(1) on average. 2. To construct the longest consecutive sequence, for each element check if it is the start of a sequence by ensuring the preceding number is not present in the HashSet.","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest consecutive elements subsequence. Parameters: nums (List[int]): A list of integers. Returns: int: Length of the longest consecutive elements subsequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # check if this number is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Coding Task: Implement a Minesweeper Solver Problem Statement: You are given a `Minesweeper` class that simulates a Minesweeper game. Your task is to implement a method called `reveal_grid` which reveals the content of the grid when a cell is clicked. If the clicked cell contains a mine, the game should be over. If the clicked cell is a number (\'1\'-\'8\') representing the count of adjacent mines, only that cell should be revealed. If the clicked cell is an empty cell (represented with a \'.\'), you should reveal all connected empty cells and stop at cells that contain numbers. Requirements: 1. Implement the `reveal_grid` method to handle revealing of cells according to the Minesweeper rules. 2. Ensure that mines (\'M\') are not revealed during this process. 3. Develop a way to flag the game as lost when a mine is revealed. Function Signature: ```python def reveal_grid(self, row: int, col: int) -> None: pass ``` Input: - `row` (int): Row index of the cell to be revealed. - `col` (int): Column index of the cell to be revealed. Constraints: - The row and column indices are valid and within the dimensions of the grid. - The grid is represented as a 2D list where \'M\' represents a mine, \'.\' represents an empty cell, and \'1\'-\'8\' represent the number of adjacent mines. Output: - Modify the instance\'s `board` property by revealing the cells according to the rules mentioned above. - Maintain a flag to determine if the game has ended. Example: ```python # Example usage: minesweeper = Minesweeper([ [\'1\', \'M\', \'1\', \'.\', \'.\'], [\'1\', \'1\', \'1\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'2\', \'M\'], [\'.\', \'.\', \'.\', \'2\', \'1\'], [\'.\', \'M\', \'1\', \'1\', \'.\'] ]) # Reveal the cell at (0, 3) minesweeper.reveal_grid(0, 3) minesweeper.visualize_board() ``` Expected Output: ``` 1 M 1 _ _ 1 1 1 _ _ _ _ _ 2 M _ _ _ 2 1 _ M 1 1 _ ``` Notes: - Ensure that your implemented method handles revealing cells recursively for connected empty cells. - Provide appropriate methods to visualize the board and test the functionality of the `reveal_grid` method. - Consider edge cases such as revealing cells at the border of the board.","solution":"class Minesweeper: def __init__(self, board): self.board = board self.rows = len(board) self.cols = len(board[0]) self.game_over = False def visualize_board(self): for row in self.board: print(\' \'.join(row)) def reveal_grid(self, row, col): if self.board[row][col] == \'M\': self.game_over = True print(\\"Game Over\\") return if self.board[row][col] != \'.\': self.board[row][col] = \'_\' return def dfs(r, c): if r < 0 or r >= self.rows or c < 0 or c >= self.cols or self.board[r][c] == \'_\' or self.board[r][c] == \'M\': return if self.board[r][c] != \'.\': self.board[r][c] = \'_\' return self.board[r][c] = \'_\' dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) dfs(r - 1, c - 1) dfs(r - 1, c + 1) dfs(r + 1, c - 1) dfs(r + 1, c + 1) dfs(row, col)"},{"question":"**Scenario**: You are tasked with developing a simplified simulation engine for a game that involves managing a fleet of different types of vehicles. The game requires performing operations like refueling vehicles, calculating fuel efficiency, and displaying the status of the vehicles. # Task 1. **Class Definition**: - Define a `Vehicle` class with the following properties: - `name` (str): The name of the vehicle. - `capacity` (float): The fuel capacity of the vehicle. - `fuel_efficiency` (float): The fuel efficiency of the vehicle in kilometers per liter. - `current_fuel` (float): The current amount of fuel in the vehicle. 2. **Method Implementation**: - Implement the following methods for the `Vehicle` class: - `refuel(amount: float) -> None`: Adds the specified amount of fuel to the `current_fuel`. If the added fuel exceeds the `capacity`, set the `current_fuel` to `capacity`. - `travel(distance: float) -> float`: Updates the `current_fuel` based on the `distance` traveled and returns the `fuel_used` for the journey. If the vehicle doesn\'t have enough fuel for the specified distance, travel until the fuel runs out and return the `total_distance_traveled`. - `status() -> dict`: Returns a dictionary with keys `name`, `current_fuel`, `capacity`, and `fuel_efficiency` representing the current state of the vehicle. # Input and Output Format - **Input**: * For `refuel`: parameter `amount` (float) representing the amount of fuel to add. * For `travel`: parameter `distance` (float) representing the distance to travel. * No input parameters for the `status` method. - **Output**: * For `refuel`: No return value. * For `travel`: Returns a float representing the fuel used or the distance traveled with remaining fuel. * For `status`: Returns a dictionary representing the vehicle\'s state. # Constraints - The fuel amount and distances will always be positive values. # Example ```python # Class Definition class Vehicle: def __init__(self, name, capacity, fuel_efficiency, current_fuel): self.name = name self.capacity = capacity self.fuel_efficiency = fuel_efficiency self.current_fuel = current_fuel def refuel(self, amount): self.current_fuel += amount if self.current_fuel > self.capacity: self.current_fuel = self.capacity def travel(self, distance): fuel_needed = distance / self.fuel_efficiency if fuel_needed > self.current_fuel: max_travel_distance = self.current_fuel * self.fuel_efficiency self.current_fuel = 0 return max_travel_distance else: self.current_fuel -= fuel_needed return fuel_needed def status(self): return { \'name\': self.name, \'current_fuel\': self.current_fuel, \'capacity\': self.capacity, \'fuel_efficiency\': self.fuel_efficiency } # Example Usage vehicle = Vehicle(\'Car\', 50, 10, 20) vehicle.refuel(15) print(vehicle.status()) # returns {\'name\': \'Car\', \'current_fuel\': 35, \'capacity\': 50, \'fuel_efficiency\': 10} distance_traveled = vehicle.travel(200) print(distance_traveled) # returns 15.0 (all fuel used, remaining distance can\'t be traveled) print(vehicle.status()) # returns {\'name\': \'Car\', \'current_fuel\': 0, \'capacity\': 50, \'fuel_efficiency\': 10} ```","solution":"class Vehicle: def __init__(self, name: str, capacity: float, fuel_efficiency: float, current_fuel: float): self.name = name self.capacity = capacity self.fuel_efficiency = fuel_efficiency self.current_fuel = current_fuel def refuel(self, amount: float) -> None: self.current_fuel += amount if self.current_fuel > self.capacity: self.current_fuel = self.capacity def travel(self, distance: float) -> float: fuel_needed = distance / self.fuel_efficiency if fuel_needed > self.current_fuel: max_travel_distance = self.current_fuel * self.fuel_efficiency self.current_fuel = 0 return max_travel_distance else: self.current_fuel -= fuel_needed return distance def status(self) -> dict: return { \'name\': self.name, \'current_fuel\': self.current_fuel, \'capacity\': self.capacity, \'fuel_efficiency\': self.fuel_efficiency }"},{"question":"**Context:** String manipulation, specifically substrings, is a common problem in software development, often encountered in text processing and data parsing tasks. This exercise will challenge your ability to efficiently handle strings and extract meaningful data. **Question:** Write a function `longest_shared_substr(s1: str, s2: str) -> str` that finds the longest common substring between two given strings `s1` and `s2`. **Requirements:** 1. The function should efficiently manage the search for the longest common substring. 2. If there are multiple common substrings with the same length, return any one of them. **Expected Input and Output:** * **Input:** Two strings `s1` and `s2`. For example, `\\"powerful\\"` and `\\"wonderful\\"`. * **Output:** A string representing the longest common substring. For example, given the inputs `\\"powerful\\"` and `\\"wonderful\\"`, the function could return `\\"erful\\"`. **Function Signature:** ```python def longest_shared_substr(s1: str, s2: str) -> str: pass ``` **Constraints:** - The strings `s1` and `s2` have lengths up to (10^3) characters. - The strings contain lowercase English letters only. --- **Example:** ```python assert longest_shared_substr(\\"powerful\\", \\"wonderful\\") == \\"erful\\" assert longest_shared_substr(\\"abcba\\", \\"abcbcba\\") == \\"abc\\" ``` This problem will test your understanding of dynamic programming and efficient string manipulation, aligning well with typical coding assessment questions.","solution":"def longest_shared_substr(s1: str, s2: str) -> str: Finds the longest common substring between two given strings. Caution: This is a brute force solution with time complexity O(n^3), suitable for small strings. len_s1, len_s2 = len(s1), len(s2) max_len = 0 end = 0 dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)] for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] end = i return s1[end - max_len: end]"},{"question":"You are given two integers `num1` and `num2`. You need to write a function `gcd(num1: int, num2: int) -> int` that returns the greatest common divisor (GCD) of `num1` and `num2`. # Example ```python >>> gcd(48, 18) 6 >>> gcd(56, 98) 14 >>> gcd(101, 10) 1 ``` # Constraints * `num1` and `num2` will always be positive integers less than or equal to 10^6. * 1 <= num1, num2 <= 10^6 # Requirements 1. Implement the function using the Euclidean algorithm. 2. Evaluate edge cases such as: - Both numbers being the same. - One number being 1. - Large values close to the upper limit (1,000,000). # Performance Expectations * The solution should have a time complexity of O(log(min(num1, num2))). * The solution should efficiently handle large inputs up to 1,000,000.","solution":"def gcd(num1: int, num2: int) -> int: Returns the greatest common divisor (GCD) of num1 and num2 using the Euclidean algorithm. while num2: num1, num2 = num2, num1 % num2 return num1"},{"question":"# SQL Query Challenge: Employee Salaries You’re provided with a table `employees` that contains data about employees in a company. The table schema is as follows: ``` employees: +----+-------+-------------+----------+ | id | name | department | salary | +----+-------+-------------+----------+ | 1 | Alice | HR | 60000 | | 2 | Bob | Engineering | 75000 | | 3 | Carol | HR | 66000 | | 4 | Dave | Engineering | 80000 | | 5 | Eve | Sales | 72000 | ... +----+-------+-------------+----------+ ``` Write a SQL query to find the names and salaries of employees who have the highest salary in their respective departments. # Expected Output: The query should return the names and salaries of employees with the highest salary for each department. If there are multiple employees with the same highest salary in a department, all should be included in the output. ```sql SELECT name, salary FROM employees WHERE (department, salary) IN ( SELECT department, MAX(salary) FROM employees GROUP BY department ); ``` Example Output: ``` +--------+--------+ | name | salary | +--------+--------+ | Carol | 66000 | | Dave | 80000 | | Eve | 72000 | ... +--------+--------+ ``` **Constraints:** - The `employees` table may contain duplicate entries in names and salaries, but the combination of `id`, `name`, and `department` will be unique. Your task is to write the SQL query as detailed above and ensure it works correctly against the given schema.","solution":"def highest_salary_employees_query(): Returns a SQL query to find the names and salaries of employees who have the highest salary in their respective departments. query = SELECT name, salary FROM employees WHERE (department, salary) IN ( SELECT department, MAX(salary) FROM employees GROUP BY department ); return query"},{"question":"# Tic-Tac-Toe Winner Determination Create a Python function to determine the winner of a Tic-Tac-Toe game. The game is played on a 3x3 board represented as a list of lists. Each cell in the board is marked by \'X\', \'O\', or an empty string \'\'. The function should return the winner of the game or \'Draw\' if there is no winner. The rules for winning are: 1. One player wins the game if they have three of their marks (\'X\' or \'O\') in a row, column, or a diagonal. # Input * A 3x3 list of lists representing the Tic-Tac-Toe board. # Output * Return \'X\' if player \'X\' is the winner. * Return \'O\' if player \'O\' is the winner. * Return \'Draw\' if there is no winner. # Constraints * Assume the board is always a properly populated 3x3 grid. # Example ```python def tic_tac_toe_winner(board: List[List[str]]) -> str: def check_winner(player: str) -> bool: # Check for winning rows, columns, or diagonals for the given player. for player in [\'X\', \'O\']: if check_winner(player): return player return \'Draw\' # Example: board1 = [ [\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'O\', \'X\', \'X\'] ] assert tic_tac_toe_winner(board1) == \'X\' board2 = [ [\'X\', \'O\', \'\'], [\'O\', \'X\', \'O\'], [\'O\', \'\', \'X\'] ] assert tic_tac_toe_winner(board2) == \'X\' board3 = [ [\'X\', \'O\', \'X\'], [\'O\', \'O\', \'X\'], [\'O\', \'X\', \'O\'] ] assert tic_tac_toe_winner(board3) == \'Draw\' ``` Implement the following function: 1. **`tic_tac_toe_winner`**: Function that checks if the given player is the winner by analyzing the rows, columns, and diagonals.","solution":"from typing import List def tic_tac_toe_winner(board: List[List[str]]) -> str: def check_winner(player: str) -> bool: # Check rows for row in board: if all(mark == player for mark in row): return True # Check columns for col in range(3): if all(board[row][col] == player for row in range(3)): return True # Check diagonals if all(board[i][i] == player for i in range(3)): return True if all(board[i][2 - i] == player for i in range(3)): return True return False for player in [\'X\', \'O\']: if check_winner(player): return player return \'Draw\'"},{"question":"# Context: In graphics programming, particularly when working with colors, colors can be represented using the Hexadecimal color codes. You need to convert such hex color codes into their respective RGB (Red, Green, Blue) components. # Problem Statement: Write a function `hex_to_rgb(hex_color: str) -> tuple` that converts a hexadecimal color string to its equivalent RGB tuple. Your implementation should: 1. Remove any leading or trailing whitespace, and the optional \'#\' prefix. 2. Ensure the remaining string has exactly 6 hexadecimal characters. 3. Validate that the string only contains valid hexadecimal digits (0-9, a-f, A-F). 4. Convert the hexadecimal string into RGB integers. 5. Raise `ValueError` with a descriptive message when: * The string is empty or has incorrect length. * The string contains any character not in the valid hexadecimal range. # Input: * A string `hex_color` (length <= 7), which may contain leading/trailing whitespace and the optional \'#\' prefix. # Output: * A tuple of three integers representing the RGB equivalent of the hex color code. # Constraints: * You may assume the input will not be extremely large and will handle up to 7 characters efficiently. # Examples: ```python >>> hex_to_rgb(\\" #1A2B3C \\") (26, 43, 60) >>> hex_to_rgb(\\"4F5E6D\\") (79, 94, 109) >>> hex_to_rgb(\\"GHIJKL\\") Traceback (most recent call last): ... ValueError: Non-hexadecimal value was passed to the function ``` # Detailed Requirements: 1. Remove leading/trailing whitespace and an optional \'#\'. 2. Check if the string is empty or has incorrect length after trimming and raise `ValueError(\\"Invalid length for a hex color code\\")` if true. 3. Validate the characters are valid hexadecimal digits (0-9, a-f, A-F), raising `ValueError(\\"Non-hexadecimal value was passed to the function\\")` if an invalid character is found. 4. Convert the string into its RGB components (each component is represented by two hexadecimal characters), turning the result into a tuple of three integers. 5. Return the resulting RGB tuple.","solution":"def hex_to_rgb(hex_color: str) -> tuple: Converts a hexadecimal color string to its equivalent RGB tuple. :param hex_color: A string representing the hex color code. :return: A tuple of three integers representing the RGB components. # Remove leading/trailing whitespace and \'#\' if present hex_color = hex_color.strip().lstrip(\'#\') # Check for correct length if len(hex_color) != 6: raise ValueError(\\"Invalid length for a hex color code\\") # Check for valid hexadecimal characters if not all(char in \'0123456789abcdefABCDEF\' for char in hex_color): raise ValueError(\\"Non-hexadecimal value was passed to the function\\") # Convert hex to RGB r = int(hex_color[0:2], 16) g = int(hex_color[2:4], 16) b = int(hex_color[4:6], 16) return (r, g, b)"},{"question":"# Question: Image Processing - Grayscale Filter As an engineer working on an image editing application, your task is to create a set of functions to apply a grayscale filter to a given color image. The objective is to convert the color image into its grayscale representation by properly averaging the color intensity values of its pixels. Function 1: `average_grayscale` Implement a function `average_grayscale` that takes in three parameters: * `red` (int): Red color intensity value of a pixel (0 to 255). * `green` (int): Green color intensity value of a pixel (0 to 255). * `blue` (int): Blue color intensity value of a pixel (0 to 255). The function should return an integer representing the grayscale value, calculated as the average of the red, green, and blue intensity values. Function 2: `apply_grayscale_filter` Implement a function `apply_grayscale_filter` that takes in one parameter: * `image` (list of list of tuples): A 2D matrix representing the image where each tuple contains three integers representing the red, green, and blue color intensity of a pixel (0 to 255). The function should return a new 2D matrix where each pixel is converted to its grayscale equivalent using the `average_grayscale` function. # Constraints * All input values must be valid integers in the range of 0 to 255. * Ensure to handle edge cases, such as an empty image. * The image matrix can have dimensions up to 1024x1024. # Examples ```python # Calculate grayscale value for a pixel print(average_grayscale(100, 150, 200)) # 150 # Apply grayscale filter to a sample image sample_image = [ [(255, 0, 0), (0, 255, 0), (0, 0, 255)], [(125, 125, 125), (75, 75, 75), (200, 200, 200)] ] print(apply_grayscale_filter(sample_image)) # [[85, 85, 85], [125, 125, 125], [75, 75, 75], [200, 200, 200]] ``` # Requirements Your functions should: 1. Handle invalid pixel intensity values by raising a `ValueError`. 2. Ensure the resulting grayscale image preserves the dimensions of the original image. 3. Guarantee robustness and efficiency, especially for large input sizes. Start coding these functions, ensuring that all the provided examples and edge cases are handled effectively. Good luck!","solution":"def average_grayscale(red, green, blue): Calculate the average grayscale value of a pixel given its red, green, and blue intensity values. Args: red (int): Red intensity value (0-255). green (int): Green intensity value (0-255). blue (int): Blue intensity value (0-255). Returns: int: The grayscale value. Raises: ValueError: If any of the provided values are not in the range 0-255. if not (0 <= red <= 255) or not (0 <= green <= 255) or not (0 <= blue <= 255): raise ValueError(\\"Color intensity values must be in the range 0-255\\") return (red + green + blue) // 3 def apply_grayscale_filter(image): Apply a grayscale filter to a given color image. Args: image (list of list of tuples): A 2D matrix representing the color image. Each tuple contains three integers (red, green, blue). Returns: list of list of int: A 2D matrix representing the grayscale image. grayscale_image = [] for row in image: grayscale_row = [] for pixel in row: grayscale_value = average_grayscale(pixel[0], pixel[1], pixel[2]) grayscale_row.append(grayscale_value) grayscale_image.append(grayscale_row) return grayscale_image"},{"question":"# Coding Assessment Question: Generating Abbreviations for Words Context: A company wants to implement a feature to generate unique abbreviations for words in their internal document processing system. The objective is to shorten words while retaining their uniqueness within a given context. To achieve this, the company decides to generate abbreviations by removing vowels from the words. Your Task: Write a function called `generate_abbreviation` that: 1. Removes all vowels (`a`, `e`, `i`, `o`, `u`) from a given string. 2. Ensures that the resulting abbreviation is unique within a provided context, which is a list of already existing abbreviations. 3. If the abbreviation already exists in the context, append a numerical suffix (starting from 1) to ensure uniqueness. Function Signature: ```python def generate_abbreviation(word: str, context: List[str]) -> str: Generates a unique abbreviation for the given word by removing vowels and ensuring no conflict with existing abbreviations. :param word: A string representing the word to be abbreviated. :param context: A list of strings representing existing abbreviations. :return: A string representing the unique abbreviation. Example: >>> generate_abbreviation(\\"international\\", [\\"intrntnl\\", \\"internatnl1\\"]) \'intrntnl2\' >>> generate_abbreviation(\\"abbreviation\\", []) \'bbrvtn\' >>> generate_abbreviation(\\"example\\", [\\"xmpl\\", \\"xmpl1\\"]) \'xmpl2\' ``` # Constraints: * The length of the word will not exceed 100 characters. * The context list will not contain more than 10,000 abbreviations. * Both inputs are non-empty. Implementation: Ensure the function effectively removes vowels, manages the uniqueness of abbreviations by handling conflicts with numerical suffixes, and appropriately returns the correct abbreviation considering the context.","solution":"def generate_abbreviation(word: str, context: list) -> str: vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} # Remove vowels from the word abbreviation = \'\'.join([char for char in word if char not in vowels]) # Check for uniqueness and append numerical suffix if necessary unique_abbreviation = abbreviation suffix = 0 while unique_abbreviation in context: suffix += 1 unique_abbreviation = abbreviation + str(suffix) return unique_abbreviation"},{"question":"URL Shortener Algorithm Implementation Task # Objective You are required to implement an algorithm for a URL shortening service that converts long URLs into short, unique, and easy-to-share URLs. The system should be capable of converting a given long URL to a short version and also be able to retrieve the original URL when given the short version. # Problem Statement Write a class `URLShortener` with the following methods: 1. `encode(long_url: str) -> str`: Converts a long URL into a short URL. 2. `decode(short_url: str) -> str`: Converts a short URL back into its original long URL. # Implementation Details 1. **Input** for `encode`: A string representing a long URL. 2. **Output** for `encode`: A string representing a short URL. 3. **Input** for `decode`: A string representing a short URL. 4. **Output** for `decode`: A string representing the original long URL. # Class Signature ```python class URLShortener: def __init__(self): pass def encode(self, long_url: str) -> str: pass def decode(self, short_url: str) -> str: pass ``` # Constraints 1. Both `encode` and `decode` operations should be efficient. 2. The service should ensure that each long URL corresponds to a unique short URL. 3. The short URL should be significantly shorter than the original URL. 4. The short URLs should ideally be as short as possible while maintaining uniqueness. 5. You may assume the number of URLs to be encoded is sufficiently large. # Example ```python url_shortener = URLShortener() long_url = \\"https://www.example.com/articles/how-to-code-in-python\\" short_url = url_shortener.encode(long_url) assert url_shortener.decode(short_url) == long_url ``` # Description The class `URLShortener` should: 1. Maintain a mapping from long URLs to short URLs and vice versa. 2. Use a method such as base62 encoding to convert long URLs into short URLs. 3. Ensure the short URLs are unique by maintaining an internal data structure that tracks mappings. # Notes - Handle edge cases like very short or empty input URLs gracefully. - Ensure your implementation can handle a high volume of URL shortening and expansion requests. - Consider thread safety if your solution is part of a web service. Your implementation will be tested with a wide range of URL inputs, including very long URLs and URLs with special characters. Ensure your solution adheres to the given constraints and performs efficiently.","solution":"import string class URLShortener: def __init__(self): self.counter = 0 self.url_map = {} self.short_to_long = {} self.charset = string.ascii_letters + string.digits def _id_to_short_url(self, id): short_url = [] base = len(self.charset) while id > 0: short_url.append(self.charset[id % base]) id = id // base return \'\'.join(reversed(short_url)) def encode(self, long_url: str) -> str: if long_url in self.url_map: return self.url_map[long_url] self.counter += 1 short_url = self._id_to_short_url(self.counter) self.url_map[long_url] = short_url self.short_to_long[short_url] = long_url return short_url def decode(self, short_url: str) -> str: return self.short_to_long.get(short_url, \\"\\")"},{"question":"External Sorting Implementation # Objective: Implement the `ExternalSort` class, focusing on the sort and merge logic for large text files without loading the entire file into memory. # Constraints: 1. Do not use more than 100 MB of memory (hard cap). 2. Input file sizes can vary from 1MB to several GB. 3. Consider the disk I/O implications in your sorting and merging process. # Requirements: 1. Implement the `FileSplitter` class to: * Split the input file into smaller blocks that are sorted individually. * Ensure each block is written back to disk. 2. Implement the `FileMerger` class: * Use the N-Way Merge to combine sorted blocks into a final sorted output file. 3. Ensure the `ExternalSort` class encapsulates the split-sort-merge workflow. # Input: - Path to the input filename as a string. - Optional custom comparator function for sorting. # Output: - Path to the sorted output file named `<input_filename>.sorted`. # Example: ```python sorter = ExternalSort(100 * 1024 * 1024) # 100 MB memory limit sorter.sort(\\"large_data.txt\\") # The sorted file should be saved as \\"large_data.txt.sorted\\" ``` # Edge Cases: 1. Empty files. 2. Extremely large files that test the split and merge functionality. 3. Files where all lines are identical. # Performance Notes: - Implement error handling for file read/write operations. - Ensure efficient memory usage by managing read buffers carefully. - Optimize merging strategy to minimize unnecessary disk I/O. # Objective: Design and implement an in-memory key-value store with entry expiry functionality. # Constraints: 1. Each key-value entry may have an individual expiry time. 2. Ensure O(1) time complexity for `set` and `get` operations. 3. Efficiently handle the automatic removal of expired entries. # Requirements: 1. Implement the `set` method: * Store the key-value pair with an optional expiry time in seconds. 2. Implement the `get` method: * Retrieve the value for a given key, considering its expiry time. 3. Implement the `delete` method: * Manually remove a key-value pair from the store. 4. Implement the `cleanup` method: * Periodically remove expired entries from the store. # Input: - `set(key: str, value: any, expire_in: Optional[int] = None)` accepts a key, a value, and an optional expiry time in seconds. - `get(key: str)` retrieves the value associated with the key. - `delete(key: str)` removes a key from the store. - `cleanup()` removes all expired keys. # Output: - `get(key: str)` returns the value for the key, or `None` if the key doesn\'t exist or has expired. # Example: ```python store = KeyValueStore() store.set(\\"foo\\", \\"bar\\", expire_in=5) print(store.get(\\"foo\\")) # Output: \\"bar\\" # ... After 5 seconds print(store.get(\\"foo\\")) # Output: None store.set(\\"fizz\\", \\"buzz\\") store.delete(\\"fizz\\") print(store.get(\\"fizz\\")) # Output: None ``` # Edge Cases: 1. Setting multiple entries with different expiry times. 2. Attempting to retrieve expired keys. 3. Handling large numbers of keys efficiently. # Performance Notes: - Use time-based sorting and hashing techniques to handle entry expiry efficiently. - Minimize the use of locks or other synchronization mechanisms to ensure high concurrency.","solution":"import heapq import time class KeyValueStore: def __init__(self): self.store = {} self.expiry_heap = [] def set(self, key, value, expire_in=None): expiry_time = time.time() + expire_in if expire_in is not None else None self.store[key] = (value, expiry_time) if expiry_time is not None: heapq.heappush(self.expiry_heap, (expiry_time, key)) def get(self, key): self.cleanup() if key in self.store: value, expiry_time = self.store[key] if expiry_time is None or expiry_time > time.time(): return value return None def delete(self, key): if key in self.store: del self.store[key] def cleanup(self): current_time = time.time() while self.expiry_heap and self.expiry_heap[0][0] <= current_time: _, key = heapq.heappop(self.expiry_heap) if key in self.store and self.store[key][1] <= current_time: del self.store[key]"},{"question":"# Quadratic Equation Solver Problem Statement You are given a quadratic equation of the form ( ax^2 + bx + c = 0 ). The quadratic equation can have two real roots, one real root, or two complex roots. The solutions to this equation are given by the quadratic formula: [ x = frac{-b pm sqrt{b^2 - 4ac}}{2a} ] Implement a function `quadratic_solver` that adheres to the following signature: ```python def quadratic_solver( a: float, # coefficient of x^2 b: float, # coefficient of x c: float # constant term ) -> tuple: ``` The function should: 1. **Raise a `ValueError`** if the coefficient ( a ) is zero, as this would not be a quadratic equation. 2. Calculate the discriminant (Delta = b^2 - 4ac). 3. **Return a tuple** of the roots: - If the discriminant is positive, return a tuple containing the two real roots in any order. - If the discriminant is zero, return a tuple with one real root (both elements in the tuple should be the same). - If the discriminant is negative, return a tuple containing the two complex roots in the form of complex numbers. Examples ```python >>> quadratic_solver(1, -3, 2) (2.0, 1.0) >>> quadratic_solver(1, 2, 1) (-1.0, -1.0) >>> quadratic_solver(1, 0, 1) (complex(0, 1), complex(0, -1)) >>> quadratic_solver(0, 2, 1) Traceback (most recent call last): ... ValueError: Coefficient \'a\' must not be zero. ``` Put special focus on validating inputs and handling edge cases appropriately. Your implementation should be efficient and capable of handling both real and complex number computations accurately.","solution":"import cmath def quadratic_solver(a: float, b: float, c: float) -> tuple: if a == 0: raise ValueError(\\"Coefficient \'a\' must not be zero.\\") discriminant = b**2 - 4*a*c two_a = 2 * a if discriminant > 0: root1 = (-b + cmath.sqrt(discriminant).real) / two_a root2 = (-b - cmath.sqrt(discriminant).real) / two_a return (root1, root2) elif discriminant == 0: root = -b / two_a return (root, root) else: root1 = (-b + cmath.sqrt(discriminant)) / two_a root2 = (-b - cmath.sqrt(discriminant)) / two_a return (root1, root2)"},{"question":"# Coding Assessment Question Problem Description You are given a list of integers representing the quantities of various items in a warehouse. Write a function that returns a list of integers where each integer indicates the difference between the highest quantity and the current quantity in the original list. Function Signature ```python def quantity_differences(quantities: List[int]) -> List[int]: ``` Input - A list of integers `quantities` where each integer represents the quantity of items for different products in a warehouse. The length of the list `quantities` can be between 1 and 10^5 (1 ≤ len(quantities) ≤ 10^5) and each quantity is between 1 and 10^6 (1 ≤ quantities[i] ≤ 10^6). Output - A list of integers where each integer represents the difference between the maximum quantity and the current quantity from the original list. Example ```python >>> quantity_differences([3, 7, 2, 5]) [4, 0, 5, 2] >>> quantity_differences([10, 20, 20, 5]) [10, 0, 0, 15] ``` Constraints - The function should handle large inputs efficiently. - Adhere to time and space complexity requirements (O(n) time complexity and O(n) space complexity where n is the length of the input list). Additional Notes 1. Be mindful of edge cases such as when all quantities are the same. 2. Ensure your function scales with the input size. 3. Optimize for readability and performance where possible.","solution":"from typing import List def quantity_differences(quantities: List[int]) -> List[int]: Returns a list of differences between the maximum quantity and each quantity in the original list. max_quantity = max(quantities) return [max_quantity - quantity for quantity in quantities]"},{"question":"# Coding Question: String Manipulation and Palindromes **Context**: Mia is developing a software application that analyzes strings for various properties. One feature she wants to include is checking if a string forms a palindrome after removing all non-alphanumeric characters and ignoring case differences. **Task**: Write a Python function `is_palindrome` that: 1. Removes all non-alphanumeric characters from the given string. 2. Ignores case differences. 3. Checks if the resulting string is a palindrome. **Function Signature**: ```python def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome after removing all non-alphanumeric characters and ignoring case differences. :param s: str - the input string to be checked :return: bool - True if the cleaned string is a palindrome, False otherwise pass ``` **Constraints**: * The function should handle an empty string correctly. * The function should handle varied cases (uppercase and lowercase) appropriately. * The function should ignore non-alphanumeric characters gracefully. **Example**: When calling `is_palindrome(\\"A man, a plan, a canal, Panama\\")`, the function should return `True`. When calling `is_palindrome(\\"race a car\\")`, the function should return `False`. When calling `is_palindrome(\\"\\")`, the function should return `True` (an empty string is considered a palindrome in this context). **Additional Considerations**: - Ensure the function performs efficiently even for long strings. - Handle edge cases appropriately, such as strings with only non-alphanumeric characters. ```python def is_palindrome(s: str) -> bool: # Remove all non-alphanumeric characters and convert to lowercase cleaned_str = \'\'.join(ch.lower() for ch in s if ch.isalnum()) # Check if the cleaned string is a palindrome return cleaned_str == cleaned_str[::-1] ```","solution":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome after removing all non-alphanumeric characters and ignoring case differences. :param s: str - the input string to be checked :return: bool - True if the cleaned string is a palindrome, False otherwise # Remove all non-alphanumeric characters and convert to lowercase cleaned_str = \'\'.join(ch.lower() for ch in s if ch.isalnum()) # Check if the cleaned string is a palindrome return cleaned_str == cleaned_str[::-1]"},{"question":"# Question: You are tasked with creating a function to rotate an NxN matrix by 90 degrees in a clockwise direction. Rotating a matrix entails reorganizing its elements such that the first row becomes the last column, the second row becomes the second to last column, and so on. Function Signature: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input: * `matrix`: A 2D list of integers representing an NxN matrix (1 ≤ N ≤ 100). Output: * Return the 2D list of integers representing the rotated matrix. Constraints: * The matrix contains only integers. * The function should handle all integer values, including negatives and zero. * Optimize the function to run efficiently within the given constraints. Requirements: 1. Ensure the function rotates the matrix in place if possible, and accounts for all edge cases such as a 1x1 matrix. 2. Understand the space and time complexity implications of your solution to ensure it meets the performance criteria. Example: ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 matrix = [ [1] ] rotate_matrix(matrix) # Output: [ # [1] # ] # Example 3 matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) # Output: [ # [3, 1], # [4, 2] # ] # Example 4 matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] rotate_matrix(matrix) # Output: [ # [0, 0, 0], # [0, 0, 0], # [0, 0, 0] # ] # Example 5 matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] rotate_matrix(matrix) # Output: [ # [-7, -4, -1], # [-8, -5, -2], # [-9, -6, -3] # ] ```","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix by 90 degrees clockwise. N = len(matrix) rotated = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): rotated[j][N-1-i] = matrix[i][j] return rotated"},{"question":"# Calculate Net Salary After Tax You are tasked with writing software for a payroll system that computes the net salary of employees after tax deductions. The tax system is straightforward: there is a flat tax rate applied to an individual\'s salary. Write the function `calculate_net_salary` that takes the parameters `gross_salary`, and `tax_rate` and returns the net salary after deducting the tax. # Implementation Details: - **Input**: - `gross_salary` (float): The gross salary of the employee. - `tax_rate` (float): The flat tax rate to be applied. - **Output**: - `float`: The net salary after tax deduction. - **Constraints**: - `gross_salary` > 0 - `tax_rate` >= 0 and `tax_rate` <= 1 Net salary is calculated using the formula: [ text{net_salary} = text{gross_salary} - (text{gross_salary} times text{tax_rate}) ] # Examples ```python >>> calculate_net_salary(50000, 0.30) 35000.0 >>> calculate_net_salary(75000, 0.22) 58500.0 >>> calculate_net_salary(100000, 0.15) 85000.0 ``` # Implementation Hints 1. Multiply the gross salary by the tax rate to compute the tax amount. 2. Subtract the tax amount from the gross salary to get the net salary.","solution":"def calculate_net_salary(gross_salary, tax_rate): Calculate the net salary after tax deduction. Parameters: gross_salary (float): The gross salary of the employee. tax_rate (float): The flat tax rate to be applied (between 0 and 1). Returns: float: The net salary after tax deduction. # Calculate the tax amount tax_amount = gross_salary * tax_rate # Calculate the net salary net_salary = gross_salary - tax_amount return net_salary"},{"question":"# Problem Statement You are tasked with developing an algorithm that evaluates and verifies a series of mathematical expressions provided as strings. These expressions may include basic arithmetic operators, parentheses for grouping, and integer operands. The goal is to determine if each expression is valid in terms of syntax and, if valid, compute its value. # Requirements Implement a Python function `evaluate_expressions` that takes a single parameter, `expressions: List[str]`, representing a list of mathematical expression strings. The function should: 1. Verify the syntax of each expression for common mistakes (e.g. unmatched parentheses, misplaced operators). 2. If an expression is valid, compute its value. 3. Return a dictionary containing the original expression as the key and either the computed value or an error message as the value for each expression. # Constraints * The expressions may include the following elements: * Integer operands (both positive and negative values). * Arithmetic operators: `+`, `-`, `*`, `/`. * Parentheses `(` and `)` for grouping operations. * Operands and operators are separated by spaces. * Assume expressions will not contain any variables or special symbols other than those mentioned above. * Limit the computations to standard 32-bit signed integers. * If any expression is invalid, return an appropriate error message such as \\"Syntax Error\\". # Input and Output Formats * **Input**: * `expressions: List[str]`: A list of strings representing mathematical expressions. * **Output**: * `Dict[str, Union[int, str]]`: A dictionary where each key is an expression string and the value is either the computed integer result or an error message indicating the type of error. # Performance Requirements * The function should efficiently handle a list of up to 1000 expressions. * Each expression should be evaluated independently to ensure accurate error handling and results. # Example ```python def evaluate_expressions(expressions: List[str]) -> Dict[str, Union[int, str]]: # Your implementation here # Example usage expressions = [ \\"3 + 4 * 2\\", \\"( 1 + 2 ) * ( 3 / 4 )\\", \\"5 / ( 2 - 2 )\\" ] results = evaluate_expressions(expressions) print(results) ``` # Expected Output ```python { \\"3 + 4 * 2\\": 11, \\"( 1 + 2 ) * ( 3 / 4 )\\": 2.25, \\"5 / ( 2 - 2 )\\": \\"Syntax Error\\" } ``` # Notes * You may use the `ast` module or similar libraries to safely evaluate expressions, but you should handle syntax validation manually. * Ensure to adhere to standard Python best practices for exception handling and edge case management.","solution":"from typing import List, Dict, Union def evaluate_expressions(expressions: List[str]) -> Dict[str, Union[int, str]]: def validate_expression(expression: str) -> str: # Check if parentheses are balanced stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return \\"Syntax Error\\" stack.pop() if stack: return \\"Syntax Error\\" return \\"\\" def safe_eval(expression: str): try: result = eval(expression) if isinstance(result, (int, float)): return result else: return \\"Syntax Error\\" except: return \\"Syntax Error\\" results = {} for expr in expressions: validation_error = validate_expression(expr) if validation_error: results[expr] = validation_error else: results[expr] = safe_eval(expr) return results"},{"question":"# Binary Tree Level Order Traversal **Objective**: Implement the Level Order Traversal of a binary tree. **Description**: You are required to write a function, `level_order_traversal`, which takes the root node of a binary tree and returns a list of lists, where each list contains the values of the nodes at each level of the binary tree from top to bottom. **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode) -> list: ``` # Input Format: - A `TreeNode` object representing the root of a binary tree. # Output Format: - A list of lists, where each inner list contains integers representing node values at each level from top to bottom. # Constraints: - The binary tree can have a maximum of 10^4 nodes. - Node values are integers and can be negative, positive, or zero. - The function should handle an empty tree (i.e., when root is `None`) and return an empty list. # Performance Requirements: - Aim for O(n) time complexity, where n is the number of nodes in the tree. - Space complexity should be O(n) due to storage of nodes at each level in the output list and the queue used for BFS. # Example: ```python # Example 1 # Input tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert level_order_traversal(root) == [[3], [9, 20], [15, 7]] # Example 2 # Input tree: # 1 # # 2 root = TreeNode(1) root.right = TreeNode(2) assert level_order_traversal(root) == [[1], [2]] # Example 3 # Input tree: # 1 # / # 3 2 # / # 4 root = TreeNode(1) root.left = TreeNode(3) root.right = TreeNode(2) root.left.left = TreeNode(4) assert level_order_traversal(root) == [[1], [3, 2], [4]] ``` # Additional Context: Consider edge cases such as completely unbalanced trees (all nodes on one side), trees with only one node, and trees with various types of integer values. Ensure that your function efficiently handles large trees and appropriately returns the nodes in level order. The solution should utilize breadth-first search (BFS) traversal, typically facilitated by a queue.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode) -> list: if not root: return [] from collections import deque queue = deque([root]) result = [] while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Memory Management: Simulate Garbage Collection in a Simple Language You are designing a basic simulator for a toy programming language that includes a fundamental garbage collection mechanism based on reference counting. Your task is to implement the core components of this simulator. Scenario: In this toy language, objects are created, and references to these objects can be assigned, reassigned, and deleted. Your simulator needs to handle reference counting and identify when objects should be collected (i.e., deleted) because no references exist. Objective: Implement functions `assign_reference`, `release_reference`, and `garbage_collect` to manage objects and their reference counts. # Specifications: 1. Functions: * `assign_reference` - Takes a dictionary of objects, a reference dictionary, and a new reference assignment. Updates reference counts accordingly. * `release_reference` - Takes a dictionary of objects, a reference dictionary, and a reference to be released. Updates reference counts and potentially marks objects for deletion. * `garbage_collect` - Takes a dictionary of objects and deletes objects with zero reference counts. 2. Input/Output Formats: * **Input**: * For `assign_reference`: * `objects`: a dictionary where keys are object IDs and values are the object\'s data. * `references`: a dictionary where keys are variable names and values are object IDs they reference. * `var_name`: the variable name to assign a new reference. * `obj_id`: the object ID to be referenced. * For `release_reference`: * `objects`: a dictionary of objects currently in memory. * `references`: a dictionary of current variable references. * `var_name`: the variable name whose reference is to be released. * For `garbage_collect`: * `objects`: a dictionary of objects currently in memory. * **Output**: * For `assign_reference`: None. The function modifies `objects` and `references` in place. * For `release_reference`: None. The function modifies `objects` and `references` in place. * For `garbage_collect`: None. The function modifies `objects` in place. Function Signatures: ```python def assign_reference(objects: dict, references: dict, var_name: str, obj_id: int) -> None: pass def release_reference(objects: dict, references: dict, var_name: str) -> None: pass def garbage_collect(objects: dict) -> None: pass ``` Example Usage: ```python objects = {1: \'data1\', 2: \'data2\'} references = {} assign_reference(objects, references, \'a\', 1) assign_reference(objects, references, \'b\', 2) release_reference(objects, references, \'a\') garbage_collect(objects) # After gc, only object 2 should remain print(objects) # Output should be {2: \'data2\'} print(references) # Output should be {\'b\': 2} ``` Constraints: * Object IDs are unique integers. * Variable names are non-empty strings composed of lowercase alphabetic characters. * Simulator functions should manage large numbers of objects and references efficiently. * Reference counts are managed correctly through assignments and releases, ensuring garbage collection accurately identifies unreachable objects.","solution":"def assign_reference(objects: dict, references: dict, var_name: str, obj_id: int) -> None: Assign a new reference to a variable. Parameters: objects (dict): Dictionary of object IDs to objects. references (dict): Dictionary of variable names to object IDs. var_name (str): Variable name to assign a new reference. obj_id (int): Object ID to be referenced. Returns: None # If the variable already has a reference, release it first if var_name in references: release_reference(objects, references, var_name) # Assign the new reference references[var_name] = obj_id if obj_id in objects: if \'__refcount__\' in objects[obj_id]: objects[obj_id][\'__refcount__\'] += 1 else: objects[obj_id][\'__refcount__\'] = 1 def release_reference(objects: dict, references: dict, var_name: str) -> None: Release a reference from a variable. Parameters: objects (dict): Dictionary of object IDs to objects. references (dict): Dictionary of variable names to object IDs. var_name (str): Variable name whose reference is to be released. Returns: None if var_name in references: obj_id = references[var_name] if obj_id in objects and \'__refcount__\' in objects[obj_id]: objects[obj_id][\'__refcount__\'] -= 1 if objects[obj_id][\'__refcount__\'] == 0: del objects[obj_id] del references[var_name] def garbage_collect(objects: dict) -> None: Garbage collect objects with zero reference counts. Parameters: objects (dict): Dictionary of object IDs to objects. Returns: None to_delete = [obj_id for obj_id, data in objects.items() if data.get(\'__refcount__\', 1) == 0] for obj_id in to_delete: del objects[obj_id]"},{"question":"# Coding Assessment Question **Problem Context**: You are developing an application that involves extensive manipulation and transformation of strings. One crucial function you need to implement involves reversing each word in the string while maintaining the order of the words. **Task**: Create a function `reverse_words(s: str) -> str` that reverses each word in a given string while preserving the order of the words. Words are defined as sequences of non-space characters, and the words in the string will be separated by single spaces. **Function Signature**: ```python def reverse_words(s: str) -> str: pass ``` **Constraints**: 1. The input string will only contain printable ASCII characters and spaces. 2. There must be exactly one space between words, and no leading or trailing spaces. 3. The function should handle edge cases, such as empty strings and single-word strings. 4. Optimize for time and space complexity. **Input Format**: - A single string `s` containing words separated by spaces. **Output Format**: - A string where each word from the input string is reversed, but the order of the words remains the same. **Example**: ``` >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"a b c d e\\") \\"a b c d e\\" >>> reverse_words(\\"a\\") \\"a\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"data science\\") \\"atad ecneics\\" ``` **Additional Task**: - Implement a `main` function that reads an input string from the user, calls the `reverse_words` function, and prints the result. Ensure this main function handles invalid input scenarios gracefully, such as null inputs or non-string inputs. **Performance Requirements**: - The function should have a time complexity of O(n), where n is the length of the input string. - The space complexity should be optimally managed using in-place transformations where possible.","solution":"def reverse_words(s: str) -> str: This function takes a string s and returns a new string with each word reversed, but with the original word order preserved. return \' \'.join(word[::-1] for word in s.split())"},{"question":"# Implement a Custom Sorting Algorithm for a Specific Use Case You are tasked with implementing a custom sorting algorithm for sorting a list of complex objects. The objects have multiple attributes, and the sorting should be based on one primary attribute and one secondary attribute. Instructions 1. Define a class `CustomObject` with the following attributes: * `name` (string): Name of the object. * `priority` (integer): Primary sorting key. * `timestamp` (integer): Secondary sorting key. 2. Implement a function `custom_sort` that takes a list of `CustomObject` instances and returns the sorted list. The sorting should first consider the `priority` attribute in ascending order. If two objects have the same `priority`, it should then consider the `timestamp` attribute also in ascending order. 3. Demonstrate the use of the `custom_sort` function with a list of `CustomObject` instances. Expected Input and Output * **Input**: * A list of `CustomObject` instances. * **Output**: * A list of `CustomObject` instances sorted based on the specified criteria. Performance Requirements * Ensure your function works efficiently with input lists of up to 1,000 objects. Example ```python # Example usage of `custom_sort` function class CustomObject: def __init__(self, name, priority, timestamp): self.name = name self.priority = priority self.timestamp = timestamp def __repr__(self): return f\\"{self.name} (priority: {self.priority}, timestamp: {self.timestamp})\\" def custom_sort(objects): return sorted(objects, key=lambda obj: (obj.priority, obj.timestamp)) # Demonstrating the use of the custom_sort function objects = [ CustomObject(\'obj1\', 2, 3), CustomObject(\'obj2\', 1, 2), CustomObject(\'obj3\', 2, 1), CustomObject(\'obj4\', 1, 3), CustomObject(\'obj5\', 3, 2) ] sorted_objects = custom_sort(objects) print(sorted_objects) # Output: # [obj2 (priority: 1, timestamp: 2), # obj4 (priority: 1, timestamp: 3), # obj3 (priority: 2, timestamp: 1), # obj1 (priority: 2, timestamp: 3), # obj5 (priority: 3, timestamp: 2)] ``` You are expected to write your own `CustomObject` class definition and `custom_sort` function, and demonstrate their use with a sample list of `CustomObject` instances.","solution":"class CustomObject: def __init__(self, name, priority, timestamp): self.name = name self.priority = priority self.timestamp = timestamp def __repr__(self): return f\\"{self.name} (priority: {self.priority}, timestamp: {self.timestamp})\\" def custom_sort(objects): return sorted(objects, key=lambda obj: (obj.priority, obj.timestamp)) # Demonstrating the use of the custom_sort function objects = [ CustomObject(\'obj1\', 2, 3), CustomObject(\'obj2\', 1, 2), CustomObject(\'obj3\', 2, 1), CustomObject(\'obj4\', 1, 3), CustomObject(\'obj5\', 3, 2) ] sorted_objects = custom_sort(objects) print(sorted_objects) # Output: # [obj2 (priority: 1, timestamp: 2), # obj4 (priority: 1, timestamp: 3), # obj3 (priority: 2, timestamp: 1), # obj1 (priority: 2, timestamp: 3), # obj5 (priority: 3, timestamp: 2)]"},{"question":"# Matrix Traversal and Pathfinding Problem Given a 2D matrix of integers, your task is to find the maximum sum of any path from the top-left corner to the bottom-right corner. You can only move right or down at each step. Description Implement the `max_path_sum` method of the `Matrix` class that calculates the maximum sum of any path from the top-left corner to the bottom-right corner in the given matrix. The matrix will be represented as a list of lists. Specifications * **Input**: * A 2D list `matrix` representing the grid of integers. * **Output**: * Return an integer representing the maximum sum along a path from the top-left corner to the bottom-right corner of the matrix. Example ```python class Matrix: def __init__(self, matrix: list[list[int]]) -> None: self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if matrix else 0 def max_path_sum(self) -> int: if not self.matrix: return 0 # Initialize a 2D list to store the maximum sum at each cell dp = [[0 for _ in range(self.cols)] for _ in range(self.rows)] dp[0][0] = self.matrix[0][0] # Fill in the first row for col in range(1, self.cols): dp[0][col] = dp[0][col - 1] + self.matrix[0][col] # Fill in the first column for row in range(1, self.rows): dp[row][0] = dp[row - 1][0] + self.matrix[row][0] # Fill in the rest of the dp table for row in range(1, self.rows): for col in range(1, self.cols): dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]) + self.matrix[row][col] return dp[self.rows - 1][self.cols - 1] if __name__ == \\"__main__\\": matrix_data = [ [5, 3, 2, 1], [1, 2, 10, 1], [4, 3, 2, 20], [2, 5, 10, 9] ] mat = Matrix(matrix_data) print(mat.max_path_sum()) # Output: 51 (5->3->2->10->2->20->9) ``` Instructions 1. Implement the `max_path_sum` method in the `Matrix` class. 2. Use dynamic programming to build a table that stores the maximum sum at each cell. 3. Ensure that your solution correctly handles edge cases such as empty matrices or single row/column matrices. 4. Optimize the solution to work efficiently with matrices up to 1000x1000 in size. Constraints * The dimensions of the matrix, m (rows) and n (columns), can be up to 1000. * Each cell in the matrix contains an integer between -1000 and 1000 inclusive.","solution":"class Matrix: def __init__(self, matrix: list[list[int]]) -> None: self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if matrix else 0 def max_path_sum(self) -> int: if not self.matrix: return 0 # Initialize a 2D list to store the maximum sum at each cell dp = [[0 for _ in range(self.cols)] for _ in range(self.rows)] dp[0][0] = self.matrix[0][0] # Fill in the first row for col in range(1, self.cols): dp[0][col] = dp[0][col - 1] + self.matrix[0][col] # Fill in the first column for row in range(1, self.rows): dp[row][0] = dp[row - 1][0] + self.matrix[row][0] # Fill in the rest of the dp table for row in range(1, self.rows): for col in range(1, self.cols): dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]) + self.matrix[row][col] return dp[self.rows - 1][self.cols - 1] if __name__ == \\"__main__\\": matrix_data = [ [5, 3, 2, 1], [1, 2, 10, 1], [4, 3, 2, 20], [2, 5, 10, 9] ] mat = Matrix(matrix_data) print(mat.max_path_sum()) # Output: 51 (5->3->2->10->2->20->9)"},{"question":"# Problem: Handling and Extending Matrix Operations You are required to extend the given Matrix class to include a new method `inverse_matrix` that computes the inverse of the matrix if it exists. The implementation should handle edge cases and validate inputs to ensure correct functionality. # Function Signature ```python def inverse_matrix(self) -> \'Matrix\': ``` # Requirements 1. Implement the `inverse_matrix` method in the given Matrix class. 2. Validate that the matrix is square (number of rows equals number of columns). 3. Check if the matrix is invertible by ensuring its determinant is non-zero. 4. Use appropriate algorithms for matrix inversion, like Gaussian elimination or LU decomposition. 5. Raise appropriate exceptions for any invalid inputs: - Non-square matrices. - Singular matrices (determinant is zero). # Constraints - The matrix is represented as a 2D list (a list of lists) with numeric values. - Implement necessary helper methods for determinant calculation and matrix inversion. - Do not use external libraries for matrix inversion; only Python\'s standard library and basic operations are allowed. # Example ```python >>> matrix = Matrix([[2, 5], [1, 3]]) >>> inv_matrix = matrix.inverse_matrix() >>> inv_matrix.values [[-3.0, 5.0], [1.0, -2.0]] ``` # Note - For a 2x2 matrix [[a, b], [c, d]], its inverse is [[frac{d}{ad-bc}, frac{-b}{ad-bc}], [frac{-c}{ad-bc}, frac{a}{ad-bc}]] if the determinant (ad-bc neq 0). - Generalize this concept for larger matrices using Gaussian elimination or LU decomposition. - Ensure numerical stability and handle potential floating-point precision issues properly.","solution":"class Matrix: def __init__(self, values): self.values = values self.rows = len(values) self.cols = len(values[0]) if not all(len(row) == self.cols for row in values): raise ValueError(\\"All rows in the matrix must have the same length\\") if self.rows != self.cols: raise ValueError(\\"Matrix must be square to invert\\") def determinant(self, matrix=None): if matrix is None: matrix = self.values # Base case for 2x2 matrix: if len(matrix) == 2 and len(matrix[0]) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1)**c) * matrix[0][c] * self.determinant(self.get_minor(matrix, 0, c)) return determinant def get_minor(self, matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def inverse_matrix(self): if self.rows != self.cols: raise ValueError(\\"Non-square matrices cannot be inverted\\") det = self.determinant(self.values) if det == 0: raise ValueError(\\"Singular matrix cannot be inverted\\") # Base case for 2x2 matrix: if self.rows == 2: return Matrix([[self.values[1][1] / det, -1 * self.values[0][1] / det], [-1 * self.values[1][0] / det, self.values[0][0] / det]]) # Find matrix of cofactors cofactors = [] for r in range(self.rows): cofactorRow = [] for c in range(self.cols): minor = self.get_minor(self.values, r, c) cofactorRow.append(((-1)**(r+c)) * self.determinant(minor)) cofactors.append(cofactorRow) cofactors = self.transpose_matrix(cofactors) for r in range(self.rows): for c in range(self.cols): cofactors[r][c] = cofactors[r][c] / det return Matrix(cofactors) def transpose_matrix(self, matrix): return [[matrix[c][r] for c in range(len(matrix))] for r in range(len(matrix[0]))] # Example usage: # matrix = Matrix([[2, 5], [1, 3]]) # inv_matrix = matrix.inverse_matrix() # print(inv_matrix.values)"},{"question":"# Generating the Longest Arithmetic Subsequence Context: You are given an array of integers. Your task is to implement a function that returns the length of the longest arithmetic subsequence within the given array. An arithmetic subsequence is defined as a subsequence of numbers with a constant difference between consecutive elements. Specifications: * Function Signature: `def longest_arith_seq_length(nums: List[int]) -> int` * Input: * A list of integers `nums` * Output: * An integer representing the length of the longest arithmetic subsequence. Constraints: 1. The input list may have between 1 and 1000 elements. 2. Each element in the list is a non-negative integer and does not exceed 10,000. 3. Your solution should preferably operate in O(n^2) time complexity. Example: ```python longest_arith_seq_length([3, 6, 9, 12]) # Returns 4 longest_arith_seq_length([9, 4, 7, 2, 10]) # Returns 3 longest_arith_seq_length([20, 1, 15, 3, 10, 5, 8]) # Returns 4 ``` Task: Implement the function `longest_arith_seq_length()` that satisfies the above requirements. Include necessary edge case handling and systematic testing.","solution":"def longest_arith_seq_length(nums): if not nums: return 0 n = len(nums) if n == 1: return 1 dp = [{} for _ in range(n)] max_length = 2 for i in range(1, n): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 # a new sequence that starts with length 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"# Problem Statement You are given a list of integers and your task is to sort them using the QuickSort algorithm. Implement the function `quick_sort(nums: List[int]) -> List[int]`, which takes a list of integers `nums` and returns a new sorted list in ascending order. # Input * `nums`: A list of integers which may contain both positive and negative values. # Output * A new list of integers sorted in ascending order. # Constraints 1. The length of the list will be in the range 1 to 10^4. 2. The integers in the list will be in the range from -10^6 to 10^6. # Requirements * Implement the QuickSort algorithm. * Ensure the function handles all edge cases, including empty lists. * Optimize for average and worst-case performance by using a good pivot selection strategy (e.g., Median of Three). # Example ```python from typing import List def quick_sort(nums: List[int]) -> List[int]: if len(nums) <= 1: return nums pivot = nums[len(nums) // 2] left = [x for x in nums if x < pivot] middle = [x for x in nums if x == pivot] right = [x for x in nums if x > pivot] return quick_sort(left) + middle + quick_sort(right) # Example usage nums = [3, 6, 8, 10, 1, 2, 1] sorted_nums = quick_sort(nums) print(sorted_nums) # Output should be: [1, 1, 2, 3, 6, 8, 10] ```","solution":"from typing import List def quick_sort(nums: List[int]) -> List[int]: if len(nums) <= 1: return nums pivot = nums[len(nums) // 2] left = [x for x in nums if x < pivot] middle = [x for x in nums if x == pivot] right = [x for x in nums if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Problem Statement Consider a street with houses numbered consecutively from 1 to n. There is a thief who starts at house 1, moving forward step-by-step, stealing from houses along the way. However, the thief can only steal from a house if it is a power of 2 (i.e., houses numbered 1, 2, 4, 8, 16, etc.). Given the number of houses, n, write a function to calculate the total number of houses the thief will steal from during his journey. **Function Signature**: `def count_powers_of_two_houses(n: int) -> int` # Input - **n**: An integer n (1 ≤ n ≤ 10^5) representing the number of houses. # Output - **int**: The total number of houses the thief will steal from, which are houses numbered as powers of 2 up to n. # Constraints - The number of houses is always a positive integer. - The thief will only steal from houses that are numbered as powers of 2. # Examples 1. **Input**: `n = 10` **Output**: `4` (because the thief will steal from houses numbered 1, 2, 4, and 8) 2. **Input**: `n = 16` **Output**: `5` (because the thief will steal from houses numbered 1, 2, 4, 8, and 16) 3. **Input**: `n = 5` **Output**: `3` (because the thief will steal from houses numbered 1, 2, and 4) # Instructions 1. Implement the function `count_powers_of_two_houses(n: int) -> int`. 2. Conduct unit tests to ensure the algorithm correctly calculates the number of houses from which the thief will steal. 3. Optimize the algorithm to handle the upper limit of n efficiently.","solution":"def count_powers_of_two_houses(n: int) -> int: Given the number of houses n, return the count of houses that the thief will steal from, which are houses numbered as powers of 2 up to n. count = 0 power = 1 while power <= n: count += 1 power *= 2 return count"},{"question":"# Task: Implement a Dijkstra\'s Algorithm for Shortest Path in a Graph Objective You are provided with a simple graph structure and an implementation of the Breadth-First Search (BFS) algorithm for unweighted shortest-path calculation. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a source node to all other nodes in a weighted graph. Dijkstra\'s algorithm accounts for edge weights and ensures the shortest path is computed for graphs with non-negative weights. Requirements 1. **Function Definition**: Define a function `dijkstra_shortest_path` with the following parameters: * `graph: Dict[int, List[Tuple[int, int]]]`: A dictionary where the key is a node, and the value is a list of tuples (neighbor, weight) representing the connected nodes and the edge weights. * `start: int`: An integer representing the starting node for the shortest path calculation. 2. **Input Format**: * `graph`: A dictionary representing a weighted graph. * `start`: An integer representing the starting node. 3. **Output Format**: * A dictionary where the key is a node, and the value is the minimum distance from the start node to that node. 4. **Constraints**: * The input graph will have at least one node and no more than 1000 nodes. * All edge weights will be non-negative integers. * The graph may be disconnected. Performance Requirements The function should compute the shortest paths efficiently within the given constraints. Scenario You are tasked with developing a feature for a routing application that calculates the shortest path from a given location to all other locations on a map. Given the varying distances (weights) between locations, Dijkstra\'s algorithm is chosen for its efficiency in handling graphs with non-negative weights. Implement and test this technique to ensure it provides accurate shortest paths within a reasonable execution time. ```python def dijkstra_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: import heapq distances = {node: float(\'infinity\') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances ``` Ensure to test the function with various graph configurations to validate its correctness and performance.","solution":"def dijkstra_shortest_path(graph, start): import heapq # Initialize distances with infinity except for the start node distances = {node: float(\'infinity\') for node in graph} distances[start] = 0 # Use a priority queue to store (distance, node) tuples priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the distance is greater than the recorded shortest distance, skip it if current_distance > distances[current_node]: continue # Check neighbors of the current node for neighbor, weight in graph[current_node]: distance = current_distance + weight # If a new shorter path is found, update the distance and push to the priority queue if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Advanced Coding Assessment Question Context You are developing a scheduling system for a series of events. Each event has a start time and end time, and you need to manage them such that no two events overlap. Problem Statement Implement a class `EventScheduler` that helps to manage the events. The class should allow adding new events and checking if a new event can be scheduled without overlapping existing events. 1. Implement the class `EventScheduler` with the following methods: - `add_event(self, start: int, end: int) -> bool`: Attempts to add an event from `start` to `end`. Returns `True` if the event is added successfully (i.e., it does not overlap with any existing events), and `False` otherwise. - `can_schedule(self, start: int, end: int) -> bool`: Returns `True` if an event from `start` to `end` can be added without overlapping existing events, and `False` otherwise. 2. Ensure proper handling of edge cases: - Events with `end` time less than or equal to `start` time should not be allowed. - Events should be managed efficiently to ensure quick addition and overlap checking. Constraints * `start` and `end` times are non-negative integers. * There can be up to 10^4 events. Function Signatures * `class EventScheduler` - `def __init__(self) -> None` - `def add_event(self, start: int, end: int) -> bool` - `def can_schedule(self, start: int, end: int) -> bool` Input and Output * `EventScheduler.__init__()` - **Initialization**: Initializes an empty list of events. * `EventScheduler.add_event(start: int, end: int) -> bool` - **Input**: Two integers `start` and `end`. - **Output**: Returns `True` if the event from `start` to `end` is added successfully, and `False` otherwise. * `EventScheduler.can_schedule(start: int, end: int) -> bool` - **Input**: Two integers `start` and `end`. - **Output**: Returns `True` if the event from `start` to `end` can be scheduled without overlapping existing events, and `False` otherwise. Example Usage ```python es = EventScheduler() # Add events print(es.add_event(1, 5)) # Outputs: True (event added) print(es.add_event(6, 10)) # Outputs: True (event added) print(es.add_event(5, 6)) # Outputs: True (event added) print(es.add_event(3, 4)) # Outputs: False (overlaps with existing events) # Check if an event can be scheduled print(es.can_schedule(2, 3)) # Outputs: False (overlaps with existing events) print(es.can_schedule(10, 15)) # Outputs: True (can be scheduled) print(es.can_schedule(5, 7)) # Outputs: False (overlaps with existing events) # Handling edge cases try: es.add_event(10, 10) # Outputs: False (invalid event) except ValueError as e: print(e) # Outputs: Event start time must be before the end time try: es.add_event(7, 5) # Outputs: False (invalid event) except ValueError as e: print(e) # Outputs: Event start time must be before the end time ``` By following these guidelines and example usage patterns, the `EventScheduler` class should help manage and schedule events effectively without conflicts.","solution":"class EventScheduler: def __init__(self): self.events = [] def add_event(self, start: int, end: int) -> bool: if start >= end: return False if not self.can_schedule(start, end): return False self.events.append((start, end)) self.events.sort() # Keep events sorted for efficient overlap checking return True def can_schedule(self, start: int, end: int) -> bool: for event_start, event_end in self.events: if start < event_end and end > event_start: return False return True"},{"question":"# Question Context: You are developing a feature for a text editor which involves text manipulation. A common operation is reversing the words in a given sentence, where the words are defined as non-space contiguous sequences of characters. Task: Write a function `reverse_words(sentence: str) -> str` that: 1. Accepts a single input string `sentence` containing words separated by spaces. 2. Returns a new string where the order of words is reversed but the characters within each word remain in the original order. # Requirements: 1. The function should handle multiple spaces between words and trim leading/trailing spaces. 2. Any additional spaces within the sentence should be reduced to a single space in the output. 3. The function should preserve the case of the characters. # Input Format: * A single string `sentence`. # Output Format: * A string with the words in reversed order. # Constraints: * The length of the input string will be at most 10<sup>5</sup> characters. * The input can contain alphabetic characters (both uppercase and lowercase) and spaces. # Example Usage: ```python >>> reverse_words(\' Hello world \') \'world Hello\' >>> reverse_words(\'The quick brown fox\') \'fox brown quick The\' >>> reverse_words(\'Python programming is fun\') \'fun is programming Python\' >>> reverse_words(\'a b c d\') \'d c b a\' >>> reverse_words(\' singleWord \') \'singleWord\' >>> reverse_words(\'\') \'\' ``` # Performance Requirements: - The solution should efficiently handle input strings, ensuring linear time complexity relative to the length of the string. Implementation Example: Here is a function signature to start with: ```python def reverse_words(sentence: str) -> str: pass ```","solution":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: The sentence with words in reversed order. # Split the sentence by spaces, filtering out empty strings caused by multiple spaces words = [word for word in sentence.split(\' \') if word] # Reverse the order of the words and join them by a single space return \' \'.join(reversed(words))"},{"question":"# Question You are given the task of writing a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list (matrix) of integers and returns its transpose. Input - A 2D list `matrix` of integers where the matrix size is `n x m`, which means there are `n` rows and `m` columns. Output - A 2D list representing the transposed matrix. The size of the transposed matrix should be `m x n`. Constraints - The input matrix will have `n > 0` and `m > 0`. - The total number of elements in the matrix will not exceed 10^6. Expected Time Complexity - O(n * m), where `n` is the number of rows and `m` is the number of columns in the input matrix. Example ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([]) Traceback (most recent call last): ... ValueError: Empty matrix provided. >>> transpose_matrix([[1, 2], [3, \'a\']]) Traceback (most recent call last): ... TypeError: Matrix can contain only integers. ``` Notes - You need to validate the input to ensure it is a non-empty matrix of integers. - Raise a `ValueError` if the matrix is empty. - Raise a `TypeError` if any element of the matrix is not an integer. Write the function `transpose_matrix` adhering to these specifications, ensuring it handles and raises errors for invalid inputs correctly.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix: raise ValueError(\\"Empty matrix provided.\\") if not all(isinstance(row, list) for row in matrix): raise TypeError(\\"Matrix should be a list of lists.\\") for row in matrix: if not all(isinstance(elem, int) for elem in row): raise TypeError(\\"Matrix can contain only integers.\\") return list(map(list, zip(*matrix)))"},{"question":"# Question: Find the Most Frequent Element in an Array Context You are given an array of integers, where your task is to find the element that appears most frequently. If there are multiple elements with the same highest frequency, return any one of them. Function Signature ```python def most_frequent_element(arr: list[int]) -> int: ``` Input * A list of integers `arr` (1 ≤ len(arr) ≤ 10^5) where each integer can be in the range of (-10^9) to (10^9). Output * An integer which is the most frequent element in the array. Constraints * An element may appear more than once in the array. * If there are multiple elements with the same highest frequency, return any one of them. Example ```python >>> most_frequent_element([1, 3, 2, 1, 4, 1, 3, 3]) 1 >>> most_frequent_element([5, 5, 5, 7, 7, 7]) 5 # or 7 >>> most_frequent_element([10, 20, 10, 30, 20, 20, 30, 10]) 10 # or 20 >>> most_frequent_element([-1, -1, -2, -2, -1, -2]) -1 # or -2 >>> most_frequent_element([1]) 1 ``` Analysis Write a function that efficiently finds the most frequent element in the provided array. Your implementation will be assessed for both correctness and efficiency, so consider the trade-offs when managing large inputs.","solution":"from collections import Counter def most_frequent_element(arr: list[int]) -> int: Finds the most frequent element in the array. If multiple elements have the same highest frequency, returns any one of them. frequency = Counter(arr) most_common = frequency.most_common(1) # This will return a list of tuples return most_common[0][0]"},{"question":"# Problem Statement You are given two 2-dimensional matrices `mat1` and `mat2` of identical dimensions. Your task is to implement a function to find the element-wise arithmetic mean of these two matrices and return a new matrix with the computed means. Implement the function `matrix_mean` with the following signature: ```python def matrix_mean(mat1: np.ndarray, mat2: np.ndarray) -> np.ndarray: Calculate the element-wise arithmetic mean of two matrices. Args: - mat1 (np.ndarray): 2D array of shape (m, n) representing the first matrix. - mat2 (np.ndarray): 2D array of shape (m, n) representing the second matrix. Returns: - np.ndarray: 2D array of shape (m, n) representing the element-wise mean of mat1 and mat2. ``` # Constraints - Both `mat1` and `mat2` will have the same dimensions. - The dimensions of the matrices will not exceed 1,000 x 1,000. - Values in `mat1` and `mat2` will all be within the range [-10^6, 10^6]. # Example ```python import numpy as np mat1 = np.array([[1, 2, 3], [4, 5, 6]]) mat2 = np.array([[7, 8, 9], [10, 11, 12]]) result = matrix_mean(mat1, mat2) print(result) # Expected Output: # [[4. 5. 6.] # [7. 8. 9.]] ``` # Notes - Ensure that your implementation handles large inputs efficiently. - You must use the NumPy library to perform matrix operations. - You can assume that the input matrices will always be non-empty and have the same shape. Test your function with various dimensions within the specified range to ensure its correctness and performance.","solution":"import numpy as np def matrix_mean(mat1: np.ndarray, mat2: np.ndarray) -> np.ndarray: Calculate the element-wise arithmetic mean of two matrices. Args: - mat1 (np.ndarray): 2D array of shape (m, n) representing the first matrix. - mat2 (np.ndarray): 2D array of shape (m, n) representing the second matrix. Returns: - np.ndarray: 2D array of shape (m, n) representing the element-wise mean of mat1 and mat2. return (mat1 + mat2) / 2.0"},{"question":"# Problem Statement Write a function to evaluate the similarity between two strings using a specific similarity metric. Specifically, compute the Jaccard similarity index based on the set of character shingles (substrings of fixed length) derived from both strings. Ensure your implementation handles special cases, such as strings containing spaces or non-alphanumeric characters. # Function Signature ```python def jaccard_similarity(s1: str, s2: str, k: int) -> float: pass ``` # Input 1. `s1`: A string containing the first sequence of characters. 2. `s2`: A string containing the second sequence of characters. 3. `k`: An integer denoting the length of the shingle (substring). # Output Returns a float value representing the Jaccard similarity index of the two strings based on their k-shingles. # Implementation Notes The Jaccard similarity index is a measure of the similarity between two sets, defined as the size of the intersection divided by the size of the union of the sets. In this problem, the sets consist of k-shingles derived from both strings. # Examples 1. Input: ```python s1 = \\"abcde\\" s2 = \\"bcdef\\" k = 2 ``` Output: ```python 0.5 ``` Explanation: - Shingles for s1: {\\"ab\\", \\"bc\\", \\"cd\\", \\"de\\"} - Shingles for s2: {\\"bc\\", \\"cd\\", \\"de\\", \\"ef\\"} - Intersection: {\\"bc\\", \\"cd\\", \\"de\\"} - size is 3 - Union: {\\"ab\\", \\"bc\\", \\"cd\\", \\"de\\", \\"ef\\"} - size is 5 - Jaccard similarity = 3 / 5 = 0.6 2. Input: ```python s1 = \\"hello\\" s2 = \\"jello\\" k = 3 ``` Output: ```python 0.4 ``` Explanation: - Shingles for s1: {\\"hel\\", \\"ell\\", \\"llo\\"} - Shingles for s2: {\\"jel\\", \\"ell\\", \\"llo\\"} - Intersection: {\\"ell\\", \\"llo\\"} - size is 2 - Union: {\\"hel\\", \\"jel\\", \\"ell\\", \\"llo\\"} - size is 4 - Jaccard similarity = 2 / 4 = 0.5 # Constraints - 1 <= len(s1), len(s2) <= 1000 - 1 <= k <= min(len(s1), len(s2)) # Hints 1. Use sets to store and manipulate the shingles efficiently. 2. Consider edge cases where substrings might be empty or very small.","solution":"def jaccard_similarity(s1: str, s2: str, k: int) -> float: Computes the Jaccard similarity index between two strings based on k-shingles. def get_k_shingles(s, k): return {s[i:i+k] for i in range(len(s) - k + 1)} shingles_s1 = get_k_shingles(s1, k) shingles_s2 = get_k_shingles(s2, k) intersection = shingles_s1.intersection(shingles_s2) union = shingles_s1.union(shingles_s2) return len(intersection) / len(union) if union else 1.0"},{"question":"# Coding Question Context You are a software engineer working for a cybersecurity firm. Your team is working on a new feature to detect anomalies in log files by extracting unique IP addresses. The previous implementation was not capable of handling very large log files efficiently. Problem Write a Python function `extract_unique_ips` that takes a list of strings (representing log entries) and returns a list of unique IP addresses found in the logs. Each log entry is guaranteed to contain exactly one IP address. Requirements 1. Your function should handle large lists of log entries efficiently. 2. The IP addresses can be in IPv4 format. 3. IP addresses are extracted in the order they appear in the input list and the output list should also maintain this order. 4. Assume each log entry is properly formatted. Input and Output Formats * **Input**: A list of strings where each string is a log entry containing one IP address. ```python def extract_unique_ips(log_entries: list) -> list: pass ``` * **Output**: A list of unique IP addresses, in the order they first appear. Constraints * The input list can be very large, potentially containing millions of log entries. * Each log entry contains exactly one valid IPv4 address. Example ```python assert extract_unique_ips([ \\"2022-10-01 12:00:00 INFO 192.168.1.1 Success\\", \\"2022-10-01 12:00:01 ERROR 192.168.1.2 Failure\\", \\"2022-10-01 12:00:02 INFO 192.168.1.1 Success\\", \\"2022-10-01 12:00:03 INFO 192.168.1.3 Success\\", \\"2022-10-01 12:00:04 ERROR 192.168.1.4 Failure\\", \\"2022-10-01 12:00:05 INFO 192.168.1.2 Success\\" ]) == [\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.3\\", \\"192.168.1.4\\"] assert extract_unique_ips([]) == [] assert extract_unique_ips([\\"2022-10-01 12:00:00 INFO 10.0.0.1 Success\\"]) == [\\"10.0.0.1\\"] ``` **Note**: Ensure that your solution handles large datasets efficiently and maintains the order of IP addresses as they first appear in the input list.","solution":"def extract_unique_ips(log_entries: list) -> list: seen_ips = set() unique_ips = [] for log in log_entries: # Assume IP address is the fourth element in the log entry after tokenizing by spaces ip_address = log.split()[3] if ip_address not in seen_ips: seen_ips.add(ip_address) unique_ips.append(ip_address) return unique_ips"},{"question":"# Sum of Absolute Differences You are tasked with implementing a function to compute the sum of absolute differences between the respective elements of two lists. This is often used in computer vision and signal processing as a simple error metric. # Requirements 1. Write a function `sum_of_absolute_differences(list1: list[int], list2: list[int]) -> int` that takes two lists of integers and returns the sum of the absolute differences between their respective elements. 2. `list1` and `list2`: Two lists of integers of the same length. 3. The function should return an integer representing the sum of absolute differences. # Constraints 1. The length of both `list1` and `list2` will always be equal and contain at least one element. 2. The elements in the lists can be negative or positive. 3. Lists will contain at most 10^5 elements. # Example ```python list1 = [1, 2, 3, 4] list2 = [4, 3, 2, 1] result = sum_of_absolute_differences(list1, list2) print(result) # Example Output: 8 ``` **Hint**: Utilize the built-in `abs` function to compute the absolute difference between each pair of elements from `list1` and `list2`.","solution":"def sum_of_absolute_differences(list1, list2): Returns the sum of the absolute differences between the respective elements of two lists. return sum(abs(a - b) for a, b in zip(list1, list2))"},{"question":"# Coding Assessment Question: Sparse Matrix Operations Context: You are provided with a sparse matrix represented by a list of tuples. Each tuple contains three elements: (row_index, col_index, value). The task is to implement a function that performs various operations on the sparse matrix such as addition, subtraction, and scalar multiplication. Task: Implement the `SparseMatrix` class that supports operations on sparse matrices. Class Signature: ```python class SparseMatrix: def __init__(self, elements: list[tuple[int, int, int]], shape: tuple[int, int]): pass def add(self, other: \'SparseMatrix\') -> \'SparseMatrix\': pass def subtract(self, other: \'SparseMatrix\') -> \'SparseMatrix\': pass def scalar_multiply(self, scalar: int) -> \'SparseMatrix\': pass def to_dense(self) -> list[list[int]]: pass ``` Input: - `__init__`: - `elements` (list[tuple[int, int, int]]): List of tuples where each tuple represents (row_index, col_index, value). - `shape` (tuple[int, int]): Shape of the matrix as (rows, columns). - `add` and `subtract`: - `other` (\'SparseMatrix\'): Another sparse matrix to perform the addition or subtraction with. - `scalar_multiply`: - `scalar` (int): An integer value to scale the matrix elements. Output: - `__init__`: Initializes the sparse matrix with given elements and shape. - `add` and `subtract`: Returns a new `SparseMatrix` that is the result of the addition or subtraction. - `scalar_multiply`: Returns a new `SparseMatrix` that is scaled by the given scalar. - `to_dense`: Converts the sparse matrix to its dense (regular 2D list) form. Constraints: - The operations should be efficient and take advantage of the sparsity of the matrix. - Ensure that the operations handle matrices of compatible shapes only. - Raise appropriate errors for invalid operations or inputs. Example: ```python # Matrix A: 3x3 with elements: # (0, 0) = 1 # (1, 1) = 2 # (2, 2) = 3 elements_A = [(0, 0, 1), (1, 1, 2), (2, 2, 3)] matrix_A = SparseMatrix(elements_A, (3, 3)) # Matrix B: 3x3 with elements: # (0, 2) = 4 # (2, 0) = 5 elements_B = [(0, 2, 4), (2, 0, 5)] matrix_B = SparseMatrix(elements_B, (3, 3)) # Add matrices result_addition = matrix_A.add(matrix_B) # Subtract matrices result_subtraction = matrix_A.subtract(matrix_B) # Scalar multiply matrix A by 2 result_scalar_multiplication = matrix_A.scalar_multiply(2) # Convert matrix A to dense dense_A = matrix_A.to_dense() ``` **Note**: The operations should maintain the sparsity of the matrices and be performant. --- This new question maintains the style, complexity, and scope of the provided sample. It requires handling sparse matrices, which is a relevant and complementary concept in computer science and data processing.","solution":"class SparseMatrix: def __init__(self, elements: list[tuple[int, int, int]], shape: tuple[int, int]): self.elements = { (r, c): v for r, c, v in elements } self.shape = shape def add(self, other: \'SparseMatrix\') -> \'SparseMatrix\': if self.shape != other.shape: raise ValueError(\\"Matrices must have the same shape for addition\\") result_elements = {} for (r, c), v in self.elements.items(): result_elements[(r, c)] = v + other.elements.get((r, c), 0) for (r, c), v in other.elements.items(): if (r, c) not in self.elements: result_elements[(r, c)] = v result_as_list = [(r, c, v) for (r, c), v in result_elements.items()] return SparseMatrix(result_as_list, self.shape) def subtract(self, other: \'SparseMatrix\') -> \'SparseMatrix\': if self.shape != other.shape: raise ValueError(\\"Matrices must have the same shape for subtraction\\") result_elements = {} for (r, c), v in self.elements.items(): result_elements[(r, c)] = v - other.elements.get((r, c), 0) for (r, c), v in other.elements.items(): if (r, c) not in self.elements: result_elements[(r, c)] = -v result_as_list = [(r, c, v) for (r, c), v in result_elements.items()] return SparseMatrix(result_as_list, self.shape) def scalar_multiply(self, scalar: int) -> \'SparseMatrix\': result_elements = [(r, c, v * scalar) for (r, c), v in self.elements.items()] return SparseMatrix(result_elements, self.shape) def to_dense(self) -> list[list[int]]: dense_matrix = [[0] * self.shape[1] for _ in range(self.shape[0])] for (r, c), v in self.elements.items(): dense_matrix[r][c] = v return dense_matrix"},{"question":"# Longest Consecutive Sequence Context: You have been asked to develop a feature for a social media application that identifies the longest streak of consecutive days a user has been active. The application maintains a log of user activity, represented as an unsorted list of unique integers where each integer represents a day in the format `YYYYMMDD`. Task: Write a function **`longest_consecutive_sequence(days: List[int]) -> int`** that computes the length of the longest streak of consecutive active days. The function receives a list of integers and returns an integer representing the length of this streak. Input: * A list `days` (where 0 <= len(days) <= 10^5). Output: * An integer representing the longest streak of consecutive active days. Constraints: * Each integer in the list represents a valid date, hence a positive integer. * The solution must handle an empty list and return 0 in such a case. Example: ```python # Example to illustrate days = [20230102, 20230101, 20230103, 20230106, 20230105, 20230104, 20230110] assert longest_consecutive_sequence(days) == 6 days = [20221231, 20230101, 20230102, 20231118] assert longest_consecutive_sequence(days) == 3 ``` Performance Considerations: The implementation should efficiently process the list to find the longest streak of consecutive active days given the potential size constraints.","solution":"from typing import List def longest_consecutive_sequence(days: List[int]) -> int: Computes the length of the longest streak of consecutive active days. if not days: return 0 days_set = set(days) longest_streak = 0 for day in days_set: # If day-1 is not in set, then this is the start of a sequence if (day - 1) not in days_set: current_streak = 1 current_day = day while (current_day + 1) in days_set: current_day += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Problem Statement Context: You are developing an application that handles text transformations. You need to implement functionality to perform specific text modifications based on user input. Instructions: 1. **Create a function `text_transformer`**: - This function should take two parameters: `text`, a string, and `transformations`, a list of strings representing the transformations to apply. - The transformations can include the following options: `\\"reverse\\"`, `\\"upper\\"`, `\\"lower\\"`, `\\"capitalize\\"`, `\\"swapcase\\"`. - Apply the transformations in the order they appear in the list. 2. **Implement input validation**: - Ensure `text` is a string and `transformations` is a list of strings. If not, raise a `TypeError`. Specifications: - **Function Signature**: ```python def text_transformer(text: str, transformations: list) -> str: ... ``` - **Input/Output Examples**: ```python >>> text_transformer(\\"Hello World!\\", [\\"upper\\"]) \'HELLO WORLD!\' >>> text_transformer(\\"Hello World!\\", [\\"lower\\"]) \'hello world!\' >>> text_transformer(\\"Hello World!\\", [\\"reverse\\"]) \'!dlroW olleH\' >>> text_transformer(\\"Hello World!\\", [\\"swapcase\\"]) \'hELLO wORLD!\' >>> text_transformer(\\"hello world!\\", [\\"capitalize\\"]) \'Hello world!\' >>> text_transformer(\\"hElLo WoRlD\\", [\\"upper\\", \\"reverse\\"]) \'DLROW OLLEH\' >>> text_transformer(123, [\\"reverse\\"]) Traceback (most recent call last): ... TypeError: Invalid input: text must be a string and transformations must be a list of strings. >>> text_transformer(\\"Hello\\", \\"upper\\") Traceback (most recent call last): ... TypeError: Invalid input: text must be a string and transformations must be a list of strings. ``` - **Constraints**: - Ensure that the `text` parameter is a string. - Ensure that the `transformations` parameter is a list of strings, with valid transformation options being: `\\"reverse\\"`, `\\"upper\\"`, `\\"lower\\"`, `\\"capitalize\\"`, `\\"swapcase\\"`. - **Performance Requirements**: - The function should efficiently handle the transformations ensuring O(n) or better complexity per transformation, where `n` is the length of the `text`.","solution":"def text_transformer(text, transformations): Transforms the input text based on the list of transformations provided. Parameters: - text (str): The input string to be transformed. - transformations (list): A list of transformations to apply on the text in the given order. Valid transformations are \\"reverse\\", \\"upper\\", \\"lower\\", \\"capitalize\\", \\"swapcase\\". Returns: - str: The transformed text. Raises: - TypeError: If the input parameters are not of the expected types. if not isinstance(text, str): raise TypeError(\'Invalid input: text must be a string and transformations must be a list of strings.\') if not isinstance(transformations, list) or not all(isinstance(trans, str) for trans in transformations): raise TypeError(\'Invalid input: text must be a string and transformations must be a list of strings.\') for transformation in transformations: if transformation == \\"reverse\\": text = text[::-1] elif transformation == \\"upper\\": text = text.upper() elif transformation == \\"lower\\": text = text.lower() elif transformation == \\"capitalize\\": text = text.capitalize() elif transformation == \\"swapcase\\": text = text.swapcase() return text"},{"question":"# Command Line Arguments Parser You are tasked with implementing a command-line argument parser in Python. Your job is to write a class `CommandLineParser` that can parse arguments passed to a script and provide easy access to their values. **Requirements**: * Your `CommandLineParser` class should be initialized with a list of arguments. * You need to implement a method `get_value` that retrieves the value associated with a given argument name. * Implement a method `has_argument` to check if a specific argument is present. * Assume that arguments follow the format `--arg=value` or `--arg` (boolean flag). **Function Specifications**: ```python class CommandLineParser: def __init__(self, arguments: list): Initialize the CommandLineParser with the given list of arguments. pass def get_value(self, arg_name: str) -> str: Retrieve the value associated with the given argument name. pass def has_argument(self, arg_name: str) -> bool: Check if the given argument name is present. pass ``` **Constraints**: * The `arguments` list will only contain strings in the format `--arg=value` or `--arg`. * Argument names will not have spaces and will start with double dashes `--`. * There could be arguments that appear as flags without a value (i.e., `--verbose`). **Example**: ```python parser = CommandLineParser([\\"--host=localhost\\", \\"--port=8080\\", \\"--verbose\\"]) print(parser.get_value(\\"--host\\")) # Expected output: \'localhost\' print(parser.get_value(\\"--port\\")) # Expected output: \'8080\' print(parser.has_argument(\\"--verbose\\")) # Expected output: True print(parser.has_argument(\\"--debug\\")) # Expected output: False ``` **Edge Cases** to Consider: * What if the argument list is empty? * What if an argument is provided without a value and it\'s not a boolean flag? * Does the parser handle multiple arguments correctly, either with or without values?","solution":"class CommandLineParser: def __init__(self, arguments: list): Initialize the CommandLineParser with the given list of arguments. self.arguments = {} for arg in arguments: if \\"=\\" in arg: key, value = arg.split(\\"=\\", 1) self.arguments[key] = value else: self.arguments[arg] = True def get_value(self, arg_name: str) -> str: Retrieve the value associated with the given argument name. return self.arguments.get(arg_name, None) def has_argument(self, arg_name: str) -> bool: Check if the given argument name is present. return arg_name in self.arguments"},{"question":"Nested Dictionary Record Retrieval and Update You are tasked with implementing a set of Python functions to interact with a nested dictionary structure representing a collection of records. Each record contains details about individuals, including their ID, name, age, and a nested dictionary of personal attributes. The nested dictionary structure is as follows: ```python records = { \\"ID1\\": { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"attributes\\": { \\"height\\": 165, \\"weight\\": 68, \\"hobbies\\": [\\"reading\\", \\"swimming\\"] } }, \\"ID2\\": { \\"name\\": \\"Bob\\", \\"age\\": 25, \\"attributes\\": { \\"height\\": 175, \\"weight\\": 75, \\"hobbies\\": [\\"cycling\\", \\"hiking\\"] } }, ... } ``` Your tasks are to implement the following functions: 1. `get_attribute(record_id: str, attr_key: str) -> any`: This function fetches the value of an attribute for a given record: - **Input**: - `record_id` (str): The ID of the record. - `attr_key` (str): The key of the attribute to retrieve. - **Output**: - Returns the value of the attribute (which can be of any type). - **Constraints**: - The function should raise a `KeyError` if the `record_id` does not exist. - The function should raise a `KeyError` if the `attr_key` does not exist within the specified record. 2. `update_attribute(record_id: str, attr_key: str, attr_value: any) -> None`: This function updates the value of an attribute for a given record: - **Input**: - `record_id` (str): The ID of the record. - `attr_key` (str): The key of the attribute to update. - `attr_value` (any): The new value of the attribute. - **Output**: - None (the dictionary is updated in place). - **Constraints**: - The function should raise a `KeyError` if the `record_id` does not exist. - The function should raise a `KeyError` if the `attr_key` does not exist within the specified record. # Example ```python records = { \\"ID1\\": { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"attributes\\": { \\"height\\": 165, \\"weight\\": 68, \\"hobbies\\": [\\"reading\\", \\"swimming\\"] } }, \\"ID2\\": { \\"name\\": \\"Bob\\", \\"age\\": 25, \\"attributes\\": { \\"height\\": 175, \\"weight\\": 75, \\"hobbies\\": [\\"cycling\\", \\"hiking\\"] } } } # Example usage of get_attribute: >>> get_attribute(\\"ID1\\", \\"height\\") 165 >>> get_attribute(\\"ID1\\", \\"unknown_attr\\") Traceback (most recent call last): ... KeyError: \\"The attribute \'unknown_attr\' does not exist within record \'ID1\'.\\" >>> get_attribute(\\"unknown_id\\", \\"height\\") Traceback (most recent call last): ... KeyError: \\"The record ID \'unknown_id\' does not exist.\\" # Example usage of update_attribute: >>> update_attribute(\\"ID1\\", \\"weight\\", 70) >>> records[\\"ID1\\"][\\"attributes\\"][\\"weight\\"] 70 >>> update_attribute(\\"ID2\\", \\"hobbies\\", [\\"running\\", \\"painting\\"]) >>> records[\\"ID2\\"][\\"attributes\\"][\\"hobbies\\"] [\'running\', \'painting\'] >>> update_attribute(\\"unknown_id\\", \\"weight\\", 70) Traceback (most recent call last): ... KeyError: \\"The record ID \'unknown_id\' does not exist.\\" >>> update_attribute(\\"ID2\\", \\"unknown_attr\\", 80) Traceback (most recent call last): ... KeyError: \\"The attribute \'unknown_attr\' does not exist within record \'ID2\'.\\" ``` # Constraints - Ensure your code handles edge cases such as non-existent records or attributes. - Maintaining the nested dictionary structure is critical; you must not modify the overall format. # Performance - Time complexity for both operations should be (O(1)) on average assuming a hash table implementation for dictionaries. - Space complexity for both operations should be (O(1)). Good luck, and remember to test edge cases such as non-existent records, attributes, and significant updates!","solution":"def get_attribute(records, record_id: str, attr_key: str): Fetches the value of an attribute for a given record. Args: records (dict): The dictionary containing the records. record_id (str): The ID of the record. attr_key (str): The key of the attribute to retrieve. Returns: any: The value of the attribute. Raises: KeyError: If the `record_id` or `attr_key` does not exist. if record_id not in records: raise KeyError(f\\"The record ID \'{record_id}\' does not exist.\\") if attr_key not in records[record_id][\\"attributes\\"]: raise KeyError(f\\"The attribute \'{attr_key}\' does not exist within record \'{record_id}\'.\\") return records[record_id][\\"attributes\\"][attr_key] def update_attribute(records, record_id: str, attr_key: str, attr_value: any) -> None: Updates the value of an attribute for a given record. Args: records (dict): The dictionary containing the records. record_id (str): The ID of the record. attr_key (str): The key of the attribute to update. attr_value (any): The new value of the attribute. Returns: None Raises: KeyError: If the `record_id` or `attr_key` does not exist. if record_id not in records: raise KeyError(f\\"The record ID \'{record_id}\' does not exist.\\") if attr_key not in records[record_id][\\"attributes\\"]: raise KeyError(f\\"The attribute \'{attr_key}\' does not exist within record \'{record_id}\'.\\") records[record_id][\\"attributes\\"][attr_key] = attr_value"},{"question":"# Array Pair Sum Finder **Background**: Given an array of integers, you need to find all unique pairs in the array whose sum equals a given target value. The pairs should be returned as a list of tuples, where each tuple represents a pair of numbers. Ensure that each pair is sorted in ascending order and that the list of pairs is also sorted in ascending order. **Function Specification**: Implement the function `find_pairs_with_sum(arr, target_sum)` that accomplishes this task. **Input**: - `arr`: A list of integers where pairs will be searched. - `target_sum`: An integer representing the target sum for the pairs. **Output**: - A list of tuples where each tuple contains two integers that add up to the `target_sum`. The tuples and the list must be sorted in ascending order. **Constraints**: - Each input integer array will have at least 0 and up to 1000 elements. - The integers in the array can be both positive and negative. - No duplicate pairs are allowed in the output. - If no pairs are found, return an empty list. **Performance Requirements**: - The solution should handle arrays of varying lengths efficiently. **Example**: ```python def find_pairs_with_sum(arr, target_sum): # Your code here # Examples print(find_pairs_with_sum([1, 2, 3, 4, 5], 5)) # [(1, 4), (2, 3)] print(find_pairs_with_sum([-1, 0, 1, 2, -1, -4], 0)) # [(-1, 1)] print(find_pairs_with_sum([-2, -1, 0, 1, 2], 1)) # [(-1, 2), (0, 1)] print(find_pairs_with_sum([1, 2, 3, 4, 5], 10)) # [] print(find_pairs_with_sum([], 3)) # [] ``` Implement the function to demonstrate your understanding of handling array operations, sorting, and filtering unique pairs.","solution":"def find_pairs_with_sum(arr, target_sum): Find all unique pairs in the array whose sum equals the target value. Each pair in the result is sorted in ascending order, and the list of pairs is sorted in ascending order as well. seen = set() output = set() for num in arr: complement = target_sum - num if complement in seen: output.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(output)"},{"question":"# Problem Statement You are tasked with developing a function that extracts specific nested information from a complex JSON object representing a collection of books. Each book has multiple authors, and each author may have multiple awards. Your function should return a list of authors who have won a specific award. # Requirements 1. **Extract Authors by Award**: Write a function that takes two parameters, a list of book objects (as described below) and the name of an award. The function should return a list of authors who have won that specific award. # Input/Output - **Input**: 1. A list of book objects, where each book is a dictionary containing: - \\"title\\" (string): the title of the book. - \\"authors\\" (list of dictionaries): a list of authors, each with: - \\"name\\" (string): the author\'s name. - \\"awards\\" (list of strings): a list of awards the author has won. 2. A string representing the name of an award. - **Output**: A list of strings, where each string is the name of an author who has won the specified award. The names should be unique. # Constraints 1. If no authors have won the specified award, return an empty list. 2. An author can appear only once in the output list. 3. The input will always be a valid list of books containing valid dictionaries. 4. The awards and author names are case-sensitive. # Function Signature ```python def get_authors_by_award(books: list[dict], award_name: str) -> list[str]: pass ``` # Example ```python books = [ { \\"title\\": \\"Book One\\", \\"authors\\": [ {\\"name\\": \\"Author A\\", \\"awards\\": [\\"Award X\\", \\"Award Y\\"]}, {\\"name\\": \\"Author B\\", \\"awards\\": [\\"Award Z\\"]} ] }, { \\"title\\": \\"Book Two\\", \\"authors\\": [ {\\"name\\": \\"Author C\\", \\"awards\\": [\\"Award X\\"]}, {\\"name\\": \\"Author A\\", \\"awards\\": [\\"Award Z\\"]} ] } ] award_name = \\"Award X\\" print(get_authors_by_award(books, award_name)) # Output: [\\"Author A\\", \\"Author C\\"] ``` # Implementation Details 1. Iterate through the list of books and their authors. 2. Maintain a set to track authors who have won the specified award. 3. Ensure no duplicate author names appear in the result. 4. Return the final list of author names.","solution":"def get_authors_by_award(books, award_name): Returns a list of authors who have won the specified award. Parameters: books (list of dict): The list of books with authors. award_name (str): The name of the award to search for. Returns: list of str: The list of authors who have won the specified award. authors_with_award = set() for book in books: for author in book[\'authors\']: if award_name in author[\'awards\']: authors_with_award.add(author[\'name\']) return list(authors_with_award)"},{"question":"# Problem Description You are tasked with implementing a function that performs a Depth-First Search (DFS) traversal of a directed graph. The graph is represented as an adjacency list, and you need to return the order in which nodes are visited during the DFS traversal as well as detect and return if a cycle exists in the graph. # Input - An integer `n` representing the number of nodes in the graph. - A list `edges` of tuples `(u, v)` representing directed edges from node `u` to node `v`. # Output - Return a tuple `(dfs_order, contains_cycle)` where: - `dfs_order` is a list of integers representing the nodes in the order they were visited during the DFS traversal. - `contains_cycle` is a boolean indicating whether or not the graph contains a cycle. # Constraints - 1 ≤ `n` ≤ 100 - 0 ≤ `len(edges)` ≤ 1000 - 0 ≤ `u`, `v` < `n` # Example ```python def dfs_traversal(n, edges): # Implementation goes here pass # Example Usage n = 4 edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] dfs_order, contains_cycle = dfs_traversal(n, edges) print(dfs_order) # Example Output: [0, 1, 2, 3] print(contains_cycle) # Example Output: True ``` # Notes 1. Implement the DFS traversal using an iterative or recursive approach. 2. Ensure that the returned order of nodes is based on the first encountered unvisited node. 3. For cycle detection, use appropriate methods to keep track of visited nodes and the nodes currently in the recursion stack. 4. Initialize the DFS traversal from node 0 or any other available node if node 0 does not have outgoing edges, and continue to traverse all connected components.","solution":"def dfs_traversal(n, edges): from collections import defaultdict # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * n rec_stack = [False] * n dfs_order = [] contains_cycle = False def dfs(node): nonlocal contains_cycle visited[node] = True rec_stack[node] = True dfs_order.append(node) for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor): contains_cycle = True elif rec_stack[neighbor]: contains_cycle = True rec_stack[node] = False return contains_cycle for node in range(n): if not visited[node]: if dfs(node): contains_cycle = True return dfs_order, contains_cycle"},{"question":"# Question: Implementing Depth-First Search for Strongly Connected Components You are tasked with implementing Kosaraju\'s Algorithm to find all Strongly Connected Components (SCCs) in a directed graph. In a directed graph, a subset of vertices forms an SCC if every vertex is reachable from every other vertex in this set. The graph is represented by: - An integer **V**, representing the number of vertices in the graph. - A list of lists **edges**, where each element is a pair of integers `[u, v]` indicating a directed edge from vertex **u** to vertex **v**. # Input * An integer **V** (1 <= V <= 1000) -- the number of vertices. * A list of lists **edges** representing the directed edges, where **edges[i]** (0 <= i < len(edges)) is a pair `[u, v]` (0 <= u, v < V) indicating a directed edge from vertex **u** to vertex **v**. # Output * A list of lists **sccs**, where each list contains the vertices of one strongly connected component in any order. # Constraints * The input graph may contain self-loops and multiple edges between the same vertices. * Vertices in each SCC should be listed only once. # Example ```python Input: V = 5 edges = [ [1, 0], [0, 2], [2, 1], [0, 3], [3, 4] ] Output: [[4], [3], [0, 1, 2]] ``` # Note - The output order of components and the vertices within components does not matter. - Ensure to handle graphs with vertices that are isolated (i.e., no incoming or outgoing edges). - Kosaraju\'s Algorithm uses two passes of Depth-First Search (DFS). In the first pass, record the finishing times of vertices in a stack. In the second pass, process vertices in the reverse order of their finishing times using the transposed graph. Implement the function `find_sccs(V, edges)` to solve the problem.","solution":"from collections import defaultdict, deque def find_sccs(V, edges): def dfs(v, graph, visited, stack=None): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor, graph, visited, stack) if stack is not None: stack.append(v) def transpose_graph(V, edges): transposed = defaultdict(list) for u, v in edges: transposed[v].append(u) return transposed # Step 1: Perform DFS and store vertices according to their finishing times graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * V stack = deque() for i in range(V): if not visited[i]: dfs(i, graph, visited, stack) # Step 2: Get the transpose of the graph transposed = transpose_graph(V, edges) # Step 3: Process all vertices in order defined by the stack visited = [False] * V sccs = [] while stack: v = stack.pop() if not visited[v]: scc_stack = [] dfs(v, transposed, visited, scc_stack) sccs.append(scc_stack) return sccs"},{"question":"# Problem Statement You are tasked with implementing a function that interprets a string containing a mathematical expression and evaluates it based on custom priority rules. The expressions can include addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). However, the operations should follow a non-standard order of precedence defined as: 1. Addition (`+`), Subtraction (`-`). 2. Multiplication (`*`), Division (`/`). # Function Signature ```python def evaluate_expression(expression: str) -> float: ... ``` # Input - `expression`: A string representing a mathematical expression that includes integers, plus `+`, minus `-`, multiply `*`, and divide `/`. # Output A float representing the result of the evaluated expression according to the custom priority rules. # Constraints - The input string is a valid mathematical expression with non-negative integers and operators. - Division by zero should raise a `ZeroDivisionError`. - Whitespace in the input string should be ignored. - The input string will contain at most 100 characters. # Requirements 1. Implement input validation and error handling. 2. Operate with the custom precedence rules where addition and subtraction are prioritized over multiplication and division. 3. Support standard floating-point arithmetic accuracy. 4. Ensure efficiency and handle edge cases such as division by zero and invalid input. # Custom Precedence Example - Standard precedence: `\\"2 + 3 * 4\\"` evaluates to `14` (multiplication before addition). - Custom precedence: `\\"2 + 3 * 4\\"` evaluates to `20` (all additions and subtractions evaluated first, then multiplications and divisions). # Example ```python >>> evaluate_expression(\\"2 + 3 * 4\\") 20.0 >>> evaluate_expression(\\"5 - 2 + 3\\") 6.0 >>> evaluate_expression(\\"8 / 2 * 3\\") 1.6666666666666665 >>> evaluate_expression(\\"10 + 2 - 5 / 5 * 2\\") 12.0 >>> evaluate_expression(\\"10 / 0\\") Traceback (most recent call last): ... ZeroDivisionError: division by zero >>> evaluate_expression(\\"10 + + 3\\") Traceback (most recent call last): ... ValueError: Invalid Expression ``` # Note - Ensure to evaluate the expression following the custom precedence rules. - Handle whitespace sensibly, ensuring it doesn\'t affect the evaluation. - Provide clear error messages for invalid expressions.","solution":"import re def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression according to custom priority rules. 1. Perform addition and subtraction operations. 2. Perform multiplication and division operations. # Remove any whitespace from the expression expression = re.sub(r\\"s+\\", \\"\\", expression) # Split the expression into addition and subtraction parts parts = re.split(r\'([+-])\', expression) # Calculate the result with + and - treatment first new_parts = [] i = 0 while i < len(parts): if parts[i] in \'+-\': new_parts.append(parts[i]) else: # Handle multiplication and division in the current part sub_parts = re.split(r\'([*/])\', parts[i]) sub_result = float(sub_parts[0]) j = 1 while j < len(sub_parts): operator = sub_parts[j] operand = float(sub_parts[j + 1]) if operator == \'*\': sub_result *= operand elif operator == \'/\': if operand == 0: raise ZeroDivisionError(\\"division by zero\\") sub_result /= operand j += 2 new_parts.append(sub_result) i += 1 # Evaluate the overall result with the simplified parts result = float(new_parts[0]) i = 1 while i < len(new_parts): operator = new_parts[i] operand = float(new_parts[i + 1]) if operator == \'+\': result += operand elif operator == \'-\': result -= operand i += 2 return result"},{"question":"# Coding Assessment Question: Prime Factorization **Context**: Prime factorization involves breaking down a composite number into its prime factors. For example, the number 28 can be factored into 2, 2, and 7, since (2 times 2 times 7 = 28). # Task: Write a function `prime_factors` that returns a list of prime factors for a given positive integer. The function should handle edge cases and input constraints accordingly. # Function Signature: ```python def prime_factors(number: int) -> List[int]: ``` # Input: * `number` (int): The integer to be factorized, where (1 leq number leq 10^6). # Output: * `List[int]`: Returns a list containing the prime factors of the given number, ordered from smallest to largest. # Constraints: * Raise a `ValueError` if `number` is not an integer. * Raise a `ValueError` if `number` is less than 1. * Ensure the function\'s performance is sufficient for (1 leq number leq 10^6). # Examples: ```python assert prime_factors(28) == [2, 2, 7] assert prime_factors(15) == [3, 5] assert prime_factors(13) == [13] assert prime_factors(1) == [1] assert prime_factors(-1) == ValueError(\\"number must be greater than or equal to 1\\") assert prime_factors(\\"string\\") == ValueError(\\"number must be an integer\\") assert prime_factors(12.34) == ValueError(\\"number must be an integer\\") ``` # Requirements: * Implement the function with an efficient algorithm, considering the provided constraints. * Validate input to ensure it meets the specified criteria. * Ensure the function is robust against various edge cases and handle exceptions properly.","solution":"from typing import List def prime_factors(number: int) -> List[int]: Returns a list of prime factors for a given positive integer. if not isinstance(number, int): raise ValueError(\\"number must be an integer\\") if number < 1: raise ValueError(\\"number must be greater than or equal to 1\\") factors = [] # Handle the number 1 case directly if number == 1: return [1] divisor = 2 while number >= divisor: while number % divisor == 0: factors.append(divisor) number //= divisor divisor += 1 return factors"},{"question":"# Coding Assessment Question Context: You have been assigned to design a new feature for an online shopping platform that helps customers determine if they can achieve a specific total purchase amount using a subset of available item prices. Your goal is to implement a function that checks if any combination of the prices can exactly sum up to a target value. Task: Implement a function `can_purchase_exact_amount(prices, target)` that checks if it is possible to pick a subset of item prices from the given list that would sum up exactly to the provided target. Function Signature: ```python def can_purchase_exact_amount(prices: list[int], target: int) -> bool: ``` Input: - `prices`: A list of integers representing item prices (`0 ≤ len(prices) ≤ 20`, `0 ≤ prices[i] ≤ 10^3`). - `target`: An integer (`0 ≤ target ≤ 10^4`). Output: - A boolean value: `True` if it is possible to achieve the target amount using any combination of item prices, otherwise `False`. Examples: ```python assert can_purchase_exact_amount([2, 3, 7, 8, 10], 11) == True assert can_purchase_exact_amount([1, 2, 3, 4, 5], 9) == True assert can_purchase_exact_amount([1, 2, 3], 7) == False assert can_purchase_exact_amount([5, 5, 5, 5], 10) == True assert can_purchase_exact_amount([], 0) == True assert can_purchase_exact_amount([], 10) == False ``` Constraints: - The function should have a time complexity of (O(2^n)) due to the subset sum problem being NP-complete, and space complexity of (O(n)) or (O(1)). **Performance Requirements**: Ensure the implementation handles the given constraints efficiently, particularly considering the exponential time complexity for the subset sum problem. Notes: - Consider using a backtracking approach or dynamic programming to solve the subset sum problem. - Pay special attention to edge cases such as an empty list and a zero target value. # Explanation: This question tests the ability to work with subsets of a list and solve combinatorial problems, similar in complexity and domain to the given questions, focusing on efficient algorithms for specific problem constraints.","solution":"def can_purchase_exact_amount(prices, target): Determines if a subset of prices can sum up exactly to the target amount. :param prices: list of integers representing item prices :param target: integer representing target amount :return: bool, True if a subset of prices can sum up to target, else False # Define a helper function to use recursion and backtracking def backtrack(index, current_sum): # Base cases if current_sum == target: return True if index >= len(prices) or current_sum > target: return False # Recursive cases: include or exclude the current price # Include the current price if backtrack(index + 1, current_sum + prices[index]): return True # Exclude the current price if backtrack(index + 1, current_sum): return True return False return backtrack(0, 0)"},{"question":"# Problem Statement You are given a series of records indicating employee arrivals and departures at the office. Your task is to determine the total amount of time each employee spent in the office for a given day. Each record includes an employee ID, a timestamp, and an action (\'arrive\' or \'depart\'). Write a function that takes these records and computes the total time each employee was present in the office. # Input ```txt The function should accept a list of tuples `records`, where each tuple contains: - an integer `employee_id` representing the employee\'s unique ID, - a string `timestamp` in the format \'HH:MM\', - a string `action`, which can either be \'arrive\' or \'depart\'. ``` # Output ```txt The function should return a dictionary where the keys are employee IDs and the values are total minutes each employee spent in the office. ``` # Constraints * The timestamps are guaranteed to be in chronological order within the same employee\'s records. * An \'arrive\' action will always be followed by a corresponding \'depart\' action for the same employee within the provided records (no partial days). * Each employee can have multiple arrive-depart cycles within the same day. * The office operates in a single day shift, i.e., the timestamps are from \'00:00\' to \'23:59\'. # Performance Requirements * The function should handle up to 10^4 records efficiently. # Example Input ```python records = [ (1, \\"09:00\\", \\"arrive\\"), (1, \\"12:00\\", \\"depart\\"), (2, \\"09:30\\", \\"arrive\\"), (2, \\"17:00\\", \\"depart\\"), (1, \\"13:00\\", \\"arrive\\"), (1, \\"15:00\\", \\"depart\\"), (3, \\"10:00\\", \\"arrive\\"), (3, \\"11:30\\", \\"depart\\"), ] ``` Expected Output ```python { 1: 300, # 180 minutes (09:00-12:00) + 120 minutes (13:00-15:00) 2: 450, # 450 minutes (09:30-17:00) 3: 90 # 90 minutes (10:00-11:30) } ``` # Implementation Implement the function `calculate_office_time` which takes a list of records and returns the total minutes each employee spent in the office: ```python def calculate_office_time(records: list[tuple[int, str, str]]) -> dict[int, int]: # implementation details pass ```","solution":"def calculate_office_time(records): from collections import defaultdict def to_minutes(timestamp): hours, minutes = map(int, timestamp.split(\\":\\")) return hours * 60 + minutes employee_time = defaultdict(int) last_arrival = {} for employee_id, timestamp, action in records: if action == \\"arrive\\": last_arrival[employee_id] = to_minutes(timestamp) elif action == \\"depart\\": if employee_id in last_arrival: duration = to_minutes(timestamp) - last_arrival[employee_id] employee_time[employee_id] += duration del last_arrival[employee_id] return dict(employee_time)"},{"question":"# Graph Traversal with Depth-First Search **Context**: A logistics company is managing a network of warehouses connected by roads, represented as a graph. They need to ensure that their delivery fleet can reach every warehouse starting from a central warehouse using depth-first search (DFS). Your task is to implement the DFS algorithm to determine the reachable warehouses. # Task: Implement the `depth_first_search` function to traverse the graph of warehouses. # Function Signature: ```python def depth_first_search(graph: dict, start_node: str) -> list: pass ``` # Input: - `graph (dict)`: A dictionary where keys are warehouse identifiers (strings) and values are lists of adjacent warehouses. - `start_node (str)`: The identifier of the starting warehouse. # Output: - A list of warehouse identifiers representing the reachable warehouses from the `start_node`. The list should be in the order the warehouses are visited by the DFS algorithm. # Constraints: - Ensure that the algorithm efficiently handles large graphs with up to 10,000 warehouses. - Implement the DFS using an iterative approach with an explicit stack to avoid recursion limit issues. - Assume all warehouse identifiers are unique strings. - Assume the graph is unidirectional (i.e., if there is a road from A to B, it doesn\'t imply a road from B to A unless explicitly stated). # Example: ```python # Example graph graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [], \'F\': [] } start_node = \'A\' reachable_warehouses = depth_first_search(graph, start_node) print(reachable_warehouses) # Output: [\'A\', \'B\', \'D\', \'F\', \'C\', \'E\'] ``` **Expectation**: Demonstrate a concrete understanding of the depth-first search algorithm, ensuring that it effectively traverses the graph and handles edge cases such as isolated nodes and large datasets.","solution":"def depth_first_search(graph: dict, start_node: str) -> list: Performs an iterative depth-first search on the graph starting from the start_node. :param graph: A dictionary where keys are warehouse identifiers and values are lists of adjacent warehouses. :param start_node: The identifier of the starting warehouse. :return: A list of warehouse identifiers representing the reachable warehouses in the order they are visited. visited = set() stack = [start_node] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) # Extend the stack with the adjacent nodes in reverse order to maintain the correct order in DFS stack.extend(reversed(graph.get(node, []))) return result"},{"question":"# Context In a list of numerical codes, a code becomes a \\"palindromic code\\" if the sequence reads the same backward as forward. Let\'s design a function to identify how many such \\"palindromic codes\\" exist in a given list. # Problem Statement Write a function `count_palindromic_codes(codes: List[str]) -> int` that takes a list of numerical codes (as strings) and returns the number of palindromic codes in the list. A palindromic code is defined as a string that reads the same forward and backward. # Expected Input and Output Formats - **Input**: A list of strings containing numerical codes. - Example: `[\\"12321\\", \\"45654\\", \\"12345\\", \\"112211\\"]` - **Output**: An integer representing the count of palindromic codes. - Example for the above input: `3` (`\\"12321\\"`, `\\"45654\\"`, and `\\"112211\\"` are palindromic codes) # Constraints 1. Codes will contain only numeric characters (\'0\'-\'9\'). 2. The list length can be up to 2000 codes. 3. The average length of a code will be less than 30 characters. # Performance Requirements - Your solution should be efficient in terms of both time and space complexities while handling the stated constraints. # Notes - A palindromic code reads the same backward as forward. - Example of checking if \\"12321\\" is a palindromic code: - Reverse of \\"12321\\" is \\"12321\\", which is the same as the original, so it is a palindromic code. # Implementation: Implement the function with the following signature: ```python from typing import List def count_palindromic_codes(codes: List[str]) -> int: # Your implementation here ```","solution":"from typing import List def count_palindromic_codes(codes: List[str]) -> int: Returns the count of palindromic codes in the provided list of codes. :param codes: List of strings containing numerical codes :return: Integer count of palindromic codes return sum(code == code[::-1] for code in codes)"},{"question":"# Scenario You have a large text document that you want to analyze for certain pattern occurrences. Specifically, you are tasked with finding how many times a specific word appears in the document, and then identifying the positions in the text where this word appears. # Problem Statement Write a function `find_word_occurrences` that takes two inputs: a string `text` representing the document, and a string `word` representing the word you are searching for. The function should return a tuple containing the count of occurrences of the word in the text and a list with the start indices of each occurrence. # Input Format Two strings: 1. `text`: The text document as a single string. 2. `word`: The word to find in the document. # Output Format A tuple containing: 1. An integer representing the number of times the word occurs in the text. 2. A list of integers representing the start indices of each occurrence of the word in the text. # Constraints * The length of `text` will not exceed 10^6 characters. * The length of `word` will not exceed 100 characters. * The comparison should be case-sensitive. * Words are sequences of non-space characters separated by spaces or punctuation. # Function Signature ```python def find_word_occurrences(text: str, word: str) -> tuple: # implementation here ``` # Examples Example 1 **Input**: ```python find_word_occurrences(\\"hello world, this is a test. Hello world!\\", \\"world\\") ``` **Output**: ```python (2, [6, 36]) ``` **Explanation**: The word \\"world\\" appears twice in the given text, at indices 6 and 36. Example 2 **Input**: ```python find_word_occurrences(\\"banana banana banana\\", \\"banana\\") ``` **Output**: ```python (3, [0, 7, 14]) ``` **Explanation**: The word \\"banana\\" appears three times in the given text, at indices 0, 7, and 14. # Implementation Notes * You may consider using the `str.find` method, `re.finditer` from the `re` module, or other efficient string searching techniques. * Ensure your approach is efficient to handle the upper limit of input sizes.","solution":"def find_word_occurrences(text, word): Returns the count of occurrences of `word` in `text` and the list of start indices for each occurrence. count = 0 indices = [] word_len = len(word) start = 0 while True: start = text.find(word, start) if start == -1: break indices.append(start) count += 1 start += word_len return (count, indices)"},{"question":"# Task: Square Root Calculation with Multiple Edge Cases Problem Statement You are provided with a function to calculate the square root of a given non-negative number. However, the function needs to be enhanced to handle special cases like NaN (not a number), infinity, and negative inputs more effectively. Your task is to extend this function to include these edge cases and improve its robustness. Function Signature ```python def sqrt_calculator(number: float) -> float: pass ``` Input - `number` (float): The number for which the square root is to be calculated. Output - Returns the square root of the number (float). Constraints 1. If `number` is negative, raise a `ValueError` with the message \\"Square root of a negative number is undefined\\". 2. If `number` is NaN (not a number), raise a `ValueError` with the message \\"Input is not a number\\". 3. If `number` is positive infinity, raise a `ValueError` with the message \\"Square root of infinity is undefined\\". 4. Return the square root of the number for all non-negative, finite numbers. Example ```python >>> sqrt_calculator(4) 2.0 >>> sqrt_calculator(0) 0.0 >>> sqrt_calculator(-4) Traceback (most recent call last): ... ValueError: Square root of a negative number is undefined >>> sqrt_calculator(float(\'nan\')) Traceback (most recent call last): ... ValueError: Input is not a number >>> sqrt_calculator(float(\'inf\')) Traceback (most recent call last): ... ValueError: Square root of infinity is undefined ``` Requirements - Implement additional validations and error handling. - Ensure the function returns the correct square root for valid inputs. - Optimize the function if possible while maintaining clarity and robustness.","solution":"import math def sqrt_calculator(number: float) -> float: Calculates and returns the square root of the given non-negative number. Handles special cases: NaN, negative numbers, and infinity. if math.isnan(number): raise ValueError(\\"Input is not a number\\") if number < 0: raise ValueError(\\"Square root of a negative number is undefined\\") if math.isinf(number): raise ValueError(\\"Square root of infinity is undefined\\") return math.sqrt(number)"},{"question":"# Coding Assessment Question Objective Implement a function to compute the smallest positive integer that is missing from a given list of integers. **Function Signature**: ```python def find_missing_integer(arr: List[int]) -> int: Returns the smallest positive integer that is not present in the input list. Parameters: arr (List[int]): A list of integers. Returns: int: The smallest positive integer that is missing from the list. ``` Input format * A list of integers `arr` (1 ≤ len(arr) ≤ 10^6) containing both positive and negative integers. Output format * Return a single integer, representing the smallest positive integer that is missing from the list. Constraints * The list can contain repeated values. * The list can contain negative numbers and zeros. * Ensure your solution runs efficiently within the provided input size. Example ```python >>> find_missing_integer([3, 4, -1, 1]) 2 >>> find_missing_integer([1, 2, 0]) 3 ``` Additional Information * Consider using an algorithm with linear time complexity, as the size of the array can be large. * Handle edge cases such as a list with no positive numbers or a list with all integers in sequence.","solution":"def find_missing_integer(arr): Returns the smallest positive integer that is not present in the input list. Parameters: arr (list of int): A list of integers. Returns: int: The smallest positive integer that is missing from the list. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: # Swap elements to their correct positions arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"# Challenge: Merge Two Sorted Lists **Context**: As part of a data processing pipeline, you often need to combine ordered datasets. One of your current tasks involves merging two sorted lists into a single sorted list. **Problem**: Write a function `merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]` that takes two lists of integers `list1` and `list2`, both already sorted in non-decreasing order, and returns a single list containing all elements from `list1` and `list2` in non-decreasing order. **Constraints**: 1. `list1` and `list2` may have different lengths, ranging from 0 to 10^5. 2. The elements within each list are guaranteed to be in non-decreasing order. **Input**: - Two lists `list1` and `list2`, each containing integers in non-decreasing order. **Output**: - A new list containing all elements from `list1` and `list2`, merged in non-decreasing order. **Performance Requirements**: - The function should process the input in linear time, O(n + m), where `n` is the length of `list1` and `m` is the length of `list2`. **Example**: ```python >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([2, 3, 5], []) [2, 3, 5] ```","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Parameters: - list1: List[int], a list of sorted integers - list2: List[int], another list of sorted integers Returns: - List[int]: a new list containing all elements from `list1` and `list2`, in non-decreasing order merged_list = [] i, j = 0, 0 # Traverse both lists and append smaller element from either list to the result while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1, append them while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2, append them while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Statement Implement a function that simulates a simple task scheduler. The scheduler should execute tasks based on their priority levels and execution times. Tasks with higher priority should be executed first. If two tasks have the same priority, the one that comes first in the input list should be executed first. # Specifications * **Function**: `schedule_tasks(tasks: list[tuple[str, int, int]]) -> list[str]` * **Input**: A list of tuples, where each tuple contains a task name (string), its priority (int), and its execution time (int) respectively. * **Output**: A list of task names in the order they should be executed. # Constraints * The length of the input list will not exceed `10^4` elements. * Priorities will be non-negative integers. * Execution time will be a positive integer. * No two tasks will have the same name. # Example ```python # Given the following list of tasks tasks = [(\\"task1\\", 2, 5), (\\"task2\\", 1, 3), (\\"task3\\", 3, 4), (\\"task4\\", 2, 2)] # After running schedule_tasks on the tasks list scheduled = schedule_tasks(tasks) # scheduled should be [\\"task3\\", \\"task1\\", \\"task4\\", \\"task2\\"] ``` # Explanation - \\"task3\\" has the highest priority (3) and is executed first. - \\"task1\\" and \\"task4\\" have the same priority (2), but \\"task1\\" comes before \\"task4\\" in the input list. - \\"task2\\" has the lowest priority (1) and is executed last.","solution":"def schedule_tasks(tasks): Returns the list of task names sorted by priority (higher first); if there is a tie, the original order is maintained. # Sort tasks by priority (descending), then by the original order (index) sorted_tasks = sorted(tasks, key=lambda x: (-x[1], tasks.index(x))) return [task[0] for task in sorted_tasks]"},{"question":"# Log File Parsing and Analysis Objective You are tasked with writing a function to analyze log data from a server and extract meaningful information. The logs contain information about user interactions, errors, and other events occurring on the server. Problem Statement Implement a function `parse_log_file(log: List[str]) -> Dict[str, Any]` that: 1. Analyzes the provided log file and extracts the following information: - The number of unique users who have accessed the server. - The most common type of error logged. - The average response time of requests. Input * A list of strings, where each string represents a line in the log file. Each line has the following format: ``` [timestamp] [user_id] [response_time] [event_type] [event_details] ``` Output * A dictionary with the following keys and their corresponding values: - `\\"unique_users\\"`: the number of unique users who accessed the server. - `\\"common_error\\"`: the most frequent error type in the log. - `\\"average_response_time\\"`: the average response time of all requests. Constraints * `timestamp` is a string representing date and time. * `user_id` is a string of alphanumeric characters. * `response_time` is an integer representing the time taken to respond to a request in milliseconds. * `event_type` is a string which could be `\\"INFO\\"`, `\\"ERROR\\"`, or `\\"WARNING\\"`. * `event_details` is a string with details about the event. Example ```python >>> logs = [ ... \\"[2023-10-02 14:12:32] user123 200 INFO User logged in\\", ... \\"[2023-10-02 14:12:35] user124 150 ERROR Database connection failed\\", ... \\"[2023-10-02 14:12:40] user125 300 INFO File uploaded\\", ... \\"[2023-10-02 14:12:50] user123 100 INFO User logged out\\", ... \\"[2023-10-02 14:12:55] user126 250 WARNING Low disk space\\", ... \\"[2023-10-02 14:13:00] user124 180 ERROR Database connection failed\\" ... ] >>> parse_log_file(logs) { \\"unique_users\\": 4, \\"common_error\\": \\"Database connection failed\\", \\"average_response_time\\": 196.66666666666666 } ``` Requirements * Ensure proper parsing of each log line. * Handle edge cases such as logs with no errors or no events at all. * Use appropriate data structures for efficient computation. * Provide clear comments explaining your code logic.","solution":"from typing import List, Dict, Any import re from collections import Counter def parse_log_file(log: List[str]) -> Dict[str, Any]: Parses the log file and extracts meaningful information. Args: log (List[str]): A list of strings representing the log data. Returns: Dict[str, Any]: A dictionary with keys \\"unique_users\\", \\"common_error\\", and \\"average_response_time\\". user_set = set() errors = [] response_times = [] for line in log: # Use regex to parse the log line match = re.match(r\\"[(.*?)] (w+) (d+) (INFO|ERROR|WARNING) (.*)\\", line) if match: timestamp, user_id, response_time, event_type, event_details = match.groups() user_set.add(user_id) response_times.append(int(response_time)) if event_type == \\"ERROR\\": errors.append(event_details) unique_users = len(user_set) common_error = None if not errors else Counter(errors).most_common(1)[0][0] average_response_time = sum(response_times) / len(response_times) if response_times else 0 return { \\"unique_users\\": unique_users, \\"common_error\\": common_error, \\"average_response_time\\": average_response_time }"},{"question":"# Median of Running Integers You are tasked with implementing a data structure that efficiently maintains a collection of integers and calculates the median value dynamically as new integers are added. The median is the middle value in a sorted list of integers—if the list length is odd, it is the middle element; if even, it is the average of the two middle elements. Function Signatures ```python class MedianFinder: def __init__(self): pass def add_num(self, num: int) -> None: pass def find_median(self) -> float: pass ``` Input and Output - **Method `__init__`**: - Initializes any data structures needed. - **Method `add_num`**: - `num` (int): The integer to add to the collection. - **Method `find_median`**: - Returns the median value as a float. Constraints - Integers passed to `add_num` are in the range `-10^9 <= num <= 10^9`. - The median calculation should be efficient, with an expected O(log n) time complexity for both adding a number and finding the median using appropriate data structures (e.g., heaps). Performance Requirements - The data structure should handle up to `10^5` integers efficiently. Example ```python mf = MedianFinder() mf.add_num(1) mf.add_num(2) assert mf.find_median() == 1.5 # (1+2)/2 mf.add_num(3) assert mf.find_median() == 2 # middle value of [1, 2, 3] mf.add_num(4) assert mf.find_median() == 2.5 # (2+3)/2 mf.add_num(5) assert mf.find_median() == 3 # middle value of [1, 2, 3, 4, 5] ``` Additional Information - Handle edge cases, such as adding the first number or when all numbers added are the same. - The implementation should be efficient in terms of both time and space. Use appropriate data structures to maintain two halves of the list (e.g., max-heap and min-heap). Implement the `MedianFinder` class and its methods to meet these criteria.","solution":"import heapq class MedianFinder: def __init__(self): Initialize two heaps: - A max-heap to store the smaller half of the numbers. - A min-heap to store the larger half of the numbers. self.small = [] # max-heap (as negative min-heap) self.large = [] # min-heap def add_num(self, num: int) -> None: Add a number to the data structure. # Add number to max-heap (small half) heapq.heappush(self.small, -num) # Ensure the largest number in small half is less than or equal to the smallest number in large half if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) # Balance the heaps sizes if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def find_median(self) -> float: Find the median of the current list of numbers. if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2.0"},{"question":"# Coding Problem: Data Normalization for Machine Learning **Context**: You are working as a data scientist in a tech firm. A common preprocessing step for machine learning algorithms is data normalization, which transforms data to fit within a specific range, commonly [0, 1] or [-1, 1]. We need a function to normalize a given list of numerical data into the range [0, 1] using min-max normalization. **Task**: Implement a function `normalize_data` that normalizes a list of numerical data into the range [0, 1] using the min-max normalization formula: [ text{normalized}_i = frac{x_i - text{min}(X)}{text{max}(X) - text{min}(X)} ] Where: * (x_i) is an element of the list (X) * (text{min}(X)) is the minimum value in the list (X) * (text{max}(X)) is the maximum value in the list (X) # Function Signature ```python def normalize_data(data: List[float]) -> List[float]: pass ``` # Input format * `data`: A list of floats. # Output format * Return a list of floats representing the normalized values in the range [0, 1]. # Constraints * The list `data` will contain at least 2 elements. * All elements in the list are unique. * The list `data` will only contain numerical (float) values. # Performance Requirements * The function must operate in (O(n)) time complexity, where (n) is the length of the list `data`. # Examples ```python assert normalize_data([1, 2, 3, 4, 5]) == [0.0, 0.25, 0.5, 0.75, 1.0] assert normalize_data([10, 20, 30, 40, 50]) == [0.0, 0.25, 0.5, 0.75, 1.0] assert normalize_data([5, 10, 15]) == [0.0, 0.5, 1.0] ``` # Notes * If the list contains any non-numerical value, raise a `ValueError` with the message: \\"Data must contain only numerical values.\\" * If the list has less than 2 elements, raise a `ValueError` with the message: \\"Data must contain at least 2 elements.\\" This question examines basic data manipulation and transformation skills, which are essential for any aspiring data scientist or machine learning engineer and aligns well with the complexity and scope of the existing set.","solution":"from typing import List def normalize_data(data: List[float]) -> List[float]: if len(data) < 2: raise ValueError(\\"Data must contain at least 2 elements.\\") if not all(isinstance(x, (int, float)) for x in data): raise ValueError(\\"Data must contain only numerical values.\\") min_val = min(data) max_val = max(data) if min_val == max_val: raise ValueError(\\"Cannot normalize when all elements are the same.\\") return [(x - min_val) / (max_val - min_val) for x in data]"},{"question":"# Context You are tasked with developing a system to automate the grading of multiple-choice exam answers. Students\' answers will be compared against a provided answer key to compute their scores. # Task Write a function to grade the multiple-choice exams based on the given answer key. Each correct answer will score one point, and there are no deductions for incorrect answers. # Implementation You will have to implement the following function: 1. **`grade_exam(answer_key: list[str], student_answers: list[str]) -> int`**: - Compare the student\'s answers to the answer key and compute the total score. - Example: ```python answer_key = [\'A\', \'C\', \'B\', \'D\'] student_answers = [\'A\', \'C\', \'B\', \'D\'] assert grade_exam(answer_key, student_answers) == 4 ``` # Constraints * Both the answer key and student answers lists will be of the same length. * Each answer will be a single uppercase letter \'A\' to \'D\'. * The function should handle student answers that perfectly match or partially match the answer key. # Input/Output - **Input**: List of characters representing the answer key, list of characters representing the student\'s answers. - **Output**: Integer representing the student\'s total score. # Example Scenario ```python # Example use answer_key = [\'B\', \'A\', \'D\', \'C\'] student_answers = [\'B\', \'B\', \'D\', \'C\'] score = grade_exam(answer_key, student_answers) print(score) # Output should be 3, since the student got three answers correct. ``` Submit your complete solution in a Python file.","solution":"def grade_exam(answer_key, student_answers): Returns the total score of the student based on the answer key. Parameters: answer_key (list of str): The correct answers. student_answers (list of str): The student\'s answers. Returns: int: The total score of the student. return sum(1 for correct, student in zip(answer_key, student_answers) if correct == student)"},{"question":"# Coding Assessment Question: String Reversal while Preserving Word Positions **Context**: Reversing a string typically involves changing the order of characters within the string. However, in this problem, you are required to reverse the order of the words while preserving the positions of spaces within the original string. The provided string contains words and spaces only. # Problem Statement Your task is to implement the function `reverse_preserve_spaces(input_string: str) -> str` that reverses the words in the given string while maintaining the position of spaces. # Function Specification * **Input**: * A string `input_string` where the string consists of words and spaces only. * **Output**: * A string where the words are reversed but the spaces remain in their original positions. * **Constraints**: * The length of `input_string` will be between 1 and 10^5 (inclusive). * Words are sequences of non-space characters separated by spaces. * Your solution should handle spaces properly without altering their positions. * You should raise a `TypeError` if `input_string` is not a string. # Examples ```python >>> reverse_preserve_spaces(\\"hello world\\") \\"world hello\\" >>> reverse_preserve_spaces(\\" quick brown fox \\") \\" fox brown quick \\" >>> reverse_preserve_spaces(\\"a b c\\") \\"c b a\\" >>> reverse_preserve_spaces(\\"singleWord\\") \\"singleWord\\" >>> reverse_preserve_spaces(\\"a\\") \\"a\\" >>> reverse_preserve_spaces(123) Traceback (most recent call last): ... TypeError: input_string must be a string. ``` # Guidelines * Focus on maintaining the positions of spaces while reversing the words. * Ensure that your function handles edge cases such as strings with leading, trailing, or multiple consecutive spaces. * The function should operate efficiently given the input constraint length.","solution":"def reverse_preserve_spaces(input_string: str) -> str: if not isinstance(input_string, str): raise TypeError(\\"input_string must be a string.\\") # Split the input_string by spaces to get the words words = input_string.split() # Reverse the list of words reversed_words = list(reversed(words)) # Create an iterator for the reversed words word_iter = iter(reversed_words) # Rebuild the output string using the original spacing as a template output = [] in_word = False for char in input_string: if char == \' \': output.append(char) in_word = False else: if not in_word: output.append(next(word_iter)) in_word = True return \\"\\".join(output)"},{"question":"# Coding Assessment Question Context You are developing a utility function for handling temperatures in a weather monitoring system. The system should efficiently find the highest and the lowest temperature recorded on any given day. Objective Write a function that processes a list of temperature recordings and returns the highest and the lowest temperatures observed. Requirements 1. Implement the function `temperature_extremes(temperatures: list[int]) -> tuple[int, int]` which takes a list of integer temperatures as input and returns a tuple with two elements: the highest and lowest temperatures from the list. 2. Ensure the function handles cases where the list is empty by raising a `ValueError` with an appropriate error message. 3. Include error handling for non-integer values within the list by raising a `ValueError`. Constraints * Each temperature in the list will be an integer representing degrees Celsius. * If the input list is empty, raise a `ValueError`. * If the input list contains non-integer values, raise a `ValueError`. Examples ```python def temperature_extremes(temperatures: list[int]) -> tuple[int, int]: # Your implementation here pass # Example usage and results assert temperature_extremes([23, 45, -2, 0, 34, 18]) == (45, -2) assert temperature_extremes([0]) == (0, 0) assert temperature_extremes([-5, -3, -10, -1]) == (-1, -10) assert temperature_extremes([]) # should raise ValueError: \\"The temperature list is empty\\" assert temperature_extremes([23, 45.6, -2, 0]) # should raise ValueError: \\"The temperature list contains non-integer values\\" ``` Notes: * The function should iterate through the list of temperatures and track the highest and lowest values. * You should include proper error messages to handle invalid inputs.","solution":"def temperature_extremes(temperatures: list[int]) -> tuple[int, int]: Returns the highest and lowest temperatures from the list. Parameters: temperatures (list[int]): A list of integers representing temperatures in degrees Celsius. Returns: tuple[int, int]: A tuple containing the highest and the lowest temperatures. Raises: ValueError: If the input list is empty or contains non-integer values. if not temperatures: raise ValueError(\\"The temperature list is empty\\") if not all(isinstance(t, int) for t in temperatures): raise ValueError(\\"The temperature list contains non-integer values\\") highest = max(temperatures) lowest = min(temperatures) return (highest, lowest)"},{"question":"# **Unique Characters in a String** Background Understanding the uniqueness of characters in a string is a common programming problem. It helps in various applications such as checking for duplicates in a password, validating puzzle inputs, and more. Task Write a Python function `has_unique_characters(s: str) -> bool` that determines whether a given string contains all unique characters. Details: 1. **Input Format**: A single string `s`. 2. **Output Format**: A boolean indicating whether all characters in the string are unique. Constraints: - The function should raise a `TypeError` if the input is not a string. - Consider all characters, including punctuation, whitespace, and numbers. Examples: ``` has_unique_characters(\\"abcdef\\") # True, all characters are unique has_unique_characters(\\"aabbcc\\") # False, characters are duplicated has_unique_characters(\\"12345\\") # True, all characters are unique has_unique_characters(\\"apple\\") # False, \'p\' is repeated has_unique_characters(\\"\\") # True, an empty string has no repeated characters has_unique_characters(12345) # Raises TypeError, input is not a string ``` Notes: 1. You can use additional data structures like sets to help with the implementation. 2. Perform validation on input to ensure it is a string before proceeding with uniqueness check. 3. Write appropriate test cases to handle various possible edge cases.","solution":"def has_unique_characters(s: str) -> bool: Determines whether a given string contains all unique characters. Args: s (str): The string to be checked. Returns: bool: True if all characters are unique, False otherwise. Raises: TypeError: If the input is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return len(set(s)) == len(s)"},{"question":"# Question: Implement a Function to Sort Employess by Age and Experience You have been asked to implement a function that sorts a list of employees. Each employee is represented as a tuple containing their name, age, and years of experience. The sorting criteria are as follows: 1. Primary criterion: Sort by age in ascending order. 2. Secondary criterion: If two employees have the same age, sort by years of experience in descending order. If two employees have the same age and years of experience, their relative order does not matter. Task: Implement the function `sort_employees(employees: list) -> list` to return the sorted list of employees. # Constraints: - The input list `employees` can have a length of up to 10^5. - Each employee is represented as a tuple: `(name: str, age: int, experience: int)`. - The names of the employees are unique. # Requirements: 1. **Function Signature**: `def sort_employees(employees: list) -> list:` 2. **Input/Output**: - **Input**: A list of tuples `employees`, where each tuple contains a string (employee name), an integer (age), and an integer (experience). - **Output**: The sorted list of employees based on the given criteria. # Example: ```python assert sort_employees([(\'Alice\', 30, 5), (\'Bob\', 25, 10), (\'Charlie\', 30, 10), (\'Dave\', 25, 8)]) == [(\'Bob\', 25, 10), (\'Dave\', 25, 8), (\'Charlie\', 30, 10), (\'Alice\', 30, 5)] assert sort_employees([(\'Eve\', 22, 2), (\'Frank\', 22, 3), (\'Grace\', 35, 10), (\'Heidi\', 35, 9)]) == [(\'Frank\', 22, 3), (\'Eve\', 22, 2), (\'Grace\', 35, 10), (\'Heidi\', 35, 9)] assert sort_employees([(\'Ivy\', 40, 15), (\'Judy\', 40, 15)]) == [(\'Ivy\', 40, 15), (\'Judy\', 40, 15)] assert sort_employees([(\'Ivan\', 28, 2), (\'Oscar\', 28, 5), (\'Nancy\', 20, 12)]) == [(\'Nancy\', 20, 12), (\'Oscar\', 28, 5), (\'Ivan\', 28, 2)] ``` # Performance Note: The implementation should be efficient and handle the average case in O(n log n) time complexity, given the constraints of standard sorting algorithms.","solution":"def sort_employees(employees): Sorts a list of employees first by age (ascending) and then by experience (descending). Parameters: employees (list): A list of tuples, where each tuple contains a string (employee name), an integer (age), and an integer (experience). Returns: list: A sorted list of employees. # Sort by age ascending and then by experience descending return sorted(employees, key=lambda emp: (emp[1], -emp[2]))"},{"question":"# Scenario A software development firm needs a function to help with optimizing a series of calculations involving large numbers. They require an algorithm that can compute the greatest common divisor (GCD) of two non-negative integers efficiently. This function will be used to simplify fraction operations in various applications. # Problem Statement Implement a function `find_gcd` that calculates the greatest common divisor of two given non-negative integers using the Euclidean algorithm. # Function Signature ```python def find_gcd(a: int, b: int) -> int: ``` # Input * Two non-negative integers, `a` and `b`. # Output * An integer representing the greatest common divisor of the two provided integers. # Constraints * The values for `a` and `b` will be in the range [0, 10^9]. * The function should handle the case where both `a` and `b` are zero by returning 0. # Requirements * The solution must be efficient, preferably using the Euclidean algorithm. # Examples ```python assert find_gcd(48, 18) == 6 assert find_gcd(0, 0) == 0 assert find_gcd(7, 3) == 1 assert find_gcd(1000000000, 500000000) == 500000000 assert find_gcd(123456789, 987654321) == 9 ``` # Performance * The function should be able to handle the upper limits of the input range without significant performance degradation.","solution":"def find_gcd(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm. Parameters: a (int): First non-negative integer. b (int): Second non-negative integer. Returns: int: The greatest common divisor of a and b. while b: a, b = b, a % b return a"},{"question":"# Coding Assessment Question Context Having efficient algorithms is crucial in computer science. One of the most common tasks is sorting an array. Now, it\'s time to implement one of the famous sorting algorithms - the Merge Sort. Your goal is to practice implementing the algorithm and ensure its correctness. The Task Write an implementation of the **Merge Sort** algorithm to sort an array of integers in ascending order. Input A list of integers `arr` with length `n` (0 ≤ n ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6 for each element arr[i]). Output A list of integers sorted in ascending order. Performance Requirements - Your implementation should have a time complexity of O(n log n), and the space complexity should also be carefully managed. - Consider the base cases and handle lists with different types of elements. # Implementation Guide 1. Implement the main function `merge_sort(arr: List[int]) -> List[int]` using the Merge Sort algorithm: * Define the base case for recursion when the array is of length 0 or 1. * Split the array into two halves. * Recursively sort the two halves. * Merge the sorted halves. * Return the sorted array. 2. Test your implementation with various edge cases to ensure correctness, including empty arrays and arrays with one element. # Example Usage ```python from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list # Example usage: print(merge_sort([])) # Output: [] print(merge_sort([1])) # Output: [1] print(merge_sort([3, 1, 4, 1, 5, 9, 2, 6])) # Output: [1, 1, 2, 3, 4, 5, 6, 9] ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list # Example usage: # print(merge_sort([])) # Output: [] # print(merge_sort([1])) # Output: [1] # print(merge_sort([3, 1, 4, 1, 5, 9, 2, 6])) # Output: [1, 1, 2, 3, 4, 5, 6, 9]"},{"question":"# Question: Matrix Manipulation Challenge Context: Consider a `Matrix` class to handle various operations on a 2D matrix. The class will support the following functionalities: 1. Query sum of a specific submatrix. 2. Update the value of an element in the matrix. 3. Rotate the matrix clockwise by 90 degrees. 4. Find the transpose of the matrix. Task: Extend the functionality of the existing `Matrix` class with the following new methods: 1. `submatrix_sum(top_left, bottom_right)`: Calculate the sum of the elements within the submatrix specified by the top-left and bottom-right coordinates. 2. `update_value(row, col, new_value)`: Update the element at the specified row and column with the new value. 3. `rotate_90_clockwise()`: Rotate the entire matrix by 90 degrees in the clockwise direction. 4. `transpose()`: Transpose the matrix, flipping it over its diagonal. Implementation Details: - **submatrix_sum(top_left, bottom_right)**: - Input: `top_left` (tuple of coordinates of the top-left cell), `bottom_right` (tuple of coordinates of the bottom-right cell). - Output: Integer representing the sum of elements in the submatrix. - **update_value(row, col, new_value)**: - Input: `row` (row index), `col` (column index), `new_value` (new value for the specified element). - Output: None. - **rotate_90_clockwise()**: - Input: None. - Output: None, but the internal representation of the matrix should be updated. - **transpose()**: - Input: None. - Output: None, but the internal representation of the matrix should be updated. Constraints: - The input matrix will have at most 1000 rows and 1000 columns. - Elements of the matrix are integers. - `top_left` and `bottom_right` will always define a valid submatrix. Example: ```python matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) # Requirements print(matrix.submatrix_sum((0, 0), (1, 1))) # Output: 12 (sum of elements in the submatrix [[1, 2], [4, 5]]) matrix.update_value(0, 0, 10) print(matrix.submatrix_sum((0, 0), (1, 1))) # Output: 21 (sum after updating the top-left element to 10) matrix.rotate_90_clockwise() print(matrix.matrix) # Output: [[7, 4, 10], [8, 5, 2], [9, 6, 3]] matrix.transpose() print(matrix.matrix) # Output: [[7, 8, 9], [4, 5, 6], [10, 2, 3]] ```","solution":"class Matrix: def __init__(self, matrix): self.matrix = matrix def submatrix_sum(self, top_left, bottom_right): row1, col1 = top_left row2, col2 = bottom_right total = 0 for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): total += self.matrix[i][j] return total def update_value(self, row, col, new_value): self.matrix[row][col] = new_value def rotate_90_clockwise(self): self.matrix = [list(reversed(col)) for col in zip(*self.matrix)] def transpose(self): self.matrix = [list(row) for row in zip(*self.matrix)]"},{"question":"# Background In the context of data analysis, filtering data based on various criteria is a common task. One such scenario is filtering a list of student records to identify students who meet specific performance criteria. Each student record contains the student\'s name and their scores in multiple subjects. # Problem Statement You are required to implement a function `filter_students` that takes a list of student records and a threshold score as input and returns a list of names of students whose average score is above the given threshold. # Function Signature ```python def filter_students(records: List[Tuple[str, List[int]]], threshold: float) -> List[str]: pass ``` # Input Format - `records`: A list of tuples where each tuple contains a student\'s name (string) and a list of their scores (integers). - `threshold`: A float representing the score threshold. # Output Format - Returns a list of names of students whose average score is above the threshold. # Constraints - `records` will contain between 1 and 10,000 student records. - Each student\'s name is a non-empty string and unique. - Each list of scores will contain between 1 and 10 integers, each in the range [0, 100]. - `threshold` is in the range [0, 100]. # Performance Requirements - The solution should complete in linear time relative to the number of student records. # Example ```python records = [ (\\"Alice\\", [80, 90, 70]), (\\"Bob\\", [60, 75, 85]), (\\"Charlie\\", [90, 95, 100]) ] threshold = 80.0 print(filter_students(records, threshold)) # Output: [\'Alice\', \'Charlie\'] ``` # Notes - The average score is calculated as the sum of scores divided by the number of scores. - Ensure to handle edge cases such as empty lists of scores gracefully.","solution":"from typing import List, Tuple def filter_students(records: List[Tuple[str, List[int]]], threshold: float) -> List[str]: Filters students whose average score is above the given threshold. :param records: List of tuples where each tuple contains a student\'s name and their scores. :param threshold: A float representing the score threshold. :return: List of names of students whose average score is above the threshold. filtered_students = [] for name, scores in records: if scores: # ensuring there are scores to avoid division by zero average_score = sum(scores) / len(scores) if average_score > threshold: filtered_students.append(name) return filtered_students"},{"question":"# Scenario You have been hired to enhance a simple inventory management system for a small store. The initial implementation allows adding and removing items as well as checking the current stock levels. However, the system lacks some critical features, such as tracking sales, generating summaries, and handling stock alerts. # Objective Improve the given inventory management script by implementing the following features: 1. **Sales Tracking**: Keep track of items sold and update the inventory accordingly. 2. **Sales Summary**: Generate a summary of items sold, including total revenue. 3. **Stock Alerts**: Inform the user when the stock of any item falls below a certain threshold. 4. **Dynamic Pricing**: Adjust the price of items based on demand (items sold). # Instructions 1. Ensure the function `manage_inventory`: * Takes a list of dictionaries representing transactions (`transactions`). * Updates the inventory with sales data, adjusts pricing, and generates a summary. ```python def manage_inventory(transactions): pass ``` 2. Implement the following details: * Track item sales and adjust stock levels. * Generate a sales summary with total revenue and units sold. * Alert when stock levels fall below a specified threshold (e.g., 5 units). * Dynamically adjust pricing based on demand: increase price by 10% when more than 10 units of an item are sold in a day. # Expected Input and Output - **Input**: A list of transaction dictionaries (`[{\\"item\\": \\"apple\\", \\"quantity\\": 5, \\"price\\": 1.0, \\"transaction_type\\": \\"sale\\"}, ...]`) - **Output**: A dictionary summarizing total sales and updated inventory. # Constraints - Handle up to 100 transactions in a given input list. - Assume initial stock levels and pricing are pre-defined within the script. # Example Usage ```python if __name__ == \\"__main__\\": transactions = [ {\\"item\\": \\"apple\\", \\"quantity\\": 5, \\"price\\": 1.0, \\"transaction_type\\": \\"sale\\"}, {\\"item\\": \\"banana\\", \\"quantity\\": 2, \\"price\\": 0.5, \\"transaction_type\\": \\"sale\\"}, {\\"item\\": \\"apple\\", \\"quantity\\": 3, \\"price\\": 1.0, \\"transaction_type\\": \\"sale\\"}, {\\"item\\": \\"banana\\", \\"quantity\\": 3, \\"price\\": 0.5, \\"transaction_type\\": \\"sale\\"} ] summary = manage_inventory(transactions) print(summary) ``` # Performance Requirements - Efficiently update inventory and handle high volumes of transactions. - Handle edge cases, such as attempts to sell items not in stock or exceeding available quantities. # Additional Notes - Pre-defined initial stock levels and pricing should be implemented within the script for simplicity. - Include detailed and user-friendly messages for stock alerts and summary reports.","solution":"def manage_inventory(transactions): inventory = { \\"apple\\": {\\"stock\\": 20, \\"price\\": 1.0, \\"units_sold\\": 0}, \\"banana\\": {\\"stock\\": 20, \\"price\\": 0.5, \\"units_sold\\": 0} } stock_alert_threshold = 5 total_revenue = 0.0 for transaction in transactions: item = transaction[\\"item\\"] quantity = transaction[\\"quantity\\"] transaction_type = transaction[\\"transaction_type\\"] if transaction_type == \\"sale\\": if item in inventory and inventory[item][\\"stock\\"] >= quantity: inventory[item][\\"stock\\"] -= quantity inventory[item][\\"units_sold\\"] += quantity total_revenue += quantity * inventory[item][\\"price\\"] # Dynamic pricing based on demand if inventory[item][\\"units_sold\\"] > 10: inventory[item][\\"price\\"] *= 1.10 # Increase price by 10% # Stock alert if inventory[item][\\"stock\\"] < stock_alert_threshold: print(f\\"Alert: Stock of {item} is below {stock_alert_threshold} units.\\") else: print(f\\"Error: Not enough stock for {item} or item not found.\\") else: print(f\\"Error: Unsupported transaction type {transaction_type}\\") sales_summary = { \\"total_revenue\\": total_revenue, \\"items_sold\\": {item: info[\\"units_sold\\"] for item, info in inventory.items()}, \\"current_stock\\": {item: info[\\"stock\\"] for item, info in inventory.items()} } return sales_summary"},{"question":"Question You are given a binary tree where each node contains an integer value. Your task is to implement a function `sum_of_left_leaves` that calculates the sum of all left leaves in the tree. A leaf is a node with no children, and it is considered a left leaf if it is a left child of its parent. # Function Signature ```python def sum_of_left_leaves(root: Optional[TreeNode]) -> int: ``` # Parameters - `root`: The root node of the binary tree. # Returns - An integer representing the sum of all left leaves in the binary tree. # Constraints - The number of nodes in the tree will be in the range [0, 1000]. - -1000 ≤ Node.val ≤ 1000 # Edge Cases to Consider - The tree could be empty. - The tree could have only one node, which is the root. - All nodes could be only left children or only right children. # Example Usage ```python # Example 1: # Given binary tree [3, 9, 20, None, None, 15, 7], # 3 # / # 9 20 # / # 15 7 # The left leaves are 9 and 15. root1 = TreeNode(3) root1.left = TreeNode(9) root1.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(sum_of_left_leaves(root1)) # Should output: 24 # Example 2: # Given binary tree [1], # 1 # The tree has no left leaves. root2 = TreeNode(1) print(sum_of_left_leaves(root2)) # Should output: 0 ``` # Implementation Details - You may use a helper method to facilitate the traversal of the tree and identification of left leaves. - Consider both depth-first and breadth-first traversal methods, although a recursive or iterative depth-first approach may be simpler.","solution":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root: Optional[TreeNode]) -> int: if not root: return 0 def is_leaf(node: TreeNode) -> bool: return node is not None and node.left is None and node.right is None def dfs(node: TreeNode, is_left: bool) -> int: if not node: return 0 if is_leaf(node) and is_left: return node.val return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False)"},{"question":"# Problem Statement Implement a function that simulates the execution of a sequence of operations on a stack data structure. The operations consist of pushing elements onto the stack, popping elements from the stack, and retrieving the maximum element in the stack at any given time. Your task is to ensure that the retrieval of the maximum element is optimized for efficiency. # Specifications * **Function**: `execute_operations(operations: list[str]) -> list[int]` * **Input**: A list of strings `operations`, where each string represents a stack operation: - `\\"push x\\"`: Push integer `x` onto the stack. - `\\"pop\\"`: Pop the top element from the stack. - `\\"max\\"`: Retrieve the maximum element currently in the stack. * **Output**: A list of integers representing the results of `\\"max\\"` operations in the order they were requested. # Constraints * The number of operations will not exceed `10^5`. * The integers `x` in the operations will be within the range `1` to `10^9`. * The stack will always be manipulated with valid operations; specifically, `\\"pop\\"` and `\\"max\\"` operations will never be invoked on an empty stack. # Example ```python # Given the following operations operations = [\\"push 5\\", \\"push 1\\", \\"push 10\\", \\"max\\", \\"pop\\", \\"max\\", \\"pop\\", \\"max\\"] # After executing the function results = execute_operations(operations) # results should be [10, 5, 5] ``` # Implementation Implement the `execute_operations` function to handle the sequence of operations efficiently. Aim for O(1) time complexity for each `max` operation.","solution":"def execute_operations(operations): stack = [] max_stack = [] result = [] for op in operations: if op.startswith(\\"push\\"): _, value = op.split() value = int(value) stack.append(value) if not max_stack or value >= max_stack[-1]: max_stack.append(value) elif op == \\"pop\\": if stack: value = stack.pop() if value == max_stack[-1]: max_stack.pop() elif op == \\"max\\": if max_stack: result.append(max_stack[-1]) return result"},{"question":"# Coding Assessment Question Background: You are developing a text processing tool for an editor. The tool analyzes articles and provides various metrics. One specific feature to implement is counting the frequency of each word in the text while ignoring case sensitivity and punctuation. Task: You need to implement a function `word_frequency(text: str) -> dict` that takes a string containing the article\'s text as input and returns a dictionary with each unique word as the key and its frequency as the value. The function should follow these steps: 1. Remove punctuation from the text. 2. Convert all words to lowercase. 3. Split the text into words. 4. Count the frequency of each word. Input: - `text` (str): a string containing the article text. Output: - Returns a dictionary where keys are unique words and values are the frequency of those words in the text. Constraints: - The input text can be of any length but will not exceed 10⁶ characters. - Assume that words are separated by whitespace and punctuation. Performance Requirements: - The function should operate efficiently, even for large texts. Example: Given the text `\\"Hello, hello! How are you? How have you been?\\"`, the function should return: ```python { \'hello\': 2, \'how\': 2, \'are\': 1, \'you\': 2, \'have\': 1, \'been\': 1 } ``` Function Signature: ```python def word_frequency(text: str) -> dict: pass ```","solution":"import string def word_frequency(text: str) -> dict: Returns the frequency of each word in the given text. Punctuation is removed, and case is ignored (all words are treated as lowercase). # Remove punctuation text = text.translate(str.maketrans(\'\', \'\', string.punctuation)) # Convert text to lowercase text = text.lower() # Split text into words words = text.split() # Count word frequencies frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"Problem Statement: You need to design a data structure for a dynamic priority queue. This priority queue will support integer priorities and allow for changes to the priorities of existing elements. # Features to Implement: 1. **Insert Element**: - Method: `insert(element: Any, priority: int) -> None` - Description: Adds an element with a specific priority to the priority queue. If the element already exists, raise a `ValueError`. 2. **Increase Priority**: - Method: `increase_priority(element: Any, priority: int) -> None` - Description: Increases the priority of the given element. If the element does not exist or the new priority is not greater than the current priority, raise a `ValueError`. 3. **Decrease Priority**: - Method: `decrease_priority(element: Any, priority: int) -> None` - Description: Decreases the priority of the given element. If the element does not exist or the new priority is not lesser than the current priority, raise a `ValueError`. 4. **Extract Max**: - Method: `extract_max() -> Any` - Description: Removes and returns the element with the highest priority. If the priority queue is empty, raise an `IndexError`. 5. **Peek Max**: - Method: `peek_max() -> Any` - Description: Returns the element with the highest priority without removing it. If the priority queue is empty, raise an `IndexError`. 6. **Contains Element**: - Method: `contains(element: Any) -> bool` - Description: Returns `True` if the element is present in the priority queue, `False` otherwise. # Constraints: - The priority queue must be implemented efficiently, especially for the operations involving priority changes. - Duplicate priorities are allowed, but each element must be unique. - The elements within the priority queue can be of any data type. # Example: ```python # Example Usage pq = DynamicPriorityQueue() pq.insert(\\"task1\\", priority=3) pq.insert(\\"task2\\", priority=5) pq.insert(\\"task3\\", priority=1) assert pq.peek_max() == \\"task2\\" pq.increase_priority(\\"task3\\", priority=6) assert pq.peek_max() == \\"task3\\" pq.decrease_priority(\\"task3\\", priority=2) assert pq.peek_max() == \\"task2\\" pq.extract_max() assert pq.peek_max() == \\"task1\\" assert pq.contains(\\"task2\\") == False print(\\"All tests passed.\\") ``` Implement the `DynamicPriorityQueue` class following the above description and ensure your implementation passes all necessary edge cases.","solution":"import heapq class DynamicPriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} # mapping of elements to entries self.REMOVED = \'<removed-element>\' # placeholder for a removed element self.counter = 0 # unique sequence count for tie-breaking def insert(self, element, priority): Adds an element with a specific priority to the priority queue. If the element already exists, raise a ValueError. if element in self.entry_finder: raise ValueError(\\"Element already exists in the priority queue.\\") count = self.counter entry = [-priority, count, element] # use negative priority to simulate max-heap in heapq self.entry_finder[element] = entry heapq.heappush(self.heap, entry) self.counter += 1 def increase_priority(self, element, priority): Increases the priority of the given element. If element does not exist or the new priority is not greater than current priority, raise a ValueError. if element not in self.entry_finder: raise ValueError(\\"Element not found in the priority queue.\\") current_entry = self.entry_finder[element] current_priority = -current_entry[0] if priority <= current_priority: raise ValueError(\\"New priority must be greater than the current priority.\\") self._remove_element(element) self.insert(element, priority) def decrease_priority(self, element, priority): Decreases the priority of the given element. If element does not exist or the new priority is not lesser than current priority, raise a ValueError. if element not in self.entry_finder: raise ValueError(\\"Element not found in the priority queue.\\") current_entry = self.entry_finder[element] current_priority = -current_entry[0] if priority >= current_priority: raise ValueError(\\"New priority must be less than the current priority.\\") self._remove_element(element) self.insert(element, priority) def extract_max(self): Removes and returns the element with the highest priority. If the priority queue is empty, raise an IndexError. while self.heap: priority, count, element = heapq.heappop(self.heap) if element is not self.REMOVED: del self.entry_finder[element] return element raise IndexError(\\"The priority queue is empty.\\") def peek_max(self): Returns the element with the highest priority without removing it. If the priority queue is empty, raise an IndexError. while self.heap: priority, count, element = self.heap[0] if element is not self.REMOVED: return element heapq.heappop(self.heap) raise IndexError(\\"The priority queue is empty.\\") def contains(self, element): Returns True if the element is present in the priority queue, False otherwise. return element in self.entry_finder and self.entry_finder[element][2] is not self.REMOVED def _remove_element(self, element): Marks an existing element as REMOVED. entry = self.entry_finder.pop(element) entry[2] = self.REMOVED"},{"question":"# Coding Assessment Question Problem Statement You are given a string `s` consisting of lowercase and uppercase alphabets. Your task is to write a function that generates all possible permutations of the given string where the case of each character can either be uppercase or lowercase. Function Definition You need to implement the following function: ```python def generate_case_permutations(s: str) -> list[str]: Generates all possible permutations of the given string where each character can be either uppercase or lowercase. :param s: A string consisting of lowercase and uppercase alphabets. :return: A list containing all case permutations of the input string. pass ``` Input - A string `s` of length `n`, where `1 <= n <= 12`, containing only alphabetic characters (both lowercase and uppercase). Output - A list of strings, where each string is a permutation of the input string with different combinations of character cases. Example ```python # Example 1 s = \\"a1b2\\" print(generate_case_permutations(s)) # Output: [\'a1b2\', \'a1B2\', \'A1b2\', \'A1B2\'] # Example 2 s = \\"3z4\\" print(generate_case_permutations(s)) # Output: [\'3z4\', \'3Z4\'] # Example 3 s = \\"12345\\" print(generate_case_permutations(s)) # Output: [\'12345\'] ``` Constraints - The input string `s` will have a length between 1 and 12. - The string will contain only alphabets and/or digits. Notes - Digits in the input string should remain unchanged in the output. - Your function should be case-sensitive and provide all possible permutations of the string resulting from changing each alphabetic character to either lowercase or uppercase. Edge Cases - Handle cases where the string includes digits, but those digits should remain unchanged. - When the string contains a mixture of numeric and alphabetic characters, manage the alterations appropriately based on the character type. Performance Requirements - The time complexity of your solution should be O(2^n), where n is the number of alphabetic characters in the string. - The space complexity should be managed within acceptable limits given the constraints.","solution":"from itertools import product def generate_case_permutations(s: str) -> list[str]: Generates all possible permutations of the given string where each character can be either uppercase or lowercase. :param s: A string consisting of lowercase and uppercase alphabets. :return: A list containing all case permutations of the input string. cases = [(char.lower(), char.upper()) if char.isalpha() else (char,) for char in s] return [\'\'.join(variation) for variation in product(*cases)]"},{"question":"# Problem Statement You are given a list of integers `nums`. Your task is to write a function `find_second_largest(nums: List[int]) -> int` that returns the second largest number in the list. If no such number exists, return `None`. # Input Format - A list of integers `nums` (0 ≤ `len(nums)` ≤ 10^5, -10^9 ≤ `nums[i]` ≤ 10^9). # Output Format - An integer representing the second largest number in the list, or `None` if no such number exists. # Constraints - Consider edge cases where the list has fewer than two unique elements. - The function should handle lists with negative numbers and duplicates appropriately. # Performance Requirements - Your solution should ideally run in linear time, O(n), where n is the length of the list. # Example ```python >>> find_second_largest([6, 3, 8, 5, 2]) 6 >>> find_second_largest([4, 4, 4]) None >>> find_second_largest([10]) None ``` # Analysis Analyze the given problem considering the need to identify unique elements. A single pass solution to keep track of the largest and the second-largest numbers efficiently is preferred. # Constraints & Edge Cases 1. Handle lists with all identical values. 2. Handle empty lists or lists with a single element. 3. Consider the impact of both very large and very small integers on performance and correctness. Implement the function `find_second_largest` below: ```python from typing import List, Optional def find_second_largest(nums: List[int]) -> Optional[int]: if len(nums) < 2: return None largest = second_largest = float(\'-inf\') for num in nums: if num > largest: second_largest, largest = largest, num elif largest > num > second_largest: second_largest = num return second_largest if second_largest != float(\'-inf\') else None # You may write your own test cases to validate your solution if __name__ == \\"__main__\\": print(find_second_largest([6, 3, 8, 5, 2])) # Should output 6 print(find_second_largest([4, 4, 4])) # Should output None print(find_second_largest([10])) # Should output None ```","solution":"from typing import List, Optional def find_second_largest(nums: List[int]) -> Optional[int]: if len(nums) < 2: return None largest = second_largest = float(\'-inf\') for num in nums: if num > largest: second_largest, largest = largest, num elif largest > num > second_largest: second_largest = num return second_largest if second_largest != float(\'-inf\') else None"},{"question":"# Customer Segmentation with K-Means You are provided with a partially implemented `KMeans` class in Python for customer segmentation. Your task is to complete the implementation of the `KMeans` algorithm to cluster customers based on their features. 1. **Implement the `fit` method** to compute the centroids of the clusters using the K-means clustering algorithm. 2. **Implement the `predict` method** to assign new data points to the nearest cluster centroids determined during the fit. 3. **Handle edge cases** like empty clusters or invalid initial centroids. # Input * A numpy array `X` of shape `(n_samples, n_features)` representing the training data. * An integer `k` representing the number of clusters. * A numpy array `new_data` of shape `(m_samples, n_features)` representing new data points for which you need to predict the closest clusters. # Output * For the `fit` method: No output (it should just update the internal state of the `KMeans` object with the centroids). * For the `predict` method: Return a numpy array of shape `(m_samples,)` with the cluster index (from `0` to `k-1`) for each new data point. # Constraints * The number of clusters `k` must be a positive integer. * Ensure efficient computation for large datasets (e.g., using vectorized operations where possible). # Example ```python # Define training data X = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) # Initialize and train the KMeans model kmeans = KMeans(k=3) kmeans.fit(X) # Predict the cluster for a new data point new_data = np.array([ [1.2, 1.9], [2.0, 10.0] ]) predictions = kmeans.predict(new_data) print(predictions) # Expected output: array([0, 2]) ``` # Notes * Ensure your implementation converges to a stable cluster configuration. * Use the Euclidean distance to measure proximity of data points to cluster centroids. * Include appropriate error handling for invalid parameters and edge cases. The new question retains the style, complexity, and scope of the existing set while introducing a different algorithm (K-means) for clustering, which is a related domain in machine learning.","solution":"import numpy as np class KMeans: def __init__(self, k, max_iters=100): self.k = k self.max_iters = max_iters self.centroids = None def fit(self, X): if self.k <= 0: raise ValueError(\\"Number of clusters must be a positive integer.\\") if X.shape[0] < self.k: raise ValueError(\\"Number of clusters cannot exceed the number of data points.\\") # Randomly initialize the centroids by selecting k unique points from the dataset np.random.seed(42) # For reproducible results initial_indices = np.random.choice(X.shape[0], self.k, replace=False) self.centroids = X[initial_indices] for _ in range(self.max_iters): # Assign each sample to the nearest centroid distances = self._compute_distances(X, self.centroids) labels = np.argmin(distances, axis=1) # Compute new centroids from the means of the samples assigned to each cluster new_centroids = np.array([X[labels == i].mean(axis=0) for i in range(self.k)]) # If the centroids do not change, break out of the loop (convergence) if np.allclose(self.centroids, new_centroids): break self.centroids = new_centroids def predict(self, new_data): if self.centroids is None: raise ValueError(\\"Model has not been fitted yet.\\") distances = self._compute_distances(new_data, self.centroids) return np.argmin(distances, axis=1) def _compute_distances(self, X, centroids): # Calculate the Euclidean distance between each point and each centroid distances = np.zeros((X.shape[0], self.k)) for i, centroid in enumerate(centroids): distances[:, i] = np.linalg.norm(X - centroid, axis=1) return distances"},{"question":"Breadth-First Search for Shortest Path in Grid # Context: You are given a 2D grid representing a map where \\"1\\" is a passable path and \\"0\\" is an impassable obstacle. Your task is to implement a function that uses the Breadth-First Search (BFS) algorithm to find the shortest path from a given starting point to a destination point. The movement is allowed in four directions: up, down, left, and right. # Task: Implement the `shortest_path` function that takes the following parameters: 1. A 2D list `grid` representing the map. 2. A tuple `start` representing the starting coordinates (row, column). 3. A tuple `end` representing the destination coordinates (row, column). The function should return the length of the shortest path. If there is no valid path, return -1. # Function Signature: ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: ``` # Constraints: 1. The grid will have a minimum size of 2x2 and a maximum size of 100x100. 2. The grid elements will be either 0 or 1. 3. The `start` and `end` points will always contain a 1. 4. The movement in the grid is limited to four directions: up, down, left, and right. # Example: ```python grid = [ [1, 0, 1, 1, 1], [1, 1, 0, 0, 1], [0, 1, 1, 1, 1], [1, 0, 0, 1, 0], [1, 1, 1, 1, 1] ] start = (0, 0) end = (4, 4) print(shortest_path(grid, start, end)) # Output: 8 ``` # Additional Information: - You are encouraged to pay attention to proper boundary checks. - Handling of visited nodes is crucial to avoid infinite loops. - Ensure that your implementation efficiently handles the maximum grid size.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Uses BFS to find the shortest path from start to end in a given grid. :param grid: List[List[int]] - The 2D grid of passable and impassable paths. :param start: Tuple[int, int] - Starting coordinates (row, column). :param end: Tuple[int, int] - Destination coordinates (row, column). :return: int - The length of the shortest path, or -1 if no path exists. if start == end: return 0 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(start, 0)]) # (position, distance) visited = set() visited.add(start) while queue: (row, col), dist = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1: new_position = (new_row, new_col) if new_position == end: return dist + 1 if new_position not in visited: visited.add(new_position) queue.append((new_position, dist + 1)) return -1"},{"question":"# Dictionary Query Optimization In this task, you need to optimize the process of querying a dictionary for multiple keys. You are provided with a list of dictionaries and a list of keys, and your task is to efficiently extract the values corresponding to those keys from each dictionary. Function to Implement Implement a new method, `query_dicts()`, that takes in a list of dictionaries and a list of keys, and returns a list of lists with the values for the specified keys in the same order as the input dictionaries. Input - A list of dictionaries, `dicts`, where each dictionary contains key-value pairs of string-type keys and integer-type values. - A list of strings, `keys`, representing the keys you need to query in each dictionary. Output - A list of lists, where each inner list contains the values corresponding to the input keys from the respective dictionary. Constraints - `1 <= len(dicts) <= 10^4` - `1 <= len(keys) <= 10^2` - Each dictionary in `dicts` will have at most 10^3 entries. Example ```python dicts = [ {\\"apple\\": 1, \\"banana\\": 2, \\"orange\\": 3}, {\\"apple\\": 4, \\"banana\\": 5, \\"grape\\": 6}, {\\"banana\\": 7, \\"cherry\\": 8}, ] keys = [\\"banana\\", \\"orange\\"] result = query_dicts(dicts, keys) print(result) # Example output: [[2, 3], [5, None], [7, None]] ``` Note - If a key is not present in a dictionary, the value for that key should be `None`. - Ensure the function handles edge cases like empty dictionary list and queries with keys not present in any dictionary. - The order of the values in the output for each dictionary should match the order of the input keys.","solution":"def query_dicts(dicts, keys): Given a list of dictionaries and a list of keys, return a list of lists containing the values corresponding to those keys from each dictionary. Parameters: dicts (list): List of dictionaries with string keys and integer values. keys (list): List of keys to query from each dictionary. Returns: list: List of lists with values for specified keys from each dictionary. result = [] for dictionary in dicts: values = [] for key in keys: values.append(dictionary.get(key)) result.append(values) return result"},{"question":"# Pascal\'s Triangle Row Generator Problem Statement: Pascal\'s Triangle is an infinite triangular array of the binomial coefficients. Your task is to implement a function that generates the k-th row of Pascal\'s Triangle. Input: - A single integer `k` (0 <= k <= 30). Output: - A list containing the elements of the k-th row of Pascal\'s Triangle. Example: ```python generate_pascals_row(0) # Output: [1] generate_pascals_row(3) # Output: [1, 3, 3, 1] generate_pascals_row(5) # Output: [1, 5, 10, 10, 5, 1] ``` Constraints: - Focus on minimizing the time and space complexity of your solution. - You may use combinatorial properties directly to compute the coefficients. Implementation Requirements: - Avoid unnecessary calculations or storage. Starter Code: ```python from math import comb def generate_pascals_row(k: int) -> list: Generate the k-th row of Pascal\'s Triangle. :param k: int: the index of the row to generate :return: list: the k-th row of Pascal\'s Triangle return [comb(k, i) for i in range(k + 1)] # Example usage: if __name__ == \\"__main__\\": k = int(input(\\"Enter row index k: \\").strip()) result = generate_pascals_row(k) print(f\\"The {k}-th row of Pascal\'s Triangle is: {result}\\") ```","solution":"from math import comb def generate_pascals_row(k: int) -> list: Generate the k-th row of Pascal\'s Triangle. :param k: int: the index of the row to generate :return: list: the k-th row of Pascal\'s Triangle return [comb(k, i) for i in range(k + 1)]"},{"question":"You are tasked with organizing a social event where guests can attend various presentations. Each presentation has a fixed start and end time. Your job is to determine the maximum number of presentations that one guest can attend without any overlaps. Write a function `max_presentations(presentations: List[Tuple[int, int]]) -> int` that computes the maximum number of presentations a single guest can attend from a list of presentations given their start and end times. # Input: * A list of tuples, `presentations`, where each tuple contains two integers `(start, end)`. `start` represents the start time and `end` represents the end time of a presentation. # Output: * An integer representing the maximum number of presentations that can be attended by one guest without any overlaps. # Constraints: * The number of presentations will be between 1 and 100 inclusive. * The start and end times of the presentations will be between 0 and 1000 inclusive. * The start and end times are in whole hours. # Requirements: * Optimize the function to handle the constraints efficiently. * Implement a sorting-based greedy algorithm to find the optimal solution. # Example: ```python assert max_presentations([(1, 4), (2, 3), (3, 5), (6, 8), (4, 7)]) == 3 assert max_presentations([(0, 2), (1, 3), (3, 5), (5, 7), (6, 8)]) == 4 assert max_presentations([(5, 6), (1, 2), (3, 4)]) == 3 ``` # Notes: * This problem requires understanding of greedy algorithms and the ability to use sorting for optimal scheduling without overlaps. * Ensure to handle scenarios where presentations have the same start and end times carefully.","solution":"from typing import List, Tuple def max_presentations(presentations: List[Tuple[int, int]]) -> int: Returns the maximum number of presentations that can be attended by a single guest without overlaps. # Sort presentations by their end time presentations.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in presentations: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"**[Question 2]**: You are given a function `fibonacci` that takes an integer `n` and returns the n-th Fibonacci number using dynamic programming. Optimize this implementation: ```python def fibonacci(n: int) -> int: if n <= 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n] ``` # Task Given the above implementation of the Fibonacci sequence using dynamic programming, re-implement the function to optimize its space complexity to O(1) while maintaining the time complexity of O(n). **Function Signature**: ```python def optimized_fibonacci(n: int) -> int: pass ``` **Input**: - `n`: an integer representing the position in the Fibonacci sequence (0 ≤ n ≤ 10^5). **Output**: - The n-th Fibonacci number. **Constraints**: - The result for the 10^5-th Fibonacci number will not exceed the limits of a 64-bit integer. # Example ```python print(optimized_fibonacci(0)) # Output: 0 print(optimized_fibonacci(1)) # Output: 1 print(optimized_fibonacci(10)) # Output: 55 print(optimized_fibonacci(50)) # Output: 12586269025 ``` # Explanation In the given example: - `optimized_fibonacci(0)` should return 0 as the first Fibonacci number is 0. - `optimized_fibonacci(1)` should return 1 as the second Fibonacci number is 1. - `optimized_fibonacci(10)` should return 55 as it\'s the 10th Fibonacci number. - `optimized_fibonacci(50)` should return 12586269025 as it\'s the 50th Fibonacci number.","solution":"def optimized_fibonacci(n: int) -> int: Returns the n-th Fibonacci number with optimized space complexity of O(1). if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"**Task: Implement a Roman to Integer Converter** **Objective**: Write a Python function `roman_to_integer` that converts a given Roman numeral string into its integer representation. # Function Signature ```python def roman_to_integer(roman_str: str) -> int: ``` # Input * A string `roman_str` representing a Roman numeral. The input may include leading and trailing spaces. # Output * An integer representing the decimal equivalent of the input Roman numeral string. # Constraints * The input string should only contain valid Roman numeral characters (\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\') and optionally spaces. * If the input string is empty or contains invalid characters, the function should raise a `ValueError`. # Roman Numeral Values |Symbol|Value| |------|-----| |I|1| |V|5| |X|10| |L|50| |C|100| |D|500| |M|1000| # Examples ```python >>> roman_to_integer(\'III\') 3 >>> roman_to_integer(\' IV \') 4 >>> roman_to_integer(\'IX\') 9 >>> roman_to_integer(\'MCMXCIV\') 1994 >>> roman_to_integer(\'\') Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> roman_to_integer(\'Z\') Traceback (most recent call last): ... ValueError: Invalid Roman numeral character was passed to the function ``` # Instructions - You are required to implement the `roman_to_integer` function to handle the conversion without using any external libraries. - Ensure the function handles all edge cases such as leading/trailing spaces, empty input, and invalid characters according to the above examples. - Implement a solution that respects the subtractive combination notation in Roman numerals (e.g., \'IV\' is 4, \'IX\' is 9). - Optimize for readability and maintainability of the code.","solution":"def roman_to_integer(roman_str: str) -> int: Converts a Roman numeral string to its integer representation. Args: roman_str (str): The Roman numeral string containing valid characters (\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\') and leading/trailing spaces. Returns: int: The integer representation of the Roman numeral string. Raises: ValueError: If the input string is empty or contains invalid characters. # Helper dictionary to map Roman numerals to their integer values roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Strip leading and trailing spaces roman_str = roman_str.strip() # Check for empty input if not roman_str: raise ValueError(\\"Empty string was passed to the function\\") # Initialize the total sum total = 0 prev_value = 0 for char in roman_str: if char not in roman_to_int: raise ValueError(\\"Invalid Roman numeral character was passed to the function\\") current_value = roman_to_int[char] # Subtractive combination notation if current_value > prev_value: total += current_value - 2 * prev_value else: total += current_value prev_value = current_value return total"},{"question":"# Problem Statement Design and implement a class `Circle` that represents a circle in a 2D space. This class should include the following features: 1. **Initialization**: A circle is initialized with a center point and a radius. 2. **Area Calculation**: Implement a method to calculate the area of the circle. 3. **Circumference Calculation**: Implement a method to calculate the circumference of the circle. 4. **Error Handling**: Ensure that invalid configurations (such as negative or zero radius values) are caught and appropriate errors are raised. # Implementation Details - Create a `Circle` class with the following methods: - `__init__(self, center: Tuple[int, int], radius: float)`: Initializes the circle with a center point and a positive radius. - `area(self) -> float`: Computes and returns the area of the circle. - `circumference(self) -> float`: Computes and returns the circumference of the circle. # Input & Output Formats - **Input**: - The circle is initialized with a center point `(x, y)` and a radius. - Example: `Circle((0, 0), 5)` - **Output**: - `area()` method should return a float representing the area of the circle. - `circumference()` method should return a float representing the circumference of the circle. # Constraints - Center coordinates are integers. - Radius must be a positive numeric value. # Example ```python c = Circle((0, 0), 5) print(c.area()) # Expected output: 78.53981633974483 (π * 5^2) print(c.circumference()) # Expected output: 31.41592653589793 (2 * π * 5) c_invalid = Circle((0, 0), -5) # Should raise ValueError: Invalid radius for a circle. ``` # Performance Requirements - Ensure the implementation is efficient in calculating area and circumference. - Raise appropriate errors for invalid input, such as non-positive radius values. ---","solution":"import math from typing import Tuple class Circle: def __init__(self, center: Tuple[int, int], radius: float): if radius <= 0: raise ValueError(\\"Radius must be positive.\\") self.center = center self.radius = radius def area(self) -> float: return math.pi * self.radius ** 2 def circumference(self) -> float: return 2 * math.pi * self.radius"},{"question":"# Data Transformation for Reporting You are tasked with building a function to transform raw sales data into a summary report suitable for management analysis. Objective: Create a function `transform_sales_data` that: * Reads a log of raw sales transactions. * Calculates the total sales, average sales per transaction, and the number of transactions. * Formats the output in a dictionary with specified keys. Function Signature: ```python def transform_sales_data(sales_log: list) -> dict: Processes raw sales data and generates a summary report. Args: - sales_log: list: A list of sales transactions where each transaction is represented as a dictionary with at least \'amount\' key. Returns: - dict: A dictionary containing the total sales, average sales, and transaction count. ``` Input: * `sales_log` (list): A list of dictionaries, where each dictionary contains at least the key `amount` representing the sales amount. Output: * A dictionary with three keys: - `\'total_sales\'` (float): The sum of all sales amounts. - `\'average_sales\'` (float): The average sales amount per transaction. - `\'transaction_count\'` (int): The total number of transactions. Constraints: * The list will have at least one transaction. * Each transaction dictionary will have an `amount` key with a numeric value (int or float). Example Usage: ```python sales_log = [ {\'amount\': 100.0, \'timestamp\': \'2023-01-01 10:00:00\'}, {\'amount\': 150.5, \'timestamp\': \'2023-01-01 10:10:00\'}, {\'amount\': 200.0, \'timestamp\': \'2023-01-01 10:30:00\'}, ] report = transform_sales_data(sales_log) # Expected output: # { # \'total_sales\': 450.5, # \'average_sales\': 150.17, # \'transaction_count\': 3 # } print(report) ``` # Additional Notes: - Ensure that the average sales are rounded to two decimal places. - Handle cases where sales amounts are present but other data in the dictionary might be missing.","solution":"def transform_sales_data(sales_log: list) -> dict: Processes raw sales data and generates a summary report. Args: - sales_log: list: A list of sales transactions where each transaction is represented as a dictionary with at least \'amount\' key. Returns: - dict: A dictionary containing the total sales, average sales, and transaction count. total_sales = sum(transaction[\'amount\'] for transaction in sales_log) transaction_count = len(sales_log) average_sales = round(total_sales / transaction_count, 2) return { \'total_sales\': total_sales, \'average_sales\': average_sales, \'transaction_count\': transaction_count }"},{"question":"# Coding Assessment Question You are assigned the task of developing a function to help analyze sales data. The goal is to generate a summary report of the top-selling products over a specified period, considering certain constraints. # Task Write a function `top_selling_products(sales_data: List[Dict[str, Any]], top_n: int, start_date: str, end_date: str) -> List[str]` that: 1. Filters the given sales data to only include transactions within the specified date range (`start_date` to `end_date`). 2. Aggregates the total sales quantity for each unique product. 3. Sorts the products by their total quantity sold in descending order and returns the top `top_n` products. # Constraints - Dates are provided in the format `YYYY-MM-DD`. - The sales quantity for a product is always a non-negative integer. - If there are ties in the sales quantity, resolve them alphabetically by product name. # Input - `sales_data` (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents a sales transaction with keys `date` (str), `product` (str), and `quantity` (int). - `top_n` (int): The number of top-selling products to return. - `start_date` (str): The start date for filtering sales data (inclusive). - `end_date` (str): The end date for filtering sales data (inclusive). # Output - Returns a list of strings representing the names of the top-selling products. # Example ```python sales_data = [ {\\"date\\": \\"2023-01-01\\", \\"product\\": \\"Product A\\", \\"quantity\\": 10}, {\\"date\\": \\"2023-01-02\\", \\"product\\": \\"Product B\\", \\"quantity\\": 5}, {\\"date\\": \\"2023-01-03\\", \\"product\\": \\"Product A\\", \\"quantity\\": 3}, {\\"date\\": \\"2023-01-05\\", \\"product\\": \\"Product C\\", \\"quantity\\": 8}, {\\"date\\": \\"2023-01-07\\", \\"product\\": \\"Product B\\", \\"quantity\\": 2}, {\\"date\\": \\"2023-01-10\\", \\"product\\": \\"Product C\\", \\"quantity\\": 5}, ] print(top_selling_products(sales_data, top_n=2, start_date=\\"2023-01-01\\", end_date=\\"2023-01-06\\")) ``` *Output*: ``` [\'Product A\', \'Product B\'] ``` # Implementation Notes - Use Python standard libraries such as `datetime` for parsing and comparing dates. - Ensure the function handles cases where no products are sold within the specified date range gracefully. - Consider edge cases such as empty sales data or invalid date formats.","solution":"from typing import List, Dict, Any from datetime import datetime def top_selling_products(sales_data: List[Dict[str, Any]], top_n: int, start_date: str, end_date: str) -> List[str]: # Convert string dates to datetime objects for comparison start_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_dt = datetime.strptime(end_date, \\"%Y-%m-%d\\") # Filter transactions within the date range filtered_sales = [sale for sale in sales_data if start_dt <= datetime.strptime(sale[\'date\'], \\"%Y-%m-%d\\") <= end_dt] # Aggregate the total sales quantity for each product product_totals = {} for sale in filtered_sales: product = sale[\'product\'] quantity = sale[\'quantity\'] if product in product_totals: product_totals[product] += quantity else: product_totals[product] = quantity # Sort the products by total sales quantity in descending order, resolving ties alphabetically sorted_products = sorted(product_totals.items(), key=lambda item: (-item[1], item[0])) # Return the top n products return [product for product, _ in sorted_products[:top_n]]"},{"question":"# Question: Weather Forecast via ZIP Code You are required to write a Python function that fetches and summarizes the current weather status for a given ZIP Code using the OpenWeatherMap API. The OpenWeatherMap API provides detailed weather information given a ZIP Code. # Function: `fetch_weather_summary` Input: A `zip_code` (string) representing the ZIP Code for which weather information is requested. Output: A dictionary with the following weather details or an error message if the ZIP Code is invalid or the request fails: ```python { \\"Location\\": str, \\"Temperature (C)\\": float, \\"Weather\\": str, \\"Wind Speed (m/s)\\": float, \\"Humidity (%)\\": int, \\"Pressure (hPa)\\": int, } ``` Constraints: 1. The `zip_code` will be a string of 5 digits. 2. Ensure proper handling of OpenWeatherMap API rate-limiting and network errors. 3. Optimize for minimal API calls. 4. Use the actual API endpoint: `http://api.openweathermap.org/data/2.5/weather` 5. You need an API key to access the OpenWeatherMap API. For the purpose of this assessment, assume you have your API key as `api_key = \\"YOUR_API_KEY\\"`. Note: - If a field is not available in the response, the function should gracefully handle it and not include that field in the output. - The temperature should be converted from Kelvin to Celsius before returning. # Example: ```python def fetch_weather_summary(zip_code: str) -> dict: # Implement the function here pass # Running the function with a specific ZIP Code should give results like: print(fetch_weather_summary(\\"94040\\")) # Expected Output { \\"Location\\": \\"Mountain View\\", \\"Temperature (C)\\": 22.5, \\"Weather\\": \\"clear sky\\", \\"Wind Speed (m/s)\\": 4.6, \\"Humidity (%)\\": 56, \\"Pressure (hPa)\\": 1015 } ```","solution":"import requests def fetch_weather_summary(zip_code: str) -> dict: api_key = \\"YOUR_API_KEY\\" base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" params = { \'zip\': zip_code, \'appid\': api_key } try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() weather_summary = { \\"Location\\": data.get(\\"name\\", \\"Unknown location\\"), \\"Temperature (C)\\": round(data[\\"main\\"][\\"temp\\"] - 273.15, 2) if \\"main\\" in data and \\"temp\\" in data[\\"main\\"] else None, \\"Weather\\": data[\\"weather\\"][0][\\"description\\"] if \\"weather\\" in data and len(data[\\"weather\\"]) > 0 and \\"description\\" in data[\\"weather\\"][0] else None, \\"Wind Speed (m/s)\\": data[\\"wind\\"][\\"speed\\"] if \\"wind\\" in data and \\"speed\\" in data[\\"wind\\"] else None, \\"Humidity (%)\\": data[\\"main\\"][\\"humidity\\"] if \\"main\\" in data and \\"humidity\\" in data[\\"main\\"] else None, \\"Pressure (hPa)\\": data[\\"main\\"][\\"pressure\\"] if \\"main\\" in data and \\"pressure\\" in data[\\"main\\"] else None } return weather_summary except requests.exceptions.RequestException as e: return {\\"error\\": str(e)}"},{"question":"# Coding Question: String Pattern Matching with Wildcards Problem Statement You are given two strings `s` and `p`, where `p` is a pattern string containing wildcard characters `*` and `?`. Your task is to implement a function that returns `True` if `s` matches the pattern `p` and `False` otherwise. The matching should cover the entire string `s`. The rules for matching are: - `?` matches exactly one character. - `*` matches zero or more characters. Requirements 1. **Pattern Matching**: - Implement the `is_match` method which takes two strings, `s` and `p`, and returns a boolean indicating if `s` matches the pattern `p`. Method Signature - `def is_match(s: str, p: str) -> bool:` Input and Output Formats - **Input**: Two strings, `s` and `p`. - **Output**: A boolean indicating whether the string `s` matches the pattern `p`. Constraints - `s` has a length of up to 1000. - `p` has a length of up to 1000. - The pattern `p` may contain the wildcard characters `*` and `?`. Example ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"*\\") == True assert is_match(\\"cb\\", \\"?a\\") == False assert is_match(\\"adceb\\", \\"*a*b\\") == True assert is_match(\\"acdcb\\", \\"a*c?b\\") == False ``` Implementation ```python def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j-1] == \'*\': dp[i][j] = dp[i-1][j] or dp[i][j-1] elif p[j-1] == \'?\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] return dp[m][n] ``` # Explanation In this question, we implement a dynamic programming solution to solve the string pattern matching problem with wildcards. 1. **Dynamic Programming Table**: We initialize a 2D table `dp` where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. 2. **Base Case**: The base case is when both `s` and `p` are empty (`dp[0][0] = True`). Additionally, we handle the situation where the pattern starts with `*` as it can match an empty sequence. 3. **Pattern Matching Rules**: We iterate through each character of `s` and `p` to populate the `dp` table based on the wildcard matching rules: - If the current character in `p` is `*`, it can match either zero characters (i.e., `dp[i][j] = dp[i][j-1]`) or one/more characters (i.e., `dp[i][j] = dp[i-1][j]`). - If the current character in `p` is `?` or matches the current character in `s`, then the state depends on the previous state `dp[i-1][j-1]`. 4. **Return the Result**: Finally, we return the value of `dp[m][n]`, which tells whether the entire string `s` matches the pattern `p`. The provided implementation efficiently matches the string `s` against the pattern `p` using dynamic programming, ensuring the solution works within the longest expected inputs.","solution":"def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j-1] == \'*\': dp[i][j] = dp[i-1][j] or dp[i][j-1] elif p[j-1] == \'?\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] return dp[m][n]"},{"question":"# Question: Efficient Path Finding in a Weighted Grid Scenario You are given a rectangular grid where each cell has a positive integer value representing the cost to step into that cell. You need to find the minimum cost path from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) of the grid. You can only move right or down at each step. Your task is to implement an optimized function to compute this minimum cost path using efficient algorithms and data structures while considering the grid may be large. Function Implementation Your task is to write a function `min_path_cost` which calculates the minimum cost to reach the bottom-right corner of the grid from the top-left corner. Function Signature ```python def min_path_cost(grid: list[list[int]]) -> int: ``` Input - `grid`: a 2D list of integers representing the grid, where `grid[i][j]` is the cost to move onto the cell (i, j). The dimensions of the grid can be up to `1000 x 1000`. Output - Returns an integer representing the minimum cost to reach the bottom-right corner of the grid from the top-left corner. Constraints - Grid size can go up to `1000x1000`. - All cells contain positive integer values. Example ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1], ] result = min_path_cost(grid) # Expected output is 7, as the minimum cost path is 1→3→1→1→1. ``` # Considerations - Make sure your code is efficient, especially for large grids. Consider dynamic programming techniques or priority queues to optimize the pathfinding algorithm. - Handle edge cases where the grid dimensions might be minimal (e.g., 1x1). - Avoid excessive memory usage and ensure your solution scales well with increasing grid sizes.","solution":"import heapq def min_path_cost(grid): Find the minimum cost path from the top-left to the bottom-right corner of the grid. # Dimensions of the grid n, m = len(grid), len(grid[0]) # Priority queue to store (cost, x, y) pq = [(grid[0][0], 0, 0)] # Directions right and down directions = [(0, 1), (1, 0)] # Minimum cost initialized to infinity min_cost = [[float(\'inf\')]*m for _ in range(n)] min_cost[0][0] = grid[0][0] while pq: current_cost, x, y = heapq.heappop(pq) if x == n-1 and y == m-1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = current_cost + grid[nx][ny] if new_cost < min_cost[nx][ny]: heapq.heappush(pq, (new_cost, nx, ny)) min_cost[nx][ny] = new_cost return -1 # Just for safety; should never reach here unless no valid path"},{"question":"# Scenario In software development, handling dynamic data efficiently is crucial for improving performance. One such common data structure used for this purpose is the AVL Tree, a self-balancing binary search tree. Each node in an AVL tree is assigned a balance factor based on the heights of its left and right subtrees to ensure that the tree remains balanced during insertions and deletions. **Your Task**: Implement an AVL Tree with functionalities to insert and delete nodes while maintaining balance. Your program should allow insertion of new nodes and deletion of existing nodes, and it should print the AVL Tree in an in-order traversal each time after an insertion or deletion operation. # Input Format You will be given: 1. An integer `n` representing the number of operations. 2. A list of `n` strings where each string represents an operation (\\"insert x\\" or \\"delete x\\"), where `x` is an integer to be inserted or deleted from the AVL Tree. # Output Format Your program should print the in-order traversal of the AVL Tree after each operation. If the tree is empty after an operation, print \\"Tree is empty\\". # Constraints 1. 1 <= n <= 1000 2. -10^6 <= x <= 10^6, where `x` is the value to be inserted or deleted. # Example ```python n = 7 operations = [\\"insert 10\\", \\"insert 20\\", \\"insert 30\\", \\"delete 20\\", \\"insert 40\\", \\"insert 50\\", \\"delete 30\\"] ``` Expected output: ``` 10 10 20 10 20 30 10 30 10 30 40 10 30 40 50 10 40 50 ``` # Function Signature ```python def avl_tree_operations(n: int, operations: List[str]) -> None: # your code here ``` # Notes * Make sure your AVL Tree implementation properly maintains balance after each insertion and deletion. * Consider edge cases such as attempting to delete a node that doesn\'t exist or inserting duplicate values. * Ensure that the in-order traversal accurately reflects the AVL Tree state after each operation.","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): if not root: return AVLNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and key < root.left.key: return self.rightRotate(root) if balance < -1 and key > root.right.key: return self.leftRotate(root) if balance > 1 and key > root.left.key: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.key: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.getMinValueNode(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and self.getBalance(root.left) >= 0: return self.rightRotate(root) if balance < -1 and self.getBalance(root.right) <= 0: return self.leftRotate(root) if balance > 1 and self.getBalance(root.left) < 0: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and self.getBalance(root.right) > 0: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def getMinValueNode(self, root): if root is None or root.left is None: return root return self.getMinValueNode(root.left) def inOrder(self, root): res = [] if root: res = self.inOrder(root.left) res.append(root.key) res = res + self.inOrder(root.right) return res def avl_tree_operations(n, operations): avltree = AVLTree() root = None for operation in operations: operation = operation.split() if operation[0] == \\"insert\\": root = avltree.insert(root, int(operation[1])) elif operation[0] == \\"delete\\": root = avltree.delete(root, int(operation[1])) in_order_traversal = avltree.inOrder(root) if in_order_traversal: print(\\" \\".join(map(str, in_order_traversal))) else: print(\\"Tree is empty\\")"},{"question":"# Coding Assessment Question Scenario You are developing a software application that involves arithmetic operations on integers, and one required function is computing the digital root of a number. The digital root of a number is the single-digit value obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration, until a single-digit number is achieved. For example, the digital root of 38 would be computed as: * 3 + 8 = 11 * 1 + 1 = 2 * Digital root = 2 Task Write a function `digital_root` that takes in a non-negative integer and returns its digital root. Function Signature ```python def digital_root(n: int) -> int: ``` Input * `n`: A non-negative integer. Output * A single-digit integer representing the digital root of the input number. Constraints * The input will always be a non-negative integer. Examples ```python >>> digital_root(38) 2 >>> digital_root(123) 6 >>> digital_root(0) 0 >>> digital_root(9) 9 ``` Explanation of Examples * For `digital_root(38)`, we compute 3 + 8 = 11, and then 1 + 1 = 2. Thus, the digital root is 2. * For `digital_root(123)`, we compute 1 + 2 + 3 = 6. Thus, the digital root is 6. * For `digital_root(0)`, since the input is 0, the digital root is 0. * For `digital_root(9)`, since the input is already a single digit, the digital root remains 9. Performance Requirements * The function should execute in linear time O(log(n)).","solution":"def digital_root(n: int) -> int: Returns the digital root of a non-negative integer n. while n >= 10: sum_of_digits = 0 while n > 0: sum_of_digits += n % 10 n //= 10 n = sum_of_digits return n"},{"question":"# Binary Search Tree Operations You have been provided with a basic implementation of a Binary Search Tree (BST) in Python. Your task is to extend the functionality of this BST by implementing additional operations that are frequently used in tree data structures. These enhancements should improve the utility of the BST, making it capable of handling more diverse queries and updates. # Task Requirements: 1. **In-order Traversal**: * Implement an in-order traversal method that returns the elements of the tree in ascending order. 2. **Delete Node**: * Implement a method to delete a node with a given value while maintaining the BST properties. 3. **Get Height**: * Implement a method to find the height of the tree, defined as the number of edges on the longest path from the root to a leaf. 4. **Find Kth Smallest**: * Implement a method to find the k-th smallest element in the BST. # Input and Output Formats: - **Input**: - An initial list of integers to insert into the BST. - A series of commands to perform operations (insert, delete, get height, find k-th smallest). - **Output**: - The results of the specified operations (e.g., height of the tree, k-th smallest element). # Constraints: - You can assume the initial list of integers and commands are well-formatted. - The tree must maintain the BST properties at all times. - Aim to make each operation efficient, considering the properties of the BST. # Scenario: Your company is using BSTs to keep track of a dynamically changing set of numbers. The operations you implement will help in efficiently managing and querying this data. For instance, finding the k-th smallest element is useful for statistical analyses, while maintaining height helps in understanding the tree\'s balance over time. # Code Skeleton: ```python class TreeNode: def __init__(self, key: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None) -> None: self.key = key self.left = left self.right = right class BinarySearchTree: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: # Insert logic for the BST. pass def in_order_traversal(self) -> list: # Implement in-order traversal. pass def delete(self, key: int) -> None: # Implement node deletion. pass def get_height(self) -> int: # Implement height calculation. pass def find_kth_smallest(self, k: int) -> int: # Implement k-th smallest search. pass def example_bst_usage() -> None: # Provide an example usage of the BST with all new functionalities. pass if __name__ == \\"__main__\\": example_bst_usage() ``` # Example Usage ```python if __name__ == \\"__main__\\": bst = BinarySearchTree() bst.insert(20) bst.insert(9) bst.insert(25) bst.insert(5) bst.insert(12) print(\\"In-order Traversal:\\", bst.in_order_traversal()) # Output: [5, 9, 12, 20, 25] print(\\"Tree Height:\\", bst.get_height()) # Output: 2 bst.delete(9) print(\\"After Deletion In-order Traversal:\\", bst.in_order_traversal()) # Output: [5, 12, 20, 25] print(\\"k-th Smallest (k=2):\\", bst.find_kth_smallest(2)) # Output: 12 ```","solution":"class TreeNode: def __init__(self, key: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None) -> None: self.key = key self.left = left self.right = right class BinarySearchTree: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node: TreeNode, key: int) -> None: if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def in_order_traversal(self) -> list: result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node: TreeNode, result: list) -> None: if node: self._in_order_recursive(node.left, result) result.append(node.key) self._in_order_recursive(node.right, result) def delete(self, key: int) -> None: self.root = self._delete_recursive(self.root, key) def _delete_recursive(self, node: TreeNode, key: int) -> TreeNode: if not node: return node if key < node.key: node.left = self._delete_recursive(node.left, key) elif key > node.key: node.right = self._delete_recursive(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete_recursive(node.right, temp.key) return node def _min_value_node(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current def get_height(self) -> int: return self._get_height_recursive(self.root) def _get_height_recursive(self, node: TreeNode) -> int: if not node: return -1 left_height = self._get_height_recursive(node.left) right_height = self._get_height_recursive(node.right) return 1 + max(left_height, right_height) def find_kth_smallest(self, k: int) -> int: in_order = self.in_order_traversal() if 0 < k <= len(in_order): return in_order[k - 1] return -1 # Example usage def example_bst_usage() -> None: bst = BinarySearchTree() bst.insert(20) bst.insert(9) bst.insert(25) bst.insert(5) bst.insert(12) print(\\"In-order Traversal:\\", bst.in_order_traversal()) # Output: [5, 9, 12, 20, 25] print(\\"Tree Height:\\", bst.get_height()) # Output: 2 bst.delete(9) print(\\"After Deletion In-order Traversal:\\", bst.in_order_traversal()) # Output: [5, 12, 20, 25] print(\\"k-th Smallest (k=2):\\", bst.find_kth_smallest(2)) # Output: 12 if __name__ == \\"__main__\\": example_bst_usage()"},{"question":"# Question You are tasked with creating a string manipulation tool that generates unique identifiers for various text inputs. To verify and understand the identifier generation better, implement a function based on the following requirements: # Function to Implement Function Signature ```python def generate_identifier(separator: str = \'-\') -> (str -> str, str -> str) ``` Input * `separator` (string, optional): A character or a string used to separate the different parts of the identifier. Default is \'-\'. Output * A tuple containing two functions: * An `identifier` function that takes a text input (string) and returns a unique identifier for that text. * A `validate` function that takes an identifier (string) and returns whether it is a valid identifier generated by the `identifier` function. Requirements * The `identifier` function should generate a unique identifier by combining a hash of the text with a timestamp, separated by the given separator. * The `validate` function should ensure that the identifier was created using the correct format and the correct separator. It does not need to verify the content of the hash or timestamp, only the overall structure. # Examples ```python # Example 1 identifier, validate = generate_identifier() text = \\"Sample Text\\" generated_id = identifier(text) assert validate(generated_id) # Example 2 identifier, validate = generate_identifier(\'_\') text = \\"Another Sample Text\\" generated_id = identifier(text) assert validate(generated_id) assert not validate(\\"invalid_identifier\\") ``` # Constraints * The separator will consist of a single ASCII character or a string of maximum 3 ASCII characters. * The text input for identifier generation will only consist of printable ASCII characters including spaces and punctuation. * The generated identifier should be in the format: `<hash><separator><timestamp>` where `<hash>` is a fixed size hash and `<timestamp>` is a UNIX timestamp.","solution":"import hashlib import time def generate_identifier(separator: str = \'-\'): def identifier(text: str) -> str: hash_object = hashlib.sha256(text.encode()) hash_hex = hash_object.hexdigest()[:16] # Truncate the hash for simplicity timestamp = str(int(time.time())) return f\\"{hash_hex}{separator}{timestamp}\\" def validate(identifier_str: str) -> bool: parts = identifier_str.split(separator) if len(parts) != 2: return False hash_part, timestamp_part = parts if len(hash_part) != 16: return False if not timestamp_part.isdigit(): return False return True return identifier, validate"},{"question":"# Problem Statement: Consecutive Characters in a String Write a function `max_consecutive_characters(s: str) -> Tuple[str, int]` that takes a string and returns a tuple containing the character and the length of the maximum consecutive character sequence in the string. If there are multiple characters with the same maximum sequence length, return the character that appears first in the string. Function Signature ```python def max_consecutive_characters(s: str) -> Tuple[str, int]: ``` Input - `s`: a string consisting of any characters, including letters, digits, and symbols. Output - Returns a tuple `(character, length)` where `character` is the character with the maximum consecutive repetition and `length` is the number of consecutive times it appears. Constraints - The input string `s` can be of any length, from an empty string to a very large string. - If the string is empty, return `(\'\', 0)`. Example ```python assert max_consecutive_characters(\\"abbcccddddeeeeee\\") == (\'e\', 6) # \'e\' appears 6 times consecutively assert max_consecutive_characters(\\"aabbbcc\\") == (\'b\', 3) # \'b\' appears 3 times consecutively assert max_consecutive_characters(\\"xxxxxaaaabbcc\\") == (\'x\', 5) # \'x\' appears 5 times consecutively assert max_consecutive_characters(\\"z\\") == (\'z\', 1) # \'z\' appears 1 time assert max_consecutive_characters(\\"\\") == (\'\', 0) # empty string assert max_consecutive_characters(\\"a@123\\") == (\'\', 3) # \'\' appears 3 times consecutively ``` Note - Traverse the string efficiently to determine the maximum consecutive character sequence. - If two characters have the same maximum sequence length, return the one that appears first in the string. - Handle edge cases like an empty string and strings with all unique characters properly.","solution":"def max_consecutive_characters(s: str) -> tuple: if not s: return (\'\', 0) max_char = s[0] max_length = 1 current_char = s[0] current_length = 1 for i in range(1, len(s)): if s[i] == current_char: current_length += 1 else: if current_length > max_length: max_length = current_length max_char = current_char current_char = s[i] current_length = 1 if current_length > max_length: max_char = current_char max_length = current_length return (max_char, max_length)"},{"question":"# Problem Statement Given a list of integers, write a function `second_largest(nums: List[int]) -> int` that returns the second largest unique number in the list. If there are fewer than two unique numbers, it should raise a `ValueError`. # Requirements - **Input**: - `nums`: A list of integers. The list is guaranteed to have at least two elements. - **Output**: - An integer representing the second largest unique number in the list. # Function Signature ```python def second_largest(nums: List[int]) -> int: ``` # Examples *Example 1*: ```python print(second_largest([10, 20, 4, 20, 30])) # Output: 20 ``` *Example 2*: ```python print(second_largest([4, 4, 4, 4, 4])) # Raises ValueError ``` *Example 3*: ```python print(second_largest([5, 1, 5])) # Output: 1 ``` # Constraints 1. The input list can contain negative numbers and zeros. 2. The function should handle large and small lists efficiently. 3. Aim to optimize the function to work in linear time complexity, if possible. # Hint Consider using a set to keep track of unique numbers and then determine the second largest from this set.","solution":"from typing import List def second_largest(nums: List[int]) -> int: unique_nums = list(set(nums)) if len(unique_nums) < 2: raise ValueError(\\"There are fewer than two unique numbers in the list.\\") unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"# Linked List Manipulation You are tasked with implementing a `SinglyLinkedList` class and a `ListNode` class, representing the basic constructs of a singly linked list. These classes will include methods to perform essential operations on the linked list. Tasks: 1. **ListNode Class Implementation**: - **Initialization**: Initialize with a value and a pointer to the next node (default is `None`). 2. **SinglyLinkedList Class Implementation**: - **Initialization**: Initialize with a head pointer set to `None`. - **Append**: Add a new node with a specified value to the end of the list. - **Prepend**: Add a new node with a specified value to the start of the list. - **Insert After Value**: Insert a new node with a specified value after the first node with a given value. - **Remove Value**: Remove the first node with a specified value. - **Find**: Find and return the first node with a specified value. - **Reverse**: Reverse the linked list in-place. - **Print List**: Print all values in the linked list. Constraints: - Assume the list may contain up to 1000 nodes. - Node values will be integers within the range of -10000 and 10000. Expected Input and Output Format: - **Input**: Operations by calling various methods. - **Output**: Printed results of operations: Example: ```python ll = SinglyLinkedList() # Test prepend operation ll.prepend(3) ll.prepend(2) ll.prepend(1) ll.print_list() # Output: 1 -> 2 -> 3 # Test append operation ll.append(4) ll.append(5) ll.print_list() # Output: 1 -> 2 -> 3 -> 4 -> 5 # Test insert after value operation ll.insert_after_value(3, 3.5) ll.print_list() # Output: 1 -> 2 -> 3 -> 3.5 -> 4 -> 5 # Test find operation node = ll.find(3.5) print(node.value) # Output: 3.5 # Test remove value operation ll.remove_value(3.5) ll.print_list() # Output: 1 -> 2 -> 3 -> 4 -> 5 # Test reverse operation ll.reverse() ll.print_list() # Output: 5 -> 4 -> 3 -> 2 -> 1 ``` Implement the classes such that they satisfy the constraints above, handling any edge cases appropriately.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class SinglyLinkedList: def __init__(self): self.head = None def append(self, value): new_node = ListNode(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def prepend(self, value): new_node = ListNode(value) new_node.next = self.head self.head = new_node def insert_after_value(self, target_value, value): current = self.head while current and current.value != target_value: current = current.next if current: new_node = ListNode(value) new_node.next = current.next current.next = new_node def remove_value(self, value): if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def find(self, value): current = self.head while current and current.value != value: current = current.next return current def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def print_list(self): current = self.head while current: if current.next: print(current.value, end=\' -> \') else: print(current.value, end=\'\') current = current.next print()"},{"question":"# Sort and Remove Duplicates from a List of Strings Write a function `sort_and_deduplicate(strings: List[str]) -> List[str]` that takes a list of strings, removes any duplicate entries, and then returns the list sorted in lexicographical order. Implement the function `sort_and_deduplicate(strings: List[str]) -> List[str]` that achieves the above. **Requirements:** 1. The function should handle an empty list gracefully. 2. The function should use efficient sorting and deduplication techniques. 3. Assume all strings are ASCII and case-sensitive (\\"apple\\" and \\"Apple\\" are different). **Input:** * `strings` (List[str]): A list of strings that may contain duplicates. **Output:** * (List[str]): A sorted list of strings with duplicates removed. **Constraints:** * The function should be efficient in terms of both time and space complexity. **Example:** ```python # Example usage: print(sort_and_deduplicate([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\"])) # Output: [\'apple\', \'banana\', \'orange\'] print(sort_and_deduplicate([\\"zebra\\", \\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"kiwi\\"])) # Output: [\'apple\', \'banana\', \'kiwi\', \'zebra\'] ```","solution":"from typing import List def sort_and_deduplicate(strings: List[str]) -> List[str]: Removes duplicates from the input list and returns a sorted list. Parameters: strings (List[str]): A list of strings that may contain duplicates. Returns: List[str]: A sorted list of strings with duplicates removed. return sorted(set(strings))"},{"question":"# Question: Custom Queue with Different Priorities You are tasked with implementing a custom queue that can handle elements with different priority levels. This queue supports the basic operations of enqueue and dequeue. However, elements with higher priority should be dequeued before those with lower priority, and elements with the same priority should follow a first-in, first-out (FIFO) order. **Task**: Write a class `PriorityQueue` that manages a queue with different priority levels. Implement the methods `enqueue` and `dequeue` to add and remove elements from the queue, respectively. **Class Signature**: ```python class PriorityQueue: def __init__(self): pass def enqueue(self, element: any, priority: int) -> None: pass def dequeue(self) -> any: pass ``` **Methods**: * `enqueue(element, priority)`: Adds an `element` to the queue with the given `priority`. Elements with the same `priority` should be dequeued in the order they were enqueued. * `dequeue()`: Removes and returns the element with the highest priority. If multiple elements have the highest priority, return the one that was enqueued first. If the queue is empty, return `None`. **Input**: * `element`: The element to be added to the queue. * `priority`: An integer representing the priority of the element; higher values denote higher priority. * The `PriorityQueue` will manage elements in a way that supports arbitrary complex elements (e.g., tuples, strings, etc.). **Output**: * The `dequeue` method should return the element with the highest priority currently in the queue. If the queue is empty, return `None`. **Constraints**: * The priority can be any integer (positive or negative). * Assume valid inputs for elements and priorities. * The operations `enqueue` and `dequeue` should be designed to perform efficiently. **Examples**: ```python >>> pq = PriorityQueue() >>> pq.enqueue(\'apple\', 2) >>> pq.enqueue(\'banana\', 1) >>> pq.enqueue(\'cherry\', 3) >>> pq.enqueue(\'date\', 2) >>> pq.dequeue() \'cherry\' >>> pq.dequeue() \'apple\' >>> pq.dequeue() \'date\' >>> pq.dequeue() \'banana\' >>> pq.dequeue() None ``` **Notes**: * Ensure that the class handles priorities and maintains the FIFO principle within the same priority level. * Consider performance implications and aim for efficient operations.","solution":"import heapq class PriorityQueue: def __init__(self): self.counter = 0 self.pq = [] def enqueue(self, element: any, priority: int) -> None: heapq.heappush(self.pq, (-priority, self.counter, element)) self.counter += 1 def dequeue(self) -> any: if self.pq: return heapq.heappop(self.pq)[2] return None"},{"question":"# Problem Statement Your task is to create a function that efficiently compresses a string using the run-length encoding technique. The function should reduce consecutive repeated characters in the string by encoding the character followed by its count. If a character repeats only once, it should not be followed by a count. Function Signature ```python def run_length_encode(data: str) -> str: ``` Input * `data` (str): The string to be compressed. Output * Returns a compressed version of the string using run-length encoding. Constraints * The input string can contain characters from the ASCII printable character set (32-126). * The length of the input string will not exceed 10,000 characters. Requirements * Optimize the function to run in linear time, O(n), with respect to the input string length. * The function should handle consecutive characters efficiently without building a new string for every character. * Include error handling for empty strings and non-string inputs. # Example ```python encoded = run_length_encode(\\"aaabbcdddd\\") print(encoded) # Output: \\"a3b2cd4\\" encoded = run_length_encode(\\"xyz\\") print(encoded) # Output: \\"xyz\\" ``` # Testing * Test with different types of strings, including those with no consecutive repeats, all characters repeating, and mixed cases. * Ensure the function handles edge cases like single-character strings and empty strings. * Validate the function\'s performance with very long strings.","solution":"def run_length_encode(data: str) -> str: if not isinstance(data, str): raise ValueError(\\"Input must be a string\\") if not data: return \\"\\" encoded = [] current_char = data[0] count = 1 for char in data[1:]: if char == current_char: count += 1 else: if count > 1: encoded.append(f\\"{current_char}{count}\\") else: encoded.append(current_char) current_char = char count = 1 if count > 1: encoded.append(f\\"{current_char}{count}\\") else: encoded.append(current_char) return \\"\\".join(encoded)"},{"question":"**Problem Statement:** You are tasked with implementing a simple text editor that supports undo and redo operations. The text editor should have the following functionalities: 1. `__init__(self)`: Initializes an empty text editor. 2. `write(self, text: str) -> None`: Adds the given text to the end of the current content. 3. `display(self) -> str`: Returns the current content of the text editor. 4. `undo(self) -> None`: Reverts the last write operation. Raises an `Exception` with the message `\\"Nothing to undo\\"` if there are no operations to undo. 5. `redo(self) -> None`: Redoes the last undone write operation. Raises an `Exception` with the message `\\"Nothing to redo\\"` if there are no operations to redo. # Input and Output Format: * **Input**: * The `write` method takes one argument which is the string to be added to the text editor. * The `undo` and `redo` methods do not take any arguments. * The `display` method does not take any arguments. * **Output**: * The `write` and `redo` methods do not return any value. * The `display` method returns the current content of the text editor as a string. * The `undo` method does not return any value unless an exception is raised. # Constraints: * The editor must handle a sequence of `write`, `undo`, and `redo` operations in a realistic way. * You must maintain the sequence of operations to handle undo and redo correctly. * Ensure that you handle edge cases gracefully such as attempting to undo when there are no operations to undo or redo when there are no operations to redo. # Example: ```python editor = TextEditor() editor.write(\\"Hello\\") editor.write(\\" World\\") assert editor.display() == \\"Hello World\\" editor.undo() assert editor.display() == \\"Hello\\" editor.redo() assert editor.display() == \\"Hello World\\" try: editor.redo() except Exception as e: assert str(e) == \\"Nothing to redo\\" editor.undo() editor.undo() assert editor.display() == \\"\\" try: editor.undo() except Exception as e: assert str(e) == \\"Nothing to undo\\" ``` Implement the `TextEditor` class in Python with the methods specified above.","solution":"class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] self.redo_stack = [] def write(self, text: str) -> None: self.history.append(self.content) self.content += text self.redo_stack.clear() def display(self) -> str: return self.content def undo(self) -> None: if not self.history: raise Exception(\\"Nothing to undo\\") self.redo_stack.append(self.content) self.content = self.history.pop() def redo(self) -> None: if not self.redo_stack: raise Exception(\\"Nothing to redo\\") self.history.append(self.content) self.content = self.redo_stack.pop()"},{"question":"# Sorting Names by Last Name Suppose you are given a list of names and you need to sort them by their last name. If two people have the same last name, sort by their first name. # Your Task Write a Python function, `sort_names`, which will: 1. Take a list of names as input. Each name is a string in the format \\"First Last\\". 2. Return a list of names sorted first by the last name and then by the first name if the last names are the same. # Function Signature ```python def sort_names(names: List[str]) -> List[str]: ``` # Example ```python input_names = [ \\"John Doe\\", \\"Jane Smith\\", \\"Alice Johnson\\", \\"Robert Brown\\", \\"Emily Davis\\", \\"Michael Brown\\" ] sorted_names = sort_names(input_names) print(sorted_names) ``` Output ``` [ \'Michael Brown\', \'Robert Brown\', \'Emily Davis\', \'John Doe\', \'Alice Johnson\', \'Jane Smith\' ] ``` # Constraints - The input list will contain at least one name and no more than 1000 names. - All names follow the \\"First Last\\" format and names do not contain any special characters beyond letters and spaces. - Each name will have exactly one first name and one last name. # Hints - Use the `sorted` function with a custom key for sorting. - The `split` method will be useful for separating first and last names.","solution":"from typing import List def sort_names(names: List[str]) -> List[str]: Sorts a list of names by their last name, and by first name if the last names are the same. return sorted(names, key=lambda name: (name.split()[1], name.split()[0]))"},{"question":"# Question: Balancing Parentheses in a String Create a function that takes a string consisting of only the characters \'(\' and \')\' and returns the minimum number of moves required to make the parentheses balanced. Each move can either involve inserting a parenthesis or removing an existing one. **Function Signature:** ```python def min_moves_to_balance(s: str) -> int: pass ``` **Input:** * `s`: A string of length (1 leq s leq 10^5) consisting only of the characters \'(\' and \')\'. **Output:** * An integer representing the minimum number of moves required to balance the parentheses. **Constraints:** * Aim for an efficient solution that runs in linear time. **Examples:** ```python assert min_moves_to_balance(\\"())\\") == 1 assert min_moves_to_balance(\\"(((\\") == 3 assert min_moves_to_balance(\\"()\\") == 0 assert min_moves_to_balance(\\"())(\\") == 2 assert min_moves_to_balance(\\"\\") == 0 assert min_moves_to_balance(\\")))(((\\") == 6 ``` # Explanation: - In the first example, we need one move to balance \\"())\\" by inserting one \'(\' at the beginning or the end to make it \\"(())\\". - In the second example, we need three moves to balance \\"(((\\" by adding three \')\' at the end to make it \\"((()))\\". - In the third example, the string \\"()\\" is already balanced, so no moves are required. - In the fourth example, we need two moves: one to add \'(\' at the start and one to add \')\' at the end, resulting in \\"(())()\\". - In the fifth example, the string is empty and already balanced. - In the sixth example, we need three moves to add \'(\' at the start and three moves to add \')\' at the end, resulting in \\"((()))((()))\\".","solution":"def min_moves_to_balance(s: str) -> int: Returns the minimum number of moves required to balance the parentheses string. Each move can either involve inserting a parenthesis or removing an existing one. left_unbalanced = 0 right_unbalanced = 0 for char in s: if char == \'(\': left_unbalanced += 1 else: # char == \')\' if left_unbalanced > 0: left_unbalanced -= 1 else: right_unbalanced += 1 return left_unbalanced + right_unbalanced"},{"question":"# Coding Question A balanced binary search tree (BST) is a type of binary tree where the left subtree contains only nodes with keys less than the node\'s key, and the right subtree contains only nodes with keys greater than the node\'s key. Additionally, the tree is balanced to minimize the height difference between subtrees of any node, ensuring efficient search and insert operations. You are required to implement a solution that inserts a node into a balanced BST while maintaining its balanced property and also trace the changes in the height of the tree after each insertion. Function Implementations 1. `insert_into_bst(root: Optional[TreeNode], key: int) -> TreeNode` 2. `calculate_tree_height(root: Optional[TreeNode]) -> int` 3. `trace_heights_after_inserts(keys: List[int]) -> List[int]` # Assumptions - The tree node class `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None ``` # Complexity - Aim for insertion time complexity of O(log n) for a balanced tree and an O(n) height calculation. # Input - `root`: The root of the current BST, which could be `None` if the tree is empty. - `key`: An integer representing a key to be inserted into the BST. - `keys`: A list of integers representing multiple keys to be inserted sequentially into an initially empty BST. # Output - For `insert_into_bst`: - The root of the updated BST after the insertion. - For `calculate_tree_height`: - An integer representing the height of the BST. - For `trace_heights_after_inserts`: - A list of integers, where each integer represents the height of the BST after the insertion of the corresponding key from the `keys` list. Example ```python # Assume the TreeNode class is defined as described # Function Call Sequence for Example # Insert into empty tree root = None root = insert_into_bst(root, 10) # Subsequent insertions root = insert_into_bst(root, 20) root = insert_into_bst(root, 5) # Calculate height height = calculate_tree_height(root) # Output: 2 # Trace heights after multiple inserts heights_trace = trace_heights_after_inserts([10, 20, 5, 15, 30]) # Expected Output: [0, 1, 1, 2, 2] ``` # Notes: - Ensure the BST remains balanced after each insertion. Using an algorithm like AVL or Red-Black Tree will help maintain balance. - The height of a tree is defined as the number of edges on the longest path from the root to a leaf. - Provide the functions\' implementations that maintain the BST balance property and correctly compute heights.","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 # New TreeNode is at height 1 (leaf) def get_height(node): return node.height if node else 0 def update_height(node): if node: node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): return get_height(node.left) - get_height(node.right) if node else 0 def left_rotate(z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights update_height(z) update_height(y) return y def right_rotate(z): y = z.left T3 = y.right # Perform rotation y.right = z z.left = T3 # Update heights update_height(z) update_height(y) return y def insert_into_bst(root, key): if not root: return TreeNode(key) if key < root.key: root.left = insert_into_bst(root.left, key) else: root.right = insert_into_bst(root.right, key) update_height(root) balance = get_balance(root) # Balance subtree if needed if balance > 1 and key < root.left.key: return right_rotate(root) if balance < -1 and key > root.right.key: return left_rotate(root) if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) return root def calculate_tree_height(root): if not root: return 0 return root.height def trace_heights_after_inserts(keys): root = None heights = [] for key in keys: root = insert_into_bst(root, key) heights.append(calculate_tree_height(root)) return heights"},{"question":"**Problem Statement**: You are tasked with implementing a linked list with singly and doubly linked list capabilities. This linked list should support various operations such as insertion, deletion, and traversal. Each node in the linked list should hold a value and links to its neighboring nodes. # Features to Implement: 1. **Add Node at End**: - Method: `add_node_end(value: T) -> None` - Description: Adds a new node with the specified value at the end of the linked list. 2. **Add Node at Start**: - Method: `add_node_start(value: T) -> None` - Description: Adds a new node with the specified value at the start of the linked list. 3. **Remove Node by Value**: - Method: `remove_node(value: T) -> None` - Description: Removes the first node with the specified value from the linked list. If the value is not found, raise a `ValueError`. 4. **Find Node by Value**: - Method: `find_node(value: T) -> Optional[Node[T]]` - Description: Finds the first node with the specified value and returns it. If the value is not found, return `None`. 5. **Clear List**: - Method: `clear_list() -> None` - Description: Clears all nodes from the linked list. 6. **Convert to List**: - Method: `to_list() -> List[T]` - Description: Converts the linked list to a regular Python list and returns it. # Constraints: - You can assume that `T` will always be hashable and comparable. - The solution should maintain efficiency, especially for operations involving edge cases. # Example: ```python # Example Usage linked_list = LinkedList[int]() linked_list.add_node_end(1) linked_list.add_node_start(0) linked_list.add_node_end(2) assert linked_list.to_list() == [0, 1, 2] linked_list.remove_node(1) assert linked_list.to_list() == [0, 2] assert linked_list.find_node(2).value == 2 linked_list.clear_list() assert linked_list.to_list() == [] ``` Implement the `LinkedList` class and the `Node` class with corresponding methods and ensure your implementation passes all necessary edge cases.","solution":"from typing import TypeVar, Generic, Optional, List T = TypeVar(\'T\') class Node(Generic[T]): def __init__(self, value: T): self.value = value self.next: Optional[\'Node[T]\'] = None self.prev: Optional[\'Node[T]\'] = None class LinkedList(Generic[T]): def __init__(self): self.head: Optional[Node[T]] = None self.tail: Optional[Node[T]] = None def add_node_end(self, value: T) -> None: new_node = Node(value) if not self.head: self.head = self.tail = new_node else: assert self.tail is not None # for mypy type checking self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def add_node_start(self, value: T) -> None: new_node = Node(value) if not self.head: self.head = self.tail = new_node else: self.head.prev = new_node new_node.next = self.head self.head = new_node def remove_node(self, value: T) -> None: current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next raise ValueError(\\"Value not found in the list\\") def find_node(self, value: T) -> Optional[Node[T]]: current = self.head while current: if current.value == value: return current current = current.next return None def clear_list(self) -> None: self.head = self.tail = None def to_list(self) -> List[T]: result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Question: Calculate the Intersection of Two Intervals Given two intervals, each defined by a start and an end, write a Python function to determine if the intervals intersect. If they do, the function should return the intersection interval. If they do not intersect, return `None`. The intersection of two intervals ([a, b]) and ([c, d]) is defined as: [ [max(a, c), min(b, d)] ] # Function Signature: ```python def interval_intersection(interval1: tuple[int, int], interval2: tuple[int, int]) -> tuple[int, int]|None: pass ``` # Input: - `interval1` (tuple): A tuple of two integers representing the first interval ([a, b]). - `interval2` (tuple): A tuple of two integers representing the second interval ([c, d]). # Output: - A tuple representing the intersection interval ([max(a, c), min(b, d)]) if they intersect, or `None` if they do not intersect. # Constraints: - The intervals are valid if (a leq b) and (c leq d). - The intersection interval should be valid if the start is less than or equal to the end; otherwise, return `None`. # Example: ```python >>> interval_intersection((1, 5), (2, 6)) (2, 5) >>> interval_intersection((1, 2), (3, 4)) None ``` # Notes: - Carefully handle edge cases when intervals just touch each other; the intersection in such cases should still be a valid interval. - Make sure to return `None` when there is no overlap between the intervals.","solution":"def interval_intersection(interval1: tuple[int, int], interval2: tuple[int, int]) -> tuple[int, int] | None: Determines the intersection of two intervals. Args: interval1 (tuple): A tuple of two integers representing the first interval [a, b]. interval2 (tuple): A tuple of two integers representing the second interval [c, d]. Returns: tuple: A tuple representing the intersection interval [max(a, c), min(b, d)] if they intersect, or None if they do not intersect. a, b = interval1 c, d = interval2 # Calculate the intersection interval start = max(a, c) end = min(b, d) # Check if the intersection is valid if start <= end: return (start, end) else: return None"},{"question":"# Scenario: A logistics company is trying to optimize its delivery routes. Part of the optimization process requires calculating the shortest distance between different delivery points in a city represented as a 2D grid. You are tasked with writing a function to calculate this distance based on the Manhattan distance metric. # Problem Statement: Write a function `manhattan_distance` that takes in the coordinates of two points in a 2D grid and returns the Manhattan distance between them. # Input: * `x1` (int): The x-coordinate of the first point. `x1` is an integer. * `y1` (int): The y-coordinate of the first point. `y1` is an integer. * `x2` (int): The x-coordinate of the second point. `x2` is an integer. * `y2` (int): The y-coordinate of the second point. `y2` is an integer. # Output: * `distance` (int): The Manhattan distance between the two points. # Constraints: * All input coordinates will be non-negative integers within the range [0, 10^6]. * Ensure the function handles large coordinates efficiently. # Performance Requirements: * The function must perform this operation in O(1) time complexity. * Optimize for low memory usage. # Function Signature: ```python def manhattan_distance(x1: int, y1: int, x2: int, y2: int) -> int: pass ``` # Examples: ```python manhattan_distance(1, 1, 4, 5) # Expected Output: 7 manhattan_distance(0, 0, 0, 0) # Expected Output: 0 manhattan_distance(3, 4, 7, 1) # Expected Output: 7 manhattan_distance(5, 5, 5, 10) # Expected Output: 5 ``` # Notes: * The Manhattan distance between two points ((x1, y1)) and ((x2, y2)) is calculated as (|x1 - x2| + |y1 - y2|). * Consider edge cases where the points may coincide, resulting in a distance of zero. * Do not use any external libraries for the calculations.","solution":"def manhattan_distance(x1: int, y1: int, x2: int, y2: int) -> int: Calculate the Manhattan distance between two points (x1, y1) and (x2, y2). Parameters: x1 (int): The x-coordinate of the first point. y1 (int): The y-coordinate of the first point. x2 (int): The x-coordinate of the second point. y2 (int): The y-coordinate of the second point. Returns: int: The Manhattan distance between the two points. return abs(x1 - x2) + abs(y1 - y2)"},{"question":"# Implement Merge Sort with Linked Lists # Objective: Implement the Merge Sort algorithm to sort a singly linked list of integers in ascending order. # Problem Statement: Write a function `merge_sort_linked_list` that sorts an input singly linked list of integers in ascending order using the Merge Sort algorithm. # Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: pass ``` # Input: - `head`: A `ListNode` object, representing the head of a singly linked list. The list may contain duplicate values. # Output: - A `ListNode` object, representing the head of the sorted singly linked list. # Constraints: - The linked list may contain 0 to 10^5 nodes. - The values in the list are within the range [-10^9, 10^9]. # Performance Requirements: - Average-case time complexity should be O(n log n). - Space complexity should be O(log n) due to the recursive call stack. # Example Scenario: Consider a situation where you are managing a system that processes extensive logs represented as linked lists. Efficiently sorting these logs for quick access and analysis is crucial. # Example: ```python # Helper function to print list def print_list(head): while head: print(head.val, end=\\" -> \\") head = head.next print(\\"None\\") # Create linked list: 4 -> 2 -> 1 -> 3 head = ListNode(4, ListNode(2, ListNode(1, ListNode(3)))) sorted_head = merge_sort_linked_list(head) print_list(sorted_head) # Output: 1 -> 2 -> 3 -> 4 -> None # Create linked list: -1 -> 5 -> 3 -> 4 -> 0 head = ListNode(-1, ListNode(5, ListNode(3, ListNode(4, ListNode(0))))) sorted_head = merge_sort_linked_list(head) print_list(sorted_head) # Output: -1 -> 0 -> 3 -> 4 -> 5 -> None ``` # Constraints to Keep in Mind: - Handle edge cases such as an empty list, a list with one element, and a list with all identical elements. - Ensure the implementation efficiently handles large datasets by testing with varied input sizes. # Helper Functions (if needed): You may use the following helper function templates to get started: ```python def get_middle(head: ListNode) -> ListNode: # This function should find and return the middle node of the linked list. pass def merge_sorted_lists(list1: ListNode, list2: ListNode) -> ListNode: # This function should merge two sorted linked lists and return the head of the merged list. pass ``` By following the above template, ensure that your `merge_sort_linked_list` function is efficient and adheres to the given guidelines.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head def get_middle(head): slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next return slow def merge_list(left, right): dummy = ListNode() tail = dummy while left and right: if left.val < right.val: tail.next, left = left, left.next else: tail.next, right = right, right.next tail = tail.next tail.next = left if left else right return dummy.next middle = get_middle(head) right_half = middle.next middle.next = None left_sorted = merge_sort_linked_list(head) right_sorted = merge_sort_linked_list(right_half) return merge_list(left_sorted, right_sorted)"},{"question":"# Question Context String manipulation is a fundamental aspect of computer programming, often involving tasks like reversing, concatenation, and substring identification. One common problem is finding different variations of substrings from a given string to solve complex problem-solving tasks. Imagine you are working on a software that, given a string, has to generate all the possible non-empty substrings and sort them lexicographically (in alphabetical order). Your task is to implement a function that handles this efficiently. Problem Statement Implement a function, `generate_sorted_substrings(s: str) -> list[str]`, that takes a string `s` and returns all possible non-empty substrings sorted in lexicographical order. 1. **generate_sorted_substrings(s: str) -> list[str]** - **Input**: - `s`: A string of lowercase English letters. - **Output**: - A list of strings representing all non-empty substrings of `s`, sorted lexicographically. - **Example**: ```python >>> generate_sorted_substrings(\\"abc\\") [\'a\', \'ab\', \'abc\', \'b\', \'bc\', \'c\'] ``` ```python >>> generate_sorted_substrings(\\"aab\\") [\'a\', \'a\', \'aa\', \'ab\', \'b\'] ``` 2. **Constraints**: - `1 <= len(s) <= 100` Additional Requirements - Your implementation should aim to generate and sort substrings efficiently to handle the given constraints. - Consider scenarios involving repeating characters and ensure correctness in the resultant sorted list.","solution":"def generate_sorted_substrings(s: str) -> list[str]: Generates all possible non-empty substrings of the given string and returns them sorted in lexicographical order. substrings = set() length = len(s) # Generate all possible non-empty substrings for i in range(length): for j in range(i + 1, length + 1): substrings.add(s[i:j]) # Convert set to list and sort lexicographically sorted_substrings = sorted(substrings) return sorted_substrings"},{"question":"# Problem Statement You are tasked with implementing a function that finds all the unique permutations of a given list of distinct numbers. A permutation of a list is a rearrangement of its elements. The output should be a list of lists, where each sublist represents a unique permutation of the input list. # Input/Output Formats - **Input**: - A list of distinct integers. Example: `[1, 2, 3]` - **Output**: - A list of lists, where each sublist represents a unique permutation of the input list. Example: `[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]` # Constraints - The number of elements in the list (`n`) is between 1 and 6 inclusive. - All elements in the list are distinct integers. # Example ```python input_list = [1, 2, 3] output = permute(input_list) print(output) # Expected Output: # [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] ``` # Task Implement the `permute` function that generates all unique permutations of a list of distinct numbers. The function should take a list of integers as input and return a list of lists, each representing a unique permutation of the input. ```python def permute(nums): # Your code here # Example usage input_list = [1, 2, 3] output = permute(input_list) print(output) # Expected Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ```","solution":"from itertools import permutations def permute(nums): Returns all unique permutations of the list of distinct numbers. return [list(p) for p in permutations(nums)] # Example usage input_list = [1, 2, 3] output = permute(input_list) print(output) # Expected Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"},{"question":"# Understanding of Sorting Algorithms through Implementation Objective Design and implement advanced sorting algorithms to reinforce your understanding of algorithmic efficiency and complexity. Task Extend the given `SortingAlgorithms` class by implementing the following sorting methods: 1. **Merge Sort**: Implement the merge sort algorithm which should sort a given list of integers in ascending order. 2. **Quick Sort**: Implement the quick sort algorithm which should sort a given list of integers in ascending order. 3. **Heap Sort**: Implement the heap sort algorithm which should sort a given list of integers in ascending order. Requirements - Ensure that your implementations handle edge cases such as empty input lists and lists containing duplicate values. - Your methods should follow these signatures: ```python def merge_sort(self, arr: list[int]) -> list[int]: pass def quick_sort(self, arr: list[int]) -> list[int]: pass def heap_sort(self, arr: list[int]) -> list[int]: pass ``` Input and Output Formats - **Merge, Quick, and Heap Sort** methods: - **Input**: List of integers `list[int]` - **Output**: Sorted list of integers in ascending order. Constraints - The input list can have up to 10,000 integers. - Ensure your functions are optimized for performance with large datasets. Example ```python # Sample input list arr = [34, 7, 23, 32, 5, 62] sorting = SortingAlgorithms() # Perform Merge Sort print(sorting.merge_sort(arr.copy())) # Example output: [5, 7, 23, 32, 34, 62] # Perform Quick Sort print(sorting.quick_sort(arr.copy())) # Example output: [5, 7, 23, 32, 34, 62] # Perform Heap Sort print(sorting.heap_sort(arr.copy())) # Example output: [5, 7, 23, 32, 34, 62] ``` Implement and test the functionalities with various input lists to ensure correctness and efficiency. This additional question tests competency in implementing, understanding, and optimizing common and advanced sorting algorithms. It challenges the candidate to work on sorting techniques, ensuring they handle edge cases and effectively manage performance constraints.","solution":"class SortingAlgorithms: def merge_sort(self, arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = self.merge_sort(arr[:mid]) right_half = self.merge_sort(arr[mid:]) return self._merge(left_half, right_half) def _merge(self, left, right): sorted_list = [] while left and right: if left[0] <= right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) sorted_list.extend(left or right) return sorted_list def quick_sort(self, arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return self.quick_sort(left) + middle + self.quick_sort(right) def heap_sort(self, arr): n = len(arr) for i in range(n // 2 - 1, -1, -1): self._heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] self._heapify(arr, i, 0) return arr def _heapify(self, arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] self._heapify(arr, n, largest)"},{"question":"# Coding Question Imagine you are working with a data encoding system that employs the run-length encoding (RLE) algorithm. The RLE algorithm is a simple form of lossless data compression in which runs of data (sequences in which the same data value occurs in many consecutive elements) are stored as a single data value and count. For example, the string \\"AAABBBCCDAA\\" would be encoded as \\"3A3B2C1D2A\\". Write a Python function that takes a string input and returns its RLE-encoded form. Additionally, write another function that takes an RLE-encoded string and returns the original uncompressed string. Function Implementations 1. `encode_rle(data: str) -> str` 2. `decode_rle(encoded: str) -> str` # Input - For `encode_rle`: A string `data` containing the original uncompressed data. - For `decode_rle`: A string `encoded` containing the RLE-compressed data. # Output - For `encode_rle`: - A string representing the RLE-compressed version of the original input. - For `decode_rle`: - A string representing the original uncompressed data from the RLE-encoded input. # Constraints - The input string `data` will only contain uppercase English letters (A-Z). - The encoded string will follow the format of alternating digits and uppercase letters, e.g., \\"3A3B2C1D2A\\". Example ```python # Input for Encoding data = \\"AAABBBCCDAA\\" # Function Call for Encoding encoded_data = encode_rle(data) # Expected Output for Encoding print(encoded_data) # Expected: \\"3A3B2C1D2A\\" # Input for Decoding encoded_data = \\"3A3B2C1D2A\\" # Function Call for Decoding decoded_data = decode_rle(encoded_data) # Expected Output for Decoding print(decoded_data) # Expected: \\"AAABBBCCDAA\\" ``` Your task is to correctly implement the `encode_rle` and `decode_rle` functions to achieve the RLE encoding and decoding as specified.","solution":"def encode_rle(data: str) -> str: Encodes the given string using Run-Length Encoding (RLE). :param data: The input string to encode. :return: The RLE-encoded string. if not data: return \\"\\" encoded = [] count = 1 prev_char = data[0] for char in data[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char encoded.append(f\\"{count}{prev_char}\\") # Don\'t forget the last run return \\"\\".join(encoded) def decode_rle(encoded: str) -> str: Decodes a Run-Length Encoded (RLE) string. :param encoded: The RLE-encoded string. :return: The original uncompressed string. if not encoded: return \\"\\" decoded = [] count = \\"\\" for char in encoded: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded)"},{"question":"# Merge Sorted Arrays into One Sorted Array **Context**: Merging sorted arrays is a common problem that demonstrates an understanding of algorithms, particularly sorting and merging techniques. This exercise will test your ability to combine multiple sorted arrays into one sorted array efficiently. **Objective**: Create a function `merge_sorted_arrays(arrays: List[List[int]]) -> List[int]` that takes a list of sorted integer arrays and merges them into a single sorted array. # Constraints: - Each sub-array in `arrays` is sorted in non-decreasing order. - The function should handle an arbitrary number of arrays, including edge cases like an empty list or a list with one empty array. - All integers in the input arrays are within the range of valid Python integers. **Function Signature**: ```python from typing import List def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: pass ``` # Input: - `arrays` (List[List[int]]): A list of lists, where each sub-list contains sorted integers. # Output: - A single list (List[int]) containing all integers from the input lists, sorted in non-decreasing order. # Examples: ```python >>> merge_sorted_arrays([[1, 3, 5], [2, 4, 6], [0, 7, 8]]) [0, 1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([[], [2, 3, 4], [1]]) [1, 2, 3, 4] >>> merge_sorted_arrays([[1, 2, 3], [], [4, 5, 6]]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([[], []]) [] >>> merge_sorted_arrays([[1]]) [1] ``` # Requirements: - The function should use efficient merging techniques, ideally with a time complexity better than O(n log n), where n is the total number of elements across all arrays. - Ensure the code is robust and correctly handles edge cases with empty arrays or lists. - Implement the function to minimize execution time and memory consumption, making efficient use of merging algorithms. # Additional Notes: - Consider using a min-heap to efficiently merge the arrays. - Pay attention to edge cases where one or more arrays might be empty. - Include error handling to deal with invalid input such as non-integer elements or arrays not being sorted.","solution":"from typing import List import heapq def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges multiple sorted arrays into a single sorted array. Args: arrays (List[List[int]]): A list of lists, where each sub-list contains sorted integers. Returns: List[int]: A single list containing all integers from the input lists, sorted in non-decreasing order. if not arrays: return [] # Initialize a heap and the result array min_heap = [] # Push the first element of each array into the heap for i in range(len(arrays)): if arrays[i]: heapq.heappush(min_heap, (arrays[i][0], i, 0)) result = [] # Extract the elements from the heap and add them to the result array while min_heap: val, list_index, element_index = heapq.heappop(min_heap) result.append(val) # If there is a next element in the same list, push it into the heap if element_index + 1 < len(arrays[list_index]): next_tuple = (arrays[list_index][element_index + 1], list_index, element_index + 1) heapq.heappush(min_heap, next_tuple) return result"},{"question":"Coding Assessment Question # Objective Implement a function to perform k-means clustering on a dataset, which will assess your understanding of clustering algorithms and numerical optimization. # Problem Statement You are given a dataset with `n` data points, each with `d` features, represented as a `n x d` numpy array. Your task is to write a function `k_means_clustering` that performs k-means clustering on this dataset and returns the cluster centroids and the cluster assignments for each data point. # Requirements 1. **Function Signature**: ```python def k_means_clustering(data: np.ndarray, k: int, num_iter: int) -> tuple[np.ndarray, np.ndarray]: ``` 2. **Input Format**: - `data` (numpy.ndarray): The dataset of shape (n, d), where `n` is the number of data points and `d` is the number of features. - `k` (int): The number of clusters to form. - `num_iter` (int): The number of iterations for the k-means algorithm. 3. **Output Format**: - Returns a tuple: - The first element is a numpy array of shape (k, d) representing the final cluster centroids. - The second element is a numpy array of shape (n,) representing the cluster assignment of each data point (values between 0 and k-1). 4. **Constraints**: - The input dataset `data` will have dimensions (n, d) where 1 ≤ n ≤ 1000 and 1 ≤ d ≤ 50. - Number of clusters `k` will be a positive integer (1 ≤ k ≤ n). - Number of iterations `num_iter` will be a positive integer (1 ≤ num_iter ≤ 300). 5. **Performance**: - Aim for an efficient implementation, using numpy operations for vectorized computation wherever possible. # Additional Notes Consider initializing the cluster centroids by selecting `k` data points randomly from the dataset. # Example ```python import numpy as np data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0], [9.0, 3.0] ]) k = 2 num_iter = 100 centroids, assignments = k_means_clustering(data, k, num_iter) print(\\"Centroids:n\\", centroids) print(\\"Cluster Assignments:n\\", assignments) ``` In the above code snippet, the function `k_means_clustering` takes the dataset, the number of clusters, and the number of iterations as input. The output includes the final cluster centroids and the cluster assignments for each data point.","solution":"import numpy as np def k_means_clustering(data: np.ndarray, k: int, num_iter: int) -> tuple[np.ndarray, np.ndarray]: Performs k-means clustering on a dataset. Parameters: data (numpy.ndarray): Dataset with shape (n, d). k (int): Number of clusters. num_iter (int): Number of iterations. Returns: tuple: A tuple containing: - Cluster centroids (numpy.ndarray) with shape (k, d). - Cluster assignments (numpy.ndarray) with shape (n,). n, d = data.shape # Randomly initialize cluster centroids centroids_idx = np.random.choice(n, k, replace=False) centroids = data[centroids_idx] for _ in range(num_iter): # Assign each data point to the nearest centroid distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) assignments = np.argmin(distances, axis=1) # Update centroids new_centroids = np.array([data[assignments == i].mean(axis=0) for i in range(k)]) # If centroids do not change, break the loop early if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, assignments"},{"question":"# Coding Assessment Question Scenario You are part of a team developing a text editor. One of the features you need to implement is an autocomplete function for suggesting words based on the user\'s input. The system should use a prefix tree (trie) to enable efficient prefix-based searches. Task Implement an `AutocompleteSystem` that supports the functionalities described below. The system should allow adding words to the trie and suggest words based on a given prefix. Guidelines - Implement the `AutocompleteSystem` class with the following methods: - `__init__(self)`: Initializes the trie structure. - `add_word(self, word: str)`: Adds a word to the trie. - `get_autocomplete(self, prefix: str)`: Returns a list of words in the trie that start with the given prefix. - Your implementation should support handling an empty trie and common edge cases, such as no matching words for a given prefix. Class Signature ```python class AutocompleteSystem: def __init__(self): pass def add_word(self, word: str): pass def get_autocomplete(self, prefix: str) -> list: pass ``` Input/Output - `add_word` method: - `word`: A string representing the word to be added to the trie. - `get_autocomplete` method: - `prefix`: A string representing the prefix to search for in the trie. - Returns a list of strings that are words in the trie and start with the given prefix. Constraints - Words and prefixes consist of only lowercase English letters. - The length of any word and prefix does not exceed 100 characters. - The number of words added to the trie will not exceed 10^4. Example ```python autocomplete = AutocompleteSystem() autocomplete.add_word(\'apple\') autocomplete.add_word(\'app\') autocomplete.add_word(\'application\') autocomplete.add_word(\'banana\') autocomplete.add_word(\'bandana\') assert autocomplete.get_autocomplete(\'app\') == [\'apple\', \'app\', \'application\'] assert autocomplete.get_autocomplete(\'ban\') == [\'banana\', \'bandana\'] assert autocomplete.get_autocomplete(\'cat\') == [] ``` Performance Considerations - The `get_autocomplete` method should be optimized for fast prefix search with a time complexity close to O(k + m), where k is the length of the prefix and m is the number of matching words.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def add_word(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def get_autocomplete(self, prefix: str) -> list: def dfs(node, prefix_path): if node.is_end_of_word: results.append(prefix_path) for char, child_node in node.children.items(): dfs(child_node, prefix_path + char) node = self.root results = [] for char in prefix: if char not in node.children: return [] node = node.children[char] dfs(node, prefix) return results"},{"question":"# Problem: Implement a Priority Queue Using a Min Binary Heap You are tasked with implementing a priority queue using a Min Binary Heap. A Min Binary Heap is a complete binary tree where the value at the root is the minimum of all the values in the tree. Each parent node is less than or equal to its child nodes. Your class should support the following operations efficiently: 1. `insert(val)`: Add a new element to the heap. 2. `extract_min()`: Remove and return the minimum element from the heap. 3. `get_min()`: Return the minimum element without removing it. 4. `is_empty()`: Return `True` if the heap is empty, `False` otherwise. # Function Signatures ```python class MinHeap: def __init__(self): pass def insert(self, val: int) -> None: pass def extract_min(self) -> int: pass def get_min(self) -> int: pass def is_empty(self) -> bool: pass ``` # Requirements: 1. **Heap Initialization**: Implement the `__init__` method to initialize an empty heap. 2. **Insertion**: Implement the `insert` method to add a new value to the heap, maintaining heap property. 3. **Extraction**: Implement the `extract_min` method to remove and return the smallest value in the heap, maintaining heap property. 4. **Get Minimum**: Implement the `get_min` method to return the smallest value without removing it. 5. **Heap State**: Implement the `is_empty` method to check if the heap is empty. 6. **Heap Property Maintenance**: Ensure the heap property (min-heap order) is maintained after each insertion and extraction operation. # Constraints: - You may assume all elements inserted into the heap are integers. - The heap should dynamically handle an arbitrarily large number of elements. - You should handle edge cases such as extracting from an empty heap appropriately. # Example: ```python >>> heap = MinHeap() >>> heap.is_empty() True >>> heap.insert(3) >>> heap.insert(1) >>> heap.insert(2) >>> heap.is_empty() False >>> heap.get_min() 1 >>> heap.extract_min() 1 >>> heap.get_min() 2 >>> heap.insert(0) >>> heap.get_min() 0 >>> heap.extract_min() 0 >>> heap.extract_min() 2 >>> heap.extract_min() 3 >>> heap.is_empty() True ```","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: self.heap.append(val) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: if self.is_empty(): raise IndexError(\\"extract_min() called on empty heap\\") self._swap(0, len(self.heap) - 1) min_val = self.heap.pop() self._heapify_down(0) return min_val def get_min(self) -> int: if self.is_empty(): raise IndexError(\\"get_min() called on empty heap\\") return self.heap[0] def is_empty(self) -> bool: return len(self.heap) == 0 def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self._swap(index, parent_index) self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self._swap(index, smallest) self._heapify_down(smallest) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"# Coding Question Context A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. Finding the nth prime number is a common task in mathematics and computer science, often requiring efficient algorithms due to the potential size of prime numbers. Task Write a function to find the nth prime number. The function should be able to handle inputs large enough that brute-force methods will be too slow. Function Signature ```python def nth_prime_number(n: int) -> int: Finds the nth prime number. :param n: The position of the prime number to find. :return: The nth prime number. >>> nth_prime_number(1) 2 >>> nth_prime_number(5) 11 >>> nth_prime_number(10) 29 pass ``` Input * An integer `n` (`1 <= n <= 10,000`). Output * An integer that represents the nth prime number. Constraints * Implement an efficient algorithm for calculating large prime numbers. * Consider using algorithms such as the Sieve of Eratosthenes or optimized trial division. Example ```python print(nth_prime_number(1)) # Should return 2 print(nth_prime_number(5)) # Should return 11 print(nth_prime_number(10)) # Should return 29 ```","solution":"def nth_prime_number(n: int) -> int: Finds the nth prime number using Sieve of Eratosthenes. :param n: The position of the prime number to find. :return: The nth prime number. if n < 1: raise ValueError(\\"n must be a positive integer.\\") def sieve_of_eratosthenes(limit): primes = [] sieve = [True] * (limit+1) sieve[0] = sieve[1] = False for start in range(2, limit+1): if sieve[start]: primes.append(start) for multiple in range(start*start, limit+1, start): sieve[multiple] = False return primes # Estimate upper bound using heuristic for nth prime: nth_prime ~ n * log(n*log(n)) import math if n < 6: upper_bound = 15 else: upper_bound = int(n * math.log(n * math.log(n))) + 1 primes = sieve_of_eratosthenes(upper_bound) return primes[n-1]"},{"question":"# Problem Statement You are required to implement two utility functions: `url_encode` and `url_decode`. These functions will perform encoding of a string by converting special characters into a URL-safe format and decoding such URL-encoded strings back into their original format correspondingly. **Function 1: `url_encode`** - **Input**: A `str` object `data`. - **Output**: A `str` object representing the corresponding URL-encoded version of the input data. - **Constraints**: - The `data` can contain any printable ASCII character (from space to tilde, `0x20` to `0x7E`). - Spaces must be converted to `+` and other special characters must be percent-encoded. **Function 2: `url_decode`** - **Input**: A `str` object `data` representing URL-encoded data. - **Output**: A `str` object which is the decoded representation of the input data. - **Constraints**: - The input `data` may contain `+` which should be converted back to space, and percent-encoded sequences. - If the input data contains invalid percent-encoded sequences (like `%XY` where `X` and `Y` are not valid hex digits), the function should raise a `ValueError` with the message `Invalid percent-encoded sequence`. # Example ```python def url_encode(data: str) -> str: \'\'\' This function encodes the input string into a URL-safe format. \'\'\' pass # TODO: Write the implementation here def url_decode(data: str) -> str: \'\'\' This function decodes the input URL-encoded string back into the original format. \'\'\' pass # TODO: Write the implementation here # Test Cases assert url_encode(\\"Hello World!\\") == \\"Hello+World%21\\" assert url_encode(\\"Hello+World!\\") == \\"Hello%2BWorld%21\\" assert url_encode(\\"A space and a /\\") == \\"A+space+and+a+%2F\\" assert url_encode(\\"\\") == \\"\\" assert url_decode(\\"Hello+World%21\\") == \\"Hello World!\\" assert url_decode(\\"Hello%2BWorld%21\\") == \\"Hello+World!\\" assert url_decode(\\"A+space+and+a+%2F\\") == \\"A space and a /\\" assert url_decode(\\"\\") == \\"\\" try: url_decode(\\"Hello%2GWorld\\") except ValueError as e: assert str(e) == \\"Invalid percent-encoded sequence\\" ``` **Additional Note**: - Ensure your code handles edge cases and invalid inputs appropriately, raising exceptions with meaningful messages. - The implementation should be efficient and correctly process very large input data within the constraints.","solution":"import urllib.parse def url_encode(data: str) -> str: This function encodes the input string into a URL-safe format. if not isinstance(data, str): raise TypeError(\\"The input must be a string.\\") return urllib.parse.quote_plus(data) def url_decode(data: str) -> str: This function decodes the input URL-encoded string back into the original format. if not isinstance(data, str): raise TypeError(\\"The input must be a string.\\") try: return urllib.parse.unquote_plus(data) except ValueError: raise ValueError(\\"Invalid percent-encoded sequence\\")"},{"question":"# Coding Question: Implement a Function to Check for Cyclic Dependencies in a Directed Graph Given a directed graph represented as an adjacency list, write a function `is_cyclic` that determines if the graph contains any cycles. A cycle in a directed graph is a path that starts and ends at the same vertex and involves at least one edge. **Function Signature**: ```python def is_cyclic(graph: dict[int, list[int]]) -> bool: ``` **Input**: - A dictionary `graph` where the key is a node (represented as an integer) and the value is a list of integers representing its adjacent nodes. **Output**: - Return `True` if there is a cycle in the graph. - Return `False` otherwise. **Constraints**: - The graph will have no more than 1000 nodes. - Node indices are non-negative integers. - The graph may be disconnected. **Examples**: Example 1: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } print(is_cyclic(graph)) ``` Expected output: ```python True ``` Example 2: ```python graph = { 0: [1], 1: [2], 2: [3], 3: [] } print(is_cyclic(graph)) ``` Expected output: ```python False ``` **Considerations**: - Handle edge cases like an empty graph, graph with no edges, and graphs with self-loops. - The function should efficiently handle large graphs with up to 1000 nodes. # Explanation: This question tests the knowledge of graph theory and algorithms to detect cycles in directed graphs. The candidate is expected to implement a cycle detection mechanism, potentially using Depth-First Search (DFS) with recursion stack or Kahn\'s algorithm using topological sorting. The question covers handling various graph structures and reinforces the understanding of directed graphs and cycle properties.","solution":"def is_cyclic(graph): Returns True if there is a cycle in the directed graph, otherwise False. # Helper function to perform DFS and check for cycles def dfs(node, visited, rec_stack): # Mark the node as visited and add it to the recursion stack visited[node] = True rec_stack[node] = True # Recur for all neighbors for neighbor in graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True # Remove the node from the recursion stack rec_stack[node] = False return False visited = {node: False for node in graph} rec_stack = {node: False for node in graph} # Check each node in case the graph is disconnected for node in graph: if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Scenario You\'re building a small software to manage a list of scheduled tasks. Each task has a start time and an end time, and you want to ensure there are no overlapping tasks when adding a new one to the list. # Task Implement a function `can_add_task` that determines if a new task can be added to the list without overlapping with any existing tasks. Each task is represented by a tuple of two integers `(start, end)`. # Function Signature ```python def can_add_task(tasks: list, new_task: tuple) -> bool: ``` # Input * `tasks`: A list of tuples where each tuple represents the start and end times of an existing task. Each task is a tuple of two integers `(start, end)` where `0 <= start < end <= 10^6`. * `new_task`: A tuple of two integers `(start, end)` where `0 <= start < end <= 10^6` representing the new task to be added. # Output * A boolean value indicating whether the new task can be added without any overlapping. # Constraints - The existing tasks and the new task\'s start and end times are given in the 24-hour format as integers. - The tasks are not necessarily sorted. # Example ```python can_add_task([(1, 3), (5, 6), (8, 10)], (2, 4)) # Output: False can_add_task([(1, 3), (5, 6), (8, 10)], (6, 8)) # Output: True can_add_task([], (2, 3)) # Output: True can_add_task([(1, 3), (5, 6)], (3, 5)) # Output: True can_add_task([(1, 3), (4, 6)], (3, 4)) # Output: True ``` # Hints * Consider how two tasks might overlap and the conditions that must be met to avoid overlaps. * Think through sorting the tasks or using a linear scan technique as efficient approaches to solve the problem.","solution":"def can_add_task(tasks, new_task): Determines if a new task can be added to the list of existing tasks without overlapping with any of them. Arguments: tasks -- List of tuples representing existing tasks (start, end) new_task -- Tuple representing the new task (start, end) Returns: Boolean value indicating whether the new task can be added without overlapping new_start, new_end = new_task for start, end in tasks: if not (new_end <= start or new_start >= end): return False return True"},{"question":"# Matrix Multiplication You are asked to implement a function to perform matrix multiplication. You will be given two matrices and your task is to return their product. If the matrices cannot be multiplied due to dimensional incompatibility, return an empty list. Problem Statement Implement the following function in Python: 1. **`matrix_multiply(A: list, B: list) -> list`**: - This function takes two matrices `A` and `B` represented as 2D lists and returns their product matrix. - **Input**: - `A`: a matrix represented as a 2D list - `B`: a matrix represented as a 2D list - **Output**: A 2D list representing the product of the matrices `A` and `B`, or an empty list if they cannot be multiplied. # Example ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiply(A, B) print(result) # Output: [[58, 64], [139, 154]] ``` In this example, matrix `A` is of size 2x3 and matrix `B` is of size 3x2. Their product is a 2x2 matrix. Here\'s another example with incompatible matrices: ```python A = [ [1, 2], [3, 4] ] B = [ [5, 6, 7], [8, 9, 10], [11, 12, 13] ] result = matrix_multiply(A, B) print(result) # Output: [] ``` In this case, matrix `A` is of size 2x2 and `B` is of size 3x3, so they cannot be multiplied. # Additional Details Ensure you handle different edge cases such as: - One or both matrices being empty - Incommensurable dimensions that prevent matrix multiplication - Square as well as non-square matrices. You may assume all input matrices contain integers and are valid 2D lists.","solution":"def matrix_multiply(A, B): Multiply two matrices A and B. Args: - A (list of list of int): matrix A - B (list of list of int): matrix B Returns: - list of list of int: the product of the matrices A and B if not A or not B: return [] # Number of columns in A must be equal to number of rows in B if len(A[0]) != len(B): return [] # Compute the product matrix result = [[0] * len(B[0]) for _ in range(len(A))] for i in range(len(A)): for j in range(len(B[0])): for k in range(len(A[0])): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Sum of Digits in Factorial Context Given a positive integer, calculating its factorial can result in a very large number. A common mathematical challenge is to compute the sum of the digits of these large factorials. For this task, you are required to write a function that calculates the sum of the digits of the factorial of a given number `n`. Task Write a function `sum_of_digits_in_factorial(n: int) -> int` that returns the sum of the digits of the factorial of `n`. Example ``` Input: 5 Output: 3 Explanation: The factorial of 5 is 120, and the sum of the digits is 1 + 2 + 0 = 3. Input: 10 Output: 27 Explanation: The factorial of 10 is 3628800, and the sum of the digits is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27. ``` # Constraints - Input `n` is an integer such that 1 ≤ n ≤ 100. - Ensure that the function handles large integers resulting from the factorial computation accurately.","solution":"import math def sum_of_digits_in_factorial(n: int) -> int: Returns the sum of the digits of the factorial of `n`. Parameters: n (int): A positive integer whose factorial\'s digits sum is to be calculated. Returns: int: Sum of digits of the factorial of `n`. factorial_result = math.factorial(n) return sum(int(digit) for digit in str(factorial_result))"},{"question":"# Problem Statement Objective Write a program in language L that checks whether the characters of a given string can be rearranged to form a palindrome. Motivation This task evaluates your understanding of string manipulation, frequency counting, and basic algorithm techniques. # Requirements 1. **Input**: A single string `s`. 2. **Output**: A boolean value (True or False) indicating whether the characters of the string can be rearranged to form a palindrome. # Constraints - The input string will contain only lowercase alphabets (a-z). - The length of the input string will not exceed 1000 characters. # Performance - The implementation should execute in O(n) time complexity, where n is the length of the input string. # Specification Example Consider the following test cases for clarity: - For the input `s = \\"civic\\"`, the output should be `True` (since \\"civic\\" is already a palindrome). - For the input `s = \\"ivicc\\"`, the output should be `True` (since the characters can be rearranged to form \\"civic\\"). - For the input `s = \\"hello\\"`, the output should be `False` (since no rearrangement can form a palindrome). # Hint A string can form a palindrome if at most one character has an odd frequency count, while all other characters have even frequencies. Notes - Focus on efficient string processing techniques to handle the constraints effectively. - Consider using a hash map or dictionary to count character frequencies and determine the eligibility for palindromic rearrangement.","solution":"def can_form_palindrome(s): Checks whether the characters of the given string can be rearranged to form a palindrome. Parameters: s (str): The input string containing only lowercase alphabets. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"# Problem Statement An app development company maintains a server log of user actions represented as unique strings, indicating user interaction data. The company wants to analyze these logs by counting the frequency of each unique user action and arranging the actions based on their frequency in descending order. If two actions have the same frequency, they should be arranged alphabetically in ascending order by their action strings. You are tasked to implement a function that counts how often each action appears in the list and returns a list of tuples, each containing an action and its frequency, sorted as described. Function Signature ```python def sort_actions_by_frequency(actions: list[str]) -> list[tuple[str, int]]: Counts the frequency of each unique action and sorts them by frequency in descending order. For actions with the same frequency, it sorts them alphabetically in ascending order. :param actions: List of action strings recorded in the server log. :return: List of tuples, each containing an action and its frequency, sorted by the specified order. ``` Input - `actions`: A list of action strings, where each string is a recorded user action. Output - A list of tuples where each tuple contains a string (the action) and an integer (the frequency of that action). The list is sorted by the frequency of the actions in descending order, and by the action string alphabetically in ascending order for ties in frequency. Constraints - The list may contain up to (10^5) action strings. - The action strings contain only alphabetic characters and have a length between 1 and 20 characters. Example ```python assert sort_actions_by_frequency([\\"login\\", \\"logout\\", \\"login\\", \\"play\\", \\"play\\", \\"play\\", \\"purchase\\", \\"logout\\", \\"play\\"]) == [(\\"play\\", 4), (\\"login\\", 2), (\\"logout\\", 2), (\\"purchase\\", 1)] assert sort_actions_by_frequency([\\"actionA\\", \\"actionB\\", \\"actionC\\", \\"actionA\\", \\"actionB\\", \\"actionA\\"]) == [(\\"actionA\\", 3), (\\"actionB\\", 2), (\\"actionC\\", 1)] ``` Write an efficient implementation of the `sort_actions_by_frequency` function to handle the specified performance considerations and edge cases.","solution":"from collections import Counter def sort_actions_by_frequency(actions: list[str]) -> list[tuple[str, int]]: Counts the frequency of each unique action and sorts them by frequency in descending order. For actions with the same frequency, it sorts them alphabetically in ascending order. :param actions: List of action strings recorded in the server log. :return: List of tuples, each containing an action and its frequency, sorted by the specified order. # Count the frequency of each action frequency = Counter(actions) # Sort actions by frequency in descending order, then alphabetically in ascending order sorted_actions = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) return sorted_actions"},{"question":"# Binary Search & Array Manipulation Context You\'re working on enhancing the performance of a large data processing application, which involves frequent lookups and insertions into a sorted list. To achieve this, you need to implement an optimized search and insertion routine. Task Write a function called `search_and_insert` that performs a binary search on a sorted list to find the position of a target value. If the target value is not found, the function should insert the target value into its correct position to maintain the list\'s sorted order. Function Signature ```python def search_and_insert(arr: list[int], target: int) -> int: pass ``` Input * `arr` (list[int]): A list of integers sorted in non-decreasing order. * `target` (int): The integer value to search for and possibly insert into the list. Output * `index` (int): The index where the target value was found, or the index where it was inserted. Constraints * The list can have up to (10^5) elements. * All integers in the list and the target value are between (-10^9) and (10^9). * The list does not contain duplicate values. Example ```python def test_search_and_insert(): arr = [1, 3, 5, 7, 9] # Case 1: Target is found in the array index = search_and_insert(arr, 5) assert index == 2 assert arr == [1, 3, 5, 7, 9] # Case 2: Target is not found and needs to be inserted index = search_and_insert(arr, 6) assert index == 3 assert arr == [1, 3, 5, 6, 7, 9] # Case 3: Target is smaller than all elements (insert at beginning) index = search_and_insert(arr, 0) assert index == 0 assert arr == [0, 1, 3, 5, 6, 7, 9] # Case 4: Target is larger than all elements (insert at end) index = search_and_insert(arr, 10) assert index == 7 assert arr == [0, 1, 3, 5, 6, 7, 9, 10] print(\\"All tests passed!\\") test_search_and_insert() ``` You should also consider writing additional test cases to cover edge cases such as insertion at the beginning and the end of the list, and the smallest and largest possible values for the target.","solution":"def search_and_insert(arr: list[int], target: int) -> int: Performs a binary search on a sorted list to find the position of the target value. If the target value is not found, inserts the target value into its correct position to maintain the list\'s sorted order and returns the index where it was inserted. Args: arr (list[int]): A list of integers sorted in non-decreasing order. target (int): The integer value to search for and possibly insert into the list. Returns: int: The index where the target value was found, or the index where it was inserted. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 arr.insert(left, target) return left"},{"question":"# Graph Traversal Using Depth-First Search You are given a class `Graph` that represents an undirected graph using an adjacency list. The graph supports the following operations: - `add_edge(v1, v2)`: adds an edge between vertices `v1` and `v2`. Your task is to enhance the functionality of the `Graph` class by implementing additional utility functions for depth-first search (DFS): 1. **dfs(start)**: Performs a DFS beginning from the `start` vertex and returns a list of vertices in the order they are visited. 2. **has_path(start, end)**: Checks if there is a path between the `start` and `end` vertices using DFS. 3. **connected_components()**: Identifies and returns a list of all connected components in the graph. Each connected component is represented as a list of vertices. # Specification Method Signature ```python def dfs(self, start: int) -> list[int] def has_path(self, start: int, end: int) -> bool def connected_components(self) -> list[list[int]] ``` Input - For `dfs` and `has_path`, the inputs are integers representing vertex IDs of the graph. - For `connected_components`, there are no inputs since it operates directly on the graph instance. Output - `dfs` returns a list of integers depicting the vertices in the order they were visited. - `has_path` returns a boolean indicating whether there is a path from the `start` vertex to the `end` vertex. - `connected_components` returns a list of lists, where each inner list represents a connected component of the graph. Constraints - The graph can have up to 1000 vertices. - There will be no self-loops or multiple edges between the same pair of vertices. - The graph can be disconnected. - All vertex identifiers are integers starting from zero. Example ```python g = Graph() g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(3, 4) assert g.dfs(0) == [0, 1, 2] # Order of visits may vary assert g.dfs(3) == [3, 4] # Order of visits may vary assert g.has_path(0, 2) == True assert g.has_path(0, 4) == False components = g.connected_components() components.sort() expected_components = [[0, 1, 2], [3, 4]] for component in components: component.sort() assert components == expected_components ``` Use the existing `Graph` class framework to implement these additional functionalities. *The class definition for `Graph` and provided sample input/output are illustrative; you must develop the DFS-related methods accordingly.*","solution":"class Graph: def __init__(self): self.graph = {} def add_edge(self, v1, v2): if v1 not in self.graph: self.graph[v1] = [] if v2 not in self.graph: self.graph[v2] = [] self.graph[v1].append(v2) self.graph[v2].append(v1) def dfs(self, start: int): visited = set() result = [] def dfs_visit(vertex): visited.add(vertex) result.append(vertex) for neighbor in self.graph.get(vertex, []): if neighbor not in visited: dfs_visit(neighbor) dfs_visit(start) return result def has_path(self, start: int, end: int) -> bool: visited = set() def dfs_check(vertex): if vertex == end: return True visited.add(vertex) for neighbor in self.graph.get(vertex, []): if neighbor not in visited: if dfs_check(neighbor): return True return False return dfs_check(start) def connected_components(self) -> list[list[int]]: visited = set() components = [] def dfs_collect(start): component = [] stack = [start] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) component.append(vertex) for neighbor in self.graph.get(vertex, []): if neighbor not in visited: stack.append(neighbor) return component for vertex in self.graph: if vertex not in visited: component = dfs_collect(vertex) components.append(component) return components"},{"question":"# Scenario A company wants to analyze the browsing patterns of their website users. They have a logfile that records user actions with timestamps, and they aim to identify the most frequently visited page within a specified time window. You need to write a Python function to process this log and determine the most visited page. # Problem Statement Implement the function `most_visited_page(log: List[Tuple[str, str]], start_time: str, end_time: str) -> str` which returns the most frequently visited page within the given time window. The log is a list of tuples where each tuple contains a timestamp (in the format `\'YYYY-MM-DD HH:MM:SS\'`) and a page URL. The `start_time` and `end_time` are also provided as strings in the same format. # Function Signature ```python def most_visited_page(log: List[Tuple[str, str]], start_time: str, end_time: str) -> str: ``` # Input - `log` (List[Tuple[str, str]]): A list of tuples where each tuple consists of: - A timestamp string in the format `\'YYYY-MM-DD HH:MM:SS\'`. - A page URL string. - `start_time` (str): The start of the time window in the format `\'YYYY-MM-DD HH:MM:SS\'`. - `end_time` (str): The end of the time window in the format `\'YYYY-MM-DD HH:MM:SS\'`. # Output - `str`: The most frequently visited page URL within the specified time window. # Constraints - The `log` list can contain up to 10,000 entries. - There can be multiple pages with the same maximum count; in that case, return the lexicographically smallest URL. - `start_time` will always be less than or equal to `end_time`. # Examples ```python log = [ (\\"2023-01-01 12:00:00\\", \\"/home\\"), (\\"2023-01-01 12:00:05\\", \\"/about\\"), (\\"2023-01-01 12:01:00\\", \\"/home\\"), (\\"2023-01-01 12:02:00\\", \\"/contact\\"), (\\"2023-01-01 12:03:00\\", \\"/home\\"), (\\"2023-01-01 12:03:05\\", \\"/about\\") ] most_visited_page(log, \\"2023-01-01 12:00:00\\", \\"2023-01-01 12:03:00\\") -> \\"/home\\" most_visited_page(log, \\"2023-01-01 12:02:00\\", \\"2023-01-01 12:03:00\\") -> \\"/contact\\" ``` # Guidelines 1. First parse the log entries to filter out those within the given time window. 2. Use a dictionary to count the occurrences of each page URL within the specified time window. 3. Identify the page URL with the highest count and account for ties by selecting the lexicographically smallest URL. 4. Utilize Python\'s datetime library to handle timestamp comparisons efficiently. # Hints - Ensure your solution handles edge cases where no logs fall within the specified time window. - Account for scenarios where the log contains duplicate timestamps and URLs.","solution":"from typing import List, Tuple from collections import defaultdict from datetime import datetime def most_visited_page(log: List[Tuple[str, str]], start_time: str, end_time: str) -> str: # Convert start_time and end_time to datetime objects for comparison start_dt = datetime.strptime(start_time, \'%Y-%m-%d %H:%M:%S\') end_dt = datetime.strptime(end_time, \'%Y-%m-%d %H:%M:%S\') page_count = defaultdict(int) for timestamp, url in log: log_time = datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') if start_dt <= log_time <= end_dt: page_count[url] += 1 # Find the page with the highest count and lexicographically smallest in case of ties max_count = 0 most_visited = None for page, count in page_count.items(): if count > max_count or (count == max_count and page < most_visited): max_count = count most_visited = page return most_visited"},{"question":"# Context You are tasked with developing a text-based analysis tool that evaluates the frequency of word usage in a given document. The objective is to identify the most common words and their respective counts, excluding any common English stop words. # Task Write a Python function that takes a string representing a document and returns a dictionary containing the ten most frequent non-stop words and their respective counts. # Function Signature ```python def most_common_words(document: str) -> dict[str, int]: pass ``` # Input - `document` (str): A string representing the text of the document. # Output A dictionary with the ten most frequent words (excluding stop words) as keys and their counts as values. If there are fewer than ten unique words in the document, return a dictionary with all unique words and their counts. # Constraints - The document will have a maximum length of 10,000 characters. - Stop words to exclude are: \\"the\\", \\"is\\", \\"in\\", \\"and\\", \\"to\\", \\"a\\", \\"with\\", \\"that\\", \\"for\\", \\"on\\". - The function should be case-insensitive (i.e., \\"The\\" and \\"the\\" should be treated as the same word). - Punctuation should be ignored, and words should be considered based on alphabetical characters only. # Example ```python document = \\"The quick brown fox jumps over the lazy dog. The dog is not amused.\\" expected_output = { \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"over\\": 1, \\"lazy\\": 1, \\"dog\\": 2, \\"not\\": 1, \\"amused\\": 1 } assert most_common_words(document) == expected_output ``` # Additional Notes - Ensure the function correctly handles edge cases where the document may be empty or contain only stop words. - Normalize all words to lowercase to ensure consistent frequency counts.","solution":"import re from collections import Counter def most_common_words(document: str) -> dict[str, int]: stop_words = {\\"the\\", \\"is\\", \\"in\\", \\"and\\", \\"to\\", \\"a\\", \\"with\\", \\"that\\", \\"for\\", \\"on\\"} # Normalize the document to lowercase and use regex to find words words = re.findall(r\'bw+b\', document.lower()) # Filter out the stop words filtered_words = [word for word in words if word not in stop_words] # Count the frequencies of the remaining words word_counts = Counter(filtered_words) # Get the 10 most common words most_common = word_counts.most_common(10) return dict(most_common) # Example usage: # document = \\"The quick brown fox jumps over the lazy dog. The dog is not amused.\\" # print(most_common_words(document))"},{"question":"# Problem: Evaluate Arithmetic Expression from a File You are given a file containing multiple arithmetic expressions, one per line. Each expression can contain positive integers and the operators `+`, `-`, `*`, and `/`. Your task is to write a program that reads the file, evaluates each arithmetic expression, and returns a list of the results. Input * A string `filename` which denotes the path to the file containing the arithmetic expressions. The file will contain one expression per line, formatted as a valid arithmetic expression with integers and operators like so: ``` 3+5*2 10/2-3 6+9/3*2 ``` Output * A list of floats or integers, each representing the result of evaluating the corresponding arithmetic expression from the file. Constraints * The expressions will contain valid positive integers and the arithmetic operators `+`, `-`, `*`, and `/`. * The file will contain exactly 1000 lines. * Division by zero will not occur in any of the expressions. Example Given this sample text file `expressions.txt`: ``` 3+5*2 10/2-3 6+9/3*2 ``` Your function should return `[13, 2.0, 12]`. Function Signature ```python def evaluate_expressions_from_file(filename: str) -> list: ``` # Notes * Use Python\'s `eval` function or similar methods to evaluate expressions efficiently. * Ensure to handle file reading and parsing efficiently.","solution":"def evaluate_expressions_from_file(filename: str) -> list: Reads a file containing arithmetic expressions and evaluates each line. Parameters: filename (str): The path to the file containing the arithmetic expressions. Returns: list: A list of results from evaluating each expression in the file. results = [] with open(filename, \'r\') as file: for line in file.readlines(): expression = line.strip() result = eval(expression) results.append(result) return results"},{"question":"# Maze Pathfinder Scenario You are working on a robotic system designed to navigate through a grid-based maze. The robot needs to find its way from the top-left corner (starting point) to the bottom-right corner (target point). Task Write a function `find_path` that takes a 2D grid representing the maze and returns the path from the start to the target as a list of coordinates. The robot can only move up, down, left, or right but not diagonally, and it cannot pass through walls. Function Definition ```python def find_path(maze: list[list[int]]) -> list[tuple[int, int]]: ``` Input - A 2D list of integers representing the maze, where: - `0` represents open spaces. - `1` represents walls. - The dimensions of the maze are `m x n` where `2 <= m, n <= 100`. - Example: ```python [ [0, 0, 1, 0], [1, 0, 1, 0], [1, 0, 0, 0], [0, 1, 0, 0] ] ``` Output - A list of tuples representing the path from the starting point `(0, 0)` to the target point `(m-1, n-1)`. - Example output: `[(0, 0), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3)]` - If no path exists, the function should return an empty list. Constraints - The maze contains at least one open space at the top-left corner `(0, 0)` and at the bottom-right corner `(m-1, n-1)`. Performance Requirements - Aim for a time complexity of O(m * n), utilizing BFS (Breadth-First Search) for finding the shortest path. Validation Scenarios To validate your solution, it should pass these examples: ```python assert find_path([ [0, 0, 1, 0], [1, 0, 1, 0], [1, 0, 0, 0], [0, 1, 0, 0] ]) == [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3)] assert find_path([ [0, 1], [1, 0] ]) == [] ``` Special Cases - The function should handle edge cases such as: * The maze having no possible path due to the blockade of walls. * The maze being a 2x2 grid with a straightforward path.","solution":"from collections import deque def find_path(maze): Finds the path from the top-left corner to the bottom-right corner in a grid-based maze. Args: maze (list of list of int): A 2D grid representing the maze. Returns: list of tuple: A list of coordinates representing the path, or an empty list if no path exists. if not maze or not maze[0]: return [] m, n = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and maze[x][y] == 0 # BFS initialization queue = deque([(0, 0, [(0, 0)])]) # (x, y, path) visited = set((0, 0)) while queue: x, y, path = queue.popleft() if (x, y) == (m - 1, n - 1): return path for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, path + [(nx, ny)])) return []"},{"question":"Question: Stock Price Analyzer In financial markets, tracking stock prices and identifying trends is a common task. Your goal is to implement a function that determines the longest period of continuous stock price increases from a given list of daily stock prices. # Details: 1. **Stock Prices Representation**: Stock prices are provided as a list of integers, where each integer represents the price of the stock on a given day. 2. **Continuous Increase**: A continuous increase is defined as a period where each subsequent price is higher than the previous day\'s price. # Function Definition: Implement a function `longest_increasing_period` with the following signature: ```python def longest_increasing_period(prices: List[int]) -> int ``` * **Input**: A list of integers `prices` where `1 <= len(prices) <= 10^5` and `0 <= prices[i] <= 10^9`. * **Output**: An integer representing the length of the longest period of continuous stock price increases. # Constraints: * The list length will be at least 1. * All prices are valid non-negative integers within the specified range. # Example: ```python assert longest_increasing_period([100, 101, 102, 103, 102, 100, 105, 106]) == 4 assert longest_increasing_period([9, 8, 7, 6, 5]) == 1 assert longest_increasing_period([3, 4, 5, 1, 2, 3, 2, 3, 4, 5, 6]) == 5 assert longest_increasing_period([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 ``` # Task: Implement the `longest_increasing_period` function as described. Ensure your solution passes the above example test cases. # Notes: * Your solution should focus on efficiency due to the potentially large input size. * Consider edge cases such as lists with one element or no increases at all. * Test your implementation for correctness and performance.","solution":"from typing import List def longest_increasing_period(prices: List[int]) -> int: if not prices: return 0 longest_period = 1 current_period = 1 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: current_period += 1 longest_period = max(longest_period, current_period) else: current_period = 1 return longest_period"},{"question":"Problem Description You are given two strings, `s1` and `s2`, and you need to determine if `s1` is a subsequence of `s2`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Implement a function that returns `True` if `s1` is a subsequence of `s2`, and `False` otherwise. Function Signature ```python def is_subsequence(s1: str, s2: str) -> bool: Determine whether s1 is a subsequence of s2. Parameters: ---------- s1: str - The string to be checked as a subsequence. s2: str - The string to be checked against. Returns: ------- bool - True if s1 is a subsequence of s2, False otherwise. Constraints: ----------- - 0 <= len(s1) <= 1000 - 0 <= len(s2) <= 1000 - s1 and s2 consist of lowercase English letters only. ``` Example ```python assert is_subsequence(\\"abc\\", \\"ahbgdc\\") == True assert is_subsequence(\\"axc\\", \\"ahbgdc\\") == False assert is_subsequence(\\"\\", \\"ahbgdc\\") == True assert is_subsequence(\\"abc\\", \\"abc\\") == True assert is_subsequence(\\"abc\\", \\"acb\\") == False ``` # Constraints * Ensure that `s1` and `s2` consist of lowercase English letters only. * Handle cases where either `s1` or `s2` are empty strings. # Performance Requirement * The solution should have a time complexity of O(n + m) where n and m are the lengths of `s1` and `s2`, respectively. * The solution should have a space complexity of O(1). # Edge Cases to Handle * If `s1` is an empty string, it should be a subsequence of any string including an empty `s2`. * If `s2` is an empty string, then any non-empty `s1` should return `False` as it cannot be a subsequence of an empty string. * If both `s1` and `s2` are empty strings, `s1` is considered a subsequence of `s2`.","solution":"def is_subsequence(s1: str, s2: str) -> bool: Determine whether s1 is a subsequence of s2. Parameters: ---------- s1: str - The string to be checked as a subsequence. s2: str - The string to be checked against. Returns: ------- bool - True if s1 is a subsequence of s2, False otherwise. Constraints: ----------- - 0 <= len(s1) <= 1000 - 0 <= len(s2) <= 1000 - s1 and s2 consist of lowercase English letters only. m, n = len(s1), len(s2) i, j = 0, 0 while i < m and j < n: if s1[i] == s2[j]: i += 1 j += 1 return i == m"},{"question":"# Find Second Smallest Element in List Context: Consider a scenario where you need to determine the second smallest number in a list of integers. This is useful, for example, when analyzing a leaderboard where you need to find the runner-up score. Task: Implement a function to find the second smallest number in a list of integers. Requirements: 1. **Function**: `find_second_smallest(numbers: list[int]) -> int` - Input: A list of integers `numbers`. - Output: The second smallest integer in the list. - Constraints: - The input list `numbers` will contain at least two distinct integers. Example: ```python assert find_second_smallest([4, 2, 7, 3, 8, 5]) == 3 assert find_second_smallest([10, 2, 14, 1, 5, 9]) == 2 assert find_second_smallest([50, 30, 20, 60, 40]) == 30 ``` Explanation: - In the first example, the smallest number is 2, and the second smallest is 3. - In the second example, the smallest number is 1, and the second smallest is 2. - In the third example, the smallest number is 20, and the second smallest is 30.","solution":"def find_second_smallest(numbers): Finds the second smallest number in a list of integers. Parameters: numbers (list[int]): A list containing at least two distinct integers. Returns: int: The second smallest integer in the list. # Initialize the first and second minimum values first_min = float(\'inf\') second_min = float(\'inf\') for number in numbers: if number < first_min: second_min = first_min first_min = number elif first_min < number < second_min: second_min = number return second_min"},{"question":"# Rectangular Perimeter Calculation A rectangle can be defined on a 2D plane using its coordinates. Given the coordinates of the bottom-left and top-right corners of a rectangle, your task is to calculate its perimeter. # Requirements: 1. Implement a function, `calculate_perimeter(bottom_left: Tuple[int, int], top_right: Tuple[int, int]) -> int` that returns the perimeter of the rectangle. 2. The input tuples will only contain non-negative integers. 3. Ensure that the bottom-left and top-right coordinates are valid, meaning that the bottom-left coordinates must be less than the top-right coordinates. # Constraints: - Coordinates values are within the range `[0, 10^5]`. # Example: ```python # Example 1 bottom_left = (1, 1) top_right = (4, 5) calculate_perimeter(bottom_left, top_right) => 14 # Example 2 bottom_left = (0, 0) top_right = (2, 3) calculate_perimeter(bottom_left, top_right) => 10 # Example 3 bottom_left = (2, 2) top_right = (5, 6) calculate_perimeter(bottom_left, top_right) => 14 # Example 4 bottom_left = (3, 4) top_right = (7, 9) calculate_perimeter(bottom_left, top_right) => 18 ``` # Edge Cases: - The coordinates are very close, such as the rectangle being the smallest possible area. - The longest possible rectangle within given coordinate constraints. # Performance Consideration: - Coordinate values are typically small, but ensure the calculation handles edge conditions efficiently. # Function Signature: ```python def calculate_perimeter(bottom_left: Tuple[int, int], top_right: Tuple[int, int]) -> int: pass ``` # Implementation Note: - You must validate the input to ensure bottom-left coordinates are less than top-right coordinates. Raise a `ValueError` if the input does not comply.","solution":"from typing import Tuple def calculate_perimeter(bottom_left: Tuple[int, int], top_right: Tuple[int, int]) -> int: Returns the perimeter of the rectangle given bottom-left and top-right corner coordinates. # Validate the input coordinates if not (bottom_left[0] < top_right[0] and bottom_left[1] < top_right[1]): raise ValueError(\\"Invalid rectangle coordinates. Ensure bottom-left coordinates are less than top-right coordinates.\\") # Calculate the lengths of the sides length = top_right[0] - bottom_left[0] width = top_right[1] - bottom_left[1] # Calculate the perimeter perimeter = 2 * (length + width) return perimeter"},{"question":"# Problem Statement: Write a function `robot_movement(commands: List[str]) -> Tuple[int, int]` that takes a list of commands controlling the movements of a robot starting at the origin (0, 0) on a 2D plane. The function should return the final coordinates of the robot after executing all commands. # Commands Explanation: - Each command will be a string consisting of a direction (one of `UP`, `DOWN`, `LEFT`, `RIGHT`) followed by a space and an integer indicating the number of steps to move in that direction. - For instance, the command `UP 5` means move 5 steps up. - Moving `UP` increases the y-coordinate. - Moving `DOWN` decreases the y-coordinate. - Moving `LEFT` decreases the x-coordinate. - Moving `RIGHT` increases the x-coordinate. # Input: * A list of strings, `commands`, where each string is formatted as described above (1 ≤ len(commands) ≤ 1000). # Output: * A tuple of two integers representing the final coordinates of the robot. # Constraints: * Each command string is guaranteed to be formatted correctly and within the specified constraints. # Examples: ```python >>> robot_movement([\\"UP 5\\", \\"DOWN 3\\", \\"LEFT 3\\", \\"RIGHT 2\\"]) (-1, 2) >>> robot_movement([\\"UP 10\\", \\"UP 5\\", \\"LEFT 6\\"]) (-6, 15) >>> robot_movement([\\"DOWN 7\\", \\"RIGHT 4\\", \\"UP 3\\", \\"LEFT 2\\", \\"DOWN 1\\"]) (2, -5) >>> robot_movement([]) (0, 0) ``` Your implementation should correctly interpret all commands and effectively calculate the final position on the plane.","solution":"from typing import List, Tuple def robot_movement(commands: List[str]) -> Tuple[int, int]: x, y = 0, 0 for command in commands: direction, steps = command.split() steps = int(steps) if direction == \\"UP\\": y += steps elif direction == \\"DOWN\\": y -= steps elif direction == \\"LEFT\\": x -= steps elif direction == \\"RIGHT\\": x += steps return (x, y)"},{"question":"# Coding Assessment Question Scenario You are working on a data processing engine that includes a feature to \\"flatten\\" nested lists (lists within lists) into a single list of values. This functionality is crucial for standardizing input data structures before further processing steps. # Objective Implement the `flatten_list` function that takes a nested list of arbitrary depth and returns a flat list containing all the elements in the original nested lists. # Function Signature ```python def flatten_list(nested_list: list) -> list: pass ``` # Constraints - The function should handle lists containing any data type (integers, floats, strings, etc.). - The function should ensure that all sub-elements and deeply nested elements are included in the resultant flat list. - The function should operate recursively to accommodate the arbitrary depth of nesting. - If the input is not a list, raise a `TypeError` with a meaningful message. - Optimize for readability and maintainability. # Input - `nested_list` (list): A list, potentially nested to various depths. # Output - (list): A flat list containing all elements from the nested structure. # Examples ```python assert flatten_list([1, 2, [3, 4], [5, [6, 7]]]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_list([[\'a\', \'b\'], [\'c\', [\'d\', [\'e\', \'f\']]], \'g\']) == [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\'] assert flatten_list([-1, [-2, -3, [-4, -5], 0], 1]) == [-1, -2, -3, -4, -5, 0, 1] assert flatten_list([]) == [] assert flatten_list([[[], [[]]]]) == [] try: flatten_list(\\"Not a list\\") except TypeError as e: assert str(e) == \\"Input must be a list\\" try: flatten_list(123) except TypeError as e: assert str(e) == \\"Input must be a list\\" try: flatten_list({\'key\': \'value\'}) except TypeError as e: assert str(e) == \\"Input must be a list\\" ``` # Implementation Details 1. Implement the `flatten_list` function to adhere to the specified behavior and constraints. 2. Write a test function `test_flatten_list()` to verify correctness, including edge cases and error handling.","solution":"def flatten_list(nested_list): Flattens a nested list of arbitrary depth into a single list of values. Args: nested_list (list): A list potentially nested to various depths. Returns: list: A flat list containing all elements from the nested structure. Raises: TypeError: If the input is not a list. if not isinstance(nested_list, list): raise TypeError(\\"Input must be a list\\") result = [] for element in nested_list: if isinstance(element, list): result.extend(flatten_list(element)) else: result.append(element) return result"},{"question":"# Scenario A software development team is building an application that requires performing operations on numerical data provided as strings. You are tasked with developing a function that processes these string inputs to calculate the sum of all valid integers and floating-point numbers within the string. The input string can contain arbitrary text interspersed with valid numerical values. # Task Description Implement a function `sum_numbers` that takes a string `input_str` and returns a floating-point number representing the sum of all valid integers and floating-point numbers found in the input string. # Function Signature ```python def sum_numbers(input_str: str) -> float: pass ``` # Input * A single string `input_str` that may contain valid integers, floating-point numbers, and arbitrary text. * Valid integers are contiguous sequences of digits (e.g., \\"123\\"). * Valid floating-point numbers contain a decimal point within contiguous digits (e.g., \\"123.45\\"). # Output * A floating-point number representing the sum of all valid integers and floating-point numbers found in `input_str`. # Constraints * The input string `input_str` will have a maximum length of 10^4 characters. * Each valid integer or floating-point number will fit within standard Python float representation. # Example Example 1 ```python input_str = \\"The numbers are 3.5 and 42\\" print(sum_numbers(input_str)) # Output: 45.5 ``` Example 2 ```python input_str = \\"Savings account: 1500.75, Expenses: 75.25\\" print(sum_numbers(input_str)) # Output: 1576.0 ``` Example 3 ```python input_str = \\"No numbers here!\\" print(sum_numbers(input_str)) # Output: 0.0 ``` Example 4 ```python input_str = \\"Mix 45 with 0.78 and 900\\" print(sum_numbers(input_str)) # Output: 945.78 ``` # Notes * Ensure to handle potential leading or trailing spaces in the input string. * Use only the Python standard library. * Consider edge cases such as strings without any numbers or with negative numbers properly handled if encountered.","solution":"import re def sum_numbers(input_str: str) -> float: Sums all valid integers and floating-point numbers in the input string. Args: input_str (str): The input string containing arbitrary text and numbers. Returns: float: The sum of all valid integers and floating-point numbers found in the input string. pattern = r\'[-+]?d*.d+|[-+]?d+\' numbers = re.findall(pattern, input_str) total = sum(map(float, numbers)) return total"},{"question":"# Problem Statement You are tasked with implementing a function that sorts a list of integers using the Merge Sort algorithm. Merge Sort is a divide-and-conquer algorithm that divides the input list into two halves, recursively sorts them, and then merges the sorted halves to produce the final sorted list. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers to be sorted. The list can contain both positive and negative integers. # Output - Returns a new list containing the sorted integers in ascending order. # Constraints - The input list can have a length of up to 10^6 elements. - Each integer in the list will fit within a 32-bit signed integer range. # Example Input ```python arr = [38, 27, 43, 3, 9, 82, 10] ``` Output ```python [3, 9, 10, 27, 38, 43, 82] ``` Input ```python arr = [5, 2, 9, 1, 5, 6] ``` Output ```python [1, 2, 5, 5, 6, 9] ``` # Detailed Requirements 1. **Divide**: Recursively divide the input list into two halves until each half contains a single element or is empty. 2. **Conquer**: Recursively sort the two halves. 3. **Merge**: Merge the two sorted halves to produce the final sorted list. 4. Ensure that your implementation is efficient and can handle the upper limit of the input size within a reasonable time frame.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: result = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] <= right[right_idx]: result.append(left[left_idx]) left_idx += 1 else: result.append(right[right_idx]) right_idx += 1 # Append remaining elements (if any) result.extend(left[left_idx:]) result.extend(right[right_idx:]) return result"},{"question":"# Problem Description You are given a list of `N` strings where each string is of length `M`. Your task is to implement an algorithm to group the strings that are anagrams of each other. The result should be a list of groups, where each group contains the original strings that are anagrams, and each group is sorted in lexicographical order. # Input * An integer `N`, the number of strings (1 ≤ N ≤ 1000). * An integer `M`, the length of each string (1 ≤ M ≤ 100). * A list of `N` strings where each string is of length `M`. # Output A list of groups, where each group is a list of strings that are anagrams of each other, sorted in lexicographical order. The groups themselves should be sorted such that the first string in each group is in lexicographical order. # Constraints All strings are composed of lowercase English letters. # Performance Requirement Your function should complete in `O(NM log M)` time. # Function Signature ```python def group_anagrams(N: int, M: int, strings: List[str]) -> List[List[str]]: ``` # Example **Input:** ```python N = 5 M = 3 strings = [ \\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\" ] ``` **Output:** ```python [ [\\"bat\\", \\"tab\\"], [\\"eat\\", \\"tea\\"], [\\"tan\\"] ] ``` # Note In the given example, the strings \\"bat\\" and \\"tab\\" are anagrams and form one group. Similarly, \\"eat\\" and \\"tea\\" are anagrams and form another group. The string \\"tan\\" does not have any anagrams in the list and forms a group by itself. The groups are sorted lexicographically and within each group, the strings are also sorted lexicographically.","solution":"from typing import List from collections import defaultdict def group_anagrams(N: int, M: int, strings: List[str]) -> List[List[str]]: anagram_map = defaultdict(list) # Group strings by their sorted tuple of characters for s in strings: sorted_tuple = tuple(sorted(s)) anagram_map[sorted_tuple].append(s) # Sort each group and the list of groups sorted_groups = [sorted(group) for group in anagram_map.values()] sorted_groups.sort(key=lambda x: x[0]) return sorted_groups"},{"question":"Question # Context A software company is building a scheduling application. One feature they need is the ability to detect overlapping time intervals quickly. To aid in this development, they require you to write a function that determines if any two time intervals in a given list overlap. # Problem Statement Write a function `has_overlapping_intervals(intervals: List[Tuple[int, int]]) -> bool` that takes a list of time intervals and returns `True` if any two intervals overlap, otherwise returns `False`. # Function Signature ```python def has_overlapping_intervals(intervals: List[Tuple[int, int]]) -> bool: pass ``` # Input 1. `intervals` - a list of tuples, where each tuple contains two integers representing the start and end time of an interval. # Output * A boolean, `True` if any two intervals overlap, otherwise `False`. # Examples 1. `has_overlapping_intervals([(1, 3), (2, 4), (5, 7)])` should return `True`. 2. `has_overlapping_intervals([(1, 2), (2, 3), (3, 4)])` should return `False`. 3. `has_overlapping_intervals([(1, 5), (3, 6), (7, 9)])` should return `True`. 4. `has_overlapping_intervals([(1, 3), (4, 6), (8, 10)])` should return `False`. # Constraints * Each interval is represented as a tuple of two integers (start, end). * The start time will always be less than the end time. * List `intervals` length will be between 1 and 10^5. * Each start and end time will be a non-negative integer (0 ≤ start < end ≤ 10^6). # Notes * Your solution should be optimized to handle a large number of intervals within the specified constraints. * Consider edge cases such as intervals that just touch (e.g., end1 == start2) should not overlap.","solution":"from typing import List, Tuple def has_overlapping_intervals(intervals: List[Tuple[int, int]]) -> bool: Determine if any two intervals overlap. Args: intervals: List of tuples, where each tuple contains two integers (start, end). Returns: True if any two intervals overlap, otherwise False. # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) # Compare each interval with the previous one for i in range(1, len(intervals)): # If the current interval starts before the previous one ends, there\'s an overlap if intervals[i][0] < intervals[i-1][1]: return True return False"},{"question":"# Scenario You are tasked with implementing a function for calculating the Manhattan distance between two points in a 2-dimensional space. The Manhattan distance, also known as L1 distance, between two points (x1, y1) and (x2, y2) is given by |x1 - x2| + |y1 - y2|. # Task Implement the function `manhattan_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> int` which computes the Manhattan distance between two given points. # Function Signature ```python def manhattan_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> int: pass ``` # Input: * `point1` (Tuple[int, int]): A tuple representing the coordinates of the first point (x1, y1). * `point2` (Tuple[int, int]): A tuple representing the coordinates of the second point (x2, y2). # Output: * Returns an integer representing the Manhattan distance between the two points. # Constraints: * Both points are represented as tuples of two integers. * The coordinate values are within the range of [-10^4, 10^4]. # Examples: 1. Input: `point1 = (1, 2)`, `point2 = (4, 6)` Output: `7` (|1 - 4| + |2 - 6| = 3 + 4) 2. Input: `point1 = (-3, -4)`, `point2 = (3, 4)` Output: `14` (|-3 - 3| + |-4 - 4| = 6 + 8) 3. Input: `point1 = (0, 0)`, `point2 = (0, 0)` Output: `0` (|0 - 0| + |0 - 0| = 0) # Note: The Manhattan distance can be particularly useful in grid-based pathfinding algorithms or robotics, where movement is restricted to horizontal and vertical paths.","solution":"from typing import Tuple def manhattan_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> int: Calculate the Manhattan distance between two points in a 2D space. Args: point1 (tuple): coordinates of the first point (x1, y1) point2 (tuple): coordinates of the second point (x2, y2) Returns: int: the Manhattan distance between the two points x1, y1 = point1 x2, y2 = point2 return abs(x1 - x2) + abs(y1 - y2)"},{"question":"**Question:** You have been given a string `S` representing an arithmetic expression, which includes the following characters: - Digits (`0-9`) - Arithmetic operators (`+`, `-`, `*`, `/`) - Parentheses (`(`, `)`) Your task is to write a function `evaluate_expression` that evaluates the given arithmetic expression and returns its result as a floating point number. The expression can contain spaces which should be ignored, and you need to follow the standard operator precedence rules: 1. Parentheses 2. Multiplication and division (from left to right) 3. Addition and subtraction (from left to right) # Task: Implement an efficient function `evaluate_expression` that evaluates the given arithmetic expression string and returns the result. # Input: - **Type**: String - **Description**: A valid arithmetic expression string `S` which may include spaces, digits, operators, and parentheses. # Output: - **Return Type**: Float - **Description**: The evaluated result of the arithmetic expression. # Constraints: - The input string `S` will be non-empty. - The length of the string `S` will not exceed 200 characters. - The division operator `/` always results in floating point division. - The result of the expression will fit within the range of a standard floating point number. # Example: ```python def evaluate_expression(S: str) -> float: # implement the function here pass if __name__ == \\"__main__\\": expression_1 = \\"3 + 5 / 2\\" print(evaluate_expression(expression_1)) # Should print 5.5 expression_2 = \\"(2 + 3) * (5 - 2) / 3\\" print(evaluate_expression(expression_2)) # Should print 5.0 ``` In this problem, you will need to handle parsing the expression, managing the precedence rules, and performing arithmetic operations as per mathematical rules. You may use any standard library that helps in evaluating expressions, or you can write your own parser for the input string.","solution":"def evaluate_expression(S): This function evaluates a given arithmetic expression string containing digits, operators (+, -, *, /), and parentheses, and returns the result as a floating point number. import re def parse_expression(expression): expression = re.sub(r\'s+\', \'\', expression) return helper(expression) def helper(expr): num_stack = [] op_stack = [] i = 0 def apply_operation(): op = op_stack.pop() right = num_stack.pop() left = num_stack.pop() if op == \'+\': num_stack.append(left + right) elif op == \'-\': num_stack.append(left - right) elif op == \'*\': num_stack.append(left * right) elif op == \'/\': num_stack.append(left / right) precedence = {\'+\':1, \'-\':1, \'*\':2, \'/\':2} while i < len(expr): char = expr[i] if char.isdigit() or char == \'.\': num = [] while i < len(expr) and (expr[i].isdigit() or expr[i] == \'.\'): num.append(expr[i]) i += 1 num_stack.append(float(\'\'.join(num))) continue elif char == \'(\': op_stack.append(char) elif char == \')\': while op_stack and op_stack[-1] != \'(\': apply_operation() op_stack.pop() elif char in precedence: while (op_stack and op_stack[-1] in precedence and precedence[op_stack[-1]] >= precedence[char]): apply_operation() op_stack.append(char) i += 1 while op_stack: apply_operation() return num_stack[0] return parse_expression(S)"},{"question":"# Matrix Rotation Algorithm Scenario You have been contracted to develop an image editing library for a graphic design application. One of the features required is the ability to rotate an image represented as a 2D matrix by 90 degrees clockwise. The application expects this operation to be efficient based on the size of the image. Objective Implement the `ImageRotator` class that will take in a square matrix and rotate it 90 degrees clockwise. Your solution should demonstrate a grasp of matrix manipulation techniques and should be optimal in terms of time complexity. Requirements 1. **Input**: - A 2D list (matrix) `image` of integers where each integer represents a pixel value in the image. The matrix will be of size `n x n`, where `1 <= n <= 1000`. 2. **Output**: - A new 2D list (matrix) that represents the rotated image. 3. **Constraints**: - The input matrix will always be non-empty and square. Function Signature ```python class ImageRotator: def __init__(self, image: list[list[int]]): # initialization code def rotateClockwise90(self) -> list[list[int]]: # code to rotate the matrix 90 degrees clockwise ``` Hints - Consider how the positions of elements change when rotating the matrix. - Aim to achieve an in-place algorithm or one that efficiently handles large matrices with minimal additional memory usage. - Ensure proper edge handling for the corners and boundaries of the matrix. Example ```python image = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ir = ImageRotator(image) rotated_image = ir.rotateClockwise90() print(rotated_image) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ```","solution":"class ImageRotator: def __init__(self, image: list[list[int]]): self.image = image def rotateClockwise90(self) -> list[list[int]]: n = len(self.image) # Initialize the result matrix with the same dimensions rotated = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = self.image[i][j] return rotated"},{"question":"# **Detecting Cycles in a Directed Graph** **Context** You are working on a system that requires validation of workflows represented as directed graphs. It is crucial to ensure that there are no cycles in these workflows to maintain proper execution order. **Problem Statement** Write a function `detect_cycle_in_graph` that takes in a directed graph represented by its adjacency list and determines if the graph contains any cycles. **Input Format** - An adjacency list `graph` where `graph[i]` is a list of nodes that are directed from node `i`. - The graph is represented as a dictionary where the keys are node identifiers and the values are lists of adjacent nodes. - The total number of nodes `n` is such that `1 <= n <= 10^5`. - Each node identifier is a non-negative integer. **Output Format** - Return `True` if there are any cycles in the graph; otherwise, return `False`. **Constraints** - There are no self-loops (i.e., no node has an edge to itself). - The graph can have zero or more connected components. - The graph may contain isolated nodes (nodes with no edges). **Performance Requirements** - The time complexity should be O(V + E), where V is the number of vertices and E is the number of edges, leveraging Depth-First Search (DFS) or similar algorithms. - The space complexity should be O(V) to handle the node visitations and recursion stack (if using DFS). **Function Signature** ```python def detect_cycle_in_graph(graph: dict[int, list[int]]) -> bool: pass ``` **Example** ```python def detect_cycle_in_graph(graph): Detects if a directed graph contains any cycles using DFS. def dfs(node): if node in recursion_stack: return True # Cycle detected if node in visited: return False visited.add(node) recursion_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True recursion_stack.remove(node) return False visited = set() recursion_stack = set() for node in graph: if not node in visited: if dfs(node): return True return False # Example Usage: graph = { 0: [1], 1: [2], 2: [0], # Cycle here 3: [4], 4: [5], 5: [3] # Another cycle here } print(detect_cycle_in_graph(graph)) # Output: True graph_no_cycle = { 0: [1, 2], 1: [2], 2: [3], 3: [] } print(detect_cycle_in_graph(graph_no_cycle)) # Output: False ``` Write unit tests to validate the implementation thoroughly, ensuring all edge cases are handled appropriately.","solution":"def detect_cycle_in_graph(graph): Detects if a directed graph contains any cycles using DFS. def dfs(node): if node in recursion_stack: return True # Cycle detected if node in visited: return False visited.add(node) recursion_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True recursion_stack.remove(node) return False visited = set() recursion_stack = set() for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"Implement a class `BinarySearchTree` that represents a binary search tree (BST) supporting basic operations such as inserting and deleting nodes, searching for values, and finding the minimum and maximum values in the tree. # Implementation Details Implement the class `BinarySearchTree` that supports the following methods: 1. `__init__(self) -> None`: - Initializes an empty binary search tree. 2. `insert(self, value: int) -> None`: - Inserts a value into the BST. If the value already exists, it does not insert it again. 3. `delete(self, value: int) -> None`: - Deletes a value from the BST. If the value does not exist, it raises a `ValueError`. 4. `search(self, value: int) -> bool`: - Searches for a value in the BST. Returns `True` if the value is found, `False` otherwise. 5. `find_min(self) -> int`: - Finds and returns the minimum value in the BST. Raises a `ValueError` if the tree is empty. 6. `find_max(self) -> int`: - Finds and returns the maximum value in the BST. Raises a `ValueError` if the tree is empty. # Constraints - All values in the BST are unique. - The tree maintains the BST property, where each node\'s left subtree contains values less than the node\'s value, and each node\'s right subtree contains values greater than the node\'s value. # Example ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(3) bst.insert(7) bst.insert(15) bst.delete(20) assert bst.search(10) == True assert bst.search(20) == False assert bst.find_min() == 3 assert bst.find_max() == 15 bst.delete(10) assert bst.find_min() == 3 assert bst.find_max() == 15 ``` # Notes - Ensure proper handling of edge cases like attempting to delete a non-existing value or finding minimum/maximum in an empty tree. - The implementation should efficiently manage insertion, deletion, and search operations, upholding the properties of a binary search tree. - Correct handling of tree re-balancing is not required, but maintaining the BST properties through insertion and deletion is essential.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) elif key > node.val: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) # If key == node.val, do nothing (BSTs do not contain duplicate values) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: raise ValueError(\\"Value not found in the tree\\") # Step 1: Find the node to be deleted if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: # Node with only one child or no child if node.left is None: return node.right elif node.right is None: return node.left # Node with two children: Get the inorder successor (smallest in the right subtree) temp_val = self._find_min(node.right) node.val = temp_val # Delete the inorder successor node.right = self._delete(node.right, temp_val) return node def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None: return False if node.val == key: return True elif key < node.val: return self._search(node.left, key) else: return self._search(node.right, key) def find_min(self): if self.root is None: raise ValueError(\\"Tree is empty\\") return self._find_min(self.root) def _find_min(self, node): current = node while current.left is not None: current = current.left return current.val def find_max(self): if self.root is None: raise ValueError(\\"Tree is empty\\") return self._find_max(self.root) def _find_max(self, node): current = node while current.right is not None: current = current.right return current.val"},{"question":"# Coding Assessment Question: You are developing a data processing tool to convert a string representation of time in \\"HH:MM\\" format to the total number of minutes from midnight (00:00). Implement a function that performs this conversion. Function Signature: ```python def time_to_minutes(time: str) -> int: Converts a time string in \\"HH:MM\\" format to total minutes from midnight. Args: time (str): A string representing the time in \\"HH:MM\\" format. Returns: int: The total number of minutes from midnight. ``` Input: - A string `time` in 24-hour \\"HH:MM\\" format where `00 <= HH <= 23` and `00 <= MM <= 59`. Output: - An integer representing the total number of minutes from midnight. Example: ```python >>> time_to_minutes(\\"00:00\\") 0 >>> time_to_minutes(\\"12:34\\") 754 >>> time_to_minutes(\\"23:59\\") 1439 >>> time_to_minutes(\\"05:30\\") 330 ``` Constraints: 1. The input string is always valid and correctly formatted as \\"HH:MM\\". 2. Ensure the function handles edge cases such as \\"00:00\\" and \\"23:59\\" efficiently. Additional Notes: - You may use Python\'s string manipulation methods to extract hours and minutes. - Avoid using any external libraries. Your task is to implement the function `time_to_minutes` based on the given description and constraints.","solution":"def time_to_minutes(time: str) -> int: Converts a time string in \\"HH:MM\\" format to total minutes from midnight. Args: time (str): A string representing the time in \\"HH:MM\\" format. Returns: int: The total number of minutes from midnight. hours, minutes = map(int, time.split(\':\')) return hours * 60 + minutes"},{"question":"# Problem Statement You have been hired to develop a function that processes a large JSON dataset representing user interactions on a social media platform. Each record in the dataset includes a timestamp, user ID, and the type of interaction (like, comment, share). Your task is to extract and summarize this data to provide meaningful insights to the platform\'s analysts. # Task Write a function `summarize_interactions` that takes in a list of JSON objects representing user interactions and a string `user_id`. Your function should return a dictionary summarizing the interactions by type for the specified user. # Input * `interactions` (list): A list of dictionaries, where each dictionary contains: * `timestamp` (str): The timestamp of the interaction in ISO 8601 format (e.g., \\"2023-01-01T12:00:00Z\\"). * `user_id` (str): The ID of the user who performed the interaction. * `interaction_type` (str): The type of interaction (\\"like\\", \\"comment\\", \\"share\\"). * `user_id` (str): The ID of the user whose interactions you want to summarize. # Output * A dictionary containing: * `like` (int): The total number of likes by the user. * `comment` (int): The total number of comments by the user. * `share` (int): The total number of shares by the user. # Constraints * Assume the `interactions` list contains between 1 and 100,000 records. * The `interaction_type` will always be one of the three types: \\"like\\", \\"comment\\", or \\"share\\". * The `timestamp` will always be a valid ISO 8601 string. * The `user_id` will always be a non-empty string. # Performance Requirements * The solution should efficiently handle up to 100,000 interactions. * The solution should be able to provide the summary with a time complexity of O(n). # Example Function Signature ```python def summarize_interactions(interactions: list, user_id: str) -> dict: summary = {\'like\': 0, \'comment\': 0, \'share\': 0} for interaction in interactions: if interaction[\'user_id\'] == user_id: interaction_type = interaction[\'interaction_type\'] if interaction_type in summary: summary[interaction_type] += 1 return summary ``` # Example Usage ```python interactions = [ {\\"timestamp\\": \\"2023-01-01T12:00:00Z\\", \\"user_id\\": \\"user123\\", \\"interaction_type\\": \\"like\\"}, {\\"timestamp\\": \\"2023-01-01T12:01:00Z\\", \\"user_id\\": \\"user123\\", \\"interaction_type\\": \\"comment\\"}, {\\"timestamp\\": \\"2023-01-01T12:02:00Z\\", \\"user_id\\": \\"user456\\", \\"interaction_type\\": \\"like\\"}, {\\"timestamp\\": \\"2023-01-01T12:03:00Z\\", \\"user_id\\": \\"user123\\", \\"interaction_type\\": \\"share\\"}, {\\"timestamp\\": \\"2023-01-01T12:04:00Z\\", \\"user_id\\": \\"user123\\", \\"interaction_type\\": \\"like\\"} ] summary = summarize_interactions(interactions, \\"user123\\") print(summary) # Output: {\\"like\\": 2, \\"comment\\": 1, \\"share\\": 1} ``` **Remember**: Ensure your solution can handle edge cases, such as an empty interactions list or a user ID that doesn\'t exist in the interactions.","solution":"def summarize_interactions(interactions, user_id): Summarizes interactions by type for a specified user. Args: interactions (list): A list of dictionaries, each containing a \'timestamp\', \'user_id\', and \'interaction_type\'. user_id (str): ID of the user whose interactions need to be summarized. Returns: dict: Dictionary with counts of \'like\', \'comment\', and \'share\' interactions for the user. summary = {\'like\': 0, \'comment\': 0, \'share\': 0} for interaction in interactions: if interaction[\\"user_id\\"] == user_id: interaction_type = interaction[\\"interaction_type\\"] if interaction_type in summary: summary[interaction_type] += 1 return summary"},{"question":"# Temperature Conversion You are provided with a partially implemented function that converts temperatures between three scales: Celsius, Fahrenheit, and Kelvin. Task Complete the function `convert_temperature` such that it performs the following conversions: - Celsius to Fahrenheit: ( F = frac{9}{5} times C + 32 ) - Fahrenheit to Celsius: ( C = frac{5}{9} times (F - 32) ) - Celsius to Kelvin: ( K = C + 273.15 ) - Kelvin to Celsius: ( C = K - 273.15 ) - Fahrenheit to Kelvin: First convert to Celsius, then to Kelvin. - Kelvin to Fahrenheit: First convert to Celsius, then to Fahrenheit. You must ensure: - The input scale is correctly recognized. - The output should be properly labelled with the target scale. Inputs - `temp` (float): The temperature value to be converted. - `from_scale` (str): The scale of the input temperature. Should be one of \'Celsius\', \'Fahrenheit\', or \'Kelvin\'. - `to_scale` (str): The target scale to convert the temperature to. Should be one of \'Celsius\', \'Fahrenheit\', or \'Kelvin\'. Outputs - Returns a tuple containing: - The converted temperature value (float). - The scale of the converted temperature (str). Constraints - The input scale `from_scale` and the target scale `to_scale` must be valid. - The temperature value must be within a realistic range for each scale. Example Usage ```python def convert_temperature(temp: float, from_scale: str, to_scale: str) -> tuple: # Your implementation here # Examples print(convert_temperature(100, \'Celsius\', \'Fahrenheit\')) # (212.0, \'Fahrenheit\') print(convert_temperature(32, \'Fahrenheit\', \'Celsius\')) # (0.0, \'Celsius\') print(convert_temperature(0, \'Celsius\', \'Kelvin\')) # (273.15, \'Kelvin\') print(convert_temperature(273.15, \'Kelvin\', \'Celsius\')) # (0.0, \'Celsius\') print(convert_temperature(32, \'Fahrenheit\', \'Kelvin\')) # (273.15, \'Kelvin\') print(convert_temperature(273.15, \'Kelvin\', \'Fahrenheit\')) # (32.0, \'Fahrenheit\') ``` Write a function `convert_temperature` so that it behaves as described. Validate your function with the given examples, and ensure it handles invalid inputs by raising appropriate errors.","solution":"def convert_temperature(temp: float, from_scale: str, to_scale: str) -> tuple: Converts temperature between Celsius, Fahrenheit, and Kelvin. :param temp: The temperature value to be converted. :param from_scale: The current scale of the temperature. (\'Celsius\', \'Fahrenheit\', or \'Kelvin\') :param to_scale: The target scale to convert the temperature to. (\'Celsius\', \'Fahrenheit\', or \'Kelvin\') :return: A tuple (converted_temperature, target_scale) from_scale = from_scale.lower() to_scale = to_scale.lower() if from_scale not in {\'celsius\', \'fahrenheit\', \'kelvin\'}: raise ValueError(\\"Invalid from_scale value\\") if to_scale not in {\'celsius\', \'fahrenheit\', \'kelvin\'}: raise ValueError(\\"Invalid to_scale value\\") if from_scale == \'celsius\': if to_scale == \'fahrenheit\': converted_temp = (temp * 9/5) + 32 elif to_scale == \'kelvin\': converted_temp = temp + 273.15 else: # celsius to celsius converted_temp = temp elif from_scale == \'fahrenheit\': if to_scale == \'celsius\': converted_temp = (temp - 32) * 5/9 elif to_scale == \'kelvin\': converted_temp = (temp - 32) * 5/9 + 273.15 else: # fahrenheit to fahrenheit converted_temp = temp elif from_scale == \'kelvin\': if to_scale == \'celsius\': converted_temp = temp - 273.15 elif to_scale == \'fahrenheit\': converted_temp = (temp - 273.15) * 9/5 + 32 else: # kelvin to kelvin converted_temp = temp return (converted_temp, to_scale.capitalize())"},{"question":"# Question: Finding the Shortest Path in a Weighted Graph You are given a directed weighted graph represented by nodes and edges. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a given starting node to a target node. Function Signature Write a function `shortest_path(start: str, target: str, edges: List[Tuple[str, str, int]]) -> int` Input - `start`: A string representing the starting node. - `target`: A string representing the target node. - `edges`: A list of tuples where each tuple `(u, v, w)` represents a directed edge from node `u` to node `v` with a weight `w`. Output - An integer representing the shortest distance from the start node to the target node. If there is no path from the start node to the target node, return `-1`. Constraints - The graph may contain cycles. - Nodes are represented by unique strings. - Weights are non-negative integers. Example ```python start = \\"A\\" target = \\"D\\" edges = [(\\"A\\", \\"B\\", 1), (\\"A\\", \\"C\\", 4), (\\"B\\", \\"C\\", 2), (\\"B\\", \\"D\\", 5), (\\"C\\", \\"D\\", 1)] print(shortest_path(start, target, edges)) # Expected Output: 4 ``` Notes - Pay attention to edge cases such as graphs with no edges, graphs that are disconnected, or large graphs with complex weight distributions. - Aim for an efficient solution that minimizes computational complexity.","solution":"from heapq import heappop, heappush from collections import defaultdict, deque from typing import List, Tuple def shortest_path(start: str, target: str, edges: List[Tuple[str, str, int]]) -> int: graph = defaultdict(list) # Build the graph for u, v, w in edges: graph[u].append((v, w)) # Min heap to keep track of the shortest path heap = [(0, start)] # Dictionary to store the shortest distances distances = {start: 0} while heap: current_distance, current_node = heappop(heap) # If we reached the target, return the distance if current_node == target: return current_distance # Look at neighbors and update distances for neighbor, weight in graph[current_node]: distance = current_distance + weight # If the calculated distance is less than the known distance, update it if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heappush(heap, (distance, neighbor)) # If there\'s no path to the target node return -1"},{"question":"# Problem Statement You are tasked with implementing a word frequency counter with additional functionality to manage and analyze the word counts efficiently. # Requirements 1. **Initialization:** - Initialize the word counter. 2. **Operations:** - **Add Word (add_word(word))**: Add a word to the counter. Increment its count if it already exists. - **Get Frequency (get_frequency(word))**: Return the frequency of the specified word. - **Most Frequent (most_frequent())**: Display the word(s) with the highest frequency. If multiple words have the same highest frequency, return all of them sorted alphabetically. - **Words with Frequency (words_with_frequency(f))**: Display all words that have exactly the specified frequency `f`, sorted alphabetically. # Input Format - A sequence of operations and their values. # Output Format - For a **get_frequency** operation, output the frequency of the specified word. - For a **most_frequent** operation, output the word(s) with the highest frequency. - For a **words_with_frequency** operation, output the list of words with the specified frequency. # Constraints - Words will only contain alphabetic characters and will be presented as lowercase. - Operations are provided in the form of a list of tuples, where each tuple contains the operation name and necessary parameters. # Example ```python # Sequence of operations operations = [ (\\"add_word\\", \\"apple\\"), (\\"add_word\\", \\"banana\\"), (\\"add_word\\", \\"apple\\"), (\\"get_frequency\\", \\"apple\\"), # Output: 2 (\\"get_frequency\\", \\"banana\\"), # Output: 1 (\\"most_frequent\\",), # Output: [\\"apple\\"] (\\"add_word\\", \\"banana\\"), (\\"add_word\\", \\"banana\\"), (\\"most_frequent\\",), # Output: [\\"banana\\"] (\\"words_with_frequency\\", 2), # Output: [\\"apple\\"] (\\"words_with_frequency\\", 1), # Output: [] ] word_counter = WordCounter() for operation in operations: if operation[0] == \\"add_word\\": word_counter.add_word(operation[1]) elif operation[0] == \\"get_frequency\\": print(word_counter.get_frequency(operation[1])) elif operation[0] == \\"most_frequent\\": print(word_counter.most_frequent()) elif operation[0] == \\"words_with_frequency\\": print(word_counter.words_with_frequency(operation[1])) ``` # Boilerplate Code: Implement the required methods in the provided class: ```python from collections import defaultdict from typing import List class WordCounter: def __init__(self) -> None: # Initialize the word counter storage self.counter = defaultdict(int) def add_word(self, word: str) -> None: # Add a word to the counter self.counter[word] += 1 def get_frequency(self, word: str) -> int: # Get the frequency of a word return self.counter[word] def most_frequent(self) -> List[str]: # Get the word(s) with the highest frequency if not self.counter: return [] max_freq = max(self.counter.values()) return sorted([word for word, freq in self.counter.items() if freq == max_freq]) def words_with_frequency(self, f: int) -> List[str]: # Get the words with the specified frequency return sorted([word for word, freq in self.counter.items() if freq == f]) ```","solution":"from collections import defaultdict from typing import List class WordCounter: def __init__(self) -> None: # Initialize the word counter storage self.counter = defaultdict(int) def add_word(self, word: str) -> None: # Add a word to the counter self.counter[word] += 1 def get_frequency(self, word: str) -> int: # Get the frequency of a word return self.counter[word] def most_frequent(self) -> List[str]: # Get the word(s) with the highest frequency if not self.counter: return [] max_freq = max(self.counter.values()) return sorted([word for word, freq in self.counter.items() if freq == max_freq]) def words_with_frequency(self, f: int) -> List[str]: # Get the words with the specified frequency return sorted([word for word, freq in self.counter.items() if freq == f])"},{"question":"# Scenario You are developing a simplified shopping cart application as part of an e-commerce website. The cart should be able to add items, remove items, and calculate the total cost of the items it contains. Each item in the cart has a name, price, and quantity. # Task Define a `ShoppingCart` class that supports the following methods: 1. `add_item(name, price, quantity)`: Adds an item to the cart. If the item already exists, it updates the quantity and price. 2. `remove_item(name)`: Removes an item from the cart by its name. 3. `total_cost()`: Returns the total cost of all items in the cart. # Requirements 1. Implement the `ShoppingCart` class and its methods. 2. Ensure the `add_item` method updates an existing item with the same name. 3. Ensure the `remove_item` method removes the item correctly. 4. Ensure the `total_cost` method calculates the sum of the prices of all items, considering their quantities. # Input & Output - **Input**: Methods of the `ShoppingCart` class should be invoked to test its functionality. - `add_item(\\"apple\\", 1.0, 3)` - `add_item(\\"banana\\", 0.5, 5)` - `remove_item(\\"apple\\")` - `total_cost()` - **Output**: - After adding items: The items should be stored correctly. - After removing an item: The item should no longer be present in the cart. - Total cost: Correct sum should be calculated (e.g., 2.5 for the remaining item). # Constraints - Items with the same name must be treated as one item. - Item price is a non-negative float. - Item quantity is a non-negative integer. # Example ```python cart = ShoppingCart() cart.add_item(\\"apple\\", 1.0, 3) cart.add_item(\\"banana\\", 0.5, 5) cart.remove_item(\\"apple\\") assert cart.total_cost() == 2.5 ```","solution":"class ShoppingCart: def __init__(self): self.items = {} def add_item(self, name, price, quantity): if name in self.items: self.items[name][\'price\'] = price self.items[name][\'quantity\'] += quantity else: self.items[name] = {\'price\': price, \'quantity\': quantity} def remove_item(self, name): if name in self.items: del self.items[name] def total_cost(self): total = 0.0 for item in self.items.values(): total += item[\'price\'] * item[\'quantity\'] return total"},{"question":"# Sum of Positive Divisors Given a positive integer `m`, write a function to find the sum of all positive divisors of `m`. A divisor of `m` is any positive integer `d` such that `m % d == 0`. Input: - A single integer `m` (1 ≤ m ≤ 10^6) Output: - A single integer representing the sum of all positive divisors of `m`. Constraints: - Avoid using inefficient brute-force methods to maintain performance. Example: ```python >>> sum_of_divisors(6) 12 >>> sum_of_divisors(28) 56 >>> sum_of_divisors(10) 18 >>> sum_of_divisors(1) 1 ``` > **Scenario**: > Your friend is writing a research paper on number theory and needs a function that can quickly compute the sum of all divisors of any given number `m`. Help them by implementing this function efficiently. Function Signature ```python def sum_of_divisors(m: int) -> int: pass ```","solution":"def sum_of_divisors(m: int) -> int: Returns the sum of all positive divisors of m. divisors_sum = 0 for i in range(1, int(m**0.5) + 1): if m % i == 0: if i != m // i: divisors_sum += i + (m // i) else: divisors_sum += i return divisors_sum"},{"question":"# Problem Statement You are tasked with designing a cache system for storing computed values to optimize a function that requires multiple recalculations with the same inputs. The system should support adding values to the cache, retrieving values, and clearing the cache when needed. # Instructions 1. Write a class `CacheSystem` with the following methods: * `__init__(self)`: Initializes the cache. * `add(self, key: Any, value: Any)`: Adds a key-value pair to the cache. * `get(self, key: Any) -> Any`: Retrieves the value from the cache corresponding to the provided key. Raises a `KeyError` if the key is not found. * `clear(self)`: Clears all items from the cache. 2. Implement a function `cached_function` that uses the `CacheSystem` class to optimize the provided function `func`. The `cached_function` should: * Check if the result of the function call with the given arguments is already in the cache. * Return the cached result if available. * Compute, store, and return the result if not available. * Use a default cache instance if none is provided. # Function Signature and Class Definition ```python from typing import Any, Callable class CacheSystem: def __init__(self): pass def add(self, key: Any, value: Any): pass def get(self, key: Any) -> Any: pass def clear(self): pass def cached_function(func: Callable[..., Any], cache: CacheSystem = None) -> Callable[..., Any]: def wrapper(*args, **kwargs): pass return wrapper ``` # Input - `func`: The function to be optimized (a callable). - `cache`: An optional custom cache instance of the `CacheSystem` class. # Output - Returns a wrapper function that optimizes `func` using the caching mechanism. # Example ```python >>> def slow_function(x): >>> import time >>> time.sleep(2) >>> return x * x >>> cache = CacheSystem() >>> optimized_func = cached_function(slow_function, cache) >>> import time >>> start_time = time.time() >>> print(optimized_func(2)) 4 >>> print(f\'Time taken: {time.time() - start_time:.2f} seconds\') >>> start_time = time.time() >>> print(optimized_func(2)) 4 >>> print(f\'Time taken: {time.time() - start_time:.2f} seconds\') # The second call should be much faster due to caching. ``` # Constraints - Ensure that the cache correctly handles unique keys for different sets of function arguments. - Performance improvements should be noticeable for functions with significant computation time. - Handle all edge cases such as uninitialized cache or non-existent keys appropriately.","solution":"from typing import Any, Callable class CacheSystem: def __init__(self): self.cache = {} def add(self, key: Any, value: Any): self.cache[key] = value def get(self, key: Any) -> Any: if key in self.cache: return self.cache[key] else: raise KeyError(\\"Key not found in cache.\\") def clear(self): self.cache.clear() def cached_function(func: Callable[..., Any], cache: CacheSystem = None) -> Callable[..., Any]: if cache is None: cache = CacheSystem() def wrapper(*args, **kwargs): key = (args, tuple(kwargs.items())) try: return cache.get(key) except KeyError: result = func(*args, **kwargs) cache.add(key, result) return result return wrapper"},{"question":"# Scenario You have a virtual file system simulator that mimics basic file and directory operations in a hierarchical file system. Initially, the file system starts with a single root directory (`/`). You need to implement methods to create directories, create files, and retrieve file content based on a given path. All paths are expected to be absolute paths starting from `/`. # Task Extend the `FileSystem` class by implementing methods to create directories (`mkdir`), create files with content (`touch`), and return file contents (`cat`). # Function Signatures You need to implement the following methods within the `FileSystem` class: ```python class FileSystem: def __init__(self): pass def mkdir(self, path: str) -> None: Create a new directory at the specified path. Args: path (str): The absolute path where the new directory should be created. pass def touch(self, path: str, content: str) -> None: Create a new file with the provided content at the specified path. Args: path (str): The absolute path of the new file to be created. content (str): The content to be written to the new file. pass def cat(self, path: str) -> str: Retrieve the content of the file at the specified path. Args: path (str): The absolute path of the file whose content is to be retrieved. Returns: str: The content of the specified file. pass ``` # Input * `mkdir` and `touch` methods take a string representing the path. * `touch` method additionally takes a string representing the file contents. * `cat` method takes a string representing the file path. # Output * `mkdir` and `touch` methods do not return a value. * `cat` method returns the content of the file as a string. # Constraints * All paths given to the methods are valid absolute paths. * Directories and files are identified by their unique paths. * You may assume that directories and files have unique names within a directory. * A path will not be more than 1000 characters long. # Expected Complexity * Expected time complexity for `mkdir` and `touch` is O(P), where P is the depth of the directory path. * Expected time complexity for `cat` is O(1). * Expected space complexity is O(N), where N is the number of files and directories created. # Example Usage ```python fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.touch(\\"/a/b/c/file.txt\\", \\"Hello World\\") print(fs.cat(\\"/a/b/c/file.txt\\")) # Expected output: \\"Hello World\\" ```","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: dirs = path.strip(\\"/\\").split(\\"/\\") current_dir = self.root for d in dirs: if d not in current_dir: current_dir[d] = {} current_dir = current_dir[d] def touch(self, path: str, content: str) -> None: dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() current_dir = self.root for d in dirs: current_dir = current_dir[d] current_dir[file_name] = content def cat(self, path: str) -> str: dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() current_dir = self.root for d in dirs: current_dir = current_dir[d] return current_dir[file_name]"},{"question":"Coding Question Objective Write a function `next_prime` that finds the closest prime number greater than a given input integer. The function should accept an integer and return the next prime number. Function Signature ```python def next_prime(n: int) -> int: pass ``` Input * `n`: An integer, representing the base number to start the search from. Output * An integer, representing the next prime number greater than `n`. Constraints * The function should raise a `ValueError` if `n` is less than 1. * If `n` is a negative integer, zero, or less than 1, the function should raise a `ValueError` with the message \\"Input must be a positive integer\\". Examples ```python >>> next_prime(10) 11 >>> next_prime(15) 17 >>> next_prime(20) 23 >>> next_prime(30) 31 >>> next_prime(50) 53 >>> next_prime(1) 2 >>> next_prime(0) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> next_prime(-5) Traceback (most recent call last): ... ValueError: Input must be a positive integer ``` Additional Requirements * The function should be optimized for performance. * Include error handling to manage incorrect inputs and raise relevant error messages. * Prime numbers are numbers greater than 1 that have no divisors other than 1 and themselves.","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def next_prime(n: int) -> int: Returns the closest prime number greater than the given input integer n. if n < 1: raise ValueError(\\"Input must be a positive integer\\") candidate = n + 1 while True: if is_prime(candidate): return candidate candidate += 1"},{"question":"# Problem Statement You are required to implement a version of a Circular Buffer (Ring Buffer) with the following functionalities: 1. **Add Element**: Add an element to the buffer. If the buffer is full, overwrite the oldest element. 2. **Get Buffer Contents**: Output the contents of the buffer in the order they were added, excluding any overwritten elements. 3. **Check if Full**: Return whether the buffer is currently full. Function Signature ```python class CircularBuffer: def __init__(self, capacity: int) -> None: Initialize an empty Circular Buffer with maximum capacity \'capacity\'. pass def add(self, value: int) -> None: Add the element \'value\' to the buffer. pass def get_contents(self) -> list: Return the content of the buffer in the order they were added. pass def is_full(self) -> bool: Return whether the buffer is full. pass ``` # Specifications - **Input Format**: A series of calls to the `add`, `get_contents`, and `is_full` methods. - **Output Format**: The results of the `get_contents` and `is_full` method calls. - **Constraints**: - The capacity of the buffer must be a positive integer. - Elements added will be integers. # Example ```python # Initialize buffer with capacity 3 buffer = CircularBuffer(3) buffer.add(10) buffer.add(20) print(buffer.get_contents()) # Output: [10, 20] print(buffer.is_full()) # Output: False buffer.add(30) print(buffer.get_contents()) # Output: [10, 20, 30] print(buffer.is_full()) # Output: True buffer.add(40) print(buffer.get_contents()) # Output: [20, 30, 40] print(buffer.is_full()) # Output: True buffer.add(50) print(buffer.get_contents()) # Output: [30, 40, 50] print(buffer.is_full()) # Output: True ``` # Notes 1. Use a list (array) to store buffer elements and a few indices to keep track of the start and end of the buffer. 2. Properly handle edge cases such as adding elements when the buffer is empty or when it\'s full. 3. Ensure the buffer wraps around correctly when elements are added after reaching its capacity. This question tests the ability to correctly implement a data structure managing circular positioning and overwriting elements, similar to ring buffers commonly used in low-level systems and concurrent programming.","solution":"class CircularBuffer: def __init__(self, capacity: int) -> None: Initialize an empty Circular Buffer with maximum capacity \'capacity\'. self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.end = 0 self.full = False def add(self, value: int) -> None: Add the element \'value\' to the buffer. self.buffer[self.end] = value if self.full: self.start = (self.start + 1) % self.capacity self.end = (self.end + 1) % self.capacity if self.end == self.start: self.full = True def get_contents(self) -> list: Return the content of the buffer in the order they were added. if not self.full: return [self.buffer[i] for i in range(self.start, self.end)] return [self.buffer[(self.start + i) % self.capacity] for i in range(self.capacity)] def is_full(self) -> bool: Return whether the buffer is full. return self.full"},{"question":"# Question: Matrix Rotation You are given an `n x n` 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). # Implementation Details: - **Function Signature**: `def rotate_matrix(matrix: list[list[int]]) -> None:` - **Input**: - `matrix`: A list of `n` lists, each containing `n` integers representing the image. - **Output**: - The function should modify the input `matrix` directly (it should not return anything). - **Constraints**: - (1 leq n leq 200) - The matrix values will be in the range of (-10^3) to (10^3). # Requirements: 1. The rotation must be done in-place, without using extra space for another matrix. 2. The function must handle all edge cases properly. # Example: ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass # Example Test Cases matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix_1) assert matrix_1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix_2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix_2) assert matrix_2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] matrix_3 = [ [1] ] rotate_matrix(matrix_3) assert matrix_3 == [ [1] ] matrix_4 = [ [1, 2], [3, 4] ] rotate_matrix(matrix_4) assert matrix_4 == [ [3, 1], [4, 2] ] ``` # Description: Rotate a given `n x n` matrix clockwise by 90 degrees in-place. This will require careful swapping of elements within the original matrix to achieve the desired rotation without using additional space for another matrix. Ensure you handle edge cases like the smallest and largest possible matrices correctly.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotate the given n x n matrix by 90 degrees clockwise in-place. :param matrix: 2D list of integers n = len(matrix) # Step 1: Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Assessment Question You are working on a project management tool that tracks the progress of multiple tasks. Each task has a unique identifier, estimated hours to complete, hours spent, and status (either \\"pending\\", \\"in progress\\", or \\"completed\\"). Your task is to implement a Python class `TaskManager` to manage these tasks and ensure robust error handling. Your Task Implement the `TaskManager` class with the following specifications: # Class Specification `TaskManager` - **Attributes**: - `tasks` (dict): A dictionary where task IDs are keys and values are dictionaries with task details. Methods: 1. `add_task(task_id, estimated_hours)` - **Input**: `task_id` (string), `estimated_hours` (float) - **Output**: None - **Exceptions**: - Raise `ValueError` if `task_id` already exists. - Raise `ValueError` if `estimated_hours` is zero or negative. 2. `update_task(task_id, hours_spent, status)` - **Input**: `task_id` (string), `hours_spent` (float), `status` (string) - **Output**: None - **Exceptions**: - Raise `KeyError` if `task_id` does not exist. - Raise `ValueError` if `hours_spent` is negative. - Raise `ValueError` if `status` is not one of \\"pending\\", \\"in progress\\", or \\"completed\\". 3. `get_progress(task_id)` - **Input**: `task_id` (string) - **Output**: `dict` (containing `estimated_hours`, `hours_spent`, and `status`) - **Exceptions**: - Raise `KeyError` if `task_id` does not exist. # Example Usage ```python try: manager = TaskManager() manager.add_task(\\"task_1\\", 10) manager.update_task(\\"task_1\\", 3, \\"in progress\\") progress = manager.get_progress(\\"task_1\\") print(progress) # Expected Output: {\'estimated_hours\': 10, \'hours_spent\': 3, \'status\': \'in progress\'} manager.update_task(\\"task_1\\", 7, \\"completed\\") progress = manager.get_progress(\\"task_1\\") print(progress) # Expected Output: {\'estimated_hours\': 10, \'hours_spent\': 7, \'status\': \'completed\'} manager.add_task(\\"task_2\\", -5) # Expected: ValueError except ValueError as e: print(e) except KeyError as e: print(e) ``` # Constraints - `task_id` should be a non-empty string. - `estimated_hours` and `hours_spent` should be non-negative floating-point numbers. - The `status` should be \\"pending\\", \\"in progress\\", or \\"completed\\". Good luck and ensure your class handles all edge cases properly!","solution":"class TaskManager: def __init__(self): self.tasks = {} def add_task(self, task_id, estimated_hours): if task_id in self.tasks: raise ValueError(\\"Task ID already exists.\\") if estimated_hours <= 0: raise ValueError(\\"Estimated hours must be a positive value.\\") self.tasks[task_id] = { \'estimated_hours\': estimated_hours, \'hours_spent\': 0, \'status\': \'pending\' } def update_task(self, task_id, hours_spent, status): if task_id not in self.tasks: raise KeyError(\\"Task ID does not exist.\\") if hours_spent < 0: raise ValueError(\\"Hours spent cannot be negative.\\") if status not in [\\"pending\\", \\"in progress\\", \\"completed\\"]: raise ValueError(\\"Invalid status. Must be \'pending\', \'in progress\', or \'completed\'.\\") task = self.tasks[task_id] task[\'hours_spent\'] += hours_spent task[\'status\'] = status def get_progress(self, task_id): if task_id not in self.tasks: raise KeyError(\\"Task ID does not exist.\\") return self.tasks[task_id]"},{"question":"# Problem Statement Implement a function that constructs a binary tree using the pre-order and in-order traversal lists of the tree. The function should ensure that the binary tree is constructed correctly and should return the root of the binary tree. # Function Signature ```python class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def build_tree(preorder: list[int], inorder: list[int]) -> TreeNode: Constructs a binary tree from the given preorder and inorder traversal lists. :param preorder: List[int] representing the preorder traversal of the binary tree. :param inorder: List[int] representing the inorder traversal of the binary tree. :return: The root of the constructed binary tree. ``` # Input * **preorder**: a list of integers, `preorder` where `1 <= len(preorder) <= 10^3`. * **inorder**: a list of integers, `inorder` where `1 <= len(inorder) <= 10^3`. # Output * The function should return the root node of the binary tree constructed from the given traversal lists. # Constraints 1. The elements in the `preorder` and `inorder` lists are unique and represent valid binary tree nodes. 2. Both lists have the same length. 3. The input lists contain values in the range [-10^4, 10^4]. # Example ```python >>> class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right >>> def print_tree_level_order(root: TreeNode): if not root: return [] result, queue = [], [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing None values while result and result[-1] is None: result.pop() return result >>> preorder = [3, 9, 20, 15, 7] >>> inorder = [9, 3, 15, 20, 7] >>> root = build_tree(preorder, inorder) >>> print_tree_level_order(root) [3, 9, 20, None, None, 15, 7] >>> preorder = [-1] >>> inorder = [-1] >>> root = build_tree(preorder, inorder) >>> print_tree_level_order(root) [-1] ``` # Instructions 1. Implement the `build_tree` function that will construct the binary tree based on the given `preorder` and `inorder` traversal lists. 2. Ensure your function passes the provided example cases and handles edge cases appropriately. 3. Focus on the accuracy of tree construction and use efficient algorithms to adhere to the given constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder, inorder): if not preorder or not inorder: return None root_val = preorder.pop(0) root = TreeNode(root_val) inorder_index = inorder.index(root_val) root.left = build_tree(preorder, inorder[:inorder_index]) root.right = build_tree(preorder, inorder[inorder_index + 1:]) return root"},{"question":"# Scenario In your recent assignment, you encountered a problem related to manipulating strings and character frequencies. Your goal is to write a function that can perform specific operations related to these tasks. # Problem Statement Write a Python function `compress_string(s: str) -> str` that compresses a given string `s` using the counts of repeated characters. For instance, the string \'aabcccccaaa\' would become \'a2b1c5a3\'. If the compressed string is not smaller than the original string, return the original string. Additionally, implement a function `decompress_string(compressed: str) -> str` that decompresses a given string that was compressed using the above method back to its original form. # Requirements 1. **Input/Output Specifications**: * `compress_string(s: str) -> str`: Returns the compressed version of the string if it is shorter than the original string, otherwise returns the original. * `decompress_string(compressed: str) -> str`: Returns the original string from its compressed form. 2. **Constraints**: * Assume `0 <= len(s) <= 10^5` for the compression function. * The string `s` contains only lowercase alphabetical characters (`a` to `z`). 3. **Performance Requirements**: * Optimize both functions to run efficiently even for the upper limit of the string length. # Example ```python def compress_string(s: str) -> str: # Your implementation here def decompress_string(compressed: str) -> str: # Your implementation here # Example usage: print(compress_string(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(decompress_string(\\"a2b1c5a3\\")) # Output: \\"aabcccccaaa\\" ``` # Notes 1. You may use helper functions if necessary. 2. Ensure your solution is efficiently implemented as larger strings might be tested. 3. Handle edge cases, such as empty strings, appropriately.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] counter = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: counter += 1 else: compressed.append(s[i - 1] + str(counter)) counter = 1 compressed.append(s[-1] + str(counter)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s def decompress_string(compressed: str) -> str: if not compressed: return compressed decompressed = [] i = 0 while i < len(compressed): char = compressed[i] count = \'\' i += 1 while i < len(compressed) and compressed[i].isdigit(): count += compressed[i] i += 1 decompressed.append(char * int(count)) return \'\'.join(decompressed)"},{"question":"# Problem Statement You are given an integer array `arr` of size `n`, and an integer `k`. Write a function `find_max_average_subarray(arr: List[int], k: int) -> float` that finds the contiguous subarray of length `k` that has the maximum average value. Return this maximum average value. # Function Signature ```python def find_max_average_subarray(arr: List[int], k: int) -> float: ``` # Input * `arr` (List[int]): A list of integers. * `k` (int): An integer representing the length of the subarray. # Output * (float): The maximum average value of any contiguous subarray of length `k`. # Constraints * The length of the list `arr` will be between 1 and 100,000. * The integer `k` will be between 1 and the length of the list `arr`. * Elements of `arr` will be within the range `[-10^4, 10^4]`. # Examples ```python >>> find_max_average_subarray([1, 12, -5, -6, 50, 3], 4) 12.75 >>> find_max_average_subarray([5], 1) 5.0 >>> find_max_average_subarray([0, 1, 1, 3, 3], 3) 2.3333333333333335 ``` # Implementation Requirements * The solution should utilize a sliding window approach to maintain the sum of the current subarray of length `k` and update the maximum average accordingly. * The target time complexity should be O(n), and the space complexity should be O(1). * Carefully handle edge cases, such as when the subarray length k equals the length of the array `arr`, or `arr` contains negative numbers.","solution":"from typing import List def find_max_average_subarray(arr: List[int], k: int) -> float: if not arr or k <= 0 or k > len(arr): return 0.0 # Calculate the sum of the first window of size k max_sum = curr_sum = sum(arr[:k]) # Iterate through the array using a sliding window approach for i in range(k, len(arr)): curr_sum += arr[i] - arr[i - k] max_sum = max(max_sum, curr_sum) # The maximum average would be max_sum / k return max_sum / k"},{"question":"# Coding Challenge Question: Repeated Character Counter with Enhanced Validation **Context**: In string manipulation, it is often necessary to count the occurrence of characters, filtering out non-alphabetic characters. This assignment involves improving the function for counting repeated characters in a string with added validation and optimized performance. Problem Statement Implement a function `count_repeated_characters(s: str) -> dict` that takes a string and returns a dictionary with characters as keys and their respective counts as values, but only for characters that appear more than once. Your implementation should also: 1. Validate that the input is a string. 2. Return an empty dictionary if the input is not a string. 3. Ignore non-alphabetic characters and map all alphabetic characters to lowercase. Input * A string `s` containing alphanumeric characters, spaces, and punctuation. Output * A dictionary with characters as keys and counts as values, but only for characters that appear more than once. Constraints * The string length (`n`) can be 0 <= n <= 10^6. Expectations 1. Efficient handling of input validation. 2. Correct counting of repeated alphabetic characters (case-insensitive). 3. Handling of edge cases and invalid inputs robustly. Example ```python >>> count_repeated_characters(\\"Hello, World!\\") {\'l\': 3, \'o\': 2} >>> count_repeated_characters(\\"Python3.8 & Python2.7\\") {\'t\': 2, \'h\': 2, \'o\': 2, \'n\': 2, \'p\': 2} >>> count_repeated_characters(\\"123 @\\") {} >>> count_repeated_characters(256) {} >>> count_repeated_characters(\\"\\") {} ``` Implementation Challenge * Consider edge cases where the string might be empty or non-string inputs. * Ensure performance is optimal for large strings. * Handle erroneous inputs gracefully. Feel free to define helper functions if needed.","solution":"def count_repeated_characters(s): Returns a dictionary with characters as keys and their respective counts as values, but only for characters that appear more than once. Non-alphabetic characters are ignored and alphabetic characters are considered case-insensitive. if not isinstance(s, str): return {} s = s.lower() char_count = {} # Counting characters for char in s: if char.isalpha(): if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Filtering out characters that appear only once repeated_chars = {char: count for char, count in char_count.items() if count > 1} return repeated_chars"},{"question":"# Question: Find the Most Frequent 3-Character Substring in a Text **Context**: In text data analysis, it\'s often useful to identify the frequency of substrings of a given length. This can be used in various applications including text compression, plagiarism detection, and natural language processing. **Task**: Write a Python function `most_frequent_trigram(text: str) -> str` that finds and returns the most frequent 3-character substring (trigram) in the given text. In case of ties (multiple substrings with the same maximum frequency), return the lexicographically smallest one. # Input * A string `text` containing only lowercase alphabetical characters (1 ≤ len(text) ≤ 10^5). # Output * A string representing the most frequent trigram in the text. # Constraints * The input string will always contain at least 3 characters. * The function should operate efficiently even for a large `text`. # Example ```python # Given text # The text \'ababcababc\' # The trigrams and their frequencies are: # \'aba\': 3 occurrences # \'bab\': 2 occurrences # \'abc\': 2 occurrences # \'cab\': 1 occurrence # The most frequent trigram is \'aba\' with 3 occurrences print(most_frequent_trigram(\'ababcababc\')) # Output: \'aba\' ``` # Implementation Details 1. Iterate through the string to collect all trigrams. 2. Use a dictionary to keep track of the frequency of each trigram. 3. Determine the most frequent trigram by comparing their frequencies. 4. In case of ties, return the lexicographically smallest trigram.","solution":"def most_frequent_trigram(text: str) -> str: from collections import defaultdict # Dictionary to store the frequency of each trigram trigram_count = defaultdict(int) # Iterate through the text to collect trigrams for i in range(len(text) - 2): trigram = text[i:i+3] trigram_count[trigram] += 1 # Find the most frequent trigram max_frequency = 0 most_frequent = \\"\\" for trigram, count in trigram_count.items(): if count > max_frequency or (count == max_frequency and trigram < most_frequent): max_frequency = count most_frequent = trigram return most_frequent"},{"question":"# Length of Last Word Context: As part of a text analysis tool, you\'re required to implement a function that can determine the length of the last word in a given string. This function will be used to process various text inputs, such as paragraphs or sentences, to extract this specific metric. Task: Implement the `length_of_last_word` function that takes a string `s` and returns the length of the last word. Function Signature: ```python def length_of_last_word(s: str) -> int: Returns the length of the last word in the string s. pass ``` Constraints: * The string `s` consists of ASCII characters. * Words in the string are separated by one or more spaces. * A word is defined as a maximal substring of non-space characters. Input: * `s` (str) - the input string, length (0 leq text{len(s)} leq 10^4). Output: * (int) - the length of the last word in the input string. Example: ```python s = \\"Hello World\\" result = length_of_last_word(s) print(result) # Output: 5 s = \\" fly me to the moon \\" result = length_of_last_word(s) print(result) # Output: 4 s = \\"a\\" result = length_of_last_word(s) print(result) # Output: 1 s = \\" \\" result = length_of_last_word(s) print(result) # Output: 0 ``` Ensure your function handles various edge cases like empty strings, multiple spaces, and single-word inputs correctly. Performance Expectations: * The implementation should efficiently handle strings up to (10^4) characters. * Solutions must process the string in linear time and avoid unnecessary operations.","solution":"def length_of_last_word(s: str) -> int: Returns the length of the last word in the string s. # Split the string by spaces and filter out empty strings words = s.split() # Return the length of the last word if it exists, otherwise return 0 return len(words[-1]) if words else 0"},{"question":"# Question: Finding Bridges in a Network In a communication network represented by an undirected graph, some edges are critical for the network\'s connectivity. These critical edges are called \\"bridges\\". Removing a bridge will increase the number of connected components in the graph. Your task is to write a function to find all such bridges. Function Signature ```python def find_bridges(graph: Dict[int, List[int]]) -> List[Tuple[int, int]]: pass ``` # Input: - `graph`: A dictionary where keys represent nodes and values are lists of adjacent nodes, thus describing an undirected graph. # Output: - A list of tuples, where each tuple represents a bridge in the graph, with the smaller node first. The list of bridges should be sorted in ascending order of the first node, and for ties, by the second node. # Constraints: - Each node will have an integer identifier. - The graph will have at most 1000 nodes and 5000 edges. # Examples: **Example 1:** ```python graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4], 4: [3, 5, 6], 5: [4], 6: [4], } assert find_bridges(graph) == [(2, 3), (3, 4), (4, 5), (4, 6)] ``` **Example 2:** ```python graph = { 0: [1, 2], 1: [0, 2, 3], 2: [0, 1], 3: [1, 4], 4: [3], } assert find_bridges(graph) == [(1, 3), (3, 4)] ``` # Instructions: 1. Implement Depth-First Search (DFS) based approach to find bridges. 2. Track discovery and low values for each vertex. 3. Identify bridges using the aforementioned conditions. 4. Return the list of identified bridges sorted in the specified order. 5. Your solution should be efficient with respect to both time and space complexity. # Note: - You are required to handle general graphs, including both connected and disconnected components. - Ensure that your code handles edge cases, such as graphs with no edges or very high connectivity. ---","solution":"def find_bridges(graph): Finds all the bridges in an undirected graph. :param graph: Dictionary representing an undirected graph where keys are nodes and values are lists of adjacent nodes. :return: List of tuples representing the bridges in the graph. def dfs(node, parent, discovery_time, low_time, visited, graph, result): visited[node] = True discovery_time[node] = low_time[node] = find_bridges.timer find_bridges.timer += 1 for neighbor in graph[node]: if neighbor == parent: continue if not visited[neighbor]: dfs(neighbor, node, discovery_time, low_time, visited, graph, result) low_time[node] = min(low_time[node], low_time[neighbor]) if low_time[neighbor] > discovery_time[node]: result.append((min(node, neighbor), max(node, neighbor))) else: low_time[node] = min(low_time[node], discovery_time[neighbor]) visited = {node: False for node in graph} discovery_time = {node: float(\'inf\') for node in graph} low_time = {node: float(\'inf\') for node in graph} result = [] find_bridges.timer = 0 for node in graph: if not visited[node]: dfs(node, None, discovery_time, low_time, visited, graph, result) return sorted(result)"},{"question":"# Binary Tree Inorder Traversal Objective You are tasked to implement an algorithm to perform an inorder traversal of a binary tree, which returns the elements in ascending order based on their values. Problem Statement Design and implement the `inorder_traversal` function that takes the root node of a binary tree and returns a list of its elements in inorder sequence. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> list: ``` Input - `root`: The root node of a binary tree. Output - A list of integers representing the inorder traversal of the tree. Constraints - The number of nodes in the tree is between 0 and 10^4. - The values of the nodes in the tree can range from -10^9 to 10^9. Example Usage ```python # Example 1: # Input: [1, None, 2, 3] # 1 # # 2 # / # 3 root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) >>> inorder_traversal(root) [1, 3, 2] # Example 2: # Input: [] root = None >>> inorder_traversal(root) [] # Example 3: # Input: [1] # 1 root = TreeNode(1) >>> inorder_traversal(root) [1] ``` Edge Cases to Consider - An empty tree should return an empty list. - A tree with a single node should return a list with that single element. - Trees with only left or right subtrees should be properly traversed. Testing Your solution should be designed to be testable using standard testing tools for Python, such as `doctest` or `unittest`. --- Ensure you include sufficient comments and documentation within your code to make it understandable and maintainable.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> list: Perform an inorder traversal of the binary tree. :param root: TreeNode :return: List[int] result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"# Task Write a function `find_closest_pair(numbers: List[int], target: int) -> Tuple[int, int]` that finds two distinct elements in a list whose sum is closest to a given target value. Ensure the solution optimizes for both time and space complexity, and handles edge cases smoothly. # Input and Output Expectations - **Input**: A list of integers `numbers` and an integer `target`. - 2 <= len(numbers) <= 10^5 - -10^6 <= numbers[i] <= 10^6 - -10^6 <= target <= 10^6 - **Output**: - A tuple `(num1, num2)` of two distinct integers from the list `numbers` such that `num1 + num2` is closest to the `target`. - In case of multiple pairs with the same minimal difference, return the pair with the smaller numbers first. # Function Signature ```python from typing import List, Tuple def find_closest_pair(numbers: List[int], target: int) -> Tuple[int, int]: pass ``` # Examples ```python assert find_closest_pair([10, 22, 28, 29, 30, 40], 54) == (22, 30) assert find_closest_pair([-1, 3, 8, 2, 9, 5], 10) == (2, 8) assert find_closest_pair([1, 60, -10, 70, -80, 85], 0) == (-80, 85) ``` # Constraints - The function should efficiently handle lists with a large number of elements. - The solution must account for negative numbers and ensure that pairs are distinct. - The pair should be ordered such that for pairs with the same sum difference, the pair with the smaller first element is returned.","solution":"from typing import List, Tuple def find_closest_pair(numbers: List[int], target: int) -> Tuple[int, int]: Finds two distinct elements in a list whose sum is closest to a given target. numbers.sort() left, right = 0, len(numbers) - 1 closest_pair = (numbers[left], numbers[right]) closest_diff = abs(numbers[left] + numbers[right] - target) while left < right: current_sum = numbers[left] + numbers[right] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = (numbers[left], numbers[right]) if current_sum < target: left += 1 else: right -= 1 return closest_pair"},{"question":"# Problem Statement You are given a string containing a combination of alphabetical characters and digits. Your task is to write a function that will sort the characters in the string such that all alphabetical characters come first, followed by digits. Within each category, the characters should be sorted in ascending order. Function Signature ```python def sort_string_characters(s: str) -> str: ``` Parameters * **s**: A string containing alphabetical characters and digits. Returns * A string with sorted characters, where alphabetical characters come first in ascending order, followed by digits in ascending order. Input Constraints * The length of the string (`len(s)`) can be up to 10^5. * The string contains only English alphabetical characters (both lowercase and uppercase) and digits. Example ```python # Example 1 assert sort_string_characters(\\"d3c2b1a4\\") == \\"abcd1234\\" # Example 2 assert sort_string_characters(\\"A1B2C3\\") == \\"ABC123\\" # Example 3 assert sort_string_characters(\\"z9y8x7\\") == \\"xyz789\\" ```","solution":"def sort_string_characters(s: str) -> str: Sort the characters in the input string such that all alphabetical characters come first, followed by digits. Both groups are sorted in ascending order. Parameters: s (str): The input string containing alphabetical characters and digits. Returns: str: A string with sorted characters where alphabetical characters come first, followed by digits in ascending order. alphabets = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: alphabets.append(char) sorted_alphabets = \'\'.join(sorted(alphabets)) sorted_digits = \'\'.join(sorted(digits)) return sorted_alphabets + sorted_digits"},{"question":"# Logistic Regression from Scratch Your task is to implement logistic regression by defining the necessary functions for model training and prediction. The provided snippets include partial implementations of the functions required. # Function Descriptions 1. **sigmoid(z: np.ndarray) -> np.ndarray** * Compute the sigmoid function for the input `z`, which could be a numpy array or a scalar. 2. **train_logistic_regression(x_train: np.ndarray, y_train: np.ndarray, learning_rate: float, epochs: int) -> np.ndarray** * Train the logistic regression model using the provided training data `x_train` and `y_train`. Return the parameters (weights). 3. **predict_logistic_regression(x_test: np.ndarray, weights: np.ndarray) -> np.ndarray** * Use the trained model weights to predict the probability of each test sample in `x_test` belonging to the positive class. # Requirements * Implement the `sigmoid`, `train_logistic_regression`, and `predict_logistic_regression` functions as described. * The input `x_train` is a 2D numpy array, where each row is a training sample with its features. * The input `y_train` is a 1D numpy array containing the binary target values (0 or 1) corresponding to each row in `x_train`. * The input `x_test` is a 2D numpy array with the same number of features as `x_train`. * The input `learning_rate` is a float that controls the step size during gradient descent. * The input `epochs` is an integer that specifies the number of iterations for training the model. # Constraints * Assume that `x_train`, `y_train`, and `x_test` are non-empty with consistent dimensions. * Ensure efficient handling of up to 1000 training samples and a similar number of features. # Example ```python import numpy as np # Implement the functions def sigmoid(z: np.ndarray) -> np.ndarray: return 1 / (1 + np.exp(-z)) def train_logistic_regression(x_train: np.ndarray, y_train: np.ndarray, learning_rate: float, epochs: int) -> np.ndarray: weights = np.zeros(x_train.shape[1]) for _ in range(epochs): predictions = sigmoid(np.dot(x_train, weights)) errors = y_train - predictions gradient = np.dot(x_train.T, errors) weights += learning_rate * gradient return weights def predict_logistic_regression(x_test: np.ndarray, weights: np.ndarray) -> np.ndarray: probabilities = sigmoid(np.dot(x_test, weights)) return probabilities # Test the implementation with provided data x_train = np.array([[2.3, 4.0], [1.3, 3.5], [3.5, 5.5]]) y_train = np.array([1, 0, 1]) learning_rate = 0.1 epochs = 1000 weights = train_logistic_regression(x_train, y_train, learning_rate, epochs) x_test = np.array([[1.5, 2.8], [3.0, 4.5]]) predictions = predict_logistic_regression(x_test, weights) print(predictions) # Expected Output: array with two probability values close to either 0 or 1 ``` Your solution should pass the above test case and any additional edge cases derived from the context of the problem.","solution":"import numpy as np def sigmoid(z: np.ndarray) -> np.ndarray: Compute the sigmoid function for the input z, which could be a numpy array or a scalar. return 1 / (1 + np.exp(-z)) def train_logistic_regression(x_train: np.ndarray, y_train: np.ndarray, learning_rate: float, epochs: int) -> np.ndarray: Train the logistic regression model using the provided training data x_train and y_train. Return the parameters (weights). weights = np.zeros(x_train.shape[1]) for _ in range(epochs): predictions = sigmoid(np.dot(x_train, weights)) errors = y_train - predictions gradient = np.dot(x_train.T, errors) weights += learning_rate * gradient return weights def predict_logistic_regression(x_test: np.ndarray, weights: np.ndarray) -> np.ndarray: Use the trained model weights to predict the probability of each test sample in x_test belonging to the positive class. probabilities = sigmoid(np.dot(x_test, weights)) return probabilities"},{"question":"# Context You are tasked with implementing a custom binary search tree (BST) in Python that supports insertion, search, deletion, and traversal operations. This BST should mimic the behavior of a typical binary search tree with no duplicate values. # Problem Statement Implement a `BinarySearchTree` class that supports the following methods: - `insert(self, key)`: Inserts a new key into the BST. - `search(self, key)`: Searches for a key in the BST and returns `True` if the key is found, otherwise returns `False`. - `delete(self, key)`: Deletes a key from the BST. Returns `True` if the key was deleted, otherwise returns `False`. - `inorder(self)`: Returns a list of keys representing the inorder traversal of the BST. # Requirements 1. The BST should not allow duplicate keys. 2. Implement the BST such that insertion, deletion, and search operations are O(h), where h is the height of the tree. 3. Make sure the tree maintains its properties after each insertion and deletion. # Constraints - Keys will be integers. - Use standard BST properties where left child nodes are less than the root node, and right child nodes are greater. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): # Insert a new key into the BST pass def search(self, key): # Search for a key in the BST pass def delete(self, key): # Delete a key from the BST pass def inorder(self): # Inorder traversal of the BST pass ``` # Example Usage ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.search(4)) # Output: True print(bst.search(10)) # Output: False bst.delete(7) print(bst.inorder()) # Output: [2, 3, 4, 5, 6, 8] ```","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, current, key): if key < current.key: if current.left is None: current.left = Node(key) else: self._insert(current.left, key) elif key > current.key: if current.right is None: current.right = Node(key) else: self._insert(current.right, key) def search(self, key): return self._search(self.root, key) def _search(self, current, key): if current is None: return False if current.key == key: return True elif key < current.key: return self._search(current.left, key) else: return self._search(current.right, key) def delete(self, key): self.root, deleted = self._delete(self.root, key) return deleted def _delete(self, current, key): if current is None: return current, False deleted = False if key < current.key: current.left, deleted = self._delete(current.left, key) elif key > current.key: current.right, deleted = self._delete(current.right, key) else: deleted = True if current.left is None: return current.right, deleted elif current.right is None: return current.left, deleted min_larger_node = self._get_min(current.right) current.key = min_larger_node.key current.right, _ = self._delete(current.right, min_larger_node.key) return current, deleted def _get_min(self, current): while current.left is not None: current = current.left return current def inorder(self): keys = [] self._inorder(self.root, keys) return keys def _inorder(self, current, keys): if current is not None: self._inorder(current.left, keys) keys.append(current.key) self._inorder(current.right, keys)"},{"question":"# Fibonacci-like Sequence Generator In this problem, you are required to write a function to calculate the nth number in a custom Fibonacci-like sequence using an iterative approach. The sequence starts with two given numbers `a` and `b` and each subsequent number is the sum of the two preceding ones. Function Signature ```python def custom_fibonacci(n: int, a: int, b: int) -> int: ``` Parameters - `n` (int): The position in the sequence we want to calculate (1-based index). - `a` (int): The first number in the sequence. - `b` (int): The second number in the sequence. Returns - `int`: The nth number in the custom Fibonacci-like sequence. Constraints - `n` is an integer such that 1 <= n <= 50 (These constraints are given to avoid performance issues and handle larger sums comfortably). - `1 <= a, b <= 1000` Example ```python assert custom_fibonacci(1, 2, 3) == 2 assert custom_fibonacci(2, 2, 3) == 3 assert custom_fibonacci(3, 2, 3) == 5 assert custom_fibonacci(4, 2, 3) == 8 assert custom_fibonacci(5, 2, 3) == 13 ``` Edge Cases - Ensure your function handles small values such as `n=1` correctly and returns `a`. - Handle cases where `n=2` correctly and returns `b`. - Raise appropriate exceptions for input values less than 1. - Ensure the function performs efficiently for larger values of `n`. **Your task** is to implement the `custom_fibonacci` function while ensuring it is efficient and correctly handles all scenarios mentioned.","solution":"def custom_fibonacci(n: int, a: int, b: int) -> int: Calculate the nth number in a custom Fibonacci-like sequence. Parameters: n (int): The position in the sequence we want to calculate (1-based index). a (int): The first number in the sequence. b (int): The second number in the sequence. Returns: int: The nth number in the custom Fibonacci-like sequence. if n < 1: raise ValueError(\\"n must be a positive integer.\\") if n == 1: return a elif n == 2: return b prev2 = a prev1 = b current = 0 for _ in range(3, n + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return current"},{"question":"# Problem Statement In many real-world applications, it is often necessary to determine the prime factors of a given number. Prime factors are the prime numbers which multiply together to give the original number. Task Write a function `prime_factors(n: int) -> List[int]` that returns a list of all prime factors of the given number `n`. The prime factors should be listed in ascending order. Input * `n` (int): The number for which the prime factors need to be determined. (2 ≤ n ≤ 10^6) Output * Returns a list of integers representing the prime factors of the given number in ascending order. Constraints * Your implementation should efficiently handle the input size within reasonable runtime and memory usage. * Consider edge cases such as when the input number is itself a prime number. # Example ```python assert prime_factors(60) == [2, 2, 3, 5] assert prime_factors(13) == [13] assert prime_factors(100) == [2, 2, 5, 5] assert prime_factors(1) == [] assert prime_factors(97) == [97] assert prime_factors(1024) == [2, 2, 2, 2, 2, 2, 2, 2, 2, 2] ``` Hints 1. A prime number is only divisible by 1 and itself. 2. Start dividing the number by the smallest primes (2, 3, 5, etc.) and then move to larger primes. 3. Efficient algorithms may involve verifying divisibility up to the square root of the given number.","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of all prime factors of the given number `n` in ascending order. factors = [] # Start with the smallest prime number divisor = 2 while n >= divisor * divisor: while n % divisor == 0: factors.append(divisor) n //= divisor divisor += 1 if n > 1: factors.append(n) return factors"},{"question":"# Problem Statement You are given a list of non-overlapping intervals represented by their start and end times [start, end]. Your task is to implement a function `insert_interval` that inserts a new interval into the list of intervals and merges overlapping intervals if necessary. # Input Format - The input consists of two parts: 1. A list of intervals `intervals`, where each interval is represented as a list of two integers `[start, end]` with `start < end`. 2. A single new interval represented as a list of two integers `[start, end]` with `start < end`. # Output Format - Return a list of intervals after inserting the new interval and merging all necessary overlapping intervals. # Constraints - The intervals in the input list are non-overlapping and sorted in an ascending order based on their start time. - The new interval can start or finish at any point, not necessarily in order. - The input `intervals` list will contain at most 10,000 intervals. - The values for the interval boundaries will be between -10,000,000 and 10,000,000. # Performance Requirements - The solution should be efficient with respect to the constraints. - Aim for a time complexity of O(n), where n is the number of initial intervals. # Function Signature ```python def insert_interval(intervals: list[list[int]], new_interval: list[int]) -> list[list[int]]: pass ``` # Example ```python assert insert_interval([[1, 3], [6, 9]], [2, 5]) == [[1, 5], [6, 9]] assert insert_interval([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 8]) == [[1, 2], [3, 10], [12, 16]] assert insert_interval([], [4, 8]) == [[4, 8]] assert insert_interval([[1, 5]], [2, 3]) == [[1, 5]] assert insert_interval([[1, 5]], [6, 8]) == [[1, 5], [6, 8]] ```","solution":"def insert_interval(intervals: list[list[int]], new_interval: list[int]) -> list[list[int]]: merged_intervals = [] i = 0 n = len(intervals) # Add all intervals before the new_interval while i < n and intervals[i][1] < new_interval[0]: merged_intervals.append(intervals[i]) i += 1 # Merge overlapping intervals with the new_interval while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 merged_intervals.append(new_interval) # Add all the remaining intervals after the new_interval while i < n: merged_intervals.append(intervals[i]) i += 1 return merged_intervals"},{"question":"# Connected Components in an Undirected Graph Given an undirected graph represented as an adjacency list, write a function to determine the number of connected components in the graph. A connected component is a maximal set of vertices such that each pair of vertices is connected by a path. Your task is to implement the function `count_connected_components(graph)` which takes a dictionary representing the graph and returns the number of connected components. Parameters: - The input `graph` is a dictionary where keys are vertex indices (integers) and values are lists of adjacent vertices. Output: - The function should return an integer representing the number of connected components in the graph. Constraints: - Number of vertices (V) is at most 1000. - Number of edges (E) is at most 10,000. Example: ```python # Example adjacency list representation of a graph graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3], 5: [] } # Expected output: 3 connected components print(count_connected_components(graph)) ``` * The function should return `3`.","solution":"def count_connected_components(graph): Returns the number of connected components in an undirected graph represented as an adjacency list. :param graph: Dictionary where keys are vertex indices and values are lists of adjacent vertices. :return: Integer representing the number of connected components in the graph. def dfs(node): Depth-First Search to visit all nodes in the same connected component. visited.add(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor) visited = set() count = 0 for vertex in graph: if vertex not in visited: count += 1 dfs(vertex) return count"},{"question":"# Problem Statement Array Sorting with Custom Comparator Overview You are given an array of tuples representing items and their associated values. Your task is to sort this array with a custom comparator function. This comparator function should be provided by the user during initialization and should determine the order of sorting based on the comparison of two tuples. Task Modify the provided `CustomSorter` class to accept a custom comparator function. Use this comparator function to sort the array of tuples. Requirements 1. **Custom Comparator Function Parameter**: Add a new parameter `comparator` to the `CustomSorter` class which should be a callable. 2. **Validation**: Validate that the comparator is a callable that takes two tuples and returns an integer. 3. **Sorting Implementation**: Ensure the custom comparator is used when sorting the array. Input - **Initialization Parameters**: ```python CustomSorter(comparator: callable) ``` - **Array of Tuples**: ```text items: list of tuples ``` Output - The sorted array of tuples based on the custom comparator. Constraints - The comparator, if provided, must be a callable that takes two tuples and returns an integer (-1, 0, or 1). - The input array will contain tuples with comparable elements. Example ```python # Define a custom comparator function for sorting based on the second element in descending order def comparator(tuple1, tuple2): if tuple1[1] > tuple2[1]: return -1 elif tuple1[1] < tuple2[1]: return 1 else: return 0 # Sample data items = [(1, 2), (2, 1), (3, 3), (4, 2)] # Instantiate the CustomSorter with custom comparator sorter = CustomSorter(comparator=comparator) # Sort the items sorted_items = sorter.sort(items) print(sorted_items) # Expected output: [(3, 3), (1, 2), (4, 2), (2, 1)] ``` **Note**: Your solution should ensure the comparator function is used correctly to sort the array without breaking any existing functionality.","solution":"from typing import List, Tuple, Callable class CustomSorter: def __init__(self, comparator: Callable[[Tuple, Tuple], int]): if not callable(comparator): raise TypeError(\'Comparator must be a callable function\') self.comparator = comparator def sort(self, items: List[Tuple]) -> List[Tuple]: Sorts the list of tuples using the custom comparator function. :param items: List of tuples to be sorted. :return: Sorted list of tuples. return sorted(items, key=lambda x: functools.cmp_to_key(self.comparator)(x)) # Ensure you import functools at the top of your file. import functools"},{"question":"# Problem Statement Write a function that takes a non-negative integer `n` and returns the sum of its digits. If the resulting sum has more than one digit, repeatedly sum the digits until a single-digit sum is obtained. # Function Signature ```python def digit_root(n: int) -> int: Computes the digit root of a non-negative integer n. :param n: A non-negative integer :return: A single-digit integer that represents the digit root of n Example: >>> digit_root(1234) 1 >>> digit_root(999) 9 >>> digit_root(0) 0 >>> digit_root(987654321) 9 ``` # Input - `n` (non-negative integer): The integer for which the digit root must be computed. The value of `n` can be as large as 10^18. # Output - Returns a single-digit integer that is the digit root of the input number. # Constraints - The function should handle integers as large as 10^18. - The input integer will always be non-negative. # Performance Requirements - The solution should be efficient, focusing on simplicity with repeated sums of digits until a single digit is achieved. # Examples 1. `digit_root(1234)` should return `1` because 1 + 2 + 3 + 4 = 10 (1 + 0 = 1). 2. `digit_root(999)` should return `9` because 9 + 9 + 9 = 27 (2 + 7 = 9). 3. `digit_root(0)` should return `0` because the digit root of 0 is 0. 4. `digit_root(987654321)` should return `9`. # Additional Notes - Consider using a mathematical approach to simplify the summation process instead of iterating through digits multiple times. - Focus on edge cases such as `n` being zero and very large integers close to 10^18.","solution":"def digit_root(n: int) -> int: Computes the digit root of a non-negative integer n. # Digit root based on digital root formula if n == 0: return 0 else: return (n - 1) % 9 + 1"},{"question":"# Problem Statement You are assigned to create a function that processes a dataset of user activities and summarizes the total activity time for each user. The dataset is represented as a list of dictionaries, where each dictionary contains a `\\"user_id\\"` and an `\\"activity_duration\\"` in minutes. The main objective is to aggregate the total activity duration for each user. # Functionality Requirements - Implement a function `summarize_activity(data: list) -> dict` that takes a dataset of user activities and returns a summary of total activity time for each user. - Each user should be represented by their `\\"user_id\\"` and the corresponding total `\\"total_duration\\"` in minutes. - Handle potential errors such as invalid data formats gracefully. # Constraints - The function should run efficiently even for large datasets. - Assume each `activity_duration` is a positive integer. - You must ensure the output dictionary contains unique `user_id` keys. # Input - `data` (list): A list of dictionaries, where each dictionary represents a user\'s activity with: - `\\"user_id\\"` (str): The ID of the user. - `\\"activity_duration\\"` (int): The duration of the activity in minutes. # Output - A dictionary where each key is a `user_id` and each value is the total `\\"total_duration\\"` of all activities for that user in minutes. # Examples ```python summarize_activity([ {\\"user_id\\": \\"user1\\", \\"activity_duration\\": 30}, {\\"user_id\\": \\"user2\\", \\"activity_duration\\": 45}, {\\"user_id\\": \\"user1\\", \\"activity_duration\\": 25} ]) ``` should return: ```python { \\"user1\\": 55, \\"user2\\": 45 } ``` # Scenario You are developing a fitness tracking application that monitors users\' workouts. The application logs each user\'s activity duration in minutes. Your task is to compile a summary of total activity time for each user, which will be used for displaying weekly or monthly activity reports. # Performance Requirements - Ensure that the solution handles the aggregation efficiently, even if the dataset contains thousands of records. - Optimize for minimal computational complexity and quick aggregation. # Hints - Consider using a dictionary to store the cumulative duration for each user. - Use a loop to iterate over the dataset and update the total activity duration for each user accordingly. - Handle edge cases where the dataset might be empty or contain invalid activity records.","solution":"def summarize_activity(data): Summarizes the total activity duration for each user. Parameters: data (list): A list of dictionaries where each dictionary contains a \\"user_id\\" (str) and an \\"activity_duration\\" (int). Returns: dict: A dictionary where keys are \\"user_id\\" and values are the total activity duration in minutes for that user. summary = {} for record in data: user_id = record.get(\\"user_id\\") activity_duration = record.get(\\"activity_duration\\") if not isinstance(user_id, str) or not isinstance(activity_duration, int): continue # skip invalid records if user_id in summary: summary[user_id] += activity_duration else: summary[user_id] = activity_duration return summary"},{"question":"Question: Determine if a Number is a Power of Two Write a function that checks if a given non-negative integer is a power of two. Implement two methods to determine this: one using bitwise operations and one using logarithms. # Function Signatures ```python def is_power_of_two_bitwise(number: int) -> bool: pass def is_power_of_two_log(number: int) -> bool: pass ``` # Input - An integer `number` (0 ≤ number ≤ 2^31 - 1). # Output - A boolean value indicating whether the `number` is a power of two. # Constraints - The function should raise a `ValueError` if `number` is negative. # Example ```python assert is_power_of_two_bitwise(1) == True assert is_power_of_two_bitwise(2) == True assert is_power_of_two_bitwise(3) == False assert is_power_of_two_bitwise(16) == True assert is_power_of_two_bitwise(18) == False assert is_power_of_two_bitwise(0) == False try: is_power_of_two_bitwise(-8) except ValueError: print(\\"ValueError caught as expected\\") assert is_power_of_two_log(1) == True assert is_power_of_two_log(2) == True assert is_power_of_two_log(3) == False assert is_power_of_two_log(16) == True assert is_power_of_two_log(18) == False assert is_power_of_two_log(0) == False try: is_power_of_two_log(-8) except ValueError: print(\\"ValueError caught as expected\\") ``` # Notes - Investigate the efficiency and edge cases for both methods. - Discuss the advantages and limitations of using bitwise operations versus logarithms for this problem. - Ensure to handle edge cases and provide comprehensive testing for both implementations.","solution":"import math def is_power_of_two_bitwise(number: int) -> bool: This function checks if a number is a power of two using bitwise operations. if number < 0: raise ValueError(\\"Number must be non-negative.\\") # A number is a power of two if and only if it has exactly one bit set in the binary representation. # For example, 4 (binary 100) is a power of two, but 5 (binary 101) is not. return number != 0 and (number & (number - 1)) == 0 def is_power_of_two_log(number: int) -> bool: This function checks if a number is a power of two using logarithms. if number < 0: raise ValueError(\\"Number must be non-negative.\\") if number == 0: return False # A number is a power of two if log2(number) is an integer. return math.log2(number).is_integer()"},{"question":"# Coding Assessment Question Scenario You are working with a document management system that needs to handle versioning of documents. Each document is identified by its unique ID and can have multiple versions. Objective Write a function `get_latest_version` that takes a list of document versions and outputs the latest version of each document based on their version numbers. Function Signature ```python def get_latest_version(documents: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Given a list of document versions, find and return the latest version of each document. Parameters: documents (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers - document ID and its version number. Returns: List[Tuple[int, int]]: A list of tuples representing the latest version of each document. ``` Input 1. `documents` (List[Tuple[int, int]]): A list of tuples where each tuple has: - `document_id` (int): An identifier for the document. - `version_number` (int): The version number of the document. Output * A list of tuples representing the latest version of each document, expressed as (document ID, latest version number). Constraints * The length of the documents list is between 1 and 1000. * Document IDs and version numbers are positive integers. * Multiple documents can have the same document ID but with different version numbers. Example ```python get_latest_version([(1, 2), (2, 1), (1, 3), (2, 5), (1, 1)]) # Output: [(2, 5), (1, 3)] get_latest_version([(5, 1), (3, 2), (5, 3), (3, 4)]) # Output: [(3, 4), (5, 3)] get_latest_version([(8, 1), (8, 4), (8, 2), (8, 5)]) # Output: [(8, 5)] ``` Requirements * You must efficiently find the latest version of each document. * Ensure the function handles edge cases such as documents with multiple duplicates or only one version.","solution":"from typing import List, Tuple def get_latest_version(documents: List[Tuple[int, int]]) -> List[Tuple[int, int]]: latest_versions = {} for doc_id, version in documents: if doc_id not in latest_versions or version > latest_versions[doc_id]: latest_versions[doc_id] = version result = [(doc_id, version) for doc_id, version in latest_versions.items()] return result"},{"question":"# Problem Statement You are given a list of integers representing the heights of consecutive buildings. Your task is to implement a function that computes the number of \\"peaks\\" in the list. A peak is defined as an element that is strictly greater than its immediate neighbors. # Requirements Implement the function `count_peaks(heights: list) -> int` such that: 1. The function accepts a list of integers. 2. It returns an integer representing the number of peaks in the list. 3. If the input is not a list, the function should raise a `TypeError` with a message. # Input Format - `heights`: A list of integers representing the heights of buildings. # Output Format - An integer representing the number of peaks in the input list. # Constraints - You may assume the elements in the list are integers within the range [-10^6, 10^6]. - The length of the list, `n`, will be such that `1 <= n <= 1000`. # Performance Requirements Ensure that the function is optimized to handle the upper constraint limit efficiently. # Example 1. Example 1: - Input: `heights = [1, 2, 3, 1, 5, 6, 4]` - Output: `2` 2. Example 2: - Input: `heights = [5, 10, 20, 15, 7, 11, 9]` - Output: `2` 3. Example 3: - Input: `heights = [10, 8, 6, 4, 2, 1]` - Output: `0` # Edge Cases - The list has fewer than 3 elements. - Non-list input types. - The list is in strictly increasing or decreasing order. ```python def count_peaks(heights: list) -> int: :param heights: a list of integers representing building heights. :return: an integer count of the number of peaks in the list. Raises: TypeError: If the input is not a list. if not isinstance(heights, list): raise TypeError(f\\"The input value of [heights={heights}] is not a list\\") if len(heights) < 3: return 0 peaks = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peaks += 1 return peaks ``` Test your function with edge cases and various inputs to ensure robustness and correctness.","solution":"def count_peaks(heights: list) -> int: :param heights: a list of integers representing building heights. :return: an integer count of the number of peaks in the list. Raises: TypeError: If the input is not a list. if not isinstance(heights, list): raise TypeError(f\\"The input value of [heights={heights}] is not a list\\") if len(heights) < 3: return 0 peaks = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peaks += 1 return peaks"},{"question":"Temperature Conversion Utility # Background Temperature scales, Celsius, Fahrenheit, and Kelvin, are commonly used in science, industry, and daily life. Conversion between these scales is often necessary for various applications. # Problem You are required to write a class `TemperatureConverter` that provides methods to convert temperatures between Celsius, Fahrenheit, and Kelvin. # Methods - `celsius_to_fahrenheit(celsius: float) -> float`: Converts Celsius to Fahrenheit. - `celsius_to_kelvin(celsius: float) -> float`: Converts Celsius to Kelvin. - `fahrenheit_to_celsius(fahrenheit: float) -> float`: Converts Fahrenheit to Celsius. - `fahrenheit_to_kelvin(fahrenheit: float) -> float`: Converts Fahrenheit to Kelvin. - `kelvin_to_celsius(kelvin: float) -> float`: Converts Kelvin to Celsius. - `kelvin_to_fahrenheit(kelvin: float) -> float`: Converts Kelvin to Fahrenheit. # Formulas - Celsius to Fahrenheit: ( F = (C times frac{9}{5}) + 32 ) - Celsius to Kelvin: ( K = C + 273.15 ) - Fahrenheit to Celsius: ( C = frac{(F - 32) times 5}{9} ) - Fahrenheit to Kelvin: ( K = frac{(F - 32) times 5}{9} + 273.15 ) - Kelvin to Celsius: ( C = K - 273.15 ) - Kelvin to Fahrenheit: ( F = (K - 273.15) times frac{9}{5} + 32 ) # Inputs and Outputs - Each method will take a single floating-point number representing the temperature in the given scale. - Each method will return a floating-point number, representing the converted temperature rounded to two decimal places. # Example ```python converter = TemperatureConverter() assert converter.celsius_to_fahrenheit(0) == 32.0 assert converter.celsius_to_kelvin(100) == 373.15 assert converter.fahrenheit_to_celsius(32) == 0.0 assert converter.fahrenheit_to_kelvin(212) == 373.15 assert converter.kelvin_to_celsius(273.15) == 0.0 assert converter.kelvin_to_fahrenheit(373.15) == 212.0 ``` **Your task** is to implement the `TemperatureConverter` class with all its methods properly calculating and returning the converted temperatures as specified by the formulas and adhering to the input/output requirements described.","solution":"class TemperatureConverter: @staticmethod def celsius_to_fahrenheit(celsius: float) -> float: fahrenheit = (celsius * 9/5) + 32 return round(fahrenheit, 2) @staticmethod def celsius_to_kelvin(celsius: float) -> float: kelvin = celsius + 273.15 return round(kelvin, 2) @staticmethod def fahrenheit_to_celsius(fahrenheit: float) -> float: celsius = (fahrenheit - 32) * 5/9 return round(celsius, 2) @staticmethod def fahrenheit_to_kelvin(fahrenheit: float) -> float: kelvin = (fahrenheit - 32) * 5/9 + 273.15 return round(kelvin, 2) @staticmethod def kelvin_to_celsius(kelvin: float) -> float: celsius = kelvin - 273.15 return round(celsius, 2) @staticmethod def kelvin_to_fahrenheit(kelvin: float) -> float: fahrenheit = (kelvin - 273.15) * 9/5 + 32 return round(fahrenheit, 2)"},{"question":"Problem Statement You are given a string representing a mathematical expression that includes numbers, and the operators \'+\', \'-\', \'*\', \'/\', and parentheses \'()\'. Your task is to evaluate the expression and return the result as a float. Write a function `evaluate_expression(expression: str) -> float` that takes a single parameter: - `expression` (a string): The input string containing the mathematical expression to evaluate. The function should return the result of the expression as a float. # Constraints 1. The input string will have at most length `1000`. 2. The input string will only contain valid characters that could appear in a mathematical expression (numbers, operators \'+\', \'-\', \'*\', \'/\', and parentheses \'()\'). 3. Division by zero should be handled and return `float(\'inf\')` if it occurs. # Example ```python def evaluate_expression(expression: str) -> float: # TODO: Write your implementation here ``` Input: ```python evaluate_expression(\\"3+2*(2-1)\\") ``` Output: ```python 5.0 ``` Input: ```python evaluate_expression(\\"(4+8)/2\\") ``` Output: ```python 6.0 ``` Input: ```python evaluate_expression(\\"10/(2-2)\\") ``` Output: ```python inf ``` # Notes - Your solution should correctly handle nested parentheses and operator precedence. - Ensure efficient evaluation of the expression. - Handle edge cases such as division by zero and empty parentheses.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression provided as a string. Parameters: expression (str): The input string containing the mathematical expression to evaluate. Returns: float: The result of the mathematical expression. try: # Using eval for simplicity, but with caution result = eval(expression) # Convert to float return float(result) except ZeroDivisionError: return float(\'inf\')"},{"question":"# Scenario You are a software engineer working on a project that involves processing large datasets. One of the tasks requires standardizing different columns in a dataframe to have a mean of 0 and a standard deviation of 1, which is a common preprocessing step for many machine learning models. # Problem Statement Write a function called `standardize_columns` that takes a pandas dataframe and a list of column names to standardize. The function should return a new dataframe where the specified columns are standardized to have a mean of 0 and a standard deviation of 1. # Function Signature ```python import pandas as pd def standardize_columns(df: pd.DataFrame, columns: list) -> pd.DataFrame: pass ``` # Input - `df` (pd.DataFrame): A pandas dataframe containing the data to be processed. - `columns` (list): A list of column names (strings) in the dataframe that should be standardized. # Output - Returns a new pandas dataframe with the specified columns standardized. The other columns should remain unchanged. # Constraints - Each column to be standardized should contain numerical values. - If the dataframe is empty or the column list is empty, return the original dataframe. - Handle cases where columns specified for standardization do not exist in the dataframe by raising an appropriate exception with a clear message. # Examples ```python >>> data = { ... \'A\': [1, 2, 3, 4, 5], ... \'B\': [10, 20, 30, 40, 50], ... \'C\': [100, 200, 300, 400, 500] ... } >>> df = pd.DataFrame(data) >>> standardize_columns(df, [\'A\', \'B\']) A B C 0 -1.264911 -1.264911 100 1 -0.632456 -0.632456 200 2 0.000000 0.000000 300 3 0.632456 0.632456 400 4 1.264911 1.264911 500 >>> standardize_columns(df, [\'C\']) A B C 0 1 10 -1.264911 1 2 20 -0.632456 2 3 30 0.000000 3 4 40 0.632456 4 5 50 1.264911 ``` # Notes - Use pandas\' vectorized operations to achieve efficient computations. - Ensure to round the standardized values to a reasonable number of decimal places to avoid floating-point precision issues in the output.","solution":"import pandas as pd def standardize_columns(df: pd.DataFrame, columns: list) -> pd.DataFrame: if df.empty or not columns: return df for col in columns: if col not in df.columns: raise ValueError(f\\"Column \'{col}\' does not exist in the DataFrame.\\") mean = df[col].mean() std = df[col].std() if std == 0: raise ValueError(f\\"Column \'{col}\' has a standard deviation of zero, cannot standardize.\\") df[col] = (df[col] - mean) / std return df"},{"question":"Question: Reverse Words in a Sentence # Scenario You have been asked to create a utility for processing text data as part of a language analysis tool. Your goal is to implement a function that reverses the order of words in a given sentence while preserving all other formatting. # Implementation Requirements - Implement a function `reverse_words(sentence: str) -> str` that takes a string input representing a sentence and returns a new string with the order of words reversed. # Input - A single string representing a sentence, e.g., `\\"Hello, world!\\"`. # Output - A single string where the words have been reversed in order, preserving the original punctuation and spacing, e.g., `\\"world! Hello,\\"`. # Constraints - The input string may contain punctuation, numbers, and whitespaces. - The input string mut not be empty. # Example ```python sentence = \\"Hello, this is a test.\\" print(reverse_words(sentence)) # Output: \\"test. a is this Hello,\\" sentence = \\"Python programming is fun!\\" print(reverse_words(sentence)) # Output: \\"fun! is programming Python\\" ``` # Edge Cases - Sentence with multiple spaces between words, e.g., `\\"Hello, world!\\"` should be reversed properly with spacing maintained. - Sentence with no spaces should return the same input, e.g., `\\"Test\\"` should return `\\"Test\\"`. - Preserve the original capitalization and punctuation locations. # Hint - Consider using Python\'s `split` method to handle word separation and `join` method to compose the final sentence.","solution":"def reverse_words(sentence: str) -> str: Returns the sentence with the order of words reversed, preserving punctuation and spacing. words = sentence.split() reversed_words = words[::-1] return \\" \\".join(reversed_words)"},{"question":"# Water Container Problem Context You are given an input list representing the heights of vertical lines on a 2D plane. Each line\'s endpoints are at (i, 0) and (i, height[i]). The task is to find two lines such that the container they form with the x-axis contains the most water. Function Definition Implement the `max_water_container(heights: List[int]) -> int` function. **Input**: - `heights` (List[int]): A list of non-negative integers representing the height of vertical lines. **Output**: - An integer representing the maximum amount of water the container can hold. Constraints: - The length of the list `heights` will be between 2 and 10^5. - All height values will be in the range [0, 10^4]. - The container formed should be between two different lines. Example: ```python assert max_water_container([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_water_container([1, 1]) == 1 assert max_water_container([4, 3, 2, 1, 4]) == 16 assert max_water_container([1, 2, 1]) == 2 ``` Requirements: 1. The function should aim for O(n) time complexity by optimizing the traversal. 2. Use a two-pointer technique to determine the maximum container size efficiently. # Explanation: The question requires you to determine the maximum volume of water that can be trapped between two vertical lines on a plane, exploring efficient algorithms through clear constraints and thorough testing examples.","solution":"from typing import List def max_water_container(heights: List[int]) -> int: Returns the maximum amount of water that the container can hold. Args: heights (List[int]): A list of non-negative integers representing the height of vertical lines. Returns: int: The maximum amount of water the container can hold. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) current_area = width * height max_area = max(max_area, current_area) # Move the shorter line to try to find a taller one if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Scenario You work at a financial institution and are asked to create a utility that processes transaction data for various currencies. The goal is to convert transaction amounts from their respective currencies into a standard currency, such as USD, to simplify financial analysis and reporting. # Problem Statement Implement the `currency_conversion` function that converts a given transaction amount from one currency to another using predefined exchange rates. The function should ensure valid inputs and appropriately handle cases where the conversion cannot be performed due to invalid input values. # Function Signature ```python def currency_conversion(amount: float, from_currency: str, to_currency: str) -> float: ``` # Input * `amount` (float): The numerical value representing the transaction amount. * `from_currency` (str): The currency code of the input transaction amount, which can be one of: - \'USD\' - \'EUR\' - \'JPY\' - \'GBP\' - \'AUD\' - \'CAD\' - \'CHF\' - \'CNY\' * `to_currency` (str): The target currency code to which the transaction amount should be converted. Possible values are: - \'USD\' - \'EUR\' - \'JPY\' - \'GBP\' - \'AUD\' - \'CAD\' - \'CHF\' - \'CNY\' # Output * Returns a float representing the converted transaction amount. # Exception Handling * Raise a `ValueError` if `from_currency` or `to_currency` is not one of the supported currency codes. * Display an appropriate error message on invalid inputs. # Constraints * Predefined exchange rates should be used in the function. Ensure precision is maintained for financial calculations. * The function must handle a wide range of transaction amounts without running into precision issues. # Example ```python # Example usage of currency_conversion with hypothetical exchange rates print(currency_conversion(100, \\"USD\\", \\"EUR\\")) # 85.0 assuming 1 USD = 0.85 EUR print(currency_conversion(2000, \\"JPY\\", \\"USD\\")) # 18.18 assuming 1 JPY = 0.00909 USD ``` # Test Cases Ensure your function passes the following test cases: 1. `currency_conversion(150, \\"GBP\\", \\"USD\\")` should return `195.0` assuming 1 GBP = 1.3 USD 2. `currency_conversion(1000, \\"AUD\\", \\"CAD\\")` should return `935.0` assuming 1 AUD = 0.935 CAD 3. `currency_conversion(500, \\"XYZ\\", \\"USD\\")` should raise a `ValueError`","solution":"def currency_conversion(amount: float, from_currency: str, to_currency: str) -> float: exchange_rates = { \'USD\': {\'EUR\': 0.85, \'JPY\': 110.0, \'GBP\': 0.75, \'AUD\': 1.4, \'CAD\': 1.25, \'CHF\': 0.91, \'CNY\': 6.45, \'USD\': 1.0}, \'EUR\': {\'USD\': 1.18, \'JPY\': 129.53, \'GBP\': 0.88, \'AUD\': 1.65, \'CAD\': 1.47, \'CHF\': 1.07, \'CNY\': 7.57, \'EUR\': 1.0}, \'JPY\': {\'USD\': 0.0091, \'EUR\': 0.0077, \'GBP\': 0.0068, \'AUD\': 0.0128, \'CAD\': 0.0113, \'CHF\': 0.0083, \'CNY\': 0.0585, \'JPY\': 1.0}, \'GBP\': {\'USD\': 1.3, \'EUR\': 1.14, \'JPY\': 150.6, \'AUD\': 1.84, \'CAD\': 1.63, \'CHF\': 1.21, \'CNY\': 8.6, \'GBP\': 1.0}, \'AUD\': {\'USD\': 0.72, \'EUR\': 0.61, \'JPY\': 82.5, \'GBP\': 0.54, \'CAD\': 0.94, \'CHF\': 0.66, \'CNY\': 4.65, \'AUD\': 1.0}, \'CAD\': {\'USD\': 0.80, \'EUR\': 0.68, \'JPY\': 88.0, \'GBP\': 0.61, \'AUD\': 1.06, \'CHF\': 0.71, \'CNY\': 4.95, \'CAD\': 1.0}, \'CHF\': {\'USD\': 1.10, \'EUR\': 0.93, \'JPY\': 118.0, \'GBP\': 0.83, \'AUD\': 1.52, \'CAD\': 1.41, \'CNY\': 7.0, \'CHF\': 1.0}, \'CNY\': {\'USD\': 0.15, \'EUR\': 0.13, \'JPY\': 17.09, \'GBP\': 0.12, \'AUD\': 0.215, \'CAD\': 0.202, \'CHF\': 0.143, \'CNY\': 1.0}, } if from_currency not in exchange_rates: raise ValueError(f\\"Unsupported from_currency: {from_currency}\\") if to_currency not in exchange_rates[from_currency]: raise ValueError(f\\"Unsupported to_currency: {to_currency}\\") rate = exchange_rates[from_currency][to_currency] converted_amount = amount * rate return round(converted_amount, 2)"},{"question":"# Question Objective Implement a function to convert a given integer into its corresponding column title in an Excel sheet. This involves converting the number to a string that follows Excel\'s column naming convention (e.g., 1 -> \'A\', 27 -> \'AA\'). Function Signature ```python def number_to_excel_column(n: int) -> str: ``` Input * **n (int)**: The given integer which denotes the column number. `1 <= n <= 10^9`. Output * **Return (str)**: The corresponding column title in Excel format. Constraints * Ensure the function optimally handles the upper bound where the column number can be large. * Consider edge cases like the smallest and largest possible values of `n`. Example ```python # Example 1: input: n = 1 output: \'A\' # Example 2: input: n = 28 output: \'AB\' # Example 3: input: n = 701 output: \'ZY\' ``` Scenario Context Imagine you are working on a system that interfaces with Excel files. You need a utility function to convert column numbers to their corresponding column titles as used in Excel spreadsheets. This conversion is crucial when dynamically generating or interpreting Excel files programmatically. **Your task** is to implement the `number_to_excel_column` function to achieve this conversion efficiently.","solution":"def number_to_excel_column(n: int) -> str: Converts an integer column number to its corresponding Excel column title. result = [] while n > 0: n -= 1 # decrement n to handle 1-based indexing result.append(chr(n % 26 + ord(\'A\'))) n //= 26 return \'\'.join(result[::-1])"},{"question":"Context You are a software engineer tasked with developing a module that performs text analysis on transcripts of conversations. One of the key requirements is to count the frequency of specific keywords within the text. Requirements Write two functions, `count_keyword_frequency` and `count_all_keywords`, based on the following specifications: # Function 1: count_keyword_frequency **Input**: - `transcript`: A string representing the text of the conversation. - `keyword`: A string representing the keyword to be counted. **Output**: - Returns an integer representing the frequency of the `keyword` in the `transcript`. **Constraints**: - The comparison should be case-insensitive. - If `keyword` is an empty string, return 0. - Non-alphabetical characters in the text should be considered part of the word boundaries. # Function 2: count_all_keywords **Input**: - `transcript`: A string representing the text of the conversation. - `keywords`: A list of strings representing the keywords to be counted. **Output**: - Returns a dictionary where the keys are the keywords and the values are the integers representing the frequency of each keyword in the `transcript`. **Constraints**: - The comparison should be case-insensitive. - If `keywords` contains any empty string, ignore that entry. - Non-alphabetical characters in the text should be considered part of the word boundaries. Example Usage ```python assert count_keyword_frequency(\\"Hello world! Hello!\\", \\"hello\\") == 2 assert count_keyword_frequency(\\"The quick brown fox jumps over the lazy dog.\\", \\"The\\") == 1 assert count_keyword_frequency(\\"The quick brown fox jumps over the lazy dog.\\", \\"\\") == 0 assert count_keyword_frequency(\\"The quick brown fox jumps over the lazy dog.\\", \\"cat\\") == 0 assert count_all_keywords(\\"Hello world! Hello!\\", [\\"hello\\", \\"world\\"]) == {\\"hello\\": 2, \\"world\\": 1} assert count_all_keywords(\\"The quick brown fox jumps over the lazy dog.\\", [\\"the\\", \\"quick\\", \\"dog\\", \\"cat\\"]) == {\\"the\\": 2, \\"quick\\": 1, \\"dog\\": 1, \\"cat\\": 0} assert count_all_keywords(\\"The quick brown fox jumps over the lazy dog.\\", [\\"\\"]) == {} assert count_all_keywords(\\"The quick brown fox jumps over the lazy dog.\\", [\\"the\\", \\"\\", \\"lazy\\"]) == {\\"the\\": 2, \\"lazy\\": 1} ``` Make sure to handle edge cases and validate inputs as specified.","solution":"import re from collections import defaultdict def count_keyword_frequency(transcript, keyword): Returns the frequency of the keyword in the transcript. Parameters: - transcript (str): The text of the conversation. - keyword (str): The keyword to be counted. Returns: - int: The frequency of the keyword in the transcript. if not keyword: return 0 # Make case-insensitive search keyword = keyword.lower() words = re.findall(r\'bw+b\', transcript.lower()) return words.count(keyword) def count_all_keywords(transcript, keywords): Returns a dictionary with the frequency of each keyword in the transcript. Parameters: - transcript (str): The text of the conversation. - keywords (list): The list of keywords to be counted. Returns: - dict: A dictionary where keys are keywords and values are their respective frequencies. # Filter out empty keywords valid_keywords = [keyword.lower() for keyword in keywords if keyword] result = defaultdict(int) # If no valid keywords, return an empty dictionary if not valid_keywords: return result words = re.findall(r\'bw+b\', transcript.lower()) for word in words: if word in valid_keywords: result[word] += 1 # Ensure all keywords are included in the result for keyword in valid_keywords: if keyword not in result: result[keyword] = 0 return result"},{"question":"# String Parsing and Keyword Extraction Problem Statement A text analysis company needs to extract specific keywords from a paragraph of text. These keywords are used for indexing and search optimization. As a software developer, you\'re asked to implement a mechanism that will parse a given paragraph and extract predefined keywords. Objectives 1. Write a function `extract_keywords` that extracts specific keywords from a given paragraph of text. 2. Keywords should be case insensitive and extracted in the order they appear in the text. 3. The extracted keywords should be unique in the result, preserving their first occurrence. Function Signature ```python def extract_keywords(paragraph: str, keywords: list) -> list: Extracts specific keywords from the given paragraph. Parameters: paragraph (str): The paragraph of text to be parsed keywords (list): The list of predefined keywords to be extracted Returns: list: A list of extracted keywords in the order they appear in the text pass ``` Example ```python paragraph = \\"Natural Language Processing is a field of Artificial Intelligence. It includes tasks like word tokenization, syntactic analysis, and semantic understanding. Python is widely used for NLP.\\" keywords = [\\"natural language processing\\", \\"artificial intelligence\\", \\"python\\", \\"nlp\\"] extracted_keywords = extract_keywords(paragraph, keywords) print(f\\"Extracted Keywords: {extracted_keywords}\\") ``` Expected Output ``` Extracted Keywords: [\'Natural Language Processing\', \'Artificial Intelligence\', \'Python\', \'NLP\'] ``` Constraints 1. `paragraph` consists of printable ASCII characters. 2. `keywords` are given as a list of case insensitive strings. 3. Keywords, in the result list, should retain their case as they appear in the text. 4. The length of `paragraph` can be up to 10,000 characters. 5. The length of `keywords` list is limited to 100 items. Ensure the function is efficient and can handle the edge cases where keywords might overlap or be part of other words in the paragraph.","solution":"def extract_keywords(paragraph: str, keywords: list) -> list: Extracts specific keywords from the given paragraph. Parameters: paragraph (str): The paragraph of text to be parsed keywords (list): The list of predefined keywords to be extracted Returns: list: A list of extracted keywords in the order they appear in the text lowercase_paragraph = paragraph.lower() encountered_keywords = set() result = [] for keyword in keywords: keyword_lower = keyword.lower() if keyword_lower in lowercase_paragraph and keyword_lower not in encountered_keywords: start_index = lowercase_paragraph.find(keyword_lower) end_index = start_index + len(keyword_lower) result.append(paragraph[start_index:end_index]) encountered_keywords.add(keyword_lower) return result"},{"question":"# Question Style Context **You are tasked with developing a system that manages orders at a fictional e-commerce store. One of the essential components is the ability to calculate the total cost of an order after applying various discounts. Discounts are either a fixed value off the total or a percentage reduction.** Task Implement a function that calculates the final total cost of an order given the initial price and a list of discounts. The function should ensure that discounts are applied in the order they are given. Function Specification ```python def calculate_final_price(initial_price: float, discounts: list) -> float: This function should calculate the final price of an order after applying a series of discounts. Arguments: initial_price (float): The initial price of the order. discounts (list): A list of discounts to be applied. Each discount is represented by a tuple where the first element is a string (\'fixed\' or \'percent\') indicating the type of discount and the second element is a float representing the discount value. Returns: float: The final price after applying all discounts, rounded to two decimal places. Raises: ValueError: if initial_price is not positive or if a discount value is invalid. Example: >>> calculate_final_price(100, [(\'fixed\', 5), (\'percent\', 10)]) 85.50 >>> calculate_final_price(200, [(\'percent\', 10), (\'fixed\', 20)]) 160.00 >>> calculate_final_price(80, [(\'fixed\', 10), (\'percent\', 50)]) 35.00 >>> calculate_final_price(50, [(\'percent\', 200)]) Raises ValueError: Invalid discount percentage pass # Your code here ``` Constraints 1. `initial_price` must be greater than 0. 2. Each discount must be: - If type is \'fixed\', the value should be non-negative and no greater than the current price. - If type is \'percent\', the value should be between 0 and 100 inclusive. 3. The final price should not go below zero. Performance Requirements The nature of the input ensures the time complexity should be O(n) where n is the number of discounts. Your Task Implement the function `calculate_final_price` as specified. Ensure that your function passes all the given test cases.","solution":"def calculate_final_price(initial_price: float, discounts: list) -> float: if initial_price <= 0: raise ValueError(\\"Initial price must be positive\\") final_price = initial_price for discount in discounts: if discount[0] == \'fixed\': if discount[1] < 0: raise ValueError(\\"Invalid fixed discount value\\") final_price -= discount[1] elif discount[0] == \'percent\': if not (0 <= discount[1] <= 100): raise ValueError(\\"Invalid discount percentage\\") percentage_reduction = (discount[1] / 100) * final_price final_price -= percentage_reduction if final_price < 0: final_price = 0 return round(final_price, 2)"},{"question":"# Problem Statement: Find Common Elements in K-Sorted Lists You are given a list of `k` sorted lists containing integers. Your task is to implement an algorithm that finds all the common elements across all the lists. # Function Signature ```python def find_common_elements(lists: list[list[int]]) -> list[int]: pass ``` # Parameters * `lists` (list of list of integers): A list containing `k` sorted lists of integers. # Output * A list of integers containing all the elements that are present in each of the input lists. The output list should be sorted in ascending order. # Constraints * The number of sorted lists, `k`, will be at least 2. * Each sorted list may have between 1 and 10,000 integers. * The integers in the lists are within the range `-10^9` to `10^9`. * The input lists are sorted in non-decreasing order. * The output list, if any common elements exist, must also be sorted in non-decreasing order. If no common elements exist, return an empty list. # Examples ```python # Example 1 lists = [ [1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [2, 3, 5, 7, 8] ] print(find_common_elements(lists)) # Expected Output: [2, 3, 5] # Example 2 lists = [ [1, 3, 5], [2, 4, 6], [7, 9, 10] ] print(find_common_elements(lists)) # Expected Output: [] # Example 3 lists = [ [1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 3, 6] ] print(find_common_elements(lists)) # Expected Output: [1, 2, 3] ``` # Additional Information 1. Consider edge cases such as very small lists or lists where there are no common elements. 2. Ensure that the solution is optimized for performance, especially for larger lists. 3. The implementation should handle cases efficiently where the lists have disjoint sets of integers.","solution":"from collections import Counter def find_common_elements(lists: list[list[int]]) -> list[int]: Finds all common elements across all given sorted lists and returns them in sorted order. # Using a counter dictionary to count occurrence of each element in all lists. element_count = Counter() for lst in lists: element_count.update(set(lst)) # We only need elements which are present in all lists, which means the count should be equal to the number of lists. common_elements = [element for element, count in element_count.items() if count == len(lists)] # Return the sorted list of common elements. return sorted(common_elements)"},{"question":"# Context As part of a data analysis project, you need to create a tool that processes a collection of numerical data points. One key requirement is to compute the running median of a dynamically updating stream of numbers. # Task Write a class `RunningMedian` that maintains a stream of numbers and allows computation of the median of the current list at any given state. # Class Specification **Class Name**: `RunningMedian` Methods * `__init__(self)`: Initializes an empty list to store the numbers. * `add_number(self, num: float) -> None`: Adds a new number to the stream. * `get_median(self) -> float`: Computes and returns the median of the current list of numbers. # Example ```python # Initialize the RunningMedian class running_median = RunningMedian() # Adding numbers to the stream running_median.add_number(1) running_median.add_number(3) running_median.add_number(2) # Getting the median after each addition print(running_median.get_median()) # Output: 2.0 running_median.add_number(4) print(running_median.get_median()) # Output: 2.5 running_median.add_number(5) print(running_median.get_median()) # Output: 3.0 ``` # Notes * The median of a list of numbers is the middle number if the list is odd in length, and the average of the two middle numbers if the list is even in length. * Implementing this efficiently may require using data structures like a min-heap and max-heap to maintain the balance. However, simple approaches that sort the list each time are also acceptable depending on the desired complexity. # Constraints * The stream will not contain more than 10^5 numbers. * Each added `num` will be a float value in the range of -10^6 to 10^6.","solution":"import bisect class RunningMedian: def __init__(self): self.nums = [] def add_number(self, num: float) -> None: bisect.insort(self.nums, num) def get_median(self) -> float: n = len(self.nums) if n == 0: raise ValueError(\\"No elements in the list\\") if n % 2 == 1: return float(self.nums[n // 2]) else: return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2.0"},{"question":"# Question: Kth Smallest Element in a Sorted Matrix Context: A sorted matrix is a matrix in which each of the rows and each of the columns is sorted in non-decreasing order. You are given such a matrix and need to find the k-th smallest element in it. Specification: * Function Name: `kth_smallest` * Input: - An integer matrix `matrix` of dimensions n x n, where rows and columns are sorted in non-decreasing order. - An integer `k`. * Output: Return the k-th smallest element in the given sorted matrix. * Constraints: 1 ≤ n ≤ 300; 1 ≤ matrix[i][j] ≤ 10^9; 1 ≤ k ≤ n^2. Requirements: Implement the function `kth_smallest` such that it accepts the sorted matrix and the integer `k`, and returns the k-th smallest element in the matrix. Example: ```python def kth_smallest(matrix: List[List[int]], k: int) -> int: from heapq import heappop, heappush n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): # No need to push more than k elements in the heap initially heappush(min_heap, (matrix[r][0], r, 0)) # Perform k-1 extractions to get the k-th smallest element for _ in range(k - 1): val, r, c = heappop(min_heap) if c + 1 < n: heappush(min_heap, (matrix[r][c+1], r, c+1)) return heappop(min_heap)[0] # Examples print(kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8)) # should return 13 print(kth_smallest([[1, 2], [1, 3]], 2)) # should return 1 ``` Additional Information: * The problem integrates concepts of sorting, binary search, and heap data structures for efficient computation. * Focus on optimal time and space complexity, especially considering the constraints. * Ensure appropriate handling of edge cases, such as small and large matrix sizes and `k` values.","solution":"from heapq import heappop, heappush from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Finds the k-th smallest element in a sorted matrix. n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): # No need to push more than k elements in the heap initially heappush(min_heap, (matrix[r][0], r, 0)) # Perform k-1 extractions to get the k-th smallest element for _ in range(k - 1): val, r, c = heappop(min_heap) if c + 1 < n: heappush(min_heap, (matrix[r][c+1], r, c+1)) return heappop(min_heap)[0]"},{"question":"# Generate Fibonacci Sequence in Range Objective: **Write a function to generate all Fibonacci numbers within a given range [low, high], and return them as a list.** Task: Implement the following function: **`fibonacci_in_range(low, high)`** - Parameters: * `low` (int): The lower bound of the range. * `high` (int): The upper bound of the range. - Returns: * `List[int]`: A list of all Fibonacci numbers within the specified range [low, high], inclusive. Constraints: * 0 <= low <= high <= 10^9 * The number of Fibonacci numbers within the range will not exceed 1000. Example Input: ```python low = 10 high = 100 ``` Example Output: ```python result = [13, 21, 34, 55, 89] ``` Function Signature: ```python def fibonacci_in_range(low: int, high: int) -> List[int]: pass ``` Brief Scenario: Consider you are developing a functionality for a mathematical library where a user may want to find all Fibonacci numbers between a given range. The Fibonacci sequence starts with 0 and 1, and the next numbers are the sum of the previous two. Given a range [low, high], your task is to generate all Fibonacci numbers within this range, which can be a useful tool in numerical analysis or algorithm design contexts.","solution":"def fibonacci_in_range(low, high): Returns all Fibonacci numbers within a specified range [low, high]. Parameters: low (int): The lower bound of the range. high (int): The upper bound of the range. Returns: List[int]: A list of all Fibonacci numbers within the specified range [low, high]. fibs = [] a, b = 0, 1 while a <= high: if a >= low: fibs.append(a) a, b = b, a + b return fibs"},{"question":"# Coding Assessment Question # Context A common problem in mathematics and computer science is to determine whether a number is a perfect square. A number is a perfect square if it can be expressed as the product of an integer with itself. # Task Implement a function `largest_perfect_square(n: int) -> int` that returns the largest perfect square less than or equal to a given integer `n`. # Function Signature ```python def largest_perfect_square(n: int) -> int: pass ``` # Input * `n` (int): The upper limit for the perfect square search (1 ≤ n ≤ 1,000,000). # Output * Returns an integer representing the largest perfect square less than or equal to `n`. # Example ```python >>> largest_perfect_square(17) 16 >>> largest_perfect_square(26) 25 >>> largest_perfect_square(1) 1 ``` # Constraints * The solution should utilize an efficient approach to find the largest perfect square without iterating over all possible perfect squares. # Performance Requirements * Your solution should run in O(√n) or better time complexity. # Notes * Consider utilizing mathematical functions such as square root to optimize the solution. * Ensure the function handles edge cases such as the smallest value for `n`. # Additional Example ```python >>> largest_perfect_square(1000000) 1000000 ```","solution":"import math def largest_perfect_square(n: int) -> int: Returns the largest perfect square less than or equal to a given integer n. :param n: Upper limit for the perfect square search :type n: int :return: Largest perfect square less than or equal to n :rtype: int if n < 1: return 0 # There is no perfect square less than 1 # Find the integer part of the square root of n root = int(math.sqrt(n)) # The largest perfect square less than or equal to n return root * root"},{"question":"# Problem Statement Implement a class `TemperatureConverter` that can convert temperatures between Celsius, Fahrenheit, and Kelvin scales. The class should support the following methods: 1. `__init__(self, temperature: float, scale: str)`: Initializes the TemperatureConverter with a given temperature and its scale (\'C\' for Celsius, \'F\' for Fahrenheit, \'K\' for Kelvin). Raise a `ValueError` if any scale other than these three is provided. 2. `to_celsius(self) -> float`: Converts the stored temperature to Celsius. 3. `to_fahrenheit(self) -> float`: Converts the stored temperature to Fahrenheit. 4. `to_kelvin(self) -> float`: Converts the stored temperature to Kelvin. # Input and Output Formats - **Input** - `temperature`: a float representing the temperature value. - `scale`: a string representing the temperature scale, restricted to \'C\', \'F\', or \'K\'. - **Output** - Methods return the temperature converted to the desired scale as a float. # Constraints - The temperature value should be a float in the range `[-1e+5, 1e+5]`. - Ensure that the conversion between scales is accurate up to two decimal places. # Example - **Example 1:** ```python tc = TemperatureConverter(100, \'C\') print(tc.to_fahrenheit()) # Expected Output: 212.00 print(tc.to_kelvin()) # Expected Output: 373.15 ``` - **Example 2:** ```python tc = TemperatureConverter(32, \'F\') print(tc.to_celsius()) # Expected Output: 0.00 print(tc.to_kelvin()) # Expected Output: 273.15 ``` - **Example 3:** ```python tc = TemperatureConverter(273.15, \'K\') print(tc.to_celsius()) # Expected Output: 0.00 print(tc.to_fahrenheit()) # Expected Output: 32.00 ``` # Note Ensure that your class handles edge cases where the temperature is extremely low or high while maintaining the precision of the conversions. If an invalid scale is provided during initialization, the constructor should raise a `ValueError` with an appropriate error message.","solution":"class TemperatureConverter: def __init__(self, temperature: float, scale: str): self.temperature = temperature valid_scales = {\'C\', \'F\', \'K\'} if scale not in valid_scales: raise ValueError(\\"Scale must be one of \'C\', \'F\', \'K\'\\") self.scale = scale def to_celsius(self) -> float: if self.scale == \'C\': return self.temperature elif self.scale == \'F\': return (self.temperature - 32) * 5.0 / 9.0 elif self.scale == \'K\': return self.temperature - 273.15 def to_fahrenheit(self) -> float: if self.scale == \'C\': return (self.temperature * 9.0 / 5.0) + 32 elif self.scale == \'F\': return self.temperature elif self.scale == \'K\': return (self.temperature - 273.15) * 9.0 / 5.0 + 32 def to_kelvin(self) -> float: if self.scale == \'C\': return self.temperature + 273.15 elif self.scale == \'F\': return (self.temperature - 32) * 5.0 / 9.0 + 273.15 elif self.scale == \'K\': return self.temperature"},{"question":"# Array Transformation and Validation **Context**: Your task is to implement a function that transforms a given integer array based on specific rules and then validates whether the transformed array meets a target condition. The validation checks if the sum of all elements in the transformed array is equal to a given target sum. # Problem Description **Function Signature**: ```python def transform_and_validate_array(arr: list[int], target_sum: int) -> bool: ``` **Parameters**: - `arr` (list): A list of integers where each integer can be positive, negative, or zero. - `target_sum` (int): An integer representing the target sum to validate against the transformed array. **Output**: - Returns a boolean indicating whether the sum of the elements in the transformed array equals the `target_sum`. # Constraints - The length of `arr` will be between 1 and 1000 inclusive. - The elements of `arr` will be between -1000 and 1000 inclusive. - The `target_sum` can be any integer within the range of -1,000,000 to 1,000,000 inclusive. # Transformation Rules 1. Each positive element in the array should be increased by 1. 2. Each negative element should be turned positive. 3. Zero elements remain unchanged. # Requirements 1. Implement the `transform_and_validate_array` function. 2. Apply the transformation rules to each element in the input array. 3. Check if the sum of the transformed array equals `target_sum` and return the result as a boolean. # Example ```python if __name__ == \\"__main__\\": arr = [1, -2, 3, 0, -4] target_sum = 13 result = transform_and_validate_array(arr, target_sum) # Expected output: True # Explanation: # Transformed array: [2, 2, 4, 0, 4] # Sum of transformed array: 2 + 2 + 4 + 0 + 4 = 12 # The function should return False because 12 != 13. print(result) # Output: False ```","solution":"def transform_and_validate_array(arr: list[int], target_sum: int) -> bool: Transforms the array based on given rules and validates if the sum equals target_sum. Args: arr (list): List of integers to be transformed. target_sum (int): Target sum to validate against transformed array. Returns: bool: True if sum of transformed array equals target_sum, otherwise False. # Apply the transformation rules transformed_array = [(x + 1) if x > 0 else (-x) if x < 0 else x for x in arr] # Calculate the sum of the transformed array transformed_sum = sum(transformed_array) # Validate and return if the sum equals target_sum return transformed_sum == target_sum"},{"question":"**Problem Statement**: You are to simulate an OR gate operation over an array of boolean values. Your task is to implement a function that takes two arrays of equal length, each containing 0s and 1s (representing False and True respectively), and performs the OR operation element-wise between the corresponding elements of the two arrays. # Function Signature ```python def or_gate_array(array1: List[int], array2: List[int]) -> List[int]: pass ``` # Input: * Two arrays `array1` and `array2`, each consisting of integers 0 or 1. * Both arrays will have the same length, which will be in the range `[1, 1000]`. # Output: * Return an array of integers where each element is the result of the OR operation between the corresponding elements of `array1` and `array2`. # Constraints: * The arrays `array1` and `array2` will have the same length. * Each element in `array1` and `array2` will be either 0 or 1. # Example ```python >>> or_gate_array([0, 1, 0, 1], [1, 0, 1, 0]) [1, 1, 1, 1] >>> or_gate_array([1, 0, 0, 1], [0, 1, 1, 0]) [1, 1, 1, 1] >>> or_gate_array([0, 0, 0], [0, 0, 1]) [0, 0, 1] ``` # Instructions 1. Implement the `or_gate_array` function. 2. The function should utilize the OR gate logic where 0 OR 0 = 0, 0 OR 1 = 1, 1 OR 0 = 1, and 1 OR 1 = 1. 3. Ensure your solution handles edge cases where either array is entirely 0s or 1s. 4. Optimize your function for both time and space efficiency within the constraints.","solution":"from typing import List def or_gate_array(array1: List[int], array2: List[int]) -> List[int]: Perform OR operation element-wise between two arrays of equal length. return [array1[i] | array2[i] for i in range(len(array1))]"},{"question":"# Merge K Sorted Lists Assessment Question Your task is to develop an algorithm that merges multiple sorted linked lists into a single sorted linked list. Each of the given lists is individually sorted in increasing order. Task: Write a function `merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]` that takes a single argument: - `lists` (List[Optional[ListNode]]): A list of `k` linked lists, where each linked list is represented by its head node. The value `k` will be at most 1000. The function should return the head node of the merged sorted linked list. Example to Represent ListNode: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Input: - Each linked list is guaranteed to be sorted in increasing order. - The total number of nodes across all linked lists will be at most 20000. Output: - Return the head node of the singly linked list containing all nodes from the input lists, sorted in increasing order. Examples: ```python # Example 1: # Input: lists = [[1,4,5],[1,3,4],[2,6]] # Output: [1,1,2,3,4,4,5,6] # Explanation: The lists represented are: # 1->4->5, 1->3->4, 2->6 # The merged list will be 1->1->2->3->4->4->5->6 >>> l1 = ListNode(1, ListNode(4, ListNode(5))) >>> l2 = ListNode(1, ListNode(3, ListNode(4))) >>> l3 = ListNode(2, ListNode(6)) >>> merge_k_sorted_lists([l1, l2, l3]) ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(4, ListNode(5, ListNode(6)))))))) # Example 2: # Input: lists = [] # Output: [] # Explanation: No lists to merge, so the result is an empty list. >>> merge_k_sorted_lists([]) None # Example 3: # Input: lists = [[]] # Output: [] # Explanation: One list provided and it is empty, so the result is an empty list. >>> merge_k_sorted_lists([None]) None ``` Constraints: - Your algorithm should be efficient in terms of time and space complexity. - Handle edge cases such as empty input lists and lists with no nodes properly.","solution":"import heapq from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None min_heap = [] for i, l in enumerate(lists): if l: heapq.heappush(min_heap, (l.val, i, l)) dummy = ListNode() current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"**Question**: You are tasked with creating a function that reformats a given list of numbers according to a specified format string. The format string contains placeholders that dictate the structure of the output. The placeholders include: - `#d` for a decimal (integer) placeholder - `#f` for a floating-point number placeholder - `#s` for a string placeholder (if there are any string representations among the inputs) The function should substitute each placeholder with the corresponding element from the input list, maintaining the order of appearance. The input list will include integers, floats, and strings (if placeholders allow). # Function Signature ```python def reformat_numbers(numbers: list, format_string: str) -> str: pass ``` # Input * **numbers (list)**: A list of integers, floats, and/or strings. * **format_string (str)**: A string containing placeholders (`#d`, `#f`, `#s`) that dictate the structure of the output. # Output * **Returns (str)**: A string where the placeholders are replaced by the corresponding elements from the input list. # Constraints * The length of `numbers` list is up to ( 10^5 ). * The length of the `format_string` is up to ( 10^6 ). * The format string is guaranteed to have valid placeholders that correspond to the types in the list. # Example ```python print(reformat_numbers([1, 2.5, \\"three\\"], \\"Values: #d, #f, #s.\\")) # Output: \'Values: 1, 2.5, three.\' print(reformat_numbers([123, 456], \\"Numbers: #d and #d.\\")) # Output: \'Numbers: 123 and 456.\' print(reformat_numbers([5.5, 3], \\"Floating: #f, Integer: #d\\")) # Output: \'Floating: 5.5, Integer: 3\' ``` # Explanation 1. **Example 1**: The placeholders `#d`, `#f`, and `#s` are replaced with 1, 2.5, and \\"three\\" respectively. 2. **Example 2**: Both `#d` placeholders are replaced with integers 123 and 456. 3. **Example 3**: The `#f` placeholder is replaced with 5.5 and the `#d` placeholder with 3. # Performance Requirements Your implementation should efficiently handle lists and format strings up to the maximum length constraints and should not exceed memory limitations. Ensure that the function handles various data types within the list correctly as per their placeholders in the format string.","solution":"def reformat_numbers(numbers: list, format_string: str) -> str: Replace placeholders in the format string with corresponding elements from the numbers list. Args: numbers: list of integers, floats, and/or strings. format_string: string containing placeholders (#d, #f, #s). Returns: A formatted string with placeholders replaced by elements from the list. from itertools import cycle iter_numbers = iter(numbers) result_string = \\"\\" i = 0 while i < len(format_string): if format_string[i:i+2] == \\"#d\\": result_string += str(next(iter_numbers)) i += 2 elif format_string[i:i+2] == \\"#f\\": result_string += str(next(iter_numbers)) i += 2 elif format_string[i:i+2] == \\"#s\\": result_string += str(next(iter_numbers)) i += 2 else: result_string += format_string[i] i += 1 return result_string"},{"question":"# Coding Challenge: Palindrome Pairs # Context: A palindrome is a word, phrase, or sequence of characters that reads the same backward as forward. Finding palindrome pairs in a list of words is a common problem that involves checking if the concatenation of two words results in a palindrome. # Task: You need to write a function that, given a list of unique words, finds all the pairs of indices (i, j) such that the concatenation of the words at those indices forms a palindrome. The concatenation should be considered in both orders: `words[i] + words[j]` and `words[j] + words[i]`. # Requirements: 1. Implement a function to find all unique pairs of indices `(i, j)` where the concatenation of `words[i]` and `words[j]` forms a palindrome. 2. Ensure the function handles cases where words can have different lengths. 3. Consider an empty string as a palindrome. 4. The indices in pairs should be in ascending order based on the first index and then the second index. # Input: - A list of unique words `words` containing lowercase English letters. # Output: - A list of pairs `(i, j)` where the concatenation of `words[i]` and `words[j]` forms a palindrome. # Constraints: - The length of `words` will not exceed `500`, and each word will not exceed `100` characters. # Function Signature: ```python from typing import List, Tuple def palindrome_pairs(words: List[str]) -> List[Tuple[int, int]]: pass ``` # Examples: ```python >>> palindrome_pairs([\\"bat\\", \\"tab\\", \\"cat\\"]) [(0, 1), (1, 0)] >>> palindrome_pairs([\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"]) [(0, 1), (1, 0), (3, 2), (2, 4)] >>> palindrome_pairs([\\"a\\", \\"\\"]) [(0, 1), (1, 0)] >>> palindrome_pairs([\\"abc\\", \\"xyz\\", \\"aba\\"]) [] ``` **Note**: You are encouraged to consider edge cases and thoroughly test your implementation. # Evaluation Criteria: - Correctness: Your code should correctly identify all palindrome pairs. - Efficiency: Implement optimal strategies to handle the worst-case time complexity. - Robustness: Your code should handle edge cases and validate inputs properly. - Clarity: Ensure your code is readable and well-documented to explain your logic and approach.","solution":"from typing import List, Tuple def is_palindrome(word: str) -> bool: Helper function to check if a given word is a palindrome. return word == word[::-1] def palindrome_pairs(words: List[str]) -> List[Tuple[int, int]]: Finds all unique pairs of indices (i, j) where the concatenation of words[i] + words[j] or words[j] + words[i] forms a palindrome. result = [] word_to_index = {word: i for i, word in enumerate(words)} for i, word in enumerate(words): n = len(word) for j in range(n + 1): # Split the word into two parts: prefix and suffix prefix, suffix = word[:j], word[j:] # Check if prefix is a palindrome and suffix reversed is a different word in the list if is_palindrome(prefix): suffix_rev = suffix[::-1] if suffix_rev in word_to_index and word_to_index[suffix_rev] != i: result.append((word_to_index[suffix_rev], i)) # Check if suffix is a palindrome and prefix reversed is a different word in the list if j != n and is_palindrome(suffix): # j != n to prevent duplicate pairs for split at position n prefix_rev = prefix[::-1] if prefix_rev in word_to_index and word_to_index[prefix_rev] != i: result.append((i, word_to_index[prefix_rev])) return result"},{"question":"# Problem Statement **Product of Array Except Self** You are required to implement a function that returns an array such that each element at index `i` of the array is the product of all the values in the input array except the value at index `i`. **Function Signature**: ```python def product_except_self(nums: List[int]) -> List[int]: pass ``` **Input**: - `nums` (List[int]): A list of integers. The length of the list is at least 2 and at most 10^4. Each integer is between -10^4 and 10^4. **Output**: - `List[int]`: A list of integers where the value at each index `i` is the product of all integers in the input list except `nums[i]`. **Constraints**: - You must not use the division operation. - Try to design a solution that runs in O(n) time and uses O(n) space. **Example**: ```python >>> product_except_self([1,2,3,4]) >>> [24,12,8,6] >>> product_except_self([0,4,0]) >>> [0,0,0] >>> product_except_self([-1,1,0,-3,3]) >>> [0,0,9,0,0] ``` **Scenario**: You are developing a system that processes large datasets, and you need efficient algorithms to perform complex calculations on the data. **Guidelines**: 1. Ensure that your function handles edge cases, such as the presence of zeroes in the input list. 2. Consider the space complexity of your approach to avoid excessive memory usage. ***","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: length = len(nums) answer = [1] * length left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"# Coding Assessment Question: Palindrome Check and Modification Context You are developing a utility for verifying and transforming strings based on their palindrome properties. Task Write a function `make_palindrome(input_text: str) -> str` that performs the following: 1. Checks if the `input_text` string is a palindrome. 2. If it is not a palindrome, modifies the string by appending the minimum number of characters to make it a palindrome and returns the modified string. Function Signature ```python def make_palindrome(input_text: str) -> str: pass ``` Input * `input_text` (str): A non-empty string consisting of lowercase letters only. Output * Returns a string which is either the original `input_text` if it was already a palindrome, or a modified palindrome version of it. Constraints * The input string length will be between 1 and 1000. Performance Requirements * Aim for a time complexity of O(n^2) and space complexity of O(n). Example ```python >>> make_palindrome(\\"race\\") \\"racecar\\" >>> make_palindrome(\\"madam\\") \\"madam\\" >>> make_palindrome(\\"abc\\") \\"abcba\\" ```","solution":"def make_palindrome(input_text: str) -> str: This function checks if the input_text is a palindrome, and if it is not, modifies it to be a palindrome by adding the minimum number of characters at the end. if input_text == input_text[::-1]: return input_text # Function to find the longest palindromic suffix def longest_palindromic_suffix(text): n = len(text) for i in range(n): if text[i:] == text[i:][::-1]: return text[i:] return \\"\\" lps = longest_palindromic_suffix(input_text) return input_text + input_text[::-1][len(lps):]"},{"question":"# Coding Assessment: Matrix Transpose and Multiplication Write a program that can perform matrix transpose and matrix multiplication for given input matrices. You need to implement two core functions to complete the task: 1. **matrix_transpose** 2. **matrix_multiply** Requirements 1. **matrix_transpose(matrix):** - **Input**: - `matrix` : List of lists, where each inner list represents a row of the matrix. - **Output**: - Returns a new matrix as a list of lists that is the transpose of the input matrix. - **Constraints**: - Ensure the input matrix is non-empty and rectangular (all rows have the same length). 2. **matrix_multiply(matrix_a, matrix_b):** - **Input**: - `matrix_a`: List of lists, where each inner list represents a row of the first matrix. - `matrix_b`: List of lists, where each inner list represents a row of the second matrix. - **Output**: - Returns a new matrix as a list of lists that is the product of `matrix_a` and `matrix_b`. - **Constraints**: - Raise `ValueError` if the matrices cannot be multiplied (i.e., if the number of columns in `matrix_a` is not equal to the number of rows in `matrix_b`). - Ensure both matrices are non-empty and rectangular. Examples ```python # Example 1: Matrix Transpose matrix = [ [1, 2, 3], [4, 5, 6] ] transposed_matrix = matrix_transpose(matrix) # Expected: [[1, 4], [2, 5], [3, 6]] # Example 2: Matrix Multiplication matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] product_matrix = matrix_multiply(matrix_a, matrix_b) # Expected: [[58, 64], [139, 154]] ``` Use the above-mentioned function definitions to implement the required functionality.","solution":"def matrix_transpose(matrix): Returns the transpose of the input matrix. if not matrix or not all(len(row) == len(matrix[0]) for row in matrix): raise ValueError(\\"Invalid matrix: non-rectangular or empty matrix provided.\\") return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] def matrix_multiply(matrix_a, matrix_b): Returns the product of two input matrices. if not matrix_a or not matrix_b or not all(len(row) == len(matrix_a[0]) for row in matrix_a) or not all(len(row) == len(matrix_b[0]) for row in matrix_b): raise ValueError(\\"Invalid matrix: non-rectangular or empty matrices provided.\\") if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Matrices cannot be multiplied. Invalid matrix dimensions.\\") rows_a, cols_a = len(matrix_a), len(matrix_a[0]) cols_b = len(matrix_b[0]) product_matrix = [[0] * cols_b for _ in range(rows_a)] for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): product_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j] return product_matrix"},{"question":"# Subarray Sum Equals K You have started working for a startup that analyzes transaction patterns. One requirement is to identify subarrays of transactions that sum up to a specific target value `k`. This will help in detecting unusual patterns within transaction sequences. Task Write a function `subarray_sum` that counts the number of continuous subarrays whose sum equals to a given target integer `k`. Function Signature ```python def subarray_sum(nums: List[int], k: int) -> int: ``` Input - `nums` (List[int]): List of integers representing transaction amounts (1 ≤ len(nums) ≤ 10^5, -10^4 ≤ nums[i] ≤ 10^4). - `k` (int): The target sum for subarrays (-10^4 ≤ k ≤ 10^4). Output - An integer representing the count of subarrays whose sums equal the target sum `k`. Constraints - `nums` can contain both positive and negative integers. Example ```python subarray_sum([1, 1, 1], 2) -> 2 subarray_sum([1, 2, 3], 3) -> 2 subarray_sum([-1, -1, 1], 0) -> 1 ``` Explanation 1. For `nums = [1, 1, 1]` and `k = 2`: - Possible subarrays: [1, 1], [1, 1] (2 subarrays) 2. For `nums = [1, 2, 3]` and `k = 3`: - Possible subarrays: [1, 2], [3] (2 subarrays) 3. For `nums = [-1, -1, 1]` and `k = 0`: - Possible subarray: [-1, -1, 1] (1 subarray) Make sure to consider efficiency, as the input size can be large.","solution":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: Counts the number of continuous subarrays whose sum equals to a given target integer k. cumulative_sum = 0 count = 0 prefix_sums = {0: 1} for num in nums: cumulative_sum += num if cumulative_sum - k in prefix_sums: count += prefix_sums[cumulative_sum - k] if cumulative_sum in prefix_sums: prefix_sums[cumulative_sum] += 1 else: prefix_sums[cumulative_sum] = 1 return count"},{"question":"# Scenario You are given a set of integers and need to find a subset that sums to a target value. This problem is a variation of the subset-sum problem, which is a classic problem in computer science and can be solved using dynamic programming. # Task Write a function `subset_sum(nums: list[int], target: int) -> bool` that determines if there is a subset of the given set `nums` that sums up to the given `target`. # Input * `nums` (list of integers): A list of integers representing the set. * `target` (integer): The target sum we are trying to find in the subset. # Output * A boolean value: `True` if there is a subset of `nums` that sums up to `target`, otherwise `False`. # Constraints 1. The length of `nums` will not exceed 100. 2. Each integer in `nums` will be non-negative. 3. The target will be a non-negative integer. # Examples ```python >>> subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> subset_sum([3, 34, 4, 12, 5, 2], 30) False ``` # Note You may assume that the input will be well-formed and will not require additional validation beyond the described constraints.","solution":"def subset_sum(nums, target): Determines if there is a subset of the given set nums that sums up to the given target. :param nums: List of integers representing the set. :param target: An integer, the target sum to find in the subset. :return: True if there is a subset that sums up to target, otherwise False. n = len(nums) dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[n][target]"},{"question":"Problem Statement You are tasked with implementing additional functionality for a class `MinStack` that operates as a stack but also supports retrieving the minimum element in constant time. Extend the existing class by implementing a method `min(self) -> int` which returns the minimum item in the stack without removing it. If the stack is empty, it should raise an `IndexError` with the message \\"Stack is empty\\". # Requirements: 1. **min()**: - This method should return the minimum item in the stack without removing it. - If the stack is empty, it should raise an `IndexError` with the message \\"Stack is empty\\". # Constraints 1. You may only use the internal `_stack` and `_min_stack` lists for implementing the `min` method. 2. You should not alter the existing methods `push` and `pop`. # Expected Input and Output Format * The `min` method has no inputs other than `self`. * The `min` method outputs the minimum item in the stack, or raises an `IndexError` when the stack is empty. # Example ```python >>> min_stack = MinStack() >>> min_stack.push(3) >>> min_stack.push(5) >>> min_stack.min() 3 >>> min_stack.push(2) >>> min_stack.push(1) >>> min_stack.min() 1 >>> min_stack.pop() 1 >>> min_stack.min() 2 >>> min_stack.pop() 2 >>> min_stack.min() 3 >>> min_stack.pop() 5 >>> min_stack.min() 3 >>> min_stack.pop() 3 >>> min_stack.min() Traceback (most recent call last): ... IndexError: Stack is empty ``` # Additional Instructions * Ensure your implementation maintains the `O(1)` time complexity for the `min` method. * Test your method thoroughly to account for edge cases and proper functionality under various conditions.","solution":"class MinStack: def __init__(self): self._stack = [] self._min_stack = [] def push(self, x: int) -> None: self._stack.append(x) if not self._min_stack or x <= self._min_stack[-1]: self._min_stack.append(x) def pop(self) -> int: if not self._stack: raise IndexError(\\"Stack is empty\\") item = self._stack.pop() if self._min_stack and item == self._min_stack[-1]: self._min_stack.pop() return item def min(self) -> int: if not self._min_stack: raise IndexError(\\"Stack is empty\\") return self._min_stack[-1]"},{"question":"# Coding Assessment Question Context: In a popular programming competition, participants are faced with a problem surrounding the manipulation of strings to match certain transformation rules. This problem involves determining whether you can transform one string into another by applying a series of rotation and swapping operations. Understanding basic string manipulations and practicing algorithmic logic is vital for this task. Task: Write a Python function `can_transform(s1: str, s2: str) -> bool` that determines if it is possible to transform string `s1` into string `s2` by repeatedly rotating the characters in `s1` by one position (left or right) or swapping any two characters exactly once. 1. **Function Signature**: ```python def can_transform(s1: str, s2: str) -> bool: ``` 2. **Input**: - `s1` (a string): The original string you want to transform. - `s2` (a string): The target string you want the original string to become. 3. **Output**: - Returns `True` if it is possible to transform `s1` into `s2` using the described operations; otherwise, returns `False`. 4. **Constraints**: - Both strings `s1` and `s2` consist of lowercase English letters. - The lengths of `s1` and `s2` are the same and are in the range [1, 100]. 5. **Performance Requirement**: - Ensure the solution works efficiently within the given constraints. Examples: ```python # Example 1 assert can_transform(\\"abc\\", \\"bca\\") == True # Rotation of \'abc\' by one position to the left gives \'bca\' # Example 2 assert can_transform(\\"aac\\", \\"caa\\") == True # Swap \'a\' and \'c\' in \'aac\' to get \'caa\' # Example 3 assert can_transform(\\"xyz\\", \\"zyx\\") == True # Multiple swaps and rotations possible to achieve # Example 4 assert can_transform(\\"aab\\", \\"aba\\") == True # Swapping first \'a\' with \'b\' in \'aab\' gives \'aba\' # Example 5 assert can_transform(\\"abc\\", \\"def\\") == False # Different characters, transformation impossible ``` Notes: - Consider the properties of rotations where the string remains cyclic. Any possible rotation of `s1` should be considered in the transformation. - Single swap can drastically change the position but only does it once. - Efficiently check all potential rotation results and consider the impact of a single swap.","solution":"def can_transform(s1: str, s2: str) -> bool: Determines if it is possible to transform s1 into s2 by rotating the characters and/or swapping exactly one pair of characters. if len(s1) != len(s2): return False # If s2 is a rotation of s1 if s2 in (s1 + s1): return True # Else, check for one swap possibility if sorted(s1) != sorted(s2): return False diff_count = 0 for a, b in zip(s1, s2): if a != b: diff_count += 1 if diff_count > 2: return False return True # If only two mismatched characters or rotation case"},{"question":"# Context: You are building a basic text editor feature that implements a list of text commands. Each command will either insert a character at a specific position or delete a character from a specific position. The text editor should be able to execute a series of these commands on an initial string and return the resulting text after all commands have been executed. # Task: **Implement** the command execution mechanism as described below. # Function Definitions: 1. **execute_commands**(`initial_text: str`, `commands: list[tuple[str, int, str]]`) -> `str`: - **Input**: - A string `initial_text` that represents the initial state of the text editor. - A list of commands where each command is represented as a tuple `(command_type, position, character)`. The `command_type` will either be \\"insert\\" or \\"delete\\". - For \\"insert\\" commands, `position` indicates where the `character` should be inserted. - For \\"delete\\" commands, `position` indicates the position of the character to be deleted. The `character` attribute will be ignored for delete commands. - **Output**: The final string after all commands have been executed. # Constraints: - Input text will contain only alphabets (a-z, A-Z). - Commands will be valid; no need to handle erroneous commands. - Insert operations will ensure the position is within the bounds of the text length. - Delete operations will ensure the position is within the bounds of the text length. # Example: ```python def execute_commands(initial_text: str, commands: list[tuple[str, int, str]]) -> str: text = list(initial_text) # Convert to list for easy manipulation for command in commands: command_type, position, character = command if command_type == \\"insert\\": text.insert(position, character) elif command_type == \\"delete\\": del text[position] return \'\'.join(text) if __name__ == \\"__main__\\": initial_text = \\"HelloWorld\\" commands = [(\\"insert\\", 5, \\" \\"), (\\"delete\\", 10, \\"\\"), (\\"insert\\", 10, \\"!\\")] result = execute_commands(initial_text, commands) print(result) # Should output: \\"Hello World!\\" ``` **Example Usage**: ```python initial_text = \\"HelloWorld\\" commands = [(\\"insert\\", 5, \\" \\"), (\\"delete\\", 10, \\"\\"), (\\"insert\\", 10, \\"!\\")] result = execute_commands(initial_text, commands) print(result) # Output: \\"Hello World!\\" ```","solution":"def execute_commands(initial_text: str, commands: list[tuple[str, int, str]]) -> str: Executes a series of text editing commands (\'insert\' or \'delete\') on the initial_text and returns the result. Parameters: initial_text (str): The initial state of the text editor. commands (list[tuple[str, int, str]]): A list of commands where each command is a tuple (command_type, position, character). Returns: str: The final string after executing all provided commands. text = list(initial_text) # Convert to list for easy manipulation for command in commands: command_type, position, character = command if command_type == \\"insert\\": text.insert(position, character) elif command_type == \\"delete\\": del text[position] return \'\'.join(text)"},{"question":"# Finding the First Non-Repeated Character in a String You are required to demonstrate your understanding of string manipulation and hash map (dictionary) usage by implementing a function that identifies the first non-repeated character in a given string. The core of this task is understanding how to efficiently keep track of character counts and determine the position of the first non-repeated character. Function Signature ```python def first_non_repeated_char(s: str) -> str: pass ``` Requirements 1. The function should accept a single string and return the first character that does not repeat. 2. If all characters are repeated or the string is empty, return an empty string. 3. The function must handle: - An empty string. - A string with a single character. - A string where all characters are identical. - A string with multiple non-repeated characters. - A string where all characters repeat but one. 4. Demonstrate your implementation by writing test cases for each of these scenarios. 5. Use Python\'s built-in assertion mechanism to validate your outputs. Constraints * Do not use any external libraries or built-in functions specifically designed for this purpose. * The function should be efficient in terms of time complexity, ideally operating in linear time. Example Usage Here are some examples of expected input and output: ```python assert first_non_repeated_char(\\"aabbccdd\\") == \\"\\" assert first_non_repeated_char(\\"aabccdb\\") == \\"d\\" assert first_non_repeated_char(\\"abcdef\\") == \\"a\\" assert first_non_repeated_char(\\"a\\") == \\"a\\" assert first_non_repeated_char(\\"\\") == \\"\\" assert first_non_repeated_char(\\"aaa\\") == \\"\\" assert first_non_repeated_char(\\"swiss\\") == \\"w\\" ``` Test your implementation rigorously to cover all scenarios. Explain in comments how each test case validates a specific aspect of the algorithm.","solution":"def first_non_repeated_char(s: str) -> str: Returns the first non-repeated character in the given string s. If all characters are repeated or the string is empty, returns an empty string. char_count = {} # First pass: Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: Find the first character that has a count of 1 for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"# Detect Valid UTF-8 Encodings Scenario: You need to write a function to validate if a given list of integers represents a valid UTF-8 encoding. UTF-8 is a variable-width character encoding used for electronic communication. UTF-8 encodes each of the 1,112,064 valid character code points in Unicode using one to four 8-bit bytes. Task: Implement a function `valid_utf8` to check whether a given list of integers represents a valid UTF-8 encoding. Function Signature: ```python def valid_utf8(data: list[int]) -> bool: Determine if a given list of integers represents a valid UTF-8 encoding. :param list[int] data: A list of integers representing bytes of the encoding. :return bool: True if valid UTF-8 encoding, False otherwise. Example: >>> valid_utf8([197, 130, 1]) True >>> valid_utf8([235, 140, 4]) False >>> valid_utf8([240, 162, 138, 147]) True >>> valid_utf8([145]) False >>> valid_utf8([]) True # Your implementation goes here ``` Constraints: - Each integer `x` in the list will be in the range `0` to `255` - An empty list should return `True` as it represents an empty string which is a valid UTF-8 encoding. Performance Requirement: - The function should run in linear time (O(n)) relative to the length of the list. Test your implementation with provided examples and additional test cases to ensure its correctness and performance. # Explanation: Each byte in a valid UTF-8 encoding can be identified by its leading bits: 1. For a 1-byte character, the byte starts with `0`. 2. For a 2-byte character, the first byte starts with `110` and the second byte starts with `10`. 3. For a 3-byte character, the first byte starts with `1110` and the following two bytes start with `10`. 4. For a 4-byte character, the first byte starts with `11110` and the following three bytes start with `10`.","solution":"def valid_utf8(data: list[int]) -> bool: Determine if a given list of integers represents a valid UTF-8 encoding. :param list[int] data: A list of integers representing bytes of the encoding. :return bool: True if valid UTF-8 encoding, False otherwise. n = len(data) i = 0 while i < n: first_byte = data[i] if first_byte & 0b10000000 == 0: # 1-byte character i += 1 continue elif first_byte & 0b11100000 == 0b11000000: # 2-byte character num_bytes = 2 elif first_byte & 0b11110000 == 0b11100000: # 3-byte character num_bytes = 3 elif first_byte & 0b11111000 == 0b11110000: # 4-byte character num_bytes = 4 else: return False if i + num_bytes > n: return False for j in range(1, num_bytes): if data[i + j] & 0b11000000 != 0b10000000: return False i += num_bytes return True"},{"question":"# Loan Default Prediction using Random Forest You are tasked with predicting the probability of loan default based on borrower details using a Random Forest classifier. Random Forests are suitable for this task due to their ability to handle various types of predictors and their robustness to overfitting. # Problem Statement Given a dataset `loan_data.csv` which contains borrower details and the corresponding loan default status, write a Python function `train_and_evaluate_rf` that: 1. Loads and preprocesses the data. 2. Trains a Random Forest classifier. 3. Evaluates the model using ROC AUC score. 4. Returns the predicted probabilities for the test set. The dataset is a CSV file with the following columns: - \\"loan_amount\\" (float): Amount of the loan. - \\"term\\" (int): Term of the loan in months. - \\"interest_rate\\" (float): Interest rate of the loan. - \\"annual_income\\" (float): Annual income of the borrower. - \\"loan_status\\" (binary): 1 if the loan defaulted, 0 otherwise. You should: - Handle missing values if any, by imputing with the median for numerical columns. - Encode categorical variables if any. - Split the data into training and testing sets. - Train the Random Forest model and output the predicted probability of default for the test set. # Function Signature ```python def train_and_evaluate_rf(file_path: str, test_size: float, n_estimators: int, max_depth: int, random_state: int) -> np.array: Trains a Random Forest classifier on loan data and evaluates its performance. Args: - file_path (str): Path to the CSV file containing loan data. - test_size (float): Proportion of the dataset to include in the test split. - n_estimators (int): Number of trees in the forest. - max_depth (int): Maximum depth of the tree. - random_state (int): Random seed for reproducibility. Returns: - np.array: Predicted probabilities of loan default for the test set. pass ``` # Input - `file_path` : A string representing the path to the CSV file with loan data. - `test_size` : A float representing the proportion of the dataset to include in the test split. - `n_estimators` : An integer representing the number of trees in the Random Forest. - `max_depth` : An integer representing the maximum depth of each tree. - `random_state` : An integer representing the random seed for reproducibility. # Output - An array of predicted probabilities of loan default for the test set. # Constraints - The CSV file might have missing values which need to be handled. - The dataset should be large enough to have a meaningful train/test split. - The number of estimators and max depth are positive integers. # Example Usage ```python # Example usage: predicted_probabilities = train_and_evaluate_rf(\\"loan_data.csv\\", 0.2, 100, 10, 42) print(predicted_probabilities) ``` Implement the function `train_and_evaluate_rf` to solve the given problem. Make sure to handle missing values, data splitting, model training, and evaluation properly within the function.","solution":"import pandas as pd import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import train_test_split from sklearn.metrics import roc_auc_score from sklearn.impute import SimpleImputer from sklearn.preprocessing import StandardScaler def train_and_evaluate_rf(file_path: str, test_size: float, n_estimators: int, max_depth: int, random_state: int) -> np.array: # Load the data data = pd.read_csv(file_path) # Handle missing values by imputing with median for numerical columns imputer = SimpleImputer(strategy=\'median\') # Identify the predictors and the target X = data.drop(columns=[\'loan_status\']) y = data[\'loan_status\'] # Impute missing values X = pd.DataFrame(imputer.fit_transform(X), columns=X.columns) # Split the data into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state, stratify=y) # Initialize the Random Forest model rf = RandomForestClassifier(n_estimators=n_estimators, max_depth=max_depth, random_state=random_state) # Train the model rf.fit(X_train, y_train) # Predict probabilities for the test set y_pred_prob = rf.predict_proba(X_test)[:, 1] # Evaluate the model using ROC AUC score roc_auc = roc_auc_score(y_test, y_pred_prob) print(f\\"ROC AUC Score: {roc_auc}\\") # Return the predicted probabilities for test set return y_pred_prob"},{"question":"# Coding Assessment Question: Factorial Number Extraction Context In mathematics, a factorial of a non-negative integer ( n ) is the product of all positive integers less than or equal to ( n ). It is denoted by ( n! ). For example, ( 5! = 5 times 4 times 3 times 2 times 1 = 120 ). Your task is to extract the digits of the factorial in the reverse order. Objective Implement a function `reverse_factorial_digits(n: int) -> List[int]` that computes the factorial of ( n ) and returns a list of its digits in reverse order. Input/Output Formats - **Input**: * An integer `n` (0 ≤ n ≤ 100). - **Output**: * A list of integers representing the digits of ( n! ) in reverse order. Constraints - Handle large factorial values accurately using appropriate data types and/or libraries. - Ensure efficient computation of the factorial to deal with the upper constraint. Performance Requirements - The solution should have a time complexity that efficiently handles the computation of large factorials. Using Python\'s built-in functionality for large integers is recommended. Example ```python def reverse_factorial_digits(n: int) -> List[int]: # Implementation here print(reverse_factorial_digits(5)) # Expected Output: [0, 2, 1] print(reverse_factorial_digits(10)) # Expected Output: [0, 0, 8, 8, 2, 6, 3] ``` Provide the complete implementation of the function that calculates the factorial and extracts its digits in reverse order, ensuring it works within the given constraints.","solution":"from math import factorial def reverse_factorial_digits(n: int): Compute the factorial of n and return the list of its digits in reverse order. Args: n (int): A non-negative integer whose factorial to compute. Returns: List[int]: A list of digits of the factorial in reverse order. factorial_result = factorial(n) return [int(digit) for digit in str(factorial_result)[::-1]]"},{"question":"# Problem Statement CSV (Comma-Separated Values) files are commonly used for storing tabular data where each line corresponds to a row of data, and elements are separated by commas. One common task is to extract a specific column from a CSV file. Write a function `extract_csv_column` that takes a CSV string and a column header\'s name, and returns a list containing all the values from that column. The CSV string may have multiple lines and columns. **Function: extract_csv_column** - **Input**: 1. A string `csv_data` representing the CSV content. The first line in `csv_data` is the header row containing the column names. 2. A string `column_name` representing the name of the column to be extracted. - **Output**: A list of strings representing the values from the specified column in the order they appear in the CSV string. **Constraints**: - The input `csv_data` is guaranteed to be a well-formed CSV string with at least one row of data and one header row. - The specified `column_name` is guaranteed to be one of the headers in the CSV data. - The CSV values will not contain any commas. - Lines are separated by newlines \'n\', and elements within each line are separated by commas \',\'. # Example ```python # Example Usage csv_content = Name,Age,Occupation Alice,30,Engineer Bob,25,Artist Charlie,35,Doctor # Extract the \\"Name\\" column names = extract_csv_column(csv_content, \\"Name\\") print(names) # [\'Alice\', \'Bob\', \'Charlie\'] # Extract the \\"Age\\" column ages = extract_csv_column(csv_content, \\"Age\\") print(ages) # [\'30\', \'25\', \'35\'] # Test Cases assert extract_csv_column(csv_content, \'Name\') == [\'Alice\', \'Bob\', \'Charlie\'] assert extract_csv_column(csv_content, \'Age\') == [\'30\', \'25\', \'35\'] assert extract_csv_column(csv_content, \'Occupation\') == [\'Engineer\', \'Artist\', \'Doctor\'] assert extract_csv_column(\\"Header1,Header2nValue1,Value2\\", \'Header1\') == [\'Value1\'] assert extract_csv_column(\\"Header1,Header2nValue1,Value2n,Value3\\", \'Header2\') == [\'Value2\', \'Value3\'] # Edge Cases empty_csv = \\"Column1n\\" assert extract_csv_column(empty_csv, \'Column1\') == [] missing_values_csv = \\"A,B,Cn1,2,n4,5,6n7,,9\\" assert extract_csv_column(missing_values_csv, \'C\') == [\'\', \'6\', \'9\'] ``` **Scenario**: Assume you are dealing with a CSV file that stores employee data. You are tasked with extracting specific columns from the CSV to generate reports on demand. Your function should efficiently parse the CSV content and retrieve the required columns for further processing. **Edge Cases**: - CSV files with rows of missing column values. - CSV files where the specified column may have empty values at certain rows. - Handling the extraction from CSV that contains only the header row and no data rows.","solution":"def extract_csv_column(csv_data, column_name): Extracts and returns the values from the specified column in the given CSV string. Parameters: csv_data (str): The CSV content as a string. column_name (str): The name of the column to extract values from. Returns: list: A list of values from the specified column. lines = csv_data.split(\'n\') header = lines[0].split(\',\') column_index = header.index(column_name) return [line.split(\',\')[column_index] for line in lines[1:] if line]"},{"question":"# Coding Assessment Question **Objective**: Implement a function to perform matrix multiplication without using any external libraries. **Scenario**: You are provided with two 2D lists (matrices) `A` and `B`. Your task is to write a function `matrix_multiplication` that multiplies these matrices together. Matrices are represented as lists of lists, where each inner list represents a row. **Method Description**: Matrix multiplication rules: - If `A` is an (m times n) matrix and `B` is an (n times p) matrix, the resulting matrix `C` will be an (m times p) matrix. - The element in the i-th row and j-th column of `C` is calculated as: [ C[i][j] = sum_{k=0}^{n-1} A[i][k] times B[k][j] ] **Task**: - Implement the `matrix_multiplication` function. - Ensure it checks that matrix dimensions are compatible for multiplication. - If the matrices cannot be multiplied due to incompatible dimensions, raise a `ValueError` with the message \\"Incompatible matrix dimensions\\". **Constraints**: - Do not use any external libraries such as NumPy. - Ensure that the matrices have valid dimensions and elements to perform the multiplication. **Expected Behavior**: - If `A` has dimensions (m times n) and `B` has dimensions (n times p), return the resulting matrix `C` that has dimensions (m times p). - If the matrices have incompatible dimensions for multiplication, raise the appropriate error. **Function Signature**: ```python def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` **Examples**: ```python >>> A = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> B = [ ... [7, 8], ... [9, 10], ... [11, 12] ... ] >>> result = matrix_multiplication(A, B) >>> result [[58, 64], [139, 154]] >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [5, 6, 7], ... [8, 9, 10] ... ] >>> result = matrix_multiplication(A, B) >>> result [[21, 24, 27], [47, 54, 61]] >>> A = [ ... [1, 2, 3] ... ] >>> B = [ ... [4, 5], ... [6, 7] ... ] >>> result = matrix_multiplication(A, B) Traceback (most recent call last): ... ValueError: Incompatible matrix dimensions ```","solution":"def matrix_multiplication(A, B): Multiplies two matrices A and B and returns the resultant matrix. Parameters: A (List[List[int]]): The first matrix with dimensions m x n. B (List[List[int]]): The second matrix with dimensions n x p. Returns: List[List[int]]: The resulting matrix with dimensions m x p. Raises: ValueError: If the given matrices cannot be multiplied due to incompatible dimensions. # Number of rows and columns of the matrices m = len(A) n = len(A[0]) p = len(B[0]) # Check if the number of columns in A is equal to the number of rows in B if len(B) != n: raise ValueError(\\"Incompatible matrix dimensions\\") # Initialize the result matrix with zeros C = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"# Coding Assessment Question Context: You are provided with a log file from a server, where each line contains a timestamp and the message associated with a specific event. Your task is to write a script that processes these log files to extract information about the frequency of different types of events over time. Task: Implement a function `parse_log_file` that reads a log file and computes the frequency of each event type for each day. The log file has lines in the following format: ``` timestamp event_type ``` - `timestamp` is in the format `YYYY-MM-DDTHH:MM:SS` (ISO 8601 format). - `event_type` is a string representing the type of event. Your function should return a dictionary where the keys are dates (`YYYY-MM-DD`) and the values are dictionaries. Each inner dictionary should have event types as keys and their corresponding counts as values. Expected Input and Output Formats: Function signature: ```python def parse_log_file(log_file: str) -> typing.Dict[str, typing.Dict[str, int]]: ``` - **Input**: `log_file` (str) - A string representing the file path to the log file. - **Output**: A dictionary (`Dict[str, Dict[str, int]]`): - Outer dictionary keys are dates in `YYYY-MM-DD` format. - Outer dictionary values are dictionaries where: - Keys are event types (strings). - Values are event counts (integers) for the corresponding date. Constraints and Assumptions: - The log file is well-formed and each line correctly follows the given format. - There can be multiple events of the same type on the same day. - Log entries are not necessarily in chronological order. Hints: - You may use `collections.defaultdict` to handle the mapping and counting more efficiently. - Consider using `str.split` to parse each line of the log file. Example Implementation: ```python import collections import typing def parse_log_file(log_file: str) -> typing.Dict[str, typing.Dict[str, int]]: frequency_dict = collections.defaultdict(lambda: collections.defaultdict(int)) with open(log_file, \'r\') as file: for line in file: timestamp, event_type = line.strip().split() date = timestamp.split(\'T\')[0] frequency_dict[date][event_type] += 1 return frequency_dict ``` # Example Input: **logfile.txt** ``` 2023-01-01T00:01:02 ERROR 2023-01-01T01:10:45 WARNING 2023-01-02T02:23:15 INFO 2023-01-01T03:33:12 ERROR 2023-01-01T04:17:58 WARNING 2023-01-02T05:45:29 ERROR ``` # Example Output: ```python { \\"2023-01-01\\": {\\"ERROR\\": 2, \\"WARNING\\": 2}, \\"2023-01-02\\": {\\"INFO\\": 1, \\"ERROR\\": 1} } ``` The function should correctly parse the log file and compute the frequency of each event type for each day, returning the results in the specified format.","solution":"import collections import typing def parse_log_file(log_file: str) -> typing.Dict[str, typing.Dict[str, int]]: frequency_dict = collections.defaultdict(lambda: collections.defaultdict(int)) with open(log_file, \'r\') as file: for line in file: timestamp, event_type = line.strip().split() date = timestamp.split(\'T\')[0] frequency_dict[date][event_type] += 1 return frequency_dict"},{"question":"# Set Operations with Matrices You are tasked to perform a series of set operations on two matrices and determine the result of these operations. The matrices contain integers, and the operations are union, intersection, and set difference. # Problem Statement Given two matrices, you need to write a function `matrix_set_operations(matrix1: list[list[int]], matrix2: list[list[int]], operation: str) -> list[list[int]]` to perform the specified set operation and return the result as a list of lists. The matrices may not be of equal size, so treat them as collections of integers for the set operations. # Function Signature ```python def matrix_set_operations(matrix1: list[list[int]], matrix2: list[list[int]], operation: str) -> list[list[int]]: pass ``` # Input * `matrix1` (`list[list[int]]`): The first input matrix of integers. * `matrix2` (`list[list[int]]`): The second input matrix of integers. * `operation` (`str`): The set operation to perform, which can be one of `\'union\'`, `\'intersection\'`, or `\'difference\'`. # Output * `list[list[int]]`: The result of the specified set operation between the two matrices, presented as a matrix (list of lists). # Constraints * Matrices can be of different sizes. * Matrices can be empty. * Operation string will always be one of `\'union\'`, `\'intersection\'`, `or \'difference\'`. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6] ] matrix2 = [ [4, 5, 6], [7, 8, 9] ] result = matrix_set_operations(matrix1, matrix2, \'union\') print(result) # Expected output for union: [[1, 2, 3, 4, 5, 6, 7, 8, 9]] result = matrix_set_operations(matrix1, matrix2, \'intersection\') print(result) # Expected output for intersection: [[4, 5, 6]] result = matrix_set_operations(matrix1, matrix2, \'difference\') print(result) # Expected output for difference: [[1, 2, 3]] ``` # Additional Notes * Treat both matrices as sets of integers regardless of their dimensions. * Ensure the solution efficiently handles large matrices. * Respect the particular characteristics of set operations: * **Union**: The set containing all unique elements from both matrices. * **Intersection**: The set containing common elements in both matrices. * **Difference**: The set containing elements in the first matrix not present in the second.","solution":"def matrix_set_operations(matrix1, matrix2, operation): Perform set operations (union, intersection, difference) on two matrices and return the result as a matrix. Parameters: matrix1 (list[list[int]]): The first input matrix of integers. matrix2 (list[list[int]]): The second input matrix of integers. operation (str): The set operation to perform, which can be one of \'union\', \'intersection\', or \'difference\'. Returns: list[list[int]]: The result of the specified set operation between the two matrices, presented as a matrix (list of lists). # Flatten the matrices and convert them to sets set1 = {elem for row in matrix1 for elem in row} set2 = {elem for row in matrix2 for elem in row} # Perform the set operation if operation == \'union\': result_set = set1 | set2 elif operation == \'intersection\': result_set = set1 & set2 elif operation == \'difference\': result_set = set1 - set2 else: raise ValueError(\\"Invalid operation. Must be \'union\', \'intersection\', or \'difference\'\\") # Convert the result set back to a sorted list of lists (1-row matrix) result = [sorted(result_set)] return result"},{"question":"# Check for Unique Characters in a String Given a string, determine if it consists of all unique characters. Write a function to return a boolean indicating whether all characters in the string are unique. **Function Signature**: ```python def all_unique_characters(s: str) -> bool: pass ``` # Input: * `s` (string): A string containing only printable ASCII characters, with length ( 0 leq text{len}(s) leq 10^6 ). # Output: * Returns a boolean: `True` if all characters in the string are unique, otherwise `False`. # Examples: ```python >>> all_unique_characters(\\"abcdef\\") True >>> all_unique_characters(\\"hello\\") False >>> all_unique_characters(\\"\\") True >>> all_unique_characters(\\"abcdefghijklmnopqrstuvwxyz\\") True ``` # Constraints: * You must use an efficient algorithm to compute the solution within a time complexity of (O(n)). * Avoid using additional data structures (e.g., list, set) that result in an auxiliary space complexity greater than (O(1)). # Requirements: 1. Implement the logic efficiently to handle very large inputs. 2. Utilize bit manipulation techniques for optimal space usage. # Example Explanation: For `s = \\"abcdef\\"`, each character in the string is unique, so the function returns `True`. For `s = \\"hello\\"`, the character \'l\' appears more than once, so the function returns `False`. For an empty string, the function should return `True` since there are no characters to repeat.","solution":"def all_unique_characters(s: str) -> bool: Determines if all characters in the string s are unique. if len(s) > 128: # There are only 128 unique ASCII characters return False char_set = [False] * 128 for char in s: val = ord(char) if char_set[val]: return False char_set[val] = True return True"},{"question":"# Balanced Brackets with Custom Types # Context Checking for balanced delimiters (brackets, braces, parentheses) is a common problem in compilers and interpreters, ensuring that every opening delimiter has a matching closing delimiter and that they are correctly nested. # Problem Statement Write a function to determine if a string containing various types of brackets is balanced. The function will accept a dictionary specifying valid pairs of opening and closing delimiters. The function should return `True` if the string is balanced according to the given pairs and `False` otherwise. # Function Signature ```python def is_balanced(s: str, pairs: dict) -> bool: Checks if the string s is balanced according to the delimiter pairs specified in the pairs dictionary. Parameters: - s: A string containing various brackets, braces, and other delimiters. - pairs: A dictionary where keys are opening delimiters and values are the corresponding closing delimiters. Returns: - A boolean indicating whether the string is balanced. ``` # Expected Inputs and Outputs * Input: - `s`: A string containing delimiters. - `pairs`: A dictionary with opening delimiters as keys and closing delimiters as values. * Output: - A boolean indicating if the string `s` is balanced according to the given pairs. # Examples ```python pairs1 = {\\"(\\": \\")\\", \\"{\\": \\"}\\", \\"[\\": \\"]\\"} assert is_balanced(\\"(){}[]\\", pairs1) == True assert is_balanced(\\"({[()]})\\", pairs1) == True assert is_balanced(\\"({[(])})\\", pairs1) == False assert is_balanced(\\"({[()]\\", pairs1) == False pairs2 = {\\"<\\": \\">\\", \\"(\\": \\")\\", \\"{\\": \\"}\\", \\"[\\": \\"]\\"} assert is_balanced(\\"<({[()]})>\\", pairs2) == True assert is_balanced(\\"<({[()]}]\\", pairs2) == False assert is_balanced(\\"<({[()]})>\\", pairs2) == True assert is_balanced(\\"<<>>\\", pairs2) == True assert is_balanced(\\"<<>><<\\", pairs2) == False ``` # Constraints - The string `s` will only contain characters present in the `pairs` dictionary and possibly other characters that should be ignored. - The pairs dictionary will only contain valid pairs of opening and closing delimiters. - The function should ignore characters in `s` that are not specified as keys or values in `pairs`. # Additional Information Consider using a stack data structure to help validate the balancing of delimiters. Ensure the function handles nested delimiters correctly and ignores irrelevant characters.","solution":"def is_balanced(s: str, pairs: dict) -> bool: # Dictionary to quickly lookup closing brackets opening_brackets = pairs.keys() closing_brackets = pairs.values() matching_brackets = {closing: opening for opening, closing in pairs.items()} stack = [] for char in s: if char in opening_brackets: stack.append(char) elif char in closing_brackets: if stack and stack[-1] == matching_brackets[char]: stack.pop() else: return False return len(stack) == 0"},{"question":"# Question: Implement a Cache Replacement Policy You are required to implement a least recently used (LRU) cache. The cache should have a fixed size and should perform two main operations: `put` and `get`. Items stored in the cache should be efficiently retrievable, and the least recently used items should be removed when the cache exceeds its capacity. **Your task is to define and implement the LRUCache class with the following methods:** 1. `get(self, key: int) -> int`: Return the value corresponding to the provided key if it exists in the cache. If the key does not exist, return `-1`. This operation should mark the key as recently used. 2. `put(self, key: int, value: int) -> None`: Insert a key-value pair into the cache. If the key already exists, update its value and mark it as recently used. If the number of items exceeds the cache capacity after the insertion, remove the least recently used item. Inputs: - A sequence of method calls and corresponding parameters for `LRUCache` Outputs: - The output from `get` method calls according to the inputs. Constraints: - Keys and values are integer numbers. - All operations performed on the cache should be done in O(1) time complexity. - The cache capacity will be a positive integer less than or equal to 10^5. - 1 ≤ key, value ≤ 10^4 # Example Usage: ```python # Initialize a cache with capacity 2 cache = LRUCache(2) # Perform operations cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Returns 1 cache.put(3, 3) # Removes key 2 print(cache.get(2)) # Returns -1 (not found) cache.put(4, 4) # Removes key 1 print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4 ``` # Partial Implementation: ```python class LRUCache: def __init__(self, capacity: int): # Initialize the cache with the given capacity pass def get(self, key: int) -> int: # Retrieve the value if present and mark it as recently used pass def put(self, key: int, value: int) -> None: # Insert the key-value pair and ensure the capacity constraints pass ``` This question will test the candidate\'s ability to design and implement a data structure with specific performance requirements, ensuring an understanding of caching mechanisms and memory management techniques.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the cache with the given capacity. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Retrieve the value if present and mark it as recently used. if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: Insert the key-value pair and ensure the capacity constraints. If the number of items exceeds the cache capacity, remove the least recently used item. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Coding Assessment Question **Travel Cost Minimization Using Dijkstra\'s Algorithm** You are tasked with minimizing the travel cost between two cities in a given transportation network. Implement a function `minimal_travel_cost` that utilizes Dijkstra\'s shortest path algorithm to find the least cost from a start city to a destination city. The network is represented as a weighted, directed graph. Function Signature ```python def minimal_travel_cost(n: int, edges: list, start: int, destination: int) -> int: ``` Input * `n` (int): The number of cities (nodes) in the network. * `edges` (list of tuples): Each tuple represents a direct route in the network and is of the form `(u, v, w)` where `u` is the starting city, `v` is the destination city, and `w` is the travel cost. * `start` (int): The starting city. * `destination` (int): The destination city. Output * An integer representing the minimal travel cost from `start` to `destination`. If there is no path, return `-1`. Constraints * 1 ≤ `n` ≤ 10^5 * 0 ≤ `u, v` < `n` * 1 ≤ `w` ≤ 10^4 * `start` and `destination` will be valid city indices. Example ```python n = 6 edges = [(0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15), (2, 3, 11), (2, 5, 2), (3, 4, 6), (4, 5, 9)] start = 0 destination = 4 result = minimal_travel_cost(n, edges, start, destination) print(result) # Output: 20 ``` Detailed Explanation * Your function should first represent the given transportation network using an adjacency list. * It will then implement Dijkstra\'s algorithm to find the shortest path from the `start` city to the `destination` city. * If the `destination` city is unreachable from the `start` city, your function should return `-1`. Ensure your implementation correctly handles large inputs efficiently and performs necessary error checking.","solution":"import heapq def minimal_travel_cost(n, edges, start, destination): Finds the minimal travel cost using Dijkstra\'s algorithm. Parameters: n (int): number of cities (nodes). edges (list): list of tuples representing the edges (u, v, w). start (int): starting city index. destination (int): destination city index. Returns: int: minimal travel cost from start to destination, or -1 if no path exists. # Create an adjacency list for the graph graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Assuming undirected graph # Using Dijkstra\'s algorithm min_heap = [(0, start)] # (cost, node) distances = {i: float(\'inf\') for i in range(n)} distances[start] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node == destination: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 if distances[destination] == float(\'inf\') else distances[destination]"},{"question":"New Question # Question: Implement a Stock Price Simulator and Anomaly Detector Your task is to implement a function that simulates stock prices based on historical daily percentage changes using different provided models (Simple Moving Average, Exponential Moving Average, and Monte Carlo Simulation). Then, detect any anomalies in the predicted stock prices. Function Specifications 1. **Function Signature** ```python def stock_price_simulator( train_dates: list, train_prices: list, test_dates: list, num_simulations: int = 1000, anomaly_threshold: float = 0.05 ) -> tuple: ``` 2. **Input** - `train_dates`: List of training dates (e.g., [\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", ...]). - `train_prices`: List of historical stock prices corresponding to `train_dates`. - `test_dates`: List of dates for simulation predictions. - `num_simulations` (optional): Number of Monte Carlo simulations to perform (default is `1000`). - `anomaly_threshold` (optional): Percentage threshold to detect anomalies in the predicted stock prices compared to the actual prices (default is `0.05`). 3. **Output** - A tuple containing: - Predictions using Simple Moving Average, Exponential Moving Average, and Monte Carlo Simulation. - A list of boolean values indicating the presence of anomalies in the predictions for each test date. Constraints - The length of `train_dates` and `train_prices` will be equal. - The length of `test_dates` can be different from the training set length. - `train_dates` and `train_prices` will contain at least 10 values. - Predictions must be made for each date in `test_dates`. Performance Requirements - The implementation should work efficiently for length of input data up to 1000 elements. Edge Cases to Consider - Missing or zero elements in any data list should be handled gracefully. - Ensure that floating-point predictions match actual results within a tolerance of `1e-6`. Example ```python # Given training data train_dates = [\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", \\"2023-01-04\\"] train_prices = [100, 102, 105, 107] # Given test data test_dates = [\\"2023-01-05\\", \\"2023-01-06\\"] # Call the function predictions, anomalies = stock_price_simulator(train_dates, train_prices, test_dates) # Expected output print(predictions) # Example: ([108, 109], [108.5, 110], [107.8, 109.2]) <- Assuming float outputs from each model print(anomalies) # Example: [False, True] <- Based on the `anomaly_threshold` provided ```","solution":"from typing import List, Tuple import numpy as np def calculate_sma(prices: List[float], window: int) -> List[float]: return [np.mean(prices[i:i + window]) for i in range(len(prices) - window + 1)] def calculate_ema(prices: List[float], window: int) -> List[float]: ema = [] k = 2 / (window + 1) ema.append(prices[0]) for price in prices[1:]: ema.append(price * k + ema[-1] * (1 - k)) return ema def monte_carlo_simulation(prices: List[float], num_simulations: int, num_days: int) -> List[float]: returns = np.diff(prices) / prices[:-1] mean_return = returns.mean() std_return = returns.std() simulated_prices = [] for _ in range(num_simulations): simulated_price_path = [prices[-1]] for _ in range(num_days): new_price = simulated_price_path[-1] * (1 + np.random.normal(mean_return, std_return)) simulated_price_path.append(new_price) simulated_prices.append(simulated_price_path[-1]) return simulated_prices def stock_price_simulator( train_dates: List[str], train_prices: List[float], test_dates: List[str], num_simulations: int = 1000, anomaly_threshold: float = 0.05 ) -> Tuple[Tuple[List[float], List[float], List[float]], List[bool]]: window = 3 # Define window length for smoothing # Simple Moving Average Predictions sma_predictions = calculate_sma(train_prices, window)[-1:] * len(test_dates) # Exponential Moving Average Predictions ema_predictions = calculate_ema(train_prices, window)[-1:] * len(test_dates) # Monte Carlo Simulation Predictions mc_predictions = [] for _ in test_dates: mc_predictions.append(np.mean(monte_carlo_simulation(train_prices, num_simulations, len(test_dates)))) # Anomaly Detection anomalies = [] for sma, ema, mc in zip(sma_predictions, ema_predictions, mc_predictions): anomaly = max(abs(sma - ema) / max(1, abs(ema)), abs(sma - mc) / max(1, abs(mc)), abs(ema - mc) / max(1, abs(mc))) > anomaly_threshold anomalies.append(anomaly) return (sma_predictions, ema_predictions, mc_predictions), anomalies"},{"question":"# Problem Description You are asked to enhance a Python-based Linked List implementation by adding specific functionalities and improving its efficiency. The task requires you to implement new methods and optimize existing ones to ensure better performance for key operations. # Objectives 1. Implement the `remove_duplicates` method to remove duplicate nodes from the linked list. 2. Add a method `reverse_sublist` to reverse a section of the linked list between two given positions. 3. Enhance the linked list for efficient look-up operations by implementing a way to cache nodes for quick access. # Requirements Part 1: `remove_duplicates` * **Function Signature**: `def remove_duplicates(self) -> None:` * **Outputs**: None. The list should be modified in place to remove duplicate nodes. * **Constraints**: - The linked list can contain any data type. - Duplicates must be completely removed, not just consecutive similar values. Part 2: `reverse_sublist` * **Function Signature**: `def reverse_sublist(self, start: int, end: int) -> None:` * **Inputs**: Two integer positions `start` and `end`. * **Outputs**: None. The list should be modified in place such that the section between `start` and `end` (inclusive) is reversed. * **Constraints**: - `start` and `end` are 1-based indices. - `start` is less than or equal to `end`. - If positions are invalid, the method should not change the list. Part 3: Efficient Lookup - Implement a caching mechanism for node references to improve the efficiency of node look-ups. - Use a dictionary to store references to nodes in the linked list. - Ensure the cache is updated appropriately during insertions and deletions. # Input and Output Format ```python # Example for Part 1 ll = LinkedList() ll.append(1, 3, 3, 1, 5) ll.remove_duplicates() print(ll.to_list()) # Output should be [1, 3, 5] # Example for Part 2 ll = LinkedList() ll.append(1, 2, 3, 4, 5) ll.reverse_sublist(2, 4) print(ll.to_list()) # Output should be [1, 4, 3, 2, 5] # Example for Part 3 ll = LinkedList() ll.append(1, 2, 3) print(ll.lookup(2).data) # Output should be 2 (assuming lookup() returns the node containing the value) ll.append(4) ll.remove(3) print(ll.lookup(4).data) # Output should be 4 (cache should be updated after insertion) ``` Performance and Constraints - Ensure the list operations maintain efficiency even after adding enhancements. - Handle edge cases such as reversing sublist in single-element or empty lists. # Function Details 1. `remove_duplicates(self) -> None` 2. `reverse_sublist(self, start: int, end: int) -> None` 3. `append(self, *values) -> None` 4. `remove(self, value: Any) -> None` 5. `lookup(self, value: Any) -> Node | None` 6. Additional necessary functions to ensure correct caching mechanisms. # Scenario Imagine you are designing a software application that manages user playlists, where users frequently update and modify their lists by adding or removing songs. Implementing efficient linked list operations ensures optimal performance during heavy usage, such as removing duplicates, flipping sections of the playlist, and quickly accessing songs. This makes the application responsive and user-friendly.","solution":"class LinkedList: class Node: def __init__(self, data): self.data = data self.next = None def __init__(self): self.head = None self.cache = {} def append(self, *values): for value in values: new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node self.cache[value] = new_node def to_list(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result def remove_duplicates(self): if not self.head: return seen = set() current = self.head prev = None while current: if current.data in seen: prev.next = current.next self.cache.pop(current.data, None) else: seen.add(current.data) prev = current current = current.next def reverse_sublist(self, start, end): if not self.head or start >= end: return dummy = self.Node(0) dummy.next = self.head sublist_head_prev = dummy for _ in range(start - 1): sublist_head_prev = sublist_head_prev.next sublist_working_precursor = sublist_head_prev.next for _ in range(end - start): temp = sublist_working_precursor.next sublist_working_precursor.next = temp.next temp.next = sublist_head_prev.next sublist_head_prev.next = temp self.head = dummy.next def lookup(self, value): return self.cache.get(value)"},{"question":"**File System Operations** # Objective Implement and simulate a basic virtual file system (VFS) that supports file and directory operations. This task will evaluate your understanding of data structures, recursive algorithms, and object-oriented programming principles. # Problem Statement Create a class `FileSystem` that mimics simple file system operations including creating directories, adding files, and retrieving the content of a file or listing contents of a directory. Class and Method Definitions: 1. **Class `FileSystem`**: - Initialize the file system with a root directory. 2. **Method `mkdir(path: str) -> None`**: - Creates directories recursively starting from the root directory. - **Input**: - `path`: A string representing the path where directories should be created. - **Output**: None 3. **Method `addFile(path: str, content: str) -> None`**: - Adds a file to the specified directory with the given content. - **Input**: - `path`: A string representing the file path with filename included. - `content`: A string representing the content to be added to the file. - **Output**: None 4. **Method `readFile(path: str) -> str`**: - Retrieves the content of the specified file. - **Input**: - `path`: A string representing the file path with filename included. - **Output**: A string representing the content of the file. 5. **Method `ls(path: str) -> list`**: - Lists the contents of the specified directory. If the path is a file, returns the file itself. - **Input**: - `path`: A string representing the directory or file path. - **Output**: A list of strings representing the directory contents or the filename. # Constraints - `path` elements are separated by the \'/\' character. - Directory and file names contain only alphanumeric characters. - File system operations should handle all edge cases gracefully and should raise suitable exceptions if invalid operations are performed, such as reading from a non-existent path. # Examples ```python fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.addFile(\\"/a/b/c/file.txt\\", \\"Hello World\\") assert fs.readFile(\\"/a/b/c/file.txt\\") == \\"Hello World\\" fs.mkdir(\\"/x/y\\") fs.addFile(\\"/x/y/file.txt\\", \\"Another File\\") assert fs.readFile(\\"/x/y/file.txt\\") == \\"Another File\\" assert fs.ls(\\"/a/b\\") == [\\"c\\"] assert fs.ls(\\"/x/y/file.txt\\") == [\\"file.txt\\"] assert fs.ls(\\"/\\") == [\\"a\\", \\"x\\"] ``` # Function Signatures ```python class FileSystem: def __init__(self): pass def mkdir(self, path: str) -> None: pass def addFile(self, path: str, content: str) -> None: pass def readFile(self, path: str) -> str: pass def ls(self, path: str) -> list: pass ``` # Notes - Ensure your implementation is efficient in terms of time complexity, especially for frequently accessed paths. - Test your implementation with a variety of edge cases including deeply nested directories and large files.","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: dirs = path.split(\'/\') node = self.root for d in dirs: if d: # ignore empty strings from split if d not in node: node[d] = {} node = node[d] def addFile(self, path: str, content: str) -> None: dirs = path.split(\'/\') node = self.root for d in dirs[:-1]: if d: # ignore empty strings from split node = node[d] node[dirs[-1]] = content def readFile(self, path: str) -> str: dirs = path.split(\'/\') node = self.root for d in dirs: if d: # ignore empty strings from split node = node[d] return node def ls(self, path: str) -> list: dirs = path.split(\'/\') node = self.root for d in dirs: if d: # ignore empty strings from split node = node[d] if isinstance(node, str): return [dirs[-1]] return sorted(node.keys())"},{"question":"# String Permutations and Substring Verification You are tasked with implementing additional functions for string manipulation to deepen your understanding of permutations and substring operations. Specifically, you need to implement methods for generating all permutations of a string and verifying if one string is a substring of another. **Function Signatures**: 1. `generate_permutations(s: str) -> List[str]` 2. `is_substring(sub: str, main: str) -> bool` **Implementation Details**: 1. **generate_permutations(s)**: * This function should take a string `s`. * It should return a list of all possible permutations of the string. 2. **is_substring(sub, main)**: * This method should take two strings, `sub` and `main`. * It should return a boolean indicating whether `sub` is a substring of `main`. **Constraints**: * String for permutation generation, `s`, will have a maximum length of 7. * Both strings, `sub` and `main`, are non-empty. **Example**: ```python # Test generate_permutations function s = \\"abc\\" result = generate_permutations(s) print(result) # Should print [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] (order can vary) # Test is_substring function sub = \\"abc\\" main = \\"aabbcc\\" result = is_substring(sub, main) print(result) # Should print False sub = \\"abbc\\" main = \\"aabbcc\\" result = is_substring(sub, main) print(result) # Should print True ``` # Edge Cases: * Permutation function should handle the standard input size and return permutations in any order. * Substring function should handle both equal-length and non-equal-length comparisons effectively. Implement these functions to extend the capabilities for string manipulation and verification of substructures within strings.","solution":"from typing import List import itertools def generate_permutations(s: str) -> List[str]: Generates all permutations of the input string s. return [\'\'.join(p) for p in itertools.permutations(s)] def is_substring(sub: str, main: str) -> bool: Checks if sub is a substring of main. return sub in main"},{"question":"# Coding Question: Data Manipulation in CSV Files Context You are provided with a CSV file containing information about various products in an inventory. Each row in the CSV file represents a product, and the columns include `ProductID`, `ProductName`, `Category`, `Quantity`, and `Price`. Task Implement a function `summarize_inventory(file_path: str) -> dict` that takes the file path of the CSV as input and returns a dictionary summarizing the total inventory and the average price per category. The dictionary should have the following structure: ```python { \\"total_inventory\\": int, # Total quantity of all products \\"average_price_per_category\\": { # Average price for each product category \\"category1\\": float, \\"category2\\": float, ... } } ``` The CSV file is structured as follows: ``` ProductID, ProductName, Category, Quantity, Price 1,Widget A,Widgets,100,2.5 2,Widget B,Widgets,150,3.0 3,Gadget A,Gadgets,200,5.0 4,Gadget B,Gadgets,300,7.5 ``` Input * `file_path` - A string representing the file path to the CSV file. Output * A dictionary summarizing the total inventory and the average price per category. Constraints * Handle errors gracefully, such as issues with file reading or parsing. * Ensure that your solution is efficient and handles large files within reasonable time limits. Example Usage ```python # Example usage of the summarize_inventory function inventory_summary = summarize_inventory(\\"products.csv\\") print(inventory_summary) # Expected output: # { # \\"total_inventory\\": 750, # \\"average_price_per_category\\": { # \\"Widgets\\": 2.75, # \\"Gadgets\\": 6.25 # } # } ``` Additional Information * You can use the `csv` module to read and parse the CSV file. * Consider edge cases such as missing or malformed data entries and provide appropriate error handling. * The function should work seamlessly for any properly structured CSV file with the same header format. Make sure your function correctly processes the input file and produces the expected output in the described format.","solution":"import csv def summarize_inventory(file_path: str) -> dict: Summarizes the total inventory and the average price per category from the CSV file. Args: file_path (str): The path to the CSV file containing the inventory data. Returns: dict: A dictionary summarizing the total inventory and average price per category. total_inventory = 0 category_totals = {} category_counts = {} try: with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file) for row in reader: try: quantity = int(row[\'Quantity\']) price = float(row[\'Price\']) category = row[\'Category\'] total_inventory += quantity if category not in category_totals: category_totals[category] = 0 category_counts[category] = 0 category_totals[category] += price category_counts[category] += 1 except ValueError: # Handle cases where conversion to int or float fails # Skip this row if it has malformed data continue average_price_per_category = { category: category_totals[category] / category_counts[category] for category in category_totals } return { \\"total_inventory\\": total_inventory, \\"average_price_per_category\\": average_price_per_category } except FileNotFoundError: raise FileNotFoundError(f\\"The file at path {file_path} was not found.\\") except Exception as e: raise Exception(f\\"An error occurred while processing the file: {e}\\")"},{"question":"You are provided with a rudimentary implementation of a sorting algorithm. Your task is to enhance the algorithm to handle sorting of large datasets more efficiently while maintaining simplicity and comprehension. # Context The provided `simple_sort` function sorts an array of integers in ascending order using a basic sorting technique. Your task is to improve this function to better handle large arrays while ensuring it remains easy to understand. # Function Signature ```python def simple_sort(arr: list[int]) -> list[int]: Sorts the given array of integers in ascending order. :param arr: The array of integers to be sorted. :return: The sorted array in ascending order. ``` # Requirements 1. Optimize the `simple_sort` function to improve its performance on larger arrays. 2. Maintain the simplicity and readability of the implementation for ease of understanding. 3. Implement edge case handling, such as when the array is empty or contains duplicate elements. 4. Ensure the solution includes detailed testing for performance and correctness. # Input Constraints * `arr` will be a list of integers. * The length of `arr` can range from 0 to 10⁶. * The integers within the array can be negative, zero, or positive. # Example ```python # Testing the simple_sort function arr = [4, 3, 2, 1] print(simple_sort(arr)) # Expected output: [1, 2, 3, 4] arr = [4, 4, 4, -1, 6, 3] print(simple_sort(arr)) # Expected output: [-1, 3, 4, 4, 4, 6] arr = [] print(simple_sort(arr)) # Expected output: [] ``` # Guidelines * Enhance the function to handle large arrays more efficiently, possibly considering an efficient sorting algorithm like Merge Sort or Quick Sort. * Ensure edge cases such as empty arrays or arrays with duplicates are properly handled. * Provide clear and concise comments to explain your logic and any optimizations applied.","solution":"def simple_sort(arr: list[int]) -> list[int]: Sorts the given array of integers in ascending order using the Timsort algorithm, which is the sorting algorithm used by Python\'s built-in sort() method for better performance. :param arr: The array of integers to be sorted. :return: The sorted array in ascending order. return sorted(arr)"},{"question":"# Circular Array Rotation You need to implement a function to perform right circular rotations on an array of integers. The function should take the array, the number of rotations, and provide a new array that has been rotated accordingly. Additionally, you should optimize the function to handle large numbers of rotations effectively. Your function should: 1. Rotate the array to the right by the specified number of positions. 2. Return the resulting array after the rotations. # Function Signature ```python def circular_array_rotation(arr: List[int], rotations: int) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers. * `rotations` (int): The number of times to rotate the array to the right. # Output * A list of integers that represents the array after performing the specified number of right rotations. # Constraints * 1 <= len(arr) <= 10^5 * 1 <= rotations <= 10^9 * -10^6 <= arr[i] <= 10^6 # Example ```python # Example 1: arr1 = [1, 2, 3, 4, 5] rotations1 = 2 result1 = circular_array_rotation(arr1, rotations1) # Expected output: [4, 5, 1, 2, 3] # Example 2: arr2 = [1, 2, 3, 4, 5] rotations2 = 5 result2 = circular_array_rotation(arr2, rotations2) # Expected output: [1, 2, 3, 4, 5] # Example 3: arr3 = [1, 2, 3, 4, 5] rotations3 = 7 result3 = circular_array_rotation(arr3, rotations3) # Expected output: [4, 5, 1, 2, 3] ``` # Explanation of Output Example * **Example 1**: The array [1, 2, 3, 4, 5] is rotated 2 times to the right, resulting in [4, 5, 1, 2, 3]. * **Example 2**: Rotating the array [1, 2, 3, 4, 5] five times returns it to its original form. * **Example 3**: Rotating the array [1, 2, 3, 4, 5] seven times is equivalent to rotating it 2 times (since 7 % 5 = 2), resulting in [4, 5, 1, 2, 3]. ***Note***: Ensure the function can handle very large values for the number of rotations efficiently, using optimal time complexity techniques.","solution":"from typing import List def circular_array_rotation(arr: List[int], rotations: int) -> List[int]: Performs right circular rotations on an array of integers. Parameters: arr (List[int]): A list of integers. rotations (int): The number of times to rotate the array to the right. Returns: List[int]: The array after performing the specified number of right rotations. n = len(arr) rotations = rotations % n # Effective rotations needed return arr[-rotations:] + arr[:-rotations]"},{"question":"# Problem Statement You are given a binary tree in which each node contains a value of an integer type. Your task is to construct an efficient algorithm to determine the number of nodes in the tree that lie within a given range [L, R]. You will implement: 1. A function to count the number of nodes within the specified range in the binary tree. # Function Specification Function: `count_nodes_in_range` - **Input**: 1. A root of a binary tree `root` which is a TreeNode object. 2. Two integers `L` and `R` representing the given range [L, R]. - **Output**: An integer representing the number of nodes that have values within the range [L, R] inclusively. ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_nodes_in_range(root: TreeNode, L: int, R: int) -> int: pass ``` # Constraints - The number of nodes in the tree will be between 1 and 100,000. - The value of each node is an integer between -10^9 and 10^9. - L and R are integers where -10^9 ≤ L ≤ R ≤ 10^9. # Example ```python root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(8) root.right.right = TreeNode(18) L = 5 R = 15 print(count_nodes_in_range(root, L, R)) # Expected output: 4 ``` # Notes - Your solution should be optimized to handle the largest possible input sizes efficiently. - Consider an approach that leverages the properties of binary trees, such as using depth-first or breadth-first search to traverse and count nodes. - Ensure the function correctly handles edge cases, such as an empty tree, single-node tree, or all nodes falling outside the range. This task will test your skill in working with binary trees as well as implementing efficient algorithms to handle large datasets.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_nodes_in_range(root: TreeNode, L: int, R: int) -> int: if root is None: return 0 count = 0 if L <= root.value <= R: count = 1 count += count_nodes_in_range(root.left, L, R) count += count_nodes_in_range(root.right, L, R) return count"},{"question":"**Context**: Design a function that takes a list of timestamps and calculates the average interval between consecutive timestamps. Every timestamp is a string formatted as `\\"YYYY-MM-DD HH:MM:SS\\"`. Your function should parse the timestamps, calculate the differences, and then return the average interval in seconds as a floating-point number. **Task**: Create a function `average_interval` that calculates the average interval between consecutive timestamps. **Function Signature**: ```python def average_interval(timestamps: List[str]) -> float: ``` **Input**: - `timestamps`: A list of strings representing timestamps in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. **Output**: - Return the average interval between consecutive timestamps in seconds as a float. **Examples**: ```python timestamps = [ \\"2023-01-01 00:00:00\\", \\"2023-01-01 00:00:10\\", \\"2023-01-01 00:00:20\\", \\"2023-01-01 00:00:30\\" ] print(average_interval(timestamps)) ``` Expected Output: ``` 10.0 ``` **Constraints**: - The list of timestamps is not empty and contains at least two timestamps. - The timestamps are in chronological order. - The format of the timestamps is guaranteed to be correct as `\\"YYYY-MM-DD HH:MM:SS\\"`. Ensure your function correctly handles all edge cases, such as varying intervals between timestamps.","solution":"from typing import List from datetime import datetime def average_interval(timestamps: List[str]) -> float: Calculate the average interval between consecutive timestamps in the list. Parameters: timestamps (List[str]): A list of timestamp strings in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: float: The average interval in seconds. total_interval = 0 num_intervals = len(timestamps) - 1 for i in range(num_intervals): t1 = datetime.strptime(timestamps[i], \'%Y-%m-%d %H:%M:%S\') t2 = datetime.strptime(timestamps[i + 1], \'%Y-%m-%d %H:%M:%S\') interval = (t2 - t1).total_seconds() total_interval += interval average_interval = total_interval / num_intervals return average_interval"},{"question":"# Substring Finder Context Manipulating strings and finding substrings is a common task in programming, often useful in text processing and search functionalities. Efficiently determining the occurrence of a specific substring within a larger string can be crucial for many applications. Task Write a function `find_substring_occurrences(main_string: str, sub_string: str) -> int` that counts the number of non-overlapping occurrences of the `sub_string` within the `main_string`. The function should adhere to the following constraints and characteristics: 1. If either `main_string` or `sub_string` is empty, raise a `ValueError` with the message \\"Input strings must not be empty\\". 2. The function should return the number of times the `sub_string` appears in the `main_string` without overlapping. Input - `main_string`: A string in which to search for occurrences. - `sub_string`: A string whose occurrences need to be counted within `main_string`. Output - Return an integer representing the number of non-overlapping occurrences of `sub_string` in `main_string`. Constraints - `main_string` and `sub_string` must be non-empty strings. Example ```python find_substring_occurrences(\\"banana\\", \\"ana\\") # Output: 1 find_substring_occurrences(\\"abcabcabc\\", \\"abc\\") # Output: 3 find_substring_occurrences(\\"hello world\\", \\"world\\") # Output: 1 ``` Hints - Consider using a sliding window approach or the built-in string method for finding non-overlapping substrings. - Ensure that the function handles edge cases where `sub_string` might occur at the very start or end of `main_string`.","solution":"def find_substring_occurrences(main_string: str, sub_string: str) -> int: Counts the number of non-overlapping occurrences of sub_string within main_string. Raises a ValueError if either input string is empty. :param main_string: The main string in which to search for occurrences. :param sub_string: The substring whose occurrences need to be counted. :return: The number of non-overlapping occurrences of sub_string in main_string. if not main_string or not sub_string: raise ValueError(\\"Input strings must not be empty\\") count = 0 start = 0 while True: start = main_string.find(sub_string, start) if start == -1: break count += 1 start += len(sub_string) return count"},{"question":"# Coding Challenge Scenario You are designing a file system for an operating system. One crucial feature of this system is to count the number of files and subdirectories contained within a directory and any of its subdirectories. To simplify this feature, you need to write a function that counts all files in a nested directory structure, where a directory can contain files and other directories. Task Implement the function `count_files_in_directory(directory: dict) -> int` which takes a directory represented as a nested dictionary and returns the total number of files contained within this directory and all its subdirectories. # Input and Output - **Input**: A dictionary where: - Keys represent file or directory names. - Values are either `None` if the key is a file, or another dictionary if it is a directory. - **Output**: An integer representing the total number of files. # Constraints - The input dictionary will not contain cyclic references. - The depth of nested directories can vary, but you can assume the structure is well-formed. # Performance Requirements - Your solution should efficiently traverse the directory structure, aiming for a time complexity of ( O(n) ), where ( n ) is the total number of files and directories. - Space complexity should also be considered, ideally aiming for ( O(h) ), where ( h ) is the maximum depth of the directory structure. # Examples - `count_files_in_directory({\\"file1\\": None, \\"file2\\": None, \\"subdir1\\": {\\"file3\\": None, \\"subdir2\\": {\\"file4\\": None}}})` should return `4` - `count_files_in_directory({\\"fileA\\": None, \\"dir1\\": {\\"fileB\\": None, \\"dir2\\": {\\"fileC\\": None, \\"fileD\\": None}}})` should return `4` - `count_files_in_directory({\\"file1\\": None, \\"dir1\\": {}})` should return `1` - `count_files_in_directory({})` should return `0` # Additional Notes - You can assume the directory names and file names are unique within each level. - Pay attention to the efficiency of your traversal method and ensure your function is robust to handle varying depths of nesting within the directory structure.","solution":"def count_files_in_directory(directory: dict) -> int: This function recursively counts all files in a given directory. Args: - directory (dict): A dictionary representing the directory structure. Returns: - int: The total number of files. file_count = 0 for key, value in directory.items(): if value is None: # It\'s a file file_count += 1 else: # It\'s a directory, we need to recursively count its files file_count += count_files_in_directory(value) return file_count"},{"question":"# Coding Assessment Question: Write a function `sum_even_fibonacci(n: int) -> int` that takes an integer `n` and returns the sum of all even Fibonacci numbers that do not exceed `n`. **Function Signature** ```python def sum_even_fibonacci(n: int) -> int: pass ``` **Input** - `n`: A positive integer (2 ≤ n ≤ 4,000,000). **Output** - An integer representing the sum of all even Fibonacci numbers not exceeding `n`. **Example** ```python assert sum_even_fibonacci(10) == 10 # Since the even Fibonacci numbers less than 10 are 2 and 8 assert sum_even_fibonacci(34) == 44 # Since the even Fibonacci numbers less than 34 are 2, 8, and 34 ``` **Constraints and Conditions** - Ensure your solution is optimized for the given constraint `n ≤ 4,000,000`. - Handle cases where the input could be relatively large efficiently. **Performance Considerations** - The time complexity should be linear with respect to the sequence generation, aiming to handle the maximum value of `n` efficiently. - Use an efficient iterative approach or any other suitable method to minimize computational overhead. **Scenario** You are developing a module that involves heavy Fibonacci sequence computations for a scientific application. The requirement is to calculate the sum of all even Fibonacci numbers under a certain threshold quickly, to be integrated into a larger calculation pipeline where performance is critical.","solution":"def sum_even_fibonacci(n: int) -> int: Returns the sum of all even Fibonacci numbers that do not exceed n. a, b = 1, 2 total = 0 while b <= n: if b % 2 == 0: total += b a, b = b, a + b return total"},{"question":"# Stock Price Update Tracker Context As part of a project to build a stock trading application, you need to create a feature that tracks and processes updates of stock prices over time to calculate the highest and lowest prices seen during the day. Problem Statement Write a Python class `StockTracker` that provides functionalities to add stock price updates and calculate the highest and lowest stock prices seen during the day. The class should support the following methods: 1. `add_price(price: float)` - Adds a new price update. 2. `get_highest_price()` - Returns the highest stock price recorded. 3. `get_lowest_price()` - Returns the lowest stock price recorded. Ensure the methods return `None` if no prices have been added yet. Class Signature ```python class StockTracker: def __init__(self): pass def add_price(self, price: float): pass def get_highest_price(self) -> float: pass def get_lowest_price(self) -> float: pass ``` Example ```python >>> tracker = StockTracker() >>> tracker.add_price(100.5) >>> tracker.add_price(98.7) >>> tracker.add_price(102.3) >>> tracker.add_price(99.9) >>> tracker.get_highest_price() 102.3 >>> tracker.get_lowest_price() 98.7 >>> tracker = StockTracker() >>> tracker.get_highest_price() # No prices added yet >>> print(tracker.get_highest_price()) # Should print None >>> print(tracker.get_lowest_price()) # Should print None ``` Constraints and Notes 1. Prices are represented as floating-point numbers. 2. Make sure the class handles sequences of price updates efficiently. 3. Handle edge cases, such as querying for the highest and lowest prices when no prices have been added yet. 4. Consider the efficiency of adding prices and retrieving the highest and lowest prices, as this may be frequently invoked in a real-time application. Testing Include several test cases to validate your implementation, particularly focusing on conditions where no prices have been added yet and when multiple updates are added in quick succession.","solution":"class StockTracker: def __init__(self): self.prices = [] def add_price(self, price: float): self.prices.append(price) def get_highest_price(self) -> float: if not self.prices: return None return max(self.prices) def get_lowest_price(self) -> float: if not self.prices: return None return min(self.prices)"},{"question":"# Problem Statement: You are tasked with generating a sequence of numbers where each number is the sum of digital roots of all numbers from 1 up to that number (inclusive). The digital root of a number is the single digit obtained by an iterative process of summing digits, on each step using the result from the previous step, until a single digit is obtained. # Function Signature: ```python def digital_root_sum_sequence(n: int) -> list: pass ``` # Input: - `n` (int): The length of the sequence to be generated. # Output: - (list): A list of length `n` where the `i-th` element (0-based index) is the sum of digital roots of integers from 1 to `i+1`. # Constraints: - `1 <= n <= 10^4` - Digital root calculation should be efficient. # Performance Requirements: - The time complexity of your solution should not exceed ( O(n) ). - The space complexity should be ( O(n) ). # Examples: ```python assert digital_root_sum_sequence(5) == [1, 3, 6, 10, 15] assert digital_root_sum_sequence(10) == [1, 3, 6, 10, 15, 21, 28, 36, 45, 46] assert digital_root_sum_sequence(1) == [1] ``` # Explanation of the Example: - For `n = 5`, the sequence is: - Digital roots: [1, 2, 3, 4, 5] - Sums: [1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5] - Result: [1, 3, 6, 10, 15] - For `n = 10`, the sequence is: - Digital roots: [1, 2, 3, 4, 5, 6, 7, 8, 9, 1] - Sums: [1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5, 1+2+3+4+5+6, 1+2+3+4+5+6+7, 1+2+3+4+5+6+7+8, 1+2+3+4+5+6+7+8+9, 1+2+3+4+5+6+7+8+9+1] - Result: [1, 3, 6, 10, 15, 21, 28, 36, 45, 46] - For `n = 1`, the sequence is: - Digital roots: [1] - Sums: [1] - Result: [1] # Additional Notes: - The digital root of `0` is `0`. - Digital root of a number can be efficiently calculated using properties of modulo 9. - Validate your input to ensure it fits within the constraints specified.","solution":"def digital_root(n): Returns the digital root of n. if n == 0: return 0 else: return (n - 1) % 9 + 1 def digital_root_sum_sequence(n): Returns a list of length n where the i-th element is the sum of digital roots of integers from 1 to i+1. sequence = [] total_sum = 0 for i in range(1, n + 1): total_sum += digital_root(i) sequence.append(total_sum) return sequence"},{"question":"# Array Rotation Scenario You are working on a data visualization tool where you need to dynamically rotate arrays representing different visualization elements. The goal is to shift the array elements to the right by a specified number of steps. Handling this efficiently is important due to potential large size of the arrays. Task Implement the function `rotate_array` that rotates the elements of an input array to the right by a specified number of steps. Function Signature ```python def rotate_array(arr: List[int], steps: int) -> List[int]: ``` Input * **arr** (List[int]): A list of integers. * **steps** (int): The number of steps to rotate the array by. Output * **List[int]**: The rotated array. Constraints * The length of the array can be up to 10^5 elements. * The number of rotation steps can be greater than the length of the array. * Handle edge cases like an empty array and rotation steps being zero. Example ```python arr = [1, 2, 3, 4, 5] steps = 2 assert rotate_array(arr, steps) == [4, 5, 1, 2, 3] arr = [1, 2, 3, 4, 5] steps = 7 assert rotate_array(arr, steps) == [4, 5, 1, 2, 3] arr = [] steps = 3 assert rotate_array(arr, steps) == [] arr = [1, 2, 3, 4, 5] steps = 0 assert rotate_array(arr, steps) == [1, 2, 3, 4, 5] ``` This question tests your understanding of array manipulation and modular arithmetic to efficiently rotate elements within an array, optimizing for both time and space complexity.","solution":"from typing import List def rotate_array(arr: List[int], steps: int) -> List[int]: This function rotates the array to the right by a specified number of steps. n = len(arr) if n == 0 or steps % n == 0: # No need to rotate return arr steps = steps % n # Normalize steps to be within the range of array length return arr[-steps:] + arr[:-steps]"},{"question":"# Question Add a new node to a singly linked list at a specified index. If the index is larger than the length of the linked list, append the new node at the end of the list. Implement and test the following functions: 1. **Function Name**: `insert_node(head: Optional[ListNode], index: int, value: int) -> ListNode` - **Input**: - `head`: The head node of a singly linked list (`Optional[ListNode]`). - `index`: An integer representing the position where the new node should be inserted. - `value`: An integer value for the new node. - **Output**: The head node of the modified linked list (`ListNode`). - **Constraints**: Handle cases where the list is empty and where the index is larger than the current size of the list. - **Error Handling**: Raise an appropriate error if the index is negative. # Example ```python >>> # Define the ListNode class >>> class ListNode: ... def __init__(self, x): ... self.val = x ... self.next = None ... def __repr__(self): ... return f\\"{self.val} -> {self.next}\\" >>> # Helper function to convert a list to a singly linked list >>> def create_linked_list(lst): ... head = ListNode(lst[0]) ... current = head ... for item in lst[1:]: ... current.next = ListNode(item) ... current = current.next ... return head >>> head = create_linked_list([1, 2, 3, 4]) >>> print(insert_node(head, 2, 99)) 1 -> 2 -> 99 -> 3 -> 4 -> None >>> head = create_linked_list([1, 2, 3, 4]) >>> print(insert_node(head, 0, 99)) 99 -> 1 -> 2 -> 3 -> 4 -> None >>> head = create_linked_list([1, 2, 3, 4]) >>> print(insert_node(head, 10, 99)) 1 -> 2 -> 3 -> 4 -> 99 -> None >>> head = None >>> print(insert_node(head, 0, 99)) 99 -> None >>> head = create_linked_list([1, 2, 3, 4]) >>> print(insert_node(head, -1, 99)) Traceback (most recent call last): ... ValueError: The index must be a non-negative integer. ``` # Requirements - Implement proper error handling for invalid indices. - Ensure the function works efficiently, even when the list is very large. - Write a helper function or additional code to test the solution with various edge cases.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def __repr__(self): return f\\"{self.val} -> {self.next}\\" def insert_node(head, index, value): if index < 0: raise ValueError(\\"The index must be a non-negative integer.\\") new_node = ListNode(value) if not head: return new_node if index == 0: new_node.next = head return new_node current = head count = 0 while current.next and count < index - 1: current = current.next count += 1 new_node.next = current.next current.next = new_node return head # Helper function to convert a list to a singly linked list def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for item in lst[1:]: current.next = ListNode(item) current = current.next return head"},{"question":"# Subsequences with Distinct Elements In this task, you are required to find the length of the longest subsequence in a given list of positive integers such that all elements in the subsequence are distinct. Write a function `longest_distinct_subsequence` **Function Signature**: ```python def longest_distinct_subsequence(arr: List[int]) -> int: ``` **Input**: - A list of integers `arr` containing `n` elements, where `1 <= n <= 1000`. **Output**: - An integer representing the length of the longest subsequence with all distinct elements. Constraints: - Each element in the array is a positive integer and does not exceed 100,000. Example ```python print(longest_distinct_subsequence([1, 2, 3, 4, 5])) # expected output: 5 print(longest_distinct_subsequence([1, 2, 2, 3, 4, 5, 6, 7, 2, 3])) # expected output: 7 print(longest_distinct_subsequence([10, 10, 10, 10])) # expected output: 1 ``` Hints: - Utilize a set to effectively determine if an element has appeared before in the subsequence. - Iterate through the list while maintaining a record of seen elements to dynamically build the longest subsequence with distinct elements.","solution":"def longest_distinct_subsequence(arr): Returns the length of the longest subsequence with all distinct elements. seen = set() # To keep track of seen elements longest_subseq_len = 0 for num in arr: if num not in seen: seen.add(num) longest_subseq_len += 1 return longest_subseq_len"},{"question":"# Scenario: You are working with a data processing system that relies on consistent and unique identifiers for records. The current approach generates identifiers by hashing the record contents, but this method can sometimes lead to collisions. Your task is to implement a function that generates a unique, incremental identifier for each new record. # Task: Write a function `generate_unique_id(records: List[str]) -> Dict[str, int]` that takes a list of record names and returns a dictionary where each key is a record name and each value is a unique identifier starting from 1. Ensure the identifiers are assigned in the order the records appear in the input list. # Input: * A list of strings `records` where each string represents a record name (1 <= len(records) <= 10^6). # Output: * A dictionary where each key is a record name from the input list and each value is a unique integer identifier. # Example: ```python def generate_unique_id(records: List[str]) -> Dict[str, int]: pass print(generate_unique_id([\\"record1\\", \\"record2\\", \\"record3\\"])) # Output: {\'record1\': 1, \'record2\': 2, \'record3\': 3} print(generate_unique_id([\\"apple\\", \\"banana\\", \\"apple\\"])) # Output: {\'apple\': 1, \'banana\': 2, \'apple_1\': 3} ``` # Constraints: * The input list may contain duplicate record names; in such cases, suffix the subsequent occurrences of the same name with an incremental count (_1, _2, etc.) to maintain uniqueness. * Ensure the function is efficient and can handle the upper limits of input size. * The output must maintain the order of the records as they appear in the input list. **Hint**: Use a dictionary to keep track of counts for each record name to handle duplicates.","solution":"from typing import List, Dict def generate_unique_id(records: List[str]) -> Dict[str, int]: unique_id_dict = {} existing_records = {} for i, record in enumerate(records): if record not in existing_records: unique_record_name = record existing_records[record] = 1 else: existing_records[record] += 1 unique_record_name = f\\"{record}_{existing_records[record] - 1}\\" unique_id_dict[unique_record_name] = i + 1 return unique_id_dict"},{"question":"# Problem Statement: Base64 URL Safe Compressor You are tasked with building a system that securely stores and transfers sensitive binary data by encoding it in a textual format. The chosen format for this task is Base64 URL Safe encoding, which avoids characters commonly confused in URL contexts and eliminates the need for padding. **Objective:** Implement two functions, `custom_base64_urlsafe_encode` and `custom_base64_urlsafe_decode`, that encode and decode binary data using the Base64 URL Safe system. Your functions should be optimized for performance and handle edge cases appropriately. # Function 1: custom_base64_urlsafe_encode **Input:** - `data: bytes` - A bytes object representing the binary data to be encoded. **Output:** - `encoded_data: str` - The Base64 URL Safe encoded representation of the input data as a string. # Function 2: custom_base64_urlsafe_decode **Input:** - `encoded_data: str` - A Base64 URL Safe encoded string. **Output:** - `data: bytes` - The original binary data after decoding the Base64 encoded input. # Constraints: 1. The input to `custom_base64_urlsafe_encode` can be any length of bytes. 2. The input to `custom_base64_urlsafe_decode` must be a valid Base64 URL Safe encoded string. 3. Your implementation must handle any edge cases like empty input or improper padding seamlessly. # Example: ```python def custom_base64_urlsafe_encode(data: bytes) -> str: # Your implementation here pass def custom_base64_urlsafe_decode(encoded_data: str) -> bytes: # Your implementation here pass # Test cases: # Encode assert custom_base64_urlsafe_encode(b\\"Hello World!\\") == \'SGVsbG8gV29ybGQh\' assert custom_base64_urlsafe_encode(b\\"123456\\") == \'MTIzNDU2\' assert custom_base64_urlsafe_encode(b\\"test string for encoding\\") == \'dGVzdCBzdHJpbmcgZm9yIGVuY29kaW5n\' # Decode assert custom_base64_urlsafe_decode(\'SGVsbG8gV29ybGQh\') == b\'Hello World!\' assert custom_base64_urlsafe_decode(\'MTIzNDU2\') == b\'123456\' assert custom_base64_urlsafe_decode(\'dGVzdCBzdHJpbmcgZm9yIGVuY29kaW5n\') == b\'test string for encoding\' ``` Your solution should be efficient, handling large data inputs gracefully, and include proper handling of edge cases such as empty input and improper padding. Ensure the encoded data is both URL-safe and human-readable. **Good Luck!**","solution":"import base64 def custom_base64_urlsafe_encode(data: bytes) -> str: Encodes the given binary data using Base64 URL Safe encoding and removes padding. encoded_data = base64.urlsafe_b64encode(data).rstrip(b\'=\').decode(\'utf-8\') return encoded_data def custom_base64_urlsafe_decode(encoded_data: str) -> bytes: Decodes the given Base64 URL Safe encoded string to its original binary data. Adds necessary padding before decoding. padding = 4 - (len(encoded_data) % 4) encoded_data += \'=\' * padding data = base64.urlsafe_b64decode(encoded_data) return data"},{"question":"Task Write a Python function that calculates the running median of a continuously updated list of integers. Input * A list of integers. Output * A list of floating-point numbers representing the median after each insertion. Constraints * The function should handle lists of varying lengths, including very long lists efficiently. * The function should work in O(log n) time complexity per insertion. Performance * Aim to handle million-sized lists efficiently by maintaining the sorted order using appropriate data structures (e.g., heaps). Function Signature ```python from typing import List def running_median(nums: List[int]) -> List[float]: ``` Example ```python nums = [2, 1, 5, 7, 2, 0, 5] result = running_median(nums) print(result) # Expected output: [2, 1.5, 2, 3.5, 2, 2, 2] ``` Hint Use two heaps (a max-heap for the lower half of the numbers, and a min-heap for the upper half) to maintain the balance and retrieve the median efficiently after each insertion.","solution":"from typing import List import heapq def running_median(nums: List[int]) -> List[float]: Calculates the running median of a continuously updated list of integers. def add_number(num, lowers, highers): if len(lowers) == 0 or num < -lowers[0]: heapq.heappush(lowers, -num) else: heapq.heappush(highers, num) def rebalance(lowers, highers): if len(lowers) > len(highers) + 1: heapq.heappush(highers, -heapq.heappop(lowers)) elif len(highers) > len(lowers): heapq.heappush(lowers, -heapq.heappop(highers)) def get_median(lowers, highers) -> float: if len(lowers) == len(highers): return (-lowers[0] + highers[0]) / 2.0 else: return -lowers[0] lowers, highers = [], [] # max-heap for the lower half and min-heap for the upper half medians = [] for num in nums: add_number(num, lowers, highers) rebalance(lowers, highers) medians.append(get_median(lowers, highers)) return medians"},{"question":"Data Structure Manipulation – In-Place Rotation of a Matrix Objective: Implement a function that takes a square matrix and rotates it 90 degrees clockwise in-place. Description: Given an `n x n` 2D matrix, rotate the matrix by 90 degrees (clockwise). This must be done in place, which means you have to modify the input 2D matrix directly. Do not allocate another 2D matrix and perform the rotation. Function Definition: ```python def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given n x n matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): 2D list representing the square matrix. Returns: None: The matrix is modified in place. ``` Constraints: 1. The matrix is a square matrix, i.e., the number of rows and columns are equal. 2. The matrix dimensions are within the range 1 <= n <= 1000. Input: - `matrix`: A list of lists where each list represents a row of the square matrix. Output: - The function returns nothing as the matrix is modified in place. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Approach: 1. Transpose the matrix by swapping `matrix[i][j]` with `matrix[j][i]`. 2. Reverse each row to get the final rotated matrix. Edge Cases to Consider: 1. Handle the smallest case where the matrix has a single element. 2. Ensure the function works correctly for large matrices close to the upper constraint. Good luck!","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given n x n matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): 2D list representing the square matrix. Returns: None: The matrix is modified in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Rotate Matrix **Context**: Matrix manipulation is a common task in programming, particularly within the realms of game development, image processing, and mathematical computations. **Problem Statement**: Given an `NxN` matrix, your task is to rotate the matrix 90 degrees clockwise. **Function to Implement**: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Requirements: 1. **Input**: The function should accept a single argument: * `matrix (List[List[int]])`: A 2D list representing the NxN matrix. 2. **Output**: The function should return: * A new `NxN` matrix that is the original matrix rotated 90 degrees clockwise. 3. **Constraints**: * The matrix will have at least 1x1 dimensions. * You can utilize additional data structures if necessary but aim for an in-place solution if possible. 4. **Performance**: * Ensure the solution is efficient in both time and space complexity. 5. **Edge Cases**: * An empty matrix. * A matrix with only one element. * Matrices with uniform elements. 6. **Coding Guidelines**: * Ensure the code is well-structured, with clear function definitions. * Include comments for any non-trivial logic. **Example**: Consider the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` After rotating the matrix 90 degrees clockwise, your function should return: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Remember to test your function thoroughly with various input scenarios to ensure its correctness and efficiency!","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix 90 degrees clockwise. n = len(matrix) # Create a new matrix to store the rotated result rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"# Network throughput calculation You have been hired to design a simple network analysis tool that calculates the throughput of a network based on given parameters. Throughput is a measure of how much data is successfully transmitted from one place to another in a given time period and is usually measured in bits per second (bps). Your task is to implement a function that calculates the network throughput using the following formula: [ T = frac{S times 8}{T_t} ] where: - ( T ) is the network throughput in bps. - ( S ) is the size of the transferred data in bytes. - ( T_t ) is the total transmission time in seconds. **Task**: Write a function: 1. `network_throughput(data_size: float, transmission_time: float) -> float` The function must: 1. Calculate the throughput using the formula provided. 2. Raise a `ValueError` if the input data size or transmission time is zero or negative: - `\\"Invalid inputs. Enter positive values for data size and transmission time.\\"` # Function description and example 1. **network_throughput** - **Input**: - `data_size` (float): size of the transferred data in bytes. - `transmission_time` (float): total transmission time in seconds. - **Output**: - Returns the network throughput (float) in bps. - **Examples**: ```python assert network_throughput(1000, 2) == 4000.0 assert network_throughput(500, 4) == 1000.0 assert network_throughput(1.5e6, 30) == 400000.0 ``` Make sure the function raises appropriate errors for invalid inputs, as described above.","solution":"def network_throughput(data_size: float, transmission_time: float) -> float: Calculate the network throughput in bps. Args: data_size (float): Size of the transferred data in bytes. transmission_time (float): Total transmission time in seconds. Returns: float: Network throughput in bps. Raises: ValueError: If data_size or transmission_time are non-positive. if data_size <= 0 or transmission_time <= 0: raise ValueError(\\"Invalid inputs. Enter positive values for data size and transmission time.\\") throughput = (data_size * 8) / transmission_time return throughput"},{"question":"# Problem Statement You have been provided with a partly implemented Game of Life simulator in Python. Your task is to complete the function `game_of_life(grid: List[List[int]]) -> List[List[int]]`, which takes a 2D grid of 0s and 1s representing the game board and updates it to the next state according to the Game of Life rules. # Requirements and Constraints 1. **Input:** - `grid`: A list of lists (2D array) containing integers 0 and 1 (0 represents a dead cell, 1 represents a live cell). 2. **Output:** - Returns a new 2D list representing the game board in its next state. 3. **Constraints:** - The grid dimensions will be in the range [1, 1000] for both rows and columns. - You need to handle edge cells correctly as if they have adjacent cells that are dead. # Game of Life Rules: 1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation. 2. Any live cell with two or three live neighbors lives on to the next generation. 3. Any live cell with more than three live neighbors dies, as if by overpopulation. 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. # Example **Input**: ```python grid = [ [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0] ] ``` **Output**: ```python [ [0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0] ] ``` # Instructions 1. Implement the function `game_of_life(grid: List[List[int]]) -> List[List[int]]` to simulate one iteration of the Game of Life. 2. Ensure that the output grid is a new grid and does not modify the input grid directly. 3. Test your function thoroughly with different grid configurations and edge cases. ```python from typing import List def game_of_life(grid: List[List[int]]) -> List[List[int]]: # Your code goes here pass # Example usage: # grid = [ # [0, 1, 0], # [0, 0, 1], # [1, 1, 1], # [0, 0, 0] # ] # new_grid = game_of_life(grid) ```","solution":"from typing import List def game_of_life(grid: List[List[int]]) -> List[List[int]]: def count_live_neighbors(r, c): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < len(grid) and 0 <= cc < len(grid[0]): count += grid[rr][cc] return count rows, cols = len(grid), len(grid[0]) new_grid = [[0 for _ in range(cols)] for _ in range(rows)] for r in range(rows): for c in range(cols): live_neighbors = count_live_neighbors(r, c) if grid[r][c] == 1: if live_neighbors < 2 or live_neighbors > 3: new_grid[r][c] = 0 else: new_grid[r][c] = 1 else: if live_neighbors == 3: new_grid[r][c] = 1 else: new_grid[r][c] = 0 return new_grid"},{"question":"Problem Statement You are tasked with writing a function that calculates the least common multiple (LCM) of an array of integers. The least common multiple of a set of positive integers is the smallest positive integer that is divisible by each of them. # Function Signature ```python def find_lcm(arr: List[int]) -> int: pass ``` # Input - A list of integers `arr` (1 ≤ len(arr) ≤ 100, 1 ≤ arr[i] ≤ 10^4) representing the elements for which you need to find the LCM. # Output - Returns the least common multiple of the integers in the input array. # Example ```python >>> find_lcm([2, 7, 3]) 42 >>> find_lcm([5, 10, 20]) 20 >>> find_lcm([4, 6, 8]) 24 ``` # Constraints - The function should handle an array of integers where the length of the array and the values of the integers are within the specified range. - Optimize the function to consider time complexity, especially for larger values and longer arrays. # Notes - Ensure to validate input and handle edge cases where the input array might have very small or very large numbers. - Utilize efficient algorithms or built-in functions to calculate the LCM, leveraging the relationship between GCD (Greatest Common Divisor) and LCM. Your task is to implement the function `find_lcm` following the above specifications.","solution":"from math import gcd from functools import reduce from typing import List def lcm(a: int, b: int) -> int: Helper function to find the LCM of two numbers. return a * b // gcd(a, b) def find_lcm(arr: List[int]) -> int: Returns the LCM of an array of integers. return reduce(lcm, arr)"},{"question":"# Problem Statement You have been tasked with writing a script to help manage the inventory of products in a small shop. Your program needs to ensure the consistency and correctness of inventory data by performing several operations. Write a program that: 1. Accepts two lists as input: `products` (a list of strings representing product names) and `quantities` (a list of integers representing the quantity in stock for each product). 2. Matches each product with its corresponding quantity, ensuring that both lists are of the same length. 3. Allows the user to query the quantity of a specific product by its name. 4. Raises an appropriate error if the `products` and `quantities` lists do not match in length. # Input Format * Two lists: 1. A list of strings `products`, where each string represents a product name. 2. A list of integers `quantities`, where each integer represents the quantity of the corresponding product in the `products` list. # Output Format * When querying a product, print the quantity of that product. * If the queried product does not exist, print \\"Product not found\\". * If the input lists do not match in length, raise a `ValueError` with a descriptive message. # Constraints * All quantity values must be non-negative. # Example Input ```python products = [\\"apple\\", \\"banana\\", \\"orange\\"] quantities = [10, 5, 15] query = \\"banana\\" ``` Output ``` 5 ``` Input ```python products = [\\"apple\\", \\"banana\\", \\"orange\\"] quantities = [10, 5, 15, 20] # mismatched length ``` Output ``` ValueError: The length of products and quantities lists must match. ``` # Function Signature The implementation should include the following function: ```python def inventory_check(products: list, quantities: list, query: str) -> int: pass ``` # Requirements 1. Ensure that the two input lists `products` and `quantities` have the same length, raising a `ValueError` if they do not. 2. Handle the querying of a product name gracefully, returning its quantity or \\"Product not found\\" if the product is not present. 3. Implement all necessary error checking to ensure robust and reliable code.","solution":"def inventory_check(products: list, quantities: list, query: str) -> int: Checks the inventory and returns the quantity of the queried product. if len(products) != len(quantities): raise ValueError(\\"The length of products and quantities lists must match.\\") inventory = dict(zip(products, quantities)) if query in inventory: return inventory[query] else: raise ValueError(\\"Product not found\\")"},{"question":"# Coding Assessment Question Context Sorting algorithms are fundamental concepts in computer science and critical for optimizing numerous applications. They arrange data in a particular order, improving the efficiency of various operations, from searching to merging datasets. Problem Statement Your task is to implement the Merge Sort algorithm in Python. Merge Sort is a divide-and-conquer algorithm that recursively splits an array into halves, sorts each half, and then merges the sorted halves back together. Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` Input - `arr` (List[int]): A list of integers which needs to be sorted. Output - A sorted list of integers (List[int]). Constraints - The input list may contain zero or more integers. - The input list can have negative integers as well. - You should not use built-in sorting functions. - The operation must have a time complexity of O(n log n). Examples ```python >>> merge_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] >>> merge_sort([4, 2, 6, 1]) [1, 2, 4, 6] >>> merge_sort([]) [] >>> merge_sort([-3, 2, -1, 4]) [-3, -1, 2, 4] >>> merge_sort([5]) [5] ``` Additional Notes 1. Implement the helper function `merge` that takes two sorted lists and merges them into a single sorted list, which will be used by the `merge_sort` function. 2. Ensure your solution handles edge cases such as an empty list or a list with one element. 3. Consider both the best-case and worst-case time complexity during implementation. Good luck!","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Binary Search on a Sorted Array with Duplicates You are given a task to find the first occurrence of a target value in a sorted array that may contain duplicate values using the Binary Search algorithm. Function to Implement ```python def find_first_occurrence(arr, target): Find the index of the first occurrence of the target value in a sorted array. If the target value is not found, return -1. Parameters: arr (list of int): The sorted array (may contain duplicates). target (int): The target value to find. Returns: int: The index of the first occurrence of target, or -1 if the target is not found. pass ``` Input: * `arr`: A list of integers in non-decreasing order. The list can contain duplicate values. * `target`: An integer, the value to search for in the array. Output: * Return the index of the first occurrence of the target value in the array. If the target does not exist in the array, return -1. Constraints: * The length of the array (`len(arr)`) is between 1 and 10^5. * The elements of the array and the target value are between -10^9 and 10^9. Performance Requirements: * Time Complexity: O(log n) * Space Complexity: O(1) Example: ```python arr = [1, 2, 2, 2, 3, 4, 5] target = 2 # Using the find_first_occurrence function index = find_first_occurrence(arr, target) print(f\\"First occurrence of {target} is at index: {index}\\") ``` *Expected Output*: `First occurrence of 2 is at index: 1`","solution":"def find_first_occurrence(arr, target): Find the index of the first occurrence of the target value in a sorted array. If the target value is not found, return -1. Parameters: arr (list of int): The sorted array (may contain duplicates). target (int): The target value to find. Returns: int: The index of the first occurrence of target, or -1 if the target is not found. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: result = mid right = mid - 1 elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Find Kth Element in Two Sorted Arrays Problem Statement You are to implement an algorithm to find the `k`-th smallest element in the union of two sorted arrays. The arrays may have different lengths and can contain both positive and negative integers. The solution should be optimized beyond a naive O((m+n) log(m+n)) approach. Function Signature ```python def find_kth_element(arr1: list[int], arr2: list[int], k: int) -> int: ``` Input - `arr1: list[int]` - a sorted list of integers where `0 <= len(arr1) <= 10^5`. - `arr2: list[int]` - another sorted list of integers where `0 <= len(arr2) <= 10^5`. - `k: int` - an integer representing the position (1-based) to find in the combined sorted order of `arr1` and `arr2`, where `1 <= k <= len(arr1) + len(arr2)`. Output - An integer representing the k-th smallest element in the merged version of `arr1` and `arr2`. Example ```plaintext Input: arr1 = [1, 3, 8], arr2 = [2, 7, 10], k = 5 Output: 8 ``` Constraints - Both `arr1` and `arr2` are individually sorted in non-decreasing order. - You may assume both arrays contain no duplicate elements within themselves but may have duplicates between them. - Implement an efficient solution with time complexity O(log(min(len(arr1), len(arr2)))). Note 1. The goal is to use a binary search approach that efficiently narrows down the possible values for the k-th element by comparing partitions of the two arrays. 2. Be sure to handle edge cases, such as when one of the arrays is empty, or when all the elements from one array appear before the k-th element in the merged order.","solution":"def find_kth_element(arr1: list[int], arr2: list[int], k: int) -> int: def kth_smallest(a, b, k): if len(a) > len(b): return kth_smallest(b, a, k) if not a: return b[k - 1] if k == 1: return min(a[0], b[0]) i = min(len(a), k // 2) j = min(len(b), k - i) if a[i - 1] > b[j - 1]: return kth_smallest(a, b[j:], k - j) else: return kth_smallest(a[i:], b, k - i) return kth_smallest(arr1, arr2, k)"},{"question":"# Question Context A secret service agency has intercepted a series of encrypted messages. To understand if the content of these messages are significant, they need to analyze the distribution of vowels and consonants in each message. This analysis could help in deciphering the text by comparing patterns in different messages. Task Write a Python function that calculates the ratio of vowels to the total number of alphabetic characters in a given text and determines if the text is likely to be meaningful or random. This determination will be based on comparing the calculated ratio to a standard threshold ratio typical for meaningful English sentences. Function Signature ```python def is_meaningful_text(text: str, threshold: float) -> bool: pass ``` Input * `text` (str): A string of arbitrary length which can include letters, punctuation, digits, and spaces. * `threshold` (float): A float value representing the threshold ratio. Output * Returns a boolean indicating whether the text is considered meaningful (True) or random (False). Constraints and Requirements * The text should be treated case-insensitively. * Non-alphabet characters should be ignored. * The function should run in linear time concerning the length of the text. Example ```python assert is_meaningful_text(\\"Hello World!\\", 0.4) == True assert is_meaningful_text(\\"Hll Wrld!\\", 0.4) == False ``` Explanation 1. \\"Hello World!\\": - Vowels: E=1, O=2 (3 vowels) - Consonants: H=1, L=3, W=1, R=1, D=1 (7 consonants) - Total: 3 (vowels) + 7 (consonants) = 10 alphabetic characters - Vowel ratio: 3/10 = 0.3 - The threshold ratio is 0.4, and since 0.3 < 0.4, the function returns True, indicating the text is meaningful. 2. \\"Hll Wrld!\\": - Vowels: None - Consonants: H=1, L=3, W=1, R=1, D=1 (6 consonants) - Total: 0 (vowels) + 6 (consonants) = 6 alphabetic characters - Vowel ratio: 0/6 = 0.0 - The threshold ratio is 0.4, and since 0.0 < 0.4, the function returns False, indicating the text is random.","solution":"def is_meaningful_text(text: str, threshold: float) -> bool: Determines if the given text is meaningful based on the ratio of vowels to total alphabetic characters. Args: text (str): The input text to analyze. threshold (float): The threshold ratio for considering the text meaningful. Returns: bool: True if the text is considered meaningful, False otherwise. vowels = set(\\"aeiou\\") total_alpha = 0 vowel_count = 0 for char in text.lower(): if char.isalpha(): total_alpha += 1 if char in vowels: vowel_count += 1 if total_alpha == 0: return False vowel_ratio = vowel_count / total_alpha return vowel_ratio >= threshold"},{"question":"# String Manipulation and Pattern Matching You will implement a function that processes a list of strings and returns a dictionary where the keys are the first characters of the strings, and the values are lists of strings that start with that character, sorted in alphabetical order. Problem Statement Implement the `group_and_sort_strings` function which takes a list of strings and returns a dictionary as described above. **Function Signature:** ```python def group_and_sort_strings(strings: List[str]) -> Dict[str, List[str]]: pass ``` **Functionality:** 1. **Input**: - A list of strings. - Strings are non-empty and contain only lowercase alphabetic characters (a-z). 2. **Output**: - A dictionary where each key is a single character (a-z) and each value is a list of strings starting with that character. The list of strings should be sorted in alphabetical order. 3. **Processing**: - Group the strings based on their first character. - Sort the grouped lists of strings in alphabetical order. 4. **Constraints**: - You may assume the input list contains up to 10^5 strings. - Each string has a maximum length of 100 characters. Example ```python input_strings = [\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\", \\"carrot\\"] result = group_and_sort_strings(input_strings) # Expected Result: # { # \'a\': [\'apple\', \'apricot\'], # \'b\': [\'banana\', \'blueberry\'], # \'c\': [\'carrot\', \'cherry\'] # } ``` Additional Example ```python input_strings = [\\"dog\\", \\"deer\\", \\"deal\\", \\"bat\\", \\"ball\\", \\"break\\"] result = group_and_sort_strings(input_strings) # Expected Result: # { # \'d\': [\'deal\', \'deer\', \'dog\'], # \'b\': [\'ball\', \'bat\', \'break\'] # } ``` Constraints - The function should handle up to 10^5 strings efficiently. - Each string is guaranteed to be non-empty and consists only of lowercase alphabetic characters. Implement the `group_and_sort_strings` function as described above.","solution":"from typing import List, Dict def group_and_sort_strings(strings: List[str]) -> Dict[str, List[str]]: result = {} for string in strings: first_char = string[0] if first_char not in result: result[first_char] = [] result[first_char].append(string) for key in result: result[key].sort() return result"},{"question":"# Coding Assessment Question Scenario You are working on enhancing the functionality of a statistical library by adding robust algorithms for data clustering. To evaluate the students\' grasp of clustering algorithms, you want to test their ability to implement an optimized version of the k-means clustering algorithm that converges efficiently. Task Implement a function `optimized_k_means` that partitions a set of `n` multidimensional points into `k` clusters, ensuring the total intra-cluster variance is minimized. The implementation should optimize the standard k-means algorithm by including intelligent initialization of cluster centroids and incorporating an efficient stopping criterion. Function Signature ```python def optimized_k_means(points: List[List[float]], k: int, max_iterations: int = 300, tolerance: float = 1e-4) -> Tuple[List[int], List[List[float]]]: ``` Parameters - `points`: A list of lists of floats, where each inner list represents the coordinates of a point in the space. - `k`: An integer specifying the number of clusters to form. - `max_iterations`: An integer specifying the maximum number of iterations the algorithm should run (default is 300). - `tolerance`: A float specifying the convergence criterion (default is 1e-4). Returns - A tuple containing two elements: - A list of integers where each integer represents the cluster index assigned to the corresponding point in `points`. - A list of lists of floats, where each inner list represents the coordinates of the cluster centroids. Requirements 1. Initialize cluster centroids using the k-means++ method. 2. Implement an efficient stopping criterion based on changes in intra-cluster variance or centroid movement. 3. Ensure the function handles edge cases, such as fewer points than clusters or identical points. 4. Provide at least two test cases demonstrating the function\'s performance, e.g., clusters of simple synthetic data and real-world data. Example Usage ```python points = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0], [9.0, 3.0] ] labels, centroids = optimized_k_means(points, 3, max_iterations=100, tolerance=1e-4) print(f\\"Cluster assignments: {labels}\\") print(f\\"Cluster centroids: {centroids}\\") small_dataset = [ [2.0, 3.0], [2.1, 2.9], [0.1, 0.2] ] labels, centroids = optimized_k_means(small_dataset, 2) print(f\\"Cluster assignments for small dataset: {labels}\\") print(f\\"Cluster centroids for small dataset: {centroids}\\") ``` Constraints - Optimize the time complexity of the k-means algorithm using efficient data structures. - Ensure scalability to handle large datasets without significant performance degradation. Performance Requirements - Achieve convergence within the given `tolerance` and `max_iterations` constraints on typical datasets. - Handle large and high-dimensional datasets efficiently while minimizing intra-cluster variance.","solution":"import random from typing import List, Tuple import math def euclidean_distance(point1, point2): return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def initialize_centroids(points, k): centroids = [] centroids.append(random.choice(points)) while len(centroids) < k: distances = [] for point in points: distances.append(min(euclidean_distance(point, centroid) for centroid in centroids)) next_centroid = points[distances.index(max(distances))] centroids.append(next_centroid) return centroids def assign_points_to_centroids(points, centroids): labels = [] for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] labels.append(distances.index(min(distances))) return labels def compute_centroids(points, labels, k): new_centroids = [[0] * len(points[0]) for _ in range(k)] counts = [0] * k for label, point in zip(labels, points): for i in range(len(point)): new_centroids[label][i] += point[i] counts[label] += 1 for i in range(k): for j in range(len(new_centroids[0])): if counts[i] == 0: new_centroids[i][j] = random.choice(points)[j] else: new_centroids[i][j] /= counts[i] return new_centroids def optimized_k_means(points: List[List[float]], k: int, max_iterations: int = 300, tolerance: float = 1e-4) -> Tuple[List[int], List[List[float]]]: if len(points) < k: raise ValueError(\\"Number of clusters k cannot be greater than the number of points.\\") centroids = initialize_centroids(points, k) for _ in range(max_iterations): old_centroids = centroids labels = assign_points_to_centroids(points, centroids) centroids = compute_centroids(points, labels, k) diff = sum(euclidean_distance(old, new) for old, new in zip(old_centroids, centroids)) if diff < tolerance: break return labels, centroids"},{"question":"# Scenario: You are developing a banking application and need to implement a feature that calculates the interest accrued over a period of time for a fixed deposit. The interest is compounded annually. # Task: Implement a Python function `compute_interest(principal, rate, time)` that calculates the amount accrued (principal + interest) on a fixed deposit over a given period. # Function Specification: Input: - `principal` (float): The initial amount of money deposited. - `rate` (float): The annual interest rate in percentage. - `time` (int): The time the money is invested for in years. Output: - A float representing the total amount accrued after the given time period, rounded to two decimal places. Calculation: - Use the formula for compound interest: ( A = P left(1 + frac{r}{100}right)^t ) - ( A ) is the amount accrued. - ( P ) is the principal. - ( r ) is the rate of interest. - ( t ) is the time period. Constraints: - The input values for `principal` and `rate` will be positive numbers. - The input value for `time` will be a non-negative integer. - Ensure that the function handles edge cases such as zero time or zero principal gracefully. # Example: ```python # Example usage total_amount = compute_interest(1000, 5, 10) print(total_amount) ``` Expected Output: ```python 1628.89 ```","solution":"def compute_interest(principal, rate, time): Calculates the amount accrued after a certain period of time with compound interest. Args: principal (float): The initial amount of money deposited. rate (float): The annual interest rate in percentage. time (int): The time the money is invested for in years. Returns: float: The total amount accrued after the given time period, rounded to two decimal places. amount = principal * (1 + rate / 100) ** time return round(amount, 2)"},{"question":"Problem Statement You are working as a systems programmer, and you need to handle tracking the delivery status of parcels in a logistics company. Write a Python class that simulates a simplified parcel tracking system. The class should be able to add parcels, update their status, and retrieve a list of parcels with their current statuses. # Function Signature: ```python class Parcel: def __init__(self, parcel_id: int, description: str) -> None: Initialize a new parcel with the given id and description. Args: parcel_id (int): The unique identifier for the parcel. description (str): A brief description of the parcel. class ParcelTrackingSystem: def __init__(self) -> None: Initialize the parcel tracking system with an empty list of parcels. def add_parcel(self, parcel: Parcel) -> None: Add a new parcel to the tracking system. Args: parcel (Parcel): The parcel object to be added. def update_status(self, parcel_id: int, status: str) -> None: Update the status of a parcel given its id. Args: parcel_id (int): The unique identifier of the parcel to update. status (str): The new status of the parcel. def get_status(self, parcel_id: int) -> str: Get the current status of a parcel given its id. Args: parcel_id (int): The unique identifier of the parcel to retrieve status. Returns: str: The current status of the parcel. def list_parcels(self) -> list: List all the parcels in the system with their ids, descriptions, and statuses. Returns: list: A list of dictionaries where each dictionary represents a parcel with \'id\', \'description\', and \'status\' keys. ``` # Input - A parcel to be added has a unique identifier (`parcel_id: int`) and a description (`description: str`). - The status to be updated or retrieved is a string (`status: str`). # Output - The status retrieval function returns a string (`status: str`). - The parcel listing function returns a list of dictionaries. # Constraints - The `parcel_id` is guaranteed to be a positive integer. - The `description` and `status` are non-empty strings. - Handle up to `1000` parcels in the tracking system. # Example ```python # Creating an instance of the Parcel Tracking System pts = ParcelTrackingSystem() # Creating and adding new parcels p1 = Parcel(1, \\"Electronics\\") p2 = Parcel(2, \\"Clothing\\") pts.add_parcel(p1) pts.add_parcel(p2) # Updating parcel statuses pts.update_status(1, \\"In Transit\\") pts.update_status(2, \\"Delivered\\") # Retrieving the status of a specific parcel print(pts.get_status(1)) # Output: \\"In Transit\\" # Listing all parcels print(pts.list_parcels()) # Output: [{\'id\': 1, \'description\': \'Electronics\', \'status\': \'In Transit\'}, # {\'id\': 2, \'description\': \'Clothing\', \'status\': \'Delivered\'}] ``` # Additional Notes - Your implementation should ensure that each parcel has a unique identifier. - The system should efficiently update and retrieve parcel information.","solution":"class Parcel: def __init__(self, parcel_id: int, description: str) -> None: Initialize a new parcel with the given id and description. Args: parcel_id (int): The unique identifier for the parcel. description (str): A brief description of the parcel. self.parcel_id = parcel_id self.description = description self.status = \'Pending\' # Default status when the parcel is created class ParcelTrackingSystem: def __init__(self) -> None: Initialize the parcel tracking system with an empty list of parcels. self.parcels = {} def add_parcel(self, parcel: Parcel) -> None: Add a new parcel to the tracking system. Args: parcel (Parcel): The parcel object to be added. self.parcels[parcel.parcel_id] = parcel def update_status(self, parcel_id: int, status: str) -> None: Update the status of a parcel given its id. Args: parcel_id (int): The unique identifier of the parcel to update. status (str): The new status of the parcel. if parcel_id in self.parcels: self.parcels[parcel_id].status = status def get_status(self, parcel_id: int) -> str: Get the current status of a parcel given its id. Args: parcel_id (int): The unique identifier of the parcel to retrieve status. Returns: str: The current status of the parcel. if parcel_id in self.parcels: return self.parcels[parcel_id].status else: return \\"Parcel not found\\" def list_parcels(self) -> list: List all the parcels in the system with their ids, descriptions, and statuses. Returns: list: A list of dictionaries where each dictionary represents a parcel with \'id\', \'description\', and \'status\' keys. return [ { \'id\': parcel.parcel_id, \'description\': parcel.description, \'status\': parcel.status } for parcel in self.parcels.values() ]"},{"question":"# Image Processing Filter Application You are tasked with developing an image processing function that applies various filters to an input image. The function should support multiple filter types and handle invalid inputs gracefully. Objective: Modify the `apply_filter` function to: * Accept an image and a filter type as input arguments. * Apply the specified filter to the image. * Return the processed image. * Handle cases where the image file is not found or cannot be read. * Manage unsupported filter types by raising appropriate errors. Function Signature: ```python def apply_filter(image_path: str, filter_type: str) -> object: Applies the specified filter to the image located at the given path. Args: - image_path: str: The file path to the input image. - filter_type: str: The type of filter to apply (e.g., \'grayscale\', \'sepia\', \'invert\'). Returns: - object: The processed image object. Raises: - FileNotFoundError: If the image file cannot be found. - ValueError: If the filter_type is not supported. ``` Input: * `image_path` (str): A string representing the file path to the input image. * `filter_type` (str): A string representing the type of filter to apply (options include \'grayscale\', \'sepia\', \'invert\'). Output: * The processed image object with the specified filter applied. Constraints: * The image file must exist and be readable. * The filter_type must be one of the supported options (\'grayscale\', \'sepia\', \'invert\'). * The function should handle errors gracefully, providing meaningful messages for issues like file not found or unsupported filters. Example Usage: ```python try: processed_image = apply_filter(\\"sample.jpg\\", \\"grayscale\\") processed_image.show() except Exception as e: print(f\\"Failed to apply filter: {e}\\") ``` # Additional Notes: - Use a library like PIL (Pillow) for image processing. - Each filter should transform the image in a distinct and visually identifiable way. - Ensure that the function handles file reading and filter application errors robustly.","solution":"from PIL import Image, ImageOps, ImageEnhance import os def apply_filter(image_path: str, filter_type: str): Applies the specified filter to the image located at the given path. Args: image_path: str: The file path to the input image. filter_type: str: The type of filter to apply (e.g., \'grayscale\', \'sepia\', \'invert\'). Returns: object: The processed image object. Raises: FileNotFoundError: If the image file cannot be found. ValueError: If the filter_type is not supported. if not os.path.exists(image_path): raise FileNotFoundError(f\\"Image file not found at path: {image_path}\\") supported_filters = [\'grayscale\', \'sepia\', \'invert\'] if filter_type not in supported_filters: raise ValueError(f\\"Unsupported filter type: {filter_type}. Supported filters: {supported_filters}\\") image = Image.open(image_path) if filter_type == \'grayscale\': image = ImageOps.grayscale(image) elif filter_type == \'sepia\': sepia_image = ImageEnhance.Color(image).enhance(0.3) sepia_image = ImageOps.colorize(ImageOps.grayscale(sepia_image), \'#704214\', \'#C0C080\') image = sepia_image elif filter_type == \'invert\': image = ImageOps.invert(image.convert(\\"RGB\\")) return image"},{"question":"# Dynamic Programming: Minimum Edit Distance Context: In computational biology and text processing, the minimum edit distance (or Levenshtein distance) is a measure of the similarity between two strings. It is calculated as the minimum number of single-character edits (insertions, deletions, or substitutions) needed to transform one string into the other. Problem Statement: Given two strings `s1` and `s2`, your task is to implement a dynamic programming algorithm to compute the minimum edit distance between the two strings. Input: - The first line contains the string `s1` (length `0 <= |s1| <= 1000`). - The second line contains the string `s2` (length `0 <= |s2| <= 1000`). Output: - Output should be a single integer indicating the minimum edit distance between the two strings. Constraints: - The input strings may contain any printable characters. - Handle cases where one or both strings are empty. Example: **Input:** ``` kitten sitting ``` **Output:** ``` 3 ``` **Explanation:** - Convert \\"kitten\\" to \\"sitting\\" with these operations: kitten → sitten (substitute \'k\' with \'s\'), sitten → sittin (insert \'i\' at the end), sittin → sitting (insert \'g\' at the end). # Implementation Requirements: - You need to implement the main method `min_edit_distance(s1: str, s2: str) -> int` that returns the minimum edit distance. - Optimize the solution to handle the maximum input size efficiently. - Consider edge cases such as one string being empty, both strings being identical, and varying lengths of the input strings. Good luck!","solution":"def min_edit_distance(s1, s2): Computes the minimum edit distance between two strings s1 and s2 using dynamic programming. m, n = len(s1), len(s2) # Create a DP table to memoize results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): dp[i][0] = i # If second string is empty, we need i deletions for j in range(n + 1): dp[0][j] = j # If first string is empty, we need j insertions # Compute the DP table values for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: # If characters match dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[m][n]"},{"question":"# Anomaly Detection using Z-score Context Anomaly detection is essential in various applications, ranging from fraud detection in finance to monitoring industrial equipment. One simple yet effective method to detect anomalies is using the Z-score, which measures how many standard deviations a given data point is from the mean. Data points with a Z-score greater than a specified threshold can be considered anomalies. Task Implement the `detect_anomalies` function that identifies anomalies in a given list of numbers using the Z-score method. The function should return the indices of the identified anomalies. Function Signature ```python def detect_anomalies(data: list, threshold: float) -> list: pass ``` Input * `data` (list of float): A list of numerical values. * `threshold` (float): The Z-score threshold beyond which data points are considered anomalies. Output * Returns a list of integers, where each integer represents the index of an anomaly in the input data. Constraints * The input list `data` will have at least three elements. * The `threshold` will be a positive number. Requirements * Compute the mean and standard deviation of the input data. * Find the Z-score for each data point. * Identify data points where the absolute value of the Z-score exceeds the threshold. * Return the indices of these anomalous data points. Example ```python data = [10.0, 12.0, 11.5, 14.0, 13.5, 120.0, 10.5, 11.0, 12.5, 13.0, 14.5] threshold = 2.0 # Applying anomaly detection anomalies = detect_anomalies(data, threshold) print(anomalies) # Output might be [5] ``` *Note: Ensure to use standard libraries such as `statistics` for mean and standard deviation calculation.*","solution":"import statistics def detect_anomalies(data: list, threshold: float) -> list: Identifies anomalies in a given list of numbers using the Z-score method. Args: data (list of float): A list of numerical values. threshold (float): The Z-score threshold beyond which data points are considered anomalies. Returns: list: A list of indices of the identified anomalies. mean = statistics.mean(data) stdev = statistics.stdev(data) anomalies = [] for i, value in enumerate(data): z_score = (value - mean) / stdev if abs(z_score) > threshold: anomalies.append(i) return anomalies"},{"question":"# Coding Challenge Question: Secure File Duplicate Remover **Context**: File duplicate removal is a common operation to save storage space. The task involves implementing a function that finds duplicate files in a directory based on their contents and removes them securely. File integrity and performance are crucial in handling large datasets. Problem Statement Implement a function `remove_duplicates(directory: str) -> int` that takes the path to a directory and removes all duplicate files, retaining only the first encountered copy. The function should: 1. Validate that the input is a string representing a valid directory path. 2. Use file contents to determine duplicates, not just filenames. 3. Return the count of files that were deleted. Input * A string representing the path to a directory. Example: `/path/to/directory`. Output * An integer value representing the number of duplicate files removed. Constraints * The function must handle directories containing any number of files. * Ensure file integrity and proper handling of large files. * The directory can contain nested subdirectories which should not be processed. Expectations 1. Efficient detection of duplicate files based on file contents. 2. Proper validation of the input directory path. 3. Accurate count of removed duplicate files. 4. Safe and secure file deletion practices to avoid data loss. Example ```python >>> remove_duplicates(\\"/path/to/directory\\") 4 >>> remove_duplicates(\\"/invalid/path\\") ValueError: Invalid directory path >>> remove_duplicates(\\"/empty/directory\\") 0 ``` Implementation Challenge * Consider using cryptographic hashing (e.g., MD5, SHA-256) to compare file contents efficiently. * Handle large files by reading them in chunks to avoid memory overload. * Ensure that the deletion of files is secure and does not corrupt remaining data. Feel free to define helper functions if needed.","solution":"import os import hashlib def compute_file_hash(file_path): Compute the SHA-256 hash of the file content. hash_func = hashlib.sha256() with open(file_path, \'rb\') as f: while chunk := f.read(8192): hash_func.update(chunk) return hash_func.hexdigest() def remove_duplicates(directory): Removes duplicate files in the directory based on their contents. Args: directory (str): The path to the directory. Returns: int: The count of files that were deleted. # Validate input directory path if not isinstance(directory, str) or not os.path.isdir(directory): raise ValueError(\\"Invalid directory path\\") seen_files = {} files_deleted = 0 # Walk through the directory but not into subdirectories for root, _, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) file_hash = compute_file_hash(file_path) if file_hash in seen_files: os.remove(file_path) files_deleted += 1 else: seen_files[file_hash] = file_path return files_deleted"},{"question":"# Find the First Repeating Character Write a function `first_repeating_character` that takes a string as input and returns the first repeating character in the string. If no character repeats, return `None`. Function Signature ```python def first_repeating_character(s: str) -> Union[str, None]: pass ``` # Input - A single string `s` (1 ≤ |s| ≤ 10^5), consisting of lowercase English letters. # Output - A single character which is the first character that repeats in the string. - If no character repeats, return `None`. # Constraints - The function should execute efficiently, preferably in O(n) time complexity. # Example ```python # Example input s = \\"swiss\\" # Example output print(first_repeating_character(s)) # Output: \'s\' # Example input s = \\"abcdef\\" # Example output print(first_repeating_character(s)) # Output: None ``` # Additional Requirements - Handle edge cases such as an empty string or a string with only unique characters. - Ensure the function is optimally using memory and processing time. - The solution should be clear and concise, avoiding unnecessary complexity.","solution":"def first_repeating_character(s: str) -> str: Returns the first repeating character in the string s. If no character repeats, return None. seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"**Scenario**: You are developing a financial application that requires frequent calculations involving dates, currency conversion, and interest rates. To facilitate these operations, you decide to create a set of utility functions. # Task 1. **Date Calculation Function**: - Implement a function `add_days_to_date` that takes a starting date and a number of days, and returns the resulting date. - The starting date will be provided as a string in the format \'YYYY-MM-DD\', and the function should return the resulting date in the same format. 2. **Currency Conversion Function**: - Implement a function `convert_currency` that takes an amount, a source currency, and a target currency. - Use a predefined dictionary `currency_rates` to obtain the conversion rate. If the specified currencies are not found in the dictionary, raise a `ValueError` with an appropriate message. 3. **Interest Calculation Function**: - Implement a function `calculate_interest` that accepts four parameters: `principal` (float), `annual_rate` (float), `years` (int), and `compounds_per_year` (int). - This function should calculate the compound interest and return the total amount after the specified years. # Input and Output Format - **Input**: * For `add_days_to_date`: params `start_date` (str), `days` (int) * For `convert_currency`: params `amount` (float), `source_currency` (str), `target_currency` (str) * For `calculate_interest`: params `principal` (float), `annual_rate` (float), `years` (int), `compounds_per_year` (int) - **Output**: * For `add_days_to_date`: return a string representing the resulting date. * For `convert_currency`: return the converted amount (float). * For `calculate_interest`: return the total amount after the specified years (float). # Constraints - The starting date will always be a valid date string in \'YYYY-MM-DD\' format. - The number of days will always be a non-negative integer. - The amount for currency conversion will always be a positive float value. - The principal for interest calculation will always be a positive float value. - The annual rate will be provided as a percentage (e.g., 5 for 5%). - The number of years and compounds per year will always be non-negative integer values. # Example ```python # Date Calculation Function result_date = add_days_to_date(\'2023-10-01\', 10) # returns \'2023-10-11\' # Currency Conversion Function currency_rates = { \'USD\': 1, \'EUR\': 0.85, \'JPY\': 110.53 } try: converted_amount = convert_currency(100, \'USD\', \'EUR\') except ValueError as e: print(e) # Outputs: \\"Currency \'XYZ\' not found in currency_rates.\\" # Interest Calculation Function total_amount = calculate_interest(1000, 5, 10, 4) # returns 1645.31 (approx.) ```","solution":"from datetime import datetime, timedelta def add_days_to_date(start_date, days): Adds a given number of days to a starting date. :param start_date: str, the starting date in \'YYYY-MM-DD\' format :param days: int, the number of days to add :return: str, the resulting date in \'YYYY-MM-DD\' format date_obj = datetime.strptime(start_date, \'%Y-%m-%d\') result_date = date_obj + timedelta(days=days) return result_date.strftime(\'%Y-%m-%d\') def convert_currency(amount, source_currency, target_currency, currency_rates): Converts an amount from source currency to target currency. :param amount: float, the amount to convert :param source_currency: str, the source currency code :param target_currency: str, the target currency code :param currency_rates: dict, the dictionary containing currency conversion rates :return: float, the converted amount :raises: ValueError if the currency code is not found in currency_rates if source_currency not in currency_rates or target_currency not in currency_rates: raise ValueError(f\\"Currency \'{source_currency}\' or \'{target_currency}\' not found in currency_rates.\\") source_rate = currency_rates[source_currency] target_rate = currency_rates[target_currency] return (amount / source_rate) * target_rate def calculate_interest(principal, annual_rate, years, compounds_per_year): Calculates the compound interest and returns the total amount after the specified years. :param principal: float, the starting principal amount :param annual_rate: float, the annual interest rate as a percentage (e.g., 5 for 5%) :param years: int, the number of years :param compounds_per_year: int, the number of times interest is compounded per year :return: float, the total amount after the specified years if compounds_per_year == 0: return principal * (1 + annual_rate / 100 * years) # Simple interest case rate_per_period = annual_rate / 100 / compounds_per_year total_periods = years * compounds_per_year total_amount = principal * (1 + rate_per_period) ** total_periods return round(total_amount, 2)"},{"question":"# Coding Assessment Question Scenario A company\'s product inventory is represented as a list of tuples, where each tuple contains the product\'s name and its quantity in stock. The company wants to implement a system that allows efficient checking and updating of product quantities. Task Implement a class `Inventory` with methods to add products, get the quantity of a product, and update the quantity of a product. Class Signature ```python class Inventory: def __init__(self): Initializes the inventory with an empty list. def add_product(self, product_name: str, quantity: int) -> None: Adds a new product to the inventory with the given quantity. If the product already exists, it updates the quantity. :param product_name: A string representing the product name. :param quantity: An integer representing the quantity of the product. def get_quantity(self, product_name: str) -> int: Retrieves the quantity of the given product name. :param product_name: A string representing the product name. :return: An integer representing the quantity of the product, or -1 if the product does not exist. def update_quantity(self, product_name: str, quantity: int) -> None: Updates the quantity of an existing product. :param product_name: A string representing the product name. :param quantity: An integer representing the new quantity of the product. ``` Input - A list of product-name and quantity tuples, where: * `1 <= len(products) <= 10^4` * `1 <= len(product_name) <= 100` * `-10^9 <= quantity <= 10^9` Output - Methods to add a product, get the quantity of a product, and update the quantity of a product. Constraints - The product names are case-sensitive. - You must ensure efficient handling and updates of the product inventory. Examples - Example 1: ```python inventory = Inventory() inventory.add_product(\\"apple\\", 50) inventory.add_product(\\"banana\\", 30) assert inventory.get_quantity(\\"apple\\") == 50 assert inventory.get_quantity(\\"banana\\") == 30 inventory.update_quantity(\\"banana\\", 45) assert inventory.get_quantity(\\"banana\\") == 45 ``` - Example 2: ```python inventory = Inventory() inventory.add_product(\\"orange\\", 20) assert inventory.get_quantity(\\"mango\\") == -1 inventory.update_quantity(\\"orange\\", 25) assert inventory.get_quantity(\\"orange\\") == 25 ``` - Example 3: ```python inventory = Inventory() inventory.add_product(\\"grapes\\", 0) assert inventory.get_quantity(\\"grapes\\") == 0 inventory.update_quantity(\\"grapes\\", 10) assert inventory.get_quantity(\\"grapes\\") == 10 ``` Notes - The `add_product` method should handle cases where a product is added multiple times by updating the quantity. - Ensure the `get_quantity` method returns `-1` for non-existent products. - Use appropriate data structures to ensure efficient lookup, addition, and updates in the inventory.","solution":"class Inventory: def __init__(self): Initializes the inventory with an empty dictionary. self.inventory = {} def add_product(self, product_name: str, quantity: int) -> None: Adds a new product to the inventory with the given quantity. If the product already exists, it updates the quantity. :param product_name: A string representing the product name. :param quantity: An integer representing the quantity of the product. if product_name in self.inventory: self.inventory[product_name] += quantity else: self.inventory[product_name] = quantity def get_quantity(self, product_name: str) -> int: Retrieves the quantity of the given product name. :param product_name: A string representing the product name. :return: An integer representing the quantity of the product, or -1 if the product does not exist. return self.inventory.get(product_name, -1) def update_quantity(self, product_name: str, quantity: int) -> None: Updates the quantity of an existing product. :param product_name: A string representing the product name. :param quantity: An integer representing the new quantity of the product. if product_name in self.inventory: self.inventory[product_name] = quantity else: self.inventory[product_name] = quantity"},{"question":"# Question: Implement a Decimal to Roman Numeral Converter **Scenario**: You are developing a feature for a historic dates display system that requires converting decimal integers to Roman numerals. To fulfill this requirement, you need to write a function capable of accurately transforming any given non-negative integer within a certain range (from 1 to 3999) into its corresponding Roman numeral representation. **Function to Implement**: Implement the function `int_to_roman(n: Any) -> str` that takes an integer, validates the input, and returns the Roman numeral representation of that number. Follow these specific requirements and constraints: **Requirements**: 1. Validate the input to ensure it’s an integer within the range [1, 3999]. 2. Handle inputs that: * Are outside the acceptable range. * Are of incorrect types (e.g., floats, strings). 3. Return the corresponding Roman numeral for valid integers. 4. Raise appropriate errors for invalid inputs. **Input**: - A single value, `n`, which should be validated to be an integer within the range [1, 3999]. **Output**: - A string representing the Roman numeral equivalent of the input integer. **Constraints**: - If `n` is not an integer within the range [1, 3999], raise a `ValueError`. - Raise a `TypeError` if `n` is not an integer. **Example Cases**: ```python >>> int_to_roman(58) \'LVIII\' >>> int_to_roman(1994) \'MCMXCIV\' >>> int_to_roman(3999) \'MMMCMXCIX\' >>> int_to_roman(0) Traceback (most recent call last): ... ValueError: Input must be an integer between 1 and 3999 >>> int_to_roman(4000) Traceback (most recent call last): ... ValueError: Input must be an integer between 1 and 3999 >>> int_to_roman(-5) Traceback (most recent call last): ... ValueError: Input must be an integer between 1 and 3999 >>> int_to_roman(3.5) Traceback (most recent call last): ... TypeError: Input must be an integer >>> int_to_roman(\\"123\\") Traceback (most recent call last): ... TypeError: Input must be an integer ``` **Function Template**: ```python def int_to_roman(n: Any) -> str: Convert and return the Roman numeral representation of an integer within the range [1, 3999]. :param n: Any type of input to validate :return: Roman numeral representation of the integer :raises ValueError: If input is not an integer within the specified range :raises TypeError: If input is not an integer # Your implementation goes here if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` The given problem requires a thorough implementation that validates input types and ranges, transforming valid integers within bounds into their equivalent Roman numeral strings. This ensures data accuracy and robustness, crucial for functionalities dealing with historical data processing.","solution":"def int_to_roman(n): Convert and return the Roman numeral representation of an integer within the range [1, 3999]. :param n: Any type of input to validate :return: Roman numeral representation of the integer :raises ValueError: If input is not an integer within the specified range :raises TypeError: If input is not an integer if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if not (1 <= n <= 3999): raise ValueError(\\"Input must be an integer between 1 and 3999\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syms[i] n -= val[i] i += 1 return roman_num"},{"question":"# Coding Assessment Question **Context**: You have been assigned a task to implement a custom algorithm to determine the longest sequence of consecutive elements in an array that maintains a strictly increasing order. The goal is to identify the length of this sequence. **Objective**: Write a function `longest_increasing_sequence(arr: list[int]) -> int` that returns the length of the longest strictly increasing subsequence found in the given list of integers. **Function Signature**: ```python def longest_increasing_sequence(arr: list[int]) -> int: pass ``` **Input**: - `arr`: A list of integers. **Output**: - An integer representing the length of the longest strictly increasing subsequence. **Constraints**: - The input list may contain up to 10^3 elements. - Elements in the list can be negative or positive integers. **Example**: ```python >>> longest_increasing_sequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_sequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_sequence([7, 7, 7, 7, 7, 7, 7]) 1 ``` **Explanation**: - In the first example, the longest strictly increasing subsequence is `[2, 3, 7, 101]`. - In the second example, the longest strictly increasing subsequence is `[0, 1, 2, 3]`. - In the third example, the longest strictly increasing subsequence is `[7]` (all elements are the same, so the longest increasing subsequence has a length of 1). **Performance Requirements**: - Ensure the implementation handles lists with up to 10^3 elements efficiently. - Aim for a solution with a time complexity of O(n log n) if possible. **Additional Notes**: - Consider edge cases, such as an empty list, lists with identical elements, and very short lists.","solution":"def longest_increasing_sequence(arr: list[int]) -> int: import bisect if not arr: return 0 subsequence = [] for x in arr: pos = bisect.bisect_left(subsequence, x) if pos == len(subsequence): subsequence.append(x) else: subsequence[pos] = x return len(subsequence)"},{"question":"# Problem Statement As a junior software developer at a robotics company, you\'ve been assigned the task of creating an algorithm to help your team manage a warehouse robot\'s inventory. The robot follows instructions to pick up and deliver items scattered around the warehouse. Each item is represented by an inventory ID, and the robot keeps a log of inventory IDs it picks up and delivers. Your task is to implement functions that ensure the robot operates efficiently and accurately manages the inventory. # Requirements 1. Implement a class `WarehouseRobot` to manage the robot\'s inventory. The class should have methods to record an item pickup, record an item delivery, and check the current inventory. 2. The class should handle exceptions when trying to deliver items that are not in the inventory. # Class Definition ```python class WarehouseRobot: def __init__(self): # Initialize the inventory as an empty list pass def pick_item(self, item_id: int) -> None: \'\'\' Record the pickup of an item. Parameters: - item_id (int): ID of the item picked up. \'\'\' # Your code here instead of \'pass\' pass def deliver_item(self, item_id: int) -> None: \'\'\' Record the delivery of an item. Parameters: - item_id (int): ID of the item delivered. Raises: - ValueError: If the item ID is not found in the inventory. \'\'\' # Your code here instead of \'pass\' pass def current_inventory(self) -> list: \'\'\' Get the list of items currently in the inventory. Returns: - List[int]: List of item IDs currently in the inventory. \'\'\' # Your code here instead of \'pass\' pass ``` # Input Parameters * `item_id` (int): The ID of an item, positive integer. # Output * The `pick_item` method does not return a value. * The `deliver_item` method does not return a value but may raise a `ValueError` if the item is not currently in the inventory. * The `current_inventory` method returns a list of item IDs currently in the inventory. # Error Handling * The `deliver_item` method should raise a `ValueError` if trying to deliver an item that is not currently in the inventory. # Example ```python # Example 1: robot = WarehouseRobot() robot.pick_item(101) robot.pick_item(102) assert robot.current_inventory() == [101, 102] robot.deliver_item(101) assert robot.current_inventory() == [102] # Example 2: robot.pick_item(103) robot.pick_item(104) assert robot.current_inventory() == [102, 103, 104] try: robot.deliver_item(105) except ValueError as e: assert str(e) == \\"Item ID 105 not found in inventory\\" ``` # Explanation 1. The `WarehouseRobot` class maintains an inventory of item IDs the robot currently has. 2. The `pick_item` method adds an item ID to the inventory. 3. The `deliver_item` method removes an item ID from the inventory, raising an error if the item is not found. 4. The `current_inventory` method returns the list of items currently held by the robot. Implement the `WarehouseRobot` class, ensuring accuracy and proper exception handling for efficient warehouse operations.","solution":"class WarehouseRobot: def __init__(self): # Initialize the inventory as an empty list self.inventory = [] def pick_item(self, item_id: int) -> None: \'\'\' Record the pickup of an item. Parameters: - item_id (int): ID of the item picked up. \'\'\' self.inventory.append(item_id) def deliver_item(self, item_id: int) -> None: \'\'\' Record the delivery of an item. Parameters: - item_id (int): ID of the item delivered. Raises: - ValueError: If the item ID is not found in the inventory. \'\'\' if item_id in self.inventory: self.inventory.remove(item_id) else: raise ValueError(f\\"Item ID {item_id} not found in inventory\\") def current_inventory(self) -> list: \'\'\' Get the list of items currently in the inventory. Returns: - List[int]: List of item IDs currently in the inventory. \'\'\' return self.inventory"},{"question":"# Question: Matrix Manipulation and Path Calculation **Context:** You are enhancing a toolkit for matrix operations and pathfinding algorithms. Your previous tasks included basic matrix manipulations and search algorithms. Now, you will be implementing more advanced features involving matrices and dynamic programming for pathfinding in a grid. **Objective:** Implement the following functions with a focus on handling typical edge cases, optimizing performance, and ensuring accurate results: 1. **Transpose a Matrix**: Return the transpose of a given matrix. 2. **Matrix Multiplication**: Multiply two matrices and return the result. 3. **Count Unique Paths in a Grid**: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, using dynamic programming. **Function Signatures:** ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass def multiply_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: pass def unique_paths(m: int, n: int) -> int: pass ``` **Expected Input and Output**: ```python assert transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert multiply_matrices([[1, 2], [3, 4]], [[5, 6], [7, 8]]) == [[19, 22], [43, 50]] assert unique_paths(3, 2) == 3 assert unique_paths(7, 3) == 28 ``` **Constraints**: - The inputs for transpose_matrix and multiply_matrices will be valid matrices with integers. - The inputs for unique_paths will be positive integers (m and n). - Performance should handle matrix dimensions and grid sizes up to 1000 x 1000 for path calculations. **Detailed Requirements**: 1. **Transpose a Matrix**: - **Input:** A matrix represented as a list of lists of integers. - **Output:** A matrix which is the transpose of the input matrix. - Swap rows and columns to achieve the transpose. 2. **Matrix Multiplication**: - **Input:** Two matrices represented as lists of lists of integers. - **Output:** The product matrix as a result of multiplying matrix1 by matrix2. - Ensure that the number of columns in matrix1 equals the number of rows in matrix2. 3. **Count Unique Paths in a Grid**: - **Input:** Two integers, m (number of rows) and n (number of columns). - **Output:** An integer representing the number of unique paths from the top-left to bottom-right of an m x n grid. - Utilize dynamic programming to count paths where you can only move right or down. **Edge Cases to Consider**: - Minimal Input: Handle smallest grid sizes (e.g., unique_paths(1, 1) == 1). - Large Grids: Ensure performance efficiency for larger grid sizes. - Validate matrix dimensions for multiplication to toss errors on incompatible sizes. - Transpose of non-square matrices should be tested for consistency.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of a given matrix. if not matrix or not matrix[0]: return [] return [list(row) for row in zip(*matrix)] def multiply_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Multiply two matrices and return the result. Assumes that the number of columns in matrix1 equals the number of rows in matrix2. if not matrix1 or not matrix1[0] or not matrix2 or not matrix2[0]: return [] rows_matrix1 = len(matrix1) cols_matrix1 = len(matrix1[0]) cols_matrix2 = len(matrix2[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(cols_matrix2)] for _ in range(rows_matrix1)] for i in range(rows_matrix1): for j in range(cols_matrix2): for k in range(cols_matrix1): result[i][j] += matrix1[i][k] * matrix2[k][j] return result def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, using dynamic programming. # Initialize the DP table with 1s dp = [[1] * n for _ in range(m)] # Fill the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"# Context You are developing a feature for an application that processes sequences of numerical data. As part of this feature, you need to detect and remove any sequences of consecutive duplicate numbers, effectively collapsing them into a single number. To achieve this, you will implement a utility class. # Problem Statement Write a class `SequenceCleaner` with the following static method: 1. `remove_consecutive_duplicates(sequence: List[int]) -> List[int]` Method Description: * **remove_consecutive_duplicates**: Given a sequence of integers, remove all consecutive duplicate values and return the cleaned sequence. Consecutive duplicates are only removed if they appear next to each other. Input and Output Formats: * **Input**: - `sequence`: A list of integers (0 <= sequence length <= 10^5), with each integer within the range (-10^9, 10^9). * **Output**: A list of integers, with consecutive duplicates removed. Example Usage: ```python cleaner = SequenceCleaner() print(cleaner.remove_consecutive_duplicates([1, 2, 2, 3, 3, 3, 4])) # Output: [1, 2, 3, 4] print(cleaner.remove_consecutive_duplicates([1, 1, 1, 1, 1])) # Output: [1] print(cleaner.remove_consecutive_duplicates([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(cleaner.remove_consecutive_duplicates([])) # Output: [] print(cleaner.remove_consecutive_duplicates([10, 10, -2, -2, -2, 5, 5])) # Output: [10, -2, 5] ``` # Performance Requirement The method should run in linear time, O(n), where n is the length of the input sequence. Good luck and ensure your solution handles a variety of inputs appropriately!","solution":"from typing import List class SequenceCleaner: @staticmethod def remove_consecutive_duplicates(sequence: List[int]) -> List[int]: if not sequence: return [] result = [sequence[0]] for num in sequence[1:]: if num != result[-1]: result.append(num) return result"},{"question":"# Question: Implement an Event Reminder System In this exercise, you are to implement a Python class that manages an event reminder system. The system should allow adding, deleting, and viewing events for specific dates, as well as checking for reminders on the current date. Class Signature ```python class EventReminder: def __init__(self): pass def add_event(self, date: str, event_description: str) -> bool: pass def delete_event(self, date: str, event_description: str) -> bool: pass def view_events(self, date: str) -> list: pass def check_today_reminders(self) -> list: pass ``` Methods Details 1. `add_event` method takes a date as a string in the format `\'YYYY-MM-DD\'` and an `event_description`: - If the addition is successful, it returns `True`. - If the event already exists for the date, it returns `False`. 2. `delete_event` method takes a date as a string in the format `\'YYYY-MM-DD\'` and an `event_description`: - If the deletion is successful, it returns `True`. - If the event does not exist, it returns `False`. 3. `view_events` method takes a date as a string in the format `\'YYYY-MM-DD\'`: - Returns a list of all events descriptions for the given date. - If no events exist for the date, it returns an empty list. 4. `check_today_reminders` method checks for events scheduled for the current date: - Returns a list of event descriptions for today. Constraints * Use the Python `datetime` module to handle dates. * Ensure all methods handle invalid date formats and provide meaningful feedback. * Use a dictionary to store the events, where the key is the date and the value is a list of events for that date. # Example Usage ```python er = EventReminder() print(er.add_event(\\"2023-10-18\\", \\"Doctor\'s Appointment\\")) # Expected output: True print(er.add_event(\\"2023-10-18\\", \\"Team Meeting\\")) # Expected output: True print(er.view_events(\\"2023-10-18\\")) # Expected output: [\\"Doctor\'s Appointment\\", \\"Team Meeting\\"] print(er.delete_event(\\"2023-10-18\\", \\"Team Meeting\\")) # Expected output: True print(er.view_events(\\"2023-10-18\\")) # Expected output: [\\"Doctor\'s Appointment\\"] print(er.check_today_reminders()) # Expected output: List of events for today ```","solution":"from datetime import datetime class EventReminder: def __init__(self): self.events = {} def _validate_date(self, date): try: return datetime.strptime(date, \'%Y-%m-%d\') except ValueError: return False def add_event(self, date: str, event_description: str) -> bool: if not self._validate_date(date): return False if date in self.events: if event_description in self.events[date]: return False self.events[date].append(event_description) else: self.events[date] = [event_description] return True def delete_event(self, date: str, event_description: str) -> bool: if not self._validate_date(date): return False if date in self.events and event_description in self.events[date]: self.events[date].remove(event_description) if not self.events[date]: # Remove the date key if no events are left del self.events[date] return True return False def view_events(self, date: str) -> list: if not self._validate_date(date): return [] return self.events.get(date, []) def check_today_reminders(self) -> list: today = datetime.today().strftime(\'%Y-%m-%d\') return self.events.get(today, [])"},{"question":"# Problem Statement Write a function that takes a list of words and an integer k, and returns the k most frequent words in the list. If there is a tie for the k-th position, select words that are alphabetically smaller. **Input Format**: - A list of strings `words` where each string consists of lowercase English letters. - An integer `k`. **Output Format**: - A list of k strings, representing the most frequent words in descending order of frequency. In case two words have the same frequency, the word with the alphabetically smaller order comes first. **Constraints**: 1. (1 leq len(words) leq 10^4) 2. (1 leq k leq min(100, len(words))) 3. Each word in words is comprised of lowercase English letters only. Write your function: ```python def top_k_frequent_words(words: list[str], k: int) -> list[str]: pass ``` **Example**: ```python >>> top_k_frequent_words([\\"i\\", \\"love\\", \\"python\\", \\"i\\", \\"love\\", \\"coding\\"], 2) [\\"i\\", \\"love\\"] >>> top_k_frequent_words([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] ```","solution":"from collections import Counter import heapq def top_k_frequent_words(words: list[str], k: int) -> list[str]: Returns the k most frequent words from the given list of words. In case of a tie, returns the alphabetically smaller word first. word_count = Counter(words) # Using a heap to keep track of the top k elements heap = [] for word, freq in word_count.items(): heapq.heappush(heap, (-freq, word)) result = [] for _ in range(k): result.append(heapq.heappop(heap)[1]) return result"},{"question":"# Coding Assessment Question: Domino Tiling Problem Context You are given a rectangular grid of size 2 x n (2 rows and n columns). Your task is to determine the number of ways to tile this grid using 1 x 2 and 2 x 1 dominoes. Objective Implement a function `number_of_ways(n: int) -> int` that computes the number of distinct ways to cover the entire grid with the given domino tiles. Input/Output Formats - **Input**: * An integer `n` (1 ≤ n ≤ 10^4) representing the number of columns in the grid. - **Output**: * An integer representing the number of ways to fully cover the 2 x n grid. Constraints - The solution should be efficient to handle the upper limits of `n`. Performance Requirements - The algorithm should aim for a time complexity of O(n). Example ```python def number_of_ways(n: int) -> int: # Implementation here print(number_of_ways(3)) # Expected Output: 3 print(number_of_ways(4)) # Expected Output: 5 ``` Implement the function, possibly using dynamic programming techniques to efficiently compute the number of tiling ways for larger values of `n`. # Explanation - For `n = 1`, there\'s only 1 way to tile the grid with a single vertical domino. - For `n = 2`, there are 2 possible ways: two vertical dominoes or two horizontal dominoes. - For `n = 3`, there are 3 ways to tile the grid: 1. Three vertical dominoes. 2. One vertical domino covering the first column and two horizontal dominoes. 3. Two horizontal dominoes covering the first two columns and one vertical domino. Explore the relation of the problem to the Fibonacci sequence for constructing your solution.","solution":"def number_of_ways(n: int) -> int: Returns the number of ways to fully cover a 2 x n grid using 1x2 and 2x1 dominoes. if n == 1: return 1 if n == 2: return 2 # Use dynamic programming to find the solution dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"# Scenario You are a software developer for an online bookstore. One of your tasks is to implement a recommendation system that helps users discover new books based on their reading history and ratings. The system uses a collaborative filtering algorithm to suggest new books to users. # Task Write a function `recommend_books` that takes information about users\' book ratings and generates a list of book recommendations for a specified user. The recommendations are based on the similarity of users\' ratings. # Function Signature ```python def recommend_books( user_ratings: Dict[str, Dict[str, int]], target_user: str, num_recommendations: int ) -> List[str]: ``` # Input - `user_ratings` (Dict[str, Dict[str, int]]): A dictionary where the keys are user IDs and the values are dictionaries containing book IDs as keys and their respective ratings (from 1 to 5) as values. - `target_user` (str): The user ID for whom you want to generate book recommendations. - `num_recommendations` (int): The number of book recommendations to generate. # Output - Returns a list of book IDs recommended for the target user, sorted by their predicted rating in descending order. If two or more books have the same predicted rating, the order can be arbitrary. # Constraints - All user IDs and book IDs are strings consisting of alphanumeric characters. - Ratings are integers between 1 and 5 inclusive. - The `target_user` is guaranteed to exist in the `user_ratings` dictionary. - There will always be enough books to recommend (at least `num_recommendations`). # Examples ```python # Example 1 user_ratings = { \'user1\': {\'book1\': 5, \'book2\': 3, \'book3\': 4}, \'user2\': {\'book1\': 4, \'book2\': 5, \'book3\': 3}, \'user3\': {\'book1\': 2, \'book2\': 5, \'book3\': 5}, \'user4\': {\'book4\': 4, \'book5\': 3} } print(recommend_books(user_ratings, \'user1\', 2)) # Output: [\'book4\', \'book5\'] # Example 2 user_ratings = { \'user1\': {\'book1\': 5, \'book2\': 3, \'book3\': 4, \'book4\': 2}, \'user2\': {\'book1\': 4, \'book2\': 5, \'book3\': 3, \'book4\': 4}, \'user3\': {\'book3\': 5, \'book4\': 2, \'book5\': 5}, } print(recommend_books(user_ratings, \'user2\', 1)) # Output: [\'book5\'] # Example 3 user_ratings = { \'user1\': {\'book1\': 1, \'book2\': 1, \'book3\': 1}, \'user2\': {\'book1\': 2, \'book2\': 2, \'book3\': 2}, \'user3\': {\'book1\': 3, \'book2\': 3, \'book3\': 3}, \'user4\': {\'book1\': 4, \'book2\': 4, \'book3\': 4} } print(recommend_books(user_ratings, \'user3\', 3)) # Output: [\'None\', \'None\', \'None\'] (No new books to recommend) ``` # Notes - Consider using cosine similarity or other similarity measures to compare users\' ratings. - Focus on recommending books that the target user has not already rated. - Handle cases where the target user has rated all available books by returning book IDs with a lower combined similarity score as a fallback.","solution":"from typing import Dict, List from collections import defaultdict import math def cosine_similarity(user_ratings1: Dict[str, int], user_ratings2: Dict[str, int]) -> float: common_books = set(user_ratings1.keys()).intersection(set(user_ratings2.keys())) if not common_books: return 0.0 sum1 = sum([user_ratings1[book] ** 2 for book in common_books]) sum2 = sum([user_ratings2[book] ** 2 for book in common_books]) dot_product = sum([user_ratings1[book] * user_ratings2[book] for book in common_books]) return dot_product / (math.sqrt(sum1) * math.sqrt(sum2)) def recommend_books( user_ratings: Dict[str, Dict[str, int]], target_user: str, num_recommendations: int ) -> List[str]: # Calculate similarity for each user against target_user user_similarities = {} for user in user_ratings: if user != target_user: similarity = cosine_similarity(user_ratings[target_user], user_ratings[user]) user_similarities[user] = similarity # Calculate weighted ratings for books book_scores = defaultdict(float) for user, similarity in user_similarities.items(): for book, rating in user_ratings[user].items(): if book not in user_ratings[target_user]: book_scores[book] += similarity * rating # Sort books by score and return top recommendations recommended_books = sorted(book_scores.items(), key=lambda x: x[1], reverse=True) return [book for book, score in recommended_books[:num_recommendations]]"},{"question":"# Longest Consecutive Sequence Given an unsorted list of integers, write a function `longest_consecutive_sequence(nums) -> int` that returns the length of the longest consecutive sequence of numbers within the list. A consecutive sequence is defined as a sequence of numbers where each number is exactly one greater than the previous. **Input**: - `nums` (List[int]): A list of integers. **Output**: - An integer representing the length of the longest consecutive sequence. **Constraints**: - Each integer in `nums` is unique and the list can be empty. - You must handle invalid inputs by raising an assertion error with a message indicating that the input must be a list of integers. # Examples ```python longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) # Output: 4 (sequence: [1, 2, 3, 4]) longest_consecutive_sequence([0, 9, 1, 4, 5, 7, 2, 3, 6]) # Output: 10 (sequence: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) longest_consecutive_sequence([10, 5, 4, 20, 1]) # Output: 2 (sequence: [4, 5]) longest_consecutive_sequence([]) # Output: 0 longest_consecutive_sequence([3]) # Output: 1 (sequence: [3]) ``` # Explanation In the function `longest_consecutive_sequence`, start by ensuring `nums` is a list of integers. If the list is empty, return 0. Use a set to store the unique integers from `nums` for O(1) average-time complexity look-up. Iterate through the list and for each number, check if it is the start of a sequence (i.e., the previous number is not in the set). If it is the start, count the length of the sequence by incrementing numbers until the sequence breaks. Track the maximum length of such sequences found and return that length. Implement the function efficiently to handle large inputs within performance constraints and correctly manage edge cases.","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive sequence of numbers in the list. :param nums: List[int] - a list of integers. :return: int - length of the longest consecutive sequence. if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise AssertionError(\\"Input must be a list of integers\\") num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # num is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"**Graph Traversal Challenge** You have been provided with a weighted, undirected graph represented as an adjacency list and must implement Dijkstra\'s algorithm to find the shortest path from a given starting node to all other nodes in the graph. # Problem Statement Write a function `dijkstra(graph: dict, start: int) -> dict` that takes a weighted graph and a starting node and returns a dictionary containing the shortest distances from the start node to all other nodes using Dijkstra\'s algorithm. # Function Signature ```python def dijkstra(graph: dict, start: int) -> dict: ``` # Input - `graph`: A dictionary where the keys are integers representing nodes and the values are lists of tuples. Each tuple `(neighbor, weight)` represents an edge from the key node to the `neighbor` node with the given `weight`. It is guaranteed that all weights are non-negative integers (`0 <= weight <= 100`). - `start`: An integer representing the starting node. # Output - A dictionary where the keys are nodes and the values are the shortest distances from the start node to the key node. # Constraints 1. The graph will contain at most 1,000 nodes. 2. There will be no negative weights. 3. The starting node and all nodes within the graph will be non-negative integers. 4. If a node is not reachable from the start node, its distance should be represented as `float(\'inf\')`. # Performance Considerations 1. Efficiently handle graphs with up to 1,000 nodes. 2. Use appropriate data structures to optimize the graph traversal and shortest path calculations. # Examples ```python >>> graph = { ... 0: [(1, 4), (2, 1)], ... 1: [(3, 1)], ... 2: [(1, 2), (3, 5)], ... 3: [] ... } >>> dijkstra(graph, 0) {0: 0, 1: 3, 2: 1, 3: 4} >>> graph = { ... 0: [(1, 2)], ... 1: [] ... } >>> dijkstra(graph, 0) {0: 0, 1: 2} >>> dijkstra(graph, 1) {0: inf, 1: 0} >>> graph = { ... 0: [(1, 2)], ... 1: [(0, 2), (2, 4)], ... 2: [(3, 1)], ... 3: [(1, 1)] ... } >>> dijkstra(graph, 0) {0: 0, 1: 2, 2: 6, 3: 7} >>> graph = { ... 0: [(1, 10)], ... 1: [(2, 20), (3, 30)], ... 2: [(3, 5)], ... 3: [] ... } >>> dijkstra(graph, 0) {0: 0, 1: 10, 2: 30, 3: 35} >>> dijkstra(graph, 2) {0: inf, 1: inf, 2: 0, 3: 5} ``` # Requirements 1. Implement the edge case handling for unreachable nodes. 2. Ensure the implementation adheres to the input and output format and constraints closely. 3. Consider using a priority queue to optimize the algorithm.","solution":"import heapq def dijkstra(graph, start): Implements Dijkstra\'s algorithm to find the shortest path from the start node to all other nodes. Parameters: graph (dict): A dictionary representing the weighted, undirected graph. Keys are nodes and values are lists of tuples (neighbor, weight). start (int): The starting node. Returns: dict: A dictionary where keys are nodes and values are the shortest distances from the start node to the key node. # Initialize the priority queue pq = [(0, start)] distances = {node: float(\'inf\') for node in graph} # Initialize distances to all nodes as infinity distances[start] = 0 # Distance to the start node is 0 while pq: current_distance, current_node = heapq.heappop(pq) # If this distance is already greater, we skip processing if current_distance > distances[current_node]: continue # Visit all the neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"# Loan Default Prediction with Logistic Regression For this assessment, you are tasked with creating a Machine Learning classification model using Logistic Regression to predict loan defaults. You will be given a dataset containing borrower information and loan statuses (defaulted or not), and you will need to implement a classification model to predict whether a new borrower is likely to default. **Problem**: 1. Implement a function `preprocess_data` that preprocesses the input data, handling missing values and normalizing features as required. 2. Implement a function `train_logistic_regression` that trains the Logistic Regression model and performs predictions on a test dataset. 3. Implement a `main` function to run the entire process and evaluate the model. # Input: 1. A dictionary `data` with keys: * `features` - A string representing the array of features (feature values per borrower). * `target` - A string representing the array of corresponding target statuses (1 for default, 0 for non-default). # Output: 1. A callable Logistic Regression model function. 2. A prediction output array of default probabilities for the test dataset. # Constraints: * Use Logistic Regression\'s default parameters as much as possible. * Ensure the evaluation metrics (Accuracy, Precision, Recall, and F1-Score) are calculated correctly. * Handle any missing or incorrect input data accurately. # Example: ```python # Expected data format for input dictionary example_data = { \\"features\\": \\"[[50000, 35, 10], [60000, 40, 12], ...]\\", \\"target\\": \\"[0, 1, ...]\\" } # Define the functions def preprocess_data(data): # Perform data preprocessing including handling missing values and normalizing features pass def train_logistic_regression(train_features, train_target, test_features): # Train Logistic Regression model and perform prediction on test data pass def main(): # Running the model pass if __name__ == \\"__main__\\": main() ``` # Evaluation: Evaluate your solution based on: 1. Correctness: Does the function accurately predict the probability of loan defaults for given data? 2. Efficiency: Is your solution optimized for given constraints? 3. Robustness: Does your solution handle edge cases and missing data gracefully?","solution":"import json import numpy as np from sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score from sklearn.preprocessing import StandardScaler from sklearn.impute import SimpleImputer def preprocess_data(data): Preprocesses the input data by handling missing values and normalizing features. Args: data (dict): A dictionary containing \'features\' and \'target\' as strings. Returns: tuple: preprocessed training features, test features, training target, and test target arrays features = np.array(json.loads(data[\'features\'])) target = np.array(json.loads(data[\'target\'])) imputer = SimpleImputer(strategy=\'mean\') features = imputer.fit_transform(features) scaler = StandardScaler() features = scaler.fit_transform(features) train_features, test_features, train_target, test_target = train_test_split(features, target, test_size=0.2, random_state=42) return train_features, test_features, train_target, test_target def train_logistic_regression(train_features, train_target, test_features): Trains a Logistic Regression model and returns the predictions on the test dataset. Args: train_features (np.array): The feature values for training. train_target (np.array): The target values for training. test_features (np.array): The feature values for testing. Returns: np.array: The predicted probabilities of the test data. model = LogisticRegression() model.fit(train_features, train_target) predictions = model.predict_proba(test_features)[:, 1] return model, predictions def main(data): Runs the entire process: preprocessing data, training model, and evaluating the results. Args: data (dict): A dictionary containing \'features\' and \'target\' as strings. Returns: dict: a dictionary containing evaluation metrics. train_features, test_features, train_target, test_target = preprocess_data(data) model, predictions = train_logistic_regression(train_features, train_target, test_features) pred_labels = (predictions >= 0.5).astype(int) evaluation = { \\"accuracy\\": accuracy_score(test_target, pred_labels), \\"precision\\": precision_score(test_target, pred_labels), \\"recall\\": recall_score(test_target, pred_labels), \\"f1_score\\": f1_score(test_target, pred_labels) } return evaluation, model # Example usage: # if __name__ == \\"__main__\\": # example_data = { # \\"features\\": \\"[[50000, 35, 10], [60000, 40, 12], ...]\\", # \\"target\\": \\"[0, 1, ...]\\" # } # eval_metrics, trained_model = main(example_data) # print(eval_metrics)"},{"question":"# Task: Implement a Custom Sorting Function Your task is to implement a custom sort function that sorts a list of tuples based on multiple criteria. The function should sort the tuples in ascending order based on the second element, and if two tuples have the same second element, it should then sort by the first element in descending order. # Function Signature ```python def custom_sort(tuples_list): Sort a list of tuples based on the second element in ascending order. If two tuples have the same second element, sort them by the first element in descending order. :param tuples_list: list of tuples (int, int) :return: list of tuples sorted based on the criteria >>> custom_sort([(1, 3), (2, 2), (3, 2), (1, 1)]) [(1, 1), (3, 2), (2, 2), (1, 3)] >>> custom_sort([(4, 4), (2, 3), (3, 4), (1, 2)]) [(1, 2), (2, 3), (4, 4), (3, 4)] >>> custom_sort([]) [] # Your implementation here ``` # Constraints 1. The elements of each tuple and the list can be assumed to contain only integers. 2. The input list can be empty. # Example Usages - `custom_sort([(1, 3), (2, 2), (3, 2), (1, 1)])` should return `[(1, 1), (3, 2), (2, 2), (1, 3)]`. - `custom_sort([(4, 4), (2, 3), (3, 4), (1, 2)])` should return `[(1, 2), (2, 3), (4, 4), (3, 4)]`. - `custom_sort([])` should return `[]`.","solution":"def custom_sort(tuples_list): Sort a list of tuples based on the second element in ascending order. If two tuples have the same second element, sort them by the first element in descending order. :param tuples_list: list of tuples (int, int) :return: list of tuples sorted based on the criteria >>> custom_sort([(1, 3), (2, 2), (3, 2), (1, 1)]) [(1, 1), (3, 2), (2, 2), (1, 3)] >>> custom_sort([(4, 4), (2, 3), (3, 4), (1, 2)]) [(1, 2), (2, 3), (4, 4), (3, 4)] >>> custom_sort([]) [] return sorted(tuples_list, key=lambda x: (x[1], -x[0]))"},{"question":"# Scenario: You are developing a text editor application that needs to implement a \\"Find and Replace\\" feature. The feature should allow users to replace all occurrences of a particular word in a paragraph with another word. # Task: Implement a function `find_and_replace` that performs the following: 1. Searches for all occurrences of a specified target word in a given paragraph. 2. Replaces each occurrence of the target word with a given replacement word. 3. Returns the updated paragraph. # Specifications: 1. `find_and_replace(paragraph: str, target: str, replacement: str) -> str` - **Parameters**: - `paragraph (str)`: A string representing the paragraph of text. - `target (str)`: The word in the paragraph that needs to be replaced. - `replacement (str)`: The word that will replace the target word. - **Returns**: The modified paragraph as a string. 2. The function should validate and ensure: - The paragraph, target, and replacement are non-empty strings. - The target word exists in the paragraph. 3. **Considerations**: - The search should be case-sensitive. - Only whole words should be replaced (e.g., \\"cat\\" should not match and replace \\"caterpillar\\"). # Example: ```python paragraph = \\"The quick brown fox jumps over the lazy dog. The quick brown fox is clever.\\" target = \\"fox\\" replacement = \\"cat\\" print(find_and_replace(paragraph, target, replacement)) ``` **Expected Output**: ``` The quick brown cat jumps over the lazy dog. The quick brown cat is clever. ``` # Constraints: - Assume the paragraph will be a well-formed sentence or series of sentences. - Focus on code readability and correctness.","solution":"import re def find_and_replace(paragraph, target, replacement): Searches for all occurrences of the target word in the given paragraph and replaces them with the replacement word. Args: paragraph (str): The paragraph of text. target (str): The word in the paragraph that needs to be replaced. replacement (str): The word that will replace the target word. Returns: str: The modified paragraph with the target word replaced by the replacement word. if not paragraph: raise ValueError(\\"Paragraph should not be empty.\\") if not target: raise ValueError(\\"Target word should not be empty.\\") if not replacement: raise ValueError(\\"Replacement word should not be empty.\\") if target not in paragraph: raise ValueError(\\"Target word does not exist in the paragraph.\\") # Using regex word boundary b to ensure only whole words are replaced. pattern = r\'b\' + re.escape(target) + r\'b\' updated_paragraph = re.sub(pattern, replacement, paragraph) return updated_paragraph"},{"question":"# Problem Statement Given a list of integers, write a function to find the smallest possible positive number that is not the sum of a subsequence of the list. A subsequence is a sequence derived by deleting some or no elements of the list without changing the order of the remaining elements. # Function Signature ```python def smallest_missing_positive_sum(nums: List[int]) -> int: ``` # Input - `nums`: A list of integers. The list will always have at least one element, and the elements can be both positive and negative. # Output - Returns an integer, the smallest possible positive number that is not the sum of any subsequence of the list. # Constraints - The length of `nums` is between 1 and 1000. - Each element of `nums` is between -1000 and 1000. # Example ```python nums = [1, 2, 2, 4] print(smallest_missing_positive_sum(nums)) # Expected Output: 10 nums = [1, 3, 6, 10, 11, 15] print(smallest_missing_positive_sum(nums)) # Expected Output: 2 nums = [1, 1, 1, 1] print(smallest_missing_positive_sum(nums)) # Expected Output: 5 nums = [-1, -5, 3, 8] print(smallest_missing_positive_sum(nums)) # Expected Output: 1 ``` # Instructions 1. Implement the function `smallest_missing_positive_sum(nums: List[int]) -> int`. 2. Your function should handle both positive and negative integers in the input list. 3. Ensure efficiency and correctness of your solution. Consider edge cases effectively. 4. Write clear and readable code, with comments explaining key steps if necessary. # Notes - A subsequence does not have to be contiguous, but it must maintain the order of the original list. - The provided example inputs should be used for testing purposes to ensure the correctness of your function.","solution":"def smallest_missing_positive_sum(nums): Returns the smallest positive number that is not the sum of any subsequence of the list. nums.sort() smallest_missing = 1 for num in nums: if num > smallest_missing: break if num > 0: smallest_missing += num return smallest_missing"},{"question":"# Scenario You are developing a software to control an automated factory. The factory machines are represented by binary switches (on/off). You need to manage the switching mechanism efficiently. # Task Implement a function that accepts a list of binary switches representing the current state of machines. Your function should return the count of switches that are turned on (1). # Function Signature ```python def count_switches_on(switches: list[int]) -> int: Count the number of switches that are turned on. :param switches: A list of binary values (0 or 1) representing the state of the switches. :return: The number of switches that are turned on. :raises ValueError: If any element in the list is not 0 or 1. ``` # Input * `switches`: a list of integers where each integer is 0 or 1 # Output Returns the count of switches that are turned on. # Constraints * All elements in the list must be 0 or 1. * If any element is not 0 or 1, the function should raise a `ValueError`. * The length of the list can be up to (10^6). # Example ```python >>> count_switches_on([0, 1, 0, 1, 1]) 3 >>> count_switches_on([0, 0, 0, 0]) 0 >>> count_switches_on([1, 1, 1, 1]) 4 >>> count_switches_on([1, 0, 2, 1]) Traceback (most recent call last): ... ValueError: All elements in the list must be 0 or 1 >>> count_switches_on([1, -1, 0, 1]) Traceback (most recent call last): ... ValueError: All elements in the list must be 0 or 1 ``` # Notes * Ensure your implementation runs efficiently with a time complexity of O(n) where n is the length of the list. * Provide proper validation to ensure the input constraints are met.","solution":"def count_switches_on(switches: list[int]) -> int: Count the number of switches that are turned on. :param switches: A list of binary values (0 or 1) representing the state of the switches. :return: The number of switches that are turned on. :raises ValueError: If any element in the list is not 0 or 1. if not all(switch in [0, 1] for switch in switches): raise ValueError(\\"All elements in the list must be 0 or 1\\") return sum(switches)"},{"question":"# Array List Manipulation for Duplicate Removal Context Many real-world applications require processing large lists of data to remove duplicates while maintaining the initial occurrence of each element. Implementing an efficient solution for this problem is crucial for optimizing memory usage and computational speed. Problem Statement You are required to implement a function `remove_duplicates` that takes a list of integers and returns a new list containing the original elements but with all duplicates removed. The order of the remaining elements must be preserved as in the original list. Function Signature ```python def remove_duplicates(int_list: list) -> list: pass ``` Parameters - `int_list` (list): A list of integers that may contain duplicates. Returns - list: A new list with duplicates removed, maintaining the order of their first occurrence in the original list. Constraints - The input list may have a length ranging from 0 to 10^6. - Elements of the list are integers in the range of -10^6 to 10^6. - Prefer solutions with linear time complexity, O(n), and linear space complexity, O(n). Examples ```python >>> remove_duplicates([1, 2, 3, 2, 4, 3, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 4, 7, 8]) [4, 5, 7, 8] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([5, 6, 7, 7, 8, 9, 10, 6, 5, 4, 3]) [5, 6, 7, 8, 9, 10, 4, 3] ``` Notes - Utilize a set or dictionary to track seen elements and efficiently check for duplicates. - Ensure that your implementation handles edge cases like empty lists or lists with all identical elements. - Test your function with large inputs to verify its performance within the constraints. Ensure your implementation adheres to the required function signature and efficiently removes duplicates while preserving the original order of the first occurrences.","solution":"def remove_duplicates(int_list: list) -> list: Removes duplicates from the list while maintaining the order of the first occurrences. seen = set() result = [] for num in int_list: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Background You are given an array of integers representing elevations of terrain, where each element represents the height of the terrain at that point. Your task is to compute how much water can be trapped after a rain. Water is trapped in the valleys between the peaks of the terrain when there are higher terrains on both the left and right sides. # Task Implement a function that calculates the total amount of water that can be trapped in the given terrain. # Function Signature ```python def trap_water(elevations: list[int]) -> int: pass ``` # Input - `elevations` (list[int]): A list of non-negative integers representing the heights of the terrain. # Output - `result` (int): The total amount of water trapped after it rains. # Example ```python assert trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap_water([4, 2, 0, 3, 2, 5]) == 9 ``` # Constraints - The length of `elevations` will be between 0 and 10,000. - Each element in `elevations` will be a non-negative integer with a maximum value of 100,000. # Note - For the first example, the terrain elevation is [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]. We can trap 6 units of water between the peaks. - In the second example, the terrain elevation is [4, 2, 0, 3, 2, 5]. We can trap 9 units of water between the peaks.","solution":"def trap_water(elevations: list[int]) -> int: if not elevations: return 0 left, right = 0, len(elevations) - 1 left_max, right_max = elevations[left], elevations[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, elevations[left]) water_trapped += max(0, left_max - elevations[left]) else: right -= 1 right_max = max(right_max, elevations[right]) water_trapped += max(0, right_max - elevations[right]) return water_trapped"},{"question":"# Coding Challenge: Simplified Currency Conversion You are given a dictionary representing exchange rates between several currencies and a list of transactions in various currencies. Your task is to consolidate the transactions into a single currency using the given exchange rates. # Task Create a function `consolidate_transactions` that takes a dictionary of exchange rates and a list of transactions, and returns the total sum of the transactions converted to a target currency. # Function Signature ```python def consolidate_transactions(transactions: list[dict], exchange_rates: dict, target_currency: str) -> float: ``` # Inputs - `transactions`: A list of dictionaries, each representing a transaction with keys `\'currency\'` and `\'amount\'`. For example, `{\'currency\': \'USD\', \'amount\': 100.0}`. - `exchange_rates`: A dictionary where keys are currency codes (strings), and values are the exchange rate to the target currency (floats). For example, `{\'USD\': 1.0, \'EUR\': 0.85, \'JPY\': 110.0}`. - `target_currency`: A string representing the currency code to which all transactions should be converted. # Outputs - Returns a float representing the total amount of the transactions converted to the target currency. # Constraints 1. The target currency will always be present in both the transactions and exchange rates. 2. The exchange rates will always provide a valid conversion to the target currency. 3. The transactions list will contain at least one transaction. 4. Amounts are non-negative numbers. # Example ```python transactions = [ {\'currency\': \'USD\', \'amount\': 100.0}, {\'currency\': \'EUR\', \'amount\': 200.0}, {\'currency\': \'JPY\', \'amount\': 30000.0} ] exchange_rates = { \'USD\': 1.0, \'EUR\': 0.85, \'JPY\': 110.0 } target_currency = \'USD\' print(consolidate_transactions(transactions, exchange_rates, target_currency)) # Expected Output: # 472.72727272727275 (100.0 USD + 235.2941176470588 USD (200 EUR) + 272.72727272727275 USD (30000 JPY)) ``` # Additional Information - Exchange rates are given per unit of the target currency (e.g., if target currency is USD, `exchange_rates[\'EUR\']` gives the number of Euros per USD). - Floating-point arithmetic precision is important but slight variations within the precision limits of floating-point representation are acceptable. # Hints - Use the exchange rates to convert each transaction amount to the target currency. - Accumulate the converted values to get the total sum. - Pay attention to the possibility of needing to divide rather than multiply by an exchange rate, depending on the context. # Answer ```python def consolidate_transactions(transactions: list[dict], exchange_rates: dict, target_currency: str) -> float: total = 0.0 for transaction in transactions: currency = transaction[\'currency\'] amount = transaction[\'amount\'] rate = exchange_rates[currency] # Convert to target currency total += amount / rate return total # Example usage transactions = [ {\'currency\': \'USD\', \'amount\': 100.0}, {\'currency\': \'EUR\', \'amount\': 200.0}, {\'currency\': \'JPY\', \'amount\': 30000.0} ] exchange_rates = { \'USD\': 1.0, \'EUR\': 0.85, \'JPY\': 110.0 } target_currency = \'USD\' print(consolidate_transactions(transactions, exchange_rates, target_currency)) # Output: # 472.72727272727275 ```","solution":"def consolidate_transactions(transactions: list[dict], exchange_rates: dict, target_currency: str) -> float: total = 0.0 for transaction in transactions: currency = transaction[\'currency\'] amount = transaction[\'amount\'] rate = exchange_rates[currency] # Convert to target currency total += amount / rate return total"},{"question":"# Problem Statement You are given a string. Your task is to implement a function that returns `True` if the string is a valid palindrome with at most one character modification (i.e., you can modify at most one character to make it a palindrome), and `False` otherwise. Function Signature ```python def valid_palindrome_with_one_modification(s: str) -> bool: ``` Input - A string `s` (1 ≤ len(s) ≤ 1000) Output - A boolean value indicating whether the string can be made a palindrome with at most one modification. # Performance Requirements - Your solution should handle edge cases efficiently as per the constraints. # Example **Input**: `\\"abca\\"` **Output**: `True` **Explanation**: You can change \'c\' to \'b\' to make it \\"abba\\", which is a palindrome. **Input**: `\\"abcdef\\"` **Output**: `False` **Explanation**: More than one modification is needed to make it a palindrome. # Constraints 1. The length of the string will be between 1 and 1000 (both inclusive). 2. The string will contain only lowercase English letters. # Implementation Notes - Ensure to handle edge cases such as a string with a single character, which is trivially a palindrome. - Consider optimal ways to check the possibility of a palindrome with minimal string modifications.","solution":"def valid_palindrome_with_one_modification(s: str) -> bool: Returns True if the string can be made into a palindrome with at most one modification. def is_palindrome_range(start, end): Checks if the substring s[start:end+1] is a palindrome. while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # If mismatch found, try to skip either the left character or the right character return is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) left += 1 right -= 1 # If no mismatches are found, it is already a palindrome return True"},{"question":"# Coding Assessment Question You need to create a function that computes the longest sequence of consecutive integers in an unsorted list. This is useful in scenarios where identifying the longest stretch of contiguous data points is necessary. # Requirements Implement the function `longest_consecutive_sequence(nums)` which takes: 1. `nums`: A list of integers. # Expected Function Signature ```python def longest_consecutive_sequence(nums: List[int]) -> int: ``` # Constraints - The input list `nums` can be empty. - The function should not use additional libraries or constructs other than standard Python. # Example ```python >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive_sequence([]) 0 ``` # Performance Expectations - The function should run in O(n) time complexity, where n is the length of `nums`. - Use O(n) additional space for the hash set used in the solution logic.","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only look for the start of a streak if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Question: Implement a Memoization Technique for Recursive Fibonacci Calculation You are assigned to optimize the computation of Fibonacci numbers using memoization. This will improve the efficiency of the recursive function by storing the results of subproblems. Problem Statement Your task is to write a function `memoized_fibonacci(n, memo={})` that computes the nth Fibonacci number using a recursive approach with memoization. Requirements 1. **Memoized Fibonacci Function**: - Implement a recursive function to compute Fibonacci numbers. - Use a dictionary to store previously calculated Fibonacci numbers to avoid redundant computations. - The function should accept an integer `n` and an optional dictionary `memo`. - Return the nth Fibonacci number. 2. **Handling Base Cases**: - Base cases must be handled for `n = 0` and `n = 1`, returning 0 and 1 respectively. - Ensure the function correctly initializes the base case values in the memo dictionary. 3. **Optimization**: - Ensure that the function efficiently computes large Fibonacci numbers by leveraging memoization. - Include necessary checks to avoid duplicate calculations. Input and Output - The function `memoized_fibonacci(n, memo={})` should take an integer `n` and an optional dictionary `memo` for memoization. - The function returns an integer representing the nth Fibonacci number. Constraints - `0 <= n <= 100` - Ensure that the solution accounts for large values of `n` efficiently using memoization. Example ```python def memoized_fibonacci(n, memo={}): if n in memo: return memo[n] if n <= 1: return n memo[n] = memoized_fibonacci(n - 1, memo) + memoized_fibonacci(n - 2, memo) return memo[n] # Test cases print(memoized_fibonacci(10)) # Output: 55 print(memoized_fibonacci(50)) # Output: 12586269025 print(memoized_fibonacci(100)) # Output: 354224848179261915075 ``` Output: ```plaintext memoized_fibonacci(10) = 55 memoized_fibonacci(50) = 12586269025 memoized_fibonacci(100) = 354224848179261915075 ``` Implement the above solution and validate using test cases to ensure efficiency and correctness for a range of input values.","solution":"def memoized_fibonacci(n, memo=None): Computes the nth Fibonacci number using memoization. Args: n (int): The index of the Fibonacci number to compute. memo (dict, optional): A dictionary to store previously computed Fibonacci numbers. Returns: int: The nth Fibonacci number. if memo is None: memo = {} if n in memo: return memo[n] if n <= 1: return n memo[n] = memoized_fibonacci(n - 1, memo) + memoized_fibonacci(n - 2, memo) return memo[n]"},{"question":"# Matrix Transpose Context In linear algebra, the transpose of a matrix is an operator which flips a matrix over its diagonal. It switches the row and column indices of the matrix by producing another matrix denoted as (A^T). Transposing a matrix can be useful in numerous mathematical and computational applications. Task You are to implement a function `transpose(matrix: List[List[int]]) -> List[List[int]]` that returns the transpose of a given 2D matrix. Requirements: 1. The function should return the transpose of the input matrix. 2. If the matrix is empty or any of its rows are empty, the function should raise a `ValueError` with a message: \\"input matrix is invalid\\". 3. The function should handle rectangular matrices, not just square matrices. Input: * `matrix`: A list of lists where each inner list represents a row of the matrix containing integers. Output: * A list of lists representing the transposed matrix. Constraints: * The elements of the matrix are integers. * Ensure the solution handles varying dimensions efficiently. Examples: ```python >>> transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose([[7]]) [[7]] >>> transpose([[], []]) Traceback (most recent call last): ... ValueError: input matrix is invalid >>> transpose([]) Traceback (most recent call last): ... ValueError: input matrix is invalid ``` Implementation Note: Ensure the function handles different dimensions of matrices smoothly and includes appropriate error handling for invalid inputs.","solution":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the input matrix. Parameters: matrix (List[List[int]]): A 2D list where each inner list is a row of the matrix. Returns: List[List[int]]: The transposed matrix. Raises: ValueError: If the input matrix is invalid (empty matrix or empty rows). if not matrix or not all(matrix): raise ValueError(\\"input matrix is invalid\\") # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] return transposed_matrix"},{"question":"# Minimum Spanning Tree - Kruskal\'s Algorithm You are required to implement Kruskal\'s algorithm to find the Minimum Spanning Tree (MST) of a connected, undirected graph. Kruskal\'s algorithm is a well-known algorithm for finding the MST using the greedy approach. # Problem 1. **Implement the Disjoint Set (Union-Find) Data Structure**: - Write a class `DisjointSet` with methods `find` and `union`. - The constructor initializes the parent and rank of each node. 2. **Implement Kruskal\'s MST Algorithm**: - Write a function `kruskal_mst(edges, num_vertices)` to find the MST of a graph. - `edges` is a list of tuples where each tuple is in the form `(weight, u, v)` representing an edge with a certain weight between vertices `u` and `v`. - `num_vertices` is the number of vertices in the graph. # Function Signatures ```python class DisjointSet: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [0] * n def find(self, u: int) -> int: # Implement this function def union(self, u: int, v: int) -> bool: # Implement this function def kruskal_mst(edges: List[Tuple[int, int, int]], num_vertices: int) -> List[Tuple[int, int, int]]: # Implement this function ``` # Requirements 1. **Input**: - `DisjointSet(n)`: An integer `n` representing the number of vertices. - `edges`: A list of tuples `[(weight1, u1, v1), (weight2, u2, v2), ...]` representing the edges of the graph. - `num_vertices`: An integer representing the number of vertices in the graph. 2. **Output**: - `kruskal_mst(edges, num_vertices)`: Returns a list of edges that form the MST. Each edge is represented as a tuple `(weight, u, v)`. 3. **Constraints**: - Vertices are zero-indexed. - The graph is connected and undirected. - Edges weights are non-negative. # Example Finding the MST of a graph using Kruskal\'s algorithm: ```python edges = [ (1, 0, 1), (3, 0, 2), (3, 1, 2), (6, 1, 3), (4, 2, 3), ] num_vertices = 4 mst = kruskal_mst(edges, num_vertices) print(mst) # Output: [(1, 0, 1), (3, 0, 2), (4, 2, 3)] # Example output; actual may vary ``` # Additional Notes - Ensure your implementation handles edge cases like multiple edges with the same weight and small inputs. - Optimize for algorithmic efficiency, especially in the union-find operations.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [0] * n def find(self, u: int) -> int: if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u: int, v: int) -> bool: root_u = self.find(u) root_v = self.find(v) if root_u == root_v: return False if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 return True def kruskal_mst(edges: List[Tuple[int, int, int]], num_vertices: int) -> List[Tuple[int, int, int]]: edges.sort() # Sort the edges by their weight dsu = DisjointSet(num_vertices) mst = [] for weight, u, v in edges: if dsu.union(u, v): mst.append((weight, u, v)) return mst"},{"question":"# Problem Statement: You are tasked with writing a `kSmallestElement` class to find the k-th smallest element in an unsorted list of integers. Your solution should ensure efficient performance, prioritizing both time and space optimizations. # Requirements: * Implement the class `kSmallestElement` with a method `find_kth` to take a list of integers and an integer k, then return the k-th smallest element. * Handle edge cases and ensure the algorithm is efficient for large inputs. * You may use up to O(n log n) solutions, but strive for an optimized approach where possible. # Function Signature: ```python class kSmallestElement: def find_kth(self, nums: list[int], k: int) -> int: ``` # Expected Input: * A list of integers, e.g., [3, 2, 1, 5, 6, 4]. * An integer k which represents the position (1-based) of the smallest element to find, e.g., 2. # Expected Output: * An integer representing the k-th smallest element, e.g., 2. # Constraints: * 1 <= len(nums) <= 10000 * 1 <= k <= len(nums) * -100000 <= nums[i] <= 100000 # Implementation Details: 1. Implement a partition-based approach, like Quickselect, to effectively find the k-th smallest element. 2. Use helper methods as needed to support the primary solution. 3. Ensure robustness by handling edge cases, such as empty lists or invalid k values. # Example: ```python >>> finder = kSmallestElement() >>> finder.find_kth([3, 2, 1, 5, 6, 4], 2) 2 >>> finder.find_kth([7, 10, 4, 3, 20, 15], 3) 7 ``` # Notes: * Do not use Python\'s built-in sorting or selection methods. * Aim for a solution with a better-than-O(n log n) time complexity, such as O(n) average with Quickselect if possible.","solution":"import random class kSmallestElement: def find_kth(self, nums: list[int], k: int) -> int: Returns the k-th smallest element in an unsorted list of integers. Uses the Quickselect algorithm for an average O(n) time complexity. def partition(left, right, pivot_index): pivot_value = nums[pivot_index] # Move pivot to the end nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 # Move pivot to its final place nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def select(left, right, k_smallest): Returns the k-th smallest element of list within left..right. if left == right: return nums[left] # Select a random pivot_index between pivot_index = random.randint(left, right) pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(nums) - 1, k - 1)"},{"question":"# Task: Implement a Function to Calculate the Median of a Data Stream Problem Statement: You are tasked with implementing a class `RunningMedian` that maintains and calculates the median of a stream of integers. The class should support the following methods: - `add_number(number: int) -> None`: Adds a new number to the data stream. - `find_median() -> float`: Returns the median of all numbers added so far. Details: - **Input**: - `number (int)` : A new integer to be added to the data stream for the `add_number` method. - **Output**: - For `find_median`, a float representing the median of the numbers added to the data stream. - Note: If the stream has an even number of elements, the median is the average of the two middle elements. Constraints: - The number of integers added will not exceed 10^5. - The integer values can be between -10^6 and 10^6. - Operations should be optimized for performance, aiming for O(log n) insertion time and O(1) median retrieval time. Performance Requirements: - Efficient use of data structures is essential to handle up to 10^5 insertions in a reasonable time. - Ensure that each method operates within its specified time complexities. Scenario: You are developing a real-time analytics system for financial transactions, where the median transaction value needs to be reported continuously as new transactions are processed. Edge Cases: - No numbers added yet when `find_median` is called. - All numbers added are the same. - Mixture of negative and positive integers. Skeleton Code: ```python import heapq class RunningMedian: def __init__(self): self.min_heap = [] self.max_heap = [] def add_number(self, number: int) -> None: if not self.max_heap or number <= -self.max_heap[0]: heapq.heappush(self.max_heap, -number) else: heapq.heappush(self.min_heap, number) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) == 0: raise ValueError(\\"No numbers are added to the data stream.\\") if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0 ``` Hints: 1. Use two heaps (a max-heap for the lower half of numbers and a min-heap for the upper half) to balance the data. 2. Ensure to rebalance the heaps if their sizes differ by more than one after every insertion. 3. Handle cases where no numbers have been added yet by raising appropriate exceptions. Implement the `RunningMedian` class and write corresponding test cases to verify its correctness. Consider edge cases like no elements added, duplicates, and negative values.","solution":"import heapq class RunningMedian: def __init__(self): self.min_heap = [] self.max_heap = [] def add_number(self, number: int) -> None: if not self.max_heap or number <= -self.max_heap[0]: heapq.heappush(self.max_heap, -number) else: heapq.heappush(self.min_heap, number) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) == 0: raise ValueError(\\"No numbers are added to the data stream.\\") if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Question: Move Zeros to End Write a function that takes a list of integers and moves all the zeros to the end of the list, while maintaining the relative order of the other elements. Your implementation should be done in-place, modifying the input list. Function Signature ```python def move_zeros_to_end(nums: list[int]) -> None: Move all zeros in the list to the end while maintaining the order of other elements. :param nums: A list of integers. ``` Input/Output Examples 1. **Input**: `move_zeros_to_end([0, 1, 0, 3, 12])` - **Output**: `[1, 3, 12, 0, 0]` - **Explanation**: The zeros are moved to the end while the relative order of non-zero elements is preserved. 2. **Input**: `move_zeros_to_end([1, 0, 2, 0, 0, 7, 0, 8, 0])` - **Output**: `[1, 2, 7, 8, 0, 0, 0, 0, 0]` - **Explanation**: The zeros are moved to the end while the relative order of non-zero elements is preserved. 3. **Input**: `move_zeros_to_end([0, 0, 0, 0])` - **Output**: `[0, 0, 0, 0]` - **Explanation**: All the elements are zeros and remain unchanged. 4. **Input**: `move_zeros_to_end([4, 2, 1, 3])` - **Output**: `[4, 2, 1, 3]` - **Explanation**: There are no zeros to move, so the list remains unchanged. # Constraints and Limitations - The operation must be performed in-place: no additional lists should be created. - The function should handle lists containing both positive and negative integers, as well as zeros. - The function should be efficient and handle larger lists gracefully.","solution":"def move_zeros_to_end(nums: list[int]) -> None: Move all zeros in the list to the end while maintaining the order of other elements. :param nums: A list of integers. # Initialize a pointer for the position to place the next non-zero element position = 0 # Iterate over the list for num in nums: if num != 0: # Place the non-zero element at the \'position\' index nums[position] = num position += 1 # Fill the rest of the list with zeros for i in range(position, len(nums)): nums[i] = 0"},{"question":"Question: # Context: You are tasked with writing an algorithm that simulates a simplified version of a file system. The file system consists of directories and files. Each directory can contain other directories and files, and each file has a specific size. # Challenge: Write a class `FileSystem` that supports the following operations: 1. `add_file(path: str, size: int) -> None`: Adds a file with the given size to the specified path. If the path does not exist, create the necessary directories. If the file already exists, update its size. 2. `add_directory(path: str) -> None`: Adds a directory to the specified path. If the path does not exist, create the necessary directories. 3. `get_directory_size(path: str) -> int`: Returns the total size of all files in the specified directory and its subdirectories. # Input: - `path`: A string representing the path to the file or directory. Paths are represented using forward slashes `/` similar to Unix file systems. - `size`: An integer representing the size of the file. # Output: - For `get_directory_size(path: str)`, return the total size of all files within the specified directory. For other methods, no return value is needed. # Constraints: - File paths and directory paths will always be valid strings. - File sizes will be positive integers. - The file system should handle multiple nested directories and file additions efficiently. # Example: ```python class FileSystem: def __init__(self): Your code here def add_file(self, path: str, size: int) -> None: Your code here def add_directory(self, path: str) -> None: Your code here def get_directory_size(self, path: str) -> int: Your code here fs = FileSystem() fs.add_directory(\'/a/b/c\') fs.add_file(\'/a/b/c/d.txt\', 100) assert fs.get_directory_size(\'/a\') == 100 fs.add_file(\'/a/b/c/e.txt\', 200) assert fs.get_directory_size(\'/a/b\') == 300 ``` # Implementation Hints: - Use a nested dictionary structure to represent the directories and files. - Keep track of file sizes within the directories to facilitate the size computation efficiently.","solution":"class FileSystem: def __init__(self): self.fs = {\'/\': {}} def get_dir(self, path: str): elements = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for element in elements: if element: if element not in current: current[element] = {} current = current[element] return current def add_file(self, path: str, size: int) -> None: elements = path.strip(\'/\').split(\'/\') filename = elements[-1] current = self.get_dir(\'/\' + \'/\'.join(elements[:-1])) current[filename] = size def add_directory(self, path: str) -> None: self.get_dir(path) def get_directory_size(self, path: str) -> int: current = self.get_dir(path) return self._get_size(current) def _get_size(self, current) -> int: size = 0 for key, value in current.items(): if isinstance(value, dict): size += self._get_size(value) else: size += value return size"},{"question":"# Problem Statement You are tasked with determining if the given number is a special type of number known as a \'Palindromic Prime\'. A Palindromic Prime is a number that is both prime and reads the same forwards and backwards, such as 131 or 727. # Function Requirements You need to implement the following functions: 1. `is_prime(n: int) -> bool`: This function takes an integer `n` and returns `True` if the number `n` is a prime, otherwise `False`. 2. `is_palindrome(n: int) -> bool`: This function takes an integer `n` and returns `True` if the number `n` reads the same forwards and backwards, otherwise `False`. 3. `palindromic_prime(n: int) -> bool`: This function takes an integer `n` and returns `True` if the number `n` is both prime and a palindrome. # Input - `n` ( (1 leq n leq 10^6) ): An integer to be checked if it is a Palindromic Prime. # Output - A boolean value, `True` if `n` is a Palindromic Prime, otherwise `False`. # Example ```python # Function tests >>> is_prime(131) True >>> is_prime(133) False >>> is_prime(2) True >>> is_palindrome(131) True >>> is_palindrome(133) False >>> is_palindrome(2) True # Combined function test >>> palindromic_prime(131) True >>> palindromic_prime(133) False >>> palindromic_prime(727) True ``` # Constraints - You can assume that the input number `n` is a valid positive integer. - Consider computational efficiency when implementing the `is_prime` function to handle larger numbers effectively.","solution":"def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n: int) -> bool: Returns True if n is a palindrome, else False. return str(n) == str(n)[::-1] def palindromic_prime(n: int) -> bool: Returns True if n is both a prime and a palindrome. return is_prime(n) and is_palindrome(n)"},{"question":"# Question Objective Create a function `remove_duplicates_preserve_order(sequence: list) -> list` that removes duplicate elements from a list while preserving the original order of their first occurrences. Details 1. **Input**: A list `sequence` containing any hashable elements. 2. **Output**: A list with duplicates removed, maintaining the order of first appearances. Constraints * The given list elements can be of any hashable type (e.g., int, float, string, tuple). * The function should handle empty lists gracefully. Examples ```python >>> remove_duplicates_preserve_order([1, 2, 3, 1, 2, 1]) [1, 2, 3] >>> remove_duplicates_preserve_order([\'a\', \'b\', \'c\', \'a\', \'b\', \'a\']) [\'a\', \'b\', \'c\'] >>> remove_duplicates_preserve_order([(1, 2), (3, 4), (1, 2), (5, 6)]) [(1, 2), (3, 4), (5, 6)] >>> remove_duplicates_preserve_order([]) [] >>> remove_duplicates_preserve_order([1.1, 2.2, 1.1, 3.3, 2.2]) [1.1, 2.2, 3.3] ``` Hints - Consider using a set to track elements that have already been encountered. - Ensure that the original order of the sequence is preserved after removing duplicates. **Submit your implementation of `remove_duplicates_preserve_order` below:**","solution":"def remove_duplicates_preserve_order(sequence): Removes duplicate elements from the list while preserving the original order of their first occurrences. Parameters: sequence (list): List of hashable elements. Returns: list: A list with duplicates removed and order preserved. seen = set() result = [] for item in sequence: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Problem Statement You are required to implement a function that mimics a simplified file system. The file system supports creating directories, adding files, and querying the total size of files within a specific directory. # Function Signature ```python def file_system(operations: List[Tuple[str, str, int]]) -> List[int]: pass ``` # Input and Output The function should take: * `operations`: a list of tuples, where each tuple represents an operation in the format: - `(\\"mkdir\\", path, 0)`: To create a directory at the given path. - `(\\"addfile\\", path, size)`: To add a file at the given path with the specified size. - `(\\"getsize\\", path, 0)`: To return the total size of all files within the specified directory path and its subdirectories. * All paths will be well-formed strings using forward slashes `/` to separate directories. Directories and filenames will be alphanumeric strings, and paths will not end with a slash (except for the root directory which is \'/\'). The function should return a list of integers for each `getsize` operation, representing the total size of all files within the specified directory and its subdirectories. # Constraints * `path` strings and filenames will only contain alphanumeric characters and forward slashes. * The path of each directory and file uniquely identifies it. * Directories must be created before use in any path. * The size of files will be non-negative integers. # Explanation and Example To implement the file system, follow these steps: 1. Create an appropriate data structure to store directories and files. 2. Handle each operation in sequence. 3. Ensure directories are traversed correctly to support nested directory structures. Example ``` operations = [ (\\"mkdir\\", \\"/a\\", 0), (\\"mkdir\\", \\"/a/b\\", 0), (\\"addfile\\", \\"/a/b/file1.txt\\", 10), (\\"addfile\\", \\"/a/b/file2.txt\\", 20), (\\"getsize\\", \\"/a\\", 0) ] ``` Steps: 1. Create directory `/a`. 2. Create directory `/a/b`. 3. Add file `/a/b/file1.txt` with size 10. 4. Add file `/a/b/file2.txt` with size 20. 5. Query the size of `/a`, which should include the sizes of `/a/b/file1.txt` and `/a/b/file2.txt`. The function should return: ``` [30] ``` # Note Ensure to handle edge cases, including: * Nested directory structures. * Querying sizes for subdirectories that contain their own nested directories and files.","solution":"from typing import List, Tuple def file_system(operations: List[Tuple[str, str, int]]) -> List[int]: file_tree = {\'/\': {\'files\': {}, \'directories\': {}}} def add_directory(path): Adds a directory to the file system current = file_tree[\'/\'] for part in path.split(\'/\')[1:]: if part not in current[\'directories\']: current[\'directories\'][part] = {\'files\': {}, \'directories\': {}} current = current[\'directories\'][part] def add_file(path, size): Adds a file and its size to the file system parts = path.split(\'/\') filename = parts[-1] directory_path = \'/\'.join(parts[:-1]) current = file_tree[\'/\'] for part in directory_path.split(\'/\')[1:]: current = current[\'directories\'][part] current[\'files\'][filename] = size def get_size(path): Gets the total size of all files within the given directory current = file_tree[\'/\'] for part in path.split(\'/\')[1:]: current = current[\'directories\'][part] def calculate_size(directory): total_size = 0 for size in directory[\'files\'].values(): total_size += size for subdir in directory[\'directories\'].values(): total_size += calculate_size(subdir) return total_size return calculate_size(current) result = [] for operation, path, size in operations: if operation == \'mkdir\': add_directory(path) elif operation == \'addfile\': add_file(path, size) elif operation == \'getsize\': result.append(get_size(path)) return result"},{"question":"# Problem Statement You are tasked with verifying the validity of identifiers in a custom programming language and programming environment. An identifier is considered valid if it follows these rules: 1. It must start with either an underscore (`_`) or an alphabetical character (uppercase or lowercase). 2. The rest of the identifier (if present) may consist of underscores, alphabetical characters, or digits. 3. Identifiers are case-sensitive. Write a program that determines if a given identifier is valid according to the above rules. # Function Specifications You need to implement the following function: ```python def is_valid_identifier(identifier: str) -> bool: Determine if the provided identifier is valid. Parameters: identifier (str): The identifier string to be evaluated. Returns: bool: True if the identifier is valid, otherwise False. pass ``` # Input The function `is_valid_identifier` takes a single argument: * **identifier (1 <= len(identifier) <= 100)**: A string representing the identifier to be validated. # Output The function should return a boolean: * `True` if the identifier is valid according to the specified rules. * `False` otherwise. # Example Example 1: ```python print(is_valid_identifier(\\"_variable1\\")) # Output: True ``` Example 2: ```python print(is_valid_identifier(\\"2variable\\")) # Output: False ``` Example 3: ```python print(is_valid_identifier(\\"vari_able\\")) # Output: True ``` Example 4: ```python print(is_valid_identifier(\\"variable!name\\")) # Output: False ``` # Commentary The function leverages string characteristics and Python\'s string methods to validate the identifier. The primary tasks involve checking the initial character, ensuring all subsequent characters meet the criteria, and ensuring the overall length constraint aligns with typical identifier length expectations in many programming environments. Efficient string handling ensures the function performs well within the given constraints.","solution":"def is_valid_identifier(identifier: str) -> bool: Determine if the provided identifier is valid. Parameters: identifier (str): The identifier string to be evaluated. Returns: bool: True if the identifier is valid, otherwise False. if not identifier: return False if not (identifier[0].isalpha() or identifier[0] == \'_\'): return False for char in identifier[1:]: if not (char.isalnum() or char == \'_\'): return False return True"},{"question":"# Question: Processing and Analyzing Weather Data You are tasked with developing a Python function that fetches weather data from a public API and processes it to calculate average temperatures. The function should handle and parse the JSON response, then compute the average temperature for a given list of cities over a specified period. Function Signature ```python def fetch_average_temperatures(api_key: str, cities: list[str], start_date: str, end_date: str) -> dict[str, float]: pass ``` Input: - `api_key` (str): The API key for authenticating with the weather service. - `cities` (list[str]): A list of city names for which you want to fetch weather data. - `start_date` (str): The start date for the temperature data in the format \\"YYYY-MM-DD\\". - `end_date` (str): The end date for the temperature data in the format \\"YYYY-MM-DD\\". Output: - A dictionary where each key is a city name and the corresponding value is the average temperature (float) for the specified period. Constraints: - The function should handle HTTP errors gracefully by returning an empty dictionary on failure. - Ensure that the API key is securely handled and not hardcoded. - The function should handle cases where some cities may not have data for the entire given period by ignoring those cities in the output. Sample Execution: ```python # Environment setup (DON\'T hardcode these values in your code) api_key = \\"<your_weather_api_key>\\" # Fetch average temperatures average_temperatures = fetch_average_temperatures(api_key, [\\"London\\", \\"New York\\"], \\"2023-01-01\\", \\"2023-01-07\\") print(average_temperatures) # Expected: {\'London\': average_temperature_value, \'New York\': average_temperature_value} ``` Background: This exercise is meant to test your understanding of: - Handling authentication and secure communication with web APIs. - Parsing and processing JSON responses. - Computing average values from a dataset. - Catching and handling exceptions related to network interactions. **Example of the JSON structure from a weather API response**: ```json { \\"location\\": { \\"name\\": \\"London\\", \\"region\\": \\"\\", \\"country\\": \\"United Kingdom\\", \\"lat\\": 51.52, \\"lon\\": -0.11, \\"tz_id\\": \\"Europe/London\\", \\"localtime_epoch\\": 1613321952, \\"localtime\\": \\"2023-01-01 4:25\\" }, \\"forecast\\": { \\"forecastday\\": [ { \\"date\\": \\"2023-01-01\\", \\"day\\": { \\"avgtemp_c\\": 8.5 } }, { \\"date\\": \\"2023-01-02\\", \\"day\\": { \\"avgtemp_c\\": 7.2 } }, { \\"date\\": \\"2023-01-03\\", \\"day\\": { \\"avgtemp_c\\": 9.1 } } ] } } ``` Refer to the [Weather API documentation](https://www.weatherapi.com/docs/) for more details.","solution":"import requests from datetime import datetime, timedelta def fetch_average_temperatures(api_key: str, cities: list[str], start_date: str, end_date: str) -> dict[str, float]: base_url = \\"http://api.weatherapi.com/v1/history.json\\" results = {} start_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_dt = datetime.strptime(end_date, \\"%Y-%m-%d\\") total_days = (end_dt - start_dt).days + 1 for city in cities: total_temperature = 0.0 days_counted = 0 for n in range(total_days): current_date = (start_dt + timedelta(days=n)).strftime(\\"%Y-%m-%d\\") params = { \'key\': api_key, \'q\': city, \'dt\': current_date } try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() day_data = data.get(\'forecast\', {}).get(\'forecastday\', [])[0].get(\'day\', {}) avg_temp = day_data.get(\'avgtemp_c\') if avg_temp is not None: total_temperature += avg_temp days_counted += 1 except (requests.RequestException, KeyError, IndexError): continue if days_counted > 0: results[city] = total_temperature / days_counted return results"},{"question":"# Problem: Find the Longest Increasing Subsequence Given an array of integers, implement a function to find the length of the longest increasing subsequence (LIS) using a dynamic programming approach. **Input Format** - An integer `n` (1 ≤ n ≤ 10^5) indicating the size of the array. - A single line with `n` space-separated integers representing the array elements, where each integer ( a_i ) (1 ≤ ( a_i ) ≤ 10^9). **Output Format** - Return a single integer which is the length of the longest increasing subsequence in the array. **Constraints** - The time complexity of your solution should be O(n log n). - Ensure your code handles large inputs efficiently. **Example** *Input:* ``` 8 10 22 9 33 21 50 41 60 ``` *Output:* ``` 5 ``` # Detailed Requirements 1. Design a function `longest_increasing_subsequence` which utilizes a combination of dynamic programming and binary search to determine the length of the LIS. 2. The function should optimize time complexity to O(n log n) by employing a technique such as the patience sorting approach with binary search. 3. Provide adequate comments and documentation to explain the logic and flow of your implementation.","solution":"import bisect def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence (LIS) in the given array. This function uses a dynamic programming approach with a binary search optimization to achieve a time complexity of O(n log n). Parameters: arr (List[int]): The input array of integers. Returns: int: The length of the longest increasing subsequence. if not arr: return 0 # Initialize an empty list to keep track of the ends of increasing subsequences lis_ends = [] for num in arr: # Use binary search to find the insertion point of the current number in lis_ends pos = bisect.bisect_left(lis_ends, num) # If the number is larger than any element in lis_ends, add it to the end if pos == len(lis_ends): lis_ends.append(num) else: # If there\'s a larger or equal element at pos, replace it with num lis_ends[pos] = num # The length of lis_ends is the length of the longest increasing subsequence return len(lis_ends)"},{"question":"# Scenario You are building a feature for an ecommerce platform that helps customers find affordable products quickly. The platform regularly updates its list of products, and you need to create a functionality that finds the top three cheapest products currently available. # Task Write a Python function, `get_top_three_cheapest_products()`, that retrieves the current list of products from a given API and identifies the top three cheapest products. The function should return the details of these products. # Requirements 1. **Function Signature**: ```python def get_top_three_cheapest_products(api_url: str) -> list[dict[str, str]]: ``` 2. **Input**: - `api_url` (str): A string representing the URL endpoint to fetch the product data from. 3. **Output**: A list of three dictionaries, each containing the following keys and their corresponding values: * `Product Name`: Name of the product. * `Price ()`: Price of the product formatted to two decimal places. * `Category`: Category of the product. * `Rating`: Average customer rating for the product formatted to one decimal place. 4. **Constraints**: * Handle cases where the total number of products is less than three. * Use appropriate error handling for network issues, JSON parsing errors, or unexpected data structures. * Ensure products are sorted by price in ascending order. # Example ```python [ { \'Product Name\': \'USB-C Cable\', \'Price ()\': \'5.99\', \'Category\': \'Electronics\', \'Rating\': \'4.5\' }, { \'Product Name\': \'Wireless Mouse\', \'Price ()\': \'12.49\', \'Category\': \'Electronics\', \'Rating\': \'4.7\' }, { \'Product Name\': \'Notebook\', \'Price ()\': \'2.99\', \'Category\': \'Stationery\', \'Rating\': \'4.1\' } ] ``` # Additional Guidelines * You may use any Python HTTP client library such as `requests`. * Ensure your function is efficient and includes error handling for robustness. * Write a few test cases to validate your implementation.","solution":"import requests from typing import List, Dict def get_top_three_cheapest_products(api_url: str) -> List[Dict[str, str]]: try: response = requests.get(api_url) response.raise_for_status() products = response.json() if not isinstance(products, list): raise ValueError(\\"API did not return a list of products\\") # Sort products by price in ascending order sorted_products = sorted(products, key=lambda x: float(x[\'price\'])) top_three_products = [] for product in sorted_products[:3]: formatted_product = { \'Product Name\': product[\'name\'], \'Price ()\': f\\"{float(product[\'price\']):.2f}\\", \'Category\': product[\'category\'], \'Rating\': f\\"{float(product[\'rating\']):.1f}\\" } top_three_products.append(formatted_product) return top_three_products except requests.RequestException as e: print(f\\"An error occurred while making the API request: {e}\\") return [] except (ValueError, KeyError, TypeError) as e: print(f\\"An error occurred while processing the product data: {e}\\") return []"},{"question":"# Problem Statement Given a string `s`, your task is to compute all possible permutations of the string that do not contain any consecutive duplicate characters. Write a function that returns these valid permutations in lexicographical order. **Function Signature**: ```python def generate_permutations(s: str) -> List[str]: ``` # Input: * `s` (str): A string containing only lowercase alphabetic characters. # Output: * A list of strings, with each string representing a valid permutation of `s` that does not have consecutive duplicate characters, ordered lexicographically. # Example: ```python s = \\"aab\\" print(generate_permutations(s)) # Output: [\'aba\'] s = \\"abc\\" print(generate_permutations(s)) # Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] ``` # Constraints: * The length of `s` will not exceed 10. # Notes: - You should first generate all permutations of the string `s`. - You then need to filter out the permutations that contain consecutive duplicate characters. - Make sure the final list of permutations is sorted in lexicographical order. # Hints: - Use itertools.permutations to generate all possible permutations. - Be careful with duplicate permutations if the input string contains duplicate characters. - Sorting may help you ensure the correct order of permutations.","solution":"from typing import List import itertools def generate_permutations(s: str) -> List[str]: Returns all valid permutations of the string `s` that do not have consecutive duplicate characters, sorted in lexicographical order. def has_consecutive_duplicates(s): # Helper function to check for consecutive duplicates for i in range(1, len(s)): if s[i] == s[i-1]: return True return False # Generate all unique permutations unique_permutations = set(itertools.permutations(s)) # Convert each tuple permutation to a string and filter valid_permutations = [\'\'.join(p) for p in unique_permutations if not has_consecutive_duplicates(\'\'.join(p))] # Return the sorted list of valid permutations return sorted(valid_permutations)"},{"question":"# Task Description Implement a function that takes a list of integers and returns the number of unique triplets (i, j, k) such that i < j < k and the sum of the triplet is zero. # Function Signature ```python def count_unique_triplets(nums: List[int]) -> int: pass ``` # Input - A list of integers `nums` representing the sequence. (0 ≤ len(nums) ≤ 10^4, -10^3 ≤ nums[i] ≤ 10^3) # Output - Return an integer representing the number of unique triplets (i, j, k) such that i < j < k and `nums[i] + nums[j] + nums[k] == 0`. # Constraints - Do not use the same element more than once to form a triplet. - The solution should be efficient and handle large inputs. # Example ```python assert count_unique_triplets([-1, 0, 1, 2, -1, -4]) == 2 assert count_unique_triplets([0, 0, 0]) == 1 assert count_unique_triplets([1, 1, -2]) == 1 assert count_unique_triplets([]) == 0 assert count_unique_triplets([3, -1, -7, 2, 5, -3, 6]) == 1 ``` # Special Note - Aim to implement an efficient solution with a time complexity better than O(n^3). - Consider sorting the input array first and using a two-pointer technique for an O(n^2) solution.","solution":"from typing import List def count_unique_triplets(nums: List[int]) -> int: if len(nums) < 3: return 0 nums.sort() unique_triplets = set() for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: triplet_sum = nums[i] + nums[left] + nums[right] if triplet_sum == 0: unique_triplets.add((nums[i], nums[left], nums[right])) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif triplet_sum < 0: left += 1 else: right -= 1 return len(unique_triplets)"},{"question":"Problem Statement You are given a list of words from a text file. Each line in the file represents a single word. Your task is to identify and return a list of all the words in the file that are palindromes. A palindrome is a word that reads the same backward as forward, ignoring case. # Input - A single string `filepath` representing the path to the text file. # Output - A list of strings, each representing a palindrome found in the file. # Constraints - The text file contains at most 10,000 words. - Each word has a maximum length of 30 characters. - Words consist only of alphabetical characters. # Example Consider the following words in the file: - \\"Racecar\\" - \\"Level\\" - \\"Algorithm\\" - \\"Rotator\\" The function `find_palindromes(\'words.txt\')` should return `[\'Racecar\', \'Level\', \'Rotator\']` because these words are palindromes. # Guidance To determine if a word is a palindrome, normalize the word by converting it to lowercase and compare it to its reverse. # Sample Function Definition ```python def find_palindromes(filepath: str) -> list[str]: # Your code here ``` # Note Ensure your solution reads the input file correctly and handles any edge cases appropriately, such as different word lengths and varying cases.","solution":"def find_palindromes(filepath: str) -> list[str]: Reads a file and returns a list of palindromes found in the file. Words are case-insensitive palindromes. Parameters: filepath (str): The path to the text file containing words. Returns: list[str]: A list of palindromic words. palindromes = [] with open(filepath, \'r\') as file: for line in file: word = line.strip() if word.lower() == word[::-1].lower(): palindromes.append(word) return palindromes"},{"question":"**Scenario**: You are given an array `queries` where `queries[i] = (a, b, c)` corresponds to a query for the greatest common divisor (GCD) of the numbers in the subarray `array[a:b+1]` followed by a constraint check to see if the result is divisible by `c`. Implement the following class and methods. **Instructions**: - Implement the `ArrayProcessor` class as described. - The `update` method should update the element at a specific index. - The `query_gcd` method should return a boolean indicating if the GCD of the subarray is divisible by the provided `c`. **Function Signature**: The function signatures should be as follows: ```python class ArrayProcessor: def __init__(self, array: List[int]): # Initialization code goes here def update(self, index: int, value: int): # Code to update array index goes here def query_gcd(self, a: int, b: int, c: int) -> bool: # Code to calculate GCD and check divisibility goes here ``` # Expected Input and Output **Input**: - `array` (List[int]): Initial array of integers. - `queries` (List[Tuple[int, int, int]]): List of queries, where each query is represented as a tuple `(a, b, c)`. **Output**: - The `query_gcd` method should return `True` if the GCD of array elements between indices `a` and `b` (inclusive) is divisible by `c`, otherwise `False`. # Sample Input: ```python array = [24, 36, 48, 60] queries = [ (0, 2, 12), # Check if GCD(24, 36, 48) % 12 == 0 (1, 3, 6) # Check if GCD(36, 48, 60) % 6 == 0 ] ap = ArrayProcessor(array) print(ap.query_gcd(*queries[0])) # Output should be True print(ap.query_gcd(*queries[1])) # Output should be True ap.update(2, 50) # Update array[2] to 50 print(ap.query_gcd(*queries[0])) # Output should be False after update since GCD(24, 36, 50) % 12 != 0 ``` **Constraints**: - `1 <= len(array) <= 1000` - `1 <= a <= b < len(array)` - `1 <= c <= 1000` - `1 <= array[i] <= 1000` - Number of updates and queries will not exceed 1000. **Performance Requirements**: The solution should handle up to O(n log n) operations for GCD calculations efficiently.","solution":"from math import gcd from typing import List, Tuple from functools import reduce class ArrayProcessor: def __init__(self, array: List[int]): self.array = array def update(self, index: int, value: int): self.array[index] = value def query_gcd(self, a: int, b: int, c: int) -> bool: subarray = self.array[a:b+1] gcd_result = reduce(gcd, subarray) return gcd_result % c == 0"},{"question":"# Question: Implement a Unique Alphabet Permutation Generator Description Implement a function that generates all the unique permutations of the given string of lowercase English letters. The input string will have no more than 6 characters. Input - A string `s` (1 ≤ len(s) ≤ 6) consisting of lowercase English letters. Output - A list of strings, each representing a unique permutation of the input string, sorted lexicographically. Constraints 1. If the input is not a string, the function should raise a `TypeError` with the message: `Input value of [string={s}] must be a string`. 2. If the length of the input string is greater than 6 or less than 1, raise a `ValueError` with the message: `Input value of [string={s}] must have length between 1 and 6`. Example ```plaintext Input: \\"abc\\" Output: [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] Input: \\"a\\" Output: [\\"a\\"] Input: \\"aab\\" Output: [\\"aab\\", \\"aba\\", \\"baa\\"] ``` Additional Notes - Generate all permutations of the input string. - You should ensure the uniqueness of the permutations. - The permutations should be sorted in lexicographical order. Template ```python from itertools import permutations def unique_permutations(s: str) -> list: if not isinstance(s, str): msg = f\\"Input value of [string={s}] must be a string\\" raise TypeError(msg) if len(s) < 1 or len(s) > 6: msg = f\\"Input value of [string={s}] must have length between 1 and 6\\" raise ValueError(msg) perm_set = set(permutations(s)) unique_perms = sorted([\'\'.join(p) for p in perm_set]) return unique_perms # Example Usage print(unique_permutations(\\"abc\\")) # Output: [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] print(unique_permutations(\\"a\\")) # Output: [\\"a\\"] print(unique_permutations(\\"aab\\")) # Output: [\\"aab\\", \\"aba\\", \\"baa\\"] ``` Explanation - The function checks if the input is a string and raises a `TypeError` if not. - It ensures the length of the string is between 1 and 6, raising a `ValueError` if not. - Uses `itertools.permutations` to generate all permutations, and a set to ensure uniqueness. - Converts the set back to a list of strings, sorts them lexicographically, and returns the result.","solution":"from itertools import permutations def unique_permutations(s: str) -> list: if not isinstance(s, str): msg = f\\"Input value of [string={s}] must be a string\\" raise TypeError(msg) if len(s) < 1 or len(s) > 6: msg = f\\"Input value of [string={s}] must have length between 1 and 6\\" raise ValueError(msg) perm_set = set(permutations(s)) unique_perms = sorted([\'\'.join(p) for p in perm_set]) return unique_perms"},{"question":"# Question: Implement a Simple Genetic Algorithm You are required to implement a simple Genetic Algorithm (GA) for maximizing a given objective function. The GA should be able to evolve a population of candidate solutions through selection, crossover, and mutation operations. Specifically, you need to implement the following methods in the `GeneticAlgorithm` class: 1. `select_parents(self, population: list[list[int]], fitness: list[float]) -> list[list[int]]`: This method should select pairs of parents from the population based on their fitness scores. Use a roulette-wheel selection approach. 2. `crossover(self, parent1: list[int], parent2: list[int], crossover_rate: float) -> list[int]`: This method should perform crossover between two parents with a fixed crossover rate. If crossover is not performed, return one of the parents unchanged. 3. `mutate(self, individual: list[int], mutation_rate: float) -> list[int]`: This method should apply mutation to an individual with a given mutation rate. Each gene in the individual has a chance equal to the mutation rate to be flipped (0 becomes 1 and vice versa). 4. `evolve(self, population: list[list[int]], fitness_function: callable, generations: int, crossover_rate: float, mutation_rate: float) -> list[int]`: This method should apply the genetic algorithm over a specified number of generations and return the best individual found. Inputs: - `population`: A list of candidates, where each candidate is represented as a list of integers (0s and 1s). - `fitness_function`: A function that takes an individual and returns a fitness score. - `generations`: The number of generations to run the GA. - `crossover_rate`: The probability of performing a crossover operation. - `mutation_rate`: The probability of performing a mutation operation on each gene. Outputs: - The method `evolve` should return the best individual found after the specified number of generations. Constraints: - The initial population consists of binary vectors (lists of 0s and 1s). - The fitness function should be maximized. - The crossover_rate and mutation_rate are float values between 0 and 1. # Example Usage: ```python # Fitness function def fitness_function(individual): return sum(individual) # Initial population population = [ [0, 1, 1, 0, 1], [1, 0, 0, 1, 1], [0, 0, 1, 1, 0], [1, 1, 0, 0, 0] ] # Parameters generations = 10 crossover_rate = 0.7 mutation_rate = 0.01 # Create the GeneticAlgorithm object ga = GeneticAlgorithm() # Evolve the population best_individual = ga.evolve(population, fitness_function, generations, crossover_rate, mutation_rate) # Output the best individual print(best_individual) ``` # Additional Details: 1. **Roulette-Wheel Selection**: The probability of selecting an individual is proportional to its fitness score. 2. **Crossover Operation**: Generate a random crossover point and swap the segments of the parents at this point to create a new individual. 3. **Mutation Operation**: Flip each gene of the individual with a probability equal to the mutation rate. Implementing these steps will help you understand the basics of Genetic Algorithms and how they are used to solve optimization problems.","solution":"import random class GeneticAlgorithm: def select_parents(self, population, fitness): total_fitness = sum(fitness) selection_probs = [f / total_fitness for f in fitness] parents = [] for _ in range(len(population)): parent = population[self.roulette_wheel_selection(selection_probs)] parents.append(parent) return parents def roulette_wheel_selection(self, selection_probs): r = random.uniform(0, 1) cumulative_prob = 0.0 for i, prob in enumerate(selection_probs): cumulative_prob += prob if r < cumulative_prob: return i return len(selection_probs) - 1 def crossover(self, parent1, parent2, crossover_rate): if random.random() > crossover_rate: return parent1 if random.random() < 0.5 else parent2 crossover_point = random.randint(1, len(parent1) - 1) return parent1[:crossover_point] + parent2[crossover_point:] def mutate(self, individual, mutation_rate): return [ (gene if random.random() > mutation_rate else 1 - gene) for gene in individual ] def evolve(self, population, fitness_function, generations, crossover_rate, mutation_rate): for _ in range(generations): fitness = [fitness_function(individual) for individual in population] parents = self.select_parents(population, fitness) next_population = [] for i in range(len(population) // 2): parent1, parent2 = random.sample(parents, 2) child1 = self.crossover(parent1, parent2, crossover_rate) child2 = self.crossover(parent2, parent1, crossover_rate) next_population.append(self.mutate(child1, mutation_rate)) next_population.append(self.mutate(child2, mutation_rate)) population = next_population fitness = [fitness_function(individual) for individual in population] return population[fitness.index(max(fitness))]"},{"question":"# Problem Statement Implement a function `binary_arithmetic(operation: str, num1: str, num2: str, length: int) -> str` that performs a specified bitwise arithmetic operation on two binary strings and returns the result as a binary string padded/truncated to a specified length. # Requirements: - The function should accept the following parameters: - `operation` (str): A string indicating the bitwise arithmetic operation to be performed (`\\"AND\\"`, `\\"OR\\"`, `\\"XOR\\"`, `\\"NOT\\"`). - `num1` (str): A binary string representing the first operand. - `num2` (str): A binary string representing the second operand (not used for `\\"NOT\\"` operation). - `length` (int): The desired length of the resulting binary string. - Supported operations: - `\\"AND\\"`: Perform a bitwise AND on each corresponding pair of bits from `num1` and `num2`. - `\\"OR\\"`: Perform a bitwise OR on each corresponding pair of bits from `num1` and `num2`. - `\\"XOR\\"`: Perform a bitwise XOR on each corresponding pair of bits from `num1` and `num2`. - `\\"NOT\\"`: Invert all bits in `num1`. - Pad the resulting binary string with leading zeros if it\'s shorter than the specified length. - Truncate the leading bits if the resulting binary string is longer than the specified length. # Expected Input and Output: - **Input**: - `operation` (str): The bitwise operation to perform. - `num1` (str): First binary string. - `num2` (str): Second binary string (except for `\\"NOT\\"` operation). - `length` (int): Desired length of the result binary string. Constraints: - The binary strings `num1` and `num2` will only contain characters \'0\' and \'1\'. - The length of `num1` and `num2` will be between 1 and 1000. - The `length` parameter will be between 1 and 1000. - The `operation` parameter will be one of `\\"AND\\"`, `\\"OR\\"`, `\\"XOR\\"`, or `\\"NOT\\"`. # Example Usage: ```python def binary_arithmetic(operation: str, num1: str, num2: str, length: int) -> str: ... # Examples: binary_arithmetic(\\"AND\\", \\"1101\\", \\"1011\\", 4) -> \\"1001\\" binary_arithmetic(\\"OR\\", \\"1101\\", \\"1011\\", 5) -> \\"01111\\" binary_arithmetic(\\"XOR\\", \\"1101\\", \\"1011\\", 4) -> \\"0110\\" binary_arithmetic(\\"NOT\\", \\"1101\\", \\"\\", 4) -> \\"0010\\" binary_arithmetic(\\"AND\\", \\"0011\\", \\"0101\\", 6) -> \\"000001\\" binary_arithmetic(\\"OR\\", \\"0011\\", \\"0101\\", 3) -> \\"111\\" binary_arithmetic(\\"XOR\\", \\"0011\\", \\"0101\\", 5) -> \\"00010\\" binary_arithmetic(\\"NOT\\", \\"0011\\", \\"\\", 6) -> \\"111100\\" ``` # Notes: - Ensure to handle leading zeroes correctly for padding. - Make sure the function returns exactly `length` bits, handling padded and truncated cases appropriately.","solution":"def binary_arithmetic(operation: str, num1: str, num2: str, length: int) -> str: Perform specified bitwise operation on two binary strings and return the result as a binary string of specified length. Parameters: operation (str): Bitwise operation to be performed (\'AND\', \'OR\', \'XOR\', \'NOT\'). num1 (str): First binary operand. num2 (str): Second binary operand (ignored for \'NOT\'). length (int): Desired length of the resulting binary string. Returns: str: Result of the bitwise operation as a binary string of specified length. if operation == \\"NOT\\": result = \'\'.join(\'1\' if bit == \'0\' else \'0\' for bit in num1) else: if operation == \\"AND\\": result = \'\'.join(\'1\' if num1[i] == \'1\' and num2[i] == \'1\' else \'0\' for i in range(len(num1))) elif operation == \\"OR\\": result = \'\'.join(\'1\' if num1[i] == \'1\' or num2[i] == \'1\' else \'0\' for i in range(len(num1))) elif operation == \\"XOR\\": result = \'\'.join(\'1\' if num1[i] != num2[i] else \'0\' for i in range(len(num1))) else: raise ValueError(f\\"Unsupported operation: {operation}\\") # Adjust the result to the specified length, padded with zeros if necessary if len(result) < length: result = result.zfill(length) elif len(result) > length: result = result[-length:] return result"},{"question":"# Problem Statement A company wants to analyze the popularity of its product by tracking the sale price changes over several days. You are tasked with implementing a feature that generates an array of changes. Given a list of integers representing the sale prices of a product over several days, you have to implement a function `calculate_price_changes` that returns a new list where each element represents the difference between the selling price of the product on the current day and the previous day, starting from the second day in the sequence. # Function Signature ```python def calculate_price_changes(prices: List[int]) -> List[int]: ``` # Input - `prices`: A list of integers representing the sale prices of a product over `n` days, `1 <= n <= 10^5`. Each price is an integer in the range `[0, 10^4]`. # Output - Returns a list of integers where each integer represents the change in price from the previous day. # Constraints - The list `prices` will have at least one element and at most `10^5` elements. - Prices can include zero, which means the product was given away for free that day. # Example ```python prices = [100, 105, 103, 107, 110] result = calculate_price_changes(prices) # Output: [5, -2, 4, 3] # Explanation: # Day 2: 105 - 100 = 5 # Day 3: 103 - 105 = -2 # Day 4: 107 - 103 = 4 # Day 5: 110 - 107 = 3 ``` # Detailed Description 1. **Algorithm to Calculate Changes** - Start by initializing an empty list `changes`. - Iterate through the `prices` list starting from the second element. - For each day, compute the difference between the current day\'s price and the previous day\'s price. - Append this difference to the `changes` list. - Continue this process until the end of the list is reached. 2. **Edge Case** - If the `prices` list contains only one element, return an empty list, as there cannot be a price change without at least two measurements. # Code Template ```python from typing import List def calculate_price_changes(prices: List[int]) -> List[int]: if len(prices) < 2: return [] changes = [] for i in range(1, len(prices)): changes.append(prices[i] - prices[i - 1]) return changes ``` Validate your implementation with the provided example and ensure it handles edge cases like lists with single elements or prices remaining the same over consecutive days correctly.","solution":"from typing import List def calculate_price_changes(prices: List[int]) -> List[int]: if len(prices) < 2: return [] changes = [] for i in range(1, len(prices)): changes.append(prices[i] - prices[i - 1]) return changes"},{"question":"# Problem Statement Implement a function named `autocomplete` to build an auto-completion system for a given list of words. The function should provide the top suggestions based on the prefix entered by the user, employing a trie (prefix tree) structure to efficiently store and query the terms. # Function Signature ```python class AutocompleteSystem: def __init__(self, words: List[str]): Initialize the auto-completion system with the provided list of words. Parameters: words (List[str]): A list of words to be used for auto-completion. pass def insert(self, word: str) -> None: Insert a word into the auto-completion system. Parameters: word (str): The word to be inserted. pass def get_suggestions(self, prefix: str) -> List[str]: Retrieve the top 5 suggestions for the given prefix. Parameters: prefix (str): The prefix string for which suggestions are to be provided. Returns: List[str]: A list of up to 5 suggestions matching the prefix. pass ``` # Input - `words` is a list of unique strings where each string represents a word. - `word` is a string representing a single word to be inserted. - `prefix` is a string representing the prefix for which suggestions are to be retrieved. # Output - For the instantiation and insertion, there is no output. - The function `get_suggestions` returns a list of up to 5 words from the system that start with the given prefix, sorted in lexicographical order. If fewer than 5 words match the prefix, return all matching words. # Constraints - The length of each word and prefix is between 1 and 100 characters. - The words list contains between 1 and 10^4 words. - The words contain only lowercase English letters. # Performance Requirements - The auto-completion system should efficiently handle lookups and insertions. - The `get_suggestions` method should run in sub-linear time relative to the total size of the words list, leveraging the trie structure. # Scenarios 1. **Basic Functionality**: Implement the trie-based storage and ensure words can be inserted and retrieved based on prefix efficiently. 2. **Edge Cases**: Handle cases where no words match the prefix or the prefix length exceeds the length of any word in the system. 3. **Performance**: Ensure that the system can efficiently provide suggestions even as the number of words grows significantly, potentially up to the maximum constraint. # Example ```python autocomplete = AutocompleteSystem([\\"dog\\", \\"deer\\", \\"deal\\", \\"cat\\", \\"cut\\", \\"cute\\"]) print(autocomplete.get_suggestions(\\"de\\")) # Should return [\\"deal\\", \\"deer\\"] print(autocomplete.get_suggestions(\\"cu\\")) # Should return [\\"cut\\", \\"cute\\"] print(autocomplete.get_suggestions(\\"d\\")) # Should return [\\"deal\\", \\"deer\\", \\"dog\\"] autocomplete.insert(\\"dot\\") print(autocomplete.get_suggestions(\\"do\\")) # Should return [\\"dog\\", \\"dot\\"] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AutocompleteSystem: def __init__(self, words): self.root = TrieNode() for word in words: self.insert(word) def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def get_suggestions(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] suggestions = [] self.dfs(node, prefix, suggestions) return sorted(suggestions)[:5] def dfs(self, node, prefix, suggestions): if node.is_end_of_word: suggestions.append(prefix) for char in node.children: self.dfs(node.children[char], prefix + char, suggestions)"},{"question":"# Problem Statement As part of a new navigation system for delivery drones, you need to design a function that calculates the shortest path through a series of points that forms a square grid. The drones can only move left, right, up, or down, one step at a time. They start at the top-left corner and need to reach the bottom-right corner. Your task is to implement a function that returns the number of unique paths the drone can take to reach its destination on an `m x n` grid. # Function Signature ```python def unique_paths(m: int, n: int) -> int: pass ``` # Input * Two integers `m` and `n` such that `1 <= m, n <= 100` — the dimensions of the grid. # Output * An integer representing the number of unique paths from the top-left to the bottom-right corner. # Constraints * The function should handle edge cases such as the smallest possible grid size (1x1). # Examples ```python >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(1, 1) 1 ``` # Notes 1. The drone can only move to the right or down at any point in time. 2. The function should be efficient and able to handle the upper limit within a reasonable time frame. 3. The solution should ideally use dynamic programming for efficiency. --- This question aligns with the given set by focusing on algorithmic problem solving and efficiency. It requires an understanding of combinatorial mathematics, which complements the original sample\'s emphasis on mathematical generation, while introducing a different scenario and set of constraints.","solution":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from top-left to bottom-right in an m x n grid. # Create a 2D array filled with 1s, which will hold the number of ways to reach each cell. dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from cell (1, 1) because the first row and first column # can only be reached by one path, either from the left or from above. for i in range(1, m): for j in range(1, n): # Each cell can be reached either from the cell above it or from the cell to the left of it. dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will contain the number of unique paths to reach it. return dp[-1][-1]"},{"question":"# Problem Statement You are given a string `s` consisting of lower case English letters and a list of words `words` where each word can only consist of lower case English letters. Implement a function `find_substring_indices(s: str, words: list[str]) -> list[int]` which finds all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. Write a function to return the list of all such starting indices. The order of output does not matter. # Function Signature ```python def find_substring_indices(s: str, words: list[str]) -> list[int]: ``` # Input - `s`: A string of lower case English letters. - `words`: A list of words, where each word consists of lowercase English letters. # Output - Return a list of integers representing the starting indices of substrings in `s` that are a concatenation of each of the words in `words`. # Constraints - The length of `s` is between `1` and `10^4`. - The length of each word in `words` is between `1` and `10^4`. - The total number of words does not exceed `5000`. - Words can be repeated in `words`. # Example ```python >>> find_substring_indices( ... \\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substring_indices( ... \\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) [] >>> find_substring_indices( ... \\"barfoofoobarthefoobarman\\", [\\"bar\\",\\"foo\\",\\"the\\"]) [6, 9, 12] >>> find_substring_indices( ... \\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"good\\"]) [8] ``` # Note Write your function in a clean and organized manner with proper handling of edge cases and constraints.","solution":"from collections import Counter def find_substring_indices(s, words): if not s or not words: return [] word_len = len(words[0]) total_len = word_len * len(words) word_count = Counter(words) result = [] for i in range(word_len): left = i right = i current_count = Counter() while right + word_len <= len(s): word = s[right:right + word_len] right += word_len if word in word_count: current_count[word] += 1 while current_count[word] > word_count[word]: current_count[s[left:left + word_len]] -= 1 left += word_len if right - left == total_len: result.append(left) else: current_count.clear() left = right return result"},{"question":"# Problem Statement You have been hired to implement a custom string compression algorithm. The goal is to compress a string by using the counts of repeated characters. The function should handle various edge cases and retain the original character if it has no duplicates. # Function Signature ```python def compress_string(s: str) -> str: Compresses the given string by collapsing consecutive repeated characters into the character followed by the count of repeats. :param s: The input string to be compressed. :return: The compressed version of the input string. ``` # Input * **s**: a string of characters, `s` where (0 leq text{len(s)} leq 10^5). # Output * The function should return a new compressed string. # Constraints 1. The input string may contain uppercase and lowercase letters only. 2. The function must handle an empty string and return it as is. 3. The compressed string should be shorter than or equal to the original string in length. 4. If the length of the compressed string is greater than or equal to the original string, return the original string. # Example ```python >>> compress_string(\\"aaabbcccc\\") \\"a3b2c4\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"\\") \\"\\" ``` # Instructions 1. Implement the `compress_string` function according to the specifications above. 2. Ensure your function passes the provided example cases as well as any additional edge cases you can think of. 3. Optimize for readability and efficiency within the given constraints.","solution":"def compress_string(s: str) -> str: Compresses the given string by collapsing consecutive repeated characters into the character followed by the count of repeats. :param s: The input string to be compressed. :return: The compressed version of the input string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + (str(count) if count > 1 else \'\')) count = 1 compressed.append(s[-1] + (str(count) if count > 1 else \'\')) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Question: Implement a Voting System for Roaring Elephants Game You are required to implement functions to manage a voting system for a fictional game called \\"Roaring Elephants\\". The voting system allows participants to vote for their favorite players. Each participant can only vote once, and votes must be tallied correctly to determine the winner at any point in time. Implement the following three functions: 1. `cast_vote(participant_name: str, player_name: str) -> str` * This function accepts the name of the participant and the name of the player they want to vote for. * If the participant has already voted, return \\"Error: Participant has already voted.\\". * If the vote is successful, return \\"Vote cast successfully.\\". 2. `count_votes() -> Dict[str, int]` * This function should return a dictionary where the keys are player names and the values are the count of votes each player has received. 3. `find_winner() -> str` * This function should return the player name with the highest number of votes. * If there is a tie, return \\"Tie\\" as the result. # Constraints: - Participant names are unique and consist of alphabetic characters only. - Player names consist of alphabetic characters only. - There are at most 10^3 participants and 10^2 players. - Votes must be cast in a case-insensitive manner (e.g., \\"Alice\\" and \\"alice\\" should be considered the same participant). # Example Usage: ```python >>> cast_vote(\\"Alice\\", \\"Dumbo\\") \'Vote cast successfully.\' >>> cast_vote(\\"Bob\\", \\"Manny\\") \'Vote cast successfully.\' >>> cast_vote(\\"Alice\\", \\"Manny\\") \'Error: Participant has already voted.\' >>> count_votes() {\'Dumbo\': 1, \'Manny\': 1} >>> cast_vote(\\"Charlie\\", \\"Dumbo\\") \'Vote cast successfully.\' >>> find_winner() \'Dumbo\' >>> cast_vote(\\"David\\", \\"Manny\\") \'Vote cast successfully.\' >>> find_winner() \'Tie\' ``` Implement the functions with appropriate error handling and considerations for performance.","solution":"from typing import Dict votes = {} # Dictionary to store who each participant voted for vote_counts = {} # Dictionary to store count of votes for each player def cast_vote(participant_name: str, player_name: str) -> str: participant_name = participant_name.lower() if participant_name in votes: return \\"Error: Participant has already voted.\\" player_name = player_name.lower() votes[participant_name] = player_name if player_name not in vote_counts: vote_counts[player_name] = 0 vote_counts[player_name] += 1 return \\"Vote cast successfully.\\" def count_votes() -> Dict[str, int]: return {k.capitalize(): v for k, v in vote_counts.items()} def find_winner() -> str: if not vote_counts: return \\"No votes have been cast.\\" sorted_votes = sorted(vote_counts.items(), key=lambda item: item[1], reverse=True) if len(sorted_votes) > 1 and sorted_votes[0][1] == sorted_votes[1][1]: return \\"Tie\\" return sorted_votes[0][0].capitalize()"},{"question":"# Binary Search Implementation You are required to implement a binary search algorithm. Given a sorted list of integers and a target integer, your task is to determine whether the target integer exists in the list. If it exists, return its index. If it does not exist, return -1. Function Signature: ```python def binary_search(nums: list[int], target: int) -> int: ``` Input: - **nums**: A sorted list of integers. - **target**: An integer which you need to search in the list. Output: - An integer representing the index of the target if it is found in the list, otherwise -1. Constraints: - The array will have no duplicate elements. Examples: ```python nums = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 assert binary_search(nums, target) == 4 nums = [10, 20, 30, 40, 50] target = 25 assert binary_search(nums, target) == -1 nums = [-5, -3, 0, 2, 4] target = -3 assert binary_search(nums, target) == 1 ``` Scenario: Imagine you are managing a library catalog system, where book identifiers are stored in a sorted list. You need to efficiently locate whether a particular book identifier exists in the catalog, and if so, return the position of the book in the catalog list. This ensures quick retrieval and management of book data.","solution":"def binary_search(nums: list[int], target: int) -> int: Performs binary search on a sorted list to find the index of the target element. Parameters: nums (list[int]): A sorted list of integers. target (int): The integer to be searched in the list. Returns: int: The index of the target element if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question Context In computer networks, a common task is to ensure messages are delivered accurately and in order. One way to achieve this is through packet reassembly after transmission. Each message is broken down into packets of a fixed size, except possibly the last packet, and these packets are sent separately to be reassembled at the destination. Imagine you are building a network simulator that transmits messages as packets. Your task is to implement functions to split a message into packets and reassemble them back into the original message. Problem Statement Implement two functions, `split_message` and `reassemble_message`, to handle packetization and reconstruction of messages. 1. **split_message(message: str, packet_size: int) -> list[str]** - **Input**: - `message`: A string representing the original message to be sent. - `packet_size`: An integer representing the fixed size of each packet. - **Output**: - A list of strings where each string is a packet containing a portion of the original message. - **Example**: ```python >>> split_message(\\"HelloWorld\\", 4) [\'Hell\', \'oWor\', \'ld\'] ``` 2. **reassemble_message(packets: list[str]) -> str** - **Input**: - `packets`: A list of strings representing the packets received in order. - **Output**: - A string representing the reassembled original message. - **Example**: ```python >>> reassemble_message([\'Hell\', \'oWor\', \'ld\']) \'HelloWorld\' ``` 3. **Constraints**: - `1 <= len(message) <= 10^5` - `1 <= packet_size <= 10^3` Additional Requirements - Your implementation should handle edge cases such as: - Empty message string. - Single-character message string. - Message length being an exact multiple of the packet size. - All packets of the same size except possibly the last one. - Aim for a time-complexity-efficient solution to handle the upper input limits gracefully.","solution":"def split_message(message: str, packet_size: int) -> list[str]: Splits a message into packets of a fixed size, except possibly the last packet. Parameters: - message: str: The original message to be split into packets - packet_size: int: The fixed size of each packet Returns: - list[str]: A list of packets each containing a portion of the original message return [message[i:i + packet_size] for i in range(0, len(message), packet_size)] def reassemble_message(packets: list[str]) -> str: Reassembles the original message from the provided list of packets. Parameters: - packets: list[str]: The list of packets to be combined Returns: - str: The reassembled original message return \'\'.join(packets)"},{"question":"# Coding Challenge Context In a list of integers, a peak element is an element that is greater than its neighbors. For this challenge, an element in the list is a peak if it is greater than the element directly before it and the element directly after it. If an element is at the beginning or end of the list, it is considered a peak if it is greater than its sole neighbor. Task Write a Python function to find the index of a peak element in the given list. The algorithm should aim for logarithmic complexity, exploiting properties of the input. Function Signature ```python def find_peak_element(nums: List[int]) -> int: pass ``` Input * `nums` (List[int]): A list of integers where consecutive elements are not equal. Output * (int): The index of a peak element. If multiple peaks exist, return the index of any one of them. Constraints * 1 ≤ len(nums) ≤ 10^5 * Each list element is unique. Examples ```python >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 3, 4, 5]) 4 >>> find_peak_element([5, 4, 3, 2, 1]) 0 ``` Notes * The function must return a valid index based on 0-based indexing. * Multiple answers are possible; any valid peak element index is accepted. * Input values are guaranteed to be unique and valid according to the constraints. Edge Cases * If the list has only one element, return its index (0). * Ensure the function handles larger lists efficiently within the constraints. * Consider using a divide-and-conquer or binary search approach to meet the efficiency requirement.","solution":"from typing import List def find_peak_element(nums: List[int]) -> int: left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 # Compare middle element with its neighbors if nums[mid] > nums[mid + 1]: # If mid element is greater than its next element, # then the peak lies on the left half including mid right = mid else: # If mid element is less than its next element, # then the peak lies on the right half excluding mid left = mid + 1 return left # peak element index"},{"question":"# Coding Assessment Question Context You have been provided with a data structure representing a binary tree. Your task is to traverse this tree in a specific order and perform operations on the node values. The binary tree is represented using a class-based structure with attributes for the left and right children and the node value. Task You need to implement a function that performs the following: 1. **In-Order Traversal**: Traverse the binary tree using in-order traversal. 2. **Node Value Operation**: For each node visited during the traversal, double its value and store the result in a list. 3. **Result Compilation**: Return the list compiled from the node values during traversal. Function Signature ```python class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def in_order_double_values(root: TreeNode) -> List[int]: Perform in-order traversal on the binary tree, doubling each node\'s value. Parameters: root (TreeNode): The root of the binary tree. Returns: List[int]: A list of doubled node values in in-order traversal sequence. ``` Input * **root (TreeNode)**: The root of the binary tree. Output * A list of integers representing the doubled values of nodes in an in-order traversal sequence. Constraints * The binary tree has at most 1000 nodes. * The node values are integers between -1000 and 1000 inclusive. * You must use in-order traversal. * Handle edge cases where the binary tree is empty (i.e., the root is `None`). Example ```python # Example binary tree # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) # Call the function with the example tree print(in_order_double_values(root)) ``` **Expected Outcome**: ``` [2, 4, 6, 8, 10] ``` Good luck!","solution":"from typing import List class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def in_order_double_values(root: TreeNode) -> List[int]: Perform in-order traversal on the binary tree, doubling each node\'s value. Parameters: root (TreeNode): The root of the binary tree. Returns: List[int]: A list of doubled node values in in-order traversal sequence. result = [] def in_order_traversal(node: TreeNode): if node is not None: in_order_traversal(node.left) result.append(2 * node.value) in_order_traversal(node.right) in_order_traversal(root) return result"},{"question":"# Matrix Zeroing Problem In this problem, you need to write a function that receives a matrix and sets entire rows and columns to zero if an element in those rows or columns is zero. The operation should be performed in-place. Requirements * Implement the function `zero_matrix(matrix: List[List[int]]) -> None` that modifies the matrix in place. * Do not use any additional space beyond the input matrix and a few built-in variables. Function Signature ```python from typing import List def zero_matrix(matrix: List[List[int]]) -> None: pass ``` # Input * `matrix`: A 2D list of integers. - The number of rows and columns can be different. - The elements are integers. # Output * The function does not return anything but modifies the input matrix in place. # Example ```python matrix1 = [ [1, 2, 3], [4, 0, 6], [7, 8, 9] ] zero_matrix(matrix1) assert matrix1 == [ [1, 0, 3], [0, 0, 0], [7, 0, 9] ] matrix2 = [ [0, 2, 3], [4, 5, 6], [7, 8, 9] ] zero_matrix(matrix2) assert matrix2 == [ [0, 0, 0], [0, 5, 6], [0, 8, 9] ] ``` # Constraints * The input matrix will have at least one element. * Use constant space outside the input matrix and a few built-in variables. * Optimize the function to minimize the number of passes over the matrix. # Notes * Consider edge cases like single-row/column matrices and matrices without any zeros. * Carefully handle floating-point inaccuracies if the elements are large integers. * Aim for a clear and concise implementation to facilitate understanding when debugging.","solution":"from typing import List def zero_matrix(matrix: List[List[int]]) -> None: if not matrix or not matrix[0]: return rows = len(matrix) cols = len(matrix[0]) first_row_zero = False first_col_zero = False # Check if the first row has any zeros for j in range(cols): if matrix[0][j] == 0: first_row_zero = True break # Check if the first column has any zeros for i in range(rows): if matrix[i][0] == 0: first_col_zero = True break # Use first row and first column as markers # Mark the rows and columns that need to be zeroed for i in range(1, rows): for j in range(1, cols): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 # Zero out cells based on markers in the first row and column for i in range(1, rows): if matrix[i][0] == 0: for j in range(1, cols): matrix[i][j] = 0 for j in range(1, cols): if matrix[0][j] == 0: for i in range(1, rows): matrix[i][j] = 0 # Zero out the first row if needed if first_row_zero: for j in range(cols): matrix[0][j] = 0 # Zero out the first column if needed if first_col_zero: for i in range(rows): matrix[i][0] = 0"},{"question":"# Sorting Algorithms: Implementing Bubble Sort Background Bubble sort is a simple sorting algorithm that works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items, and swapping them if they are in the wrong order. The pass through the list is repeated until the list is sorted. Task Write a function `bubble_sort(arr: List[int]) -> List[int]` that takes a list of integers and returns a new list with the integers sorted in ascending order using the Bubble Sort algorithm. Input - `arr`: A list of integers that need to be sorted. Output - Returns a new list of integers sorted in ascending order. Constraints - The input list will be of length 1 to 1000. - Each integer in the list will be in the range -10000 to 10000. Example ```python >>> bubble_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> bubble_sort([5, 3, 8, 4, 2]) [2, 3, 4, 5, 8] ``` Additional Notes - You are required to implement the Bubble Sort algorithm from scratch and not use any built-in sort functions. - Careful consideration should be given to the efficiency of your solution, particularly in terms of time complexity. The worst-case time complexity of Bubble Sort is O(n^2). Your task is to implement this `bubble_sort` function correctly and efficiently.","solution":"def bubble_sort(arr): Sorts an array of integers using the Bubble Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: A new list of integers sorted in ascending order. n = len(arr) sorted_arr = arr[:] for i in range(n): for j in range(0, n-i-1): if sorted_arr[j] > sorted_arr[j+1]: sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j] return sorted_arr"},{"question":"# Problem Statement You are given an array of integers where each element represents the height of a vertical bar. You must compute the maximum amount of water that can be trapped between these bars after it rains. # Task Write a function `trap_water` that takes in a list of integers `heights` representing the heights of bars. Your function should return an integer representing the maximum amount of water that can be trapped between the bars. # Input * `heights`: A list of non-negative integers representing the heights of the bars. # Output * An integer representing the maximum amount of water that can be trapped. # Constraints * The length of `heights` will be at most 50,000 elements. * Each element in `heights` will be at most 100,000. # Example ```python def trap_water(heights: list[int]) -> int: pass # Example Usage heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(trap_water(heights)) # Output: 6 heights = [4, 2, 0, 3, 2, 5] print(trap_water(heights)) # Output: 9 ``` # Notes Consider edge cases where heights have less than 3 bars, as they cannot trap any water. Aim for an efficient solution to handle large input sizes within the constraints.","solution":"def trap_water(heights): Compute the maximum amount of water that can be trapped between the bars. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"# Scenario You are a developer for a logistics company, and you need to optimize the routes taken by delivery trucks. The company operates within a city represented as a grid, where some streets are blocked due to construction. The objective is to find the shortest path for a truck to travel from a starting point to a destination on the grid. # Problem Statement Write a function `shortest_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int` that finds the shortest path from the `start` position to the `destination` position on a grid. Input: * `grid`: A 2D list where `0` represents a drivable street and `1` represents a blocked street. * `start`: A tuple `(x, y)` representing the starting position. * `destination`: A tuple `(x, y)` representing the destination position. Output: * An integer representing the length of the shortest path from the `start` to the `destination`. If no such path exists, return `-1`. Constraints: * The grid dimensions (m and n) are between 1 and 1000. * The starting and destination positions are guaranteed to be on drivable streets (`0`). Example: ```python grid = [ [0, 0, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0], [0, 0, 0, 0] ] start = (0, 0) destination = (3, 3) print(shortest_path(grid, start, destination)) # Output should be 6 ``` Notes: - Your solution must efficiently handle large grids. - The truck can move up, down, left, or right to adjacent cells on the grid, but cannot move diagonally. - If multiple paths exist with the same shortest length, any one of them can be considered as the solution.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == destination: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Problem Statement: You\'re required to create a function that computes the minimum total cost to connect all points in a 2D plane. Each point is represented by its coordinates `(x, y)`. Connecting any two points `(xi, yi)` and `(xj, yj)` incurs a cost given by the Manhattan distance between them, which is defined as `|xi - xj| + |yi - yj|`. # Input: * A list of tuples `points` where each tuple `(x, y)` represents the coordinates of a point. The list contains at least two points and at most 1000 points, with the coordinate values being integers between -1000 and 1000. # Output: * An integer representing the minimum total cost to connect all the given points. # Constraints: * The function should efficiently handle up to the maximum constraint. # Example: ```python assert min_cost_connect_points([(0,0), (2,2), (3,10), (5,2), (7,0)]) == 20 assert min_cost_connect_points([(3,12), (-2,5), (-4,1)]) == 18 ``` # Hint: * This problem can be approached using Minimum Spanning Tree algorithms such as Prim\'s or Kruskal\'s algorithm. * Utilize a priority queue to ensure efficient edge selection while growing the spanning tree. # Implementation: Implement the function `min_cost_connect_points(points: List[Tuple[int, int]]) -> int` based on the above analysis.","solution":"from heapq import heappop, heappush from typing import List, Tuple def manhattan_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> int: Calculate the manhattan distance between two points. return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) def min_cost_connect_points(points: List[Tuple[int, int]]) -> int: Returns the minimum cost to connect all points in a 2D plane using the minimum spanning tree approach. n = len(points) if n == 1: return 0 # Priority queue to select the edge with minimum weight at each step pq = [] heappush(pq, (0, 0)) total_cost = 0 in_mst = [False] * n edges_used = 0 while edges_used < n: cost, u = heappop(pq) if in_mst[u]: continue in_mst[u] = True total_cost += cost edges_used += 1 for v in range(n): if not in_mst[v]: heappush(pq, (manhattan_distance(points[u], points[v]), v)) return total_cost"},{"question":"# Coding Challenge: Frequent Substring Finder Problem Statement You are given a string `s` and an integer `n`. Your task is to determine the most frequent substring of length `n` in the given string. If there are multiple substrings with the same maximum frequency, return the lexicographically smallest one. Write a function `find_most_frequent_substring(s: str, n: int) -> str` that accepts a string `s` and an integer `n` and returns the most frequent substring of length `n`. If multiple substrings have the same frequency, return the lexicographically smallest one. Input - `s`: A string consisting of lowercase English letters. (1 ≤ len(s) ≤ 10^5) - `n`: An integer representing the length of the substring. (1 ≤ n ≤ len(s)) Output - Returns the most frequent substring of length `n`. Constraints 1. Your solution should efficiently handle input strings up to length 10^5. 2. The input string will only contain lowercase English letters. Performance Requirements The function should handle the input within a reasonable time frame, ideally within a second for any valid input. Example ```python assert find_most_frequent_substring(\\"ababab\\", 2) == \\"ab\\" assert find_most_frequent_substring(\\"aabbaabbaabb\\", 2) == \\"aa\\" assert find_most_frequent_substring(\\"abcdabcabcabc\\", 3) == \\"abc\\" ``` Detailed Steps 1. **Sliding Window**: Use a sliding window approach to generate all substrings of length `n`. 2. **Frequency Count**: Implement a counter to track the frequency of each substring. 3. **Lexicographical Check**: Track the most frequent substring and ensure to consider lexicographical order in case of ties. 4. **Main Logic**: Sequentially process the string to determine the most frequent substring of the desired length. Good luck and Happy Coding!","solution":"def find_most_frequent_substring(s: str, n: int) -> str: from collections import defaultdict # Edge case: If n is greater than length of the string if n > len(s): return \\"\\" substring_count = defaultdict(int) # Count the frequency of each substring of length n for i in range(len(s) - n + 1): substring = s[i:i+n] substring_count[substring] += 1 # Find the most frequent substring, prefer lexicographically smallest in case of ties most_frequent_substring = min(substring_count, key=lambda k: (-substring_count[k], k)) return most_frequent_substring"},{"question":"# Coding Challenge You have been hired to develop a feature for a scientific calculator that requires quick and accurate computations of exponential values. One key function in this calculator is to compute the power of a base number raised to a specified exponent. However, the target users need this function to handle very large exponents efficiently without causing overflow or losing precision during the calculations. Objective Your task is to implement a function utilizing exponentiation by squaring to compute the power of a base number raised to an exponent. This method provides an efficient way to compute large power values with reduced computational complexity. Requirements - Implement the function `power` that takes two integers, a base and an exponent, as input and returns the result of raising the base to the exponent. - Ensure the function handles both positive and negative exponents. - The function should efficiently compute large power values without causing overflow. Function Signature ```python def power(base: int, exponent: int) -> float: pass ``` Input - `base`: An integer representing the base. - `exponent`: An integer representing the exponent, which can be positive or negative. Output - A float representing the result of base raised to the exponent. Constraints - The base and exponent will be within the range of 32-bit signed integers. - Handle edge cases such as `0` raised to `0` (typically considered as `1`) and negative exponents properly. Example Here is an example of how your function should work: ```python >>> power(2, 3) 8.0 >>> power(5, -2) 0.04 >>> power(0, 0) 1.0 >>> power(10, 5) 100000.0 ``` Code Template Use the following template to start your implementation: ```python def power(base: int, exponent: int) -> float: if exponent == 0: return 1.0 # Handle negative exponent if exponent < 0: base = 1 / base exponent = -exponent result = 1.0 while exponent > 0: if exponent % 2 == 1: # If exponent is odd result *= base base *= base # Square the base exponent //= 2 return result if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def power(base: int, exponent: int) -> float: if exponent == 0: return 1.0 # Handle negative exponent if exponent < 0: base = 1 / base exponent = -exponent result = 1.0 current_base = base while exponent > 0: if exponent % 2 == 1: # If exponent is odd result *= current_base current_base *= current_base # Square the base exponent //= 2 return result"},{"question":"Merging Two Sorted Lists You are required to implement a function that merges two given sorted lists into a single sorted list. The input lists are sorted in ascending order and may contain both integers and floating-point numbers. Your job is to ensure the merged list is also sorted in ascending order. Requirements - **Function Name**: `merge_sorted_lists` - **Input**: - `list1: list` A sorted list of numeric elements. - `list2: list` Another sorted list of numeric elements. - **Output**: A new list containing all elements from `list1` and `list2`, sorted in ascending order. Constraints 1. Both input lists are individually sorted in ascending order. 2. The lists can contain integers and floating-point numbers. 3. The combined length of the input lists will be `0 <= len(list1) + len(list2) <= 2 * 10^4`. Expected Performance - Time complexity should be O(n + m), where n is the length of `list1` and m is the length of `list2`. - Space complexity should be O(n + m) for the output list. # Example ```python merge_sorted_lists([1, 3, 5], [2, 4, 6]) # Output: [1, 2, 3, 4, 5, 6] merge_sorted_lists([-5, 3.2, 4], [-6, 0, 10]) # Output: [-6, -5, 0, 3.2, 4, 10] merge_sorted_lists([1.1, 2.2], [3.3, 4.4]) # Output: [1.1, 2.2, 3.3, 4.4] merge_sorted_lists([], []) # Output: [] merge_sorted_lists([1, 3, 5], []) # Output: [1, 3, 5] ``` # Implementation Details - Do not use any built-in functions for sorting directly; implement the merging logic according to the merge step of the merge sort algorithm. - Ensure your function can handle edge cases, such as when one or both lists are empty. Note Focus on merging the lists efficiently, ensuring all elements from `list1` and `list2` are included in the resultant list in ascending order.","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. :param list1: list, A sorted list of numeric elements. :param list2: list, Another sorted list of numeric elements. :return: A new list containing all elements from list1 and list2, sorted in ascending order. merged_list = [] i, j = 0, 0 n1, n2 = len(list1), len(list2) while i < n1 and j < n2: if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < n1: merged_list.append(list1[i]) i += 1 while j < n2: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Matrix Column Sum Problem Statement You are given a two-dimensional list (matrix) of integers. Your task is to write a function that calculates the sum of each column in the matrix and returns a list with the sums in the order of the columns. Implement a function `column_sums` that adheres to the following signature: ```python def column_sums(matrix: List[List[int]]) -> List[int]: ``` The function should: 1. **Raise a `ValueError`** if the input matrix is empty or if any of its rows have different lengths. 2. Compute the sum of each column. 3. **Return a list** containing the sums of each column. Examples ```python >>> column_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [12, 15, 18] >>> column_sums([[1, 2], [3, 4], [5, 6]]) [9, 12] >>> column_sums([[10], [20], [30]]) [60] >>> column_sums([]) Traceback (most recent call last): ... ValueError: Matrix must not be empty. >>> column_sums([[1, 2], [3, 4, 5], [6, 7]]) Traceback (most recent call last): ... ValueError: All rows in the matrix must have the same length. ``` To summarize, your implementation should validate the structure of the input matrix, compute the sum of each column appropriately and handle edge cases effectively. Ensure that your solution is optimized for efficiency and correctness.","solution":"from typing import List def column_sums(matrix: List[List[int]]) -> List[int]: Calculates the sum of each column in the given 2D matrix. Parameters: matrix (List[List[int]]): The input 2-dimensional matrix of integers. Returns: List[int]: A list containing the sums of each column. Raises: ValueError: If the input matrix is empty or if any of its rows have different lengths. # Check if matrix is empty if not matrix or not matrix[0]: raise ValueError(\\"Matrix must not be empty.\\") # Check if all rows have the same length row_length = len(matrix[0]) for row in matrix: if len(row) != row_length: raise ValueError(\\"All rows in the matrix must have the same length.\\") # Compute column sums num_columns = row_length sums = [0] * num_columns for row in matrix: for i in range(num_columns): sums[i] += row[i] return sums"},{"question":"# Coding Question Context You are given a string containing digits, lowercase English letters, and some special characters. Your task is to determine if the string is a valid \'numeric palindrome\'. A \'numeric palindrome\' means that the digits in the string form a palindrome, ignoring all other characters. A valid numeric palindrome reads the same forwards and backwards when only digits are considered. Task Implement a function `is_numeric_palindrome(s: str) -> bool` that determines if the string forms a numeric palindrome. Input and Output Formats * **Input**: * A string `s` containing digits, lowercase English letters, and special characters (`1 <= len(s) <= 1000`). * **Output**: * Return `True` if the numeric part of the string is a palindrome. * Return `False` otherwise. Examples ```python Examples: >>> is_numeric_palindrome(\\"ab1cd2dc1ba\\") True >>> is_numeric_palindrome(\\"a1b2c3d4e5\\") False >>> is_numeric_palindrome(\\"12321\\") True >>> is_numeric_palindrome(\\"abc\\") True >>> is_numeric_palindrome(\\"1a2b3c2b1a\\") False ``` Constraints * Consider only numeric characters to determine if the string is a numeric palindrome. * The solution should be efficient enough to handle the upper limit of the input size. **Note**: The function should handle all possible edge cases gracefully.","solution":"def is_numeric_palindrome(s: str) -> bool: Given a string, determine if the numeric part of the string forms a palindrome. Args: s (str): the input string containing digits, letters, and special characters. Returns: bool: True if the numeric part of the string is a palindrome, False otherwise. # Extract the digits from the string digits = [char for char in s if char.isdigit()] # Check if the list of digits is the same forwards and backwards return digits == digits[::-1]"},{"question":"# Problem Statement You are given a list of integers representing the heights of buildings along a street, and you need to determine the maximum rectangular area that can be formed by contiguous buildings. Implement the function `max_rectangle_area(heights)` that takes a list of integers `heights` and returns the maximum rectangular area that can be formed. # Function Signature ```python def max_rectangle_area(heights: List[int]) -> int: ``` # Input - `heights`: A list of integers where `1 <= len(heights) <= 10^5` and `0 <= heights[i] <= 10^4` representing the heights of buildings in the street. # Output - An integer representing the maximum rectangular area that can be formed by contiguous buildings. # Constraints - Heights are non-negative integers. - Consider edge cases where heights contain multiple zeros or a single building. # Example ```python print(max_rectangle_area([2, 1, 5, 6, 2, 3])) # Outputs: 10 print(max_rectangle_area([2, 4])) # Outputs: 4 ``` # Execution Requirements - The function should operate efficiently, leveraging stack-based techniques to achieve an acceptable time complexity (ideally, O(n) time). # Scenario Imagine a city planner needs to design the most effective use of billboard space by finding the largest possible rectangular area that can be utilized from building heights along a busy street. Your function will help maximize advertising space, ensuring efficient utilization of available structures. # Notes - Consider optimizing the function with a stack to handle the computation in linear time. - Ensure your solution is robust against a variety of input sizes and patterns, including sequences of identical heights, increasing or decreasing sequences, and the presence of height \'0\' values.","solution":"def max_rectangle_area(heights): Returns the maximum rectangular area that can be formed by contiguous buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Scenario: You are tasked with developing a simulation for a drone delivery system that operates within a 2-dimensional city grid. Each cell in the grid can either be a building (unwalkable) or free space (walkable). The drone can only move horizontally or vertically, not diagonally, and seeks the shortest path from its starting position to its destination. If no path exists, the function should return -1. # Task: Write a Python function that determines the shortest path for the drone from the start cell to the destination cell. Use Breadth-First Search (BFS) to find the shortest path in an unweighted grid. # Function Signature: ```python def shortest_drone_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: pass ``` # Input: - `grid` (List[List[int]]): A 2D list representing the city grid, where `0` signifies walkable space and `1` signifies a building. - `start` (Tuple[int, int]): A tuple indicating the starting coordinates of the drone (row, column). - `destination` (Tuple[int, int]): A tuple indicating the destination coordinates of the drone (row, column). # Output: - Returns an integer representing the length of the shortest path from start to destination. If no path exists, return -1. # Constraints: - `1 ≤ n, m ≤ 500` where `n` is the number of rows and `m` is the number of columns in the grid. - The start and destination coordinates are within the grid boundaries. - The start and destination cells are always walkable (i.e., contain `0`). # Performance: - Optimize the function to operate efficiently on a grid with the maximum possible size. # Example: ```python >>> grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] >>> start = (0, 0) >>> destination = (4, 4) >>> shortest_drone_path(grid, start, destination) 8 >>> grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] >>> start = (0, 0) >>> destination = (2, 2) >>> shortest_drone_path(grid, start, destination) -1 ``` # Requirements: - Implement your solution using BFS for unweighted shortest path finding. - Handle edge cases where the grid might be filled with buildings or the path might not exist.","solution":"from collections import deque from typing import List, Tuple def shortest_drone_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if start == destination: return 0 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: if (nr, nc) == destination: return dist + 1 queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"# Knapsack Problem for Maximum Value Computation **Context**: You are an inventory manager for an adventure gear store, and your task is to select a set of items to be placed in a backpack such that the total weight does not exceed the capacity of the backpack, and the total value of the selected items is maximized. This problem helps with optimizing packaging and resource allocation in logistics. **Task**: Implement a function `knapsack_max_value` which, given the weight capacity of a backpack and a list of items with associated weights and values, determines the maximum value that can be obtained by selecting a subset of the items without exceeding the weight capacity. **Function Signature**: ```python def knapsack_max_value(capacity: int, items: list[tuple[int, int]]) -> int: pass ``` **Input**: - `capacity` (int): The weight capacity of the backpack. - `items` (list of tuples): A list of items, where each item is represented as a tuple (weight, value). **Output**: - An integer representing the maximum value that can be obtained without exceeding the weight capacity. **Constraints**: - The number of items can range from `0` to `1000`. - The weights and values of items can range from `0` to `1000`. - The capacity of the backpack can range from `0` to `10000`. **Example**: ```python assert knapsack_max_value(50, [(10, 60), (20, 100), (30, 120)]) == 220 assert knapsack_max_value(10, [(5, 50), (5, 50), (5, 50)]) == 100 ``` **Notes**: * Ensure the function can handle edge cases effectively, such as an empty list of items or zero capacity. * The function should utilize dynamic programming to solve the problem efficiently. * This problem tests your understanding of dynamic programming and combinatorial optimization, demonstrating practical problem-solving skills in inventory management and resource optimization.","solution":"def knapsack_max_value(capacity: int, items: list[tuple[int, int]]) -> int: Function to determine the maximum value that can be obtained from the given items within the given capacity of the backpack. Args: capacity (int): The weight capacity of the backpack. items (list of tuples): A list of items where each item is represented as a tuple (weight, value). Returns: int: The maximum value obtainable without exceeding the weight capacity. n = len(items) # Create a 2D DP array to store the maximum value that can be achieved with # various capacities. dp = [[0] * (capacity + 1) for _ in range(n + 1)] # Populate the DP array for i in range(1, n + 1): weight, value = items[i - 1] for w in range(1, capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"Matrix Transpose with Constraints Context Matrix operations are fundamental in various fields such as computer graphics, machine learning, and scientific computing. A common operation is the matrix transpose, which flips a matrix over its diagonal, switching the row and column indices of the matrix. Problem Write a Python function `transpose_matrix_with_constraints` to transpose a given matrix and validate it against certain constraints with the following signature: ```python def transpose_matrix_with_constraints(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input & Output **Input:** - **matrix** (list of list of int): A two-dimensional list representing an ( M times N ) matrix where ( 1 leq M, N leq 50 ). **Output:** - **Result:** (list of list of int) Transpose of the input matrix. Constraints 1. Each row in the input matrix must have the same number of columns. 2. All elements in the matrix should be integers between (-1000) and (1000) (inclusive). Performance Constraints The function should operate with a time complexity of (O(M times N)) and space complexity of (O(M times N)). Function Execution - If the input matrix doesn\'t comply with the constraints, raise a `ValueError` with the message \\"Invalid matrix\\". # Examples ```python >>> transpose_matrix_with_constraints([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix_with_constraints([[1, -2], [-3, 4], [5, -6]]) [[1, -3, 5], [-2, 4, -6]] >>> transpose_matrix_with_constraints([[1000, -1000], [999, -999]]) [[1000, 999], [-1000, -999]] ``` Note You can assume that the input matrix will always be a valid non-empty two-dimensional list and will only need to validate constraints related to the elements and structure as stated above.","solution":"from typing import List def transpose_matrix_with_constraints(matrix: List[List[int]]) -> List[List[int]]: # Check if all rows have the same number of columns if not all(len(row) == len(matrix[0]) for row in matrix): raise ValueError(\\"Invalid matrix\\") # Check if each element is within the specified range for row in matrix: for elem in row: if not (-1000 <= elem <= 1000): raise ValueError(\\"Invalid matrix\\") # Transpose the matrix transposed_matrix = [[matrix[row][col] for row in range(len(matrix))] for col in range(len(matrix[0]))] return transposed_matrix"},{"question":"# Question In computer science, a palindrome is a string that reads the same forward and backward. A more complex form of palindrome is the \\"skipping palindrome\\", where non-alphanumeric characters (spaces, punctuation) are ignored while checking whether the string is a palindrome. Write a function `is_skipping_palindrome` that determines if a given string is a skipping palindrome. The function should ignore all non-alphanumeric characters and be case-insensitive. The function should return `True` if the string is a skipping palindrome and `False` otherwise. Function Signature: ```python def is_skipping_palindrome(s: str) -> bool: ``` Constraints: - The string `s` will have at most length `10^5`. Input: - A string `s` which may contain a mix of alphanumeric and non-alphanumeric characters. Output: - A boolean value `True` if `s` is a skipping palindrome, `False` otherwise. Example: ```python is_skipping_palindrome(\\"A man, a plan, a canal: Panama\\") # Output: True is_skipping_palindrome(\\"race a car\\") # Output: False is_skipping_palindrome(\\"No lemon, no melon\\") # Output: True is_skipping_palindrome(\\"\\") # Output: True ``` Edge Cases: - An empty string should be considered a skipping palindrome. - Strings consisting solely of non-alphanumeric characters are skipping palindromes. - Strings with mixed case letters should be treated similar to their lowercased versions. Use the following skeleton code to get started: ```python import re def is_skipping_palindrome(s: str) -> bool: Determine if a string is a skipping palindrome, ignoring non-alphanumeric characters and case. :param s: The input string to check. :return: True if s is a skipping palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Compare the cleaned string with its reverse return cleaned_s == cleaned_s[::-1] ``` This function ensures that only the alphanumeric characters are considered, and it performs a straightforward palindrome check by comparing the cleaned string to its reverse.","solution":"import re def is_skipping_palindrome(s: str) -> bool: Determine if a string is a skipping palindrome, ignoring non-alphanumeric characters and case. :param s: The input string to check. :return: True if s is a skipping palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Compare the cleaned string with its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"Problem Statement You are given a binary tree consisting of nodes where each node contains a unique integer value. Your task is to implement two functions that: 1. Finds the height of the binary tree (`find_height` function). 2. Returns a list of nodes visible from the left side view of the binary tree (`left_side_view` function). You must implement both functions with the following specifications: # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_height(root: Optional[TreeNode]) -> int: # Your implementation here def left_side_view(root: Optional[TreeNode]) -> List[int]: # Your implementation here ``` # Input - `root`: The root node of the binary tree (may be `None` if the binary tree is empty). # Output - `find_height`: Returns an integer representing the height of the binary tree. - `left_side_view`: Returns a list of integers representing the nodes visible from the left side view of the binary tree. # Constraints - The binary tree has at most 10^4 nodes. - Each node value is unique. # Example ```python # Example tree: # 1 # / # 2 3 # / # 4 5 6 # / # 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.left.left.left = TreeNode(7) >>> find_height(root) 4 >>> left_side_view(root) [1, 2, 4, 7] ``` # Additional Information 1. For the `find_height` function, the height is defined as the number of edges on the longest path from the root to a leaf node. 2. For the `left_side_view` function, the left side view of the binary tree contains the nodes that are visible when the tree is viewed from the left side. The functions should aim for optimal performance and handle both balanced and unbalanced binary trees efficiently.","solution":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_height(root: Optional[TreeNode]) -> int: if root is None: return 0 left_height = find_height(root.left) right_height = find_height(root.right) return max(left_height, right_height) + 1 def left_side_view(root: Optional[TreeNode]) -> List[int]: if root is None: return [] left_view = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if len(left_view) == level: left_view.append(node.val) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return left_view"},{"question":"# Coding Question: Product of Array Except Self You are given an array of integers, where \\"nums[i]\\" represents the ith number in the array. Write a function that returns an array where the element at each index \\"i\\" is the product of all the elements in \\"nums\\" except \\"nums[i]\\". Your solution should have a time complexity of O(n) and should not use division. Function Signature: Implement the function `product_except_self`: ```python def product_except_self(nums: list[int]) -> list[int]: pass ``` Input: * `nums`: A list of integers with at least 2 elements and at most 10^5 elements. Output: * Returns a list of integers representing the product of all elements except self. Constraints: * The input list `nums` will contain at least 2 elements and at most 10^5 elements. Examples: ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6, 7]) [42, 35, 30] >>> product_except_self([2, 3]) [3, 2] ``` Explanation: 1. For the array `[1, 2, 3, 4]`, the array of products except self is `[24, 12, 8, 6]` because: - For index 0: 2*3*4 = 24 - For index 1: 1*3*4 = 12 - For index 2: 1*2*4 = 8 - For index 3: 1*2*3 = 6 2. For the array `[5, 6, 7]`, the array of products except self is `[42, 35, 30]` because: - For index 0: 6*7 = 42 - For index 1: 5*7 = 35 - For index 2: 5*6 = 30 3. For the array `[2, 3]`, the array of products except self is `[3, 2]` because: - For index 0: 3 - For index 1: 2 Hint: Consider using two passes to create the resulting array: one for accumulating products before each index and one for after.","solution":"def product_except_self(nums: list[int]) -> list[int]: n = len(nums) result = [1] * n # Traverse from left to right, accumulating product left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Traverse from right to left, accumulating product right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"# Coding Assessment Question Scenario You are designing a software system to keep track of user activities within a time frame. Each activity has a start time and an end time. You need to manage and analyze overlapping activities to ensure that they are handled properly. Task Write a function to compute the maximum number of overlapping activities at any point in time within a given list of activities. Each activity is represented as a tuple containing a start time and an end time. Function Signature ```python def max_overlapping_activities(activities: List[Tuple[int, int]]) -> int: Calculates the maximum number of overlapping activities. :param activities: A list of tuples where each tuple represents an activity with a start and end time. - (start_time, end_time): start_time and end_time are positive integers representing the start and end times of the activity. :return: The maximum number of activities that overlap at any point in time. ``` Constraints 1. The list `activities` can contain up to (10^5) activities. 2. All start and end times are positive integers. 3. The start time of an activity is strictly less than its end time. Example Given the following activities: ```python activities = [(1, 4), (2, 5), (5, 6), (6, 8), (4, 7)] ``` The function should return: `2` because between times 2 and 4, activities `(1, 4)` and `(2, 5)` overlap.","solution":"from typing import List, Tuple def max_overlapping_activities(activities: List[Tuple[int, int]]) -> int: Calculates the maximum number of overlapping activities. :param activities: A list of tuples where each tuple represents an activity with a start and end time. - (start_time, end_time): start_time and end_time are positive integers representing the start and end times of the activity. :return: The maximum number of activities that overlap at any point in time. events = [] for start, end in activities: events.append((start, \'start\')) events.append((end, \'end\')) events.sort() max_overlap = 0 current_overlap = 0 for time, type in events: if type == \'start\': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) elif type == \'end\': current_overlap -= 1 return max_overlap"},{"question":"# Warehouse Sorting Algorithm Scenario You are tasked with developing an algorithm that helps a warehouse manage its inventory more efficiently. Items in the warehouse are stored in bins, and each bin contains items identified by a unique identifier number. To optimize space and accessibility, you need to sort the bin identifiers according to specific criteria. Task Write a function `sort_bin_ids` that takes a list of bin identifiers and returns a list of the sorted bin identifiers. The sorting criteria are as follows: 1. Even identifiers should come before odd identifiers. 2. Within the even and odd groups, identifiers should be sorted in ascending order. Function Definition ```python def sort_bin_ids(bin_ids: list[int]) -> list[int]: ``` Input - A list of integers, each representing a unique bin identifier. - Example: `[9, 4, 1, 11, 8, 12]` Output - A list of integers representing the sorted bin identifiers. - Example: `[4, 8, 12, 1, 9, 11]` Constraints - Each bin identifier is a non-negative integer. - The list of bin identifiers can range from 1 to 1000 elements. Performance Requirements - The solution should be efficient with a time complexity of O(n log n), where n is the length of the bin identifier list. Validation Scenarios To validate your solution, it should pass these examples: ```python assert sort_bin_ids([9, 4, 1, 11, 8, 12]) == [4, 8, 12, 1, 9, 11] assert sort_bin_ids([22, 5, 1, 8, 2]) == [2, 8, 22, 1, 5] assert sort_bin_ids([0, 5, 10, 15, 20]) == [0, 10, 20, 5, 15] ``` Special Cases - The function should handle the following cases gracefully: * An empty list of bin identifiers. * A list with only even or only odd identifiers.","solution":"def sort_bin_ids(bin_ids: list[int]) -> list[int]: Sorts bin identifiers such that even identifiers come before odd identifiers, and each group (even and odd) is sorted in ascending order. :param bin_ids: List of bin identifiers (integers). :return: sorted list of bin identifiers. evens = sorted([id for id in bin_ids if id % 2 == 0]) odds = sorted([id for id in bin_ids if id % 2 != 0]) return evens + odds"},{"question":"# Array\'s Greatest Product Substring You are given an array of positive integers `arr` and an integer `k`. Your task is to determine the maximum product of a contiguous substring of length `k` within the array. Input: - A list of positive integers `arr` (1 ≤ length of `arr` ≤ 1000). - An integer `k` (1 ≤ `k` ≤ length of `arr`). Output: - An integer representing the maximum product of any contiguous substring of length `k`. # Function Signature ```python def max_product_substring(arr: [int], k: int) -> int: pass ``` # Requirements 1. Your function should handle large input sizes efficiently. 2. Implement a window sliding mechanism to consider all possible contiguous substrings efficiently. 3. Ensure that the function works within the constraint limits for both performance and memory usage. # Constraints - `arr` will consist of positive integers only. - Consider edge cases such as when the array has the minimum possible length. # Example The function call: ```python max_product_substring([1, 2, 3, 4, 5], 3) ``` should return: ``` 60 ``` Explanation: The contiguous substring with length 3 that gives the maximum product is `[3, 4, 5]`, and the product is `3 * 4 * 5 = 60`. # Solution Explanation To find the maximum product of any contiguous substring of length `k` within the array, the code utilizes a sliding window approach, computing the product for each possible substring and keeping track of the maximum product found.","solution":"def max_product_substring(arr, k): Returns the maximum product of a contiguous substring of length k within the array. n = len(arr) if k > n: return -1 # This should not happen as per the problem constraints (1 ≤ k ≤ n) max_product = 0 product = 1 for i in range(n): product *= arr[i] if i >= k: product //= arr[i-k] # remove the element that is sliding out of the window if i >= k-1: max_product = max(max_product, product) return max_product"},{"question":"# Question You are required to implement a recursive algorithm to multiply two integers using the ancient Egyptian multiplication method (also known as Russian peasant multiplication). This algorithm should only use addition, subtraction, and bitwise operations. Function Signature ```python def egyptian_multiplication(a: int, b: int) -> int: pass ``` Input - `a`: An integer (( a )) that can be positive, negative, or zero. - `b`: An integer (( b )) that can be positive, negative, or zero. Output - An integer result of ( a times b ). Constraints - Handle edge cases where either ( a ) or ( b ) or both are zero appropriately. - Manage sign correctly to return the proper result for negative inputs. Examples - `egyptian_multiplication(15, 12)` should return `180` - `egyptian_multiplication(-6, 7)` should return `-42` - `egyptian_multiplication(0, 5)` should return `0` Additional Notes - The ancient Egyptian multiplication method works by successively doubling one number and halving the other, while adding up the instances where the halved number is odd. - Consider using a helper function for the recursive implementation. - You must strictly avoid using the multiplication operator (*) except for in construction of output examples. Performance Requirements - Your solution should be efficient in both time and space complexity, relying on the properties of bitwise operations for doubling and halving.","solution":"def egyptian_multiplication(a: int, b: int) -> int: def multiply(x, y): if y == 0: return 0 if y % 2 == 0: return multiply(x << 1, y >> 1) else: return x + multiply(x << 1, y >> 1) # Handle sign negative_result = (a < 0) ^ (b < 0) a, b = abs(a), abs(b) result = multiply(a, b) return -result if negative_result else result"},{"question":"# Problem Statement Design a system that simulates an elevator\'s operation in a building with multiple floors. The elevator should process requests efficiently, serving the nearest request first. Implement a function to simulate the sequence of stops the elevator will make given a series of floor requests. Function Signature ```python def elevator_simulation(requests: List[int], initial_floor: int) -> List[int]: pass ``` Input * `requests` - A list of integers representing the floors where requests were made. Each floor number is within the range of floors available in the building. * `initial_floor` - An integer representing the starting floor where the elevator is currently located. Output * Returns a list of integers representing the sequence of floors that the elevator will stop at to fulfill all requests. Constraints * You may assume the building has at least 2 floors and at most 100 floors. * The elevator is capable of servicing up to 50 requests in a single operation. * Input will always be valid as per above constraints. Example ```python requests = [3, 15, 2, 5, 9] initial_floor = 4 # The function should return [4, 3, 2, 5, 9, 15] as the sequence of stops. ``` # Guidelines 1. **Nearest Request First**: Always move the elevator to the nearest request, minimizing travel distance. 2. **Optimal Path**: Ensure the optimal path is taken each time to service the nearest floor request. 3. **Implementation**: Implement a simple greedy algorithm to find the next closest floor from the elevator\'s current position. # Hints 1. Use sorting and list operations to find and remove the nearest floor each step. 2. Keep track of the current floor after each move to continuously compute the nearest request. 3. The use of a priority queue or a sorted list may simplify the problem of finding the nearest floor.","solution":"def elevator_simulation(requests, initial_floor): Simulates the elevator operation by determining the sequence of stops to fulfill all floor requests starting from the initial floor. The elevator serves the nearest request first. Args: requests (List[int]): List of requested floors. initial_floor (int): The starting floor of the elevator. Returns: List[int]: Sequence of floors the elevator will stop at. import heapq if not requests: return [initial_floor] # Initialize result list with the initial floor stops = [initial_floor] # Convert requests to a min heap based on the absolute distance from initial floor heap = [(abs(floor - initial_floor), floor) for floor in requests] heapq.heapify(heap) # Process the requests in order of nearest distance first while heap: _, next_stop = heapq.heappop(heap) stops.append(next_stop) # Update the distances with respect to the new current floor heap = [(abs(floor - next_stop), floor) for _, floor in heap] heapq.heapify(heap) return stops"},{"question":"# Question: Command History Tracker You are tasked with implementing a `CommandHistory` class that keeps track of a sequence of executed commands and allows you to retrieve the history of commands up to a specified limit. # Class Specification Implement the class `CommandHistory` with the following methods: 1. **`__init__(self, limit: int)`** - **Description**: Initializes the `CommandHistory` object with a fixed limit on the number of commands to track. - **Input**: `limit` (int) – The maximum number of commands to retain in history. - **Output**: None 2. **`execute(self, command: str) -> None`** - **Description**: Adds a new command to the history. - **Input**: `command` (str) – The command to be added to the history. - **Output**: None 3. **`get_history(self) -> List[str]`** - **Description**: Returns the list of commands in the history, in the order they were executed, up to the specified limit. - **Output**: A list of the most recent commands (List[str]). # Constraints - The `limit` is guaranteed to be a positive integer. - The `execute` method will be called at least once. - The input commands are non-empty strings with a maximum length of 100 characters. # Example Usage ```python h = CommandHistory(3) h.execute(\\"mkdir new_folder\\") h.execute(\\"cd new_folder\\") h.execute(\\"touch file.txt\\") print(h.get_history()) # Output: [\\"mkdir new_folder\\", \\"cd new_folder\\", \\"touch file.txt\\"] h.execute(\\"ls\\") print(h.get_history()) # Output: [\\"cd new_folder\\", \\"touch file.txt\\", \\"ls\\"] ``` # Notes - If the number of executed commands exceeds the specified limit, the oldest commands should be discarded. - Ensure your solution efficiently maintains the command history within the given limit. - Consider edge cases such as when the history has fewer commands than the specified limit initially. - Optimize for both time and space complexity.","solution":"class CommandHistory: def __init__(self, limit: int): self.limit = limit self.history = [] def execute(self, command: str) -> None: if len(self.history) >= self.limit: self.history.pop(0) self.history.append(command) def get_history(self) -> list: return self.history"},{"question":"# List Intersection with Constraints Background You are given two lists of integers. Your task is to find their intersection. However, the intersection should only include the unique elements and should be sorted in ascending order. Task Write a function `list_intersection(arr1: List[int], arr2: List[int]) -> List[int]` that receives two lists of integers. Your function should return a list containing their intersection, with unique elements sorted in ascending order. Input * Two lists of integers `arr1` and `arr2`. Output * A list of integers representing the intersection of `arr1` and `arr2`, with unique elements sorted in ascending order. Constraints * The lists can be empty. * The integers in the lists can be negative or positive. * There should be no duplicates in the output list. Performance Requirements * Your solution should handle lists of up to 1000 elements efficiently. Example ```python assert list_intersection([1, 2, 2, 1], [2, 2]) == [2] assert list_intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [4, 9] assert list_intersection([], [1, 2, 3]) == [] assert list_intersection([1, 2, 3], []) == [] assert list_intersection([1, -1, 2], [-2, -1, 1]) == [-1, 1] ``` Notes * Ensure that the intersection result is without duplicates and sorted in ascending order. * Consider edge cases where one or both lists are empty.","solution":"def list_intersection(arr1, arr2): Returns the intersection of arr1 and arr2, with unique elements sorted in ascending order. # Convert lists to sets to find the intersection set1 = set(arr1) set2 = set(arr2) # Find the intersection intersection = set1 & set2 # Convert the intersection to a sorted list and return result = sorted(intersection) return result"},{"question":"# Dijkstra\'s Shortest Path Algorithm Implementation In this exercise, you are required to implement the Dijkstra\'s Shortest Path algorithm. The goal is to allow students to demonstrate their understanding of graph traversal, priority queues, and shortest path computation. Task Implement the `DijkstraAlgorithm` class which can compute the shortest path between two nodes in a weighted graph using Dijkstra\'s algorithm. # Function Signatures and Description ```python class DijkstraAlgorithm: def __init__(self, graph: dict): graph : dictionary, representing the weighted adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight). Initializes the DijkstraAlgorithm object with the given graph. pass def find_shortest_path(self, start_node: str, end_node: str) -> tuple[list[str], float]: Compute the shortest path from the start node to the end node. start_node : string, the starting node end_node : string, the destination node Returns: tuple containing: - path : list of strings, the sequence of nodes from start to end representing the shortest path. - total_cost : float, the total cost of the shortest path. pass ``` # Constraints and Performance Requirements * The graph is represented as an adjacency list with a dictionary, where keys are nodes and values are lists of tuples containing a neighbor and the weight of the edge. * It is assumed the graph is connected and weights are non-negative. * Nodes are unique strings, and the total number of nodes (N) is such that 1 ≤ N ≤ 1000. * The graph can have up to 10000 edges. * If the end_node is not reachable from the start_node, return an empty list for the path and infinity (`float(\'inf\')`) for the cost. # Example Usage ```python if __name__ == \\"__main__\\": graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } dijkstra_algorithm = DijkstraAlgorithm(graph) shortest_path, cost = dijkstra_algorithm.find_shortest_path(\'A\', \'D\') print(\\"Shortest path from A to D:\\", shortest_path) print(\\"Total cost:\\", cost) ``` # Scenarios to Consider 1. Graphs with multiple paths and varying weights leading to the same node. 2. Sparse graphs with many nodes but few connections. 3. Edge cases like minimal graphs (only one node) or graphs with disconnected subgraphs.","solution":"import heapq class DijkstraAlgorithm: def __init__(self, graph: dict): Initializes the DijkstraAlgorithm object with the given graph. self.graph = graph def find_shortest_path(self, start_node: str, end_node: str) -> tuple[list[str], float]: Compute the shortest path from the start node to the end node using Dijkstra\'s algorithm. start_node : string, the starting node end_node : string, the destination node Returns: tuple containing: - path : list of strings, the sequence of nodes from start to end representing the shortest path. - total_cost : float, the total cost of the shortest path. priority_queue = [(0, start_node, [])] visited = set() min_costs = {start_node: 0} while priority_queue: (current_cost, current_node, path) = heapq.heappop(priority_queue) if current_node in visited: continue path = path + [current_node] visited.add(current_node) if current_node == end_node: return path, current_cost for neighbor, weight in self.graph.get(current_node, []): if neighbor in visited: continue next_cost = current_cost + weight if neighbor not in min_costs or next_cost < min_costs[neighbor]: min_costs[neighbor] = next_cost heapq.heappush(priority_queue, (next_cost, neighbor, path)) return [], float(\'inf\')"},{"question":"Write a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a square matrix (2D list) and rotates it 90 degrees clockwise in place. # Input: * A 2D list `matrix` where every element is an ( n times n ) matrix (1 ≤ n ≤ 1000). # Output: * The same 2D list `matrix`, but rotated 90 degrees clockwise. # Function Signature: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Example: ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Note: * The rotation should be done in place, meaning that no new matrix should be created. * Focus on an efficient algorithm that minimizes both time and space complexity. * Consider edge cases such as the smallest matrix possible (1x1) and very large matrices.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise in place. :param matrix: The n x n matrix to rotate :return: The same n x n matrix rotated 90 degrees clockwise n = len(matrix) # First step is to transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step is to reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Coding Assessment Question Context Sorting algorithms are fundamental in computer science and are used to arrange elements of a list in a particular order. One common sorting challenge is to write a custom sort function based on specific criteria. Task Implement the `custom_sort` function that sorts a given list of tuples based on the second element of each tuple in descending order. If two tuples have the same second element, they should retain their original order. Function Signature ```python def custom_sort(input_list: list) -> list: Sorts a list of tuples based on the second element of each tuple in descending order. If two tuples have the same second element, they should retain their original order. @param input_list: a list of tuples where each tuple contains exactly two elements @return: the sorted list of tuples ``` Input and Output - **Input**: A list of tuples where each tuple contains exactly two elements. - **Output**: A list of tuples sorted primarily by the second element in descending order. If two tuples have the same second element, maintain their original order as found in the input list. Constraints - The input list will have at least one tuple. - Each tuple will contain exactly two elements. - The tuples\' second elements are guaranteed to be comparable. Performance - Aim to use a stable sorting algorithm to ensure that the relative order of tuples with equal second elements is preserved. - Strive for efficient and readable code. Example Use Cases ```python print(custom_sort([(1, 2), (3, 4), (5, 3)])) # Output: [(3, 4), (5, 3), (1, 2)] print(custom_sort([(2, 1), (4, 4), (6, 4), (3, 3)])) # Output: [(4, 4), (6, 4), (3, 3), (2, 1)] print(custom_sort([(1, 5), (2, 5), (3, 5)])) # Output: [(1, 5), (2, 5), (3, 5)] print(custom_sort([(1, 0)])) # Output: [(1, 0)] print(custom_sort([(1, -1), (2, -2), (3, -3)])) # Output: [(1, -1), (2, -2), (3, -3)] ``` Error Handling - Return an empty list if the input list is empty. - Assume the input list is properly formatted and does not require additional validation beyond sorting.","solution":"def custom_sort(input_list: list) -> list: Sorts a list of tuples based on the second element of each tuple in descending order. If two tuples have the same second element, they should retain their original order. @param input_list: a list of tuples where each tuple contains exactly two elements @return: the sorted list of tuples return sorted(input_list, key=lambda x: x[1], reverse=True)"},{"question":"# Array Rotation **Context**: Array rotation is a common operation in algorithms where the elements in an array are shifted either to the left or the right by a certain number of positions. Understanding how to efficiently perform this operation is crucial in many areas, such as data processing and cyclic rearrangements. **Objective**: Write a function that rotates an array to the right by a given number of steps. The rotation should be performed in-place, meaning that the original array should be modified without using additional space for another array. **Function Signature**: ```python def rotate_array(nums: List[int], k: int) -> None: ``` **Input**: - `nums` (List[int]): A list of integers, where the length of the list is `n` (0 <= n <= 10^5). - `k` (int): The number of steps to rotate the array (0 <= k <= 10^5). **Output**: - The function does not return anything. Modify the `nums` list in-place. **Examples**: ```python >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate_array(nums, 3) >>> print(nums) [5, 6, 7, 1, 2, 3, 4] >>> nums = [-1, -100, 3, 99] >>> rotate_array(nums, 2) >>> print(nums) [3, 99, -1, -100] >>> nums = [1] >>> rotate_array(nums, 0) >>> print(nums) [1] ``` **Constraints**: - Modify the `nums` list in-place without using extra space for another array. - Consider whether the input list can be empty or not. - The function should handle large inputs efficiently. **Performance Requirements**: - The solution should have a time complexity of O(n), where n is the length of the input list. - The space complexity should be O(1), not counting the input parameters. **Notes**: - Think about performing multiple steps of rotation in a modular arithmetic way to avoid redundant rotations. - Ensure to handle cases where `k` is greater than or equal to the length of the list by using `k % n`. **Task**: Implement the `rotate_array` function to meet the above specifications.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> None: Rotates the array to the right by k steps in place. :param nums: List of integers to rotate. :param k: Number of steps to rotate right. :returns: None. The array is modified in place. n = len(nums) if n == 0 or k == 0: return k = k % n # Handle cases where k is larger than n def reverse(nums, start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 reverse(nums, 0, n - 1) reverse(nums, 0, k - 1) reverse(nums, k, n - 1)"},{"question":"# Problem Statement You are asked to write a function that finds the k-th smallest number in a multiplication table with dimensions m x n. The table\'s rows and columns are indexed starting from 1, and each entry at position (i, j) is calculated as i * j. # Function Signature ```python def find_kth_number(m: int, n: int, k: int) -> int: ``` # Input 1. `m` (int): The number of rows in the multiplication table. It should be between 1 and 300 inclusive. 2. `n` (int): The number of columns in the multiplication table. It should be between 1 and 300 inclusive. 3. `k` (int): The k-th smallest number to find. It should be between 1 and m*n inclusive. # Output * Returns an integer representing the k-th smallest number in the m x n multiplication table. # Rules and Constraints 1. The multiplication table is constructed such that the entry at row `i` and column `j` is given by the product `i * j`. 2. Your algorithm should efficiently handle the constraints using an optimal searching technique. # Example ```python find_kth_number(3, 3, 5) # Should return 3 ``` # Explanation ``` The multiplication table for m=3 and n=3 looks like: 1 2 3 2 4 6 3 6 9 The sorted list of numbers is: [1, 2, 2, 3, 3, 4, 6, 6, 9] The 5th smallest number is 3. ``` # Performance Requirements Your algorithm should optimize the search process and avoid creating the entire table in memory due to potential size constraints. Consider using a binary search approach to achieve the solution within a reasonable time complexity. # Hints 1. The kth smallest number will lie in the range from 1 to (m * n). 2. Consider binary search on this range, counting how many numbers in the table are less than or equal to the midpoint to determine the correct position of k.","solution":"def find_kth_number(m, n, k): def count_less_equal(x): count = 0 for i in range(1, m + 1): count += min(x // i, n) return count left, right = 1, m * n while left < right: mid = (left + right) // 2 if count_less_equal(mid) < k: left = mid + 1 else: right = mid return left"},{"question":"# Context: Route Planning in a City using Dijkstra\'s Algorithm You are tasked with developing a feature for a navigation system that can determine the shortest path between two points in a city. The city is represented as a graph where intersections are nodes, and roads are weighted edges representing the travel time between intersections. Using the principles of Dijkstra\'s algorithm, implement a navigation feature that extends the provided Graph class to include the following methods: 1. **Shortest Path**: Implement a method `shortest_path` that computes the shortest path from a given starting node to a specified destination node. 2. **All Shortest Paths**: Implement a method `all_shortest_paths` that returns the shortest path from a starting node to every other node in the graph. # Task Requirements - Implement `shortest_path` method: This should return the shortest path and its length from the start node to the destination node. - Implement `all_shortest_paths` method: This should return a dictionary where keys are nodes and values are the lengths of the shortest paths from the specified start node to that node. Function Signatures: ```python class NavigationGraph(Graph): def shortest_path(self, start: int, destination: int) -> Tuple[int, List[int]]: pass def all_shortest_paths(self, start: int) -> Dict[int, int]: pass ``` Input/Output Formats: - **shortest_path**: - **Input**: Two integers `start` and `destination` (node indices). - **Output**: A tuple where the first element is the length of the shortest path, and the second element is a list of node indices representing the path. - **all_shortest_paths**: - **Input**: One integer `start` (node index). - **Output**: A dictionary where the keys are node indices and the values are the lengths of the shortest paths from the specified start node. Constraints: - 0 <= start, destination < number_of_nodes - The graph is connected, and all edges have non-negative weights.","solution":"import heapq from typing import List, Tuple, Dict class Graph: def __init__(self): self.edges = {} def add_edge(self, u: int, v: int, weight: int): if u not in self.edges: self.edges[u] = [] if v not in self.edges: self.edges[v] = [] self.edges[u].append((v, weight)) self.edges[v].append((u, weight)) class NavigationGraph(Graph): def shortest_path(self, start: int, destination: int) -> Tuple[int, List[int]]: queue = [(0, start, [])] visited = set() while queue: (cost, node, path) = heapq.heappop(queue) if node in visited: continue visited.add(node) path = path + [node] if node == destination: return (cost, path) for neighbor, weight in self.edges.get(node, []): if neighbor not in visited: heapq.heappush(queue, (cost + weight, neighbor, path)) return (float(\\"inf\\"), []) def all_shortest_paths(self, start: int) -> Dict[int, int]: queue = [(0, start)] visited = set() distances = {start: 0} while queue: (cost, node) = heapq.heappop(queue) if node in visited: continue visited.add(node) for neighbor, weight in self.edges.get(node, []): new_cost = cost + weight if neighbor not in distances or new_cost < distances[neighbor]: distances[neighbor] = new_cost heapq.heappush(queue, (new_cost, neighbor)) return distances"},{"question":"# Word Ladder Transformation Path You are tasked with implementing a function to find the shortest transformation path from a start word to an end word such that only one letter can be changed at a time, and each transformed word must exist in a given word list. # Problem Statement Write a function `find_transformation_path(start_word: str, end_word: str, word_list: list[str]) -> (int, list[str])` that: - **Input**: - `start_word`: A string representing the starting word. - `end_word`: A string representing the target word. - `word_list`: A list of strings that includes all intermediary words that can be used in the transformation. - **Output**: - Returns a tuple containing an integer and a list of strings. The integer represents the length of the shortest transformation path (including the start and end words), and the list of strings represents the path of words in the transformation process. If no such transformation is possible, return (0, []). # Constraints - All words have the same length. - All words consist of lowercase alphabets. - The word list does not exceed 1000 words. - The length of each word does not exceed 10 characters. # Performance Requirements - Aim to implement the algorithm with a time complexity of (O(n cdot m^2)), where (n) is the number of words in the list and (m) is the length of each word. - Ensure the solution properly handles edge cases as outlined in the analysis. # Example ```python # Example 1 start_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] path_length, transformation_path = find_transformation_path(start_word, end_word, word_list) print(f\\"Path Length: {path_length}, Transformation Path: {transformation_path}\\") # Output Example: Path Length: 5, Transformation Path: [\'hit\', \'hot\', \'dot\', \'dog\', \'cog\'] # Example 2 start_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] path_length, transformation_path = find_transformation_path(start_word, end_word, word_list) print(f\\"Path Length: {path_length}, Transformation Path: {transformation_path}\\") # Output Example: Path Length: 0, Transformation Path: [] ``` # Function Signature ```python def find_transformation_path(start_word: str, end_word: str, word_list: list[str]) -> (int, list[str]): pass ``` # Additional Notes: - If you need to simulate changing letters, make sure that each transformation yields a valid word in `word_list`. - You are encouraged to include helper functions if it helps simplify your solution. - You can assume the `start_word` is not equal to the `end_word` initially but may be transformed into the `end_word` through valid intermediate transformations.","solution":"from collections import deque def find_transformation_path(start_word: str, end_word: str, word_list: list[str]) -> (int, list[str]): Returns the length of the shortest transformation path and the path itself from start_word to end_word using the given word_list. if end_word not in word_list: return (0, []) word_set = set(word_list) queue = deque([(start_word, [start_word])]) while queue: current_word, path = queue.popleft() for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word == end_word: return (len(path) + 1, path + [next_word]) if next_word in word_set: queue.append((next_word, path + [next_word])) word_set.remove(next_word) return (0, [])"},{"question":"# Question: Calculate and Format Meeting Durations Context: A company\'s conference management system logs the start and end timestamps of the meetings held throughout the day. The company needs a utility to calculate the duration of each meeting in a readable format. Additionally, it should format the durations into a standardized string representation for reporting purposes. Task: Implement a Python function that calculates the duration of each meeting given its start and end timestamps. The function should then format each duration in \\"HH:MM:SS\\" format, where: - HH is the number of complete hours. - MM is the number of complete minutes. - SS is the number of complete seconds. Function Signature: ```python from datetime import datetime def format_meeting_durations(meetings: list) -> list: pass ``` Input: * **meetings** (list): A list of tuples, each containing two `datetime` objects (`start` and `end`) representing the start and end times of each meeting. Output: * **durations** (list): A list of strings, each representing the formatted duration of a meeting in \\"HH:MM:SS\\" format. Constraints: * Each `datetime` object will include timezone information. * Ensure proper handling of meetings that last exactly 0 seconds. * The function should handle edge cases such as meetings that start and end in different hours or minutes. Example: ```python >>> from datetime import datetime, timezone >>> meetings = [ ... (datetime(2023, 10, 5, 9, 0, 0, tzinfo=timezone.utc), datetime(2023, 10, 5, 10, 0, 0, tzinfo=timezone.utc)), ... (datetime(2023, 10, 5, 11, 30, 0, tzinfo=timezone.utc), datetime(2023, 10, 5, 12, 15, 30, tzinfo=timezone.utc)), ... ] >>> durations = format_meeting_durations(meetings) >>> assert durations == [\\"01:00:00\\", \\"00:45:30\\"] ``` Notes: * The input list is guaranteed to have at least one meeting. * The start timestamp is always earlier than the end timestamp for each meeting. * Ensure the output matches the \\"HH:MM:SS\\" format precisely, including leading zeros where necessary.","solution":"from datetime import datetime def format_meeting_durations(meetings: list) -> list: durations = [] for start, end in meetings: duration = end - start total_seconds = int(duration.total_seconds()) hours, remainder = divmod(total_seconds, 3600) minutes, seconds = divmod(remainder, 60) formatted_duration = f\\"{hours:02}:{minutes:02}:{seconds:02}\\" durations.append(formatted_duration) return durations"},{"question":"# Coding Question: Implement String Compression Context You have been tasked with creating a function that compresses a string using run-length encoding (RLE). This technique is useful for reducing the size of repetitive data, making it more efficient for storage and transmission without losing the original information. Task Write a function `compress_string(s: str) -> str` that takes a string `s` as input and returns a compressed version of the string using run-length encoding. If the compressed string is not smaller than the original string, the function should return the original string. Expected Input and Output * **Input**: A single string parameter `s`. * **Output**: A compressed string if the run-length encoding reduces the size, otherwise the original string. Constraints 1. The input string `s` is non-empty and consists only of ASCII alphabetic letters (case-sensitive). 2. The function should raise a `TypeError` if the input is not a string. 3. Run-length encoding represents consecutive characters as a single character followed by the number of repetitions. Performance Requirements * The solution should execute in linear time O(n), where n is the length of the string. Examples ```python >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"aabbaa\\") \\"aabbaa\\" >>> compress_string(\\"aaAAaaAA\\") \\"aaAAaaAA\\" >>> compress_string(\\"\\") Traceback (most recent call last): ... TypeError: input must be a non-empty string >>> compress_string(12345) Traceback (most recent call last): ... TypeError: input must be a string ``` - **Edge Case**: For input \\"abcdef\\", the output should be \\"abcdef\\" because run-length encoding would not reduce its size. - **Edge Case**: For input \\"\\", the function should raise `TypeError`. # Edge Cases and Performance Expectations Consider and handle edge cases such as: * Strings where compression doesn\'t reduce size. * Strings with varying character cases. * Invalid input types (integers, lists, etc.). Your solution should account for these scenarios and operate efficiently.","solution":"def compress_string(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"input must be a string\\") if not s: raise TypeError(\\"input must be a non-empty string\\") compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Add the last repeated character compressed.append(s[-1] + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"Coding Challenge: Range Sum Query - Immutable **Scenario**: You are asked to design a class that efficiently handles multiple sum range queries on a list of integers. The sum range query, given two indices i and j, returns the sum of the elements between indices i and j (i ≤ j), inclusive. **Task**: Implement a class `NumArray` with the following methods: 1. **`__init__(self, nums: List[int])`**: - Constructor that initializes the object with the list `nums`. 2. **`sumRange(self, i: int, j: int) -> int`**: - Method that returns the sum of the elements of `nums` between indices `i` and `j` inclusive. **Input**: - The `nums` list can contain up to 10,000 elements where each element is an integer between `-10^5` and `10^5`. - Method `sumRange` will be called multiple times. **Output**: - The `sumRange` method should return the sum of the subarray specified by `i` and `j`. **Example**: ```python >>> arr = NumArray([-2, 0, 3, -5, 2, -1]) >>> print(arr.sumRange(0, 2)) # Output: 1 >>> print(arr.sumRange(2, 5)) # Output: -1 >>> print(arr.sumRange(0, 5)) # Output: -3 ``` **Implementation Notes**: - To optimize the `sumRange` operation, consider preprocessing the input list `nums` to create an auxiliary data structure that allows for fast range sum queries. - One possible approach is to use a prefix sum array where each element at index `i` contains the sum of all elements in `nums` from the start up to `i`. - Ensure that your solution can handle large arrays and multiple queries efficiently.","solution":"class NumArray: def __init__(self, nums): Initializes the num array and computes prefix sums. self.prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i] def sumRange(self, i, j): Returns the sum of the elements between indices i and j inclusive. return self.prefix_sums[j + 1] - self.prefix_sums[i]"},{"question":"# Coding Assessment: Matrix Block Sum Calculation **Objective**: Implement a function to calculate the block sum for each element in a given matrix using a specified block size. # Problem Given a matrix of integers and an integer `K`, write a function `matrix_block_sum` that returns a new matrix of the same dimensions where each element `(i, j)` contains the sum of all elements in the submatrix of size `(2*K + 1, 2*K + 1)` centered at `(i, j)`. If the submatrix extends beyond the matrix boundaries, consider only the existing elements. # Function Signature ```python def matrix_block_sum(mat: List[List[int]], K: int) -> List[List[int]]: Calculate the block sum for each element in the given matrix. Args: mat (List[List[int]]): The input matrix containing integers. K (int): The block size parameter for summing. Returns: List[List[int]]: A new matrix of the same dimensions with the block sums. pass ``` # Input * `mat`: A 2D list of integers of shape `(m, n)` where `m` is the number of rows and `n` is the number of columns. * `K`: An integer representing the block size. # Output * A 2D list of the same shape `(m, n)` containing the block sums for each element. # Constraints * 1 ≤ m, n ≤ 100 (dimensions of the matrix) * 1 ≤ mat[i][j] ≤ 100 (elements of the matrix) * 0 ≤ K ≤ min(m, n) # Example ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] K = 1 result = matrix_block_sum(mat, K) print(result) # Expected output: # [ # [12, 21, 16], # [27, 45, 33], # [24, 39, 28] # ] ``` # Instructions 1. Implement the function `matrix_block_sum` to correctly calculate the block sums as described. 2. Handle matrix boundaries appropriately when summing. 3. Optimize your solution to handle the edge cases and larger values of `m`, `n`, and `K`. 4. Validate the input to ensure it meets the constraints. # Notes * Consider using prefix sums to efficiently compute the block sums. * Ensure the solution is optimized for large inputs within the constraint limits. * Write additional test cases to validate the correctness of your implementation beyond the provided example.","solution":"from typing import List def matrix_block_sum(mat: List[List[int]], K: int) -> List[List[int]]: m, n = len(mat), len(mat[0]) # Compute the prefix sums prefix = [[0] * (n + 1) for _ in range(m + 1)] for r in range(m): for c in range(n): prefix[r + 1][c + 1] = mat[r][c] + prefix[r + 1][c] + prefix[r][c + 1] - prefix[r][c] # Function to get the sum using the prefix sums def get_sum(r1, c1, r2, c2): r1 = max(0, r1) c1 = max(0, c1) r2 = min(m - 1, r2) c2 = min(n - 1, c2) return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1] # Calculate the result matrix using the block sums result = [[0] * n for _ in range(m)] for r in range(m): for c in range(n): result[r][c] = get_sum(r - K, c - K, r + K, c + K) return result"},{"question":"# Problem Statement You are given a list representing an email thread where each email is marked with its `id` and the list of its `replies`. Your task is to flatten this nested structure into a single list of email `id`s in the order they would be read if you followed all threads chronologically. # Function Signature ```python def flatten_email_thread(emails: List[Dict[str, Any]]) -> List[int]: ``` # Input - `emails`: A list of dictionaries, where each dictionary represents an email with the following keys: - `\'id\'`: An integer representing the email\'s unique identifier. - `\'replies\'`: A list of dictionaries, each representing a reply to this email in the same format. # Output - A list of integers representing the flattened email thread, i.e., the reading order of the email ids. # Constraints - The function should handle a deeply nested structure. - The function should efficiently handle up to `10^5` nested emails. # Example ```python emails = [ { \'id\': 1, \'replies\': [ { \'id\': 2, \'replies\': [] }, { \'id\': 3, \'replies\': [ { \'id\': 4, \'replies\': [] } ] } ] }, { \'id\': 5, \'replies\': [] } ] >>> flatten_email_thread(emails) [1, 2, 3, 4, 5] ``` # Notes - The order of the output list should reflect the reading order: each email followed by its replies in the order they appear. - You can assume the `id` values in the original input are unique. - Ensure you handle edge cases, such as an empty input or an email with no replies.","solution":"from typing import List, Dict, Any def flatten_email_thread(emails: List[Dict[str, Any]]) -> List[int]: Flatten the nested email structure into a single list of email ids in reading order. result = [] def _flatten(emails): for email in emails: result.append(email[\'id\']) _flatten(email[\'replies\']) _flatten(emails) return result"},{"question":"**Problem Statement**: You\'re given a `transpose_matrix` function that needs to transpose a given 2D matrix represented as a list of lists in Python. The transpose of a matrix swaps the matrix\'s rows with its columns. # Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input: * A 2D list `matrix` where `matrix[i][j]` represents the element in the ith row and jth column of the matrix. * The matrix will have `r` rows and `c` columns, where `1 <= r, c <= 100`. # Output: * Return the transposed matrix as a 2D list. # Constraints: * Each element in the matrix will be an integer between `0` and `100`. # Example ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] ``` # Instructions 1. Implement the `transpose_matrix` function. 2. The function should return the transposed version of the input matrix, swapping rows with columns. 3. Handle the edge cases where the matrix has only one row or one column. 4. Ensure your solution is optimized for both time and space, keeping in mind the given constraints. # Additional Information * The transpose of a matrix involves creating a new matrix where the rows of the original matrix become the columns and vice versa. For instance, the transpose of a 2x3 matrix `[[1, 2, 3], [4, 5, 6]]` is a 3x2 matrix `[[1, 4], [2, 5], [3, 6]]`. * Your implementation should not modify the original matrix and should return a new 2D list representing the transposed matrix.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Given a 2D matrix, return the transpose of the matrix. The transpose of a matrix swaps the rows with its columns. return list(map(list, zip(*matrix)))"},{"question":"# Coding Assessment Question **Context**: In this problem, you are asked to implement a system for managing and analyzing tasks in a project. Each task has specific attributes, such as an identifier, name, description, priority, and status. You need to write a function that can process a series of operations on tasks and return a summary. Tasks have the following statuses: - \\"To Do\\" - \\"In Progress\\" - \\"Completed\\" - \\"Archived\\" You need to manage the tasks and provide summary information following these operations: - Add a new task. - Update the priority of an existing task. - Change the status of a task. - Get a summary of tasks by status. # Function Signature ```python class TaskManager: def __init__(self): self.tasks = {} def add_task(self, task_id: str, name: str, description: str, priority: int, status: str) -> None: Add a new task with the given attributes. Args: task_id (str): The unique identifier for the task. name (str): The name of the task. description (str): A description of the task. priority (int): The priority of the task (lower number indicates higher priority). status (str): The status of the task (must be one of \\"To Do\\", \\"In Progress\\", \\"Completed\\", \\"Archived\\"). def update_priority(self, task_id: str, new_priority: int) -> None: Update the priority of an existing task. Args: task_id (str): The unique identifier for the task. new_priority (int): The new priority of the task. def change_status(self, task_id: str, new_status: str) -> None: Change the status of an existing task. Args: task_id (str): The unique identifier for the task. new_status (str): The new status of the task (must be one of \\"To Do\\", \\"In Progress\\", \\"Completed\\", \\"Archived\\"). def get_summary(self) -> dict: Get a summary of the number of tasks by each status. Returns: dict: A dictionary where keys are statuses (\\"To Do\\", \\"In Progress\\", \\"Completed\\", \\"Archived\\") and values are integers representing the number of tasks in each status. ``` # Inputs * `task_id (str)`: The unique identifier for a task. * `name (str)`: The name of the task. * `description (str)`: A description of the task. * `priority (int)`: The priority of the task. * `status (str)`: The status of the task, can be \\"To Do\\", \\"In Progress\\", \\"Completed\\", \\"Archived\\". * `new_priority (int)`: The new priority to update the task with. * `new_status (str)`: The new status to update the task with. # Outputs * `None`: The add_task, update_priority, and change_status methods should not return any value. * `dict`: The get_summary method should return a dictionary summarizing tasks by their status. # Constraints 1. Task `task_id` will be unique across all tasks. 2. `priority` will be a non-negative integer. 3. `status` will always be one of the \\"To Do\\", \\"In Progress\\", \\"Completed\\", \\"Archived\\". # Examples 1. **Example 1**: ```python tm = TaskManager() tm.add_task(\\"1\\", \\"Task 1\\", \\"Description for task 1\\", 2, \\"To Do\\") tm.add_task(\\"2\\", \\"Task 2\\", \\"Description for task 2\\", 1, \\"In Progress\\") tm.change_status(\\"1\\", \\"Completed\\") tm.update_priority(\\"2\\", 3) tm.get_summary() ``` * Returns: `{\\"To Do\\": 0, \\"In Progress\\": 1, \\"Completed\\": 1, \\"Archived\\": 0}` 2. **Example 2**: ```python tm = TaskManager() tm.add_task(\\"3\\", \\"Task 3\\", \\"Description for task 3\\", 0, \\"To Do\\") tm.add_task(\\"4\\", \\"Task 4\\", \\"Description for task 4\\", 5, \\"To Do\\") tm.change_status(\\"3\\", \\"Archived\\") tm.get_summary() ``` * Returns: `{\\"To Do\\": 1, \\"In Progress\\": 0, \\"Completed\\": 0, \\"Archived\\": 1}`","solution":"class TaskManager: def __init__(self): self.tasks = {} def add_task(self, task_id: str, name: str, description: str, priority: int, status: str) -> None: Add a new task with the given attributes. Args: task_id (str): The unique identifier for the task. name (str): The name of the task. description (str): A description of the task. priority (int): The priority of the task (lower number indicates higher priority). status (str): The status of the task (must be one of \\"To Do\\", \\"In Progress\\", \\"Completed\\", \\"Archived\\"). self.tasks[task_id] = {\\"name\\": name, \\"description\\": description, \\"priority\\": priority, \\"status\\": status} def update_priority(self, task_id: str, new_priority: int) -> None: Update the priority of an existing task. Args: task_id (str): The unique identifier for the task. new_priority (int): The new priority of the task. if task_id in self.tasks: self.tasks[task_id][\\"priority\\"] = new_priority def change_status(self, task_id: str, new_status: str) -> None: Change the status of an existing task. Args: task_id (str): The unique identifier for the task. new_status (str): The new status of the task (must be one of \\"To Do\\", \\"In Progress\\", \\"Completed\\", \\"Archived\\"). if task_id in self.tasks: self.tasks[task_id][\\"status\\"] = new_status def get_summary(self) -> dict: Get a summary of the number of tasks by each status. Returns: dict: A dictionary where keys are statuses (\\"To Do\\", \\"In Progress\\", \\"Completed\\", \\"Archived\\") and values are integers representing the number of tasks in each status. summary = {\\"To Do\\": 0, \\"In Progress\\": 0, \\"Completed\\": 0, \\"Archived\\": 0} for task in self.tasks.values(): summary[task[\\"status\\"]] += 1 return summary"},{"question":"# Task Description Write a function that finds the most frequently occurring string in a list and returns it. If there are multiple strings with the same highest frequency, return the one that appears first in the list. # Function Specifications Implement the following function: ```python def most_frequent_string(strings: List[str]) -> str: Finds the most frequently occurring string in a list. If there is a tie, returns the one that appears first. Args: strings (List[str]): A list of strings. Returns: str: The most frequently occurring string. Example: >>> most_frequent_string([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) \'apple\' >>> most_frequent_string([\\"a\\", \\"b\\", \\"b\\", \\"c\\", \\"a\\", \\"c\\", \\"c\\"]) \'c\' # Your implementation here ``` # Constraints 1. The input list `strings` is non-empty. 2. Each element in the `strings` list is a non-empty string. 3. You may assume case sensitivity for the comparison (i.e., \'Apple\' and \'apple\' are different strings). # Detailed Example Given the `strings` list `[\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]`: 1. \'apple\' appears 3 times. 2. \'banana\' appears 2 times. 3. \'orange\' appears 1 time. 4. Since \'apple\' has the highest frequency, the function returns: `\'apple\'`. Given the `strings` list `[\\"a\\", \\"b\\", \\"b\\", \\"c\\", \\"a\\", \\"c\\", \\"c\\"]`: 1. \'a\' appears 2 times. 2. \'b\' appears 2 times. 3. \'c\' appears 3 times. 4. Since \'c\' has the highest frequency, the function returns: `\'c\'`.","solution":"from typing import List from collections import Counter def most_frequent_string(strings: List[str]) -> str: Finds the most frequently occurring string in a list. If there is a tie, returns the one that appears first. Args: strings (List[str]): A list of strings. Returns: str: The most frequently occurring string. # Count the frequency of each string in the list counter = Counter(strings) # Find the maximum frequency max_frequency = max(counter.values()) # Find the first string in the list with the maximum frequency for string in strings: if counter[string] == max_frequency: return string"},{"question":"# Currency Exchange Rate Converter **Scenario**: You have been asked by an international finance company to develop a currency exchange rate converter utility. The utility should facilitate currency conversions based on predefined exchange rates. The system should be able to handle any number of rates and provide precise conversions with accurate results. **Requirements**: 1. Write a function `add_exchange_rate(base_currency: str, target_currency: str, rate: float) -> None` that registers a new exchange rate from the base currency to the target currency. 2. Write a function `convert_currency(amount: float, base_currency: str, target_currency: str) -> float` that converts an amount of money from the base currency to the target currency using the registered exchange rates. **Function Signatures**: ```python def add_exchange_rate(base_currency: str, target_currency: str, rate: float) -> None: pass def convert_currency(amount: float, base_currency: str, target_currency: str) -> float: pass ``` **Input/Output**: * `add_exchange_rate`: * **Input**: * `base_currency` (a string indicating the base currency, e.g., \\"USD\\"). * `target_currency` (a string indicating the target currency, e.g., \\"EUR\\"). * `rate` (a float representing the exchange rate from the base currency to the target currency). * **Output**: None * `convert_currency`: * **Input**: * `amount` (a float representing the amount of money in the base currency). * `base_currency` (a string indicating the currency of the `amount`). * `target_currency` (a string indicating the currency into which the amount should be converted). * **Output**: * A float representing the amount of money in the target currency. **Constraints**: * The exchange rate for any currency pair will be positive and non-zero. * Currency strings will be in uppercase and adhere to ISO 4217 codes (e.g., \\"USD\\", \\"EUR\\"). * If a conversion is requested without a registered exchange rate, raise an appropriate error. * Ensure floating-point precision is handled adequately. **Example**: ```python >>> add_exchange_rate(\\"USD\\", \\"EUR\\", 0.85) >>> add_exchange_rate(\\"EUR\\", \\"JPY\\", 129.53) >>> convert_currency(100, \\"USD\\", \\"EUR\\") 85.0 >>> convert_currency(100, \\"EUR\\", \\"JPY\\") 12953.0 >>> convert_currency(100, \\"USD\\", \\"JPY\\") 10910.5 ``` # Additional Notes: Your solution will be evaluated on correctness, efficiency, and adherence to best coding practices. Ensure to write clean and readable code with appropriate comments.","solution":"# Dictionary to store the exchange rates exchange_rates = {} def add_exchange_rate(base_currency: str, target_currency: str, rate: float) -> None: Registers a new exchange rate from the base currency to the target currency. Parameters: - base_currency (str): The base currency. - target_currency (str): The target currency. - rate (float): The exchange rate from the base currency to the target currency. if rate <= 0: raise ValueError(\\"Exchange rate must be positive and non-zero.\\") exchange_rates[(base_currency, target_currency)] = rate def convert_currency(amount: float, base_currency: str, target_currency: str) -> float: Converts an amount of money from the base currency to the target currency using the registered exchange rates. Parameters: - amount (float): The amount of money in the base currency. - base_currency (str): The currency of the `amount`. - target_currency (str): The currency into which the amount should be converted. Returns: - float: The amount of money in the target currency. if (base_currency, target_currency) in exchange_rates: return amount * exchange_rates[(base_currency, target_currency)] else: raise KeyError(f\\"No exchange rate registered for {base_currency} to {target_currency}.\\")"},{"question":"# Coding Assessment Question Scenario You are developing a software that processes information about various shipments. One of the features requested is to categorize items based on their dimensions and weights to determine the best shipment method. A specific classification involves determining if an item qualifies as \\"small\\", \\"medium\\", \\"large\\", or \\"oversized\\" based on given criteria. Task Implement a function `classify_item(weight: float, length: float, width: float, height: float) -> str` that categorizes an item into one of the following categories: \\"small\\", \\"medium\\", \\"large\\", or \\"oversized\\" based on its weight and dimensions. Classification Criteria * **Small**: * Weight ≤ 1 kg * Length + Width + Height ≤ 60 cm * **Medium**: * Weight > 1 kg and ≤ 5 kg * Length + Width + Height > 60 cm and ≤ 150 cm * **Large**: * Weight > 5 kg and ≤ 20 kg * Length + Width + Height > 150 cm and ≤ 300 cm * **Oversized**: * Weight > 20 kg * Length + Width + Height > 300 cm Requirements * **Input**: Four floating-point numbers representing the weight (in kg), length (in cm), width (in cm), and height (in cm) of the item. * **Output**: A string indicating the category (\\"small\\", \\"medium\\", \\"large\\", \\"oversized\\"). Constraints * Ensure the input values are positive numbers. * Handle edge cases where the dimensions or weight may fall exactly on the boundaries of the categories. Example ```python classify_item(0.5, 20.0, 15.0, 10.0) # Output: \\"small\\" classify_item(3.0, 50.0, 40.0, 30.0) # Output: \\"medium\\" classify_item(10.0, 100.0, 100.0, 95.0) # Output: \\"large\\" classify_item(25.0, 150.0, 100.0, 75.0) # Output: \\"oversized\\" ``` Notes * Ensure accurate comparisons based on floating-point arithmetic. * Assume the dimensions and weight input will always be realistic and fall within common shipment item ranges. * Validate the input to ensure it meets the specified constraints.","solution":"def classify_item(weight: float, length: float, width: float, height: float) -> str: Classifies an item as \'small\', \'medium\', \'large\' or \'oversized\' based on given weight and dimensions. Parameters: weight (float): The weight of the item in kilograms. length (float): The length of the item in centimeters. width (float): The width of the item in centimeters. height (float): The height of the item in centimeters. Returns: str: Classification of the item. # Calculate the total dimension sum total_dimension = length + width + height if weight <= 1 and total_dimension <= 60: return \\"small\\" elif weight <= 5 and total_dimension <= 150: return \\"medium\\" elif weight <= 20 and total_dimension <= 300: return \\"large\\" else: return \\"oversized\\""},{"question":"# Context In order to evaluate your understanding of recursion and combinatorial algorithms, you\'re tasked with developing a function that generates all possible permutations of a given list of integers. Specifically, you should be able to understand and utilize the depth-first search (DFS) methodology to achieve an efficient solution. # Objective Implement a function to generate all possible permutations of a list of unique integers. Your function should be able to handle lists with up to 8 elements efficiently and return the results in lexicographical order. # Function Definition - `def permute(nums: list[int]) -> list[list[int]]` # Input and Output Formats - **permute(nums: list[int])** * `nums`: List of unique integers. - **Returns** * A list of lists, where each inner list is a unique permutation of `nums`, each permutation presented in lexicographical order. # Constraints - The input list `nums` will contain unique integers. - The length of `nums` will be between 1 and 8. # Example Usage ```python # Example 1 nums = [1, 2, 3] result = permute(nums) print(result) # Example output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] # Example 2 nums = [0, 1] result = permute(nums) print(result) # Example output: [[0, 1], [1, 0]] # Example 3 nums = [1] result = permute(nums) print(result) # Example output: [[1]] ``` # Task Implement the function `permute(nums: list[int]) -> list[list[int]]` that generates all possible permutations of the list `nums`, ensuring the results are sorted in lexicographical order.","solution":"def permute(nums): Generates all possible permutations of a list of unique integers in lexicographical order. :param nums: List of unique integers. :return: List of lists, where each inner list is a permutation of `nums`. def dfs(current, remaining, result): if not remaining: result.append(current) return for i in range(len(remaining)): dfs(current + [remaining[i]], remaining[:i] + remaining[i+1:], result) result = [] nums.sort() # Ensure the input is sorted as the result should be lexicographical order dfs([], nums, result) return result"},{"question":"# Question Context You are helping to build a simple financial library that includes basic currency conversion. One of the fundamental functions is to convert an amount from one currency to another using a given exchange rate. This is a crucial part of financial calculations and portfolion management. Task Implement a function that converts an amount from one currency to another given the amount in the initial currency and the corresponding exchange rate. Function Specification ```python def currency_conversion(amount: float, exchange_rate: float) -> float: This function should convert the given amount from one currency to another using the provided exchange rate. Arguments: amount (float): the amount in the initial currency to be converted. exchange_rate (float): the conversion rate from the initial currency to the target currency. Returns: float: The amount converted to the target currency. Raises: ValueError: if the amount or exchange rate is non-positive. Example: >>> currency_conversion(100, 1.2) 120.0 >>> currency_conversion(50, 0.85) 42.5 >>> currency_conversion(0, 1.2) Raises ValueError: Amount must be positive >>> currency_conversion(100, 0) Raises ValueError: Exchange rate must be positive pass # Your code here ``` Constraints 1. The amount must be positive. 2. The exchange rate must be positive. 3. Only floating-point numbers should be used or returned. Performance Requirements The expected time complexity should be O(1) and the space complexity should be O(1). Your Task Implement the function `currency_conversion` as specified. Ensure that your function passes all the given test cases.","solution":"def currency_conversion(amount: float, exchange_rate: float) -> float: This function converts the given amount from one currency to another using the provided exchange rate. Arguments: amount (float): the amount in the initial currency to be converted. exchange_rate (float): the conversion rate from the initial currency to the target currency. Returns: float: The amount converted to the target currency. Raises: ValueError: if the amount or exchange rate is non-positive. if amount <= 0: raise ValueError(\\"Amount must be positive\\") if exchange_rate <= 0: raise ValueError(\\"Exchange rate must be positive\\") converted_amount = amount * exchange_rate return converted_amount"},{"question":"# Prime Anagrams Scenario: You are working as a software developer at a cybersecurity firm. One of your tasks is to implement a function to determine special properties of numbers, which can aid in cryptographic algorithms. A particular property of interest is identifying prime anagrams. An anagram of a number is another number formed by rearranging its digits. Task: Your task is to implement a function that checks whether two given numbers are prime anagrams of each other. Two numbers are prime anagrams if they are both prime and one number\'s digits can be rearranged to form the other number. # Function to Implement: **`are_prime_anagrams(num1, num2)`**: * **Input**: * `num1` (int): The first number. * `num2` (int): The second number. * **Output**: * A boolean value: True if the numbers are prime anagrams of each other, and False otherwise. # Example: ```python # Example usage and expected outputs print(are_prime_anagrams(13, 31)) # Output: True, since both are prime and 13 can be rearranged to form 31 print(are_prime_anagrams(13, 37)) # Output: False, since 37 is not an anagram of 13 print(are_prime_anagrams(17, 71)) # Output: True, since both are prime and 17 can be rearranged to form 71 print(are_prime_anagrams(23, 32)) # Output: False, since 32 is not a prime number ``` # Constraints: * The numbers `num1` and `num2` can range between 10 and 100000. * Implement a helper function `is_prime(n)` to determine if a number `n` is prime. * Implement another helper function `is_anagram(n1, n2)` to check if two numbers `n1` and `n2` are anagrams. * Ensure your solution is efficient and can handle the largest input size within a reasonable time. Your implementation should gracefully handle any edge cases, such as non-digit characters or invalid inputs, and provide meaningful error messages where applicable.","solution":"def is_prime(n): if n < 2: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def is_anagram(n1, n2): return sorted(str(n1)) == sorted(str(n2)) def are_prime_anagrams(num1, num2): return is_prime(num1) and is_prime(num2) and is_anagram(num1, num2)"},{"question":"# Movie Database Query and Summary Task You have been tasked with creating a utility that fetches and processes information about popular movies from a given database. Implement the following two functions: 1. **fetch_movie_data**: This function should make an HTTP request to a given URL, extract information about popular movies, including the movie title, release year, and rating, and return them as a list of dictionaries. * **Input**: A string representing the URL from which to fetch the movie data. * **Output**: A list of dictionaries, where each dictionary contains \'title\' (str), \'year\' (int), and \'rating\' (float) of a movie. * **Constraints**: - Ensure the function handles network timeouts appropriately. - The function must correctly parse the required elements from the JSON or HTML response. - The function should handle cases where data might be missing or incomplete. 2. **summarize_movies**: This function should process the list of movies returned by `fetch_movie_data` and print a summary of the movies, including the total number of movies, the average rating, and the oldest and newest movies in the list. * **Input**: A list of dictionaries, each containing \'title\', \'year\', and \'rating\' of a movie. * **Output**: None (side effect of printing the summary). * **Constraints**: - Handle cases where the list of movies might be empty. - Ensure the function computes the summary statistics correctly, considering edge cases like ties in the oldest or newest movies. # Example ```python # Example usage if __name__ == \\"__main__\\": movies_url = \\"https://api.somemoviedatabase.com/popular\\" movie_list = fetch_movie_data(movies_url) summarize_movies(movie_list) ``` # Notes - Ensure robust error handling and consider edge cases such as network errors or malformed data. - For testing purposes, you can use mock URLs or predefined JSON responses to simulate different scenarios. - Performance considerations: avoid unnecessary computations and handle network-related delays efficiently.","solution":"import requests def fetch_movie_data(url): Fetches movie data from the given URL and returns a list of dictionaries containing the title, year, and rating of the movies. :param url: URL to fetch the movie data from :return: List of dictionaries containing movie data try: response = requests.get(url, timeout=10) response.raise_for_status() data = response.json() movies = [] for movie in data.get(\'results\', []): title = movie.get(\'title\') year = movie.get(\'release_year\') rating = movie.get(\'rating\') if title and year and rating: movies.append({\'title\': title, \'year\': int(year), \'rating\': float(rating)}) return movies except (requests.RequestException, ValueError) as e: print(f\\"Error fetching data: {e}\\") return [] def summarize_movies(movies): Prints a summary of the movies including the total number, average rating, and the oldest and newest movies. :param movies: List of dictionaries containing movie data :return: None if not movies: print(\\"No movies to summarize.\\") return total_movies = len(movies) average_rating = sum(movie[\'rating\'] for movie in movies) / total_movies oldest_movie = min(movies, key=lambda x: x[\'year\']) newest_movie = max(movies, key=lambda x: x[\'year\']) print(f\\"Total Movies: {total_movies}\\") print(f\\"Average Rating: {average_rating:.2f}\\") print(f\\"Oldest Movie: {oldest_movie[\'title\']} ({oldest_movie[\'year\']})\\") print(f\\"Newest Movie: {newest_movie[\'title\']} ({newest_movie[\'year\']})\\")"},{"question":"# UK National Insurance Number Validator **Scenario:** Develop a function that validates UK National Insurance numbers (NINO). A valid NINO consists of two prefix letters, six digits, and a suffix letter which may be present or absent. It is essential for ensuring the authenticity and correctness of the NINO in various systems. **Function Specification:** ```python def is_uk_nino(nino: str) -> bool: Validates a UK National Insurance Number (NINO). Parameters: nino (str): The NINO to be validated. Returns: bool: True if the NINO is valid, False otherwise. Raises: TypeError: If the input is not a string. ValueError: If the input does not follow the correct format (AA000000A). Example: >>> is_uk_nino(\\"QQ123456C\\") True >>> is_uk_nino(\\"qq123456c\\") True >>> is_uk_nino(\\"AB123456\\") True >>> is_uk_nino(\\"A123456C\\") Traceback (most recent call last): ... ValueError: Input must follow the format AA000000A ``` **Requirements:** 1. The function should accept one parameter `nino` which is expected to be a string composed of: - Two prefix letters. - Six digits. - One optional suffix letter. 2. The function should normalize the input by: - Converting all characters to uppercase. 3. Validate the structure: - Ensure the cleaned string is either 8 or 9 characters long. - Ensure the first two characters are letters. - Ensure the next six characters are digits. - If present, ensure the 9th character is a letter. 4. Raise a `TypeError` if the input is not a string. 5. Raise a `ValueError` for any other format issues. **Constraints:** - The input string may contain lower or uppercase letters. # Examples: ```python assert is_uk_nino(\\"QQ123456C\\") == True assert is_uk_nino(\\"qq123456c\\") == True assert is_uk_nino(\\"AB123456\\") == True # Without suffix letter assert is_uk_nino(\\"A123456C\\") == False # Raises ValueError assert is_uk_nino(\\"12345678B\\") == False # Raises ValueError assert is_uk_nino(\\"QQ12A456C\\") == False # Raises ValueError assert is_uk_nino(\\"QQ12345678C\\") == False # Raises ValueError assert is_uk_nino(12345678) == False # Raises TypeError ```","solution":"def is_uk_nino(nino: str) -> bool: Validates a UK National Insurance Number (NINO). Parameters: nino (str): The NINO to be validated. Returns: bool: True if the NINO is valid, False otherwise. Raises: TypeError: If the input is not a string. ValueError: If the input does not follow the correct format (AA000000A). if not isinstance(nino, str): raise TypeError(\\"Input must be a string\\") # Normalize the NINO nino = nino.upper() # Validate length if len(nino) not in (8, 9): return False # Validate structure: first two characters must be letters if not nino[:2].isalpha(): return False # Validate structure: next six characters must be digits if not nino[2:8].isdigit(): return False # Validate structure: optional ninth character must be a letter if present if len(nino) == 9 and not nino[8].isalpha(): return False return True"},{"question":"# Scenario You are developing a financial reporting application that needs to generate weekly summaries of transaction data. Each transaction includes the transaction amount and the day of the week it occurred (represented as an integer between 0 and 6, where 0 is Sunday and 6 is Saturday). Your task is to build a function that computes the total transaction amount for each day of the week from a given list of transactions. # Task You must implement the `weekly_summary` function that processes the list of transactions and returns a list of total amounts for each day of the week. # Specification **Function Signature**: ```python def weekly_summary(transactions: list[tuple[int, int]]) -> list[int]: Summarizes the transactions for each day of the week. Args: transactions: A list of tuples where each tuple contains: - day: integer (0 to 6) representing the day of the week - amount: integer representing the transaction amount Returns: list[int]: A list of total amounts for each day of the week (Sunday to Saturday). ``` # Input * `transactions` (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers: - The first integer (0 to 6) represents the day of the week. - The second integer represents the transaction amount. # Output * `List[int]`: A list of 7 integers, where each integer represents the total amount of transactions for the corresponding day of the week (Sunday to Saturday). # Example ```python assert weekly_summary([(0, 100), (2, 50), (2, 25), (6, 300), (0, 75)]) == [175, 0, 75, 0, 0, 0, 300] assert weekly_summary([(1, 200), (4, 150), (5, 50), (1, 10), (3, 5), (6, 0)]) == [0, 210, 0, 5, 150, 50, 0] assert weekly_summary([(0, 0), (0, 0), (0, 0)]) == [0, 0, 0, 0, 0, 0, 0] assert weekly_summary([]) == [0, 0, 0, 0, 0, 0, 0] ``` # Constraints * Each transaction\'s day of the week must be in the range [0, 6]. * Each transaction\'s amount is an integer that can be positive, negative, or zero. * The list of transactions can have up to (10^5) elements.","solution":"def weekly_summary(transactions): Summarizes the transactions for each day of the week. Args: transactions: A list of tuples where each tuple contains: - day: integer (0 to 6) representing the day of the week - amount: integer representing the transaction amount Returns: list[int]: A list of total amounts for each day of the week (Sunday to Saturday). summary = [0] * 7 for day, amount in transactions: summary[day] += amount return summary"},{"question":"# Scenario A team of data scientists is developing a tool that requires efficient parsing and processing of large text files. One common task is to analyze text and extract meaningful information like word frequencies. They need a function that can read a text input and return a dictionary with each unique word as a key and its frequency count as the value. To ensure that the function handles variations in capitalization, words should be counted in a case-insensitive manner. # Task Write a Python function `word_count(text: str) -> dict` that takes a string input representing the text content and returns a dictionary where the keys are unique words (in lowercase) and the values are their respective counts. # Requirements - The function should be case-insensitive. All words should be converted to lowercase. - Punctuation should be ignored. Only consider alphanumeric characters. - Handle edge cases like empty input and inputs composed entirely of non-alphanumeric characters. # Input and Output - **Input**: A single string `text` representing the text content - **Output**: A dictionary with lowercase words as keys and their frequency counts as values # Constraints - The input text will be a string with a maximum length of 10^6 characters. # Performance Requirements - The solution should efficiently handle large texts up to 10^6 characters. # Examples ```python >>> word_count(\\"Hello world! Hello Universe.\\") {\'hello\': 2, \'world\': 1, \'universe\': 1} >>> word_count(\\"To be, or not to be; that is the question.\\") {\'to\': 2, \'be\': 2, \'or\': 1, \'not\': 1, \'that\': 1, \'is\': 1, \'the\': 1, \'question\': 1} >>> word_count(\\"\\") {} >>> word_count(\\"!!!\\") {} ``` **Notes** - You may find the `re` module helpful for filtering out non-alphanumeric characters.","solution":"import re from collections import defaultdict def word_count(text: str) -> dict: Return a dictionary with each unique word as a key and its frequency count as the value. # Use a regular expression to find all words and convert them to lowercase words = re.findall(r\'bw+b\', text.lower()) # Initialize a default dictionary to count the occurrences of each word word_frequency = defaultdict(int) # Count the frequency of each word for word in words: word_frequency[word] += 1 return dict(word_frequency)"},{"question":"# Divisible Subset You are asked to write a function that identifies a subset of integers from a provided list where every pair of integers in the subset is divisible (i.e., for any two integers a and b in the subset, a % b == 0 or b % a == 0). # Objectives: - Implement a function `largest_divisible_subset()` which finds the largest subset of integers where any pair of integers in the subset satisfies the divisibility condition. - If there are multiple subsets of the same maximum length, return any one of them. # Function Signature: ```python def largest_divisible_subset(nums: list) -> list: pass ``` # Input: - A list of integers, `nums`. # Output: - A list of integers forming the largest divisible subset. # Constraints: - The input list will have at least one integer. - All integers will be positive. - The integers may not be unique. # Example: ```python nums = [1, 2, 3] print(largest_divisible_subset(nums)) # Expected Output: # [1, 2] or [1, 3] nums = [1, 2, 4, 8] print(largest_divisible_subset(nums)) # Expected Output: # [1, 2, 4, 8] ``` # Notes: - **Optimization**: Aim for a solution with O(n^2) time complexity, where n is the length of the input list. - It is recommended to sort the list first and then use dynamic programming to build the solution. Submit your implementation of `largest_divisible_subset()` along with a few test cases demonstrating its correctness and efficiency.","solution":"def largest_divisible_subset(nums): if not nums: return [] nums.sort() n = len(nums) dp = [1] * n prev = [-1] * n max_size = 1 max_index = 0 for i in range(n): for j in range(i): if nums[i] % nums[j] == 0: if dp[j] + 1 > dp[i]: dp[i] = dp[j] + 1 prev[i] = j if dp[i] > max_size: max_size = dp[i] max_index = i result = [] while max_index >= 0: result.append(nums[max_index]) max_index = prev[max_index] return result[::-1]"},{"question":"# Circular Singly Linked List Implementation Context You need to implement a circular singly linked list to manage a sequence of nodes. Each node contains some integer data and points to the next node, with the last node pointing back to the first node, forming a circular structure. You\'ll need to implement basic functionalities including adding and deleting nodes as well as checking the size of the list. Requirements Write a class `CircularSinglyLinkedList` with the following methods: 1. **`__init__(self)`**: Initialize your linked list. This method should properly initialize the head node to `None`. 2. **`append(self, data: int)`**: Add a new node containing `data` at the end of the list. 3. **`delete(self, data: int)`**: Delete the first node containing `data`. If no such node exists, do nothing. 4. **`__len__(self) -> int`**: Return the number of nodes currently in the list. 5. **`traverse(self) -> list`**: Return a list containing the data of all nodes in the order they appear in the list. Input and Output * **Input**: * `append` method should accept an integer `data`. * `delete` method should accept an integer `data`. * **Output**: * `__len__` method should return the number of nodes as an integer. * `traverse` method should return a list of integers representing the node data. * **Constraints**: * Data values will be integers. * The list will hold up to (10^5) nodes. Example ```python lst = CircularSinglyLinkedList() lst.append(10) lst.append(20) lst.append(30) assert len(lst) == 3 assert lst.traverse() == [10, 20, 30] lst.delete(20) assert len(lst) == 2 assert lst.traverse() == [10, 30] lst.delete(40) # Nothing happens since 40 is not in the list assert len(lst) == 2 assert lst.traverse() == [10, 30] ``` # Note * The `append` method should efficiently add a new node at the end and properly link the nodes in a circular manner. * The `delete` method should efficiently find and remove the node containing the specified data and maintain the circular structure of the list.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class CircularSinglyLinkedList: def __init__(self): self.head = None def append(self, data: int): new_node = Node(data) if not self.head: self.head = new_node new_node.next = self.head else: current = self.head while current.next != self.head: current = current.next current.next = new_node new_node.next = self.head def delete(self, data: int): if not self.head: return current = self.head prev = None while True: if current.data == data: if prev: prev.next = current.next else: # Deleting the head node # Find last node tail = self.head while tail.next != self.head: tail = tail.next if current.next == self.head: # Only one node in the list self.head = None else: self.head = current.next tail.next = self.head return prev = current current = current.next if current == self.head: break def __len__(self) -> int: if not self.head: return 0 count = 1 current = self.head while current.next != self.head: count += 1 current = current.next return count def traverse(self) -> list: result = [] if not self.head: return result current = self.head while True: result.append(current.data) current = current.next if current == self.head: break return result"},{"question":"# Problem Statement: You are developing a reservation system for a small library. The system needs to manage the inventory of books and their respective reservations. Write a class that handles book reservations, allows checking the availability of books, and provides basic statistics about the book inventory. # Class Signature: ```python class LibraryReservationSystem: def __init__(self): Initializes a new instance of the LibraryReservationSystem class. def add_book(self, book_id: int, title: str) -> None: Adds a new book to the inventory. :param book_id: The unique identifier for the book. :param title: The title of the book. def remove_book(self, book_id: int) -> None: Removes a book from the inventory. :param book_id: The unique identifier for the book. def reserve_book(self, book_id: int, user_id: int) -> bool: Reserves a book for a user if it\'s available. :param book_id: The unique identifier for the book. :param user_id: The identifier for the user. :return: True if the reservation is successful, False otherwise. def book_status(self, book_id: int) -> str: Checks the status of a specific book. :param book_id: The unique identifier for the book. :return: \'Available\' if the book is available for reservation, otherwise \'Reserved\'. def inventory_status(self) -> dict: Provides the current status of the book inventory. :return: A dictionary with the total number of books and the number of available books. ``` # Example Usage: ```python library = LibraryReservationSystem() library.add_book(1, \\"1984\\") library.add_book(2, \\"To Kill a Mockingbird\\") print(library.book_status(1)) # Output: \'Available\' print(library.reserve_book(1, 1001)) # Output: True print(library.book_status(1)) # Output: \'Reserved\' print(library.reserve_book(1, 1002)) # Output: False library.remove_book(2) print(library.inventory_status()) # Output: {\'total_books\': 1, \'available_books\': 0} ``` # Constraints: 1. `1 <= book_id, user_id <= 10^6` 2. Each `book_id` and `user_id` is unique. 3. Only one book can be reserved by each user at a time. 4. When a book is removed, all reservations for that book are also removed. 5. Assume there are no race conditions for the scope of this problem.","solution":"class LibraryReservationSystem: def __init__(self): Initializes a new instance of the LibraryReservationSystem class. self.books = {} # Holds book_id to title mapping self.reservations = {} # Holds book_id to user_id mapping def add_book(self, book_id: int, title: str) -> None: Adds a new book to the inventory. :param book_id: The unique identifier for the book. :param title: The title of the book. self.books[book_id] = title def remove_book(self, book_id: int) -> None: Removes a book from the inventory. :param book_id: The unique identifier for the book. if book_id in self.books: del self.books[book_id] if book_id in self.reservations: del self.reservations[book_id] def reserve_book(self, book_id: int, user_id: int) -> bool: Reserves a book for a user if it\'s available. :param book_id: The unique identifier for the book. :param user_id: The identifier for the user. :return: True if the reservation is successful, False otherwise. if book_id in self.books and book_id not in self.reservations: self.reservations[book_id] = user_id return True return False def book_status(self, book_id: int) -> str: Checks the status of a specific book. :param book_id: The unique identifier for the book. :return: \'Available\' if the book is available for reservation, otherwise \'Reserved\'. if book_id in self.books: return \'Reserved\' if book_id in self.reservations else \'Available\' return \'Not Found\' def inventory_status(self) -> dict: Provides the current status of the book inventory. :return: A dictionary with the total number of books and the number of available books. total_books = len(self.books) available_books = total_books - len(self.reservations) return {\'total_books\': total_books, \'available_books\': available_books}"},{"question":"# Question: Implement Priority Queue using Max-Heap Design and implement a priority queue using a max-heap to manage and retrieve elements based on their priority values. Your task is to complete the operations such as insert, extract_max, and get_max efficiently. # Function Signatures ```python class MaxHeap: def __init__(self): pass def insert(self, key: int): pass def extract_max(self) -> int: pass def get_max(self) -> int: pass ``` # Input 1. `key`: An integer representing the priority value to be inserted into the max-heap. # Output * `extract_max` returns the maximum key from the max-heap and removes it. * `get_max` returns the maximum key from the max-heap without removing it. # Constraints * The number of operations to be performed on the max-heap will not exceed 10^4. * All `key` values are integers within the range ([-10^6, 10^6]). # Performance Requirements * Insert operation should be performed in O(log n) time complexity. * Extract and get max operations should be performed in O(log n) and O(1) time complexities, respectively. # Example ```python max_heap = MaxHeap() max_heap.insert(5) max_heap.insert(10) max_heap.insert(3) max_heap.insert(8) print(max_heap.get_max()) # Output: 10 print(max_heap.extract_max()) # Output: 10 print(max_heap.get_max()) # Output: 8 print(max_heap.extract_max()) # Output: 8 ``` # Notes * You may make use of a dynamic array (like Python\'s list) to implement the max-heap. * Ensure to maintain the properties of the max-heap after each insert and extract operation. * Handle corner cases like extracting from an empty heap gracefully. # Hints * Remember to rearrange the heap to maintain its properties after operations. * When inserting a new key, ensure it is placed in the correct position by comparing with its parent nodes.","solution":"class MaxHeap: def __init__(self): self.heap = [] def insert(self, key: int): self.heap.append(key) self._heapify_up(len(self.heap) - 1) def extract_max(self) -> int: if len(self.heap) == 0: raise IndexError(\\"extract_max from empty heap\\") if len(self.heap) == 1: return self.heap.pop() max_value = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return max_value def get_max(self) -> int: if len(self.heap) == 0: raise IndexError(\\"get_max from empty heap\\") return self.heap[0] def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): largest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] > self.heap[largest]: largest = left_child if right_child < len(self.heap) and self.heap[right_child] > self.heap[largest]: largest = right_child if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self._heapify_down(largest)"},{"question":"# Reverse Linked List II You are given a singly linked list and two integers left and right. The task is to reverse the nodes of the list from the left-th node to the right-th node (1-indexed). The reversal should be done in-place and needs to be within the given range, without affecting the other parts of the list. Problem Statement You need to write a function that reverses a part of the linked list from the given left position to the right position. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, left: int, right: int) -> ListNode: Reverse a portion of the linked list from \'left\' to \'right\' index inclusive. :param head: The head node of the singly linked list. :param left: The starting position of the reversal (1-indexed). :param right: The ending position of the reversal (1-indexed). :return: The head of the modified linked list. pass ``` # Requirements 1. **Function Implementation**: Implement the `reverse_between` function. It should take the head of a linked list and two positions, and return the head of the modified linked list. 2. **In-place Modification**: Ensure that the linked list is modified in-place. Do not allocate extra space for copying the list or its parts. 3. **Boundary Conditions**: Handle edge cases such as empty list, single node list, and invalid left or right positions gracefully. 4. **Constraints**: Assume the positions `left` and `right` are valid and within the length of the list. # Input - `head`: ListNode representing the head of a singly linked list. - `left`: Integer representing the starting position of the reversal. - `right`: Integer representing the ending position of the reversal. Example Input ```python head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) left = 2 right = 4 ``` # Output - Return the head of the modified linked list after performing the reversal. Example Output For the given example, the output linked list should be: ```python [ 1 -> 4 -> 3 -> 2 -> 5 ] ``` # Explanation The nodes from position 2 to 4 are reversed in place. The list initially `1 -> 2 -> 3 -> 4 -> 5` becomes `1 -> 4 -> 3 -> 2 -> 5`. # Constraints - The number of nodes in the linked list will not exceed 500. - `1 <= left <= right <= number of nodes`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, left: int, right: int) -> ListNode: Reverse a portion of the linked list from \'left\' to \'right\' index inclusive. :param head: The head node of the singly linked list. :param left: The starting position of the reversal (1-indexed). :param right: The ending position of the reversal (1-indexed). :return: The head of the modified linked list. if not head or left == right: return head # Initialize dummy node for easier head operations dummy = ListNode(0, head) prev = dummy # Move prev to the node before the start of the reverse section for _ in range(left - 1): prev = prev.next # Reverse the sublist curr = prev.next # curr will be the start of the reversed sublist next_node = None for _ in range(right - left): next_node = curr.next curr.next = next_node.next next_node.next = prev.next prev.next = next_node return dummy.next"},{"question":"# Coding Assessment: String Splitting by Delimiter Context You have been working on data processing tasks and often encounter the need to split strings based on specific delimiters. In some cases, these delimiters are not fixed and can include multiple possible characters. Problem Statement Write a function `split_string` that takes a string and a list of delimiters, and splits the string into substrings based on any of the provided delimiters. Function Definition ```python def split_string(input_string: str, delimiters: list) -> list: Split the input string based on multiple delimiters. Parameters: - input_string (str): The string to be split. - delimiters (list): A list of delimiter characters to split the string. Returns: - list: A list of substrings obtained by splitting the input string. Example Usage: >>> split_string(\\"hello,world;this:is-a:test\\", [\\",\\", \\";\\", \\":\\", \\"-\\"]) [\'hello\', \'world\', \'this\', \'is\', \'a\', \'test\'] >>> split_string(\\"foo:bar-baz,qux\\", [\\":\\", \\"-\\", \\",\\"]) [\'foo\', \'bar\', \'baz\', \'qux\'] import re # Join the delimiters into a pattern string with regex \\"or\\" (|) operator pattern = \'|\'.join(map(re.escape, delimiters)) # Split the input string based on the compiled regex pattern return re.split(pattern, input_string) ``` Requirements 1. **Input Validation**: - Ensure `input_string` is a string. - Ensure `delimiters` is a list containing one or more single-character strings. - Raise a `ValueError` with an appropriate message for invalid inputs. 2. **Edge Case Handling**: - Handle inputs where `input_string` contains none of the delimiters. - Handle empty `input_string` (should return an empty list). 3. **Improved Clarity**: - Provide clear and concise docstrings. Input/Output Format * **Input**: - `input_string`: A string to be split. - `delimiters`: A list of single-character delimiters to split the string. * **Output**: - A list of substrings obtained by splitting the input string by any of the delimiters. Constraints 1. `input_string` must be a non-empty string. 2. `delimiters` must be a list containing only single-character strings. Example ```python try: print(split_string(\\"hello,world;this:is-a:test\\", [\\",\\", \\";\\", \\":\\", \\"-\\"])) # Outputs: [\'hello\', \'world\', \'this\', \'is\', \'a\', \'test\'] print(split_string(\\"foo:bar-baz,qux\\", [\\":\\", \\"-\\", \\",\\"])) # Outputs: [\'foo\', \'bar\', \'baz\', \'qux\'] print(split_string(\\"plainstring\\", [\\",\\", \\":\\", \\"-\\"])) # Outputs: [\'plainstring\'] print(split_string(\\"\\", [\\",\\", \\":\\", \\"-\\"])) # Outputs: [] except ValueError as ve: print(f\\"ValueError: {ve}\\") ```","solution":"import re def split_string(input_string: str, delimiters: list) -> list: Split the input string based on multiple delimiters. Parameters: - input_string (str): The string to be split. - delimiters (list): A list of delimiter characters to split the string. Returns: - list: A list of substrings obtained by splitting the input string. Raises: - ValueError: If the input_string is not a string or delimiters is not a list of single-character strings. # Input Validation if not isinstance(input_string, str): raise ValueError(\\"Input must be a string.\\") if not isinstance(delimiters, list) or not all(isinstance(d, str) and len(d) == 1 for d in delimiters): raise ValueError(\\"Delimiters must be a list of single-character strings.\\") # Edge case: empty input string if input_string == \\"\\": return [] # Join the delimiters into a pattern string with regex \\"or\\" (|) operator pattern = \'|\'.join(map(re.escape, delimiters)) # Split the input string based on the compiled regex pattern return re.split(pattern, input_string)"},{"question":"# Question: Implementing an Efficient Sorting Algorithm with Threading **Context**: Sorting is a fundamental task in computer science. Your task is to implement an efficient sorting algorithm that leverages the power of multithreading to enhance performance. The algorithm should be a multi-threaded version of QuickSort. **Requirements**: 1. Implement a multi-threaded QuickSort algorithm. 2. Use Python\'s `threading` module to divide the sorting task among multiple threads. 3. Ensure that the algorithm can efficiently sort large lists by leveraging concurrency. **Function Signature**: ```python def multi_threaded_quick_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr (List[int])`: A list of integers to sort. **Output**: - Return a list of integers sorted in ascending order. **Constraints**: - The length of the list (`n`) should be between `0` and `10^5`. - The integers within the list can range from `-10^6` to `10^6`. **Performance**: - The solution should demonstrate significantly improved performance over a single-threaded QuickSort for large lists. **Examples**: ```python >>> res = multi_threaded_quick_sort([3, 6, 8, 10, 1, 2, 1]) >>> res == [1, 1, 2, 3, 6, 8, 10] True >>> res = multi_threaded_quick_sort([3, -1, 4, 1, 5, 9, 2]) >>> res == [-1, 1, 2, 3, 4, 5, 9] True ``` **Hint**: You can use Python\'s `ThreadPoolExecutor` from the `concurrent.futures` module to manage and create threads efficiently. Divide the array into parts and sort each part in a different thread. Finally, merge the sorted parts.","solution":"from concurrent.futures import ThreadPoolExecutor from typing import List def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort(arr, low, high): if low < high: pi = partition(arr, low, high) quicksort(arr, low, pi - 1) quicksort(arr, pi + 1, high) def threaded_quicksort(arr, low, high): if low < high: pi = partition(arr, low, high) with ThreadPoolExecutor(max_workers=2) as executor: left_sort = executor.submit(quicksort, arr, low, pi - 1) right_sort = executor.submit(quicksort, arr, pi + 1, high) left_sort.result() right_sort.result() def multi_threaded_quick_sort(arr: List[int]) -> List[int]: if not arr: return [] threaded_quicksort(arr, 0, len(arr) - 1) return arr"},{"question":"# Problem Statement You are developing a system that manages transactions. Each transaction can be classified as either a deposit or a withdrawal. Implement a class `TransactionHistory` that allows registering and analyzing these transactions to provide useful insights. **Specifications**: Implement a `TransactionHistory` class with the following methods: 1. `record_transaction(amount: float, transaction_type: str)`: Record a transaction with a given `amount` and `transaction_type` which can be either `\\"deposit\\"` or `\\"withdrawal\\"`. 2. `get_total_deposit() -> float`: Return the sum of all deposit transactions. 3. `get_total_withdrawal() -> float`: Return the sum of all withdrawal transactions. 4. `get_balance() -> float`: Return the current balance (total deposits minus total withdrawals). 5. `get_transaction_count(transaction_type: str) -> int`: Return the number of transactions of a given `transaction_type`. 6. `get_transaction_history() -> List[Tuple[float, str]]`: Return a list of tuples, each containing the amount and transaction type, representing the entire transaction history. **Error Handling**: - *InvalidTransactionTypeError*: Raised when `transaction_type` is not `deposit` or `withdrawal`. **Input/Output**: - Ensure methods function correctly and handle edge cases. - Transactions are processed and stored sequentially in the order they are recorded. # Inputs: - A sequence of method calls and parameters for recording and analyzing transactions. # Outputs: - For `record_transaction`: None. - For `get_total_deposit`, `get_total_withdrawal`, `get_balance`: The respective numerical values. - For `get_transaction_count`: An integer count of transactions of the specified type. - For `get_transaction_history`: A list of tuples representing the recorded transactions. # Example: ```python history = TransactionHistory() history.record_transaction(150.0, \\"deposit\\") history.record_transaction(50.0, \\"withdrawal\\") print(history.get_total_deposit()) # Output: 150.0 print(history.get_total_withdrawal()) # Output: 50.0 print(history.get_balance()) # Output: 100.0 print(history.get_transaction_count(\\"deposit\\")) # Output: 1 print(history.get_transaction_history()) # Output: [(150.0, \\"deposit\\"), (50.0, \\"withdrawal\\")] history.record_transaction(100.0, \\"transfer\\") # Raises InvalidTransactionTypeError: Transaction type must be \\"deposit\\" or \\"withdrawal\\". ``` # Constraints: - The transaction `amount` is a floating-point number and is always non-negative. - The number of transactions is capped at 10^5. - Transactions are processed efficiently, and methods should handle large numbers effectively. # Task: Implement the `TransactionHistory` class as described above, ensuring accurate functionality and appropriate error handling.","solution":"class InvalidTransactionTypeError(Exception): pass class TransactionHistory: def __init__(self): self.transactions = [] def record_transaction(self, amount: float, transaction_type: str): if transaction_type not in {\\"deposit\\", \\"withdrawal\\"}: raise InvalidTransactionTypeError(\\"Transaction type must be \'deposit\' or \'withdrawal\'\\") self.transactions.append((amount, transaction_type)) def get_total_deposit(self) -> float: return sum(amount for amount, t_type in self.transactions if t_type == \\"deposit\\") def get_total_withdrawal(self) -> float: return sum(amount for amount, t_type in self.transactions if t_type == \\"withdrawal\\") def get_balance(self) -> float: total_deposit = self.get_total_deposit() total_withdrawal = self.get_total_withdrawal() return total_deposit - total_withdrawal def get_transaction_count(self, transaction_type: str) -> int: if transaction_type not in {\\"deposit\\", \\"withdrawal\\"}: raise InvalidTransactionTypeError(\\"Transaction type must be \'deposit\' or \'withdrawal\'\\") return sum(1 for amount, t_type in self.transactions if t_type == transaction_type) def get_transaction_history(self): return self.transactions"},{"question":"# Coding Assessment Question Context A software company needs your help to enhance their utility for calculating the nth Fibonacci number. The current algorithm is a naive recursive implementation which becomes extremely inefficient for large values of n. They aim to improve this by using a more efficient approach. Task Write a function `efficient_fibonacci(n: int) -> int` to compute the nth Fibonacci number efficiently. Use an iterative approach or matrix exponentiation to ensure the algorithm runs in optimal time for large n. Input/Output Format * **Input**: A non-negative integer `n` where `n >= 0`. * **Output**: An integer representing the nth Fibonacci number. Constraints 1. Ensure the function handles the input for both small and large values of `n` efficiently. 2. Raise a `ValueError` if `n` is negative. 3. Optimize the performance to handle very large values up to at least `n = 10^5`. Example ```python >>> efficient_fibonacci(0) 0 >>> efficient_fibonacci(1) 1 >>> efficient_fibonacci(10) 55 >>> efficient_fibonacci(50) 12586269025 >>> efficient_fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer ```","solution":"def efficient_fibonacci(n: int) -> int: Returns the nth Fibonacci number using an iterative approach. Raises a ValueError if n is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") # Special cases if n == 0: return 0 if n == 1: return 1 # Start with the first two Fibonacci numbers a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Matrix Path Sum - Dynamic Programming Optimization You are given a 2D grid of integers where each cell contains a positive integer representing a cost. Your task is to find the minimum path sum from the top-left corner to the bottom-right corner of the grid, where you can only move to the right or down. To demonstrate your understanding of dynamic programming, you should implement and optimize an algorithm to solve this problem. # Requirements 1. Implement the `min_path_sum` function using dynamic programming to find the minimum path sum. 2. Optimize the function to handle large grids efficiently. 3. Ensure your solution uses only O(m*n) time and O(min(m, n)) space complexity, where m is the number of rows and n is the number of columns. # Input and Output Formats `min_path_sum` * **Input**: - `grid`: A 2D list of positive integers representing the cost grid. * **Output**: - An integer representing the minimum path sum from the top-left to the bottom-right corner. # Constraints - Assume the grid dimensions will be at least 1x1. - Each cell in the grid contains a positive integer. - You can only traverse right or down from a given cell. # Example ```python # Example usage of the `min_path_sum` grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] result = min_path_sum(grid) # Expected Output: 7 (1 -> 3 -> 1 -> 1 -> 1 -> 1) grid = [ [1, 2, 5], [3, 2, 1] ] result = min_path_sum(grid) # Expected Output: 6 (1 -> 2 -> 1 -> 2) ``` # Your Task: 1. Implement the `min_path_sum` function using dynamic programming to find the minimum path sum. 2. Optimize the function for efficient performance.","solution":"def min_path_sum(grid): Find the minimum path sum from the top-left to the bottom-right corner of the grid. You can only move to the right or down. :param grid: List[List[int]], a 2D list of positive integers representing the cost grid. :return: int, the minimum path sum. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # We will use a 1D array to optimize space complexity. dp = [float(\'inf\')] * n dp[0] = grid[0][0] for i in range(m): for j in range(n): if j == 0: if i != 0: dp[j] += grid[i][j] else: if i == 0: dp[j] = dp[j-1] + grid[i][j] else: dp[j] = min(dp[j], dp[j-1]) + grid[i][j] return dp[-1]"},{"question":"# Sorting a List of Tuples by a Specific Key Problem Statement You are provided with a list of tuples, each containing multiple elements. Your task is to write a function that sorts the list based on one of the tuple elements (specified by its position in the tuple). Requirements Implement the following function: ```python def sort_tuples_by_key(tuples_list: list, key_index: int) -> list: Sort a list of tuples by the specified key index. Parameters: tuples_list (list): List of tuples to be sorted. key_index (int): Index of the tuple element to sort by. Returns: list: Sorted list of tuples. Example: >>> tuples_list = [(1, 3), (2, 2), (3, 1)] >>> sorted_list = sort_tuples_by_key(tuples_list, 1) >>> print(sorted_list) [(3, 1), (2, 2), (1, 3)] ``` Your implementation must: - Sort the tuples based on the element at the `key_index` position. - Maintain elements in their original order if two elements at `key_index` are equal (stable sort). Input and Output - **Input**: A list of tuples and an integer `key_index`. - Example: `[(1, 3), (2, 2), (3, 1)]`, `key_index = 1` - **Output**: A sorted list of tuples. - Example: `[(3, 1), (2, 2), (1, 3)]` Constraints - The `tuples_list` can contain up to 10^5 tuples. - Tuple elements are of comparable types, such as integers or strings. Example ```python >>> tuples_list = [(1, 3), (2, 2), (3, 1)] >>> sorted_list = sort_tuples_by_key(tuples_list, 1) >>> print(sorted_list) # Output: [(3, 1), (2, 2), (1, 3)] >>> tuples_list = [(\'a\', 3), (\'c\', 1), (\'b\', 2)] >>> sorted_list = sort_tuples_by_key(tuples_list, 0) >>> print(sorted_list) # Output: [(\'a\', 3), (\'b\', 2), (\'c\', 1)] ``` # Note - The list should be sorted in ascending order based on the specified key index. - Ensure that your sorting algorithm is efficient, preferably using Python\'s built-in sorting functions which utilize Timsort, with an average time complexity of O(n log n).","solution":"def sort_tuples_by_key(tuples_list: list, key_index: int) -> list: Sort a list of tuples by the specified key index. Parameters: tuples_list (list): List of tuples to be sorted. key_index (int): Index of the tuple element to sort by. Returns: list: Sorted list of tuples. return sorted(tuples_list, key=lambda x: x[key_index])"},{"question":"# Problem Statement: You are given a list of transactions represented by a list of lists. Each transaction contains an epoch timestamp and an amount. Write a function `average_amount(transactions: list, start_time: int, end_time: int) -> float` that calculates the average transaction amount within the given time range inclusive. Ensure your implementation handles cases where there are no transactions within the range appropriately. # Function Signature: ```python def average_amount(transactions: list, start_time: int, end_time: int) -> float: ``` # Input: - `transactions` is a list of lists, where each sublist represents a transaction `[timestamp, amount]`. Each timestamp is an integer representing the epoch time, and each amount is a positive float. - `start_time` and `end_time` are integers representing the start and end of the time range, inclusive. # Output: - Return a float representing the average transaction amount within the specified time range. If no transactions occurred within the range, return 0.0. # Constraints: - The transactions list will be non-empty. - `start_time` and `end_time` will be valid integers such that `start_time <= end_time`. # Example: ```python assert average_amount([ [1609459200, 100.0], [1609459260, 50.0], [1609459320, 150.0], [1609459380, 200.0] ], 1609459200, 1609459320) == 100.0 assert average_amount([ [1609459200, 100.0], [1609459260, 50.0], [1609459320, 150.0], [1609459380, 200.0] ], 1609459200, 1609459380) == 125.0 assert average_amount([ [1609459200, 100.0], [1609459260, 50.0], [1609459320, 150.0], [1609459380, 200.0] ], 1609459400, 1609459500) == 0.0 ``` # Notes: - Ensure your implementation correctly filters and averages the transactions within the specified time range. - Handle the case where no transactions occur within the given time range by returning `0.0`. # Additional Challenge: - Optimize your implementation to handle long lists of transactions efficiently.","solution":"def average_amount(transactions: list, start_time: int, end_time: int) -> float: Calculate the average transaction amount within the given time range inclusive. Parameters: transactions (list): A list of transactions where each transaction is represented by a list [timestamp, amount]. start_time (int): The start of the time range (inclusive). end_time (int): The end of the time range (inclusive). Returns: float: The average transaction amount within the specified time range. If no transactions occurred within the range, return 0.0. filtered_transactions = [amount for timestamp, amount in transactions if start_time <= timestamp <= end_time] if not filtered_transactions: return 0.0 return sum(filtered_transactions) / len(filtered_transactions)"},{"question":"# Binary Search Implementation Context You need to implement the Binary Search algorithm to find the position of a target value within a sorted list of integers. Binary Search is efficient for searching in large datasets due to its logarithmic time complexity. Task Write a Python function `binary_search(collection: list, target: int) -> int` that takes a sorted list of integers and a target integer. The function should return the index of the target in the list if it is present, or `-1` if the target is not found. Your implementation should follow the binary search iterative approach. Function Signature ```python def binary_search(collection: list, target: int) -> int: pass ``` Input and Output * **Input**: * A sorted list of integers, `collection`, where each integer can be negative, positive, or zero. The list does not contain duplicate values. * An integer, `target`, which needs to be located in the list. * **Output**: * The index of the `target` if found in the list; otherwise `-1`. Constraints * Each integer in the list will be in the range -10^6 to 10^6. * The length of the list will not exceed 10^4. Examples ```python assert binary_search([1, 2, 3, 4, 5], 3) == 2 assert binary_search([1, 2, 3, 4, 5], 6) == -1 assert binary_search([-10, -5, 0, 5, 10], -5) == 1 assert binary_search([], 3) == -1 assert binary_search([3], 3) == 0 ``` Performance Requirements Your implementation should have a time complexity of O(log n). Additional Notes * Edge cases to consider include an empty list, a single-element list, and cases where the target is at the beginning or end of the list.","solution":"def binary_search(collection: list, target: int) -> int: Returns the index of target in the sorted list collection or -1 if the target is not found. left, right = 0, len(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] == target: return mid elif collection[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Scenario You have been asked to implement a module for basic arithmetic operations that can handle very large integers. The standard arithmetic operators (+, *, and -) might behave incorrectly with extremely large numbers due to overflow issues in some programming environments. To ensure precision and correctness, you need to manage these operations through string manipulation. # Task Write a function `large_number_multiply(a: str, b: str) -> str` that takes two non-negative integers `a` and `b` represented as strings and returns their product, also as a string. The function should handle arbitrarily large numbers. # Function Signature ```python def large_number_multiply(a: str, b: str) -> str: ``` # Expected Input and Output - **Input**: Two strings `a` and `b` representing non-negative integers, where each string consists of digits only. Both `a` and `b` have length between `1` and `10^5`. - **Output**: A string that represents the product of `a` and `b`. # Constraints - The input strings are guaranteed to represent valid non-negative integers. - The length of each input string is between `1` and `10^5`. # Performance Requirements - The function should have a time complexity of `O(n * m)`, where `n` and `m` are the lengths of the strings `a` and `b`, respectively. - The space complexity should be `O(n + m)`. # Examples ```python assert large_number_multiply(\\"123\\", \\"456\\") == \\"56088\\" assert large_number_multiply(\\"2048\\", \\"2048\\") == \\"4194304\\" assert large_number_multiply(\\"15\\", \\"0\\") == \\"0\\" assert large_number_multiply(\\"1\\", \\"987654321\\") == \\"987654321\\" assert large_number_multiply(\\"999999999999999999\\", \\"999999999999999999\\") == \\"999999999999999998000000000000000001\\" ``` # Notes - You must handle leading zeros in the input strings and ensure they do not appear in the output unless the product is zero. - Your solution should be efficient enough to handle the upper constraint limits.","solution":"def large_number_multiply(a: str, b: str) -> str: if a == \\"0\\" or b == \\"0\\": return \\"0\\" len_a, len_b = len(a), len(b) result = [0] * (len_a + len_b) for i in range(len_a - 1, -1, -1): for j in range(len_b - 1, -1, -1): mul = int(a[i]) * int(b[j]) p1, p2 = i + j, i + j + 1 summation = mul + result[p2] result[p1] += summation // 10 result[p2] = summation % 10 result_str = \'\'.join(map(str, result)).lstrip(\'0\') return result_str if result_str else \'0\'"},{"question":"# Problem Statement You are given a string that consists of lowercase alphabets and spaces. Your task is to implement a function that finds the length of the longest substring without repeating characters. # Implementation Details * Function Name: `length_of_longest_substring` * Input: A string `s` (e.g., `\\"abcabcbb\\"`) * Output: An integer representing the length of the longest substring without repeating characters (e.g., `3`) # Constraints 1. The input string will have a length between 0 and 10,000. 2. Return 0 if the input string is empty. 3. The solution should have a time complexity of O(N). # Example ```python def length_of_longest_substring(s: str) -> int: # Your implementation here # Test Cases print(length_of_longest_substring(\\"abcabcbb\\")) # Expected: 3 (\\"abc\\") print(length_of_longest_substring(\\"\\")) # Expected: 0 print(length_of_longest_substring(\\"bbbbb\\")) # Expected: 1 (\\"b\\") print(length_of_longest_substring(\\"pwwkew\\")) # Expected: 3 (\\"wke\\") print(length_of_longest_substring(\\"aabcdefga\\")) # Expected: 7 (\\"abcdefg\\") ``` **Restrictions**: * Do not use any library functions for finding permutations or combinations. * Ensure the solution efficiently handles cases with long strings by maintaining a linear scan. # Notes 1. Consider using a sliding window technique or a hash set to maintain the set of unique characters within the current window. 2. Handle edge cases, such as an empty string or a string with all identical characters, to ensure correctness.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in the given string. n = len(s) if n == 0: return 0 char_index_map = {} longest = 0 left = 0 for right in range(n): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right longest = max(longest, right - left + 1) return longest"},{"question":"# Coding Assessment Question Problem Statement You are given an integer array `nums` representing the prices of items, and an integer `budget` representing a total budget. Your task is to implement a function `can_purchase_all_items(nums, budget)` that returns a boolean indicating whether it is possible to purchase at least one of each type of item within the given budget. If it is possible to purchase all items within the budget, return `True`, otherwise return `False`. Function Signature ```python def can_purchase_all_items(nums: List[int], budget: int) -> bool: pass ``` Input - `nums`: A list of integers where each integer represents the price of an item. (1 leq text{len}(nums) leq 10^4) and (1 leq text{nums[i]} leq 10^4). - `budget`: An integer representing the total budget. (0 leq text{budget} leq 10^6). Output - A boolean value indicating whether it is possible to purchase all items within the given budget. Example ```python nums = [20, 50, 70, 10] budget = 100 print(can_purchase_all_items(nums, budget)) # Output: True nums = [100, 200, 300] budget = 100 print(can_purchase_all_items(nums, budget)) # Output: False ``` Constraints - The function should run efficiently for large inputs. Notes - Ensure the function considers all items and correctly calculates whether they all can be bought within the specified budget. - The function should return `False` if the total price of all items exceeds the budget, and `True` otherwise. This question assesses understanding of basic list operations, simple arithmetic, and control flow within a program. Performing well on this question demonstrates proficiency in handling constraints and building efficient solutions.","solution":"from typing import List def can_purchase_all_items(nums: List[int], budget: int) -> bool: Determines if all items in the list can be purchased within the given budget. :param nums: List of item prices :param budget: The budget to spend :return: True if all items can be bought within the budget, False otherwise total_cost = sum(nums) return total_cost <= budget"},{"question":"# Scenario You are developing a text processing toolkit that includes several string manipulation utilities. One of the required utilities is a function that converts a given string into its \\"comma-separated format.\\" The \\"comma-separated format\\" inserts commas into a string such that each comma separates three characters from the right, except for the leading segment which can contain fewer than three characters. # Task Implement the function `comma_separated_format(s: str) -> str` that transforms the input string `s` according to the rules outlined above. # Details 1. **Function Implementation**: * The function `comma_separated_format` should take a string `s` as input and return a new string with commas inserted properly. * The input string `s` will only contain numeric characters. 2. **Algorithm Description**: * Traverse the string from right to left. * Insert commas after every three characters from the end. * Ensure the leading segment can be fewer than three characters if the total length isn\'t a multiple of three. # Input * `s`: A non-empty string of numeric characters. # Output * Returns a string formatted with commas. # Constraints * The length of `s` is between 1 and 1000 characters. # Example ```python print(comma_separated_format(\\"123456789\\")) # Expected output: \\"123,456,789\\" print(comma_separated_format(\\"1000\\")) # Expected output: \\"1,000\\" ``` # Notes 1. Ensure the function handles strings of all valid lengths effectively. 2. No constraints on input other than the given length and numeric characters.","solution":"def comma_separated_format(s: str) -> str: Convert numeric string into comma-separated format. Args: s (str): Numeric string. Returns: str: Comma-separated formatted string. # Starting from the end of the string, insert commas after every third character. segments = [] while s: segments.append(s[-3:]) s = s[:-3] segments.reverse() return \',\'.join(segments)"},{"question":"# Coding Assessment Question Problem: In a warehouse management system, products are typically tracked by their identifiers. Each product identifier consists of digits and uppercase letters. Unfortunately, due to a system glitch, some product identifiers may contain consecutive duplicate characters. You need to implement a function that cleans these identifiers by removing all consecutive duplicate characters from each product\'s identifier. Function Signature: ```python def clean_identifiers(identifiers: List[str]) -> List[str]: Removes consecutive duplicate characters from each product identifier. Input Parameters: ----------------- identifiers: List of strings where each string represents a product identifier. Returns: -------- A list of cleaned product identifiers with consecutive duplicate characters removed. pass ``` Input: - `identifiers`: A list of strings, where each string is a product identifier consisting of digits and uppercase letters. The list will contain at most 1000 identifiers, and each identifier will have a length between 1 and 100 characters. Output: - Return a list of strings where each product identifier has been cleaned of consecutive duplicate characters. Constraints: - The input list will not be empty. - Each identifier consists only of digits (0-9) and uppercase letters (A-Z). Example: ```python clean_identifiers([\\"AAB33CC\\", \\"TTTFFEEE\\", \\"123456\\", \\"AABBCC\\", \\"A1B2C3\\"]) # Output: [\\"AB3C\\", \\"TFE\\", \\"123456\\", \\"ABC\\", \\"A1B2C3\\"] clean_identifiers([\\"ZZZ\\", \\"YY\\", \\"WWW34WWW\\", \\"11122\\", \\"QQRQQR\\"]) # Output: [\\"Z\\", \\"Y\\", \\"W34W\\", \\"12\\", \\"QRQR\\"] ``` You should catch and handle any potential exceptions that may arise due to invalid inputs, although guaranteed inputs will adhere to the described constraints.","solution":"def clean_identifiers(identifiers): Removes consecutive duplicate characters from each product identifier. Input Parameters: ----------------- identifiers: List of strings where each string represents a product identifier. Returns: -------- A list of cleaned product identifiers with consecutive duplicate characters removed. cleaned_identifiers = [] for identifier in identifiers: if not identifier: cleaned_identifiers.append(\\"\\") continue cleaned_identifier = [identifier[0]] for char in identifier[1:]: if char != cleaned_identifier[-1]: cleaned_identifier.append(char) cleaned_identifiers.append(\\"\\".join(cleaned_identifier)) return cleaned_identifiers"},{"question":"Problem Statement You have been asked to implement a custom integer list class, `CustomList`, that supports the following operations: appending an element, getting an element by index, removing an element by index, and finding the maximum and minimum elements in the list without using any built-in functions for those operations. # Function Signature ```python class CustomList: def __init__(self): pass def append(self, value: int) -> None: pass def get(self, index: int) -> int: pass def remove(self, index: int) -> None: pass def maximum(self) -> int: pass def minimum(self) -> int: pass ``` # Input - `value` (an integer): The value to append to the list. - `index` (an integer): The index of the element to get or remove from the list. # Output - `append(value)`: Adds the `value` to the list. Returns nothing. - `get(index)`: Returns the element at the specified index. - `remove(index)`: Removes the element at the specified index. Returns nothing. - `maximum()`: Returns the maximum element in the list. - `minimum()`: Returns the minimum element in the list. # Example ```python custom_list = CustomList() custom_list.append(5) custom_list.append(1) custom_list.append(4) print(custom_list.get(2)) # Output: 4 custom_list.remove(1) print(custom_list.get(1)) # Output: 4 print(custom_list.maximum()) # Output: 5 print(custom_list.minimum()) # Output: 4 ``` # Constraints - The list operations should handle edge cases such as empty lists and invalid indices appropriately. - Assume that only integers are used in the operations. - Aim to achieve optimal performance for the operations where possible. - Avoid using built-in functions for `maximum` and `minimum`; instead, implement these functionalities manually using simple comparisons.","solution":"class CustomList: def __init__(self): self.elements = [] def append(self, value: int) -> None: self.elements.append(value) def get(self, index: int) -> int: if index < 0 or index >= len(self.elements): raise IndexError(\\"Index out of bounds\\") return self.elements[index] def remove(self, index: int) -> None: if index < 0 or index >= len(self.elements): raise IndexError(\\"Index out of bounds\\") del self.elements[index] def maximum(self) -> int: if not self.elements: raise ValueError(\\"Empty list has no maximum element\\") max_val = self.elements[0] for val in self.elements: if val > max_val: max_val = val return max_val def minimum(self) -> int: if not self.elements: raise ValueError(\\"Empty list has no minimum element\\") min_val = self.elements[0] for val in self.elements: if val < min_val: min_val = val return min_val"},{"question":"# Problem Statement You are developing an application that tracks user activity data including webpage visits. You need to implement a system to process and track unique page views per user in an efficient manner. # Task **Implement a class `UserActivityTracker` that tracks unique page views for each user.** **Specifications**: 1. The class should implement the following methods: - `__init__()`: Initializes the user activity tracker. - `record_visit(user_id, page_url)`: Records a visit to the specified page by the given user. This should only count unique visits to each page URL for every user. - `get_unique_pages(user_id)`: Returns a list of all unique pages visited by the specified user. - `total_unique_visits()`: Returns the total number of unique visits recorded across all users. **Input Format**: - `user_id`: A unique identifier for a user (an integer). - `page_url`: A string representing the URL of the page being visited. **Output Format**: - `record_visit(user_id, page_url)`: This method does not return any value. - `get_unique_pages(user_id)`: A list of strings representing the unique page URLs visited by the user. - `total_unique_visits()`: An integer representing the total number of unique page visits. **Examples**: ```python >>> tracker = UserActivityTracker() >>> tracker.record_visit(1, \\"http://example.com/home\\") >>> tracker.record_visit(1, \\"http://example.com/about\\") >>> tracker.record_visit(1, \\"http://example.com/home\\") >>> tracker.get_unique_pages(1) [\'http://example.com/home\', \'http://example.com/about\'] >>> tracker.record_visit(2, \\"http://example.com/home\\") >>> tracker.record_visit(2, \\"http://example.com/contact\\") >>> tracker.get_unique_pages(2) [\'http://example.com/home\', \'http://example.com/contact\'] >>> tracker.total_unique_visits() 4 ``` # Constraints: - Assume the number of users and page URLs is manageable within the available memory. - Optimize for efficient handling of unique page views tracking and retrieval.","solution":"class UserActivityTracker: def __init__(self): self.user_pages = {} self.unique_visits = set() def record_visit(self, user_id, page_url): if user_id not in self.user_pages: self.user_pages[user_id] = set() if page_url not in self.user_pages[user_id]: self.user_pages[user_id].add(page_url) self.unique_visits.add((user_id, page_url)) def get_unique_pages(self, user_id): if user_id not in self.user_pages: return [] return list(self.user_pages[user_id]) def total_unique_visits(self): return len(self.unique_visits)"},{"question":"# Problem Statement You are provided with a list of strings representing names and a list of numbers representing scores. Each name corresponds to a score at the same index in its respective list. Your task is to write a function that groups the scores by the names and returns a dictionary where each key is a name, and the corresponding value is a list of scores associated with that name. Additionally, sort each list of scores in descending order. Function Signature ```python def group_scores_by_name(names: list[str], scores: list[int]) -> dict[str, list[int]]: pass ``` # Input * `names`: A list of strings where each string is a name. (1 ≤ len(names) ≤ 1000) * `scores`: A list of integers where each integer is a score. (1 ≤ len(scores) ≤ 1000) * It is guaranteed that the lengths of the `names` and `scores` lists are equal. # Output * A dictionary where keys are names (str) and values are lists of integers. Each list of integers should be sorted in descending order. # Constraints * Each name may appear multiple times in the `names` list. * All integers in the `scores` list are non-negative and less than or equal to 100. # Example ```python # Example 1: names = [\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Alice\\"] scores = [50, 40, 70, 60, 80] assert group_scores_by_name(names, scores) == { \\"Alice\\": [80, 70, 50], \\"Bob\\": [60, 40] } # Example 2: names = [\\"Charlie\\"] scores = [100] assert group_scores_by_name(names, scores) == { \\"Charlie\\": [100] } # Example 3: names = [\\"David\\", \\"Eve\\", \\"David\\"] scores = [20, 30, 25] assert group_scores_by_name(names, scores) == { \\"David\\": [25, 20], \\"Eve\\": [30] } ``` # Additional Information * Consider using a dictionary to store names as keys and lists of their scores as values. * Use appropriate list methods and sorting algorithms to ensure that the lists of scores are sorted in descending order. * Ensure your solution is efficient and handles the input constraints gracefully. Good luck!","solution":"def group_scores_by_name(names: list[str], scores: list[int]) -> dict[str, list[int]]: Groups scores by corresponding names and sorts each list of scores in descending order. Args: names (list of str): List of names. scores (list of int): List of scores. Returns: dict: A dictionary where keys are names and values are lists of scores sorted in descending order. from collections import defaultdict result = defaultdict(list) for name, score in zip(names, scores): result[name].append(score) for name in result: result[name].sort(reverse=True) return dict(result)"},{"question":"**Question**: **Traveling Salesman Problem (TSP) for Small Dataset** **Context**: Given a list of cities and the distances between each pair of cities, your task is to determine the length of the shortest possible route that visits each city exactly once and returns to the starting city (i.e., solve the Traveling Salesman Problem for small datasets). **Details**: 1. Implement a function `tsp(cities: List[str], distances: List[List[int]]) -> int` that: - Takes a list of city names and a 2D distance matrix representing the distances between each pair of cities. - Returns the length of the shortest possible round trip that visits each city exactly once and returns to the starting city. 2. You may assume that there are at most 10 cities, making it feasible to use brute-force approaches. **Input Format**: - `cities`: A list of city names (strings). - `distances`: A 2D list (matrix) where `distances[i][j]` is the distance between the `i`-th and `j`-th cities. **Output Format**: - An integer representing the length of the shortest possible round trip. **Constraints**: - The number of cities `n` is at most 10 (1 ≤ n ≤ 10). - The `distances` matrix is symmetric, and `distances[i][i] = 0`. **Example**: ```python def tsp(cities, distances): # Your implementation here # Example usage: city_names = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] distance_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] result = tsp(city_names, distance_matrix) print(result) # Expected Output: # 80 city_names = [\\"A\\", \\"B\\", \\"C\\"] distance_matrix = [ [0, 5, 9], [5, 0, 10], [9, 10, 0] ] result = tsp(city_names, distance_matrix) print(result) # Expected Output: # 24 ``` In this question, the Traveling Salesman Problem (TSP) is posed with a constraint on the number of cities, ensuring that a brute-force solution is computationally feasible. This complements the existing set of questions by exploring another fundamental computational problem involving graphs and optimization.","solution":"from itertools import permutations def tsp(cities, distances): Solves the Traveling Salesman Problem for a small number of cities using brute-force. Parameters: cities (List[str]): A list of city names. distances (List[List[int]]): A 2D list representing distances between cities. Returns: int: The length of the shortest round trip that visits each city exactly once and returns to the starting city. n = len(cities) min_path_cost = float(\'inf\') # Generate all possible permutations of cities for perm in permutations(range(n)): current_path_cost = 0 # Calculate the total distance for this permutation for i in range(n): current_path_cost += distances[perm[i]][perm[(i + 1) % n]] # Update minimum path cost if current path is shorter min_path_cost = min(min_path_cost, current_path_cost) return min_path_cost"},{"question":"# Scenario: You have been given a list of integers representing the heights of trees in a forest. During a survey, you need to determine the maximum difference in heights between any two trees. # Task: Write a function `max_height_difference` that takes a list of integers representing tree heights and returns the maximum difference between the heights of the tallest and the shortest tree. # Expected Function: ```python def max_height_difference(tree_heights: list) -> int: ``` # Input Format: * A list of integers `tree_heights` with length `n` where `2 <= n <= 10^5`. # Output Format: * An integer representing the maximum height difference. # Constraints: * The function should run in linear time, O(n). * The heights in the tree_heights list are not necessarily unique. # Example: ```python >>> max_height_difference([10, 20, 30, 40]) 30 >>> max_height_difference([100, 50, 25, 75]) 75 >>> max_height_difference([12, 12, 12, 12]) 0 ``` # Notes: 1. Ensure that your solution handles edge cases and performs efficiently for large input sizes. 2. Optimize the function to minimize time complexity, aiming for O(n) time using a single pass through the list.","solution":"def max_height_difference(tree_heights: list) -> int: Returns the maximum difference in heights between the tallest and the shortest tree. # Initialize the minimum and maximum with the first element min_height = max_height = tree_heights[0] # Traverse through all tree heights to find the minimum and maximum heights for height in tree_heights: if height < min_height: min_height = height if height > max_height: max_height = height # The maximum difference between the tallest and the shortest tree return max_height - min_height"},{"question":"# Scenario An e-commerce company wants to develop a system for managing product inventories in their warehouses. One key component is to effectively track the in-and-out movements of products to ensure accurate stock levels. To achieve this, the company needs a program that can analyze the movements and provide real-time stock information for each product. **Your Task**: Implement an inventory management system that efficiently tracks the product quantities in the warehouse based on a series of transactions. Your program should compute and output the current stock level of each product after processing all transactions. # Input Format You will be given: 1. An integer `m` representing the number of unique products. 2. A list of `m` strings representing the product names. 3. An integer `t` representing the number of transactions. 4. A list of `t` strings representing the transaction types (\\"in\\" for incoming stock, \\"out\\" for outgoing stock). 5. A list of `t` strings representing the product names involved in each transaction. 6. A list of `t` integers representing the quantities associated with each transaction. # Output Format Your program should print the current stock level for each product in alphabetical order of product names. # Constraints 1. 1 <= m <= 1000 2. 1 <= t <= 10000 3. 1 <= quantity[i] <= 1000 # Example ```python m = 3 product_names = [\\"apple\\", \\"banana\\", \\"orange\\"] t = 5 transaction_types = [\\"in\\", \\"out\\", \\"in\\", \\"in\\", \\"out\\"] transaction_product_names = [\\"apple\\", \\"banana\\", \\"orange\\", \\"banana\\", \\"orange\\"] transaction_quantities = [50, 20, 30, 40, 10] ``` Expected output: ``` apple: 50 banana: 20 orange: 20 ``` # Function Signature ```python def inventory_management(m: int, product_names: List[str], t: int, transaction_types: List[str], transaction_product_names: List[str], transaction_quantities: List[int]) -> None: # your code here ``` # Notes * Ensure your code handles transactions appropriately, updating stock levels correctly. * Pay attention to proper formatting in the output. * Consider efficiency in processing transactions, especially for large inputs.","solution":"def inventory_management(m, product_names, t, transaction_types, transaction_product_names, transaction_quantities): # Initialize a dictionary to store the stock levels of each product stock_levels = {name: 0 for name in product_names} # Process each transaction for i in range(t): product_name = transaction_product_names[i] quantity = transaction_quantities[i] if transaction_types[i] == \\"in\\": stock_levels[product_name] += quantity elif transaction_types[i] == \\"out\\": stock_levels[product_name] -= quantity # Sort the product names alphabetically and print stock levels for product_name in sorted(stock_levels.keys()): print(f\\"{product_name}: {stock_levels[product_name]}\\")"},{"question":"# Scenario You are creating a utility for a financial application to help users track their investments. As part of this tool, you need to convert an array of daily prices for a particular stock into a list of percentage changes between consecutive days. This will allow users to quickly gauge the volatility of the stock. # Task Implement a function called `calculate_percentage_changes` that takes an array of daily prices and returns an array of the same length where each element represents the percentage change from the previous day to the current day. The first element of the output array should always be 0 since there is no previous day to compare to. # Function Signature ```python def calculate_percentage_changes(prices: List[float]) -> List[float]: ``` # Input 1. `prices`: A list of floats representing daily stock prices. The list will contain at least one price. All prices are positive numbers. # Output The function should return a list of floats representing the percentage changes. The first element should be 0. # Constraints * The prices will always be positive floats. * The list will contain at least one element. # Example ```python >>> calculate_percentage_changes([100.0, 105.0, 102.0, 110.0]) [0, 5.0, -2.857142857142857, 7.8431372549019605] >>> calculate_percentage_changes([200.0]) [0] >>> calculate_percentage_changes([50.0, 50.0, 50.0]) [0, 0.0, 0.0] >>> calculate_percentage_changes([50.0, 100.0, 50.0]) [0, 100.0, -50.0] ``` # Note In case there is only one price in the input list, the output should be `[0]` since there is no previous day to compare. Each percentage change is calculated as: (((current_price - previous_price) / previous_price) times 100).","solution":"from typing import List def calculate_percentage_changes(prices: List[float]) -> List[float]: if len(prices) == 1: return [0] percentage_changes = [0] # The first day change is always 0 for i in range(1, len(prices)): previous_price = prices[i - 1] current_price = prices[i] percentage_change = ((current_price - previous_price) / previous_price) * 100 percentage_changes.append(percentage_change) return percentage_changes"},{"question":"# Task You are given a binary tree. Implement a function that verifies if the tree is balanced or not. # Objective Your task is to write a function `is_balanced` that takes the root of a binary tree as input and returns `True` if the tree is height-balanced, and `False` otherwise. # Function Signature ```python def is_balanced(root: Node) -> bool: ``` # Input The function `is_balanced` should take a single argument: - `root`: The root node of the binary tree (Node object). # Output The function should return a boolean: - `True` if the binary tree is height-balanced. - `False` otherwise. # Constraints - The tree can have between 0 and 10^4 nodes. - Each node\'s data value ranges from -10^4 to 10^4. # Example Consider the binary tree representation: 1 / 2 3 / 4 5 Calling `is_balanced(root)` should return `True` because: - The left subtree (rooted at 2) and the right subtree (rooted at 3) differ in height by at most 1. - Subtrees 4 and 5 are also balanced. # Edge Cases 1. A null root should return `True` (an empty tree is balanced). 2. A single-node tree should return `True`. 3. A tree with only one side having nodes (a skewed tree) should return `False` if the difference of heights exceeds 1. # Notes - Use the Node class provided in the snippet. - Efficiency and proper handling of edge cases will be considered in the evaluation.","solution":"class Node: def __init__(self, data=0, left=None, right=None): self.data = data self.left = left self.right = right def is_balanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) current_height = 1 + max(left_height, right_height) is_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_balanced _, result = check_height(root) return result"},{"question":"# Problem Description You are required to create an application that performs basic string transformations and manipulations based on specific rules. This involves reversing strings, shifting characters, and finding patterns within given strings. # Requirements 1. **Function 1: `reverse_string`** - **Input**: A string `s`. - **Output**: The reversed string. - **Behavior**: Reverse the characters in the input string and return the result. 2. **Function 2: `shift_characters`** - **Input**: A string `s` and an integer `n`. Positive `n` indicates a shift to the right; negative `n` indicates a shift to the left. - **Output**: A string with each character shifted `n` positions in the alphabet. - **Behavior**: Shift each character in the string `s` by `n` positions (wrapping around the alphabet) and return the transformed string. 3. **Function 3: `find_pattern`** - **Input**: A string `s` and a string `pattern`. - **Output**: A list of starting indices where `pattern` is found in `s`. - **Behavior**: Identify all starting positions of `pattern` within `s` and return these positions as a list. # Input and Output Formats - Inputs will be alphabetic characters only, with no spaces or special characters unless specified otherwise. - Outputs will be strings corresponding to the transformed input. # Example ```python >>> reverse_string(\'hello\') \'olleh\' >>> shift_characters(\'abc\', 2) \'cde\' >>> shift_characters(\'xyz\', 3) \'abc\' >>> find_pattern(\'abracadabra\', \'abra\') [0, 7] >>> find_pattern(\'aaaa\', \'aa\') [0, 1, 2] ``` # Constraints * Length of input strings should not exceed 100 characters. * Shifts will always stay within the bounds of the alphabet. * Input strings will only contain lowercase alphabetic characters, and you should ensure they are processed in lowercase or converted to it if necessary. # Task Implement these functions in Python to solve the problem as described.","solution":"def reverse_string(s): Returns the reversed string of the input. return s[::-1] def shift_characters(s, n): Shifts each character in the string `s` by `n` positions in the alphabet. Positive `n` shifts to the right and negative `n` shifts to the left. def shift_char(c, n): return chr((ord(c) - ord(\'a\') + n) % 26 + ord(\'a\')) return \'\'.join(shift_char(c, n) for c in s) def find_pattern(s, pattern): Returns a list of starting indices where `pattern` is found in `s`. return [i for i in range(len(s) - len(pattern) + 1) if s[i:i+len(pattern)] == pattern]"},{"question":"# Objective You are tasked with implementing a class that simulates a parking lot system and write two functions for vehicle entry and exit management. The parking lot has a fixed number of slots and can only accommodate a certain type of vehicle in each slot. # Task 1. Implement a class `ParkingLot` with the following functionalities: - Initialize the parking lot with a predefined number of slots for cars and motorcycles. - Allow a vehicle to enter if there is an available slot for that vehicle type. - Allow a vehicle to exit and free up its slot. 2. Write a function to display the current status of the parking lot, showing the number of occupied and available slots for each type of vehicle. # Instructions 1. **Implement ParkingLot Class**: - The class should have methods to initialize the parking lot, handle vehicle entry, and handle vehicle exit. - The parking lot should differentiate between cars and motorcycles. - The entry and exit methods should properly update the state of the parking lot. 2. **Function to Show Parking Lot Status**: - The function should take an instance of `ParkingLot` and print the current status showing the number of occupied and available slots for both cars and motorcycles. # Input and Output Formats ParkingLot Class - **Input** (during initialization): - `num_car_slots` (int): Number of slots available for cars. - `num_motorcycle_slots` (int): Number of slots available for motorcycles. - **Methods**: - `enter_vehicle(vehicle_type: str) -> bool`: Attempts to enter a vehicle of type `vehicle_type` (\'car\' or \'motorcycle\'). Returns `True` if successful, or `False` if no slot is available. - `exit_vehicle(vehicle_type: str) -> bool`: Attempts to exit a vehicle of type `vehicle_type`. Returns `True` if successful, or `False` if no vehicle of that type is in the lot. Function to Show Parking Lot Status - **Input**: - `parking_lot` (ParkingLot): Instance of the parking lot. - **Output**: - Prints the current status of the parking lot. # Example ```python class ParkingLot: def __init__(self, num_car_slots: int, num_motorcycle_slots: int): self.car_slots = num_car_slots self.motorcycle_slots = num_motorcycle_slots self.occupied_car_slots = 0 self.occupied_motorcycle_slots = 0 def enter_vehicle(self, vehicle_type: str) -> bool: if vehicle_type == \'car\': if self.occupied_car_slots < self.car_slots: self.occupied_car_slots += 1 return True else: return False elif vehicle_type == \'motorcycle\': if self.occupied_motorcycle_slots < self.motorcycle_slots: self.occupied_motorcycle_slots += 1 return True else: return False def exit_vehicle(self, vehicle_type: str) -> bool: if vehicle_type == \'car\': if self.occupied_car_slots > 0: self.occupied_car_slots -= 1 return True else: return False elif vehicle_type == \'motorcycle\': if self.occupied_motorcycle_slots > 0: self.occupied_motorcycle_slots -= 1 return True else: return False def show_parking_lot_status(parking_lot: ParkingLot): print(f\\"Car slots: {parking_lot.occupied_car_slots}/{parking_lot.car_slots} occupied\\") print(f\\"Motorcycle slots: {parking_lot.occupied_motorcycle_slots}/{parking_lot.motorcycle_slots} occupied\\") # Usage lot = ParkingLot(num_car_slots=10, num_motorcycle_slots=5) lot.enter_vehicle(\'car\') lot.enter_vehicle(\'motorcycle\') show_parking_lot_status(lot) lot.exit_vehicle(\'car\') show_parking_lot_status(lot) ``` In the example, you create an instance of `ParkingLot` with specified slots for cars and motorcycles. The `enter_vehicle` and `exit_vehicle` methods manage vehicle entries and exits, while the `show_parking_lot_status` function prints the current status of the parking lot.","solution":"class ParkingLot: def __init__(self, num_car_slots: int, num_motorcycle_slots: int): self.car_slots = num_car_slots self.motorcycle_slots = num_motorcycle_slots self.occupied_car_slots = 0 self.occupied_motorcycle_slots = 0 def enter_vehicle(self, vehicle_type: str) -> bool: if vehicle_type == \'car\': if self.occupied_car_slots < self.car_slots: self.occupied_car_slots += 1 return True else: return False elif vehicle_type == \'motorcycle\': if self.occupied_motorcycle_slots < self.motorcycle_slots: self.occupied_motorcycle_slots += 1 return True else: return False def exit_vehicle(self, vehicle_type: str) -> bool: if vehicle_type == \'car\': if self.occupied_car_slots > 0: self.occupied_car_slots -= 1 return True else: return False elif vehicle_type == \'motorcycle\': if self.occupied_motorcycle_slots > 0: self.occupied_motorcycle_slots -= 1 return True else: return False def show_parking_lot_status(parking_lot: ParkingLot): print(f\\"Car slots: {parking_lot.occupied_car_slots}/{parking_lot.car_slots} occupied\\") print(f\\"Motorcycle slots: {parking_lot.occupied_motorcycle_slots}/{parking_lot.motorcycle_slots} occupied\\")"},{"question":"Problem Statement You are given a non-negative integer `n`. Your task is to implement a function that calculates the n-th Fibonacci number using matrix exponentiation. Additionally, implement a function that calculates the n-th Fibonacci number modulo `m`. # Function Signature ```python def fibonacci_matrix(n: int) -> int: pass def fibonacci_matrix_mod(n: int, m: int) -> int: pass ``` # Input 1. `n` (0 <= n <= 10^9): The position in the Fibonacci sequence. 2. `m` (1 <= m <= 10^9): The modulus value. # Output 1. `fibonacci_matrix(n)` should return an integer which is the n-th Fibonacci number. 2. `fibonacci_matrix_mod(n, m)` should return an integer which is the n-th Fibonacci number modulo m. # Examples fibonacci_matrix ```python fibonacci_matrix(0) # Output: 0 fibonacci_matrix(1) # Output: 1 fibonacci_matrix(2) # Output: 1 fibonacci_matrix(3) # Output: 2 fibonacci_matrix(10) # Output: 55 fibonacci_matrix(20) # Output: 6765 fibonacci_matrix(50) # Output: 12586269025 ``` fibonacci_matrix_mod ```python fibonacci_matrix_mod(0, 5) # Output: 0 fibonacci_matrix_mod(5, 7) # Output: 5 fibonacci_matrix_mod(10, 12) # Output: 7 fibonacci_matrix_mod(20, 15) # Output: 0 fibonacci_matrix_mod(50, 100) # Output: 25 fibonacci_matrix_mod(10**6, 1000) # Output: 875 ``` # Constraints - The functions must operate within a time complexity of O(log n) and space complexity of O(1). - You must use matrix exponentiation to compute the Fibonacci numbers. - Ensure to handle large values for `n` and intermediate computations efficiently. - Take care to avoid overflowing the integers by using modular arithmetic where necessary. # Notes - Matrix exponentiation provides a highly efficient method to compute Fibonacci numbers, especially for large `n`. - The n-th Fibonacci number can be computed by raising the matrix [[1, 1], [1, 0]] to the power of n-1. - The property F(n) % m should be used to keep computations within manageable limits for large n.","solution":"def matrix_mult(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_mult_mod(A, B, m): return [ [(A[0][0]*B[0][0] + A[0][1]*B[1][0]) % m, (A[0][0]*B[0][1] + A[0][1]*B[1][1]) % m], [(A[1][0]*B[0][0] + A[1][1]*B[1][0]) % m, (A[1][0]*B[0][1] + A[1][1]*B[1][1]) % m] ] def matrix_pow(A, n): result = [[1, 0], [0, 1]] base = A while n > 0: if n % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) n = n // 2 return result def matrix_pow_mod(A, n, m): result = [[1, 0], [0, 1]] base = A while n > 0: if n % 2 == 1: result = matrix_mult_mod(result, base, m) base = matrix_mult_mod(base, base, m) n = n // 2 return result def fibonacci_matrix(n): if n == 0: return 0 A = [[1, 1], [1, 0]] result = matrix_pow(A, n-1) return result[0][0] def fibonacci_matrix_mod(n, m): if n == 0: return 0 A = [[1, 1], [1, 0]] result = matrix_pow_mod(A, n-1, m) return result[0][0]"},{"question":"# Coding Assessment Question **Problem Statement**: You are given a list of integers `arr` and an integer `k`. Your task is to write a function `top_k_frequent_elements` that returns the `k` most frequent elements in the list in descending order of their frequency. If multiple elements have the same frequency, they should be sorted by their value in ascending order. If the input is invalid (non-integer list elements, non-integer k, or invalid value for k), the function should raise a `ValueError` with a message \\"Invalid input\\". **Function Signature**: ```python def top_k_frequent_elements(arr: List[int], k: int) -> List[int]: pass ``` **Input**: * A list of integers `arr` where `-10^5 <= arr[i] <= 10^5` and the length of the list does not exceed `10^4`. * An integer `k` where `1 <= k <= len(arr)`. **Output**: * A list of the `k` most frequent integers in descending order of their frequency. If frequencies are the same, sort by value in ascending order. **Constraints**: * The input list must contain only integers. * The integer `k` must be within the valid range. * If the input is not valid, raise a `ValueError` with the message \\"Invalid input\\". **Examples**: ```python assert top_k_frequent_elements([1,1,1,2,2,3], 2) == [1, 2] assert top_k_frequent_elements([4,4,4,6,6,6,5,5,7,7,7,7], 3) == [7, 4, 6] assert top_k_frequent_elements([1,2,3,2,4,3,3,5,1], 1) == [3] try: top_k_frequent_elements([1,2,3], 4) except ValueError as e: assert str(e) == \\"Invalid input\\" try: top_k_frequent_elements([1,2,3], \'test\') except ValueError as e: assert str(e) == \\"Invalid input\\" try: top_k_frequent_elements([1,2,\'a\',3], 2) except ValueError as e: assert str(e) == \\"Invalid input\\" ``` **Performance Requirement**: Ensure that the function runs efficiently for large input sizes up to `10^4` elements.","solution":"from typing import List from collections import Counter def top_k_frequent_elements(arr: List[int], k: int) -> List[int]: # Validate the inputs if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr) or not isinstance(k, int) or k < 1 or k > len(arr): raise ValueError(\\"Invalid input\\") # Compute the frequency of each element count = Counter(arr) # Sort elements first by frequency in descending order, then by element value in ascending order sorted_elements = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k elements result = [element for element, _ in sorted_elements[:k]] return result"},{"question":"# Problem Description You are required to implement the Breath-First Search (BFS) algorithm to traverse and find the shortest path in an unweighted undirected graph. Your implementation should correctly find the shortest path between two given nodes using the BFS traversal method. # Requirements - Implement the BFS traversal algorithm. - Ensure the algorithm finds the shortest path in terms of the number of edges. - Handle graphs with disconnected components gracefully. # Constraints - Nodes will be integers or strings. - The graph will contain up to 10<sup>4</sup> nodes. - The graph is unweighted and undirected. # Input The input consists of: - A list of tuples where each tuple represents an edge of the graph in the form (node1, node2). - Two nodes representing the start node and the end node for finding the shortest path. Example input: ``` [ (1, 2), (2, 3), (1, 4), (4, 5) ], 1, 3 ``` # Output The output should be a list of nodes representing the shortest path from the start node to the end node. If there are multiple paths with the same length, return any one of them. If there is no valid path, return an empty list. Example output: ``` [1, 2, 3] ``` # Example Given the input graph edges and nodes: ``` [ (1, 2), (2, 3), (1, 4), (4, 5) ], 1, 3 ``` A possible valid output for the shortest path could be: ``` [1, 2, 3] ``` # Implementation Details 1. **Graph Representation**: - Use an adjacency list representation to store the graph. - Implement utility methods to add edges and perform BFS traversal. 2. **BFS Algorithm**: - Implement the BFS algorithm to find the shortest path between two given nodes. # Code Template ```python from typing import List, Tuple, Union, Any from collections import deque, defaultdict class Graph: def __init__(self): self.adj_list = defaultdict(list) def add_edge(self, node1: Union[int, str], node2: Union[int, str]): self.adj_list[node1].append(node2) self.adj_list[node2].append(node1) def bfs_shortest_path(self, start: Union[int, str], end: Union[int, str]) -> List[Union[int, str]]: queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path if current_node not in visited: visited.add(current_node) for neighbor in self.adj_list[current_node]: queue.append((neighbor, path + [neighbor])) return [] def find_shortest_path(graph_edges: List[Tuple[Any, Any]], start: Any, end: Any) -> List[Any]: graph = Graph() for edge in graph_edges: graph.add_edge(edge[0], edge[1]) return graph.bfs_shortest_path(start, end) # Example usage: # graph_edges = [(1, 2), (2, 3), (1, 4), (4, 5)] # start_node = 1 # end_node = 3 # assert find_shortest_path(graph_edges, start_node, end_node) == [1, 2, 3] ``` This implementation accurately reflects the style, complexity, length, and topic alignment with the provided sample questions, ensuring that it seamlessly integrates with the original set.","solution":"from typing import List, Tuple, Union, Any from collections import deque, defaultdict class Graph: def __init__(self): self.adj_list = defaultdict(list) def add_edge(self, node1: Union[int, str], node2: Union[int, str]): self.adj_list[node1].append(node2) self.adj_list[node2].append(node1) def bfs_shortest_path(self, start: Union[int, str], end: Union[int, str]) -> List[Union[int, str]]: if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path if current_node not in visited: visited.add(current_node) for neighbor in self.adj_list[current_node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] def find_shortest_path(graph_edges: List[Tuple[Any, Any]], start: Any, end: Any) -> List[Any]: graph = Graph() for edge in graph_edges: graph.add_edge(edge[0], edge[1]) return graph.bfs_shortest_path(start, end)"},{"question":"# Context: As part of an educational software for understanding number sequences, you are tasked with developing a function that works with arithmetic progressions. Given the first term, common difference, and the number of terms, you must generate the entire sequence. # Problem Statement: Write a function `generate_arithmetic_sequence(first_term: int, common_diff: int, num_terms: int) -> List[int]` that generates an arithmetic sequence based on the given parameters. Your implementation should: 1. Ensure the number of terms (`num_terms`) is a positive integer greater than zero. 2. Compute each term in the sequence using the formula `term_n = first_term + (n - 1) * common_diff`. 3. Return the sequence as a list of integers. 4. Raise `ValueError` with a descriptive message if `num_terms` is less than or equal to zero. # Input: * An integer `first_term` (the first term of the sequence). * An integer `common_diff` (the difference between successive terms). * An integer `num_terms` (the number of terms in the sequence; should be > 0). # Output: * A list of integers representing the arithmetic sequence. # Constraints: * Assume `first_term` and `common_diff` will be within the range `-10^6` to `10^6`. * Assume `num_terms` will be within the range `1` to `10^4`. # Examples: ```python >>> generate_arithmetic_sequence(2, 3, 5) [2, 5, 8, 11, 14] >>> generate_arithmetic_sequence(5, 0, 4) [5, 5, 5, 5] >>> generate_arithmetic_sequence(1, -1, 3) [1, 0, -1] >>> generate_arithmetic_sequence(1, 2, 0) Traceback (most recent call last): ... ValueError: The number of terms must be a positive integer ``` # Detailed Requirements: 1. Validate that `num_terms` is a positive integer. Raise `ValueError(\\"The number of terms must be a positive integer\\")` if it is not. 2. Use the given formula to compute each term in the arithmetic sequence. 3. Return the sequence as a list. 4. Optimize for performance to handle the upper limit of constraints efficiently.","solution":"from typing import List def generate_arithmetic_sequence(first_term: int, common_diff: int, num_terms: int) -> List[int]: Generates an arithmetic sequence based on the given first term, common difference, and number of terms. Parameters: - first_term (int): The first term of the sequence. - common_diff (int): The common difference between successive terms. - num_terms (int): The number of terms in the sequence; should be greater than 0. Returns: - List[int]: The generated arithmetic sequence. Raises: - ValueError: If `num_terms` is less than or equal to 0. if num_terms <= 0: raise ValueError(\\"The number of terms must be a positive integer\\") return [first_term + (n - 1) * common_diff for n in range(1, num_terms + 1)]"},{"question":"# Scenario You are developing a system that analyzes large sets of numerical data for statistical purposes. One key feature of this system is the ability to compute the running median of a stream of numbers. This allows for real-time monitoring of the data\'s central tendency. # Coding Task Write a class `RunningMedian` that efficiently computes the median of a sequence of numbers as they are added one by one. # Input 1. The class should support a method `add_number(num: int) -> None` which adds a new number to the data stream. 2. The class should support a method `get_median() -> float` which returns the current median of the data stream. # Output 1. `float`: The median of the data stream after each insertion. If the number of elements is even, the median is the average of the two middle elements. If the number of elements is odd, the median is the middle element. # Constraints 1. All input numbers will be integers. 2. The number of elements added can reach up to `10^6`. # Performance Requirements 1. Efficient data structure utilization to ensure optimal time complexity for both insertion and median calculation. 2. Handle large input sizes within a reasonable time frame. # Example ```python rm = RunningMedian() rm.add_number(1) print(rm.get_median()) # Output: 1.0 rm.add_number(5) print(rm.get_median()) # Output: 3.0 rm.add_number(2) print(rm.get_median()) # Output: 2.0 ``` # Starter Code ```python import heapq class RunningMedian: def __init__(self): # Max-heap for the lower half self.low = [] # Min-heap for the upper half self.high = [] def add_number(self, num: int) -> None: if len(self.low) == 0 or num <= -self.low[0]: heapq.heappush(self.low, -num) else: heapq.heappush(self.high, num) # Balance the heaps if len(self.low) > len(self.high) + 1: heapq.heappush(self.high, -heapq.heappop(self.low)) elif len(self.high) > len(self.low): heapq.heappush(self.low, -heapq.heappop(self.high)) def get_median(self) -> float: if len(self.low) > len(self.high): return float(-self.low[0]) else: return (-self.low[0] + self.high[0]) / 2.0 # Example: # rm = RunningMedian() # rm.add_number(1) # print(rm.get_median()) # Output: 1.0 # rm.add_number(5) # print(rm.get_median()) # Output: 3.0 # rm.add_number(2) # print(rm.get_median()) # Output: 2.0 ``` # Evaluation Criteria * Correctness: The sequence of medians produced must be accurate. * Efficiency: The insertion and median retrieval should conform to the expected time complexities. * Edge Case Handling: Correctly managing inputs to maintain the balance between heaps.","solution":"import heapq class RunningMedian: def __init__(self): # Max-heap for the lower half self.low = [] # Min-heap for the upper half self.high = [] def add_number(self, num: int) -> None: if len(self.low) == 0 or num <= -self.low[0]: heapq.heappush(self.low, -num) else: heapq.heappush(self.high, num) # Balance the heaps if len(self.low) > len(self.high) + 1: heapq.heappush(self.high, -heapq.heappop(self.low)) elif len(self.high) > len(self.low): heapq.heappush(self.low, -heapq.heappop(self.high)) def get_median(self) -> float: if len(self.low) > len(self.high): return float(-self.low[0]) else: return (-self.low[0] + self.high[0]) / 2.0 # Example usage: # rm = RunningMedian() # rm.add_number(1) # print(rm.get_median()) # Output: 1.0 # rm.add_number(5) # print(rm.get_median()) # Output: 3.0 # rm.add_number(2) # print(rm.get_median()) # Output: 2.0"},{"question":"# Scenario You have to implement a system for processing image data. As part of this system, you need a way to efficiently flip an image represented as a 2D grid of pixel values. Each pixel value is either 0 (representing a black pixel) or 1 (representing a white pixel). The flip operation should reverse the row order. # Problem Statement Implement a function `flip_image(image: List[List[int]]) -> List[List[int]]` that takes a 2D list `image` representing a binary image and returns a new 2D list with the rows in reversed order. # Input and Output Formats * The function will receive a 2D list of integers as input. * The function will return a 2D list of integers. # Constraints * The dimensions of the image can be up to (1000 times 1000). * Each pixel in the image is either 0 or 1. # Performance Requirements * The implementation should have linear time complexity (O(n times m)), where (n) is the number of rows and (m) is the number of columns in the image. # Example Cases ```python >>> flip_image([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) [[0, 0, 1], [0, 1, 0], [1, 0, 0]] >>> flip_image([[1, 1, 0], [0, 0, 1], [1, 1, 1]]) [[1, 1, 1], [0, 0, 1], [1, 1, 0]] >>> flip_image([[0, 0, 0], [1, 1, 1], [0, 1, 0]]) [[0, 1, 0], [1, 1, 1], [0, 0, 0]] ``` # Additional Notes * Do not modify the input image in place. Instead, create a new 2D list to return. * Consider edge cases such as empty images or images with only one row.","solution":"def flip_image(image): Reverse the rows order of the given 2D list representing a binary image. Parameters: image (List[List[int]]): A 2D list representing a binary image. Returns: List[List[int]]: A new 2D list with the rows in reversed order. return image[::-1]"},{"question":"# Scenario You are tasked with developing a feature that generates unique user IDs for a web application. Each user ID should be a string consisting of a specific prefix followed by a sequence of digits. To ensure uniqueness, the digit sequence should start from 1 and increment by 1 for each new user. # Task 1. Implement a class `UserIDGenerator` that generates unique user IDs. 2. Write unit tests for your class to ensure it works as expected. # Requirements **Class Definition**: ```python class UserIDGenerator: def __init__(self, prefix: str): # Your implementation here def generate_id(self) -> str: # Your implementation here ``` **Usage**: 1. Upon instantiation, `UserIDGenerator` takes a `prefix` argument that will be the prefix for all generated user IDs. 2. The `generate_id` method returns a unique user ID each time it is called, starting with the prefix followed by \\"1\\", then prefix followed by \\"2\\", and so on. # Example ```python generator = UserIDGenerator(\\"User\\") print(generator.generate_id()) # Expected output: \\"User1\\" print(generator.generate_id()) # Expected output: \\"User2\\" print(generator.generate_id()) # Expected output: \\"User3\\" ``` # Constraints - The prefix is guaranteed to be a non-empty string consisting of alphanumeric characters. - The generated user IDs should not include any leading zeros in the digit sequence. - Ensure the class handles multiple instances independently and does not share the counter between instances. # Testing - Write unit tests to validate the proper functioning of the `UserIDGenerator` class. - Ensure the `generate_id` method consistently returns unique IDs and independently increments for each instance of the class. - Use assertions to check that the expected output matches the actual output for various scenarios. # Additional Information - Consider edge cases like a very large number of user IDs being generated. - Handle cases such as reinitializing the class with a different prefix and ensuring the count starts from 1 for each new prefix instance.","solution":"class UserIDGenerator: def __init__(self, prefix: str): self.prefix = prefix self.counter = 0 def generate_id(self) -> str: self.counter += 1 return f\\"{self.prefix}{self.counter}\\""},{"question":"# Scenario You are part of a development team working on a system that handles a large number of financial transactions. One of the tasks is to generate a comprehensive report summarizing the daily transactions. To do this, you need to group the transactions by their date and calculate the total amount for each day. # Task Implement a function `summarize_transactions` that takes a list of dictionaries, each representing a transaction, and returns a summary of transactions grouped by date. # Function Signature ```python def summarize_transactions(transactions: list) -> dict: Summarizes the daily transactions by grouping them by date and calculating the total amount for each day. :param transactions: List of dictionaries, each representing a transaction with keys \'date\' (str) and \'amount\' (float) :return: Dictionary where the keys are dates (str) and the values are the total transaction amount (float) for each day ``` # Input - `transactions`: A list of dictionaries `transactions`, where each dictionary contains: - `\'date\'`: A string representing the date in the format \'YYYY-MM-DD\'. - `\'amount\'`: A float representing the amount of the transaction. # Output The function should return a dictionary where the keys are dates (as strings in \'YYYY-MM-DD\' format) and the values are the total amounts (floats) of transactions for each corresponding date. # Constraints - The length of `transactions` will be between 1 and 10^5. - Dates in the input list are guaranteed to be in valid \'YYYY-MM-DD\' format. - Transaction amounts are floats within the range -10^6 to 10^6. # Example ```python transactions = [ {\'date\': \'2023-01-01\', \'amount\': 100.0}, {\'date\': \'2023-01-01\', \'amount\': 200.5}, {\'date\': \'2023-01-02\', \'amount\': 50.0}, {\'date\': \'2023-01-03\', \'amount\': -20.0} ] result = summarize_transactions(transactions) print(result) # Output: {\'2023-01-01\': 300.5, \'2023-01-02\': 50.0, \'2023-01-03\': -20.0} ``` # Notes - The solution should handle large inputs efficiently and return the correct accumulated amounts for each date. - You may assume that the transaction list is not necessarily sorted by date. - Ensure the function is resilient to transactions on the same date but spread across the input list, and handle them by summing the amounts correctly.","solution":"def summarize_transactions(transactions): Summarizes the daily transactions by grouping them by date and calculating the total amount for each day. :param transactions: List of dictionaries, each representing a transaction with keys \'date\' (str) and \'amount\' (float) :return: Dictionary where the keys are dates (str) and the values are the total transaction amount (float) for each day summary = {} for transaction in transactions: date = transaction[\'date\'] amount = transaction[\'amount\'] if date in summary: summary[date] += amount else: summary[date] = amount return summary"},{"question":"# Task You need to develop an algorithm to find all possible combinations of a given string\'s characters that can be rearranged into palindromes. # Objective Given a string `s`, write a function `generate_palindromic_permutations` that returns all the unique palindromic permutations of the string. # Input - `s` (str): A string consisting of lowercase letters. # Output - List[str]: List of all unique palindromic permutations of the string, sorted in lexicographical order. An empty list if no palindromic permutation exists. # Constraints 1. The input string length should be between 1 and 10 (`1 <= len(s) <= 10`). 2. The string only contains lowercase English letters. # Examples ```python generate_palindromic_permutations(\\"aabb\\") # Output: [\\"abba\\", \\"baab\\"] generate_palindromic_permutations(\\"abc\\") # Output: [] generate_palindromic_permutations(\\"a\\") # Output: [\\"a\\"] generate_palindromic_permutations(\\"aaa\\") # Output: [\\"aaa\\"] ``` # Guidelines - Consider edge cases such as strings with no possible palindromic permutations. - Optimize for performance by avoiding unnecessary computations. - Utilize backtracking and frequency counting to facilitate permutation generation. **Hint**: A palindrome reads the same forwards and backwards, so the first and second halves must mirror each other.","solution":"from collections import Counter def generate_palindromic_permutations(s): def can_form_palindrome(s): count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) return odd_count <= 1 def generate_half_permutations(half): perm = [] def backtrack(path, counter): if len(path) == len(half): perm.append(\\"\\".join(path)) return for char in sorted(counter.keys()): # Sort to ensure lexicographic order if counter[char] > 0: path.append(char) counter[char] -= 1 backtrack(path, counter) path.pop() counter[char] += 1 backtrack([], Counter(half)) return perm if not can_form_palindrome(s): return [] char_counter = Counter(s) middle = [char for char, count in char_counter.items() if count % 2 != 0] half = [char * (count // 2) for char, count in char_counter.items()] half = \\"\\".join(half) half_permutations = generate_half_permutations(half) palindromic_permutations = [ perm + \\"\\".join(middle) + perm[::-1] for perm in half_permutations ] return palindromic_permutations"},{"question":"# Task: Implementing a Linked List with Cycle Detection You are required to implement a linked list with an efficient method to detect cycles within it. Your implementation should handle different use cases effectively, ensuring accurate detection of any cycles. # Input: - A series of operations to perform on the linked list. Each operation is given as a string. - **\\"append <value>\\"**: Append an integer value to the end of the list. - **\\"create_cycle <index>\\"**: Create a cycle in the linked list by linking the last node to the node at the specified index (0-based). - **\\"detect_cycle\\"**: Detect if there is a cycle in the linked list. # Output: - For each **\\"detect_cycle\\"** operation, return **True** if a cycle is detected and **False** otherwise. # Constraints: - The list will contain at most `10^5` nodes. - Each value in the list will be an integer within the range `-10^6` to `10^6`. - The number of operations will not exceed `10^5`. # Example: ```python # Example usage: operations = [ \\"append 1\\", \\"append 2\\", \\"append 3\\", \\"create_cycle 1\\", \\"detect_cycle\\" ] # Result should be: # [True] operations = [ \\"append 1\\", \\"append 2\\", \\"append 3\\", \\"detect_cycle\\" ] # Result should be: # [False] ``` # Additional Notes: - Implement the linked list using a class structure. - The cycle detection should utilize Floyd\'s Tortoise and Hare algorithm (two-pointer technique) for efficient detection. - Handle edge cases like checking for cycles in an empty list or a single-element list gracefully.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = ListNode(value) if not self.head: self.head = new_node self.tail = new_node else: self.tail.next = new_node self.tail = new_node def create_cycle(self, index): if not self.head: return current = self.head target_node = None i = 0 while current: if i == index: target_node = current if current.next is None: self.tail = current current = current.next i += 1 if self.tail: self.tail.next = target_node def detect_cycle(self): if not self.head: return False slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Coding Assessment Question: Bitwise Swap without Temporary Variable **Context**: In low-level programming and system optimizations, in-place operations can have performance benefits. One such operation is swapping values without using a temporary variable, utilizing bitwise XOR. **Objective**: Write a function `bitwise_swap(a: int, b: int) -> tuple` that swaps the values of `a` and `b` without using any temporary variable and returns the swapped values as a tuple `(new_a, new_b)`. **Function Signature**: ```python def bitwise_swap(a: int, b: int) -> tuple: pass ``` # Input: - Two integers `a` and `b` where `-10^18 <= a, b <= 10^18`. # Output: - A tuple `(new_a, new_b)` where `new_a` is the value that was originally in `b` and `new_b` is the value that was originally in `a`. # Constraints: - You must use bitwise XOR to swap the numbers. - Handle large integer inputs efficiently within the provided constraints. # Examples: ```python >>> bitwise_swap(5, 7) (7, 5) >>> bitwise_swap(-10, 20) (20, -10) >>> bitwise_swap(0, 1000000000000000000) (1000000000000000000, 0) >>> bitwise_swap(-1000, -2000) (-2000, -1000) >>> bitwise_swap(1, 1) (1, 1) ``` # Additional Notes: 1. The XOR swap algorithm can be implemented as follows: - `a = a ^ b` - `b = a ^ b` - `a = a ^ b` 2. This method does not require any additional space, thus making it an in-place swap. 3. Pay attention to how XOR operates and how it ensures that values can be swapped without using extra storage. [End of Question]","solution":"def bitwise_swap(a: int, b: int) -> tuple: Swaps the values of a and b using bitwise XOR and returns the swapped values as a tuple. :param a: First integer to swap :param b: Second integer to swap :return: A tuple (new_a, new_b) where new_a is the value that was originally in b, and new_b is the value that was originally in a. a = a ^ b b = a ^ b a = a ^ b return (a, b)"},{"question":"# Problem Statement You have been tasked with creating a budgeting application that tracks income and expenses over several months. To facilitate this, you need to implement a function that calculates the net balance after a given number of months, accounting for recurring monthly incomes and expenses. # Task Implement a function `calculate_net_balance` that computes the net balance after a specified number of months, based on monthly income, initial balance, and recurring monthly expenses. Function Signature ```python def calculate_net_balance( initial_balance: float, monthly_income: float, monthly_expenses: float, months: int ) -> float: ``` Input * `initial_balance` (float): The initial amount in the account. * `monthly_income` (float): The recurring monthly income. * `monthly_expenses` (float): The recurring monthly expenses. * `months` (int): The number of months over which to calculate the net balance. Output * (float): The net balance in the account after the specified number of months. Constraints * The values for `initial_balance`, `monthly_income`, and `monthly_expenses` must be non-negative. * The value for `months` must be a non-negative integer. # Example ```python net_balance = calculate_net_balance(5000.0, 3000.0, 2000.0, 6) print(net_balance) # Output should be the net balance after 6 months ``` # Notes 1. Ensure to validate the input values. 2. The function should handle edge cases, such as zero months, zero income, or zero expenses. 3. Document any assumptions or additional considerations in your solution, such as what to do in the case of negative net balance.","solution":"def calculate_net_balance(initial_balance: float, monthly_income: float, monthly_expenses: float, months: int) -> float: Calculate the net balance after a given number of months. Parameters: initial_balance (float): The initial amount in the account. monthly_income (float): The recurring monthly income. monthly_expenses (float): The recurring monthly expenses. months (int): The number of months over which to calculate the net balance. Returns: float: The net balance in the account after the specified number of months. # Validate inputs if initial_balance < 0 or monthly_income < 0 or monthly_expenses < 0 or months < 0: raise ValueError(\\"All input values must be non-negative.\\") net_balance = initial_balance + months * (monthly_income - monthly_expenses) return net_balance"},{"question":"# Coding Question: Generate Unique Anagram Combinations Context: You are part of a team developing an advanced text analyzer tool that allows users to explore various combinations of words formed by a given string of letters. One crucial feature of this tool is to generate all unique anagram combinations of a given string and collect them in alphabetical order. Objective: - Write a function `unique_anagrams(s: str) -> List[str]` that: - Generates all unique anagram combinations of the given string `s`. - Returns the list of anagrams sorted lexicographically (alphabetical order). Input and Output: - **Input**: A single string `s` consisting of lowercase letters only (e.g., \\"abc\\"). - **Output**: A list of strings containing all unique anagram combinations sorted alphabetically. Constraints and Limitations: - `s` will contain only lowercase alphabets and be of length at most 10. - Your function should handle strings with repeated characters and ensure uniqueness in the output list. Examples: ```python >>> unique_anagrams(\'abc\') [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> unique_anagrams(\'aab\') [\'aab\', \'aba\', \'baa\'] >>> unique_anagrams(\'abcd\') [\'abcd\', \'abdc\', \'acbd\', \'acdb\', \'adbc\', \'adcb\', \'bacd\', \'badc\', \'bacd\', \'bacd\', \'bacd\', \'bacd\'] >>> unique_anagrams(\'aa\') [\'aa\'] ``` Function Signature: ```python from typing import List def unique_anagrams(s: str) -> List[str]: pass ``` *Note: You might find it useful to explore libraries like `itertools` for generating permutations.*","solution":"from typing import List from itertools import permutations def unique_anagrams(s: str) -> List[str]: Generates all unique anagram combinations of the given string s. Returns the list of anagrams sorted lexicographically. # Generate all permutations of the string perm = permutations(s) # Convert permutations to a set to ensure uniqueness unique_perm = set([\'\'.join(p) for p in perm]) # Convert the set to a list and sort it lexicographically sorted_perm = sorted(unique_perm) return sorted_perm"},{"question":"# Coding Assessment Question Problem Statement You are given a string consisting of lowercase English letters and an integer `k`. Implement a function that rearranges the letters in the string such that the same characters are at least distance `k` apart. If it is not possible to reorganize the string to meet this requirement, return an empty string. Function Signature ```python def rearrange_string(s: str, k: int) -> str: Rearrange the string so that the same characters are at least distance k apart. :param s: The input string consisting of lowercase English letters. :param k: The minimum distance between the same characters. :return: The rearranged string or an empty string if reorganization is not possible. ``` Input Format * A string `s` consisting of lowercase English letters. * An integer `k` (0 <= k <= length of `s`). Output Format * A string where no two identical characters are less than `k` distance apart. * If it is impossible to meet the requirement, return an empty string. Example ```python print(rearrange_string(\\"aabbcc\\", 3)) # Output: \\"abcabc\\" or any other valid permutation print(rearrange_string(\\"aaabc\\", 3)) # Output: \\"\\" ``` Constraints * The length of the string will not exceed 10^5. * The string will only contain characters from \'a\' to \'z\'. * The input string is guaranteed to have at least one character. Implementation Notes * Carefully consider the efficiency of your solution to ensure that it can handle large strings. * Focus on ensuring that the rearranged string meets the `k`-distance requirement. * Use appropriate data structures to manage the frequency and positions of characters to efficiently determine if a valid rearrangement is possible.","solution":"from collections import Counter, deque import heapq def rearrange_string(s: str, k: int) -> str: if k == 0: return s # If k is 0, no need to rearrange counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) result = [] queue = deque() # To keep track of last k positions where characters were placed while max_heap: count, char = heapq.heappop(max_heap) result.append(char) queue.append((char, count + 1)) # reduce count since it was negative if len(queue) == k: prev_char, prev_count = queue.popleft() if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"# Coding Assessment Question # Implementing and Testing a Custom Sorting Algorithm You are tasked with implementing a custom sorting algorithm that sorts a list of tuples representing student records. Each tuple contains three elements: the student\'s name (a string), grade (an integer), and age (an integer). The sorting algorithm must sort the list first by grade in descending order. If two students have the same grade, they should be sorted by age in ascending order. If two students have the same grade and age, they should be sorted by their names in alphabetical order. 1. Write a function to compare two student records based on the criteria mentioned above. 2. Write a function that sorts the list of student records using your comparison function. 3. Ensure your solution handles edge cases such as an empty list or lists with identical records gracefully. Function Specifications 1. **custom_sort** - **Input**: A list of tuples, where each tuple contains (name: str, grade: int, age: int). - **Output**: A sorted list of tuples based on the criteria outlined. - **Constraints**: - Each tuple will contain valid data types for the respective fields. - The input list may be empty. - **Performance Requirements**: - The sorting algorithm should have a time complexity of O(n log n). Example ```python def custom_sort(records): # Your solution here # Example Usage students = [(\\"Alice\\", 90, 20), (\\"Bob\\", 95, 21), (\\"Charlie\\", 90, 19), (\\"Dave\\", 95, 21)] print(custom_sort(students)) # Output: [(\'Bob\', 95, 21), (\'Dave\', 95, 21), (\'Charlie\', 90, 19), (\'Alice\', 90, 20)] ``` This new question aligns well with the sample question style, length, complexity, and topic coverage, covering sorting with custom comparison logic.","solution":"def custom_sort(records): Sorts the list of student records based on: 1. Grade in descending order. 2. Age in ascending order if grades are the same. 3. Name in alphabetical order if both grade and age are the same. return sorted(records, key=lambda x: (-x[1], x[2], x[0]))"},{"question":"# Problem Statement: Graph Traversal Using Depth-First Search (DFS) Context You are tasked with implementing the depth-first search (DFS) algorithm to traverse a graph from a given starting node. The algorithm should be able to handle both connected and disconnected graphs, and it should return the traversal order of the nodes. Objective Implement a function named `dfs_traversal` that performs a depth-first search on a given graph. Function Specifications * **Function Name**: `dfs_traversal` * **Input**: - `graph`: A dictionary where keys are node labels and values are lists of adjacent nodes. - `start`: A string representing the label of the starting node for the traversal. * **Output**: - Returns a list containing the nodes in the order they were visited during the DFS traversal. Constraints * The graph is represented as an adjacency list. * The nodes are labeled with unique strings. * The graph can be disconnected. * The starting node will always be a valid node in the graph. Requirements * Implement the function with O(V + E) time complexity, where V is the number of vertices and E is the number of edges. * Ensure the function handles graphs with cycles. Example ```python >>> graph = { ... \\"A\\": [\\"B\\", \\"C\\"], ... \\"B\\": [\\"D\\", \\"E\\"], ... \\"C\\": [\\"F\\"], ... \\"D\\": [], ... \\"E\\": [\\"F\\"], ... \\"F\\": [] ... } >>> dfs_traversal(graph, \\"A\\") [\'A\', \'B\', \'D\', \'E\', \'F\', \'C\'] >>> disconnected_graph = { ... \\"A\\": [\\"B\\"], ... \\"B\\": [], ... \\"C\\": [\\"D\\"], ... \\"D\\": [\\"E\\"], ... \\"E\\": [] ... } >>> dfs_traversal(disconnected_graph, \\"A\\") [\'A\', \'B\'] ``` Implementation Guidelines 1. Use a stack to help with the DFS traversal. 2. Keep track of visited nodes to avoid visiting the same node multiple times. 3. Start the traversal from the given starting node. 4. Ensure the function handles all nodes in the graph, including disconnected components. ```python def dfs_traversal(graph: dict, start: str) -> list: stack = [start] visited = set() traversal_order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) traversal_order.append(node) # Add adjacent nodes to stack (in reverse order to maintain correct traversal) for neighbor in reversed(graph[node]): if neighbor not in visited: stack.append(neighbor) return traversal_order ``` Testing - Ensure test cases cover basic, edge, and complex scenarios, including graphs with cycles, disconnected graphs, and single-node graphs.","solution":"def dfs_traversal(graph, start): stack = [start] visited = set() traversal_order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) traversal_order.append(node) # Add adjacent nodes to stack (in reverse order to maintain correct traversal) for neighbor in reversed(graph[node]): if neighbor not in visited: stack.append(neighbor) return traversal_order"},{"question":"# Median Maintenance with Two Heaps In this exercise, you\'ll be tasked with maintaining an efficient method to get the median of a dynamically growing list of integers. You are expected to use two heaps to accomplish this task, ensuring that the median retrieval continues to operate in logarithmic time even as elements are added to the list. **Task**: 1. Implement a `MedianFinder` class that provides methods to add numbers to the list and retrieve the current median. 2. The class should use a max heap and a min heap to maintain the elements. **Function Signatures**: 1. `class MedianFinder:` 2. `def __init__(self): -> None` 3. `def add_num(self, num: int): -> None` 4. `def find_median(self): -> float` **Input Constraints**: - `num` is an integer within the range ([-10^5, 10^5]). - Up to (2 times 10^4) calls will be made to `add_num` and `find_median`. **Output**: - The `add_num` method does not return anything. - The `find_median` method returns the median of the current list as a float. **Examples**: ```python # Creating a MedianFinder object median_finder = MedianFinder() # Adding numbers and finding the median median_finder.add_num(1) assert median_finder.find_median() == 1.0 median_finder.add_num(2) assert median_finder.find_median() == 1.5 median_finder.add_num(3) assert median_finder.find_median() == 2.0 median_finder.add_num(4) assert median_finder.find_median() == 2.5 ```","solution":"import heapq class MedianFinder: def __init__(self): Initializes the MedianFinder object with two heaps: - max_heap to store the smaller half of the numbers (simulated as a max heap using negative values) - min_heap to store the larger half of the numbers self.max_heap = [] # Max-heap for the lower half (invert values to use heapq as max-heap) self.min_heap = [] # Min-heap for the upper half def add_num(self, num: int) -> None: Adds a number into the data structure. # Ensure the max-heap property for the smaller half heapq.heappush(self.max_heap, -num) # Ensure the smallest value in max_heap is less than or equal to the smallest in min_heap if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) # Balance the sizes of the two heaps if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def find_median(self) -> float: Returns the median of the current list. if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Coding Assessment Question **Context**: You are given a series of English sentences. Your task is to implement a function that processes these sentences to detect and replace certain target words with their synonyms. You will utilize a pre-defined dictionary mapping target words to their synonyms. **Objective**: Implement a function `replace_with_synonyms` that replaces each instance of a target word in a sentence with its corresponding synonym from a given dictionary. **Function Signature**: ```python def replace_with_synonyms(sentences: List[str], synonym_dict: Dict[str, str]) -> List[str]: Parameters: - sentences: List[str], A list of sentences. - synonym_dict: Dict[str, str], A dictionary where keys are words to be replaced and values are the corresponding synonyms. Returns: - List[str]: A list of sentences with the target words replaced by their synonyms. ``` **Input**: * `sentences`: A list of sentences (strings). * `synonym_dict`: A dictionary where keys are the target words to be replaced and the values are the corresponding synonyms. **Output**: * Returns a list of sentences with each target word replaced by its synonym. **Constraints**: * Do not change the case of any words in the sentences. * Only replace whole words that match the keys exactly (i.e., \\"cats\\" should not be replaced if the synonym_dict only has \\"cat\\"). * Words should be replaced without altering the structure or punctuation of the sentences. **Example**: ```python sentences = [ \\"The quick brown fox jumps over the lazy dog.\\", \\"A journey of a thousand miles begins with a single step.\\", \\"To be or not to be, that is the question.\\" ] synonym_dict = { \\"quick\\": \\"fast\\", \\"jumps\\": \\"leaps\\", \\"lazy\\": \\"sluggish\\", \\"journey\\": \\"voyage\\", \\"question\\": \\"query\\" } # Expected output: # [ # \\"The fast brown fox leaps over the sluggish dog.\\", # \\"A voyage of a thousand miles begins with a single step.\\", # \\"To be or not to be, that is the query.\\" # ] output = replace_with_synonyms(sentences, synonym_dict) print(output) ``` **Additional Information**: The primary goal is to implement the `replace_with_synonyms` function and verify its output by using a predefined dictionary of synonyms to transform each sentence accurately. **Note**: Ensure that words are replaced correctly considering punctuation and case-sensitivity, preserving the original sentence structure. Test the function thoroughly to handle various edge cases.","solution":"import re from typing import List, Dict def replace_with_synonyms(sentences: List[str], synonym_dict: Dict[str, str]) -> List[str]: def replace_word(match): word = match.group(0) return synonym_dict.get(word, word) pattern = re.compile(r\'bw+b\') updated_sentences = [] for sentence in sentences: new_sentence = pattern.sub(replace_word, sentence) updated_sentences.append(new_sentence) return updated_sentences"},{"question":"**Scenario**: You are tasked with developing a feature for a navigation system, similar to those used in GPS applications. One important feature is calculating the shortest path between two points in a grid map. Each cell in the grid represents a unit square area, and the valid moves are up, down, left, or right to another cell. There are certain cells marked as obstacles that cannot be traversed. **Objective**: Implement the `shortest_path` function that computes the shortest distance from a starting point to a destination point on a grid, considering obstacles. # Function Signature ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: pass ``` # Input - `grid`, a 2D list of integers where `0` represents a traversable cell and `1` represents an obstacle. - `start`, a tuple `(x, y)` representing the starting coordinates in the grid. - `destination`, a tuple `(x, y)` representing the destination coordinates in the grid. # Output - An integer representing the shortest distance from the starting point to the destination point, or `-1` if the destination is not reachable. # Constraints - The grid size is at most `100x100`. - The start and destination points are guaranteed to be traversable cells (i.e., marked with `0`). # Example Usage ```python >>> grid = [ ... [0, 0, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0] ... ] >>> start = (0, 0) >>> destination = (4, 4) >>> shortest_path(grid, start, destination) 8 >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> destination = (2, 2) >>> shortest_path(grid, start, destination) 4 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> start = (0, 0) >>> destination = (1, 1) >>> shortest_path(grid, start, destination) -1 ``` # Additional Notes - Utilize a breadth-first search (BFS) approach to ensure finding the shortest path in an unweighted grid. - Consider edge cases such as blocked paths where the destination is not reachable.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 rows, cols = len(grid), len(grid[0]) queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right while queue: x, y, distance = queue.popleft() if (x, y) == destination: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1 # Destination is not reachable"},{"question":"# Problem: Implement the Runge-Kutta Method for Systems of ODEs Create a function to solve systems of ordinary differential equations using the Runge-Kutta method of order 4. The method should accommodate systems comprising multiple equations and allow for both fixed and adaptive step size configurations to balance performance and accuracy. Task 1. **Implement the `runge_kutta_system` function** to numerically solve a system of ODEs using the Runge-Kutta method of order 4. 2. Include an adaptive step size mechanism for enhanced accuracy in dynamically changing systems. 3. Ensure proper handling of edge cases, such as stiff equations or varying initial conditions. Function Signature ```python def runge_kutta_system( ode_system: Callable, y0: np.ndarray, t0: float, step_size: float, t_end: float, adaptive: bool ) -> np.ndarray: pass ``` Parameters * `ode_system`: Function representing the system of ODEs, taking arguments (t, y), where `y` is an array of dependent variables. * `y0`: Initial values as an array of floats for the dependent variables. * `t0`: Initial value for the independent variable (time). * `step_size`: Suggested step size for iterations. * `t_end`: Final value of the independent variable up to which to solve the system. * `adaptive`: Boolean flag indicating whether to use adaptive step size (True) or fixed step size (False). Requirements * When `adaptive` is `True`, the function should dynamically adjust `step_size` based on the magnitude of the system\'s derivatives, allowing larger steps in regions with smaller magnitudes and smaller steps in areas with larger magnitudes. * Ensure the solution accurately reaches the endpoint `t_end`, even with adaptive step adjustments. * Verify the robustness of your solution against edge cases, such as stiff equations, small and large ranges, and varying initial conditions. Constraints * Maintain efficient memory usage. * The function should correctly solve systems with varying numbers of equations. * Implement unit tests to validate the correctness using various systems of differential equations and initial conditions. Example ```python >>> def system(t, y): ... dydt = np.zeros_like(y) ... dydt[0] = y[1] ... dydt[1] = -y[0] ... return dydt >>> y0 = np.array([1.0, 0.0]) >>> res = runge_kutta_system(system, y0, 0.0, 0.01, 10.0, adaptive=True) >>> isinstance(res, np.ndarray) True >>> round(float(res[-1, 0]), 2) -0.83 # This result should be close to the actual value considering adaptive steps ``` Ensure your solution is efficient, robust, and well-tested.","solution":"import numpy as np def runge_kutta_system(ode_system, y0, t0, step_size, t_end, adaptive): Solves a system of ODEs using the 4th order Runge-Kutta method. Parameters: ode_system : function Function representing the system of ODEs, taking arguments (t, y). y0 : array_like Initial values for the dependent variables. t0 : float Initial value for the independent variable (time). step_size : float Suggested step size for iterations. t_end : float Final value of the independent variable up to which to solve the system. adaptive : bool Flag indicating whether to use adaptive step size (True) or fixed step size (False). Returns: y : ndarray Array of solution values for the dependent variables. def step_size_adjustment(t, y, h): # Simple adaptive step size logic based on the magnitude of the derivatives y_derivative = np.abs(ode_system(t, y)) max_derivative = np.max(y_derivative) if max_derivative > 1: return h / max_derivative else: return h t = t0 y = np.array(y0) y_result = [y.copy()] t_result = [t] while t < t_end: if adaptive: h = step_size_adjustment(t, y, step_size) else: h = step_size if t + h > t_end: h = t_end - t # Runge-Kutta 4th order method k1 = ode_system(t, y) k2 = ode_system(t + 0.5 * h, y + 0.5 * h * k1) k3 = ode_system(t + 0.5 * h, y + 0.5 * h * k2) k4 = ode_system(t + h, y + h * k3) y += (h / 6) * (k1 + 2 * k2 + 2 * k3 + k4) t += h y_result.append(y.copy()) t_result.append(t) return np.array(y_result), np.array(t_result)"},{"question":"# Scenario: A warehouse has an automated system to manage its inventory, with various products stored in bins located on shelves. Each bin is identified by a unique numeric ID and contains a certain number of items. The systems use a list to track the bins, where each element is a tuple containing the bin ID and the number of items in that bin. To prevent stockouts and efficiently manage resources, the warehouse manager needs to know the maximum number of items available across all bins after performing a series of operations. Each operation either adds items to a specific bin or removes items from it. # Task: Write a Python function that simulates the given operations and returns the maximum number of items across all bins after all operations are completed. # Function Signature: ```python def max_items_after_operations(bins: List[Tuple[int, int]], operations: List[Tuple[str, int, int]]) -> int: pass ``` # Input: - `bins` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers: - The first integer represents the bin ID (unique). - The second integer represents the number of items in that bin. - `operations` (List[Tuple[str, int, int]]): A list of tuples where each tuple represents an operation: - The first element is a string \\"add\\" or \\"remove\\", indicating whether to add or remove items. - The second element is an integer, the bin ID to which the operation applies. - The third element is an integer, the number of items to add or remove. # Output: - Returns an integer representing the maximum number of items available across all bins after performing all operations. # Constraints: - 1 ≤ len(bins) ≤ 100 - 1 ≤ len(operations) ≤ 10^4 - 1 ≤ ID ≤ 10^3 - 0 ≤ items ≤ 10^4 - If an operation tries to remove more items than are currently available in the bin, set the bin\'s items to 0 (it cannot have negative items). # Example: ```python bins = [(1, 10), (2, 5), (3, 8)] operations = [(\\"add\\", 1, 5), (\\"remove\\", 2, 2), (\\"add\\", 3, 10), (\\"remove\\", 1, 20)] >>> max_items_after_operations(bins, operations) 18 ``` # Solution Approach: - Implement a function to initialize the bins based on the provided list. - Apply the operations sequentially to update the number of items in each bin. - After all operations are complete, find and return the bin with the maximum number of items. - Ensure the function handles cases where items become negative or bins are not found correctly.","solution":"from typing import List, Tuple def max_items_after_operations(bins: List[Tuple[int, int]], operations: List[Tuple[str, int, int]]) -> int: # Convert the list of bins to a dictionary for faster access bin_dict = {bin_id: count for bin_id, count in bins} for operation in operations: action, bin_id, amount = operation if bin_id in bin_dict: if action == \\"add\\": bin_dict[bin_id] += amount elif action == \\"remove\\": bin_dict[bin_id] = max(0, bin_dict[bin_id] - amount) # Return the maximum number of items in any bin return max(bin_dict.values())"},{"question":"Scenario To practice your skills in handling dynamic programming problems, you will implement an algorithm to find the maximum sum of non-adjacent elements from an array. This type of problem is commonly encountered in dynamic programming and requires careful consideration of overlapping subproblems to optimize the solution effectively. # Problem Statement Write a function `max_non_adjacent_sum(nums: list) -> int` that returns the maximum sum of non-adjacent elements in the list `nums`. You may assume that the list contains at least one element. # Input * `nums` (1 ≤ len(nums) ≤ 10^4): A list of integers where each integer lies between -10^4 and 10^4. # Output * Return the maximum sum of non-adjacent elements. # Constraints * The solution should run in O(n) time complexity with O(1) auxiliary space. # Example ```python def max_non_adjacent_sum(nums: list) -> int: # Implement your function here # Example usage: print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Output should be 15 print(max_non_adjacent_sum([-2, 1, 3, -4, 5])) # Output should be 8 print(max_non_adjacent_sum([-2, -1, -3, -4, -5])) # Output should be 0 ``` In these examples, the function should compute the maximum sum of non-adjacent elements in the list provided. # Notes 1. If all elements are negative, the function should return 0, as the maximum sum of non-adjacent elements would be to choose none of the elements. 2. The function should handle both positive and negative integers in the list. 3. Edge cases such as single-element lists should be considered and appropriately handled.","solution":"def max_non_adjacent_sum(nums: list) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) prev1 = max(0, nums[0]) prev2 = 0 for i in range(1, len(nums)): current = max(prev1, prev2 + nums[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"# Problem Statement You are given a list of integers representing the scores of a series of games played by two players, Player A and Player B. Each odd-indexed game (0-based index) was played by Player A, and each even-indexed game was played by Player B. Your task is to write a function `calculate_scores` that calculates and returns the total scores of Player A and Player B. # Function Signature ```python def calculate_scores(scores: list[int]) -> tuple[int, int]: pass ``` # Input - `scores`: A list of integers `scores` (0 <= len(scores) <= 10^5), where `scores[i]` represents the score achieved in the ith game. Each score is guaranteed to be a non-negative integer. # Output - A tuple of two integers. The first integer represents the total score of Player A, and the second integer represents the total score of Player B. # Examples ```python assert calculate_scores([10, 20, 30, 40]) == (60, 60) assert calculate_scores([5, 8, 9]) == (14, 8) assert calculate_scores([3]) == (3, 0) assert calculate_scores([]) == (0, 0) assert calculate_scores([10, 15, 5, 10, 20, 25]) == (35, 50) ``` # Constraints - Ensure your solution handles large inputs efficiently. - You can assume that the input list will only contain non-negative integers. - Do not use any libraries except built-in Python functions and data structures. # Notes - Consider edge cases such as an empty list, lists with one or two elements, and lists where all scores are zero. - Ensure the solution is optimized to handle lists of varying sizes within the given constraints.","solution":"def calculate_scores(scores: list[int]) -> tuple[int, int]: Calculates and returns the total scores of Player A and Player B. Player A plays at odd-indexed positions, and Player B plays at even-indexed positions. Parameters: scores (list[int]): List of integers representing scores of games. Returns: tuple[int, int]: A tuple containing the total score of Player A and Player B. player_a_score = sum(scores[i] for i in range(0, len(scores), 2)) player_b_score = sum(scores[i] for i in range(1, len(scores), 2)) return player_a_score, player_b_score"},{"question":"# Context: Data compression is a vital technique used to reduce the size of files, making them easier to store and transmit. One simple and commonly used method is run-length encoding (RLE), particularly effective for data with many repeating characters. Implementing this technique will help you better understand fundamental text processing tasks. # Objective: Implement a function that performs run-length encoding on a given string. This function should convert the string into the encoded format where consecutive characters are represented by a single character followed by its count. # Problem Statement: Write a function `run_length_encode` that performs run-length encoding on the input string. # Function Signature: ```python def run_length_encode(input_string: str) -> str: pass ``` # Input: - `input_string`: A string consisting of printable ASCII characters. The length of the string is in the range [1, 10^4]. # Output: - Returns a string that contains the run-length encoded version of the input string. # Examples: ```python >>> run_length_encode(\\"aaabbc\\") \\"a3b2c1\\" >>> run_length_encode(\\"hhhhhhh\\") \\"h7\\" >>> run_length_encode(\\"a\\") \\"a1\\" >>> run_length_encode(\\"aaAAaaaAAA\\") \\"a2A2a3A3\\" ``` # Constraints: - The input string will only contain printable ASCII characters. - The function should be case sensitive. # Explanation: For the first example, the input string \\"aaabbc\\" is encoded by noting that \'a\' repeats three times, \'b\' repeats twice, and \'c\' repeats once, resulting in the encoded string \\"a3b2c1\\". For the second example, the input string \\"hhhhhhh\\" has \'h\' repeating seven times, resulting in \\"h7\\".","solution":"def run_length_encode(input_string: str) -> str: Encode the input string using run-length encoding. if not input_string: return \\"\\" encoded_string = \\"\\" current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string += current_char + str(count) current_char = char count = 1 encoded_string += current_char + str(count) return encoded_string"},{"question":"# Coding Assessment Question **Scenario**: You are developing a document management system that stores and retrieves documents based on keywords extracted from their content. The system requires a fast and efficient way to search for documents that contain specific keywords. **Task**: Implement a class `DocumentManager` that allows you to add documents and search for them based on keywords. Each document will have a unique identifier and a list of keywords. **Class Signature**: ```python class DocumentManager: def __init__(self): Initializes the DocumentManager with an empty collection of documents. def add_document(self, doc_id: str, keywords: list) -> None: Adds a document with the given doc_id and keywords to the collection. Args: doc_id (str): The unique identifier for the document. keywords (list): A list of keywords associated with the document. def search_documents(self, keyword: str) -> list: Searches for documents that contain the given keyword and returns a list of document IDs that match the search criteria. Args: keyword (str): The keyword to search for in the document collection. Returns: list: List of document IDs that contain the keyword. ``` **Example**: ```python doc_manager = DocumentManager() doc_manager.add_document(\'doc1\', [\'python\', \'coding\', \'programming\']) doc_manager.add_document(\'doc2\', [\'anime\', \'streaming\', \'fun\']) doc_manager.add_document(\'doc3\', [\'python\', \'data\', \'science\']) results = doc_manager.search_documents(\'python\') print(results) # Output should be [\'doc1\', \'doc3\'] results = doc_manager.search_documents(\'anime\') print(results) # Output should be [\'doc2\'] ``` **Constraints**: 1. Each doc_id is unique and only contains alphanumeric characters. 2. Each keyword is a single word without spaces. 3. Your class must: - Handle the addition of up to 10,000 documents. - Ensure efficient search operations with constraints that there can be up to 1,000 unique keywords across all documents. **Performance Boundaries**: - Ensure that both adding and searching operations can handle the upper limits of the constraints without significant performance degradation. **Additional Notes**: - Consider using appropriate data structures for efficient storage and retrieval. - Properly structure and comment your code for readability and maintainability.","solution":"class DocumentManager: def __init__(self): Initializes the DocumentManager with an empty collection of documents. self.documents = {} self.keyword_index = {} def add_document(self, doc_id: str, keywords: list) -> None: Adds a document with the given doc_id and keywords to the collection. Args: doc_id (str): The unique identifier for the document. keywords (list): A list of keywords associated with the document. self.documents[doc_id] = keywords for keyword in keywords: if keyword in self.keyword_index: self.keyword_index[keyword].append(doc_id) else: self.keyword_index[keyword] = [doc_id] def search_documents(self, keyword: str) -> list: Searches for documents that contain the given keyword and returns a list of document IDs that match the search criteria. Args: keyword (str): The keyword to search for in the document collection. Returns: list: List of document IDs that contain the keyword. return self.keyword_index.get(keyword, [])"},{"question":"# Coding Question You have been tasked with creating a function that calculates the sum of the first N prime numbers. **Function: `sum_of_primes`** ```python def sum_of_primes(N: int) -> int: Takes an integer N and returns the sum of the first N prime numbers. Examples: >>> sum_of_primes(5) 28 # The first 5 primes are 2, 3, 5, 7, and 11, their sum is 28 >>> sum_of_primes(10) 129 # The first 10 primes are 2, 3, 5, 7, 11, 13, 17, 19, 23, and 29, their sum is 129 >>> sum_of_primes(0) 0 # No prime numbers to sum >>> sum_of_primes(-1) Traceback (most recent call last): ... Exception: N must be a non-negative integer pass # your code here ``` # Constraints - N must be a non-negative integer. - If N is 0, the function should return 0. - If N is negative, the function should raise an exception. # Example Scenario: Imagine you are working on a mathematics research project focusing on the properties of prime numbers. As part of your analysis, you need to calculate the sum of a specified number of primes to identify patterns and behaviors. **Sample Input:** ```plaintext Enter the number of prime numbers to sum: 5 ``` **Sample Output:** ```plaintext The sum of the first 5 prime numbers is: 28 ```","solution":"def sum_of_primes(N: int) -> int: Takes an integer N and returns the sum of the first N prime numbers. if N < 0: raise Exception(\\"N must be a non-negative integer\\") if N == 0: return 0 def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True prime_sum = 0 count = 0 number = 2 while count < N: if is_prime(number): prime_sum += number count += 1 number += 1 return prime_sum"},{"question":"# Task: Implement a Multi-Input AND Gate Context In digital logic design, the AND gate is a basic logic gate that implements logical conjunction - it outputs true only if all the inputs are true. In complex circuits, you may encounter scenarios where you need to simulate an AND gate that can handle multiple inputs instead of just two. Objective Write a function `multi_input_and_gate` that simulates an AND gate with multiple inputs. The function should take a list of binary inputs and return the result of the AND operation applied across all the inputs. # Function Signature ```python def multi_input_and_gate(inputs: list[int]) -> int: pass ``` # Input * **inputs** (list[int]): A list of integers where each element is either `0` or `1`. # Output * **int**: The result of the AND operation applied across all the inputs (0 or 1). # Constraints * The length of the input list will be in the range [1, 1000]. * Each element in the input list will be either `0` or `1`. # Example Scenarios Example 1 * **Input**: [1, 1, 1, 1] * **Output**: 1 * **Explanation**: All inputs are 1, hence the output is 1. Example 2 * **Input**: [1, 0, 1, 1] * **Output**: 0 * **Explanation**: At least one input is 0, hence the output is 0. Example 3 * **Input**: [0, 0, 0, 0] * **Output**: 0 * **Explanation**: All inputs are 0, hence the output is 0. # Performance Requirements * The function should operate in O(n) time complexity, where n is the number of inputs. # Points to Consider * Handle edge cases with input lists containing a single element. * Ensure to validate that input elements are either 0 or 1.","solution":"def multi_input_and_gate(inputs: list[int]) -> int: Simulates a multi-input AND gate. Returns 1 if all inputs are 1, else returns 0. Args: inputs (list[int]): A list of integers (0 or 1). Returns: int: The result of the AND operation, 0 or 1. # Iterate over each input and perform AND operation; if any input is 0, return 0 for bit in inputs: if bit == 0: return 0 return 1"},{"question":"# Coding Question **Interval Tree with Range Sum Query** You are provided with an implementation of an `IntervalTree` data structure which supports typical interval operations, including inserting intervals and finding all intervals that intersect with a given point. Your task is to extend this functionality to support a `range_sum` operation that calculates the sum of all intervals overlapping a given range. # Problem Statement: Implement a method called `range_sum` for the `IntervalTree` class that calculates the sum of all intervals intersecting with a given range [start, end]. # Constraints: 1. Intervals are represented as tuples, where each tuple contains a start and end point. 2. The range [start, end] to be queried is inclusive at both ends. 3. If an interval intersects the range, its entire sum should be counted. # Class Definitions and Method to Implement: ```python class IntervalTree: def __init__(self): self.intervals = [] def insert(self, interval: tuple): self.intervals.append(interval) self.intervals.sort() # Keeping intervals sorted for easier querying def range_sum(self, start: int, end: int) -> int: # your code here ``` # Function Signature: ```python def range_sum(self, start: int, end: int) -> int: Calculate the sum of all intervals that intersect the given range [start, end]. Parameters: start (int): The start of the range to query. end (int): The end of the range to query. Returns: int: The sum of sizes of all intervals intersecting with the range. ``` # Example: ```python interval_tree = IntervalTree() interval_tree.insert((1, 3)) interval_tree.insert((2, 5)) interval_tree.insert((8, 10)) interval_tree.insert((7, 9)) print(\\"Intervals inserted in the tree:\\") for interval in interval_tree.intervals: print(interval) # Query sum of intervals overlapping with range [1, 6] print(f\\"Sum of intervals overlapping with range [1, 6]: {interval_tree.range_sum(1, 6)}\\") # Expected Output: 7 (1-3: 3, 2-5: 4) # Query sum of intervals overlapping with range [6, 10] print(f\\"Sum of intervals overlapping with range [6, 10]: {interval_tree.range_sum(6, 10)}\\") # Expected Output: 6 (8-10: 3, 7-9: 3) ``` # Note: - Ensure the intervals are properly managed so that the range sum query is accurate. - Focus on optimizing the query efficiently, given that the intervals are sorted upon insertion.","solution":"class IntervalTree: def __init__(self): self.intervals = [] def insert(self, interval: tuple): self.intervals.append(interval) self.intervals.sort() # Keeping intervals sorted for easier querying def range_sum(self, start: int, end: int) -> int: total_sum = 0 for interval in self.intervals: interval_start, interval_end = interval # Check if the current interval intersects with the range [start, end] if interval_end >= start and interval_start <= end: # Calculate the full length of the interval interval_length = interval_end - interval_start + 1 total_sum += interval_length return total_sum"},{"question":"# Coding Assessment Question: Implementing K-Nearest Neighbors (K-NN) from Scratch Objective Implement the K-Nearest Neighbors (K-NN) algorithm from scratch to classify data into categories. This problem will test your understanding of distance metrics, sorting, and the concept of nearest neighbors in a dataset. Task Write a function `k_nearest_neighbors` that classifies test samples based on the \'k\' nearest training samples using the Euclidean distance metric. Additionally, implement functions to compute the Euclidean distance and make predictions on a test set. Function Signatures ```python def euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: pass def k_nearest_neighbors(x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, k: int) -> np.ndarray: pass ``` Input 1. **`x_train`**: A 2D NumPy array of shape `(m, n)` where `m` is the number of training samples and `n` is the number of features. 2. **`y_train`**: A 1D NumPy array of shape `(m,)` containing the class labels for the training samples. 3. **`x_test`**: A 2D NumPy array of shape `(p, n)` where `p` is the number of test samples and `n` is the number of features. 4. **`k`**: The number of nearest neighbors to consider for voting. Output 1. **`y_pred`**: A 1D NumPy array of shape `(p,)` containing the predicted class labels for the test samples. # Example Usage ```python # Importing required libraries import numpy as np # Training data x_train = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [6.0, 7.0]]) y_train = np.array([0, 0, 1, 1]) # Test data x_test = np.array([[1.5, 2.5], [5.0, 6.0]]) # Number of nearest neighbors k = 3 # Function Call y_pred = k_nearest_neighbors(x_train, y_train, x_test, k) print(\\"Predicted Labels:\\", y_pred) ``` Constraints - Implement the Euclidean distance metric as a separate function. - Use majority voting to determine the class label for each test sample. - Ensure your implementation handles ties in voting by selecting the label with the smallest label value. - Verify the value of \'k\' is positive and no larger than the number of training samples. Implementing this algorithm will help you solidify concepts related to supervised learning, distance metrics, and nearest neighbors classification.","solution":"import numpy as np from collections import Counter def euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: Computes the Euclidean distance between two points. Parameters: - point1: np.ndarray - point2: np.ndarray Returns: - float: Euclidean distance. return np.sqrt(np.sum((point1 - point2) ** 2)) def k_nearest_neighbors(x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, k: int) -> np.ndarray: Classifies test samples based on the \'k\' nearest training samples using the Euclidean distance metric. Parameters: - x_train: np.ndarray - 2D array of training data - y_train: np.ndarray - 1D array of training labels - x_test: np.ndarray - 2D array of test data - k: int - number of neighbors to consider Returns: - np.ndarray: 1D array of predicted labels for test data y_pred = [] for test_point in x_test: distances = [euclidean_distance(test_point, train_point) for train_point in x_train] sorted_indices = np.argsort(distances) top_k_indices = sorted_indices[:k] top_k_labels = y_train[top_k_indices] label_counts = Counter(top_k_labels) most_common_label = sorted(label_counts.items(), key=lambda item: (-item[1], item[0]))[0][0] y_pred.append(most_common_label) return np.array(y_pred)"},{"question":"# Problem Statement You are tasked with creating a function that finds all the simple cycles (also called elementary cycles) in an undirected graph. A simple cycle is a path of edges and vertices wherein a vertex is reachable from itself, with no vertex repeated except for the starting and ending vertex. # Function Signature ```python def find_cycles(graph: Dict[int, List[int]]) -> List[List[int]]: Finds all simple cycles in an undirected graph. :param graph: A dictionary representing the graph, where the keys are node IDs and the values are lists of adjacent node IDs. :return: A list of cycles, where each cycle is represented as a list of node IDs. ``` # Input - `graph`: A dictionary where keys are integers representing nodes and values are lists of integers representing adjacent nodes. # Output - Returns a list of lists, where each sublist is a simple cycle (a list of node IDs representing a cycle). # Constraints - Each node ID is guaranteed to be unique. - The graph can contain up to 10^3 nodes. - Each node can have up to 10^3 edges. - The graph is undirected, meaning if node `a` is connected to node `b`, `b` will also be connected to `a`. # Example ```python from typing import Dict, List def find_cycles(graph: Dict[int, List[int]]) -> List[List[int]]: # To be implemented pass # Example Graph graph1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4], 4: [3] } # Example Cycle in Graph # Cycle 1: [0, 1, 2, 0] # Cycle 2: [0, 2, 1, 0] # Cycle 3: [1, 2, 0, 1] print(find_cycles(graph1)) # Output might include: [[0, 1, 2], [0, 2, 1], [1, 2, 0]] (Order of cycles and nodes may vary) # Example Graph with no cycles graph2 = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } print(find_cycles(graph2)) # Output: [] ``` # Implementation Tips - Use depth-first search (DFS) to explore all possible paths. - Use a stack to keep track of the current path. - Utilize a visited set to avoid revisiting nodes within the same path exploration. - Ensure cycles are added to the result only if they form a simple cycle, with no repeated vertices except the starting and ending vertex.","solution":"from typing import Dict, List def find_cycles(graph: Dict[int, List[int]]) -> List[List[int]]: def dfs(vertex, start, path): if vertex in visited: if vertex == start and len(path) > 2: cycles.append(path[:]) return visited.add(vertex) path.append(vertex) for neighbor in graph[vertex]: dfs(neighbor, start, path) path.pop() visited.remove(vertex) visited = set() cycles = [] for node in graph: dfs(node, node, []) return cycles"},{"question":"# Scenario You are given a string comprised of lowercase letters and a set of queries, where each query asks for the length of the longest substring consisting of the same character. The task is to preprocess the string to efficiently answer each query. # Problem Statement Implement a function `longest_substring_length(s: str, queries: List[int]) -> List[int]` that takes a string `s` and a list of query positions within the string, then returns a list of integer answers, one for each query. Each answer is the length of the longest substring of the same character that contains the character at the queried position. # Input * `s`: A string of length `n` consists of lowercase letters. * `1 <= n <= 10^5` * `queries`: A list of `m` integers, each being a valid index in the string `s`. * `1 <= m <= 10^5` # Output * A list of integers where each integer corresponds to the length of the longest contiguous substring of the same character that includes the character at the queried position. # Example * `longest_substring_length(\\"aaabbbaac\\", [0, 3, 5, 6, 8])` should return `[3, 3, 3, 2, 1]`. * `longest_substring_length(\\"aabba\\", [0, 1, 2, 4])` should return `[2, 2, 2, 1]`. * `longest_substring_length(\\"abcde\\", [0, 1, 2, 3, 4])` should return `[1, 1, 1, 1, 1]`. **Note**: If there are multiple substrings with the same length, returning any valid option is acceptable. # Requirements * Your implementation should consider efficiency both in preprocessing the string and in answering queries, aiming for a balance between preprocessing time and query response time.","solution":"def longest_substring_length(s, queries): Given a string and a list of query positions, return the length of the longest contiguous substring of the same character at each queried position. n = len(s) lengths = [0] * n # Preprocess to find the length of the longest contiguous substring for each position i = 0 while i < n: j = i while j < n and s[j] == s[i]: j += 1 length = j - i for k in range(i, j): lengths[k] = length i = j # Answer the queries result = [] for query in queries: result.append(lengths[query]) return result"},{"question":"# Problem Statement You are provided with a 2D matrix (list of lists) representing a grid of \'0\'s (empty spaces) and \'1\'s (islands). Your task is to write two functions to perform the following operations: counting the number of islands in the grid, and converting all islands into empty spaces (water). Function 1: `count_islands` Implement the function `count_islands` that counts the number of islands in the given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. ```python def count_islands(grid: list[list[int]]) -> int: ``` **Parameters**: - `grid` (list[list[int]]): A 2D grid of \'0\'s and \'1\'s. **Returns**: - `int`: The number of islands in the grid. **Example**: ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ] print(count_islands(grid)) # Output: 5 ``` Function 2: `convert_islands_to_water` Implement the function `convert_islands_to_water` that modifies the given grid by converting all \'1\'s (islands) into \'0\'s (water). ```python def convert_islands_to_water(grid: list[list[int]]) -> None: ``` **Parameters**: - `grid` (list[list[int]]): A 2D grid of \'0\'s and \'1\'s. **Returns**: - `None`: This function modifies the grid in place and does not return a value. **Example**: ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ] convert_islands_to_water(grid) print(grid) # Output: [ # [0, 0, 0, 0, 0], # [0, 0, 0, 0, 0], # [0, 0, 0, 0, 0], # [0, 0, 0, 0, 0], # [0, 0, 0, 0, 0] # ] ``` Constraints * The grid dimensions will be at most 100x100. * You may assume all elements in the grid are either \'0\' or \'1\'. * Implement the functions efficiently to handle the upper constraint limits. Additional Requirements 1. You should use Depth First Search (DFS) or Breadth First Search (BFS) to identify islands. 2. Ensure your code handles edge cases gracefully, such as if the grid is entirely water or entirely land. 3. Focus on clean and readable code, following Python conventions.","solution":"def count_islands(grid: list[list[int]]) -> int: def dfs(i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark the visited island part as water # Recursively visit all connecting (up, down, left, right) parts of the island dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: count += 1 dfs(i, j) return count def convert_islands_to_water(grid: list[list[int]]) -> None: def dfs(i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark the visited island part as water # Recursively visit all connecting (up, down, left, right) parts of the island dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) if not grid: return for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j)"},{"question":"# Consolidated Order Inventory Management A prominent logistics company needs to manage its order inventory efficiently. You have been tasked with developing a solution that consolidates the orders based on the products ordered. Each order consists of a single product type and a quantity. Your goal is to determine the total quantity for each unique product type across all orders. # Function Signature ```python def consolidate_orders(orders: list[(str, int)]) -> dict[str, int]: ``` # Input - A list of tuples where each tuple `(product_name, quantity)` represents an order: - `product_name (str)`: The name of the product ordered. - `quantity (int)`: The quantity of the product ordered in this particular order. # Output - A dictionary where each key is a `product_name` and the corresponding value is the total quantity of that product consolidated across all orders. # Constraints - `orders` has at most `10^4` elements. - `1 <= len(product_name) <= 100` - `1 <= quantity <= 10^3` - Product names consist only of letters (both uppercase and lowercase). # Examples 1. Input: `[(\\"apple\\", 10), (\\"banana\\", 5), (\\"apple\\", 6), (\\"orange\\", 7), (\\"banana\\", 8)]` Output: `{\'apple\': 16, \'banana\': 13, \'orange\': 7}` 2. Input: `[(\\"widget\\", 12), (\\"gadget\\", 15), (\\"widget\\", 20)]` Output: `{\'widget\': 32, \'gadget\': 15}` 3. Input: `[(\\"ball\\", 5)]` Output: `{\'ball\': 5}` # Explanation - **Example 1**: Summing quantities for \'apple\' results in 16 (10 + 6), for \'banana\' it results in 13 (5 + 8), and \'orange\' remains 7 as there is only one entry. - **Example 2**: Summing quantities for \'widget\' yields 32 (12 + 20), and for \'gadget\' it\'s 15. # Performance Requirements The implementation should efficiently manage the aggregation of quantities even with the maximum constraint limits. Expected time complexity should be close to O(n). # Notes - Ensure that the solution correctly handles the consolidation of large numbers of orders and different product names. - Handle edge cases like empty order lists or orders with the same product names but different quantities. Implement the function `consolidate_orders` to solve the inventory management problem outlined above.","solution":"def consolidate_orders(orders): Consolidates the quantities for each unique product type from a list of orders. Parameters: orders (list of tuples): Each tuple contains a product name (str) and a quantity (int). Returns: dict: A dictionary where keys are product names and values are total quantities. consolidated_inventory = {} for product, quantity in orders: if product in consolidated_inventory: consolidated_inventory[product] += quantity else: consolidated_inventory[product] = quantity return consolidated_inventory"},{"question":"# Problem Statement You are given an array of integers where each element appears thrice except for one which appears exactly once. Your task is to write a function, `find_unique_number(arr)`, that finds and returns this unique number. # Function Signature ```python def find_unique_number(arr: List[int]) -> int: ``` # Input and Output * **Input**: A list of integers `arr` where each integer appears exactly three times except for one integer which appears once. * **Output**: Return the integer that appears only once. # Constraints - `1 <= len(arr) <= 3 * 10^4` - `-2^31 <= arr[i] <= 2^31 - 1` - It is guaranteed that only one element appears once and all others appear thrice. # Example Example 1 ```python arr = [2, 2, 3, 2] print(find_unique_number(arr)) # Output: 3 ``` Example 2 ```python arr = [0, 1, 0, 1, 0, 1, 99] print(find_unique_number(arr)) # Output: 99 ``` # Notes - Aim for a solution with linear time complexity and constant space complexity. - Consider using bitwise operations to achieve the desired efficiency. - Detailed explanation of the approach is recommended to ensure understanding. # Example Call ```python arr = [2, 2, 3, 2] result = find_unique_number(arr) print(result) # Should output: 3 ``` ```python arr = [0, 1, 0, 1, 0, 1, 99] result = find_unique_number(arr) print(result) # Should output: 99 ```","solution":"from typing import List def find_unique_number(arr: List[int]) -> int: Returns the element that appears exactly once in the array where each other element appears exactly three times. one = two = 0 for num in arr: # first appearance: one = (one ^ num) & ~two # second appearance: two = (two ^ num) & ~one return one"},{"question":"# Problem Statement You are given a list of integers representing a batch of scores obtained by students in a coding assessment. Your task is to implement a function `k_highest_scores` that finds the top `k` unique highest scores from the list and returns them in a sorted list (from highest to lowest). # Input Format - A list of integers `scores` representing the scores. - An integer `k` representing the number of top unique scores to return. # Output Format - Return a list of the top `k` unique highest scores in descending order. If there are fewer than `k` unique scores, return all the unique scores in descending order. # Constraints - `1 <= len(scores) <= 10^5` - `1 <= scores[i] <= 10^9` - `1 <= k <= len(scores)` # Performance Requirements - Time Complexity: O(n log n) - Space Complexity: O(n) # Function Signature ```python def k_highest_scores(scores: list[int], k: int) -> list[int]: pass ``` # Example ```python assert k_highest_scores([100, 90, 90, 85, 80, 75, 75, 75, 70, 60], 3) == [100, 90, 85] assert k_highest_scores([55, 77, 77, 81, 90, 81, 72, 60], 2) == [90, 81] assert k_highest_scores([45, 45, 30, 25], 5) == [45, 30, 25] # fewer unique scores than k ``` Write your implementation of `k_highest_scores` carefully to handle large inputs efficiently and ensure the function adheres to the outlined performance requirements.","solution":"def k_highest_scores(scores, k): Returns the top k unique highest scores from the list in descending order. :param scores: List[int] - a list of scores :param k: int - the number of top unique scores to return :return: List[int] - the top k unique highest scores in descending order unique_scores = sorted(set(scores), reverse=True) return unique_scores[:k]"},{"question":"# Problem Statement Implement a function named `matrix_diagonal_order` that takes an `m x n` matrix and returns a list containing all elements of the matrix in diagonal order. The elements in each diagonal should be traversed starting from the top-left corner of the matrix and moving towards the bottom-right corner. # Function Signature ```python def matrix_diagonal_order(matrix: List[List[int]]) -> List[int]: pass ``` # Input * `matrix`: A list of lists where each inner list represents a row of dimensions `m x n`. # Output * A list of integers representing the matrix elements in diagonal order. # Constraints * `0 <= m, n <= 1000` * `-10^6 <= matrix[i][j] <= 10^6` # Examples ```python assert matrix_diagonal_order([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [1, 2, 4, 7, 5, 3, 6, 8, 9] assert matrix_diagonal_order([ [1, 2], [3, 4] ]) == [1, 2, 3, 4] assert matrix_diagonal_order([ [1] ]) == [1] assert matrix_diagonal_order([ [1, 2, 3, 4], [5, 6, 7, 8] ]) == [1, 2, 5, 6, 3, 4, 7, 8] assert matrix_diagonal_order([]) == [] assert matrix_diagonal_order([[]]) == [] ``` # Additional Notes 1. The implementation should properly handle edge cases such as an empty matrix or a matrix with a single row or column. 2. Ensure the traversal captures the zigzag (diagonal) ordering that starts from the top-left to the bottom-right of the matrix. 3. Maintain clarity and efficiency in the approach to handle large matrices effectively. 4. Properly validate input to ensure robustness.","solution":"from typing import List def matrix_diagonal_order(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] diagonals = {} for i in range(m): for j in range(n): if i + j not in diagonals: diagonals[i + j] = [] diagonals[i + j].append(matrix[i][j]) for k in range(m + n - 1): if k % 2 == 0: result.extend(reversed(diagonals[k])) else: result.extend(diagonals[k]) return result"},{"question":"# **Coding Assessment Question:** # Context: You are responsible for developing a simple task management application. One of the core features is the ability to filter tasks by their status and priority levels. You need to write a function that filters tasks based on the given criteria and returns a list of task names that match the specified status and priority. # Question: Implement a Python function that, given a list of tasks, a status, and a priority level, filters the tasks and returns a list of their names that match the specified status and priority. Each task is represented as a dictionary containing the properties `name`, `status`, and `priority`. # Function Signature: ```python def filter_tasks(tasks: List[Dict[str, Any]], status: str, priority: str) -> List[str]: ``` # Inputs: - **tasks** (List[Dict[str, Any]]): A list of dictionaries, where each dictionary represents a task with the following properties: - `name` (str): The name of the task. - `status` (str): The status of the task (e.g., \\"completed\\", \\"pending\\", \\"in-progress\\"). - `priority` (str): The priority level of the task (e.g., \\"high\\", \\"medium\\", \\"low\\"). - **status** (str): A string indicating the desired status to filter by. - **priority** (str): A string indicating the desired priority level to filter by. # Outputs: - **List[str]**: A list of task names that match both the specified status and priority. # Constraints: - Each task dictionary will contain the keys `name`, `status`, and `priority`. - The `status` and `priority` arguments will always be valid strings and match the values used in the tasks list. # Example: ```python tasks = [ {\\"name\\": \\"Task 1\\", \\"status\\": \\"completed\\", \\"priority\\": \\"high\\"}, {\\"name\\": \\"Task 2\\", \\"status\\": \\"pending\\", \\"priority\\": \\"medium\\"}, {\\"name\\": \\"Task 3\\", \\"status\\": \\"in-progress\\", \\"priority\\": \\"low\\"}, {\\"name\\": \\"Task 4\\", \\"status\\": \\"completed\\", \\"priority\\": \\"medium\\"}, {\\"name\\": \\"Task 5\\", \\"status\\": \\"pending\\", \\"priority\\": \\"high\\"}, ] print(filter_tasks(tasks, \\"completed\\", \\"medium\\")) # Expected Output: # [\\"Task 4\\"] ``` # Note: - Ensure your solution is efficient and can handle a reasonably large list of tasks. - Pay attention to edge cases, such as when no tasks match the specified criteria. - Document any assumptions and ensure your code follows best practices for both readability and maintainability.","solution":"from typing import List, Dict, Any def filter_tasks(tasks: List[Dict[str, Any]], status: str, priority: str) -> List[str]: Filters tasks based on the specified status and priority level. Args: tasks (List[Dict[str, Any]]): A list of task dictionaries. status (str): The status to filter by. priority (str): The priority level to filter by. Returns: List[str]: A list of task names that match the given status and priority level. return [task[\\"name\\"] for task in tasks if task[\\"status\\"] == status and task[\\"priority\\"] == priority]"},{"question":"# Task You are required to write a function to simulate a ticket reservation system for a theater that can handle multiple types of reservations. Each reservation can either be for a single seat, multiple consecutive seats, or a VIP box that contains 4 seats. # Function Signature ```python class Theater: def __init__(self, rows: int, seats_per_row: int): pass def reserve_single(self, row: int, seat: int) -> bool: pass def reserve_multiple(self, row: int, start_seat: int, num_seats: int) -> bool: pass def reserve_vip(self, row: int) -> bool: pass def __str__(self) -> str: pass ``` # Requirements 1. **Initialization**: - The constructor should accept `rows` and `seats_per_row`, indicating the number of rows and number of seats per row. - Initialize the theater seating chart with all seats unreserved. 2. **Reserve Single Seat**: - Accepts a specific row and seat number to reserve. - Should return `False` if the seat is already reserved or if the seat position is invalid, otherwise reserves the seat and returns `True`. 3. **Reserve Multiple Consecutive Seats**: - Accepts a specific row, starting seat number, and the number of consecutive seats to reserve. - Should return `False` if any of the seats are already reserved, if seats are out of bounds, or if the multiple seat reservation crosses row boundaries, otherwise reserves the seats and returns `True`. 4. **Reserve VIP Box**: - Accepts a row number and reserves a block of 4 consecutive seats starting from the beginning of the specified row. - Should return `False` if any of the seats in the VIP box are already reserved, if the row is invalid, or if there are less than 4 seats per row, otherwise reserves the VIP box and returns `True`. 5. **String Representation**: - Implement `__str__` method to return the current state of the theater seating. - Use \'O\' to represent an open (unreserved) seat and \'X\' to represent a reserved seat. # Example Usage ```python theater = Theater(5, 10) print(theater) theater.reserve_single(0, 5) theater.reserve_multiple(1, 3, 4) theater.reserve_vip(2) print(theater) # Should display the seating arrangement with reserved and unreserved seats theater.reserve_single(2, 1) # Should return False because part of a VIP box is reserved theater.reserve_multiple(1, 3, 1) # Should return False, seats already reserved theater.reserve_vip(4) # Should return True print(theater) # Should display the updated seating arrangement ``` # Constraints and Limits - The theater must have at least 1 row and 1 seat per row. - Any invalid operations (e.g., invalid row/seat, overflows, underflows) should appropriately return `False` without altering the state of the theater. # Custom Exceptions (Optional) - Custom exceptions for invalid operations can be implemented to provide more detailed error messages.","solution":"class Theater: def __init__(self, rows: int, seats_per_row: int): self.rows = rows self.seats_per_row = seats_per_row self.seating = [[\'O\' for _ in range(seats_per_row)] for _ in range(rows)] def reserve_single(self, row: int, seat: int) -> bool: if row < 0 or row >= self.rows or seat < 0 or seat >= self.seats_per_row: return False if self.seating[row][seat] == \'X\': return False self.seating[row][seat] = \'X\' return True def reserve_multiple(self, row: int, start_seat: int, num_seats: int) -> bool: if row < 0 or row >= self.rows or start_seat < 0 or start_seat + num_seats > self.seats_per_row: return False if any(self.seating[row][seat] == \'X\' for seat in range(start_seat, start_seat + num_seats)): return False for seat in range(start_seat, start_seat + num_seats): self.seating[row][seat] = \'X\' return True def reserve_vip(self, row: int) -> bool: if row < 0 or row >= self.rows or self.seats_per_row < 4: return False if any(self.seating[row][seat] == \'X\' for seat in range(4)): return False for seat in range(4): self.seating[row][seat] = \'X\' return True def __str__(self) -> str: return \'n\'.join(\'\'.join(row) for row in self.seating)"},{"question":"# String Permutations Checker **Context**: Given two strings, determine if one string is a permutation of the other. A string is a permutation of another if it contains the same characters, only the order of characters can be different. This problem tests your understanding of sorting/string manipulation or hash map techniques. # Task: Write a function `are_permutations` that checks if two input strings are permutations of one another and returns a boolean result. # Requirements: 1. **Input**: Two strings, `s1` and `s2`. 2. **Output**: A boolean value indicating whether the input strings are permutations of each other. 3. **Constraints**: - The strings may contain any printable characters, including spaces. - The function should be case-sensitive (e.g., \'A\' is different from \'a\'). - The function should handle both strings of any length from 0 to 10^5 characters. - You should not use any built-in functions that directly solve the problem, like `collections.Counter`. # Examples: ```python def are_permutations(s1: str, s2: str) -> bool: Checks if two strings are permutations of each other. :param s1: First input string. :param s2: Second input string. :return: Boolean indicating if s1 is a permutation of s2. Example: >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"triangle\\", \\"integral\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False if len(s1) != len(s2): return False char_count = {} for ch in s1: if ch in char_count: char_count[ch] += 1 else: char_count[ch] = 1 for ch in s2: if ch in char_count: char_count[ch] -= 1 if char_count[ch] == 0: del char_count[ch] else: return False return len(char_count) == 0 if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Test your function with provided examples and add more edge cases to ensure robustness.","solution":"def are_permutations(s1: str, s2: str) -> bool: Checks if two strings are permutations of each other. :param s1: First input string. :param s2: Second input string. :return: Boolean indicating if s1 is a permutation of s2. Example: >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"triangle\\", \\"integral\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False if len(s1) != len(s2): return False char_count = {} for ch in s1: if ch in char_count: char_count[ch] += 1 else: char_count[ch] = 1 for ch in s2: if ch in char_count: char_count[ch] -= 1 if char_count[ch] == 0: del char_count[ch] else: return False return len(char_count) == 0"},{"question":"# Objective Write a function to determine the number of days between two given dates. # Problem Statement Given two dates as strings in the format \\"YYYY-MM-DD\\", write a function `days_between_dates` that calculates and returns the number of full days between them. Ensure your algorithm handles leap years and varying month lengths correctly. # Function Signature ```python def days_between_dates(date1: str, date2: str) -> int: ``` # Input - `date1` (str): The first date in \\"YYYY-MM-DD\\" format. - `date2` (str): The second date in \\"YYYY-MM-DD\\" format. # Output - Returns an integer representing the number of full days between the two dates. # Constraints - The input dates will be valid and in the correct format. - `date1` and `date2` represent dates between the years 1900 and 2100 inclusive. - It is allowed for `date1` to be earlier than, later than, or equal to `date2`. # Examples ```python >>> days_between_dates(\\"2023-04-01\\", \\"2023-04-10\\") 9 >>> days_between_dates(\\"2020-01-01\\", \\"2020-01-01\\") 0 >>> days_between_dates(\\"2023-04-10\\", \\"2023-04-01\\") 9 >>> days_between_dates(\\"2020-01-01\\", \\"2019-12-31\\") 1 ``` # Requirements 1. Ensure the function correctly calculates the days between two dates regardless of the order. 2. Consider varying month lengths and leap years in your solution. 3. Implement checks for invalid input formats and handle gracefully. # Notes - Use built-in libraries like `datetime` for date manipulation to simplify your implementation. - The function should handle cases where the dates are in any order (i.e., `date1` might be before or after `date2`). # Performance Your implementation should have a time complexity of O(1) and space complexity of O(1).","solution":"from datetime import datetime def days_between_dates(date1: str, date2: str) -> int: Returns the number of full days between two dates. date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) delta = abs((d2 - d1).days) return delta"},{"question":"# Coding Assessment Question Scenario & Context You are a data analyst working at a company that tracks the performance of online advertisement campaigns. Your team needs to process logs from multiple ad servers to calculate the number of unique users who have clicked on an ad, and the total clicks on a specific ad within a given time range. Problem Statement Implement two functions, `unique_clicks` and `total_clicks`, to calculate the number of unique users who clicked on an ad and the total number of clicks on a specific ad within a given time range. 1. **unique_clicks**: This function should calculate the number of unique users who clicked on a specified ad. 2. **total_clicks**: This function should calculate the total number of clicks for a specified ad within a given time range. Function Specifications 1. **unique_clicks** function: - **Input**: - `logs` (List[Tuple[int, str, str, str]]): A list of tuples, each representing a log entry with user ID, ad ID, timestamp, and action (\'click\'). - **Output**: - (int): Number of unique users who clicked on the ad. - **Constraints**: - Each log entry is a tuple with exactly four elements: user ID (int), ad ID (str), timestamp (str in \'YYYY-MM-DD HH:MM:SS\' format), and action (\'click\'). - Only consider logs with action \'click\'. - **Error Handling**: - Raise a ValueError if the logs list contains any improperly formatted tuples. 2. **total_clicks** function: - **Input**: - `logs` (List[Tuple[int, str, str, str]]): A list of tuples, each representing a log entry with user ID, ad ID, timestamp, and action (\'click\'). - `ad_id` (str): The ID of the ad to count clicks for. - `start_time` (str): The start of the time range in \'YYYY-MM-DD HH:MM:SS\' format. - `end_time` (str): The end of the time range in \'YYYY-MM-DD HH:MM:SS\' format. - **Output**: - (int): Total number of clicks for the specified ad within the given time range. - **Constraints**: - Each log entry is a tuple with exactly four elements: user ID (int), ad ID (str), timestamp (str in \'YYYY-MM-DD HH:MM:SS\' format), and action (\'click\'). - Only consider logs with action \'click\' and timestamps within the specified time range. - `start_time` should be less than or equal to `end_time`. - **Error Handling**: - Raise a ValueError if the logs list contains any improperly formatted tuples. - Raise a ValueError if `start_time` is not less than or equal to `end_time`. # Example ```python # Example logs logs = [ (1, \\"ad_001\\", \\"2023-01-01 12:00:00\\", \\"click\\"), (2, \\"ad_001\\", \\"2023-01-01 12:05:00\\", \\"click\\"), (1, \\"ad_001\\", \\"2023-01-01 12:10:00\\", \\"click\\"), (3, \\"ad_002\\", \\"2023-01-01 12:15:00\\", \\"click\\"), (4, \\"ad_001\\", \\"2023-01-02 12:00:00\\", \\"click\\"), ] # Example 1 unique_clicks(logs) # Output: 3 # Example 2 total_clicks(logs, \\"ad_001\\", \\"2023-01-01 12:00:00\\", \\"2023-01-01 12:10:00\\") # Output: 3 ``` Note - Use Python\'s datetime module to handle timestamp comparisons. - Ensure to validate and raise appropriate errors where necessary.","solution":"import datetime def unique_clicks(logs): Calculate the number of unique users who clicked on an ad. # Validate logs for log in logs: if len(log) != 4 or not isinstance(log[0], int) or not isinstance(log[1], str) or not isinstance(log[2], str) or not isinstance(log[3], str): raise ValueError(\\"Invalid log format\\") unique_users = set() for user_id, ad_id, timestamp, action in logs: if action == \\"click\\": unique_users.add((user_id, ad_id)) return len(unique_users) def total_clicks(logs, ad_id, start_time, end_time): Calculate the total number of clicks for a specified ad within a given time range. # Validate logs for log in logs: if len(log) != 4 or not isinstance(log[0], int) or not isinstance(log[1], str) or not isinstance(log[2], str) or not isinstance(log[3], str): raise ValueError(\\"Invalid log format\\") try: start = datetime.datetime.strptime(start_time, \'%Y-%m-%d %H:%M:%S\') end = datetime.datetime.strptime(end_time, \'%Y-%m-%d %H:%M:%S\') except ValueError: raise ValueError(\\"Invalid timestamp format\\") if start > end: raise ValueError(\\"start_time should be less than or equal to end_time\\") total_clicks_count = 0 for user_id, log_ad_id, timestamp, action in logs: if action == \\"click\\" and log_ad_id == ad_id: current_time = datetime.datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') if start <= current_time <= end: total_clicks_count += 1 return total_clicks_count"},{"question":"# Problem Statement You are to implement a genetic algorithm (GA) to solve the OneMax problem, where the objective is to maximize the number of ones in a binary string. Write a function `evolve` that evolves a population of binary strings to find the optimal string consisting entirely of ones. # Input Format The function `evolve` should accept the following parameters: ```python def evolve(population_size: int, chromosome_length: int, mutation_rate: float, generations: int) -> tuple[int, str]: # Implementation here ``` - `population_size`: An integer representing the number of individuals in the population. - `chromosome_length`: An integer representing the number of bits in each string. - `mutation_rate`: A float representing the probability of flipping a bit in a string (ranging from 0 to 1). - `generations`: An integer representing the number of generations the algorithm should run. # Output Format The function should return a tuple of: - An integer representing the maximum fitness achieved (i.e., maximum number of ones in a string). - A string representing the binary string with the highest fitness found. # Performance Requirements Your implementation should handle populations with up to 100 individuals and chromosome lengths up to 100 efficiently. # Example ```python population_size = 10 chromosome_length = 8 mutation_rate = 0.01 generations = 50 max_fitness, best_chromosome = evolve(population_size, chromosome_length, mutation_rate, generations) print(max_fitness) # Output: 8 print(best_chromosome) # Output: \\"11111111\\" ``` # Constraints - Population size ranges from 1 to 100. - Chromosome length ranges from 1 to 100. - Mutation rate ranges from 0.0 to 1.0. - Number of generations ranges from 1 to 1000. # Task Implement the following functions to complete the assignment: 1. `initialize_population`: Create and return an initial population of random binary strings. 2. `fitness`: Calculate and return the fitness of a binary string (i.e., number of ones). 3. `select_parents`: Select and return two parents from the population using fitness-proportionate selection (roulette wheel selection). 4. `crossover`: Perform crossover between two parents to produce an offspring. 5. `mutate`: Apply mutation to a binary string based on the mutation rate. 6. `evolve`: Combine the above functions to simulate the genetic algorithm process and return the result. Ensure to handle edge cases and optimize performance within the given constraints.","solution":"import random def initialize_population(population_size, chromosome_length): return [\'\'.join(random.choice(\'01\') for _ in range(chromosome_length)) for _ in range(population_size)] def fitness(chromosome): return chromosome.count(\'1\') def select_parents(population, fitnesses): total_fitness = sum(fitnesses) probs = [f / total_fitness for f in fitnesses] parents = random.choices(population, weights=probs, k=2) return parents def crossover(parent1, parent2): point = random.randint(1, len(parent1) - 1) return parent1[:point] + parent2[point:] def mutate(chromosome, mutation_rate): return \'\'.join(ch if random.random() > mutation_rate else \'1\' if ch == \'0\' else \'0\' for ch in chromosome) def evolve(population_size, chromosome_length, mutation_rate, generations): population = initialize_population(population_size, chromosome_length) best_chromosome = \'\' max_fitness = 0 for generation in range(generations): fitnesses = [fitness(chromosome) for chromosome in population] new_population = [] if max(fitnesses) > max_fitness: max_fitness = max(fitnesses) best_chromosome = population[fitnesses.index(max_fitness)] for _ in range(population_size): parent1, parent2 = select_parents(population, fitnesses) offspring = crossover(parent1, parent2) mutated_offspring = mutate(offspring, mutation_rate) new_population.append(mutated_offspring) population = new_population return max_fitness, best_chromosome"},{"question":"# Question: Rotating a Matrix In-Place Context: You are working on a graphics application where manipulation of 2D matrices is crucial. One of the common operations is rotating matrices in-place, which saves memory and maintains program efficiency. Your task is to rotate a given square matrix by 90 degrees clockwise. Task: Write a function `rotate_matrix` that rotates an NxN matrix in place, with the following specifications: 1. **Input**: * An NxN matrix (a list of lists) where each element is an integer or float. * Ensure the function handles the matrix rotation and proper edge cases. 2. **Output**: * The function should modify the input matrix in place and not return anything. * The resulting matrix should be the same input matrix rotated 90 degrees clockwise. 3. **Constraints**: * The matrix will always be square with dimensions between 1x1 and 100x100. * The elements in the matrix are always suitable for numerical operations. 4. **Performance**: * The solution should achieve in-place rotation with constant space complexity, O(1), and linearithmic time complexity, O(N^2). 5. **Edge Cases**: * Matrices with one element (1x1 matrix). * Matrices with negative numbers or zeros. * Ensure proper handling of empty matrices. Example Usage: ```python def rotate_matrix(matrix: List[List[Union[int, float]]]) -> None: # Your implementation goes here pass # Example test cases matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) print(matrix1) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [1, 2], [3, 4] ] rotate_matrix(matrix2) print(matrix2) # Output: [ # [3, 1], # [4, 2] # ] matrix3 = [ [1] ] rotate_matrix(matrix3) print(matrix3) # Output: [ # [1] # ] ``` Note: Test cases should also cover potential edge cases, such as very small or very large matrices to ensure robust function behavior. --- The newly created question maintains the same style, complexity, and scope of the original questions provided in the example. It ensures problem-solving in a related core programming concept (manipulating matrices), maintains clarity, and challenges the test-taker\'s ability to think about in-place operations and edge cases.","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix in place 90 degrees clockwise. :param matrix: List[List[Union[int, float]]] The NxN matrix to be rotated. if not matrix or len(matrix) == 0 or len(matrix) != len(matrix[0]): # If the matrix is empty or not a square matrix. return n = len(matrix) # Perform a four-way swap from the outer layer towards the inner. for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"# Problem Statement You are given a string containing an arithmetic expression with non-negative integers and the `+`(addition) and `*`(multiplication) operators. Your task is to evaluate the arithmetic expression and return the result as an integer. The expression does not contain any parentheses and follows the standard precedence rules where multiplication is performed before addition. # Function Signature ```python def evaluate_expression(expression: str) -> int: ``` # Input and Output * **Input**: A string `expression` containing a valid arithmetic expression with non-negative integers and the operators `+` and `*`. The length of the expression will not exceed 100 characters. * **Output**: An integer representing the computed result of the arithmetic expression. # Example ```python assert evaluate_expression(\\"2+3*2\\") == 8 # 2 + (3 * 2) = 8 assert evaluate_expression(\\"3+5*2*2\\") == 23 # 3 + (5 * 2 * 2) = 23 assert evaluate_expression(\\"10+2*3\\") == 16 # 10 + (2 * 3) = 16 assert evaluate_expression(\\"10*2+3\\") == 23 # (10 * 2) + 3 = 23 assert evaluate_expression(\\"3*3*3+2+2\\") == 31 # (3 * 3 * 3) + 2 + 2 = 31 ``` # Constraints * The input string contains only digits (0-9), `+`, `*`, and no spaces. * The length of the input string will not exceed 100 characters. * There will not be any invalid expressions. * The result will fit in a standard 32-bit integer. # Hint You may find it helpful to use the `eval` function carefully or manually parse the expression to respect operator precedence.","solution":"def evaluate_expression(expression: str) -> int: # Split the expression by \'+\' and handle the multiplication separately terms = expression.split(\'+\') sum = 0 for term in terms: if \'*\' in term: product = 1 for factor in term.split(\'*\'): product *= int(factor) sum += product else: sum += int(term) return sum"},{"question":"# Coding Question: Merge and Sort Lists Without Duplicates You are given two lists of integers that may contain duplicate values. Write a function `merge_and_sort` that takes two lists as input, removes any duplicates within each list, merges the two lists into one, and returns the resulting list sorted in ascending order. # Example ```python >>> merge_and_sort([5, 3, 9, 3, 5], [10, 3, 1, 3, 2]) [1, 2, 3, 5, 9, 10] ``` Explanation: - First list without duplicates: [5, 3, 9] - Second list without duplicates: [10, 3, 1, 2] - Merging both lists: [5, 3, 9, 10, 3, 1, 2] - Removing duplicates from merged list: [5, 3, 9, 10, 1, 2] - Sorting the final list: [1, 2, 3, 5, 9, 10] # Constraints 1. Both input lists will only contain integers. 2. Both lists can be empty. 3. You can assume the input lists do not need to be sorted. # Input - `list1`: A list of integers. - `list2`: A list of integers. # Output - Returns a sorted list of integers containing unique elements from both input lists. ```python def merge_and_sort(list1: list[int], list2: list[int]) -> list[int]: # Your implementation here ```","solution":"def merge_and_sort(list1: list[int], list2: list[int]) -> list[int]: Merges two lists, removes duplicates, and returns a sorted list. # Convert lists to sets to remove duplicates set1 = set(list1) set2 = set(list2) # Merge the sets and convert back to a list merged_list = list(set1.union(set2)) # Sort the list merged_list.sort() return merged_list"},{"question":"**Design and Implement an Autocomplete System** Your task is to design and implement an autocomplete system that suggests the most frequent or most recent words or phrases as the user types. The system should include the following: 1. **Class Definition & Initialization**: - Define `AutocompleteSystem` class that initializes with a list of sentences and their corresponding times (frequencies). 2. **Methods**: - **input(char)**: Accepts a character of input at a time and returns the top 3 sentences that could be autocompleted from the current input. If the input character is \'#\' it signifies the end of the search phrase, and the existing phrase should be added to the sentences list with a default frequency of 1 or update the frequency if it already exists. - **update(sentence, frequency)**: Updates the frequency of a specified sentence. 3. **Data Structure Choice**: - Use a trie data structure to efficiently store and retrieve sentences based on prefix matching. - Prioritize lexical orders for sentences with the same frequency. 4. **Constraints**: - There will be at most 1000 sentences initially. - Each input phrase will have at most length 100. - All inputs will be lowercase letters, spaces, or the ‘#’ character. # Example ```python # Initializing the Autocomplete System with sentences and their frequencies sentences = [\\"i love you\\", \\"island\\", \\"ironman\\", \\"i love leetcode\\"] frequencies = [5, 3, 2, 2] autocomplete_system = AutocompleteSystem(sentences, frequencies) # Typing \'i\' print(autocomplete_system.input(\'i\')) # Output: [\\"i love you\\", \\"island\\", \\"i love leetcode\\"] # Typing a space print(autocomplete_system.input(\' \')) # Output: [\\"i love you\\", \\"i love leetcode\\"] # Typing \'a\' print(autocomplete_system.input(\'a\')) # Output: [] # Typing \'#\' print(autocomplete_system.input(\'#\')) # Output: [] # Typing \'i\' again print(autocomplete_system.input(\'i\')) # Output: [\\"i love you\\", \\"island\\", \\"i love leetcode\\"] # Updating frequencies of existing sentences autocomplete_system.update(\\"i love leetcode\\", 5) # Typing \'i\', \'space\', \'l\' print(autocomplete_system.input(\'i\')) # Output: [\\"i love leetcode\\", \\"i love you\\", \\"island\\"] print(autocomplete_system.input(\' \')) # Output: [\\"i love leetcode\\", \\"i love you\\"] print(autocomplete_system.input(\'l\')) # Output: [\\"i love leetcode\\", \\"i love you\\"] ``` # Implementation Details: - Your program should use a trie to store words and their frequencies. - Utilize a priority queue for keeping track of top 3 sentences. - Ensure that the `input` method accurately reflects changes in the trie structure after each key press. # Performance Requirement: - Ensure that searching and updating frequencies in the trie data structure operates efficiently within constraints.","solution":"import collections class TrieNode: def __init__(self): self.children = {} self.frequencies = collections.defaultdict(int) # sentence to frequency class AutocompleteSystem: def __init__(self, sentences, frequencies): self.root = TrieNode() self.current_node = self.root self.current_input = \\"\\" for sentence, frequency in zip(sentences, frequencies): self.insert(sentence, frequency) def insert(self, sentence, frequency): node = self.root for char in sentence: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.frequencies[sentence] += frequency # necessary for end of the word node.frequencies[sentence] += frequency def input(self, c): if c == \'#\': self.insert(self.current_input, 1) self.current_input = \\"\\" self.current_node = self.root return [] self.current_input += c if self.current_node and c in self.current_node.children: self.current_node = self.current_node.children[c] else: self.current_node = None return [] sorted_sentences = sorted(self.current_node.frequencies.items(), key=lambda item: (-item[1], item[0])) return [sentence for sentence, freq in sorted_sentences[:3]] def update(self, sentence, frequency): node = self.root for char in sentence: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.frequencies[sentence] += frequency node.frequencies[sentence] += frequency"},{"question":"# Implement a Basic Calculator with Support for Variables **Scenario**: You are tasked with developing a basic calculator application that can evaluate simple arithmetic expressions involving addition, subtraction, multiplication, and division. Moreover, the calculator must be able to handle variables, where variable definitions are provided separately. **Task**: Implement the function `calculate_expression` that takes a mathematical expression as a string and a dictionary of variable definitions. The function should return the result of evaluating the expression with the given variables. ```python def calculate_expression(expression, variables): Evaluates a mathematical expression with support for variables. Parameters: expression : str A mathematical expression in the form of a string. variables : dict A dictionary where the keys are variable names (str) and values are numeric values (int or float) to replace in the expression. Returns: float : The result of evaluating the expression with the given variables. Raises: ValueError : If the expression or variables are invalid. pass ``` **Input and Output Formats**: - `expression`: A string representing an arithmetic expression (e.g., `\\"a + b * c\\"`, `\\"x / y - z\\"`). - `variables`: A dictionary where keys are strings representing variable names, and values are numbers (`int` or `float`). **Constraints**: 1. The expression will only contain the operators `+`, `-`, `*`, `/`, parentheses for grouping, and variables. 2. The variables dictionary may contain up to 100 entries. 3. All variable names and their values will be valid and defined properly. 4. Expression evaluation must handle division by zero gracefully, returning `float(\'inf\')` or `float(\'-inf\')` for such cases. **Performance Requirements**: Your solution should efficiently parse and evaluate the expressions, leveraging proper order of operations (time complexity O(n), space complexity O(n)). **Examples**: ```python assert calculate_expression(\\"a + b\\", {\\"a\\": 2, \\"b\\": 3}) == 5 assert calculate_expression(\\"x * y - z\\", {\\"x\\": 4, \\"y\\": 2.5, \\"z\\": 1}) == 9 assert calculate_expression(\\"(m + n) * p\\", {\\"m\\": 1, \\"n\\": 1, \\"p\\": 5}) == 10 assert calculate_expression(\\"k / l\\", {\\"k\\": 10, \\"l\\": 0}) == float(\'inf\') ``` **Note**: Make sure to handle invalid inputs gracefully by raising appropriate errors. Also, ensure that the operator precedence is correctly handled when evaluating the expressions.","solution":"def calculate_expression(expression, variables): Evaluates a mathematical expression with support for variables. Parameters: expression : str A mathematical expression in the form of a string. variables : dict A dictionary where the keys are variable names (str) and values are numeric values (int or float) to replace in the expression. Returns: float : The result of evaluating the expression with the given variables. Raises: ValueError : If the expression or variables are invalid. try: # Replace variables in the expression for var, value in variables.items(): if not isinstance(value, (int, float)): raise ValueError(\\"All variable values must be numeric (int or float)\\") expression = expression.replace(var, str(value)) # Evaluate the expression result = eval(expression) return result except ZeroDivisionError: return float(\'inf\') except Exception as e: raise ValueError(\\"Invalid expression or variables\\") from e"},{"question":"# Question **Context**: In text processing, one common task is to identify the frequency of words in a corpus of text. This can be useful for various applications, including keyword extraction, document summarization, and information retrieval. **Task**: Implement a function that computes the frequency of each word in a given text document. The function should ignore punctuation and be case-insensitive. **Requirements**: * Implement the function `word_frequencies(text: str) -> Dict[str, int]` * The input `text` is a string containing the text document. * Punctuation should be ignored, and word frequencies should be computed in a case-insensitive manner. * The function should return a dictionary where the keys are words and the values are their corresponding frequencies in the text. **Constraints**: * The input text can be up to 1,000,000 characters long. * Assume that the text only contains ASCII characters. **Performance**: * The implementation should efficiently handle large texts, aiming for a linear time complexity relative to the length of the text. **Example**: ```python def test_word_frequencies(): text = \\"Hello, world! Hello everyone. This is a test. This text is for testing; Testing, one two three.\\" expected_output = { \'hello\': 2, \'world\': 1, \'everyone\': 1, \'this\': 2, \'is\': 2, \'a\': 1, \'test\': 1, \'text\': 1, \'for\': 1, \'testing\': 2, \'one\': 1, \'two\': 1, \'three\': 1 } output = word_frequencies(text) assert output == expected_output # Add more test cases as necessary. print(\\"Test passed!\\") test_word_frequencies() ``` **Hints**: * Consider using regular expressions to remove punctuation and split the text into words. * Convert the text to lower case before processing to ensure case insensitivity.","solution":"import re from collections import defaultdict from typing import Dict def word_frequencies(text: str) -> Dict[str, int]: Compute the frequency of each word in a given text document. Ignore punctuation and be case-insensitive. Parameters: text (str): The input text document. Returns: Dict[str, int]: A dictionary where keys are words and values are their frequencies. # Convert text to lower case text = text.lower() # Use regex to find words (ignore punctuation) words = re.findall(r\'bw+b\', text) # Initialize a defaultdict to count word frequencies word_count = defaultdict(int) # Count each word for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Interval Merging Merging intervals is a common problem encountered in scheduling and spatial allocation tasks. Your challenge is to write a program that merges overlapping intervals. Task Implement a function `merge_overlapping_intervals` that takes a list of intervals, where each interval is represented by a tuple of two integers, and merges all overlapping intervals. Your Task 1. **Function Definition** Implement the following function in Python: ```python def merge_overlapping_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Your implementation here ``` 2. **Inputs** The function will receive: - `intervals`: A list of tuples, where each tuple consists of two integers representing the start and end of an interval. 3. **Expected Output** - The function should return a list of non-overlapping intervals covering all the input intervals. 4. **Constraints** - The intervals are not necessarily sorted. - The intervals can be open-ended but are represented with closed integers. - Each interval will have start <= end. 5. **Performance Requirements** - The time complexity should be O(n log n), where n is the number of intervals, due to the necessity of sorting the intervals. 6. **Implementation Details** - Sort the intervals based on their starting points. - Merge intervals iteratively by maintaining a current interval, and whenever an overlap is found, extend the current interval. - Store and return the merged list of intervals. Example Given the following intervals: - [(1, 3), (2, 6), (8, 10), (15, 18)] The function `merge_overlapping_intervals([(1, 3), (2, 6), (8, 10), (15, 18)])` should return `[(1, 6), (8, 10), (15, 18)]`. Given the following intervals: - [(1, 4), (4, 5)] The function `merge_overlapping_intervals([(1, 4), (4, 5)])` should return `[(1, 5)]`. Additional Instructions 1. Test your function with both examples and additional edge cases like single interval input and completely non-overlapping intervals. 2. Ensure your code is clean, well-commented, and follows good programming practices. Bonus (Optional) - Extend your `merge_overlapping_intervals` function to handle cases where the input list is empty gracefully, returning an empty list.","solution":"from typing import List, Tuple def merge_overlapping_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping intervals from a list of intervals represented by tuples. Args: intervals (List[Tuple[int, int]]): List of intervals represented as tuples (start, end). Returns: List[Tuple[int, int]]: List of merged, non-overlapping intervals. if not intervals: return [] # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last = merged_intervals[-1] if current[0] <= last[1]: # There is an overlap, merge the intervals merged_intervals[-1] = (last[0], max(last[1], current[1])) else: # No overlap, add the current interval to the list merged_intervals.append(current) return merged_intervals"},{"question":"# Coding Assessment Question: Scenario: You are developing an e-commerce platform where one of the key features is product recommendation based on user purchase history. Each product belongs to a specific category, and your goal is to determine the category that has the highest average purchase price. Users can purchase multiple products, and the same product can be bought multiple times by different users. # Function Signature: ```python def highest_average_price(categories: List[str], prices: List[float], sales: List[Tuple[str, float]]) -> str: pass ``` # Input: * `categories` (List[str]): A list of category names, where each name is a unique string. * `prices` (List[float]): A list of prices corresponding to each category in the same order, where each price is a positive float. * `sales` (List[Tuple[str, float]]): A list of tuples, where each tuple consists of a category (str) and the purchase price (float) of a product in that category. # Output: * Return the category name (str) that has the highest average purchase price. If there are multiple categories with the highest average price, return the one that appears first in the `categories` list. # Example: ```python categories = [\\"Electronics\\", \\"Books\\", \\"Clothing\\"] prices = [300.0, 20.0, 50.0] sales = [(\\"Electronics\\", 400.0), (\\"Books\\", 15.0), (\\"Books\\", 25.0), (\\"Clothing\\", 45.0), (\\"Clothing\\", 55.0), (\\"Electronics\\", 350.0)] assert highest_average_price(categories, prices, sales) == \\"Electronics\\" ``` # Constraints: - All category names in `categories` are unique. - `1 <= len(categories) == len(prices) <= 100` - `1 <= len(sales) <= 10^4` - Each `price` and sale price in `sales` is a positive float. # Performance Requirements: Ensure your solution efficiently handles input sizes within the provided constraints. Implementation: Write the function `highest_average_price` that calculates and returns the category name with the highest average purchase price based on user transactions and the base prices of the products in each category.","solution":"from typing import List, Tuple from collections import defaultdict def highest_average_price(categories: List[str], prices: List[float], sales: List[Tuple[str, float]]) -> str: # Initialize category index map index_map = {category: idx for idx, category in enumerate(categories)} # Dictionary to store total sales and count of sales for each category total_sales = defaultdict(float) sales_count = defaultdict(int) # Populate total sales and sales count for category, sale_price in sales: total_sales[category] += sale_price sales_count[category] += 1 # Dictionary to store the average purchase prices per category average_price_per_category = {} for category in categories: if sales_count[category] > 0: average_price_per_category[category] = total_sales[category] / sales_count[category] else: average_price_per_category[category] = prices[index_map[category]] # Find the category with the highest average purchase price highest_avg_price_category = max(average_price_per_category, key=average_price_per_category.get) return highest_avg_price_category"},{"question":"# Data Compression and Decompression Background In the field of data storage and transmission, it\'s essential to compress large files to save space or to send them efficiently over the network. One commonly used method is Run-Length Encoding (RLE), which reduces the size by replacing consecutive elements with a single element and a count. Task Implement two methods `compress` and `decompress` for the `RunLengthEncoder` class to handle the compression and decompression of a given string using Run-Length Encoding. Requirements - Define the `RunLengthEncoder` class with two methods: - `compress(self, input_string: str) -> str`: This method compresses the input string using RLE. - `decompress(self, compressed_string: str) -> str`: This method decompresses a RLE-compressed string back to its original form. Compression Description In Run-Length Encoding, consecutive occurrences of the same character are replaced by the character followed by the number of occurrences. For example, \\"aaabbcc\\" would be encoded as \\"a3b2c2\\". Decompression Description The decompression reverses the compression operation by expanding each character and its count back into the original string. For example, \\"a3b2c2\\" would be decoded back to \\"aaabbcc\\". Input - `compress` method: A single input string (A string consisting of lowercase alphabets) - `decompress` method: A single input string (A valid RLE-compressed string) Output - `compress` method: A Run-Length Encoded string. - `decompress` method: The original string decompressed from the RLE format. Example Usage ```python class RunLengthEncoder: def compress(self, input_string: str) -> str: # Implement compression logic here compressed_string = \\"\\" if not input_string: return compressed_string count = 1 current_char = input_string[0] for i in range(1, len(input_string)): if input_string[i] == current_char: count += 1 else: compressed_string += current_char + str(count) current_char = input_string[i] count = 1 compressed_string += current_char + str(count) return compressed_string def decompress(self, compressed_string: str) -> str: # Implement decompression logic here decompressed_string = \\"\\" i = 0 while i < len(compressed_string): char = compressed_string[i] count = int(compressed_string[i+1]) # Assumes valid input decompressed_string += char * count i += 2 return decompressed_string # Example Usage encoder = RunLengthEncoder() compressed = encoder.compress(\\"aaabbcc\\") print(compressed) # Output: \\"a3b2c2\\" decompressed = encoder.decompress(compressed) print(decompressed) # Output: \\"aaabbcc\\" ``` Constraints - Ensure the `compress` method handles strings efficiently even if they contain long runs of repeated characters. - Ensure the `decompress` method correctly handles valid compressed strings and any edge cases presented by the compression. Good luck!","solution":"class RunLengthEncoder: def compress(self, input_string: str) -> str: Compress the input string using Run-Length Encoding. compressed_string = \\"\\" if not input_string: return compressed_string count = 1 current_char = input_string[0] for i in range(1, len(input_string)): if input_string[i] == current_char: count += 1 else: compressed_string += current_char + str(count) current_char = input_string[i] count = 1 compressed_string += current_char + str(count) return compressed_string def decompress(self, compressed_string: str) -> str: Decompress the Run-Length Encoded string back to its original form. decompressed_string = \\"\\" i = 0 while i < len(compressed_string): char = compressed_string[i] count = int(compressed_string[i+1]) # Assumes valid input decompressed_string += char * count i += 2 return decompressed_string"},{"question":"# Disjoint Set Union (DSU) with Path Compression and Union by Rank **Context:** You are given a series of elements and a set of union and find operations. Your task is to efficiently manage these operations using a Disjoint Set Union (DSU) structure, which supports union by rank and path compression techniques to optimize for performance. # Requirements: 1. Implement a Disjoint Set Union (DSU) that supports: * **Union Operation**: Merge two sets containing different elements. * **Find Operation**: Retrieve the representative or root of the set containing a particular element, with path compression to flatten the structure. # Specifications: * **Function Definitions**: * `__init__(self, n: int)`: Initialize the DSU with `n` elements, where each element is initially its own representative. * `find(self, x: int) -> int`: Return the representative of the set containing `x`. * `union(self, x: int, y: int)`: Merge the sets containing `x` and `y`. * **Input Constraints**: * 0 ≤ x, y < n * The total number of operations (union and find) will be within a reasonable limit to ensure performance. * Each element belongs to exactly one set initially. * **Example**: ```python dsu = DSU(5) dsu.union(0, 1) dsu.union(1, 2) assert dsu.find(0) == dsu.find(2) # 0, 1, and 2 are in the same set dsu.union(3, 4) assert dsu.find(3) != dsu.find(0) # 3 and 0 are in different sets dsu.union(2, 4) assert dsu.find(0) == dsu.find(4) # 0, 1, 2, 3, and 4 are now in the same set ``` * **Edge Cases to Consider**: * Union operations on elements already in the same set. * Find operations on elements never queried before. * Union operations that result in complex set structures. # Objective: Provide a clean and efficient implementation of the Disjoint Set Union (DSU) with path compression and union by rank. Ensure to handle all edge cases robustly.","solution":"class DSU: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1"},{"question":"# Matrix Spiral Traversal You are given an (n times n) matrix of integers. Your task is to traverse the matrix in a spiral order and collect the integers into a list. Implementation: You need to implement a function: ```python def spiral_traversal(matrix: List[List[int]]) -> List[int]: pass ``` **Input**: - `matrix` (List[List[int]]): A 2D list representing the (n times n) matrix of integers. **Output**: - Return a list of integers representing the elements of the matrix traversed in spiral order. **Constraints**: - The matrix will always be square and have dimensions (n times n) where (1 leq n leq 100). - Each element in the matrix is an integer and can be within the range of (-1000) to (1000). **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert spiral_traversal(matrix) == [1, 2, 3, 6, 9, 8, 7, 4, 5] matrix = [ [1, 2], [3, 4] ] assert spiral_traversal(matrix) == [1, 2, 4, 3] ``` Your solution should correctly follow the spiral order to traverse through the matrix and gather the numbers as specified.","solution":"def spiral_traversal(matrix): if not matrix or not matrix[0]: return [] res = [] left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1 while left <= right and top <= bottom: # Traverse from left to right. for i in range(left, right + 1): res.append(matrix[top][i]) top += 1 # Traverse downwards. for i in range(top, bottom + 1): res.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left. for i in range(right, left - 1, -1): res.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top. for i in range(bottom, top - 1, -1): res.append(matrix[i][left]) left += 1 return res"},{"question":"# Matrix Diagonal Sum Context You are required to work with a matrix and calculate specific sums based on the diagonal elements. This question tests your ability to handle multi-dimensional arrays and perform efficient calculations. Problem Statement 1. **Primary Diagonal Sum**: Implement a method `primary_diagonal_sum(matrix: List[List[int]]) -> int` that calculates the sum of the primary diagonal elements of a given square matrix. * **Input**: A 2D list `matrix` of integers representing an `n x n` square matrix. * **Output**: An integer representing the sum of the primary diagonal elements. 2. **Secondary Diagonal Sum**: Implement a method `secondary_diagonal_sum(matrix: List[List[int]]) -> int` that calculates the sum of the secondary diagonal elements of a given square matrix. * **Input**: A 2D list `matrix` of integers representing an `n x n` square matrix. * **Output**: An integer representing the sum of the secondary diagonal elements. # Implementation Details * Implement the following two methods inside a class `MatrixOperations`: ```python class MatrixOperations: @staticmethod def primary_diagonal_sum(matrix: List[List[int]]) -> int: # Your implementation here @staticmethod def secondary_diagonal_sum(matrix: List[List[int]]) -> int: # Your implementation here ``` # Example Usage ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mos = MatrixOperations() print(mos.primary_diagonal_sum(matrix)) # Should print: 15 (1 + 5 + 9) print(mos.secondary_diagonal_sum(matrix)) # Should print: 15 (3 + 5 + 7) ``` * **Constraints**: - The provided `matrix` will always be a list of lists containing integers. - The matrix is always square, i.e., the number of rows equals the number of columns. - The size of the matrix `n` will be between 1 and 1000 inclusive. * **Submission Requirements**: - Both `primary_diagonal_sum` and `secondary_diagonal_sum` methods should work independently and return the respective sums as integers. Explain your approach after implementing the above methods briefly.","solution":"from typing import List class MatrixOperations: @staticmethod def primary_diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) return sum(matrix[i][i] for i in range(n)) @staticmethod def secondary_diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) return sum(matrix[i][n - 1 - i] for i in range(n))"},{"question":"# Question Context You are required to implement a strategy for managing a resource pool where resources can be checked out and returned. Your goal is to ensure that no resource is checked out more than once and that all resources are efficiently managed. # Problem Statement Implement a class called `ResourcePool` in Python which manages a fixed set of resources. Each resource can be checked out and returned. Your implementation should maintain correctness and efficiency, and you should write thorough unit tests using Python\'s `unittest` framework to validate your solution. # Requirements 1. **Class Definition**: ```python class ResourcePool: def __init__(self, resources: list): pass def checkout(self) -> str: pass def return_resource(self, resource: str) -> None: pass ``` 2. **Behavior**: - The `__init__` method initializes the resource pool with a list of resources. - The `checkout` method allows a resource to be checked out if any are available, returning the checked-out resource. - The `return_resource` method allows a checked-out resource to be returned to the pool. - If no resources are available for checkout, the `checkout` method should raise an exception. - If an attempt is made to return a resource not currently checked out, the `return_resource` method should raise an exception. 3. **Testing Requirements**: - Use Python\'s `unittest` framework. - Validate that resources can be checked out and returned correctly. - Ensure the correct exceptions are raised when attempting to checkout a resource with none available, or return a resource that wasn\'t checked out. - Write tests to cover edge cases, such as attempting to return a resource that was never in the pool. # Expected Input and Output Formats - **Input**: - The class methods do not take standard input parameters in the usual sense. Initialization takes a list of strings representing resources. - The \'checkout\' method takes no parameters and returns a string. - The \'return_resource\' method takes a single string representing the resource to return. - **Output**: - No standard output, but the methods manage the internal state of the resource pool and may raise exceptions. # Constraints - The initial list of resources will always be non-empty. - The pool should handle up to 1000 resources efficiently. # Performance Requirements - All operations should be completed in a time efficient manner, ideally O(1) for each method call. # Implementation You are required to implement the `ResourcePool` class and a comprehensive set of unit tests following the outlined specifications.","solution":"class ResourcePool: def __init__(self, resources: list): self.available_resources = set(resources) self.checked_out_resources = set() def checkout(self) -> str: if not self.available_resources: raise Exception(\\"No resources available to check out\\") resource = self.available_resources.pop() self.checked_out_resources.add(resource) return resource def return_resource(self, resource: str) -> None: if resource not in self.checked_out_resources: raise Exception(\\"Resource was not checked out\\") self.checked_out_resources.remove(resource) self.available_resources.add(resource)"},{"question":"# Question: Disk Utilization Over Time Simulator Your task is to implement a function that simulates the disk utilization over a period, given a list of starting utilization percentages, a list of daily utilization changes, and the total number of days for the simulation. Function Specifications 1. **Function Signature** ```python def disk_utilization_simulator( initial_utilizations: list, daily_changes: list, days: int ) -> list: ``` 2. **Input** - `initial_utilizations`: List of initial disk utilization percentages for multiple disks (e.g., [70, 50, 80]). - `daily_changes`: List of daily utilization changes corresponding to each day in the simulation (e.g., [2, -1, 0]). - `days`: Total number of days to simulate. 3. **Output** - A list of final disk utilization percentages for each disk after simulating the given number of days. Constraints - The length of `initial_utilizations` will be equal to or greater than 1. - The length of `daily_changes` will be equal to or greater than the number of days specified. - Disk utilization percentages will be in the range of 0 to 100. - Utilization percentages should be clamped to fit within the range of 0 to 100 after each daily change. Edge Cases to Consider - Ensure that the disk utilization never goes below 0% or above 100% after applying daily changes. - Consider scenarios where daily changes might result in utilization percentages that require clamping. Example ```python # Given initial utilizations initial_utilizations = [70, 50, 80] # Given daily changes daily_changes = [2, -1, 0, 3, -4] # Given number of days days = 3 # Call the function final_utilizations = disk_utilization_simulator(initial_utilizations, daily_changes, days) # Expected output print(final_utilizations) # Example: [76, 47, 86] ```","solution":"def disk_utilization_simulator(initial_utilizations: list, daily_changes: list, days: int) -> list: final_utilizations = initial_utilizations.copy() for day in range(days): for i in range(len(final_utilizations)): final_utilizations[i] += daily_changes[day] final_utilizations[i] = max(0, min(100, final_utilizations[i])) return final_utilizations"},{"question":"# Problem Statement You are given a collection of meeting time intervals in the form of a 2D array `meetings`, where each meeting `i` is represented as `[start_i, end_i]`. Your task is to determine if a person can attend all the meetings without any overlaps. Implement the function `can_attend_all_meetings` with the following signature: ```python def can_attend_all_meetings(meetings: List[List[int]]) -> bool: Determine if a person can attend all meetings without any overlaps. Args: - meetings (List[List[int]]): A list of lists where each sublist contains two integers [start, end]. Returns: - bool: True if a person can attend all meetings without conflicts, False otherwise. ``` # Constraints - The number of meetings will not exceed 10,000. - The start and end times are integers within the range `0` to `10^6` (inclusive). - Each meeting\'s end time will be greater than its start time. # Example ```python meetings = [[0, 30], [5, 10], [15, 20]] result = can_attend_all_meetings(meetings) print(result) # Expected Output: False ``` # Notes - Sort the meetings by their start time and iterate through them to check for any overlaps. - An overlap occurs if the start time of the current meeting is less than the end time of the previous meeting.","solution":"from typing import List def can_attend_all_meetings(meetings: List[List[int]]) -> bool: Determine if a person can attend all meetings without any overlaps. Args: - meetings (List[List[int]]): A list of lists where each sublist contains two integers [start, end]. Returns: - bool: True if a person can attend all meetings without conflicts, False otherwise. # Sort the meetings by their start time meetings.sort(key=lambda x: x[0]) # Iterate through the sorted list and check for any overlaps for i in range(1, len(meetings)): if meetings[i][0] < meetings[i - 1][1]: return False return True"},{"question":"# List Partitioning: Balanced Equal Sum Problem Statement You are given an array of integers. The task is to determine if the array can be partitioned into two non-empty subarrays such that the sum of the elements in both subarrays is equal. Write a function `can_partition(nums: List[int]) -> bool` to determine if the partition is possible. Input * `nums` (List[int]): A list of integers where each integer can be negative, zero, or positive. Output * Return `True` if the array can be partitioned into two subarrays with equal sum. * Otherwise, return `False`. Constraints * The length of `nums` will be between 2 and 500. * The elements of `nums` will be between -1000 and 1000. Examples ```python can_partition([1, 5, 11, 5]) -> True # Explanation: [1, 5, 5] and [11] have the same sum of 11. can_partition([1, 2, 3, 5]) -> False # Explanation: No partition exists with equal sum. ``` Additional Information A feasible solution involves calculating the total sum of the array and using dynamic programming to determine if a subset with half of this sum can be formed from the elements of the array. Consider all possible partitions and test your function thoroughly to ensure correctness across a variety of edge cases.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If the total sum is odd, we cannot partition it into two equal sum parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be achieved using elements from 0 to current index dp = [False] * (target + 1) dp[0] = True for num in nums: # iterate backwards to prevent overwriting results within the same iteration for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"# Coding Question: Advanced Dynamic Programming Wildcard Matching **Context**: Bob is working on a pattern matching algorithm for a search engine\'s query filter. The algorithm should support wildcard characters in search queries to match sequences of characters in text data. The wildcard characters are `\'*\'` (matches any sequence of characters, including the empty sequence) and `\'?\'` (matches any single character). **Objective**: Your task is to implement the `WildcardMatching` class that determines whether a given string matches a given pattern using dynamic programming. **Function to Implement**: You need to implement the `WildcardMatching` class with the following method: ```python class WildcardMatching: def __init__(self, pattern: str): # Initialize the method with the pattern. pass def is_match(self, s: str) -> bool: # Method to check if the string s matches the pattern. pass ``` **Input Format**: - The constructor `__init__` receives a string `pattern` containing the wildcard pattern. - Example: `pattern = \\"a*b?d\\"` - The `is_match` method receives a string `s` to be matched against the pattern. - Example: `s = \\"aabcd\\"` **Output Format**: - The `is_match` method should return a boolean value: `True` if the pattern matches the string, `False` otherwise. - Example: `True` or `False` **Constraints**: - The length of the pattern and string can be up to 1000 characters. - The pattern contains only lowercase letters, `\'*\'`, and `\'?\'`. - The string contains only lowercase letters. **Performance Requirements**: - The solution must handle cases efficiently, optimizing both time and space complexity. **Example**: Given the pattern and string: ```python pattern = \\"a*b?d\\" s = \\"aabcd\\" ``` Output: - The result should be: `True` Given the pattern and string: ```python pattern = \\"a*d\\" s = \\"abcd\\" ``` Output: - The result should be: `False` Write your implementation in the class provided to correctly determine if the pattern matches the string using dynamic programming.","solution":"class WildcardMatching: def __init__(self, pattern: str): self.pattern = pattern def is_match(self, s: str) -> bool: m, n = len(s), len(self.pattern) # dp[i][j] will be True if the first i characters in string s # matches the first j characters in pattern dp = [[False] * (n + 1) for _ in range(m + 1)] # Base case: Empty string matches empty pattern dp[0][0] = True # Handle patterns with \'*\'s that match empty strings for j in range(1, n + 1): if self.pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Build the DP table for i in range(1, m + 1): for j in range(1, n + 1): if self.pattern[j - 1] == \'*\': # \'*\' can match zero or more of the preceding element dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif self.pattern[j - 1] == \'?\' or self.pattern[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"# Coding Assessment Question Objective To evaluate the understanding and implementation of binary search algorithm. Question You are provided with a sorted list of integers and a target integer. Your task is to write a function to determine the index of the target in the list using the binary search algorithm. If the target is not in the list, return -1. Function Signature ```python def binary_search(nums: list[int], target: int) -> int: Returns the index of the target integer in a sorted list. :param nums: Sorted list of integers :param target: Integer to find in the list :return: Index of the target integer, or -1 if not found ``` Inputs 1. `nums`: A list of integers sorted in ascending order. (1 ≤ len(nums) ≤ 10^5, -10^9 ≤ nums[i] ≤ 10^9) 2. `target`: An integer representing the value to find in the list (-10^9 ≤ target ≤ 10^9) Outputs - An integer representing the index of the target integer in the list, or -1 if the target is not found. Constraints - Optimize the function to run in logarithmic time, O(log n). Example ```python >>> nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> target = 5 >>> binary_search(nums, target) 4 >>> nums = [-10, -5, 0, 3, 8, 12] >>> target = 8 >>> binary_search(nums, target) 4 >>> nums = [2, 3, 4, 10, 40] >>> target = 10 >>> binary_search(nums, target) 3 >>> nums = [1, 3, 5, 7, 9] >>> target = 2 >>> binary_search(nums, target) -1 ``` Notes * Consider edge cases where the target is the first or last element in the list, or the list contains only one element. * Ensure to handle cases where the target value is not present in the list by returning -1. * Justify the usage of the binary search algorithm over other methods. * Ensure the function runs efficiently for large input sizes.","solution":"def binary_search(nums: list[int], target: int) -> int: Returns the index of the target integer in a sorted list. :param nums: Sorted list of integers :param target: Integer to find in the list :return: Index of the target integer, or -1 if not found left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Faculty Allocation for Course Schedule In a university setting, proper allocation of faculty to courses while maintaining a balanced workload is essential for smooth operations. Each faculty member can teach a limited number of courses and every course has a certain number of sections to cover. Your task is to create an algorithm that assigns faculty to courses in a way that attempts to balance the total workload across all faculty members. **Function Signature**: ```python def allocate_faculty(m: int, capacity: List[int], n: int, course_sections: List[int]) -> List[List[int]]: ``` **Input**: * `m`: (Integer) The number of faculty members. * `capacity`: (List of Integers) A list where capacity[i] represents the maximum number of sections that faculty member `i` can handle. * `n`: (Integer) The number of distinct courses. * `course_sections`: (List of Integers) A list where course_sections[j] represents the number of sections required by course `j`. **Output**: * A 2D list where `result[i]` contains the indices of courses (0-indexed) that faculty member `i` is assigned to. If it\'s not possible to allocate all courses within the given capacities, return an empty list. **Constraints**: * 1 ≤ m ≤ 100 * 1 ≤ n ≤ 100 * 1 ≤ capacity[i] ≤ 20 * 1 ≤ course_sections[j] ≤ 20 **Example**: ```python >>> m = 3 >>> capacity = [5, 7, 8] >>> n = 4 >>> course_sections = [4, 3, 2, 1] >>> allocate_faculty(m, capacity, n, course_sections) [ [0, 3], # faculty 0 handles courses 0 and 3 (total sections 4+1=5) [1, 2], # faculty 1 handles courses 1 and 2 (total sections 3+2=5) [] # faculty 2 has no courses assigned ] ``` **Important Considerations**: * Aim to distribute the workload as evenly as possible while respecting the faculty capacities. * If a solution exists, ensure that no faculty member exceeds their maximum capacity. * If it is not feasible to allocate all course sections to the available faculty without exceeding their capacities, return an empty list. Good luck!","solution":"from typing import List def allocate_faculty(m: int, capacity: List[int], n: int, course_sections: List[int]) -> List[List[int]]: # Container for each faculty\'s assignment assignment = [[] for _ in range(m)] # Container for each faculty\'s used capacity used_capacity = [0] * m # To sort the courses by their number of sections in descending order course_indices = sorted(range(n), key=lambda x: course_sections[x], reverse=True) for course in course_indices: assigned = False for faculty in range(m): if used_capacity[faculty] + course_sections[course] <= capacity[faculty]: assignment[faculty].append(course) used_capacity[faculty] += course_sections[course] assigned = True break if not assigned: return [] # If we couldn\'t assign this course, return an empty list return assignment"},{"question":"# Scenario As a software developer for a startup, you are tasked with developing a new feature for the company\'s e-commerce platform. This feature involves helping customers to find all products whose prices fall within a specified range. Given a list of product prices, you need to implement a function that filters the products based on the given price range. # Task Write a function `filter_products_in_price_range(prices: List[int], low: int, high: int) -> List[int]` that returns a list of prices that fall within the specified range `[low, high]` inclusive. # Input * **prices**: A list of integers `prices` where `1 <= len(prices) <= 1,000,000` and each price `1 <= prices[i] <= 1,000,000`. * **low**: An integer `1 <= low <= high <= 1,000,000` representing the lower bound of the price range. * **high**: An integer `1 <= high <= 1,000,000` representing the upper bound of the price range. # Output * Return a list of integers representing the prices that fall within the specified range `[low, high]`. # Function Signature ```python from typing import List def filter_products_in_price_range(prices: List[int], low: int, high: int) -> List[int]: pass ``` # Examples * `filter_products_in_price_range([10, 22, 37, 4, 5, 89], 5, 30)` should return `[10, 22, 5]`. * `filter_products_in_price_range([100, 200, 300, 400], 150, 350)` should return `[200, 300]`. # Constraints * Ensure the function is efficient, given the potentially large size of the input list. * Consider edge cases, such as when no prices fall within the given range or when all prices do. # Notes * You may assume that the input list and range values always adhere to the given constraints. * The function should maintain the order of prices as in the original list.","solution":"from typing import List def filter_products_in_price_range(prices: List[int], low: int, high: int) -> List[int]: Filters and returns the list of prices that fall within the given range [low, high] inclusive. return [price for price in prices if low <= price <= high]"},{"question":"# Coding Question: Most Frequent Element Scenario You are developing an e-commerce application where you need to analyze customer behaviors based on their activity logs. One of the tasks involves identifying the most frequently visited product on the website. Problem Write a function to find the most frequent element in a list of integers. If there are multiple elements with the same highest frequency, return the smallest one. Function Signature ```python def most_frequent_element(elements: List[int]) -> int: ``` Input * A list of integers `elements` (0 ≤ len(elements) ≤ 10^6, -10^6 ≤ elements[i] ≤ 10^6). Output * An integer representing the most frequent element. If the list is empty, return `None`. Constraints * The list may contain duplicate elements. * The list may include negative numbers, zero, and positive numbers. Performance Requirements * Your solution should have a linear or better time complexity. Example ```python >>> most_frequent_element([1, 3, 2, 2, 1, 3, 3]) 3 >>> most_frequent_element([4, 4, 4, 2, 2]) 4 >>> most_frequent_element([-1, -1, -1, -2, -2, 0]) -1 >>> most_frequent_element([]) None ``` Note: * In the first example, the element `3` appears 3 times, which is more frequent than any other element. * In the second example, the element `4` appears the most frequently (3 times). * In the third example, the element `-1` appears the most frequently (3 times). * In the fourth example, the list is empty, hence the return value is `None`. Edge Cases * Empty list should return `None`. * List with all unique elements should return the smallest one. * List with multiple elements having the same frequency should return the smallest one among them. Implement the function `most_frequent_element`.","solution":"from typing import List, Optional from collections import Counter def most_frequent_element(elements: List[int]) -> Optional[int]: if not elements: return None frequency = Counter(elements) max_count = max(frequency.values()) most_frequent = [key for key, count in frequency.items() if count == max_count] return min(most_frequent)"},{"question":"# Matrix Rotation by 90 Degrees **Scenario**: As part of your work on image processing software, you need a function that can rotate a square matrix, representing an image, by 90 degrees in a clockwise direction. **Task**: Implement the following function to perform the matrix rotation: ```python def rotate_matrix_90(matrix): Rotates a square matrix by 90 degrees clockwise. Parameters: matrix : list[list[int]] A 2D list where each sublist represents a row of the matrix. Returns: list[list[int]] : A new 2D list representing the rotated matrix. Raises: ValueError : If the input is not a valid square matrix. pass ``` **Input and Output Formats**: - `matrix`: A list of lists where each sublist is of equal length and represents a row in the matrix. **Constraints**: 1. The matrix is non-empty and square (i.e., has the same number of rows and columns). 2. The elements of the matrix are integers. 3. The length of each sublist must be equal to the number of sublists to form a valid square matrix. **Performance Requirements**: Your solution should be efficient, with a time complexity of O(n^2) and a space complexity of O(n^2), where `n` is the number of rows (or columns) in the matrix. **Examples**: ```python assert rotate_matrix_90([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix_90([ [1, 2], [3, 4] ]) == [ [3, 1], [4, 2] ] assert rotate_matrix_90([ [1] ]) == [ [1] ] # Example explanations: # 1. For the first example, rotating the 3x3 matrix results in: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # 2. For the second example, rotating the 2x2 matrix results in: # [ # [3, 1], # [4, 2] # ] # 3. For the third example, a 1x1 matrix remains unchanged when rotated. ``` **Note**: Ensure proper validation of the input matrix and raise `ValueError` if the input format is incorrect.","solution":"def rotate_matrix_90(matrix): Rotates a square matrix by 90 degrees clockwise. Parameters: matrix : list[list[int]] A 2D list where each sublist represents a row of the matrix. Returns: list[list[int]] : A new 2D list representing the rotated matrix. Raises: ValueError : If the input is not a valid square matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"The input must be a non-empty square matrix\\") n = len(matrix) # Initialize a new matrix with the same size as the original rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Fibonacci Sequence Calculation: Iterative Approach Background The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. Starting with 0 and 1, the sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, ... Task Write a function `fibonacci(n: int) -> int` that calculates the nth Fibonacci number using an iterative approach. Input - `n`: An integer specifying the position in the Fibonacci sequence (0-indexed). Output - Returns an integer which is the nth Fibonacci number. Constraints - 0 ≤ `n` ≤ 50 Example ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(6) 8 ``` Additional Notes - The function should handle the input efficiently to avoid excessive computational times, especially for higher values of `n`. Your task is to implement this `fibonacci` function correctly and efficiently.","solution":"def fibonacci(n): Returns the nth Fibonacci number using an iterative approach. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Coding Question: Time Interval Overlap Detection **Background**: In scheduling or booking systems, it is often necessary to check for overlapping time intervals to prevent double-booking or to optimize resource allocation. An interval is represented as a tuple `(start, end)` where `start` is the start time and `end` is the end time. **Task**: Implement a function that takes a list of intervals and determines if any two intervals overlap. An overlap means that one interval starts before another interval ends. **Function Signature**: ```python def has_overlap(intervals: list) -> bool: Determines if there is any overlap between given intervals. :param intervals: A list of tuples, where each tuple consists of start and end times (both integers). :return: Boolean value, True if any two intervals overlap, False otherwise. Example: >>> has_overlap([(1, 3), (5, 8), (4, 6)]) True pass ``` **Instructions**: 1. Implement the function `has_overlap(intervals)` which checks for overlapping intervals in the list. 2. An interval `(a, b)` overlaps with `(c, d)` if `a < d` and `c < b`. 3. Ensure the function handles edge cases such as: - Empty input list - Single interval in the list - Lists with intervals having same start and end times 4. Optimize for performance to handle larger lists up to 10^5 intervals. **Constraints**: - Each interval is a tuple of two integers within the range of [-10^9, 10^9]. - The list `intervals` can contain up to 10^5 elements. **Example**: ```python >>> has_overlap([(1, 3), (5, 8), (4, 6)]) True >>> has_overlap([(1, 2), (3, 4), (5, 6)]) False >>> has_overlap([(1, 3), (2, 4)]) True >>> has_overlap([]) False >>> has_overlap([(5, 5)]) False ```","solution":"def has_overlap(intervals): Determines if there is any overlap between given intervals. :param intervals: A list of tuples, where each tuple consists of start and end times (both integers). :return: Boolean value, True if any two intervals overlap, False otherwise. if not intervals: return False # Sort intervals by start time intervals.sort() # Compare each interval with the next one for i in range(len(intervals) - 1): if intervals[i][1] > intervals[i + 1][0]: return True return False"},{"question":"# Scenario You are developing a game where players can unlock various achievements based on their actions and scores. To encourage players to replay and improve, your backend system should keep track of the highest scores achieved in different levels and compare them against new scores to update the leaderboard. # Task Write a function `update_leaderboard` that takes in a dictionary representing the current high scores on different levels and a list of tuples with new scores. The function should update the high scores dictionary based on the new scores and return the updated dictionary. If a new score is higher than the existing high score for a level, it should replace the old score. If there are multiple new scores for a level, only the highest one should be considered. # Function Signature ```python def update_leaderboard(high_scores: dict[str, int], new_scores: list[tuple[str, int]]) -> dict[str, int]: ``` # Input - `high_scores`: A dictionary where the keys are level names (strings) and the values are the highest scores (integers) achieved on those levels. - `new_scores`: A list of tuples where each tuple contains a level name (string) and a new score (integer). # Output - Returns an updated dictionary with the highest scores for each level. # Constraints - `high_scores` and `new_scores` will always contain valid level names and scores. - The new scores can include levels not yet present in the high scores dictionary. # Examples ```python high_scores = {\'level1\': 1500, \'level2\': 3000, \'level3\': 2500} new_scores = [(\'level1\', 1800), (\'level2\', 2800), (\'level3\', 3200), (\'level4\', 2700)] print(update_leaderboard(high_scores, new_scores)) # Output: {\'level1\': 1800, \'level2\': 3000, \'level3\': 3200, \'level4\': 2700} high_scores = {\'level1\': 1500, \'level2\': 3000} new_scores = [(\'level1\', 1400), (\'level2\', 3100), (\'level3\', 2800)] print(update_leaderboard(high_scores, new_scores)) # Output: {\'level1\': 1500, \'level2\': 3100, \'level3\': 2800} high_scores = {} new_scores = [(\'level1\', 1500), (\'level2\', 3000)] print(update_leaderboard(high_scores, new_scores)) # Output: {\'level1\': 1500, \'level2\': 3000} ``` # Notes - Ensure that the function updates the dictionary in place and returns the result. - Handle cases where there are no current high scores or the new scores introduce new levels. - The function should efficiently manage large numbers of levels and scores, ensuring performance scalability.","solution":"def update_leaderboard(high_scores: dict[str, int], new_scores: list[tuple[str, int]]) -> dict[str, int]: for level, score in new_scores: if level in high_scores: if score > high_scores[level]: high_scores[level] = score else: high_scores[level] = score return high_scores"},{"question":"# Coding Question Introduction: Sorting algorithms are fundamental to computer science and numerous applications depend on their efficiency. Merge Sort is a classic divide-and-conquer algorithm that reliably sorts data in O(n log n) time. In this task, you will implement the Merge Sort algorithm to sort an input list of integers. Task: Write a function `merge_sort` that takes a list of integers as input and returns a new list with the integers sorted in non-decreasing order. Ensure your implementation uses recursion to divide the list and the merge step to combine the sorted sublists. Function Signature: ```python def merge_sort(numbers: List[int]) -> List[int]: ``` Input: - `numbers`: A list of integers to be sorted. The list can contain duplicate values and its length can vary from 0 to 1000. Output: - A list of integers sorted in non-decreasing order. Constraints: - Do not use any built-in sorting functions. - The solution must implement the merge sort algorithm using recursion. Example: ```python # Example call result = merge_sort([38, 27, 43, 3, 9, 82, 10]) # Example output # [3, 9, 10, 27, 38, 43, 82] ``` Notes: 1. Ensure your function handles edge cases such as empty input list or list with one element correctly. 2. Focus on implementing the divide-and-conquer approach, split the list until sublists of size one are achieved, then merge them back in a sorted order. 3. Recursion and helper functions are highly recommended to achieve a cleaner implementation.","solution":"from typing import List def merge_sort(numbers: List[int]) -> List[int]: if len(numbers) <= 1: return numbers # Base case: a list of one element is inherently sorted # Recursive case: divide the list into halves and sort each half middle = len(numbers) // 2 left_half = merge_sort(numbers[:middle]) right_half = merge_sort(numbers[middle:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # If there are remaining elements in the left list, add them if left_index < len(left): sorted_list.extend(left[left_index:]) # If there are remaining elements in the right list, add them if right_index < len(right): sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Question: Secure Message Encoding Context You have been tasked with creating a secure messaging system. One of the components of this system involves encoding messages to ensure sensitive data is not easily deciphered if intercepted. Your goal is to develop an encoding function that transforms a given message by shifting each letter by a specified number of steps in the alphabet. Task Write a function to encode a message using a Caesar cipher. The Caesar cipher is a type of substitution cipher in which each letter in the plaintext is shifted a certain number of places down the alphabet. # Requirements 1. **Function Signature**: `def caesar_cipher_encode(message: str, shift: int) -> str:` 2. **Input**: - A string `message` consisting of lowercase and uppercase English letters and spaces. - An integer `shift` which specifies the number of positions to shift each letter. The value of `shift` will be within the range [-26, 26]. - Example: `message = \\"hello world\\"`, `shift = 3` 3. **Output**: - A string representing the encoded message where each letter is shifted by `shift` positions. Spaces should be preserved as is. 4. **Constraints**: - The case of the letters (uppercase or lowercase) must be preserved in the encoded message. - Spaces and non-letter characters should not be altered. - Ensure the function handles cases where `shift` is negative, effectively working as a backward shift in the alphabet. # Performance Expectations - The solution should operate in **O(n)** time complexity, where n is the length of the message. Example ```python >>> caesar_cipher_encode(\\"hello world\\", 3) \'khoor zruog\' >>> caesar_cipher_encode(\\"HELLO WORLD\\", 3) \'KHOOR ZRUOG\' >>> caesar_cipher_encode(\\"abc XYZ\\", -3) \'xyz UVW\' >>> caesar_cipher_encode(\\"Secure Message\\", 26) \'Secure Message\' >>> caesar_cipher_encode(\\"Secure Message!\\", 3) \'Vhfxuh Phvvdjh!\' ``` # Additional Test Cases ```python >>> caesar_cipher_encode(\\"AaBbCc\\", 1) \'BbCcDd\' >>> caesar_cipher_encode(\\"Why come here\\", 5) \'Bmz htrj mjwj\' >>> caesar_cipher_encode(\\"Python3.8\\", 4) \'Tcznsr3.8\' ```","solution":"def caesar_cipher_encode(message: str, shift: int) -> str: def shift_char(c, base): return chr((ord(c) - base + shift) % 26 + base) encoded_message = [] for char in message: if char.islower(): encoded_message.append(shift_char(char, ord(\'a\'))) elif char.isupper(): encoded_message.append(shift_char(char, ord(\'A\'))) else: encoded_message.append(char) return \'\'.join(encoded_message)"},{"question":"# Coding Assessment Question Write a function `find_kth_smallest_unsorted` that finds the k-th smallest element in an unsorted array using the Quickselect algorithm. Quickselect is a selection algorithm to find the k-th smallest (or largest) element in an unordered list. It is related to the quicksort sorting algorithm. Also write a helper function `partition` to be used within Quickselect to partition the array around a pivot element. Function Signature ```python def find_kth_smallest_unsorted(arr, k): pass ``` Input/Output * **Input**: - `arr`: A list of integers representing the unsorted array. - `k`: An integer representing the position of the smallest element to find (1-based index). * **Output**: - Returns the k-th smallest element in the list. Constraints * The elements in `arr` can be both positive and negative integers. * The length of the array will be at most 10,000. * 1 ≤ k ≤ len(arr) Scenario You are working on a project that involves processing large datasets where you need to efficiently find specific order statistics (e.g., the k-th smallest number). Quickselect will help in reducing the time complexity compared to naive O(nlogn) sorting-based approaches. Performance Requirements * The implemented algorithm should have an average time complexity of O(n). Example ```python print(find_kth_smallest_unsorted([3, 1, 2, 4, 5], 2)) # Output: 2 print(find_kth_smallest_unsorted([7, 10, 4, 3, 20, 15], 3)) # Output: 7 print(find_kth_smallest_unsorted([100, 90, 80, 70], 4)) # Output: 100 ```","solution":"def partition(arr, left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to the end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all elements smaller than pivot_value to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(arr, left, right, k): if left == right: # If the list contains only one element return arr[left] # Select a random pivot_index pivot_index = (left + right) // 2 pivot_index = partition(arr, left, right, pivot_index) # The pivot is in its final sorted position if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k) def find_kth_smallest_unsorted(arr, k): Find the k-th smallest element in an unsorted array. return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"# Coding Question Problem Statement You are given a binary tree where each node contains an integer value. Your task is to implement a function `findKthSmallest(root: TreeNode, k: int) -> int` that finds the k-th smallest element in the binary tree. # Input and Output Formats * **Input Format**: * `root`: A TreeNode representing the root of a binary tree. * `k`: An integer representing the k-th smallest position to find in the tree. * **Output Format**: * Return a single integer representing the k-th smallest element in the tree. # Constraints * The binary tree has at least one node and at most 10^5 nodes. * `1 ≤ k ≤ n` where `n` is the number of nodes in the tree. * The values in the nodes are unique and range from `1` to `10^9`. # Performance Requirements Your solution should have a time complexity of O(n) in the worst case. # Example Input ```python # Tree representation: # 3 # / # 1 4 # # 2 root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(4) root.left.right = TreeNode(2) k = 2 ``` Output ```python 2 ``` # Hints * Consider using an in-order traversal approach to find the k-th smallest element efficiently. Here\'s the function signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findKthSmallest(root: TreeNode, k: int) -> int: pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findKthSmallest(root: TreeNode, k: int) -> int: Find the k-th smallest element in a binary tree. def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) inorder_list = inorder_traversal(root) return inorder_list[k-1]"},{"question":"# Problem Statement You are required to implement a function that calculates the number of permutations of a given list of integers such that no element appears in its original position (known as a derangement). The function should include input validation to ensure proper functionality. # Function Signature ```python def count_derangements(nums: list) -> int: pass ``` # Input * `nums` (list) - A list of distinct integers. # Output * Returns the number of derangements (int) of the input list. # Constraints * The list can contain between 1 and 10 integers. * If the input list is empty, raise a `ValueError` with a clear message like `\\"Input list must not be empty\\"`. # Example ```python >>> count_derangements([1, 2, 3]) 2 >>> count_derangements([1, 2, 3, 4]) 9 ``` # Additional Requirements * Implement the function using recursion. * If the input list is empty or the length of the list is greater than 10, raise a `ValueError` with an appropriate error message. # Guidelines 1. Calculate the derangements correctly using the recursive definition of derangements. 2. Validate that the input list meets the constraints. 3. Test your function with various inputs to ensure it handles edge cases appropriately. # Hints * Use the formula for derangements: !n = (n-1) * (!(n-1) + !(n-2)) with base cases !0 = 1 and !1 = 0.","solution":"def count_derangements(nums: list) -> int: Returns the number of derangements of the input list. A derangement is a permutation where no element appears in its original position. if not nums: raise ValueError(\\"Input list must not be empty\\") n = len(nums) if n > 10: raise ValueError(\\"Input list is too long\\") def derangement(n): if n == 0: return 1 if n == 1: return 0 return (n - 1) * (derangement(n - 1) + derangement(n - 2)) return derangement(n)"},{"question":"# Problem Description You need to implement a system that manages a list of tasks. Each task has a unique identifier and a priority level. The system should support adding tasks, removing tasks by identifier, and retrieving the task with the highest priority. # Requirements 1. Implement a `Task` class with relevant attributes: identifier and priority. 2. Implement a `TaskManager` class that supports the following methods: - `add_task(identifier, priority)`: Adds a task with the given identifier and priority to the task list. - `remove_task(identifier)`: Removes the task with the specified identifier from the task list. - `get_highest_priority_task()`: Returns the identifier of the task with the highest priority. If there are multiple tasks with the same highest priority, return the one that was added earliest. If no tasks are present, raise a `ValueError` with a descriptive message. # Input and Output * **Input**: * For `add_task(identifier, priority)`: A string representing the task identifier and an integer representing its priority. * For `remove_task(identifier)`: A string representing the task identifier to be removed. * For `get_highest_priority_task()`: No input. * **Output**: * For `add_task`: None. * For `remove_task`: None. * For `get_highest_priority_task`: A string representing the identifier of the task with the highest priority. # Constraints * The priority is an integer where a higher number indicates a higher priority. * Task identifiers are unique strings. * The system will provide valid inputs according to the method descriptions. * The `add_task` method will not add a task with an existing identifier. * The `remove_task` method will only attempt to remove tasks that exist in the list. # Example Scenarios 1. **Example 1**: * Task Manager operations: ```python tm = TaskManager() tm.add_task(\\"task1\\", 3) tm.add_task(\\"task2\\", 5) tm.add_task(\\"task3\\", 1) assert tm.get_highest_priority_task() == \\"task2\\" tm.remove_task(\\"task2\\") assert tm.get_highest_priority_task() == \\"task1\\" ``` 2. **Example 2**: * Task Manager operations: ```python tm = TaskManager() tm.add_task(\\"taskA\\", 2) tm.add_task(\\"taskB\\", 2) tm.add_task(\\"taskC\\", 4) assert tm.get_highest_priority_task() == \\"taskC\\" tm.remove_task(\\"taskC\\") assert tm.get_highest_priority_task() == \\"taskA\\" tm.remove_task(\\"taskA\\") assert tm.get_highest_priority_task() == \\"taskB\\" ``` # Implementation Template ```python class Task: def __init__(self, identifier, priority): Initializes a task with an identifier and priority. :param identifier: String representing the unique task identifier. :param priority: Integer representing the task priority. self.identifier = identifier self.priority = priority self.timestamp = None # This will be set when the task is added. class TaskManager: def __init__(self): Initializes the TaskManager with an empty task list. self.tasks = {} self.counter = 0 def add_task(self, identifier, priority): Adds a task with the given identifier and priority to the task list. :param identifier: String representing the task identifier. :param priority: Integer representing the task priority. task = Task(identifier, priority) self.counter += 1 task.timestamp = self.counter self.tasks[identifier] = task def remove_task(self, identifier): Removes the task with the specified identifier from the task list. :param identifier: String representing the task identifier to be removed. if identifier in self.tasks: del self.tasks[identifier] def get_highest_priority_task(self): Returns the identifier of the task with the highest priority. If no tasks are present, raises ValueError with a descriptive message. if not self.tasks: raise ValueError(\\"No tasks available\\") highest_priority_task = max(self.tasks.values(), key=lambda t: (t.priority, -t.timestamp)) return highest_priority_task.identifier ``` Use the provided template and complete the methods `add_task`, `remove_task`, and `get_highest_priority_task` to fulfill the requirements specified. Implement the task management system correctly to ensure accurate task operations.","solution":"# Task class to define the structure of a task with identifier and priority class Task: def __init__(self, identifier, priority): Initializes a task with an identifier and priority. :param identifier: String representing the unique task identifier. :param priority: Integer representing the task priority. self.identifier = identifier self.priority = priority self.timestamp = None # This will be set when the task is added. # TaskManager class to manage tasks class TaskManager: def __init__(self): Initializes the TaskManager with an empty task list. self.tasks = {} self.counter = 0 def add_task(self, identifier, priority): Adds a task with the given identifier and priority to the task list. :param identifier: String representing the task identifier. :param priority: Integer representing the task priority. task = Task(identifier, priority) self.counter += 1 task.timestamp = self.counter self.tasks[identifier] = task def remove_task(self, identifier): Removes the task with the specified identifier from the task list. :param identifier: String representing the task identifier to be removed. if identifier in self.tasks: del self.tasks[identifier] def get_highest_priority_task(self): Returns the identifier of the task with the highest priority. If no tasks are present, raises ValueError with a descriptive message. if not self.tasks: raise ValueError(\\"No tasks available\\") highest_priority_task = max(self.tasks.values(), key=lambda t: (t.priority, -t.timestamp)) return highest_priority_task.identifier"},{"question":"# Distance Unit Conversion Tool You are tasked with enhancing a distance unit conversion tool that helps users convert distance values between various units such as meters, kilometers, miles, and yards. The current implementation supports accurate conversion using predefined factors stored in a dictionary. **Objectives**: 1. **Enhance the Tool**: - Extend the conversion tool to include additional distance units (e.g., \\"feet\\", \\"inches\\"). - Support for converting multiple distances from one unit to another in bulk. 2. **Function Definitions**: - **`distance_conversion_single(value: float, from_type: str, to_type: str) -> float`**: Perform a single unit conversion. - **`distance_conversion_bulk(values: list[float], from_type: str, to_type: str) -> list[float]`**: Convert a list of values from one unit to another. **Input/Output Specifications**: - **`distance_conversion_single`**: - **Input**: - `value` (float): The numerical distance value to be converted. - `from_type` (str): The unit of the given value (e.g., \\"meters\\"). - `to_type` (str): The unit to which the value should be converted (e.g., \\"kilometers\\"). - **Output**: - (float): The converted distance value in the `to_type` unit. - **Exceptions**: - Raise `ValueError` if any provided unit type is unsupported. - **`distance_conversion_bulk`**: - **Input**: - `values` (list[float]): A list of distance values to be converted. - `from_type` (str): The unit of the given values (e.g., \\"meters\\"). - `to_type` (str): The unit to which the values should be converted (e.g., \\"miles\\"). - **Output**: - (list[float]): A list containing the converted distance values in the `to_type` unit. - **Exceptions**: - Raise `ValueError` if any provided unit type is unsupported. **Example**: Given the following inputs: - For `distance_conversion_single`: ```python distance_conversion_single(1000, \\"meters\\", \\"kilometers\\") ``` Output: ```python 1.0 ``` - For `distance_conversion_bulk`: ```python distance_conversion_bulk([1000, 2000, 3000], \\"meters\\", \\"miles\\") ``` Output: ```python [0.621371, 1.242742, 1.864113] ``` **Constraints**: - You can add new distance units to the global `DISTANCE_CONVERSION` dictionary. - Handle invalid units with appropriate exception handling. - Preserve and enhance the provided docstrings and test cases. Implement the additional distance units and the new bulk conversion function in Python.","solution":"DISTANCE_CONVERSION = { \\"meters\\": 1.0, \\"kilometers\\": 1000.0, \\"miles\\": 1609.34, \\"yards\\": 0.9144, \\"feet\\": 0.3048, \\"inches\\": 0.0254, } def distance_conversion_single(value: float, from_type: str, to_type: str) -> float: Converts a single distance value from one unit to another. if from_type not in DISTANCE_CONVERSION or to_type not in DISTANCE_CONVERSION: raise ValueError(f\\"Unsupported unit type: {from_type} or {to_type}\\") from_factor = DISTANCE_CONVERSION[from_type] to_factor = DISTANCE_CONVERSION[to_type] return (value * from_factor) / to_factor def distance_conversion_bulk(values: list[float], from_type: str, to_type: str) -> list[float]: Converts a list of distance values from one unit to another. return [distance_conversion_single(value, from_type, to_type) for value in values]"},{"question":"# Coding Assessment Question **Scenario**: You are working on an e-commerce platform where your task is to generate discount codes for promotional campaigns. Each discount code should be unique, and users should only redeem them once. The discount code should be composed of uppercase letters and digits. **Task**: Implement a class `DiscountCodeGenerator` that generates and validates discount codes. Your class should have methods to generate a new code, validate if a code is unique, and mark a code as redeemed. **Class Signature**: ```python class DiscountCodeGenerator: def __init__(self): Initializes a new DiscountCodeGenerator instance. self.generated_codes = set() self.redeemed_codes = set() def generate_code(self, length: int) -> str: Generates a unique discount code with the specified length. Args: length (int): Length of the discount code to be generated. Returns: str: The generated unique discount code. def validate_code(self, code: str) -> bool: Validates if the given code is unique and has not been redeemed. Args: code (str): The discount code to validate. Returns: bool: True if the code is unique and not redeemed, otherwise False. def redeem_code(self, code: str) -> bool: Marks the given discount code as redeemed if it is valid. Args: code (str): The discount code to mark as redeemed. Returns: bool: True if the code was successfully redeemed, otherwise False. ``` **Example**: ```python generator = DiscountCodeGenerator() new_code = generator.generate_code(8) print(f\\"Generated Code: {new_code}\\") is_valid = generator.validate_code(new_code) print(f\\"Is the code valid? {is_valid}\\") was_redeemed = generator.redeem_code(new_code) print(f\\"Was the code redeemed? {was_redeemed}\\") # Trying to redeem the same code again was_redeemed_again = generator.redeem_code(new_code) print(f\\"Was the code redeemed again? {was_redeemed_again}\\") # Generating a new code and checking validity another_code = generator.generate_code(8) print(f\\"Generated Another Code: {another_code}\\") is_valid = generator.validate_code(another_code) print(f\\"Is the another code valid? {is_valid}\\") ``` **Constraints**: 1. The `generate_code` method must ensure that each code is unique. 2. The generated code should contain only uppercase letters (A-Z) and digits (0-9). 3. The length of the code should be at least 6 characters. 4. The `redeem_code` method should mark a valid code as redeemed and prevent it from being used again. 5. The system should be able to create and handle around 100,000 codes efficiently. **Additional Notes**: - You may use Python standard libraries `random` and `string` to handle code generation. - Ensure your class methods are efficient and consider edge cases where a generated code might collide with an existing one. - Properly comment and structure your code for readability and maintainability.","solution":"import random import string class DiscountCodeGenerator: def __init__(self): Initializes a new DiscountCodeGenerator instance. self.generated_codes = set() self.redeemed_codes = set() def generate_code(self, length: int) -> str: Generates a unique discount code with the specified length. Args: length (int): Length of the discount code to be generated. Returns: str: The generated unique discount code. if length < 6: raise ValueError(\\"Code length must be at least 6 characters long.\\") characters = string.ascii_uppercase + string.digits while True: code = \'\'.join(random.choices(characters, k=length)) if code not in self.generated_codes: self.generated_codes.add(code) return code def validate_code(self, code: str) -> bool: Validates if the given code is unique and has not been redeemed. Args: code (str): The discount code to validate. Returns: bool: True if the code is unique and not redeemed, otherwise False. return code in self.generated_codes and code not in self.redeemed_codes def redeem_code(self, code: str) -> bool: Marks the given discount code as redeemed if it is valid. Args: code (str): The discount code to mark as redeemed. Returns: bool: True if the code was successfully redeemed, otherwise False. if self.validate_code(code): self.redeemed_codes.add(code) return True return False"},{"question":"# Context As a data analyst, you frequently work with large datasets that contain multiple records of user activities. Each record includes a user ID and a timestamp. To understand user behavior better, you need an efficient approach to determine the most active users within a specific time frame. # Task Implement a function that takes a list of user activity records and returns the user ID with the highest number of activities within a given time frame. If multiple users have the same highest number of activities, return a list of those user IDs sorted in ascending order. # Function Signature ```python def most_active_users(activity_records: list, start_time: str, end_time: str) -> list: ``` # Input - `activity_records` (list of tuples): Each tuple contains a user ID (integer) and a timestamp (string in the format \'YYYY-MM-DD HH:MM:SS\'). - `start_time` (string): The start of the time frame in \'YYYY-MM-DD HH:MM:SS\' format. - `end_time` (string): The end of the time frame in \'YYYY-MM-DD HH:MM:SS\' format. # Output - Returns a list of user ID(s) with the highest number of activities within the specified time frame. If there is a tie, return a sorted list of user IDs. # Examples ```python assert most_active_users([(1, \'2023-10-01 08:00:00\'), (2, \'2023-10-01 09:00:00\'), (1, \'2023-10-01 10:00:00\')], \'2023-10-01 07:00:00\', \'2023-10-01 11:00:00\') == [1] assert most_active_users([(1, \'2023-10-01 08:00:00\'), (2, \'2023-10-01 09:00:00\'), (1, \'2023-10-01 10:00:00\'), (2, \'2023-10-01 10:30:00\')], \'2023-10-01 07:00:00\', \'2023-10-01 11:00:00\') == [1, 2] assert most_active_users([], \'2023-10-01 07:00:00\', \'2023-10-01 11:00:00\') == [] ``` # Constraints 1. The list of activity records can contain up to 10^6 entries. 2. Timestamps in `activity_records`, `start_time`, and `end_time` will follow the \'YYYY-MM-DD HH:MM:SS\' format. 3. The function should handle empty activity records list gracefully and return an empty list. # Edge Cases 1. The function should correctly handle cases where no activities fall within the time frame. 2. The implementation should ensure efficient computation even with the upper limit of input size.","solution":"from collections import defaultdict from datetime import datetime def most_active_users(activity_records: list, start_time: str, end_time: str) -> list: start_time = datetime.strptime(start_time, \'%Y-%m-%d %H:%M:%S\') end_time = datetime.strptime(end_time, \'%Y-%m-%d %H:%M:%S\') user_activity_count = defaultdict(int) for user_id, timestamp in activity_records: activity_time = datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') if start_time <= activity_time <= end_time: user_activity_count[user_id] += 1 if not user_activity_count: return [] max_activity = max(user_activity_count.values()) most_active_users = [user_id for user_id, count in user_activity_count.items() if count == max_activity] return sorted(most_active_users)"},{"question":"Flight Itinerary Reconstruction You are given a list of airline tickets represented as `from` and `to` pairs. Each ticket represents a direct flight from one airport to another. Write a function `reconstruct_itinerary` to return the itinerary in order. If there are multiple valid itineraries, return the itinerary that is lexicographically smallest. All tickets form at least one valid itinerary. Function Signature ```python def reconstruct_itinerary(tickets: List[Tuple[str, str]]) -> List[str]: ``` Input * **tickets**: A list of tuples where each tuple `(from, to)` represents a flight from airport `from` to airport `to`. Output * **itinerary**: A list of strings representing the lexicographically smallest itinerary starting from the \\"JFK\\" airport. Constraints * The number of tickets `|tickets|` will not exceed 300. * Airports are represented by three capital letters. Example ```python tickets = [(\\"MUC\\", \\"LHR\\"), (\\"JFK\\", \\"MUC\\"), (\\"SFO\\", \\"SJC\\"), (\\"LHR\\", \\"SFO\\")] print(reconstruct_itinerary(tickets)) # Output: [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] tickets = [(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")] print(reconstruct_itinerary(tickets)) # Output: [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"] ``` Approach 1. **Graph Construction**: Construct a graph where each airport points to a list of destinations in lexicographical order. 2. **Eulerian Path**: Use a Depth-First Search (DFS) approach to perform Hierhozer\'s algorithm to find the Eulerian path which satisfies the requirement for valid itinerary reconstruction. 3. **Handling Multiple Paths**: Maintain a priority queue or utilize a sorted data structure to ensure the lexicographically smallest path is chosen at each step of the exploration. * **Edge Cases**: Consider scenarios where an airport has multiple departure options and ensure the lexicographical order is respected in such cases. Implement the `reconstruct_itinerary` function that processes the given tickets and returns the smallest lexicographical itinerary starting from \\"JFK\\".","solution":"def reconstruct_itinerary(tickets): Reconstructs the itinerary from given list of tickets to form the lexicographically smallest itinerary. from collections import defaultdict, deque # Build the graph flights = defaultdict(list) for start, end in sorted(tickets): flights[start].append(end) # Store the final path itinerary = [] def visit(airport): while flights[airport]: next_flight = flights[airport].pop(0) visit(next_flight) itinerary.append(airport) visit(\'JFK\') return itinerary[::-1]"},{"question":"Coding Question: Burrows-Wheeler Transform and Inverse # Objective Implement the Burrows-Wheeler Transform (BWT) and its inverse. Your task is to write two functions `burrows_wheeler_transform` and `inverse_burrows_wheeler_transform` that perform the BWT and its inverse on strings. # Function Signatures ```python def burrows_wheeler_transform(s: str) -> str: pass def inverse_burrows_wheeler_transform(bwt: str) -> str: pass ``` # Input and Output burrows_wheeler_transform * **Input**: - `s: str`: The input string to be transformed. * **Output**: - `str`: The Burrows-Wheeler transformed string. inverse_burrows_wheeler_transform * **Input**: - `bwt: str`: The Burrows-Wheeler transformed string. * **Output**: - `str`: The original string before transformation. # Constraints - The input string for both functions will consist of printable ASCII characters. - The length of the input string will be between 1 and 1000 characters inclusive. # Example ```python # Example BWT print(burrows_wheeler_transform(\\"banana\\")) # \\"annbaa\\" # Example inverse BWT print(inverse_burrows_wheeler_transform(\\"annbaa\\")) # \\"banana\\" ``` # Explanation The `burrows_wheeler_transform` function should compute the BWT of the input string, which involves generating all cyclic rotations of the string, sorting these rotations lexicographically, and extracting the last column of the sorted rotations. The `inverse_burrows_wheeler_transform` function should reverse the BWT to recover the original string. This involves reconstructing the original string from its last column using the ranks of characters and their positions. Implement these functions considering edge cases, such as handling input strings with repeated characters.","solution":"def burrows_wheeler_transform(s: str) -> str: s = s + \\"\\" table = sorted(s[i:] + s[:i] for i in range(len(s))) return \\"\\".join(row[-1] for row in table) def inverse_burrows_wheeler_transform(bwt: str) -> str: n = len(bwt) table = [\\"\\"] * n for _ in range(n): table = sorted(bwt[i] + table[i] for i in range(n)) for row in table: if row.endswith(\\"\\"): return row.rstrip(\\"\\")"},{"question":"# Question: Unique Pathways in a Forest Grid Background You are exploring a dense forest that can be represented as an ( n times m ) grid. Each cell in the grid contains either a tree (represented by 1) or a clear pathway (represented by 0). You are standing at the top-left corner of the grid (0,0) and need to find a way to reach the bottom-right corner (n-1, m-1). You can only move either down or right at any point in time. Given an integer `n` and an integer `m`, representing the dimensions of the grid, and a list of lists `forest` where each element is either 0 (clear pathway) or 1 (tree), your task is to determine the number of unique paths from the top-left corner to the bottom-right corner that do not pass through any trees. Task Write a function `unique_paths(forest: List[List[int]]) -> int` that returns the number of unique paths from the top-left corner to the bottom-right corner of the grid. There is no path if you start or end on a tree. Input - A list of lists `forest` of integers where each sublist represents one row of the grid, and each element in the sublist is either 0 (clear pathway) or 1 (tree) Output - Returns an integer representing the number of unique paths from the top-left corner to the bottom-right corner Example ```python from typing import List def unique_paths(forest: List[List[int]]) -> int: n = len(forest) m = len(forest[0]) if forest[0][0] == 1 or forest[n-1][m-1] == 1: return 0 # Initialize a 2D dp array with 0\'s dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if forest[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Example usage: forest = [ [0, 0, 1], [0, 0, 0], [1, 0, 0] ] print(unique_paths(forest)) # Expected output: 2 ``` Constraints 1. `1 ≤ n, m ≤ 100` 2. The list `forest` will consist of exactly `n` sublists, each containing exactly `m` integers (0s or 1s). Hints - Use dynamic programming to keep track of the number of ways to reach each cell. - Ensure to handle the cases where the starting or ending points are trees (1s).","solution":"from typing import List def unique_paths(forest: List[List[int]]) -> int: n = len(forest) m = len(forest[0]) if forest[0][0] == 1 or forest[n-1][m-1] == 1: return 0 # Initialize a 2D dp array with 0\'s dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if forest[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Example usage: forest = [ [0, 0, 1], [0, 0, 0], [1, 0, 0] ] print(unique_paths(forest)) # Expected output: 2"},{"question":"# Coding Question Scenario In a database of customer transactions, data scientists often need to calculate cumulative spending to analyze customer behavior over time. Given a series of daily spending amounts, you are tasked with computing the cumulative sum of the spending to get an insight into how spending evolves. Task Implement the function `cumulative_spending` to compute the cumulative sum for a list of numerical data points representing daily customer spending. # Function Signature ```python def cumulative_spending(data: list[float]) -> list[float]: ``` # Input * `data`: A list of floats representing daily customer spending amounts. # Output * A list of floats where each float is the cumulative sum of spending up to that day. # Constraints * The length of `data` will be between 1 and 10^5. * Each element in `data` will be a non-negative float. # Requirements 1. If the `data` list is empty, the function should return an empty list. 2. Handle edge cases of single-day spending gracefully. # Example ```python # Input data = [100.5, 200.0, 50.0, 300.0, 150.0] # Output [100.5, 300.5, 350.5, 650.5, 800.5] ``` **Notes:** Use the `round` function to round the cumulative sum values up to two decimal places, ensuring precision throughout the calculations. **Edge cases to consider:** - When there is only one element in the data list. - Handling empty lists. - Catching and processing floating-point arithmetic to maintain accuracy. **Test Cases to consider:** - Input data with various lengths. - Input data with floating points and zero values. - Ensure the function handles large inputs within the constraints efficiently.","solution":"def cumulative_spending(data: list[float]) -> list[float]: Returns the cumulative sum of daily customer spending. Parameters: data (list of float): A list of non-negative floats representing daily spending amounts. Returns: list of float: A list where each float is the cumulative sum up to that day. if not data: return [] cumulative_sum = [] current_sum = 0.0 for amount in data: current_sum += amount cumulative_sum.append(round(current_sum, 2)) # keep precision up to two decimal places return cumulative_sum"},{"question":"# Coding Question **Data Stream Moving Average** You are given a class `MovingAverage` that maintains a moving average of values in a data stream. Your task is to enhance this class to support an additional method for retrieving the current moving average on demand. Objectives: 1. **Moving Average Calculation**: - Maintain a class that calculates the moving average of a fixed number of most recently added integer values. 2. **Retrievable Moving Average**: - Allow the current moving average to be retrievable at any point without additional value insertions. You need to implement the enhanced class `MovingAverage` that meets the above objectives. Class Definition: ```python class MovingAverage: def __init__(self, size: int): ```Initialize your data structure here.``` def next(self, val: int) -> float: ```Insert next value into the stream and return moving average``` def get_current_average(self) -> float: ```Return the current moving average of the values in the data stream``` ``` Constraints: - The size of the moving average window is fixed at the class initialization. - The input values for `next()` are integers. - The moving average should be calculated using only the most recent values within the specified window size. Examples: ```python # Example 1 mov_avg = MovingAverage(3) print(mov_avg.next(1)) # Returns 1.0 (since 1 / 1 = 1.0) print(mov_avg.next(10)) # Returns 5.5 (since (1 + 10) / 2 = 5.5) print(mov_avg.next(3)) # Returns 4.67 (since (1 + 10 + 3) / 3 = 4.67) print(mov_avg.get_current_average()) # Returns 4.67 (current moving average) print(mov_avg.next(5)) # Returns 6.0 (since (10 + 3 + 5) / 3 = 6.0) print(mov_avg.get_current_average()) # Returns 6.0 (current moving average) # Example 2 mov_avg = MovingAverage(2) print(mov_avg.next(1)) # Returns 1.0 (since 1 / 1 = 1.0) print(mov_avg.next(10)) # Returns 5.5 (since (1 + 10) / 2 = 5.5) print(mov_avg.get_current_average()) # Returns 5.5 (current moving average) print(mov_avg.next(3)) # Returns 6.5 (since (10 + 3) / 2 = 6.5) print(mov_avg.get_current_average()) # Returns 6.5 (current moving average) ``` Implementation Notes: - Use a queue data structure from `collections.deque` to ensure efficient append and pop operations. - Use a running sum to keep track of the sum of the elements in the current window to avoid recalculating the sum for each `next()` call. - Handle situations where the number of added elements is less than the window size.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize your data structure here. self.size = size self.window = deque() self.sum = 0 def next(self, val: int) -> float: Insert next value into the stream and return moving average. self.window.append(val) self.sum += val if len(self.window) > self.size: self.sum -= self.window.popleft() return self.sum / len(self.window) def get_current_average(self) -> float: Return the current moving average of the values in the data stream. if not self.window: return 0.0 return self.sum / len(self.window)"},{"question":"# Scenario: You are developing a feature for an application that generates automated reports based on transaction data from a user\'s financial activities. One critical task is to identify and summarize the top recurring transactions within a given period. This feature will help users quickly see which transactions occur most frequently, enabling better financial planning. # Problem Description: Implement a function `find_top_recurring_transactions` that takes a list of transaction records and returns a summary of the top N recurring transactions during the specified period. Each transaction record contains the transaction date, description, and amount. Your function needs to: 1. Parse and filter transactions based on the given period. 2. Identify unique transactions based on their description (case-insensitive). 3. Count the occurrences for each unique transaction and sort them by frequency. 4. Return the top N recurring transactions. # Function Signature: `def find_top_recurring_transactions(transactions: List[Dict[str, Any]], start_date: str, end_date: str, top_n: int) -> List[Tuple[str, int, float]]:` # Input: - `transactions`: A list of dictionaries where each dictionary contains the transaction details - date (str), description (str), amount (float). - `start_date`: A string representing the start date of the period (inclusive) in the format \\"YYYY-MM-DD\\". - `end_date`: A string representing the end date of the period (inclusive) in the format \\"YYYY-MM-DD\\". - `top_n`: An integer representing the number of top recurring transactions to return. # Output: - Returns a list of tuples representing the top N recurring transactions. Each tuple should contain: - Transaction description (str) - Frequency of the transaction (int) - Total amount spent on this transaction (float) # Constraints: - The transactions list can contain a large number of records, so optimize your code for efficiency. - Ignore case when comparing transaction descriptions. - The date in each transaction will always be in the \\"YYYY-MM-DD\\" format. # Example: ```python transactions = [ {\'date\': \'2023-01-01\', \'description\': \'Grocery Store\', \'amount\': 50.75}, {\'date\': \'2023-01-02\', \'description\': \'Coffee Shop\', \'amount\': 3.50}, {\'date\': \'2023-01-03\', \'description\': \'grocery store\', \'amount\': 20.45}, {\'date\': \'2023-01-04\', \'description\': \'Movie Theater\', \'amount\': 15.00}, {\'date\': \'2023-01-01\', \'description\': \'Grocery Store\', \'amount\': 60.00}, ] print(find_top_recurring_transactions(transactions, \'2023-01-01\', \'2023-01-31\', 2)) # Expected Output: [(\'Grocery Store\', 3, 131.20), (\'Coffee Shop\', 1, 3.50)] ``` # Notes: - Ensure the correct parsing and comparison of dates. - Efficient sorting and counting mechanisms are essential due to potential dataset size. - Helper functions might be useful for breaking down tasks such as date filtering and transaction summarization. Good luck!","solution":"from typing import List, Dict, Any, Tuple from collections import defaultdict, Counter from datetime import datetime def find_top_recurring_transactions(transactions: List[Dict[str, Any]], start_date: str, end_date: str, top_n: int) -> List[Tuple[str, int, float]]: format = \\"%Y-%m-%d\\" start = datetime.strptime(start_date, format) end = datetime.strptime(end_date, format) filtered_transactions = [ txn for txn in transactions if start <= datetime.strptime(txn[\'date\'], format) <= end ] counter = defaultdict(lambda: {\'frequency\': 0, \'total_amount\': 0.0}) for txn in filtered_transactions: description = txn[\'description\'].strip().lower() counter[description][\'frequency\'] += 1 counter[description][\'total_amount\'] += txn[\'amount\'] sorted_transactions = sorted(counter.items(), key=lambda item: item[1][\'frequency\'], reverse=True) result = [ (description.capitalize(), data[\'frequency\'], data[\'total_amount\']) for description, data in sorted_transactions[:top_n] ] return result"},{"question":"# Missing Number in a Sorted Array You are provided with a description of a problem involving a sorted array containing consecutive integers. Your task is to implement a function that finds the missing number in this sorted array. Scenario Assume you have a sorted array of distinct integers, where the integers form a consecutive sequence except for one missing number. Your job is to identify the missing number. Requirements 1. Implement a function `find_missing_number(nums: List[int]) -> int` that finds the missing number in the sorted array. 2. The function should have a time complexity of O(log n). Input * A sorted list of distinct integers, `nums`, where integers form a consecutive sequence except for one missing number. * The length of the list will be at least 2 and at most 10^6. Output * The integer value of the missing number. Example ```python def find_missing_number(nums: List[int]) -> int: # Implementation here pass print(find_missing_number([1, 2, 3, 5, 6])) # Output: 4 print(find_missing_number([10, 11, 12, 13, 14, 15, 16, 18])) # Output: 17 ``` Make sure your implementation is efficient and able to handle large input sizes up to the provided limits.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in a sorted list of consecutive integers. :param nums: List[int] - a sorted list of consecutive integers with one missing number. :return: int - the missing number in the list. left = 0 right = len(nums) - 1 while left <= right: mid = left + (right - left) // 2 # If the middle element is at its correct position if nums[mid] == nums[0] + mid: left = mid + 1 else: right = mid - 1 # The left index points to the first spot where the consecutive sequence is broken return nums[0] + left"},{"question":"# Question: Implement a Custom Least Squares Polynomial Fit Context In data analysis and curve fitting, the least squares method is a standard approach to approximate the solution of overdetermined systems. Here, you are required to write a function that performs a least squares polynomial fit of a given degree to a set of data points. Objective Write a Python function `least_squares_poly_fit` that takes in three parameters: a list of `x` values, a list of corresponding `y` values, and the degree of the polynomial to fit. The function should return a list of coefficients representing the best-fit polynomial. Input Format 1. `x_values`: A list of float values representing the x-coordinates of the data points. 2. `y_values`: A list of float values representing the y-coordinates of the data points. 3. `degree`: An integer representing the degree of the polynomial to fit. Output Format * Return a list of float values representing the coefficients of the best-fit polynomial, starting from the coefficient of the highest degree term. Constraints * The length of `x_values` and `y_values` must be equal and more than `degree + 1`, otherwise raise a `ValueError`. * `degree` is a non-negative integer. Performance Requirements * Implement the algorithm efficiently to handle larger sets of data points. * Ensure numerical stability and handle potential edge cases. Example ```python # Data points x_values = [1.0, 2.0, 3.0, 4.0, 5.0] y_values = [2.3, 2.1, 0.9, 5.0, 6.9] # Fit a polynomial of degree 2 to the data points coefficients = least_squares_poly_fit(x_values, y_values, 2) print(f\\"Polynomial coefficients: {coefficients}\\") ``` Explanation: In this example, the function fits a polynomial of degree 2 to the provided data points and returns the coefficients of the resulting polynomial. ```python import numpy as np def least_squares_poly_fit(x_values, y_values, degree): if len(x_values) != len(y_values): raise ValueError(\\"x_values and y_values must have the same length\\") if len(x_values) <= degree: raise ValueError(\\"Not enough data points to fit the requested degree of polynomial\\") X = np.vander(x_values, degree + 1) y = np.array(y_values) coeffs, _, _, _ = np.linalg.lstsq(X, y, rcond=None) return coeffs.tolist() ```","solution":"import numpy as np def least_squares_poly_fit(x_values, y_values, degree): Find the least squares polynomial fit of a given degree for the provided data points. :param x_values: List of x-coordinates of the data points. :param y_values: List of y-coordinates of the data points. :param degree: Degree of the polynomial to fit. :return: List of coefficients of the best-fit polynomial, from the highest degree to the lowest. if len(x_values) != len(y_values): raise ValueError(\\"x_values and y_values must have the same length\\") if len(x_values) <= degree: raise ValueError(\\"Not enough data points to fit the requested degree of polynomial\\") X = np.vander(x_values, degree + 1) y = np.array(y_values) coeffs, _, _, _ = np.linalg.lstsq(X, y, rcond=None) return coeffs.tolist()"},{"question":"# Context A delivery company needs to optimize its route planning software to minimize the travel distance for its drivers. They have a list of delivery locations and need to determine the optimal sequence of deliveries to minimize the total travel distance, starting and ending at the main distribution center. # Task Write a function `optimal_delivery_route(locations: List[Tuple[int, int]], main_distribution_center: Tuple[int, int]) -> List[Tuple[int, int]]` that finds the optimal route to visit all given locations exactly once starting and ending at the main distribution center. Use a greedy algorithm for simplicity. # Input - `locations` (List[Tuple[int, int]]): a list of tuples, where each tuple represents the coordinates (x, y) of a delivery location. - `main_distribution_center` (Tuple[int, int]): a tuple representing the coordinates (x, y) of the main distribution center. # Output - (List[Tuple[int, int]]): a list of tuples representing the sequence of locations starting and ending at the main distribution center that results in the minimum travel distance, determined by a greedy algorithm. # Constraints - The number of locations will be at least 1 and at most 20. - Coordinates are integers that can be positive or negative. - It is guaranteed that no two locations share the same coordinates. # Example ```python >>> optimal_delivery_route([(1, 1), (2, 2), (3, 3)], (0, 0)) [(0, 0), (1, 1), (2, 2), (3, 3), (0, 0)] >>> optimal_delivery_route([(5, 5), (2, 1), (4, 3)], (0, 0)) [(0, 0), (2, 1), (4, 3), (5, 5), (0, 0)] >>> optimal_delivery_route([(10, 10), (20, 20), (30, 30), (40, 40)], (0, 0)) [(0, 0), (10, 10), (20, 20), (30, 30), (40, 40), (0, 0)] ``` # Function Signature ```python from typing import List, Tuple def optimal_delivery_route(locations: List[Tuple[int, int]], main_distribution_center: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` # Additional Notes - Use the Euclidean distance to calculate the distance between locations. - Implement a greedy algorithm that always chooses the nearest unvisited location from the current location. - The output list should start and end at the `main_distribution_center`. - If there\'s only one location, the route should simply connect the main distribution center to that location and back.","solution":"from typing import List, Tuple import math def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def optimal_delivery_route(locations: List[Tuple[int, int]], main_distribution_center: Tuple[int, int]) -> List[Tuple[int, int]]: Finds the optimal route to visit all given locations exactly once starting and ending at the main distribution center using a greedy algorithm. unvisited = locations[:] current_location = main_distribution_center route = [current_location] while unvisited: # Find the nearest unvisited location nearest_location = min(unvisited, key=lambda loc: euclidean_distance(current_location, loc)) # Move to the nearest location current_location = nearest_location route.append(current_location) unvisited.remove(nearest_location) # Return to the main distribution center route.append(main_distribution_center) return route"},{"question":"# Coding Assessment Question Context In your role as a software developer, you are working on a tool for managing projects. One of the functionalities required in this tool is to compute the optimal way to assign tasks such that the team members can complete their work in the least amount of time. Each task has a specific time to complete, and every team member can take one task from the list. Your task is to ensure that the maximum time taken by any team member to complete a task is minimized. Objective Write a function `minimize_max_task_time(tasks: list[int], team_size: int) -> int` that finds the minimum possible maximum task time for the given number of team members. Input and Output - **Input**: - `tasks` is a list of integers where each integer represents the time required to complete a task. - `team_size` is an integer representing the number of team members. - **Output**: An integer representing the minimized maximum task time. Constraints - The length of `tasks` will be between 1 and 10,000 inclusive. - Each task time in `tasks` will be a positive integer and can be as large as 10,000. - `team_size` will be between 1 and 1,000 inclusive. - The number of team members will always be less than or equal to the number of tasks. Performance Requirements - The solution should aim for a time complexity of O(n log T), where n is the number of tasks and T is the sum of all task times, due to binary search. Example ```python def minimize_max_task_time(tasks: list[int], team_size: int) -> int: Minimize the maximum task time assigned to any team member. Args: - tasks (list[int]): List of task times. - team_size (int): Number of team members. Returns: - int: Minimized maximum task time. pass # Your implementation goes here # Example Usage tasks = [10, 20, 30, 40, 50] team_size = 2 print(minimize_max_task_time(tasks, team_size)) # Output: 90 tasks = [7, 5, 8, 10, 20] team_size = 4 print(minimize_max_task_time(tasks, team_size)) # Output: 20 ``` Notes - Ensure the implementation efficiently handles edge cases such as: - Minimum and maximum number of tasks. - Disproportionate large task times with small numbers of tasks. - Consider using binary search to optimize the distribution of task times.","solution":"def minimize_max_task_time(tasks: list[int], team_size: int) -> int: Minimize the maximum task time assigned to any team member. Args: - tasks (list[int]): List of task times. - team_size (int): Number of team members. Returns: - int: Minimized maximum task time. def can_distribute(mid): current_sum = 0 num_teams = 1 for task in tasks: if current_sum + task > mid: num_teams += 1 current_sum = task if num_teams > team_size: return False else: current_sum += task return True left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_distribute(mid): right = mid else: left = mid + 1 return left"},{"question":"# String Manipulation with Repeated Pattern Removal Objective: Implement a function that removes all occurrences of a given substring pattern from an input string and returns the modified string. Description: Given a string and a pattern, you need to remove all instances of the pattern from the string. The removal should continue iteratively until no further occurrences of the pattern are found. Function Definition: ```python def remove_pattern(input_string: str, pattern: str) -> str: Remove all instances of a given pattern from the input string. Args: input_string (str): The original string from which patterns need to be removed. pattern (str): The substring pattern to be removed. Returns: str: The string after removing all instances of the pattern. ``` Constraints: 1. The `input_string` can vary in length from 0 to 10^5 characters. 2. The `pattern` is a non-empty string with a length that varies from 1 to 100 characters. 3. The pattern will not change during the function execution. Input: - `input_string`: A string containing the original characters. - `pattern`: A string representing the pattern to be removed. Output: - A string after removing all instances of the pattern. Example: ```python input_string = \\"abababc\\" pattern = \\"ab\\" result = remove_pattern(input_string, pattern) print(result) # Expected output: \\"c\\" input_string = \\"hellohellshell\\" pattern = \\"hell\\" result = remove_pattern(input_string, pattern) print(result) # Expected output: \\"os\\" input_string = \\"aaaaaa\\" pattern = \\"a\\" result = remove_pattern(input_string, pattern) print(result) # Expected output: \\"\\" ``` Edge Cases to Consider: 1. The input string is empty. 2. The input string does not contain the pattern. 3. The pattern is repeated consecutively within the input string. 4. The pattern overlaps itself within the input string.","solution":"def remove_pattern(input_string: str, pattern: str) -> str: Remove all instances of a given pattern from the input string. Args: input_string (str): The original string from which patterns need to be removed. pattern (str): The substring pattern to be removed. Returns: str: The string after removing all instances of the pattern. while pattern in input_string: input_string = input_string.replace(pattern, \\"\\") return input_string"},{"question":"# Array Rotation Background Array rotation is a fundamental operation used in various applications, such as data structures, algorithms, and signal processing. Rotating an array involves shifting the elements of the array to the left or right by a specified number of positions. Your task is to write a function that rotates an array either to the left or to the right by a given number of positions. Task Write a Python function `rotate_array(arr: list, positions: int, direction: str) -> list` that rotates an array by the specified number of positions in the given direction. The function must follow these rules: 1. The `direction` parameter must be either \\"left\\" or \\"right\\". 2. Handle cases where the number of positions exceeds the array length by using modulo operations. 3. The function should return a new list representing the rotated array. Input * Three parameters: * `arr` (list): The input array of integers. * `positions` (int): The number of positions to rotate the array. * `direction` (str): The direction to rotate the array (\\"left\\" or \\"right\\"). Output * A new list representing the array rotated by the specified positions in the given direction. Examples ```python >>> rotate_array([1, 2, 3, 4, 5], 2, \'left\') [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 3, \'right\') [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 5, \'left\') [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 1, \'right\') [5, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5], 0, \'left\') [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7, \'right\') [4, 5, 1, 2, 3] ``` # Constraints * The input array (`arr`) will contain between 1 to 1000 elements. * Each element in the array (`arr`) will be an integer between -1000 and 1000 inclusive. * The `positions` parameter will be a non-negative integer. * The `direction` parameter will be either \\"left\\" or \\"right\\". This question will help assess the candidate\'s understanding of array manipulations, modulo operations, and handling parameter constraints in a function, aligning well with the style, complexity, and scope of the provided sample questions.","solution":"def rotate_array(arr, positions, direction): Rotates the array by the specified number of positions in the given direction. Parameters: arr (list): The input array of integers. positions (int): The number of positions to rotate the array. direction (str): The direction to rotate the array (\\"left\\" or \\"right\\"). Returns: list: The rotated array. n = len(arr) if direction == \\"left\\": positions = positions % n return arr[positions:] + arr[:positions] elif direction == \\"right\\": positions = positions % n return arr[-positions:] + arr[:-positions] else: raise ValueError(\\"Direction must be either \'left\' or \'right\'.\\") # Example usage: # print(rotate_array([1, 2, 3, 4, 5], 2, \'left\')) # Output: [3, 4, 5, 1, 2] # print(rotate_array([1, 2, 3, 4, 5], 3, \'right\')) # Output: [3, 4, 5, 1, 2]"},{"question":"# Problem Statement You are required to implement a function that converts a string containing a number in a given base to its decimal (base 10) representation. The input string will include digits and letters representing values according to the base provided. # Constraints - The base `b` will be an integer such that 2 ≤ `b` ≤ 36. - The input string `n` will be a valid number in the given base and will be in uppercase. # Input - `n` (str): A string representing the number in base `b`. - `b` (int): The base of the input number. # Output - The function should return an integer, which is the decimal representation of the given input number. # Function Signature ```python def base_to_decimal(n: str, b: int) -> int: pass ``` # Example Your implementation should produce the following outputs: ```python print(base_to_decimal(\\"1A\\", 16)) print(base_to_decimal(\\"101\\", 2)) print(base_to_decimal(\\"Z\\", 36)) print(base_to_decimal(\\"10\\", 10)) ``` Expected Outputs: ```python 26 5 35 10 ``` # Explanation 1. The string \\"1A\\" in base 16 (hexadecimal) converts to 1*16^1 + 10*16^0 = 16 + 10 = 26 in decimal. 2. The string \\"101\\" in binary (base 2) converts to 1*2^2 + 0*2^1 + 1*2^0 = 4 + 0 + 1 = 5 in decimal. 3. The string \\"Z\\" in base 36 converts to 35 in decimal. 4. The string \\"10\\" in base 10 (decimal) is already 10.","solution":"def base_to_decimal(n: str, b: int) -> int: Converts a string containing a number in base b to its decimal (base 10) representation. Params: n : str : input string representing the number in base b b : int : base of the input number Returns: int : decimal representation of the input number return int(n, b)"},{"question":"# Coding Challenge: File System Simulation with Directory Paths **Context**: In many operating systems, files and directories are organized in a hierarchical structure. Each directory can contain files or subdirectories, and each file or directory is defined by its path. # Task Implement a class `FileSystem` to simulate a simple file system. Your class should support the following operations: 1. **Create File**: Add a file at a specific path. 2. **List Directory**: List all files and subdirectories in a given directory. 3. **Delete File**: Delete a file at a given path. 4. **Move File**: Move a file from one path to another. # Input and Output - **Create File Operation**: - Method: `create_file(path: str, filename: str) -> bool` - Input: String path and filename. - Output: `True` if file is created successfully, `False` otherwise. - **List Directory Operation**: - Method: `list_directory(path: str) -> List[str]` - Input: String path. - Output: List of filenames and subdirectory names in the given directory. - **Delete File Operation**: - Method: `delete_file(path: str, filename: str) -> bool` - Input: String path and filename. - Output: `True` if file is deleted successfully, `False` otherwise. - **Move File Operation**: - Method: `move_file(src_path: str, dest_path: str, filename: str) -> bool` - Input: Source path, destination path, and filename. - Output: `True` if file is moved successfully, `False` otherwise. # Constraints 1. A directory can have multiple files or subdirectories. 2. Ensure that paths are managed correctly and mimic the hierarchy of a typical file system. 3. Handle edge cases such as creating files in non-existent directories and deleting or moving non-existent files. # Scenario Create an instance of `FileSystem`. Perform operations such as adding, listing, deleting, and moving files to demonstrate the functionality of the file system. ```python from __future__ import annotations from typing import List, Dict class FileSystem: def __init__(self) -> None: self.root = {\\"\\": {}} def create_file(self, path: str, filename: str) -> bool: dirs = path.split(\\"/\\") current = self.root[\\"\\"] for directory in dirs: if directory: current = current.setdefault(directory, {}) if filename in current: return False # File already exists current[filename] = None return True def list_directory(self, path: str) -> List[str]: dirs = path.split(\\"/\\") current = self.root[\\"\\"] for directory in dirs: if directory: current = current.get(directory, None) if current is None: return [] return list(current.keys()) def delete_file(self, path: str, filename: str) -> bool: dirs = path.split(\\"/\\") current = self.root[\\"\\"] for directory in dirs: if directory: current = current.get(directory, None) if current is None: return False if filename in current: del current[filename] return True return False def move_file(self, src_path: str, dest_path: str, filename: str) -> bool: if not self.delete_file(src_path, filename): return False if not self.create_file(dest_path, filename): # Rollback if move operation fails self.create_file(src_path, filename) return False return True if __name__ == \\"__main__\\": fs = FileSystem() print(fs.create_file(\\"/home/user\\", \\"file1.txt\\")) # Expected Output: True print(fs.create_file(\\"/home/user\\", \\"file2.txt\\")) # Expected Output: True print(fs.list_directory(\\"/home/user\\")) # Expected Output: [\'file1.txt\', \'file2.txt\'] print(fs.delete_file(\\"/home/user\\", \\"file2.txt\\")) # Expected Output: True print(fs.list_directory(\\"/home/user\\")) # Expected Output: [\'file1.txt\'] print(fs.move_file(\\"/home/user\\", \\"/home/shared\\", \\"file1.txt\\")) # Expected Output: True print(fs.list_directory(\\"/home/user\\")) # Expected Output: [] print(fs.list_directory(\\"/home/shared\\")) # Expected Output: [\'file1.txt\'] ``` Ensure to include edge cases such as attempting to create a file in a non-existent directory and handling paths appropriately.","solution":"from __future__ import annotations from typing import List, Dict, Optional class FileSystem: def __init__(self) -> None: self.root = {\\"\\": {}} def create_file(self, path: str, filename: str) -> bool: dirs = path.split(\\"/\\") current = self.root[\\"\\"] for directory in dirs: if directory: current = current.setdefault(directory, {}) if filename in current: return False # File already exists current[filename] = None return True def list_directory(self, path: str) -> List[str]: dirs = path.split(\\"/\\") current = self.root[\\"\\"] for directory in dirs: if directory: current = current.get(directory, None) if current is None: return [] return list(current.keys()) def delete_file(self, path: str, filename: str) -> bool: dirs = path.split(\\"/\\") current = self.root[\\"\\"] for directory in dirs: if directory: current = current.get(directory, None) if current is None: return False if filename in current: del current[filename] return True return False def move_file(self, src_path: str, dest_path: str, filename: str) -> bool: if not self.delete_file(src_path, filename): return False if not self.create_file(dest_path, filename): # Rollback if move operation fails self.create_file(src_path, filename) return False return True"},{"question":"# Task: Removing Duplicates and Sorting Elements in a List Objective Write a function `process_list` that takes a list of integers, removes any duplicate values, and returns the list sorted in ascending order. Scenario You are given a list with potentially repeated integer values. To simplify further processing, you need to remove all duplicates and sort the remaining values in ascending order. Function Signature ```python def process_list(numbers: list[int]) -> list[int]: pass ``` Input 1. `numbers` - A list of integers. Output - A list of integers sorted in ascending order with duplicates removed. Constraints - The input list can have from 0 to 10^6 integers. - Each integer in the list can be between -10^6 and 10^6. Examples ```python assert process_list([4, 2, 9, 4, 7, 2, 1]) == [1, 2, 4, 7, 9] assert process_list([10, -1, 0, 10, 0]) == [-1, 0, 10] assert process_list([]) == [] ``` # Requirements 1. Ensure your solution efficiently removes duplicates and sorts the list. 2. Handle edge cases such as an empty list or a list already sorted with no duplicates. 3. Optimize the code for performance given the large potential input size. # Approach - Convert the list to a set to remove duplicates. - Convert the set back to a list. - Sort the list in ascending order before returning it.","solution":"def process_list(numbers: list[int]) -> list[int]: Takes a list of integers, removes duplicate values, and returns the list sorted in ascending order. return sorted(set(numbers))"},{"question":"# Coding Assessment Question You are tasked with writing a Python function to convert a flat dictionary representing a nested structure into an actual nested dictionary. This problem tests your understanding of dictionary manipulation, recursion, and string processing in Python. **Function Description:** Write a function `convert_flat_dict(flat_dict: Dict[str, Any]) -> Dict[str, Any]` that converts a flat dictionary with keys representing nested structures separated by periods into a properly nested dictionary. Input: * `flat_dict` (Dict[str, Any]): A flat dictionary where keys are strings representing nested dictionary paths, separated by periods. Output: * A nested dictionary constructed based on the keys in the input dictionary. Example: For the input dictionary: ```python { \\"a.b.c\\": 1, \\"a.b.d\\": 2, \\"a.e\\": 3, \\"f\\": 4 } ``` The output should be: ```python { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": 2 }, \\"e\\": 3 }, \\"f\\": 4 } ``` Constraints: * Keys in the input dictionary will be unique and non-empty. * The input dictionary will not be empty. * You may assume the maximum depth of nested structures will not exceed 5. Additional Notes: * Your solution should be general enough to handle any valid configuration of nested keys. * You must not import any additional modules beyond the standard library.","solution":"from typing import Any, Dict def convert_flat_dict(flat_dict: Dict[str, Any]) -> Dict[str, Any]: nested_dict = {} for flat_key, value in flat_dict.items(): keys = flat_key.split(\'.\') current_level = nested_dict for key in keys[:-1]: if key not in current_level: current_level[key] = {} current_level = current_level[key] current_level[keys[-1]] = value return nested_dict"},{"question":"# Problem Statement You are building an inventory management system. Your task is to implement a function that summarizes the inventory by category. Given a list of items with their categories and a list of categories, return the count of items in each category. # Function to Implement ```python def summarize_inventory(items: list[tuple[str, str]], categories: list[str]) -> dict[str, int]: Summarizes the inventory by counting the number of items per category. Parameters: items (list[tuple[str, str]]): A list of tuples where each tuple contains the item name and item category. categories (list[str]): A list of categories to include in the summary. Returns: dict[str, int]: A dictionary where keys are category names and values are the count of items in those categories. pass ``` # Example ```python items = [ (\\"item1\\", \\"category1\\"), (\\"item2\\", \\"category2\\"), (\\"item3\\", \\"category1\\"), (\\"item4\\", \\"category3\\"), (\\"item5\\", \\"category2\\"), ] categories = [\\"category1\\", \\"category2\\", \\"category3\\", \\"category4\\"] summarize_inventory(items, categories) # Output should be: # { # \\"category1\\": 2, # \\"category2\\": 2, # \\"category3\\": 1, # \\"category4\\": 0, # } ``` # Constraints 1. The categories list will always contain at least one category. 2. The items list may be empty. 3. Categories may contain any valid strings, including special characters and spaces. 4. Items\' categories are guaranteed to be among the categories in the categories list. # Assumptions 1. Categories are case-sensitive. 2. An item in the items list is a valid entry and will always have a category listed in the categories list. 3. The summarize_inventory function will be called with valid inputs. # Performance Requirements Ensure that your solution is efficient in terms of both time and space complexity for lists containing up to 1000 items and categories.","solution":"def summarize_inventory(items: list[tuple[str, str]], categories: list[str]) -> dict[str, int]: Summarizes the inventory by counting the number of items per category. Parameters: items (list[tuple[str, str]]): A list of tuples where each tuple contains the item name and item category. categories (list[str]): A list of categories to include in the summary. Returns: dict[str, int]: A dictionary where keys are category names and values are the count of items in those categories. summary = {category: 0 for category in categories} for item, category in items: if category in summary: summary[category] += 1 return summary"},{"question":"# Coding Question: Find the Largest Connected Component Background In a given 2D grid, each cell represents either land (1) or water (0). A connected component of land cells forms an island if they are connected horizontally or vertically. The objective is to find the largest connected island (in terms of number of cells). Objective Write a function `largest_island(grid: list) -> int` that calculates the size of the largest connected island in the given grid. Input * A 2D list of integers representing the grid, where each element is either a 0 (water) or a 1 (land). Output * Return an integer representing the size of the largest connected island. Constraints * The grid has at least one row and one column. * Each element of the grid is either 0 or 1. Example ```python >>> largest_island([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 1, 1, 0, 0] ]) 4 >>> largest_island([ [1, 0, 0, 1], [0, 1, 1, 0], [1, 0, 1, 1] ]) 3 ``` Notes * The use of Depth-First Search (DFS) or Breadth-First Search (BFS) is recommended to find the connected components. * Ensure to handle edge cases such as: * The grid being completely water or land. * Non-rectangular grids are logically handled through appropriate error messages. Edge Cases * If the grid or its rows are empty, the function should return 0 as there are no islands to be counted. Validation In addition to the above cases, your solution should run efficiently for a large grid (up to 1000x1000).","solution":"def largest_island(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return 0 grid[r][c] = 0 # mark as visited size = 1 size += dfs(r+1, c) size += dfs(r-1, c) size += dfs(r, c+1) size += dfs(r, c-1) return size max_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: max_size = max(max_size, dfs(r, c)) return max_size"},{"question":"# Problem Statement You are given a matrix of integers and tasked to implement a two-dimensional Fenwick Tree (Binary Indexed Tree) data structure to handle range sum queries and point updates efficiently. Specifically, you need to perform the following operations: 1. Build the Fenwick Tree with the given matrix. 2. Update a specific element in the matrix. 3. Query the sum of elements in a specific submatrix defined by two corners. # Function Specifications Complete the following functions: 1. `__init__(self, matrix: List[List[int]]) -> None` - **Input**: * `matrix`: 2D list of integers representing the initial matrix. - **Output**: * None. - **Description**: - Initializes the Fenwick Tree with the provided matrix. 2. `update(self, row: int, col: int, val: int) -> None` - **Input**: * `row`: Integer, row index of the element to update (0-based index). * `col`: Integer, column index of the element to update (0-based index). * `val`: Integer, the new value to set at the specified position. - **Output**: * None. - **Description**: - Updates the value at the position `(row, col)` in the matrix and the corresponding Fenwick Tree. 3. `query(self, row1: int, col1: int, row2: int, col2: int) -> int` - **Input**: * `row1`: Integer, starting row index of the submatrix (0-based index). * `col1`: Integer, starting column index of the submatrix (0-based index). * `row2`: Integer, ending row index of the submatrix (0-based index). * `col2`: Integer, ending column index of the submatrix (0-based index). - **Output**: * Returns the sum of the elements in the specified submatrix defined by `(row1, col1)` as the top-left corner and `(row2, col2)` as the bottom-right corner. - **Description**: - Queries the Fenwick Tree to find the sum of elements in the submatrix specified by the two corners. # Constraints 1. The dimensions of the matrix are between `1x1` and `1000x1000`. 2. Elements in the matrix can be between `-10^4` and `10^4`. 3. Indices `row` and `col` are 0-based and within the bounds of the matrix. # Example ```python # Example usage: matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] fenwick_tree = FenwickTree(matrix) print(fenwick_tree.query(2, 1, 4, 3)) # Output: 8 fenwick_tree.update(3, 2, 2) print(fenwick_tree.query(2, 1, 4, 3)) # Output: 10 ```","solution":"from typing import List class FenwickTree: def __init__(self, matrix: List[List[int]]) -> None: Initialize the Fenwick Tree with the given matrix. if not matrix or not matrix[0]: return self.rows = len(matrix) self.cols = len(matrix[0]) self.tree = [[0] * (self.cols + 1) for _ in range(self.rows + 1)] self.matrix = [[0] * self.cols for _ in range(self.rows)] for r in range(self.rows): for c in range(self.cols): self.update(r, c, matrix[r][c]) def _add(self, row: int, col: int, delta: int) -> None: Helper function to add a delta value at (row, col) in the Fenwick Tree. i = row + 1 while i <= self.rows: j = col + 1 while j <= self.cols: self.tree[i][j] += delta j += j & -j i += i & -i def update(self, row: int, col: int, val: int) -> None: Update the value at (row, col) to val. delta = val - self.matrix[row][col] self.matrix[row][col] = val self._add(row, col, delta) def _sum(self, row: int, col: int) -> int: Helper function to get the sum from (0,0) to (row,col). total = 0 i = row + 1 while i > 0: j = col + 1 while j > 0: total += self.tree[i][j] j -= j & -j i -= i & -i return total def query(self, row1: int, col1: int, row2: int, col2: int) -> int: Query the sum of the submatrix from (row1, col1) to (row2, col2). return ( self._sum(row2, col2) - self._sum(row1 - 1, col2) - self._sum(row2, col1 - 1) + self._sum(row1 - 1, col1 - 1) )"},{"question":"# Context Graph traversal is a technique used for searching or exploring a graph. The two most common methods of graph traversal are Depth-First Search (DFS) and Breadth-First Search (BFS). DFS is used to traverse or search through the nodes of a graph in depthward motion. It uses a stack data structure. BFS, on the other hand, uses a queue to traverse a graph in a levelwise manner. Given an undirected, unweighted graph represented by an adjacency list, your task is to perform both DFS and BFS starting from a given node and return the order of the nodes visited in both traversals. # Task Implement a function `graph_traversal` that performs both Depth-First Search and Breadth-First Search on an undirected graph. 1. **Function Signature**: ```python def graph_traversal(adj_list: Dict[int, List[int]], start_node: int) -> Tuple[List[int], List[int]]: pass ``` 2. **Parameters**: - `adj_list`: A dictionary representing the adjacency list of the graph, where each key is a node and the value is a list of connected nodes. - `start_node`: The node from which the traversals will start. 3. **Returns**: - A tuple containing two lists: - The first list shows the order of nodes visited in DFS. - The second list shows the order of nodes visited in BFS. # Constraints - The graph is connected. - Each node in the graph is denoted by a unique integer. - There are no self-loops or parallel edges. # Example Consider the following graph represented as an adjacency list: ```python adj_list = { 1: [2, 3], 2: [1, 4, 5], 3: [1], 4: [2], 5: [2] } start_node = 1 ``` After performing both traversals: - `DFS`: The traversal order would be `[1, 2, 4, 5, 3]` - `BFS`: The traversal order would be `[1, 2, 3, 4, 5]` Therefore, the function should return: ```python graph_traversal(adj_list, start_node) == ([1, 2, 4, 5, 3], [1, 2, 3, 4, 5]) ``` # Implementation Details 1. For DFS, use an iterative approach with a stack. Start from the `start_node` and explore each branch completely before moving on to the next branch. 2. For BFS, use an iterative approach with a queue. Start from the `start_node` and explore each neighbor at the present depth level before moving on to nodes at the next depth level.","solution":"def graph_traversal(adj_list, start_node): def dfs(adj_list, start_node): visited = set() stack = [start_node] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) # Add neighbors in reverse order to get the correct order in DFS stack.extend(reversed(adj_list[node])) return result def bfs(adj_list, start_node): visited = set([start_node]) queue = [start_node] result = [] while queue: node = queue.pop(0) result.append(node) for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return result return dfs(adj_list, start_node), bfs(adj_list, start_node)"},{"question":"# Problem Statement You are developing a simple calculator application and need to implement division functionality safely without causing errors or unexpected results. Create a function `safe_divide(dividend: int, divisor: int) -> float` that takes two integers, `dividend` and `divisor`, and returns the result of the division. If the `divisor` is zero, the function should return the string \\"Error: Division by zero\\". # Input - Two integers, `dividend` and `divisor`. # Output - The function should return a floating-point number representing the division of `dividend` by `divisor`. - If the `divisor` is zero, return the string \\"Error: Division by zero\\". # Constraints - The `dividend` and `divisor` will be within the range of -10^5 to 10^5. - Handle the edge cases where `divisor` is zero. # Example - `safe_divide(10, 2)` should return `5.0`. - `safe_divide(10, 0)` should return `\\"Error: Division by zero\\"`. - `safe_divide(-5, 2)` should return `-2.5`. # Implementation Note Ensure that your implementation accurately handles division and gracefully manages the case where the `divisor` is zero to avoid runtime errors.","solution":"def safe_divide(dividend: int, divisor: int) -> float: Returns the result of dividing dividend by divisor. If the divisor is zero, returns \\"Error: Division by zero\\". if divisor == 0: return \\"Error: Division by zero\\" return dividend / divisor"},{"question":"# Decision Tree Classifier Implementation **Problem Statement**: Implement a Decision Tree classifier from scratch in Python. Your task is to understand and implement the key components and functionalities of the Decision Tree algorithm as provided in the code snippets. Demonstrate your coding proficiency by writing correct, optimized, and tested code. Components to Implement: 1. **Split Function**: Determines the best way to split the dataset based on different features and thresholds to maximize information gain. 2. **Information Gain Calculation**: Measures the reduction in entropy or impurity criteria (e.g., Gini, Entropy) brought by a split. 3. **Tree Building**: Constructs the decision tree recursively until stopping criteria are met. Requirements: 1. Implement the functions `split_function()`, `information_gain()`, and `build_tree()` as described. 2. Ensure your implementation can handle edge cases and large datasets efficiently. Input and Output: 1. **Input**: * `X` (np.ndarray): Feature matrix. * `y` (np.ndarray): Target labels. * `max_depth` (int): Maximum depth of the tree to prevent overfitting. * `min_samples_split` (int): Minimum number of samples required to split a node. 2. **Output**: * `tree` (dict): The constructed Decision Tree in a dictionary format. Examples: ```python # Sample Inputs X = np.array([[2.0, 3.0], [1.5, 2.5], [3.0, 4.0], [4.0, 5.0], [2.5, 3.5]]) y = np.array([0, 1, 0, 1, 0]) max_depth = 3 min_samples_split = 2 # Call the decision tree function tree = build_tree(X, y, max_depth, min_samples_split) # Expected Output (format the output to match the example) print(f\\"Decision Tree: {tree}\\") ``` Ensure your solution works for the sample input and appropriately handles a variety of real-world datasets, considering the tree structure and result accuracy. Constraints: 1. You must adhere to the essential properties of each function. 2. Highly optimized solutions are preferred. 3. Test your implementation thoroughly using multiple test cases and edge scenarios.","solution":"import numpy as np def entropy(y): Calculate the entropy of label array y. hist = np.bincount(y) ps = hist / len(y) return -np.sum([p * np.log2(p) for p in ps if p > 0]) def split(X, y, feature, threshold): Split the dataset X, y based on a feature and a feature value threshold left_mask = X[:, feature] <= threshold right_mask = X[:, feature] > threshold return X[left_mask], X[right_mask], y[left_mask], y[right_mask] def information_gain(y, y_left, y_right): Calculate the information gain of a split based on entropy parent_entropy = entropy(y) n = len(y) n_left, n_right = len(y_left), len(y_right) if n_left == 0 or n_right == 0: return 0 weighted_avg_child_entropy = (n_left / n) * entropy(y_left) + (n_right / n) * entropy(y_right) return parent_entropy - weighted_avg_child_entropy def best_split(X, y): Find the best split by searching over all features and all thresholds best_feature, best_threshold, best_gain = None, None, -1 n_samples, n_features = X.shape for feature in range(n_features): thresholds = np.unique(X[:, feature]) for threshold in thresholds: X_left, X_right, y_left, y_right = split(X, y, feature, threshold) gain = information_gain(y, y_left, y_right) if gain > best_gain: best_gain, best_feature, best_threshold = gain, feature, threshold return best_feature, best_threshold, best_gain def build_tree(X, y, max_depth, min_samples_split, depth=0): Recursively build the decision tree n_samples, n_features = X.shape n_labels = len(np.unique(y)) # Stopping condition if depth >= max_depth or n_labels == 1 or n_samples < min_samples_split: return np.bincount(y).argmax() # Return the majority class # Find the best split feature, threshold, gain = best_split(X, y) if gain == 0: return np.bincount(y).argmax() # Split the dataset X_left, X_right, y_left, y_right = split(X, y, feature, threshold) # Recursive call on left and right child left_child = build_tree(X_left, y_left, max_depth, min_samples_split, depth + 1) right_child = build_tree(X_right, y_right, max_depth, min_samples_split, depth + 1) return {\\"feature\\": feature, \\"threshold\\": threshold, \\"left\\": left_child, \\"right\\": right_child} X = np.array([[2.0, 3.0], [1.5, 2.5], [3.0, 4.0], [4.0, 5.0], [2.5, 3.5]]) y = np.array([0, 1, 0, 1, 0]) max_depth = 3 min_samples_split = 2 # Calling build_tree function to build the decision tree. tree = build_tree(X, y, max_depth, min_samples_split) # Output the tree structure print(f\\"Decision Tree: {tree}\\")"},{"question":"\\"Storage Allocation Optimization\\" # Context In a cloud computing environment, you have a set of storage devices with limited capacities, and a set of files that need to be stored. Each file must be stored in a single device, and no splitting of files across devices is allowed. Your goal is to determine if it\'s possible to allocate all files onto the devices without exceeding their capacities, and, if possible, find one such allocation. # Problem Statement You are given: 1. An integer `M` representing the total number of storage devices. 2. A list of integers `capacities` where the `i-th` integer indicates the capacity of the `i-th` storage device. 3. An integer `F` representing the total number of files. 4. A list of integers `file_sizes` where the `i-th` integer indicates the size of the `i-th` file. Write a Python function: ```python def storage_allocation_possible(M, capacities, F, file_sizes): pass ``` The function should return `True` if it is possible to allocate all files to the devices without exceeding their capacities, otherwise return `False`. If possible, it should also return one example of such an allocation as a list of lists, where the i-th list contains the indices of files stored in the i-th device. # Input Format - An integer `M` - the total number of storage devices. - A list of integers `capacities` - the capacity of each storage device. - An integer `F` - the total number of files. - A list of integers `file_sizes` - the size of each file. # Output Format - A tuple where the first element is a boolean indicating if the allocation is possible (`True` or `False`). If `True`, the second element is a list of lists representing one possible allocation of files to devices. If `False`, the second element can be an empty list. # Constraints - (1 leq M leq 15) - (1 leq text{capacities[i]} leq 10^6) - (1 leq F leq 20) - (1 leq text{file_sizes[i]} leq 10^6) # Example ```python def storage_allocation_possible(M, capacities, F, file_sizes): # implementation goes here pass # Example M = 3 capacities = [10, 20, 30] F = 4 file_sizes = [5, 10, 15, 20] output = storage_allocation_possible(M, capacities, F, file_sizes) print(output) # Should return (True, [[0], [1, 2], [3]]) or similar valid allocation ``` # Explanation For the example provided: - Storage devices\' capacities: [10, 20, 30] - Files to be stored: [5, 10, 15, 20] The function should determine if it is possible to allocate files to storage devices without exceeding capacities and provide a valid allocation if possible. # Edge Cases - All files being too large for any single device (e.g., having file sizes greater than any device\'s capacity). - Files perfectly fitting into capacities without exceeding. # Notes Optimize your solution for both correctness and performance. Handle edge cases carefully, and consider using backtracking with memoization to ensure efficiency.","solution":"def storage_allocation_possible(M, capacities, F, file_sizes): from itertools import permutations # Generate all possible orders of files for permutation in permutations(range(F)): # Create a copy of the capacities to keep track of remaining capacities remaining_capacities = capacities[:] # Create an allocation list to store which files go to which device allocation = [[] for _ in range(M)] # Try to allocate each file in the current permutation for file_index in permutation: file_size = file_sizes[file_index] allocated = False for i in range(M): if remaining_capacities[i] >= file_size: remaining_capacities[i] -= file_size allocation[i].append(file_index) allocated = True break if not allocated: # If we failed to allocate the current file, try next permutation. break else: # If we successfully allocated all files, return the result return True, allocation # If we tried all permutations and couldn\'t find a valid allocation: return False, []"},{"question":"# Task Given a list of strings, where each string contains only lowercase English letters, write a Python function `most_frequent_char(words: list) -> dict` to determine the most frequently occurring character across all the strings. If there is a tie, any of the most frequent characters can be returned. # Function Signature ```python def most_frequent_char(words: list) -> dict: pass ``` # Input * **words**: A list of strings, where each string contains only lowercase English letters (1 ≤ len(words) ≤ 10,000). # Output * Returns a dictionary where keys are characters and values are their respective frequencies, containing only the characters with the maximum frequency. # Constraints * The function should efficiently handle the upper limit of the list and the strings contained in it. * Implement the function in a way that it can handle large input sizes without significant performance degradation. # Example Consider the input `[\'apple\', \'banana\', \'cherry\']`. The most frequent characters are \'a\' and \'e\', both appearing 2 times. Therefore, the function should return `{\'a\': 4, \'e\': 2}`. ```python >>> most_frequent_char([\'apple\', \'banana\', \'cherry\']) {\'a\': 4, \'e\': 2} ``` # Note If no tie handling is required, make sure to select any one of the most frequent characters. The function should pay attention to the overall frequency including across different strings.","solution":"def most_frequent_char(words: list) -> dict: from collections import Counter # Create a counter to count frequencies of all characters char_counter = Counter() for word in words: char_counter.update(word) # Determine the highest frequency if not char_counter: return {} max_frequency = max(char_counter.values()) # Extract characters that have the max frequency most_frequent_chars = {char: freq for char, freq in char_counter.items() if freq == max_frequency} return most_frequent_chars"},{"question":"# Sorting an Array of Dates You need to write a function in Python that takes a list of dates (strings) in the format \'YYYY-MM-DD\' and returns a list of dates sorted in ascending order. Function Signature ```python def sort_dates(dates: list[str]) -> list[str]: ``` Parameters: - `dates` (list[str]): A list of dates represented as strings in the format \'YYYY-MM-DD\'. Returns: - `list[str]`: The list of dates sorted in ascending order. # Requirements: 1. Ensure the function handles valid date strings of the format \'YYYY-MM-DD\'. 2. The function should sort the dates correctly in chronological order. # Constraints: - The list of dates will contain between 1 and 1000 elements. - Each date string will be a valid date in the range from \'0001-01-01\' to \'9999-12-31\'. # Example Usage: ```python dates = [\'2023-10-23\', \'1990-02-19\', \'2000-01-01\'] print(sort_dates(dates)) # Output: [\'1990-02-19\', \'2000-01-01\', \'2023-10-23\'] dates = [\'2023-01-01\', \'2022-12-31\', \'2023-01-02\'] print(sort_dates(dates)) # Output: [\'2022-12-31\', \'2023-01-01\', \'2023-01-02\'] dates = [\'2022-02-28\', \'2020-02-29\', \'2021-02-28\'] print(sort_dates(dates)) # Output: [\'2020-02-29\', \'2021-02-28\', \'2022-02-28\'] ``` Implement the `sort_dates` function and ensure it passes the provided test cases.","solution":"def sort_dates(dates): Sorts a list of date strings in the format \'YYYY-MM-DD\' in ascending order. return sorted(dates)"},{"question":"# Matrix Rotation **Context**: You are tasked with rotating a square 2D matrix by 90 degrees in a clockwise direction. The input matrix will always be a square, meaning it will have the same number of rows and columns. **Task**: Write a function `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` that takes a square matrix (a list of lists of integers) and returns a new matrix that is rotated 90 degrees clockwise. **Input**: - `matrix` (list of list of int): An NxN list of lists where each element is an integer. **Output**: - A new NxN matrix which is the rotated version of the input matrix. **Constraints**: - The matrix will have ( n times n ) dimensions where ( 1 leq n leq 10 ). - The elements of the matrix are integers. **Examples**: ```python def test_rotate_matrix(): matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Rotated matrix should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] expected_rotated_matrix_1 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] assert rotate_matrix(matrix_1) == expected_rotated_matrix_1 matrix_2 = [ [1, 2], [3, 4], ] # Rotated matrix should be: # [ # [3, 1], # [4, 2], # ] expected_rotated_matrix_2 = [ [3, 1], [4, 2], ] assert rotate_matrix(matrix_2) == expected_rotated_matrix_2 test_rotate_matrix() ``` **Notes**: - Consider using in-place rotation techniques if possible for optimizing memory usage. - Remember to handle different sizes of square matrices and ensure that the rotation is clockwise.","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix by 90 degrees clockwise. Parameters: matrix (list of list of int): A square matrix (NxN) Returns: list of list of int: The rotated matrix n = len(matrix) # Create a new matrix to hold the rotated values rotated_matrix = [[0] * n for _ in range(n)] for r in range(n): for c in range(n): rotated_matrix[c][n - 1 - r] = matrix[r][c] return rotated_matrix"},{"question":"# String Permutation Check Context: In computer science, one common problem is to determine if one string is a permutation of another. A permutation is a rearrangement of letters. The task at hand is to verify whether one string is a permutation of another string. This function is particularly useful in scenarios such as cryptography and data validation. Task: You need to implement the `check_permutation` function that takes two strings as input and returns a boolean indicating whether one string is a permutation of the other. Function Signature: ```python def check_permutation(str1: str, str2: str) -> bool: Checks if str1 is a permutation of str2. pass ``` Constraints: * Both `str1` and `str2` are non-empty strings consisting of ASCII characters. * The lengths of `str1` and `str2` are between 1 and (10^5). Input: * `str1` (str) - the first string. * `str2` (str) - the second string. Output: * (bool) - `True` if `str1` is a permutation of `str2`, otherwise `False`. Example: ```python str1 = \\"listen\\" str2 = \\"silent\\" print(check_permutation(str1, str2)) # Output: True str1 = \\"apple\\" str2 = \\"papel\\" print(check_permutation(str1, str2)) # Output: True str1 = \\"hello\\" str2 = \\"billion\\" print(check_permutation(str1, str2)) # Output: False ``` Performance Expectations: * The implementation should efficiently handle strings up to (10^5) characters. * The function should have a time complexity of O(n), where n is the length of the strings.","solution":"def check_permutation(str1: str, str2: str) -> bool: Checks if str1 is a permutation of str2. if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"# Coding Assessment: Implement LRU Cache Eviction Policy Context You are working on an optimization module for a high-frequency transaction system that frequently references a set of items. To enhance performance, you need to implement a Least Recently Used (LRU) cache, which evicts the least recently accessed items when the cache reaches its capacity. Requirements Implement a class `LRUCache` with the following methods: 1. **__init__(self, capacity: int)**: * Initializes the LRU cache with a given capacity. 2. **get(self, key: int) -> int**: * Returns the value of the key if it exists in the cache, otherwise returns -1. * Updates the usage state of the key to indicate it was recently accessed. 3. **put(self, key: int, value: int) -> None**: * Inserts the key-value pair into the cache. * If the key is already in the cache, it updates the value. * If the cache reaches its capacity, it evicts the least recently used item. * Updates the usage state of the new or existing key to indicate it was recently accessed. Input * You will be provided with a series of operations and their corresponding key-value pairs. * Example: ```python operations = [\\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"get\\"] data = [[1, 1], [1], [2, 2], [1], [2]] ``` Output * The class should handle each operation efficiently and output the results of any `get` operations in order. * Ensure that operations that do not require output are handled correctly without printing additional data. Example ```python # Example provided inputs: operations = [\\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"get\\"] data = [[1, 1], [1], [2, 2], [1], [2]] # Usage of LRUCache cache = LRUCache(2) results = [] for i, operation in enumerate(operations): if operation == \\"put\\": cache.put(data[i][0], data[i][1]) elif operation == \\"get\\": results.append(cache.get(data[i][0])) # Expected Output # The result of cache operations should be: # [1, -1, 2] print(results) ``` Ensure your implementation handles edge cases and efficiently manages the internal state of the cache.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key in self.cache: value = self.cache.pop(key) self.cache[key] = value # Reinsert to mark as recently used return value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # Pop the first item (least recently used) self.cache[key] = value"},{"question":"# String Permutations Challenge Objective: Generate all possible permutations of a given string and return them in lexicographic order. # Task: Write a function `string_permutations` that takes a string and returns a list of all its permutations in lexicographic order. # Function Specifications: 1. **string_permutations(s: str) -> List[str]**: * Generates all possible permutations of the input string. * **Input**: * s: A string for which permutations are to be generated. * **Output**: List of permutations of the input string in lexicographic order. # Constraints: - The string will have a maximum length of 8 characters. - All characters in the string are unique. # Example: ```python >>> string_permutations(\'abc\') [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> string_permutations(\'bca\') [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] ``` # Notes: - Ensure that the permutations are output in lexicographic order as shown in the examples. - The input string will not contain any duplicate characters for simplicity.","solution":"from itertools import permutations def string_permutations(s: str) -> list: Generates all possible permutations of the input string in lexicographic order. # use itertools.permutations to get all permutations perm = permutations(s) # convert permutations to sorted list of strings sorted_perm = sorted([\'\'.join(p) for p in perm]) return sorted_perm"},{"question":"# Problem Statement: You are given a rectangular matrix `grid` of integers with `m` rows and `n` columns. Your task is to implement a function `spiral_traverse` that returns all elements of the matrix sorted in a spiral order starting from the top-left corner of the grid. # Function Signature: ```python def spiral_traverse(grid: List[List[int]]) -> List[int]: ``` # Input: - `grid`: A list of lists where each inner list represents a row of the matrix. The dimensions of the grid are `m x n`, where 0 <= m, n <= 1000. # Output: - Return a list of integers that are the elements of the grid in spiral order, starting from the top-left corner. # Constraints: 1. Handle edge cases such as an empty grid or a grid with only one row or one column. 2. Ensure the solution is efficient and can handle the upper limits of matrix size. # Example: ```python assert spiral_traverse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] assert spiral_traverse([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] assert spiral_traverse([[1]]) == [1] assert spiral_traverse([[]]) == [] assert spiral_traverse([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 6, 5, 4] ``` # Notes: - Particularly consider edge cases, including very small (1x1) and very large grids. - Optimize the function for performance given the constraints, while keeping the code clean and readable. # Solution Criteria: - Your solution should demonstrate a clear grasp of matrix traversal techniques. - Ensure the implementation is robust, handles various edge cases, and maintains efficiency both in terms of time and space.","solution":"from typing import List def spiral_traverse(grid: List[List[int]]) -> List[int]: Returns elements of the grid in spiral order starting from the top-left corner. if not grid or not grid[0]: return [] result = [] top, bottom = 0, len(grid) - 1 left, right = 0, len(grid[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): result.append(grid[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(grid[i][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): result.append(grid[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(grid[i][left]) left += 1 return result"},{"question":"# Problem Statement Given a string containing only the characters \'a\', \'b\', and \'c\', your task is to rearrange the string so that no two adjacent characters are the same. If it is impossible to rearrange the string to meet this condition, return an empty string. Write a function `rearrange_string(s: str) -> str` that takes a string and returns a new string with the described properties. Input * A string `s` (1 ≤ len(s) ≤ 10^5) consisting of only \'a\', \'b\', and \'c\'. Output * A string that satisfies the condition of no two adjacent characters being the same, or an empty string if it\'s not possible to rearrange the input string. Example ``` Input: s = \\"aaabc\\" Output: \\"abaca\\" Input: s = \\"aa\\" Output: \\"\\" Input: s = \\"aabbcc\\" Output: \\"abcabc\\" ``` In the first example, the string \\"aaabc\\" can be rearranged as \\"abaca\\" where no two adjacent characters are the same. In the second example, it is impossible to rearrange the string \\"aa\\" such that no two adjacent characters are the same, hence the output is an empty string. In the third example, the string \\"aabbcc\\" can be rearranged as \\"abcabc\\" or \\"bacbac\\", where no two adjacent characters are the same. Constraints * You may assume that the string only contains characters \'a\', \'b\', and \'c\'. * Aim to achieve an efficient solution, preferably with a time complexity of `O(n log n)`.","solution":"from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearranges the string so that no two adjacent characters are the same. If it\'s not possible, returns an empty string. if not s: return \\"\\" # Count the frequency of each character freq = Counter(s) max_freq = max(freq.values()) # If the highest frequency character occurs more times than the combination of other characters plus one, it\'s not possible if max_freq > (len(s) + 1) // 2: return \\"\\" # Create a max heap max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) # O(n) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append the character to the result result.append(char) # If there was a previous character to re-add to the heap if prev_char is not None and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update the previous character and its count prev_char = char prev_count = count + 1 # Increment the count since we are using one occurrence return \\"\\".join(result)"},{"question":"# Context: You are developing a program to analyze weather data and forecast future temperatures based on historical data. You will utilize a linear regression model for this task. # Task: Implement a Python function `train_and_predict_temperature(data_file, days_to_predict, test_ratio, epochs)` that: 1. Loads the weather data from a CSV file specified by `data_file`. 2. Preprocesses the data to handle any missing values and normalizes it. 3. Splits the data into training and testing sets based on `test_ratio`. 4. Trains a linear regression model on the training data. 5. Uses the trained model to predict temperatures for the next `days_to_predict` days. # Input: * `data_file` (str): File path to the dataset in CSV format, with temperature values in the second column. * `days_to_predict` (int): Number of days in the future for which predictions are required. * `test_ratio` (float): Proportion of data to be used for testing (e.g., 0.2 for 20%). * `epochs` (int): Number of iterations to train the model. # Output: * Returns a list of predicted temperatures for the next `days_to_predict` days. If the dataset is not sufficient for splitting, return an error message. # Constraints: * The dataset must contain at least 100 rows of data. * Handle missing values by imputing with the mean of the column. * Dataset normalization should be performed using StandardScaler. * `test_ratio` should be a value between 0.1 and 0.5. # Requirements: * Ensure your model handles potential edge cases such as insufficient data points or excessive missing values. * Optimize the model to achieve reliable performance within the given constraints. # Example: ```python predictions = train_and_predict_temperature(\\"weather_data.csv\\", 7, 0.2, 100) print(predictions) # Output: Example: [15.6, 15.8, 16.1, 16.5, 16.9, 17.2, 17.5] ```","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.preprocessing import StandardScaler from sklearn.impute import SimpleImputer def train_and_predict_temperature(data_file, days_to_predict, test_ratio, epochs): Trains a linear regression model to forecast temperatures. Args: data_file (str): Path to the dataset CSV file. days_to_predict (int): Number of future days to predict. test_ratio (float): Proportion of data to use for testing. epochs (int): Number of iterations to train the model. Returns: List[float]: Predicted temperatures for the next `days_to_predict` days. # Load data data = pd.read_csv(data_file) if data.shape[0] < 100: return \\"Error: Dataset must contain at least 100 rows.\\" # Assuming the second column contains the temperature data data = data.iloc[:, 1:2] # Handle missing values by imputing with the mean imputer = SimpleImputer(strategy=\'mean\') data = imputer.fit_transform(data) # Normalize data using StandardScaler scaler = StandardScaler() data = scaler.fit_transform(data) # Prepare input (X) and output (y) variables X = np.array(range(len(data))).reshape(-1, 1) y = data # Split data into training and testing sets if not (0.1 <= test_ratio <= 0.5): return \\"Error: test_ratio must be between 0.1 and 0.5.\\" X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_ratio, shuffle=False) # Initialize and train the model model = LinearRegression() for epoch in range(epochs): model.fit(X_train, y_train) # Predict future temperatures future_X = np.array(range(len(data), len(data) + days_to_predict)).reshape(-1, 1) predictions = model.predict(future_X) # Inverse transform of predictions to original scale predictions = scaler.inverse_transform(predictions) # Flatten the predictions list for readability return predictions.flatten().tolist()"},{"question":"# Task: Implement a Log File Analyzer for Error Detection Scenario You are tasked with creating a tool to analyze server log files and identify patterns of errors occurring within specific time intervals. The log files are plain text files where each line represents a log entry with a timestamp and a severity level (INFO, WARNING, ERROR). Requirements 1. **Function Implementation**: Implement the function `find_error_patterns(log_file_path: str, interval: int) -> Dict[str, int]` - **Input**: - `log_file_path` (str): The file path to the server log file. - `interval` (int): The time interval, in minutes, to analyze for patterns. - **Output**: A dictionary where the keys are the time intervals and the values are the count of errors during those intervals. Each time interval should be formatted as `HH:MM-HH:MM`. 2. **Constraints**: - Parse the log entries assuming a fixed format: `YYYY-MM-DD HH:MM:SS [LEVEL] Message`. - Only consider log entries with the severity level `ERROR`. - If an interval has no errors, it should not appear in the output dictionary. 3. **Performance Requirements**: - The function must handle large log files efficiently. - Ensure the solution is scalable and can process logs with millions of entries without excessive memory use. Example Usage ```python # Sample log file content: # 2023-03-01 08:05:23 [INFO] Server started # 2023-03-01 08:10:45 [ERROR] Database connection failed # 2023-03-01 08:12:11 [ERROR] Timeout error on request # 2023-03-01 08:30:00 [WARNING] High memory usage # 2023-03-01 09:00:01 [ERROR] Disk space low log_file_path = \\"server_logs.txt\\" interval = 15 # Analyze logs in 15-minute intervals error_patterns = find_error_patterns(log_file_path, interval) for interval, count in error_patterns.items(): print(f\\"There were {count} errors in the interval {interval}\\") ``` # Additional Considerations - Ensure your implementation includes appropriate error handling for file I/O operations. - Test with different log files to cover various scenarios including varying levels of log verbosity and different interval settings.","solution":"from typing import Dict from datetime import datetime, timedelta def find_error_patterns(log_file_path: str, interval: int) -> Dict[str, int]: error_counts = {} try: with open(log_file_path, \'r\') as log_file: logs = log_file.readlines() except FileNotFoundError: print(f\\"Log file {log_file_path} not found.\\") return error_counts for log in logs: parts = log.strip().split(\' \') timestamp_str = \' \'.join(parts[:2]) log_level = parts[2].strip(\'[]\') if log_level != \'ERROR\': continue timestamp = datetime.strptime(timestamp_str, \'%Y-%m-%d %H:%M:%S\') minutes = (timestamp.minute // interval) * interval interval_start = timestamp.replace(minute=minutes, second=0) interval_end = interval_start + timedelta(minutes=interval) interval_key = f\\"{interval_start.strftime(\'%H:%M\')}-{interval_end.strftime(\'%H:%M\')}\\" if interval_key in error_counts: error_counts[interval_key] += 1 else: error_counts[interval_key] = 1 return error_counts"},{"question":"# Problem Description You are tasked with synchronizing and merging two or more sorted sequences of integers into a single sorted sequence. This problem requires you to implement a function that efficiently merges the input lists while maintaining the sorted order. # Task Write a Python function `merge_sorted_lists` that takes as input a list of sorted integer lists and merges them into a single sorted list. # Requirements 1. **merge_sorted_lists(lists)**: Consolidate all input lists into one sorted list. 2. The lists can vary in length, including possibly being empty. # Constraints - Implement the function with an efficient merging strategy (e.g., using a heap to achieve optimal time complexity). - Do not use built-in sort functions. - Consider edge cases like empty lists or lists of different lengths. # Input and Output - **lists**: A list containing `n` sorted lists (each list is of type `List[int]`). The overall structure is `List[List[int]]`. - The function returns a single list of integers – the merged sorted list. # Example ```python def merge_sorted_lists(lists): import heapq merged_list = [] min_heap = [] # Initialize the heap with the first element of each list for i, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst[0], i, 0)) while min_heap: val, list_ind, elem_ind = heapq.heappop(min_heap) merged_list.append(val) if elem_ind + 1 < len(lists[list_ind]): next_tuple = (lists[list_ind][elem_ind + 1], list_ind, elem_ind + 1) heapq.heappush(min_heap, next_tuple) return merged_list # Example usage: lists = [[1, 4, 5], [1, 3, 4], [2, 6]] print(merge_sorted_lists(lists)) # Output: [1, 1, 2, 3, 4, 4, 5, 6] lists = [[], [2, 6], [1, 3, 5]] print(merge_sorted_lists(lists)) # Output: [1, 2, 3, 5, 6] ``` # Implementation Challenge Implement the `merge_sorted_lists` function to ensure it handles input lists of different lengths, including empty lists, and efficiently merges them while preserving sorted order.","solution":"import heapq def merge_sorted_lists(lists): Merge multiple sorted lists into a single sorted list. Parameters: lists (List[List[int]]): A list of sorted integer lists. Returns: List[int]: A single sorted list containing all elements from the input lists. merged_list = [] min_heap = [] # Initialize the heap with the first element of each list for i, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst[0], i, 0)) while min_heap: val, list_ind, elem_ind = heapq.heappop(min_heap) merged_list.append(val) if elem_ind + 1 < len(lists[list_ind]): next_tuple = (lists[list_ind][elem_ind + 1], list_ind, elem_ind + 1) heapq.heappush(min_heap, next_tuple) return merged_list"},{"question":"# Question: Implement the Longest Arithmetic Subsequence Scenario You need to implement a function to compute the length of the longest arithmetic subsequence in a given list of integers. An arithmetic subsequence is a sequence of numbers from the list that have the same difference between consecutive elements. Requirements Implement the function `longest_arithmetic_subsequence(nums: List[int]) -> int`. # Input - `nums`: A list of integers where the length of the list will be at most 10^3. # Output - A single integer representing the length of the longest arithmetic subsequence among the elements in `nums`. # Constraints - The length of `nums` will be at most 10^3. - The elements of `nums` will be in the range ([-10^4, 10^4]). # Detailed Explanation 1. An arithmetic subsequence of list `nums` is a subsequence where the difference between consecutive elements is the same. 2. You need to find the length of such a subsequence that is the longest. # Example ```python >>> nums = [3, 6, 9, 12] >>> longest_arithmetic_subsequence(nums) 4 # The entire sequence is an arithmetic subsequence with difference 3 >>> nums = [9, 4, 7, 2, 10] >>> longest_arithmetic_subsequence(nums) 3 # The subsequence [9, 7, 10] or [4, 7, 10] both have max length 3 with difference 1 >>> nums = [20, 1, 15, 3, 10, 5, 8] >>> longest_arithmetic_subsequence(nums) 4 # The subsequence [20, 15, 10, 5] with difference -5 ``` # Function Signature: ```python from typing import List def longest_arithmetic_subsequence(nums: List[int]) -> int: # Your code here pass ``` # Notes: - Be mindful of edge cases such as an empty list or a list with only one or two elements.","solution":"from typing import List def longest_arithmetic_subsequence(nums: List[int]) -> int: if not nums: return 0 n = len(nums) if n == 1: return 1 # dp dictionary to store subsequences and their lengths dp = {} max_len = 1 for i in range(n): for j in range(i): diff = nums[i] - nums[j] if (j, diff) in dp: dp[(i, diff)] = dp[(j, diff)] + 1 else: dp[(i, diff)] = 2 max_len = max(max_len, dp[(i, diff)]) return max_len"},{"question":"# Scenario As a software engineer at an online retail company, you are responsible for developing a feature that automatically determines the optimal shipping method based on various constraints. Your task is to write a program to select the best shipping method based on the given weight of the package and the available shipping options. # Task Write a Python function `select_shipping_method` that takes in the weight of the package and a list of dictionaries representing the available shipping options. The function should return the name of the optimal shipping method based on the lowest cost for the given weight. Ensure that the function handles invalid inputs appropriately. # Input - `weight` (float): The weight of the package in kilograms. Must be positive. - `shipping_options` (list): A list of dictionaries, each representing a shipping method with the following keys: * `name` (str): The name of the shipping method. * `base_cost` (float): The base cost of this shipping method. Must be positive. * `cost_per_kg` (float): The cost per kilogram for this shipping method. Must be positive. # Output - Return a string representing the name of the optimal shipping method. # Constraints 1. All inputs must be in the correct format (weight as a positive float, and shipping_options as a list of dictionaries with appropriate positive values). 2. Raise `ValueError` with a descriptive message if any of the following conditions are not met: * Weight must be positive. * All base costs must be positive. * All cost per kg values must be positive. # Examples ```python >>> shipping_options = [ ... {\\"name\\": \\"Economy\\", \\"base_cost\\": 5.00, \\"cost_per_kg\\": 1.00}, ... {\\"name\\": \\"Express\\", \\"base_cost\\": 10.00, \\"cost_per_kg\\": 1.50}, ... {\\"name\\": \\"Overnight\\", \\"base_cost\\": 20.00, \\"cost_per_kg\\": 2.00} ... ] >>> select_shipping_method(weight=2.5, shipping_options=shipping_options) \'Economy\' >>> select_shipping_method(weight=0, shipping_options=shipping_options) Traceback (most recent call last): ... ValueError: Weight must be positive >>> shipping_options = [ ... {\\"name\\": \\"Economy\\", \\"base_cost\\": -5.00, \\"cost_per_kg\\": 1.00}, ... {\\"name\\": \\"Express\\", \\"base_cost\\": 10.00, \\"cost_per_kg\\": 1.50} ... ] >>> select_shipping_method(weight=2.5, shipping_options=shipping_options) Traceback (most recent call last): ... ValueError: Base costs must be positive >>> shipping_options = [ ... {\\"name\\": \\"Economy\\", \\"base_cost\\": 5.00, \\"cost_per_kg\\": -1.00}, ... {\\"name\\": \\"Express\\", \\"base_cost\\": 10.00, \\"cost_per_kg\\": 1.50} ... ] >>> select_shipping_method(weight=2.5, shipping_options=shipping_options) Traceback (most recent call last): ... ValueError: Cost per kg values must be positive ```","solution":"def select_shipping_method(weight, shipping_options): Select the optimal shipping method based on the lowest cost for the given weight. Args: weight (float): The weight of the package in kilograms. Must be positive. shipping_options (list): A list of dictionaries, each representing a shipping method with: - \'name\' (str): The name of the shipping method. - \'base_cost\' (float): The base cost of this shipping method. Must be positive. - \'cost_per_kg\' (float): The cost per kilogram for this shipping method. Must be positive. Returns: str: The name of the optimal shipping method. Raises: ValueError: If weight is not positive, or if base_cost or cost_per_kg are not positive in any shipping option. if weight <= 0: raise ValueError(\\"Weight must be positive\\") for option in shipping_options: if option[\'base_cost\'] <= 0: raise ValueError(\\"Base costs must be positive\\") if option[\'cost_per_kg\'] <= 0: raise ValueError(\\"Cost per kg values must be positive\\") optimal_method = None lowest_cost = float(\'inf\') for option in shipping_options: total_cost = option[\'base_cost\'] + option[\'cost_per_kg\'] * weight if total_cost < lowest_cost: lowest_cost = total_cost optimal_method = option[\'name\'] return optimal_method"},{"question":"# Scenario You are tasked with creating a software component for an e-commerce application for managing discount prices of products. The system should apply various types of discounts based on the promotional campaigns. Implementing this effectively will help users see the correct prices during sales and promotions. # Task You need to implement a function that calculates the final price after applying one of the following types of discounts: percentage discount, fixed amount discount, or buy-one-get-one-free (BOGO) discount. # Function Signature ```python def calculate_discounted_price( original_price: float, discount_type: str, discount_value: float = None, quantity: int = 1 ) -> float: ``` # Input 1. `original_price` (float): The original price of the product. Should be greater than or equal to 0. 2. `discount_type` (str): The type of discount to apply. It can be one of `\\"percentage\\"`, `\\"fixed\\"`, or `\\"bogo\\"`. 3. `discount_value` (float, optional): The value of the discount to apply. For `\\"percentage\\"` discount, this is the percentage off. For `\\"fixed\\"` discount, this is the amount off. For `\\"bogo\\"` discount, this should be `None`. 4. `quantity` (int): The number of items to purchase. Defaults to 1 and should be a positive integer. # Output The function should return the final price after applying the discount, as a float. # Constraints * For `percentage` discounts, `discount_value` should be between 0 and 100. * For `fixed` discounts, `discount_value` should be a non-negative value and should not exceed the original price. * For `bogo` discounts, no discount value is necessary. * The original price should be a non-negative float. * Quantity should be a positive integer. * If any input constraints are violated, the function should raise a `ValueError` with the message `\\"Invalid inputs.\\"`. # Example ```python >>> calculate_discounted_price(100.0, \'percentage\', discount_value=20) 80.0 >>> calculate_discounted_price(50.0, \'fixed\', discount_value=10) 40.0 >>> calculate_discounted_price(30.0, \'bogo\', quantity=3) 60.0 >>> calculate_discounted_price(45.0, \'percentage\', discount_value=110) Traceback (most recent call last): ... ValueError: Invalid inputs. >>> calculate_discounted_price(80.0, \'fixed\', discount_value=90) Traceback (most recent call last): ... ValueError: Invalid inputs. ``` # Hint For the `bogo` discount, consider that when you buy `n` items, you get `floor(n / 2)` items for free. So the final price calculation should account for only the payable items.","solution":"import math def calculate_discounted_price( original_price: float, discount_type: str, discount_value: float = None, quantity: int = 1 ) -> float: if original_price < 0 or quantity <= 0: raise ValueError(\\"Invalid inputs.\\") if discount_type == \\"percentage\\": if discount_value is None or not (0 <= discount_value <= 100): raise ValueError(\\"Invalid inputs.\\") final_price = original_price * (1 - discount_value / 100) elif discount_type == \\"fixed\\": if discount_value is None or discount_value < 0 or discount_value > original_price: raise ValueError(\\"Invalid inputs.\\") final_price = original_price - discount_value elif discount_type == \\"bogo\\": if discount_value is not None: raise ValueError(\\"Invalid inputs.\\") payable_items = (quantity // 2) + (quantity % 2) final_price = original_price * payable_items else: raise ValueError(\\"Invalid inputs.\\") return final_price * quantity if discount_type != \\"bogo\\" else final_price"},{"question":"# Coding Assessment Question **Problem Statement:** You are given the implementation of an algorithm for converting a given integer to its Roman numeral representation and vice versa. Roman numerals are represented by combinations of letters from the Latin alphabet. The characters used in Roman numerals are I, V, X, L, C, D, and M, where each letter corresponds to a fixed value, and combinations represent numbers by summing or subtracting them. **Objective:** Write a function `roman_numeral_operations` that takes a list of operations and numbers/strings, and returns the corresponding conversions using provided `RomanNumeralConverter` class. **Function Signature:** ```python def roman_numeral_operations(operations: List[Tuple[str, Union[int, str]]]) -> List[Union[int, str]]: ``` **Input:** * `operations`: A list of tuples where each tuple contains: - A string indicating the operation type: `\\"to_roman\\"` or `\\"to_integer\\"`. - An integer or string which is the number to convert to Roman numeral or Roman numeral to convert to an integer. **Output:** * A list of integers or strings where each element is the result of the corresponding conversion operation. **Constraints:** * The integer input for `\\"to_roman\\"` operations will be in the range [1, 3999]. * The Roman numeral input for `\\"to_integer\\"` will be a valid Roman numeral representing a number in the range [1, 3999]. * Invalid operations should be ignored (i.e., operations other than `\\"to_roman\\"` or `\\"to_integer\\"`). **Example:** ```python operations = [(\\"to_roman\\", 1997), (\\"to_integer\\", \\"MCMLXX\\"), (\\"to_roman\\", 49), (\\"to_integer\\", \\"XLIX\\")] result = roman_numeral_operations(operations) print(result) # Output: [\\"MCMXCVII\\", 1970, \\"XLIX\\", 49] ``` **Requirements:** 1. Implement the function `roman_numeral_operations` by using the `RomanNumeralConverter` class methods. 2. Correct handling of edge cases (e.g., maximum range values, validity of Roman numerals) as described. 3. Thoroughly test the function with various inputs representing different edge cases.","solution":"class RomanNumeralConverter: @staticmethod def to_roman(num): val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num @staticmethod def to_integer(s): roman = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } integer = 0 for i in range(len(s)): if i > 0 and roman[s[i]] > roman[s[i - 1]]: integer += roman[s[i]] - 2 * roman[s[i - 1]] else: integer += roman[s[i]] return integer def roman_numeral_operations(operations): results = [] for op, value in operations: if op == \\"to_roman\\" and isinstance(value, int): results.append(RomanNumeralConverter.to_roman(value)) elif op == \\"to_integer\\" and isinstance(value, str): results.append(RomanNumeralConverter.to_integer(value)) return results"},{"question":"Question: Sentiment Analysis Using SVM You are assigned to build a sentiment analysis model that categorizes sentiments as positive or negative from textual data. You will use a Support Vector Machine (SVM) classifier for this task. The goal is to train the model on given datasets and evaluate its performance based on Accuracy and F1 Score. # Task 1. **Data Preprocessing** - Write a function `data_preprocessing(dataset: list) -> tuple` that takes a list of tuples containing text and their corresponding sentiment labels. This function should: - Tokenize the text and extract features using TF-IDF vectorization. - Return a tuple containing the feature data and the target labels as arrays. 2. **Model Training and Evaluation** - Write a function `svm_classifier(features: np.ndarray, target: np.ndarray, test_features: np.ndarray, test_target: np.ndarray) -> tuple` that: - Initializes and trains an SVM classifier on the provided training features and target values. - Predicts the sentiments on the given test features. - Computes and returns the accuracy and F1 score of the predictions. 3. **Main Function** - Write a function `main()` that: - Loads the dataset. - Preprocesses the data using the `data_preprocessing` function. - Splits the data into training and testing sets. - Trains the model and evaluates it using the `svm_classifier` function. - Prints the accuracy and F1 score of the predictions. # Constraints - Ensure reproducibility with a fixed random state of 42. - Handle edge cases where the dataset might have missing or NaN values. # Example ```python import numpy as np from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.metrics import accuracy_score, f1_score from sklearn.model_selection import train_test_split from sklearn.svm import SVC # Sample dataset dataset = [ (\\"I loved the movie, it was fantastic!\\", 1), (\\"The film was terrible, I hated it.\\", 0), (\\"Best movie ever!\\", 1), (\\"Worst film I\'ve seen, do not recommend.\\", 0) ] def data_preprocessing(dataset: list) -> tuple: texts, labels = zip(*dataset) tfidf = TfidfVectorizer(stop_words=\'english\') features = tfidf.fit_transform(texts) return features.toarray(), np.array(labels) def svm_classifier(features: np.ndarray, target: np.ndarray, test_features: np.ndarray, test_target: np.ndarray) -> tuple: svm = SVC(kernel=\'linear\', random_state=42) svm.fit(features, target) predictions = svm.predict(test_features) accuracy = accuracy_score(test_target, predictions) f1 = f1_score(test_target, predictions) return accuracy, f1 def main() -> None: features, labels = data_preprocessing(dataset) x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=0.25, random_state=42) accuracy, f1 = svm_classifier(x_train, y_train, x_test, y_test) print(f\\"Accuracy: {accuracy}\\") print(f\\"F1 Score: {f1}\\") if __name__ == \\"__main__\\": main() ``` # Expected Results You should expect the following error metrics: - **Accuracy**: ~1.0 - **F1 Score**: ~1.0 Note: The results may vary slightly due to the small dataset provided as an example. For a real-world application, use a larger and more comprehensive dataset for meaningful evaluation.","solution":"import numpy as np from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.metrics import accuracy_score, f1_score from sklearn.model_selection import train_test_split from sklearn.svm import SVC def data_preprocessing(dataset: list) -> tuple: Preprocesses the dataset by tokenizing text and extracting features using TF-IDF vectorization. Parameters: dataset (list): A list of tuples where each tuple contains a text and its corresponding sentiment label. Returns: tuple: A tuple containing the feature data as an array and the target labels as an array. texts, labels = zip(*dataset) tfidf = TfidfVectorizer(stop_words=\'english\') features = tfidf.fit_transform(texts) return features.toarray(), np.array(labels) def svm_classifier(features: np.ndarray, target: np.ndarray, test_features: np.ndarray, test_target: np.ndarray) -> tuple: Initializes and trains an SVM classifier, and evaluates its performance based on accuracy and F1 score. Parameters: features (np.ndarray): Training feature data. target (np.ndarray): Training target labels. test_features (np.ndarray): Testing feature data. test_target (np.ndarray): Testing target labels. Returns: tuple: A tuple containing the accuracy and F1 score of the predictions. svm = SVC(kernel=\'linear\', random_state=42) svm.fit(features, target) predictions = svm.predict(test_features) accuracy = accuracy_score(test_target, predictions) f1 = f1_score(test_target, predictions) return accuracy, f1 def main() -> None: The main function that loads the dataset, preprocesses the data, splits it into training and testing sets, trains the SVM classifier and evaluates its performance. # Sample dataset dataset = [ (\\"I loved the movie, it was fantastic!\\", 1), (\\"The film was terrible, I hated it.\\", 0), (\\"Best movie ever!\\", 1), (\\"Worst film I\'ve seen, do not recommend.\\", 0) ] features, labels = data_preprocessing(dataset) x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=0.25, random_state=42) accuracy, f1 = svm_classifier(x_train, y_train, x_test, y_test) print(f\\"Accuracy: {accuracy}\\") print(f\\"F1 Score: {f1}\\") if __name__ == \\"__main__\\": main()"},{"question":"# Question: Cache System with Expiry Implementation You are tasked with implementing a simple cache system that stores key-value pairs with a time-to-live (TTL) expiry mechanism. Once a key\'s TTL has expired, it should no longer be retrievable from the cache. **Objectives:** 1. Implement a class `Cache` with the following methods: - `put(key: str, value: any, ttl: int) -> None`: Stores the key-value pair in the cache with a specified TTL (in seconds). If the key already exists, update the value and reset the TTL. - `get(key: str) -> any`: Retrieves the value associated with the key if it exists and has not expired. If the key does not exist or has expired, raise a `KeyError` with a custom message \\"Key not found\\". 2. Ensure proper handling of expired keys and concurrent access to the cache. **Constraints:** - TTL is always a positive integer. - For this exercise, you can assume the environment has a reliable way to track time. **Function Signatures:** - `class Cache:` - `def __init__(self) -> None:` - `def put(self, key: str, value: any, ttl: int) -> None:` - `def get(self, key: str) -> any:` **Example Usage:** ```python import time cache = Cache() cache.put(\\"key1\\", \\"value1\\", 2) time.sleep(1) # Wait for 1 second print(cache.get(\\"key1\\")) # Output: \\"value1\\" cache.put(\\"key2\\", \\"value2\\", 1) time.sleep(2) # Wait for 2 seconds try: print(cache.get(\\"key2\\")) except KeyError as e: print(e) # Output: \\"Key not found\\" cache.put(\\"key3\\", \\"value3\\", 3) time.sleep(2) print(cache.get(\\"key3\\")) # Output: \\"value3\\" time.sleep(2) try: print(cache.get(\\"key3\\")) except KeyError as e: print(e) # Output: \\"Key not found\\" ``` Your task is to implement the `Cache` class ensuring it operates as described and handles key expiry correctly.","solution":"import time import threading class Cache: def __init__(self) -> None: self.store = {} self.lock = threading.Lock() def put(self, key: str, value: any, ttl: int) -> None: expiry_time = time.time() + ttl with self.lock: self.store[key] = (value, expiry_time) def get(self, key: str) -> any: with self.lock: if key in self.store: value, expiry_time = self.store[key] if time.time() <= expiry_time: return value else: # Key has expired, remove it from the store del self.store[key] raise KeyError(\\"Key not found\\") else: raise KeyError(\\"Key not found\\")"},{"question":"# Coding Challenge: Implement the File System Simulation Context A file system is a logical collection of files on a storage device that organizes data in a way that makes it easy to manage, access, and modify. File systems often simulate complex operations such as file creation, deletion, reading, and writing. Task Implement a basic file system simulation using the provided `FileSystem` class template. You will complete the following key methods: 1. **`create_file`** - Creates a new file with a specified name and size. 2. **`delete_file`** - Deletes an existing file by name. 3. **`read_file`** - Returns the content of a file by name. 4. **`write_file`** - Writes content to an existing file by name. 5. **`list_files`** - Lists all files in the file system with their sizes. 6. **Helper Methods**: - `validate_file_name` - `has_sufficient_space` - `is_file_exists` Requirements 1. **Function Signatures**: - `create_file`: `(self, file_name: str, size: int) -> str` - `delete_file`: `(self, file_name: str) -> str` - `read_file`: `(self, file_name: str) -> str` - `write_file`: `(self, file_name: str, content: str) -> str` - `list_files`: `(self) -> list` 2. **Input/Output**: - Input: Instructions to create, delete, read, or write files along with file names and sizes/content. - Output: Confirmation messages for creating, deleting, and writing files; file content for reading; list of files for listing. 3. **Performance**: - Ensure that file operations efficiently manage storage space and handle invalid operations gracefully. 4. **Constraints**: - File names are non-empty strings without special characters. - File sizes are positive integers. - Total storage capacity is limited and should be predefined. Example ```python class FileSystem: def __init__(self, capacity: int): self.capacity = capacity self.used_space = 0 self.files = {} # Dictionary to store file_name as key and content as value def validate_file_name(self, file_name: str) -> bool: if file_name and file_name.isalnum(): return True return False def has_sufficient_space(self, size: int) -> bool: if self.used_space + size <= self.capacity: return True return False def is_file_exists(self, file_name: str) -> bool: return file_name in self.files def create_file(self, file_name: str, size: int) -> str: if self.is_file_exists(file_name): return f\\"File \'{file_name}\' already exists.\\" if not self.validate_file_name(file_name): return \\"Invalid file name.\\" if not self.has_sufficient_space(size): return \\"Insufficient storage space.\\" self.files[file_name] = \'\' # Initialize file with empty content self.used_space += size return f\\"File \'{file_name}\' created.\\" def delete_file(self, file_name: str) -> str: if not self.is_file_exists(file_name): return f\\"File \'{file_name}\' does not exist.\\" del self.files[file_name] return f\\"File \'{file_name}\' deleted.\\" def read_file(self, file_name: str) -> str: if not self.is_file_exists(file_name): return f\\"File \'{file_name}\' does not exist.\\" return self.files[file_name] def write_file(self, file_name: str, content: str) -> str: if not self.is_file_exists(file_name): return f\\"File \'{file_name}\' does not exist.\\" self.files[file_name] = content return f\\"Content written to \'{file_name}\'.\\" def list_files(self) -> list: return list(self.files.keys()) if __name__ == \\"__main__\\": fs = FileSystem(100) print(fs.create_file(\\"file1\\", 20)) # File \'file1\' created. print(fs.create_file(\\"file2\\", 30)) # File \'file2\' created. print(fs.write_file(\\"file1\\", \\"Hello, World!\\")) # Content written to \'file1\'. print(fs.read_file(\\"file1\\")) # Hello, World! print(fs.list_files()) # [\'file1\', \'file2\'] print(fs.delete_file(\\"file1\\")) # File \'file1\' deleted. print(fs.list_files()) # [\'file2\'] print(fs.delete_file(\\"file3\\")) # File \'file3\' does not exist. ```","solution":"class FileSystem: def __init__(self, capacity: int): self.capacity = capacity self.used_space = 0 self.files = {} # Dictionary to store file_name as key and content as value def validate_file_name(self, file_name: str) -> bool: return file_name.isalnum() def has_sufficient_space(self, size: int) -> bool: return (self.used_space + size) <= self.capacity def is_file_exists(self, file_name: str) -> bool: return file_name in self.files def create_file(self, file_name: str, size: int) -> str: if not self.validate_file_name(file_name): return \\"Invalid file name.\\" if self.is_file_exists(file_name): return f\\"File \'{file_name}\' already exists.\\" if not self.has_sufficient_space(size): return \\"Insufficient storage space.\\" self.files[file_name] = \\"\\" # Initialize file with empty content self.used_space += size return f\\"File \'{file_name}\' created.\\" def delete_file(self, file_name: str) -> str: if not self.is_file_exists(file_name): return f\\"File \'{file_name}\' does not exist.\\" size = len(self.files[file_name]) del self.files[file_name] self.used_space -= size return f\\"File \'{file_name}\' deleted.\\" def read_file(self, file_name: str) -> str: if not self.is_file_exists(file_name): return f\\"File \'{file_name}\' does not exist.\\" return self.files[file_name] def write_file(self, file_name: str, content: str) -> str: if not self.is_file_exists(file_name): return f\\"File \'{file_name}\' does not exist.\\" size_difference = len(content) - len(self.files[file_name]) if not self.has_sufficient_space(size_difference): return \\"Insufficient storage space.\\" self.files[file_name] = content self.used_space += size_difference return f\\"Content written to \'{file_name}\'.\\" def list_files(self) -> list: return [(file_name, len(content)) for file_name, content in self.files.items()]"},{"question":"# Background Numerical integration is a common task in scientific computing, where an approximate value of an integral is computed. The Trapezoidal Rule is a numerical method used to evaluate definite integrals, providing a good balance between simplicity and accuracy. # Task Write a function `integrate_trapezoidal(func: Callable[[float], float], a: float, b: float, n: int) -> float` that performs numerical integration using the Trapezoidal Rule. The function should: 1. Approximate the integral of the provided function `func` over the interval [a, b]. 2. Use `n` equally spaced intervals. # Function Signature ```python def integrate_trapezoidal(func: Callable[[float], float], a: float, b: float, n: int) -> float: pass ``` # Input * `func` (Callable[[float], float]): A function to integrate, which takes a single float and returns a float. * `a` (float): The start of the interval of integration. * `b` (float): The end of the interval of integration. * `n` (int): The number of sub-intervals to use (must be a positive integer). # Output A single float representing the approximate value of the integral over [a, b] using the trapezoidal rule. # Constraints 1. `a` and `b` can take any float values where (a < b). 2. `n` must be a positive integer. 3. Handle invalid inputs by raising an appropriate error. # Example Usage ```python from math import sin, pi def my_func(x: float) -> float: return sin(x) result = integrate_trapezoidal(my_func, 0, pi, 100) print(result) # Expected value close to 2, as the integral of sin(x) from 0 to pi is 2. ``` # Performance Requirements * The solution should be efficient in terms of time complexity with respect to the number of intervals `n`. # Notes - The Trapezoidal Rule approximation is given by: [ int_{a}^{b} f(x) dx approx frac{b-a}{2n} left[ f(a) + 2 sum_{i=1}^{n-1} fleft(a + i frac{b-a}{n}right) + f(b) right] ] - Ensure to test the function with different types of integrand functions and various interval lengths to validate the accuracy of the approximation.","solution":"from typing import Callable def integrate_trapezoidal(func: Callable[[float], float], a: float, b: float, n: int) -> float: if n <= 0: raise ValueError(\\"Number of intervals n must be a positive integer.\\") if a >= b: raise ValueError(\\"The start of the interval a must be less than the end b.\\") h = (b - a) / n integral = 0.5 * (func(a) + func(b)) for i in range(1, n): integral += func(a + i * h) integral *= h return integral"},{"question":"# Sorting Efficiently with a Custom Comparator **Context**: Sorting is a fundamental aspect of computer science, used in various applications ranging from data analysis to algorithm optimization. Python provides powerful in-built sorting capabilities through the `sorted()` function and the `list.sort()` method. To extend the sorting functionality, Python also allows the use of custom comparator functions. In this exercise, you will implement efficient sorting of a list of tuples based on their second element using a custom comparator and Python\'s sorting mechanisms. **Task**: 1. Implement a comparator function to help sort tuples based on their second element. 2. Use this custom comparator with Python’s `sorted()` function, and verify its correctness. 3. Implement a function to compare the manually-sorted list versus the Python-sorted list and validate the outcome. **Requirements**: 1. **Function 1**: `custom_comparator(a: tuple, b: tuple) -> int` - For tuples `a` and `b`, return -1 if the second element of `a` is less than the second element of `b`, 1 if greater, and 0 if they are equal. 2. **Function 2**: `sort_tuples(tuples_list: list) -> list` - Use the custom comparator to sort the list of tuples in non-decreasing order of their second elements. 3. **Function 3**: `validate_sorting(original_list: list, sorted_list: list) -> bool` - Compare the manually sorted list with the sorted list obtained using Python’s in-built `sorted()` function (using the custom comparator). - Return `True` if the lists are identical, else return `False`. **Performance Requirements**: - Both sorting methods should perform in ( O(n log n) ) time complexity. **Constraints**: - The input list contains up to ( 10^5 ) tuples. - Each tuple consists of two integers, and the second integer can be within the range ([-10^6, 10^6]). ```python from typing import List, Tuple def custom_comparator(a: Tuple[int, int], b: Tuple[int, int]) -> int: if a[1] < b[1]: return -1 elif a[1] > b[1]: return 1 else: return 0 def sort_tuples(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: return sorted(tuples_list, key=lambda x: x[1]) def validate_sorting(original_list: List[Tuple[int, int]], sorted_list: List[Tuple[int, int]]) -> bool: manual_sorted_list = sort_tuples(original_list) return manual_sorted_list == sorted_list # Example Usage: # original = [(1, 3), (2, 1), (3, 2)] # sorted_list = sort_tuples(original) # print(validate_sorting(original, sorted_list)) # Output should be True ```","solution":"from typing import List, Tuple def custom_comparator(a: Tuple[int, int], b: Tuple[int, int]) -> int: if a[1] < b[1]: return -1 elif a[1] > b[1]: return 1 else: return 0 def sort_tuples(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: return sorted(tuples_list, key=lambda x: x[1]) def validate_sorting(original_list: List[Tuple[int, int]], sorted_list: List[Tuple[int, int]]) -> bool: manually_sorted_list = sorted(original_list, key=lambda x: x[1]) return manually_sorted_list == sorted_list"}]'),O={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},R={class:"search-container"},F={class:"card-container"},L={key:0,class:"empty-state"},N=["disabled"],D={key:0},z={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",R,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",z,"Loading...")):(n(),i("span",D,"See more"))],8,N)):u("",!0)])}const Y=h(O,[["render",P],["__scopeId","data-v-01e69786"]]),V=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/48.md","filePath":"quotes/48.md"}'),j={name:"quotes/48.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{V as __pageData,U as default};
