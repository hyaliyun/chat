import{_ as c,o as s,c as r,a as t,m as _,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},A={class:"review-content"};function R(n,e,u,m,i,a){return s(),r("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(d(u.poem.solution),1)])])])}const N=c(k,[["render",R],["__scopeId","data-v-730b8701"]]),F=JSON.parse(`[{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing only positive integers and +, -, *, considering operator precedence and ignoring whitespace. Args: expression (str): A string representing the mathematical expression. Returns: int: The result of evaluating the expression. Examples: >>> evaluate_expression(\\"3 + 5 * 2 - 4\\") 9 >>> evaluate_expression(\\"10 + 2 * 6\\") 22 >>> evaluate_expression(\\"100 * 2 + 12\\") 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400 >>> evaluate_expression(\\"10 - (2 + 3) * 2\\") 0 >>> evaluate_expression(\\"2 * (5 + 5 - 3) * 2\\") 28","solution":"def evaluate_expression(expression): Evaluate a mathematical expression containing only positive integers and +, -, *, considering operator precedence and ignoring whitespace. def calculate(ops, values): rhs = values.pop() lhs = values.pop() op = ops.pop() if op == '+': values.append(lhs + rhs) elif op == '-': values.append(lhs - rhs) elif op == '*': values.append(lhs * rhs) def precedence(op): if op in ('+', '-'): return 1 if op == '*': return 2 return 0 ops = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue elif expression[i] == '(': ops.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(ops) != 0 and ops[-1] != '(': calculate(ops, values) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(expression[i])): calculate(ops, values) ops.append(expression[i]) i += 1 while len(ops) != 0: calculate(ops, values) return values[-1]"},{"question":"def smallest_string_with_abc(n: int) -> str: Returns the lexicographically smallest string of length n that contains at least one 'a', one 'b', and one 'c'. It uses only the characters 'a', 'b', and 'c'. Examples: >>> smallest_string_with_abc(3) 'abc' >>> smallest_string_with_abc(4) 'aabc' >>> smallest_string_with_abc(5) 'aaabc' >>> smallest_string_with_abc(7) 'aaaaabc' >>> smallest_string_with_abc(10) 'aaaaaaaabc'","solution":"def smallest_string_with_abc(n: int) -> str: Returns the lexicographically smallest string of length n that contains at least one 'a', one 'b', and one 'c'. It uses only the characters 'a', 'b', and 'c'. # Base length is 3 for the minimum requirement 'a', 'b', and 'c' # For minimal lexicographic order, we begin with repeated 'a' followed by 'b' and 'c' if n == 3: return \\"abc\\" else: return \\"a\\" * (n - 2) + \\"bc\\""},{"question":"def cyberville_cipher(text: str, shift: int) -> str: Encrypts the given text by shifting the letters by the specified number of positions in the alphabet, wrapping around if necessary. Only letters are shifted; all other characters remain unchanged. Parameters: text (str): The string to be encrypted. shift (int): The number of positions each letter in the string is to be shifted. Returns: str: The encrypted string. >>> cyberville_cipher('Hello, World!', 3) 'Khoor, Zruog!' >>> cyberville_cipher('Python 3.9', 5) 'Udymts 3.9'","solution":"def cyberville_cipher(text, shift): Encrypts the given text by shifting the letters by the specified number of positions in the alphabet, wrapping around if necessary. Only letters are shifted; all other characters remain unchanged. Parameters: text (str): The string to be encrypted. shift (int): The number of positions each letter in the string is to be shifted. Returns: str: The encrypted string. def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) return c return ''.join(shift_char(c, shift) for c in text)"},{"question":"def to_snake_case(s: str) -> str: Convert a given PascalCase string to snake_case. :param s: The PascalCase string :return: The snake_case string >>> to_snake_case(\\"ThisIsAnExample\\") 'this_is_an_example' >>> to_snake_case(\\"WhereIsMyCamel\\") 'where_is_my_camel' >>> to_snake_case(\\"AnotherExample\\") 'another_example'","solution":"def to_snake_case(s): Convert a given PascalCase string to snake_case. :param s: The PascalCase string :return: The snake_case string result = [] for char in s: if char.isupper(): if result: # Add underscore if result is not empty result.append('_') result.append(char.lower()) else: result.append(char) return ''.join(result)"},{"question":"class TextEditor: def __init__(self): Initialize the state pass def append(self, string): Appends the given string to the end of the current text. pass def delete(self, n): Deletes the last 'n' characters from the current text. pass def undo(self): Undoes the last operation (either append or delete). pass def redo(self): Redoes the last undone operation. pass def get_text(self): Returns the current state of the text. pass # Example Usage editor = TextEditor() editor.append(\\"Hello\\") editor.append(\\" World\\") editor.delete(6) editor.undo() editor.redo() # Unit Tests def test_append(): editor = TextEditor() editor.append(\\"Hello\\") assert editor.get_text() == \\"Hello\\" editor.append(\\" World\\") assert editor.get_text() == \\"Hello World\\" def test_delete(): editor = TextEditor() editor.append(\\"Hello World\\") editor.delete(6) assert editor.get_text() == \\"Hello\\" editor.delete(5) assert editor.get_text() == \\"\\" def test_undo(): editor = TextEditor() editor.append(\\"Hello\\") editor.append(\\" World\\") editor.delete(6) editor.undo() assert editor.get_text() == \\"Hello World\\" editor.undo() assert editor.get_text() == \\"Hello\\" editor.undo() assert editor.get_text() == \\"\\" def test_redo(): editor = TextEditor() editor.append(\\"Hello\\") editor.append(\\" World\\") editor.undo() assert editor.get_text() == \\"Hello\\" editor.redo() assert editor.get_text() == \\"Hello World\\" editor.undo() editor.undo() editor.redo() assert editor.get_text() == \\"Hello\\" editor.redo() assert editor.get_text() == \\"Hello World\\" def test_mixed_operations(): editor = TextEditor() editor.append(\\"Hello\\") editor.delete(2) assert editor.get_text() == \\"Hel\\" editor.undo() assert editor.get_text() == \\"Hello\\" editor.redo() assert editor.get_text() == \\"Hel\\" editor.append(\\"lo World\\") editor.undo() assert editor.get_text() == \\"Hel\\" editor.undo() assert editor.get_text() == \\"Hello\\" editor.redo() editor.redo() assert editor.get_text() == \\"Hello World\\"","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] self.redo_stack = [] def append(self, string): self.history.append(self.text) self.text += string self.redo_stack = [] # clear redo stack when new changes are made def delete(self, n): self.history.append(self.text) self.text = self.text[:-n] self.redo_stack = [] # clear redo stack when new changes are made def undo(self): if self.history: self.redo_stack.append(self.text) self.text = self.history.pop() def redo(self): if self.redo_stack: self.history.append(self.text) self.text = self.redo_stack.pop() def get_text(self): return self.text"},{"question":"def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Calculate the number of unique paths in a grid with obstacles. Given a grid represented as a list of lists of integers, where 1 represents an obstacle and 0 represents an empty cell, this function calculates the number of unique paths from the top-left corner of the grid to the bottom-right corner, while only being able to move either down or right. >>> uniquePathsWithObstacles([ ... [0,0,0], ... [0,1,0], ... [0,0,0] ... ]) 2 >>> uniquePathsWithObstacles([ ... [0,1], ... [0,0] ... ]) 1 pass from typing import List def test_example1(): grid = [ [0,0,0], [0,1,0], [0,0,0] ] assert uniquePathsWithObstacles(grid) == 2 def test_example2(): grid = [ [0,1], [0,0] ] assert uniquePathsWithObstacles(grid) == 1 def test_starting_obstacle(): grid = [ [1,0], [0,0] ] assert uniquePathsWithObstacles(grid) == 0 def test_ending_obstacle(): grid = [ [0,0], [0,1] ] assert uniquePathsWithObstacles(grid) == 0 def test_single_cell_no_obstacle(): grid = [ [0] ] assert uniquePathsWithObstacles(grid) == 1 def test_grid_filled_with_obstacles(): grid = [ [0,1,0], [1,1,0], [0,0,0] ] assert uniquePathsWithObstacles(grid) == 0","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid considering obstacles. :param obstacleGrid: List[List[int]] - 2D list representing the grid :return: int - number of unique paths if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 rows = len(obstacleGrid) cols = len(obstacleGrid[0]) # Initialize the DP array with zeros dp = [[0]*cols for _ in range(rows)] # Initialize the starting point dp[0][0] = 1 # Fill in the dp array for i in range(rows): for j in range(cols): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[rows-1][cols-1]"},{"question":"from typing import List def can_reach_target(n: int, m: int, grid: List[str], sx: int, sy: int, tx: int, ty: int, k: int) -> str: Determines whether the drone can reach the target cell within the given number of moves without recharging. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): The grid representing the delivery area. sx (int): Starting cell x-coordinate (1-based). sy (int): Starting cell y-coordinate (1-based). tx (int): Target cell x-coordinate (1-based). ty (int): Target cell y-coordinate (1-based). k (int): Maximum number of moves the drone can make. Returns: str: \\"YES\\" if the drone can reach the target cell within k moves, \\"NO\\" otherwise. >>> can_reach_target(5, 5, [\\".#...\\", \\"...#.\\", \\".#.#.\\", \\"...#.\\", \\".....\\"], 1, 1, 5, 5, 10) 'YES' >>> can_reach_target(5, 5, [\\".....\\", \\".....\\", \\".#.\\", \\".....\\", \\".....\\"], 1, 1, 5, 5, 6) 'NO' def test_can_reach_target(): n, m = 5, 5 grid = [ \\".#...\\", \\"...#.\\", \\".#.#.\\", \\"...#.\\", \\".....\\" ] assert can_reach_target(n, m, grid, 1, 1, 5, 5, 10) == \\"YES\\" assert can_reach_target(n, m, grid, 1, 1, 5, 5, 9) == \\"YES\\" grid = [ \\".....\\", \\".....\\", \\".#.\\", \\".....\\", \\".....\\" ] assert can_reach_target(n, m, grid, 1, 1, 5, 5, 6) == \\"NO\\" assert can_reach_target(n, m, grid, 1, 1, 5, 5, 10) == \\"YES\\" n, m = 1, 1 grid = [ \\".\\" ] assert can_reach_target(n, m, grid, 1, 1, 1, 1, 0) == \\"YES\\" n, m = 2, 2 grid = [ \\".#\\", \\"#.\\" ] assert can_reach_target(n, m, grid, 1, 1, 2, 2, 3) == \\"NO\\"","solution":"from collections import deque def can_reach_target(n, m, grid, sx, sy, tx, ty, k): # Converting to 0-index sx -= 1 sy -= 1 tx -= 1 ty -= 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False for _ in range(m)] for __ in range(n)] queue = deque([(sx, sy, 0)]) while queue: x, y, moves = queue.popleft() if moves > k: break # No point in continuing if we exceed k moves if x == tx and y == ty: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, moves + 1)) return \\"NO\\""},{"question":"def increment_list(lst): Returns a new list with each integer in the input list increased by 1. >>> increment_list([1, 2, 3]) [2, 3, 4] >>> increment_list([5, -1, 0]) [6, 0, 1] >>> increment_list([-5, -2, -3]) [-4, -1, -2] >>> increment_list([]) [] >>> increment_list([0]) [1] >>> increment_list([10]) [11] >>> increment_list([-1]) [0]","solution":"def increment_list(lst): Returns a new list with each integer in the input list increased by 1. :param lst: A list of integers :return: A new list with each integer increased by 1 return [x + 1 for x in lst]"},{"question":"def min_total_time(widgets): Determines the minimum total time required for each widget to be fully processed through their sequences of machines. Parameters: widgets (list): A list where each element is a list containing the sequence of (machine_id, time) pairs for a widget. Returns: list: A list containing the minimum total time for each widget. pass # Test cases def test_single_widget_single_machine(): assert min_total_time([[(1, 500)]]) == [500] def test_single_widget_multiple_machines(): assert min_total_time([[(1, 500), (2, 1000), (3, 1500)]]) == [3000] def test_multiple_widgets_single_machine_each(): assert min_total_time([[(1, 500)], [(2, 1000)], [(3, 1500)]]) == [500, 1000, 1500] def test_multiple_widgets_multiple_machines(): assert min_total_time([[(1, 500), (2, 1000)], [(3, 1500), (4, 2000)]]) == [1500, 3500] def test_empty_widget_list(): assert min_total_time([]) == []","solution":"def min_total_time(widgets): Determines the minimum total time required for each widget to be fully processed through their sequences of machines. Parameters: widgets (list): A list where each element is a list containing the sequence of (machine_id, time) pairs for a widget. Returns: list: A list containing the minimum total time for each widget. result = [] for widget in widgets: total_time = sum(time for machine_id, time in widget) result.append(total_time) return result"},{"question":"def canWatchMovie(age: int, withAdult: bool) -> bool: Determines if a person can watch a PG-13 movie based on their age and whether they are accompanied by an adult. Parameters: age (int): The age of the person. withAdult (bool): Whether the person is accompanied by an adult. Returns: bool: True if allowed to watch the movie, False otherwise. >>> canWatchMovie(14, False) == True >>> canWatchMovie(13, False) == True >>> canWatchMovie(12, False) == False >>> canWatchMovie(12, True) == True >>> canWatchMovie(10, True) == True >>> canWatchMovie(10, False) == False # Write your code here","solution":"def canWatchMovie(age, withAdult): Determines if a person can watch a PG-13 movie based on their age and whether they are accompanied by an adult. Parameters: age (int): The age of the person. withAdult (bool): Whether the person is accompanied by an adult. Returns: bool: True if allowed to watch the movie, False otherwise. return age >= 13 or withAdult"},{"question":"def check_prime(n: int) -> str: Determines if the given integer n is a prime number. Returns \\"Prime\\" if n is a prime number and \\"Not Prime\\" otherwise. >>> check_prime(2) 'Prime' >>> check_prime(4) 'Not Prime' >>> check_prime(17) 'Prime' >>> check_prime(1) 'Not Prime' >>> check_prime(-5) 'Not Prime'","solution":"def check_prime(n): Determines if the given integer n is a prime number. Returns \\"Prime\\" if n is a prime number and \\"Not Prime\\" otherwise. if n <= 1: return \\"Not Prime\\" if n == 2: return \\"Prime\\" if n % 2 == 0: return \\"Not Prime\\" for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return \\"Not Prime\\" return \\"Prime\\""},{"question":"def separate_strings_and_integers(lst): Separates strings and integers from a mixed list while preserving their original order. Args: lst (list): A list containing strings and integers in mixed order. Returns: tuple: A tuple containing two lists - one with integers and one with strings. Examples: >>> separate_strings_and_integers([1, \\"a\\", 3, \\"b\\", 2, \\"c\\", \\"d\\", 4]) ([1, 3, 2, 4], [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) >>> separate_strings_and_integers([7, \\"x\\", \\"y\\", 8]) ([7, 8], [\\"x\\", \\"y\\"]) >>> separate_strings_and_integers([\\"x\\", \\"y\\", \\"z\\"]) ([], [\\"x\\", \\"y\\", \\"z\\"]) >>> separate_strings_and_integers([0, 1, 2]) ([0, 1, 2], []) >>> separate_strings_and_integers([]) ([], [])","solution":"def separate_strings_and_integers(lst): Separates strings and integers from a mixed list while preserving their original order. Args: lst (list): A list containing strings and integers in mixed order. Returns: tuple: A tuple containing two lists - one with integers and one with strings. integers = [item for item in lst if isinstance(item, int)] strings = [item for item in lst if isinstance(item, str)] return (integers, strings)"},{"question":"def rearrange_string(s: str) -> str: Rearranges the characters of the string such that no two adjacent characters are the same. If it is not possible to rearrange the string, returns an empty string. >>> rearrange_string(\\"aabbcc\\") \\"abcabc\\" >>> rearrange_string(\\"aaab\\") \\"\\" >>> rearrange_string(\\"aaabbbccc\\") \\"abcabcabc\\" >>> rearrange_string(\\"aaa\\") \\"\\" >>> rearrange_string(\\"aab\\") \\"aba\\"","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the characters of the string such that no two adjacent characters are the same. If it is not possible to rearrange the string, returns an empty string. freq = Counter(s) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) result = [] prev_count, prev_char = 0, '' while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged_str = ''.join(result) return rearranged_str if len(rearranged_str) == len(s) else \\"\\" # Test case examples print(rearrange_string(\\"aabbcc\\")) # Example output: \\"abcabc\\" print(rearrange_string(\\"aaab\\")) # Example output: \\"\\" print(rearrange_string(\\"aaabbbccc\\")) # Example output: \\"abcabcabc\\" print(rearrange_string(\\"aaa\\")) # Example output: \\"\\" print(rearrange_string(\\"aab\\")) # Example output: \\"aba\\""},{"question":"from collections import deque, defaultdict from typing import List, Tuple def find_order(num_levels: int, dependencies: List[Tuple[int, int]]) -> str: Determine the order of levels to be completed based on dependencies. Args: - num_levels: int : Number of levels - dependencies: List[Tuple[int, int]] : List of dependencies (U, V) indicating level U must be completed before level V Returns: - str: A string with the levels in the order they should be completed, separated by spaces. \\"impossible\\" if there is a cyclic dependency. Example: >>> find_order(4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 'impossible' >>> find_order(3, [(3, 2), (1, 3)]) '1 3 2' pass def order_levels(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Processes multiple test cases and determine the order of levels for each. Args: - test_cases: List[Tuple[int, int, List[Tuple[int, int]]]] : List of tuples, where each tuple contains: - Number of levels - Number of dependencies - List of dependencies Returns: - List[str]: A list of results for each test case. Example: >>> order_levels([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]), (3, 2, [(3, 2), (1, 3)])]) ['impossible', '1 3 2'] pass import pytest def test_order_levels_basic(): test_cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]), (3, 2, [(3, 2), (1, 3)]) ] expected_results = [\\"impossible\\", \\"1 3 2\\"] assert order_levels(test_cases) == expected_results def test_order_levels_no_dependencies(): test_cases = [ (3, 0, []) ] expected_results = [\\"1 2 3\\"] result = order_levels(test_cases)[0] result_set = set(map(int, result.split())) expected_set = set([1, 2, 3]) assert result_set == expected_set def test_order_levels_simple_dependency(): test_cases = [ (2, 1, [(1, 2)]) ] expected_results = [\\"1 2\\"] assert order_levels(test_cases) == expected_results def test_order_levels_multiple_valid_orders(): test_cases = [ (4, 3, [(1, 2), (1, 3), (3, 4)]) ] possible_results = [ \\"1 2 3 4\\", \\"1 3 2 4\\" ] assert order_levels(test_cases)[0] in possible_results def test_order_levels_large_case(): test_cases = [ (5, 4, [(1, 5), (2, 5), (3, 5), (4, 5)]) ] expected_results = [\\"1 2 3 4 5\\"] assert order_levels(test_cases) == expected_results","solution":"from collections import deque, defaultdict def find_order(num_levels, dependencies): in_degree = {i: 0 for i in range(1, num_levels + 1)} graph = defaultdict(list) for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 queue = deque([node for node in in_degree if in_degree[node] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == num_levels: return \\" \\".join(map(str, order)) else: return \\"impossible\\" def order_levels(test_cases): results = [] for num_levels, num_dependencies, dependencies in test_cases: result = find_order(num_levels, dependencies) results.append(result) return results"},{"question":"def isToeplitzMatrix(matrix: List[List[int]]) -> bool: Check if a matrix is Toeplitz. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. >>> isToeplitzMatrix([ ... [1,2,3,4], ... [5,1,2,3], ... [9,5,1,2] ... ]) == True >>> isToeplitzMatrix([ ... [1,2], ... [2,2] ... ]) == False","solution":"def isToeplitzMatrix(matrix): Returns True if the given matrix is a Toeplitz matrix, else False. m = len(matrix) n = len(matrix[0]) for i in range(m - 1): for j in range(n - 1): if matrix[i][j] != matrix[i + 1][j + 1]: return False return True"},{"question":"def find_majority(nums: List[int]) -> int: Determines the majority element in the list, if it exists. A majority element is an element that appears more than n/2 times in the list. If no majority element exists, returns -1. >>> find_majority([3, 2, 3]) == 3 >>> find_majority([2, 2, 1, 1, 1, 2, 2]) == 2 >>> find_majority([1, 2, 3, 4, 5]) == -1 >>> find_majority([1]) == 1 >>> find_majority([1, 1, 2]) == 1 >>> find_majority([1, 2, 2, 1, 3]) == -1 >>> find_majority([4]*100000) == 4","solution":"def find_majority(nums): Determines the majority element in the list, if it exists. A majority element is an element that appears more than n/2 times in the list. If no majority element exists, returns -1. count = {} n = len(nums) for num in nums: if num in count: count[num] += 1 else: count[num] = 1 if count[num] > n // 2: return num return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, targetSum: int) -> bool: Determine if there is a root-to-leaf path with the sum of node values equal to the target sum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> hasPathSum(root, 22) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> hasPathSum(root, 5) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, targetSum: int) -> bool: if not root: return False # if this is a leaf node, check if the path sum equals the targetSum if not root.left and not root.right: return root.val == targetSum # otherwise, subtract the current node's value from targetSum and check the remaining sum return (hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val))"},{"question":"def findInsertPosition(arr, value): Determines the index position at which a value should be inserted into a sorted (ascending) array to maintain its sorted order. Parameters: arr (list of int): A sorted list of integers. value (int): The value to be inserted. Returns: int: The index position where the value should be inserted. Examples: >>> findInsertPosition([1, 3, 5, 6], 5) 2 >>> findInsertPosition([1, 3, 5, 6], 2) 1","solution":"def findInsertPosition(arr, value): Determines the index position at which a value should be inserted into a sorted (ascending) array to maintain its sorted order. Parameters: arr (list of int): A sorted list of integers. value (int): The value to be inserted. Returns: int: The index position where the value should be inserted. left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < value: left = mid + 1 else: right = mid return left"},{"question":"from typing import List def canBreak(s: str, wordDict: List[str]) -> bool: Determine if a given string can be segmented into a space-separated sequence of one or more dictionary words. Args: s (str): The input string containing lowercase English letters. wordDict (List[str]): The list of unique words. Returns: bool: True if the string can be segmented into one or more dictionary words, False otherwise. Examples: >>> canBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> canBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> canBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False","solution":"from typing import List def canBreak(s: str, wordDict: List[str]) -> bool: word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # Base case: empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def canConstructWord(grid: List[List[str]], word: str) -> bool: Determine if the word can be constructed in the grid by sequentially adjacent characters. \\"Adjacent\\" characters are horizontally, vertically, or diagonally neighboring. The same letter cell may not be used more than once. >>> grid = [ ... ['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e'] ... ] >>> canConstructWord(grid, \\"abcced\\") True >>> canConstructWord(grid, \\"see\\") True >>> canConstructWord(grid, \\"abcb\\") False from typing import List def test_example_1(): grid = [ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ] assert canConstructWord(grid, \\"abcced\\") == True def test_example_2(): grid = [ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ] assert canConstructWord(grid, \\"see\\") == True def test_example_3(): grid = [ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ] assert canConstructWord(grid, \\"abcb\\") == False def test_single_letter_grid_word(): grid = [['a']] assert canConstructWord(grid, \\"a\\") == True def test_single_letter_grid_invalid_word(): grid = [['a']] assert canConstructWord(grid, \\"b\\") == False def test_diagonal_construct_word(): grid = [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ] assert canConstructWord(grid, \\"aei\\") == True def test_adjacent_cells(): grid = [ ['a', 'b', 'a'], ['b', 'a', 'b'], ['a', 'b', 'a'] ] assert canConstructWord(grid, \\"abababa\\") == True def test_no_valid_path(): grid = [ ['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p'] ] assert canConstructWord(grid, \\"abcdefgh\\") == False def test_word_larger_than_grid(): grid = [ ['a', 'b'], ['c', 'd'] ] assert canConstructWord(grid, \\"abcdabcd\\") == False","solution":"def canConstructWord(grid, word): rows, cols = len(grid), len(grid[0]) word_len = len(word) def is_valid(x, y, index, visited): if index == word_len: return True if x < 0 or y < 0 or x >= rows or y >= cols or (x, y) in visited: return False if grid[x][y] != word[index]: return False visited.add((x, y)) # Check all 8 possible directions (horizontally, vertically, diagonally) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for dx, dy in directions: if is_valid(x + dx, y + dy, index + 1, visited): return True visited.remove((x, y)) return False for i in range(rows): for j in range(cols): if grid[i][j] == word[0]: if is_valid(i, j, 0, set()): return True return False"},{"question":"def prime_factorization(n): Returns the prime factorization of a positive integer n as a dictionary where keys are the prime factors and values are their respective exponents. >>> prime_factorization(18) {2: 1, 3: 2} >>> prime_factorization(60) {2: 2, 3: 1, 5: 1} >>> prime_factorization(1) {} >>> prime_factorization(13) {13: 1} >>> prime_factorization(100) {2: 2, 5: 2} >>> prime_factorization(123456) {2: 6, 3: 1, 643: 1}","solution":"def prime_factorization(n): Returns the prime factorization of a positive integer n as a dictionary where keys are the prime factors and values are their respective exponents. factors = {} # Test for number of 2s count = 0 while n % 2 == 0: count += 1 n //= 2 if count > 0: factors[2] = count # Test for odd factors from 3 onwards factor = 3 while factor * factor <= n: count = 0 while n % factor == 0: count += 1 n //= factor if count > 0: factors[factor] = count factor += 2 # If n is still a prime number greater than 2 if n > 2: factors[n] = 1 return factors"},{"question":"import re from typing import List def passwordValidator(password: str) -> bool: Validates a password string based on specific criteria: - at least 8 characters long - contains at least one uppercase letter - contains at least one lowercase letter - contains at least one digit - contains at least one special character from the set: !@#%^&*()-_+= >>> passwordValidator(\\"Password123!\\") == True >>> passwordValidator(\\"password123!\\") == False >>> passwordValidator(\\"PASSWORD123!\\") == False >>> passwordValidator(\\"Password!\\") == False >>> passwordValidator(\\"Password123\\") == False >>> passwordValidator(\\"Pass12!\\") == False","solution":"import re def passwordValidator(password): Validates a password string based on specific criteria: - at least 8 characters long - contains at least one uppercase letter - contains at least one lowercase letter - contains at least one digit - contains at least one special character from the set: !@#%^&*()-_+= if len(password) < 8: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[0-9]', password): return False if not re.search(r'[!@#%^&*()-_+=]', password): return False return True"},{"question":"def find_unsorted_subarray_length(arr: List[int]) -> int: Given an array of integers, determine the length of the shortest contiguous subarray, that if sorted, would result in the entire array being sorted. Args: arr (List[int]): Array of integers to be analyzed. Returns: int: The length of the shortest subarray that needs to be sorted. Examples: >>> find_unsorted_subarray_length([2, 6, 4, 8, 10, 9, 15]) 5 >>> find_unsorted_subarray_length([1, 2, 3, 4, 5]) 0 from solution import find_unsorted_subarray_length def test_example_case(): assert find_unsorted_subarray_length([2, 6, 4, 8, 10, 9, 15]) == 5 def test_already_sorted_array(): assert find_unsorted_subarray_length([1, 2, 3, 4, 5]) == 0 def test_reverse_sorted_array(): assert find_unsorted_subarray_length([5, 4, 3, 2, 1]) == 5 def test_single_element_array(): assert find_unsorted_subarray_length([1]) == 0 def test_random_unsorted_subarray(): assert find_unsorted_subarray_length([1, 3, 5, 4, 2, 6, 7]) == 4 assert find_unsorted_subarray_length([2, 3, 3, 2, 4]) == 3 assert find_unsorted_subarray_length([1, 2, 5, 3, 4, 6]) == 3 def test_edge_case_min_max_at_ends(): assert find_unsorted_subarray_length([1, 3, 2, 4, 5]) == 2 assert find_unsorted_subarray_length([1, 2, 3, 5, 4]) == 2 assert find_unsorted_subarray_length([3, 1, 2, 5, 4]) == 5","solution":"def find_unsorted_subarray_length(arr): Returns the length of the shortest contiguous subarray which, if sorted, would result in the whole array being sorted. n = len(arr) left, right = 0, n - 1 # Find the first element out of order from the left while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # If the entire array is sorted if left == n - 1: return 0 # Find the first element out of order from the right while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Find the minimum and maximum of the subarray arr[left:right+1] subarray_min = min(arr[left:right + 1]) subarray_max = max(arr[left:right + 1]) # Extend the subarray to include any number that is greater than the minimum while left > 0 and arr[left - 1] > subarray_min: left -= 1 # Extend the subarray to include any number that is less than the maximum while right < n - 1 and arr[right + 1] < subarray_max: right += 1 return right - left + 1"},{"question":"def island_count(grid: List[List[int]]) -> int: Count the number of distinct islands in a given 2D grid. An island is made up of 1s (land) and is surrounded by water represented by 0s. The \\"islands\\" are connected horizontally or vertically, not diagonally. Args: grid: List[List[int]] - A 2D list of integers where 0 represents water and 1 represents land. Returns: int: The number of distinct islands in the grid. >>> island_count([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 0, 1, 1] ... ]) # 4 >>> island_count([ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) # 0 >>> island_count([ ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) # 1","solution":"def island_count(grid): Count the number of distinct islands in the given 2D grid. Args: - grid: List[List[int]] - A 2D list of integers where 0 represents water and 1 represents land. Returns: - int: The number of distinct islands in the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0: return grid[r][c] = 0 # Mark the land as visited by sinking it (setting it to 0) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Down, Up, Right, Left for dr, dc in directions: dfs(r + dr, c + dc) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Found an unvisited piece of land island_count += 1 dfs(r, c) return island_count"},{"question":"def diagonal_sum(matrix): Returns the sum of the main diagonal elements of a n x n matrix. >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 15 >>> diagonal_sum([[5, 3], [2, 4]]) == 9 >>> diagonal_sum([[7]]) == 7 >>> diagonal_sum([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == 34 >>> diagonal_sum([ [1, 2, 3], [4, -5, 6], [7, 8, -9] ]) == -13","solution":"def diagonal_sum(matrix): Returns the sum of the main diagonal elements of a n x n matrix. n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] return total_sum"},{"question":"import heapq def shortest_path(city_grid: dict, start: str, end: str) -> list: Returns the shortest path from start to end using Dijkstra's algorithm. :param city_grid: dict, A dictionary representing the city grid with edges and distances. :param start: str, The starting intersection. :param end: str, The destination intersection. :return: list, The shortest path from start to end. # ... (Implement the algorithm here) def test_shortest_path_direct(): city_grid = { 'A': [('B', 2)], 'B': [('A', 2)] } assert shortest_path(city_grid, 'A', 'B') == ['A', 'B'] def test_shortest_path_multiple_paths(): city_grid = { 'A': [('B', 2), ('D', 1)], 'B': [('A', 2), ('C', 4)], 'C': [('B', 4), ('D', 5)], 'D': [('A', 1), ('C', 5)] } assert shortest_path(city_grid, 'A', 'C') == ['A', 'B', 'C'] assert shortest_path(city_grid, 'D', 'B') == ['D', 'A', 'B'] def test_shortest_path_no_path(): city_grid = { 'A': [('B', 2)], 'B': [('A', 2)] } assert shortest_path(city_grid, 'A', 'C') == [] def test_shortest_path_start_equals_end(): city_grid = { 'A': [('B', 2), ('C', 3)], 'B': [('A', 2), ('C', 4)], 'C': [('A', 3), ('B', 4)] } assert shortest_path(city_grid, 'A', 'A') == ['A'] def test_shortest_path_complex(): city_grid = { 'A': [('B', 2), ('C', 3)], 'B': [('A', 2), ('D', 1)], 'C': [('A', 3), ('D', 5)], 'D': [('B', 1), ('C', 5), ('E', 1)], 'E': [('D', 1)] } assert shortest_path(city_grid, 'A', 'E') == ['A', 'B', 'D', 'E']","solution":"import heapq def shortest_path(city_grid, start, end): Returns the shortest path from start to end using Dijkstra's algorithm. :param city_grid: dict, A dictionary representing the city grid with edges and distances. :param start: str, The starting intersection. :param end: str, The destination intersection. :return: list, The shortest path from start to end. # Priority queue to store the vertices to be checked pq = [(0, start, [])] visited = set() while pq: (cost, current_node, path) = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) path = path + [current_node] if current_node == end: return path for neighbor, weight in city_grid.get(current_node, []): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) return [] # Example usage: # city_grid = { # 'A': [('B', 2), ('D', 1)], # 'B': [('A', 2), ('C', 4)], # 'C': [('B', 4), ('D', 5)], # 'D': [('A', 1), ('C', 5)], # } # print(shortest_path(city_grid, 'A', 'C')) # ==> ['A', 'B', 'C'] # print(shortest_path(city_grid, 'D', 'B')) # ==> ['D', 'A', 'B']"},{"question":"def sort_colors(nums): Sort an array containing only integers 0, 1, and 2 using a single pass algorithm with constant space. Args: nums: List[int] --> list of integers that only contains 0, 1, and 2 Returns: None. The list should be sorted in place. Example: >>> nums = [2, 0, 2, 1, 1, 0] >>> sort_colors(nums) >>> print(nums) # Output: [0, 0, 1, 1, 2, 2] # Your code here # Unit tests def test_sort_colors_sorted(): nums = [0, 1, 2] sort_colors(nums) assert nums == [0, 1, 2] def test_sort_colors_reverse_sorted(): nums = [2, 1, 0] sort_colors(nums) assert nums == [0, 1, 2] def test_sort_colors_mixed(): nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) assert nums == [0, 0, 1, 1, 2, 2] def test_sort_colors_already_sorted(): nums = [0, 0, 1, 1, 2, 2] sort_colors(nums) assert nums == [0, 0, 1, 1, 2, 2] def test_sort_colors_single_element(): nums = [1] sort_colors(nums) assert nums == [1] def test_sort_colors_two_elements(): nums = [2, 0] sort_colors(nums) assert nums == [0, 2] def test_sort_colors_all_same_element(): nums = [2, 2, 2] sort_colors(nums) assert nums == [2, 2, 2]","solution":"def sort_colors(nums): Sorts the list containing only integers 0, 1, and 2 in-place. Args: nums: List[int] --> list of integers that only contains 0, 1, and 2 Returns: None. The list should be sorted in place. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"def longest_common_prefix(strs: List[str]) -> str: Returns the longest common prefix of the given list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"same\\", \\"same\\", \\"same\\"]) 'same' >>> longest_common_prefix([\\"single\\"]) 'single' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"ab\\", \\"a\\"]) 'a' >>> longest_common_prefix([\\"abcd\\", \\"abce\\", \\"abcdefg\\"]) 'abc'","solution":"def longest_common_prefix(strs): Returns the longest common prefix of the given list of strings. if not strs: return \\"\\" # Find the shortest string in the list min_length_str = min(strs, key=len) for i in range(len(min_length_str)): char = min_length_str[i] if not all(s[i] == char for s in strs): return min_length_str[:i] return min_length_str # Example usage: # n = int(input()) # strs = [input().strip() for _ in range(n)] # print(longest_common_prefix(strs))"},{"question":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the unsorted integer array. >>> find_smallest_missing_positive([]) == 1 True >>> find_smallest_missing_positive([1, 2, 3, 4, 5]) == 6 True >>> find_smallest_missing_positive([3, 4, -1, 1]) == 2 True >>> find_smallest_missing_positive([1, 2, 0]) == 3 True >>> find_smallest_missing_positive([1, 1, 1, 1, 2]) == 3 True >>> find_smallest_missing_positive([100, 200, 300]) == 1 True >>> find_smallest_missing_positive([5, 3, 2, 7, -10, 0]) == 1 True","solution":"def find_smallest_missing_positive(nums): Returns the smallest positive integer that is missing from the unsorted integer array. if not nums: return 1 nums = list(filter(lambda x: x > 0, nums)) num_set = set(nums) smallest_missing = 1 while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"from typing import List, Tuple def max_trees(m: int, n: int) -> int: Returns the maximum number of trees that can be placed in an MxN field such that no two trees are directly adjacent (vertically, horizontally, or diagonally). pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Takes a list of test cases and returns the results for each test case according to the max_trees function. pass # Example test cases def test_max_trees_case_1(): test_cases = [(3, 3)] assert solve(test_cases) == [5] def test_max_trees_case_2(): test_cases = [(2, 2)] assert solve(test_cases) == [2] def test_max_trees_case_single_row(): test_cases = [(1, 5)] assert solve(test_cases) == [5] def test_max_trees_case_single_column(): test_cases = [(5, 1)] assert solve(test_cases) == [5] def test_max_trees_case_large(): test_cases = [(100, 100)] assert solve(test_cases) == [5000] def test_max_trees_case_small(): test_cases = [(1, 1)] assert solve(test_cases) == [1] def test_max_trees_multiple_cases(): test_cases = [(3, 3), (2, 2), (5, 5), (4, 7)] assert solve(test_cases) == [5, 2, 13, 14]","solution":"def max_trees(m, n): Returns the maximum number of trees that can be placed in an MxN field such that no two trees are directly adjacent (vertically, horizontally, or diagonally). if m == 1 or n == 1: return m * n total_slots = m * n alternating_slots = (total_slots + 1) // 2 return alternating_slots def solve(test_cases): results = [] for (m, n) in test_cases: results.append(max_trees(m, n)) return results"},{"question":"def insert_into_sorted_list(sorted_list, value): Inserts a value into a sorted list while maintaining the sorted order. Parameters: sorted_list (list): A list of integers sorted in ascending order. value (int): An integer value to insert into the list. Returns: list: The updated list with the value inserted. >>> insert_into_sorted_list([1, 3, 5, 7], 4) [1, 3, 4, 5, 7] >>> insert_into_sorted_list([10, 20, 30, 40], 25) [10, 20, 25, 30, 40] >>> insert_into_sorted_list([-5, -3, -1, 0, 2], -2) [-5, -3, -2, -1, 0, 2] >>> insert_into_sorted_list([1, 2, 3, 4], 0) [0, 1, 2, 3, 4] >>> insert_into_sorted_list([1, 2, 3, 4], 5) [1, 2, 3, 4, 5] >>> insert_into_sorted_list([], 1) [1] >>> insert_into_sorted_list([1, 2, 2, 3], 2) [1, 2, 2, 2, 3]","solution":"def insert_into_sorted_list(sorted_list, value): Inserts a value into a sorted list while maintaining the sorted order. Parameters: sorted_list (list): A list of integers sorted in ascending order. value (int): An integer value to insert into the list. Returns: list: The updated list with the value inserted. if not sorted_list: return [value] for i in range(len(sorted_list)): if value <= sorted_list[i]: sorted_list.insert(i, value) break else: sorted_list.append(value) return sorted_list"},{"question":"from typing import List, Tuple def smallest_lexicographical_string(K: int, S: str) -> str: Find the lexicographically smallest string that can be obtained by performing the given operation exactly K times. Args: K (int): Number of operations S (str): Input string Returns: str: The lexicographically smallest string obtained >>> smallest_lexicographical_string(3, 'bdaca') 'aabcd' >>> smallest_lexicographical_string(3, 'cab') 'abc' pass def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Processes multiple test cases for the smallest_lexicographical_string function. Args: T (int): Number of test cases test_cases (List[Tuple[int, str]]): List containing tuples of K and S for each test case Returns: List[str]: List of results for each test case >>> process_test_cases(2, [(3, 'bdaca'), (3, 'cab')]) ['aabcd', 'abc'] >>> process_test_cases(1, [(1, 'dbca')]) ['dbca'] pass","solution":"def smallest_lexicographical_string(K, S): if K == 1: return S # More than 1 operations allow sorting the entire string result = ''.join(sorted(S)) return result def process_test_cases(T, test_cases): results = [] for K, S in test_cases: results.append(smallest_lexicographical_string(K, S)) return results"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a grid with dimensions m x n. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(1, 1) 1 >>> unique_paths(1, 10) 1 >>> unique_paths(10, 1) 1 >>> unique_paths(4, 4) 20 >>> unique_paths(10, 10) 48620 >>> unique_paths(20, 20) 35345263800 >>> unique_paths(15, 15) 40116600","solution":"def unique_paths(m, n): Calculate the number of unique paths from the top-left to the bottom-right corner of a grid with dimensions m x n. # Create a 2D list to store the number of paths to reach each cell dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from cell (1, 1) for i in range(1, m): for j in range(1, n): # The number of paths to reach cell (i, j) is the sum of paths to reach cell (i-1, j) and cell (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] # The number of unique paths to reach the bottom-right corner is stored in cell (m-1, n-1) return dp[m-1][n-1]"},{"question":"def has_pair_with_difference(arr: List[int], k: int) -> bool: Given an array of integers, find out whether there are two distinct indices \`i\` and \`j\` in the array such that the absolute difference between numbers at these indices is equal to a given value \`k\`. >>> has_pair_with_difference([1, 5, 3, 4, 2], 2) True >>> has_pair_with_difference([1, 5, 3, 4, 2], 6) False >>> has_pair_with_difference([1, 2, 3, 4, 5], 0) False >>> has_pair_with_difference([1, 1, 2, 3], 0) True >>> has_pair_with_difference([1, 2, 3, 1, 5], 4) True >>> has_pair_with_difference([-1, -2, -3, -4, -5], 1) True >>> has_pair_with_difference([], 1) False >>> has_pair_with_difference([1], 1) False pass","solution":"def has_pair_with_difference(arr, k): Returns True if there are two distinct indices i and j in arr such that the absolute difference between arr[i] and arr[j] is equal to k. seen = set() for num in arr: if (num + k) in seen or (num - k) in seen: return True seen.add(num) return False"},{"question":"def longestIncreasingPath(matrix): Find the longest increasing path in an N x N grid filled with random integers. From each cell, you can either move to four directions: left, right, up, or down. You may not move diagonally or move outside the boundary of the grid. Args: matrix (List[List[int]]): The input grid of integers. Returns: int: The length of the longest increasing path. Examples: >>> longestIncreasingPath([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longestIncreasingPath([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4","solution":"def longestIncreasingPath(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[-1 for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if dp[r][c] != -1: return dp[r][c] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_length = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] > matrix[r][c]: current_length = 1 + dfs(nr, nc) max_length = max(max_length, current_length) dp[r][c] = max_length return dp[r][c] max_path = 0 for i in range(rows): for j in range(cols): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"def is_palindrome(s: str) -> bool: Determine if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\" \\") True >>> is_palindrome(\\"Able , was I saw elba\\") True >>> is_palindrome(\\"MadAm\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"123321\\") True >>> is_palindrome(\\"A1B2B1A\\") True","solution":"def is_palindrome(s: str) -> bool: Determine if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = ''.join(c.lower() for c in s if c.isalnum()) # Check if the filtered string is the same forwards and backwards return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List from itertools import permutations def is_valid_time(a: int, b: int, c: int, d: int) -> bool: Check if the given four digits can form a valid time (HH:MM) in a 24-hour format. >>> is_valid_time(1, 8, 3, 2) True >>> is_valid_time(2, 4, 6, 9) False >>> is_valid_time(0, 9, 5, 0) True >>> is_valid_time(2, 5, 0, 0) False def can_form_valid_time(digits: List[int]) -> str: Determine if any permutation of digits can form a valid time (HH:MM). >>> can_form_valid_time([1, 8, 3, 2]) \\"1\\" >>> can_form_valid_time([9, 5, 6, 0]) \\"1\\" >>> can_form_valid_time([2, 4, 6, 9]) \\"0\\" def check_times(test_cases: List[List[int]]) -> List[str]: Check multiple test cases to see if they can form valid times. >>> check_times([[1, 8, 3, 2], [9, 5, 6, 0], [2, 4, 6, 9]]) [\\"1\\", \\"1\\", \\"0\\"] def test_is_valid_time(): assert is_valid_time(1, 8, 3, 2) == True assert is_valid_time(2, 4, 6, 9) == False assert is_valid_time(0, 9, 5, 0) == True assert is_valid_time(2, 5, 0, 0) == False def test_can_form_valid_time(): assert can_form_valid_time([1, 8, 3, 2]) == \\"1\\" assert can_form_valid_time([9, 5, 6, 0]) == \\"1\\" assert can_form_valid_time([2, 4, 6, 9]) == \\"0\\" def test_check_times(): test_cases = [ [1, 8, 3, 2], [9, 5, 6, 0], [2, 4, 6, 9] ] assert check_times(test_cases) == [\\"1\\", \\"1\\", \\"0\\"]","solution":"from itertools import permutations def is_valid_time(a, b, c, d): hour = a * 10 + b minute = c * 10 + d return 0 <= hour < 24 and 0 <= minute < 60 def can_form_valid_time(digits): for perm in permutations(digits): if is_valid_time(perm[0], perm[1], perm[2], perm[3]): return \\"1\\" return \\"0\\" def check_times(test_cases): results = [] for digits in test_cases: results.append(can_form_valid_time(digits)) return results"},{"question":"def sum_except_self(arr): Given an array of integers, return a new array such that each element at index i of the new array is the sum of all the numbers in the original array except the one at i. >>> sum_except_self([1, 2, 3, 4, 5]) [14, 13, 12, 11, 10] >>> sum_except_self([3, 6, 4, 8, 9]) [27, 24, 26, 22, 21] >>> sum_except_self([10]) [0] >>> sum_except_self([1, 2]) [2, 1] >>> sum_except_self([0, 0, 0]) [0, 0, 0] >>> sum_except_self([-1, 0, 1, 2]) [3, 2, 1, 0] >>> sum_except_self([-1, -2, -3, -4]) [-9, -8, -7, -6] pass","solution":"def sum_except_self(arr): Given an array of integers, return a new array such that each element at index i of the new array is the sum of all the numbers in the original array except the one at i. # First compute the total sum of the array total_sum = sum(arr) # Then build the result array where each element at index i is total_sum - arr[i] result = [total_sum - num for num in arr] return result"},{"question":"from typing import List, Tuple def shortest_delivery_time(N: int, M: int, routes: List[Tuple[int, int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Determine the shortest delivery time between any two given cities, if a route exists. If there is no way to deliver a package between the two cities, return -1. Args: N: An integer representing the number of cities. M: An integer representing the number of direct delivery routes. routes: A list of tuples where each tuple represents a direct delivery route between cities (u, v) with delivery time (t). Q: An integer representing the number of queries. queries: A list of tuples where each tuple represents a query to find the shortest delivery time between city a and city b. Returns: A list of integers where each integer represents the shortest delivery time for each query, or -1 if there is no path. Example: >>> N = 5 >>> M = 6 >>> routes = [ ... (1, 2, 4), ... (1, 3, 2), ... (2, 3, 5), ... (2, 4, 10), ... (3, 4, 3), ... (4, 5, 1) ... ] >>> Q = 3 >>> queries = [ ... (1, 5), ... (1, 4), ... (3, 2) ... ] >>> shortest_delivery_time(N, M, routes, Q, queries) [6, 5, -1] >>> N = 3 >>> M = 0 >>> routes = [] >>> Q = 1 >>> queries = [ ... (1, 3) ... ] >>> shortest_delivery_time(N, M, routes, Q, queries) [-1]","solution":"import heapq import sys def dijkstra(graph, start): distances = {node: float('inf') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_delivery_time(N, M, routes, Q, queries): graph = {i: {} for i in range(1, N + 1)} for u, v, t in routes: if v in graph[u]: graph[u][v] = min(graph[u][v], t) else: graph[u][v] = t results = [] for a, b in queries: distances = dijkstra(graph, a) results.append(distances[b] if distances[b] != float('inf') else -1) return results"},{"question":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: Find the smallest missing positive integer in an unsorted list of integers. This function will handle both positive and negative integers, but will focus on finding the smallest positive integer that does not appear in the list. >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_smallest_missing_positive([1, 2, 3, 4, 5]) 6 >>> find_smallest_missing_positive([-10, -3, -100, -1]) 1 >>> find_smallest_missing_positive([]) 1 pass","solution":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: # Ensure all numbers cannot be negative or zero (smallest positive is 1) n = len(nums) for i in range(n): if nums[i] <= 0: nums[i] = n + 1 # Use index to mark presence of elements for num in nums: abs_num = abs(num) if 1 <= abs_num <= n: nums[abs_num - 1] = -abs(nums[abs_num - 1]) # Find the smallest missing positive integer for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def min_bookshelves(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the minimum number of bookshelves needed to hold all books without exceeding the weight limit on any shelf. Args: T : int : number of test cases test_cases : List[Tuple[Tuple[int, int], List[int]]] : List of test case tuples. Each test case is a tuple containing: - a tuple with two integers N and W (number of books and weight limit of a shelf) - a list of integers representing weights of the books. Returns: List[int] : List of integers representing the minimum number of shelves required for each test case. >>> T = 2 >>> test_cases = [((5, 10), [2, 3, 5, 4, 1]), ((4, 8), [4, 3, 4, 3])] >>> min_bookshelves(T, test_cases) [2, 2] >>> T = 1 >>> test_cases = [((6, 15), [5, 5, 5, 5, 5, 5])] >>> min_bookshelves(T, test_cases) [2] >>> T = 1 >>> test_cases = [((4, 20), [10, 10, 10, 10])] >>> min_bookshelves(T, test_cases) [2]","solution":"def min_bookshelves(T, test_cases): results = [] for i in range(T): N, W = test_cases[i][0] books = sorted(test_cases[i][1], reverse=True) shelves = 0 while books: shelves += 1 remaining_capacity = W j = 0 while j < len(books): if books[j] <= remaining_capacity: remaining_capacity -= books[j] books.pop(j) else: j += 1 results.append(shelves) return results"},{"question":"def apply_shifts(s: str, shifts: List[int]) -> str: Apply shift according to the shifts array to the string s. Parameters: s (str): Input string consisting of lowercase English letters. shifts (list): List of integers indicating the shift amount for each character in s. Returns: str: Resulting string after applying all shifts. Examples: >>> apply_shifts(\\"abc\\", [1, 2, 3]) \\"bdf\\" >>> apply_shifts(\\"xyz\\", [1, 1, 1]) \\"yza\\" >>> apply_shifts(\\"hello\\", [5, 5, 5, 5, 5]) \\"mjqqt\\"","solution":"def apply_shifts(s, shifts): Apply shift according to the shifts array to the string s. Parameters: s (str): Input string consisting of lowercase English letters. shifts (list): List of integers indicating the shift amount for each character in s. Returns: str: Resulting string after applying all shifts. result = [] for i, char in enumerate(s): # Calculate the shifted character shifted_char = chr((ord(char) - ord('a') + shifts[i]) % 26 + ord('a')) result.append(shifted_char) return ''.join(result)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring of s that contains only distinct characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abcabcabcabcd\\") 4 >>> length_of_longest_substring(\\"aabcdabcbbabcde\\") 5 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 pass","solution":"def length_of_longest_substring(s): Returns the length of the longest substring of s that contains only distinct characters. char_map = {} left = 0 longest = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right longest = max(longest, right - left + 1) return longest"},{"question":"def isValidSudoku(board): Checks if the given 9x9 Sudoku board is valid according to the rules mentioned in the prompt. pass def test_valid_sudoku(): board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] assert isValidSudoku(board) == True def test_invalid_sudoku_due_to_row(): board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\"7\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], # <-- Duplicate 7 here [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] assert isValidSudoku(board) == False def test_invalid_sudoku_due_to_column(): board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] board[0][0] = \\"8\\" # <-- Conflict with board[3][0] assert isValidSudoku(board) == False def test_invalid_sudoku_due_to_box(): board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] board[0][0] = \\"9\\" # <-- Conflict with board[1][1], board[2][2] assert isValidSudoku(board) == False # Execute these tests using pytest","solution":"def isValidSudoku(board): Checks if the given 9x9 Sudoku board is valid according to the rules mentioned in the prompt. def isValidBlock(block): Helper function to check if a block (row, column, or 3x3 sub-box) is valid. seen = [x for x in block if x != '.'] return len(seen) == len(set(seen)) # Check rows for row in board: if not isValidBlock(row): return False # Check columns for col in range(9): if not isValidBlock([board[row][col] for row in range(9)]): return False # Check 3x3 sub-boxes for box_row in range(3): for box_col in range(3): if not isValidBlock([board[row][col] for row in range(box_row*3, (box_row+1)*3) for col in range(box_col*3, (box_col+1)*3)]): return False return True"},{"question":"def find_diameter(num_nodes, edges): Find the diameter of a tree with given number of nodes and edges. >>> find_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> find_diameter(6, [(1, 2), (1, 3), (3, 4), (4, 5), (4, 6)]) 4 def solve_diameter_of_trees(t, cases): Given the number of test cases and a list of cases with nodes and edges for each tree, find the diameter for each test case. >>> solve_diameter_of_trees(2, [(5, [(1, 2), (1, 3), (2, 4), (2, 5)]), (6, [(1, 2), (1, 3), (3, 4), (4, 5), (4, 6)])]) [3, 4] >>> solve_diameter_of_trees(1, [(3, [(1, 2), (2, 3)])]) [2]","solution":"def find_diameter(num_nodes, edges): from collections import defaultdict, deque def bfs(start_node): visited = [False] * (num_nodes + 1) distances = [-1] * (num_nodes + 1) queue = deque([start_node]) visited[start_node] = True distances[start_node] = 0 while queue: node = queue.popleft() for neighbor in tree[node]: if not visited[neighbor]: visited[neighbor] = True distances[neighbor] = distances[node] + 1 queue.append(neighbor) max_distance = max(distances) farthest_node = distances.index(max_distance) return farthest_node, max_distance # Build the tree from edges tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Start BFS from any node, let's choose node 1 farthest_node, _ = bfs(1) # Perform BFS from the farthest node found _, diameter = bfs(farthest_node) return diameter def solve_diameter_of_trees(t, cases): results = [] for i in range(t): num_nodes = cases[i][0] edges = cases[i][1:] diameter = find_diameter(num_nodes, edges) results.append(diameter) return results"},{"question":"def decode_string(s: str) -> str: Decodes the input string following the specified pattern. :param s: Encoded string :return: Decoded string >>> decode_string(\\"3[a]\\") == \\"aaa\\" >>> decode_string(\\"2[bc]\\") == \\"bcbc\\" >>> decode_string(\\"4[ab]\\") == \\"abababab\\" >>> decode_string(\\"3[a2[bc]]\\") == \\"abcbcabcbcabcbc\\" >>> decode_string(\\"2[3[a]b]\\") == \\"aaabaaab\\" >>> decode_string(\\"2[ab3[cd]]\\") == \\"abcdcdcdabcdcdcd\\" >>> decode_string(\\"10[a]\\") == \\"aaaaaaaaaa\\" >>> decode_string(\\"abc3[cd]xyz\\") == \\"abccdcdcdxyz\\" >>> decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decode_string(\\"10[a3[b]]\\") == \\"abbbabbbabbbabbbabbbabbbabbbabbbabbbabbb\\" >>> decode_string(\\"0[a]\\") == \\"\\" pass","solution":"def decode_string(s): Decodes the input string following the specified pattern. :param s: Encoded string :return: Decoded string stack = [] current_num = 0 current_str = '' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_str, current_num)) current_str = '' current_num = 0 elif char == ']': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"def can_form_word(word: str, characters: List[str]) -> bool: Evaluate if a word can be formed using characters from a list of available characters. The function should handle case sensitivity, meaning 'A' and 'a' should be treated as distinct characters. >>> can_form_word(\\"apple\\", ['a', 'p', 'p', 'l', 'e']) True >>> can_form_word(\\"apple\\", ['a', 'p', 'l', 'e']) False >>> can_form_word(\\"Apple\\", ['a', 'p', 'p', 'l', 'e']) False >>> can_form_word(\\"BANANA\\", ['B', 'A', 'N', 'A', 'N', 'A']) True >>> can_form_word(\\"BANANA\\", ['b', 'a', 'n', 'a', 'n', 'a']) False","solution":"def can_form_word(word, characters): Returns True if the word can be formed using the characters in the list, including case sensitivity. Each character in the list can only be used once. :param word: str, word to be formed :param characters: list of str, available characters :return: bool from collections import Counter word_counter = Counter(word) char_counter = Counter(characters) for char, count in word_counter.items(): if char_counter[char] < count: return False return True"},{"question":"def find_unique_number(n: int, sequence: List[int]) -> int: Given a sequence of integer numbers where each number appears exactly twice, except for one number which appears exactly once, find the number that appears only once. Parameters: n (int): The length of the sequence (always odd). sequence (list of int): The elements of the sequence. Returns: int: The unique number that appears exactly once. Examples: >>> find_unique_number(7, [4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_number(5, [10, 20, 10, 30, 20]) 30","solution":"def find_unique_number(n, sequence): Given a sequence of integer numbers where each number appears exactly twice, except for one number which appears exactly once, find the number that appears only once. Parameters: n (int): The length of the sequence (always odd). sequence (list of int): The elements of the sequence. Returns: int: The unique number that appears exactly once. unique_num = 0 for num in sequence: unique_num ^= num return unique_num"},{"question":"def find_pairs_with_difference(nums: List[int], k: int) -> Union[str, bool]: Returns whether there exist two distinct indices \`i\` and \`j\` in the array such that the absolute difference between \`nums[i]\` and \`nums[j]\` is equal to \`k\`. If the array has less than two elements, returns \\"Not enough elements\\". >>> find_pairs_with_difference([], 1) \\"Not enough elements\\" >>> find_pairs_with_difference([1], 1) \\"Not enough elements\\" >>> find_pairs_with_difference([1, 5, 3, 4, 2], 2) True >>> find_pairs_with_difference([1, 2, 3, 4, 5], 5) False >>> find_pairs_with_difference([10, -10, 20, -20, 30], 10) True >>> find_pairs_with_difference([1, 2, 2, 1], 1) True >>> find_pairs_with_difference([5, 5, 5, 5], 0) True >>> find_pairs_with_difference([3, 1], 2) True >>> find_pairs_with_difference([1, 3], 2) True >>> find_pairs_with_difference([1, 3, 5, 7], 10) False >>> find_pairs_with_difference([10, 20, 30, 40], 25) False","solution":"def find_pairs_with_difference(nums, k): Returns whether there exist two distinct indices \`i\` and \`j\` in the array such that the absolute difference between \`nums[i]\` and \`nums[j]\` is equal to \`k\`. If the array has less than two elements, returns \\"Not enough elements\\". :param nums: List of integers :param k: The target difference :return: \\"Not enough elements\\" or True/False if len(nums) < 2: return \\"Not enough elements\\" seen = set(nums) for num in seen: if (num + k) in seen or (num - k) in seen: return True return False"},{"question":"def find_pair_with_sum_k(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Given multiple test cases, each with an array of integers and a number K, determines if there exists a pair of indices such that the sum of their elements equals K. Parameters: test_cases (list of tuples): Each tuple contains: - an integer N (size of the array) - an integer K - a list of N integers (the array) Returns: list of str: Each element is \\"YES\\" or \\"NO\\" corresponding to whether such a pair exists in each test case. >>> find_pair_with_sum_k([(5, 8, [1, 2, 3, 4, 5]), (4, -3, [-1, -1, -1, -1])]) [\\"YES\\", \\"NO\\"] >>> find_pair_with_sum_k([(3, 10, [1, 2, 3])]) [\\"NO\\"] >>> find_pair_with_sum_k([(4, 0, [-1, 1, 2, -2])]) [\\"YES\\"] >>> find_pair_with_sum_k([(2, 2000000, [1000000, 1000000])]) [\\"YES\\"] >>> find_pair_with_sum_k([(3, -5, [-1, -2, -3])]) [\\"YES\\"] >>> find_pair_with_sum_k([(2, 5, [2, 3])]) [\\"YES\\"] >>> find_pair_with_sum_k([(5, 10, [2, 2, 2, 2, 2])]) [\\"NO\\"]","solution":"def find_pair_with_sum_k(test_cases): Given multiple test cases, each with an array of integers and a number K, determines if there exists a pair of indices such that the sum of their elements equals K. Parameters: test_cases (list of tuple): Each tuple contains: - an integer N (size of the array) - an integer K - a list of N integers (the array) Returns: list of str: Each element is \\"YES\\" or \\"NO\\" corresponding to whether such a pair exists in each test case. results = [] for case in test_cases: N, K, array = case seen = set() found = False for num in array: if K - num in seen: results.append(\\"YES\\") found = True break seen.add(num) if not found: results.append(\\"NO\\") return results"},{"question":"def rectangle_properties(height: float, base: float) -> tuple: Returns the area and perimeter of a rectangle given its height and base. Parameters: height (float): The height of the rectangle. base (float): The base of the rectangle. Returns: tuple: (area, perimeter) >>> rectangle_properties(5, 10) (50, 30) >>> rectangle_properties(0, 10) (0, 20) >>> rectangle_properties(10, 0) (0, 20) >>> rectangle_properties(4.5, 7.2) (32.4, 23.4) >>> rectangle_properties(1, 1) (1, 4) # Your code here","solution":"def rectangle_properties(height, base): Returns the area and perimeter of a rectangle given its height and base. Parameters: height (float): The height of the rectangle. base (float): The base of the rectangle. Returns: tuple: (area, perimeter) area = height * base perimeter = 2 * (height + base) return area, perimeter"},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"aabbcc\\") == 2 >>> length_of_longest_substring(\\"abacabad\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_index_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def min_operations_to_sort(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimum number of operations needed to sort each array for given test cases. Parameters: T : int Number of test cases test_cases: list of tuples Each tuple contains an integer N and a list of N integers representing the array Returns: list of int Minimum number of operations needed to sort each array in non-decreasing order Examples: >>> min_operations_to_sort(2, [(5, [3, 1, 2, 4, 5]), (3, [3, 2, 1])]) [1, 1] pass # Unit Test def test_already_sorted(): assert min_operations_to_sort(1, [(5, [1, 2, 3, 4, 5])]) == [0] def test_reverse_entire_array(): assert min_operations_to_sort(1, [(5, [5, 4, 3, 2, 1])]) == [1] def test_one_reversal_needed(): assert min_operations_to_sort(1, [(5, [3, 1, 2, 4, 5])]) == [1] def test_another_single_reversal(): assert min_operations_to_sort(1, [(3, [3, 2, 1])]) == [1] def test_multiple_cases(): assert min_operations_to_sort(2, [(5, [3, 1, 2, 4, 5]), (3, [3, 2, 1])]) == [1, 1] def test_case_with_duplicates(): assert min_operations_to_sort(1, [(5, [3, 3, 2, 2, 1])]) == [1] def test_almost_sorted(): assert min_operations_to_sort(1, [(5, [1, 2, 4, 3, 5])]) == [1]","solution":"def min_operations_to_sort(T, test_cases): Determines the minimum number of operations needed to sort each array for given test cases. Parameters: T : int Number of test cases test_cases: list of tuples Each tuple contains an integer N and a list of N integers representing the array Returns: list of int Minimum number of operations needed to sort each array in non-decreasing order results = [] for N, array in test_cases: if sorted(array) == array: # Already sorted results.append(0) elif sorted(array) == array[::-1]: # Only one reverse needed as the array is sorted in decreasing order results.append(1) else: # General case, we consider strictly one reversal can solve any non-decreasing sorted transformation if not sorted in increasing or decreasing manner results.append(1) return results"},{"question":"def product_of_odds(lst: List[int]) -> int: Write a function that takes in a list of integers and returns the product of all the odd numbers in the list. If there are no odd numbers, the function should return 1. >>> product_of_odds([2, 4, 6, 8]) 1 >>> product_of_odds([1, 2, 3, 4, 5]) 15 >>> product_of_odds([1, 3, 5, 7, 9]) 945 >>> product_of_odds([7]) 7 >>> product_of_odds([]) 1 >>> product_of_odds([2, 4, 6, 10, 20]) 1","solution":"def product_of_odds(lst): Returns the product of all the odd numbers in the list. If there are no odd numbers, the function returns 1. product = 1 has_odds = False for num in lst: if num % 2 != 0: product *= num has_odds = True return product if has_odds else 1"},{"question":"def find_mix_order(n, m, dependencies): Determine a valid order to mix ingredients based on given dependencies. Parameters: - n (int): Number of ingredients. - m (int): Number of dependencies. - dependencies (List[Tuple[int, int]]): List of dependencies (u, v) where u must come before v. Returns: - List[int] or str: A valid mix order of ingredients as a list of integers, or \\"IMPOSSIBLE\\" if no valid order exists. pass from solution import find_mix_order def test_example_case(): n = 4 m = 3 dependencies = [(1, 2), (1, 3), (3, 4)] order = find_mix_order(n, m, dependencies) assert order in [[1, 2, 3, 4], [1, 3, 4, 2]] def test_no_dependencies(): n = 3 m = 0 dependencies = [] order = find_mix_order(n, m, dependencies) assert order in [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] def test_circular_dependency(): n = 3 m = 3 dependencies = [(1, 2), (2, 3), (3, 1)] order = find_mix_order(n, m, dependencies) assert order == \\"IMPOSSIBLE\\" def test_multiple_valid_sequences(): n = 6 m = 6 dependencies = [(1, 2), (1, 3), (3, 4), (5, 6), (4, 6), (2, 5)] order = find_mix_order(n, m, dependencies) assert order in [ [1, 2, 3, 5, 4, 6], [1, 3, 4, 2, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 6, 5] ] def test_single_ingredient(): n = 1 m = 0 dependencies = [] order = find_mix_order(n, m, dependencies) assert order == [1]","solution":"from collections import defaultdict, deque def find_mix_order(n, m, dependencies): Determine a valid order to mix ingredients based on given dependencies. Parameters: - n (int): Number of ingredients. - m (int): Number of dependencies. - dependencies (List[Tuple[int, int]]): List of dependencies (u, v) where u must come before v. Returns: - List[int] or str: A valid mix order of ingredients as a list of integers, or \\"IMPOSSIBLE\\" if no valid order exists. # Initialize the graph graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n + 1)} # Build the graph for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Queue for nodes with no incoming edges queue = deque([node for node in in_degree if in_degree[node] == 0]) mix_order = [] while queue: node = queue.popleft() mix_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we are able to process all nodes, return the order if len(mix_order) == n: return mix_order else: return \\"IMPOSSIBLE\\""},{"question":"def max_path_sum(matrix: List[List[int]]) -> int: Returns the maximum path sum in a 2D matrix from the top-left corner to the bottom-right corner. You can only move either right or down at any point in time. >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_path_sum([ ... [5] ... ]) 5 >>> max_path_sum([ ... [1, 2, 3, 4] ... ]) 10 >>> max_path_sum([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12","solution":"def max_path_sum(matrix): Returns the maximum path sum in a 2D matrix from the top-left corner to the bottom-right corner. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = matrix[0][0] # Initialize the first column of the dp table for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Initialize the first row of the dp table for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill up the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1] # Function to take input and produce the output def main(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) n = int(data[1]) matrix = [] index = 2 for i in range(m): row = list(map(int, data[index:index+n])) matrix.append(row) index += n result = max_path_sum(matrix) print(result)"},{"question":"from typing import List def GroupAnagrams(strs: List[str]) -> List[List[str]]: Groups anagrams from the input list into separate lists Parameters: strs (list): List of strings to be grouped by anagrams. Returns: list: List of lists, where each inner list contains grouped anagrams. Example: >>> GroupAnagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] pass def test_group_anagrams_basic(): input_list = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] expected_output = [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] result = GroupAnagrams(input_list) assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected_output]) def test_group_anagrams_empty_list(): input_list = [] expected_output = [] result = GroupAnagrams(input_list) assert result == expected_output def test_group_anagrams_single_word(): input_list = [\\"word\\"] expected_output = [[\\"word\\"]] result = GroupAnagrams(input_list) assert result == expected_output def test_group_anagrams_no_anagrams(): input_list = [\\"abc\\", \\"def\\", \\"ghi\\"] expected_output = [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] result = GroupAnagrams(input_list) assert sorted(result) == sorted(expected_output) def test_group_anagrams_all_anagrams(): input_list = [\\"aabb\\", \\"baba\\", \\"baab\\", \\"abba\\"] expected_output = [[\\"aabb\\", \\"baba\\", \\"baab\\", \\"abba\\"]] result = GroupAnagrams(input_list) assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected_output])","solution":"from collections import defaultdict def GroupAnagrams(strs): Groups anagrams from the input list into separate lists Parameters: strs (list): List of strings to be grouped by anagrams. Returns: list: List of lists, where each inner list contains grouped anagrams. anagrams = defaultdict(list) for word in strs: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def balance_fleet(weights: List[int]) -> int: Calculate the minimum possible difference between the sums of weights of two groups. >>> balance_fleet([1, 6, 11, 5]) 1 >>> balance_fleet([10, 20, 15, 5, 25]) 5 >>> balance_fleet([1, 2, 3, 4, 5]) 1","solution":"def balance_fleet(weights): Calculate the minimum possible difference between the sums of weights of two groups. total_weight = sum(weights) n = len(weights) dp = [[False] * (total_weight // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for w in range(total_weight // 2 + 1): if dp[i - 1][w]: dp[i][w] = True elif w >= weights[i - 1]: dp[i][w] = dp[i - 1][w] or dp[i - 1][w - weights[i - 1]] for w in range(total_weight // 2, -1, -1): if dp[n][w]: return total_weight - 2 * w"},{"question":"from typing import List, Tuple def game_winner(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine who will win the arithmetic game if both players play optimally. >>> game_winner(1, [(3, [1, 2, 3])]) [\\"Dana\\"] >>> game_winner(1, [(4, [2, 3, 5, 7])]) [\\"Shaun\\"] >>> game_winner(2, [(3, [1, 2, 3]), (4, [2, 3, 5, 7])]) [\\"Dana\\", \\"Shaun\\"]","solution":"def game_winner(T, test_cases): results = [] for case in test_cases: N = case[0] if (N - 3) % 2 == 0: results.append(\\"Dana\\") else: results.append(\\"Shaun\\") return results"},{"question":"def min_insertions_to_make_palindrome(s: str) -> int: Given a string s, find the minimum number of characters to insert into the string to make it a palindrome. A palindrome is a string that reads the same forwards and backwards. Example: >>> min_insertions_to_make_palindrome(\\"abca\\") 1 >>> min_insertions_to_make_palindrome(\\"race\\") 3","solution":"def min_insertions_to_make_palindrome(s): Returns the minimum number of characters to insert into the string \`s\` to make it a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1]"},{"question":"def inventory_manager(input_str: str) -> List[Dict[str, str]]: Parses the inventory list string and returns an array of dictionaries. :param input_str: str, the inventory list string :return: list of dictionaries Example: >>> inventory_manager(\\"Computer,001,Dell XPS;Monitor,002,Samsung Curved Monitor\\") [{\\"type\\": \\"Computer\\", \\"id\\": \\"001\\", \\"description\\": \\"Dell XPS\\"}, {\\"type\\": \\"Monitor\\", \\"id\\": \\"002\\", \\"description\\": \\"Samsung Curved Monitor\\"}] >>> inventory_manager(\\"\\") [] >>> inventory_manager(None) []","solution":"def inventory_manager(input_str): Parses the inventory list string and returns an array of dictionaries. :param input_str: str, the inventory list string :return: list of dictionaries if not input_str: return [] items = input_str.split(';') inventory_list = [] for item in items: parts = item.split(',') if len(parts) == 3: equipment_type, equipment_id, description = parts inventory_list.append({ \\"type\\": equipment_type, \\"id\\": equipment_id, \\"description\\": description }) return inventory_list"},{"question":"def binary_sum_list(bin_list): Given a list of binary strings, return a new list where each element is the sum of all other binary strings in the list, converted back to binary format. Parameters: bin_list (list): A list of binary strings. Returns: list: A list of binary strings where each element is the sum of all other binary strings in the input list, in binary format. >>> binary_sum_list([\\"101\\", \\"110\\"]) [\\"1011\\", \\"1110\\"] >>> binary_sum_list([\\"10\\", \\"11\\", \\"1\\"]) [\\"100\\", \\"101\\", \\"110\\"] >>> binary_sum_list([\\"101\\"]) [\\"0\\"] >>> binary_sum_list([]) [] >>> binary_sum_list([\\"0\\", \\"0\\", \\"0\\"]) [\\"0\\", \\"0\\", \\"0\\"] >>> binary_sum_list([\\"10\\", \\"1\\", \\"110\\"]) [\\"111\\", \\"1000\\", \\"11\\"]","solution":"def binary_sum_list(bin_list): Given a list of binary strings, return a new list where each element is the sum of all other binary strings in the list, converted back to binary format. Parameters: bin_list (list): A list of binary strings. Returns: list: A list of binary strings where each element is the sum of all other binary strings in the input list, in binary format. # Convert each binary string to decimals dec_list = [int(b, 2) for b in bin_list] # Compute the sum of all the elements in the decimal list total_sum = sum(dec_list) # Create the result list by subtracting each element from the total sum # and converting the result back to binary result = [bin(total_sum - d)[2:] for d in dec_list] return result"},{"question":"def reverse_words(s: str) -> str: Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: >>> reverse_words(\\"The sky is blue\\") \\"ehT yks si eulb\\" Example 2: >>> reverse_words(\\" Hello World \\") \\" olleH dlroW \\" Example 3: >>> reverse_words(\\"a good example\\") \\"a doog elpmaxe\\"","solution":"def reverse_words(s): Reverses the characters in each word within a sentence while preserving whitespace and initial word order. return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"def longest_palindrome_substring(s: str) -> int: Design a function that takes a string as input and returns the length of the longest substring that can be rearranged to form a palindrome. The function should consider case sensitivity, i.e., 'A' and 'a' are treated as different characters. >>> longest_palindrome_substring(\\"abcbcbcb\\") 7 >>> longest_palindrome_substring(\\"aA\\") 1 >>> longest_palindrome_substring(\\"abccba\\") 6 from solution import longest_palindrome_substring def test_longest_palindrome_substring_example1(): assert longest_palindrome_substring(\\"abcbcbcb\\") == 7 def test_longest_palindrome_substring_example2(): assert longest_palindrome_substring(\\"aA\\") == 1 def test_longest_palindrome_substring_example3(): assert longest_palindrome_substring(\\"abccba\\") == 6 def test_longest_palindrome_substring_empty_string(): assert longest_palindrome_substring(\\"\\") == 0 def test_longest_palindrome_substring_single_char(): assert longest_palindrome_substring(\\"z\\") == 1 def test_longest_palindrome_substring_all_unique(): assert longest_palindrome_substring(\\"abcdef\\") == 1 def test_longest_palindrome_substring_mixed_case(): assert longest_palindrome_substring(\\"aAbBcCdDe\\") == 1 def test_longest_palindrome_multiple_odds(): assert longest_palindrome_substring(\\"aaabbbcccdddd\\") == 11","solution":"def longest_palindrome_substring(s): from collections import Counter char_count = Counter(s) length = 0 found_odd = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 found_odd = True if found_odd: length += 1 return length"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Function to find the maximum sum of a contiguous subarray such that the subarray contains at least one element of the given integer array. >>> max_subarray_sum([7]) 7 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_subarray_sum([]) 0 pass","solution":"def max_subarray_sum(nums): Function to find the maximum sum of a contiguous subarray such that the subarray contains at least one element of the given integer array. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the string such that no two adjacent characters are the same. If not possible, returns an empty string. :param s: Input string containing only lowercase alphabetical characters. :return: A rearranged string or an empty string if rearrangement is not possible. >>> rearrange_string(\\"aab\\") \\"aba\\" >>> rearrange_string(\\"aaab\\") \\"\\"","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If not possible, returns an empty string. :param s: Input string containing only lowercase alphabetical characters. :return: A rearranged string or an empty string if rearrangement is not possible. # Count the frequency of each character freq = Counter(s) # Use a max heap (by storing negative frequencies) to store characters by their frequencies max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heappop(max_heap) if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) result.append(char) prev_count, prev_char = count + 1, char rearranged_str = ''.join(result) return rearranged_str if len(rearranged_str) == len(s) else \\"\\""},{"question":"def unique_substrings(input_str: str) -> List[str]: Returns a list of all possible unique substrings formed by removing exactly one character at each step until the string is empty. >>> unique_substrings(\\"abc\\") [\\"abc\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"a\\", \\"b\\", \\"c\\"] >>> unique_substrings(\\"aa\\") [\\"aa\\", \\"a\\"] >>> unique_substrings(\\"abcd\\") [\\"abcd\\", \\"abc\\", \\"abd\\", \\"acd\\", \\"bcd\\", \\"ab\\", \\"ac\\", \\"ad\\", \\"bc\\", \\"bd\\", \\"cd\\", \\"a\\", \\"b\\", \\"c\\", \\"d\\"] >>> unique_substrings(\\"\\") [] >>> unique_substrings(\\"a\\") [\\"a\\"] >>> unique_substrings(\\"aab\\") [\\"aab\\", \\"aa\\", \\"ab\\", \\"a\\", \\"b\\"]","solution":"def unique_substrings(input_str): Returns a list of all possible unique substrings formed by removing exactly one character at each step until the string is empty. if not input_str: return [] def generate_substrings(s): substrings = set() queue = [s] while queue: current = queue.pop(0) substrings.add(current) for i in range(len(current)): new_substring = current[:i] + current[i+1:] if new_substring and new_substring not in substrings: queue.append(new_substring) return sorted(substrings, key=lambda x: (-len(x), x)) return generate_substrings(input_str)"},{"question":"def most_frequent_char(s: str) -> str: Given a string, returns the most frequently occurring character in the string. If there are multiple characters with the same highest frequency, return the one that appears first in the string. >>> most_frequent_char(\\"character\\") -> \\"c\\" >>> most_frequent_char(\\"excellence\\") -> \\"e\\" >>> most_frequent_char(\\"aabbccddeeff\\") -> \\"a\\" >>> most_frequent_char(\\"abcabcabc\\") -> \\"a\\"","solution":"def most_frequent_char(s: str) -> str: from collections import Counter # Create a counter to count frequency of each character counter = Counter(s) # Find the character with the highest frequency max_count = max(counter.values()) # Find the first character that has the highest frequency for char in s: if counter[char] == max_count: return char"},{"question":"def assign_bonuses(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Assign bonuses to employees based on their performance scores. >>> assign_bonuses(3, [((3, 2), [100, 90, 80]), ((4, 3), [50, 50, 50, 50]), ((5, 1), [20, 35, 35, 20, 20])]) ['3 2 1', '4 3 2 1', '-1'] >>> assign_bonuses(1, [((3, 1), [100, 100, 100])]) ['-1'] >>> assign_bonuses(1, [((1, 1), [50])]) ['1'] >>> assign_bonuses(1, [((2, 1), [75, 75])]) ['2 1'] >>> assign_bonuses(1, [((5, 100), [87, 92, 85, 90, 88])]) result = assign_bonuses(1, [((5, 100), [87, 92, 85, 90, 88])]) assert len(result) == 1 assert result[0].count(' ') == 4 # ensure there are 5 numbers assert result[0] != '-1'","solution":"def assign_bonuses(T, test_cases): results = [] for i in range(T): N, D = test_cases[i][0] scores = test_cases[i][1] sorted_indices = sorted(range(N), key=lambda x: scores[x], reverse=True) bonuses = [0] * N max_bonus = N for idx in sorted_indices: bonuses[idx] = max_bonus max_bonus -= 1 max_difference = max(bonuses) - min(bonuses) if max_difference <= D: results.append(\\" \\".join(map(str, bonuses))) else: results.append(\\"-1\\") return results # Example usage T = 3 test_cases = [ ((3, 2), [100, 90, 80]), ((4, 3), [50, 50, 50, 50]), ((5, 1), [20, 35, 35, 20, 20]) ] print(assign_bonuses(T, test_cases)) # Expected: ['3 2 1', '4 3 2 1', '-1']"},{"question":"from typing import List def canPartition(array: List[int]) -> bool: Determine whether a given array of integers can be partitioned into two subsets such that the sum of the elements in both subsets is equal. >>> canPartition([1, 5, 11, 5]) # returns True because [1, 5, 5] and [11] >>> canPartition([1, 2, 3, 5]) # returns False because no such subsets exist >>> canPartition([1, 1, 1, 1, 1, 1]) # returns True because [1, 1, 1] and [1, 1, 1] >>> canPartition([]) # returns True, two empty subsets.","solution":"def canPartition(array): Determines whether a given array of integers can be partitioned into two subsets such that the sum of the elements in both subsets is equal. total_sum = sum(array) # If total sum is odd, cannot partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(array) # DP array to store whether subset with sum j can be formed dp = [False] * (target + 1) dp[0] = True for num in array: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def handle_queries(N: int, S: str, Q: int, queries: List[str]) -> List[int]: Handle the given queries on the string S. Parameters: - N: Length of the string S - S: The initial string - Q: Number of queries - queries: List of queries Returns: - List of results for type 1 queries results = [] from typing import List def test_handle_queries_sample_case(): N = 5 S = \\"ababc\\" Q = 4 queries = [\\"1 1 3\\", \\"2 2 d\\", \\"1 1 3\\", \\"1 2 5\\"] expected = [2, 2, 4] assert handle_queries(N, S, Q, queries) == expected def test_handle_queries_single_character_query(): N = 1 S = \\"a\\" Q = 2 queries = [\\"1 1 1\\", \\"2 1 b\\"] expected = [1] # Only one distinct character in \\"a\\" assert handle_queries(N, S, Q, queries) == expected def test_handle_queries_multiple_changes(): N = 6 S = \\"aaaaaa\\" Q = 3 queries = [\\"1 1 6\\", \\"2 3 b\\", \\"1 1 6\\"] expected = [1, 2] assert handle_queries(N, S, Q, queries) == expected def test_handle_queries_distinct_chars_and_changes(): N = 6 S = \\"abcdef\\" Q = 4 queries = [\\"1 1 6\\", \\"2 2 a\\", \\"1 1 6\\", \\"2 5 d\\"] expected = [6, 5] # Initially 6 distinct chars, then 'a' is repeated assert handle_queries(N, S, Q, queries) == expected","solution":"def handle_queries(N, S, Q, queries): Handle the given queries on the string S. Parameters: - N: Length of the string S - S: The initial string - Q: Number of queries - queries: List of queries Returns: - List of results for type 1 queries results = [] s_list = list(S) # Convert string to list for mutability for query in queries: parts = query.split() if parts[0] == '1': # Type 1 query l = int(parts[1]) - 1 r = int(parts[2]) - 1 substring = s_list[l:r+1] distinct_count = len(set(substring)) results.append(distinct_count) elif parts[0] == '2': # Type 2 query i = int(parts[1]) - 1 c = parts[2] s_list[i] = c return results"},{"question":"from typing import List def combinationSum(numbers: List[int], target: int) -> List[List[int]]: Finds all unique combinations in \`numbers\` where the candidate numbers sum to \`target\`. The same repeated number may be chosen from \`numbers\` an unlimited number of times. The solution set must not contain duplicate combinations. Example: >>> combinationSum([2,3,6,7], 7) [[2,2,3], [7]] >>> combinationSum([2,3,5], 8) [[2,2,2,2], [2,3,3], [3,5]]","solution":"from typing import List def combinationSum(numbers: List[int], target: int) -> List[List[int]]: def backtrack(remain, combo, start): if remain == 0: results.append(list(combo)) return elif remain < 0: return for i in range(start, len(numbers)): combo.append(numbers[i]) backtrack(remain - numbers[i], combo, i) combo.pop() results = [] backtrack(target, [], 0) return results"},{"question":"def max_discount_value(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Calculate the maximum total value a customer can get using at most K discount offers for each test case. >>> max_discount_value(2, [(5, 3, [1, 2, 3, 4, 5]), (4, 2, [10, 8, 5, 3])]) [12, 18] >>> max_discount_value(1, [(6, 2, [1, 2, 3, 4, 5, 6])]) [11] >>> max_discount_value(1, [(5, 3, [5, 5, 5, 5, 5])]) [15] >>> max_discount_value(1, [(1, 1, [10])]) [10] >>> max_discount_value(1, [(4, 4, [1, 2, 3, 4])]) [10]","solution":"def max_discount_value(T, test_cases): results = [] for t in range(T): N, K, offers = test_cases[t] offers.sort(reverse=True) results.append(sum(offers[:K])) return results"},{"question":"def fib_sum(n: int) -> int: Returns the sum of the first \`n\` numbers in the Fibonacci sequence. >>> fib_sum(0) 0 >>> fib_sum(1) 0 >>> fib_sum(2) 1 >>> fib_sum(3) 2 >>> fib_sum(5) 7 >>> fib_sum(10) 88 pass def test_fib_sum_zero(): assert fib_sum(0) == 0 def test_fib_sum_one(): assert fib_sum(1) == 0 def test_fib_sum_two(): assert fib_sum(2) == 1 def test_fib_sum_three(): assert fib_sum(3) == 2 def test_fib_sum_five(): assert fib_sum(5) == 7 def test_fib_sum_ten(): assert fib_sum(10) == 88 def test_fib_sum_large(): # This is just a rough check for large inputs. It verifies that the function does not crash. assert fib_sum(1000) > 0","solution":"def fib_sum(n: int) -> int: Returns the sum of the first \`n\` numbers in the Fibonacci sequence. if n <= 0: return 0 elif n == 1: return 0 elif n == 2: return 1 fib1, fib2 = 0, 1 total = fib1 + fib2 for _ in range(2, n): fib_next = fib1 + fib2 total += fib_next fib1, fib2 = fib2, fib_next return total"},{"question":"def team_projects(t: int, data: List[Tuple[int, List[str]]]) -> List[str]: Check if it is possible to form projects with teams having diverse skills. >>> team_projects(2, [(6, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\", \\"mno\\", \\"pqr\\"]), (3, [\\"abc\\", \\"aef\\", \\"ghi\\"])]) [\\"Possible\\", \\"Impossible\\"] >>> team_projects(1, [(6, [\\"abc\\", \\"bca\\", \\"cab\\", \\"def\\", \\"edf\\", \\"fgh\\"])]) [\\"Impossible\\"] >>> team_projects(1, [(9, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\", \\"mno\\", \\"pqr\\", \\"stu\\", \\"vwx\\", \\"yz\\"])]) [\\"Possible\\"] >>> team_projects(1, [(3, [\\"abc\\", \\"def\\", \\"ghi\\"])]) [\\"Possible\\"] >>> team_projects(1, [(4, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"])]) [\\"Impossible\\"] >>> team_projects(1, [(3, [\\"a\\", \\"b\\", \\"c\\"])]) [\\"Possible\\"] >>> team_projects(1, [(3, [\\"aaa\\", \\"bbb\\", \\"ccc\\"])]) [\\"Possible\\"] >>> team_projects(1, [(1, [\\"abc\\"])]) [\\"Impossible\\"]","solution":"def is_project_possible(n, skills): from itertools import combinations for combination in combinations(skills, 3): combined_skills = set(combination[0]) is_valid_team = True for skill in combination[1:]: if combined_skills & set(skill): is_valid_team = False break combined_skills.update(skill) if is_valid_team: return \\"Possible\\" return \\"Impossible\\" def team_projects(t, data): results = [] for i in range(t): n = data[i][0] skills = data[i][1] if n % 3 != 0: results.append(\\"Impossible\\") else: results.append(is_project_possible(n, skills)) return results"},{"question":"def find_second_largest(lst: List[int]) -> Optional[int]: Write a function that takes a list of integers and returns the second largest unique number in the list. If such a number does not exist, return \`None\`. >>> find_second_largest([1, 2, 3, 4, 5]) 4 >>> find_second_largest([5, 5, 4, 4, 3]) 3 >>> find_second_largest([1, 1, 1, 1]) None >>> find_second_largest([-1, -2, -3, -4]) -2 >>> find_second_largest([-1, 3, 1, 2, -4]) 2 >>> find_second_largest([1, 2]) 1 >>> find_second_largest([1]) None >>> find_second_largest([]) None","solution":"def find_second_largest(lst): Returns the second largest unique number in the list or \`None\` if it does not exist. unique_numbers = list(set(lst)) if len(unique_numbers) < 2: return None unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"def find_most_common_fruit(fruits: str) -> str: Returns the fruit with the maximum occurrences in the string. If multiple fruits have the same maximum occurrences, returns the one that appears first in the string. >>> find_most_common_fruit(\\"apple,banana,orange,apple,apple,banana\\") \\"apple\\" >>> find_most_common_fruit(\\"grape,peach,grape,apple,peach,peach\\") \\"peach\\" >>> find_most_common_fruit(\\"kiwi,kiwi,mango,kiwi,mango,mango\\") \\"kiwi\\"","solution":"def find_most_common_fruit(fruits: str) -> str: Returns the fruit with the maximum occurrences in the string. If multiple fruits have the same maximum occurrences, returns the one that appears first in the string. fruit_list = fruits.split(',') fruit_count = {} for fruit in fruit_list: if fruit in fruit_count: fruit_count[fruit] += 1 else: fruit_count[fruit] = 1 max_count = 0 most_common_fruit = \\"\\" for fruit in fruit_list: if fruit_count[fruit] > max_count: max_count = fruit_count[fruit] most_common_fruit = fruit return most_common_fruit"},{"question":"def min_cost_to_reach(x, y, costRight, costUp): Calculate the minimum cost to reach position (x, y) from (0,0) on a 2D grid given the cost of moving right and up. Args: x (int): target x-coordinate y (int): target y-coordinate costRight (int): cost of moving right costUp (int): cost of moving up Returns: int: minimum cost to reach (x, y) >>> min_cost_to_reach(2, 3, 1, 2) 8 >>> min_cost_to_reach(3, 3, 4, 1) 15","solution":"def min_cost_to_reach(x, y, costRight, costUp): Calculate the minimum cost to reach position (x, y) from (0,0) on a 2D grid given the cost of moving right and up. Args: x (int): target x-coordinate y (int): target y-coordinate costRight (int): cost of moving right costUp (int): cost of moving up Returns: int: minimum cost to reach (x, y) return x * costRight + y * costUp"},{"question":"from typing import List, Tuple, Optional def process_scores(scores: List[int], invalid_score: int) -> Tuple[float, Optional[int], List[int]]: Process the scores list by removing the invalid_score, calculating average of the remaining scores, finding the most frequent score, and returning the sorted list of remaining scores. :param scores: List[int] - list of scores :param invalid_score: int - score that should be removed from the list :return: Tuple[float, Optional[int], List[int]] - average score, most frequent score, sorted remaining scores. :Example: >>> process_scores([10, 20, 20, 30], 0) (20.0, 20, [10, 20, 20, 30]) >>> process_scores([0, 10, 0, 20], 0) (15.0, 10, [10, 20]) pass # Sample Test Cases def test_process_scores_basic(): scores = [10, 20, 20, 30] avg_score, most_frequent_score, sorted_scores = process_scores(scores, 0) assert avg_score == 20.0 assert most_frequent_score == 20 assert sorted_scores == [10, 20, 20, 30] def test_process_scores_with_invalid_scores(): scores = [0, 10, 0, 20] avg_score, most_frequent_score, sorted_scores = process_scores(scores, 0) assert avg_score == 15.0 assert most_frequent_score == 10 # Both 10 and 20 appear once; either can be the result. assert sorted_scores == [10, 20] def test_process_scores_all_invalid_scores(): scores = [0, 0, 0, 0] avg_score, most_frequent_score, sorted_scores = process_scores(scores, 0) assert avg_score == 0 assert most_frequent_score is None assert sorted_scores == [] def test_process_scores_empty_list(): scores = [] avg_score, most_frequent_score, sorted_scores = process_scores(scores, 0) assert avg_score == 0 assert most_frequent_score is None assert sorted_scores == [] def test_process_scores_tie_most_frequent(): scores = [5, 5, 7, 7] avg_score, most_frequent_score, sorted_scores = process_scores(scores, 0) assert avg_score == 6.0 assert most_frequent_score in (5, 7) assert sorted_scores == [5, 5, 7, 7]","solution":"from collections import Counter from statistics import mean def process_scores(scores, invalid_score): Process the scores list by removing the invalid_score, calculating average of the remaining scores, finding the most frequent score, and returning the sorted list of remaining scores. :param scores: List[int] - list of scores :param invalid_score: int - score that should be removed from the list :return: Tuple[float, int, List[int]] - average score, most frequent score, sorted remaining scores # Step 1: Remove all occurrences of the invalid_score filtered_scores = [score for score in scores if score != invalid_score] # Step 2: Calculate the average score avg_score = mean(filtered_scores) if filtered_scores else 0 # Step 3: Find the most frequent score if filtered_scores: score_counts = Counter(filtered_scores) most_frequent_score = score_counts.most_common(1)[0][0] else: most_frequent_score = None # Step 4: Return the sorted list of remaining scores sorted_scores = sorted(filtered_scores) return avg_score, most_frequent_score, sorted_scores"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subarray within the given list of integers. If the array consists solely of negative numbers, the function returns 0. >>> max_subarray_sum([34, -50, 42, 14, -5, 86]) 137 >>> max_subarray_sum([100, -100, 50, -50, 50, -50, 200]) 200 >>> max_subarray_sum([-10, -5, -2]) 0 >>> max_subarray_sum([8, -19, 5, -4, 20]) 21","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subarray. If all elements are negative, returns 0. max_sum = 0 current_sum = 0 for num in arr: current_sum = max(0, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def remove_duplicates(nums: List[int]) -> int: Removes duplicates from the sorted list nums in-place and returns the new length of the list with unique elements. Parameters: nums (List[int]): A list of sorted integers. Returns: int: The length of list after duplicates have been removed. >>> remove_duplicates([1, 1, 2]) 2 >>> remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]) 5 >>> remove_duplicates([1, 2, 3, 4, 5]) 5 >>> remove_duplicates([1, 1, 1, 1, 1]) 1 >>> remove_duplicates([]) 0 >>> remove_duplicates([1]) 1","solution":"def remove_duplicates(nums): Removes duplicates from the sorted list nums in-place and returns the new length of the list with unique elements. Parameters: nums (List[int]): A list of sorted integers. Returns: int: The length of list after duplicates have been removed. if not nums: return 0 # Index to place the next unique element unique_index = 1 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[unique_index] = nums[i] unique_index += 1 return unique_index"},{"question":"def reorder_log_files(logs: List[str]) -> List[str]: Reorder the logs so that: 1. The letter-logs come before all digit-logs. 2. The letter-logs are sorted lexicographically by their content. If their contents are the same, then sort them lexicographically by their identifiers. 3. The digit-logs should be put in their original order. >>> reorder_log_files([\\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\"]) [\\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] >>> reorder_log_files([\\"a1 9 2 3 1\\", \\"g1 act car\\", \\"a2 act car\\", \\"a10 act zoo\\", \\"zo4 4 7\\"]) [\\"a2 act car\\", \\"g1 act car\\", \\"a10 act zoo\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] from solution import reorder_log_files def test_example_case(): logs = [\\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\"] expected = [\\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] assert reorder_log_files(logs) == expected def test_mixed_letter_and_digit_logs(): logs = [\\"a1 9 2 3 1\\", \\"g1 act car\\", \\"a2 act car\\", \\"a10 act zoo\\", \\"zo4 4 7\\"] expected = [\\"a2 act car\\", \\"g1 act car\\", \\"a10 act zoo\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] assert reorder_log_files(logs) == expected def test_only_digit_logs(): logs = [\\"a1 9 2 3 1\\", \\"zo4 4 7\\", \\"b1 6 5 4\\", \\"c3 3 2 1\\"] expected = [\\"a1 9 2 3 1\\", \\"zo4 4 7\\", \\"b1 6 5 4\\", \\"c3 3 2 1\\"] assert reorder_log_files(logs) == expected def test_only_letter_logs(): logs = [\\"g1 act car\\", \\"a2 act car\\", \\"a10 act zoo\\", \\"z0 zoo act\\"] expected = [\\"a2 act car\\", \\"g1 act car\\", \\"a10 act zoo\\", \\"z0 zoo act\\"] assert reorder_log_files(logs) == expected def test_same_content_different_identifiers(): logs = [\\"a1 act car\\", \\"g1 act car\\", \\"b2 act zoo\\", \\"c3 act car\\"] expected = [\\"a1 act car\\", \\"c3 act car\\", \\"g1 act car\\", \\"b2 act zoo\\"] assert reorder_log_files(logs) == expected","solution":"def reorder_log_files(logs): Reorders logs so that letter-logs come before digit-logs, sorted lexicographically. # Separate logs into two categories: letter-logs and digit-logs letter_logs, digit_logs = [], [] # Classify each log as either a letter-log or a digit-log for log in logs: # Split each log by the first space to separate the identifier and the content identifier, rest = log.split(\\" \\", 1) if rest[0].isdigit(): digit_logs.append(log) else: letter_logs.append((identifier, rest)) # Sort the letter-logs by content and then by identifier in case of ties letter_logs.sort(key=lambda log: (log[1], log[0])) # Reconstruct the sorted letter-logs sorted_letter_logs = [\\"{} {}\\".format(identifier, rest) for identifier, rest in letter_logs] # Combine sorted letter-logs with original order digit-logs return sorted_letter_logs + digit_logs"},{"question":"import re from collections import Counter from typing import List def count_keywords(K: int, keywords: List[str], C: int, comments: List[str]) -> List[str]: Counts the number of times each keyword appears in the comments. Args: K (int): The number of keywords. keywords (List[str]): The list of keywords. C (int): The number of feedback comments. comments (List[str]): The list of feedback comments. Returns: List[str]: List of keywords and their counts in descending order of their counts, in case of tie, ordered lexicographically. Examples: --------- >>> count_keywords(3, ['performance', 'functionality', 'usability'], 5, [ 'The PERFORMANCE of the app is great!', 'I love the usability and functionality of this tool.', 'Performance-wise, it is outstanding.', 'However, the Usability aspect can be improved.', 'Overall, the functionality is top-notch.' ]) ['performance 2', 'functionality 2', 'usability 2']","solution":"import re from collections import Counter, defaultdict def count_keywords(K, keywords, C, comments): keyword_counts = Counter() keyword_set = set(key.lower() for key in keywords) for comment in comments: words = re.findall(r'bw+b', comment.lower()) for word in words: if word in keyword_set: keyword_counts[word] += 1 sorted_keywords = sorted(keyword_counts.items(), key=lambda x: (-x[1], x[0])) result = [] for keyword, count in sorted_keywords: result.append(f\\"{keyword} {count}\\") return result"},{"question":"def is_palindrome(s: str) -> bool: Checks if the provided string is a palindrome, ignoring case, spaces, and punctuation. Args: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"123321\\") True >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True pass","solution":"import re def is_palindrome(s: str) -> bool: Checks if the provided string is a palindrome, ignoring case, spaces, and punctuation. Args: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Use regex to remove non-alphanumeric characters and convert to lowercase filtered_str = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the filtered string is equal to its reverse return filtered_str == filtered_str[::-1]"},{"question":"def string_transform(s: str) -> str: Transforms the given string according to the specified rules: - Reverses the order of the letters in each word. - Capitalizes the first letter of each word. - Makes all other letters lowercase. Args: s (str): The input string consisting of alphabets and spaces. Returns: str: The transformed string. >>> string_transform(\\"hello WORLD\\") 'Olleh Dlrow' >>> string_transform(\\"This Is A TEST\\") 'Siht Si A Tset' >>> string_transform(\\"\\") '' >>> string_transform(\\"hElLo WoRlD\\") 'Olleh Dlrow' >>> string_transform(\\" hello world \\") 'Olleh Dlrow' >>> string_transform(\\"HELLO WORLD\\") 'Olleh Dlrow' >>> string_transform(\\"hello world\\") 'Olleh Dlrow'","solution":"def string_transform(s): Transforms the given string according to the specified rules: - Reverses the order of the letters in each word. - Capitalizes the first letter of each word. - Makes all other letters lowercase. Args: s (str): The input string consisting of alphabets and spaces. Returns: str: The transformed string. words = s.split() transformed_words = [ word[::-1].capitalize() for word in words ] return ' '.join(transformed_words)"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths in a grid with obstacles. >>> unique_paths_with_obstacles([ ... [0,0,0], ... [0,1,0], ... [0,0,0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0,1], ... [0,0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [1,0], ... [0,0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0,0], ... [0,1] ... ]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths in a grid with obstacles. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def format_duration(seconds: int) -> str: Convert a given amount of seconds to a string representing hours, minutes, and seconds. >>> format_duration(3665) # \\"1 hour, 1 minute and 5 seconds\\" >>> format_duration(7325) # \\"2 hours, 2 minutes and 5 seconds\\" >>> format_duration(59) # \\"59 seconds\\" >>> format_duration(3600) # \\"1 hour\\"","solution":"def format_duration(seconds): Convert a given amount of seconds to a string representing hours, minutes, and seconds. hours = seconds // 3600 minutes = (seconds % 3600) // 60 seconds = seconds % 60 parts = [] if hours > 0: parts.append(f\\"{hours} hour\\" + (\\"s\\" if hours > 1 else \\"\\")) if minutes > 0: parts.append(f\\"{minutes} minute\\" + (\\"s\\" if minutes > 1 else \\"\\")) if seconds > 0 or not parts: parts.append(f\\"{seconds} second\\" + (\\"s\\" if seconds != 1 else \\"\\")) if len(parts) > 1: return f\\"{', '.join(parts[:-1])} and {parts[-1]}\\" return parts[0]"},{"question":"def max_consecutive_weeks_above_threshold(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Find the maximum number of consecutive weeks where an employee's total hours worked per week exceed a specified threshold. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains: - W (int): Number of weeks. - H (int): Threshold hours. - List[int]: List of total hours worked per week. Returns: List[int]: A list of integers representing the maximum number of consecutive weeks exceeding the threshold hours for each test case. Example: >>> max_consecutive_weeks_above_threshold(2, [(6, 40, [45, 50, 38, 42, 43, 39]), (3, 35, [36, 44, 32])]) [2, 2] >>> max_consecutive_weeks_above_threshold(1, [(4, 50, [60, 55, 50, 40])]) [2]","solution":"def max_consecutive_weeks_above_threshold(T, test_cases): results = [] for i in range(T): W, H = test_cases[i][:2] hours = test_cases[i][2] max_consec = 0 current_consec = 0 for hour in hours: if hour > H: current_consec += 1 if current_consec > max_consec: max_consec = current_consec else: current_consec = 0 results.append(max_consec) return results"},{"question":"def longest_substring_with_n_distinct_chars(strings: List[str], n: int) -> List[str]: Returns the longest substring within each string that consists of at most n distinct characters. :param strings: List of input strings :param n: Maximum number of distinct characters allowed in the substring :return: List of longest substrings >>> longest_substring_with_n_distinct_chars([\\"abcba\\"], 2) [\\"bcb\\"] >>> longest_substring_with_n_distinct_chars([\\"aa\\"], 1) [\\"aa\\"] >>> longest_substring_with_n_distinct_chars([\\"abcde\\"], 3) [\\"abc\\"] >>> longest_substring_with_n_distinct_chars([\\"abcabc\\"], 2) [\\"ab\\"] >>> longest_substring_with_n_distinct_chars([\\"aabacbebebe\\"], 3) [\\"cbebebe\\"] >>> longest_substring_with_n_distinct_chars([\\"abcba\\", \\"abcdef\\", \\"aabbcc\\"], 2) [\\"bcb\\", \\"ab\\", \\"aabb\\"] >>> longest_substring_with_n_distinct_chars([\\"\\", \\"a\\", \\"aaabb\\"], 2) [\\"\\", \\"a\\", \\"aaabb\\"] >>> longest_substring_with_n_distinct_chars([\\"x\\"], 1) [\\"x\\"] >>> longest_substring_with_n_distinct_chars([\\"ab\\"], 3) [\\"ab\\"] >>> longest_substring_with_n_distinct_chars([\\"aaaaaaa\\"], 1) [\\"aaaaaaa\\"] >>> longest_substring_with_n_distinct_chars([\\"bbb\\"], 2) [\\"bbb\\"] >>> longest_substring_with_n_distinct_chars([\\"abc\\"], 5) [\\"abc\\"] >>> longest_substring_with_n_distinct_chars([\\"abcd\\"], 10) [\\"abcd\\"]","solution":"def longest_substring_with_n_distinct_chars(strings, n): Returns the longest substring within each string that consists of at most n distinct characters. :param strings: List of input strings :param n: Maximum number of distinct characters allowed in the substring :return: List of longest substrings def longest_substring(s, n): from collections import defaultdict left = 0 right = 0 max_len = 0 max_substr = \\"\\" char_count = defaultdict(int) while right < len(s): char_count[s[right]] += 1 while len(char_count) > n: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if (right - left + 1) > max_len: max_len = right - left + 1 max_substr = s[left:right + 1] right += 1 return max_substr return [longest_substring(s, n) for s in strings]"},{"question":"def is_manager(n: int, reports: List[List[int]], a: int, b: int) -> bool: Determine if employee \`a\` is a direct or indirect manager of employee \`b\`. >>> is_manager(6, [[0,1],[0,2],[1,3],[1,4],[2,5]], 0, 4) == True >>> is_manager(6, [[0,1],[0,2],[1,3],[1,4],[2,5]], 1, 5) == False >>> is_manager(4, [[0,1],[1,2],[2,3]], 1, 3) == True >>> is_manager(4, [[0,1],[1,2],[2,3]], 2, 3) == True >>> is_manager(5, [[0,1],[1,2],[2,3],[0,4]], 4, 3) == False >>> is_manager(10000, [[i, i+1] for i in range(9999)], 0, 9999) == True >>> is_manager(5, [[0,1],[0,2],[1,3],[2,4]], 1, 4) == False","solution":"def is_manager(n, reports, a, b): Determine if employee \`a\` is a direct or indirect manager of employee \`b\`. from collections import defaultdict, deque management_tree = defaultdict(list) for manager, direct_report in reports: management_tree[manager].append(direct_report) queue = deque([a]) while queue: current = queue.popleft() if current == b: return True for direct_report in management_tree[current]: queue.append(direct_report) return False"},{"question":"def is_prime(n: int) -> bool: Determines if the given number n is a prime number. Args: n (int): The number to check for primality. Returns: bool: True if n is a prime number, False otherwise. >>> is_prime(11) True >>> is_prime(4) False >>> is_prime(-3) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(17) True","solution":"def is_prime(n): Determines if the given number n is a prime number. Args: n (int): The number to check for primality. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True"},{"question":"def is_valid_sudoku(grid): Determine if the given 9x9 Sudoku puzzle is valid according to standard Sudoku rules. Arguments: grid -- List of Lists of integers representing a 9x9 Sudoku puzzle. Returns: Boolean value True if the grid is a valid Sudoku puzzle, and False otherwise. >>> is_valid_sudoku([[5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9]]) == True >>> is_valid_sudoku([[5, 3, 0, 0, 7, 0, 0, 0, 3], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9]]) == False","solution":"def is_valid_sudoku(grid): def is_valid_group(group): elements = [num for num in group if num != 0] return len(elements) == len(set(elements)) for row in grid: if not is_valid_group(row): return False for col in range(9): if not is_valid_group([grid[row][col] for row in range(9)]): return False for box_row in range(0, 9, 3): for box_col in range(0, 9, 3): sub_grid = [grid[r][c] for r in range(box_row, box_row + 3) for c in range(box_col, box_col + 3)] if not is_valid_group(sub_grid): return False return True"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the integer n. >>> sum_of_digits(123) 6 >>> sum_of_digits(0) 0 >>> sum_of_digits(4567) 22","solution":"def sum_of_digits(n): Returns the sum of the digits of the integer n. return sum(int(digit) for digit in str(n))"},{"question":"from typing import List, Tuple def can_rearrange_to_form_t(q: int, test_cases: List[Tuple[int, str, str]]) -> List[str]: Determines if it is possible to rearrange the letters of s to form t by performing the described operation any number of times. Args: q : int : the number of test cases test_cases : List[Tuple[int, str, str]] : a list of tuples where each tuple contains an integer n (the length of the strings), and two strings s and t which are the strings in question Returns: List[str] : a list of strings where each entry is either \\"YES\\" or \\"NO\\" indicating whether it is possible to rearrange s to form t for each test case. Example: >>> can_rearrange_to_form_t(3, [(4, \\"abcd\\", \\"dcba\\"), (5, \\"abcde\\", \\"edcba\\"), (6, \\"aabbcc\\", \\"ccbbaa\\")]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_rearrange_to_form_t(3, [(4, \\"abcd\\", \\"abcd\\"), (5, \\"abcde\\", \\"abcde\\"), (6, \\"aabbcc\\", \\"aabbcc\\")]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_rearrange_to_form_t(q, test_cases): results = [] for i in range(q): n, s, t = test_cases[i] if sorted(s) == sorted(t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def total_coins(n: int) -> int: Calculate the total number of coins a player will have after completing \`n\` levels. The number of coins at each level follows the pattern where it doubles each level. Level 1 has 1 coin, level 2 has 2 coins, level 3 has 4 coins, and so on. Args: n (int): The number of levels completed by the player. Returns: int: The total number of coins after \`n\` levels. Examples: >>> total_coins(1) 1 >>> total_coins(2) 3 >>> total_coins(3) 7 >>> total_coins(4) 15","solution":"def total_coins(n): Calculate the total number of coins a player will have after completing \`n\` levels. The number of coins at each level follows the pattern where it doubles each level. Level 1 has 1 coin, level 2 has 2 coins, level 3 has 4 coins, and so on. Args: n (int): The number of levels completed by the player. Returns: int: The total number of coins after \`n\` levels. total = 0 coins = 1 for level in range(1, n + 1): total += coins coins *= 2 return total"},{"question":"def fizz_buzz(n: int) -> str: Takes an integer n and returns a string representing the number in \\"FizzBuzz\\" format. >>> fizz_buzz(3) == \\"Fizz\\" >>> fizz_buzz(5) == \\"Buzz\\" >>> fizz_buzz(15) == \\"FizzBuzz\\" >>> fizz_buzz(7) == \\"7\\"","solution":"def fizz_buzz(n): Returns a string representing the number in \\"FizzBuzz\\" format. if n % 3 == 0 and n % 5 == 0: return \\"FizzBuzz\\" elif n % 3 == 0: return \\"Fizz\\" elif n % 5 == 0: return \\"Buzz\\" else: return str(n)"},{"question":"def find_substrings(s: str, k: int) -> list[str]: Returns all unique substrings of length \`k\` in lexicographical order. Args: s (str): Input string containing only lowercase alphabets. k (int): Length of the substrings to be found. Returns: list[str]: A list of unique substrings of length \`k\` in lexicographical order. Examples: >>> find_substrings(\\"abcabc\\", 3) ['abc', 'bca', 'cab'] >>> find_substrings(\\"banana\\", 2) ['an', 'ba', 'na'] # your code here # Test cases def test_example(): assert find_substrings(\\"abcabc\\", 3) == ['abc', 'bca', 'cab'] def test_single_character_substrings(): assert find_substrings(\\"aaaa\\", 1) == ['a'] def test_all_unique_characters(): assert find_substrings(\\"abcdef\\", 2) == ['ab', 'bc', 'cd', 'de', 'ef'] def test_multiple_unique_substrings(): assert find_substrings(\\"banana\\", 2) == ['an', 'ba', 'na'] def test_length_equal_to_string(): assert find_substrings(\\"abcdef\\", 6) == ['abcdef'] def test_one_character_string(): assert find_substrings(\\"a\\", 1) == ['a'] def test_k_equals_1(): assert find_substrings(\\"abcabc\\", 1) == ['a', 'b', 'c']","solution":"def find_substrings(s: str, k: int) -> list[str]: Returns all unique substrings of length \`k\` in lexicographical order. substrings = set() # Generate all substrings of length k for i in range(len(s) - k + 1): substring = s[i:i + k] substrings.add(substring) # Return the substrings as a sorted list in lexicographical order return sorted(substrings)"},{"question":"def oldest_in_each_group(people_str: str) -> str: Returns the oldest person in each group along with their age in the format \\"Group X: Name|Age, Group Y: Name|Age, ...\\". The comparison of group characters is case-insensitive and retains original cases in the output. If the input string is empty, it returns an empty string. >>> oldest_in_each_group(\\"John Doe|45|A, Jane Smith|30|B, Alice Johnson|25|A, Bob Brown|22|B, Charlie Black|28|A\\") \\"Group A: John Doe|45, Group B: Jane Smith|30\\" >>> oldest_in_each_group(\\"John Doe|45|a, Jane Smith|30|B, Alice Johnson|25|A, Bob Brown|50|b, Charlie Black|28|A\\") \\"Group A: John Doe|45, Group B: Bob Brown|50\\" from solution import oldest_in_each_group def test_example_case(): input_str = \\"John Doe|45|A, Jane Smith|30|B, Alice Johnson|25|A, Bob Brown|22|B, Charlie Black|28|A\\" output_str = \\"Group A: John Doe|45, Group B: Jane Smith|30\\" assert oldest_in_each_group(input_str) == output_str def test_empty_input(): assert oldest_in_each_group(\\"\\") == \\"\\" def test_all_same_group(): input_str = \\"John Doe|45|A, Jane Smith|50|A, Alice Johnson|25|A\\" output_str = \\"Group A: Jane Smith|50\\" assert oldest_in_each_group(input_str) == output_str def test_multiple_oldest_same_age(): input_str = \\"John Doe|45|A, Jane Smith|45|B, Alice Johnson|45|A\\" output_str = \\"Group A: John Doe|45, Group B: Jane Smith|45\\" result = oldest_in_each_group(input_str) assert result == output_str or result == \\"Group A: Alice Johnson|45, Group B: Jane Smith|45\\" def test_case_insensitive_groups(): input_str = \\"John Doe|45|A, Jane Smith|30|b, Alice Johnson|25|a, Bob Brown|22|B, Charlie Black|28|A\\" output_str = \\"Group A: John Doe|45, Group B: Jane Smith|30\\" assert oldest_in_each_group(input_str) == output_str def test_single_person_each_group(): input_str = \\"John Doe|45|A, Jane Smith|30|B\\" output_str = \\"Group A: John Doe|45, Group B: Jane Smith|30\\" assert oldest_in_each_group(input_str) == output_str def test_mixed_case_groups(): input_str = \\"John Doe|45|a, Jane Smith|30|B, Alice Johnson|25|A, Bob Brown|50|b, Charlie Black|28|A\\" output_str = \\"Group A: John Doe|45, Group B: Bob Brown|50\\" assert oldest_in_each_group(input_str) == output_str","solution":"def oldest_in_each_group(people_str): if not people_str: return \\"\\" people = people_str.split(\\", \\") groups = {} for person in people: name, age, group = person.split(\\"|\\") age = int(age) group = group.lower() # Case-insensitive comparison if group not in groups or groups[group][1] < age: groups[group] = (name, age) result = [] for group in sorted(groups): name, age = groups[group] result.append(f\\"Group {group.upper()}: {name}|{age}\\") return \\", \\".join(result)"},{"question":"def checkerboard_pattern(n: int) -> str: Generates a checkerboard pattern of size n x n using '#' and ' ' starting with '#'. Parameters: n : int : the size of the checkerboard (should be even and >= 4) Returns: str : a string representing the checkerboard pattern with rows separated by 'n' >>> checkerboard_pattern(4) '# # n # #n# # n # #' >>> checkerboard_pattern(6) '# # # n # # #n# # # n # # #n# # # n # # #'","solution":"def checkerboard_pattern(n): Generates a checkerboard pattern of size n x n using '#' and ' ' starting with '#'. Parameters: n : int : the size of the checkerboard (should be even and >= 4) Returns: str : a string representing the checkerboard pattern with rows separated by 'n' pattern = \\"\\" for i in range(n): row = \\"\\" for j in range(n): if (i + j) % 2 == 0: row += \\"#\\" else: row += \\" \\" pattern += row + \\"n\\" return pattern.strip()"},{"question":"from typing import List def find_duplicate_numbers(nums: List[int]) -> List[int]: Find all numbers that appear twice in the input list. Assumes that the numbers are in the range 1 to n and the list size is n. Args: nums (list[int]): List of integers where each integer is in the range 1 to n. Returns: list[int]: List of duplicated integers. Examples: >>> find_duplicate_numbers([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicate_numbers([1, 1, 2]) [1] >>> find_duplicate_numbers([1]) [] def test_find_duplicate_numbers_example_1(): assert find_duplicate_numbers([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] def test_find_duplicate_numbers_example_2(): assert find_duplicate_numbers([1, 1, 2]) == [1] def test_find_duplicate_numbers_example_3(): assert find_duplicate_numbers([1]) == [] def test_find_duplicate_numbers_no_duplicates(): assert find_duplicate_numbers([1, 2, 3, 4, 5]) == [] def test_find_duplicate_numbers_single_duplicate(): assert find_duplicate_numbers([1, 2, 2, 3, 4]) == [2] def test_find_duplicate_numbers_all_duplicates(): assert find_duplicate_numbers([2, 2, 3, 3, 4, 4]) == [2, 3, 4]","solution":"def find_duplicate_numbers(nums): Function to find all numbers that appear twice in the input list. Assumes that the numbers are in the range 1 to n and the list size is n. Args: nums (list[int]): List of integers where each integer is in the range 1 to n. Returns: list[int]: List of duplicated integers. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) nums[index] = -nums[index] return duplicates"},{"question":"def max_area(heights: List[int]) -> int: Given an array of integers heights representing the heights of a set of buildings, finds the maximum area of water that can be trapped between the buildings. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 1, 1, 1]) 3 >>> max_area([1, 2, 3, 4, 5]) 6 >>> max_area([5, 4, 3, 2, 1]) 6 >>> max_area([1, 3, 2, 4, 1]) 6 >>> max_area([1, 3]) 1 >>> max_area([1]) Traceback (most recent call last): ... ValueError: List must contain at least two elements.","solution":"def max_area(heights): Given an array of integers heights representing the heights of a set of buildings, finds the maximum area of water that can be trapped between the buildings. left, right = 0, len(heights) - 1 max_area = 0 while left < right: # Calculate the current area width = right - left height = min(heights[left], heights[right]) current_area = width * height # Update the maximum area if the current area is greater max_area = max(max_area, current_area) # Move the left or right index inward to attempt to find a larger area if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"import re def validate_username(username: str) -> bool: Validates the username based on the given rules: - The username must be between 6 and 20 characters long. - It can only contain alphanumeric characters and underscores ('_'). - It must start with a letter. Args: username (str): the username to be validated Returns: bool: True if the username is valid, False otherwise pass def test_valid_usernames(): assert validate_username(\\"valid_User1\\") == True assert validate_username(\\"user123\\") == True def test_username_starts_with_digit(): assert validate_username(\\"123username\\") == False def test_username_too_long(): assert validate_username(\\"no_way_1234567_no_way_1234567\\") == False def test_username_with_invalid_characters(): assert validate_username(\\"user@name\\") == False def test_username_too_short(): assert validate_username(\\"short\\") == False def test_username_with_underscore(): assert validate_username(\\"user_name_1\\") == True def test_username_exact_min_length(): assert validate_username(\\"a12345\\") == True def test_username_exact_max_length(): assert validate_username(\\"a12345678901234567\\") == True","solution":"import re def validate_username(username): Validates the username based on the given rules: - The username must be between 6 and 20 characters long. - It can only contain alphanumeric characters and underscores ('_'). - It must start with a letter. Args: username (str): the username to be validated Returns: bool: True if the username is valid, False otherwise if 6 <= len(username) <= 20 and re.match(r'^[A-Za-z][A-Za-z0-9_]*', username): return True return False"},{"question":"def min_operations_to_sort_string(t: int, string_list: List[str]) -> List[int]: Returns the minimum number of operations required to sort the strings in non-decreasing order. Parameters: t (int): Number of test cases. string_list (list of str): List of strings for each test case. Returns: list of int: List of minimum operations for each test case. from solution import min_operations_to_sort_string def test_single_case_cba(): assert min_operations_to_sort_string(1, ['cba']) == [2] def test_single_case_bca(): assert min_operations_to_sort_string(1, ['bca']) == [1] def test_single_case_abc(): assert min_operations_to_sort_string(1, ['abc']) == [0] def test_multiple_cases(): assert min_operations_to_sort_string(3, ['cba', 'bca', 'abc']) == [2, 1, 0] def test_edge_case_single_char(): assert min_operations_to_sort_string(1, ['a']) == [0] def test_edge_case_identical_chars(): assert min_operations_to_sort_string(1, ['aaaa']) == [0] def test_no_operations_needed(): assert min_operations_to_sort_string(2, ['abcd', 'aabb']) == [0, 0] def test_reverse_entire_string(): assert min_operations_to_sort_string(1, ['dcba']) == [3] def test_min_change_and_reverse(): assert min_operations_to_sort_string(1, ['badc']) == [2]","solution":"def min_operations_to_sort_string(t, string_list): Returns the minimum number of operations required to sort the strings in non-decreasing order. Parameters: t (int): Number of test cases. string_list (list of str): List of strings for each test case. Returns: list of int: List of minimum operations for each test case. results = [] for s in string_list: sorted_s = ''.join(sorted(s)) if s == sorted_s: results.append(0) else: # Find the longest common subsequence length between s and sorted_s m, n = len(s), len(sorted_s) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == sorted_s[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] # Minimum operations to make the string sorted results.append(m - lcs_length) return results"},{"question":"def next_multiple_of_three(arr: List[int]) -> List[int]: Given an array of integers, this function returns a new array where each element is the first multiple of 3 that is greater than or equal to the original element. >>> next_multiple_of_three([2, 7, 13, 21]) [3, 9, 15, 21] >>> next_multiple_of_three([]) [] >>> next_multiple_of_three([3, 6, 9, 12]) [3, 6, 9, 12] >>> next_multiple_of_three([2, 5, 8, 11]) [3, 6, 9, 12] >>> next_multiple_of_three([1, 4, 6, 7, 14]) [3, 6, 6, 9, 15] >>> next_multiple_of_three([-2, -3, -4, 0, 1, 2]) [0, -3, -3, 0, 3, 3] >>> next_multiple_of_three([299, 300, 301]) [300, 300, 303]","solution":"def next_multiple_of_three(arr): Given an array of integers, this function returns a new array where each element is the first multiple of 3 that is greater than or equal to the original element. result = [] for num in arr: if num % 3 == 0: result.append(num) else: result.append((num // 3 + 1) * 3) return result"},{"question":"def find_min_time_to_visit_all_parks(N: int, E: int, roads: List[Tuple[int, int, int]], P: int, parks: List[int]) -> int: Find the minimum time required to visit all the parks starting from any park. Args: N (int): The number of intersections (nodes) in the city. E (int): The number of roads (edges) in the city. roads (List[Tuple[int, int, int]]): The list of roads where each road is represented by a tuple (u, v, w) indicating a road between intersections \`u\` and \`v\` with travel time \`w\`. P (int): The number of parks. parks (List[int]): The list of intersections that have parks. Returns: int: The minimum time required to visit all the parks. Example: >>> find_min_time_to_visit_all_parks(6, 7, [(1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 6), (3, 4, 5), (3, 5, 1), (4, 6, 2)], 3, [1, 4, 6]) 10 >>> find_min_time_to_visit_all_parks(3, 0, [], 3, [1, 2, 3]) inf >>> find_min_time_to_visit_all_parks(3, 3, [(1, 2, 1), (1, 3, 4), (2, 3, 2)], 1, [1]) 0 >>> find_min_time_to_visit_all_parks(4, 2, [(1, 2, 1), (3, 4, 1)], 2, [1, 3]) inf","solution":"def find_min_time_to_visit_all_parks(N, E, roads, P, parks): # Step 1: Initialize the graph with infinite distances INF = float('inf') dist = [[INF] * (N + 1) for _ in range(N + 1)] for i in range(1, N + 1): dist[i][i] = 0 # Step 2: Fill distances with given roads information for u, v, w in roads: dist[u][v] = w dist[v][u] = w # Step 3: Apply Floyd-Warshall algorithm to find all-pairs shortest paths for k in range(1, N + 1): for i in range(1, N + 1): for j in range(1, N + 1): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Step 4: Calculate minimum time to visit all parks min_time = INF for start_park in parks: time = 0 for end_park in parks: if start_park != end_park: time += dist[start_park][end_park] min_time = min(min_time, time) return min_time"},{"question":"def find_indices(lst, target): Returns a list of indices where the target element is found in the given list. Parameters: lst (list): The list to search through. target (any): The target element to find in the list. Returns: list: A list of indices where the target element is found. >>> find_indices([1, 2, 3, 2, 4, 2], 2) [1, 3, 5] >>> find_indices(['apple', 'banana', 'apple', 'cherry'], 'apple') [0, 2] >>> find_indices(['apple', 'banana', 'cherry'], 'grapes') [] from solution import find_indices def test_find_indices_with_integers(): assert find_indices([1, 2, 3, 2, 4, 2], 2) == [1, 3, 5] def test_find_indices_with_strings(): assert find_indices(['apple', 'banana', 'apple', 'cherry'], 'apple') == [0, 2] def test_find_indices_target_not_found(): assert find_indices(['apple', 'banana', 'cherry'], 'grapes') == [] def test_find_indices_with_mixed_elements(): assert find_indices([1, 'apple', 3.0, 'apple', 2], 'apple') == [1, 3] def test_find_indices_with_empty_list(): assert find_indices([], 'apple') == [] def test_find_indices_with_target_at_start_and_end(): assert find_indices(['target', 1, 2, 3, 'target'], 'target') == [0, 4] def test_find_indices_with_all_elements_same_as_target(): assert find_indices(['same', 'same', 'same'], 'same') == [0, 1, 2]","solution":"def find_indices(lst, target): Returns a list of indices where the target element is found in the given list. Parameters: lst (list): The list to search through. target (any): The target element to find in the list. Returns: list: A list of indices where the target element is found. return [index for index, element in enumerate(lst) if element == target]"},{"question":"def sort_integers_descending(s: str) -> str: Receives a string of integers separated by commas and returns the integers in descending order. >>> sort_integers_descending('1,3,5,7,9') '9,7,5,3,1' >>> sort_integers_descending('10,1,22,15') '22,15,10,1'","solution":"def sort_integers_descending(s): Receives a string of integers separated by commas and returns the integers in descending order. # Split the string into a list of integers integers = list(map(int, s.split(','))) # Sort the list in descending order integers.sort(reverse=True) # Join the integers back into a string separated by commas return ','.join(map(str, integers))"},{"question":"from typing import List def custom_sort(arr: List[int]) -> List[int]: Sort an array of integers based on custom sorting criteria: - Numbers divisible by 3 should come first (sorted in ascending order). - Numbers divisible by 5 but not by 3 should come next (sorted in descending order). - Numbers neither divisible by 3 nor by 5 should come last (sorted in ascending order). Args: arr (List[int]): Unsorted array of integers. Returns: List[int]: The array sorted according to the custom criteria. Examples: >>> custom_sort([3, 1, 2, 5, 6, 10, 15, 7]) [3, 6, 15, 10, 5, 1, 2, 7] >>> custom_sort([30, 20, 18, 14, 9, 5, 2]) [9, 18, 30, 20, 5, 2, 14]","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: divisible_3 = sorted([x for x in arr if x % 3 == 0]) divisible_5_not_3 = sorted([x for x in arr if x % 5 == 0 and x % 3 != 0], reverse=True) neither = sorted([x for x in arr if x % 3 != 0 and x % 5 != 0]) return divisible_3 + divisible_5_not_3 + neither"},{"question":"def filter_strings(strings: List[str], character: str) -> List[str]: Filters a list of strings, returning only the strings that start with the given character. This comparison is case-insensitive. Parameters: - strings: list of str - character: str (single character) Returns: - list of str >>> filter_strings(['apple', 'banana', 'apricot'], 'a') ['apple', 'apricot'] >>> filter_strings(['apple', 'banana', 'apricot'], 'c') [] >>> filter_strings(['apple', 'banana', 'Apricot'], 'a') ['apple', 'Apricot'] >>> filter_strings(['Apple', 'banana', 'apricot'], 'A') ['Apple', 'apricot'] >>> filter_strings(['Apple', 'banana', 'Apricot', 'apricot'], 'A') ['Apple', 'Apricot', 'apricot'] >>> filter_strings(['!exclaim', '#hash', '@at'], '!') ['!exclaim'] >>> filter_strings(['!exclaim', '#hash', '@at'], '#') ['#hash'] >>> filter_strings(['apple', 'banana', 'apricot'], '') [] >>> filter_strings(['apple', 'banana', 'apricot'], 'aa') []","solution":"def filter_strings(strings, character): Filters a list of strings, returning only the strings that start with the given character. This comparison is case-insensitive. Parameters: - strings: list of str - character: str (single character) Returns: - list of str if not strings or not character or len(character) != 1: return [] character = character.lower() return [s for s in strings if s.lower().startswith(character)]"},{"question":"def absolute_sorted(lst: List[int]) -> List[int]: Takes a list of integers, returns a list of their absolute values sorted in ascending order. Parameters: lst (list): List of integers which might contain negative numbers. Returns: List of integers with absolute values sorted in ascending order. Examples: >>> absolute_sorted([-3, -1, -4, 2, 0, 1]) [0, 1, 1, 2, 3, 4] >>> absolute_sorted([3, 1, 4, 2, 0]) [0, 1, 2, 3, 4] >>> absolute_sorted([-3, 3, -2, 2, -1, 1, 0]) [0, 1, 1, 2, 2, 3, 3] >>> absolute_sorted([]) [] >>> absolute_sorted([-5]) [5] >>> absolute_sorted([6]) [6] >>> absolute_sorted([0]) [0]","solution":"def absolute_sorted(lst): Takes a list of integers, returns a list of their absolute values sorted in ascending order. Parameters: lst (list): List of integers which might contain negative numbers. Returns: List of integers with absolute values sorted in ascending order. return sorted([abs(x) for x in lst])"},{"question":"def distribute_gifts(test_cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[int, int]]: Determines the number of gifts each category will receive and how many categories will receive one extra gift. >>> distribute_gifts([(10, 3, [1, 2, 2, 3, 3, 3, 1, 1, 1, 2])]) [(3, 1)] >>> distribute_gifts([(6, 2, [1, 1, 2, 2, 1, 2])]) [(3, 0)] >>> distribute_gifts([(5, 4, [1, 1, 2, 3, 4])]) [(1, 1)] from solution import distribute_gifts def test_distribute_gifts_sample_cases(): test_cases = [ (10, 3, [1, 2, 2, 3, 3, 3, 1, 1, 1, 2]), (6, 2, [1, 1, 2, 2, 1, 2]), (5, 4, [1, 1, 2, 3, 4]), ] expected = [ (3, 1), (3, 0), (1, 1), ] assert distribute_gifts(test_cases) == expected def test_distribute_gifts_all_same_category(): test_cases = [ (10, 5, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), (8, 2, [2, 2, 2, 2, 2, 2, 2, 2]), ] expected = [ (2, 0), (4, 0), ] assert distribute_gifts(test_cases) == expected def test_distribute_gifts_single_gift(): test_cases = [ (1, 1, [1]), (1, 2, [1]), ] expected = [ (1, 0), (0, 1), ] assert distribute_gifts(test_cases) == expected def test_distribute_gifts_equal_distribution(): test_cases = [ (6, 3, [1, 2, 3, 1, 2, 3]), (12, 4, [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]), ] expected = [ (2, 0), (3, 0), ] assert distribute_gifts(test_cases) == expected","solution":"def distribute_gifts(test_cases): results = [] for n, c, gifts in test_cases: gifts_per_category = n // c extra_gifts = n % c results.append((gifts_per_category, extra_gifts)) return results"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: You are given a matrix with n rows and m columns, where each cell contains a non-negative integer indicating the height at that point. You can move left, right, up, or down from any cell. Your goal is to find the length of the longest path such that each move is to a cell with a strictly higher height than the current cell. >>> longest_increasing_path([[9, 9, 4, 9], [6, 6, 8, 6], [2, 1, 1, 7], [7, 6, 9, 7]]) 4 >>> longest_increasing_path([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> longest_increasing_path([[5]]) 1 >>> longest_increasing_path([[1, 2, 3, 4]]) 4 >>> longest_increasing_path([[1], [2], [3], [4]]) 4 >>> longest_increasing_path([[1, 2, 3], [6, 5, 4]]) 6 >>> longest_increasing_path([[3, 4, 5], [3, 2, 6], [2, 2, 1]]) 4","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) dp = [[-1] * m for _ in range(n)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] length = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] > matrix[x][y]: length = max(length, 1 + dfs(nx, ny)) dp[x][y] = length return length result = 0 for i in range(n): for j in range(m): result = max(result, dfs(i, j)) return result"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers up to n (inclusive). Args: n (int): The upper limit (inclusive) to look for prime numbers. Returns: List[int]: A list of prime numbers up to n. Examples: >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers up to n (inclusive). Args: n (int): The upper limit (inclusive) to look for prime numbers. Returns: List[int]: A list of prime numbers up to n. if n < 2: return [] # Create a boolean array \\"prime[0..n]\\" and initialize all entries as true. prime = [True] * (n + 1) p = 2 while (p * p <= n): # If prime[p] is not changed, then it is a prime if prime[p]: # Updating all multiples of p to not be primes for i in range(p * p, n + 1, p): prime[i] = False p += 1 # Collecting all prime numbers prime_numbers = [p for p in range(2, n + 1) if prime[p]] return prime_numbers"},{"question":"def transcribe_dna_to_rna(dna: str) -> str: Transcribes a DNA sequence to its corresponding RNA sequence. Parameters: dna (str): A string representation of the DNA sequence. Returns: str: The RNA sequence with 'T' replaced by 'U'. >>> transcribe_dna_to_rna(\\"GATTACA\\") \\"GAUUACA\\" >>> transcribe_dna_to_rna(\\"gattaca\\") \\"gauuaca\\" >>> transcribe_dna_to_rna(\\"\\") \\"\\" >>> transcribe_dna_to_rna(\\"ACGT\\") \\"ACGU\\" pass","solution":"def transcribe_dna_to_rna(dna): Transcribes a DNA sequence to its corresponding RNA sequence. Parameters: dna (str): A string representation of the DNA sequence. Returns: str: The RNA sequence with 'T' replaced by 'U'. return dna.replace('T', 'U').replace('t', 'u')"},{"question":"def word_frequency(sentence: str) -> dict: Write a function word_frequency(sentence) that takes a string as input and returns a dictionary where each key is a unique word in the input string, and the corresponding value is the count of occurrences of that word. The function is case-insensitive. :param sentence: input string :type sentence: str :return: dictionary with word count :rtype: dict >>> word_frequency(\\"Hello hello world\\") {'hello': 2, 'world': 1} >>> word_frequency(\\"Test the function test the Case\\") {'test': 2, 'the': 2, 'function': 1, 'case': 1} pass def test_word_frequency_single_word(): assert word_frequency(\\"test\\") == {'test': 1} def test_word_frequency_repeating_word(): assert word_frequency(\\"test test test\\") == {'test': 3} def test_word_frequency_case_insensitive(): assert word_frequency(\\"Test test TEST\\") == {'test': 3} def test_word_frequency_multiple_words(): assert word_frequency(\\"Hello hello world\\") == {'hello': 2, 'world': 1} def test_word_frequency_mixed_sentence(): assert word_frequency(\\"Test the function test the Case\\") == {'test': 2, 'the': 2, 'function': 1, 'case': 1} def test_word_frequency_empty_string(): assert word_frequency(\\"\\") == {} def test_word_frequency_spaces_within_words(): assert word_frequency(\\" test test test \\") == {'test': 3}","solution":"def word_frequency(sentence: str) -> dict: Returns a dictionary where each key is a unique word (case-insensitive) in the input string, and the corresponding value is the count of occurrences of that word. words = sentence.lower().split() freq_dict = {} for word in words: if word in freq_dict: freq_dict[word] += 1 else: freq_dict[word] = 1 return freq_dict"},{"question":"from typing import List def min_moves(board: List[str]) -> int: Determine the minimum number of moves required for the robot to get from its starting position to the target position. If it is not possible to reach the target position, return -1. The robot can only move up, down, left, or right, and cannot pass through obstacles. >>> board = [ ... \\"S..#\\", ... \\".#..\\", ... \\"...T\\", ... \\"..\\" ... ] >>> min_moves(board) 5 >>> board = [ ... \\"S#..\\", ... \\"#.\\", ... \\"...T\\" ... ] >>> min_moves(board) -1 >>> board = [ ... \\"S..T\\" ... ] >>> min_moves(board) 3 >>> board = [ ... \\"S#\\", ... \\"\\", ... \\"\\", ... \\"#T\\" ... ] >>> min_moves(board) -1 >>> board = [ ... \\"S..#\\", ... \\".#.#\\", ... \\"\\", ... \\".T\\" ... ] >>> min_moves(board) -1 >>> board = [ ... \\"S\\" + \\".\\" * 98 + \\"T\\", ... \\"#\\" * 100, ... \\".\\" * 100 ... ] >>> min_moves(board) 99 pass","solution":"from collections import deque def min_moves(board): rows = len(board) cols = len(board[0]) # Find the start and target positions start = None target = None for r in range(rows): for c in range(cols): if board[r][c] == 'S': start = (r, c) elif board[r][c] == 'T': target = (r, c) # Using BFS to find the shortest path def bfs(start, target): queue = deque([(start, 0)]) # ((row, col), distance) visited = set([start]) while queue: (r, c), dist = queue.popleft() if (r, c) == target: return dist # Explore the four possible directions for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != '#' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append(((nr, nc), dist + 1)) return -1 return bfs(start, target)"},{"question":"def most_frequent(arr): Returns the most frequent integer in the array. If there are multiple integers with the same highest frequency, return the first one to reach that frequency. >>> most_frequent([1, 3, 2, 3, 2, 3]) 3 >>> most_frequent([4, 5, 4, 6, 4, 6, 6]) 4 >>> most_frequent([1, 2, 1, 2, 1, 2, 3]) 1 >>> most_frequent([])","solution":"def most_frequent(arr): Returns the most frequent integer in the array. If there are multiple integers with the same highest frequency, return the first one to reach that frequency. if not arr: raise ValueError(\\"Array is empty\\") frequency = {} max_freq = 0 most_freq_num = arr[0] for num in arr: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 if frequency[num] > max_freq: max_freq = frequency[num] most_freq_num = num return most_freq_num"},{"question":"from collections import deque class RecentCounter: Implement the RecentCounter class that supports two methods: ping and count. Methods: - ping(int t): Adds a new request at time t. - count(): Returns the number of requests that occurred in the last 3000 milliseconds (including the new request). >>> recentCounter = RecentCounter() >>> recentCounter.ping(1) >>> recentCounter.ping(100) >>> recentCounter.ping(3001) >>> recentCounter.ping(3002) >>> recentCounter.count() 3 def __init__(self): pass def ping(self, t: int) -> None: pass def count(self) -> int: pass","solution":"from collections import deque class RecentCounter: def __init__(self): self.requests = deque() def ping(self, t: int) -> None: self.requests.append(t) while self.requests and self.requests[0] < t - 3000: self.requests.popleft() def count(self) -> int: return len(self.requests)"},{"question":"def largest_connected_land(grid: List[List[int]]) -> int: Find the size of the largest connected piece of land in the grid. Land is represented by '1's and water is represented by '0's. Two pieces of land are connected if they are adjacent horizontally or vertically. The function should return an integer representing the size of the largest connected piece of land. >>> largest_connected_land([ ... [1, 1, 0, 0, 0], ... [1, 0, 1, 0, 0], ... [0, 0, 1, 1, 1], ... [0, 1, 0, 0, 1] ... ]) 5 >>> largest_connected_land([ ... [1, 1], ... [1, 1] ... ]) 4 >>> largest_connected_land([ ... [0, 0], ... [0, 0] ... ]) 0 >>> largest_connected_land([ ... [0, 0], ... [0, 1] ... ]) 1 >>> largest_connected_land([ ... [1, 0, 0, 1], ... [0, 1, 1, 0], ... [0, 0, 0, 1], ... [1, 0, 1, 0] ... ]) 2","solution":"def largest_connected_land(grid): rows = len(grid) cols = len(grid[0]) if rows > 0 else 0 def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0: return 0 grid[r][c] = 0 # Mark as visited size = 1 size += dfs(r - 1, c) size += dfs(r + 1, c) size += dfs(r, c - 1) size += dfs(r, c + 1) return size max_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: max_size = max(max_size, dfs(r, c)) return max_size"},{"question":"def is_right_circular_rotation(s1: str, s2: str) -> bool: Determines if s2 can be obtained by performing right circular rotations on s1. >>> is_right_circular_rotation(\\"abcde\\", \\"cdeab\\") True >>> is_right_circular_rotation(\\"abcde\\", \\"abced\\") False >>> is_right_circular_rotation(\\"aaa\\", \\"aaa\\") True >>> is_right_circular_rotation(\\"abc\\", \\"cab\\") True","solution":"def is_right_circular_rotation(s1, s2): Determines if s2 can be obtained by performing right circular rotations on s1. Parameters: s1 (str): the original string s2 (str): the string to compare against s1's rotations Returns: bool: True if s2 can be obtained by right circular rotations of s1, False otherwise. if len(s1) != len(s2): return False # Concatenate s1 with itself doubled_s1 = s1 + s1 # Check if s2 is a substring of the concatenated string return s2 in doubled_s1"},{"question":"def findSubstring(str: str, sub: str) -> int: Determine if 'sub' is a substring of 'str'. Return the starting index (0-based) of 'sub' within 'str' if it exists, or return -1 if it does not. >>> findSubstring(\\"hello world\\", \\"world\\") # 6 >>> findSubstring(\\"hello world\\", \\"plan\\") # -1 >>> findSubstring(\\"abcdabc\\", \\"abc\\") # 0 >>> findSubstring(\\"hello\\", \\"HE\\") # -1 >>> findSubstring(\\"\\", \\"\\") # 0","solution":"def findSubstring(str, sub): Determine if 'sub' is a substring of 'str'. Return the starting index (0-based) of 'sub' within 'str' if it exists, or return -1 if it does not. # If sub is empty, it is considered a substring starting at index 0 if sub == \\"\\": return 0 # If sub is longer than str, sub cannot be a substring if len(sub) > len(str): return -1 # Iterate through str to find the starting index of sub for i in range(len(str) - len(sub) + 1): if str[i:i+len(sub)] == sub: return i # If sub is not found, return -1 return -1"},{"question":"def is_valid_ipv4_address(inputString: str) -> bool: Check whether a given input string is a valid IPv4 address. >>> is_valid_ipv4_address(\\"192.168.0.1\\") True >>> is_valid_ipv4_address(\\"255.255.255.255\\") True >>> is_valid_ipv4_address(\\"256.100.50.0\\") False >>> is_valid_ipv4_address(\\"172.16.254.01\\") False >>> is_valid_ipv4_address(\\"random text\\") False","solution":"def is_valid_ipv4_address(inputString): def is_valid_part(part): if len(part) == 0 or (len(part) > 1 and part[0] == '0'): return False if not part.isdigit(): return False num = int(part) return 0 <= num <= 255 parts = inputString.split('.') if len(parts) != 4: return False return all(is_valid_part(part) for part in parts)"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> bool: Determine if any two numbers in the array add up to the target value. >>> two_sum([2, 7, 11, 15], 9) True >>> two_sum([3, 2, 4], 6) True >>> two_sum([3, 3], 6) True >>> two_sum([1, 2, 3, 4], 10) False >>> two_sum([-1, -2, -3, 3], 0) True >>> two_sum([], 1) False","solution":"def two_sum(nums, target): Returns True if any two numbers in the array add up to the target value, otherwise False. seen = {} for num in nums: complement = target - num if complement in seen: return True seen[num] = True return False"},{"question":"from typing import List def min_operations(nums: List[int], k: int) -> int: Returns the minimum number of operations required to make all elements of 'nums' equal with at most 'k' operations. Example 1: >>> min_operations([1, 2, 3], 3) 2 Example 2: >>> min_operations([1, 10, 2, 9], 5) 14 Example 3: >>> min_operations([3, 3, 3], 1) 0","solution":"def min_operations(nums, k): Returns the minimum number of operations required to make all elements of 'nums' equal with at most 'k' operations. # If k = 0, we can't do any operations, so if elements are not equal, return inf (impossible case) if k == 0: return float('inf') # Sort the nums array nums.sort() # Initialize variables n = len(nums) median = nums[n // 2] # Median element in the sorted array # Calculate the total increments and decrements to make all elements equal to the median total_operations = sum(abs(median - num) for num in nums) # If we have fewer operations than or equal the allowed k, it's our answer. if total_operations <= k: return total_operations # Otherwise, it's not possible within 'k' operations return -1"},{"question":"def max_sum_with_one_removal(arr): Calculates the maximum sum of any subarray that can be obtained by removing at most one element from the array. >>> max_sum_with_one_removal([1, -2, 0, 3, 4]) 8 >>> max_sum_with_one_removal([1, -1, 1]) 2 >>> max_sum_with_one_removal([1, 2, 3, 4]) 10 >>> max_sum_with_one_removal([-1, -2, -3, -4]) -1 >>> max_sum_with_one_removal([3, -2, 5, -1, 6, -3]) 13 def max_sum_subarray_with_one_removal(T, test_cases): Determines the maximum possible sum of any subarray after removing at most one element for multiple test cases. Args: T (int): number of test cases test_cases (List[Tuple[int, List[int]]]): list of tuples containing number of elements and the array Returns: List[int]: the maximum possible sum for each test case >>> test_cases = [(5, [1, -2, 0, 3, 4])] >>> max_sum_subarray_with_one_removal(1, test_cases) [8] >>> test_cases = [(5, [1, -2, 0, 3, 4]), (3, [1, -1, 1])] >>> max_sum_subarray_with_one_removal(2, test_cases) [8, 2] >>> test_cases = [(4, [1, 2, 3, 4])] >>> max_sum_subarray_with_one_removal(1, test_cases) [10] >>> test_cases = [(4, [-1, -2, -3, -4])] >>> max_sum_subarray_with_one_removal(1, test_cases) [-1] >>> test_cases = [(6, [3, -2, 5, -1, 6, -3])] >>> max_sum_subarray_with_one_removal(1, test_cases) [13]","solution":"def max_sum_with_one_removal(arr): n = len(arr) if n == 1: return arr[0] # Initialize arrays left = [0]*n right = [0]*n # Populate the left array left[0] = arr[0] max_current = arr[0] for i in range(1, n): max_current = max(arr[i], max_current + arr[i]) left[i] = max_current # Populate the right array right[n-1] = arr[n-1] max_current = arr[n-1] for i in range(n-2, -1, -1): max_current = max(arr[i], max_current + arr[i]) right[i] = max_current # Calculate the maximum sum with one removal max_sum = max(left) for i in range(1, n-1): max_sum = max(max_sum, left[i-1] + right[i+1]) return max_sum def max_sum_subarray_with_one_removal(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] results.append(max_sum_with_one_removal(A)) return results"},{"question":"def is_path_to_cheese(maze): Given a maze represented as a grid of strings, determine if there is a path from the mouse ('M') to the cheese ('C'). >>> is_path_to_cheese([ \\"M W \\", \\"W W WWWW \\", \\"W C \\", \\"WWWWWWWWW\\" ]) True >>> is_path_to_cheese([ \\"M W \\", \\"WWWWWWWW \\", \\"W C \\", \\"WWWWWWWWW\\" ]) False >>> is_path_to_cheese([ \\"M W\\", \\"WW W\\", \\"W W\\", \\"WWWW W\\", \\" CW\\" ]) True >>> is_path_to_cheese([ \\"M C\\" ]) True >>> is_path_to_cheese([ \\"MW\\", \\"WW\\", \\"WC\\" ]) False >>> is_path_to_cheese([ \\"W\\", \\"M\\" \\"C\\" ]) False","solution":"def is_path_to_cheese(maze): def bfs(start, end): queue = [start] visited = set() visited.add(start) while queue: x, y = queue.pop(0) if (x, y) == end: return True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # up, down, left, right nx, ny = x + dx, y + dy if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] != 'W' and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False start = None end = None for i in range(len(maze)): for j in range(len(maze[0])): if maze[i][j] == 'M': start = (i, j) elif maze[i][j] == 'C': end = (i, j) if not start or not end: return False return bfs(start, end)"},{"question":"def sort_letters_and_digits(s: str) -> str: Given a string s consisting of lowercase letters and digits, return the string with all the letters in ascending order followed by all the digits in ascending order. Examples: >>> sort_letters_and_digits(\\"d4c3b2a1\\") \\"abcd1234\\" >>> sort_letters_and_digits(\\"z2y9x3w1\\") \\"wxyz1239\\" >>> sort_letters_and_digits(\\"a1b2c3d4e5\\") \\"abcde12345\\" from solution import sort_letters_and_digits def test_sort_letters_and_digits_example1(): assert sort_letters_and_digits(\\"d4c3b2a1\\") == \\"abcd1234\\" def test_sort_letters_and_digits_example2(): assert sort_letters_and_digits(\\"z2y9x3w1\\") == \\"wxyz1239\\" def test_sort_letters_and_digits_example3(): assert sort_letters_and_digits(\\"a1b2c3d4e5\\") == \\"abcde12345\\" def test_only_letters(): assert sort_letters_and_digits(\\"edcba\\") == \\"abcde\\" def test_only_digits(): assert sort_letters_and_digits(\\"54321\\") == \\"12345\\" def test_mixed_letters_digits(): assert sort_letters_and_digits(\\"a5d3b1\\") == \\"abd135\\" def test_empty_string(): assert sort_letters_and_digits(\\"\\") == \\"\\"","solution":"def sort_letters_and_digits(s): Given a string s consisting of lowercase letters and digits, return the string with all the letters in ascending order followed by all the digits in ascending order. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) elif char.isalpha(): letters.append(char) sorted_letters = ''.join(sorted(letters)) sorted_digits = ''.join(sorted(digits)) return sorted_letters + sorted_digits"},{"question":"from typing import List def smallest_subarray_with_sum(nums: List[int], target: int) -> int: Given a list of integers and a target integer, find the length of the smallest continuous subarray with a sum greater than or equal to the target integer. Return 0 if no such subarray exists. >>> smallest_subarray_with_sum([2, 1, 3, 4, 1, 1, 2], 5) 2 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1], 10) 0 >>> smallest_subarray_with_sum([4, 2, 1, 6, 5, 3], 8) 2 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10], 10) 1 >>> smallest_subarray_with_sum([10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10], 11) 2 >>> smallest_subarray_with_sum([], 1) 0 >>> smallest_subarray_with_sum([1], 1) 1","solution":"from typing import List def smallest_subarray_with_sum(nums: List[int], target: int) -> int: n = len(nums) min_len = float('inf') # Initialize minimum length to infinity current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= nums[start] start += 1 return min_len if min_len != float('inf') else 0"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns the product of every integer except the integer at that index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 3, 4]) [12, 20, 15] >>> product_except_self([10]) [1] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([]) []","solution":"def product_except_self(nums): n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def second_smallest(numbers: List[int]) -> int: Returns the second smallest number in the list. Assumes that the list has at least two elements. >>> second_smallest([3, 1, 4, 1, 5, 9]) 3 >>> second_smallest([10, 22, 5, 14, 9]) 9 >>> second_smallest([3, 1]) 3 >>> second_smallest([-3, -1, -4, -1, -5, -9]) -5 >>> second_smallest([-10, 0, 10, -5, 5]) -5","solution":"def second_smallest(numbers): Returns the second smallest number in the list. Assumes that the list has at least two elements. if len(numbers) < 2: raise ValueError(\\"List must contain at least two elements.\\") # Create a unique set of numbers to handle duplicates unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: raise ValueError(\\"List must contain at least two unique elements.\\") unique_numbers.sort() return unique_numbers[1]"},{"question":"def min_coins(toll_amount: int, coin_values: List[int]) -> int: Returns the minimum number of coins needed to make the exact toll_amount. If not possible, return -1. >>> min_coins(11, [1, 2, 5]) == 3 >>> min_coins(3, [2]) == -1 >>> min_coins(10, [10]) == 1 >>> min_coins(6, [1, 3, 4]) == 2 >>> min_coins(0, [1, 2, 5]) == 0 >>> min_coins(100, [1, 5, 10, 25]) == 4 >>> min_coins(5, []) == -1 >>> min_coins(7, [1, 3, 4]) == 2","solution":"def min_coins(toll_amount, coin_values): Returns the minimum number of coins needed to make the exact toll_amount. If not possible, return -1. # Initialize dp array to store minimum coins needed for each amount up to toll_amount dp = [float('inf')] * (toll_amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0 # Loop through each coin value and update the dp array for coin in coin_values: for x in range(coin, toll_amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # Return the result for toll_amount, or -1 if it's not possible return dp[toll_amount] if dp[toll_amount] != float('inf') else -1"},{"question":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Generate all unique subsets of a list of integers. Each subset is sorted in ascending order, and the list of subsets is sorted lexicographically. >>> unique_subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> unique_subsets([1, 2, 2]) [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> unique_subsets([1]) [[], [1]] >>> unique_subsets([]) [[]] >>> unique_subsets([2, 2, 2]) [[], [2], [2, 2], [2, 2, 2]] >>> unique_subsets([1, 3, 2, 2]) [[], [1], [1, 2], [1, 2, 2], [1, 2, 2, 3], [1, 2, 3], [1, 3], [2], [2, 2], [2, 2, 3], [2, 3], [3]]","solution":"from itertools import combinations def unique_subsets(nums): Generate all unique subsets of a list of integers. Each subset is sorted in ascending order, and the list of subsets is sorted lexicographically. # Sort the input to handle duplicates and to ensure ascending order in subsets nums.sort() # Using a set to avoid duplicates result_set = set() # Generate all subsets of all lengths for r in range(len(nums) + 1): for combination in combinations(nums, r): result_set.add(combination) # Convert each tuple to a list and sort lexicographically (natural sorting of tuples) result = [list(x) for x in sorted(result_set)] return result"},{"question":"def isSortableWithinSwaps(N: int, K: int, A: List[int]) -> bool: Determine if the array can be sorted within the given number of adjacent swaps. >>> isSortableWithinSwaps(5, 4, [3, 1, 2, 4, 5]) True >>> isSortableWithinSwaps(4, 2, [4, 3, 2, 1]) False >>> isSortableWithinSwaps(3, 0, [1, 3, 2]) False def solve_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[bool]: Solve multiple test cases for the isSortableWithinSwaps problem. >>> solve_test_cases([(5, 4, [3, 1, 2, 4, 5]), (4, 2, [4, 3, 2, 1]), (3, 0, [1, 3, 2]), (4, 0, [1, 2, 3, 4])]) [True, False, False, True]","solution":"def isSortableWithinSwaps(N, K, A): # Count the number of inversions in the array def count_inversions(arr): inv_count = 0 for i in range(len(arr)): for j in range(i + 1, len(arr)): if arr[i] > arr[j]: inv_count += 1 return inv_count # Calculate the number of inversions in the array inversions = count_inversions(A) # Since each swap can reduce inversions by at most 1, # the array can only be sorted if inversions <= K return inversions <= K def solve_test_cases(test_cases): results = [] for N, K, A in test_cases: results.append(isSortableWithinSwaps(N, K, A)) return results"},{"question":"def productExceptSelf(nums: List[int]) -> List[int]: Given a non-negative integer array nums, return a new array where each element at index i of the new array is the product of all the numbers in the original array except the one at i. >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([2, 3, 4, 5]) [60, 40, 30, 24] >>> productExceptSelf([1, 2]) [2, 1]","solution":"def productExceptSelf(nums): Given a non-negative integer array nums, return a new array where each element at index i of the new array is the product of all the numbers in the original array except the one at i. length = len(nums) # Initialize the result array with 1s result = [1] * length # Create prefix products prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] # Create suffix products and multiply with corresponding prefix products suffix = 1 for i in range(length-1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Calculate minimum sum from top-left to bottom-right in a grid. >>> min_path_sum([[1,3,1],[1,5,1],[4,2,1]]) == 7 >>> min_path_sum([[1,2],[1,1]]) == 3 def solve_min_path_sum(test_cases: List[List[List[int]]]) -> List[int]: Solve the minimum path sum for multiple test cases. >>> test_cases = [[[1, 3, 1], [1, 5, 1], [4, 2, 1]], [[1, 2], [1, 1]]] >>> solve_min_path_sum(test_cases) == [7, 3] def process_input(input_string: str) -> List[List[List[int]]]: Process the input string to get list of test cases. >>> input_string = \\"2n3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n1 1\\" >>> process_input(input_string) == [[[1, 3, 1], [1, 5, 1], [4, 2, 1]], [[1, 2], [1, 1]]] if __name__ == \\"__main__\\": input_string = 2 3 3 1 3 1 1 5 1 4 2 1 2 2 1 2 1 1 test_cases = process_input(input_string) print(solve_min_path_sum(test_cases))","solution":"import heapq def min_path_sum(grid): N, M = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] min_heap = [(grid[0][0], 0, 0)] visited = set() while min_heap: current_sum, x, y = heapq.heappop(min_heap) if (x, y) == (N-1, M-1): return current_sum if (x, y) in visited: continue visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited: heapq.heappush(min_heap, (current_sum + grid[nx][ny], nx, ny)) def solve_min_path_sum(test_cases): results = [] for grid in test_cases: results.append(min_path_sum(grid)) return results # Example usage: def process_input(input_string): input_lines = input_string.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, input_lines[index].split()) grid = [] for i in range(N): grid.append(list(map(int, input_lines[index + 1 + i].split()))) test_cases.append(grid) index += N + 1 return test_cases input_string = 2 3 3 1 3 1 1 5 1 4 2 1 2 2 1 2 1 1 test_cases = process_input(input_string) print(solve_min_path_sum(test_cases))"},{"question":"def contains_nearby_duplicate(nums, k): Given an array of n integers, find if there are any duplicate integers present in the array, such that the difference between the indices of the duplicate integers is at most k. Return true if such duplicates exist, otherwise return false. >>> contains_nearby_duplicate([1, 2, 3, 1], 3) == True >>> contains_nearby_duplicate([1, 0, 1, 1], 1) == True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) == False >>> contains_nearby_duplicate([1, 2, 3, 4, 5], 3) == False >>> contains_nearby_duplicate([1, 1], 0) == False >>> contains_nearby_duplicate([], 1) == False >>> contains_nearby_duplicate([1], 3) == False","solution":"def contains_nearby_duplicate(nums, k): Returns true if there are duplicate integers in the array such that the difference between the indices of the duplicate integers is at most k. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"def is_connected(N: int, M: int, connections: List[Tuple[int, int]]) -> str: Determines if the university has strong social bonding among students. Returns \\"YES\\" if every student is reachable from every other student directly or indirectly, otherwise returns \\"NO\\". Args: N (int): The number of students. M (int): The number of friendship connections. connections (List[Tuple[int, int]]): A list of tuples where each tuple represents a two-way friendship connection between students. Returns: str: \\"YES\\" if strong social bonding exists, \\"NO\\" otherwise. Example: >>> is_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YES' >>> is_connected(4, 2, [(1, 2), (3, 4)]) 'NO' from solution import is_connected def test_example_1(): N = 5 M = 4 connections = [(1, 2), (2, 3), (3, 4), (4, 5)] assert is_connected(N, M, connections) == \\"YES\\" def test_example_2(): N = 4 M = 2 connections = [(1, 2), (3, 4)] assert is_connected(N, M, connections) == \\"NO\\" def test_single_student(): N = 1 M = 0 connections = [] assert is_connected(N, M, connections) == \\"YES\\" def test_disconnected(): N = 3 M = 1 connections = [(1, 2)] assert is_connected(N, M, connections) == \\"NO\\" def test_fully_connected(): N = 3 M = 3 connections = [(1, 2), (2, 3), (1, 3)] assert is_connected(N, M, connections) == \\"YES\\" def test_two_components(): N = 6 M = 4 connections = [(1, 2), (2, 3), (4, 5), (5, 6)] assert is_connected(N, M, connections) == \\"NO\\"","solution":"def is_connected(N, M, connections): from collections import defaultdict, deque if N == 1: return \\"YES\\" graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) def bfs(start): queue = deque([start]) visited[start] = True count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return count connected_component_size = bfs(1) if connected_component_size == N: return \\"YES\\" else: return \\"NO\\""},{"question":"def smallest_temperature_range(temperatures: List[int], k: int) -> int: Calculate the smallest range of temperatures for any contiguous subsequence of k hours. Args: temperatures (List[int]): A list of integers representing temperature recordings each hour for a day. k (int): The number of contiguous hours to consider. Returns: int: The smallest range of temperatures for any contiguous subsequence of exactly k hours. Raises: ValueError: If the length of temperatures is less than k. Examples: >>> smallest_temperature_range([3, 1, 6, 4, 9, 2, 8], 3) 5 >>> smallest_temperature_range([10, 20, 30, 40, 50], 2) 10 >>> smallest_temperature_range([5, 2, 1, 3, 9, 7], 4) 4 pass # Test cases to validate the solution def test_smallest_temperature_range_example_1(): assert smallest_temperature_range([3, 1, 6, 4, 9, 2, 8], 3) == 5 def test_smallest_temperature_range_example_2(): assert smallest_temperature_range([10, 20, 30, 40, 50], 2) == 10 def test_smallest_temperature_range_example_3(): assert smallest_temperature_range([5, 2, 1, 3, 9, 7], 4) == 4 def test_smallest_temperature_range_single_temperature(): assert smallest_temperature_range([42], 1) == 0 def test_smallest_temperature_range_all_same_temperatures(): assert smallest_temperature_range([5, 5, 5, 5, 5], 3) == 0 def test_smallest_temperature_range_k_equals_length_of_temperatures(): assert smallest_temperature_range([10, 15, 20, 25], 4) == 15 def test_smallest_temperature_range_value_error(): import pytest with pytest.raises(ValueError): smallest_temperature_range([1, 2], 3)","solution":"def smallest_temperature_range(temperatures, k): Returns the smallest range of temperatures for any contiguous subsequence of k hours. If the length of temperatures is less than k, raises a ValueError. :param temperatures: List of integers representing temperature recordings. :param k: Integer representing number of contiguous hours to consider. :return: Integer representing the smallest range of temperatures for any k-hour subsequence. n = len(temperatures) if n < k: raise ValueError(\\"Length of temperatures must be greater than or equal to k.\\") min_range = float('inf') for i in range(n - k + 1): subsequence = temperatures[i:i+k] subsequence_range = max(subsequence) - min(subsequence) if subsequence_range < min_range: min_range = subsequence_range return min_range"},{"question":"def assign_bibs(timestamps: List[str], current_bib_number: int) -> List[int]: Assign bib numbers to participants based on their registration timestamps. Parameters: timestamps (list of str): List of registration timestamps in 'YYYY-MM-DD HH:MM:SS' format. current_bib_number (int): The starting bib number for this batch of assignments. Returns: list of int: List of assigned bib numbers sorted by registration timestamps. Example: >>> assign_bibs(['2023-05-15 09:15:00', '2023-05-15 09:00:00', '2023-05-15 09:05:00'], 10) [10, 11, 12] >>> assign_bibs(['2023-03-25 10:30:00', '2023-04-10 08:00:00', '2023-05-15 07:00:00'], 100) [100, 101, 102]","solution":"def assign_bibs(timestamps, current_bib_number): Assign bib numbers to participants based on their registration timestamps. Parameters: timestamps (list of str): List of registration timestamps in 'YYYY-MM-DD HH:MM:SS' format. current_bib_number (int): The starting bib number for this batch of assignments. Returns: list of int: List of assigned bib numbers sorted by registration timestamps. assigned_bibs = [] for i in range(len(timestamps)): assigned_bibs.append(current_bib_number + i) return assigned_bibs"},{"question":"def plantsToWater(diary: List[List[Union[str, int]]]) -> List[str]: Given a list of lists where each inner list represents a plant's name, the days since it was last watered, and the watering frequency, this function returns a list of plant names that need to be watered today. >>> plantsToWater([ ... [\\"Rose\\", 3, 2], ... [\\"Tulip\\", 5, 4], ... [\\"Orchid\\", 10, 7] ... ]) [\\"Rose\\", \\"Tulip\\", \\"Orchid\\"] >>> plantsToWater([ ... [\\"Cactus\\", 10, 30], ... [\\"Sunflower\\", 3, 3], ... [\\"Lily\\", 1, 2] ... ]) [\\"Sunflower\\"] >>> plantsToWater([ ... [\\"Cactus\\", 10, 30], ... [\\"Sunflower\\", 1, 3], ... [\\"Lily\\", 1, 2] ... ]) [] >>> plantsToWater([]) [] >>> plantsToWater([ ... [\\"Fern\\", 2, 2], ... [\\"Moss\\", 3, 3], ... [\\"Basil\\", 4, 5] ... ]) [\\"Fern\\", \\"Moss\\"] from typing import List, Union","solution":"def plantsToWater(diary): Given a list of lists where each inner list represents a plant, the days since it was last watered and the watering frequency, this function returns a list of plant names that need to be watered today. :param diary: List[List[str, int, int]] :return: List[str] plants_to_water = [] for entry in diary: plant_name, days_since_watered, watering_frequency = entry if days_since_watered >= watering_frequency: plants_to_water.append(plant_name) return plants_to_water"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def label_binary_tree(n, level_order): Label each node of a binary tree with a unique integer such that the sum of all labels on the nodes in the left subtree of any given node is less than the sum of all labels on the nodes in the right subtree. Args: n : int : the number of nodes in the tree level_order : List[int] : node values given in level-order Returns: List[int] : labels assigned to each node in level order >>> label_binary_tree(7, [1, 2, 3, 4, 5, 6, 7]) [4, 2, 6, 1, 3, 5, 7] >>> label_binary_tree(1, [1]) [1]","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def label_tree(root): # Helper function to perform in-order traversal and label the nodes def in_order_traversal(node, current_label): if node is not None: current_label = in_order_traversal(node.left, current_label) node.val = current_label current_label += 1 current_label = in_order_traversal(node.right, current_label) return current_label # List of tree nodes to enable level-order reconstruction after labeling if root is None: return [] nodes = [] queue = [root] while queue: node = queue.pop(0) nodes.append(node) if node.left: queue.append(node.left) if node.right: queue.append(node.right) # Label the tree nodes using in-order traversal starting from label 1 in_order_traversal(root, 1) # Output the labels in level order return [node.val for node in nodes] def construct_tree_from_level_order(level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = [root] i = 1 while queue and i < len(level_order): node = queue.pop(0) if i < len(level_order): node.left = TreeNode(level_order[i]) queue.append(node.left) i += 1 if i < len(level_order): node.right = TreeNode(level_order[i]) queue.append(node.right) i += 1 return root def label_binary_tree(n, level_order): if n == 0: return [] root = construct_tree_from_level_order(level_order) return label_tree(root)"},{"question":"def reverseInteger(n: int) -> int: Returns the reverse of the given integer with leading zeros removed. >>> reverseInteger(12345) == 54321 >>> reverseInteger(1002) == 2001 >>> reverseInteger(1200) == 21 >>> reverseInteger(0) == 0 >>> reverseInteger(5) == 5 >>> reverseInteger(1000) == 1 >>> reverseInteger(1221) == 1221 >>> reverseInteger(1234567890) == 987654321 >>> reverseInteger(105) == 501","solution":"def reverseInteger(n): Returns the reverse of the given integer with leading zeros removed. reversed_number = int(str(n)[::-1]) return reversed_number"},{"question":"def min_travel_times(n: int, streets: List[Tuple[int, int, int]]) -> List[int]: Calculate the minimum travel times from building 1 to all other buildings. Parameters: n (int): Number of buildings. streets (List[Tuple[int, int, int]]): List of tuples representing the streets and their travel times. Returns: List[int]: A list of minimum travel times from building 1 to each building. Example usage: >>> min_travel_times(5, [(1, 2, 10), (1, 3, 0), (3, 4, 5), (2, 5, 3), (1, 4, 1)]) [0, 10, 0, 1, 13] >>> min_travel_times(3, [(1, 2, 2), (3, 2, 1), (2, 3, 4)]) [0, 2, 6] from typing import List, Tuple def test_example_1(): assert min_travel_times(5, [(1, 2, 10), (1, 3, 0), (3, 4, 5), (2, 5, 3), (1, 4, 1)]) == [0, 10, 0, 1, 13] def test_example_2(): assert min_travel_times(3, [(1, 2, 2), (3, 2, 1), (2, 3, 4)]) == [0, 2, 6] def test_example_3(): assert min_travel_times(4, [(4, 2, 7)]) == [0, -1, -1, -1] def test_no_streets(): assert min_travel_times(3, []) == [0, -1, -1] def test_single_building(): assert min_travel_times(1, []) == [0] def test_unreachable_building(): assert min_travel_times(4, [(1, 2, 1), (1, 3, 5)]) == [0, 1, 5, -1] def test_zero_weighted_street(): assert min_travel_times(4, [(1, 2, 0), (2, 3, 0), (3, 4, 0)]) == [0, 0, 0, 0] def test_complex_case(): assert min_travel_times(6, [(1, 2, 7), (1, 3, 9), (2, 4, 10), (1, 4, 20), (3, 5, 1), (5, 6, 2)]) == [0, 7, 9, 17, 10, 12]","solution":"import heapq from typing import List, Tuple def min_travel_times(n: int, streets: List[Tuple[int, int, int]]) -> List[int]: Calculate the minimum travel times from building 1 to all other buildings. Parameters: n (int): Number of buildings. streets (List[Tuple[int, int, int]]): List of tuples representing the streets and their travel times. Returns: List[int]: A list of minimum travel times from building 1 to each building. # Initialization of graph as adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, t in streets: graph[u].append((v, t)) # Distance table, set to infinity initially except the start point dist = {i: float('inf') for i in range(1, n+1)} dist[1] = 0 # Priority queue for the Dijkstra's algorithm, initialized with the start building (1) pq = [(0, 1)] while pq: current_time, current_building = heapq.heappop(pq) # If a shorter path to current_building was found, continue if current_time > dist[current_building]: continue for neighbor, travel_time in graph[current_building]: new_time = current_time + travel_time if new_time < dist[neighbor]: dist[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) # Populate result with distances from building 1 or -1 if unreachable return [dist[i] if dist[i] != float('inf') else -1 for i in range(1, n+1)]"},{"question":"def party_distribution(t: int, k: int) -> dict: Determine the maximum number of candies each child can receive and the number of full bags needed. Parameters: t (int): The total number of candies. k (int): The total number of children. Returns: dict: A dictionary with keys \\"Candies_per_child\\" indicating the maximum number of candies each child can get and \\"Bags_needed\\" indicating the number of full bags needed. >>> party_distribution(2050, 10) {\\"Candies_per_child\\": 200, \\"Bags_needed\\": 20} >>> party_distribution(3050, 15) {\\"Candies_per_child\\": 200, \\"Bags_needed\\": 30} >>> party_distribution(100, 3) {\\"Candies_per_child\\": 0, \\"Bags_needed\\": 0} from solution import party_distribution def test_party_distribution_exact_division(): assert party_distribution(2050, 10) == {\\"Candies_per_child\\": 200, \\"Bags_needed\\": 20} def test_party_distribution_not_exact_division(): assert party_distribution(3050, 15) == {\\"Candies_per_child\\": 200, \\"Bags_needed\\": 30} def test_party_distribution_uneven_distribution(): assert party_distribution(100, 3) == {\\"Candies_per_child\\": 0, \\"Bags_needed\\": 0} def test_party_distribution_large_numbers(): assert party_distribution(1000000, 1000) == {\\"Candies_per_child\\": 1000, \\"Bags_needed\\": 10000} def test_party_distribution_small_numbers(): assert party_distribution(1, 1) == {\\"Candies_per_child\\": 0, \\"Bags_needed\\": 0} assert party_distribution(100, 1) == {\\"Candies_per_child\\": 100, \\"Bags_needed\\": 1} assert party_distribution(99, 2) == {\\"Candies_per_child\\": 0, \\"Bags_needed\\": 0} assert party_distribution(100, 3) == {\\"Candies_per_child\\": 0, \\"Bags_needed\\": 0} def test_party_distribution_not_enough_candies(): assert party_distribution(5, 10) == {\\"Candies_per_child\\": 0, \\"Bags_needed\\": 0} def test_party_distribution_single_child(): assert party_distribution(450, 1) == {\\"Candies_per_child\\": 400, \\"Bags_needed\\": 4}","solution":"def party_distribution(t, k): Returns the amount of candies each child can get and the number of bags needed. If the candies cannot be distributed evenly, returns 0 for both values. if t < k: return {\\"Candies_per_child\\": 0, \\"Bags_needed\\": 0} max_candies_per_child = t // k max_candies_per_child -= max_candies_per_child % 100 if max_candies_per_child == 0: return {\\"Candies_per_child\\": 0, \\"Bags_needed\\": 0} total_candies_distributed = max_candies_per_child * k bags_needed = (total_candies_distributed + 99) // 100 # ceiling division return {\\"Candies_per_child\\": max_candies_per_child, \\"Bags_needed\\": bags_needed}"},{"question":"class DistinctCharacterCounter: def __init__(self, S: str): Initialize the DistinctCharacterCounter with the initial string. self.S = list(S) self.size = len(S) def update(self, i: int, c: str) -> None: Update the character at the i-th position (1-based index) to 'c'. self.S[i - 1] = c def range_query(self, l: int, r: int) -> int: Determine the number of distinct characters in the substring S[l...r] (1-based inclusive). >>> dcc = DistinctCharacterCounter(\\"abacabad\\") >>> dcc.range_query(1, 4) 3 >>> dcc.update(3, 'e') >>> dcc.range_query(1, 4) 4 return len(set(self.S[l - 1:r])) def process_queries(N: int, Q: int, S: str, queries: List[Tuple[int, int, Union[int, str]]]) -> List[int]: Process a list of queries on the given string S. >>> N, Q = 8, 5 >>> S = \\"abacabad\\" >>> queries = [(2, 1, 4), (2, 1, 8), (1, 3, 'e'), (2, 1, 4), (2, 1, 8)] >>> process_queries(N, Q, S, queries) [3, 4, 4, 5] dcc = DistinctCharacterCounter(S) results = [] for query in queries: if query[0] == 1: _, i, c = query dcc.update(i, c) elif query[0] == 2: _, l, r = query results.append(dcc.range_query(l, r)) return results","solution":"class DistinctCharacterCounter: def __init__(self, S): self.S = list(S) self.size = len(S) def update(self, i, c): self.S[i-1] = c def range_query(self, l, r): return len(set(self.S[l-1:r])) def process_queries(N, Q, S, queries): dcc = DistinctCharacterCounter(S) results = [] for query in queries: if query[0] == 1: _, i, c = query dcc.update(i, c) elif query[0] == 2: _, l, r = query results.append(dcc.range_query(l, r)) return results"},{"question":"def maxProfit(k: int, prices: List[int]) -> int: Returns the maximum profit achievable with at most k transactions. :param k: int - maximum number of transactions allowed :param prices: List[int] - list of stock prices on consecutive days :return: int - maximum profit achievable >>> maxProfit(2, [3, 2, 6, 5, 0, 3]) 5 >>> maxProfit(2, [1, 2, 3, 4, 5]) 4 >>> maxProfit(1, [1, 2, 3, 4, 5]) 4 >>> maxProfit(2, [5]) 0 >>> maxProfit(0, [3, 2, 6, 5, 0, 3]) 0 >>> maxProfit(2, [5, 4, 3, 2, 1]) 0 >>> maxProfit(10, [3, 2, 6, 5, 0, 3]) 7 >>> maxProfit(100, [i for i in range(1, 1001)]) 999","solution":"def maxProfit(k, prices): Returns the maximum profit achievable with at most k transactions. :param k: int - maximum number of transactions allowed :param prices: List[int] - list of stock prices on consecutive days :return: int - maximum profit achievable if not prices or k == 0: return 0 n = len(prices) if k >= n // 2: return sum( max(prices[i + 1] - prices[i], 0) for i in range(n - 1) ) profits = [[0] * (n) for _ in range(k + 1)] for t in range(1, k + 1): max_to_buy = -prices[0] for d in range(1, n): profits[t][d] = max(profits[t][d - 1], prices[d] + max_to_buy) max_to_buy = max(max_to_buy, profits[t - 1][d] - prices[d]) return profits[k][n - 1]"},{"question":"def smallest_number_of_hubs(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Compute the smallest number of hubs required to route a given number of parcels in a given number of days. Each hub must handle an equal number of parcels per day. Parameters: T (int): Number of test cases test_cases (List[Tuple[int, int]]): Each tuple contains P (number of parcels) and D (number of days) Returns: List[int]: List of smallest required number of hubs for each test case >>> smallest_number_of_hubs(3, [(10, 5), (1000, 10), (15, 2)]) [2, 100, 8] >>> smallest_number_of_hubs(1, [(10, 1)]) [10] >>> smallest_number_of_hubs(1, [(100, 100)]) [1] >>> smallest_number_of_hubs(2, [(1000000000, 1), (1000000000, 1000000000)]) [1000000000, 1]","solution":"def smallest_number_of_hubs(T, test_cases): results = [] for P, D in test_cases: hubs = (P + D - 1) // D # Ceiling division results.append(hubs) return results # Example usage: # T = 3 # test_cases = [(10, 5), (1000, 10), (15, 2)] # print(smallest_number_of_hubs(T, test_cases)) # Output: [2, 100, 8]"},{"question":"def allocate_tickets(event_tickets, requests): Process ticket requests and allocate available tickets. Parameters: event_tickets (dict): Dictionary with event names as keys and available tickets as values. requests (list of tuples): List of tuples, each containing an event name and the number of tickets requested. Returns: dict: Dictionary with event names as keys and the number of tickets allocated as values. pass def test_allocate_tickets(): event_tickets = { \\"concert_a\\": 100, \\"concert_b\\": 50, \\"concert_c\\": 10 } requests = [ (\\"concert_a\\", 30), (\\"concert_b\\", 60), (\\"concert_c\\", 5), (\\"concert_a\\", 70) ] expected_output = { \\"concert_a\\": 100, \\"concert_c\\": 5 } assert allocate_tickets(event_tickets, requests) == expected_output def test_allocate_tickets_all_fulfilled(): event_tickets = { \\"event1\\": 50, \\"event2\\": 30, \\"event3\\": 20 } requests = [ (\\"event1\\", 20), (\\"event2\\", 10), (\\"event3\\", 15), (\\"event1\\", 30) ] expected_output = { \\"event1\\": 50, \\"event2\\": 10, \\"event3\\": 15 } assert allocate_tickets(event_tickets, requests) == expected_output def test_allocate_tickets_none_fulfilled(): event_tickets = { \\"event1\\": 10, \\"event2\\": 5 } requests = [ (\\"event1\\", 20), (\\"event2\\", 10) ] expected_output = {} assert allocate_tickets(event_tickets, requests) == expected_output def test_allocate_tickets_partial_fulfilled(): event_tickets = { \\"concert_x\\": 25 } requests = [ (\\"concert_x\\", 10), (\\"concert_x\\", 20) ] expected_output = { \\"concert_x\\": 10 } assert allocate_tickets(event_tickets, requests) == expected_output def test_allocate_tickets_empty_requests(): event_tickets = { \\"concert_x\\": 25 } requests = [] expected_output = {} assert allocate_tickets(event_tickets, requests) == expected_output","solution":"def allocate_tickets(event_tickets, requests): Process ticket requests and allocate available tickets. Parameters: event_tickets (dict): Dictionary with event names as keys and available tickets as values. requests (list of tuples): List of tuples, each containing an event name and the number of tickets requested. Returns: dict: Dictionary with event names as keys and the number of tickets allocated as values. allocated_tickets = {event: 0 for event in event_tickets} for event, requested in requests: if event in event_tickets: if event_tickets[event] >= requested: allocated_tickets[event] += requested event_tickets[event] -= requested return {event: tickets for event, tickets in allocated_tickets.items() if tickets > 0}"},{"question":"def countFurnitureGroups(floorPlan: List[List[int]]) -> int: Determine the number of distinct furniture groups on the floor plan. A furniture group is defined as a set of adjacent furniture pieces (vertically or horizontally connected). from typing import List def test_example_case(): floorPlan = [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1] ] assert countFurnitureGroups(floorPlan) == 3 def test_single_cell_with_furniture(): floorPlan = [ [1] ] assert countFurnitureGroups(floorPlan) == 1 def test_single_cell_without_furniture(): floorPlan = [ [0] ] assert countFurnitureGroups(floorPlan) == 0 def test_empty_floorPlan(): floorPlan = [] assert countFurnitureGroups(floorPlan) == 0 def test_no_furniture(): floorPlan = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert countFurnitureGroups(floorPlan) == 0 def test_all_furniture_connected(): floorPlan = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert countFurnitureGroups(floorPlan) == 1 def test_disconnected_furniture_groups(): floorPlan = [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] assert countFurnitureGroups(floorPlan) == 5 def test_large_complex_case(): floorPlan = [ [1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1] ] assert countFurnitureGroups(floorPlan) == 4","solution":"from typing import List def countFurnitureGroups(floorPlan: List[List[int]]) -> int: if not floorPlan: return 0 def dfs(x, y): if x < 0 or x >= len(floorPlan) or y < 0 or y >= len(floorPlan[0]) or floorPlan[x][y] == 0: return floorPlan[x][y] = 0 # Mark this cell as visited # Visit all adjacent cells (up, down, left, right) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) furniture_groups = 0 for i in range(len(floorPlan)): for j in range(len(floorPlan[0])): if floorPlan[i][j] == 1: # Found a new furniture group furniture_groups += 1 dfs(i, j) return furniture_groups"},{"question":"from typing import List def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression and returns the result as a floating-point number. The expression may include the operators '+', '-', '*', and '/'. Args: expression (str): A string representing the arithmetic expression. Returns: float: The result of evaluating the expression, rounded to two decimal places. >>> evaluate_expression(\\"3+5*2\\") 13.00 >>> evaluate_expression(\\"10/2-3\\") 2.00 >>> evaluate_expression(\\"4*3/2+7\\") 13.00 pass def evaluate_expressions(expressions: List[str]) -> List[str]: Evaluates a list of arithmetic expressions and returns the results. Args: expressions (List[str]): A list of strings, each representing an arithmetic expression. Returns: List[str]: The results of evaluating each expression, formatted as strings rounded to two decimal places. >>> evaluate_expressions([\\"3+5*2\\", \\"10/2-3\\", \\"4*3/2+7\\"]) [\\"13.00\\", \\"2.00\\", \\"13.00\\"] pass # Unit Tests def test_evaluate_expression(): assert evaluate_expression(\\"3+5*2\\") == 13.00 assert evaluate_expression(\\"10/2-3\\") == 2.00 assert evaluate_expression(\\"4*3/2+7\\") == 13.00 assert evaluate_expression(\\"1+2*3\\") == 7.00 assert evaluate_expression(\\"10+20/5*4\\") == 26.00 assert evaluate_expression(\\"100-50*2/5\\") == 80.00 def test_evaluate_expressions(): expressions = [\\"3+5*2\\", \\"10/2-3\\", \\"4*3/2+7\\"] expected_results = [\\"13.00\\", \\"2.00\\", \\"13.00\\"] assert evaluate_expressions(expressions) == expected_results expressions = [\\"1+2*3\\", \\"10+20/5*4\\"] expected_results = [\\"7.00\\", \\"26.00\\"] assert evaluate_expressions(expressions) == expected_results expressions = [\\"100-50*2/5\\", \\"7-3+4\\"] expected_results = [\\"80.00\\", \\"8.00\\"] assert evaluate_expressions(expressions) == expected_results","solution":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression and returns the result. import re # Function to calculate based on operators def calculate(operands, operators): # Support +, -, *, / while '*' in operators or '/' in operators: for i, op in enumerate(operators): if op in '*/': if op == '*': result = operands[i] * operands[i + 1] else: result = operands[i] / operands[i + 1] operands[i:i + 2] = [result] operators.pop(i) break while '+' in operators or '-' in operators: for i, op in enumerate(operators): if op in '+-': if op == '+': result = operands[i] + operands[i + 1] else: result = operands[i] - operands[i + 1] operands[i:i + 2] = [result] operators.pop(i) break return operands[0] # Extract numbers and operators numbers = list(map(float, re.findall(r'd+', expression))) operators = re.findall(r'[+-*/]', expression) return round(calculate(numbers, operators), 2) def evaluate_expressions(expressions): results = [] for expression in expressions: results.append(f\\"{evaluate_expression(expression):.2f}\\") return results"},{"question":"def organize_bookshelf(bookshelf: str) -> str: Organizes books on the bookshelf by genres in the following order: \\"fiction\\", \\"non-fiction\\", \\"comics\\", and \\"magazines\\". Args: bookshelf (str): A string representing the bookshelf with books separated by a space. Returns: str: A string with the books organized by genre. Examples: >>> organize_bookshelf(\\"fiction non-fiction fiction comics magazines comics fiction non-fiction magazines\\") 'fiction fiction fiction non-fiction non-fiction comics comics magazines magazines' >>> organize_bookshelf(\\"comics magazines fiction non-fiction\\") 'fiction non-fiction comics magazines' >>> organize_bookshelf(\\"fiction fiction fiction\\") 'fiction fiction fiction' >>> organize_bookshelf(\\"\\") ''","solution":"def organize_bookshelf(bookshelf: str) -> str: Organizes books on the bookshelf by genres in the following order: \\"fiction\\", \\"non-fiction\\", \\"comics\\", and \\"magazines\\". Args: bookshelf (str): A string representing the bookshelf with books separated by a space. Returns: str: A string with the books organized by genre. genres = [\\"fiction\\", \\"non-fiction\\", \\"comics\\", \\"magazines\\"] books = bookshelf.split() organized_books = [] for genre in genres: organized_books.extend([book for book in books if book == genre]) return ' '.join(organized_books)"},{"question":"def min_moves_to_reach(x: int, y: int): Returns the minimum number of moves Alice needs to reach Bob and the sequence of moves. Parameters: x (int): The x-coordinate of Bob y (int): The y-coordinate of Bob Returns: tuple: A tuple containing the minimum number of moves (int) and the sequence of moves (str) >>> min_moves_to_reach(3, 4) (7, \\"RRRUUUU\\") >>> min_moves_to_reach(0, 0) (0, \\"\\") >>> min_moves_to_reach(-2, -3) (5, \\"LLDDD\\") >>> min_moves_to_reach(2, -3) (5, \\"RRDDD\\") >>> min_moves_to_reach(-3, 2) (5, \\"LLLUU\\")","solution":"def min_moves_to_reach(x, y): Returns the minimum number of moves Alice needs to reach Bob and the sequence of moves. Parameters: x (int): The x-coordinate of Bob y (int): The y-coordinate of Bob Returns: tuple: A tuple containing the minimum number of moves (int) and the sequence of moves (str) # Number of moves is the sum of x and y absolute values num_moves = abs(x) + abs(y) # Create the sequence of moves move_sequence = \\"\\" if x > 0: move_sequence += \\"R\\" * x elif x < 0: move_sequence += \\"L\\" * abs(x) if y > 0: move_sequence += \\"U\\" * y elif y < 0: move_sequence += \\"D\\" * abs(y) return num_moves, move_sequence"},{"question":"def rank_elements(lst: List[int]) -> List[int]: This function takes a list of numbers and returns a new list where each number is replaced by its rank in the original list. The rank of a number is its index in the sorted list of unique numbers, starting from 1. >>> rank_elements([40, 10, 20, 30]) [4, 1, 2, 3] >>> rank_elements([40, 10, 20, 30, 20]) [4, 1, 2, 3, 2] >>> rank_elements([10, 10, 10]) [1, 1, 1] >>> rank_elements([-10, 0, 10, 10]) [1, 2, 3, 3] >>> rank_elements([3, -3, 0, -3, 3]) [3, 1, 2, 1, 3]","solution":"def rank_elements(lst): This function takes a list of numbers and returns a new list where each number is replaced by its rank in the original list. The rank of a number is its index in the sorted list of unique numbers, starting from 1. :param lst: List of numbers :return: List with ranks of the elements # Create a sorted list of unique elements unique_sorted_lst = sorted(set(lst)) # Create a dictionary to map each number to its rank rank_dict = {num: rank for rank, num in enumerate(unique_sorted_lst, start=1)} # Replace each element in original list with its rank return [rank_dict[num] for num in lst]"},{"question":"def closest_pair_to_target(arr, target): Finds two elements in the list 'arr' whose sum is closest to 'target'. If multiple pairs have the same closest sum, return the pair with the smallest first element. If still tied, return the pair with the smallest second element. :param arr: List of positive integers :param target: Target sum :return: Tuple of two integers >>> closest_pair_to_target([10, 22, 28, 29, 30, 40], 54) (22, 30) >>> closest_pair_to_target([1, 3, 4, 7, 10], 15) (4, 10) from solution import closest_pair_to_target def test_case_1(): arr = [10, 22, 28, 29, 30, 40] target = 54 assert closest_pair_to_target(arr, target) == (22, 30) def test_case_2(): arr = [1, 3, 4, 7, 10] target = 15 assert closest_pair_to_target(arr, target) == (4, 10) def test_case_with_exact_pairs(): arr = [1, 2, 3, 4, 5] target = 10 assert closest_pair_to_target(arr, target) == (4, 5) def test_case_with_multiple_closest_pairs(): arr = [1, 3, 4, 6, 8] target = 8 assert closest_pair_to_target(arr, target) == (1, 6) def test_case_with_large_numbers(): arr = [100000, 200000, 300000, 400000] target = 500000 assert closest_pair_to_target(arr, target) == (100000, 400000)","solution":"def closest_pair_to_target(arr, target): Finds two elements in the list 'arr' whose sum is closest to 'target'. If multiple pairs have the same closest sum, return the pair with the smallest first element. If still tied, return the pair with the smallest second element. :param arr: List of positive integers :param target: Target sum :return: Tuple of two integers arr.sort() # Sort the array to use two-pointer technique left, right = 0, len(arr) - 1 closest_sum = float('inf') result = (0, 0) while left < right: current_sum = arr[left] + arr[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum result = (arr[left], arr[right]) elif abs(target - current_sum) == abs(target - closest_sum): if arr[left] < result[0] or (arr[left] == result[0] and arr[right] < result[1]): result = (arr[left], arr[right]) if current_sum < target: left += 1 else: right -= 1 return result"},{"question":"def count_pairs_with_difference(nums: List[int], target: int) -> int: Returns the number of pairs of integers in the array whose difference is equal to target. >>> count_pairs_with_difference([1, 7, 5, 9, 2, 12, 3], 2) 4 >>> count_pairs_with_difference([1, 1, 1, 1], 0) 6 >>> count_pairs_with_difference([4, 4, 4, 4], 3) 0","solution":"def count_pairs_with_difference(nums, target): Returns the number of pairs of integers in the array whose difference is equal to target. if target == 0: counts = {} for num in nums: if num in counts: counts[num] += 1 else: counts[num] = 1 return sum(c * (c - 1) // 2 for c in counts.values()) num_set = set(nums) count = 0 for num in nums: if num + target in num_set: count += 1 if num - target in num_set: count += 1 num_set.discard(num) return count"},{"question":"def rotate_subrectangle(matrix, x1, y1, x2, y2): Rotate the subrectangle defined by the coordinates (x1, y1) and (x2, y2) of the given matrix in clockwise direction by one step. matrix: List[List[int]] - the original matrix x1: int - top-left x-coordinate of the subrectangle y1: int - top-left y-coordinate of the subrectangle x2: int - bottom-right x-coordinate of the subrectangle y2: int - bottom-right y-coordinate of the subrectangle Returns: List[List[int]] - the matrix after rotating the subrectangle # Unit Tests def test_rotate_basic_case(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] x1, y1, x2, y2 = 1, 1, 2, 2 result = rotate_subrectangle(matrix, x1, y1, x2, y2) expected = [ [1, 2, 3, 4], [5, 10, 6, 8], [9, 11, 7, 12], [13, 14, 15, 16] ] assert result == expected def test_no_rotation_on_single_element_subrectangle(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] x1, y1, x2, y2 = 1, 1, 1, 1 result = rotate_subrectangle(matrix, x1, y1, x2, y2) expected = matrix[:] assert result == expected def test_complete_matrix_rotation_2x2(): matrix = [ [1, 2], [3, 4] ] x1, y1, x2, y2 = 0, 0, 1, 1 result = rotate_subrectangle(matrix, x1, y1, x2, y2) expected = [ [3, 1], [4, 2] ] assert result == expected def test_partial_rectangular_submatrix(): matrix = [ [8, 2, 3, 5], [4, 6, 9, 7], [3, 10, 11, 12], [13, 14, 15, 16] ] x1, y1, x2, y2 = 1, 1, 3, 2 result = rotate_subrectangle(matrix, x1, y1, x2, y2) expected = [ [8, 2, 3, 5], [4, 10, 6, 7], [3, 14, 9, 12], [13, 15, 11, 16] ] assert result == expected","solution":"def rotate_subrectangle(matrix, x1, y1, x2, y2): Rotate the subrectangle defined by the coordinates (x1, y1) and (x2, y2) of the given matrix in clockwise direction by one step. matrix: List[List[int]] - the original matrix x1: int - top-left x-coordinate of the subrectangle y1: int - top-left y-coordinate of the subrectangle x2: int - bottom-right x-coordinate of the subrectangle y2: int - bottom-right y-coordinate of the subrectangle Returns: List[List[int]] - the matrix after rotating the subrectangle if x1 == x2 and y1 == y2: return matrix # Extract the subrectangle elements into a list elements = [] for j in range(y1, y2 + 1): elements.append(matrix[x1][j]) for i in range(x1 + 1, x2 + 1): elements.append(matrix[i][y2]) for j in range(y2 - 1, y1 - 1, -1): elements.append(matrix[x2][j]) for i in range(x2 - 1, x1, -1): elements.append(matrix[i][y1]) # Rotate the elements by one step clockwise elements = [elements[-1]] + elements[:-1] # Place the elements back into the subrectangle idx = 0 for j in range(y1, y2 + 1): matrix[x1][j] = elements[idx] idx += 1 for i in range(x1 + 1, x2 + 1): matrix[i][y2] = elements[idx] idx += 1 for j in range(y2 - 1, y1 - 1, -1): matrix[x2][j] = elements[idx] idx += 1 for i in range(x2 - 1, x1, -1): matrix[i][y1] = elements[idx] idx += 1 return matrix"},{"question":"def max_production_output(scores: List[int], k: int) -> int: Returns the maximum production output by summing the highest k productivity scores. If the number of workers is insufficient to form a complete team, ignore the remaining workers. Parameters: scores (List[int]): List of productivity scores of workers. k (int): Number of workers in each team. Returns: int: Maximum production output. >>> max_production_output([12, 45, 22, 34, 27], 3) 106 >>> max_production_output([5, 15, 8, 23, 14, 18, 30, 17], 4) 88 >>> max_production_output([9, 12, 5, 6, 8], 2) 21 >>> max_production_output([7, 4, 10, 1], 1) 10 >>> max_production_output([7, 4, 10, 1], 5) 0 >>> max_production_output([9], 1) 9 >>> max_production_output([10, 10, 10, 10], 4) 40 >>> max_production_output([], 1) 0 pass def test_max_production_output(): assert max_production_output([12, 45, 22, 34, 27], 3) == 106 assert max_production_output([5, 15, 8, 23, 14, 18, 30, 17], 4) == 88 assert max_production_output([9, 12, 5, 6, 8], 2) == 21 assert max_production_output([7, 4, 10, 1], 1) == 10 assert max_production_output([7, 4, 10, 1], 5) == 0 # Insufficient workers to form a team assert max_production_output([9], 1) == 9 assert max_production_output([10, 10, 10, 10], 4) == 40 assert max_production_output([], 1) == 0 # No workers # Run all the tests if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def max_production_output(scores, k): Returns the maximum production output by summing the highest k productivity scores. If the number of workers is insufficient to form a complete team, ignore the remaining workers. Parameters: scores (List[int]): List of productivity scores of workers. k (int): Number of workers in each team. Returns: int: Maximum production output. if len(scores) < k: return 0 scores.sort(reverse=True) return sum(scores[:k])"},{"question":"def roman_to_int(s: str) -> int: Converts a string of Roman numerals to an integer. >>> roman_to_int(\\"III\\") == 3 >>> roman_to_int(\\"IV\\") == 4 >>> roman_to_int(\\"V\\") == 5 >>> roman_to_int(\\"IX\\") == 9 >>> roman_to_int(\\"X\\") == 10 >>> roman_to_int(\\"LVIII\\") == 58 >>> roman_to_int(\\"MCMXCIV\\") == 1994 >>> roman_to_int(\\"MMXXIII\\") == 2023 >>> roman_to_int(\\"LXXX\\") == 80 >>> roman_to_int(\\"CMXC\\") == 990 >>> roman_to_int(\\"CDXLIV\\") == 444","solution":"def roman_to_int(s): Converts a string of Roman numerals to an integer. Parameters: s (str): The Roman numeral string. Returns: int: The integer representation of the given Roman numeral. roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in s[::-1]: value = roman_to_int_map[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"def sum_of_prime_factors(n: int) -> int: Write a function to find the sum of all prime factors of a given number \`n\`. A prime factor is a factor that is a prime number. >>> sum_of_prime_factors(18) 5 >>> sum_of_prime_factors(28) 9","solution":"def sum_of_prime_factors(n): Returns the sum of all prime factors of n. def is_prime(num): if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True if n <= 1: return 0 prime_factors_sum = 0 factor = 2 # Check for each factor from 2 to sqrt(n) while factor * factor <= n: if n % factor == 0: if is_prime(factor): prime_factors_sum += factor while n % factor == 0: n //= factor factor += 1 # If n is still greater than 1, it must be a prime number if n > 1 and is_prime(n): prime_factors_sum += n return prime_factors_sum"},{"question":"def solve_sudoku(board): Solves the Sudoku puzzle using backtracking. Args: board (list of list of int): 9x9 nested list representing the Sudoku grid with integers ranging from 0 to 9. Returns: bool: True if the puzzle is solved successfully, False if no valid solution exists. # Example usage: board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] if solve_sudoku(board): print(\\"Sudoku solved successfully!\\") print(board) else: print(\\"No valid solution exists.\\") Test cases to validate the solution: def test_sudoku_solvable(): board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] assert solve_sudoku(board) assert board == [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] def test_sudoku_unsolvable(): board = [ [5, 1, 6, 8, 4, 9, 7, 3, 2], [3, 0, 7, 6, 0, 5, 0, 0, 0], [8, 0, 9, 7, 0, 0, 0, 6, 5], [1, 3, 5, 0, 6, 7, 2, 0, 0], [4, 7, 2, 5, 9, 1, 3, 8, 6], [9, 6, 8, 3, 2, 4, 5, 7, 1], [2, 5, 3, 1, 8, 6, 9, 0, 7], [6, 8, 4, 2, 7, 3, 1, 5, 0], [7, 9, 1, 0, 5, 8, 6, 2, 0] ] assert not solve_sudoku(board)","solution":"def solve_sudoku(board): Solves the Sudoku puzzle using backtracking. Args: board (list of list of int): 9x9 nested list representing the Sudoku grid with integers ranging from 0 to 9. Returns: bool: True if the puzzle is solved successfully, False if no valid solution exists. def is_valid(board, row, col, num): # Check validity in the row for c in range(9): if board[row][c] == num: return False # Check validity in the column for r in range(9): if board[r][col] == num: return False # Check validity in the 3x3 subgrid start_row = (row // 3) * 3 start_col = (col // 3) * 3 for r in range(3): for c in range(3): if board[start_row + r][start_col + c] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = 0 return False return True return solve(board)"},{"question":"def flatten_dictionary(d: dict, parent_key: str = '', sep: str = '.') -> dict: Design a function \`flatten_dictionary\` that takes a dictionary with nested dictionaries as input and returns a new dictionary with only one level of nesting, using dot-separated keys to indicate the nesting. If a value is not a dictionary, it should appear as-is in the output dictionary. >>> flatten_dictionary({\\"key1\\": 1, \\"key2\\": {\\"a\\": 2, \\"b\\": 3, \\"c\\": {\\"d\\": 4, \\"e\\": 5}}}) {'key1': 1, 'key2.a': 2, 'key2.b': 3, 'key2.c.d': 4, 'key2.c.e': 5} >>> flatten_dictionary({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": 1}}}}) {'a.b.c.d': 1}","solution":"def flatten_dictionary(d, parent_key='', sep='.'): Flatten a nested dictionary using dot notation for the keys. Args: d (dict): The dictionary to flatten. parent_key (str): The base key string. sep (str): The separator to use for concatenating keys. Returns: dict: The flattened dictionary. items = [] for k, v in d.items(): new_key = parent_key + sep + k if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def fibonacci(n, memo={}): Return the n-th Fibonacci number using memoization. Parameters: n (int): The position of the Fibonacci number to be computed. Must be a non-negative integer. Returns: int: The n-th Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(50) 12586269025","solution":"def fibonacci(n, memo={}): Return the n-th Fibonacci number using memoization. Parameters: n (int): The position of the Fibonacci number to be computed. Must be a non-negative integer. Returns: int: The n-th Fibonacci number. if n in memo: return memo[n] if n == 0: return 0 if n == 1: return 1 memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo) return memo[n]"},{"question":"def convert_to_pig_latin(sentence: str) -> str: Converts a sentence to Pig Latin. Rules: 1. If the word starts with a vowel (a, e, i, o, u), \\"way\\" is appended to the end. Example: \\"apple\\" -> \\"appleway\\" 2. If the word starts with a consonant, move the initial consonant(s) to the end followed by \\"ay\\". Example: \\"banana\\" -> \\"ananabay\\" 3. Preserve capitalization and punctuation in the converted word. >>> convert_to_pig_latin(\\"Hello world!\\") \\"Ellohay orldway!\\" >>> convert_to_pig_latin(\\"I am learning Pig Latin.\\") \\"Iway amway earninglay Igpay Atinlay.\\" pass def test_convert_to_pig_latin_simple_sentence(): assert convert_to_pig_latin(\\"hello world\\") == \\"ellohay orldway\\" def test_convert_to_pig_latin_with_punctuation(): assert convert_to_pig_latin(\\"Hello world!\\") == \\"Ellohay orldway!\\" def test_convert_to_pig_latin_with_capitalization(): assert convert_to_pig_latin(\\"I am learning Pig Latin.\\") == \\"Iway amway earninglay Igpay Atinlay.\\" def test_convert_to_pig_latin_vowel_start(): assert convert_to_pig_latin(\\"apple\\") == \\"appleway\\" assert convert_to_pig_latin(\\"Apple\\") == \\"Appleway\\" def test_convert_to_pig_latin_consonant_start(): assert convert_to_pig_latin(\\"banana\\") == \\"ananabay\\" assert convert_to_pig_latin(\\"Banana\\") == \\"Ananabay\\" def test_convert_to_pig_latin_all_consonants(): assert convert_to_pig_latin(\\"rhythm\\") == \\"rhythmay\\" assert convert_to_pig_latin(\\"Rhythm\\") == \\"Rhythmay\\" def test_convert_to_pig_latin_empty_string(): assert convert_to_pig_latin(\\"\\") == \\"\\" def test_convert_to_pig_latin_single_letter(): assert convert_to_pig_latin(\\"A\\") == \\"Away\\" assert convert_to_pig_latin(\\"b\\") == \\"bay\\"","solution":"def convert_to_pig_latin(sentence: str) -> str: def word_to_pig_latin(word): vowels = 'aeiouAEIOU' punctuation = \\"\\" # Check if there's punctuation at the end if word[-1].isalpha() is False: punctuation = word[-1] word = word[:-1] # Rule for words starting with a vowel if word[0] in vowels: pig_word = word + \\"way\\" else: # Find the first vowel for i, char in enumerate(word): if char in vowels: pig_word = word[i:] + word[:i] + \\"ay\\" break else: pig_word = word + \\"ay\\" # Preserve capitalization if word[0].isupper(): pig_word = pig_word.capitalize() # Adding punctuation back pig_word += punctuation return pig_word words = sentence.split() pig_latin_words = [word_to_pig_latin(word) for word in words] return ' '.join(pig_latin_words)"},{"question":"def calculate_total_cost(prices, discount_threshold, discount_percentage): Calculates the total cost after applying a promotional discount. :param prices: List of integers representing book prices. :param discount_threshold: Integer threshold for the number of books to get the discount. :param discount_percentage: Float representing the discount percentage (e.g., 0.10 for 10%). :return: Float representing the total cost after discount, rounded to 2 decimal places. >>> calculate_total_cost([20, 15, 30, 10], 3, 0.10) 67.50 >>> calculate_total_cost([20, 15], 3, 0.10) 35.00 >>> calculate_total_cost([20, 15, 30, 10, 25], 5, 0.20) 80.00 >>> calculate_total_cost([], 3, 0.10) 0.00","solution":"def calculate_total_cost(prices, discount_threshold, discount_percentage): Calculates the total cost after applying a promotional discount. :param prices: List of integers representing book prices. :param discount_threshold: Integer threshold for the number of books to get the discount. :param discount_percentage: Float representing the discount percentage (e.g., 0.10 for 10%). :return: Float representing the total cost after discount, rounded to 2 decimal places. total_cost = sum(prices) num_books = len(prices) if num_books >= discount_threshold: discount = total_cost * discount_percentage total_cost -= discount return round(total_cost, 2)"},{"question":"def first_missing_positive(nums): Given an integer array nums, find the smallest missing positive integer. This algorithm runs in O(n) time and uses constant extra space. pass # Unit tests def test_example_1(): assert first_missing_positive([1, 2, 0]) == 3 def test_example_2(): assert first_missing_positive([3, 4, -1, 1]) == 2 def test_example_3(): assert first_missing_positive([7, 8, 9, 11, 12]) == 1 def test_single_element_missing_1(): assert first_missing_positive([2]) == 1 def test_no_positive_numbers(): assert first_missing_positive([-1, -2, -3]) == 1 def test_all_consecutive_numbers(): assert first_missing_positive([1, 2, 3, 4, 5]) == 6 def test_unsorted_array(): assert first_missing_positive([3, 4, -1, 1, 2]) == 5 def test_array_with_duplicates(): assert first_missing_positive([1, 1, 2, 2, 3, 3]) == 4","solution":"def first_missing_positive(nums): Given an integer array nums, find the smallest missing positive integer. This algorithm runs in O(n) time and uses constant extra space. n = len(nums) # Step 1: Move every positive integer (1, 2, ..., n) to its correct position (i.e., nums[i] = i + 1) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] with nums[nums[i] - 1] nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Step 2: Identify the first index i where nums[i] != i + 1 for i in range(n): if nums[i] != i + 1: return i + 1 # If all the positions are correct, then the missing number is n + 1 return n + 1"},{"question":"def num_ways(n: int) -> int: Returns the number of distinct ways to reach the nth step. >>> num_ways(1) == 1 >>> num_ways(2) == 2 >>> num_ways(3) == 3 >>> num_ways(4) == 5 >>> num_ways(5) == 8 >>> num_ways(10) == 89 >>> num_ways(20) == 10946 >>> num_ways(30) == 1346269 >>> num_ways(45) == 1836311903","solution":"def num_ways(n): Returns the number of distinct ways to reach the nth step. if n == 1: return 1 if n == 2: return 2 # Initialization of base cases first, second = 1, 2 # Calculating the number of ways for each step up to n for i in range(3, n + 1): first, second = second, first + second return second"},{"question":"def has_three_consecutive_evens(arr: List[int]) -> bool: Checks if there are three consecutive even numbers in the array. >>> has_three_consecutive_evens([1, 2, 4, 6, 7, 8]) True >>> has_three_consecutive_evens([1, 3, 5, 7, 9]) False","solution":"def has_three_consecutive_evens(arr): Checks if there are three consecutive even numbers in the array. Parameters: arr (list of int): List of integers Returns: bool: True if three consecutive even numbers exist, otherwise False. consecutive_count = 0 for num in arr: if num % 2 == 0: consecutive_count += 1 if consecutive_count == 3: return True else: consecutive_count = 0 return False"},{"question":"def valid_parentheses(n: int) -> int: Returns the number of valid parenthesis strings of length 2n. >>> valid_parentheses(1) 1 >>> valid_parentheses(2) 2 >>> valid_parentheses(3) 5 >>> valid_parentheses(4) 14 >>> valid_parentheses(5) 42","solution":"def valid_parentheses(n): Returns the number of valid parenthesis strings of length 2n. This is equivalent to the nth Catalan number. if n == 0: return 1 # Initialize a list to store computed Catalan numbers catalan = [0] * (n + 1) catalan[0] = 1 # Compute the nth Catalan number using the recursive formula: # C(n) = Sum(C(i) * C(n-i-1)) for i from 0 to n-1 for i in range(1, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[n]"},{"question":"class StockPriceTracker: Implement a StockPriceTracker class that manages the price of a single stock. The class should have the following methods: 1. void update(int timestamp, int price) – Updates the price of the stock at the given timestamp. 2. int getCurrentPrice() – Returns the latest price of the stock. 3. int getMaxPrice() – Returns the highest price ever recorded. 4. int getMinPrice() – Returns the lowest price ever recorded. 5. double getAveragePrice() – Returns the average of all recorded prices. Example: >>> tracker = StockPriceTracker() >>> tracker.update(1, 100) >>> tracker.update(2, 200) >>> tracker.update(3, 150) >>> tracker.getCurrentPrice() 150 >>> tracker.getMaxPrice() 200 >>> tracker.getMinPrice() 100 >>> tracker.getAveragePrice() 150.0 >>> tracker.update(4, 250) >>> tracker.getCurrentPrice() 250 >>> tracker.getMaxPrice() 250 >>> tracker.getMinPrice() 100 >>> tracker.getAveragePrice() 175.0 def __init__(self): pass def update(self, timestamp: int, price: int): pass def getCurrentPrice(self) -> int: pass def getMaxPrice(self) -> int: pass def getMinPrice(self) -> int: pass def getAveragePrice(self) -> float: pass","solution":"class StockPriceTracker: def __init__(self): self.prices = [] self.timestamps = [] self.current_price = None self.max_price = None self.min_price = None self.total_sum = 0 def update(self, timestamp, price): self.prices.append(price) self.timestamps.append(timestamp) self.current_price = price if self.max_price is None or price > self.max_price: self.max_price = price if self.min_price is None or price < self.min_price: self.min_price = price self.total_sum += price def getCurrentPrice(self): return self.current_price def getMaxPrice(self): return self.max_price def getMinPrice(self): return self.min_price def getAveragePrice(self): return self.total_sum / len(self.prices)"},{"question":"from typing import List def num_subarray_product_less_than_k(arr: List[int], k: int) -> int: Given an array of integers and an integer K, find the number of subarrays whose product of all elements is less than K. The results may be large, so return the final result modulo 10^9 + 7. >>> num_subarray_product_less_than_k([10, 5, 2, 6], 100) 8 >>> num_subarray_product_less_than_k([1, 2, 3], 0) 0 pass","solution":"def num_subarray_product_less_than_k(arr, k): if k <= 1: return 0 MOD = 10**9 + 7 prod = 1 left = 0 result = 0 for right in range(len(arr)): prod *= arr[right] while prod >= k and left <= right: prod //= arr[left] left += 1 result += right - left + 1 return result % MOD"},{"question":"from typing import List import re def find_palindromes(sentence: str) -> List[str]: Given a string, returns a list of unique palindromes from the string. >>> find_palindromes(\\"Madam Arora teaches malayalam!\\") == [\\"madam\\", \\"arora\\", \\"malayalam\\"] >>> find_palindromes(\\"Hello, level civic madam\\") == [\\"level\\", \\"civic\\", \\"madam\\"] >>> find_palindromes(\\"Python is fun\\") == [] >>> find_palindromes(\\"A car, a man, a maraca.\\") == [\\"a\\"] >>> find_palindromes(\\"A car, a man, a maraca, a cat!\\") == [\\"a\\"] >>> find_palindromes(\\"Madam madam MADAM!\\") == [\\"madam\\"]","solution":"import re def find_palindromes(sentence): Returns a list of unique palindromes from the given sentence. # Remove punctuation and make lowercase cleaned_sentence = re.sub(r'[^a-zA-Zs]', '', sentence).lower() # Split into words words = cleaned_sentence.split() # Identify palindromes palindromes = {word for word in words if word == word[::-1]} return list(palindromes)"},{"question":"def roman_sum(s1: str, s2: str) -> str: Compute the sum of two Roman numerals given as strings and return the result as a Roman numeral. >>> roman_sum(\\"XIII\\", \\"IV\\") \\"XVII\\" >>> roman_sum(\\"X\\", \\"X\\") \\"XX\\" >>> roman_sum(\\"IX\\", \\"I\\") \\"X\\" def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral.","solution":"def roman_to_int(s): Convert a Roman numeral to an integer. roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} total = 0 prev_value = 0 for char in reversed(s): value = roman_dict[char] if value < prev_value: total -= value else: total += value prev_value = value return total def int_to_roman(num): Convert an integer to a Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num def roman_sum(s1, s2): Compute the sum of two Roman numerals given as strings and return the result as a Roman numeral. num1 = roman_to_int(s1) num2 = roman_to_int(s2) total = num1 + num2 return int_to_roman(total)"},{"question":"from collections import deque from typing import List def maze_solver(maze: List[List[str]]) -> bool: Determines if there is a path from 'S' to 'E' in the given maze. Args: maze (List[List[str]]): The maze represented as a 2D grid Returns: bool: True if there is a path from 'S' to 'E', False otherwise Examples: >>> maze_solver([['S', '0', '1', '1', '0'], ['0', '0', '1', '0', '0'], ['1', '0', '1', '0', '1'], ['1', '0', '0', '0', 'E'], ['1', '1', '1', '1', '1']]) True >>> maze_solver([['S', '1', '1', '1', '1'], ['1', '1', '1', '0', '1'], ['1', '1', '1', '0', '1'], ['1', '0', '0', '0', '1'], ['1', 'E', '1', '1', '1']]) False pass def test_maze_solver_finds_path(): maze = [['S', '0', '1', '1', '0'], ['0', '0', '1', '0', '0'], ['1', '0', '1', '0', '1'], ['1', '0', '0', '0', 'E'], ['1', '1', '1', '1', '1']] assert maze_solver(maze) == True def test_maze_solver_no_path(): maze = [['S', '1', '1', '1', '1'], ['1', '1', '1', '0', '1'], ['1', '1', '1', '0', '1'], ['1', '0', '0', '0', '1'], ['1', 'E', '1', '1', '1']] assert maze_solver(maze) == False def test_maze_solver_direct_path(): maze = [['S', '0', 'E']] assert maze_solver(maze) == True def test_maze_solver_single_row_no_path(): maze = [['S', '1', 'E']] assert maze_solver(maze) == False def test_maze_solver_blocked_start(): maze = [['1', 'S', '1'], ['1', '1', '1'], ['1', 'E', '1']] assert maze_solver(maze) == False","solution":"from collections import deque def maze_solver(maze): Determines if there is a path from 'S' to 'E' in the given maze. :param maze: List[List[str]], the maze represented as a 2D grid :return: bool, True if there is a path from 'S' to 'E', False otherwise rows, cols = len(maze), len(maze[0]) start = None end = None # Find the start and end points for r in range(rows): for c in range(cols): if maze[r][c] == 'S': start = (r, c) elif maze[r][c] == 'E': end = (r, c) if not start or not end: return False # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) visited = set(start) while queue: current = queue.popleft() if current == end: return True for direction in directions: next_row = current[0] + direction[0] next_col = current[1] + direction[1] if 0 <= next_row < rows and 0 <= next_col < cols and maze[next_row][next_col] in {'0', 'E'}: next_position = (next_row, next_col) if next_position not in visited: visited.add(next_position) queue.append(next_position) return False"},{"question":"from typing import List def unique_combinations(nums: List[int]) -> List[List[int]]: Generate a list of unique combinations (subsets) of given integers. Each subset should be sorted in ascending order, and the solution set should not contain duplicate subsets. >>> unique_combinations([-1, 2, 2]) [ [], [-1], [-1, 2], [-1, 2, 2], [2], [2, 2] ] >>> unique_combinations([]) [[]] >>> unique_combinations([1, 2, 3]) [ [], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3] ] >>> unique_combinations([1, 1, 1]) [ [], [1], [1, 1], [1, 1, 1] ] >>> unique_combinations([1, 2, 2, 3]) [ [], [1], [1, 2], [1, 2, 2], [1, 2, 2, 3], [1, 2, 3], [1, 3], [2], [2, 2], [2, 2, 3], [2, 3], [3] ]","solution":"from typing import List def unique_combinations(nums: List[int]) -> List[List[int]]: def backtrack(start, path): result.append(path) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue backtrack(i + 1, path + [nums[i]]) nums.sort() result = [] backtrack(0, []) return result"},{"question":"def min_deletions_to_make_palindrome(s: str) -> int: Returns the minimum number of characters you need to delete to make the string a palindrome. >>> min_deletions_to_make_palindrome(\\"abca\\") # 1 >>> min_deletions_to_make_palindrome(\\"racecar\\") # 0 >>> min_deletions_to_make_palindrome(\\"google\\") # 2 >>> min_deletions_to_make_palindrome(\\"a\\") # 0 >>> min_deletions_to_make_palindrome(\\"aa\\") # 0 >>> min_deletions_to_make_palindrome(\\"aba\\") # 0 >>> min_deletions_to_make_palindrome(\\"abcdef\\") # 5","solution":"def min_deletions_to_make_palindrome(s): Returns the minimum number of characters you need to delete to make the string a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] n = len(s) lps_length = longest_palindromic_subsequence(s) return n - lps_length"},{"question":"def minimum_swaps_to_reverse(n: int) -> int: Returns the minimum number of swap operations needed to reverse the array of length n. >>> minimum_swaps_to_reverse(4) 2 >>> minimum_swaps_to_reverse(5) 2","solution":"def minimum_swaps_to_reverse(n): Returns the minimum number of swap operations needed to reverse the array of length n. return n // 2"},{"question":"def can_finish_race(speed: int, obstacle_positions: List[int]) -> bool: Determines if a race participant can avoid all obstacles. >>> can_finish_race(3, [5, 11, 20]) True >>> can_finish_race(4, [8, 16, 24]) False","solution":"def can_finish_race(speed, obstacle_positions): Returns True if the participant can avoid all obstacles on the track, otherwise returns False. for position in obstacle_positions: if position % speed == 0: return False return True"},{"question":"def first_non_repeating(s: str) -> str: Given a non-empty string s consisting of only lowercase letters, find and return the first non-repeating character in it. If it does not exist, return an underscore ('_'). >>> first_non_repeating(\\"leetcode\\") 'l' >>> first_non_repeating(\\"loveleetcode\\") 'v' >>> first_non_repeating(\\"aabbcc\\") '_'","solution":"def first_non_repeating(s): Returns the first non-repeating character in the string s. If no such character exists, returns '_'. count = {} for char in s: count[char] = count.get(char, 0) + 1 for char in s: if count[char] == 1: return char return '_'"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA, headB): Find the node at which the intersection of two singly linked lists begins or return null if there is no intersection. >>> intersect = ListNode(8) >>> intersect.next = ListNode(4) >>> intersect.next.next = ListNode(5) >>> headA = ListNode(4) >>> headA.next = ListNode(1) >>> headA.next.next = intersect >>> headB = ListNode(5) >>> headB.next = ListNode(6) >>> headB.next.next = ListNode(1) >>> headB.next.next.next = intersect >>> getIntersectionNode(headA, headB) == intersect True >>> headA = create_linked_list([2,6,4]) >>> headB = create_linked_list([1,5]) >>> getIntersectionNode(headA, headB) == None True def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA, headB): :type headA, headB: ListNode :rtype: ListNode if not headA or not headB: return None pointerA, pointerB = headA, headB while pointerA != pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"import typing from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Write a function that receives a list of integers and a target number. The function should find all unique pairs of integers in the list that add up to the target number. Return the pairs as a list of tuples. Parameters: nums (List[int]): List of integers. target (int): Target number. Returns: List[Tuple[int, int]]: List of unique pairs that sum to the target. >>> find_pairs([1, 3, 2, 2, -1, 0, 5], 4) [(1, 3), (2, 2), (-1, 5)] >>> find_pairs([2, 4, 3, 3, 6], 6) [(2, 4), (3, 3)] >>> find_pairs([1, 5, 7, -1, 5], 6) [(1, 5), (-1, 7)] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([], 5) [] >>> find_pairs([1, 2, 3, 4, 4, 5], 6) [(1, 5), (2, 4)]","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in the list that add up to the target number. Parameters: nums (List[int]): List of integers. target (int): Target number. Returns: List[Tuple[int, int]]: List of unique pairs that sum to the target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) # Ensuring each pair is ordered seen.add(num) return list(pairs)"},{"question":"def max_product_subarray(nums: List[int]) -> int: Returns the maximum product of a contiguous subarray. >>> max_product_subarray([2, 3, -2, 4]) == 6 >>> max_product_subarray([-2, 0, -1]) == 0 >>> max_product_subarray([-2, 3, -4]) == 24 from solution import max_product_subarray def test_max_product_subarray_positive(): assert max_product_subarray([2, 3, -2, 4]) == 6 def test_max_product_subarray_with_zero(): assert max_product_subarray([-2, 0, -1]) == 0 def test_max_product_subarray_mixed(): assert max_product_subarray([-2, 3, -4]) == 24 def test_max_product_subarray_all_negative(): assert max_product_subarray([-2, -3, -4]) == 12 def test_max_product_subarray_single_element(): assert max_product_subarray([3]) == 3 assert max_product_subarray([-3]) == -3 def test_max_product_subarray_with_zeros(): assert max_product_subarray([0, 2]) == 2 def test_max_product_subarray_two_elements(): assert max_product_subarray([-2, 1]) == 1 assert max_product_subarray([0, 2]) == 2 def test_max_product_subarray_large_numbers(): assert max_product_subarray([3, -1, 4]) == 4 assert max_product_subarray([3, -1, 4, 2, -5, -6]) == 240 def test_max_product_subarray_empty(): assert max_product_subarray([]) == 0","solution":"def max_product_subarray(nums): Returns the maximum product of a contiguous subarray. if not nums: return 0 max_product = current_max = current_min = nums[0] for num in nums[1:]: # If current number is negative, swap max and min if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) max_product = max(max_product, current_max) return max_product"},{"question":"def sequence_operations(n: int, q: int, operations: List[str]) -> List[int]: Determines the unlocked state of a sequence after a series of operations. >>> sequence_operations(5, 6, [\\"query 1\\", \\"lock 2\\", \\"lock 3\\", \\"query 3\\", \\"unlock 2\\", \\"query 2\\"]) [1, 3, 2] >>> sequence_operations(3, 5, [\\"lock 1\\", \\"lock 2\\", \\"query 1\\", \\"unlock 1\\", \\"query 1\\"]) [1, 1]","solution":"def sequence_operations(n, q, operations): sequence = [i + 1 for i in range(n)] locked = [False] * n result = [] for operation in operations: op = operation.split() action, p = op[0], int(op[1]) - 1 if action == \\"lock\\": locked[p] = True elif action == \\"unlock\\": locked[p] = False elif action == \\"query\\": result.append(sequence[p]) return result"},{"question":"def can_arrange_paintings(n: int, k: int, beauty_scores: List[int]) -> Tuple[str, List[int]]: Determine if it's possible to arrange paintings such that for any three consecutive paintings, the sum of their beauty scores is not divisible by k. Args: n (int): The number of paintings. k (int): The divisor. beauty_scores (List[int]): A list of integers representing the beauty scores of the paintings. Returns: Tuple[str, List[int]]: Returns a tuple where the first element is \\"Yes\\" or \\"No\\", and the second element is the order of the indices of the paintings if it is possible to arrange them accordingly. Examples: >>> can_arrange_paintings(4, 3, [1, 2, 3, 4]) (\\"Yes\\", [1, 3, 2, 4]) >>> can_arrange_paintings(5, 4, [2, 4, 6, 8, 10]) (\\"No\\",) pass # Your implementation here","solution":"from itertools import permutations def can_arrange_paintings(n, k, beauty_scores): # Generate all the permutations of indices for perm in permutations(range(1, n+1)): valid = True # Check every group of three consecutive paintings for i in range(n-2): total_beauty = beauty_scores[perm[i]-1] + beauty_scores[perm[i+1]-1] + beauty_scores[perm[i+2]-1] if total_beauty % k == 0: valid = False break if valid: return (\\"Yes\\", list(perm)) return (\\"No\\",) # Example Usage # n, k = 4, 3 # beauty_scores = [1, 2, 3, 4] # print(can_arrange_paintings(n, k, beauty_scores))"},{"question":"def generate_study_schedule(N, subjects): Generate study schedules for N students based on the number of subjects provided for each student. N : int : number of students subjects : List[int] : list of 'S' values representing the number of subjects for each student Returns a list of strings where each string represents the study schedule of a student. pass # Tests def test_single_student_one_subject(): assert generate_study_schedule(1, [1]) == [\\"1\\"] def test_single_student_two_subjects(): assert generate_study_schedule(1, [2]) == [\\"1 2\\", \\"2 1\\"] def test_single_student_three_subjects(): assert generate_study_schedule(1, [3]) == [\\"1 2 3\\", \\"2 3 1\\", \\"3 1 2\\"] def test_multiple_students_mixed_subjects(): assert generate_study_schedule(3, [2, 3, 4]) == [ \\"1 2\\", \\"2 1\\", # Student 1 \\"1 2 3\\", \\"2 3 1\\", \\"3 1 2\\", # Student 2 \\"1 2 3 4\\", \\"2 3 4 1\\", \\"3 4 1 2\\", \\"4 1 2 3\\" # Student 3 ] def test_multiple_students_same_subjects(): assert generate_study_schedule(2, [3, 3]) == [ \\"1 2 3\\", \\"2 3 1\\", \\"3 1 2\\", # Student 1 \\"1 2 3\\", \\"2 3 1\\", \\"3 1 2\\" # Student 2 ] def test_no_students(): assert generate_study_schedule(0, []) == []","solution":"def generate_study_schedule(N, subjects): Generate study schedules for N students based on the number of subjects provided for each student. N : int : number of students subjects : List[int] : list of 'S' values representing the number of subjects for each student Returns a list of strings where each string represents the study schedule of a student. schedules = [] for S in subjects: schedule = [] for i in range(1, S + 1): day_schedule = list(range(i, S + 1)) + list(range(1, i)) schedule.append(\\" \\".join(map(str, day_schedule))) schedules.extend(schedule) return schedules"},{"question":"def capture_regions(matrix: List[List[str]]) -> List[List[str]]: Modify the matrix to convert all 'O' which are not on the border and not connected to an 'O' on the border to 'X'. >>> capture_regions([ ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X'] ... ]) [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']] >>> capture_regions([['O', 'O'], ['O', 'O']]) [['O', 'O'], ['O', 'O']] >>> capture_regions([['X', 'X'], ['X', 'X']]) [['X', 'X'], ['X', 'X']] >>> capture_regions([['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]) [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']] >>> capture_regions([ ... ['X', 'X', 'X', 'X'], ... ['O', 'O', 'O', 'O'], ... ['X', 'X', 'X', 'X'], ... ['O', 'X', 'O', 'X'] ... ]) [['X', 'X', 'X', 'X'], ['O', 'O', 'O', 'O'], ['X', 'X', 'X', 'X'], ['O', 'X', 'O', 'X']]","solution":"def capture_regions(matrix): if not matrix: return matrix n, m = len(matrix), len(matrix[0]) borders = [] # Collect all border 'O's for i in range(n): if matrix[i][0] == 'O': borders.append((i, 0)) if matrix[i][m - 1] == 'O': borders.append((i, m - 1)) for j in range(m): if matrix[0][j] == 'O': borders.append((0, j)) if matrix[n - 1][j] == 'O': borders.append((n - 1, j)) # BFS to mark all 'O's connected to border 'O's while borders: x, y = borders.pop(0) if 0 <= x < n and 0 <= y < m and matrix[x][y] == 'O': matrix[x][y] = 'B' borders.append((x + 1, y)) borders.append((x - 1, y)) borders.append((x, y + 1)) borders.append((x, y - 1)) # Convert all 'O' to 'X' and 'B' back to 'O' for i in range(n): for j in range(m): if matrix[i][j] == 'O': matrix[i][j] = 'X' elif matrix[i][j] == 'B': matrix[i][j] = 'O' return matrix"},{"question":"import pytest from typing import List, Tuple def spiral_order(matrix: List[List[int]]) -> List[int]: Generate the list of numbers in a matrix in spiral order. result = [] while matrix: # Add the first row result += matrix.pop(0) if matrix and matrix[0]: # Add the last element of each remaining row for row in matrix: result.append(row.pop()) if matrix: # Add the last row in reverse result += matrix.pop()[::-1] if matrix and matrix[0]: # Add the first element of each remaining row in reverse for row in matrix[::-1]: result.append(row.pop(0)) return result def process_input(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[str]: Process the input to get the spiral order of matrices as strings. results = [] for i in range(T): M, N = test_cases[i][0] matrix = test_cases[i][1] results.append(' '.join(map(str, spiral_order(matrix)))) return results def test_spiral_order_single_case(): T = 1 test_cases = [ ((3, 3), [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) ] assert process_input(T, test_cases) == [\\"1 2 3 6 9 8 7 4 5\\"] def test_spiral_order_multiple_cases(): T = 2 test_cases = [ ((3, 3), [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), ((2, 4), [ [1, 2, 3, 4], [5, 6, 7, 8] ]) ] assert process_input(T, test_cases) == [\\"1 2 3 6 9 8 7 4 5\\", \\"1 2 3 4 8 7 6 5\\"] def test_spiral_order_varied_dimensions(): T = 2 test_cases = [ ((4, 4), [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]), ((2, 2), [ [1, 2], [3, 4] ]) ] assert process_input(T, test_cases) == [\\"1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10\\", \\"1 2 4 3\\"] def test_spiral_order_one_row(): T = 1 test_cases = [ ((1, 4), [ [1, 2, 3, 4] ]) ] assert process_input(T, test_cases) == [\\"1 2 3 4\\"] def test_spiral_order_one_column(): T = 1 test_cases = [ ((4, 1), [ [1], [2], [3], [4] ]) ] assert process_input(T, test_cases) == [\\"1 2 3 4\\"]","solution":"def spiral_order(matrix): result = [] while matrix: # Top row result += matrix.pop(0) if matrix and matrix[0]: # Right column for row in matrix: result.append(row.pop()) if matrix: # Bottom row result += matrix.pop()[::-1] if matrix and matrix[0]: # Left column for row in matrix[::-1]: result.append(row.pop(0)) return result def process_input(T, test_cases): results = [] for i in range(T): M, N = test_cases[i][0] matrix = test_cases[i][1] results.append(' '.join(map(str, spiral_order(matrix)))) return results"},{"question":"def valid_abbreviation(s: str, t: str) -> bool: Determines if a given string is a valid abbreviation of another string. s is an abbreviation of t if it can be formed by deleting some characters (possibly zero) from t without rearranging the remaining characters. >>> valid_abbreviation(\\"abc\\", \\"aabbcc\\") True >>> valid_abbreviation(\\"abc\\", \\"acb\\") False >>> valid_abbreviation(\\"\\", \\"abc\\") True >>> valid_abbreviation(\\"abc\\", \\"abc\\") True >>> valid_abbreviation(\\"a\\", \\"b\\") False","solution":"def valid_abbreviation(s, t): Determines if s is a valid abbreviation of t. Parameters: s (str): The potential abbreviation string. t (str): The original string. Returns: bool: True if s is a valid abbreviation of t, False otherwise. i, j = 0, 0 while i < len(s) and j < len(t): if s[i] == t[j]: i += 1 j += 1 return i == len(s)"},{"question":"from typing import List def minNewGroups(nums: List[int]) -> int: Returns the minimum number of new groups needed to include all people. If some people are left without forming a group of exactly 3, returns -1. >>> minNewGroups([3, 3, 3]) 3 >>> minNewGroups([3, 3, 2, 2, 1, 1]) 4 >>> minNewGroups([3, 4, 4, 1]) -1","solution":"def minNewGroups(nums): Returns the minimum number of new groups needed to include all people. If some people are left without forming a group of exactly 3, returns -1. # To store the total number of people initially total_people = sum(nums) # If the total number of people is not a multiple of 3, it is impossible to form fully filled groups if total_people % 3 != 0: return -1 # The number of fully filled groups of size 3 we can form min_groups = 0 # First, account for all complete groups of 3 min_groups += sum(x // 3 for x in nums) # Calculate remaining people after forming complete groups of 3 remainders = [x % 3 for x in nums] # Counts of how many groups have 1 or 2 remainders count1 = remainders.count(1) count2 = remainders.count(2) # We pair a 1-remainder with a 2-remainder, and each such pair forms an additional group pairs = min(count1, count2) min_groups += pairs count1 -= pairs count2 -= pairs # For any remaining 1-remainders or 2-remainders if count1 > 0 or count2 > 0: return -1 return min_groups"},{"question":"def largest_unique_substring(s): Write a function \`largest_unique_substring\` that, given a string, returns the longest substring that contains only unique characters. If there is a tie (multiple substrings of the same maximum length), return the substring that appears first. If the input is not a string or is empty, return None. >>> largest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> largest_unique_substring(\\"bbbbb\\") \\"b\\" >>> largest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> largest_unique_substring(\\"\\") is None >>> largest_unique_substring(12345) is None >>> largest_unique_substring(\\"aab\\") \\"ab\\" >>> largest_unique_substring(\\"abcbadefg\\") \\"cbadefg\\"","solution":"def largest_unique_substring(s): Returns the longest substring with all unique characters. If there is a tie, return the first appearing substring. If the input is not a string or is empty, return None. if not isinstance(s, str) or not s: return None start = 0 max_len = 0 max_substring = \\"\\" char_index_map = {} for end, char in enumerate(s): if char in char_index_map: start = max(start, char_index_map[char] + 1) char_index_map[char] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substring = s[start:end+1] return max_substring"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Serialize a binary tree to a single string. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> serialize(root) '1,2,N,N,3,4,N,N,5,N,N' def deserialize(data: str) -> TreeNode: Deserialize a single string to a binary tree. >>> data = '1,2,N,N,3,4,N,N,5,N,N' >>> root = deserialize(data) >>> serialize(root) '1,2,N,N,3,4,N,N,5,N,N'","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: def serialize_helper(node): if not node: result.append('N') else: result.append(str(node.val)) serialize_helper(node.left) serialize_helper(node.right) result = [] serialize_helper(root) return ','.join(result) def deserialize(data: str) -> TreeNode: def deserialize_helper(): val = next(values) if val == 'N': return None node = TreeNode(int(val)) node.left = deserialize_helper() node.right = deserialize_helper() return node values = iter(data.split(',')) return deserialize_helper()"},{"question":"def smallest_unrepresentable_sum(arr: List[int]) -> int: Given an array of non-negative integers, determine the smallest positive integer that cannot be represented as the sum of any subset of the array. >>> smallest_unrepresentable_sum([1, 3, 6, 10, 11, 15]) == 2 >>> smallest_unrepresentable_sum([1, 1, 1, 1]) == 5 >>> smallest_unrepresentable_sum([1]) == 2 >>> smallest_unrepresentable_sum([2]) == 1 >>> smallest_unrepresentable_sum([]) == 1 >>> smallest_unrepresentable_sum([1, 2, 5, 10, 20, 40]) == 4 >>> smallest_unrepresentable_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 56","solution":"def smallest_unrepresentable_sum(arr): arr.sort() res = 1 for num in arr: if num > res: break res += num return res"},{"question":"class QueueUsingStacks: Implements a queue using two stacks. Methods: - enqueue(e): Add integer e to the end of the queue. - dequeue(): Remove the integer from the front of the queue and return it. - front(): Return the value of the front element without dequeuing it. - empty(): Return whether the queue is empty or not. >>> q = QueueUsingStacks() >>> q.empty() True >>> q.enqueue(1) >>> q.enqueue(2) >>> q.empty() False >>> q.front() 1 >>> q.dequeue() 1 >>> q.front() 2 >>> q.dequeue() 2 >>> q.empty() True","solution":"class QueueUsingStacks: def __init__(self): self.in_stack = [] self.out_stack = [] def enqueue(self, e): self.in_stack.append(e) def dequeue(self): if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) if self.out_stack: return self.out_stack.pop() def front(self): if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) if self.out_stack: return self.out_stack[-1] def empty(self): return not (self.in_stack or self.out_stack)"},{"question":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations required to make all elements of the array equal. In one operation, you can select a single element of the array and either increment it or decrement it by 1. >>> min_operations_to_equal_elements(4, [1, 2, 3, 4]) 4 >>> min_operations_to_equal_elements(3, [7, 7, 7]) 0 >>> min_operations_to_equal_elements(5, [1, 10, 2, 9, 3]) 16 >>> min_operations_to_equal_elements(1, [100]) 0 >>> min_operations_to_equal_elements(2, [1, 1000]) 999","solution":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations required to make all elements of the array equal. In one operation, you can select a single element of the array and either increment it or decrement it by 1. # Find the median of the array arr.sort() median = arr[n // 2] # Compute the total number of operations required to set all elements to the median operations = sum(abs(x - median) for x in arr) return operations"},{"question":"def sum_unique_elements(arr, queries): Given an array and a list of queries, return the sum of unique elements in subarray defined by each query (1-based indices L to R inclusive). >>> sum_unique_elements([1, 2, 2, 1, 3, 4], [(1, 3), (2, 5), (1, 6)]) [3, 6, 10] >>> sum_unique_elements([5, 5, 5, 6, 6, 7], [(1, 6)]) [18] >>> sum_unique_elements([1, 2, 3, 4, 5], [(1, 5), (2, 3), (4, 4)]) [15, 5, 4] >>> sum_unique_elements([1], [(1, 1)]) [1] >>> sum_unique_elements([1000000000, 1000000000, 1, 2, 3, 3], [(1, 6), (3, 6), (2, 2)]) [1000000006, 6, 1000000000]","solution":"def sum_unique_elements(arr, queries): Given an array and a list of queries, return the sum of unique elements in subarray defined by each query (1-based indices L to R inclusive). results = [] for L, R in queries: subarray = arr[L-1:R] unique_elements_sum = sum(set(subarray)) results.append(unique_elements_sum) return results"},{"question":"def staircase(n: int) -> str: Generates a visual representation of a staircase pattern of height 'n' using asterisks. Parameters: n (int): The height of the staircase (1 ≤ n ≤ 100) Returns: str: A string representing the staircase pattern with each step separated by a newline character. Example: >>> staircase(4) ' *n **n ***n****' >>> staircase(1) '*' >>> staircase(3) ' *n **n***'","solution":"def staircase(n): Generates a visual representation of a staircase pattern of height 'n' using asterisks. Parameters: n (int): The height of the staircase (1 ≤ n ≤ 100) Returns: str: A string representing the staircase pattern with each step separated by a newline character. return 'n'.join(' ' * (n - i - 1) + '*' * (i + 1) for i in range(n))"},{"question":"from typing import List def next_generation(grid: List[List[bool]]) -> List[List[bool]]: Given an initial grid configuration, return the grid configuration after one time step according to Conway's Game of Life rules. >>> next_generation([ ... [False, True, False], ... [False, True, False], ... [False, True, False] ... ]) [[False, False, False], [True, True, True], [False, False, False]] >>> next_generation([ ... [False, False, False, False, False], ... [False, False, True, False, False], ... [False, False, True, False, False], ... [False, False, True, False, False], ... [False, False, False, False, False] ... ]) [[False, False, False, False, False], [False, False, False, False, False], [False, True, True, True, False], [False, False, False, False, False], [False, False, False, False, False]]","solution":"from typing import List def next_generation(grid: List[List[bool]]) -> List[List[bool]]: rows, cols = len(grid), len(grid[0]) def count_live_neighbors(r, c): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc]: count += 1 return count next_grid = [[False]*cols for _ in range(rows)] for r in range(rows): for c in range(cols): live_neighbors = count_live_neighbors(r, c) if grid[r][c]: if live_neighbors == 2 or live_neighbors == 3: next_grid[r][c] = True else: next_grid[r][c] = False else: if live_neighbors == 3: next_grid[r][c] = True return next_grid"},{"question":"def shortest_path(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Finds the shortest path from vertex 1 to vertex N in a weighted, undirected graph. If there is no path from vertex 1 to vertex N, returns -1. Parameters: N (int): number of vertices M (int): number of edges edges (list of tuples): each tuple contains three integers (u, v, w) where u and v are vertices and w is the weight of the edge Returns: int: the length of the shortest path from vertex 1 to vertex N, or -1 if no path exists >>> shortest_path(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) 6 >>> shortest_path(4, 2, [(1, 2, 3), (3, 4, 5)]) -1 >>> shortest_path(2, 1, [(1, 2, 4)]) 4 >>> shortest_path(5, 7, [(1, 2, 1), (2, 5, 10), (1, 3, 2), (3, 4, 2), (4, 5, 3), (1, 4, 15), (3, 5, 5)]) 7 >>> shortest_path(3, 3, [(1, 2, 1000000), (2, 3, 1000000), (1, 3, 2000000)]) 2000000 >>> shortest_path(6, 4, [(1, 2, 1), (2, 3, 1), (4, 5, 1), (5, 6, 1)]) -1","solution":"import heapq def shortest_path(N, M, edges): Finds the shortest path from vertex 1 to vertex N in a weighted, undirected graph. If there is no path from vertex 1 to vertex N, returns -1. Parameters: N (int): number of vertices M (int): number of edges edges (list of tuples): each tuple contains three integers (u, v, w) where u and v are vertices and w is the weight of the edge Returns: int: the length of the shortest path from vertex 1 to vertex N, or -1 if no path exists from collections import defaultdict, deque import heapq # Create adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm using a priority queue dist = {i: float('inf') for i in range(1, N+1)} dist[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist[N] if dist[N] != float('inf') else -1"},{"question":"def rotate_matrix(matrix): Rotates the input n x n matrix 90 degrees clockwise. Modifies the matrix in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [ [3, 1], [4, 2] ] >>> matrix = [ ... [1] ... ] >>> rotate_matrix(matrix) >>> matrix [ [1] ] # Your code here","solution":"def rotate_matrix(matrix): Rotates the input n x n matrix 90 degrees clockwise. Modifies the matrix in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List, Tuple def find_unique_number(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and a list of tuples where each tuple contains: - n: the size of the list - elements: the list of elements This function returns the unique number for each test case. >>> find_unique_number(2, [(5, [1, 2, 3, 2, 1]), (7, [4, 5, 6, 5, 4, 6, 7])]) [3, 7] >>> find_unique_number(1, [(5, [1, 2, 3, 4, 1])]) [2, 3, 4] result = [] for i in range(t): n, elements = test_cases[i] count = Counter(elements) for num, freq in count.items(): if freq == 1: result.append(num) break return result","solution":"from collections import Counter def find_unique_number(t, test_cases): Given the number of test cases and a list of tuples where each tuple contains: - n: the size of the list - elements: the list of elements This function returns the unique number for each test case. result = [] for i in range(t): n, elements = test_cases[i] count = Counter(elements) for num, freq in count.items(): if freq == 1: result.append(num) break return result"},{"question":"def count_paths(m: int, n: int) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. >>> count_paths(2, 2) 2 >>> count_paths(3, 7) 28 from typing import List # Unit tests def test_count_paths_2x2(): assert count_paths(2, 2) == 2 def test_count_paths_3x7(): assert count_paths(3, 7) == 28 def test_count_paths_1x1(): assert count_paths(1, 1) == 1 def test_count_paths_3x3(): assert count_paths(3, 3) == 6 def test_count_paths_5x5(): assert count_paths(5, 5) == 70 def test_count_paths_100x100(): assert count_paths(100, 100) == 22750883079422934966181954039568885395604168260154104734000 def test_count_paths_10x10(): assert count_paths(10, 10) == 48620","solution":"def count_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Create a 2D DP array and initialize with 0s dp = [[0] * n for _ in range(m)] # There is exactly one way to reach any cell in the first row and first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Compute the number of ways for the rest of the cells for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def generate_fibonacci(n: int) -> List[int]: Generate the first \`n\` numbers in the Fibonacci sequence. >>> generate_fibonacci(0) == [] >>> generate_fibonacci(1) == [0] >>> generate_fibonacci(2) == [0, 1] >>> generate_fibonacci(6) == [0, 1, 1, 2, 3, 5] >>> generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def generate_fibonacci(n): Generate the first \`n\` numbers in the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] while len(fib_sequence) < n: next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"def longest_subsequence(N: int, K: int, A: List[int]) -> int: Returns the length of the longest subsequence such that the difference between any two consecutive elements is exactly K. >>> longest_subsequence(7, 2, [4, 6, 8, 3, 5, 7, 9]) 4 >>> longest_subsequence(5, 1, [1, 2, 3, 4, 5]) 5 >>> longest_subsequence(5, 10, [1, 2, 3, 4, 5]) 1 >>> longest_subsequence(1, 0, [42]) 1 >>> longest_subsequence(6, 1000000000, [1000000000, 2000000000, 3000000000, -1000000000, 0, 1000000000]) 3 >>> longest_subsequence(6, -2, [4, 2, 0, -2, -4]) 5 >>> longest_subsequence(5, 2, [-10, -8, -6, -4, -2]) 5","solution":"def longest_subsequence(N, K, A): Returns the length of the longest subsequence such that the difference between any two consecutive elements is exactly K. from collections import defaultdict # Dict to store the length of subsequence ending at value dp = defaultdict(int) for value in A: dp[value] = dp[value - K] + 1 return max(dp.values())"},{"question":"def num_regions_of_lights(test_cases): Determine the number of distinct regions of connected intersections with traffic lights. Args: test_cases: List of tuples. Each tuple contains the dimensions and the grid of intersections from a test case. Returns: List of integers representing the number of distinct regions for each test case. Example: >>> num_regions_of_lights([((2, 2), ['YY', 'NY'])]) [1] >>> num_regions_of_lights([((3, 3), ['YNY', 'NYN', 'YNY'])]) [5] >>> num_regions_of_lights([((4, 3), ['YYY', 'YNY', 'NYN', 'YYY'])]) [2] ''' Unit Test Cases: from solution import num_regions_of_lights def test_single_region(): test_cases = [ ((2, 2), ['YY', 'NY']) ] assert num_regions_of_lights(test_cases) == [1] def test_disconnected_regions(): test_cases = [ ((3, 3), ['YNY', 'NYN', 'YNY']) ] assert num_regions_of_lights(test_cases) == [5] def test_multiple_regions(): test_cases = [ ((4, 3), ['YYY', 'YNY', 'NYN', 'YYY']) ] assert num_regions_of_lights(test_cases) == [2] def test_mixed_cases(): test_cases = [ ((2, 2), ['YY', 'NY']), ((3, 3), ['YNY', 'NYN', 'YNY']), ((4, 3), ['YYY', 'YNY', 'NYN', 'YYY']) ] assert num_regions_of_lights(test_cases) == [1, 5, 2] '''","solution":"def num_regions_of_lights(test_cases): def dfs(grid, visited, i, j, N, M): if i < 0 or i >= N or j < 0 or j >= M or visited[i][j] or grid[i][j] == 'N': return visited[i][j] = True dfs(grid, visited, i+1, j, N, M) dfs(grid, visited, i-1, j, N, M) dfs(grid, visited, i, j+1, N, M) dfs(grid, visited, i, j-1, N, M) results = [] for case in test_cases: N, M = case[0] grid = case[1] visited = [[False for _ in range(M)] for _ in range(N)] count = 0 for i in range(N): for j in range(M): if grid[i][j] == 'Y' and not visited[i][j]: dfs(grid, visited, i, j, N, M) count += 1 results.append(count) return results"},{"question":"def sort_and_remove_duplicates(s: str) -> str: Remove duplicate characters from the input string and return a sorted string with unique characters. >>> sort_and_remove_duplicates(\\"abcd\\") == \\"abcd\\" >>> sort_and_remove_duplicates(\\"aabbccdd\\") == \\"abcd\\" >>> sort_and_remove_duplicates(\\"aAbBcCdD\\") == \\"ABCDabcd\\" >>> sort_and_remove_duplicates(\\"dcba\\") == \\"abcd\\" >>> sort_and_remove_duplicates(\\"\\") == \\"\\" >>> sort_and_remove_duplicates(\\"a\\") == \\"a\\" >>> sort_and_remove_duplicates(\\"A\\") == \\"A\\" >>> sort_and_remove_duplicates(\\"aaaa\\") == \\"a\\" >>> sort_and_remove_duplicates(\\"BBBB\\") == \\"B\\" >>> sort_and_remove_duplicates(\\"a\\" * 1000 + \\"b\\" * 1000 + \\"c\\" * 1000) == \\"abc\\" >>> sort_and_remove_duplicates(\\"aa bb cc ddd eee @@@ !!!\\") == \\" !@abcde\\"","solution":"def sort_and_remove_duplicates(s): Removes duplicate characters from the input string and returns a sorted string with unique characters. return ''.join(sorted(set(s)))"},{"question":"from typing import List, Tuple def find_longest_even_odd_subarray(arr: List[int]) -> List[int]: Given a list of n integers, determine the longest contiguous subarray that has an equal number of even and odd integers. If there are multiple subarrays of the same length, return the one that starts at the smallest index. >>> find_longest_even_odd_subarray([1, 2, 3, 4, 5]) == [1, 2, 3, 4] >>> find_longest_even_odd_subarray([1, 2, 3, 4]) == [1, 2, 3, 4] pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Process multiple test cases to find the longest contiguous subarray with an equal number of even and odd integers. >>> process_test_cases([(5, [1, 2, 3, 4, 5]), (4, [1, 2, 3, 4])]) == [[1, 2, 3, 4], [1, 2, 3, 4]] pass","solution":"def find_longest_even_odd_subarray(arr): Returns the longest contiguous subarray with equal number of even and odd integers. n = len(arr) max_len = 0 start = 0 # Create a map to store the first occurrence of sums. prefix_sum = {0: -1} sum_ = 0 for i in range(n): # Check if the current element is even or odd if arr[i] % 2 == 0: sum_ += 1 else: sum_ -= 1 if sum_ in prefix_sum: if max_len < i - prefix_sum[sum_]: max_len = i - prefix_sum[sum_] start = prefix_sum[sum_] + 1 else: prefix_sum[sum_] = i return arr[start:start+max_len] def process_test_cases(test_cases): results = [] for n, arr in test_cases: result = find_longest_even_odd_subarray(arr) results.append(result) return results"},{"question":"def count_alpha_numeric(s: str) -> dict: Counts the number of alphanumeric characters in the string and returns the count as a dictionary with keys \\"letters\\" and \\"digits\\". >>> count_alpha_numeric(\\"Hello World 123!\\") == {'letters': 10, 'digits': 3} >>> count_alpha_numeric(\\"A1b2 C3!\\") == {'letters': 3, 'digits': 3} >>> count_alpha_numeric(\\"!@#%^&*()\\") == {'letters': 0, 'digits': 0}","solution":"def count_alpha_numeric(s): Counts the number of alphanumeric characters in the string. Returns a dictionary with counts of letters and digits. Parameters: s (str): Input string Returns: dict: Dictionary with keys 'letters' and 'digits' counts = {\\"letters\\": 0, \\"digits\\": 0} for char in s: if char.isalpha(): counts[\\"letters\\"] += 1 elif char.isdigit(): counts[\\"digits\\"] += 1 return counts"},{"question":"class SumRange: def __init__(self, arr): Initializes the SumRange object with the given array. Precomputes the prefix sums to allow efficient range sum calculations. :param arr: List[int] pass # implement the initialization def sumRange(self, start, end): Returns the sum of elements between indices start and end inclusive. Utilizes prefix sums for efficient calculation. :param start: int :param end: int :return: int pass # implement the sumRange function # Unit Tests def test_sumRange_example_cases(): sr = SumRange([1, 2, 3, 4, 5]) assert sr.sumRange(0, 2) == 6 # returns 6 (1 + 2 + 3) assert sr.sumRange(2, 4) == 12 # returns 12 (3 + 4 + 5) def test_sumRange_single_element(): sr = SumRange([1, 2, 3, 4, 5]) assert sr.sumRange(1, 1) == 2 # returns 2 def test_sumRange_entire_array(): sr = SumRange([1, 2, 3, 4, 5]) assert sr.sumRange(0, 4) == 15 # returns 15 (1 + 2 + 3 + 4 + 5) def test_sumRange_same_elements(): sr = SumRange([2, 2, 2, 2, 2]) assert sr.sumRange(0, 4) == 10 # returns 10 (2 + 2 + 2 + 2 + 2) assert sr.sumRange(1, 3) == 6 # returns 6 (2 + 2 + 2) def test_sumRange_negative_elements(): sr = SumRange([-1, -2, -3, -4, -5]) assert sr.sumRange(0, 2) == -6 # returns -6 (-1 + -2 + -3) assert sr.sumRange(2, 4) == -12 # returns -12 (-3 + -4 + -5)","solution":"class SumRange: def __init__(self, arr): Initializes the SumRange object with the given array. Precomputes the prefix sums to allow efficient range sum calculations. :param arr: List[int] self.prefix_sums = [0] * (len(arr) + 1) for i in range(len(arr)): self.prefix_sums[i + 1] = self.prefix_sums[i] + arr[i] def sumRange(self, start, end): Returns the sum of elements between indices start and end inclusive. Utilizes prefix sums for efficient calculation. :param start: int :param end: int :return: int return self.prefix_sums[end + 1] - self.prefix_sums[start]"},{"question":"from typing import List def count_subsets(nums: List[int], target: int) -> int: Returns the number of subsets of nums that sum up to target. >>> count_subsets([1, 2, 3, 4, 5], 5) == 3 >>> count_subsets([2, 3, 5, 6, 8, 10], 10) == 3 >>> count_subsets([1, 1, 1, 1], 1) == 4 >>> count_subsets([], 0) == 1 >>> count_subsets([5], 5) == 1","solution":"from functools import lru_cache def count_subsets(nums, target): Returns the number of subsets of nums that sum up to target. n = len(nums) # Use lru_cache to cache results for optimization @lru_cache(None) def count(i, remaining): if remaining == 0: return 1 if i == n or remaining < 0: return 0 # Include the current number in the subset or don't include it return count(i + 1, remaining - nums[i]) + count(i + 1, remaining) return count(0, target)"},{"question":"# Define the Book class class Book: def __init__(self, title, author, pages): self.title = title self.author = author self.pages = pages def __str__(self): return f\\"{self.title} by {self.author}, {self.pages} pages\\" # Define the BookCollection class class BookCollection: def __init__(self): self.books = [] def add_book(self, book): Adds a new book to the collection. >>> collection = BookCollection() >>> book = Book(\\"1984\\", \\"George Orwell\\", 328) >>> collection.add_book(book) >>> len(collection.books) 1 pass def remove_book(self, title): Removes a book from the collection by its title. Returns True if the book was found and removed, False otherwise. >>> collection = BookCollection() >>> book = Book(\\"1984\\", \\"George Orwell\\", 328) >>> collection.add_book(book) >>> result = collection.remove_book(\\"1984\\") >>> result True >>> len(collection.books) 0 >>> result = collection.remove_book(\\"Non-existent Book\\") >>> result False pass def search_by_author(self, author): Returns a list of books by the specified author. >>> collection = BookCollection() >>> book1 = Book(\\"1984\\", \\"George Orwell\\", 328) >>> book2 = Book(\\"Animal Farm\\", \\"George Orwell\\", 112) >>> collection.add_book(book1) >>> collection.add_book(book2) >>> books_by_orwell = collection.search_by_author(\\"George Orwell\\") >>> len(books_by_orwell) 2 >>> books_by_orwell[0] '1984 by George Orwell, 328 pages' >>> books_by_orwell[1] 'Animal Farm by George Orwell, 112 pages' >>> books_by_non_existent_author = collection.search_by_author(\\"NonExistent Author\\") >>> len(books_by_non_existent_author) 0 pass def sort_by_pages(self): Returns a list of books sorted by the number of pages in ascending order. >>> collection = BookCollection() >>> book1 = Book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 214) >>> book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 281) >>> book3 = Book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 180) >>> book4 = Book(\\"1984\\", \\"George Orwell\\", 328) >>> collection.add_book(book1) >>> collection.add_book(book2) >>> collection.add_book(book3) >>> collection.add_book(book4) >>> sorted_books = collection.sort_by_pages() >>> len(sorted_books) 4 >>> sorted_books[0].title 'The Great Gatsby' >>> sorted_books[1].title 'The Catcher in the Rye' >>> sorted_books[2].title 'To Kill a Mockingbird' >>> sorted_books[3].title '1984' pass","solution":"# Define the Book class class Book: def __init__(self, title, author, pages): self.title = title self.author = author self.pages = pages def __str__(self): return f\\"{self.title} by {self.author}, {self.pages} pages\\" # Define the BookCollection class class BookCollection: def __init__(self): self.books = [] def add_book(self, book): self.books.append(book) def remove_book(self, title): for book in self.books: if book.title == title: self.books.remove(book) return True return False def search_by_author(self, author): return [str(book) for book in self.books if book.author == author] def sort_by_pages(self): return sorted(self.books, key=lambda book: book.pages)"},{"question":"def optimized_sort(items: List[int]) -> List[int]: Returns the list of items sorted such that the smallest is first, followed by the largest remaining, then the second-smallest, then the second-largest, and so on. >>> optimized_sort([1, 3, 2, 4, 5]) == [1, 5, 2, 4, 3] >>> optimized_sort([10, 20, 30, 40, 50, 60]) == [10, 60, 20, 50, 30, 40] >>> optimized_sort([3, 1, 4, 2]) == [1, 4, 2, 3]","solution":"def optimized_sort(items): Returns the list of items sorted such that the smallest is first, followed by the largest remaining, then the second-smallest, then the second-largest, and so on. items.sort() result = [] start, end = 0, len(items) - 1 while start <= end: if start == end: result.append(items[start]) else: result.append(items[start]) result.append(items[end]) start += 1 end -= 1 return result"},{"question":"def rgbToHex(r: int, g: int, b: int) -> str: Converts RGB values to a hexadecimal string. Args: r (int): Red component (0-255) g (int): Green component (0-255) b (int): Blue component (0-255) Returns: str: Hexadecimal string in the format \\"#RRGGBB\\" >>> rgbToHex(255, 99, 71) '#FF6347' >>> rgbToHex(0, 255, 0) '#00FF00' >>> rgbToHex(75, 0, 130) '#4B0082'","solution":"def rgbToHex(r, g, b): Converts RGB values to a hexadecimal string. Args: r (int): Red component (0-255) g (int): Green component (0-255) b (int): Blue component (0-255) Returns: str: Hexadecimal string in the format \\"#RRGGBB\\" return f\\"#{r:02X}{g:02X}{b:02X}\\""},{"question":"from collections import defaultdict from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_frequent_tree_sum(root: TreeNode) -> List[int]: Given a binary tree, find the most frequent subtree sum(s). A subtree sum is the sum of all the node values in a subtree. If there is a tie in frequency, return all the subtree sums with the highest frequency in any order. >>> # Example tree: 5 >>> # / >>> # 2 -3 >>> # Subtree sums: [5, 2, -3, 4] >>> # Output: [2, 4, -3] or any order >>> root = TreeNode(5) >>> root.left = TreeNode(2) >>> root.right = TreeNode(-3) >>> find_frequent_tree_sum(root) [2, 4, -3] >>> # Example tree: 5 >>> # / >>> # 2 -5 >>> # Subtree sums: [5, 2, -5, 2] >>> # Output: [2] >>> root = TreeNode(5) >>> root.left = TreeNode(2) >>> root.right = TreeNode(-5) >>> find_frequent_tree_sum(root) [2]","solution":"from collections import defaultdict from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_frequent_tree_sum(root: TreeNode) -> List[int]: if not root: return [] sum_count = defaultdict(int) def dfs(node): if not node: return 0 left_sum = dfs(node.left) right_sum = dfs(node.right) subtree_sum = node.val + left_sum + right_sum sum_count[subtree_sum] += 1 return subtree_sum dfs(root) max_frequency = max(sum_count.values()) return [s for s in sum_count if sum_count[s] == max_frequency]"},{"question":"def max_product(lst): Write a function that finds the maximum product of two integers in a given list of integers. Example: >>> max_product([10, 3, 5, 6, 2]) 60 >>> max_product([1, -4, 3, -6, 7, 0]) 24","solution":"def max_product(lst): max_prod = float('-inf') n = len(lst) for i in range(n): for j in range(i + 1, n): # Start j from i+1 to avoid using the same index twice max_prod = max(max_prod, lst[i] * lst[j]) return max_prod"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, finds the length of the longest substring without repeating characters. :param s: An input string :return: The length of the longest substring with non-repeating characters Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcabcabc\\") 3","solution":"def length_of_longest_substring(s: str) -> int: Given a string s, finds the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"def maxPairProduct(arr): Given an array of integers, find the product of the maximum pair (i.e., two different elements) in the array. The array will contain at least two integers, and each integer is greater than or equal to 1. >>> maxPairProduct([3, 5, 2, 6]) 30 >>> maxPairProduct([10, 2, 3]) 30 >>> maxPairProduct([1, 1, 1, 10, 10]) 100","solution":"def maxPairProduct(arr): Returns the product of the maximum pair in the array. The array will contain at least two integers, and each integer is greater than or equal to 1. :param arr: List of integers :return: Product of the two largest integers in the array # Sort the array in descending order arr.sort(reverse=True) # The maximum pair will be the first two elements in the sorted array return arr[0] * arr[1]"},{"question":"def shortest_path(graph, start, end): Finds the shortest path in terms of number of edges between two nodes in an undirected graph. Parameters: graph (dict): Adjacency list representation of the graph. start (int): Starting node. end (int): Ending node. Returns: int: The number of edges in the shortest path from start to end. >>> shortest_path({0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 3], 3: [1, 2]}, 0, 3) 2 >>> shortest_path({0: [1], 1: [0, 2], 2: [1]}, 0, 2) 2 >>> shortest_path({0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3]}, 0, 4) 3 >>> shortest_path({0: [1], 1: [0, 2], 2: [1]}, 0, 0) 0 >>> shortest_path({0: [1], 1: [0], 2: [3], 3: [2]}, 0, 2) -1 >>> shortest_path({i: [i+1] for i in range(999)}, 0, 999) 999","solution":"from collections import deque def shortest_path(graph, start, end): Finds the shortest path in terms of number of edges between two nodes in an undirected graph. Parameters: graph (dict): Adjacency list representation of the graph. start (int): Starting node. end (int): Ending node. Returns: int: The number of edges in the shortest path from start to end. queue = deque([(start, 0)]) visited = set() while queue: node, distance = queue.popleft() if node == end: return distance if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append((neighbor, distance + 1)) return -1 # Example usage: # graph = {0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 3], 3: [1, 2]} # start = 0 # end = 3 # print(shortest_path(graph, start, end)) # Output: 2"},{"question":"from typing import List def find_peak(nums: List[int]) -> int: Given an input list of integers, return the index of any one of its peak elements. A peak element is an element that is greater than its neighbors. The function should have logarithmic complexity, i.e., O(log n). Examples: >>> find_peak([1, 2, 3, 1]) in [2] >>> find_peak([1, 2, 1, 3, 5, 6, 4]) in [1, 5] >>> find_peak([1]) == 0 >>> find_peak([3, 4, 3, 2, 1]) == 1 Args: nums (List[int]): A list of integers Returns: int: The index of a peak element","solution":"def find_peak(nums): Finds the index of any peak element in the list of integers. A peak element is an element that is greater than its neighbors. Args: nums (List[int]): A list of integers Returns: int: The index of a peak element def binary_search(low, high): if low == high: return low mid = (low + high) // 2 if nums[mid] > nums[mid + 1]: return binary_search(low, mid) return binary_search(mid + 1, high) return binary_search(0, len(nums) - 1)"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that no two consecutive characters are the same. If it's not possible, returns an empty string. >>> rearrange_string(\\"aabb\\") not in [\\"\\", \\"aabb\\", \\"bbaa\\"] True >>> rearrange_string(\\"aaab\\") == \\"\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string such that no two consecutive characters are the same. If it's not possible, returns an empty string. :param s: The input string consisting of lowercase English letters. :return: Rearranged string or an empty string if not possible. # Count the frequency of each character counter = Counter(s) max_heap = [] # Create a max heap based on the frequency for char, freq in counter.items(): heapq.heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged_s = ''.join(result) # If the rearranged string length isn't same as the input length, return empty string if len(rearranged_s) != len(s): return \\"\\" return rearranged_s"},{"question":"def group_by_frequency(lst): Groups the integers by their frequency and prints them in ascending order based on frequency. Parameters: - lst: List of integers. Returns: - A dictionary where the keys represent the frequency of the numbers and the values are lists of numbers with that frequency, sorted in ascending order. Examples: >>> group_by_frequency([4, 5, 6, 5, 4, 3, 2, 1]) == {1: [1, 2, 3, 6], 2: [4, 5]} >>> group_by_frequency([9, 9, 8, 7, 8, 7, 8]) == {1: [], 2: [7, 9], 3: [8]} >>> group_by_frequency([1, 1, 1, 1]) == {1: [], 2: [], 3: [], 4: [1]} >>> group_by_frequency([5]) == {1: [5]} >>> group_by_frequency([]) == {} >>> group_by_frequency([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == {1: [1], 2: [2], 3: [3], 4: [4]} >>> group_by_frequency([-1, -1, -2, -2, -2, -3]) == {1: [-3], 2: [-1], 3: [-2]}","solution":"from collections import defaultdict def group_by_frequency(lst): Groups the integers by their frequency and prints them in ascending order based on frequency. Parameters: - lst: List of integers. Returns: - A dictionary where the keys represent the frequency of the numbers and the values are lists of numbers with that frequency, sorted in ascending order. # Count frequencies of each element freq_count = defaultdict(int) for num in lst: freq_count[num] += 1 # Create a dictionary to group numbers by their frequency grouped_freq = defaultdict(list) for num, freq in freq_count.items(): grouped_freq[freq].append(num) # Sort the lists of numbers in ascending order within each frequency for freq in grouped_freq: grouped_freq[freq].sort() # Determine the maximum frequency max_frequency = max(grouped_freq, default=0) # Ensure dictionary contains all frequencies from 1 to max_frequency result = {} for i in range(1, max_frequency + 1): result[i] = grouped_freq.get(i, []) return result"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the length of the shortest path from the top-left cell (0, 0) to the bottom-right cell (m-1, n-1) avoiding blocked cells. If there is no valid path, return -1. >>> shortest_path([ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) == 9 >>> shortest_path([ ... [0, 1], ... [1, 0] ... ]) == -1 pass def test_shortest_path_example_1(): grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert shortest_path(grid) == 9 def test_shortest_path_example_2(): grid = [ [0, 1], [1, 0] ] assert shortest_path(grid) == -1 def test_shortest_path_no_path(): grid = [ [0, 0, 1], [1, 0, 1], [1, 1, 0] ] assert shortest_path(grid) == -1 def test_shortest_path_single_row(): grid = [ [0, 0, 0, 0] ] assert shortest_path(grid) == 4 def test_shortest_path_single_column(): grid = [ [0], [0], [0], [0] ] assert shortest_path(grid) == 4 def test_shortest_path_start_blocked(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert shortest_path(grid) == -1 def test_shortest_path_end_blocked(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert shortest_path(grid) == -1 def test_shortest_path_small_grid(): grid = [ [0, 0], [0, 0] ] assert shortest_path(grid) == 3 def test_shortest_path_large_grid(): grid = [[0]*100 for _ in range(100)] assert shortest_path(grid) == 199","solution":"from collections import deque def shortest_path(grid): if grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"class FileSystem: A class to simulate a basic file system. Operations supported: - mkdir(path: str): Creates a directory at the given path. - addContentToFile(filePath: str, content: str): Appends content to a file at the given path. - ls(path: str) -> List[str]: Returns the list of files and directories in the given path in sorted order. Example: >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") >>> fs.ls(\\"/\\") # Output: [\\"a\\"] >>> fs.ls(\\"/a/b/c/d\\") # Output: [\\"d\\"] >>> fs.ls(\\"/a/b/c\\") # Output: [\\"d\\"] >>> fs.addContentToFile(\\"/a/b/c/d\\", \\" world\\") >>> fs.ls(\\"/a/b/c/d\\") # Output: [\\"d\\"] def __init__(self): pass def mkdir(self, path: str): pass def addContentToFile(self, filePath: str, content: str): pass def ls(self, path: str) -> List[str]: pass from typing import List def test_mkdir_and_ls(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") assert fs.ls(\\"/\\") == [\\"a\\"] assert fs.ls(\\"/a\\") == [\\"b\\"] assert fs.ls(\\"/a/b\\") == [\\"c\\"] assert fs.ls(\\"/a/b/c\\") == [] def test_ls_empty_root(): fs = FileSystem() assert fs.ls(\\"/\\") == [] def test_addContentToFile_and_ls(): fs = FileSystem() fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") assert fs.ls(\\"/\\") == [\\"a\\"] assert fs.ls(\\"/a/b/c/d\\") == [\\"d\\"] assert fs.ls(\\"/a/b/c\\") == [\\"d\\"] def test_appendContentToFile(): fs = FileSystem() fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") fs.addContentToFile(\\"/a/b/c/d\\", \\" world\\") assert fs.ls(\\"/a/b/c/d\\") == [\\"d\\"] # To check content we need to access internal data FS for validation node = fs.fs['/'] for dir in \\"a/b/c/d\\".split('/'): node = node[dir] assert node == \\"hello world\\" def test_ls_with_file_as_path(): fs = FileSystem() fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") assert fs.ls(\\"/a/b/c/d\\") == [\\"d\\"] assert fs.ls(\\"/a/b/c\\") == [\\"d\\"] assert fs.ls(\\"/a/b\\") == ['c'] assert fs.ls(\\"/a\\") == ['b']","solution":"class FileSystem: def __init__(self): self.fs = {'/': {}} def mkdir(self, path: str): node = self.fs['/'] subdirs = filter(bool, path.split('/')) for dir in subdirs: if dir not in node: node[dir] = {} node = node[dir] def addContentToFile(self, filePath: str, content: str): dirs = filePath.split('/') node = self.fs['/'] file = dirs.pop() for dir in filter(bool, dirs): if dir not in node: node[dir] = {} node = node[dir] if file not in node: node[file] = \\"\\" node[file] += content def ls(self, path: str): node = self.fs['/'] if path != '/': dirs = filter(bool, path.split('/')) for dir in dirs: node = node[dir] if isinstance(node, dict): return sorted(node.keys()) return [path.split('/')[-1]]"},{"question":"def is_prime(num: int) -> bool: Check if a given number is a prime number. >>> is_prime(2) True >>> is_prime(10) False >>> is_prime(11) True def nearest_prime(n: int) -> int: Finds the nearest prime number to the given number n. >>> nearest_prime(10) 11 >>> nearest_prime(15) 13 >>> nearest_prime(20) 19 def nearestPrimes(arr: List[int]) -> List[int]: Given an array of numbers, replaces each number with the nearest prime number. If a number is equidistant to two prime numbers, the smaller prime is chosen. >>> nearestPrimes([10, 15, 20, 23]) [11, 13, 19, 23] >>> nearestPrimes([3, 4, 8, 32]) [3, 3, 7, 31] >>> nearestPrimes([2, 5, 18, 19]) [2, 5, 17, 19]","solution":"def is_prime(num): Check if a given number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def nearest_prime(n): Finds the nearest prime number to the given number n. if is_prime(n): return n offset = 0 while True: offset += 1 if is_prime(n - offset): return n - offset if is_prime(n + offset): return n + offset def nearestPrimes(arr): Given an array of numbers, replaces each number with the nearest prime number. If a number is equidistant to two prime numbers, the smaller prime is chosen. return [nearest_prime(x) for x in arr]"},{"question":"def find_most_frequent(lst): Returns the integer that appears most frequently in the list. If there are multiple numbers with the same highest frequency, returns the smallest number among them. from solution import find_most_frequent def test_single_most_frequent(): assert find_most_frequent([7, 8, 8, 9, 7, 7]) == 7 def test_multiple_most_frequent(): assert find_most_frequent([1, 3, 2, 2, 4, 3, 5]) == 2 def test_ties_with_smallest(): assert find_most_frequent([5, 5, 4, 6, 1, 1]) == 1 def test_single_element_list(): assert find_most_frequent([10]) == 10 def test_all_elements_unique(): assert find_most_frequent([1, 2, 3, 4, 5]) == 1 def test_all_elements_same(): assert find_most_frequent([3, 3, 3, 3]) == 3 def test_large_numbers(): assert find_most_frequent([1000000, 999999, 1000000, 999999, 999999]) == 999999","solution":"def find_most_frequent(lst): Returns the integer that appears most frequently in the list. If there are multiple numbers with the same highest frequency, returns the smallest number among them. from collections import Counter # Count the frequency of each number count = Counter(lst) # Find the maximum frequency max_freq = max(count.values()) # Filter numbers that have the maximum frequency most_frequent_nums = [num for num, freq in count.items() if freq == max_freq] # Return the smallest number among them return min(most_frequent_nums)"},{"question":"def medicines_to_restock(test_cases): Returns the list of medicines that need restocking, sorted alphabetically. If all medicines are sufficiently stocked, returns \\"All medicines are sufficiently stocked\\". pass # Test cases def test_medicines_to_restock_case1(): test_cases = [ (4, [(\\"Paracetamol\\", 15), (\\"Ibuprofen\\", 8), (\\"Aspirin\\", 5), (\\"Amoxicillin\\", 22)]), (3, [(\\"Cetirizine\\", 5), (\\"Atorvastatin\\", 30), (\\"Metformin\\", 0)]), ] assert medicines_to_restock(test_cases) == [\\"Aspirin\\", \\"Ibuprofen\\", \\"Cetirizine\\", \\"Metformin\\"] def test_medicines_to_restock_all_sufficient(): test_cases = [ (2, [(\\"MedicineA\\", 25), (\\"MedicineB\\", 50)]), ] assert medicines_to_restock(test_cases) == [\\"All medicines are sufficiently stocked\\"] def test_medicines_to_restock_mixed(): test_cases = [ (3, [(\\"Med1\\", 9), (\\"Med2\\", 11), (\\"Med3\\", 12)]), ] assert medicines_to_restock(test_cases) == [\\"Med1\\"] def test_medicines_to_restock_none(): test_cases = [ (1, [(\\"Med1\\", 11)]), ] assert medicines_to_restock(test_cases) == [\\"All medicines are sufficiently stocked\\"] def test_medicines_to_restock_multiple(): test_cases = [ (4, [(\\"A\\", 10), (\\"C\\", 20), (\\"B\\", 5), (\\"D\\", 25)]), (3, [(\\"X\\", 1), (\\"Y\\", 12), (\\"Z\\", 8)]), ] assert medicines_to_restock(test_cases) == [\\"A\\", \\"B\\", \\"X\\", \\"Z\\"]","solution":"def medicines_to_restock(test_cases): Returns the list of medicines that need restocking, sorted alphabetically. If all medicines are sufficiently stocked, returns \\"All medicines are sufficiently stocked\\". result = [] for case in test_cases: N, medicines = case restock_list = [name for (name, qty) in medicines if qty <= 10] if restock_list: restock_list.sort() result.extend(restock_list) else: result.append(\\"All medicines are sufficiently stocked\\") return result"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Given an array of integers, identify the number of subarrays (contiguous elements) that have a sum equal to a given target value. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1, 2, 3], 7) 0 >>> subarray_sum([3], 3) 1 >>> subarray_sum([-1, -1, 1], 0) 1 >>> subarray_sum([1, 2, 1, 2, 1], 3) 4 >>> subarray_sum([1000] * 10000, 1000) 10000","solution":"def subarray_sum(nums, k): This function returns the number of subarrays having a sum equal to k. count = 0 curr_sum = 0 sum_map = {0: 1} # To handle the case when subarray starts from index 0 for num in nums: curr_sum += num if (curr_sum - k) in sum_map: count += sum_map[curr_sum - k] if curr_sum in sum_map: sum_map[curr_sum] += 1 else: sum_map[curr_sum] = 1 return count"},{"question":"def flatten_dict(nested_dict, parent_key='', sep='.'): Flatten a nested dictionary. :param nested_dict: The dictionary to flatten. :param parent_key: The base key string for nested keys (used in recursion). :param sep: Separator between keys. :return: A flattened dictionary. >>> nested_dict = { ... 'a': { ... 'b': 1, ... 'c': { ... 'd': 2, ... 'e': 3 ... } ... }, ... 'f': { ... 'g': 4 ... } ... } >>> flatten_dict(nested_dict) {'a.b': 1, 'a.c.d': 2, 'a.c.e': 3, 'f.g': 4} >>> flatten_dict({}) {} >>> flatten_dict({'a': 1, 'b': 2}) {'a': 1, 'b': 2} >>> flatten_dict({'a': {'b': 1}, 'c': {'d': 2}}) {'a.b': 1, 'c.d': 2} >>> flatten_dict({'a': {'b': {'c': {'d': 1, 'e': 2}}}}) {'a.b.c.d': 1, 'a.b.c.e': 2} >>> flatten_dict({'a': {'b': 1, 'c': {'d': 2, 'e': 3}}, 'f': {'g': 4}}, sep='|') {'a|b': 1, 'a|c|d': 2, 'a|c|e': 3, 'f|g': 4}","solution":"def flatten_dict(nested_dict, parent_key='', sep='.'): Flatten a nested dictionary. :param nested_dict: The dictionary to flatten. :param parent_key: The base key string for nested keys (used in recursion). :param sep: Separator between keys. :return: A flattened dictionary. items = [] for k, v in nested_dict.items(): new_key = parent_key + sep + k if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"class ArrayManager: def __init__(self, array): self.array = array def update(self, x, y): self.array[x - 1] = y def sum_subarray(self, l, r): return sum(self.array[l - 1:r]) def process_queries(N, Q, array, queries): Processes a list of queries on the array as described. Args: N (int): Length of the array. Q (int): Number of queries. array (List[int]): The initial array. queries (List[str]): The queries to process. Returns: List[int]: Results of the sum queries. >>> N = 5 >>> Q = 5 >>> array = [1, 2, 3, 4, 5] >>> queries = [ ... \\"2 1 3\\", ... \\"1 3 10\\", ... \\"2 1 3\\", ... \\"2 3 5\\", ... \\"1 5 2\\" ... ] >>> process_queries(N, Q, array, queries) [6, 13, 19] # Implement the function as per the instructions","solution":"class ArrayManager: def __init__(self, array): self.array = array def update(self, x, y): self.array[x - 1] = y def sum_subarray(self, l, r): return sum(self.array[l - 1:r]) def process_queries(N, Q, array, queries): manager = ArrayManager(array) results = [] for query in queries: parts = query.split() query_type = int(parts[0]) if query_type == 1: x = int(parts[1]) y = int(parts[2]) manager.update(x, y) elif query_type == 2: l = int(parts[1]) r = int(parts[2]) results.append(manager.sum_subarray(l, r)) return results"},{"question":"def sort_boxes(test_cases): Sort the weights of boxes in ascending order for each test case. >>> sort_boxes([(5, [4, 2, 9, 1, 3]), (4, [10, 20, 5, 15])]) [\\"1 2 3 4 9\\", \\"5 10 15 20\\"] Returns: List[str]: A list of space-separated sorted weights for each test case. results = [] for N, weights in test_cases: sorted_weights = sorted(weights) results.append(\\" \\".join(map(str, sorted_weights))) return results def main(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) weights = list(map(int, lines[index + 1].split())) test_cases.append((N, weights)) index += 2 return sort_boxes(test_cases)","solution":"def sort_boxes(test_cases): results = [] for N, weights in test_cases: sorted_weights = sorted(weights) results.append(\\" \\".join(map(str, sorted_weights))) return results def main(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) weights = list(map(int, lines[index + 1].split())) test_cases.append((N, weights)) index += 2 return sort_boxes(test_cases)"},{"question":"def ascii_hex(s: str) -> str: Returns a new string where each character in the original string is replaced by a pair of its hexadecimal ASCII code and the character itself, separated by a hyphen. >>> ascii_hex(\\"Hello\\") \\"48-H65-e6C-l6C-l6F-o\\" >>> ascii_hex(\\"Code Wars\\") \\"43-C6F-o64-d65-e57-W61-a72-r73-s\\" >>> ascii_hex(\\"CODE\\") \\"43-C4F-O44-D45-E\\" >>> ascii_hex(\\"code\\") \\"63-c6F-o64-d65-e\\" >>> ascii_hex(\\"cOdE\\") \\"63-c4F-O64-d45-E\\" >>> ascii_hex(\\"ntCode\\") \\"43-C6F-o64-d65-e\\" >>> ascii_hex(\\"\\") \\"\\" >>> ascii_hex(\\"@!#\\") \\"40-@21-!23-#\\" >>> ascii_hex(\\"123\\") \\"31-132-233-3\\" >>> ascii_hex(\\"A~\\") \\"41-A7E-~\\"","solution":"def ascii_hex(s): Returns a new string where each character in the original string is replaced by a pair of its hexadecimal ASCII code and the character itself, separated by a hyphen. result = [] for char in s: ascii_code = ord(char) # Confirming if the character is printable and not a space if 32 <= ascii_code <= 126 and char != ' ': hex_code = format(ascii_code, 'x').upper() result.append(f\\"{hex_code}-{char}\\") return \\"\\".join(result)"},{"question":"def highest_grade_students(s: str) -> str: Takes a string representing a list of student names and grades in the format \\"name1:grade1,name2:grade2,...,nameN:gradeN\\", and returns the name(s) of the student(s) with the highest grade. If multiple students have the highest grade, their names are returned as a comma-separated string, in the order they appear in the input. >>> highest_grade_students(\\"John:88\\") 'John' >>> highest_grade_students(\\"John:88,Susan:92,Alex:90\\") 'Susan' >>> highest_grade_students(\\"Ron:85,Hermione:100,Harry:100\\") 'Hermione,Harry' >>> highest_grade_students(\\"Dan:75,Amy:90,Leo:85,Mike:80\\") 'Amy' >>> highest_grade_students(\\"Dan:75,Amy:90,Leo:90,Mike:85\\") 'Amy,Leo' >>> highest_grade_students(\\"John:90,Susan:90,Alex:90\\") 'John,Susan,Alex' >>> highest_grade_students(\\"Leo:90,Amy:90,Dan:90\\") 'Leo,Amy,Dan' >>> highest_grade_students(\\"John:100,Amy:100\\") 'John,Amy' >>> highest_grade_students(\\"Amy:0,Leo:0\\") 'Amy,Leo'","solution":"def highest_grade_students(s): Takes a string representing a list of student names and grades in the format \\"name1:grade1,name2:grade2,...,nameN:gradeN\\", and returns the name(s) of the student(s) with the highest grade. If multiple students have the highest grade, their names are returned as a comma-separated string, in the order they appear in the input. students = s.split(',') highest_grade = -1 highest_grade_students = [] for student in students: name, grade = student.split(':') grade = int(grade) if grade > highest_grade: highest_grade = grade highest_grade_students = [name] elif grade == highest_grade: highest_grade_students.append(name) return ','.join(highest_grade_students)"},{"question":"def evaluate(expression: str) -> int: Evaluates an arithmetic expression given as a string and returns the result as an integer. The expression may contain non-negative integers, and the operators +, -, *, /. The expression may include spaces which should be ignored. The operator precedence should be correctly handled according to standard arithmetic rules. >>> evaluate(\\"3 + 2\\") 5 >>> evaluate(\\"4 - 5 + 2\\") 1 >>> evaluate(\\"10 + 2 * 6\\") 22 >>> evaluate(\\"100 * 2 + 12\\") 212 >>> evaluate(\\"100 * ( 2 + 12 )\\") 1400 >>> evaluate(\\"100 * ( 2 + 12 ) / 14\\") 100","solution":"def evaluate(expression): Evaluates an arithmetic expression given as a string and returns the result as an integer. The expression may contain non-negative integers, and the operators +, -, *, /. def apply_operator(operands, operators): right = operands.pop() left = operands.pop() operator = operators.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(left // right) def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def calculate(expression): i = 0 n = len(expression) operands = [] operators = [] while i < n: if expression[i] == ' ': i += 1 continue if expression[i] >= '0' and expression[i] <= '9': val = 0 while (i < n and expression[i] >= '0' and expression[i] <= '9'): val = (val * 10) + int(expression[i]) i += 1 operands.append(val) i -= 1 elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while len(operators) != 0 and operators[-1] != '(': apply_operator(operands, operators) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operands, operators) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operands, operators) return operands[-1] return calculate(expression)"},{"question":"from typing import List def count_ones_in_hex_to_binary(hex_strings: List[str]) -> List[int]: Convert hexadecimal strings to their binary equivalents and count the number of '1' bits. Args: hex_strings (List[str]): List of hexadecimal strings. Returns: List[int]: List containing the number of '1' bits in the binary representation of each hexadecimal string. >>> count_ones_in_hex_to_binary(['1a', '2f', '3b']) [3, 5, 5] >>> count_ones_in_hex_to_binary(['0', '00', '000']) [0, 0, 0] >>> count_ones_in_hex_to_binary(['f', 'ff', 'fff']) [4, 8, 12] pass # Unit Tests def test_single_case(): assert count_ones_in_hex_to_binary(['1a']) == [3] def test_multiple_cases(): assert count_ones_in_hex_to_binary(['1a', '2f', '3b']) == [3, 5, 5] def test_all_zeroes(): assert count_ones_in_hex_to_binary(['0', '00', '000']) == [0, 0, 0] def test_all_ones(): assert count_ones_in_hex_to_binary(['f', 'ff', 'fff']) == [4, 8, 12] def test_uppercase_hex(): assert count_ones_in_hex_to_binary(['1A', '2F', '3B']) == [3, 5, 5] def test_mixed_case_hex(): assert count_ones_in_hex_to_binary(['1a', '2F', '3b']) == [3, 5, 5] def test_long_hex_string(): assert count_ones_in_hex_to_binary(['ffffffffffffffffffffffffffffffff']) == [128]","solution":"def count_ones_in_hex_to_binary(hex_strings): def hex_to_bin(hex_str): bin_str = bin(int(hex_str, 16))[2:] return bin_str.count('1') results = [hex_to_bin(hex_str) for hex_str in hex_strings] return results"},{"question":"def max_sum_subgrid(n, m, grid): Finds the maximum sum of any subgrid within the provided grid. Parameters: n (int): Number of rows m (int): Number of columns grid (list of list of ints): 2D array of integers representing the grid Returns: int: Maximum sum of any subgrid Examples: >>> max_sum_subgrid(3, 3, [ ... [1, 2, -1], ... [-3, 4, 2], ... [1, 5, -3] ... ]) == 11 >>> max_sum_subgrid(2, 2, [ ... [-1, -2], ... [-3, -4] ... ]) == -1","solution":"def max_sum_subgrid(n, m, grid): Finds the maximum sum of any subgrid within the provided grid. Parameters: n (int): Number of rows m (int): Number of columns grid (list of list of ints): 2D array of integers representing the grid Returns: int: Maximum sum of any subgrid max_sum = float('-inf') # Create the prefix sum matrix prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] # Explore all possible subgrids for r1 in range(1, n + 1): for r2 in range(r1, n + 1): for c1 in range(1, m + 1): for c2 in range(c1, m + 1): subgrid_sum = ( prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] ) max_sum = max(max_sum, subgrid_sum) return max_sum"},{"question":"def chef_loves_symmetry(T: int, test_cases: List[Tuple[int, int]]) -> List[str]: Given two numbers A and B, find the greatest common divisor (GCD) of all the integers between A and B inclusive that are palindromes. A number is called a palindrome if it reads the same backward as forward. >>> chef_loves_symmetry(1, [(10, 20)]) [\\"Case #1: 11\\"] >>> chef_loves_symmetry(1, [(5, 30)]) [\\"Case #1: 1\\"]","solution":"import math def is_palindrome(n): Check if a given number n is a palindrome. return str(n) == str(n)[0:][::-1] def find_palindromes(a, b): Find all palindromes in the range [a, b] inclusive. palindromes = [i for i in range(a, b + 1) if is_palindrome(i)] return palindromes def gcd_of_list(numbers): Return the GCD of a list of numbers. return math.gcd(*numbers) def gcd_of_palindromes_in_range(a, b): Calculate the GCD of all palindromes in the range [a, b]. palindromes = find_palindromes(a, b) if not palindromes: return 0 return gcd_of_list(palindromes) def chef_loves_symmetry(T, test_cases): Solve the problem for T test cases. results = [] for i in range(T): a, b = test_cases[i] gcd_result = gcd_of_palindromes_in_range(a, b) results.append(f\\"Case #{i + 1}: {gcd_result}\\") return results"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: Given a list of integers \`nums\` and a target integer \`target\`, return a tuple with two distinct numbers (in any order) from the list that add up to the target. If no such pair exists, return an empty tuple. >>> find_pair_with_sum([2, 7, 11, 15], 9) in [(2, 7), (7, 2)] True >>> find_pair_with_sum([3, 2, 4], 6) in [(2, 4), (4, 2)] True >>> find_pair_with_sum([3, 3], 6) (3, 3) >>> find_pair_with_sum([1, 2, 3], 7) () >>> find_pair_with_sum([], 5) ()","solution":"def find_pair_with_sum(nums, target): Given a list of integers \`nums\` and a target integer \`target\`, return a tuple with two distinct numbers (in any order) from the list that add up to the target. If no such pair exists, return an empty tuple. seen = {} for num in nums: complement = target - num if complement in seen: return (complement, num) seen[num] = True return ()"},{"question":"def most_frequent_character(s: str) -> str: Returns the character that appears the most frequently in the string \`s\`. If there are multiple characters with the same highest frequency, return the one that appears first in the string. >>> most_frequent_character(\\"a\\") == \\"a\\" >>> most_frequent_character(\\"aabbbcc\\") == \\"b\\" >>> most_frequent_character(\\"hello\\") == \\"l\\" >>> most_frequent_character(\\"abcccab\\") == \\"c\\" >>> most_frequent_character(\\"abababa\\") == \\"a\\" >>> most_frequent_character(\\"mnopqrstuv\\") == \\"m\\" >>> most_frequent_character(\\"aaaaaa\\") == \\"a\\" >>> most_frequent_character(\\"bbbbbbbbb\\") == \\"b\\" >>> most_frequent_character(\\"abcdefg\\") == \\"a\\"","solution":"def most_frequent_character(s): Returns the character that appears the most frequently in the string \`s\`. If there are multiple characters with the same highest frequency, return the one that appears first in the string. from collections import Counter frequency = Counter(s) max_count = max(frequency.values()) for char in s: if frequency[char] == max_count: return char"},{"question":"from typing import List, Tuple def canReachEnd(maze: List[List[int]], start: Tuple[int, int]) -> bool: Determines if there is a path from the starting cell to the bottom right cell using Depth-First Search (DFS). >>> canReachEnd([ [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0] ], (0, 0)) True >>> canReachEnd([ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 1], [1, 1, 1, 0] ], (0, 0)) False >>> canReachEnd([ [0, 0, 0], [1, 1, 0], [0, 0, 0] ], (0, 0)) True >>> canReachEnd([ [0, 1, 0], [1, 1, 0], [0, 0, 0] ], (0, 0)) False >>> canReachEnd([ [0, 0], [0, 0] ], (0, 0)) True pass","solution":"from typing import List, Tuple def canReachEnd(maze: List[List[int]], start: Tuple[int, int]) -> bool: rows = len(maze) cols = len(maze[0]) target = (rows - 1, cols - 1) def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 0 def dfs(x, y): if (x, y) == target: return True maze[x][y] = 1 # mark as visited to prevent cycles directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): if dfs(nx, ny): return True return False return dfs(*start)"},{"question":"def arithmetic_series_sum(a: int, d: int, n: int) -> int: Calcualtes the sum of the first \`n\` terms of an arithmetic series. >>> arithmetic_series_sum(1, 1, 5) 15 >>> arithmetic_series_sum(2, 3, 4) 26 >>> arithmetic_series_sum(10, 0, 3) 30","solution":"def arithmetic_series_sum(a: int, d: int, n: int) -> int: Calculates the sum of the first \`n\` terms of an arithmetic series. :param a: The first term of the series :param d: The common difference between consecutive terms :param n: The number of terms in the series :return: The sum of the first \`n\` terms if n <= 0: return 0 return n * (2 * a + (n - 1) * d) // 2"},{"question":"def zigzag_string(s: str, num_levels: int) -> str: Create a zigzag string representation of the input string s based on the given number of levels. Args: s (str): the input string num_levels (int): the number of levels for the zigzag pattern Returns: str: the zigzag patterned string Example: >>> zigzag_string(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> zigzag_string(\\"ABCDEFG\\", 4) \\"AGBFCED\\" pass","solution":"def zigzag_string(s: str, num_levels: int) -> str: if num_levels == 1 or num_levels >= len(s): return s # Create an array of strings for all levels rows = [''] * num_levels current_row = 0 going_down = False for char in s: # Append the current character to the respective row rows[current_row] += char # If we are at the top or bottom, we reverse the direction if current_row == 0 or current_row == num_levels - 1: going_down = not going_down # Move up or down current_row += 1 if going_down else -1 # Concatenate all rows' strings to get the final zigzag string return ''.join(rows)"},{"question":"class SessionAllocator: A class to allocate students to their preferred sessions according to defined capacities. >>> sa = SessionAllocator([2, 1, 3]) >>> sa.allocateStudent(1, [1, 2]) True >>> sa.allocateStudent(2, [0, 1]) True >>> sa.allocateStudent(3, [0]) True >>> sa.getSessionStudents(1) [1] >>> sa.getSessionStudents(0) [2, 3] def __init__(self, session_capacities): pass def allocateStudent(self, student_id, preferences): pass def getSessionStudents(self, session_id): pass","solution":"class SessionAllocator: def __init__(self, session_capacities): self.session_capacities = session_capacities self.sessions = {i: [] for i in range(len(session_capacities))} self.allocated_students = set() def allocateStudent(self, student_id, preferences): if student_id in self.allocated_students: return False for session_id in preferences: if len(self.sessions[session_id]) < self.session_capacities[session_id]: self.sessions[session_id].append(student_id) self.allocated_students.add(student_id) return True return False def getSessionStudents(self, session_id): return self.sessions[session_id]"},{"question":"def smallest_well_formed_number(n: int, b: int) -> int: Returns the smallest well-formed number in base \`b\` that is >= \`n\`. Examples: >>> smallest_well_formed_number(10, 2) 16 >>> smallest_well_formed_number(15, 3) 27 >>> smallest_well_formed_number(100, 10) 100 >>> smallest_well_formed_number(1, 5) 1","solution":"import math def smallest_well_formed_number(n, b): Returns the smallest well-formed number in base \`b\` that is >= \`n\`. if n <= 1: return 1 exponent = math.ceil(math.log(n, b)) return b ** exponent"},{"question":"def max_difference(arr): Finds the maximum difference between two elements such that the larger element appears after the smaller element. Args: arr (list of int): The input array of integers. Returns: int: The maximum difference, or -1 if no such pair exists. pass def solve(t, test_cases): Solve multiple test cases for finding the maximum difference. Args: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains the number of elements and the array of integers. Returns: list of int: The list of results for each test case. pass from solution import max_difference, solve def test_max_difference_general_case(): assert max_difference([7, 1, 5, 3, 6, 4]) == 5 def test_max_difference_single_element(): assert max_difference([1]) == -1 def test_max_difference_no_valid_pair(): assert max_difference([8, 9, 5, 6, 3]) == 1 def test_max_difference_all_decreasing(): assert max_difference([9, 7, 5, 3]) == -1 def test_max_difference_large_elements(): assert max_difference([1, 100000]) == 99999 def test_solve_multiple_cases(): assert solve(2, [(6, [7, 1, 5, 3, 6, 4]), (5, [8, 9, 5, 6, 3])]) == [5, 1] def test_solve_single_case(): assert solve(1, [(4, [1, 2, 3, 4])]) == [3] def test_solve_edge_case_no_elements(): assert solve(2, [(0, []), (1, [5])]) == [-1, -1]","solution":"def max_difference(arr): Finds the maximum difference between two elements such that the larger element appears after the smaller element. Parameters: arr (list of int): The input array of integers. Returns: int: The maximum difference, or -1 if no such pair exists. if not arr or len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) else: min_element = arr[i] return max_diff def solve(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(max_difference(arr)) return results"},{"question":"def find_pairs(nums: List[int]) -> List[Tuple[int, int]]: Write a function that takes a list of integers and returns a list of tuples, where each tuple contains two integers from the input list whose sum is zero. Each pair \`(a, b)\` must be unique in the sense that you cannot reuse the same elements from the input list for different pairs, and the order of pairs in the resulting list does not matter. >>> find_pairs([2, -2, 3, -3, -2, 2]) == [(2, -2), (3, -3)] >>> find_pairs([1, -1, 2, 3, -2, -3]) == [(1, -1), (2, -2), (3, -3)] >>> find_pairs([1, 2, 3, 4]) == [] >>> find_pairs([2, -2, 2, -2]) == [(2, -2)] >>> find_pairs([-1, 1, -1, -1, 1, 1]) == [(-1, 1)] >>> find_pairs([]) == [] pass","solution":"def find_pairs(nums): Returns a list of tuples (a, b) from the input list where a + b = 0. Each element in nums is used at most once. seen = set() pairs = [] nums_set = set(nums) for num in nums: if -num in nums_set and -num not in seen: pairs.append((num, -num)) seen.add(num) seen.add(-num) return pairs"},{"question":"def shortestBridge(grid: List[List[int]]) -> int: Find the shortest bridge between any two islands in a given grid by flipping 0's to 1's. Args: grid (List[List[int]]): The grid representing the map with '1's as land and '0's as water. Returns: int: The minimum number of '0's that need to be flipped to connect the two islands. Example: >>> shortestBridge([ [0, 1], [1, 0] ]) 1 >>> shortestBridge([ [0, 1, 0], [0, 0, 0], [0, 0, 1] ]) 2 >>> shortestBridge([ [1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1] ]) 1 from collections import deque def test_shortestBridge_example1(): grid = [ [0, 1], [1, 0] ] assert shortestBridge(grid) == 1 def test_shortestBridge_example2(): grid = [ [0, 1, 0], [0, 0, 0], [0, 0, 1] ] assert shortestBridge(grid) == 2 def test_shortestBridge_example3(): grid = [ [1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1] ] assert shortestBridge(grid) == 1 def test_shortestBridge_additional1(): grid = [ [1, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 1] ] assert shortestBridge(grid) == 2 def test_shortestBridge_additional2(): grid = [ [1, 0], [0, 1], [1, 0] ] assert shortestBridge(grid) == 1","solution":"from collections import deque def shortestBridge(grid): def dfs(x, y): island.append((x, y)) grid[x][y] = -1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: dfs(nx, ny) def bfs(): q = deque(island) distance = 0 while q: for _ in range(len(q)): x, y = q.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == 1: return distance if grid[nx][ny] == 0: grid[nx][ny] = -1 q.append((nx, ny)) distance += 1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] island = [] m, n = len(grid), len(grid[0]) # Find and mark the first island for i in range(m): for j in range(n): if grid[i][j] == 1: dfs(i, j) break if island: break return bfs()"},{"question":"def process_commands(commands): Process a given list of commands and return the total income and expenses. Args: commands (List[str]): A list of strings, each representing a command. Returns: Tuple[List[int], List[int]]: A tuple of two lists where each list corresponds to the income and expenses recorded at each \\"report\\" command. Example: >>> process_commands([ ... \\"income 200\\", ... \\"expense 50\\", ... \\"income 300\\", ... \\"report\\", ... \\"expense 20\\", ... \\"report\\", ... \\"expense 30\\" ... ]) ([500, 500], [50, 70])","solution":"def process_commands(commands): total_income = 0 total_expenses = 0 income_report = [] expenses_report = [] for command in commands: parts = command.split() action = parts[0] if action == \\"income\\": amount = int(parts[1]) total_income += amount elif action == \\"expense\\": amount = int(parts[1]) total_expenses += amount elif action == \\"report\\": income_report.append(total_income) expenses_report.append(total_expenses) return (income_report, expenses_report)"},{"question":"def sum_above_threshold(array: list[int], threshold: int) -> int: Returns the sum of all elements in the array that are greater than the given threshold. >>> sum_above_threshold([1, 5, 10, 3], 4) 15 >>> sum_above_threshold([1, 2, 3, 4], 4) 0 >>> sum_above_threshold([], 5) 0 from solution import sum_above_threshold def test_sum_above_threshold_with_mixed_elements(): array = [1, 5, 10, 3] threshold = 4 assert sum_above_threshold(array, threshold) == 15 def test_sum_above_threshold_with_no_elements_above_threshold(): array = [1, 2, 3, 4] threshold = 4 assert sum_above_threshold(array, threshold) == 0 def test_sum_above_threshold_with_all_elements_below_threshold(): array = [-1, -5, -10, -3] threshold = 0 assert sum_above_threshold(array, threshold) == 0 def test_sum_above_threshold_with_all_elements_above_threshold(): array = [10, 20, 30] threshold = 5 assert sum_above_threshold(array, threshold) == 60 def test_sum_above_threshold_with_mixed_sign_elements(): array = [-10, 20, -5, 30, 5] threshold = 0 assert sum_above_threshold(array, threshold) == 55 def test_sum_above_threshold_with_elements_equal_to_threshold(): array = [5, 10, 20, 5, 1] threshold = 5 assert sum_above_threshold(array, threshold) == 30 def test_sum_above_threshold_empty_array(): array = [] threshold = 5 assert sum_above_threshold(array, threshold) == 0","solution":"def sum_above_threshold(array, threshold): Returns the sum of all elements in the array that are greater than the given threshold. return sum(x for x in array if x > threshold)"},{"question":"def is_perfect_number(num: int) -> bool: Determines if a given positive integer is a perfect number. :param num: Positive integer to check :return: True if the number is perfect, False otherwise >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(12) False >>> is_perfect_number(3) False >>> is_perfect_number(99) False","solution":"def is_perfect_number(num): Determines if a given positive integer is a perfect number. :param num: Positive integer to check :return: True if the number is perfect, False otherwise if num <= 1: return False sum_of_divisors = 0 for i in range(1, num): if num % i == 0: sum_of_divisors += i return sum_of_divisors == num"},{"question":"def max_gatherings(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Determine the maximum number of unique gatherings that can be formed given the constraints. >>> max_gatherings(2, [(3, [3, 2, 1], 2), (5, [1, 4, 5, 2, 3], 3)]) [2, 2] >>> max_gatherings(1, [(4, [4, 4, 4, 4], 4)]) [4] >>> max_gatherings(1, [(3, [1, 1, 1], 2)]) [0] >>> max_gatherings(1, [(5, [5, 6, 7, 8, 9], 5)]) [5] >>> max_gatherings(1, [(5, [1, 2, 3, 4, 5], 1)]) [5] >>> max_gatherings(1, [(1, [2], 2)]) [1] >>> max_gatherings(1, [(6, [1, 6, 2, 5, 3, 4], 3)]) [4]","solution":"def max_gatherings(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] s = test_cases[i][1] E = test_cases[i][2] s.sort(reverse=True) count = 0 for j in range(N): if s[j] >= E: count += 1 results.append(count) return results"},{"question":"def replace_with_identifiers(s: str) -> str: This function takes a string consisting of lowercase letters and spaces, and replaces each word with a unique identifier based on its first occurrence and order in the list of unique words. Args: s (str): Input string containing words separated by spaces. Returns: str: Modified string with unique identifiers in place of the original words. Examples: >>> replace_with_identifiers(\\"hello world hello everyone\\") \\"1 2 1 3\\" >>> replace_with_identifiers(\\"the quick brown fox jumps over the lazy dog\\") \\"1 2 3 4 5 6 7 8 9\\" >>> replace_with_identifiers(\\"repeat repeat repeat\\") \\"1 1 1\\"","solution":"def replace_with_identifiers(s: str) -> str: This function takes a string consisting of lowercase letters and spaces, and replaces each word with a unique identifier based on its first occurrence and order in the list of unique words. Args: s (str): Input string containing words separated by spaces. Returns: str: Modified string with unique identifiers in place of the original words. words = s.split() word_to_id = {} next_id = 1 result = [] for word in words: if word not in word_to_id: word_to_id[word] = next_id next_id += 1 result.append(str(word_to_id[word])) return ' '.join(result)"},{"question":"def second_highest(numbers: List[int]) -> Optional[int]: Write a function \`second_highest\` that returns the second highest number from a list of integers. Return \`None\` if the list is empty or contains only one unique element. >>> second_highest([1, 2, 3, 4, 5]) 4 >>> second_highest([5, 5, 4, 4, 3]) 4 >>> second_highest([1]) None >>> second_highest([]) None","solution":"def second_highest(numbers): Returns the second highest number from a list of integers. Returns None if the list is empty or contains one unique element. if len(numbers) < 2: return None unique_numbers = set(numbers) if len(unique_numbers) < 2: return None unique_numbers.remove(max(unique_numbers)) return max(unique_numbers)"},{"question":"def can_remove_cubes(L, W, H, R): Determines if it is possible to remove exactly R cubes from a cuboid of dimensions L x W x H without disconnecting the remaining cubes. Parameters: L (int): Length of the cuboid W (int): Width of the cuboid H (int): Height of the cuboid R (int): Number of cubes to remove Returns: str: \\"YES\\" if it is possible to remove exactly R cubes without disconnecting the remaining cubes, otherwise \\"NO\\". def process_test_cases(test_cases): Processes multiple test cases to determine if it is possible to remove exactly R cubes for each cuboid without disconnecting the remaining cubes. Parameters: test_cases (list of tuples): List of test cases where each test case is a tuple (L, W, H, R) Returns: list of str: List of results for each test case (\\"YES\\" or \\"NO\\") return results # Test cases for verification def test_can_remove_cubes(): # Test case 1: 3x3x3 cuboid, 1 cube removed assert can_remove_cubes(3, 3, 3, 1) == \\"YES\\" # Test case 2: 2x2x2 cuboid, 8 cubes removed assert can_remove_cubes(2, 2, 2, 8) == \\"NO\\" # Test case 3: 4x4x4 cuboid, 5 cubes removed assert can_remove_cubes(4, 4, 4, 5) == \\"YES\\" # Additional test cases to cover more scenarios assert can_remove_cubes(1, 1, 1, 0) == \\"YES\\" assert can_remove_cubes(1, 1, 1, 1) == \\"NO\\" assert can_remove_cubes(2, 2, 2, 1) == \\"YES\\" assert can_remove_cubes(2, 2, 2, 7) == \\"YES\\" def test_process_test_cases(): assert process_test_cases([(3, 3, 3, 1), (2, 2, 2, 8), (4, 4, 4, 5)]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases([(1, 1, 1, 0), (1, 1, 1, 1), (2, 2, 2, 1)]) == [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_remove_cubes(L, W, H, R): Determines if it is possible to remove exactly R cubes from a cuboid of dimensions L x W x H without disconnecting the remaining cubes. total_cubes = L * W * H remaining_cubes = total_cubes - R # To keep the structure connected, at least one cube must remain. # For the structure to be single connected, remaining cubes must be at least 1. if remaining_cubes >= 1: return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): results = [] for L, W, H, R in test_cases: results.append(can_remove_cubes(L, W, H, R)) return results"},{"question":"def distributeSlices(N: int, K: int) -> List[int]: Distribute N slices of pizza among K friends such that each friend gets at least one slice, and the difference between the maximum and minimum number of slices a friend gets is minimized. >>> distributeSlices(10, 3) [3, 3, 4] >>> distributeSlices(7, 4) [1, 2, 2, 2] >>> distributeSlices(25, 7) [3, 3, 4, 4, 4, 4, 3] from typing import List","solution":"from typing import List def distributeSlices(N: int, K: int) -> List[int]: # Calculate the base number of slices each friend will get base_slices = N // K # Calculate the remaining slices to be distributed extra_slices = N % K # Create the distribution list distribution = [base_slices] * K # Distribute the remaining slices for i in range(extra_slices): distribution[i] += 1 return distribution"},{"question":"def largestSubstring(s: str, k: int) -> int: Find the length of the longest substring containing the same repeated character after performing at most \`k\` replacements. >>> largestSubstring('ABAB', 2) 4 >>> largestSubstring('AABABBA', 1) 4","solution":"def largestSubstring(s, k): from collections import defaultdict max_length = 0 left = 0 max_count = 0 count = defaultdict(int) for right in range(len(s)): count[s[right]] += 1 max_count = max(max_count, count[s[right]]) while (right - left + 1) - max_count > k: count[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def minJumps(arr: List[int]) -> int: Determine the minimum number of jumps required to reach the end of the array from the start (index 0). Args: arr (List[int]): A list of non-negative integers representing the maximum jump length from that position. Returns: int: The minimum number of jumps to reach the end of the array, or -1 if it's not possible. Example: >>> minJumps([2, 3, 1, 1, 4]) 2 >>> minJumps([3, 2, 1, 0, 4]) -1 def test_min_jumps(): assert minJumps([2, 3, 1, 1, 4]) == 2 assert minJumps([1, 2, 3, 4, 5]) == 3 assert minJumps([3, 2, 1, 0, 4]) == -1 assert minJumps([0]) == 0 assert minJumps([1]) == 0 assert minJumps([2, 0, 2, 0, 1]) == 2 assert minJumps([9, 2, 3, 1, 4]) == 1 assert minJumps([2, 3, 0, 1, 4]) == 2 assert minJumps([1, 1, 1, 1, 1]) == 4 assert minJumps([4, 1, 1, 3, 1, 1, 1]) == 2 def test_min_jumps_impossible(): assert minJumps([0, 2, 3]) == -1 assert minJumps([2, 0, 0, 1]) == -1 def test_min_jumps_with_large_step(): assert minJumps([10, 1]) == 1 def test_min_jumps_single_step(): assert minJumps([1, 1, 1, 1, 1, 1, 1, 1]) == 7","solution":"def minJumps(arr: list) -> int: if len(arr) <= 1: return 0 # If the first element is 0, we cannot move anywhere if arr[0] == 0: return -1 jumps = 0 current_end = 0 farthest = 0 for i in range(len(arr) - 1): farthest = max(farthest, i + arr[i]) # If we have reached the end of the range for the current jump if i == current_end: jumps += 1 current_end = farthest # If the farthest we can reach is already the end, return jumps if current_end >= len(arr) - 1: return jumps return -1 if current_end < len(arr) - 1 else jumps"},{"question":"def intersect(list1: List[int], list2: List[int]) -> List[int]: Returns a new list containing the elements that appear in both list1 and list2. Each element in the result appears as many times as it does in both input lists. >>> intersect([1, 2, 2, 3], [2, 2, 3, 4]) == [2, 2, 3] >>> intersect([1, 2, 3], [1, 2, 3]) == [1, 2, 3] >>> intersect([1, 2, 3], [4, 5, 6]) == [] >>> intersect([1, 1, 2, 2], [1, 1, 1, 2]) == [1, 1, 2] >>> intersect([], [1, 2, 3]) == [] >>> intersect([1, 2, 3], []) == [] >>> intersect([], []) == [] >>> intersect([1], [1]) == [1] >>> intersect([1, 2, 3], [4, 5, 3]) == [3] >>> intersect([1] * 10000 + [2] * 20000, [2] * 15000 + [3] * 20000) == [2] * 15000","solution":"def intersect(list1, list2): Returns a new list containing the elements that appear in both list1 and list2. Each element in the result appears as many times as it does in both input lists. from collections import Counter counter1 = Counter(list1) counter2 = Counter(list2) intersection = [] for element in counter1: if element in counter2: intersection.extend([element] * min(counter1[element], counter2[element])) return intersection"},{"question":"def is_happy_number(x: int) -> int: Determine if a given number is a happy number. >>> is_happy_number(19) 1 >>> is_happy_number(1) 1 >>> is_happy_number(7) 1 >>> is_happy_number(2) 0 >>> is_happy_number(3) 0","solution":"def is_happy_number(x): def get_next(n): return sum(int(char) ** 2 for char in str(n)) seen = set() while x != 1 and x not in seen: seen.add(x) x = get_next(x) return 1 if x == 1 else 0"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def lowestCommonAncestor(root, v, w): Returns the lowest common ancestor (LCA) of two given nodes in a binary tree. :param root: TreeNode, root of the binary tree. :param v: int, value of the first node. :param w: int, value of the second node. :return: int, value of the LCA node. >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> lowestCommonAncestor(root, 5, 1) 3 >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> lowestCommonAncestor(root, 6, 4) 5 >>> lowestCommonAncestor(root, 7, 8) 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def lowestCommonAncestor(root, v, w): Returns the lowest common ancestor (LCA) of two given nodes in a binary tree. :param root: TreeNode, root of the binary tree. :param v: int, value of the first node. :param w: int, value of the second node. :return: int, value of the LCA node. # Helper function to find the LCA def find_LCA(node, v, w): if node is None: return None if node.value == v or node.value == w: return node left_lca = find_LCA(node.left, v, w) right_lca = find_LCA(node.right, v, w) if left_lca and right_lca: return node return left_lca if left_lca else right_lca lca_node = find_LCA(root, v, w) return lca_node.value if lca_node else None"},{"question":"def find_special_integer(lst: List[int]) -> int: Returns the special integer that appears an odd number of times in the list. >>> find_special_integer([1, 2, 3, 2, 3, 1, 1]) 1 >>> find_special_integer([4, 4, 7, 7, 6, 6, 8]) 8","solution":"def find_special_integer(lst): Returns the special integer that appears an odd number of times in the list. special_integer = 0 for number in lst: special_integer ^= number return special_integer"},{"question":"from typing import List def reorder_array(arr: List[int]) -> List[int]: Reorders an array so that all the even elements appear before all the odd elements. The relative order of the even and odd elements is preserved from the original array. >>> reorder_array([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> reorder_array([3, 1, 2, 4]) [2, 4, 3, 1] >>> reorder_array([]) [] >>> reorder_array([2, 4, 6, 8]) [2, 4, 6, 8]","solution":"from typing import List def reorder_array(arr: List[int]) -> List[int]: Reorders an array so that all the even elements appear before all the odd elements. The relative order of the even and odd elements is preserved from the original array. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def evaluate_math_expression(expression: str) -> int: Evaluates a given mathematical expression containing non-negative integers and the operators + and *. The expression obeys the BODMAS rule and does not contain any parentheses. For example: >>> evaluate_math_expression(\\"3+5*2\\") 13 >>> evaluate_math_expression(\\"10+20+15\\") 45 >>> evaluate_math_expression(\\"7*6+1\\") 43 pass def test_single_number(): assert evaluate_math_expression(\\"5\\") == 5 def test_simple_addition(): assert evaluate_math_expression(\\"3+2\\") == 5 def test_simple_multiplication(): assert evaluate_math_expression(\\"4*2\\") == 8 def test_combined_operations_1(): assert evaluate_math_expression(\\"3+5*2\\") == 13 def test_combined_operations_2(): assert evaluate_math_expression(\\"10+20+15\\") == 45 def test_combined_operations_3(): assert evaluate_math_expression(\\"7*6+1\\") == 43 def test_combined_operations_4(): assert evaluate_math_expression(\\"2*3*4\\") == 24 def test_mixed_operations_no_multiplications(): assert evaluate_math_expression(\\"100\\") == 100 def test_multiplication_with_multiple_additions(): assert evaluate_math_expression(\\"10+5*2+3*4\\") == 10 + 10 + 12 def test_complex_expression(): assert evaluate_math_expression(\\"1+2*3+4*5+6\\") == 1 + 6 + 20 + 6 def test_edge_case_all_additions(): assert evaluate_math_expression(\\"1+1+1+1+1\\") == 5 def test_edge_case_all_multiplications(): assert evaluate_math_expression(\\"1*1*1*1*1\\") == 1","solution":"def evaluate_math_expression(expression: str) -> int: Evaluates a given mathematical expression containing non-negative integers and the operators + and *. The expression obeys the BODMAS rule and does not contain any parentheses. # Split the expression first by '+' to handle addition separately terms = expression.split('+') # Evaluate each term that might contain multiplication evaluated_terms = [eval_multiplication(term) for term in terms] # Sum up all the evaluated multiplication results return sum(evaluated_terms) def eval_multiplication(term: str) -> int: Evaluate a term containing multiplication only. factors = term.split('*') result = 1 for factor in factors: result *= int(factor) return result"},{"question":"def longest_arith_seq_length(A: List[int]) -> int: Determine the length of the longest arithmetic subsequence in the given array. Example: >>> longest_arith_seq_length([3, 6, 9, 12, 15, 18]) 6 >>> longest_arith_seq_length([1, 2, 3, 4, 5]) 5 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) 3 >>> longest_arith_seq_length([20, 1, 15, 3, 10, 5, 8]) 4 >>> longest_arith_seq_length([1]) 1 >>> longest_arith_seq_length([]) 0 >>> longest_arith_seq_length([10, 20, 30, 40, 50]) 5 >>> longest_arith_seq_length([10, 10, 10, 10, 10]) 5","solution":"def longest_arith_seq_length(A): if not A: return 0 n = len(A) dp = [{} for _ in range(n)] max_length = 1 for i in range(1, n): for j in range(i): diff = A[i] - A[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 # Start a new sequence with at least two elements (A[j], A[i]) max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"from typing import List def count_vowels(test_cases: List[str]) -> List[int]: For each string in test_cases, count the number of vowels (a, e, i, o, u) and return the counts as a list. Args: test_cases (list of str): List of strings for which the vowels count has to be determined. Returns: list of int: List of vowel counts corresponding to each string. Example: >>> count_vowels([\\"hello\\", \\"world\\", \\"programming\\"]) [2, 1, 3] >>> count_vowels([\\"bcdfg\\", \\"stv\\"]) [0, 0] >>> count_vowels([\\"HeLLo\\", \\"WoRlD\\", \\"PrOgRamMiNg\\"]) [2, 1, 3] >>> count_vowels([\\"\\"]) [0] >>> count_vowels([\\"aeiou\\", \\"AEIOU\\", \\"aEiOu\\"]) [5, 5, 5]","solution":"def count_vowels(test_cases): For each string in test_cases, count the number of vowels (a, e, i, o, u) and return the counts as a list. Args: test_cases (list of str): List of strings for which the vowels count has to be determined. Returns: list of int: List of vowel counts corresponding to each string. vowels = {'a', 'e', 'i', 'o', 'u'} results = [] for s in test_cases: count = sum(1 for char in s if char.lower() in vowels) results.append(count) return results"},{"question":"from typing import List def move_zeros(nums: List[int]) -> List[int]: Moves all zeros in the list to the end while maintaining the relative order of the non-zero elements. Parameters: nums (List[int]): The list of integers. Returns: List[int]: The list with zeros moved to the end. >>> move_zeros([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeros([1, 0, 0, 2, 3, 0, 4, 0]) [1, 2, 3, 4, 0, 0, 0, 0] >>> move_zeros([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0] >>> move_zeros([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> move_zeros([]) []","solution":"def move_zeros(nums): Moves all zeros in the list to the end while maintaining the relative order of the non-zero elements. Parameters: nums (List[int]): The list of integers. Returns: List[int]: The list with zeros moved to the end. zero_count = nums.count(0) non_zero_nums = [num for num in nums if num != 0] non_zero_nums.extend([0] * zero_count) return non_zero_nums"},{"question":"def most_frequent_character(s: str) -> str: Returns the character that appears most frequently in the string. If there are ties, returns the character that appears first in the string. >>> most_frequent_character(\\"hello\\") 'l' >>> most_frequent_character(\\"abzzzz\\") 'z' >>> most_frequent_character(\\"mississippi\\") 'i' >>> most_frequent_character(\\"abcabcabc\\") 'a' >>> most_frequent_character(\\"aabbccddeeffgg\\") 'a'","solution":"def most_frequent_character(s): Returns the character that appears most frequently in the string. If there are ties, returns the character that appears first in the string. if not s: return '' frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 max_count = 0 most_frequent_char = s[0] for char in s: if frequency[char] > max_count: max_count = frequency[char] most_frequent_char = char elif frequency[char] == max_count: # Since we are iterating through the string in order # the first character with max frequency encountered will be taken. most_frequent_char = most_frequent_char or char return most_frequent_char"},{"question":"def find_tallest_plant(garden): Finds the tallest plant in the garden and its positions. Parameters: garden (list of lists of int): The garden grid. Returns: tuple: The height of the tallest plant and a list of positions as tuples. >>> find_tallest_plant([[2, 3, 4], [4, 6, 1], [5, 6, 2]]) (6, [(1, 1), (2, 1)]) >>> find_tallest_plant([[2, 3], [3, 3]]) (3, [(0, 1), (1, 0), (1, 1)]) >>> find_tallest_plant([]) (0, []) >>> find_tallest_plant([[1, 2, 3, 7, 5]]) (7, [(0, 3)]) >>> find_tallest_plant([[1], [9], [3]]) (9, [(1, 0)]) >>> find_tallest_plant([[1, 1], [1, 1]]) (1, [(0, 0), (0, 1), (1, 0), (1, 1)])","solution":"def find_tallest_plant(garden): Finds the tallest plant in the garden and its positions. Parameters: garden (list of lists of int): The garden grid. Returns: tuple: The height of the tallest plant and a list of positions as tuples. if not garden or not garden[0]: return 0, [] max_height = float('-inf') positions = [] for i, row in enumerate(garden): for j, height in enumerate(row): if height > max_height: max_height = height positions = [(i, j)] elif height == max_height: positions.append((i, j)) return max_height, positions"},{"question":"class ParkingLot: A class to manage a parking lot with parking spaces arranged in increasing numerical order from 1 to n. Methods: park(int carId) -> bool: Parks the car with the given carId in the nearest available parking space. leave(int carId) -> bool: Removes the car with the given carId from the parking lot. findCar(int carId) -> int: Returns the parking space number for the car with the given carId. def __init__(self, capacity): pass def park(self, carId): pass def leave(self, carId): pass def findCar(self, carId): pass import pytest from solution import ParkingLot def test_park_successful(): lot = ParkingLot(5) assert lot.park(1) == True assert lot.park(2) == True assert lot.park(3) == True def test_park_fail_duplicate(): lot = ParkingLot(5) lot.park(1) assert lot.park(1) == False def test_park_fail_full(): lot = ParkingLot(3) lot.park(1) lot.park(2) lot.park(3) assert lot.park(4) == False def test_leave_successful(): lot = ParkingLot(5) lot.park(1) lot.park(2) assert lot.leave(1) == True assert lot.leave(2) == True def test_leave_fail_not_parked(): lot = ParkingLot(5) lot.park(1) assert lot.leave(2) == False def test_findCar_parked(): lot = ParkingLot(5) lot.park(1) lot.park(2) assert lot.findCar(1) == 1 assert lot.findCar(2) == 2 def test_findCar_not_parked(): lot = ParkingLot(5) lot.park(1) assert lot.findCar(2) == -1 def test_park_after_leave(): lot = ParkingLot(5) lot.park(1) lot.park(2) lot.leave(1) assert lot.park(3) == True assert lot.findCar(3) == 1","solution":"class ParkingLot: def __init__(self, capacity): self.capacity = capacity self.parking_spaces = [None] * capacity self.car_to_space = {} def park(self, carId): if carId in self.car_to_space: return False for i in range(self.capacity): if self.parking_spaces[i] is None: self.parking_spaces[i] = carId self.car_to_space[carId] = i + 1 return True return False def leave(self, carId): if carId not in self.car_to_space: return False space = self.car_to_space[carId] - 1 self.parking_spaces[space] = None del self.car_to_space[carId] return True def findCar(self, carId): return self.car_to_space.get(carId, -1)"},{"question":"def find_smallest_unique_index(arr: List[int]) -> int: Returns the index of the first occurrence of the smallest unique number in the array. If there are no unique numbers, returns -1. >>> find_smallest_unique_index([4, 5, 1, 2, 2, 4, 5]) 2 >>> find_smallest_unique_index([6, 7, 3, 6, 8, 3, 9]) 1 >>> find_smallest_unique_index([1, 1, 1, 1, 1]) -1","solution":"def find_smallest_unique_index(arr): Returns the index of the first occurrence of the smallest unique number in the array. If there are no unique numbers, returns -1. from collections import Counter # Count the frequency of each element in the array frequency = Counter(arr) # Filter elements to get only unique ones (frequency == 1) unique_elements = {key for key, count in frequency.items() if count == 1} if not unique_elements: return -1 # Find the smallest unique element smallest_unique = min(unique_elements) # Return the index of the first occurrence of the smallest unique element return arr.index(smallest_unique)"},{"question":"def harmonic_divisors(x): Return the first x harmonic divisor numbers in ascending order. Args: x : int : Number of harmonic divisor numbers to return Returns: List[int] : List of the first x harmonic divisor numbers in ascending order >>> harmonic_divisors(5) [1, 6, 28, 140, 270] >>> harmonic_divisors(10) [1, 6, 28, 140, 270, 496, 672, 1638, 2970, 6200]","solution":"def harmonic_mean(lst): Compute the harmonic mean of a list of divisors. from fractions import Fraction if not lst: return 0 n = len(lst) sum_reciprocal = sum(Fraction(1, d) for d in lst) harmonic_mean_value = Fraction(n, sum_reciprocal) return harmonic_mean_value def divisors(n): Compute the divisors of a number n. divs = [] for i in range(1, n + 1): if n % i == 0: divs.append(i) return divs def is_harmonic_divisor_number(n): Check if a number n is a harmonic divisor number. divs = divisors(n) h_mean = harmonic_mean(divs) return h_mean.denominator == 1 def harmonic_divisors(x): Return the first x harmonic divisor numbers in ascending order. result = [] num = 1 while len(result) < x: if is_harmonic_divisor_number(num): result.append(num) num += 1 return result"},{"question":"from typing import List def trap_rainwater(heights: List[int]) -> int: Given an array of non-negative integers representing the heights of buildings in a city skyline, compute how much rainwater would be trapped between these buildings after a heavy rain. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9","solution":"from typing import List def trap_rainwater(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0]*n right_max = [0]*n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a given arithmetic expression that includes addition, subtraction, multiplication, and division, respecting operator precedence and handling spaces. :param expression: A string containing the arithmetic expression :return: A float or int, the result of the arithmetic expression >>> evaluate_expression(\\"2 + 3\\") == 5.0 >>> evaluate_expression(\\"10 - 5\\") == 5.0 >>> evaluate_expression(\\"4 * 2\\") == 8.0 >>> evaluate_expression(\\"8 / 2\\") == 4.0 >>> evaluate_expression(\\"2 + 3 * 4\\") == 14.0 >>> evaluate_expression(\\"10 - 2 / 2\\") == 9.0 >>> evaluate_expression(\\"(2 + 3) * 4\\") == 20.0 >>> evaluate_expression(\\"4 * (2 + 3)\\") == 20.0 >>> evaluate_expression(\\"3 + 5 / 2 - 1\\") == 4.5 >>> evaluate_expression(\\"10 - 2 / (2 + 3)\\") == 9.6 >>> evaluate_expression(\\"2 * 3 + 4 / 2 - 1\\") == 7.0 >>> evaluate_expression(\\"2 * (3 + 1) / (1 + 1)\\") == 4.0 >>> evaluate_expression(\\" 3 + 5 / 2 - 1 \\") == 4.5 >>> evaluate_expression(\\"10- 2 / (2+ 3)\\") == 9.6 >>> evaluate_expression(\\"2* 3 + 4 / 2-1\\") == 7.0 >>> evaluate_expression(\\"2* (3 +1)/ (1+1 ) \\") == 4.0","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression that includes addition, subtraction, multiplication, and division, respecting operator precedence and handling spaces. :param expression: A string containing the arithmetic expression :return: A float or int, the result of the arithmetic expression import re tokens = re.findall(r'd+.?d*|+|-|*|/|(|)', expression.replace(' ', '')) def parse_expression(tokens): def get_term(): term = get_factor() while tokens and tokens[0] in ('*', '/'): op = tokens.pop(0) if op == '*': term *= get_factor() elif op == '/': term /= get_factor() return term def get_factor(): factor = None if tokens: if tokens[0] == '(': tokens.pop(0) factor = parse_expression(tokens) tokens.pop(0) # removing closing parenthesis else: factor = float(tokens.pop(0)) return factor result = get_term() while tokens and tokens[0] in ('+', '-'): op = tokens.pop(0) if op == '+': result += get_term() elif op == '-': result -= get_term() return result return parse_expression(tokens)"},{"question":"def manipulate_array(N: int, Q: int, array: List[int], operations: List[Tuple[int, int, int, Optional[int]]]) -> List[int]: Perform a series of operations on the array and returns the modified array. Args: N: Integer, the length of the array. Q: Integer, the number of operations. array: List of integers, the initial array. operations: List of operations. Each operation is either: - (1, L, R, X) -> Increment all elements from index L to R by X. - (2, L, R) -> Reverse all elements from index L to R. Returns: List of integers: The modified array after all operations. Example: >>> manipulate_array(5, 3, [1, 2, 3, 4, 5], [(1, 0, 4, 2), (2, 1, 3), (1, 0, 2, 1)]) [4, 7, 6, 4, 7]","solution":"def manipulate_array(N, Q, array, operations): Perform a series of operations on the array and returns the modified array. Args: N: Integer, the length of the array. Q: Integer, the number of operations. array: List of integers, the initial array. operations: List of operations. Each operation is either: - \\"1 L R X\\" -> Increment all elements from index L to R by X. - \\"2 L R\\" -> Reverse all elements from index L to R. Returns: List of integers: The modified array after all operations. for op in operations: if op[0] == 1: L, R, X = op[1], op[2], op[3] for idx in range(L, R + 1): array[idx] += X elif op[0] == 2: L, R = op[1], op[2] array[L:R + 1] = array[L:R + 1][::-1] return array"},{"question":"import heapq from collections import defaultdict class PriorityQueueWithLimitedRepeats: Implements a priority queue that limits the number of times a particular element can be present. Attributes: - k: Maximum number of times any element can be present in the queue. - maxHeap: List representing the max heap. - valCount: Dictionary to track the count of each element. Methods: - __init__(self, k): Initializes the object with the maximum number \`k\` of times any element can be present in the queue. - insert(self, val): Inserts the given positive integer \`val\` into the queue, only if the number of occurrences of \`val\` in the queue is less than \`k\`. - pop(self): Removes and returns the highest-priority element from the queue. If the queue is empty, return \`-1\`. def __init__(self, k): Initializes the object with the maximum number \`k\` of times any element can be present in the queue. pass def insert(self, val): Inserts the given positive integer \`val\` into the queue, only if the number of occurrences of \`val\` in the queue is less than \`k\`. pass def pop(self): Removes and returns the highest-priority element from the queue. If the queue is empty, return \`-1\`. pass def test_priority_queue_operations(): pq = PriorityQueueWithLimitedRepeats(2) # Test inserting elements into the queue pq.insert(4) pq.insert(3) pq.insert(5) pq.insert(5) pq.insert(6) assert pq.max_heap == [-6, -5, -4, -3, -5] # Test popping elements from the queue assert pq.pop() == 6 pq.insert(6) assert pq.pop() == 6 assert pq.pop() == 5 assert pq.pop() == 5 assert pq.pop() == 4 assert pq.pop() == 3 assert pq.pop() == -1 # Test inserting after popping elements pq.insert(2) assert pq.pop() == 2 def test_insertion_limit(): pq = PriorityQueueWithLimitedRepeats(1) # Insert the same value multiple times pq.insert(7) pq.insert(7) pq.insert(7) # Should have only one instance of 7 assert pq.max_heap == [-7] assert pq.pop() == 7 assert pq.pop() == -1 def test_empty_queue_pop(): pq = PriorityQueueWithLimitedRepeats(3) assert pq.pop() == -1 def test_multiple_insertions(): pq = PriorityQueueWithLimitedRepeats(3) pq.insert(10) pq.insert(5) pq.insert(10) pq.insert(5) pq.insert(10) pq.insert(5) pq.insert(1) pq.insert(1) assert pq.pop() == 10 assert pq.pop() == 10 assert pq.pop() == 10 assert pq.pop() == 5 assert pq.pop() == 5 assert pq.pop() == 5 assert pq.pop() == 1 assert pq.pop() == 1 assert pq.pop() == -1","solution":"import heapq from collections import defaultdict class PriorityQueueWithLimitedRepeats: def __init__(self, k): Initializes the object with the maximum number \`k\` of times any element can be present in the queue. self.k = k self.max_heap = [] self.val_count = defaultdict(int) def insert(self, val): Inserts the given positive integer \`val\` into the queue, only if the number of occurrences of \`val\` in the queue is less than \`k\`. if self.val_count[val] < self.k: heapq.heappush(self.max_heap, -val) self.val_count[val] += 1 def pop(self): Removes and returns the highest-priority element from the queue. If the queue is empty, return \`-1\`. while self.max_heap: val = -heapq.heappop(self.max_heap) if self.val_count[val] > 0: self.val_count[val] -= 1 return val return -1"},{"question":"def find_missing_number(numbers: List[int]) -> int: Given a list of distinct integers from 1 to n with one number missing, returns the missing number. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 5, 6]) 4","solution":"def find_missing_number(numbers): Given a list of distinct integers from 1 to n with one number missing, returns the missing number. n = len(numbers) + 1 # since one number is missing, the actual length should be n total_sum = n * (n + 1) // 2 # sum of first n natural numbers actual_sum = sum(numbers) # sum of given list return total_sum - actual_sum"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all other elements in the list except itself. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 2, 3]) [6, 3, 2] >>> product_except_self([5, 6, 7]) [42, 35, 30] >>> product_except_self([3, 3, 3, 3]) [27, 27, 27, 27]","solution":"def product_except_self(nums): Returns a list where each element is the product of all other elements in the list except itself. n = len(nums) left_products = [1] * n right_products = [1] * n result = [1] * n left_running_product = 1 for i in range(n): left_products[i] = left_running_product left_running_product *= nums[i] right_running_product = 1 for i in range(n - 1, -1, -1): right_products[i] = right_running_product right_running_product *= nums[i] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def generate_primes(n: int) -> list[int]: Generates the first n prime numbers. >>> generate_primes(1) [2] >>> generate_primes(5) [2, 3, 5, 7, 11] >>> generate_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71] >>> generate_primes(0) [] >>> generate_primes(-5) []","solution":"def generate_primes(n: int) -> list[int]: Generates the first n prime numbers. :param n: A positive integer representing the number of primes to generate. :return: A list containing the first n prime numbers. if n < 1: return [] primes = [] num = 2 while len(primes) < n: for i in range(2, int(num**0.5) + 1): if num % i == 0: break else: primes.append(num) num += 1 return primes"},{"question":"def find_max_occurred_char(s: str) -> str: Returns the character that appears the most frequently in the string. If multiple characters have the same highest frequency, the one that appears first in the string is returned. >>> find_max_occurred_char(\\"character\\") 'c' >>> find_max_occurred_char(\\"abbccc\\") 'c' >>> find_max_occurred_char(\\"abc\\") 'a' >>> find_max_occurred_char(\\"xyz\\") 'x' >>> find_max_occurred_char(\\"aabbccaa\\") 'a' pass","solution":"def find_max_occurred_char(s): Returns the character that appears the most frequently in the string. If multiple characters have the same highest frequency, the one that appears first in the string is returned. from collections import defaultdict char_count = defaultdict(int) for char in s: char_count[char] += 1 max_count = 0 max_char = '' for char in s: if char_count[char] > max_count: max_count = char_count[char] max_char = char return max_char"},{"question":"def max_product(nums: List[int]) -> int: Return the maximum product of three numbers in the list. >>> max_product([1, 2, 3]) == 6 >>> max_product([1, 2, 3, 4]) == 24 >>> max_product([-10, -10, 5, 2]) == 500 >>> max_product([-1, -2, -3, -4]) == -6 >>> max_product([0, 2, 3, 5]) == 30 >>> max_product([10, 3, 5, 6, 20]) == 1200 >>> max_product([-10, 3, -2, 6, -20]) == 1200 >>> max_product([1, 2, -1, 0, -3, 4, 0, -2]) == 24","solution":"def max_product(nums): Return the maximum product of three numbers in the list. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def max_height_in_sets(n: int, heights: List[int]) -> List[int]: Determine the maximum possible height of an object in each set after rearrangement in a row of blocks. Args: n (int): Number of blocks. heights (List[int]): Heights of objects in the blocks. Returns: List[int]: List of maximum possible heights for each block. >>> max_height_in_sets(5, [0, 2, 3, 0, 1]) [0, 3, 3, 0, 1] >>> max_height_in_sets(6, [4, 0, 0, 5, 0, 7]) [4, 0, 0, 5, 0, 7] >>> max_height_in_sets(4, [1, 4, 2, 3]) [4, 4, 4, 4] pass","solution":"def max_height_in_sets(n, heights): if n == 1: return heights # For a single block, the height doesn't change. result = [] i = 0 while i < n: if heights[i] == 0: result.append(0) i += 1 else: j = i while j < n and heights[j] != 0: j += 1 max_height = max(heights[i:j]) result.extend([max_height] * (j - i)) i = j return result"},{"question":"from typing import List def best_day(sales_list: List[int]) -> int: Returns the day (0-based index) with the highest sales. >>> best_day([200, 180, 220, 210, 150, 300, 170]) 5 >>> best_day([1, 2, 3, 4, 5]) 4 >>> best_day([1000, 1000, 1000]) 0 pass def worst_day(sales_list: List[int]) -> int: Returns the day (0-based index) with the lowest sales. >>> worst_day([200, 180, 220, 210, 150, 300, 170]) 4 >>> worst_day([1, 2, 3, 4, 5]) 0 >>> worst_day([1000, 1000, 999]) 2 pass def average_sales(sales_list: List[int]) -> int: Returns the average daily sales rounded down to an integer. >>> average_sales([200, 180, 220, 210, 150, 300, 170]) 204 >>> average_sales([1, 2, 3, 4, 5]) 3 >>> average_sales([1000, 1000, 1000]) 1000 pass def above_average_days(sales_list: List[int]) -> List[int]: Returns an array containing 0-based indices of the days where sales were above average. >>> above_average_days([200, 180, 220, 210, 150, 300, 170]) [2, 3, 5] >>> above_average_days([1, 2, 3, 4, 5]) [3, 4] >>> above_average_days([1000, 1000, 1000]) [] pass","solution":"def best_day(sales_list): Returns the day (0-based index) with the highest sales. return sales_list.index(max(sales_list)) def worst_day(sales_list): Returns the day (0-based index) with the lowest sales. return sales_list.index(min(sales_list)) def average_sales(sales_list): Returns the average daily sales rounded down to an integer. return sum(sales_list) // len(sales_list) def above_average_days(sales_list): Returns an array containing 0-based indices of the days where sales were above average. avg = average_sales(sales_list) return [index for index, sales in enumerate(sales_list) if sales > avg]"},{"question":"def fizz_buzz(n: int) -> str: Generates a list of numbers from 1 to n, with modifications: - Numbers divisible by 3 are replaced by \\"Fizz\\" - Numbers divisible by 5 are replaced by \\"Buzz\\" - Numbers divisible by both 3 and 5 are replaced by \\"FizzBuzz\\" Args: n (int): The upper limit of the list Returns: str: The modified list as a string with elements separated by spaces >>> fizz_buzz(15) == \\"1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz\\" >>> fizz_buzz(1) == \\"1\\" >>> fizz_buzz(5) == \\"1 2 Fizz 4 Buzz\\" >>> fizz_buzz(3) == \\"1 2 Fizz\\" >>> fizz_buzz(10) == \\"1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz\\" >>> fizz_buzz(30) == \\"1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz\\"","solution":"def fizz_buzz(n): Generates a list of numbers from 1 to n, where: - Numbers divisible by 3 are replaced by \\"Fizz\\" - Numbers divisible by 5 are replaced by \\"Buzz\\" - Numbers divisible by 3 and 5 are replaced by \\"FizzBuzz\\" Args: n (int): The upper limit of the list Returns: str: The modified list as a string with elements separated by spaces result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return \\" \\".join(result)"},{"question":"def segment_count(string: str, segment: str) -> int: Returns the number of times the segment occurs within the string. :param string: The main string in which to search for the segment :param segment: The segment (sub-string) to count within the main string :return: The count of occurrences of the segment in the string >>> segment_count(\\"hellohellohello\\", \\"hello\\") 3 >>> segment_count(\\"hello\\", \\"world\\") 0","solution":"def segment_count(string, segment): Returns the number of times the segment occurs within the string. :param string: The main string in which to search for the segment :param segment: The segment (sub-string) to count within the main string :return: The count of occurrences of the segment in the string count = 0 start = 0 while start <= len(string) - len(segment): start = string.find(segment, start) if start == -1: break count += 1 start += len(segment) return count"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in the input string. The input string consists of words separated by spaces. The function should return a string in which the words appear in reverse order compared to the input. It should handle multiple spaces properly and should not include leading or trailing spaces in the output. The words should be separated by a single space in the reversed string. Examples: >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" >>> reverse_words(\\"Alice does not even like Bob\\") \\"Bob like even not does Alice\\" >>> reverse_words(\\" \\") \\"\\"","solution":"def reverse_words(s): Reverses the order of words in the input string. Parameters: s (str): The input string. Returns: str: A string where the words are in reverse order compared to the input. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def check_balanced_brackets(n: int, strings: List[str]) -> List[str]: Given a number of strings, determine for each string if it is balanced and properly nested. Args: n: int - An integer representing the number of strings to evaluate. strings: List[str] - A list of strings that need to be checked for proper nesting and balance. Returns: List[str]: A list containing \\"YES\\" if the string is properly nested and balanced, otherwise \\"NO\\". >>> check_balanced_brackets(3, [\\"([]{})\\", \\"[(])\\", \\"[{}]\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_balanced_brackets(1, [\\"({[)]})\\"]) [\\"NO\\"] pass # Unit Tests def test_single_balanced_strings(): assert check_balanced_brackets(1, [\\"([]{})\\"]) == [\\"YES\\"] assert check_balanced_brackets(1, [\\"[{}]\\"]) == [\\"YES\\"] assert check_balanced_brackets(1, [\\"()[]{}\\"]) == [\\"YES\\"] def test_single_unbalanced_strings(): assert check_balanced_brackets(1, [\\"({[)]})\\"]) == [\\"NO\\"] assert check_balanced_brackets(1, [\\"[(])\\"]) == [\\"NO\\"] assert check_balanced_brackets(1, [\\"{[}\\"]) == [\\"NO\\"] def test_multiple_strings(): input_strings = [\\"([]{})\\", \\"[(])\\", \\"[{}]\\"] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert check_balanced_brackets(3, input_strings) == expected_output input_strings = [\\"({})\\", \\"}\\", \\"()\\"] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert check_balanced_brackets(3, input_strings) == expected_output def test_empty_string(): assert check_balanced_brackets(1, [\\"\\"]) == [\\"YES\\"] def test_large_input(): input_strings = [\\"()\\"] * 1000 expected_output = [\\"YES\\"] * 1000 assert check_balanced_brackets(1000, input_strings) == expected_output","solution":"def is_balanced(s): Check if the input string s is properly nested and balanced. stack = [] opening = '([{' closing = ')]}' matching = {')': '(', ']': '[', '}': '{'} for char in s: if char in opening: stack.append(char) elif char in closing: if not stack or stack.pop() != matching[char]: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\" def check_balanced_brackets(n, strings): Given a number of strings, determine for each string if it is balanced and properly nested. results = [] for s in strings: results.append(is_balanced(s)) return results"},{"question":"def characterReplacement(s: str, k: int) -> int: Given a string s and an integer k, returns the length of the longest substring containing the same letter after performing at most k changes. >>> characterReplacement(\\"ABAB\\", 2) 4 >>> characterReplacement(\\"AABABBA\\", 1) 4","solution":"def characterReplacement(s, k): Returns the length of the longest substring containing the same letter after performing at most k changes. left = 0 counts = {} max_count = 0 result = 0 for right in range(len(s)): counts[s[right]] = counts.get(s[right], 0) + 1 max_count = max(max_count, counts[s[right]]) while (right - left + 1) - max_count > k: counts[s[left]] -= 1 left += 1 result = max(result, right - left + 1) return result"},{"question":"import math from typing import List def is_prime_or_not(N: int) -> str: Determines whether a number N is a prime number or not. If not, returns the factors of N that are not 1 or N. >>> is_prime_or_not(7) \\"Prime\\" >>> is_prime_or_not(18) \\"Not Prime: 2, 3, 6, 9\\" >>> is_prime_or_not(29) \\"Prime\\" >>> is_prime_or_not(30) \\"Not Prime: 2, 3, 5, 6, 10, 15\\" >>> is_prime_or_not(1) \\"Not Prime\\" >>> is_prime_or_not(2) \\"Prime\\" >>> is_prime_or_not(15) \\"Not Prime: 3, 5\\" pass def check_prime_factors(T: int, numbers: List[int]) -> List[str]: Checks multiple numbers to determine if they are prime or not. >>> check_prime_factors(4, [7, 18, 29, 30]) [\\"Prime\\", \\"Not Prime: 2, 3, 6, 9\\", \\"Prime\\", \\"Not Prime: 2, 3, 5, 6, 10, 15\\"] >>> check_prime_factors(2, [1, 2]) [\\"Not Prime\\", \\"Prime\\"] >>> check_prime_factors(1, [15]) [\\"Not Prime: 3, 5\\"] pass","solution":"import math def is_prime_or_not(N): Determines whether a number N is a prime number or not. If not, returns the factors of N that are not 1 or N. if N <= 1: return \\"Not Prime\\" factors = [] for i in range(2, int(math.sqrt(N)) + 1): if N % i == 0: factors.append(i) if i != N // i: factors.append(N // i) if not factors: return \\"Prime\\" else: factors.sort() return \\"Not Prime: \\" + \\", \\".join(map(str, factors)) def check_prime_factors(T, numbers): Checks multiple numbers to determine if they are prime or not. results = [] for N in numbers: results.append(is_prime_or_not(N)) return results"},{"question":"from typing import List def is_permutation(lst: List[int]) -> bool: Check if a list is a permutation of numbers from 1 to n, where n is the length of the list. >>> is_permutation([1, 2, 3, 4, 5]) True >>> is_permutation([1, 2, 2, 4, 5]) False >>> is_permutation([5, 3, 1, 4, 2]) True >>> is_permutation([1, 2, 3, 4, 6]) False","solution":"def is_permutation(lst): Check if a list is a permutation of numbers from 1 to n, where n is the length of the list. n = len(lst) return set(lst) == set(range(1, n + 1))"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of numbers, return a new list where each element is the product of all the other elements in the original list except the current element. Args: nums (List[int]): List of integers Returns: List[int]: A new list where each element is the product of all other elements in the original list except the current element. Example: >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6]","solution":"def product_except_self(nums): Returns a new list where each element is the product of all other elements in the original list except the current element. length = len(nums) # Initialize the result array with 1s result = [1] * length # Calculate products of all elements to the left of each index left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate products of all elements to the right of each index right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def max_non_overlapping_observations(n: int, periods: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping observations. Parameters: n (int): The number of observation periods. periods (List[Tuple[int, int]]): List of observation periods, each defined by a start and end time. Returns: int: The maximum number of non-overlapping observations. >>> max_non_overlapping_observations(3, [(1,3), (2,5), (4,6)]) == 2 >>> max_non_overlapping_observations(4, [(1,2), (3,4), (0,1), (2,3)]) == 4","solution":"def max_non_overlapping_observations(n, periods): Returns the maximum number of non-overlapping observations. Parameters: n (int): The number of observation periods. periods (List[Tuple[int, int]]): List of observation periods, each defined by a start and end time. Returns: int: The maximum number of non-overlapping observations. # Sort the periods by their end times periods.sort(key=lambda x: x[1]) # Initialize variables max_observations = 0 last_end_time = -1 # We use -1 to ensure the first period is considered # Iterate through each period for start, end in periods: # If the start time of the current period is after or at the end time of the last observed period if start >= last_end_time: # We can schedule this observation max_observations += 1 # Update the end time of the last scheduled period last_end_time = end return max_observations # Example call print(max_non_overlapping_observations(3, [(1,3), (2,5), (4,6)])) # Output: 2 print(max_non_overlapping_observations(4, [(1,2), (3,4), (0,1), (2,3)])) # Output: 4"},{"question":"def is_valid_path(n: int, grid: List[List[int]]) -> bool: Determines if there exists a valid path from (1,1) to (n,n) in the given grid. A valid path means moving right or down from cell to cell with each move incrementing the cell's value by 1. :param n: Dimensions of the grid (n x n) :param grid: 2D list representing the grid :return: True if at least one valid path exists, False otherwise >>> is_valid_path(3, [ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5]]) True >>> is_valid_path(3, [ ... [1, 2, 3], ... [3, 4, 5], ... [6, 7, 8]]) False >>> is_valid_path(2, [ ... [1, 3], ... [3, 2]]) False >>> is_valid_path(1, [[1]]) True >>> is_valid_path(4, [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7]]) True pass","solution":"def is_valid_path(n, grid): Determines if there exists a valid path from (1,1) to (n,n) in the given grid. :param n: Dimensions of the grid (n x n) :param grid: 2D list representing the grid :return: True if at least one valid path exists, False otherwise # A helper function to check valid movement def is_valid_move(x, y, new_x, new_y): return 0 <= new_x < n and 0 <= new_y < n and grid[new_x][new_y] == grid[x][y] + 1 # Use BFS to traverse the grid from collections import deque # Starting point queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # Check if we've reached the bottom-right corner if x == n - 1 and y == n - 1: return True # Move right if is_valid_move(x, y, x, y + 1) and (x, y + 1) not in visited: queue.append((x, y + 1)) visited.add((x, y + 1)) # Move down if is_valid_move(x, y, x + 1, y) and (x + 1, y) not in visited: queue.append((x + 1, y)) visited.add((x + 1, y)) return False"},{"question":"inventory = {} def inventory_management(command: str): Manages the stock of items in a warehouse based on the given command. Commands can be one of the following: - \\"restock item_name quantity\\": Adds the given quantity to the stock of the item. - \\"sell item_name quantity\\": Removes the given quantity from the item's stock. - \\"remove item_name\\": Removes the item from the inventory entirely. - \\"check_stock item_name\\": Returns the current quantity of the item in the inventory. - If the stock is insufficient, set the quantity of the item to 0. - If the item does not exist, it is added with the given quantity. - If the item does not exist, return \\"Item not found\\". - If the command is invalid, return \\"Invalid command\\". Example usage: >>> inventory_management(\\"restock apples 10\\") # Adds 10 apples to the inventory >>> inventory_management(\\"sell apples 4\\") # Removes 4 apples from the inventory >>> inventory_management(\\"remove apples\\") # Completely removes apples from the inventory >>> inventory_management(\\"check_stock apples\\")# Returns the current stock of apples (or \\"Item not found\\" if apples don't exist)","solution":"inventory = {} def inventory_management(command): global inventory parts = command.split() if parts[0] == \\"restock\\": item = parts[1] quantity = int(parts[2]) if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif parts[0] == \\"sell\\": item = parts[1] quantity = int(parts[2]) if item in inventory: inventory[item] = max(0, inventory[item] - quantity) elif parts[0] == \\"remove\\": item = parts[1] if item in inventory: del inventory[item] elif parts[0] == \\"check_stock\\": item = parts[1] return inventory.get(item, \\"Item not found\\") else: return \\"Invalid command\\""},{"question":"def shift_string(s: str, k: int) -> str: Shifts each character in the string 's' k positions forward in the alphabet. Wraps around if it goes past 'z'. >>> shift_string('abc', 3) 'def' >>> shift_string('xyz', 3) 'abc' >>> shift_string('zzz', 1) 'aaa' >>> shift_string('a', 26) 'a' >>> shift_string('abc', 52) 'abc' >>> shift_string('abc', 1000) 'mno' >>> shift_string('xyz', 1000) 'jkl' >>> shift_string('abcdefghijklmnopqrstuvwxyz', 3) 'defghijklmnopqrstuvwxyzabc' >>> shift_string('abcdefghijklmnopqrstuvwxyz', 1) 'bcdefghijklmnopqrstuvwxyza' >>> shift_string('x', 5) 'c' >>> shift_string('y', 1) 'z' >>> shift_string('z', 1) 'a'","solution":"def shift_string(s, k): Shifts each character in the string 's' k positions forward in the alphabet. Wraps around if it goes past 'z'. shifted_chars = [] for char in s: new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) shifted_chars.append(new_char) return ''.join(shifted_chars)"},{"question":"def min_vans_required(num_cases: int, cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimum number of vans required to deliver all packages for each test case. >>> input_str = \\"2n10n4n2 3 8 2n15n5n4 8 5 7 3n\\" >>> num_cases, cases = parse_input(input_str) >>> min_vans_required(num_cases, cases) [2, 2] >>> input_str = \\"1n5n1n6n\\" >>> num_cases, cases = parse_input(input_str) >>> min_vans_required(num_cases, cases) [1] >>> input_str = \\"3n10n6n5 5 5 5 5 5n12n2n6 6n20n3n10 10 10n\\" >>> num_cases, cases = parse_input(input_str) >>> min_vans_required(num_cases, cases) [3, 1, 2] >>> input_str = \\"1n20n4n5 5 5 5n\\" >>> num_cases, cases = parse_input(input_str) >>> min_vans_required(num_cases, cases) [1] >>> input_str = \\"1n10n10n1 1 1 1 1 1 1 1 1 1n\\" >>> num_cases, cases = parse_input(input_str) >>> min_vans_required(num_cases, cases) [1] def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]: Parse the input string into the number of test cases and their details.","solution":"def min_vans_required(num_cases, cases): results = [] for case in cases: max_capacity, num_packages, package_weights = case package_weights.sort(reverse=True) vans = 0 used = [False] * num_packages for i in range(num_packages): if not used[i]: current_capacity = max_capacity - package_weights[i] used[i] = True for j in range(i + 1, num_packages): if not used[j] and package_weights[j] <= current_capacity: current_capacity -= package_weights[j] used[j] = True vans += 1 results.append(vans) return results # Parse input function def parse_input(input_str): lines = input_str.strip().split('n') num_cases = int(lines[0]) cases = [] current_line = 1 for _ in range(num_cases): max_capacity = int(lines[current_line]) num_packages = int(lines[current_line + 1]) package_weights = list(map(int, lines[current_line + 2].split())) cases.append((max_capacity, num_packages, package_weights)) current_line += 3 return num_cases, cases"},{"question":"def find_peak_element(nums: List[int]) -> int: Finds the index of a peak element in the array. A peak element is an element that is greater than its neighbors. >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) in [1, 5]","solution":"def find_peak_element(nums): Finds the index of a peak element in the array. A peak element is an element that is greater than its neighbors. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def reorder_list(initial_list, order_by): Reorders the elements in initial_list based on the order defined in order_by. Elements in initial_list that are not in order_by are added at the end in their original order. :param initial_list: List of integers to be reordered :param order_by: List of integers defining the order :return: Reordered list >>> reorder_list([4, 5, 6, 7], [6, 7, 4]) [6, 7, 4, 5] >>> reorder_list([1, 2, 3], [3, 1, 4, 2]) [3, 1, 2] >>> reorder_list([7, 8, 9], [9, 7, 8]) [9, 7, 8] >>> reorder_list([10, 20, 30, 40], [50, 20, 30]) [20, 30, 10, 40] >>> reorder_list([1, 2, 3], [4, 5, 6]) [1, 2, 3] >>> reorder_list([], [1, 2, 3]) [] >>> reorder_list([1, 2, 3], []) [1, 2, 3] >>> reorder_list([], []) []","solution":"def reorder_list(initial_list, order_by): Reorders the elements in initial_list based on the order defined in order_by. Elements in initial_list that are not in order_by are added at the end in their original order. :param initial_list: List of integers to be reordered :param order_by: List of integers defining the order :return: Reordered list result = [] initial_set = set(initial_list) for element in order_by: if element in initial_set: result.append(element) for element in initial_list: if element not in result: result.append(element) return result"},{"question":"def customSortString(s: str) -> str: Sorts the characters in the string as follows: - All alphabetical characters (both uppercase and lowercase) come first, - Followed by numeric characters, - Followed by punctuation marks. Within each category, characters appear in the order they first appear in the input string. >>> customSortString(\\"a1!B2@\\") 'aB12!@' >>> customSortString(\\"abcABC\\") 'abcABC' >>> customSortString(\\"123456\\") '123456' >>> customSortString(\\"!@#%\\") '!@#%' >>> customSortString(\\"a1b2C3\\") 'abC123' >>> customSortString(\\"a!b@C#\\") 'abC!@#' >>> customSortString(\\"1!2@3#\\") '123!@#' >>> customSortString(\\"\\") ''","solution":"def customSortString(s: str) -> str: Sorts the characters in the string as follows: - All alphabetical characters (both uppercase and lowercase) come first, - Followed by numeric characters, - Followed by punctuation marks. Within each category, characters appear in the order they first appear in the input string. alphabetic_characters = [] numeric_characters = [] punctuation_characters = [] for char in s: if char.isalpha(): alphabetic_characters.append(char) elif char.isdigit(): numeric_characters.append(char) else: punctuation_characters.append(char) return ''.join(alphabetic_characters + numeric_characters + punctuation_characters)"},{"question":"def check_strength(sequences: List[str]) -> str: Given a list of strings, each string representing an alphanumeric sequence, determine if the sequence has at least one uppercase letter, one lowercase letter, and one digit. Print 'Strong' if it meets the criteria, and 'Weak' otherwise. Stop processing input after finding one 'Strong' string. >>> check_strength(['aBc123', 'XyZ456', 'LmN789']) \\"Strong\\" >>> check_strength(['abc', 'XYZ', '123aA']) \\"Strong\\" >>> check_strength(['abc', 'XYZ', '123']) \\"Weak\\" >>> check_strength(['abc', 'XYZ123aA', '123', 'ABCabc123']) \\"Strong\\" >>> check_strength([]) \\"Weak\\" >>> check_strength(['aA1']) \\"Strong\\" >>> check_strength(['abc']) \\"Weak\\"","solution":"def check_strength(sequences): for sequence in sequences: has_upper = any(char.isupper() for char in sequence) has_lower = any(char.islower() for char in sequence) has_digit = any(char.isdigit() for char in sequence) if has_upper and has_lower and has_digit: return \\"Strong\\" return \\"Weak\\""},{"question":"def water_distribution(T: int, scenarios: List[Tuple[int, int, int]]) -> List[str]: Simulate the water distribution system in a research facility. Args: T (int): The number of test cases. scenarios (List[Tuple[int, int, int]]): A list of tuples where each tuple consists of: - N (int): The number of chambers. - W (int): The initial amount of water in the first chamber. - F (int): The flow rate factor (percentage of water retained in each chamber). Returns: List[str]: For each test case, a space-separated string representing the amount of water in each chamber. Example: >>> water_distribution(2, [(5, 100, 50), (3, 300, 25)]) [\\"100 50 25 12 6\\", \\"300 225 168\\"]","solution":"def water_distribution(T, scenarios): results = [] for scenario in scenarios: N, W, F = scenario chambers = [0] * N chambers[0] = W for i in range(1, N): chambers[i] = chambers[i-1] * (100 - F) / 100 results.append(\\" \\".join(map(lambda x: str(int(x)), chambers))) return results"},{"question":"def caesar_cipher(k: int, s: str) -> str: Encrypts the given string using the Caesar cipher with a shift of k. Parameters: k (int): The shift value (0 <= k <= 25). s (str): The plaintext message consisting of uppercase English letters only. Returns: str: The encrypted message. >>> caesar_cipher(3, \\"HELLO\\") \\"KHOOR\\" >>> caesar_cipher(1, \\"ZEBRA\\") \\"AFCSB\\"","solution":"def caesar_cipher(k, s): Encrypts the given string using the Caesar cipher with a shift of k. Parameters: k (int): The shift value (0 <= k <= 25). s (str): The plaintext message consisting of uppercase English letters only. Returns: str: The encrypted message. encrypted_message = [] for char in s: # Calculate the new position for the character new_pos = (ord(char) - ord('A') + k) % 26 + ord('A') encrypted_message.append(chr(new_pos)) return ''.join(encrypted_message)"},{"question":"from collections import Counter, defaultdict def min_window(s: str, t: str) -> str: Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\"\\". Example 1: >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" Example 2: >>> min_window(\\"a\\", \\"a\\") \\"a\\" Example 3: >>> min_window(\\"a\\", \\"aa\\") \\"\\" Example 4: >>> min_window(\\"abc\\", \\"b\\") \\"b\\"","solution":"from collections import Counter, defaultdict def min_window(s, t): Returns the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\"\\". if not s or not t: return \\"\\" t_freq = Counter(t) required = len(t_freq) left = right = 0 formed = 0 window_counts = defaultdict(int) min_len = float(\\"inf\\") min_window_start = 0 while right < len(s): window_counts[s[right]] += 1 if s[right] in t_freq and window_counts[s[right]] == t_freq[s[right]]: formed += 1 while left <= right and formed == required: if right - left + 1 < min_len: min_len = right - left + 1 min_window_start = left window_counts[s[left]] -= 1 if s[left] in t_freq and window_counts[s[left]] < t_freq[s[left]]: formed -= 1 left += 1 right += 1 if min_len == float(\\"inf\\"): return \\"\\" else: return s[min_window_start:min_window_start + min_len]"},{"question":"def min_swaps(balls, pivot): Returns the minimum number of swaps required to arrange the balls so that all balls with weight less than the pivot are on the left hand and all balls with weight equal to or greater than the pivot are on the right hand. >>> min_swaps([(\\"red\\", 1), (\\"blue\\", 3), (\\"green\\", 2), (\\"yellow\\", 4)], 3) 1 >>> min_swaps([(\\"red\\", 5), (\\"blue\\", 1), (\\"green\\", 8), (\\"yellow\\", 7), (\\"pink\\", 2), (\\"black\\", 3)], 4) 2 # Test cases def test_min_swaps(): balls_1 = [(\\"red\\", 1), (\\"blue\\", 3), (\\"green\\", 2), (\\"yellow\\", 4)] pivot_1 = 3 assert min_swaps(balls_1, pivot_1) == 1 balls_2 = [(\\"red\\", 5), (\\"blue\\", 1), (\\"green\\", 8), (\\"yellow\\", 7), (\\"pink\\", 2), (\\"black\\", 3)] pivot_2 = 4 assert min_swaps(balls_2, pivot_2) == 2 balls_3 = [(\\"red\\", 1), (\\"green\\", 2), (\\"blue\\", 3), (\\"yellow\\", 4)] pivot_3 = 3 assert min_swaps(balls_3, pivot_3) == 0 balls_4 = [(\\"red\\", 5), (\\"blue\\", 7), (\\"green\\", 8)] pivot_4 = 4 assert min_swaps(balls_4, pivot_4) == 0 balls_5 = [(\\"red\\", 1), (\\"blue\\", 2), (\\"green\\", 3)] pivot_5 = 4 assert min_swaps(balls_5, pivot_5) == 0 balls_6 = [(\\"red\\", 4), (\\"blue\\", 4), (\\"green\\", 4)] pivot_6 = 4 assert min_swaps(balls_6, pivot_6) == 0","solution":"def min_swaps(balls, pivot): Returns the minimum number of swaps required to arrange the balls so that all balls with weight less than the pivot are on the left hand and all balls with weight equal to or greater than the pivot are on the right hand. left = 0 right = len(balls) - 1 swaps = 0 while left < right: # Find the first ball that is on the wrong side while left < len(balls) and balls[left][1] < pivot: left += 1 while right >= 0 and balls[right][1] >= pivot: right -= 1 if left < right: # Swap the balls balls[left], balls[right] = balls[right], balls[left] swaps += 1 left += 1 right -= 1 return swaps"},{"question":"from typing import List, Tuple def get_top_k_effective_pills(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[List[List[int]]]: Find the K most effective pills for several test cases. Each test case contains pills, ingredients, and their respective effectiveness scores. Args: test_cases (List[Tuple[int, int, List[List[int]]]]): A list where each element is a tuple. Each tuple contains: - P (int): Number of pills. - K (int): Number of top pills to return. - pills (List[List[int]]): A list of pills, where each pill is a list of integers representing the effectiveness scores of the ingredients. Returns: List[List[List[int]]]: A list where each element is a list of the K most effective pills for that test case. >>> get_top_k_effective_pills([(5, 2, [[10, 20, 30], [100, 200], [1, 2, 3, 4], [5, 5, 5], [50, 50]])]) [[[100, 200], [50, 50]]] >>> get_top_k_effective_pills([(3, 1, [[30, 30], [10, 20, 30], [40, 40]])]) [[[40, 40]]]","solution":"def get_top_k_effective_pills(test_cases): results = [] for test_case in test_cases: P, K, pills = test_case pill_effectiveness = [] for pill in pills: effectiveness_score = sum(pill) pill_effectiveness.append((effectiveness_score, pill)) # Sort by effectiveness_score (descending) and by pill list (lexicographical) pill_effectiveness.sort(key=lambda x: (-x[0], x[1])) # Append the K most effective pills to the results top_k_pills = [pill for _, pill in pill_effectiveness[:K]] results.append(top_k_pills) return results"},{"question":"from typing import List def count_forests(m: int, n: int, grid: List[List[int]]) -> int: Returns the number of distinct forests in the grid. >>> count_forests(4, 5, [ ... [1, 1, 0, 0, 0], ... [0, 1, 0, 1, 1], ... [1, 0, 0, 1, 0], ... [0, 0, 0, 0, 1] ... ]) == 4 >>> count_forests(3, 3, [ ... [0, 0, 0], ... [0, 1, 1], ... [1, 1, 0] ... ]) == 1 >>> count_forests(2, 2, [ ... [0, 0], ... [0, 0] ... ]) == 0 >>> count_forests(1, 1, [ ... [1] ... ]) == 1 >>> count_forests(2, 2, [ ... [1, 0], ... [0, 1] ... ]) == 2","solution":"def count_forests(m, n, grid): Returns the number of distinct forests in the grid. def dfs(i, j): if 0 <= i < m and 0 <= j < n and grid[i][j] == 1: grid[i][j] = 0 dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) forests = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: dfs(i, j) forests += 1 return forests"},{"question":"def findMissingRanges(nums: List[int], upper: int) -> List[str]: Identify missing ranges in the list from 0 to upper inclusive and return them in a specific format. >>> findMissingRanges([0, 1, 3, 50, 75], 99) [\\"2\\", \\"4->49\\", \\"51->74\\", \\"76->99\\"] >>> findMissingRanges([], 5) [\\"0->5\\"]","solution":"def findMissingRanges(nums, upper): Returns the list of missing ranges in the list \`nums\` from 0 to \`upper\`. def formatRange(low, high): if low == high: return str(low) else: return f\\"{low}->{high}\\" result = [] prev = -1 nums.append(upper + 1) # Add an artificial boundary to handle upper range for num in nums: if num == prev + 2: result.append(formatRange(prev + 1, prev + 1)) elif num > prev + 2: result.append(formatRange(prev + 1, num - 1)) prev = num return result"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: Given a list of integers and a target sum, returns a tuple of the first two numbers from the list that add up to the target sum. If no such pair exists, returns an empty tuple. >>> find_pair_with_sum([3, 5, -4, 8, 11, 1, -1, 6], 10) (11, -1) >>> find_pair_with_sum([1, 2, 3], 7) () >>> find_pair_with_sum([3, 5, 4, 7, 8, 2, -1], 9) (5, 4) >>> find_pair_with_sum([], 5) () >>> find_pair_with_sum([1], 2) () >>> find_pair_with_sum([-3, 4, 3, 90], 0) (-3, 3)","solution":"def find_pair_with_sum(nums, target): Given a list of integers and a target sum, returns a tuple of the first two numbers from the list that add up to the target sum. If no such pair exists, returns an empty tuple. :param nums: List of integers :param target: Integer target sum :return: Tuple of two integers or empty tuple seen = {} for num in nums: complement = target - num if complement in seen: return (complement, num) seen[num] = True return ()"},{"question":"def min_changes_subsequence(s1: str, s2: str) -> int: Returns the minimum number of positions at which characters in s1 need to be changed to make it a subsequence of s2. Parameters: s1 (str): string of lowercase alphabetic characters. s2 (str): string of lowercase alphabetic characters of the same length as s1. Returns: int: minimum number of characters to change. Examples: >>> min_changes_subsequence(\\"abc\\", \\"abgfc\\") 0 >>> min_changes_subsequence(\\"axc\\", \\"abgfc\\") 1","solution":"def min_changes_subsequence(s1, s2): Returns the minimum number of positions at which characters in s1 need to be changed to make it a subsequence of s2. m, n = len(s1), len(s2) # Early exit if s1 is already a subsequence of s2 def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) if is_subsequence(s1, s2): return 0 # Prepare a matrix for dp where dp[i][j] means minimum changes to make s1[:i] a subsequence of s2[:j] dp = [[float('inf')] * (n + 1) for _ in range(m + 1)] dp[0][0] = 0 # Empty string is always subsequence with 0 changes for i in range(m + 1): for j in range(n + 1): if i > 0: dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1) if i > 0 and j > 0: if s1[i - 1] == s2[j - 1]: dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]) else: dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Given an array of unique integers, return all possible subsets (the power set) of the array. The solution should not include duplicate subsets. You can return the subsets in any order. >>> subsets([1,2,3]) [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]] >>> subsets([0]) [[] , [0]] >>> subsets([1,2]) [[], [1], [2], [1,2]]","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of the input list \`nums\`. result = [[]] for num in nums: result += [curr + [num] for curr in result] return result"},{"question":"def is_beautiful_necklace(N: str) -> str: Determines if the necklace is beautiful based on the criteria that there must be at least one bead color that appears more than once. Parameters: N (str): A string representing the beads in the necklace. Returns: str: \\"YES\\" if the necklace is beautiful, otherwise \\"NO\\". >>> is_beautiful_necklace(\\"ABCA\\") \\"YES\\" >>> is_beautiful_necklace(\\"XYZ\\") \\"NO\\" >>> is_beautiful_necklace(\\"AAB\\") \\"YES\\" >>> is_beautiful_necklace(\\"ZZ\\") \\"YES\\" >>> is_beautiful_necklace(\\"ABCD\\") \\"NO\\" >>> is_beautiful_necklace(\\"ABCDE\\") \\"NO\\"","solution":"def is_beautiful_necklace(N): Determines if the necklace is beautiful based on the criteria that there must be at least one bead color that appears more than once. Parameters: N (str): A string representing the beads in the necklace. Returns: str: \\"YES\\" if the necklace is beautiful, otherwise \\"NO\\". bead_count = {} for bead in N: if bead in bead_count: return \\"YES\\" bead_count[bead] = 1 return \\"NO\\""},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Returns a list such that, for each day in the input, it tells how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([70, 71, 72, 73, 74, 75]) == [1, 1, 1, 1, 1, 0] >>> daily_temperatures([75, 74, 73, 72, 71, 70]) == [0, 0, 0, 0, 0, 0] >>> daily_temperatures([70, 70, 70, 70]) == [0, 0, 0, 0] >>> daily_temperatures([70]) == [0] >>> daily_temperatures([50, 40, 30, 60, 90, 80, 70, 100]) == [3, 2, 1, 1, 3, 2, 1, 0]","solution":"def daily_temperatures(temperatures): Returns a list such that, for each day in the input, it tells how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. n = len(temperatures) answer = [0] * n stack = [] # This will store pairs of (temperature, index) for i in range(n): while stack and temperatures[i] > stack[-1][0]: temp, index = stack.pop() answer[index] = i - index stack.append((temperatures[i], i)) return answer"},{"question":"def find_words_with_prefix(words: List[str], prefix: str) -> Union[List[str], str]: Returns all strings in the list \`words\` that start with the given \`prefix\`. The result is sorted in lexicographical order. If no strings match the prefix, returns \\"No matches found\\". If the provided list is empty, returns \\"Empty list provided\\". >>> find_words_with_prefix([\\"apple\\", \\"application\\", \\"apricot\\", \\"banana\\", \\"apply\\"], \\"app\\") [\\"apple\\", \\"application\\", \\"apply\\"] >>> find_words_with_prefix([\\"car\\", \\"card\\", \\"cart\\", \\"cat\\", \\"dog\\"], \\"ca\\") [\\"car\\", \\"card\\", \\"cart\\", \\"cat\\"] >>> find_words_with_prefix([\\"car\\", \\"bike\\", \\"train\\"], \\"bo\\") \\"No matches found\\" >>> find_words_with_prefix([], \\"pre\\") \\"Empty list provided\\"","solution":"def find_words_with_prefix(words, prefix): Returns all strings in the list \`words\` that start with the given \`prefix\`. The result is sorted in lexicographical order. If no strings match the prefix, returns \\"No matches found\\". If the provided list is empty, returns \\"Empty list provided\\". if not words: return \\"Empty list provided\\" matching_words = [word for word in words if word.startswith(prefix)] if not matching_words: return \\"No matches found\\" return sorted(matching_words)"},{"question":"from typing import List def count_unique_chars(s: str, k: int) -> int: Returns the number of unique characters in the string s such that each character appears at least k times in s. >>> count_unique_chars(\\"aabbcc\\", 2) 3 >>> count_unique_chars(\\"aaaaabbbbccccd\\", 3) 3 >>> count_unique_chars(\\"aaabbcc\\", 4) 0 >>> count_unique_chars(\\"abcdefg\\", 1) 7 >>> count_unique_chars(\\"aabbccddeeffgghh\\", 3) 0 >>> count_unique_chars(\\"eeeeffff\\", 3) 2 >>> count_unique_chars(\\"a\\" * 100000, 50000) 1","solution":"def count_unique_chars(s, k): Returns the number of unique characters in the string s such that each character appears at least k times in s. :param s: A string containing only lowercase English letters :param k: An integer representing the minimum number of occurrences :return: An integer representing the number of unique characters meeting the criterion from collections import Counter # Count the frequency of each character in the string counter = Counter(s) # Count the number of characters that appear at least k times count = sum(1 for char in counter if counter[char] >= k) return count"},{"question":"def two_sum_exists(arr, target): Determines if there are two distinct elements in the array whose sum equals the target integer. :param arr: List of integers :param target: Target integer to find the sum :return: \\"YES\\" if the sum exists, otherwise \\"NO\\" >>> two_sum_exists([2, 7, 11, 15, 1], 9) == \\"YES\\" >>> two_sum_exists([1, 2, 3, 4], 8) == \\"NO\\" >>> two_sum_exists([-3, 4, 3, 90], 0) == \\"YES\\" >>> two_sum_exists([10**9, 2*10**9, 3*10**9], 2*10**9 + 10**9) == \\"YES\\" >>> two_sum_exists([5, 5], 10) == \\"YES\\" >>> two_sum_exists([1, 2, 3], 6) == \\"NO\\"","solution":"def two_sum_exists(arr, target): Determines if there are two distinct elements in the array whose sum equals the target integer. :param arr: List of integers :param target: Target integer to find the sum :return: \\"YES\\" if the sum exists, otherwise \\"NO\\" seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def max_container_area(elevations): Returns the area of the largest container that can be formed using any two elevations as the boundaries. Parameters: elevations (list of int): List of integers representing the elevations of the landscape points. Returns: int: The area of the largest container. pass def test_max_container_area_sample(): assert max_container_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 def test_max_container_area_minimum(): assert max_container_area([1, 2]) == 1 def test_max_container_area_multiple_same_height(): assert max_container_area([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 9 def test_max_container_area_decreasing(): assert max_container_area([5, 4, 3, 2, 1]) == 6 def test_max_container_area_increasing(): assert max_container_area([1, 2, 3, 4, 5]) == 6","solution":"def max_container_area(elevations): Returns the area of the largest container that can be formed using any two elevations as the boundaries. Parameters: elevations (list of int): List of integers representing the elevations of the landscape points. Returns: int: The area of the largest container. left, right = 0, len(elevations) - 1 max_area = 0 while left < right: height = min(elevations[left], elevations[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) # Move the pointer pointing to the shorter line to try and find a taller boundary if elevations[left] < elevations[right]: left += 1 else: right -= 1 return max_area"},{"question":"def single_number(nums: List[int]) -> int: Returns the integer that appears only once in the list, where each integer appears exactly twice except for one. >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1, 1, 2, 2, 3, 3, 4]) 4","solution":"def single_number(nums): Returns the integer that appears only once in the list, where each integer appears exactly twice except for one. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def find_smallest_subarray_to_sort(arr): This function will find the smallest subarray which, when sorted, would make the whole array sorted in non-decreasing order. pass def process_test_cases(test_cases): Process multiple test cases and return the results for each test case in the specified format. pass # Example cases def test_case_1(): test_cases = [ (9, [1, 2, 6, 5, 4, 7, 8, 9, 10]), (4, [1, 3, 2, 4]), (5, [1, 2, 3, 4, 5]) ] result = process_test_cases(test_cases) assert result == [(3, 5), (2, 3), 0] def test_case_2(): test_cases = [ (6, [1, 2, 3, 6, 5, 4]), (6, [1, 2, 6, 4, 5, 3]), (7, [10, 11, 12, 5, 6, 7, 8]) ] result = process_test_cases(test_cases) assert result == [(4, 6), (3, 6), (1, 7)] def test_case_3(): test_cases = [ (3, [3, 2, 1]), (6, [2, 6, 4, 8, 10, 9]), (5, [1, 2, 3, 3, 3]) ] result = process_test_cases(test_cases) assert result == [(1, 3), (2, 6), 0]","solution":"def find_smallest_subarray_to_sort(arr): This function will find the smallest subarray which, when sorted, would make the whole array sorted in non-decreasing order. n = len(arr) left, right = 0, n - 1 # Find the first element which is out of order from the left while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # If the entire array is already sorted if left == n - 1: return 0 # Find the first element which is out of order from the right while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Find the minimum and maximum in the subarray arr[left:right+1] min_val = min(arr[left:right+1]) max_val = max(arr[left:right+1]) # Extend the left boundary to include any number greater than min_val while left > 0 and arr[left - 1] > min_val: left -= 1 # Extend the right boundary to include any number less than max_val while right < n - 1 and arr[right + 1] < max_val: right += 1 return left + 1, right + 1 def process_test_cases(test_cases): Process multiple test cases and return the results for each test case in the specified format. results = [] for case in test_cases: n, array = case result = find_smallest_subarray_to_sort(array) results.append(result) return results"},{"question":"def fibonacci(n: int) -> int: Create a function that takes a non-negative integer n as input and returns the n-th element of the Fibonacci sequence. The Fibonacci sequence is defined as follows: F(0) = 0 F(1) = 1 Fn = F(n-1) + F(n-2) for n >= 2 >>> fibonacci(0) 0 >>> fibonacci(7) 13 def test_fibonacci_base_cases(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 def test_fibonacci_small_numbers(): assert fibonacci(2) == 1 assert fibonacci(3) == 2 assert fibonacci(4) == 3 assert fibonacci(5) == 5 def test_fibonacci_larger_numbers(): assert fibonacci(6) == 8 assert fibonacci(7) == 13 assert fibonacci(10) == 55 def test_fibonacci_edge_case(): assert fibonacci(20) == 6765","solution":"def fibonacci(n): Returns the n-th element of the Fibonacci sequence. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def roman_to_integer(s: str) -> int: Convert a Roman numeral string into its integer equivalent. The input string is guaranteed to be a valid Roman numeral. >>> roman_to_integer('IX') 9 >>> roman_to_integer('MCMXCIV') 1994 >>> roman_to_integer('III') 3 >>> roman_to_integer('LVIII') 58 >>> roman_to_integer('MMCDXXI') 2421 from solution import roman_to_integer def test_single_symbols(): assert roman_to_integer('I') == 1 assert roman_to_integer('V') == 5 assert roman_to_integer('X') == 10 assert roman_to_integer('L') == 50 assert roman_to_integer('C') == 100 assert roman_to_integer('D') == 500 assert roman_to_integer('M') == 1000 def test_simple_combinations(): assert roman_to_integer('II') == 2 assert roman_to_integer('III') == 3 assert roman_to_integer('IV') == 4 assert roman_to_integer('VI') == 6 assert roman_to_integer('VII') == 7 assert roman_to_integer('VIII') == 8 def test_complex_combinations(): assert roman_to_integer('IX') == 9 assert roman_to_integer('XL') == 40 assert roman_to_integer('XC') == 90 assert roman_to_integer('CD') == 400 assert roman_to_integer('CM') == 900 def test_mixed_numerals(): assert roman_to_integer('XXVII') == 27 assert roman_to_integer('XLII') == 42 assert roman_to_integer('LXX') == 70 assert roman_to_integer('XCIX') == 99 assert roman_to_integer('CXXIII') == 123 assert roman_to_integer('CDXLIV') == 444 assert roman_to_integer('DCCCXC') == 890 assert roman_to_integer('MCMXCIV') == 1994 def test_edge_cases(): assert roman_to_integer('MMMCMXCIV') == 3994 assert roman_to_integer('MMMM') == 4000 # Edge case for large numbers","solution":"def roman_to_integer(s): Converts a Roman numeral string into its integer equivalent. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } integer_value = 0 previous_value = 0 for char in reversed(s): current_value = roman_to_int[char] if current_value < previous_value: integer_value -= current_value else: integer_value += current_value previous_value = current_value return integer_value"},{"question":"def is_prime(n: int) -> bool: Checks whether the given integer n is a prime number. Parameters: n (int): the integer to check, should be >= 2 Returns: bool: True if n is a prime number, False otherwise Examples: >>> is_prime(11) True >>> is_prime(4) False","solution":"def is_prime(n): Checks whether the given integer n is a prime number. Parameters: n (int): the integer to check, should be >= 2 Returns: bool: True if n is a prime number, False otherwise if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"def double_characters(s: str) -> str: Returns a new string where each character in the input string 's' is repeated twice. >>> double_characters(\\"abc\\") 'aabbcc' >>> double_characters(\\"123!\\") '112233!!' >>> double_characters(\\"hello world!\\") 'hheelllloo wwoorrlldd!!' >>> double_characters(\\"A B C\\") 'AA BB CC' >>> double_characters(\\"\\") '' >>> double_characters(\\"#\\") '' pass","solution":"def double_characters(s): Returns a new string where each character in the input string 's' is repeated twice. return ''.join([char * 2 for char in s])"},{"question":"from typing import List def letter_combinations(digits: str) -> List[str]: Returns all possible letter combinations that the number could represent using the mapping on a traditional phone keypad. >>> sorted(letter_combinations(\\"23\\")) ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> letter_combinations(\\"2\\") ['a', 'b', 'c'] >>> letter_combinations(\\"\\") [] >>> sorted(letter_combinations(\\"79\\")) ['pw', 'px', 'py', 'pz', 'qw', 'qx', 'qy', 'qz', 'rw', 'rx', 'ry', 'rz', 'sw', 'sx', 'sy', 'sz'] # Your code here","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent. if not digits: return [] phone = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"from itertools import combinations def print_combinations(elements, k): Given a list of integers 'elements' and an integer 'k', prints all combinations of size 'k' from the list in lexicographic order. >>> print_combinations([2, 4, 6], 2) (2, 4) (2, 6) (4, 6) >>> print_combinations([1], 1) (1,) >>> print_combinations([7, 9, 8], 3) (7, 9, 8) >>> print_combinations([1, 2, 3, 4, 5], 3) (1, 2, 3) (1, 2, 4) (1, 2, 5) (1, 3, 4) (1, 3, 5) (1, 4, 5) (2, 3, 4) (2, 3, 5) (2, 4, 5) (3, 4, 5) >>> print_combinations([10, 20, 30, 40], 1) (10,) (20,) (30,) (40,) >>> print_combinations([5, 10, 15, 20], 4) (5, 10, 15, 20)","solution":"from itertools import combinations def print_combinations(elements, k): Given a list of integers 'elements' and an integer 'k', prints all combinations of size 'k' from the list in lexicographic order. comb = combinations(elements, k) for c in comb: print(c)"},{"question":"def trap_rain_water(arr: List[int]) -> int: Calculate the total volume of water trapped after a rain. Params: arr - list of integers representing the heights of buildings. Returns: int - total volume of water trapped. >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rain_water([1,2,3,4,5]) 0","solution":"def trap_rain_water(arr): Calculate the total volume of water trapped after a rain. Params: arr - list of integers representing the heights of buildings. Returns: int - total volume of water trapped. if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - arr[i] return total_water"},{"question":"class WordDictionary: def __init__(self): Initialize your data structure here. def addWord(self, word: str): Adds a word into the data structure. >>> dict = WordDictionary() >>> dict.addWord(\\"bad\\") >>> dict.searchWord(\\"bad\\") True def searchWord(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. >>> dict = WordDictionary() >>> dict.addWord(\\"bad\\") >>> dict.searchWord(\\"pad\\") False >>> dict.searchWord(\\".ad\\") True >>> dict.searchWord(\\"b..\\") True","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word): self.words.append(word) def searchWord(self, word): from re import fullmatch for w in self.words: if fullmatch(word, w): return True return False"},{"question":"def find_pairs_with_sum(arr: List[int], n: int) -> List[List[int]]: Finds all pairs in the array whose sum is equal to 'n'. Args: arr: List of integers. n: Integer sum to find pairs for. Returns: List of lists, where each list contains two integers that add up to 'n'. pass # Unit Tests def test_find_pairs_with_sum(): assert find_pairs_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == [[1, 9], [2, 8], [3, 7], [4, 6]] assert find_pairs_with_sum([5, 5, 3, 9], 10) == [[5, 5]] assert find_pairs_with_sum([], 5) == [] assert find_pairs_with_sum([1, 2, 3, 7, 8, -2, 4], 5) == [[-2, 7], [1, 4], [2, 3]] assert find_pairs_with_sum([2, 4, 6, 8, 10], 12) == [[2, 10], [4, 8]] assert find_pairs_with_sum([1, 1, 2, 3, 4, 4, 5, 6, 7], 8) == [[1, 7], [2, 6], [3, 5], [4, 4]] if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def find_pairs_with_sum(arr, n): Finds all pairs in the array whose sum is equal to 'n'. Args: arr: List of integers. n: Integer sum to find pairs for. Returns: List of lists, where each list contains two integers that add up to 'n'. pairs = [] seen = set() for num in arr: complement = n - num if complement in seen: pairs.append(sorted([num, complement])) seen.add(num) pairs.sort() return pairs"},{"question":"def move_zeroes(nums: List[int]) -> None: Moves all zeroes in the list to the end while maintaining the order of non-zero elements. This must be done in-place without making a copy of the array. >>> nums = [0, 1, 0, 3, 12] >>> move_zeroes(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [0, 0, 1] >>> move_zeroes(nums) >>> nums [1, 0, 0]","solution":"def move_zeroes(nums): Moves all zeroes in the list to the end while maintaining the order of non-zero elements. :param nums: List of integers :return: None (modifies the list in-place) last_non_zero_found_at = 0 # Move all non-zero numbers to the front for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # Fill the remaining positions with zeroes for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0"},{"question":"def can_be_palindrome_by_removing_one_char(s: str) -> bool: Determines if a string can be converted to a palindrome by removing exactly one character. def is_palindrome(x): return x == x[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try removing one character either from the start or end removed_left = s[left+1:right+1] removed_right = s[left:right] return is_palindrome(removed_left) or is_palindrome(removed_right) left += 1 right -= 1 return False # The string is already a palindrome def check_remove_one_char_palindrome(s: str) -> str: Check if it is possible to convert the given string to a palindrome by removing exactly one character. >>> check_remove_one_char_palindrome(\\"abca\\") 'YES' >>> check_remove_one_char_palindrome(\\"abc\\") 'NO' # Unit tests import pytest from solution import check_remove_one_char_palindrome def test_example_case_1(): assert check_remove_one_char_palindrome(\\"abca\\") == \\"YES\\" def test_example_case_2(): assert check_remove_one_char_palindrome(\\"abc\\") == \\"NO\\" def test_full_palindrome(): assert check_remove_one_char_palindrome(\\"racecar\\") == \\"NO\\" def test_single_char(): assert check_remove_one_char_palindrome(\\"a\\") == \\"NO\\" def test_almost_palindrome(): assert check_remove_one_char_palindrome(\\"radcar\\") == \\"YES\\" def test_two_characters(): assert check_remove_one_char_palindrome(\\"aa\\") == \\"NO\\" assert check_remove_one_char_palindrome(\\"ab\\") == \\"YES\\" def test_case_with_no_palindrome_formation(): assert check_remove_one_char_palindrome(\\"abcdef\\") == \\"NO\\" @pytest.mark.parametrize(\\"s, expected\\", [ (\\"abcba\\", \\"NO\\"), # Already a palindrome (\\"abcdba\\", \\"YES\\"), # Remove 'c' or 'b' (\\"abccba\\", \\"NO\\"), # Already a palindrome ]) def test_parametrized_cases(s, expected): assert check_remove_one_char_palindrome(s) == expected","solution":"def can_be_palindrome_by_removing_one_char(s): Determines if a string can be converted to a palindrome by removing exactly one character. def is_palindrome(x): return x == x[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try removing one character either from the start or end removed_left = s[left+1:right+1] removed_right = s[left:right] return is_palindrome(removed_left) or is_palindrome(removed_right) left += 1 right -= 1 return False # The string is already a palindrome # Function to get the YES/NO response def check_remove_one_char_palindrome(s): return \\"YES\\" if can_be_palindrome_by_removing_one_char(s) else \\"NO\\""},{"question":"def has_increasing_triplet(arr): Function to determine if there exists a triplet (i, j, k) such that 1 ≤ i < j < k ≤ N and ai < aj < ak. # Your code here def process_test_cases(test_cases): Function to process multiple test cases and determine if there exists an increasing triplet for each case. results = [] for case in test_cases: N, arr = case result = has_increasing_triplet(arr) results.append(result) return results # Unit Tests def test_has_increasing_triplet(): assert has_increasing_triplet([1, 2, 3, 4, 5, 6]) == \\"yes\\" assert has_increasing_triplet([6, 5, 4, 3, 2, 1]) == \\"no\\" assert has_increasing_triplet([1, 3, 2, 4, 6, 5]) == \\"yes\\" assert has_increasing_triplet([1, 1, 1, 1, 1]) == \\"no\\" assert has_increasing_triplet([-1, 0, 1]) == \\"yes\\" assert has_increasing_triplet([1, 0, -1]) == \\"no\\" assert has_increasing_triplet([5, 6, 7, 1, 2, 3]) == \\"yes\\" assert has_increasing_triplet([10, 5, 4, 1, 3, 2]) == \\"no\\" def test_process_test_cases(): assert process_test_cases([(6, [1, 2, 3, 4, 5, 6]), (6, [6, 5, 4, 3, 2, 1]), (6, [1, 3, 2, 4, 6, 5])]) == [\\"yes\\", \\"no\\", \\"yes\\"] assert process_test_cases([(3, [1, 1, 1]), (3, [1, -1, 0, 1])]) == [\\"no\\", \\"yes\\"] assert process_test_cases([(3, [-1, 0, 1])]) == [\\"yes\\"]","solution":"def has_increasing_triplet(arr): Function to determine if there exists a triplet (i, j, k) such that 1 ≤ i < j < k ≤ N and ai < aj < ak. first = second = float('inf') for num in arr: if num <= first: first = num elif num <= second: second = num else: return \\"yes\\" return \\"no\\" def process_test_cases(test_cases): results = [] for case in test_cases: N, arr = case result = has_increasing_triplet(arr) results.append(result) return results"},{"question":"from typing import List, Tuple def puzzle_operations(n: int, operations: List[Tuple[int, ...]]) -> List[int]: Simulate operations on an array and compute results for given queries. Args: n (int): The length of the array. operations (List[Tuple[int, ...]]): A list of operations to be performed on the array. Returns: List[int]: The results of the \\"Compute maximum\\" operations. Example: >>> puzzle_operations(5, [(1, 1, 3, 5), (2, 1, 3), (1, 2, 5, -2), (2, 1, 5), (1, 3, 3, 4)]) [5, 5]","solution":"def puzzle_operations(n, operations): arr = [0] * n results = [] for operation in operations: if operation[0] == 1: l, r, x = operation[1] - 1, operation[2] - 1, operation[3] for i in range(l, r + 1): arr[i] += x elif operation[0] == 2: l, r = operation[1] - 1, operation[2] - 1 results.append(max(arr[l:r + 1])) return results"},{"question":"def max_square_plots(length: int, width: int) -> int: Returns the maximum side length of each square plot that can fit into the rectangular field of given length and width without any land remaining. >>> max_square_plots(6, 9) 3 >>> max_square_plots(8, 12) 4 >>> max_square_plots(13, 13) 13 >>> max_square_plots(14, 7) 7 >>> max_square_plots(35, 14) 7 >>> max_square_plots(1000000, 500000) 500000 >>> max_square_plots(982451653, 57885161) 1 >>> max_square_plots(1, 1) 1 >>> max_square_plots(2, 3) 1","solution":"def max_square_plots(length, width): Returns the maximum side length of each square plot that can fit into the rectangular field of given length and width without any land remaining. def gcd(a, b): while b: a, b = b, a % b return a return gcd(length, width)"},{"question":"from typing import List, Tuple def max_teams(N: int, conflicts: List[Tuple[int, int]]) -> int: Determine the maximum number of non-conflicting teams that can be formed from N participants. Args: N (int): The number of participants. conflicts (List[Tuple[int, int]]): A list of tuples representing conflicting pairs of participants. Returns: int: The maximum number of non-conflicting teams that can be formed. >>> max_teams(4, []) 6 >>> max_teams(4, [(1,2), (3,4)]) 4 >>> max_teams(4, [(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)]) 0 >>> max_teams(2, [(1,2)]) 0 >>> max_teams(1, []) 0 >>> max_teams(1000, [(i, i+1) for i in range(1, 1000, 2)]) 499500","solution":"def max_teams(N, conflicts): from itertools import combinations # Initialize conflict set for quick lookup conflict_set = set(conflicts) # Generate all possible teams possible_teams = list(combinations(range(1, N+1), 2)) # Filter out conflicting teams non_conflicting_teams = [team for team in possible_teams if (team[0], team[1]) not in conflict_set and (team[1], team[0]) not in conflict_set] return len(non_conflicting_teams)"},{"question":"def is_valid_shuffle(str1: str, str2: str, shuff_str: str) -> bool: Check if shuff_str is a valid shuffle of str1 and str2. >>> is_valid_shuffle(\\"abc\\", \\"def\\", \\"adbcef\\") # True >>> is_valid_shuffle(\\"abc\\", \\"def\\", \\"abdecf\\") # True >>> is_valid_shuffle(\\"abc\\", \\"def\\", \\"abcfed\\") # False >>> is_valid_shuffle(\\"123\\", \\"456\\", \\"142536\\") # True >>> is_valid_shuffle(\\"123\\", \\"456\\", \\"123465\\") # False","solution":"def is_valid_shuffle(str1: str, str2: str, shuff_str: str) -> bool: Check if shuff_str is a valid shuffle of str1 and str2. # Base case checks if len(str1) + len(str2) != len(shuff_str): return False i = j = k = 0 while k < len(shuff_str): if i < len(str1) and str1[i] == shuff_str[k]: i += 1 elif j < len(str2) and str2[j] == shuff_str[k]: j += 1 else: return False k += 1 return i == len(str1) and j == len(str2)"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in an array of integers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the array. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def search(root, value): Searches for a value in the BST and returns True if the value exists, otherwise returns False. >>> root = Node(10) >>> root = insert(root, 5) >>> root = insert(root, 15) >>> search(root, 10) True >>> search(root, 7) False pass def insert(root, value): Inserts a new value into the BST and returns the root of the modified tree. >>> root = None >>> root = insert(root, 10) >>> root.value 10 >>> root = insert(root, 5) >>> root.left.value 5 >>> root = insert(root, 15) >>> root.right.value 15 pass","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def search(root, value): Searches for a value in the BST. if root is None: return False if root.value == value: return True elif value < root.value: return search(root.left, value) else: return search(root.right, value) def insert(root, value): Inserts a value into the BST. if root is None: return Node(value) if value < root.value: root.left = insert(root.left, value) else: root.right = insert(root.right, value) return root"},{"question":"def validate_login_ids(test_cases: List[str]) -> List[str]: Given a list of login IDs, validate each one according to specified rules. Parameters: test_cases (list of str): List of login IDs to be validated. Returns: list of str: List of results (\\"VALID\\" or \\"INVALID\\") for each login ID. >>> validate_login_ids([\\"AB1234\\", \\"XY0987\\", \\"A12345\\", \\"ABCD56\\"]) [\\"VALID\\", \\"VALID\\", \\"INVALID\\", \\"INVALID\\"] >>> validate_login_ids([\\"ZZ4321\\", \\"TS7865\\", \\"AA1111\\", \\"BC9999\\"]) [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"VALID\\"] >>> validate_login_ids([\\"AA123\\", \\"AB12C3\\", \\"123456\\", \\"XYabcd\\"]) [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] >>> validate_login_ids([\\"AA12\\", \\"Abs123\\", \\"ZZZ567\\", \\"Y67789\\"]) [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] >>> validate_login_ids([\\"AB0000\\", \\"CD1111\\", \\"EF2222\\", \\"GH3333\\"]) [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"VALID\\"] >>> validate_login_ids([\\"A12345\\", \\"Aa1234\\", \\"AB123!\\", \\"@B1234\\"]) [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"]","solution":"def validate_login_ids(test_cases): Given a list of login IDs, validate each one according to specified rules. Parameters: test_cases (list of str): List of login IDs to be validated. Returns: list of str: List of results (\\"VALID\\" or \\"INVALID\\") for each login ID. results = [] for login_id in test_cases: if len(login_id) == 6 and login_id[:2].isupper() and login_id[:2].isalpha() and login_id[2:].isdigit(): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"from typing import List def get_primes(x: int, y: int) -> List[int]: Returns a list of all prime numbers between x and y (inclusive). >>> get_primes(1, 5) == [2, 3, 5] >>> get_primes(10, 20) == [11, 13, 17, 19] >>> get_primes(22, 29) == [23, 29] >>> get_primes(0, 1) == [] >>> get_primes(-10, 2) == [2]","solution":"def get_primes(x, y): Returns a list of all prime numbers between x and y (inclusive). def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True primes = [] for num in range(x, y + 1): if is_prime(num): primes.append(num) return primes"},{"question":"def largest_contiguous_region(n: int, m: int, orchard: List[List[int]]) -> int: Write a program to help a gardener manage his apple orchard. The orchard is represented as a 2D grid of size n x m. Each cell in the grid either contains an apple tree (represented by the number 1) or is empty (represented by the number 0). The gardener wants to know the size of the largest contiguous region of apple trees in his orchard. A contiguous region of apple trees is defined as a group of apple tree cells that are connected horizontally or vertically (not diagonally). >>> largest_contiguous_region(1, 1, [[1]]) 1 >>> largest_contiguous_region(2, 2, [[0, 0], [0, 0]]) 0 >>> largest_contiguous_region(2, 2, [[1, 1], [1, 1]]) 4 >>> largest_contiguous_region(3, 3, [[1, 0, 1], [1, 1, 0], [0, 1, 1]]) 5 >>> largest_contiguous_region(3, 3, [[1, 0, 0], [0, 1, 0], [1, 0, 1]]) 1 >>> largest_contiguous_region(4, 5, [[1, 0, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 1, 0, 1], [1, 1, 0, 0, 1]]) 5","solution":"def largest_contiguous_region(n, m, orchard): def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or orchard[x][y] == 0: return 0 orchard[x][y] = 0 # Mark the cell as visited size = 1 for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]: size += dfs(x + dx, y + dy) return size max_size = 0 for i in range(n): for j in range(m): if orchard[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size # Example usage: orchard = [ [1, 0, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 1, 0, 1], [1, 1, 0, 0, 1] ] print(largest_contiguous_region(4, 5, orchard)) # Output: 5"},{"question":"from typing import List def generate_parentheses(n: int) -> List[str]: Generate all possible valid parentheses combinations for a given number n pairs. Examples: >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(4) [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"]","solution":"def generate_parentheses(n): Generates all combinations of n pairs of valid parentheses. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) result = [] backtrack() return result"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If there is no such character, returns '_'. >>> first_non_repeating_character(\\"abacabad\\") 'c' >>> first_non_repeating_character(\\"abacabaabacaba\\") '_' >>> first_non_repeating_character(\\"abcdefghijklmnopqrstuvwxyz\\") 'a'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no such character, returns '_'. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: if char_count[char] == 1: return char return '_'"},{"question":"from collections import Counter from typing import Dict def char_frequency(string: str) -> Dict[str, int]: Takes a string of lowercase alphabets and returns a dictionary where each key is a character from the string and each value is the number of times that character appears, sorted in decreasing order of frequency. >>> char_frequency(\\"banana\\") == {'a': 3, 'n': 2, 'b': 1} >>> char_frequency(\\"a\\") == {'a': 1} >>> char_frequency(\\"zzzz\\") == {'z': 4} >>> char_frequency(\\"\\") == {} >>> sorted(char_frequency(\\"abab\\").items()) == [('a', 2), ('b', 2)] def test_char_frequency(): assert char_frequency(\\"banana\\") == {'a': 3, 'n': 2, 'b': 1} assert char_frequency(\\"a\\") == {'a': 1} assert char_frequency(\\"zzzz\\") == {'z': 4} assert char_frequency(\\"\\") == {} result = char_frequency(\\"abab\\") assert result == {'a': 2, 'b': 2} or result == {'b': 2, 'a': 2} assert char_frequency(\\"abbccaaabbc\\") == {'a': 4, 'b': 4, 'c': 3}","solution":"from collections import Counter def char_frequency(string): Takes a string of lowercase alphabets and returns a dictionary where each key is a character from the string and each value is the number of times that character appears, sorted in decreasing order of frequency. frequency = Counter(string) sorted_frequency = dict(sorted(frequency.items(), key=lambda item: item[1], reverse=True)) return sorted_frequency"},{"question":"def encrypt_string(S: str, D: int) -> str: Encrypts the string S using a unique encryption algorithm by mapping each distinct character in S to an integer in the range [0, D-1]. Args: S (str): The string to be encrypted. D (int): The maximum integer value to use for encryption. Returns: str: The encrypted string or an error message if distinct characters exceed D. >>> encrypt_string(\\"abc\\", 3) \\"012\\" >>> encrypt_string(\\"hello\\", 5) \\"01223\\" >>> encrypt_string(\\"aabbcc\\", 3) \\"001122\\" >>> encrypt_string(\\"abcabc\\", 3) \\"012012\\" >>> encrypt_string(\\"abcde\\", 10) \\"01234\\" >>> encrypt_string(\\"xyz\\", 2) \\"Error: More distinct characters than D\\" pass def process_test_cases(test_cases: list) -> list: Process multiple test cases to produce encrypted strings. Args: test_cases (list): A list of tuples, where each tuple contains a string S and an integer D. Returns: list: A list of encrypted strings or error messages for each test case. >>> process_test_cases([(\\"abc\\", 3), (\\"hello\\", 5)]) [\\"012\\", \\"01223\\"] pass def test_encrypt_string(): assert encrypt_string(\\"abc\\", 3) == \\"012\\" assert encrypt_string(\\"hello\\", 5) == \\"01223\\" assert encrypt_string(\\"aabbcc\\", 3) == \\"001122\\" assert encrypt_string(\\"abcabc\\", 3) == \\"012012\\" assert encrypt_string(\\"abcde\\", 10) == \\"01234\\" assert encrypt_string(\\"xyz\\", 2) == \\"Error: More distinct characters than D\\" def test_process_test_cases(): test_cases = [(\\"abc\\", 3), (\\"hello\\", 5)] expected = [\\"012\\", \\"01223\\"] assert process_test_cases(test_cases) == expected","solution":"def encrypt_string(S, D): distinct_characters = {} counter = 0 encrypted_string = \\"\\" for char in S: if char not in distinct_characters: if counter < D: distinct_characters[char] = str(counter) counter += 1 else: return \\"Error: More distinct characters than D\\" encrypted_string += distinct_characters[char] return encrypted_string def process_test_cases(test_cases): results = [] for S, D in test_cases: results.append(encrypt_string(S, int(D))) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorderTraversal(root: TreeNode) -> List[int]: Perform an in-order traversal of the binary tree, returning a list of node values. >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> inorderTraversal(root) [1, 3, 2]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorderTraversal(root): Perform an in-order traversal of the binary tree. def traverse(node, result): if not node: return traverse(node.left, result) result.append(node.value) traverse(node.right, result) result = [] traverse(root, result) return result"},{"question":"def mirror_image(s: str) -> str: Converts a given string to its \\"mirror image\\" by reversing the order of characters. Leading and trailing whitespace is trimmed before processing. >>> mirror_image(\\"hello\\") \\"olleh\\" >>> mirror_image(\\"hello world! \\") \\"!dlrow olleh\\" >>> mirror_image(\\"12345!@#\\") \\"#@!54321\\" >>> mirror_image(\\" Python Programming\\") \\"gnimmargorP nohtyP\\" >>> mirror_image(\\"\\") \\"\\" >>> mirror_image(\\" \\") \\"\\" >>> mirror_image(\\"a\\") \\"a\\" >>> mirror_image(\\"Z\\") \\"Z\\" >>> mirror_image(\\"AbC DeF\\") \\"FeD CbA\\"","solution":"def mirror_image(s): Converts a given string to its \\"mirror image\\" by reversing the order of characters. Trims any leading and trailing whitespace before reversing the string. Parameters: s (str): The input string. Returns: str: The reversed string with trimmed whitespace. return s.strip()[::-1]"},{"question":"from typing import List def poker_hand_rank(cards: List[str]) -> str: Create a function that takes a list of 5 cards represented as strings and returns a string indicating the rank of the poker hand. Each card string will be in the format \\"RS\\", where: - R is the rank of the card, from \\"2\\" to \\"9\\" for numbered cards, and \\"T\\", \\"J\\", \\"Q\\", \\"K\\", \\"A\\" for ten, jack, queen, king, and ace respectively. - S is the suit of the card, which can be \\"H\\" (hearts), \\"D\\" (diamonds), \\"C\\" (clubs), or \\"S\\" (spades). The function should return one of the following strings: - \\"Royal Flush\\" - \\"Straight Flush\\" - \\"Four of a Kind\\" - \\"Full House\\" - \\"Flush\\" - \\"Straight\\" - \\"Three of a Kind\\" - \\"Two Pair\\" - \\"One Pair\\" - \\"High Card\\" >>> poker_hand_rank([\\"TH\\", \\"JH\\", \\"QH\\", \\"KH\\", \\"AH\\"]) \\"Royal Flush\\" >>> poker_hand_rank([\\"4H\\", \\"4C\\", \\"4S\\", \\"4D\\", \\"9H\\"]) \\"Four of a Kind\\" >>> poker_hand_rank([\\"2H\\", \\"3D\\", \\"5S\\", \\"9C\\", \\"KD\\"]) \\"High Card\\" pass","solution":"from collections import Counter def poker_hand_rank(cards): Returns the rank of the poker hand. value_map = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14} values = sorted([value_map[card[0]] for card in cards]) suits = [card[1] for card in cards] value_counts = Counter(values).values() is_flush = len(set(suits)) == 1 is_straight = len(set(values)) == 5 and (max(values) - min(values) == 4) if is_straight and is_flush: if len(set(values)) == 5 and max(values) == 14: # Check for Royal Flush return \\"Royal Flush\\" return \\"Straight Flush\\" if 4 in value_counts: return \\"Four of a Kind\\" if 3 in value_counts and 2 in value_counts: return \\"Full House\\" if is_flush: return \\"Flush\\" if is_straight: return \\"Straight\\" if 3 in value_counts: return \\"Three of a Kind\\" if list(value_counts).count(2) == 2: return \\"Two Pair\\" if 2 in value_counts: return \\"One Pair\\" return \\"High Card\\""},{"question":"def trap(height: list[int]) -> int: Calculate the total amount of water that can be trapped. :param height: List of non-negative integers representing the heights of adjacent buildings. :return: Total amount of water that can be trapped. >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([]) 0 >>> trap([2]) 0 >>> trap([2, 2]) 0 >>> trap([3, 3, 3]) 0 >>> trap([2, 1, 2]) 1 >>> trap([5, 1, 1, 1, 5]) 12","solution":"def trap(height): Calculate the total amount of water that can be trapped. :param height: List of non-negative integers representing the heights of adjacent buildings. :return: Total amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def str_arrangement(target: str, words: List[str]) -> bool: Returns True if the target can be constructed by concatenating the words from the list \`words\` exactly once. Each word can only be used once, and the order of words in the list matters. >>> str_arrangement(\\"helloworld\\", [\\"hello\\", \\"world\\"]) True >>> str_arrangement(\\"bedbathandbeyond\\", [\\"bed\\", \\"bath\\", \\"and\\", \\"beyond\\"]) True >>> str_arrangement(\\"manhattan\\", [\\"man\\", \\"hat\\", \\"man\\", \\"tan\\"]) False >>> str_arrangement(\\"codingisfun\\", [\\"coding\\", \\"is\\", \\"fun\\"]) True >>> str_arrangement(\\"\\", []) True >>> str_arrangement(\\"example\\", []) False >>> str_arrangement(\\"worldhello\\", [\\"hello\\", \\"world\\"]) False >>> str_arrangement(\\"single\\", [\\"single\\"]) True","solution":"def str_arrangement(target, words): Returns True if the target can be constructed by concatenating the words from the list \`words\` exactly once. Each word can only be used once, and the order of words in the list matters. concatenated = ''.join(words) return concatenated == target"},{"question":"def countConsonantsAndVowels(s: str) -> list: Given a string containing only letters, count the number of consonants and vowels in the string. Return a list where the first element is the number of consonants and the second element is the number of vowels. >>> countConsonantsAndVowels(\\"hello\\") [3, 2] >>> countConsonantsAndVowels(\\"world\\") [4, 1] >>> countConsonantsAndVowels(\\"aeiou\\") [0, 5] >>> countConsonantsAndVowels(\\"bcdfg\\") [5, 0] pass from solution import countConsonantsAndVowels def test_count_mixed_hello(): assert countConsonantsAndVowels(\\"hello\\") == [3, 2] def test_count_world(): assert countConsonantsAndVowels(\\"world\\") == [4, 1] def test_count_all_vowels(): assert countConsonantsAndVowels(\\"aeiou\\") == [0, 5] def test_count_all_consonants(): assert countConsonantsAndVowels(\\"bcdfg\\") == [5, 0] def test_count_empty_string(): assert countConsonantsAndVowels(\\"\\") == [0, 0] def test_count_single_vowel(): assert countConsonantsAndVowels(\\"a\\") == [0, 1] def test_count_single_consonant(): assert countConsonantsAndVowels(\\"b\\") == [1, 0] def test_count_vowels_and_consonants_mixed(): assert countConsonantsAndVowels(\\"abracadabra\\") == [6, 5]","solution":"def countConsonantsAndVowels(s): Counts the number of consonants and vowels in a given string s. Parameters: s (str): A string containing only letters. Returns: list: A list where the first element is the number of consonants and the second element is the number of vowels. vowels = 'aeiou' vowel_count = 0 consonant_count = 0 for char in s: if char in vowels: vowel_count += 1 else: consonant_count += 1 return [consonant_count, vowel_count]"},{"question":"def three_sum(arr: List[int]) -> List[List[int]]: Given an array of distinct integers, find all unique triplets in the array which sum up to zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([0, 1, 1]) == [] >>> three_sum([0, 0, 0]) == [[0, 0, 0]]","solution":"def three_sum(arr): Given an array of distinct integers, finds all unique triplets in the array which sum up to zero. arr.sort() triplets = [] for i in range(len(arr) - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return triplets"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome considering only alphanumeric characters and ignoring case. Args: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"Hello, World!\\") False pass def check_palindromes(strings: List[str]) -> List[str]: Takes a list of strings and returns a list of 'YES' or 'NO' indicating if each string is a palindrome. Args: strings (List[str]): List of strings to check. Returns: List[str]: List of results for each string ('YES' or 'NO'). >>> check_palindromes([\\"A man a plan a canal Panama\\", \\"Hello, World!\\"]) ['YES', 'NO'] pass","solution":"import re def is_palindrome(s): Checks if the given string is a palindrome considering only alphanumeric characters and ignoring case. cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned == cleaned[::-1] def check_palindromes(strings): Takes a list of strings and returns a list of 'YES' or 'NO' indicating if each string is a palindrome. results = [] for s in strings: if is_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_indices(nums: List[int], target: int) -> List[int]: Create a function that takes a list of numbers and a target number as arguments. The function should return a pair of indices of the numbers in the list that add up to the target number. Assume that each input would have exactly one solution, and you cannot use the same element twice. Args: nums (list of int): The list of numbers. target (int): The target sum. Returns: list of int: The indices of the two numbers. >>> find_indices([2, 7, 11, 15], 9) [0, 1] >>> find_indices([3, 2, 4], 6) [1, 2] >>> find_indices([3, 3], 6) [0, 1]","solution":"def find_indices(nums, target): Returns the indices of the two numbers that add up to the target. Args: nums (list of int): The list of numbers. target (int): The target sum. Returns: list of int: The indices of the two numbers. num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i"},{"question":"def sum_positive_numbers(arr: List[int]) -> int: Returns the sum of all positive numbers in the array. If the array does not contain any positive numbers, returns 0. >>> sum_positive_numbers([1, -4, 7, 12]) 20 >>> sum_positive_numbers([-1, -4, -7, -12]) 0 >>> sum_positive_numbers([]) 0 >>> sum_positive_numbers([0, 1, -1, 2, -2, 3]) 6 >>> sum_positive_numbers([5]) 5","solution":"def sum_positive_numbers(arr): Returns the sum of all positive numbers in the array. If the array does not contain any positive numbers, returns 0. return sum(x for x in arr if x > 0)"},{"question":"def group_coins_by_value(N: int, coin_values: List[int]) -> List[Tuple[int, int]]: Determines the number of groups and the size of each group in a coin collection. Parameters: N (int): The number of coins. coin_values (list): A list of integers representing the coin values. Returns: list of tuples: A list of tuples where each tuple contains a coin value and the size of the group of that coin value. >>> group_coins_by_value(8, [5, 3, 4, 5, 3, 5, 3, 4]) [(3, 3), (4, 2), (5, 3)] >>> group_coins_by_value(1, [1]) [(1, 1)] >>> group_coins_by_value(5, [2, 2, 2, 2, 2]) [(2, 5)] >>> group_coins_by_value(10, [10, 1, 1, 10, 2, 2, 9, 9, 9, 8]) [(1, 2), (2, 2), (8, 1), (9, 3), (10, 2)] >>> group_coins_by_value(6, [6, 6, 3, 3, 1, 1]) [(1, 2), (3, 2), (6, 2)] >>> group_coins_by_value(5, [5, 3, 1, 4, 2]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]","solution":"def group_coins_by_value(N, coin_values): Determines the number of groups and the size of each group in a coin collection. Parameters: N (int): The number of coins. coin_values (list): A list of integers representing the coin values. Returns: list of tuples: A list of tuples where each tuple contains a coin value and the size of the group of that coin value. from collections import Counter value_counts = Counter(coin_values) sorted_values = sorted(value_counts.items()) return sorted_values"},{"question":"def find_earliest_duplicate_packet_timestamp(n: int, packets: List[Tuple[str, int]]) -> int: Finds the earliest timestamp of a duplicate packet based on identifiers. Parameters: n (int): Number of packets packets (list of tuples): Each tuple contains (identifier (str), timestamp (int)) Returns: int: The earliest timestamp of a duplicate packet, or -1 if no duplicates are found. >>> packets = [(\\"abc\\", 3), (\\"def\\", 5), (\\"ghi\\", 7), (\\"abc\\", 4), (\\"xyz\\", 9)] >>> find_earliest_duplicate_packet_timestamp(5, packets) 3 >>> packets = [(\\"abc\\", 1)] >>> find_earliest_duplicate_packet_timestamp(1, packets) -1","solution":"def find_earliest_duplicate_packet_timestamp(n, packets): Finds the earliest timestamp of a duplicate packet based on identifiers. Parameters: n (int): Number of packets packets (list of tuples): Each tuple contains (identifier (str), timestamp (int)) Returns: int: The earliest timestamp of a duplicate packet, or -1 if no duplicates are found. seen_packets = {} earliest_timestamp = -1 for identifier, timestamp in packets: if identifier in seen_packets: if earliest_timestamp == -1 or seen_packets[identifier] < earliest_timestamp: earliest_timestamp = seen_packets[identifier] else: seen_packets[identifier] = timestamp return earliest_timestamp # Example usage: # packets = [(\\"abc\\", 3), (\\"def\\", 5), (\\"ghi\\", 7), (\\"abc\\", 4), (\\"xyz\\", 9)] # print(find_earliest_duplicate_packet_timestamp(5, packets)) # Output: 3"},{"question":"def longest_subarray_with_difference(arr: List[int], T: int) -> int: Returns the length of the longest subarray where the absolute difference between any two elements in the subarray is less than or equal to T. >>> longest_subarray_with_difference([1, 3, 6, 9, 12], 3) # 2 >>> longest_subarray_with_difference([4, 8, 5, 1, 7], 4) # 3 >>> longest_subarray_with_difference([10, 100, 200, 300], 50) # 1 ) from typing import List def test_example_1(): assert longest_subarray_with_difference([1, 3, 6, 9, 12], 3) == 2 def test_example_2(): assert longest_subarray_with_difference([4, 8, 5, 1, 7], 4) == 3 def test_example_3(): assert longest_subarray_with_difference([10, 100, 200, 300], 50) == 1 def test_all_elements_same(): assert longest_subarray_with_difference([5, 5, 5, 5], 3) == 4 def test_single_element(): assert longest_subarray_with_difference([10], 10) == 1 def test_no_valid_subarray(): assert longest_subarray_with_difference([1, 5, 10, 15, 20], 3) == 1 def test_large_T_value(): assert longest_subarray_with_difference([1, 5, 10, 15, 20], 20) == 5 def test_empty_array(): assert longest_subarray_with_difference([], 3) == 0 def test_large_array(): arr = [i for i in range(1, 10001)] assert longest_subarray_with_difference(arr, 1) == 2","solution":"def longest_subarray_with_difference(arr, T): Returns the length of the longest subarray where the absolute difference between any two elements in the subarray is less than or equal to T. from collections import deque if not arr: return 0 left = 0 max_length = 0 min_deque = deque() max_deque = deque() for right in range(len(arr)): while min_deque and arr[min_deque[-1]] > arr[right]: min_deque.pop() while max_deque and arr[max_deque[-1]] < arr[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > T: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> None: Rotates an n x n matrix 90 degrees clockwise in place. Parameters: matrix (list of list of int): n x n matrix to be rotated Returns: None Example: >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix1) >>> print(matrix1) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix2 = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix2) >>> print(matrix2) [[3, 1], [4, 2]] pass # Unit tests def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_rotate_5x5_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotate_matrix(matrix) assert matrix == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"def rotate_matrix(matrix): Rotates an n x n matrix 90 degrees clockwise in place. Parameters: matrix (list of list of int): n x n matrix to be rotated Returns: None n = len(matrix) # Step 1: Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row (swap the outermost elements moving inwards) for i in range(n): matrix[i].reverse()"},{"question":"def is_isogram(string: str) -> bool: Determines if the given string is an isogram. An isogram is a word or phrase without a repeating letter, though spaces and hyphens are allowed to appear multiple times. Parameters: string (str): The string to check. Returns: bool: True if the string is an isogram, False otherwise. >>> is_isogram(\\"isogram\\") == True >>> is_isogram(\\"hello\\") == False >>> is_isogram(\\"isograms are fun!\\") == False >>> is_isogram(\\"six-year-old\\") == True >>> is_isogram(\\"\\") == True >>> is_isogram(\\"a-b-c-d-e f g !\\") == True >>> is_isogram(\\"Alphabet\\") == False >>> is_isogram(\\"aaaa\\") == False","solution":"def is_isogram(string): Determines if the given string is an isogram. An isogram is a word or phrase without a repeating letter, though spaces and hyphens are allowed to appear multiple times. Parameters: string (str): The string to check. Returns: bool: True if the string is an isogram, False otherwise. cleaned_string = string.replace(\\" \\", \\"\\").replace(\\"-\\", \\"\\").lower() return len(cleaned_string) == len(set(cleaned_string))"},{"question":"def smallest_substring_length(s: str) -> int: Returns the length of the smallest substring that contains all the distinct characters of the string s. >>> smallest_substring_length(\\"aabcbcdbca\\") 4 >>> smallest_substring_length(\\"a\\") 1 >>> smallest_substring_length(\\"abcde\\") 5 >>> smallest_substring_length(\\"aaabbaa\\") 2 >>> smallest_substring_length(\\"aaaa\\") 1 >>> smallest_substring_length(\\"a\\" * 100000) 1","solution":"def smallest_substring_length(s): Returns the length of the smallest substring that contains all distinct characters of the input string s. if not s: return 0 distinct_characters = set(s) required_count = len(distinct_characters) unique_chars_window = {} left = 0 min_length = len(s) + 1 for right in range(len(s)): current_char = s[right] unique_chars_window[current_char] = unique_chars_window.get(current_char, 0) + 1 while len(unique_chars_window) == required_count: min_length = min(min_length, right - left + 1) left_char = s[left] unique_chars_window[left_char] -= 1 if unique_chars_window[left_char] == 0: del unique_chars_window[left_char] left += 1 return min_length"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups words that are anagrams of each other. :param words: List of words :return: List of lists of anagrams >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"\\"]) [['']] >>> group_anagrams([\\"a\\"]) [['a']] # Unit Tests def test_group_anagrams_standard(): words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] result = group_anagrams(words) expected_results = [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] for lst in expected_results: assert sorted(lst) in map(sorted, result) def test_group_anagrams_single_word(): words = [\\"a\\"] result = group_anagrams(words) assert result == [[\\"a\\"]] def test_group_anagrams_empty_string(): words = [\\"\\"] result = group_anagrams(words) assert result == [[\\"\\"]] def test_group_anagrams_mixed_length(): words = [\\"eat\\", \\"bat\\", \\"ate\\", \\"tab\\", \\"tae\\"] result = group_anagrams(words) expected_results = [[\\"eat\\", \\"ate\\", \\"tae\\"], [\\"bat\\", \\"tab\\"]] for lst in expected_results: assert sorted(lst) in map(sorted, result) def test_group_anagrams_no_anagrams(): words = [\\"apple\\", \\"banana\\", \\"carrot\\"] result = group_anagrams(words) expected_results = [[\\"apple\\"], [\\"banana\\"], [\\"carrot\\"]] for lst in expected_results: assert sorted(lst) in map(sorted, result)","solution":"from collections import defaultdict def group_anagrams(words): Groups words that are anagrams of each other. :param words: List of words :return: List of lists of anagrams anagrams = defaultdict(list) for word in words: # Sort the word to use as a key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def word_count(s): Returns a dictionary with words as keys and their counts as values. Words are sequences of alphanumeric characters separated by non-alphanumeric characters. Case is ignored when counting occurrences. :param s: input string :return: dictionary of word counts pass from solution import word_count def test_word_count_normal_case(): s = \\"Hello world! Hello again.\\" expected = {\\"hello\\": 2, \\"world\\": 1, \\"again\\": 1} assert word_count(s) == expected def test_word_count_with_punctuation(): s = \\"Good morning, Mr. Smith! Good morning to you.\\" expected = {\\"good\\": 2, \\"morning\\": 2, \\"mr\\": 1, \\"smith\\": 1, \\"to\\": 1, \\"you\\": 1} assert word_count(s) == expected def test_word_count_with_numbers(): s = \\"There are 2 apples and 10 oranges.\\" expected = {\\"there\\": 1, \\"are\\": 1, \\"2\\": 1, \\"apples\\": 1, \\"and\\": 1, \\"10\\": 1, \\"oranges\\": 1} assert word_count(s) == expected def test_word_count_mixed_case(): s = \\"Test TEST test.\\" expected = {\\"test\\": 3} assert word_count(s) == expected def test_word_count_non_string_input(): assert word_count(12345) == {} def test_word_count_empty_string(): assert word_count(\\"\\") == {} def test_word_count_single_word(): s = \\"hello\\" expected = {\\"hello\\": 1} assert word_count(s) == expected def test_word_count_multiple_spaces(): s = \\"hello world\\" expected = {\\"hello\\": 1, \\"world\\": 1} assert word_count(s) == expected","solution":"import re from collections import defaultdict def word_count(s): Returns a dictionary with words as keys and their counts as values. Words are sequences of alphanumeric characters separated by non-alphanumeric characters. Case is ignored when counting occurrences. :param s: input string :return: dictionary of word counts # Check if the input is a string if not isinstance(s, str): return {} # Convert the string to lowercase s = s.lower() # Use regular expression to find all words words = re.findall(r'bw+b', s) # Use defaultdict to count occurrences of each word count_dict = defaultdict(int) for word in words: count_dict[word] += 1 return dict(count_dict)"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Create a function that takes a non-negative integer \`n\` as input and returns a list of the first \`n\` Fibonacci numbers. >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Returns a list of the first n Fibonacci numbers. if n <= 0: return [] elif n == 1: return [0] fibs = [0, 1] while len(fibs) < n: fibs.append(fibs[-1] + fibs[-2]) return fibs"},{"question":"def common_elements(list1, list2): Returns a new list containing the common elements between list1 and list2, without duplicates. The elements in the result list are in the order they appeared in list1. >>> common_elements([1, 2, 3, 4], [3, 4, 5, 6]) => [3, 4] >>> common_elements([10, 20, 20, 30, 40], [20, 40]) => [20, 40] >>> common_elements([7, 8, 9], [10, 11, 12]) => [] from solution import common_elements def test_common_elements_basic(): assert common_elements([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4] def test_common_elements_with_duplicates_in_first_list(): assert common_elements([10, 20, 20, 30, 40], [20, 40]) == [20, 40] def test_common_elements_no_common_elements(): assert common_elements([7, 8, 9], [10, 11, 12]) == [] def test_common_elements_all_common_elements(): assert common_elements([1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_common_elements_empty_first_list(): assert common_elements([], [1, 2, 3]) == [] def test_common_elements_empty_second_list(): assert common_elements([1, 2, 3], []) == [] def test_common_elements_disorder_and_duplicates(): assert common_elements([1, 2, 2, 3, 4, 1, 5], [1, 2, 4, 6]) == [1, 2, 4] def test_common_elements_with_negative_numbers(): assert common_elements([-1, -2, -3, 4], [-3, 4, 5]) == [-3, 4]","solution":"def common_elements(list1, list2): Returns a new list containing the common elements between list1 and list2, without duplicates. The elements in the result list are in the order they appeared in list1. set2 = set(list2) # Convert list2 to set for O(1) average time complexity lookups result = [] seen = set() # To track added elements to avoid duplicates for element in list1: if element in set2 and element not in seen: result.append(element) seen.add(element) return result"},{"question":"def character_count(s: str) -> dict: Returns a dictionary where the keys are characters in the string 's' and the values are the count of each character. >>> character_count(\\"abracadabra\\") {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} >>> character_count(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} from solution import character_count def test_empty_string(): assert character_count(\\"\\") == {} def test_single_character_string(): assert character_count(\\"a\\") == {'a': 1} assert character_count(\\"z\\") == {'z': 1} def test_repeating_characters(): assert character_count(\\"aaa\\") == {'a': 3} assert character_count(\\"abcabc\\") == {'a': 2, 'b': 2, 'c': 2} def test_mixed_characters(): assert character_count(\\"abracadabra\\") == {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} assert character_count(\\"hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} def test_case_sensitive(): assert character_count(\\"aA\\") == {'a': 1, 'A': 1} assert character_count(\\"AaAa\\") == {'A': 2, 'a': 2} def test_special_characters(): assert character_count(\\"!@#%^^&*\\") == {'!': 1, '@': 1, '#': 1, '': 2, '%': 1, '^': 2, '&': 1, '*': 1} assert character_count(\\"1234567890\\") == {'1': 1, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1, '0': 1}","solution":"def character_count(s): Returns a dictionary where the keys are characters in the string 's' and the values are the count of each character. count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, return an array of the same length where each element at index i of the output array is the product of all the numbers in the original array except the one at i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6]) [6, 5]","solution":"def product_except_self(nums): Given an array of integers, return an array of the same length where each element at index i of the output array is the product of all the numbers in the original array except the one at i. length = len(nums) output = [1] * length left_product = 1 for i in range(length): output[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def contains_duplicate(nums: List[int]) -> bool: Determines whether the list contains any duplicate elements. >>> contains_duplicate([1, 2, 3, 1]) == True >>> contains_duplicate([1, 2, 3, 4]) == False >>> contains_duplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) == True >>> contains_duplicate([1]) == False >>> contains_duplicate(list(range(1, 100001))) == False >>> contains_duplicate(list(range(1, 100000)) + [99]) == True","solution":"def contains_duplicate(nums): Determines whether the list contains any duplicate elements. Parameters: nums (list of int): List of integers to check. Returns: bool: True if any integer appears at least twice in the list, otherwise False. return len(nums) != len(set(nums))"},{"question":"def standardize_units(instructions: List[str]) -> List[str]: Given a set of instructions of how different spices are to be measured for a recipe, process these instructions and return a list of combined ingredients in a standardized format. >>> standardize_units([\\"nutmeg 3g\\", \\"cinnamon 2tsp\\", \\"sugar 5grams\\", \\"nutmeg 2g\\", \\"cinnamon 1tsp\\", \\"oats 0.5cups\\"]) [\\"cinnamon 3.0 tsp\\", \\"nutmeg 5.0 g\\", \\"oats 24.0 tsp\\", \\"sugar 5.0 g\\"] >>> standardize_units([\\"nutmeg 3g\\", \\"cinnamon 2tsp\\", \\"unicorns 5magic\\"]) [\\"Invalid data\\"] >>> standardize_units([\\"nutmeg 3g\\", \\"sugar 5\\"]) [\\"Invalid data\\"] >>> standardize_units([\\"nutmeg 3g\\", \\"cinnamon 2tsp\\"]) [\\"cinnamon 2.0 tsp\\", \\"nutmeg 3.0 g\\"] >>> standardize_units([\\"oats 0.5cups\\", \\"oats 0.25cups\\"]) [\\"oats 36.0 tsp\\"] >>> standardize_units([\\"sugar 1000mg\\", \\"sugar 1g\\", \\"flour 0.001kg\\"]) [\\"flour 1.0 g\\", \\"sugar 2.0 g\\"]","solution":"def standardize_units(instructions): def to_standard_unit(quantity, unit): if unit in ['g', 'grams', 'gram']: return quantity, 'g' elif unit in ['mg', 'milligrams', 'milligram']: return quantity / 1000, 'g' elif unit in ['kg', 'kilograms', 'kilogram']: return quantity * 1000, 'g' elif unit in ['tsp', 'teaspoons', 'teaspoon']: return quantity, 'tsp' elif unit in ['tbsp', 'tablespoons', 'tablespoon']: return quantity * 3, 'tsp' elif unit in ['cups', 'cup']: return quantity * 48, 'tsp' else: raise ValueError(\\"Invalid unit\\") import re ingredient_dict = {} for instruction in instructions: parts = re.split(r's+', instruction) ingredient = parts[0] qty_unit = parts[1] match = re.match(r\\"(d*.?d+)([a-zA-Z]+)\\", qty_unit) if not match: return [\\"Invalid data\\"] try: quantity = float(match.group(1)) unit = match.group(2) except ValueError: return [\\"Invalid data\\"] try: std_qty, std_unit = to_standard_unit(quantity, unit) except ValueError: return [\\"Invalid data\\"] if ingredient not in ingredient_dict: ingredient_dict[ingredient] = {'qty': 0, 'unit': std_unit} if ingredient_dict[ingredient]['unit'] == std_unit: ingredient_dict[ingredient]['qty'] += std_qty else: return [\\"Invalid data\\"] result = [] for ingredient in sorted(ingredient_dict): qty = round(ingredient_dict[ingredient]['qty'], 2) unit = ingredient_dict[ingredient]['unit'] result.append(f\\"{ingredient} {qty} {unit}\\") return result"},{"question":"def largest_square_subgrid(grid): Returns the size of the largest square subgrid that contains only 1s. Args: - grid: List of lists, representing the grid with values 0 or 1. Returns: - Integer indicating the size of the largest square subgrid. >>> largest_square_subgrid([[0, 1, 1, 1, 0], [1, 1, 1, 1, 1], [1, 1, 1, 0, 0], [1, 1, 1, 0, 0]]) 3 >>> largest_square_subgrid([[1, 1, 0, 1]]) 1 >>> largest_square_subgrid([[1], [1], [0], [1]]) 1 >>> largest_square_subgrid([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 4 >>> largest_square_subgrid([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> largest_square_subgrid([[1]]) 1 >>> largest_square_subgrid([[1, 0, 1, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]) 4","solution":"def largest_square_subgrid(grid): Returns the size of the largest square subgrid that contains only 1s. Args: - grid: List of lists, representing the grid with values 0 or 1. Returns: - Integer indicating the size of the largest square subgrid. if not grid: return 0 R = len(grid) C = len(grid[0]) # create a 2D dp array with the same dimensions as the grid dp = [[0] * C for _ in range(R)] max_side = 0 for i in range(R): for j in range(C): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def count_successful_pastries(sales: List[int], T: int) -> int: Returns the count of pastry types that sold at least T pastries. >>> count_successful_pastries([50, 60, 70, 65, 30], 50) 4 >>> count_successful_pastries([10, 20, 30], 50) 0 >>> count_successful_pastries([60, 70, 80], 50) 3 >>> count_successful_pastries([50, 40, 70, 60, 30], 50) 3 >>> count_successful_pastries([50, 50, 50, 50], 50) 4 >>> count_successful_pastries([0, 0, 0, 0], 0) 4 >>> count_successful_pastries([10, 20, 30], 0) 3 >>> count_successful_pastries([], 50) 0","solution":"from typing import List def count_successful_pastries(sales: List[int], T: int) -> int: Returns the count of pastry types that sold at least T pastries. return sum(1 for sale in sales if sale >= T)"},{"question":"def smallest_missing_positive_integer(N, A): Finds the smallest missing positive integer in the array A of length N. >>> smallest_missing_positive_integer(5, [3, 4, -1, 1, 2]) 5 >>> smallest_missing_positive_integer(3, [-2, -5, -7]) 1 >>> smallest_missing_positive_integer(5, [1, 2, 0, -1, -2]) 3 >>> smallest_missing_positive_integer(4, [1, 2, 3, 4]) 5 >>> smallest_missing_positive_integer(7, [0, 10, 2, -10, 1, 3, 4]) 5 >>> smallest_missing_positive_integer(1, [1]) 2 >>> smallest_missing_positive_integer(1, [2]) 1","solution":"def smallest_missing_positive_integer(N, A): Finds the smallest missing positive integer in the array A of length N. # First, we will mark elements that are out of our target range [1, N]. for i in range(N): if A[i] <= 0 or A[i] > N: A[i] = N + 1 # Use index as a hash key, place negative mark on numbers found in the array for i in range(N): val = abs(A[i]) if 1 <= val <= N: A[val-1] = -abs(A[val-1]) # The first index which is positive indicates the missing number for i in range(N): if A[i] > 0: return i + 1 # If no missing number is found in the range [1, N] return N + 1"},{"question":"from typing import List, Optional def is_arithmetic_progression(arr: List[int]) -> Optional[int]: Determine if the given list of integers is an arithmetic progression. Parameters: arr (List[int]): List of integers. Returns: Optional[int]: The common difference if the array forms an AP, otherwise None. Examples: >>> is_arithmetic_progression([1, 3, 5, 7, 9]) 2 >>> is_arithmetic_progression([2, 4, 7, 10]) None >>> is_arithmetic_progression([5, 5, 5, 5]) 0","solution":"from typing import List, Optional def is_arithmetic_progression(arr: List[int]) -> Optional[int]: Determine if the given list of integers is an arithmetic progression. Parameters: arr (List[int]): List of integers. Returns: Optional[int]: The common difference if the array forms an AP, otherwise None. if len(arr) < 2: return None # Check if difference between every consecutive elements is the same common_difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] != common_difference: return None return common_difference"},{"question":"def calculate_bill(enter: str, leave: str) -> int: Calculate the total bill for the parking duration. The first 30 minutes are free, each additional started hour costs 5, with a maximum charge of 20 for a single day. Args: enter (str): Time in HH:MM format representing the entry time. leave (str): Time in HH:MM format representing the exit time. Returns: int: Total bill in dollars. Examples: >>> calculate_bill(\\"10:00\\", \\"13:21\\") 15 >>> calculate_bill(\\"11:30\\", \\"12:40\\") 5 >>> calculate_bill(\\"09:00\\", \\"18:00\\") 20 >>> calculate_bill(\\"22:00\\", \\"23:30\\") 5","solution":"def calculate_bill(enter, leave): def time_to_minutes(time): hours, minutes = map(int, time.split(':')) return hours * 60 + minutes enter_minutes = time_to_minutes(enter) leave_minutes = time_to_minutes(leave) # Calculate total parked time in minutes total_time = leave_minutes - enter_minutes # Calculate bill considering the first 30 minutes are free if total_time <= 30: return 0 chargeable_time = total_time - 30 # Calculate started additional hours additional_hours = (chargeable_time + 59) // 60 # Calculate the total cost total_cost = additional_hours * 5 # Apply maximum charge cap of 20 return min(total_cost, 20)"},{"question":"def smallest_missing_positive_integer(arr: List[int]) -> int: Given a list of integers, this function finds and returns the smallest positive integer that is not present in the list. >>> smallest_missing_positive_integer([1, 2, 0]) == 3 >>> smallest_missing_positive_integer([3, 4, -1, 1]) == 2 >>> smallest_missing_positive_integer([7, 8, 9, 11, 12]) == 1 >>> smallest_missing_positive_integer([1, 2, 3, 4, 5]) == 6 >>> smallest_missing_positive_integer([1, 2, 2, 4, 5, 6, 7]) == 3 >>> smallest_missing_positive_integer([-1, -2, 0, 1, 2]) == 3 >>> smallest_missing_positive_integer([i for i in range(1, 100001)]) == 100001 >>> smallest_missing_positive_integer([1]) == 2 >>> smallest_missing_positive_integer([2]) == 1 >>> smallest_missing_positive_integer([-1]) == 1 >>> smallest_missing_positive_integer([]) == 1 pass","solution":"def smallest_missing_positive_integer(arr): Given a list of integers, this function finds and returns the smallest positive integer that is not present in the list. # Create a set for quicker lookups num_set = set(arr) smallest_missing = 1 # Check each integer starting from 1 upwards to find the smallest missing one while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"def getMaximumGold(grid): You are given a rectangular grid where each cell can either contain a positive integer representing the amount of gold or zero representing an empty cell. You need to find the maximum amount of gold you can collect starting from any cell and moving only in four possible directions - up, down, left, or right. You cannot visit the same cell more than once in any path. Args: grid: List[List[int]], the grid containing positive integers representing gold in each cell and zeros representing empty cells. Returns: int, the maximum amount of gold that can be collected. Examples: >>> getMaximumGold([[0, 6, 0], [5, 8, 7], [0, 9, 0]]) 24 >>> getMaximumGold([[1, 0, 7], [2, 0, 6], [3, 4, 5]]) 28","solution":"def getMaximumGold(grid): def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 gold = grid[x][y] grid[x][y] = 0 # Mark the cell as visited by setting it to 0 maxGold = 0 # Explore all four directions for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)): maxGold = max(maxGold, dfs(x + dx, y + dy)) grid[x][y] = gold # Reset the cell to its original value return gold + maxGold maxGoldCollected = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] != 0: maxGoldCollected = max(maxGoldCollected, dfs(i, j)) return maxGoldCollected"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of water that can be trapped. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) -> 6 >>> trap([4,2,0,3,2,5]) -> 9","solution":"def trap(height): Calculate the total amount of water that can be trapped. :param height: List[int] :return: int if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max for each index left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right max for each index right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate water trapped at each index for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def merge_sorted_arrays(list1: List[int], list2: List[int]) -> List[int]: Merge two sorted lists into a single sorted list. Args: list1 (List[int]): A sorted list of integers in non-decreasing order. list2 (List[int]): A sorted list of integers in non-decreasing order. Returns: List[int]: A sorted list containing all integers from list1 and list2 in non-decreasing order. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([1, 2, 2], [2, 3, 4]) [1, 2, 2, 2, 3, 4] >>> merge_sorted_arrays([-3, -2, 0, 2], [-1, 1, 3]) [-3, -2, -1, 0, 1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([2, 2, 2], [2, 2, 2]) [2, 2, 2, 2, 2, 2]","solution":"def merge_sorted_arrays(list1, list2): Merges two sorted lists into a single sorted list. Arguments: list1 -- a list of integers sorted in non-decreasing order list2 -- a list of integers sorted in non-decreasing order Returns: A new list containing all integers from list1 and list2, sorted in non-decreasing order. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # append remaining elements while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def largest_rectangle_area(histogram): Calculate the area of the largest rectangle in the histogram. :param histogram: List of positive integers representing the heights of the histogram bars :return: The area of the largest rectangle in the histogram >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 1]) 10 >>> largest_rectangle_area([1, 2, 3, 4]) 6 >>> largest_rectangle_area([4, 3, 2, 1]) 6","solution":"def largest_rectangle_area(histogram): Calculate the area of the largest rectangle in the histogram. :param histogram: List of positive integers representing the heights of the histogram bars :return: The area of the largest rectangle in the histogram stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List, Tuple def find_shortest_cycle(N: int, M: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph with N nodes and M edges, find the length of the shortest cycle, or return -1 if the graph does not contain any cycles. def process_test_cases(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Process multiple test cases for the find_shortest_cycle function. >>> process_test_cases([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 2, [(1, 2), (2, 3)])]) [4, -1] from solution import process_test_cases def test_no_cycle(): test_cases = [ (3, 2, [(1, 2), (2, 3)]) ] assert process_test_cases(test_cases) == [-1] def test_single_cycle(): test_cases = [ (3, 3, [(1, 2), (2, 3), (3, 1)]) ] assert process_test_cases(test_cases) == [3] def test_multiple_cycles(): test_cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (2, 5)]) ] assert process_test_cases(test_cases) == [4, 4] def test_no_edges(): test_cases = [ (3, 0, []) ] assert process_test_cases(test_cases) == [-1] def test_complex_case(): test_cases = [ (7, 8, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 1), (2, 5)]) ] assert process_test_cases(test_cases) == [4] def test_disconnected_graph(): test_cases = [ (5, 3, [(1, 2), (2, 3), (4, 5)]), (4, 3, [(1, 2), (2, 3), (1, 3)]) ] assert process_test_cases(test_cases) == [-1, 3]","solution":"from collections import deque, defaultdict def find_shortest_cycle(N, M, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(start): dist = [-1] * (N + 1) queue = deque([(start, -1)]) dist[start] = 0 while queue: current, parent = queue.popleft() for neighbor in graph[current]: if dist[neighbor] == -1: dist[neighbor] = dist[current] + 1 queue.append((neighbor, current)) elif neighbor != parent: # Cycle found return dist[current] + dist[neighbor] + 1 return float('inf') shortest_cycle = float('inf') for node in range(1, N + 1): shortest_cycle = min(shortest_cycle, bfs(node)) return shortest_cycle if shortest_cycle != float('inf') else -1 def process_test_cases(test_cases): results = [] for N, M, edges in test_cases: result = find_shortest_cycle(N, M, edges) results.append(result) return results"},{"question":"def findMostFrequentFlower(grid: List[List[str]]) -> str: Returns the type of flower that appears most frequently in the grid. If there's a tie, returns the flower that comes first lexicographically. >>> findMostFrequentFlower([ ... ['a', 'b', 'a'], ... ['c', 'b', 'a'], ... ['c', 'd', 'a'] ... ]) 'a' >>> findMostFrequentFlower([ ... ['d', 'e', 'f'], ... ['a', 'b', 'c'], ... ['a', 'b', 'd'] ... ]) 'a'","solution":"def findMostFrequentFlower(grid): Returns the type of flower that appears most frequently in the grid. If there's a tie, returns the flower that comes first lexicographically. from collections import Counter # Flatten the grid and count the frequency of each flower flower_counts = Counter(flower for row in grid for flower in row) # Find the most frequent flower (if tie, the smaller lexicographically) most_frequent_flower = min(flower_counts, key=lambda f: (-flower_counts[f], f)) return most_frequent_flower"},{"question":"def evaluateExpression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a floating-point number. >>> evaluateExpression(\\"3+5*2\\") 13.0 >>> evaluateExpression(\\"10+2*6\\") 22.0 >>> evaluateExpression(\\"100*2+12\\") 212.0 >>> evaluateExpression(\\"100*(2+12)\\") 1400.0 >>> evaluateExpression(\\"100*(2+12)/14\\") 100.0 Raises: ValueError: If the expression is invalid. pass","solution":"def evaluateExpression(expression): Evaluates a mathematical expression and returns the result as a floating-point number. Parameters: expression (str): A string representing a mathematical expression. Returns: float: The result of the evaluated expression. try: result = eval(expression) return float(result) except Exception as e: raise ValueError(\\"Invalid expression\\") from e"},{"question":"def count_unique_characters(s: str) -> int: Return the number of unique characters in the string s. >>> count_unique_characters(\\"abcde\\") == 5 >>> count_unique_characters(\\"hello\\") == 4 >>> count_unique_characters(\\"aaaaa\\") == 1 >>> count_unique_characters(\\"\\") == 0 >>> count_unique_characters(\\"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\\") == 26","solution":"def count_unique_characters(s): Returns the number of unique characters in the string s. return len(set(s))"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced (well-formed) substring of parentheses. >>> longest_balanced_substring(\\"(()())\\") == 6 >>> longest_balanced_substring(\\")()())\\") == 4 >>> longest_balanced_substring(\\"()(()\\") == 2 >>> longest_balanced_substring(\\"()\\") == 2 >>> longest_balanced_substring(\\"\\") == 0 >>> longest_balanced_substring(\\"(((((\\") == 0 >>> longest_balanced_substring(\\")))))\\") == 0 >>> longest_balanced_substring(\\"(()((())()))\\") == 12 >>> longest_balanced_substring(\\"()()\\") == 4","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring of parentheses. max_length = 0 stack = [-1] # Stack to store indices, initialized with -1 for i, char in enumerate(s): if char == '(': stack.append(i) # Push the index onto the stack else: stack.pop() # Pop the top element if stack: max_length = max(max_length, i - stack[-1]) else: stack.append(i) # If stack is empty, push current index return max_length"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Return the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\"\\") 0","solution":"def longest_substring_without_repeating_characters(s: str) -> int: n = len(s) if n == 0: return 0 char_index = {} max_len = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List, Tuple def assign_taxis(taxis: List[int], requests: List[Tuple[int, int]]) -> List[Tuple[int, Tuple[int, int]]]: Assigns each trip request to a taxi such that the total moving distance of all the taxis is minimized. Args: taxis: A list of integers representing the current positions of the available taxis. requests: A list of tuples where each tuple contains two integers - the starting point and the destination of a trip request. Returns: A list of tuples, where each tuple contains the assigned taxi's ID (its index in the input \`taxis\` list) and the trip request tuple. The list should be ordered such that the first element corresponds to the best-matched taxi for the first request, the second element to the second request, and so on. >>> taxis = [1, 5, 9] >>> requests = [(3, 10), (8, 2), (4, 6), (7, 9)] >>> assign_taxis(taxis, requests) [(0, (3, 10)), (2, (8, 2)), (1, (4, 6))] pass import pytest from solution import assign_taxis def test_example_case(): taxis = [1, 5, 9] requests = [(3, 10), (8, 2), (4, 6), (7, 9)] expected = [(0, (3, 10)), (2, (8, 2)), (1, (4, 6))] assert assign_taxis(taxis, requests) == expected def test_more_taxis_than_requests(): taxis = [2, 4, 6] requests = [(3, 5)] expected = [(0, (3, 5))] assert assign_taxis(taxis, requests) == expected def test_more_requests_than_taxis(): taxis = [2] requests = [(3, 5), (8, 10)] expected = [(0, (3, 5))] assert assign_taxis(taxis, requests) == expected def test_exactly_enough_taxis(): taxis = [1, 2, 3] requests = [(4, 8), (5, 6), (7, 9)] expected = [(2, (4, 8)), (1, (5, 6)), (0, (7, 9))] assert assign_taxis(taxis, requests) == expected def test_identical_taxi_positions(): taxis = [1, 1, 1] requests = [(2, 3), (5, 6), (7, 8)] expected = [(0, (2, 3)), (1, (5, 6)), (2, (7, 8))] assert assign_taxis(taxis, requests) == expected def test_identical_request_start_points(): taxis = [1, 4, 6] requests = [(5, 8), (5, 6), (5, 10)] expected = [(1, (5, 8)), (2, (5, 6)), (0, (5, 10))] assert assign_taxis(taxis, requests) == expected","solution":"from typing import List, Tuple def assign_taxis(taxis: List[int], requests: List[Tuple[int, int]]) -> List[Tuple[int, Tuple[int, int]]]: assignments = [] available_taxis = list(enumerate(taxis)) for request in requests: if not available_taxis: break start_point, _ = request best_taxi_index = min(available_taxis, key=lambda x: abs(x[1] - start_point)) assignments.append((best_taxi_index[0], request)) available_taxis.remove(best_taxi_index) return assignments"},{"question":"def sort_names_by_age(people: List[Dict[str, Any]]) -> List[str]: Sorts and returns a list of names from the input list of dictionaries containing 'name' and 'age' keys, sorted by age in ascending order. If two individuals have the same age, their names should be sorted alphabetically. Args: people (list): List of dictionaries with 'name' (str) and 'age' (int) keys. Returns: list: List of names sorted by age and name. Examples: >>> sort_names_by_age([{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}, {'name': 'Charlie', 'age': 25}]) ['Bob', 'Charlie', 'Alice'] >>> sort_names_by_age([]) []","solution":"def sort_names_by_age(people): Sorts and returns a list of names from the input list of dictionaries containing 'name' and 'age' keys, sorted by age in ascending order. If two individuals have the same age, their names should be sorted alphabetically. Args: people (list): List of dictionaries with 'name' (str) and 'age' (int) keys. Returns: list: List of names sorted by age and name. sorted_people = sorted(people, key=lambda x: (x['age'], x['name'])) return [person['name'] for person in sorted_people] # Example usage: # people = [{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}, {'name': 'Charlie', 'age': 25}] # result = sort_names_by_age(people) # ['Bob', 'Charlie', 'Alice']"},{"question":"def remove_duplicates(lst: list) -> list: Returns a list with duplicate integers removed while preserving the order of first occurrence. Parameters: lst (list): A list of integers which may contain duplicates. Returns: list: A list with duplicates removed. >>> remove_duplicates([1, 2, 3, 2, 1, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 4, 7, 8, 8, 9]) [4, 5, 7, 8, 9] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([10, 20, 10, 30, 20, 40, 30, 50]) [10, 20, 30, 40, 50] >>> remove_duplicates([1]) [1]","solution":"def remove_duplicates(lst: list) -> list: Returns a list with duplicate integers removed while preserving the order of first occurrence. Parameters: lst (list): A list of integers which may contain duplicates. Returns: list: A list with duplicates removed. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def decode_alien_string(data: str) -> str: Decodes a string of space-separated integers in the range 1 to 26 to the corresponding characters in the Alpharion alphabet. :param data: A string of space-separated integers. :return: Decoded string of alphabets. >>> decode_alien_string(\\"20 5 1 13\\") 'TEAM' >>> decode_alien_string(\\"18 5 4\\") 'RED' >>> decode_alien_string(\\"8 15 16 5\\") 'HOPE'","solution":"def decode_alien_string(data: str) -> str: Decodes a string of space-separated integers in the range 1 to 26 to the corresponding characters in the Alpharion alphabet. :param data: A string of space-separated integers. :return: Decoded string of alphabets. # Split the input string into a list of integers nums = map(int, data.split()) # Convert each integer to the corresponding alphabet character decoded_chars = [chr(num + 64) for num in nums] # Join the list of characters into a decoded string and return it return ''.join(decoded_chars)"},{"question":"from typing import List def productExceptSelf(nums: List[int]) -> List[int]: Returns an array where each index contains the product of all elements except the one at the corresponding index in the input array. >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([0, 4, 5]) [20, 0, 0] >>> productExceptSelf([10]) [1] >>> productExceptSelf([0, 0, 0]) [0, 0, 0] >>> productExceptSelf([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> productExceptSelf([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"def productExceptSelf(nums): Returns an array where each index contains the product of all elements except the one at the corresponding index in the input array. length = len(nums) answer = [1] * length # Initialize the answer array with ones # Calculate products of all elements to the left of each index left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Calculate products of all elements to the right of each index right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def findNthPrime(n: int) -> int: Returns the nth prime number. >>> findNthPrime(1) 2 >>> findNthPrime(6) 13 >>> findNthPrime(10) 29 >>> findNthPrime(100) 541 >>> findNthPrime(1000) 7919 >>> findNthPrime(10000) 104729","solution":"def findNthPrime(n): Returns the nth prime number. if n == 1: return 2 limit = 104729 # Arbitrarily large limit to ensure we generate enough primes for n <= 10000 sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False primes = [] for num in range(2, limit + 1): if sieve[num]: primes.append(num) for multiple in range(num * num, limit + 1, num): sieve[multiple] = False if len(primes) >= n: break return primes[n - 1]"},{"question":"def can_be_expressed_as_sum_of_consecutive_integers(n): Returns True if n can be expressed as the sum of two or more consecutive positive integers. >>> can_be_expressed_as_sum_of_consecutive_integers(15) True >>> can_be_expressed_as_sum_of_consecutive_integers(10) True >>> can_be_expressed_as_sum_of_consecutive_integers(8) False >>> can_be_expressed_as_sum_of_consecutive_integers(6) True >>> can_be_expressed_as_sum_of_consecutive_integers(3) True","solution":"def can_be_expressed_as_sum_of_consecutive_integers(n): Returns True if n can be expressed as the sum of two or more consecutive positive integers. # The idea is to find if there exist k consecutive integers whose sum is n. # The sum of k consecutive integers starting from m is: m + (m+1) + (m+2) + ... + (m+k-1). # This can be simplified to k * m + k * (k-1) / 2 == n # or, k * (2 * m + k - 1) == 2 * n # => 2*n = k*(2*m + k - 1) for k in range(2, int((2*n)**0.5) + 1): if (2 * n) % k == 0: if ((2 * n // k) - k + 1) % 2 == 0: return True return False"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(n, values, edges): nodes = [TreeNode(values[i]) for i in range(n)] for u, v in edges: nodes[u - 1].children.append(nodes[v - 1]) nodes[v - 1].children.append(nodes[u - 1]) return nodes[0] def max_path_sum(tree): def dfs(node): if not node: return 0, float('-inf') max_root_to_node = node.value max_path = node.value for child in node.children: child.children.remove(node) # To ensure we do not revisit the parent child_max_root_to_node, child_max_path = dfs(child) max_root_to_node = max(max_root_to_node, node.value + child_max_root_to_node) max_path = max(max_path, max_root_to_node, child_max_path, node.value + child_max_root_to_node) return max_root_to_node, max_path _, max_path = dfs(tree) return max_path def find_max_path_sum_in_trees(T, test_cases): Calculates the maximum path sum for any path in a tree for each test case. Args: T (int): Number of test cases. test_cases (List[Tuple(int, List[int], List[Tuple[int, int]])]): List of test cases, where each test case is a tuple containing the number of nodes, a list of node values, and a list of edges. Returns: List[int]: List of maximum path sums for each test case. >>> T = 1 >>> test_cases = [(6, [1, 2, -3, 4, -2, 6], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)])] >>> find_max_path_sum_in_trees(T, test_cases) == [7] >>> T = 2 >>> test_cases = [ ... (6, [1, 2, -3, 4, -2, 6], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]), ... (5, [-1, -2, -3, -4, -5], [(1, 2), (1, 3), (2, 4), (3, 5)]) ... ] >>> find_max_path_sum_in_trees(T, test_cases) == [7, -1] >>> T = 1 >>> test_cases = [(5, [-9, -8, -7, -6, -5], [(1, 2), (1, 3), (2, 4), (3, 5)])] >>> find_max_path_sum_in_trees(T, test_cases) == [-5] >>> T = 1 >>> test_cases = [(2, [1, -1], [(1, 2)])] >>> find_max_path_sum_in_trees(T, test_cases) == [1]","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(n, values, edges): nodes = [TreeNode(values[i]) for i in range(n)] for u, v in edges: nodes[u - 1].children.append(nodes[v - 1]) nodes[v - 1].children.append(nodes[u - 1]) return nodes[0] def max_path_sum(tree): def dfs(node): if not node: return 0, float('-inf') max_root_to_node = node.value max_path = node.value for child in node.children: child.children.remove(node) # To ensure we do not revisit the parent child_max_root_to_node, child_max_path = dfs(child) max_root_to_node = max(max_root_to_node, node.value + child_max_root_to_node) max_path = max(max_path, max_root_to_node, child_max_path, node.value + child_max_root_to_node) return max_root_to_node, max_path _, max_path = dfs(tree) return max_path def find_max_path_sum_in_trees(T, test_cases): results = [] for case in test_cases: n, values, edges = case tree = build_tree(n, values, edges) max_sum = max_path_sum(tree) results.append(max_sum) return results # Example Usage T = 1 test_cases = [(6, [1, 2, -3, 4, -2, 6], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)])] print(find_max_path_sum_in_trees(T, test_cases)) # Output should be [7]"},{"question":"import numpy as np def reshape_array(n: int, m: int, elements: List[List[int]], k: int) -> Union[np.ndarray, str]: Given an array of shape NxM, read in an integer K and reshape the array into dimensions Kx(N*M//K). If it is not possible to reshape the array to the specified dimensions, return \\"Cannot reshape\\". >>> reshape_array(3, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], 4) array([[ 1, 2, 3], [ 4, 5, 6], [ 7, 8, 9], [10, 11, 12]]) >>> reshape_array(3, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], 5) \\"Cannot reshape\\" >>> reshape_array(1, 1, [[1]], 1) array([[1]]) >>> reshape_array(2, 2, [[1, 2], [3, 4]], 4) array([[1], [2], [3], [4]]) >>> reshape_array(1, 4, [[1, 2, 3, 4]], 4) array([[1], [2], [3], [4]])","solution":"import numpy as np def reshape_array(n, m, elements, k): if n * m % k != 0: return \\"Cannot reshape\\" else: flat_array = np.array(elements).flatten() reshaped_array = flat_array.reshape(k, n * m // k) return reshaped_array"},{"question":"from collections import deque class MovingAverage: A data structure that calculates the moving average of the last \`n\` values added to it. Methods: - __init__(self, n: int): Initializes the data structure with the size \`n\`. - add_value(self, value: float) -> None: Adds a new value to the data structure. - get_average(self) -> float: Returns the moving average of the last \`n\` values. If fewer than \`n\` values have been added, the moving average is calculated using the available values. Example: >>> ma = MovingAverage(3) >>> ma.add_value(1) >>> ma.add_value(10) >>> ma.get_average() 5.5 >>> ma.add_value(3) >>> ma.get_average() 4.666666666666667 >>> ma.add_value(5) >>> ma.get_average() 6.0 def __init__(self, n: int): pass def add_value(self, value: float) -> None: pass def get_average(self) -> float: pass from solution import MovingAverage def test_moving_average_initial(): ma = MovingAverage(3) assert ma.get_average() == 0 # No values added, average is 0 def test_moving_average_add_values_less_than_n(): ma = MovingAverage(3) ma.add_value(1) ma.add_value(10) assert ma.get_average() == 5.5 # Average of [1, 10] def test_moving_average_add_values_equal_to_n(): ma = MovingAverage(3) ma.add_value(1) ma.add_value(10) ma.add_value(3) assert ma.get_average() == 4.666666666666667 # Average of [1, 10, 3] def test_moving_average_add_values_more_than_n(): ma = MovingAverage(3) ma.add_value(1) ma.add_value(10) ma.add_value(3) ma.add_value(5) assert ma.get_average() == 6.0 # Average of [10, 3, 5] def test_moving_average_single_value(): ma = MovingAverage(3) ma.add_value(10) assert ma.get_average() == 10.0 # Average of [10] def test_moving_average_exact_n_values(): ma = MovingAverage(2) ma.add_value(1) ma.add_value(2) assert ma.get_average() == 1.5 # Average of [1, 2] ma.add_value(3) assert ma.get_average() == 2.5 # Average of [2, 3]","solution":"from collections import deque class MovingAverage: def __init__(self, n: int): self.n = n self.values = deque() self.sum = 0 def add_value(self, value: float) -> None: if len(self.values) == self.n: self.sum -= self.values.popleft() self.values.append(value) self.sum += value def get_average(self) -> float: if not self.values: return 0 return self.sum / len(self.values)"},{"question":"def max_full_games(T, test_cases): Determine the maximum number of games that can be fully staffed with available employees. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list containing the test cases. Each test case is a tuple where the first element is tuple (N, M) and the second element is a list of integers representing the number of participants required for each game. Returns: List[int]: A list containing the maximum number of games that can be fully staffed for each test case. Example: >>> test_cases = [((5, 15), [3, 8, 5, 2, 4]), ((4, 10), [1, 2, 3, 4])] >>> max_full_games(2, test_cases) [4, 4] from solution import max_full_games def test_sample_cases(): test_cases = [ ((5, 15), [3, 8, 5, 2, 4]), ((4, 10), [1, 2, 3, 4]) ] assert max_full_games(2, test_cases) == [4, 4] def test_single_game(): test_cases = [ ((1, 5), [3]), ((1, 4), [5]) ] assert max_full_games(2, test_cases) == [1, 0] def test_exact_match(): test_cases = [ ((3, 6), [2, 2, 2]), ((2, 5), [3, 2]) ] assert max_full_games(2, test_cases) == [3, 2] def test_insufficient_employees(): test_cases = [ ((3, 4), [3, 5, 2]), ((4, 7), [8, 1, 1, 1]) ] assert max_full_games(2, test_cases) == [1, 3] def test_large_number_of_games(): test_cases = [ ((10, 50), [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]), ((5, 20), [4, 4, 4, 4, 4]) ] assert max_full_games(2, test_cases) == [10, 5]","solution":"def max_full_games(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] participants_required = test_cases[i][1] participants_required.sort() game_count = 0 for participants in participants_required: if M >= participants: M -= participants game_count += 1 else: break results.append(game_count) return results"},{"question":"def custom_map(func, iterable): Simulates the behavior of the built-in 'map' function without using 'map' itself or any other high-level function like 'filter' or 'reduce'. The purpose is to apply the given function 'func' to each item of 'iterable' and yield the results one by one using a generator. Conditions: - The function must be implemented as a generator. - The function should accept two arguments: a function to apply and an iterable. - The function should be able to handle any kind of iterable and apply any kind of function that normally works with 'map'. Example usage: >>> def square(x): ... return x * x ... >>> result = custom_map(square, [1, 2, 3, 4, 5]) >>> list(result) [1, 4, 9, 16, 25] >>> def str_len(s): ... return len(s) ... >>> result = custom_map(str_len, [\\"apple\\", \\"banana\\", \\"cherry\\"]) >>> list(result) [5, 6, 6] # Your code here def test_custom_map_with_square(): def square(x): return x * x result = custom_map(square, [1, 2, 3, 4, 5]) assert list(result) == [1, 4, 9, 16, 25] def test_custom_map_with_empty_iterable(): def square(x): return x * x result = custom_map(square, []) assert list(result) == [] def test_custom_map_with_string_length(): def str_len(s): return len(s) result = custom_map(str_len, [\\"apple\\", \\"banana\\", \\"cherry\\"]) assert list(result) == [5, 6, 6] def test_custom_map_with_tuple(): def double(x): return x * 2 result = custom_map(double, (1, 2, 3)) assert list(result) == [2, 4, 6] def test_custom_map_mixed_data_types(): def to_string(x): return str(x) result = custom_map(to_string, [1, 2.5, True, None, [1,2], (3,4)]) assert list(result) == ['1', '2.5', 'True', 'None', '[1, 2]', '(3, 4)'] def test_custom_map_large_numbers(): def increment(x): return x + 1 large_list = range(1_000_000) result = custom_map(increment, large_list) assert list(result) == list(range(1, 1_000_001)) def test_custom_map_with_strings(): def shout(x): return x.upper() result = custom_map(shout, [\\"hello\\", \\"world\\"]) assert list(result) == [\\"HELLO\\", \\"WORLD\\"]","solution":"def custom_map(func, iterable): Applies the function 'func' to each item of 'iterable' and yields the results one by one. for item in iterable: yield func(item)"},{"question":"from typing import List def most_frequent(arr: List[int]) -> int: Returns the most frequent integer in the array. If there are multiple integers with the same highest frequency, returns the one that appears first in the array. >>> most_frequent([1, 3, 1, 3, 2, 1]) 1 >>> most_frequent([3, 3, 1, 3, 2, 1]) 3 >>> most_frequent([1, 3, 2, 3, 2, 1]) 1 >>> most_frequent([1, 1, 2, 2, 3, 3, 3]) 3 pass def test_most_frequent(): assert most_frequent([1, 3, 1, 3, 2, 1]) == 1 assert most_frequent([3, 3, 1, 3, 2, 1]) == 3 assert most_frequent([1, 3, 2, 3, 2, 1]) == 1 assert most_frequent([1, 1, 2, 2, 3, 3, 3]) == 3 assert most_frequent([1, 2, 2, 1]) == 1 assert most_frequent([4, 5, 6, 5, 6, 4, 6]) == 6 assert most_frequent([1, 2, 3, 4, 5]) == 1 assert most_frequent([99]) == 99 assert most_frequent([1, 2, 3]) == 1","solution":"def most_frequent(arr): Returns the most frequent integer in the array. If there are multiple integers with the same highest frequency, returns the one that appears first in the array. frequency = {} highest_freq = 0 most_frequent_element = arr[0] for num in arr: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Check if this is the new highest frequency or comes first in case of tie if frequency[num] > highest_freq or (frequency[num] == highest_freq and arr.index(num) < arr.index(most_frequent_element)): highest_freq = frequency[num] most_frequent_element = num return most_frequent_element"},{"question":"def min_practice_sessions(N: int, A: List[int], X: int) -> int: Returns the minimum number of practice sessions Chef needs to make sure he can solve all the problems. Parameters: N (int): The number of problems. A (list of int): The skill levels required to solve each problem. X (int): Chef's initial skill level. Returns: int: The minimum number of practice sessions required. pass # Implement the function here # Unit tests def test_example_case(): N = 5 A = [3, 5, 7, 6, 2] X = 4 assert min_practice_sessions(N, A, X) == 3 def test_no_sessions_needed(): N = 3 A = [2, 3, 1] X = 4 assert min_practice_sessions(N, A, X) == 0 def test_all_same_skill_levels(): N = 5 A = [3, 3, 3, 3, 3] X = 3 assert min_practice_sessions(N, A, X) == 0 def test_just_below_requirement(): N = 2 A = [4, 8] X = 7 assert min_practice_sessions(N, A, X) == 1 def test_large_numbers(): N = 3 A = [1000000, 999999, 1000000] X = 900000 assert min_practice_sessions(N, A, X) == 100000","solution":"def min_practice_sessions(N, A, X): Returns the minimum number of practice sessions Chef needs to make sure he can solve all the problems. Parameters: N (int): The number of problems. A (list of int): The skill levels required to solve each problem. X (int): Chef's initial skill level. Returns: int: The minimum number of practice sessions required. # Find the maximum skill level required among all problems max_skill = max(A) # Calculate the number of practice sessions needed if X >= max_skill: return 0 else: return max_skill - X"},{"question":"from typing import List def search_products(products: List[str], query: str) -> List[str]: Returns a list of products that match the search query. The query must appear in the product string in the same order as specified. The search is case-insensitive. Examples: >>> search_products([\\"Apple iPhone 12\\", \\"Samsung Galaxy S21\\", \\"Apple iPhone 12 Pro\\", \\"Xiaomi Mi 11\\"], \\"Apple iPhone\\") [\\"Apple iPhone 12\\", \\"Apple iPhone 12 Pro\\"] >>> search_products([\\"Apple iPhone 12\\", \\"Samsung Galaxy S21\\", \\"Apple iPhone 12 Pro\\", \\"Xiaomi Mi 11\\"], \\"Galaxy\\") [\\"Samsung Galaxy S21\\"] >>> search_products([\\"Apple iPhone 12\\", \\"Samsung Galaxy S21\\", \\"Apple iPhone 12 Pro\\", \\"Xiaomi Mi 11\\"], \\"Pixel\\") [] >>> search_products([\\"Dell XPS 13\\", \\"Dell Inspiron\\", \\"HP Spectre x360\\", \\"Asus ZenBook\\"], \\"Dell\\") [\\"Dell XPS 13\\", \\"Dell Inspiron\\"] >>> search_products([\\"Apple MacBook Air\\", \\"Lenovo ThinkPad\\", \\"Microsoft Surface Pro\\"], \\"\\") [\\"Apple MacBook Air\\", \\"Lenovo ThinkPad\\", \\"Microsoft Surface Pro\\"]","solution":"from typing import List def search_products(products: List[str], query: str) -> List[str]: Returns a list of products that match the search query. The query must appear in the product string in the same order as specified. The search is case-insensitive. query_lower = query.lower() matching_products = [] for product in products: if query_lower in product.lower(): matching_products.append(product) return matching_products"},{"question":"from typing import List class FileSystem: File System Simulation Class to handle directories and files. This class provides methods to create directories, add files, change directories, list directory contents, and read file contents. Example Usage: >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.addFile(\\"/a/b/c/d.txt\\", \\"Hello World\\") >>> fs.cd(\\"/a/b/c\\") >>> fs.ls(\\"/a/b/c\\") # Output: ['d.txt'] >>> fs.readFile(\\"/a/b/c/d.txt\\") # Output: \\"Hello World\\" >>> fs.addFile(\\"/a/e/f/g.txt\\", \\"Data Science\\") >>> fs.ls(\\"/a/e/f\\") # Output: ['g.txt'] >>> fs.ls(\\"/a/b\\") # Output: ['c'] def __init__(self): self.fs = {'': {}} self.current_dir = '' def _get_dir(self, path: str): parts = path.split('/') cur = self.fs[''] for part in parts: if part: if part not in cur: cur[part] = {} cur = cur[part] return cur def mkdir(self, path: str): Creates a directory at the given path. def addFile(self, path: str, contents: str): Creates a file at the given path with the given contents. def cd(self, path: str): Changes the current directory to the specified path. def ls(self, path: str = None) -> List[str]: Lists the contents of the directory at the specified path. def readFile(self, path: str) -> str: Returns the contents of the file at the given path. def test_mkdir_and_ls(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") assert fs.ls(\\"/a/b\\") == ['c'] def test_addFile_and_ls(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.addFile(\\"/a/b/c/d.txt\\", \\"Hello World\\") assert fs.ls(\\"/a/b/c\\") == ['d.txt'] def test_addFile_and_readFile(): fs = FileSystem() fs.addFile(\\"/a/b/c/d.txt\\", \\"Hello World\\") assert fs.readFile(\\"/a/b/c/d.txt\\") == \\"Hello World\\" def test_cd_and_ls(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.cd(\\"/a/b/c\\") fs.addFile(\\"/a/b/c/d.txt\\", \\"Hello World\\") assert fs.ls() == ['d.txt'] def test_addFile_in_nested_directories(): fs = FileSystem() fs.addFile(\\"/a/e/f/g.txt\\", \\"Data Science\\") assert fs.ls(\\"/a/e/f\\") == ['g.txt'] def test_ls_in_different_directories(): fs = FileSystem() fs.addFile(\\"/a/b/c/d.txt\\", \\"Hello World\\") fs.addFile(\\"/a/e/f/g.txt\\", \\"Data Science\\") assert fs.ls(\\"/a/b\\") == ['c'] assert fs.ls(\\"/a/e\\") == ['f'] assert fs.ls(\\"/a\\") == ['b', 'e']","solution":"class FileSystem: def __init__(self): self.fs = {'': {}} self.current_dir = '' def _get_dir(self, path: str): parts = path.split('/') cur = self.fs[''] for part in parts: if part: if part not in cur: cur[part] = {} cur = cur[part] return cur def mkdir(self, path: str): self._get_dir(path) def addFile(self, path: str, contents: str): parts = path.split('/') file_name = parts.pop() directory = '/'.join(parts) dir_dict = self._get_dir(directory) dir_dict[file_name] = contents def cd(self, path: str): self.current_dir = path def ls(self, path: str = None): if path is None: path = self.current_dir dir_dict = self._get_dir(path) return sorted([key for key in dir_dict]) def readFile(self, path: str): parts = path.split('/') file_name = parts.pop() directory = '/'.join(parts) dir_dict = self._get_dir(directory) return dir_dict[file_name]"},{"question":"def group_and_sort_by_first_occurrence(lst: List[int]) -> List[int]: Given a list of integers, group all the identical elements together and return the sorted list based on the first occurrence of each number. >>> group_and_sort_by_first_occurrence([4, 5, 6, 4, 6, 6, 7, 4, 7, 4]) [4, 4, 4, 4, 5, 6, 6, 6, 7, 7] >>> group_and_sort_by_first_occurrence([1, 2, 3, 1, 2, 1, 2, 3, 4, 3, 4]) [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4] >>> group_and_sort_by_first_occurrence([9, 9, 8, 8, 7, 8, 9, 7]) [9, 9, 9, 8, 8, 8, 7, 7] >>> group_and_sort_by_first_occurrence([1]) [1] >>> group_and_sort_by_first_occurrence([]) [] >>> group_and_sort_by_first_occurrence([5, 3, 1, 2, 4]) [5, 3, 1, 2, 4] >>> group_and_sort_by_first_occurrence([4, 4, 4, 4]) [4, 4, 4, 4] >>> input_list = [1] * 100 + [2] * 100 + [3] * 100 >>> expected_output = [1] * 100 + [2] * 100 + [3] * 100 >>> group_and_sort_by_first_occurrence(input_list) expected_output","solution":"def group_and_sort_by_first_occurrence(lst): Groups all identical elements together and returns the list sorted based on the first occurrence of each number. from collections import defaultdict groups = defaultdict(list) for number in lst: groups[number].append(number) result = [] seen = set() for number in lst: if number not in seen: result.extend(groups[number]) seen.add(number) return result"},{"question":"def shortest_travel_time(grid): Returns the shortest possible time (in minutes) to navigate from the top-left corner (0,0) to the bottom-right corner (n-1, m-1) of the grid. >>> shortest_travel_time([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> shortest_travel_time([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21 >>> shortest_travel_time([ ... [1, 2], ... [1, 1] ... ]) == 3 >>> shortest_travel_time([ ... [4, 9], ... [4, 8] ... ]) == 16 >>> shortest_travel_time([]) == -1","solution":"import heapq def shortest_travel_time(grid): Returns the shortest possible time (in minutes) to navigate from the top-left corner (0,0) to the bottom-right corner (n-1, m-1) of the grid. if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Priority queue for Dijkstra's algorithm pq = [(grid[0][0], 0, 0)] # (cost, x, y) visited = [[False] * m for _ in range(n)] while pq: cost, x, y = heapq.heappop(pq) if x == n - 1 and y == m - 1: return cost if visited[x][y]: continue visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: heapq.heappush(pq, (cost + grid[nx][ny], nx, ny)) return -1"},{"question":"def grades(scores): Returns the corresponding grades for a list of scores. Parameters: scores (list): List of integer scores ranging from 0 to 100. Returns: list or str: List of corresponding grades or 'Outstanding!' if all grades are 'Excellent'. from solution import grades def test_grades_with_various_scores(): assert grades([45, 55, 65, 75, 85]) == ['Fail', 'Pass', 'Good', 'Very Good', 'Excellent'] assert grades([50, 50, 50]) == ['Pass', 'Pass', 'Pass'] assert grades([85, 90, 95, 100]) == 'Outstanding!' def test_grades_all_fail(): assert grades([45, 44, 49]) == ['Fail', 'Fail', 'Fail'] def test_grades_all_pass(): assert grades([55, 58, 59]) == ['Pass', 'Pass', 'Pass'] def test_grades_all_good(): assert grades([65, 66, 69]) == ['Good', 'Good', 'Good'] def test_grades_all_very_good(): assert grades([75, 77, 79]) == ['Very Good', 'Very Good', 'Very Good'] def test_grades_all_excellent_but_one(): assert grades([85, 85, 95, 50]) == ['Excellent', 'Excellent', 'Excellent', 'Pass'] def test_grades_empty_list(): assert grades([]) == [] def test_grades_mixed_scores(): assert grades([40, 60, 70, 80]) == ['Fail', 'Good', 'Very Good', 'Excellent']","solution":"def grades(scores): Returns the corresponding grades for a list of scores. Parameters: scores (list): List of integer scores ranging from 0 to 100. Returns: list or str: List of corresponding grades or 'Outstanding!' if all grades are 'Excellent'. if not scores: return [] grade_list = [] for score in scores: if score < 50: grade_list.append('Fail') elif 50 <= score <= 59: grade_list.append('Pass') elif 60 <= score <= 69: grade_list.append('Good') elif 70 <= score <= 79: grade_list.append('Very Good') else: grade_list.append('Excellent') if all(grade == 'Excellent' for grade in grade_list): return 'Outstanding!' return grade_list"},{"question":"def organize_books(T: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Organize the books on the shelf in such a way that the number of continuous empty slots between any two books is exactly K. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, int]]): Each tuple contains three integers — N (number of slots), M (number of books), and K (required number of continuous empty slots). Returns: List[str]: List of strings representing the 1-based positions where the books should be placed, or -1 if it's not possible. Examples: >>> organize_books(3, [(10, 3, 2), (7, 5, 0), (8, 4, 1)]) [\\"1 4 7\\", \\"1 2 3 4 5\\", \\"1 3 5 7\\"] >>> organize_books(1, [(5, 3, 2)]) [\\"-1\\"] >>> organize_books(1, [(5, 5, 0)]) [\\"1 2 3 4 5\\"] >>> organize_books(1, [(6, 2, 4)]) [\\"1 6\\"] >>> organize_books(1, [(10, 1, 9)]) [\\"1\\"] >>> organize_books(1, [(12, 3, 0)]) [\\"1 2 3\\"]","solution":"def organize_books(T, test_cases): results = [] for i in range(T): N, M, K = test_cases[i] max_slots_needed = (M - 1) * K + M if max_slots_needed > N: results.append(\\"-1\\") else: positions = [] current_position = 1 for j in range(M): positions.append(current_position) current_position += K + 1 results.append(\\" \\".join(map(str, positions))) return results"},{"question":"from typing import List def searchUsernames(usernames: List[str], query: str) -> List[str]: Given a list of usernames and a search query, returns a list of usernames that contain the query as a substring. Args: usernames (List[str]): A list of usernames as strings. query (String): The search string to look for within the usernames. Returns: List[str]: A list of usernames that contain the query string as a substring. Example: >>> searchUsernames([\\"alice\\", \\"bob\\", \\"charlie\\", \\"david\\", \\"eve\\"], \\"a\\") [\\"alice\\", \\"charlie\\", \\"david\\"] >>> searchUsernames([\\"alice\\", \\"bob\\", \\"charlie\\", \\"david\\", \\"eve\\"], \\"z\\") [] pass","solution":"from typing import List def searchUsernames(usernames: List[str], query: str) -> List[str]: Given a list of usernames and a search query, returns a list of usernames that contain the query as a substring. return [username for username in usernames if query in username]"},{"question":"def sum_of_squares(n: int) -> int: Returns the sum of the squares of all the numbers from 1 to n. >>> sum_of_squares(3) 14 >>> sum_of_squares(10) 385","solution":"def sum_of_squares(n): Returns the sum of the squares of all the numbers from 1 to n. return sum(i ** 2 for i in range(1, n + 1))"},{"question":"def digit_sum(n): Calculate the sum of digits of a number until it is a single digit. >>> digit_sum(19) 1 >>> digit_sum(123) 6 pass # Replace this with the implementation def generate_sequence(P, test_cases): Generate a sequence based on the input number N for P test cases. The sequence should list each intermediate transformation step. >>> generate_sequence(3, [3, 5, 7]) [1, 2, 3, \\"\\", 1, 2, 3, 4, 5, \\"\\", 1, 2, 3, 4, 5, 6, 7, \\"\\"] >>> generate_sequence(1, [4]) [1, 2, 3, 4, \\"\\"] pass # Replace this with the implementation","solution":"def digit_sum(n): while n >= 10: n = sum(int(digit) for digit in str(n)) return n def generate_sequence(P, test_cases): result = [] for N in test_cases: for i in range(1, N+1): result.append(digit_sum(i)) result.append(\\"\\") # for separating different test case results return result # Example usage # P = 3 # test_cases = [3, 5, 7] # print(generate_sequence(P, test_cases))"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Determines if one string is a permutation of the other. Args: str1 (str): First string. str2 (str): Second string. Returns: bool: True if one string is a permutation of the other, False otherwise. >>> is_permutation(\\"listen\\", \\"silent\\") True >>> is_permutation(\\"triangle\\", \\"integral\\") True >>> is_permutation(\\"apple\\", \\"pale\\") False >>> is_permutation(\\"aabbcc\\", \\"abcabc\\") True >>> is_permutation(\\"aabbcc\\", \\"abccba\\") True >>> is_permutation(\\"aabbcc\\", \\"abbbc\\") False >>> is_permutation(\\"\\", \\"\\") True >>> is_permutation(\\"a\\", \\"a\\") True >>> is_permutation(\\"a\\", \\"b\\") False >>> is_permutation(\\"Listen\\", \\"Silent\\") False >>> is_permutation(\\"abc\\", \\"ABC\\") False >>> is_permutation(\\"a#1\\", \\"1#a\\") True >>> is_permutation(\\"a#1\\", \\"1#b\\") False >>> is_permutation(\\"!@#\\", \\"@!#\\") True","solution":"def is_permutation(str1, str2): Determines if one string is a permutation of the other. Args: str1 (str): First string. str2 (str): Second string. Returns: bool: True if one string is a permutation of the other, False otherwise. # If the lengths are different, they cannot be permutations if len(str1) != len(str2): return False # Sort the strings; if they are permutations, sorted versions will be the same return sorted(str1) == sorted(str2)"},{"question":"def max_rides(rides: List[List[int]]) -> int: Determines the maximum number of non-overlapping rides a visitor can take in a day. Args: rides (List[List[int]]): List of rides with their start and end times. Returns: int: Maximum number of rides a visitor can take in a day. Examples: >>> max_rides([[1, 3], [2, 4], [3, 5]]) 2 >>> max_rides([[0, 1], [3, 5], [4, 8], [10, 11]]) 3","solution":"def max_rides(rides): Determines the maximum number of non-overlapping rides a visitor can take in a day. Args: rides (List[List[int]]): List of rides with their start and end times. Returns: int: Maximum number of rides a visitor can take in a day. # Sort rides based on their end times rides.sort(key=lambda x: x[1]) # Initialize variables count = 0 last_end_time = 0 for start, end in rides: if start >= last_end_time: # Take this ride count += 1 last_end_time = end return count"},{"question":"def is_palindrome(s: str) -> bool: Returns True if s is a palindrome, ignoring spaces, punctuation, and case; otherwise, returns False. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Hello World\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"123a321\\") == True","solution":"import re def is_palindrome(s): Returns True if s is a palindrome, ignoring spaces, punctuation, and case; otherwise, returns False. # Remove non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"def find_fib_with_k_digits(k: int) -> int: Returns the smallest Fibonacci number that has at least k digits. >>> find_fib_with_k_digits(1) == 1 >>> find_fib_with_k_digits(2) == 13 >>> find_fib_with_k_digits(3) == 144 >>> find_fib_with_k_digits(10) == 1134903170 >>> find_fib_with_k_digits(5) == 10946","solution":"def find_fib_with_k_digits(k: int) -> int: Returns the smallest Fibonacci number that has at least k digits. if k <= 0: raise ValueError(\\"k must be a positive integer.\\") # The first two Fibonacci numbers a, b = 1, 1 index = 2 # because we already have F_1 and F_2 which are both '1' # Loop until we find a Fibonacci number with at least k digits while len(str(b)) < k: a, b = b, a + b index += 1 return b"},{"question":"def purchase_tickets(total_tickets, max_tickets_per_purchase, requested_tickets): Simulates a basic ticket purchasing system for an event. Parameters: - total_tickets (int): The total number of tickets available. - max_tickets_per_purchase (int): The maximum number of tickets a user can purchase in one transaction. - requested_tickets (int): The number of tickets the user wants to purchase. Returns: - str: Message indicating the success or failure of the purchase. pass # Example 1: # total_tickets = 50, max_tickets_per_purchase = 5, requested_tickets = 3 # Output: \\"Purchase successful\\" # Example 2: # total_tickets = 2, max_tickets_per_purchase = 5, requested_tickets = 3 # Output: \\"Not enough tickets available\\" # Example 3: # total_tickets = 50, max_tickets_per_purchase = 5, requested_tickets = 7 # Output: \\"Cannot purchase more than 5 tickets\\"","solution":"def purchase_tickets(total_tickets, max_tickets_per_purchase, requested_tickets): Simulates a basic ticket purchasing system for an event. Parameters: - total_tickets (int): The total number of tickets available. - max_tickets_per_purchase (int): The maximum number of tickets a user can purchase in one transaction. - requested_tickets (int): The number of tickets the user wants to purchase. Returns: - str: Message indicating the success or failure of the purchase. if requested_tickets > max_tickets_per_purchase: return f\\"Cannot purchase more than {max_tickets_per_purchase} tickets\\" if requested_tickets > total_tickets: return \\"Not enough tickets available\\" return \\"Purchase successful\\""},{"question":"def int_to_roman(num: int) -> str: Convert a positive integer to its corresponding Roman numeral representation. :param num: The integer number to convert (1 <= num <= 3999) :return: A string representing the Roman numeral. >>> int_to_roman(1) 'I' >>> int_to_roman(4) 'IV' >>> int_to_roman(99) 'XCIX' >>> int_to_roman(3999) 'MMMCMXCIX' # Your implementation here","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: The integer number to convert (1 <= num <= 3999) :return: A string representing the Roman numeral. # Define the mapping of integers to Roman numeral strings. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syms[i] num -= val[i] i += 1 return roman_numeral"},{"question":"from typing import List def longest_arith_seq_length(nums: List[int]) -> int: Write a function \`longest_arith_seq_length\` that receives a list of integers and returns the length of the longest arithmetic subsequence in the list. An arithmetic subsequence is a subsequence that follows the property where the difference between consecutive elements is always the same. >>> longest_arith_seq_length([]) == 0 >>> longest_arith_seq_length([1]) == 1 >>> longest_arith_seq_length([1, 3]) == 2 >>> longest_arith_seq_length([1, 10, 100]) == 2 >>> longest_arith_seq_length([3, 6, 9, 12, 15]) == 5 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) == 3 >>> longest_arith_seq_length([1, 3, 4, 7, 8, 10]) == 4 # [1, 4, 7, 10] >>> longest_arith_seq_length([1, 100000]) == 2 >>> longest_arith_seq_length([1, 2, 4, 8, 16, 32, 3, 9, 27]) == 3 # Sequences like [1, 4, 7], [2, 6, 10], or similar","solution":"def longest_arith_seq_length(nums): if not nums: return 0 n = len(nums) if n == 1: return 1 dp = [{} for _ in range(n)] longest = 2 for i in range(n): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest = max(longest, dp[i][diff]) return longest"},{"question":"def minimumSwaps(arr: List[int]) -> int: Returns the minimum number of swaps required to sort an array of integers in ascending order. >>> minimumSwaps([4, 3, 1, 2]) 3 >>> minimumSwaps([1, 2, 3, 4, 5]) 0 >>> minimumSwaps([5, 4, 3, 2, 1]) 2 >>> minimumSwaps([1]) 0 >>> minimumSwaps([2, 1]) 1 >>> minimumSwaps([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 5","solution":"def minimumSwaps(arr): Returns the minimum number of swaps required to sort the array. n = len(arr) arrpos = [(val, idx) for idx, val in enumerate(arr)] # Sort the array by array values arrpos.sort(key=lambda it: it[0]) # To keep track of visited elements vis = {k: False for k in range(n)} ans = 0 for i in range(n): # already swapped and corrected or already present at correct pos if vis[i] or arrpos[i][1] == i: continue # Find out the number of nodes in this cycle and add it to ans cycle_size, j = 0, i while not vis[j]: vis[j] = True # move to indexed arrayposs array index j = arrpos[j][1] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"class Library: A class used to represent a Library that organizes books by their genre and keeps track of each book's borrowing status. Methods ------- add_book(title, author, genre): Adds a new book to the library. remove_book(title): Removes a book by title. borrow_book(title): Sets the book's status to borrowed. return_book(title): Sets the book's status to available. list_books(): Returns a dictionary where each key is a genre and the value is a list of books (titles) in that genre. summary(): Returns a tuple with the total number of books and the total number of borrowed books. def add_book(self, title, author, genre): Adds a new book to the library. pass def remove_book(self, title): Removes a book by title. pass def borrow_book(self, title): Sets the book's status to borrowed. pass def return_book(self, title): Sets the book's status to available. pass def list_books(self): Returns a dictionary where each key is a genre and the value is a list of books (titles) in that genre. pass def summary(self): Returns a tuple with the total number of books and the total number of borrowed books. pass import pytest def test_add_book(): library = Library() library.add_book(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", \\"Fantasy\\") assert \\"The Hobbit\\" in library.books def test_remove_book(): library = Library() library.add_book(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", \\"Fantasy\\") library.remove_book(\\"The Hobbit\\") assert \\"The Hobbit\\" not in library.books def test_borrow_book(): library = Library() library.add_book(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", \\"Fantasy\\") library.borrow_book(\\"The Hobbit\\") assert library.books[\\"The Hobbit\\"][\\"borrowed\\"] == True def test_return_book(): library = Library() library.add_book(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", \\"Fantasy\\") library.borrow_book(\\"The Hobbit\\") library.return_book(\\"The Hobbit\\") assert library.books[\\"The Hobbit\\"][\\"borrowed\\"] == False def test_list_books(): library = Library() library.add_book(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", \\"Fantasy\\") library.add_book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\") library.add_book(\\"Harry Potter\\", \\"J.K. Rowling\\", \\"Fantasy\\") result = library.list_books() expected = { \\"Fantasy\\": [\\"The Hobbit\\", \\"Harry Potter\\"], \\"Dystopian\\": [\\"1984\\"] } assert result == expected def test_summary(): library = Library() library.add_book(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", \\"Fantasy\\") library.add_book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\") library.borrow_book(\\"The Hobbit\\") total, borrowed = library.summary() assert total == 2 assert borrowed == 1 library.return_book(\\"The Hobbit\\") total, borrowed = library.summary() assert total == 2 assert borrowed == 0","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title, author, genre): if title not in self.books: self.books[title] = { \\"author\\": author, \\"genre\\": genre, \\"borrowed\\": False } def remove_book(self, title): if title in self.books: del self.books[title] def borrow_book(self, title): if title in self.books and not self.books[title][\\"borrowed\\"]: self.books[title][\\"borrowed\\"] = True def return_book(self, title): if title in self.books and self.books[title][\\"borrowed\\"]: self.books[title][\\"borrowed\\"] = False def list_books(self): genres = {} for title, details in self.books.items(): genre = details[\\"genre\\"] if genre not in genres: genres[genre] = [] genres[genre].append(title) return genres def summary(self): total_books = len(self.books) borrowed_books = sum(1 for book in self.books.values() if book[\\"borrowed\\"]) return total_books, borrowed_books"},{"question":"def max_playground_size(matrix: List[List[int]], N: int, M: int) -> int: Returns the maximum size K of the playground that can be built in the given park matrix of size N x M. from solution import max_playground_size def test_example_input(): matrix = [ [1, 0, 1, 0, 0], [1, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 1, 0, 0, 0], [1, 0, 0, 1, 1] ] assert max_playground_size(matrix, 5, 5) == 2 def test_no_possible_playground(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_playground_size(matrix, 3, 3) == 0 def test_entire_matrix_as_playground(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_playground_size(matrix, 3, 3) == 3 def test_mixed_matrix(): matrix = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert max_playground_size(matrix, 3, 3) == 1 def test_single_row(): matrix = [ [0, 0, 0, 1, 0] ] assert max_playground_size(matrix, 1, 5) == 1 def test_single_column(): matrix = [ [1], [0], [0], [1] ] assert max_playground_size(matrix, 4, 1) == 1","solution":"def max_playground_size(matrix, N, M): Returns the maximum size K of the playground that can be built in the given park matrix of size N x M. # Create a DP table to store the size of the largest square sub-matrix # ending at each cell. dp = [[0] * M for _ in range(N)] max_size = 0 for i in range(N): for j in range(M): if i == 0 or j == 0: dp[i][j] = 1 - matrix[i][j] elif matrix[i][j] == 0: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"def sort_strings_lexicographically(n: int, strings: List[str]) -> List[str]: Given a list of strings, output them in lexicographical order. Parameters: n (int): The number of strings in the list. strings (list): The list of strings to sort. Returns: list: The list of strings sorted in lexicographical order. Example: >>> sort_strings_lexicographically(4, [\\"banana\\", \\"apple\\", \\"cherry\\", \\"date\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] >>> sort_strings_lexicographically(3, [\\"cat\\", \\"bat\\", \\"rat\\"]) [\\"bat\\", \\"cat\\", \\"rat\\"] pass","solution":"def sort_strings_lexicographically(n, strings): Returns the list of strings sorted in lexicographical order. Parameters: n (int): The number of strings in the list. strings (list): The list of strings to sort. Returns: list: The list of strings sorted in lexicographical order. return sorted(strings)"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string \\"\\". >>> longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) '' >>> longest_common_prefix([\\"interspecies\\",\\"interstellar\\",\\"interstate\\"]) 'inters' >>> longest_common_prefix([\\"\\", \\"b\\", \\"c\\"]) '' >>> longest_common_prefix([\\"\\", \\"\\", \\"\\"]) '' >>> longest_common_prefix([\\"single\\"]) 'single' >>> longest_common_prefix([\\"ab\\", \\"a\\"]) 'a' >>> longest_common_prefix([\\"Case\\", \\"Casey\\", \\"Cases\\"]) 'Case' >>> longest_common_prefix([]) ''","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string \\"\\". if not strs: return \\"\\" # Start by assuming the entire first string is the common prefix prefix = strs[0] # Compare the prefix with each string in the array for string in strs[1:]: while not string.startswith(prefix): # Shorten the prefix by one character at a time prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"from typing import List def count_paths(grid: List[List[str]]) -> int: Returns the number of unique paths from the top-left to the bottom-right corner of the grid. >>> count_paths([ ['.', '.', '.', '#'], ['.', '#', '.', '.'], ['#', '.', '.', '.'], ['.', '.', '#', '.'] ]) 2 >>> count_paths([ ['.', '#'], ['#', '.'] ]) 0","solution":"from typing import List def count_paths(grid: List[List[str]]) -> int: Returns the number of unique paths from the top-left to the bottom-right corner of the grid. if not grid or grid[0][0] == '#' or grid[-1][-1] == '#': return 0 M, N = len(grid), len(grid[0]) dp = [[0] * N for _ in range(M)] dp[0][0] = 1 # Start at the top-left corner for r in range(M): for c in range(N): if grid[r][c] == '#': dp[r][c] = 0 else: if r > 0: dp[r][c] += dp[r-1][c] if c > 0: dp[r][c] += dp[r][c-1] return dp[-1][-1]"},{"question":"def mirrored_triangle(n: int) -> None: Prints a mirrored right-angled triangle pattern with n rows. >>> mirrored_triangle(1) * >>> mirrored_triangle(3) * ** ***","solution":"def mirrored_triangle(n: int) -> None: Prints a mirrored right-angled triangle pattern with n rows. for i in range(1, n + 1): print(' ' * (n - i) + '*' * i)"},{"question":"def uniquePathsWithObstacles(obstacleGrid): Computes the number of unique paths from top-left corner to bottom-right corner in a grid with obstacles. :param obstacleGrid: List of List of integers where 0 represents empty cell and 1 represents an obstacle. :return: Integer indicating the number of unique paths.","solution":"def uniquePathsWithObstacles(obstacleGrid): Computes the number of unique paths from top-left corner to bottom-right corner in a grid with obstacles. :param obstacleGrid: List of List of integers where 0 represents empty cell and 1 represents an obstacle. :return: Integer indicating the number of unique paths. if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(1, m): dp[i][0] = dp[i-1][0] if obstacleGrid[i][0] == 0 else 0 for j in range(1, n): dp[0][j] = dp[0][j-1] if obstacleGrid[0][j] == 0 else 0 for i in range(1, m): for j in range(1, n): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"def is_lucky_number(n: int) -> bool: Checks if a number is a lucky number i.e., it contains only the digits 4 and 7. >>> is_lucky_number(4) == True >>> is_lucky_number(7) == True >>> is_lucky_number(44) == True >>> is_lucky_number(47) == True >>> is_lucky_number(5) == False >>> is_lucky_number(123) == False >>> is_lucky_number(4748) == False pass def count_lucky_numbers(A: int, B: int) -> int: Returns the count of lucky numbers within the range [A, B] inclusive. >>> count_lucky_numbers(1, 10) == 2 # 4, 7 >>> count_lucky_numbers(4, 7) == 2 # 4, 7 >>> count_lucky_numbers(40, 47) == 2 # 44, 47 >>> count_lucky_numbers(1, 1) == 0 # no lucky number in range 1 to 1 >>> count_lucky_numbers(44, 44) == 1 # 44 >>> count_lucky_numbers(100, 200) == 0 # no lucky number in range 100 to 200 pass def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) results = [] index = 1 for _ in range(T): A = int(data[index]) B = int(data[index + 1]) results.append(count_lucky_numbers(A, B)) index += 2 for result in results: print(result)","solution":"def is_lucky_number(n): Checks if a number is a lucky number i.e., it contains only the digits 4 and 7. while n > 0: digit = n % 10 if digit != 4 and digit != 7: return False n = n // 10 return True def count_lucky_numbers(A, B): Returns the count of lucky numbers within the range [A, B] inclusive. count = 0 for num in range(A, B + 1): if is_lucky_number(num): count += 1 return count def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) results = [] index = 1 for _ in range(T): A = int(data[index]) B = int(data[index + 1]) results.append(count_lucky_numbers(A, B)) index += 2 for result in results: print(result)"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Function to find the area of the largest rectangle that can be formed within the bounds of the histogram represented by heights. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([5, 5, 5, 5]) 20 >>> largest_rectangle_area([7]) 7 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 4, 6, 5, 4, 3, 2, 1]) 16 >>> largest_rectangle_area([5, 6, 2, 3, 4, 1, 2]) 10 >>> largest_rectangle_area([0, 0, 0, 0, 0]) 0 # Your code here","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Function to find the area of the largest rectangle that can be formed within the bounds of the histogram represented by heights. max_area = 0 stack = [] # stack to keep track of indices for i, h in enumerate(heights): # Process all bars before the current one in stack to process possible rectangles while stack and heights[stack[-1]] >= h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) # Process remaining bars in stack while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"def count_peaks(arr): Returns the number of peaks in the list. If no peaks are found, returns \\"No peaks found\\". >>> count_peaks([1, 3, 2, 5, 4]) 2 >>> count_peaks([1, 1, 1, 1, 1]) \\"No peaks found\\" >>> count_peaks([1, 2, 1]) 1 >>> count_peaks([]) \\"No peaks found\\" >>> count_peaks([1]) \\"No peaks found\\"","solution":"def count_peaks(arr): Returns the number of peaks in the list. If no peaks are found, returns \\"No peaks found\\". n = len(arr) if n == 0: return \\"No peaks found\\" if n == 1: return \\"No peaks found\\" peak_count = 0 for i in range(n): if (i == 0 and arr[i] > arr[i+1]) or (i == n-1 and arr[i] > arr[i-1]) or (0 < i < n-1 and arr[i] > arr[i-1] and arr[i] > arr[i+1]): peak_count += 1 if peak_count == 0: return \\"No peaks found\\" return peak_count"},{"question":"def second_largest(numbers: List[int]) -> int: Write a function that takes a list of integers and returns the second largest number in the list. >>> second_largest([10, 21, 45, 42, 18, 14, 21]) == 42 >>> second_largest([2, 3, 6, 6, 5, 8, 8]) == 6 >>> second_largest([100, 90, 80, 70, 60, 110]) == 100 >>> second_largest([-1, -2, -3, -4, -5, -1]) == -2 >>> second_largest([1, 2]) == 1 pass","solution":"def second_largest(numbers): Returns the second largest number in a list of integers. if len(numbers) < 2: raise ValueError(\\"List must contain at least two unique numbers.\\") unique_numbers = set(numbers) if len(unique_numbers) < 2: raise ValueError(\\"List must contain at least two unique numbers.\\") sorted_numbers = sorted(unique_numbers, reverse=True) return sorted_numbers[1]"},{"question":"def find_duplicates(arr: List[int]) -> List[int]: Returns a list of integers from 'arr' that appear more than once, sorted in ascending order, and without duplicates. >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] >>> find_duplicates([1, 2, 3, 4, 5, 6, 7]) == [] >>> find_duplicates([10, 10, 10]) == [10] >>> find_duplicates([-1, -2, -3, -1, -2, 1, 2, 3]) == [-2, -1] from solution import find_duplicates def test_find_duplicates_with_regular_input(): assert find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] def test_find_duplicates_with_no_duplicates(): assert find_duplicates([1, 2, 3, 4, 5, 6, 7]) == [] def test_find_duplicates_all_same_elements(): assert find_duplicates([10, 10, 10]) == [10] def test_find_duplicates_with_negative_numbers(): assert find_duplicates([-1, -2, -3, -1, -2, 1, 2, 3]) == [-2, -1] def test_find_duplicates_with_mixed_numbers(): assert find_duplicates([5, -1, -1, 5, 3, 2, 2, 3, 4]) == [-1, 2, 3, 5] def test_find_duplicates_single_element(): assert find_duplicates([1]) == [] def test_find_duplicates_large_range(): assert find_duplicates(list(range(100000))) == [] def test_find_duplicates_sparsely_repeated(): assert find_duplicates([1, 3, 1, 3, 2, 2, 4, 5, 4, 5]) == [1, 2, 3, 4, 5]","solution":"from typing import List def find_duplicates(arr: List[int]) -> List[int]: Returns a list of integers from 'arr' that appear more than once, sorted in ascending order, and without duplicates. from collections import Counter count = Counter(arr) duplicates = [item for item, freq in count.items() if freq > 1] return sorted(duplicates)"},{"question":"def convert(s: str, numRows: int) -> str: Converts a string into a zigzag pattern given a number of rows and reads row by row. :param s: The input string. :param numRows: The number of rows for the zigzag pattern. :return: The resulting string after zigzag conversion. >>> convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 1) \\"PAYPALISHIRING\\" >>> convert(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" >>> convert(\\"ABC\\", 5) \\"ABC\\" >>> convert(\\"HELLO\\", 3) \\"HOELL\\"","solution":"def convert(s: str, numRows: int) -> str: Converts a string into a zigzag pattern given a number of rows and reads row by row. :param s: The input string. :param numRows: The number of rows for the zigzag pattern. :return: The resulting string after zigzag conversion. if numRows == 1 or numRows >= len(s): return s rows = [''] * numRows current_row, step = 0, 1 for char in s: rows[current_row] += char if current_row == 0: step = 1 elif current_row == numRows - 1: step = -1 current_row += step return ''.join(rows)"},{"question":"def canFormPalindrome(s: str) -> bool: Determine whether a given string can be rearranged to form a palindrome. Parameters: s (str): The input string, containing only lowercase alphabets. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. Examples: >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"aabbc\\") True >>> canFormPalindrome(\\"abc\\") False","solution":"def canFormPalindrome(s: str) -> bool: Determine whether a given string can be rearranged to form a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string freq_count = Counter(s) # Check how many characters have an odd count odd_count = sum(1 for count in freq_count.values() if count % 2 != 0) # For the string to be rearranged into a palindrome: # - If the length of the string is even, no characters should have an odd count. # - If the length of the string is odd, exactly one character can have an odd count. return odd_count <= 1"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a new array where each element is the product of all the elements in the original array except for the element at the same index. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] pass # Your implementation goes here # Unit Tests def test_product_except_self(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] assert product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] assert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] assert product_except_self([0, 0]) == [0, 0] def test_product_except_self_single(): assert product_except_self([]) == [] assert product_except_self([1]) == [1]","solution":"def product_except_self(nums): Returns a new array where each element is the product of all the elements in the original array except for the element at the same index. length = len(nums) if length == 0: return [] left_products = [1] * length right_products = [1] * length result = [1] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def find_subsets_with_sum(nums: List[int], target: int) -> List[List[int]]: Given a list of integers, returns all subsets of the list where the sum of the subset equals a given target value. The subsets should be returned as a list of lists, with each subset in increasing order. The list of subsets themselves should also be sorted in increasing lexicographic order. >>> find_subsets_with_sum([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3], [5]] >>> find_subsets_with_sum([10, 1, 2, 7, 6, 5], 8) [[1, 2, 5], [1, 7], [2, 6]] >>> find_subsets_with_sum([3, 34, 4, 12, 5, 2], 9) [[2, 3, 4], [4, 5]] >>> find_subsets_with_sum([], 5) [] >>> find_subsets_with_sum([1, 2, 3], 10) [] >>> find_subsets_with_sum([5], 5) [[5]] >>> find_subsets_with_sum([3], 5) []","solution":"from typing import List def find_subsets_with_sum(nums: List[int], target: int) -> List[List[int]]: def backtrack(start, path, target): if target == 0: res.append(path) return for i in range(start, len(nums)): if nums[i] > target: break backtrack(i + 1, path + [nums[i]], target - nums[i]) nums.sort() res = [] backtrack(0, [], target) return res"},{"question":"def find_best_rated_product_in_category(category: str, product_records: List[str]) -> str: Returns the ProductID of the product with the highest rating within the specified category. If no products are available in the given category, return 'No products found'. :param category: str :param product_records: List[str] :return: str >>> find_best_rated_product_in_category(\\"Electronics\\", [ ... \\"A123:Electronics:499.99:10:4.5\\", ... \\"B456:Home:79.99:5:4.0\\", ... \\"C789:Electronics:299.99:20:4.7\\", ... \\"D012:Electronics:199.99:30:4.7\\", ... \\"E345:Furniture:249.99:15:3.8\\" ... ]) == \\"C789\\" >>> find_best_rated_product_in_category(\\"Furniture\\", [ ... \\"A123:Electronics:499.99:10:4.5\\", ... \\"B456:Home:79.99:5:4.0\\", ... \\"C789:Electronics:299.99:20:4.7\\", ... \\"D012:Electronics:199.99:30:4.7\\", ... \\"E345:Furniture:249.99:15:3.8\\" ... ]) == \\"E345\\" >>> find_best_rated_product_in_category(\\"Toys\\", [ ... \\"A123:Electronics:499.99:10:4.5\\", ... \\"B456:Home:79.99:5:4.0\\", ... \\"C789:Electronics:299.99:20:4.7\\", ... \\"D012:Electronics:199.99:30:4.7\\", ... \\"E345:Furniture:249.99:15:3.8\\" ... ]) == \\"No products found\\" >>> find_best_rated_product_in_category(\\"Home\\", [ ... \\"A123:Electronics:499.99:10:4.5\\", ... \\"B456:Home:79.99:5:4.0\\", ... \\"C789:Electronics:299.99:20:4.7\\", ... \\"D012:Electronics:199.99:30:4.7\\", ... \\"E345:Furniture:249.99:15:3.8\\" ... ]) == \\"B456\\" pass","solution":"def find_best_rated_product_in_category(category, product_records): Returns the ProductID of the product with the highest rating within the specified category. If no products are available in the given category, return 'No products found'. :param category: str :param product_records: List[str] :return: str best_product_id = \\"No products found\\" highest_rating = -1 for record in product_records: product_id, record_category, price, stock, rating = record.split(':') # Convert price, stock, and rating to their respective data types price = float(price) stock = int(stock) rating = float(rating) if record_category == category: if rating > highest_rating: highest_rating = rating best_product_id = product_id return best_product_id"},{"question":"def arrange_books(n: int, k: int, a: List[int]) -> Union[str, Tuple[str, List[int]]]: Determine if it's possible to organize the books on shelves such that each shelf has at most one more book than any other shelf, and each shelf has at least one book, along with the distribution of books if possible. >>> arrange_books(6, 3, [2, 3, 1, 4, 1, 2]) ('Yes', [2, 2, 2]) >>> arrange_books(7, 3, [1, 1, 1, 1, 1, 1, 1]) ('Yes', [3, 2, 2]) >>> arrange_books(5, 4, [5, 4, 3, 2, 1]) ('Yes', [2, 1, 1, 1]) >>> arrange_books(4, 5, [1, 2, 3, 4]) 'No' from typing import List, Union, Tuple def test_arrange_books_possible_equal_distribution(): assert arrange_books(6, 3, [2, 3, 1, 4, 1, 2]) == (\\"Yes\\", [2, 2, 2]) def test_arrange_books_possible_unequal_distribution(): assert arrange_books(7, 3, [1, 1, 1, 1, 1, 1, 1]) == (\\"Yes\\", [3, 2, 2]) def test_arrange_books_possible_with_one_more_book(): assert arrange_books(5, 4, [5, 4, 3, 2, 1]) == (\\"Yes\\", [2, 1, 1, 1]) def test_arrange_books_not_possible_more_shelves_than_books(): assert arrange_books(4, 5, [1, 2, 3, 4]) == \\"No\\" def test_arrange_books_one_book_one_shelf(): assert arrange_books(1, 1, [1]) == (\\"Yes\\", [1]) def test_arrange_books_one_book_more_shelves(): assert arrange_books(1, 2, [1]) == \\"No\\" def test_arrange_books_exact_division(): assert arrange_books(8, 4, [1, 2, 3, 4, 5, 6, 7, 8]) == (\\"Yes\\", [2, 2, 2, 2]) def test_arrange_books_all_books_same_width(): assert arrange_books(10, 5, [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == (\\"Yes\\", [2, 2, 2, 2, 2])","solution":"def arrange_books(n, k, a): Returns whether it's possible to organize the books on shelves such that each shelf has at most one more book than any other shelf, and each shelf has at least one book, along with the distribution of books if possible. if k > n: return \\"No\\" min_books_per_shelf = n // k extra_books = n % k result = [min_books_per_shelf] * k for i in range(extra_books): result[i] += 1 return \\"Yes\\", result"},{"question":"from typing import List def pair_difference(arr: List[int], x: int) -> bool: Given a list of integers \`arr\` and an integer \`x\`, find if there exists a pair of elements in the list whose difference is exactly \`x\`. >>> pair_difference([5, 10, 15, 20], 5) True >>> pair_difference([5, 10, 15, 20], 4) False >>> pair_difference([1, 8, 3, 4], 4) True >>> pair_difference([1, 5, 9], 3) False pass # Unit Tests def test_pair_difference_exists(): assert pair_difference([5, 10, 15, 20], 5) == True assert pair_difference([1, 8, 3, 4], 4) == True assert pair_difference([1, 7, 9, 3, 11], 2) == True def test_pair_difference_does_not_exist(): assert pair_difference([5, 10, 15, 20], 4) == False assert pair_difference([1, 5, 9], 3) == False assert pair_difference([2, 4, 6, 8], 5) == False def test_with_negative_difference(): assert pair_difference([1, 5, 9, -3, -7], 4) == True assert pair_difference([2, -2, 4], 6) == True def test_large_input(): assert pair_difference(list(range(1000000)), 999999) == True","solution":"def pair_difference(arr, x): Returns True if there exists a pair of elements in the list whose difference is exactly x. elements_set = set(arr) for num in arr: if (num + x) in elements_set or (num - x) in elements_set: return True return False"},{"question":"from typing import List, Tuple def remaining_passengers(bus_stops: List[Tuple[int, int]]) -> int: Calculate the total number of passengers remaining on the bus after the last stop. >>> remaining_passengers([(10, 0), (3, 5), (5, 8)]) == 5 >>> remaining_passengers([(3, 0), (9, 1), (4, 10), (12, 2), (6, 1), (7, 10)]) == 17 >>> remaining_passengers([(3, 5), (9, 4), (4, 6)]) == 1 pass def test_remaining_passengers_example_cases(): assert remaining_passengers([(10, 0), (3, 5), (5, 8)]) == 5 assert remaining_passengers([(3, 0), (9, 1), (4, 10), (12, 2), (6, 1), (7, 10)]) == 17 assert remaining_passengers([(3, 5), (9, 4), (4, 6)]) == 1 def test_remaining_passengers_no_alights(): assert remaining_passengers([(5, 0), (3, 0), (2, 0)]) == 10 def test_remaining_passengers_no_boards(): assert remaining_passengers([(0, 0), (0, 5)]) == -5 def test_remaining_passengers_all_bus_stops_have_equal_boarding_alighting(): assert remaining_passengers([(2, 2), (3, 3), (5, 5)]) == 0 def test_remaining_passengers_single_stop(): assert remaining_passengers([(5, 3)]) == 2 def test_remaining_passengers_no_boarding_or_alighting(): assert remaining_passengers([(0, 0)]) == 0","solution":"def remaining_passengers(bus_stops): total_passengers = 0 for onboard, alight in bus_stops: total_passengers += onboard total_passengers -= alight return total_passengers"},{"question":"import math from typing import List, Tuple, Dict def moveBoxes(instructions: List[Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]]]) -> Dict[Tuple[int, int], Tuple[int, int]]: You are designing a warehouse management system where different robots are responsible for moving boxes to different locations within the warehouse. Each robot can pick up one box at a time and move it to a specified location. The function \`moveBoxes\` takes in a list of tuples representing the robots' instructions. Each tuple contains three elements: the robot's current position, the box's current position, and the destination position for the box. The robots can only move boxes that are within a specific radius from their current position. The function should return a dictionary that shows the final destination of each box. If a robot cannot move a box because it's outside its radius, that box remains in its current position. >>> moveBoxes([((0, 0), (1, 1), (5, 5)), ((2, 2), (6, 6), (7, 7)), ((3, 3), (4, 4), (8, 8))]) {(1, 1): (5, 5), (6, 6): (6, 6), (4, 4): (8, 8)} >>> moveBoxes([((0, 0), (6, 6), (7, 7))]) {(6, 6): (6, 6)}","solution":"import math def moveBoxes(instructions): def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) final_positions = {} for robot_pos, box_pos, dest_pos in instructions: if euclidean_distance(robot_pos, box_pos) <= 5: final_positions[box_pos] = dest_pos else: final_positions[box_pos] = box_pos return final_positions"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Returns the largest sum of any consecutive subarray within the given array. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23","solution":"def max_subarray_sum(arr): Returns the largest sum of any consecutive subarray within the given array. This function implements Kadane's Algorithm. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_non_consecutive_sum(arr): Find the maximum sum of any subsequence such that no two consecutive elements are selected. >>> max_non_consecutive_sum([3, 2, 5, 10]) 13 >>> max_non_consecutive_sum([-1, -2, -3, -4]) 0 def process_input(input_str): Process the input string and compute results for each test case. >>> process_input(\\"2n4n3 2 5 10n4n-1 -2 -3 -4\\") [13, 0] def format_output(results): Format the results into a string with each result on a new line. >>> format_output([13, 0]) '13n0' def solve(input_str): Solve the problem by processing the input and formatting the output. >>> solve(\\"2n4n3 2 5 10n4n-1 -2 -3 -4\\") '13n0'","solution":"def max_non_consecutive_sum(arr): if not arr: return 0 including = 0 excluding = 0 for num in arr: new_excluding = max(including, excluding) including = excluding + num excluding = new_excluding return max(including, excluding) def process_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) results = [] index = 1 for _ in range(T): N = int(input_lines[index]) array = list(map(int, input_lines[index + 1].split())) results.append(max_non_consecutive_sum(array)) index += 2 return results def format_output(results): return 'n'.join(map(str, results)) # Let's put it altogether in one function to handle the input processing and result printing. def solve(input_str): results = process_input(input_str) return format_output(results)"},{"question":"def can_form_triangle(a: int, b: int, c: int) -> bool: Determines whether the lengths of three sides can form a valid triangle. :param a: Length of first side (positive integer) :param b: Length of second side (positive integer) :param c: Length of third side (positive integer) :returns: True if the sides can form a triangle, otherwise False >>> can_form_triangle(3, 4, 5) True >>> can_form_triangle(1, 1, 2) False >>> can_form_triangle(7, 10, 5) True >>> can_form_triangle(1, 10, 12) False","solution":"def can_form_triangle(a, b, c): Determines whether the lengths of three sides can form a valid triangle. :param a: Length of first side (positive integer) :param b: Length of second side (positive integer) :param c: Length of third side (positive integer) :returns: True if the sides can form a triangle, otherwise False return a + b > c and a + c > b and b + c > a"},{"question":"def numIslands(grid: List[List[str]]) -> int: Determine the number of islands in a given grid. An island is defined as a group of connected '1's (land) surrounded by '0's (water). >>> numIslands([]) 0 >>> numIslands([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'] ]) 1 >>> numIslands([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'] ]) 3 >>> numIslands([ ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'] ]) 0 >>> numIslands([ ['1', '1'], ['1', '1'] ]) 1","solution":"def numIslands(grid): if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # mark as visited dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': count += 1 dfs(grid, i, j) return count"},{"question":"def count_subsequence_occurrences(s: str, q: str) -> int: Counts the number of times the subsequence \`q\` appears in string \`s\`, considering the order of characters but not necessarily contiguous. >>> count_subsequence_occurrences(\\"abcabcabc\\", \\"abc\\") 10 >>> count_subsequence_occurrences(\\"abab\\", \\"ab\\") 3 >>> count_subsequence_occurrences(\\"aaaaa\\", \\"a\\") 5 >>> count_subsequence_occurrences(\\"abcde\\", \\"ae\\") 1 >>> count_subsequence_occurrences(\\"bbbaa\\", \\"b\\") 3 >>> count_subsequence_occurrences(\\"abcdef\\", \\"f\\") 1 >>> count_subsequence_occurrences(\\"abcdef\\", \\"abc\\") 1 >>> count_subsequence_occurrences(\\"abcdef\\", \\"def\\") 1 >>> count_subsequence_occurrences(\\"abcdef\\", \\"fed\\") 0 pass def process_input(input_data: str) -> List[int]: Processes the input data and calculates the number of times the subsequences appear in the respective texts for each test case. >>> process_input(\\"2nabcabcabcnabcnababnab\\") [10, 3] >>> process_input(\\"3naaaananaanbbnabcna\\") [4, 0, 1] pass","solution":"def count_subsequence_occurrences(s, q): Count the occurrences of subsequence \`q\` in string \`s\`. :param s: The text to search within :param q: The subsequence to search for :return: The number of times the subsequence \`q\` appears in \`s\` # Dynamic programming approach to count subsequence occurrences len_s, len_q = len(s), len(q) dp = [0] * (len_q + 1) dp[0] = 1 # An empty subsequence always has one occurrence in any string for i in range(1, len_s + 1): for j in range(len_q, 0, -1): if s[i - 1] == q[j - 1]: dp[j] += dp[j - 1] return dp[len_q] def process_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) results = [] index = 1 for _ in range(T): S = input_lines[index] Q = input_lines[index + 1] results.append(count_subsequence_occurrences(S, Q)) index += 2 return results"},{"question":"def min_cost_path(matrix: List[List[int]]) -> int: Returns the minimum cost path to reach the bottom-right corner of the matrix. :param matrix: List[List[int]], 2D list representing the cost matrix :return: int, the minimum cost of the path from top-left to bottom-right >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_cost_path([[1]]) 1","solution":"def min_cost_path(matrix): Returns the minimum cost path to reach the bottom-right corner of the matrix. :param matrix: List[List[int]], 2D list representing the cost matrix :return: int, the minimum cost of the path from top-left to bottom-right rows = len(matrix) cols = len(matrix[0]) # Create a 2D list to store the minimum costs dp = [[0]*cols for _ in range(rows)] # Initialize the top-left cell dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner will have the minimum cost return dp[rows-1][cols-1]"},{"question":"def replace_with_greater_neighbors(s: str) -> str: Takes in a string of space-separated integers and returns a string where each integer is replaced by its immediate greater neighbor's value. If there is no greater neighbor, it should be replaced by -1. >>> replace_with_greater_neighbors(\\"1 3 4 2\\") \\"3 4 -1 -1\\" >>> replace_with_greater_neighbors(\\"10 20 5 3 15\\") \\"20 -1 15 15 -1\\" from solution import replace_with_greater_neighbors def test_single_element(): assert replace_with_greater_neighbors(\\"5\\") == \\"-1\\" def test_two_elements(): assert replace_with_greater_neighbors(\\"5 10\\") == \\"10 -1\\" assert replace_with_greater_neighbors(\\"10 5\\") == \\"-1 -1\\" def test_multiple_elements(): assert replace_with_greater_neighbors(\\"1 3 4 2\\") == \\"3 4 -1 -1\\" assert replace_with_greater_neighbors(\\"10 20 5 3 15\\") == \\"20 -1 15 15 -1\\" assert replace_with_greater_neighbors(\\"2 3 1 4 6 5\\") == \\"3 4 4 6 -1 -1\\" def test_same_elements(): assert replace_with_greater_neighbors(\\"5 5 5 5 5\\") == \\"-1 -1 -1 -1 -1\\" def test_decreasing_elements(): assert replace_with_greater_neighbors(\\"5 4 3 2 1\\") == \\"-1 -1 -1 -1 -1\\" def test_mixed_elements(): assert replace_with_greater_neighbors(\\"8 5 10 7 12 15 3 13 9\\") == \\"10 10 12 12 15 -1 13 -1 -1\\"","solution":"def replace_with_greater_neighbors(s): Takes in a string of space-separated integers and returns a string where each integer is replaced by its immediate greater neighbor's value. If there is no greater neighbor, it should be replaced by -1. nums = list(map(int, s.split())) result = [] for i in range(len(nums)): replaced = False for j in range(i + 1, len(nums)): if nums[j] > nums[i]: result.append(nums[j]) replaced = True break if not replaced: result.append(-1) return ' '.join(map(str, result))"},{"question":"def categorize_books(N: int, years: List[int]) -> List[str]: Given the number of books and their publication years, categorize the books into decades from the 1900s to the 2000s. >>> categorize_books(6, [1995, 2001, 1987, 1974, 2000, 1965]) ['1900s: 0', '1910s: 0', '1920s: 0', '1930s: 0', '1940s: 0', '1950s: 0', '1960s: 1', '1970s: 1', '1980s: 1', '1990s: 1', '2000s: 2'] >>> categorize_books(5, [2001, 2005, 2000, 2009, 2003]) ['1900s: 0', '1910s: 0', '1920s: 0', '1930s: 0', '1940s: 0', '1950s: 0', '1960s: 0', '1970s: 0', '1980s: 0', '1990s: 0', '2000s: 5']","solution":"def categorize_books(N, years): Given the number of books and their publication years, categorize the books into decades from the 1900s to the 2000s. # Initialize decade categories from 1900s to 2000s decades = { \\"1900s\\": 0, \\"1910s\\": 0, \\"1920s\\": 0, \\"1930s\\": 0, \\"1940s\\": 0, \\"1950s\\": 0, \\"1960s\\": 0, \\"1970s\\": 0, \\"1980s\\": 0, \\"1990s\\": 0, \\"2000s\\": 0, } # Process each year and increment the respective decade count for year in years: if 1900 <= year <= 1909: decades[\\"1900s\\"] += 1 elif 1910 <= year <= 1919: decades[\\"1910s\\"] += 1 elif 1920 <= year <= 1929: decades[\\"1920s\\"] += 1 elif 1930 <= year <= 1939: decades[\\"1930s\\"] += 1 elif 1940 <= year <= 1949: decades[\\"1940s\\"] += 1 elif 1950 <= year <= 1959: decades[\\"1950s\\"] += 1 elif 1960 <= year <= 1969: decades[\\"1960s\\"] += 1 elif 1970 <= year <= 1979: decades[\\"1970s\\"] += 1 elif 1980 <= year <= 1989: decades[\\"1980s\\"] += 1 elif 1990 <= year <= 1999: decades[\\"1990s\\"] += 1 elif 2000 <= year <= 2009: decades[\\"2000s\\"] += 1 # Prepare the output as a list of strings output = [] for decade, count in decades.items(): output.append(f\\"{decade}: {count}\\") return output"},{"question":"class Animal: def __init__(self, name, species): self.name = name self.species = species def speak(self): raise NotImplementedError(\\"Subclasses must implement this method\\") class Lion(Animal): def __init__(self, name): super().__init__(name, 'Lion') def speak(self): Return the sound of the animal. >>> Lion(name=\\"Leo\\").speak() 'Roar' pass class Elephant(Animal): def __init__(self, name): super().__init__(name, 'Elephant') def speak(self): Return the sound of the animal. >>> Elephant(name=\\"Dumbo\\").speak() 'Trumpet' pass class Snake(Animal): def __init__(self, name): super().__init__(name, 'Snake') def speak(self): Return the sound of the animal. >>> Snake(name=\\"Kaa\\").speak() 'Hiss' pass def zoo_sounds(animals): Takes a list of Animal objects and returns a list of the sounds they make. >>> zoo_sounds([Lion(name=\\"Leo\\"), Elephant(name=\\"Dumbo\\"), Snake(name=\\"Kaa\\")]) ['Roar', 'Trumpet', 'Hiss'] >>> zoo_sounds([]) [] pass","solution":"class Animal: def __init__(self, name, species): self.name = name self.species = species def speak(self): raise NotImplementedError(\\"Subclasses must implement this method\\") class Lion(Animal): def __init__(self, name): super().__init__(name, 'Lion') def speak(self): return 'Roar' class Elephant(Animal): def __init__(self, name): super().__init__(name, 'Elephant') def speak(self): return 'Trumpet' class Snake(Animal): def __init__(self, name): super().__init__(name, 'Snake') def speak(self): return 'Hiss' def zoo_sounds(animals): return [animal.speak() for animal in animals]"},{"question":"class GradeBook: A simple grade book application for professors to manage student grades. Allows adding student grades and calculating the average grade of the class. def __init__(self): Initializes an empty dictionary to store student names and their respective grades. pass def add_student(self, name: str, grade: float) -> None: Adds a student and their grade to the gradebook. If the student already exists, their grade is updated. >>> gradebook = GradeBook() >>> gradebook.add_student(\\"John Doe\\", 85.5) >>> gradebook.students[\\"John Doe\\"] == 85.5 True pass def calculate_average(self) -> float: Calculates and returns the average grade of the class, rounded to 2 decimal places. Returns 0.0 if no students are present. >>> gradebook = GradeBook() >>> gradebook.add_student(\\"John Doe\\", 85.5) >>> gradebook.add_student(\\"Jane Smith\\", 92.0) >>> gradebook.add_student(\\"John Doe\\", 89.0) # Updating John Doe's grade >>> gradebook.calculate_average() 90.5 pass","solution":"class GradeBook: def __init__(self): # Initialize an empty dictionary to store student names and their respective grades self.students = {} def add_student(self, name: str, grade: float) -> None: Adds a student and their grade to the gradebook. If the student already exists, their grade is updated. self.students[name] = grade def calculate_average(self) -> float: Calculates and returns the average grade of the class, rounded to 2 decimal places. Returns 0.0 if no students are present. if not self.students: return 0.0 total = sum(self.students.values()) average = total / len(self.students) return round(average, 2)"},{"question":"def find_pairs(arr: List[int], target: int) -> List[List[int]]: Returns an array of all unique pairs of integers from the input array that add up to the target. Each pair is sorted in ascending order, and no duplicate pairs are included in the result. >>> find_pairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([1, 2, -2, -1, 0], 0) [[-2, 2], [-1, 1]] >>> find_pairs([2, 2, 2], 4) [[2, 2]] >>> find_pairs([1, 1, 1, 1], 2) [[1, 1]] >>> find_pairs([1, 2, 3, 4], 10) [] >>> find_pairs([-1, -2, 3, 1, 2], 0) [[-2, 2], [-1, 1]] >>> find_pairs([0, 0, 0], 0) [[0, 0]]","solution":"def find_pairs(arr, target): Returns an array of all unique pairs of integers from the input array that add up to the target. Each pair is sorted in ascending order, and no duplicate pairs are included in the result. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted([num, complement])) pairs.add(pair) seen.add(num) return [list(pair) for pair in sorted(pairs)]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, sum): Find all paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> pathSum(root, 22) [[5, 4, 11, 2], [5, 8, 4, 5]] pass # Remove this statement and implement your solution here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, sum): def dfs(node, current_path, current_sum): if not node: return # include the current node to the path current_path.append(node.val) current_sum += node.val # check if current_sum equals the desired sum and we're at the leaf node if current_sum == sum: paths.append(list(current_path)) # recursively call dfs on the left and right child dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) # backtrack - remove the current node from the path current_path.pop() paths = [] dfs(root, [], 0) return paths"},{"question":"def alive_people(people): Returns a list of people who are still alive, sorted by their age in ascending order. Assumes the current year is 2023. Args: people: A list of tuples, each containing a name and a birth year. Returns: A list of tuples of people who are still alive, sorted by age. >>> alive_people([(\\"Alice\\", 1990), (\\"Bob\\", 1985), (\\"Charlie\\", 2022), (\\"David\\", 1980)]) [('Charlie', 2022), ('Alice', 1990), ('Bob', 1985), ('David', 1980)] >>> alive_people([(\\"Alice\\", 1990), (\\"Bob\\", 1985), (\\"Emily\\", 2023)]) [('Alice', 1990), ('Bob', 1985)] pass","solution":"def alive_people(people): Returns a list of people who are still alive, sorted by their age in ascending order. Assumes the current year is 2023. Args: people: A list of tuples, each containing a name and a birth year. Returns: A list of tuples of people who are still alive, sorted by age. current_year = 2023 alive = [person for person in people if person[1] < current_year] return sorted(alive, key=lambda x: current_year - x[1])"},{"question":"def remove_duplicates(s: str) -> str: Given a string, return a new string where every character removed from the string appears only once, preserving the input order of the first occurrences of the characters. >>> remove_duplicates(\\"apple\\") == \\"aple\\" >>> remove_duplicates(\\"banana\\") == \\"ban\\" >>> remove_duplicates(\\"programming\\") == \\"progamin\\" >>> remove_duplicates(\\"hello\\") == \\"helo\\" >>> remove_duplicates(\\"\\") == \\"\\" >>> remove_duplicates(\\"abcdef\\") == \\"abcdef\\" >>> remove_duplicates(\\"aaaaaa\\") == \\"a\\" >>> remove_duplicates(\\"aAaAaA\\") == \\"aA\\" >>> remove_duplicates(\\"112233\\") == \\"123\\" >>> remove_duplicates(\\"!@#!@#\\") == \\"!@#\\"","solution":"def remove_duplicates(s): Return a new string where every character removed from the string appears only once, preserving the input order of the first occurrences of the characters. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy and sell transaction. :param prices: List of integers representing the prices. :return: Integer representing the maximum profit. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 5]) 4 >>> max_profit([5, 1]) 0 >>> max_profit([6, 1, 3, 2, 4, 7]) 6 >>> max_profit([5, 5, 5, 5, 5]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy and sell transaction. :param prices: List of integers representing the prices. :return: Integer representing the maximum profit. if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def generateParentheses(n: int) -> List[str]: Generates all combinations of n pairs of parentheses. :param n: Number of pairs of parentheses :return: List of valid combinations of n pairs of parentheses >>> generateParentheses(0) [\\"\\"] >>> generateParentheses(1) [\\"()\\"] >>> set(generateParentheses(2)) == {\\"(())\\", \\"()()\\"} True >>> set(generateParentheses(3)) == {\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"} True >>> set(generateParentheses(4)) == {\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"} True pass","solution":"def generateParentheses(n): Generates all combinations of n pairs of parentheses. :param n: Number of pairs of parentheses :return: List of valid combinations of n pairs of parentheses result = [] def backtrack(current, openCount, closeCount): if len(current) == 2 * n: result.append(current) return if openCount < n: backtrack(current + '(', openCount + 1, closeCount) if closeCount < openCount: backtrack(current + ')', openCount, closeCount + 1) backtrack(\\"\\", 0, 0) return result"},{"question":"def determine_winner(n: int, arr: List[int]) -> str: Returns \\"Alice\\" if Alice has a winning strategy, otherwise returns \\"Bob\\". Parameters: - n (int): The number of integers in the array. - arr (list of int): The array of integers. Returns: - str: \\"Alice\\" or \\"Bob\\" depending on who has the winning strategy. >>> determine_winner(4, [4, 3, 2, 1]) \\"Alice\\" >>> determine_winner(5, [3, 5, 1, 7, 6]) \\"Bob\\" >>> determine_winner(3, [10, 8, 6]) \\"Bob\\" >>> determine_winner(3, [1, 1, 1]) \\"Bob\\" >>> determine_winner(1, [1]) \\"Bob\\" >>> determine_winner(1000, list(range(1, 1001))) \\"Alice\\" >>> determine_winner(999, list(range(1, 1000))) \\"Bob\\"","solution":"def determine_winner(n, arr): Returns \\"Alice\\" if Alice has a winning strategy, otherwise returns \\"Bob\\". Parameters: - n (int): The number of integers in the array. - arr (list of int): The array of integers. Returns: - str: \\"Alice\\" or \\"Bob\\" depending on who has the winning strategy. arr.sort() # Sorting the array in ascending order if n % 2 == 1: return \\"Bob\\" # If the number of integers is odd, Bob wins return \\"Alice\\" # If the number of integers is even, Alice wins"},{"question":"def sum_of_evens_in_matrix(matrix: List[List[int]]) -> int: Returns the sum of all even numbers in a 2-dimensional array (list of lists). >>> sum_of_evens_in_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 20 >>> sum_of_evens_in_matrix([[11, 22], [33, 44, 55, 66]]) 132 >>> sum_of_evens_in_matrix([[]]) 0 >>> sum_of_evens_in_matrix([[10, -2], [-4, 0, 4, 13]]) 8","solution":"def sum_of_evens_in_matrix(matrix): Returns the sum of all even numbers in a 2-dimensional array (list of lists). sum_evens = 0 for row in matrix: for num in row: if num % 2 == 0: sum_evens += num return sum_evens"},{"question":"def is_valid_chess_move(piece: str, start_position: str, end_position: str) -> bool: Determines if a move is valid for a given chess piece. :param piece: The chess piece to move. :param start_position: The starting position in algebraic notation, e.g., 'e4'. :param end_position: The ending position in algebraic notation, e.g., 'e5'. :return: True if the move is valid, otherwise False. >>> is_valid_chess_move(\\"king\\", \\"e4\\", \\"e5\\") True >>> is_valid_chess_move(\\"queen\\", \\"d1\\", \\"h5\\") True >>> is_valid_chess_move(\\"knight\\", \\"g1\\", \\"f3\\") True >>> is_valid_chess_move(\\"pawn\\", \\"e2\\", \\"e4\\") True >>> is_valid_chess_move(\\"bishop\\", \\"c1\\", \\"e3\\") False from solution import is_valid_chess_move def test_king_moves(): assert is_valid_chess_move(\\"king\\", \\"e4\\", \\"e5\\") == True assert is_valid_chess_move(\\"king\\", \\"e4\\", \\"e6\\") == False def test_queen_moves(): assert is_valid_chess_move(\\"queen\\", \\"d1\\", \\"h5\\") == True assert is_valid_chess_move(\\"queen\\", \\"d1\\", \\"d3\\") == True assert is_valid_chess_move(\\"queen\\", \\"d1\\", \\"e3\\") == False def test_rook_moves(): assert is_valid_chess_move(\\"rook\\", \\"a1\\", \\"a8\\") == True assert is_valid_chess_move(\\"rook\\", \\"h1\\", \\"h3\\") == True assert is_valid_chess_move(\\"rook\\", \\"a1\\", \\"b2\\") == False def test_bishop_moves(): assert is_valid_chess_move(\\"bishop\\", \\"c1\\", \\"e3\\") == True assert is_valid_chess_move(\\"bishop\\", \\"c1\\", \\"d2\\") == True assert is_valid_chess_move(\\"bishop\\", \\"c1\\", \\"c2\\") == False def test_knight_moves(): assert is_valid_chess_move(\\"knight\\", \\"g1\\", \\"f3\\") == True assert is_valid_chess_move(\\"knight\\", \\"g1\\", \\"e2\\") == True assert is_valid_chess_move(\\"knight\\", \\"g1\\", \\"g2\\") == False def test_pawn_moves(): assert is_valid_chess_move(\\"pawn\\", \\"e2\\", \\"e4\\") == True # two squares forward on first move assert is_valid_chess_move(\\"pawn\\", \\"e2\\", \\"e3\\") == True # one square forward assert is_valid_chess_move(\\"pawn\\", \\"e2\\", \\"e5\\") == False # too many squares assert is_valid_chess_move(\\"pawn\\", \\"e2\\", \\"d3\\") == False # diagonal move def test_invalid_piece_moves(): assert is_valid_chess_move(\\"dragon\\", \\"a1\\", \\"a8\\") == False # invalid piece def test_invalid_positions(): assert is_valid_chess_move(\\"king\\", \\"i1\\", \\"e5\\") == False # invalid start position assert is_valid_chess_move(\\"king\\", \\"e4\\", \\"i5\\") == False # invalid end position","solution":"def is_valid_chess_move(piece, start_position, end_position): Determines if a move is valid for a given chess piece. :param piece: str - The chess piece to move. :param start_position: str - The starting position in algebraic notation. :param end_position: str - The ending position in algebraic notation. :return: bool - True if the move is valid, otherwise False. def position_to_coords(pos): return ord(pos[0]) - ord('a'), int(pos[1]) - 1 start_x, start_y = position_to_coords(start_position) end_x, end_y = position_to_coords(end_position) dx = end_x - start_x dy = end_y - start_y if piece == 'king': return abs(dx) <= 1 and abs(dy) <= 1 elif piece == 'queen': return dx == 0 or dy == 0 or abs(dx) == abs(dy) elif piece == 'rook': return dx == 0 or dy == 0 elif piece == 'bishop': return abs(dx) == abs(dy) elif piece == 'knight': return (abs(dx) == 2 and abs(dy) == 1) or (abs(dx) == 1 and abs(dy) == 2) elif piece == 'pawn': if start_y == 1 and dy == 2 and dx == 0: # initial double move for white return True return dx == 0 and dy == 1 return False"},{"question":"def reverse_bits(n: int) -> int: Returns the integer obtained by reversing the bits of the given integer n. >>> reverse_bits(13) == 11 >>> reverse_bits(8) == 1 >>> reverse_bits(0) == 0 >>> reverse_bits(5) == 5","solution":"def reverse_bits(n): Returns the integer obtained by reversing the bits of the given integer n. # Convert the integer to binary, remove the '0b' prefix, and reverse the string reversed_binary = bin(n)[2:][::-1] # Convert the reversed binary string back to an integer and return return int(reversed_binary, 2)"},{"question":"def predict(x, m, c, a, b): Predicts the value using the equation y = mx + c + a * e^(bx). Parameters: x (float): The input value. m (float): The coefficient for linear term. c (float): The constant term. a (float): The coefficient for exponential term. b (float): The exponent's coefficient. Returns: float: The predicted value. Examples: >>> predict(1, 2, 3, 4, 0.5) <output should be evaluated> >>> predict(0, 1, 2, 3, 0.1) <output should be evaluated>","solution":"import math def predict(x, m, c, a, b): Predicts the value using the equation y = mx + c + a * e^(bx). Parameters: x (float): The input value. m (float): The coefficient for linear term. c (float): The constant term. a (float): The coefficient for exponential term. b (float): The exponent's coefficient. Returns: float: The predicted value. return m * x + c + a * math.exp(b * x)"},{"question":"from typing import List, Tuple def add_sparse_matrices(matrix1: List[Tuple[int, int, int]], matrix2: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Add two sparse matrices and return the result in sparse matrix form. >>> add_sparse_matrices([(0, 1, 3), (1, 0, 5), (2, 2, 7)], [(0, 1, 4), (1, 0, -5), (1, 2, 9)]) [(0, 1, 7), (1, 2, 9), (2, 2, 7)] >>> add_sparse_matrices([(0, 0, 5)], [(0, 0, -5)]) [] >>> add_sparse_matrices([(0, 0, 2), (1, 2, 3)], [(2, 3, 4)]) [(0, 0, 2), (1, 2, 3), (2, 3, 4)] >>> add_sparse_matrices([(0, 1, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 1)]) [(0, 1, 2), (1, 1, 2)] >>> add_sparse_matrices([(0, 1, 2), (1, 2, -3)], [(0, 1, -2), (1, 2, 4)]) [(1, 2, 1)]","solution":"from typing import List, Tuple def add_sparse_matrices(matrix1: List[Tuple[int, int, int]], matrix2: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Adds two sparse matrices and returns the result in sparse matrix format. dict_result = {} for row, col, value in matrix1: if value != 0: dict_result[(row, col)] = value for row, col, value in matrix2: if (row, col) in dict_result: dict_result[(row, col)] += value else: dict_result[(row, col)] = value result = [(row, col, value) for (row, col), value in dict_result.items() if value != 0] result.sort() return result"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Write a function called \`is_anagram\` that takes two strings \`str1\` and \`str2\` and returns \`True\` if the strings are anagrams of each other, and \`False\` otherwise. An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. The function should ignore case and any non-letter characters. >>> is_anagram(\\"listen\\", \\"silent\\") == True >>> is_anagram(\\"triangle\\", \\"integral\\") == True >>> is_anagram(\\"hello\\", \\"billion\\") == False >>> is_anagram(\\"Lis@ten!\\", \\"Silent\\") == True >>> is_anagram(\\"\\", \\"\\") == True >>> is_anagram(\\"aabbcc\\", \\"abc\\") == False","solution":"def is_anagram(str1, str2): Returns True if str1 and str2 are anagrams of each other, ignoring case and non-letter characters. Returns False otherwise. import re # Clean the input strings: remove non-letter characters and convert to lower case clean_str1 = re.sub(r'[^a-zA-Z]', '', str1).lower() clean_str2 = re.sub(r'[^a-zA-Z]', '', str2).lower() # Sort the cleaned strings sorted_str1 = ''.join(sorted(clean_str1)) sorted_str2 = ''.join(sorted(clean_str2)) # Check if sorted strings are equal return sorted_str1 == sorted_str2"},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Given a binary tree, return the inorder traversal of its nodes' values. >>> inorderTraversal(build_tree([1, None, 2, 3])) == [1, 3, 2] >>> inorderTraversal(build_tree([])) == [] >>> inorderTraversal(build_tree([1])) == [1] >>> inorderTraversal(build_tree([1, 2])) == [2, 1] >>> inorderTraversal(build_tree([1, None, 2])) == [1, 2] pass","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Given a binary tree, return the inorder traversal of its nodes' values. def inorder(node, result): if not node: return inorder(node.left, result) result.append(node.val) inorder(node.right, result) result = [] inorder(root, result) return result"},{"question":"def single_number(nums: List[int]) -> int: Finds the single number in an array where every element appears twice except for one. >>> single_number([4,1,2,1,2]) == 4 >>> single_number([1]) == 1 >>> single_number([30000, -30000, 50000, 30000, -50000, -30000, -50000]) == 50000 >>> single_number([2, 2, 3, 3, 1, 1, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]) == 0 >>> single_number([-1, -1, -2, -2, -3]) == -3 >>> single_number([7, 3, 5, 4, 5, 3, 4]) == 7 >>> single_number([1, 2, 3, 2, 3]) == 1","solution":"def single_number(nums): Finds the single number in an array where every element appears twice except for one. Parameters: nums (list): List of integers. Returns: int: The single number. result = 0 for num in nums: result ^= num return result"},{"question":"def max_product_of_three(nums): Returns the maximum product of three integers in the list nums. If there are less than three integers, return an error message. >>> max_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([1, 2]) \\"Error: Less than three integers\\" >>> max_product_of_three([-1, -2, -3, -4]) -6 def process_test_cases(test_cases): Processes a list of test cases, computing the maximum product for each. >>> process_test_cases([\\"1 10 2 6 5 3\\", \\"-10 -10 5 2\\", \\"1 2\\"]) [300, 500, \\"Error: Less than three integers\\"] >>> process_test_cases([\\"1 2 3 4 5\\"]) [60]","solution":"def max_product_of_three(nums): Returns the maximum product of three integers in the list nums. If there are less than three integers, return an error message. if len(nums) < 3: return \\"Error: Less than three integers\\" nums.sort() return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3]) def process_test_cases(test_cases): results = [] for case in test_cases: nums = list(map(int, case.split())) results.append(max_product_of_three(nums)) return results"},{"question":"def calculate_final_grade(marks): Calculate the final grade of a class by dropping the highest and lowest marks and averaging the remaining marks. :param marks: A list of integers representing the marks :return: The final grade as a float rounded to two decimal places, or 0 if the number of students is fewer than three. >>> calculate_final_grade([70, 85, 78, 92, 88, 76]) 81.75 >>> calculate_final_grade([85, 85, 85, 85, 85]) 85.00 >>> calculate_final_grade([75]) 0.0 >>> calculate_final_grade([60, 70, 80]) 70.0 >>> calculate_final_grade([]) 0.0 >>> calculate_final_grade([50, 60, 70, 80, 90, 100]) 75.0 >>> calculate_final_grade([0, 100, 50, 75]) 62.5 >>> calculate_final_grade([50, 50, 50, 50, 50, 50]) 50.0","solution":"def calculate_final_grade(marks): Calculate the final grade of a class by dropping the highest and lowest marks and averaging the remaining marks. :param marks: A list of integers representing the marks :return: The final grade as a float rounded to two decimal places, or 0 if the number of students is fewer than three. if len(marks) < 3: return 0.0 sorted_marks = sorted(marks) trimmed_marks = sorted_marks[1:-1] average = sum(trimmed_marks) / len(trimmed_marks) return round(average, 2)"},{"question":"def sort_titles_reverse_alphabetical(n: int, titles: List[str]) -> List[str]: Sort a list of book titles in reverse alphabetical order. Parameters: n (int): Number of book titles. titles (list of str): A list containing the book titles. Returns: list of str: Book titles in reverse alphabetical order. >>> sort_titles_reverse_alphabetical(3, ['Applied Cryptography', 'The Art of Computer Programming', 'Design Patterns']) ['The Art of Computer Programming', 'Design Patterns', 'Applied Cryptography'] >>> sort_titles_reverse_alphabetical(4, ['Python Programming', 'Artificial Intelligence', 'Data Science', 'Machine Learning']) ['Python Programming', 'Machine Learning', 'Data Science', 'Artificial Intelligence'] >>> sort_titles_reverse_alphabetical(1, ['Single Title']) ['Single Title'] >>> sort_titles_reverse_alphabetical(0, []) []","solution":"def sort_titles_reverse_alphabetical(n, titles): Returns a list of titles sorted in reverse alphabetical order. Parameters: n (int): Number of book titles. titles (list of str): A list containing the book titles. Returns: list of str: Book titles in reverse alphabetical order. if not all(isinstance(title, str) for title in titles): raise ValueError(\\"All book titles must be strings.\\") # Sorting the titles in reverse alphabetical order sorted_titles = sorted(titles, reverse=True) return sorted_titles"},{"question":"from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Computes the shortest path in a grid with obstacles from start to target point. :param grid: A 2D list representing the grid, where 0 is a free space and 1 is an obstacle. :param start: A tuple (x, y) representing the starting coordinates. :param target: A tuple (x, y) representing the target coordinates. :return: An integer representing the number of steps in the shortest path or -1 if no valid path exists. >>> grid1 = [ ... [0, 0, 0, 0], ... [1, 1, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0], ... ] >>> start1, target1 = (0, 0), (4, 3) >>> shortest_path(grid1, start1, target1) 7 >>> grid2 = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> start2, target2 = (0, 0), (2, 2) >>> shortest_path(grid2, start2, target2) 4 >>> grid3 = [ ... [0, 1], ... [1, 0] ... ] >>> start3, target3 = (0, 0), (1, 1) >>> shortest_path(grid3, start3, target3) -1","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Computes the shortest path in a grid with obstacles from start to target point. :param grid: A 2D list representing the grid, where 0 is a free space and 1 is an obstacle. :param start: A tuple (x, y) representing the starting coordinates. :param target: A tuple (x, y) representing the target coordinates. :return: An integer representing the number of steps in the shortest path or -1 if no valid path exists. rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(start[0], start[1], 0)]) # store x, y, and number of steps visited = set((start[0], start[1])) while queue: x, y, steps = queue.popleft() if (x, y) == target: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # if no path is found"},{"question":"def minimum_initial_length(n: int) -> int: Determine the minimum initial string length required to achieve a string of length n by performing the specified operations. >>> minimum_initial_length(5) 3 >>> minimum_initial_length(1) 1 >>> minimum_initial_length(1000000) 1414 >>> minimum_initial_length(15) 5 >>> minimum_initial_length(20) 6 >>> minimum_initial_length(100) 14","solution":"def minimum_initial_length(n): Returns the minimum initial string length required to achieve a string of length n by performing the specified operations. length = 1 while length * (length + 1) // 2 < n: length += 1 return length"},{"question":"def sum_prime_factors(n: int) -> int: Define a function that takes a positive integer n and returns the sum of all the prime factors of n. If n is a prime number itself, the function should return n. Consider only unique prime factors when calculating the sum. >>> sum_prime_factors(10) == 7 >>> sum_prime_factors(18) == 5 >>> sum_prime_factors(11) == 11 >>> sum_prime_factors(60) == 10 >>> sum_prime_factors(100) == 7 pass","solution":"def sum_prime_factors(n): This function returns the sum of all unique prime factors of a positive integer n. def is_prime(k): if k <= 1: return False if k <= 3: return True if k % 2 == 0 or k % 3 == 0: return False i = 5 while i * i <= k: if k % i == 0 or k % (i + 2) == 0: return False i += 6 return True if n <= 1: return 0 sum_of_primes = 0 prime_factors = set() for i in range(2, int(n**0.5) + 1): if n % i == 0: if is_prime(i): prime_factors.add(i) if is_prime(n // i): prime_factors.add(n // i) # If no prime factors found and n is prime itself if not prime_factors and is_prime(n): return n return sum(prime_factors)"},{"question":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: Write a function that takes a square matrix (2D array) of integers and returns the sum of the two main diagonals of the matrix. The main diagonal runs from the top-left to the bottom-right. The anti-diagonal runs from the top-right to the bottom-left. You should avoid counting the middle element twice if the matrix has an odd size. >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> diagonal_sum(matrix1) 25 >>> matrix2 = [ ... [1, 2], ... [3, 4] ... ] >>> diagonal_sum(matrix2) 10","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Add elements from the main diagonal total_sum += matrix[i][n-i-1] # Add elements from the anti-diagonal # If the matrix has an odd dimension, we subtract the central element which was added twice if n % 2 == 1: total_sum -= matrix[n//2][n//2] return total_sum"},{"question":"def can_partition(nums: List[int]) -> bool: Given an array of distinct integers, determine if the array can be split into two subsets such that the sum of the elements in both subsets is equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([2, 2, 1, 1]) True >>> can_partition([3, 3, 3, 4, 5]) True","solution":"def can_partition(nums): total_sum = sum(nums) # If total_sum is odd, it's not possible to split it into two equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 # Initialize a DP array where dp[i] means if a subset with sum i can be formed dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target_sum]"},{"question":"def can_distribute_problems(N, available_problems, P): Determine if problems can be distributed equally among participants. Parameters: N (int): Number of participants available_problems (tuple): Counts of easy, medium, and hard problems P (int): Number of problems per participant Returns: str: \\"yes\\" if it's possible to distribute problems equally, otherwise \\"no\\" from solution import can_distribute_problems def test_example_case(): assert can_distribute_problems(3, (5, 10, 9), 3) == \\"yes\\" def test_not_enough_easy_problems(): assert can_distribute_problems(3, (2, 10, 9), 3) == \\"no\\" def test_not_enough_medium_problems(): assert can_distribute_problems(3, (5, 2, 9), 3) == \\"no\\" def test_not_enough_hard_problems(): assert can_distribute_problems(3, (5, 10, 2), 3) == \\"no\\" def test_not_evenly_divisible_problems(): assert can_distribute_problems(3, (5, 10, 9), 4) == \\"no\\" def test_single_participant(): assert can_distribute_problems(1, (1, 1, 1), 3) == \\"yes\\" def test_more_problems_than_needed(): assert can_distribute_problems(1, (10, 10, 10), 3) == \\"yes\\" def test_zero_participants(): assert can_distribute_problems(0, (0, 0, 0), 0) == \\"yes\\" def test_minimum_edge_case(): assert can_distribute_problems(1, (0, 0, 0), 1) == \\"no\\" assert can_distribute_problems(1, (1, 1, 1), 9) == \\"no\\" def test_maximum_edge_case(): assert can_distribute_problems(100, (100, 100, 100), 3) == \\"yes\\"","solution":"def can_distribute_problems(N, available_problems, P): Determine if problems can be distributed equally among participants. Parameters: N (int): Number of participants available_problems (tuple): Counts of easy, medium, and hard problems P (int): Number of problems per participant Returns: str: \\"yes\\" if it's possible to distribute problems equally, otherwise \\"no\\" easy, medium, hard = available_problems # Each participant needs an equal number of easy, medium, and hard problems required_problem_counts = [P // 3] * 3 # Check if P is evenly divisible by 3 for each participant if P % 3 != 0: return \\"no\\" # Check if we have enough problems of each type required_easy = N * required_problem_counts[0] required_medium = N * required_problem_counts[1] required_hard = N * required_problem_counts[2] if easy >= required_easy and medium >= required_medium and hard >= required_hard: return \\"yes\\" else: return \\"no\\""},{"question":"def evaluate_expression(expression: str) -> int: Write a function that takes a string containing a mathematical expression and evaluates it. The expression can contain integers, the operators + (addition) and - (subtraction), and parentheses for controlling the precedence of operations. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"10-2\\") 8 >>> evaluate_expression(\\"3+5-2\\") 6 >>> evaluate_expression(\\"10+(2-1)\\") 11 >>> evaluate_expression(\\"6-4+(7-3)+1\\") 7 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"(1+1)+2\\") 4 >>> evaluate_expression(\\"2+(3+4)\\") 9 >>> evaluate_expression(\\"0+1-0\\") 1","solution":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression string containing integers, addition (+), subtraction (-), and parentheses def helper(s_list): stack = [] num = 0 sign = 1 while len(s_list) > 0: c = s_list.pop(0) if c.isdigit(): num = num * 10 + int(c) elif c in ['+', '-']: stack.append(sign * num) num = 0 sign = 1 if c == '+' else -1 elif c == '(': num = helper(s_list) elif c == ')': stack.append(sign * num) return sum(stack) stack.append(sign * num) return sum(stack) return helper(list(expression))"},{"question":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merge k sorted linked lists and return it as one sorted linked list. >>> def list_to_listnode(lst): >>> dummy = ListNode() >>> current = dummy >>> for val in lst: >>> current.next = ListNode(val) >>> current = current.next >>> return dummy.next >>> >>> def listnode_to_list(node): >>> lst = [] >>> while node: >>> lst.append(node.val) >>> node = node.next >>> return lst >>> >>> l1 = list_to_listnode([1, 4, 5]) >>> l2 = list_to_listnode([1, 3, 4]) >>> l3 = list_to_listnode([2, 6]) >>> >>> merged_list = mergeKLists([l1, l2, l3]) >>> listnode_to_list(merged_list) == [1, 1, 2, 3, 4, 4, 5, 6] True >>> mergeKLists([]) == None True >>> mergeKLists([None, None]) == None True >>> l1 = list_to_listnode([1, 3, 5]) >>> merged_list = mergeKLists([l1]) >>> listnode_to_list(merged_list) == [1, 3, 5] True >>> l1 = list_to_listnode([1, 4, 5]) >>> l2 = list_to_listnode([1, 3, 4]) >>> l3 = list_to_listnode([2, 6]) >>> l4 = list_to_listnode([0, 7, 8, 9]) >>> merged_list = mergeKLists([l1, l2, l3, l4]) >>> listnode_to_list(merged_list) == [0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9] True","solution":"from heapq import heappush, heappop class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists): Merge k sorted linked lists and return it as one sorted linked list. min_heap = [] # Add the first node of each list to the heap for i in range(len(lists)): if lists[i]: heappush(min_heap, (lists[i].val, i, lists[i])) dummy = ListNode() current = dummy while min_heap: val, i, node = heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"def findWordsInGrid(grid, words): Returns a list of words that can be found in the grid. Parameters: grid (list of list of str): 2D grid of characters. words (list of str): List of words to search for. Returns: list of str: List of words found in the grid. Examples: >>> grid = [['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e']] >>> words = [\\"abcced\\", \\"see\\", \\"abcb\\"] >>> findWordsInGrid(grid, words) ['abcced', 'see'] >>> grid = [['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e']] >>> words = [\\"abcdef\\", \\"ghijkl\\"] >>> findWordsInGrid(grid, words) [] >>> grid = [['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e']] >>> words = [\\"abf\\"] >>> findWordsInGrid(grid, words) ['abf'] >>> grid = [['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e']] >>> words = [\\"abcced\\", \\"see\\", \\"abcb\\", \\"sfcs\\", \\"adee\\", \\"ce\\"] >>> findWordsInGrid(grid, words) ['abcced', 'see', 'sfcs', 'adee', 'ce'] >>> grid = [['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e']] >>> words = [\\"a\\", \\"e\\", \\"f\\"] >>> findWordsInGrid(grid, words) ['a', 'e', 'f']","solution":"def findWordsInGrid(grid, words): Returns a list of words that can be found in the grid. Parameters: grid (list of list of str): 2D grid of characters. words (list of str): List of words to search for. Returns: list of str: List of words found in the grid. def isValid(row, col): return 0 <= row < len(grid) and 0 <= col < len(grid[0]) def search(row, col, word, index): if index == len(word): return True if not isValid(row, col) or grid[row][col] != word[index] or visited[row][col]: return False visited[row][col] = True if (search(row + 1, col, word, index + 1) or search(row - 1, col, word, index + 1) or search(row, col + 1, word, index + 1) or search(row, col - 1, word, index + 1)): return True visited[row][col] = False return False found_words = [] for word in words: found = False for row in range(len(grid)): for col in range(len(grid[0])): visited = [[False] * len(grid[0]) for _ in range(len(grid))] if search(row, col, word, 0): found_words.append(word) found = True break if found: break return found_words"},{"question":"def longest_substring_with_m_distinct(S: str, M: int) -> int: Returns the length of the longest substring of S that contains at most M distinct characters. >>> longest_substring_with_m_distinct(\\"abcba\\", 2) 3 >>> longest_substring_with_m_distinct(\\"aaaaaaa\\", 1) 7 def process_test_cases(T: int, test_cases: List[Tuple[str, int]]) -> List[int]: Process multiple test cases to find the longest substring with at most M distinct characters. >>> process_test_cases(2, [(\\"abcba\\", 2), (\\"aaaaaaa\\", 1)]) [3, 7]","solution":"def longest_substring_with_m_distinct(S, M): Returns the length of the longest substring of S that contains at most M distinct characters. from collections import defaultdict window_start = 0 max_length = 0 char_frequency = defaultdict(int) for window_end in range(len(S)): right_char = S[window_end] char_frequency[right_char] += 1 while len(char_frequency) > M: left_char = S[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length def process_test_cases(T, test_cases): results = [] for S, M in test_cases: result = longest_substring_with_m_distinct(S, M) results.append(result) return results"},{"question":"from typing import List def max_stack_height(heights: List[int]) -> int: Given an array of box heights, returns the maximum number of stacked boxes such that each box can only be placed on another box with a height greater than or equal to its own height. >>> max_stack_height([4, 3, 2, 1]) 4 >>> max_stack_height([6, 3, 5, 7, 2]) 4 >>> max_stack_height([]) 0 >>> max_stack_height([10]) 1 >>> max_stack_height([3, 3, 3, 3]) 4 def test_example(): assert max_stack_height([4, 3, 2, 1]) == 4 assert max_stack_height([6, 3, 5, 7, 2]) == 4 def test_single_box(): assert max_stack_height([10]) == 1 def test_identical_heights(): assert max_stack_height([3, 3, 3, 3]) == 4 def test_decreasing_order(): assert max_stack_height([7, 5, 3, 2]) == 4 def test_random_order(): assert max_stack_height([9, 7, 6, 10, 3]) == 5 def test_large_input(): assert max_stack_height([i for i in range(100, 0, -1)]) == 100 def test_no_boxes(): assert max_stack_height([]) == 0","solution":"from typing import List def max_stack_height(heights: List[int]) -> int: Given an array of box heights, returns the maximum number of stacked boxes such that each box can only be placed on another box with a height greater than or equal to its own height. # Sort the heights array in non-increasing (descending) order heights.sort(reverse=True) # Initialize the max stack height to 0 max_height = 0 # Iterate over the sorted array and count the number of boxes that can be stacked for i in range(len(heights)): max_height += 1 return max_height"},{"question":"from typing import List def sum_of_minimums(grid: List[List[int]]) -> int: This function takes a grid of integers and returns the sum of the minimum elements from each row in the grid. Example: >>> sum_of_minimums([[1, 3, 2], [4, 5, 6], [7, 8, 9]]) 12 >>> sum_of_minimums([[5, 1, 3], [3, 3, 3], [7, 8, 1]]) 5 def test_sum_of_minimums(): grid = [[1]] assert sum_of_minimums(grid) == 1 grid = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert sum_of_minimums(grid) == 6 # 2 + 2 + 2 grid = [ [1, 3, 2], [4, 5, 6], [7, 8, 9] ] assert sum_of_minimums(grid) == 12 # 1 + 4 + 7 grid = [ [5, 1, 3], [3, 3, 3], [7, 8, 1] ] assert sum_of_minimums(grid) == 5 # 1 + 3 + 1 grid = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert sum_of_minimums(grid) == -18 # -3 + -6 + -9 grid = [ [10, -10, 20], [0, 0, 0], [-5, 5, -15] ] assert sum_of_minimums(grid) == -25 # -10 + 0 + -15","solution":"def sum_of_minimums(grid): This function takes a grid of integers and returns the sum of the minimum elements from each row in the grid. return sum(min(row) for row in grid)"},{"question":"def evaluateExpression(expression: str) -> int: Given a string representing a mathematical expression, evaluate its value. The string consists of non-negative integers and the operators +, -, *, / (where / represents integer division). The integer division should truncate toward zero. You can assume that the given expression is always valid. Use the standard order of operations where multiplication and division are performed before addition and subtraction. Operators of the same precedence should be evaluated from left to right. >>> evaluateExpression(\\"3+2*2\\") 7 >>> evaluateExpression(\\" 3/2 \\") 1 >>> evaluateExpression(\\" 3+5 / 2 \\") 5 >>> evaluateExpression(\\"10-2*3+4\\") 8 pass from solution import evaluateExpression def test_evaluate_simple_addition(): assert evaluateExpression(\\"3+2\\") == 5 def test_evaluate_simple_subtraction(): assert evaluateExpression(\\"5-2\\") == 3 def test_evaluate_simple_multiplication(): assert evaluateExpression(\\"3*2\\") == 6 def test_evaluate_simple_division(): assert evaluateExpression(\\"6/2\\") == 3 def test_evaluate_combined_operations_1(): assert evaluateExpression(\\"3+2*2\\") == 7 def test_evaluate_combined_operations_2(): assert evaluateExpression(\\" 3/2 \\") == 1 def test_evaluate_combined_operations_3(): assert evaluateExpression(\\" 3+5 / 2 \\") == 5 def test_evaluate_combined_operations_4(): assert evaluateExpression(\\"10-2*3+4\\") == 8 def test_evaluate_combined_operations_5(): assert evaluateExpression(\\"14+2*7-15/3\\") == 23","solution":"def evaluateExpression(expression): def calc(expression): stack = [] num = 0 sign = '+' i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) sign = char num = 0 i += 1 return sum(stack) return calc(expression.replace(\\" \\", \\"\\"))"},{"question":"def can_reach_destination(n: int, m: int, k: int, grid: List[str]) -> str: Determine whether it's possible to reach the bottom-right corner of the grid using up to k bombs. >>> can_reach_destination(5, 5, 2, [\\".....\\", \\"..#..\\", \\".#.\\", \\"..#..\\", \\".....\\"]) == \\"YES\\" >>> can_reach_destination(3, 3, 0, [\\"#\\", \\".#.\\", \\"#\\"]) == \\"NO\\"","solution":"from collections import deque def can_reach_destination(n, m, k, grid): # Directions for movement: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue queue = deque([(0, 0, 0)]) # (x, y, bombs_used) visited = {(0, 0): 0} while queue: x, y, bombs_used = queue.popleft() # Reached destination if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: next_bombs_used = bombs_used + (1 if grid[nx][ny] == '#' else 0) if next_bombs_used <= k and (nx, ny) not in visited: visited[(nx, ny)] = next_bombs_used queue.append((nx, ny, next_bombs_used)) elif next_bombs_used <= k and (nx, ny) in visited and visited[(nx, ny)] > next_bombs_used: queue.append((nx, ny, next_bombs_used)) visited[(nx, ny)] = next_bombs_used return \\"NO\\""},{"question":"def modify_dictionary(people: dict, ops: list) -> dict: Modify the dictionary \`people\` based on the operations specified in \`ops\`. Each operation is either an addition of a new key-value pair, an update to an existing key-value pair, or a removal of a key. :param people: The initial dictionary with names as keys and ages as values. :param ops: A list of operations to perform on the dictionary. :return: The modified dictionary after all operations are performed. >>> modify_dictionary({\\"John\\": 25, \\"Doe\\": 30}, [[\\"add\\", \\"Alice\\", 28]]) {\\"John\\": 25, \\"Doe\\": 30, \\"Alice\\": 28} >>> modify_dictionary({\\"John\\": 25, \\"Doe\\": 30}, [[\\"update\\", \\"John\\", 26]]) {\\"John\\": 26, \\"Doe\\": 30} >>> modify_dictionary({\\"John\\": 25, \\"Doe\\": 30}, [[\\"remove\\", \\"Doe\\"]]) {\\"John\\": 25}","solution":"def modify_dictionary(people: dict, ops: list) -> dict: Modify the dictionary \`people\` based on the operations specified in \`ops\`. :param people: The initial dictionary with names as keys and ages as values. :param ops: A list of operations to perform on the dictionary. :return: The modified dictionary after all operations are performed. for op in ops: action = op[0] key = op[1] if action == \\"add\\" or action == \\"update\\": value = op[2] people[key] = value elif action == \\"remove\\": if key in people: del people[key] return people"},{"question":"def place_buoys(test_cases): Determine distinct positions for buoys on a grid based on given guidelines. Args: test_cases (List[Tuple[int, int]]): List of tuples containing dimensions N and M of the grid. Returns: List[str]: List of strings with the formatted grids for each test case. >>> place_buoys([(3, 3)]) [\\"1 _ _n_ 2 _n_ _ 3\\"] >>> place_buoys([(4, 5)]) [\\"1 _ _ _ _n_ 2 _ _ _n_ _ 3 _ _n_ _ _ 4 _\\"] >>> place_buoys([(3, 3), (4, 5)]) [\\"1 _ _n_ 2 _n_ _ 3\\", \\"1 _ _ _ _n_ 2 _ _ _n_ _ 3 _ _n_ _ _ 4 _\\"] def main(T, dimensions): Runs the place_buoys function for the given number of test cases and dimensions Args: T (int): Number of test cases. dimensions (List[Tuple[int, int]]): List of tuples containing dimensions N and M of the grid. Returns: str: Formatted string of all results for each test case separated by two newlines. >>> main(1, [(1, 1)]) '1' >>> main(1, [(2, 2)]) '1 _n_ 2' >>> main(2, [(3, 3), (4, 5)]) \\"1 _ _n_ 2 _n_ _ 3nn1 _ _ _ _n_ 2 _ _ _n_ _ 3 _ _n_ _ _ 4 _\\"","solution":"def place_buoys(test_cases): results = [] for N, M in test_cases: grid = [['_' for _ in range(M)] for _ in range(N)] for i in range(min(N, M)): grid[i][i] = str(i + 1) # place buoy in diagonal positions as much as N and M allows result = \\"n\\".join(\\" \\".join(row) for row in grid) results.append(result) return results def format_output(results): output = \\"nn\\".join(results) return output def main(T, dimensions): results = place_buoys(dimensions) output = format_output(results) return output"},{"question":"from typing import List def shortest_path_in_grid(grid: List[str]) -> int: Find the shortest path from the top-left to the bottom-right corner of the grid. :param grid: List of strings representing the grid where '.' is open space and '#' is obstacle. :return: Length of the shortest path. >>> shortest_path_in_grid([\\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"]) 8 >>> shortest_path_in_grid([\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 6 >>> shortest_path_in_grid([\\".#.\\", \\".#.\\", \\"...\\"]) 4 >>> shortest_path_in_grid([\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> shortest_path_in_grid([\\".\\"]) 0","solution":"from collections import deque def shortest_path_in_grid(grid): Find the shortest path from the top-left to the bottom-right corner of the grid. :param grid: List of strings representing the grid where '.' is open space and '#' is obstacle. :return: Length of the shortest path. n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List, Union def find_difference(numbers: List[int]) -> Union[int, None]: Given an unsorted list of integers, return the difference between the largest and smallest values. If the list is empty, return None. >>> find_difference([3, 7, 2, 9, 4]) 7 >>> find_difference([-7, 0, 5, 8]) 15 >>> find_difference([10]) 0 >>> find_difference([]) None","solution":"from typing import List, Union def find_difference(numbers: List[int]) -> Union[int, None]: Returns the difference between the largest and smallest values in the list \`numbers\`. If the list is empty, returns None. if not numbers: return None largest = max(numbers) smallest = min(numbers) return largest - smallest"},{"question":"from typing import List, Tuple def create_grid_and_start(n: int, k: int) -> Tuple[List[List[str]], int, int]: Creates an n x n grid with exactly k storage units and specifies a starting point (r, c) for unlocking. >>> create_grid_and_start(5, 5) ([['1', '0', '0', '0', '0'], ['0', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '0'], ['0', '0', '0', '0', '1']], 1, 1) >>> create_grid_and_start(2, 1) ([['1', '0'], ['0', '0']], 1, 1) pass def format_output(grid: List[List[str]], r: int, c: int) -> str: Formats the grid and starting point into a string output format as specified. >>> grid = [['1', '0', '0', '0', '0'], ['0', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '0'], ['0', '0', '0', '0', '1']] >>> format_output(grid, 1, 1) '10000n01000n00100n00010n00001n1 1' pass def place_and_unlock(n: int, k: int) -> str: Generates the grid, places storage units, and returns the formatted output. >>> place_and_unlock(5, 5) '10000n01000n00100n00010n00001n1 1' >>> place_and_unlock(2, 1) '10n00n1 1' pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def create_grid_and_start(n, k): Creates an n x n grid and specifies a starting point (r, c) such that exactly k storage units can be unlocked without spreading corruption beyond k units. grid = [['0'] * n for _ in range(n)] storage_units = k # Start placing '1's in the diagonal until we have placed k storage units for i in range(n): if storage_units > 0: grid[i][i] = '1' storage_units -= 1 else: break # The starting point will be the first '1' on the diagonal start_row, start_col = 1, 1 return grid, start_row, start_col # Function to format the output def format_output(grid, r, c): output = \\"n\\".join([\\"\\".join(row) for row in grid]) output += f\\"n{r} {c}\\" return output # Example function to use both functions and display the result def place_and_unlock(n, k): grid, r, c = create_grid_and_start(n, k) return format_output(grid, r, c)"},{"question":"def has_cycle(graph): Determines if the directed graph contains a cycle. Args: graph (List[List[int]]): Adjacency list representing the directed graph. Returns: bool: True if the graph contains a cycle, False otherwise. Examples: >>> has_cycle([ [1, 2], [2], [0, 3], [3] ]) True >>> has_cycle([ [1], [2], [] ]) False","solution":"def has_cycle(graph): Determines if the directed graph contains a cycle. def dfs(v): Depth-First Search to detect a cycle. if visited[v] == 1: # Visiting the node currently implies a cycle. return True if visited[v] == 2: # Already visited node in a previous path return False visited[v] = 1 for neighbor in graph[v]: if dfs(neighbor): return True visited[v] = 2 return False visited = [0] * len(graph) for vertex in range(len(graph)): if visited[vertex] == 0: if dfs(vertex): return True return False"},{"question":"from typing import List def min_palindromic_cuts(S: str) -> int: Determine the minimum number of cuts needed to partition the string into palindromic substrings. Args: S (str): The string to partition. Returns: int: The minimum number of cuts required. >>> min_palindromic_cuts(\\"aab\\") 1 >>> min_palindromic_cuts(\\"a\\") 0 pass def solve_palindromic_partition(T: int, test_cases: List[str]) -> List[int]: Determine the minimum number of cuts needed for multiple test cases to partition each string into palindromic substrings. Args: T (int): Number of test cases. test_cases (List[str]): List of strings to partition. Returns: List[int]: List of minimum number of cuts required for each string. >>> solve_palindromic_partition(2, [\\"aab\\", \\"a\\"]) [1, 0] pass","solution":"def min_palindromic_cuts(S): n = len(S) if n == 0: return 0 # dp[i] will be the minimum number of cuts needed for the string S[:i+1] dp = [0] * n palindrome = [[False] * n for _ in range(n)] for i in range(n): min_cut = i # Max cuts needed is cutting each character individually for j in range(i + 1): if S[j] == S[i] and (i - j < 2 or palindrome[j + 1][i - 1]): palindrome[j][i] = True min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut return dp[-1] def solve_palindromic_partition(T, test_cases): results = [] for case in test_cases: results.append(min_palindromic_cuts(case)) return results"},{"question":"def count_peaks(altitudes: List[int]) -> int: Returns the number of distinct peaks in the array. A peak is defined as a point that is strictly greater than its immediately adjacent elements. >>> count_peaks([2, 4, 2, 1, 2, 6, 3, 2]) 2 >>> count_peaks([1, 2, 3, 4, 5]) 0","solution":"def count_peaks(altitudes): Returns the number of distinct peaks in the array. A peak is defined as a point that is strictly greater than its immediately adjacent elements. if len(altitudes) < 3: return 0 peaks_count = 0 for i in range(1, len(altitudes) - 1): if altitudes[i] > altitudes[i - 1] and altitudes[i] > altitudes[i + 1]: peaks_count += 1 return peaks_count"},{"question":"def find_unique_combinations(data): Given a dictionary where the keys are strings and the values are lists of integers, return a list of all unique combinations of integers where each combination includes exactly one integer from each list, in lexicographical order. >>> data = {\\"A\\": [1, 2], \\"B\\": [3], \\"C\\": [4, 5]} >>> find_unique_combinations(data) [[1, 3, 4], [1, 3, 5], [2, 3, 4], [2, 3, 5]] >>> data = {\\"A\\": [1, 2, 3]} >>> find_unique_combinations(data) [[1], [2], [3]] >>> data = {\\"A\\": [], \\"B\\": [1, 2], \\"C\\": [3, 4]} >>> find_unique_combinations(data) [] >>> data = {\\"A\\": [1], \\"B\\": [2, 3], \\"C\\": [4]} >>> find_unique_combinations(data) [[1, 2, 4], [1, 3, 4]] >>> data = {\\"A\\": [1, 2, 3], \\"B\\": [4, 5], \\"C\\": [6, 7, 8]} >>> find_unique_combinations(data) [[1, 4, 6], [1, 4, 7], [1, 4, 8], [1, 5, 6], [1, 5, 7], [1, 5, 8], [2, 4, 6], [2, 4, 7], [2, 4, 8], [2, 5, 6], [2, 5, 7], [2, 5, 8], [3, 4, 6], [3, 4, 7], [3, 4, 8], [3, 5, 6], [3, 5, 7], [3, 5, 8]] >>> data = {} >>> find_unique_combinations(data) [[]]","solution":"def find_unique_combinations(data): keys = sorted(data.keys()) result = [] def recurse(curr_comb, idx): if idx == len(keys): # Base case: if combination is complete result.append(curr_comb[:]) return key = keys[idx] for num in sorted(data[key]): curr_comb.append(num) recurse(curr_comb, idx + 1) curr_comb.pop() recurse([], 0) return result"},{"question":"from typing import List def trap_water(heights: List[int]) -> int: Calculate the maximum amount of water that can be trapped between the buildings after it rains. >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([]) 0 >>> trap_water([1, 1, 1, 1]) 0 >>> trap_water([3, 3, 3, 3, 3]) 0","solution":"from typing import List def trap_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n trapped_water = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from typing import List def min_total_distance(houses: List[int], k: int) -> int: Determine the minimum total distance between the houses and the nearest mailbox. Each mailbox can cover multiple houses, and each house must be covered by exactly one mailbox. Args: houses (List[int]): List of house positions along a street. k (int): Number of mailboxes to install. Returns: int: The minimum total distance. Examples: >>> min_total_distance([1, 4, 8, 10], 2) 5 >>> min_total_distance([1, 3, 6, 7, 8, 9], 1) 14 def test_example_1(): houses = [1, 4, 8, 10] k = 2 assert min_total_distance(houses, k) == 5 def test_example_2(): houses = [1, 3, 6, 7, 8, 9] k = 1 assert min_total_distance(houses, k) == 14 def test_single_house_single_mailbox(): houses = [1] k = 1 assert min_total_distance(houses, k) == 0 def test_two_houses_two_mailboxes(): houses = [3, 6] k = 2 assert min_total_distance(houses, k) == 0 def test_multiple_houses_multiple_mailboxes(): houses = [1, 2, 3, 4, 5, 6] k = 3 assert min_total_distance(houses, k) == 3 def test_minimal_total_distance(): houses = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] k = 5 assert min_total_distance(houses, k) == 5 def test_all_houses_at_same_position(): houses = [5, 5, 5, 5, 5] k = 2 assert min_total_distance(houses, k) == 0 def test_more_complicated_case(): houses = [5, 10, 15, 20, 25] k = 2 assert min_total_distance(houses, k) == 15","solution":"from typing import List import sys def min_total_distance(houses: List[int], k: int) -> int: houses.sort() def cost(start, end): mid = (end + start) // 2 mid_house = houses[mid] return sum(abs(houses[i] - mid_house) for i in range(start, end + 1)) n = len(houses) dp = [[sys.maxsize] * (k + 1) for _ in range(n)] for i in range(n): dp[i][1] = cost(0, i) for j in range(2, k + 1): for i in range(n): for p in range(i): dp[i][j] = min(dp[i][j], dp[p][j - 1] + cost(p + 1, i)) return dp[n - 1][k]"},{"question":"from collections import Counter def min_steps_to_anagram(A: str, B: str) -> int: Given a string A and a string B, find the minimum number of steps required to make A an anagram of B. In one step, you can replace any character in A with any other character. An anagram of a string is another string that contains the same characters, only the order of characters can be different. Examples: >>> min_steps_to_anagram(\\"anagram\\", \\"mangaar\\") 0 >>> min_steps_to_anagram(\\"xxyyzz\\", \\"xxyyzz\\") 0 >>> min_steps_to_anagram(\\"friend\\", \\"family\\") 4 >>> min_steps_to_anagram(\\"abc\\", \\"def\\") 3","solution":"from collections import Counter def min_steps_to_anagram(A, B): Returns the minimum number of steps required to make string A an anagram of string B. count_A = Counter(A) count_B = Counter(B) steps = sum((count_A - count_B).values()) return steps"},{"question":"def minAddToMakeValid(S: str) -> int: Returns the minimum number of parentheses needed to make the input string valid. >>> minAddToMakeValid(\\"((()))()\\") 0 >>> minAddToMakeValid(\\"(()\\") 1 >>> minAddToMakeValid(\\"))((\\") 4 >>> minAddToMakeValid(\\"\\") 0 >>> minAddToMakeValid(\\"((((((\\") 6 >>> minAddToMakeValid(\\")))))\\") 5 >>> minAddToMakeValid(\\"()(()))\\") 1 >>> minAddToMakeValid(\\"(((())))\\") 0","solution":"def minAddToMakeValid(S): Returns the minimum number of parentheses needed to make the input string valid. left_needed = 0 right_needed = 0 for char in S: if char == '(': right_needed += 1 elif char == ')': if right_needed > 0: right_needed -= 1 else: left_needed += 1 return left_needed + right_needed"},{"question":"def groupAnagrams(strs): Groups a list of strings into anagrams. >>> groupAnagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> groupAnagrams([\\"\\"]) == [[\\"\\"]] >>> groupAnagrams([\\"a\\"]) == [[\\"a\\"]] from solution import groupAnagrams def test_groupAnagrams_example_1(): input_data = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] expected_output = [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] output = groupAnagrams(input_data) # Convert lists of anagrams to sets of frozen sets for comparison (order doesn't matter) expected_output = {frozenset(group) for group in expected_output} output = {frozenset(group) for group in output} assert output == expected_output def test_groupAnagrams_single_empty_string(): assert groupAnagrams([\\"\\"]) == [[\\"\\"]] def test_groupAnagrams_single_character(): assert groupAnagrams([\\"a\\"]) == [[\\"a\\"]] def test_groupAnagrams_no_anagrams(): assert groupAnagrams([\\"a\\", \\"b\\", \\"c\\"]) == [[\\"a\\"], [\\"b\\"], [\\"c\\"]] def test_groupAnagrams_multiple_empty_strings(): assert groupAnagrams([\\"\\", \\"\\"]) == [[\\"\\", \\"\\"]] def test_groupAnagrams_mixed_case_sensitivity(): input_data = [\\"a\\", \\"A\\"] expected_output = [[\\"a\\"], [\\"A\\"]] output = groupAnagrams(input_data) # Convert lists of anagrams to sets of frozen sets for comparison (order doesn't matter) expected_output = {frozenset(group) for group in expected_output} output = {frozenset(group) for group in output} assert output == expected_output def test_groupAnagrams_large_input(): input_data = [\\"a\\"*i for i in range(1, 1001)] expected_output = [[\\"a\\"*i] for i in range(1, 1001)] output = groupAnagrams(input_data) # Convert lists of anagrams to sets of frozen sets for comparison (order doesn't matter) expected_output = {frozenset(group) for group in expected_output} output = {frozenset(group) for group in output} assert output == expected_output","solution":"from collections import defaultdict def groupAnagrams(strs): Groups a list of strings into anagrams. anagram_map = defaultdict(list) for word in strs: # Sort the word and use it as a key sorted_word = ''.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"def is_path(graph, start, end): Checks if there is a path from start to end in the given graph. Uses Depth-First Search (DFS) to explore the path. >>> is_path({1: [2, 3], 2: [4], 3: [], 4: [1]}, 1, 4) True >>> is_path({1: [2, 3], 2: [4], 3: [], 4: [1]}, 3, 4) False pass def test_case_1(): graph = {1: [2, 3], 2: [4], 3: [], 4: [1]} assert is_path(graph, 1, 4) == True def test_case_2(): graph = {1: [2, 3], 2: [4], 3: [], 4: [1]} assert is_path(graph, 3, 4) == False def test_case_3(): graph = {1: [2], 2: [3], 3: [4], 4: []} assert is_path(graph, 1, 4) == True def test_case_4(): graph = {1: [2], 2: [3], 3: [4], 4: []} assert is_path(graph, 4, 1) == False def test_case_no_edges(): graph = {} assert is_path(graph, 1, 2) == False def test_case_self_loop(): graph = {1: [1]} assert is_path(graph, 1, 1) == True def test_case_cycle_graph(): graph = {1: [2], 2: [3], 3: [1]} assert is_path(graph, 1, 3) == True assert is_path(graph, 3, 1) == True assert is_path(graph, 2, 2) == True def test_case_disconnected_graph(): graph = {1: [2], 3: [4]} assert is_path(graph, 1, 2) == True assert is_path(graph, 3, 4) == True assert is_path(graph, 1, 4) == False","solution":"def is_path(graph, start, end): Checks if there is a path from start to end in the given graph. Uses Depth-First Search (DFS) to explore the path. def dfs(node, visited): if node == end: return True visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited): return True return False return dfs(start, set())"},{"question":"def areCollectionsComplete(collections: List[Dict[str, List[str]]]) -> bool: Returns true if all collections have at least one book in each category: Fiction, Non-Fiction, and Biography. >>> areCollectionsComplete([ {'fiction': ['Book A'], 'nonFiction': ['Book B'], 'biography': ['Book C']}, {'fiction': ['Book D'], 'nonFiction': ['Book E'], 'biography': ['Book F']} ]) True >>> areCollectionsComplete([ {'fiction': ['Book A'], 'nonFiction': ['Book B'], 'biography': ['Book C']}, {'fiction': ['Book D'], 'nonFiction': [], 'biography': ['Book E']} ]) False >>> areCollectionsComplete([ {'fiction': [], 'nonFiction': [], 'biography': []} ]) False >>> areCollectionsComplete([ {'fiction': ['Book A'], 'nonFiction': ['Book B'], 'biography': ['Book C']}, {'fiction': [], 'nonFiction': ['Book E'], 'biography': ['Book F']} ]) False >>> areCollectionsComplete([]) True","solution":"def areCollectionsComplete(collections): Returns true if all collections have at least one book in each category: Fiction, Non-Fiction, and Biography. for collection in collections: if not (collection.get('fiction') and collection.get('nonFiction') and collection.get('biography')): return False return True"},{"question":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of parentheses that need to be added to make the string valid. A string is considered valid if it is empty or it can be written as AB (A and B are valid strings) or (A) (A is a valid string). Args: s (str): Input string consisting of only '(' and ')'. Returns: int: Minimum number of parentheses needed to make the string valid. Examples: >>> min_add_to_make_valid(\\"()\\") 0 >>> min_add_to_make_valid(\\"(()\\") 1 >>> min_add_to_make_valid(\\"())(\\") 2 >>> min_add_to_make_valid(\\"(()())(\\") 1","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses that need to be added to make the string valid. left_balance = 0 right_balance = 0 for char in s: if char == '(': left_balance += 1 else: # char == ')' if left_balance > 0: left_balance -= 1 else: right_balance += 1 return left_balance + right_balance"},{"question":"def string_compression(text: str) -> str: Compresses the input text by counting consecutive repeated characters. If the compressed string is not shorter than the original string, return the original string. >>> string_compression('aaabbcc') 'a3b2c2' >>> string_compression('abcd') 'abcd' >>> string_compression('aabbccddeee') 'a2b2c2d2e3' >>> string_compression('aabcccccaaa') 'a2b1c5a3' >>> string_compression('abcdeeeabc') 'abcdeeeabc'","solution":"def string_compression(text): Compresses the input text by counting consecutive repeated characters. if not text: return text compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(text[i - 1] + str(count)) count = 1 # Add the last group compressed.append(text[-1] + str(count)) # Join the compressed list into a string compressed_string = ''.join(compressed) # Return the original string if compressed string is not shorter return compressed_string if len(compressed_string) < len(text) else text"},{"question":"class ArrayOperations: Perform update and query operations on an array. Update: Add a value to each element within a range. Query: Return the sum of elements within a range. >>> ops = ArrayOperations([1, 2, 3, 4, 5]) >>> ops.update(1, 3, 2) >>> ops.query(1, 3) 12 >>> ops.update(2, 5, 4) >>> ops.query(1, 5) 37 >>> ops.query(3, 4) 17 def __init__(self, array): self.array = array def update(self, L, R, V): pass def query(self, L, R): pass def test_update_and_query_operations(): array = [1, 2, 3, 4, 5] ops = ArrayOperations(array) ops.update(1, 3, 2) assert ops.array == [3, 4, 5, 4, 5] assert ops.query(1, 3) == 12 ops.update(2, 5, 4) assert ops.array == [3, 8, 9, 8, 9] assert ops.query(1, 5) == 37 assert ops.query(3, 4) == 17 def test_update_with_negative(): array = [10, 20, 30, 40, 50] ops = ArrayOperations(array) ops.update(2, 4, -5) assert ops.array == [10, 15, 25, 35, 50] assert ops.query(2, 5) == 125 def test_query_single_element(): array = [7, 8, 9, 10, 11] ops = ArrayOperations(array) assert ops.query(3, 3) == 9 assert ops.query(1, 1) == 7 assert ops.query(5, 5) == 11 def test_large_update_and_query(): array = [0] * 100000 ops = ArrayOperations(array) ops.update(1, 100000, 5) assert ops.array == [5] * 100000 ops.update(1, 50000, -2) assert ops.array[:50000] == [3] * 50000 and ops.array[50000:] == [5] * 50000 assert ops.query(1, 100000) == 400000 assert ops.query(50001, 100000) == 250000","solution":"class ArrayOperations: def __init__(self, array): self.array = array def update(self, L, R, V): for i in range(L-1, R): self.array[i] += V def query(self, L, R): return sum(self.array[L-1:R])"},{"question":"def longest_common_prefix(strs): Returns the longest common prefix string among an array of strings. If there is no common prefix, returns an empty string \\"\\". Args: strs (List[str]): List of input strings Returns: str: Longest common prefix pass # Unit Tests def test_common_prefix_all_strings(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_no_common_prefix(): assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_full_string_prefix(): assert longest_common_prefix([\\"interspecies\\", \\"intersection\\", \\"interstellar\\"]) == \\"inters\\" def test_one_string(): assert longest_common_prefix([\\"single\\"]) == \\"single\\" def test_empty_string_in_array(): assert longest_common_prefix([\\"\\", \\"b\\", \\"c\\"]) == \\"\\" def test_with_empty_array(): assert longest_common_prefix([]) == \\"\\" def test_identical_strings(): assert longest_common_prefix([\\"same\\", \\"same\\", \\"same\\"]) == \\"same\\" def test_prefix_in_identity_order(): assert longest_common_prefix([\\"prefix\\", \\"pre\\", \\"\\"]) == \\"\\"","solution":"def longest_common_prefix(strs): Returns the longest common prefix string among an array of strings. If there is no common prefix, returns an empty string \\"\\". Args: strs (List[str]): List of input strings Returns: str: Longest common prefix if not strs: return \\"\\" # Initialize the prefix to the first string prefix = strs[0] # Iterate over all strings in the array for string in strs[1:]: # Reduce the prefix while it is not a prefix of the string while string[:len(prefix)] != prefix and prefix: prefix = prefix[:-1] # If there is no common prefix, return an empty string if not prefix: return \\"\\" return prefix"},{"question":"def find_cycle_lengths(n: int, teleports: List[int]) -> List[int]: Given the number of teleporter stations and a list of teleportation links, find the length of the teleportation cycle that each station belongs to. Args: n (int): The number of teleporter stations. teleports (List[int]): A list where the i-th integer is the index (1-based) of the station to which the i-th station teleports. Returns: List[int]: A list of the lengths of the teleportation cycles. pass def solve_teleporter_cycles(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Given multiple test cases, determine the teleportation cycle lengths for each station in each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list where each element is a tuple containing the number of teleporter stations and a list of teleportation links. Returns: List[List[int]]: A list of lists, where each inner list contains the lengths of the teleportation cycles for a test case. pass def test_find_cycle_lengths(): assert find_cycle_lengths(5, [2, 3, 1, 5, 4]) == [3, 3, 3, 2, 2] assert find_cycle_lengths(6, [2, 3, 4, 5, 6, 1]) == [6, 6, 6, 6, 6, 6] def test_solve_teleporter_cycles(): test_cases = [ (5, [2, 3, 1, 5, 4]), (6, [2, 3, 4, 5, 6, 1]) ] expected = [ [3, 3, 3, 2, 2], [6, 6, 6, 6, 6, 6] ] assert solve_teleporter_cycles(2, test_cases) == expected","solution":"def find_cycle_lengths(n, teleports): visited = [False] * n cycle_lengths = [0] * n for i in range(n): if visited[i]: continue # Find the cycle starting from station i slow = i fast = i while True: slow = teleports[slow] - 1 fast = teleports[teleports[fast] - 1] - 1 if slow == fast: break # Determine the length of the cycle cycle_length = 1 start = slow position = teleports[start] - 1 while position != start: cycle_length += 1 position = teleports[position] - 1 # Assign cycle length to all stations in the cycle position = slow while not visited[position]: visited[position] = True cycle_lengths[position] = cycle_length position = teleports[position] - 1 return cycle_lengths def solve_teleporter_cycles(T, test_cases): results = [] for n, teleports in test_cases: results.append(find_cycle_lengths(n, teleports)) return results"},{"question":"from collections import Counter def canFormPalindrome(s: str) -> bool: Checks if the input string can be rearranged to form a palindrome. Args: s (str): The input string consisting of only lowercase alphabets. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> canFormPalindrome(\\"carrace\\") True >>> canFormPalindrome(\\"hello\\") False","solution":"from collections import Counter def canFormPalindrome(s): Checks if the input string can be rearranged to form a palindrome. Args: s (str): The input string consisting of only lowercase alphabets. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. count = Counter(s) odd_count = sum(1 for count in count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def reverse_string(s: str) -> str: Recursively reverses a given string. Args: s (str): The string to be reversed. Returns: str: The reversed string. >>> reverse_string('hello') 'olleh' >>> reverse_string('recursion') 'noisrucer' >>> reverse_string('a') 'a' >>> reverse_string('') '' >>> reverse_string('A man a plan a canal Panama') 'amanaP lanac a nalp a nam A'","solution":"def reverse_string(s: str) -> str: Recursively reverses a given string. Args: s (str): The string to be reversed. Returns: str: The reversed string. if len(s) <= 1: # Base case: If the string is empty or has one character, return it as is. return s else: # Recursive case: Take the last character and add it to the reverse of the rest of the string. return s[-1] + reverse_string(s[:-1])"},{"question":"def longest_subsequence(s: str) -> str: Create a function \`longest_subsequence\` that takes a string as input and returns the longest substring without repeating characters. If there are multiple substrings with the same maximum length, return the first one that occurs. >>> longest_subsequence(\\"abcabcbb\\") 'abc' >>> longest_subsequence(\\"bbbbb\\") 'b' >>> longest_subsequence(\\"pwwkew\\") 'wke' Unit Test: from solution import longest_subsequence def test_example_cases(): assert longest_subsequence(\\"abcabcbb\\") == \\"abc\\" assert longest_subsequence(\\"bbbbb\\") == \\"b\\" assert longest_subsequence(\\"pwwkew\\") == \\"wke\\" def test_empty_string(): assert longest_subsequence(\\"\\") == \\"\\" def test_single_character_string(): assert longest_subsequence(\\"a\\") == \\"a\\" def test_all_unique_characters(): assert longest_subsequence(\\"abcdefgh\\") == \\"abcdefgh\\" def test_repeated_characters_separated(): assert longest_subsequence(\\"abba\\") == \\"ab\\" assert longest_subsequence(\\"abcdefga\\") == \\"abcdefg\\" def test_longer_subsequence_after_repeat(): assert longest_subsequence(\\"dvdf\\") == \\"vdf\\" def test_all_repeating_characters(): assert longest_subsequence(\\"aaaa\\") == \\"a\\"","solution":"def longest_subsequence(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple substrings with the same maximum length, returns the first one that occurs. start = 0 max_length = 0 max_substring = \\"\\" seen_chars = {} for end, char in enumerate(s): if char in seen_chars and seen_chars[char] >= start: start = seen_chars[char] + 1 seen_chars[char] = end if end - start + 1 > max_length: max_length = end - start + 1 max_substring = s[start:end + 1] return max_substring"},{"question":"def custom_sort(arr): Implement a sorting algorithm (such as Bubble Sort, Selection Sort, or Insertion Sort) to sort a list of integers in ascending order without using the built-in sort function. >>> custom_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> custom_sort([-3, -1, -7, -4, -5, -9]) [-9, -7, -5, -4, -3, -1] >>> custom_sort([3, -2, 9, 4, -5, 0]) [-5, -2, 0, 3, 4, 9] >>> custom_sort([4, 2, 2, 4, 3, 1]) [1, 2, 2, 3, 4, 4] >>> custom_sort([]) [] >>> custom_sort([5]) [5]","solution":"def custom_sort(arr): Sorts a list of integers in ascending order using the Selection Sort algorithm. if not arr: return arr n = len(arr) for i in range(n): # Assume the current position holds the minimum min_idx = i # Traverse the unsorted sublist for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element of the unsorted sublist arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"def manage_bookings(test_cases): Manage the bookings and cancellations for SkyHigh Airways based on the given test cases. Each test case involves a series of booking and cancellation operations on flights with specific capacities. Booking should adhere to the capacity constraints, and cancellations should remove the passengers from the system. For each test case: - F: Number of flights - N: Number of operations - capacities: List of seating capacities for each flight - operations: List of operations to be performed Operations are of two types: - [1, flightNumber, ticketNumber]: Book a seat on the given flight (1-based index) - [2, ticketNumber]: Cancel the booking with the given ticket number Args: test_cases (list): A list of tuples, with each tuple containing: - F (int): Number of flights - N (int): Number of operations - capacities (list): List of seating capacities for each flight - operations (list): List of operations to be performed Returns: list: Results for each operation in each test case, where each result is either \\"Booking Confirmed\\" or \\"Booking Failed\\". Examples: >>> manage_bookings([(3, 6, [100, 200, 150], [[1, 1, 101], [1, 2, 102], [1, 2, 103], [2, 102], [1, 2, 104], [1, 3, 105]])]) [\\"Booking Confirmed\\", \\"Booking Confirmed\\", \\"Booking Confirmed\\", \\"Booking Confirmed\\", \\"Booking Confirmed\\"] >>> manage_bookings([(1, 3, [2], [[1, 1, 101], [1, 1, 102], [1, 1, 103]])]) [\\"Booking Confirmed\\", \\"Booking Confirmed\\", \\"Booking Failed\\"] pass def process_input(input_data): Process the input data to extract test cases. Args: input_data (str): The input data as a string Returns: list: A list of tuples representing the test cases. Examples: >>> process_input(\\"1n1 2n100n1 1 101n2 101n\\") [(1, 2, [100], [[1, 1, 101], [2, 101]])] pass def main(input_data): Main function to process the input and manage bookings. Args: input_data (str): The input data as a string Returns: str: The output results as a single string joined by newline characters. Examples: >>> main(\\"1n1 4n2n1 1 101n1 1 102n2 101n1 1 103n\\") \\"Booking ConfirmednBooking ConfirmednBooking Confirmed\\" pass import pytest def test_example_case(): input_data = 2 3 6 100 200 150 1 1 101 1 2 102 1 2 103 2 102 1 2 104 1 3 105 2 3 2 4 200 300 1 1 202 1 1 203 2 202 1 1 204 expected_output = Booking Confirmed Booking Confirmed Booking Confirmed Booking Confirmed Booking Confirmed Booking Confirmed Booking Confirmed assert main(input_data) == expected_output def test_full_bookings(): input_data = 1 1 3 2 1 1 101 1 1 102 1 1 103 expected_output = Booking Confirmed Booking Confirmed Booking Failed assert main(input_data) == expected_output def test_cancellation(): input_data = 1 1 4 2 1 1 101 1 1 102 2 101 1 1 103 expected_output = Booking Confirmed Booking Confirmed Booking Confirmed assert main(input_data) == expected_output def test_multiple_flights_booking(): input_data = 1 2 4 2 1 1 1 101 1 2 201 1 1 102 1 2 202 expected_output = Booking Confirmed Booking Confirmed Booking Confirmed Booking Failed assert main(input_data) == expected_output def test_input_processing(): input_data = 1 1 2 100 1 1 101 2 101 test_cases = process_input(input_data) assert test_cases == [ (1, 2, [100], [[1, 1, 101], [2, 101]]) ] def test_management_logic(): test_cases = [ (1, 4, [2], [[1, 1, 101], [1, 1, 102], [2, 101], [1, 1, 103]]) ] results = manage_bookings(test_cases) assert results == [\\"Booking Confirmed\\", \\"Booking Confirmed\\", \\"Booking Confirmed\\"]","solution":"def manage_bookings(test_cases): results = [] for test in test_cases: F, N, capacities, operations = test # Initialize the flight bookings and a ticket to flight map bookings = {i: [] for i in range(1, F+1)} ticket_flight_map = {} for operation in operations: if operation[0] == 1: # Book a seat flightNumber, ticketNumber = operation[1], operation[2] if len(bookings[flightNumber]) < capacities[flightNumber - 1]: bookings[flightNumber].append(ticketNumber) ticket_flight_map[ticketNumber] = flightNumber results.append(\\"Booking Confirmed\\") else: results.append(\\"Booking Failed\\") elif operation[0] == 2: # Cancel a booking ticketNumber = operation[1] if ticketNumber in ticket_flight_map: flightNumber = ticket_flight_map[ticketNumber] bookings[flightNumber].remove(ticketNumber) del ticket_flight_map[ticketNumber] return results def process_input(input_data): lines = input_data.splitlines() T = int(lines[0].strip()) index = 1 test_cases = [] for _ in range(T): F, N = map(int, lines[index].strip().split()) index += 1 capacities = list(map(int, lines[index].strip().split())) index += 1 operations = [] for _ in range(N): operation = list(map(int, lines[index].strip().split())) operations.append(operation) index += 1 test_cases.append((F, N, capacities, operations)) return test_cases def main(input_data): test_cases = process_input(input_data) results = manage_bookings(test_cases) return 'n'.join(results)"},{"question":"def find_highest_weight_day(T: int, test_cases: List[List[Tuple[str, int]]]) -> List[str]: Process the records of fish sales and determine the day with the highest aggregate weight of the fish sold. If there are multiple days with the same maximum aggregate weight, the earliest day identifier should be returned. >>> find_highest_weight_day(2, [[(\\"Monday\\", 100), (\\"Tuesday\\", 200), (\\"Monday\\", 150), (\\"Wednesday\\", 300), (\\"Tuesday\\", 100)], [(\\"Friday\\", 100), (\\"Saturday\\", 400), (\\"Sunday\\", 400)]]) [\\"Tuesday\\", \\"Saturday\\"] >>> find_highest_weight_day(1, [[(\\"Monday\\", 100)]]) [\\"Monday\\"] >>> find_highest_weight_day(1, [[(\\"Friday\\", 100), (\\"Saturday\\", 400), (\\"Sunday\\", 400)]]) [\\"Saturday\\"]","solution":"def find_highest_weight_day(T, test_cases): results = [] for i in range(T): sales = test_cases[i] weight_per_day = {} for record in sales: day, weight = record if day not in weight_per_day: weight_per_day[day] = 0 weight_per_day[day] += int(weight) max_weight = max(weight_per_day.values()) highest_weight_days = [day for day, weight in weight_per_day.items() if weight == max_weight] results.append(sorted(highest_weight_days)[0]) return results"},{"question":"def reverse_sentence(sentence: str) -> str: Reverses the words in the given sentence without changing the order of characters within each word. Args: sentence (str): The sentence to reverse. Returns: str: The sentence with words in reverse order. >>> reverse_sentence(\\"Hello\\") == \\"Hello\\" >>> reverse_sentence(\\"Hello World\\") == \\"World Hello\\" >>> reverse_sentence(\\"Coding is fun\\") == \\"fun is Coding\\" >>> reverse_sentence(\\"Python is awesome\\") == \\"awesome is Python\\" >>> reverse_sentence(\\"a b c\\") == \\"c b a\\" >>> reverse_sentence(\\"The quick brown fox jumps over the lazy dog\\") == \\"dog lazy the over jumps fox brown quick The\\" >>> reverse_sentence(\\"\\") == \\"\\"","solution":"def reverse_sentence(sentence): Reverses the words in the given sentence without changing the order of characters within each word. Args: sentence (str): The sentence to reverse. Returns: str: The sentence with words in reverse order. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List def maxWidth(tree: List[int]) -> int: Compute the maximum width of any level in the binary tree represented as an array. Args: tree (List[int]): A list of integers representing the binary tree where each node is either a number or the value \`-1\` representing a null node. Returns: int: The maximum width of any level in the binary tree. Examples: >>> maxWidth([1, 3, 2, 5, 3, -1, 9]) 3 >>> maxWidth([1, 2, 3, 4, -1, -1, -1, 5, 6]) 2 >>> maxWidth([1, -1, 2, -1, -1, -1, 3]) 1","solution":"from typing import List def maxWidth(tree: List[int]) -> int: if not tree or tree[0] == -1: return 0 max_width = 0 current_level = 0 queue = [(0, tree[0])] # (index, value) while queue: level_length = len(queue) current_width = 0 for _ in range(level_length): index, value = queue.pop(0) if value != -1: current_width += 1 left_index = 2 * index + 1 right_index = 2 * index + 2 if left_index < len(tree): queue.append((left_index, tree[left_index])) if right_index < len(tree): queue.append((right_index, tree[right_index])) max_width = max(max_width, current_width) return max_width"},{"question":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindromic substring in a given string s. >>> longest_palindrome_length(\\"babad\\") == 3 >>> longest_palindrome_length(\\"cbbd\\") == 2 >>> longest_palindrome_length(\\"a\\") == 1 >>> longest_palindrome_length(\\"banana\\") == 5 >>> longest_palindrome_length(\\"abcde\\") == 1 >>> longest_palindrome_length(\\"racecar\\") == 7 >>> longest_palindrome_length(\\"abacdfgdcaba\\") == 3 >>> longest_palindrome_length(\\"abacdfgdcabba\\") == 4 def process_test_cases(input_data: str) -> List[int]: Processes multiple test cases and returns the results. >>> process_test_cases(\\"3nbabadncbbdna\\") == [3, 2, 1] >>> process_test_cases(\\"2nbanananabcde\\") == [5, 1]","solution":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindromic substring in a given string s. n = len(s) if n < 2: return n start, max_length = 0, 1 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True for end in range(1, n): for start in range(end): if s[start] == s[end]: if end - start == 1 or dp[start + 1][end - 1]: dp[start][end] = True max_length = max(max_length, end - start + 1) return max_length def process_test_cases(input_data): test_cases = input_data.strip().split('n') T = int(test_cases[0]) results = [] for i in range(1, T + 1): s = test_cases[i].strip() results.append(longest_palindrome_length(s)) return results"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Returns a new list with duplicate values removed, retaining the order of first occurrences. >>> remove_duplicates([1, 2, 3]) [1, 2, 3] >>> remove_duplicates([1, 2, 3, 2, 4]) [1, 2, 3, 4] >>> remove_duplicates([1, 1, 1, 2, 3, 3, 2, 4, 5, 5, 6]) [1, 2, 3, 4, 5, 6] >>> remove_duplicates([5, 5, 5, 5, 5, 5]) [5] >>> remove_duplicates([]) [] >>> remove_duplicates([-1, -2, -2, -3, -1]) [-1, -2, -3] >>> remove_duplicates([1, -2, 2, -2, 3, 1]) [1, -2, 2, 3]","solution":"def remove_duplicates(lst): Returns a new list with duplicate values removed, retaining the order of first occurrences. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def longest_subseq_with_diff_k(n: int, k: int, array: List[int]) -> int: Returns the length of the longest subsequence which is strictly increasing and where the difference between the consecutive elements is exactly k. >>> longest_subseq_with_diff_k(6, 2, [1, 3, 2, 5, 4, 6]) 3 >>> longest_subseq_with_diff_k(5, 1, [4, 5, 6, 7, 8]) 5 pass def process_test_cases(t: int, test_cases: List[Dict[str, Any]]) -> List[int]: Processes multiple test cases and returns the results. >>> t = 2 >>> test_cases = [ ... {'n': 6, 'k': 2, 'array': [1, 3, 2, 5, 4, 6]}, ... {'n': 5, 'k': 1, 'array': [4, 5, 6, 7, 8]} ... ] >>> process_test_cases(t, test_cases) [3, 5] pass from typing import List, Dict, Any def test_longest_subseq_with_diff_k_case_1(): assert longest_subseq_with_diff_k(6, 2, [1, 3, 2, 5, 4, 6]) == 3 def test_longest_subseq_with_diff_k_case_2(): assert longest_subseq_with_diff_k(5, 1, [4, 5, 6, 7, 8]) == 5 def test_longest_subseq_with_diff_k_no_valid_subseq(): assert longest_subseq_with_diff_k(5, 2, [1, 1, 1, 1, 1]) == 1 def test_longest_subseq_with_diff_k_single_element(): assert longest_subseq_with_diff_k(1, 1, [1]) == 1 def test_longest_subseq_with_diff_k_large_elements(): assert longest_subseq_with_diff_k(4, 1000, [1000, 2000, 3000, 4000]) == 4 def test_process_test_cases(): t = 2 test_cases = [ {'n': 6, 'k': 2, 'array': [1, 3, 2, 5, 4, 6]}, {'n': 5, 'k': 1, 'array': [4, 5, 6, 7, 8]} ] assert process_test_cases(t, test_cases) == [3, 5]","solution":"def longest_subseq_with_diff_k(n, k, array): Returns the length of the longest subsequence which is strictly increasing and where the difference between the consecutive elements is exactly k. longest = [1] * n elem_index = {array[0]: 0} for i in range(1, n): if array[i] - k in elem_index: longest[i] = longest[elem_index[array[i] - k]] + 1 elem_index[array[i]] = i return max(longest) def process_test_cases(t, test_cases): results = [] for case in test_cases: n, k, array = case['n'], case['k'], case['array'] results.append(longest_subseq_with_diff_k(n, k, array)) return results"},{"question":"def is_palindrome(s: str) -> bool: Checks if a string is a palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\" \\") == True >>> is_palindrome(\\"0P\\") == False","solution":"def is_palindrome(s): Checks if a string is a palindrome, considering only alphanumeric characters and ignoring cases. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"class GraphComponents: def __init__(self, N): Initialize the graph components with N vertices. def find(self, a): Find the root of vertex a. def union(self, a, b): Union the sets containing vertices a and b. def get_component_sizes(self): Get the sizes of all components. def process_operations(self, operations): Process a series of operations on the graph. >>> N = 5 >>> operations = [ ... ['1', '1', '2'], ... ['1', '2', '3'], ... ['2'], ... ['1', '4', '5'], ... ['2'], ... ['1', '1', '3'], ... ['2'] ... ] >>> graph = GraphComponents(N) >>> results = graph.process_operations(operations) >>> results[0] (3, [1, 1, 3]) >>> results[1] (2, [2, 3]) >>> results[2] (2, [2, 3])","solution":"class GraphComponents: def __init__(self, N): self.N = N self.parent = list(range(N + 1)) self.size = [1] * (N + 1) self.components = N def find(self, a): if self.parent[a] != a: self.parent[a] = self.find(self.parent[a]) return self.parent[a] def union(self, a, b): rootA = self.find(a) rootB = self.find(b) if rootA != rootB: if self.size[rootA] < self.size[rootB]: rootA, rootB = rootB, rootA self.parent[rootB] = rootA self.size[rootA] += self.size[rootB] self.components -= 1 def get_component_sizes(self): component_sizes = {} for i in range(1, self.N + 1): root = self.find(i) if root not in component_sizes: component_sizes[root] = 0 component_sizes[root] += 1 return sorted(component_sizes.values()) def process_operations(self, operations): results = [] for operation in operations: if operation[0] == '1': self.union(int(operation[1]), int(operation[2])) elif operation[0] == '2': component_sizes = self.get_component_sizes() results.append((self.components, component_sizes)) return results"},{"question":"def generate_bracket_combinations(n): Generates all valid combinations of n pairs of parentheses. Args: n (int): The number of pairs of parentheses. Returns: list: A list of strings, where each string is a valid combination of n pairs of parentheses. Examples: >>> generate_bracket_combinations(1) [\\"()\\"] >>> generate_bracket_combinations(2) [\\"(())\\", \\"()()\\"] >>> generate_bracket_combinations(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] # Your code here from solution import generate_bracket_combinations def test_generate_bracket_combinations_1(): assert generate_bracket_combinations(1) == [\\"()\\"] def test_generate_bracket_combinations_2(): expected_output = [\\"(())\\", \\"()()\\"] assert sorted(generate_bracket_combinations(2)) == sorted(expected_output) def test_generate_bracket_combinations_3(): expected_output = [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] assert sorted(generate_bracket_combinations(3)) == sorted(expected_output) def test_generate_bracket_combinations_4(): expected_output = [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"] assert sorted(generate_bracket_combinations(4)) == sorted(expected_output) def test_generate_bracket_combinations_5(): # This is a simple size test for n=5, without checking all the detailed combinations manually. output = generate_bracket_combinations(5) assert len(output) == 42 # There are 42 valid combinations for n=5","solution":"def generate_bracket_combinations(n): Generates all valid combinations of n pairs of parentheses. Args: n (int): The number of pairs of parentheses. Returns: list: A list of strings, where each string is a valid combination of n pairs of parentheses. result = [] def backtrack(s, open_count, close_count): if len(s) == 2 * n: result.append(s) return if open_count < n: backtrack(s + '(', open_count + 1, close_count) if close_count < open_count: backtrack(s + ')', open_count, close_count + 1) backtrack(\\"\\", 0, 0) return result"},{"question":"def palindromic_substrings(s: str) -> List[str]: Returns all unique palindromic substrings of the input string in lexicographical order. >>> palindromic_substrings(\\"aabaa\\") [\\"a\\", \\"aa\\", \\"aabaa\\", \\"aba\\", \\"b\\"] >>> palindromic_substrings(\\"abccb\\") [\\"a\\", \\"b\\", \\"bccb\\", \\"c\\", \\"cc\\"]","solution":"def is_palindrome(s): Checks if a given string is a palindrome. return s == s[::-1] def palindromic_substrings(s): Returns all unique palindromic substrings of the input string in lexicographical order. palindromes = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring = s[i:j] if is_palindrome(substring): palindromes.add(substring) return sorted(palindromes)"},{"question":"def is_path(grid): Determine if there is a path from the top-left corner to the bottom-right corner of a grid. :param grid: 2D list of integers (0s and 1s) representing the grid :return: True if there is a path from the start to the end, otherwise False >>> grid1 = [ ... [1, 0, 0, 0], ... [1, 1, 0, 1], ... [0, 1, 1, 0], ... [0, 0, 1, 1] ... ] >>> is_path(grid1) True >>> grid2 = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> is_path(grid2) False >>> grid3 = [ ... [1] ... ] >>> is_path(grid3) True >>> grid4 = [ ... [0] ... ] >>> is_path(grid4) False >>> grid5 = [ ... [1, 1, 0, 0, 0], ... [0, 1, 0, 1, 1], ... [0, 1, 1, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 1] ... ] >>> is_path(grid5) True >>> grid6 = [ ... [0, 1], ... [1, 1] ... ] >>> is_path(grid6) False >>> grid7 = [ ... [1, 1], ... [1, 0] ... ] >>> is_path(grid7) False","solution":"def is_path(grid): Determines if there is a path from the top-left corner to the bottom-right corner of a grid. :param grid: 2D list of integers (0s and 1s) representing the grid :return: True if there is a path from the start to the end, otherwise False if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return False rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r == rows - 1 and c == cols - 1: return True visited[r][c] = True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 1: if dfs(nr, nc): return True return False return dfs(0, 0)"},{"question":"from typing import List def maxSubArraySum(arr: List[int]) -> int: Returns the maximum sum of a contiguous subarray within a one-dimensional array of numbers. >>> maxSubArraySum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> maxSubArraySum([1]) 1 >>> maxSubArraySum([5,4,-1,7,8]) 23","solution":"from typing import List def maxSubArraySum(arr: List[int]) -> int: Returns the maximum sum of a contiguous subarray. max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def single_number(nums): Given an array of integers where every element appears twice except for one, this function finds that single one using an algorithm with a linear runtime complexity. Args: nums (list of int): a list of integers Returns: int: the single number that appears only once Examples: >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1]) 1","solution":"def single_number(nums): Given an array of integers where every element appears twice except for one, this function finds that single one using XOR operation for linear runtime complexity. Args: nums (list of int): a list of integers Returns: int: the single number that appears only once unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def kth_smallest_element(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array. If k is out of bounds, returns -1. >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 0) -1 >>> kth_smallest_element([5], 1) 5 >>> kth_smallest_element([-1, -2, -3, -4, -5], 3) -3 >>> kth_smallest_element([1, 2, 2, 3, 3, 3, 4], 5) 3 >>> kth_smallest_element([1, 1, 1, 1, 1], 3) 1","solution":"def kth_smallest_element(arr, k): Returns the k-th smallest element in the array. If k is out of bounds, returns -1. if k < 1 or k > len(arr): return -1 arr.sort() return arr[k - 1]"},{"question":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. Keys in the flattened dictionary are the concatenation of keys in the nested dictionary, separated by a separator. Parameters: d (dict): The nested dictionary to flatten. parent_key (str): The base key for the current level of nesting. sep (str): The separator to use between keys. Returns: dict: The flattened dictionary. >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": 12, \\"d\\": \\"Hello World\\"}}, \\"x\\": 42}) {\\"a.b.c\\": 12, \\"a.b.d\\": \\"Hello World\\", \\"x\\": 42} >>> flatten_dict({\\"a\\": 1, \\"b\\": 2}) {\\"a\\": 1, \\"b\\": 2}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. Keys in the flattened dictionary are the concatenation of keys in the nested dictionary, separated by a separator. Parameters: d (dict): The nested dictionary to flatten. parent_key (str): The base key for the current level of nesting. sep (str): The separator to use between keys. Returns: dict: The flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def print_staircase(n: int): Prints a right-aligned staircase of height n using the '#' character. >>> print_staircase(1) # >>> print_staircase(2) # >>> print_staircase(3) # # >>> print_staircase(4) # # >>> print_staircase(5) # # #","solution":"def print_staircase(n): Prints a right-aligned staircase of height n using the '#' character. for i in range(1, n + 1): print(' ' * (n - i) + '#' * i)"},{"question":"def simple_calculator(operand1, operator, operand2): Performs basic arithmetic operations between two integers. Parameters: operand1 (int): The first operand. operator (str): The operation to be performed. It can be '+', '-', '*', '/'. operand2 (int): The second operand. Returns: int/str: The result of the operation, or an error message in case of division by zero. Example: >>> simple_calculator(10, '+', 5) 15 >>> simple_calculator(10, '-', 5) 5 >>> simple_calculator(10, '*', 5) 50 >>> simple_calculator(10, '/', 5) 2 >>> simple_calculator(10, '/', 0) \\"Error: Division by zero\\"","solution":"def simple_calculator(operand1, operator, operand2): Performs basic arithmetic operations between two integers. Parameters: operand1 (int): The first operand. operator (str): The operation to be performed. It can be '+', '-', '*', '/'. operand2 (int): The second operand. Returns: int/str: The result of the operation, or an error message in case of division by zero. if operator == '+': return operand1 + operand2 elif operator == '-': return operand1 - operand2 elif operator == '*': return operand1 * operand2 elif operator == '/': if operand2 == 0: return \\"Error: Division by zero\\" return operand1 // operand2 else: return \\"Error: Invalid operator\\""},{"question":"def shortest_word_length(s: str) -> int: Given a string containing a list of space-separated words, return the length of the shortest word(s). Examples: >>> shortest_word_length(\\"Word lengths are fun to calculate\\") 2 >>> shortest_word_length(\\"I love programming challenges!\\") 1 >>> shortest_word_length(\\"Shortest word length\\") 4 pass","solution":"def shortest_word_length(s): Returns the length of the shortest word in the string s. words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def can_elphins_hit_each_other(n: int, elphins: List[Tuple[int, int]]) -> str: Determine if any pair of Elphins can cast spells and hit each other simultaneously. Parameters: n (int): Number of Elphins. elphins (List[Tuple[int, int]]): List of tuples, each containing the position (p) and spell range (r) of each Elphin. Returns: str: \\"TRUE\\" if any pair of Elphins can hit each other, otherwise \\"FALSE\\". >>> can_elphins_hit_each_other(3, [(2, 3), (5, -3), (6, 4)]) \\"TRUE\\" >>> can_elphins_hit_each_other(3, [(2, 2), (5, -3), (6, 4)]) \\"FALSE\\" >>> can_elphins_hit_each_other(1, [(2, 3)]) \\"FALSE\\" >>> can_elphins_hit_each_other(2, [(2, 5), (7, -5)]) \\"TRUE\\" >>> can_elphins_hit_each_other(3, [(-10000, 20000), (10000, -20000), (0, 10000)]) \\"TRUE\\" >>> can_elphins_hit_each_other(2, [(-10000, 10000), (10000, -10000)]) \\"FALSE\\" # Implementation goes here","solution":"def can_elphins_hit_each_other(n, elphins): Determine if any pair of Elphins can cast spells and hit each other simultaneously. Parameters: n (int): Number of Elphins. elphins (List[Tuple[int, int]]): List of tuples, each containing the position (p) and spell range (r) of each Elphin. Returns: str: \\"TRUE\\" if any pair of Elphins can hit each other, otherwise \\"FALSE\\". spell_ranges = {} for position, range in elphins: # Calculate the target positions each Elphin can hit target_position = position + range # Check if there's an Elphin that can hit 'position' from 'target_position' if target_position in spell_ranges and spell_ranges[target_position] == position: return \\"TRUE\\" # Store the target positions and their corresponding Elphin positions spell_ranges[position] = target_position return \\"FALSE\\""},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome, ignoring case and non-alphanumeric characters. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"level\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True pass","solution":"def is_palindrome(s): Returns True if the given string s is a palindrome, ignoring case and non-alphanumeric characters. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List from datetime import datetime def sort_timestamps(timestamps: List[str]) -> List[str]: Sorts an array of timestamps in chronological order. Returns an error message if the format of any timestamp is invalid. >>> sort_timestamps([\\"2022-01-02 12:30:45\\", \\"2021-12-31 23:59:59\\", \\"2022-01-01 00:00:00\\"]) [\\"2021-12-31 23:59:59\\", \\"2022-01-01 00:00:00\\", \\"2022-01-02 12:30:45\\"] >>> sort_timestamps([]) [] >>> sort_timestamps([\\"2022-01-02 12:30:45\\", \\"20221231 23:59:59\\"]) \\"Invalid input format\\" >>> sort_timestamps([\\"2022-01-02 12:30:45\\", \\"2022-01-02 12:30:45\\", \\"2022-01-02 12:30:45\\"]) [\\"2022-01-02 12:30:45\\", \\"2022-01-02 12:30:45\\", \\"2022-01-02 12:30:45\\"]","solution":"from datetime import datetime def sort_timestamps(timestamps): Sorts an array of timestamps in chronological order. Returns an error message if the format of any timestamp is invalid. try: # Check for valid format and convert to datetime objects datetime_objects = [ datetime.strptime(ts, \\"%Y-%m-%d %H:%M:%S\\") for ts in timestamps ] except ValueError: # Raised when format is violated return \\"Invalid input format\\" # Sort datetime objects and convert back to string format sorted_timestamps = sorted(datetime_objects) return [dt.strftime(\\"%Y-%m-%d %H:%M:%S\\") for dt in sorted_timestamps]"},{"question":"def path_exists(edges, start, end): Determines if there is a path between the start and end nodes in an undirected graph. Parameters: edges (List[List[int]]): A list of edges where each edge is represented as [u, v]. start (int): The starting node. end (int): The target node. Returns: bool: True if a path exists, False otherwise. # Your implementation here from solution import path_exists def test_path_exists_simple_path(): assert path_exists([[0, 1], [1, 2], [2, 3]], 0, 3) == True def test_path_exists_no_path(): assert path_exists([[0, 1], [2, 3]], 0, 3) == False def test_path_exists_direct_connection(): assert path_exists([[0, 1], [1, 2], [2, 3]], 1, 2) == True def test_path_exists_self_loop(): assert path_exists([[0, 1], [1, 2], [2, 3]], 2, 2) == True def test_path_exists_disconnected_graph(): assert path_exists([[0, 1], [2, 3], [4, 5]], 0, 5) == False def test_path_exists_single_node_same_start_end(): assert path_exists([], 0, 0) == True def test_path_exists_large_graph(): edges = [[i, i+1] for i in range(1000)] assert path_exists(edges, 0, 999) == True def test_path_exists_single_edge(): assert path_exists([[0, 1]], 0, 1) == True","solution":"def path_exists(edges, start, end): Determines if there is a path between the start and end nodes in an undirected graph. Parameters: edges (List[List[int]]): A list of edges where each edge is represented as [u, v]. start (int): The starting node. end (int): The target node. Returns: bool: True if a path exists, False otherwise. from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Use BFS to determine if there is a path queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"def count_pairs_and_unique_a(P, Q): Count the number of unique pairs (a, b) for given values of P and Q, and the number of distinct values of a. >>> count_pairs_and_unique_a(2, 5) (0, 0) >>> count_pairs_and_unique_a(1, 1) (0, 0) pass def process_test_cases(T, test_cases): Process multiple test cases to find the number of unique pairs and distinct a values for each case. >>> process_test_cases(1, [(2, 5)]) [(0, 0)] >>> process_test_cases(2, [(2, 5), (1, 1)]) [(0, 0), (0, 0)] pass # Unit tests def test_small_input(): assert count_pairs_and_unique_a(2, 5) == (0, 0) def test_single_case(): T = 1 test_cases = [(2, 5)] assert process_test_cases(T, test_cases) == [(0, 0)] def test_multiple_small_cases(): T = 2 test_cases = [(2, 5), (1, 1)] assert process_test_cases(T, test_cases) == [(0, 0), (0, 0)] def test_edge_case_minimum(): assert count_pairs_and_unique_a(1, 1) == (0, 0) def test_no_valid_pairs(): assert count_pairs_and_unique_a(10, 10) == (0, 0) def test_large_Q_small_P(): assert count_pairs_and_unique_a(1, 1000) == (0, 0) def test_large_P_small_Q(): assert count_pairs_and_unique_a(1000, 1) == (0, 0)","solution":"def count_pairs_and_unique_a(P, Q): unique_pairs = 0 unique_a_values = set() for a in range(1, P + 1): for b in range(1, Q + 1): if a**2 + b**3 == (a ^ b): unique_pairs += 1 unique_a_values.add(a) return unique_pairs, len(unique_a_values) def process_test_cases(T, test_cases): results = [] for i in range(T): P, Q = test_cases[i] result = count_pairs_and_unique_a(P, Q) results.append(result) return results"},{"question":"from typing import List def distinct_islands(grid: List[List[int]]) -> int: Determine the number of distinct islands in the given 2D grid. An island is a group of adjacent 1s (representing land) connected horizontally or vertically. Two islands are distinct if one cannot be translated to exactly match the other. >>> distinct_islands([[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 1], [0, 1, 0, 1]]) 3 >>> distinct_islands([[1, 1, 0, 0], [1, 0, 1, 1], [0, 1, 1, 1], [0, 0, 0, 1]]) 2","solution":"from typing import List def distinct_islands(grid: List[List[int]]) -> int: def dfs(r, c, origin, shape): stack = [(r, c)] visited.add((r, c)) shape.append((r - origin[0], c - origin[1])) while stack: cr, cc = stack.pop() for dr, dc in directions: nr, nc = cr + dr, cc + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 1: visited.add((nr, nc)) shape.append((nr - origin[0], nc - origin[1])) stack.append((nr, nc)) m, n = len(grid), len(grid[0]) visited = set() unique_islands = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r in range(m): for c in range(n): if grid[r][c] == 1 and (r, c) not in visited: shape = [] dfs(r, c, (r, c), shape) unique_islands.add(tuple(shape)) return len(unique_islands)"},{"question":"def max_candies(candies): Given a list of candies represented by integers, returns the maximum number of different types of candies one person can get by distributing them equally. >>> max_candies([1,1,2,2,3,3]) 3 >>> max_candies([1,1,2,3]) 2 >>> max_candies([6,6,6,6]) 1 def test_max_candies_example_1(): assert max_candies([1,1,2,2,3,3]) == 3 def test_max_candies_example_2(): assert max_candies([1,1,2,3]) == 2 def test_max_candies_example_3(): assert max_candies([6,6,6,6]) == 1 def test_max_candies_all_unique(): assert max_candies([1,2,3,4,5,6]) == 3 def test_max_candies_some_repeats(): assert max_candies([1,1,2,2,3,4]) == 3 def test_max_candies_only_twotypes(): assert max_candies([1,1,1,1,2,2,2,2]) == 2 def test_max_candies_large_input(): assert max_candies(list(range(1, 10001)) * 2) == 10000","solution":"def max_candies(candies): Given a list of candies represented by integers, returns the maximum number of different types of candies one person can get by distributing them equally. unique_candies = set(candies) max_types_per_person = len(candies) // 2 return min(len(unique_candies), max_types_per_person)"},{"question":"def top_scorers(scores: dict) -> list: Returns the names of the student(s) with the highest score, sorted in alphabetical order. Args: scores (dict): Dictionary with student names as keys and their scores as values. Returns: list: List of names with the highest score in alphabetical order. >>> top_scorers({\\"Alice\\": 91}) [\\"Alice\\"] >>> top_scorers({\\"Alice\\": 91, \\"Bob\\": 91, \\"Charlie\\": 91}) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> top_scorers({\\"Alice\\": 91, \\"Bob\\": 86, \\"Charlie\\": 75}) [\\"Alice\\"] >>> top_scorers({\\"Alice\\": 91, \\"Bob\\": 91, \\"Charlie\\": 86}) [\\"Alice\\", \\"Bob\\"] >>> top_scorers({\\"Bob\\": 85, \\"Charlie\\": 92, \\"David\\": 85}) [\\"Charlie\\"] >>> top_scorers({\\"Charlie\\": 92, \\"Bob\\": 85, \\"David\\": 92}) [\\"Charlie\\", \\"David\\"] >>> top_scorers({}) [] >>> top_scorers({\\"Alice\\": 0, \\"Bob\\": 0, \\"Charlie\\": 0}) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> top_scorers({\\"Alice\\": 50, \\"Bob\\": 75, \\"Charlie\\": 50, \\"David\\": 75}) [\\"Bob\\", \\"David\\"]","solution":"def top_scorers(scores): Returns the names of the student(s) with the highest score, sorted in alphabetical order. Args: scores (dict): Dictionary with student names as keys and their scores as values. Returns: list: List of names with the highest score in alphabetical order. if not scores: return [] max_score = max(scores.values()) top_scorers = [student for student, score in scores.items() if score == max_score] return sorted(top_scorers)"},{"question":"import random def custom_dice_roll(die1_probs, die2_probs): Simulates the roll of a pair of dice with specified probability distributions. Parameters: die1_probs (list): Probabilities for each side of dice 1. die2_probs (list): Probabilities for each side of dice 2. Returns: int: Sum of numbers rolled on the two dice. Raises: ValueError: If the sum of probabilities is not equal to 1.0 for both dice. Example: >>> custom_dice_roll([0.1, 0.2, 0.3, 0.1, 0.2, 0.1], [0.2, 0.2, 0.2, 0.1, 0.1, 0.2]) 7 >>> custom_dice_roll([0.2, 0.2, 0.2, 0.2, 0.1, 0.1], [0.1, 0.2, 0.1, 0.2, 0.3, 0.1]) 5","solution":"import random def custom_dice_roll(die1_probs, die2_probs): Simulates the roll of a pair of dice with specified probability distributions. Parameters: die1_probs (list): Probabilities for each side of dice 1. die2_probs (list): Probabilities for each side of dice 2. Returns: int: Sum of numbers rolled on the two dice. Raises: ValueError: If the sum of probabilities is not equal to 1.0 for both dice. if len(die1_probs) != 6 or len(die2_probs) != 6: raise ValueError(\\"Probability lists must contain 6 elements.\\") if not (abs(sum(die1_probs) - 1.0) < 1e-6 and abs(sum(die2_probs) - 1.0) < 1e-6): raise ValueError(\\"The probabilities must sum to 1.0\\") sides = [1, 2, 3, 4, 5, 6] roll1 = random.choices(sides, die1_probs)[0] roll2 = random.choices(sides, die2_probs)[0] return roll1 + roll2"},{"question":"def binary_pattern(n: int) -> str: Generates a binary pattern up to a specified number of rows. Parameters: n (int): Number of rows of the binary pattern. Returns: str: The binary pattern as a single string, including line breaks. >>> binary_pattern(8) '01010101n0101010n010101n01010n0101n010n01n0' >>> binary_pattern(3) '010n01n0' >>> binary_pattern(0) '' >>> binary_pattern(1) '0' >>> binary_pattern(-1) ''","solution":"def binary_pattern(n): Generates a binary pattern up to a specified number of rows. Parameters: n (int): Number of rows of the binary pattern. Returns: str: The binary pattern as a single string, including line breaks. if n < 1: return \\"\\" pattern = [] base_pattern = \\"01\\" * ((n + 1) // 2) for i in range(n): row_pattern = base_pattern[:n - i] pattern.append(row_pattern) return \\"n\\".join(pattern)"},{"question":"def uniquePaths(grid: List[List[int]]) -> int: Find the number of unique paths from the top-left to the bottom-right corner in a grid. >>> uniquePaths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> uniquePaths([[0, 1], [0, 0]]) 1 >>> uniquePaths([[0, 0, 1], [0, 0, 0], [1, 0, 0]]) 2","solution":"def uniquePaths(grid): def is_in_bounds(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def dfs(x, y): if not is_in_bounds(x, y) or grid[x][y] == 1: return 0 if (x, y) == (len(grid) - 1, len(grid[0]) - 1): return 1 if (x, y) in memo: return memo[(x, y)] grid[x][y] = 1 paths = dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) grid[x][y] = 0 memo[(x, y)] = paths return paths if grid[0][0] == 1 or grid[-1][-1] == 1: return 0 memo = {} return dfs(0, 0)"},{"question":"def validate_parentheses(s: str) -> bool: Validate if a given string containing only parentheses is valid. A string is considered valid if: 1. Every opening parenthesis has a corresponding closing parenthesis. 2. Parentheses are properly nested. :param s: String containing only parentheses. :return: True if the string is valid, otherwise False. # Implement this function pass def test_validate_parentheses(): assert validate_parentheses(\\"()\\") == True assert validate_parentheses(\\"()()\\") == True assert validate_parentheses(\\"(()())\\") == True assert validate_parentheses(\\"(()\\") == False assert validate_parentheses(\\"())\\") == False assert validate_parentheses(\\"(()))(()\\") == False assert validate_parentheses(\\"\\") == True assert validate_parentheses(\\"((()))\\") == True assert validate_parentheses(\\"((())\\") == False assert validate_parentheses(\\"(()(()))\\") == True assert validate_parentheses(\\")(\\") == False","solution":"def validate_parentheses(s: str) -> bool: Validate if a given string containing only parentheses is valid. A string is considered valid if: 1. Every opening parenthesis has a corresponding closing parenthesis. 2. Parentheses are properly nested. :param s: String containing only parentheses. :return: True if the string is valid, otherwise False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def count_inversions(lst: List[int]) -> int: Given a list of integers, returns the number of inversions in the list. An inversion is a pair of elements where the first element is greater than the second one and the first element appears before the second one in the list. >>> count_inversions([1, 2, 3, 4, 5]) == 0 >>> count_inversions([2, 1, 3, 4, 5]) == 1 >>> count_inversions([2, 4, 1, 3, 5]) == 3 >>> count_inversions([5, 4, 3, 2, 1]) == 10 >>> count_inversions([3, 1, 2, 5, 4]) == 3 >>> count_inversions([]) == 0 >>> count_inversions([1]) == 0 >>> count_inversions([1, 3, 2, 4, 5]) == 1","solution":"def count_inversions(lst): Returns the number of inversions in the list. An inversion is a pair of elements where the first element is greater than the second one and the first element appears before the second one in the list. inversions = 0 n = len(lst) for i in range(n): for j in range(i + 1, n): if lst[i] > lst[j]: inversions += 1 return inversions"},{"question":"def reverse_string(s: str) -> str: Returns the reversed version of the input string s. >>> reverse_string(\\"hello\\") 'olleh' >>> reverse_string(\\"OpenAI\\") 'IAnepO' >>> reverse_string(\\"\\") '' >>> reverse_string(\\"a\\") 'a' >>> reverse_string(\\"Z\\") 'Z' >>> reverse_string(\\"a man a plan a canal panama\\") 'amanap lanac a nalp a nam a' >>> reverse_string(\\" \\") ' ' >>> reverse_string(\\"123!@#\\") '#@!321' >>> reverse_string(\\"😊👍\\") '👍😊' def test_reverse_non_empty_string(): assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"OpenAI\\") == \\"IAnepO\\" def test_reverse_empty_string(): assert reverse_string(\\"\\") == \\"\\" def test_reverse_single_character(): assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"Z\\") == \\"Z\\" def test_reverse_string_with_spaces(): assert reverse_string(\\"a man a plan a canal panama\\") == \\"amanap lanac a nalp a nam a\\" assert reverse_string(\\" \\") == \\" \\" def test_reverse_string_with_special_characters(): assert reverse_string(\\"123!@#\\") == \\"#@!321\\" assert reverse_string(\\"😊👍\\") == \\"👍😊\\"","solution":"def reverse_string(s): Returns the reversed version of the input string s. return s[::-1]"},{"question":"from typing import List, Tuple def find_maximum_spanning_tree(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: You are given an undirected graph with \`n\` nodes and \`m\` edges. Each edge has a weight associated with it. The graph has no self-loops and no multiple edges between any pair of nodes. Your task is to find a subset of edges that forms a tree with the maximum possible sum of weights while still ensuring that the tree is spanning (includes all \`n\` nodes). In other words, you want to find a spanning tree with the maximum sum of edge weights. If it is possible to construct a spanning tree, return the maximum possible sum of edge weights in the spanning tree. If it is not possible to construct a spanning tree, return \`-1\`. Parameters: - n: an integer representing the number of nodes. - m: an integer representing the number of edges. - edges: a list of tuples where each tuple contains three integers \`u\`, \`v\`, and \`w\`, representing an edge between nodes \`u\` and \`v\` with weight \`w\`. Returns: - The maximum possible sum of edge weights in the spanning tree if it is possible to construct a spanning tree, otherwise, return \`-1\`. Example: >>> find_maximum_spanning_tree(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 6), (1, 3, 2)]) 15 >>> find_maximum_spanning_tree(2, 1, [(1, 2, 10)]) 10 >>> find_maximum_spanning_tree(4, 2, [(1, 2, 3), (3, 4, 4)]) -1 >>> find_maximum_spanning_tree(3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 1)]) 10 >>> find_maximum_spanning_tree(4, 3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) 12","solution":"def find_maximum_spanning_tree(n, m, edges): # Using Kruskal's algorithm to find the maximum spanning tree def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sort edges in descending order of their weights edges.sort(key=lambda x: x[2], reverse=True) parent = list(range(n)) rank = [0] * n maximum_spanning_tree_weight = 0 selected_edges = 0 for u, v, w in edges: u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) maximum_spanning_tree_weight += w selected_edges += 1 if selected_edges == n - 1: break if selected_edges != n - 1: return -1 return maximum_spanning_tree_weight"},{"question":"def summarize_user_activities(activities): Summarizes the total duration of activities for each hour of the day. Parameters: activities (list of tuples): A list of tuples where each tuple contains two integers, the start hour and the duration in minutes. Returns: list: A list of 24 integers where each element represents the total duration of activities for that hour. >>> summarize_user_activities([(1, 30), (2, 45), (1, 20), (2, 15), (1, 10)]) [0, 60, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> summarize_user_activities([(10, 50)]) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] pass # Test cases from solution import summarize_user_activities def test_no_activities(): assert summarize_user_activities([]) == [0] * 24 def test_single_activity(): assert summarize_user_activities([(10, 50)]) == [0] * 10 + [50] + [0] * 13 def test_multiple_activities_same_hour(): assert summarize_user_activities([(1, 30), (1, 20), (1, 10)]) == [0, 60] + [0] * 22 def test_multiple_activities_different_hours(): assert summarize_user_activities([(0, 5), (1, 30), (2, 45), (1, 20), (2, 15), (1, 10)]) == [5, 60, 60] + [0] * 21 def test_all_hours_have_activities(): activities = [(i, 10) for i in range(24)] assert summarize_user_activities(activities) == [10] * 24 def test_mixed_durations(): activities = [(0, 60), (10, 25), (10, 30), (23, 15), (23, 40)] expected = [60] + [0]*9 + [55] + [0]*12 + [55] assert summarize_user_activities(activities) == expected","solution":"def summarize_user_activities(activities): Summarizes the total duration of activities for each hour of the day. Parameters: activities (list of tuples): A list of tuples where each tuple contains two integers, the start hour and the duration in minutes. Returns: list: A list of 24 integers where each element represents the total duration of activities for that hour. hourly_durations = [0] * 24 for hour, duration in activities: hourly_durations[hour] += duration return hourly_durations"},{"question":"def count_palindromic_numbers(nums: List[int]) -> int: Returns the count of elements that are palindromic in a given list of integers. A palindromic number is a number that reads the same backward as forward. >>> count_palindromic_numbers([121, 131, 123, 22]) 3 >>> count_palindromic_numbers([345, 901, 484, 1771]) 2 >>> count_palindromic_numbers([0]) 1 pass from typing import List def test_all_palindromes(): assert count_palindromic_numbers([121, 131, 22]) == 3 def test_no_palindromes(): assert count_palindromic_numbers([123, 456, 789]) == 0 def test_mixed_palindromes(): assert count_palindromic_numbers([121, 131, 123, 22]) == 3 assert count_palindromic_numbers([345, 901, 484, 1771]) == 2 def test_single_element(): assert count_palindromic_numbers([121]) == 1 assert count_palindromic_numbers([123]) == 0 def test_empty_list(): assert count_palindromic_numbers([]) == 0 def test_large_numbers(): assert count_palindromic_numbers([1000001, 12321, 98789, 11211]) == 4 assert count_palindromic_numbers([1000001, 123456, 987654]) == 1","solution":"def count_palindromic_numbers(nums): Returns the count of palindromic numbers in the given list. A palindromic number is a number that reads the same backward as forward. def is_palindrome(n): s = str(n) return s == s[::-1] return sum(1 for num in nums if is_palindrome(num))"},{"question":"def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merge two sorted arrays into a single sorted array. Parameters: arr1 (list of int): first sorted array arr2 (list of int): second sorted array Returns: list of int: merged sorted array Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0, 2, 4], [1, 3, 5]) [0, 1, 2, 3, 4, 5] >>> merge_sorted_arrays([10, 20, 30], [5, 15, 25]) [5, 10, 15, 20, 25, 30] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([4, 6, 8], []) [4, 6, 8] from typing import List def test_merge_sorted_arrays_basic_cases(): assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_arrays([0, 2, 4], [1, 3, 5]) == [0, 1, 2, 3, 4, 5] assert merge_sorted_arrays([10, 20, 30], [5, 15, 25]) == [5, 10, 15, 20, 25, 30] def test_merge_sorted_arrays_edge_cases(): assert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_arrays([4, 6, 8], []) == [4, 6, 8] def test_merge_sorted_arrays_identical_elements(): assert merge_sorted_arrays([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 1, 1, 1] def test_merge_sorted_arrays_negatives_and_positives(): assert merge_sorted_arrays([-3, -2, -1], [-5, 0, 4, 7]) == [-5, -3, -2, -1, 0, 4, 7] assert merge_sorted_arrays([-10, -5, 0], [3, 8, 12]) == [-10, -5, 0, 3, 8, 12] def test_merge_sorted_arrays_large_numbers(): assert merge_sorted_arrays([1000, 2000, 3000], [400, 900, 1800]) == [400, 900, 1000, 1800, 2000, 3000]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Parameters: arr1 (list of int): first sorted array arr2 (list of int): second sorted array Returns: list of int: merged sorted array merged_array = [] i = 0 j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Collect the rest of the elements from arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Collect the rest of the elements from arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the vertical order traversal of its nodes as an array of arrays. Each sub-array represents the nodes at a specific horizontal distance from the root, ordered by level, then by left-to-right order. >>> root = TreeNode(1) >>> verticalOrderTraversal(root) [[1]] >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> verticalOrderTraversal(root) [[9], [3, 15], [20], [7]] >>> verticalOrderTraversal(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> verticalOrderTraversal(root) [[4], [2], [1, 5, 6], [3], [7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> verticalOrderTraversal(root) [[3], [2], [1]] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> verticalOrderTraversal(root) [[1], [2], [3]]","solution":"from collections import defaultdict, deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] node_map = defaultdict(list) queue = deque([(root, 0)]) while queue: node, hd = queue.popleft() node_map[hd].append(node.val) if node.left: queue.append((node.left, hd-1)) if node.right: queue.append((node.right, hd+1)) sorted_hd = sorted(node_map.keys()) return [node_map[hd] for hd in sorted_hd]"},{"question":"from typing import List def mergeArrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array in non-decreasing order. Parameters: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: A single merged and sorted array. Examples: >>> mergeArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeArrays([0, 10, 20], [5, 15, 25, 30]) [0, 5, 10, 15, 20, 25, 30] >>> mergeArrays([1], []) [1] >>> mergeArrays([], []) [] >>> mergeArrays([-3, -1, 2, 4], [-2, 0, 3]) [-3, -2, -1, 0, 2, 3, 4] >>> mergeArrays([1, 2, 2, 3], [2, 3, 3, 4]) [1, 2, 2, 2, 3, 3, 3, 4] pass def test_mergearrays_basic(): assert mergeArrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_mergearrays_with_gaps(): assert mergeArrays([0, 10, 20], [5, 15, 25, 30]) == [0, 5, 10, 15, 20, 25, 30] def test_mergearrays_one_empty(): assert mergeArrays([1], []) == [1] assert mergeArrays([], [1]) == [1] def test_mergearrays_both_empty(): assert mergeArrays([], []) == [] def test_mergearrays_with_negative_numbers(): assert mergeArrays([-3, -1, 2, 4], [-2, 0, 3]) == [-3, -2, -1, 0, 2, 3, 4] def test_mergearrays_duplicates(): assert mergeArrays([1, 2, 2, 3], [2, 3, 3, 4]) == [1, 2, 2, 2, 3, 3, 3, 4]","solution":"def mergeArrays(arr1, arr2): Merges two sorted arrays into a single sorted array in non-decreasing order. Parameters: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: A single merged and sorted array. merged = [] i, j = 0, 0 # Traverse both arrays and insert the smaller element from arr1 or arr2 into merged array while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Collect any remaining elements in arr1 while i < len(arr1): merged.append(arr1[i]) i += 1 # Collect any remaining elements in arr2 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def total_species(N: int) -> int: Given the number of species N in the previous year, returns the total number of species this year. >>> total_species(3) 6 >>> total_species(5) 15 >>> total_species(2) 3 >>> total_species(4) 10 >>> total_species(6) 21 def batch_total_species(test_cases: List[int]) -> List[int]: Given a list of test cases, returns the total number of species for each test case. >>> batch_total_species([2, 6, 3]) [3, 21, 6] >>> batch_total_species([1, 1, 1, 1]) [1, 1, 1, 1] >>> batch_total_species([]) [] from typing import List","solution":"def total_species(N): Given the number of species N in the previous year, returns the total number of species this year. return (N * (N + 1)) // 2 def batch_total_species(test_cases): Given a list of test cases, returns the total number of species for each test case. results = [] for N in test_cases: results.append(total_species(N)) return results"},{"question":"def custom_sort(arr): Function to sort the list such that all even numbers appear before all odd numbers, while preserving the relative order among the even and odd numbers. Parameters: arr (List[int]): A list of integers. Returns: List[int]: A list of integers sorted such that all even numbers appear before all odd numbers. Examples: >>> custom_sort([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> custom_sort([4, 1, 1, 2, 3, 5]) [4, 2, 1, 1, 3, 5] # Unit tests def test_custom_sort_all_even(): assert custom_sort([2, 4, 6, 8]) == [2, 4, 6, 8] def test_custom_sort_all_odd(): assert custom_sort([1, 3, 5, 7]) == [1, 3, 5, 7] def test_custom_sort_mixed(): assert custom_sort([1, 2, 3, 4, 5, 6]) == [2, 4, 6, 1, 3, 5] assert custom_sort([4, 1, 1, 2, 3, 5]) == [4, 2, 1, 1, 3, 5] def test_custom_sort_with_zero(): assert custom_sort([0, 1, 2, 3, 4, 5]) == [0, 2, 4, 1, 3, 5] def test_custom_sort_empty_list(): assert custom_sort([]) == [] def test_custom_sort_single_element(): assert custom_sort([1]) == [1] assert custom_sort([2]) == [2]","solution":"def custom_sort(arr): Function to sort the list such that all even numbers appear before all odd numbers, while preserving the relative order among the even and odd numbers. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def suggest_phrases(n: int, k: int, phrases: List[Tuple[str, int]], prefix: str) -> List[str]: Suggest the top k most popular search phrases that start with the given prefix. :param n: Number of search phrases :param k: Number of suggestions required :param phrases: List of tuples containing search phrases and their popularity :param prefix: The given prefix :return: List of suggested search phrases >>> suggest_phrases(5, 3, [(\\"apple\\", 100), (\\"appetizer\\", 200), (\\"application\\", 150), (\\"banana\\", 300), (\\"appliance\\", 250)], \\"app\\") [\\"appliance\\", \\"appetizer\\", \\"application\\"] >>> suggest_phrases(4, 2, [(\\"dog\\", 500), (\\"cat\\", 400), (\\"dogmatic\\", 600), (\\"catalog\\", 500)], \\"dog\\") [\\"dogmatic\\", \\"dog\\"] >>> suggest_phrases(3, 1, [(\\"test\\", 100), (\\"exam\\", 200), (\\"quiz\\", 300)], \\"ex\\") [\\"exam\\"] >>> suggest_phrases(4, 3, [(\\"interview\\", 500), (\\"internet\\", 400), (\\"interval\\", 300), (\\"internal\\", 600)], \\"in\\") [\\"internal\\", \\"interview\\", \\"internet\\"]","solution":"def suggest_phrases(n, k, phrases, prefix): Suggest the top k most popular search phrases that start with the given prefix. :param n: int - Number of search phrases :param k: int - Number of suggestions required :param phrases: List[Tuple[str, int]] - List of tuples containing search phrases and their popularity :param prefix: str - The given prefix :return: List[str] - List of suggested search phrases filtered_phrases = [phrase for phrase in phrases if phrase[0].startswith(prefix)] # Sort by popularity (descending) and lexicographically sorted_phrases = sorted(filtered_phrases, key=lambda x: (-x[1], x[0])) # Get top k phrases suggested_phrases = [phrase[0] for phrase in sorted_phrases[:k]] return suggested_phrases"},{"question":"def swapCase(s: str) -> str: Given a string s, return a new string in which the case of each letter is swapped, i.e., uppercase letters become lowercase and lowercase letters become uppercase. >>> swapCase(\\"Hello\\") 'hELLO' >>> swapCase(\\"WORLD\\") 'world' >>> swapCase(\\"CodeWars\\") 'cODEwARS' >>> swapCase(\\"a\\") 'A' >>> swapCase(\\"Z\\") 'z' >>> swapCase(\\"HeLLoWoRLd\\") 'hEllOwOrlD' from solution import swapCase def test_swapcase_all_lowercase(): assert swapCase(\\"hello\\") == \\"HELLO\\" def test_swapcase_all_uppercase(): assert swapCase(\\"WORLD\\") == \\"world\\" def test_swapcase_mixed_case(): assert swapCase(\\"CodeWars\\") == \\"cODEwARS\\" def test_swapcase_single_letter(): assert swapCase(\\"a\\") == \\"A\\" assert swapCase(\\"Z\\") == \\"z\\" def test_swapcase_alternating_case(): assert swapCase(\\"HeLLoWoRLd\\") == \\"hEllOwOrlD\\"","solution":"def swapCase(s): Returns a new string where the case of each letter in the input string s is swapped. return s.swapcase()"},{"question":"def maxProduct(nums: List[int]) -> int: Finds the maximum product of any two distinct elements in the list. >>> maxProduct([3,4,5,2]) 20 >>> maxProduct([1,5,4,5]) 25 >>> maxProduct([3,7]) 21","solution":"def maxProduct(nums): Finds the maximum product of any two distinct elements in the list. # Sort the list to find the two largest elements nums_sorted = sorted(nums, reverse=True) # Return the product of the two largest elements in the sorted list return nums_sorted[0] * nums_sorted[1]"},{"question":"from typing import List, Tuple def count_active_users(n: int, t: int, k: int, event_logs: List[Tuple[int, int]]) -> int: Determines the number of active users given the event logs. An active user is defined as having more than \`k\` events in any given period of \`t\` consecutive minutes. Args: n (int): The number of event logs. t (int): The period of consecutive minutes. k (int): The minimum number of events in the given period to be considered an active user. event_logs (List[Tuple[int, int]]): Each tuple contains a user ID and a timestamp of the event. Returns: int: The number of active users. Examples: >>> count_active_users(7, 10, 3, [(1, 5), (1, 15), (1, 25), (2, 30), (2, 60), (2, 90), (3, 10)]) 0 >>> count_active_users(5, 5, 2, [(1, 2), (1, 4), (1, 6), (2, 8), (2, 9)]) 1 pass def test_example1(): n = 7 t = 10 k = 3 event_logs = [ (1, 5), (1, 15), (1, 25), (2, 30), (2, 60), (2, 90), (3, 10) ] assert count_active_users(n, t, k, event_logs) == 0 def test_example2(): n = 5 t = 5 k = 2 event_logs = [ (1, 2), (1, 4), (1, 6), (2, 8), (2, 9) ] assert count_active_users(n, t, k, event_logs) == 1 def test_edge_case1(): n = 1 t = 1 k = 1 event_logs = [(1, 0)] assert count_active_users(n, t, k, event_logs) == 0 def test_multiple_active_users(): n = 10 t = 10 k = 2 event_logs = [ (1, 0), (1, 5), (1, 9), (2, 1), (2, 11), (3, 2), (3, 6), (3, 8), (4, 0), (4, 10) ] assert count_active_users(n, t, k, event_logs) == 2 def test_no_active_users(): n = 4 t = 10 k = 5 event_logs = [ (1, 0), (1, 20), (1, 40), (2, 10), (2, 30), (2, 50), (3, 15), (3, 35), (3, 55) ] assert count_active_users(n, t, k, event_logs) == 0","solution":"def count_active_users(n, t, k, event_logs): from collections import defaultdict user_events = defaultdict(list) for user_id, event_time in event_logs: user_events[user_id].append(event_time) active_user_count = 0 for events in user_events.values(): events.sort() for i in range(len(events)): count = 0 for j in range(i, len(events)): if events[j] - events[i] <= t: count += 1 else: break if count > k: active_user_count += 1 break return active_user_count # Example usage n = 5 t = 5 k = 2 event_logs = [ (1, 2), (1, 4), (1, 6), (2, 8), (2, 9) ] print(count_active_users(n, t, k, event_logs)) # Output: 1"},{"question":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays arr1 and arr2 into a new array, sorted in ascending order. >>> mergeSortedArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([1, 2, 3], []) [1, 2, 3] >>> mergeSortedArrays([], [4, 5, 6]) [4, 5, 6] >>> mergeSortedArrays([], []) [] >>> mergeSortedArrays([1, 2], [3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([-3, -1, 2], [-2, 0, 4]) [-3, -2, -1, 0, 2, 4] >>> mergeSortedArrays([1, 2, 2], [2, 3, 3]) [1, 2, 2, 2, 3, 3]","solution":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays arr1 and arr2 into a new array, sorted in ascending order. merged = [] i, j = 0, 0 # Traverse both arrays and append smaller element from either array to merged while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # If there are remaining elements in arr1, append them to merged while i < len(arr1): merged.append(arr1[i]) i += 1 # If there are remaining elements in arr2, append them to merged while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped after raining. Args: height : List[int] : A list of non-negative integers representing the elevation map. Returns: int: The total amount of water trapped. pass def test_trap_example_case(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_no_elevation(): assert trap([]) == 0 assert trap([0,0,0,0]) == 0 def test_trap_flat_surface(): assert trap([2, 2, 2, 2]) == 0 def test_trap_increasing_elevation(): assert trap([1,2,3,4,5]) == 0 def test_trap_decreasing_elevation(): assert trap([5,4,3,2,1]) == 0 def test_trap_single_peak(): assert trap([2,0,2]) == 2 def test_trap_multiple_peaks(): assert trap([4,2,0,3,2,5]) == 9 def test_trap_alternating_peaks(): assert trap([5,0,5,0,5]) == 10","solution":"from typing import List def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped after raining. Args: height : List[int] : A list of non-negative integers representing the elevation map. Returns: int: The total amount of water trapped. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water += right_max - height[right] return water"},{"question":"def is_path_possible(N: int, M: int, grid: List[str]) -> str: Determines if there is a valid path from the top-left corner (1,1) to the bottom-right corner (N,M) in the given grid. >>> is_path_possible(4, 4, [\\"....\\", \\"..#.\\", \\"..#.\\", \\"....\\"]) 'YES' >>> is_path_possible(4, 4, [\\"....\\", \\"\\", \\"....\\", \\"....\\"]) 'NO'","solution":"def is_path_possible(N, M, grid): Determines if there is a valid path from the top-left corner (1,1) to the bottom-right corner (N,M) in the given grid. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[str]): A list of strings representing the grid, where '.' denotes an empty cell and '#' denotes a blocked cell. Returns: str: 'YES' if a path is possible, otherwise 'NO'. from collections import deque def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == '.' directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (N-1, M-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def product_sign(a: int, b: int, c: int) -> str: Create a function \`product_sign\` that determines the sign of the product of three given integers, a, b, and c. The function should return \`'positive'\` if the product of the three numbers is positive, \`'negative'\` if the product is negative, and \`'zero'\` if any of the numbers is zero. >>> product_sign(1, 2, 3) 'positive' >>> product_sign(-1, 2, 3) 'negative' >>> product_sign(2, 0, -3) 'zero' >>> product_sign(-1, -2, -3) 'negative'","solution":"def product_sign(a, b, c): if a == 0 or b == 0 or c == 0: return 'zero' negative_count = sum(x < 0 for x in [a, b, c]) if negative_count % 2 == 0: return 'positive' else: return 'negative'"},{"question":"def find_shortest_word_length(sentence: str) -> int: Returns the length of the shortest word(s) in the given sentence. :param sentence: String containing words separated by spaces :return: Length of the shortest word >>> find_shortest_word_length(\\"A quick brown fox jumps over the lazy dog\\") == 1 >>> find_shortest_word_length(\\"hello\\") == 5 >>> find_shortest_word_length(\\"jump over the log\\") == 3 >>> find_shortest_word_length(\\"\\") == 0 >>> find_shortest_word_length(\\" \\") == 0 >>> find_shortest_word_length(\\"dog cat bat\\") == 3","solution":"def find_shortest_word_length(sentence): Returns the length of the shortest word(s) in the given sentence. :param sentence: String containing words separated by spaces :return: Length of the shortest word if not sentence.strip(): return 0 words = sentence.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def max_presentations(presentations): Determines the maximum number of non-overlapping presentations that can be scheduled. Args: presentations (list of tuple): A list where each tuple contains the start and end time of a presentation. Returns: int: The maximum number of non-overlapping presentations. Examples: >>> max_presentations([(1, 3), (2, 5), (4, 8), (6, 7)]) 2 >>> max_presentations([(0, 1), (3, 5), (4, 6), (7, 8), (9, 11)]) 4","solution":"def max_presentations(presentations): Determines the maximum number of non-overlapping presentations that can be scheduled. Args: presentations (list of tuple): A list where each tuple contains the start and end time of a presentation. Returns: int: The maximum number of non-overlapping presentations. # Sort presentations by their end times presentations.sort(key=lambda x: x[1]) max_count = 0 last_end_time = 0 for start_time, end_time in presentations: if start_time >= last_end_time: last_end_time = end_time max_count += 1 return max_count"},{"question":"def is_base_station_covered(satellites: List[Tuple[int, int, int]], base_station: Tuple[int, int]) -> bool: Determines whether any satellite's coverage includes the base station. Parameters: satellites (list of tuples): Each tuple contains (x, y, r) representing the coordinates and radius of the satellite. base_station (tuple): A tuple containing (x, y) coordinates of the base station. Returns: bool: True if the base station is covered by at least one satellite, False otherwise. >>> is_base_station_covered([(0, 0, 10), (5, 5, 5), (10, 10, 2)], (3, 3)) True >>> is_base_station_covered([(0, 0, 1), (2, 2, 1)], (5, 5)) False","solution":"def is_base_station_covered(satellites, base_station): Determines whether any satellite's coverage includes the base station. Parameters: satellites (list of tuples): Each tuple contains (x, y, r) representing the coordinates and radius of the satellite. base_station (tuple): A tuple containing (x, y) coordinates of the base station. Returns: bool: True if the base station is covered by at least one satellite, False otherwise. base_x, base_y = base_station for x, y, r in satellites: distance_squared = (x - base_x) ** 2 + (y - base_y) ** 2 if distance_squared <= r ** 2: return True return False"},{"question":"[Completion Task in Python] from typing import List def generate_spiral_matrix(n: int, m: int) -> List[List[int]]: Generate an n x m matrix filled with integers from 1 to n*m in spiral order. >>> generate_spiral_matrix(3, 4) [[1, 2, 3, 4], [10, 11, 12, 5], [9, 8, 7, 6]] >>> generate_spiral_matrix(4, 4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(1, 1) [[1]] >>> generate_spiral_matrix(1, 5) [[1, 2, 3, 4, 5]] >>> generate_spiral_matrix(5, 1) [[1], [2], [3], [4], [5]] >>> generate_spiral_matrix(2, 2) [[1, 2], [4, 3]]","solution":"def generate_spiral_matrix(n, m): Generates an n x m matrix filled with integers from 1 to n*m in spiral order. # Initialize an empty matrix matrix = [[0] * m for _ in range(n)] # Define the four possible directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] current_direction = 0 # Start with the 'right' direction current_row, current_col = 0, 0 for num in range(1, n * m + 1): matrix[current_row][current_col] = num next_row = current_row + directions[current_direction][0] next_col = current_col + directions[current_direction][1] if next_row >= 0 and next_row < n and next_col >= 0 and next_col < m and matrix[next_row][next_col] == 0: current_row, current_col = next_row, next_col else: current_direction = (current_direction + 1) % 4 current_row += directions[current_direction][0] current_col += directions[current_direction][1] return matrix"},{"question":"from itertools import permutations from typing import List, Tuple def get_permutations(A: List[int], r: int) -> List[Tuple[int, ...]]: Returns all permutations of length r for the given list A. Args: A (List[int]): A sorted list of integers r (int): Length of each permutation Returns: List[Tuple[int, ...]]: List of all possible permutations of length r Example: >>> get_permutations([1, 2, 3], 2) [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] >>> get_permutations([1, 2, 3], 3) [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] >>> get_permutations([1], 1) [(1,)] >>> get_permutations([1, 1, 2], 2) [(1, 1), (1, 2), (1, 1), (1, 2), (2, 1), (2, 1)]","solution":"from itertools import permutations def get_permutations(A, r): Returns all permutations of length r for the given list A. return list(permutations(A, r)) # Example Usage: # A = [1, 2, 3] # r = 2 # print(get_permutations(A, r)) # Output: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]"},{"question":"def num_distinct_islands(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of distinct islands present on the island. An island is a group of 'L' cells connected vertically or horizontally (not diagonally). >>> num_distinct_islands(4, 5, [[\\"L\\", \\"W\\", \\"L\\", \\"W\\", \\"L\\"], [\\"W\\", \\"L\\", \\"W\\", \\"L\\", \\"W\\"], [\\"L\\", \\"W\\", \\"L\\", \\"W\\", \\"L\\"], [\\"W\\", \\"L\\", \\"W\\", \\"L\\", \\"W\\"]]) 10 >>> num_distinct_islands(3, 3, [[\\"L\\", \\"L\\", \\"W\\"], [\\"L\\", \\"L\\", \\"W\\"], [\\"W\\", \\"W\\", \\"W\\"]]) 1 >>> num_distinct_islands(3, 3, [[\\"L\\", \\"W\\", \\"L\\"], [\\"W\\", \\"L\\", \\"W\\"], [\\"L\\", \\"W\\", \\"L\\"]]) 5 >>> num_distinct_islands(1, 1, [[\\"L\\"]]) 1 >>> num_distinct_islands(2, 2, [[\\"W\\", \\"W\\"], [\\"W\\", \\"W\\"]]) 0","solution":"def num_distinct_islands(n, m, grid): def dfs(i, j): stack = [(i, j)] while stack: x, y = stack.pop() if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 'W': continue grid[x][y] = 'W' stack.append((x+1, y)) stack.append((x-1, y)) stack.append((x, y+1)) stack.append((x, y-1)) count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': dfs(i, j) count += 1 return count"},{"question":"def process_input(t: int, test_cases_input: List[str]) -> List[int]: Determine the largest rectangular section of the garden that only contains empty spaces for each test case. Args: t: The number of test cases test_cases_input: A list of strings representing the grid input for each test case. Returns: A list of integers where each integer is the maximal possible area (in cells) of a rectangular section of the garden that only contains empty spaces (0s) for the corresponding test case. Example: >>> t = 2 >>> test_cases_input = [\\"3 4\\", \\"1 0 0 0\\", \\"0 0 0 1\\", \\"0 1 0 0\\", \\"2 5\\", \\"0 1 1 0 1\\", \\"0 0 0 0 0\\"] >>> process_input(t, test_cases_input) [4, 5] >>> t = 1 >>> test_cases_input = [\\"3 3\\", \\"0 0 0\\", \\"0 0 0\\", \\"0 0 0\\"] >>> process_input(t, test_cases_input) [9]","solution":"def maximal_rectangle(grid): This function takes a grid as input and returns the area of the largest rectangle containing only 0s. if not grid: return 0 n, m = len(grid), len(grid[0]) dp = [0] * m max_area = 0 for i in range(n): for j in range(m): if grid[i][j] == 0: dp[j] += 1 else: dp[j] = 0 stack = [] for j in range(m + 1): while stack and (j == m or dp[stack[-1]] > dp[j]): height = dp[stack.pop()] width = j if not stack else j - stack[-1] - 1 max_area = max(max_area, width * height) stack.append(j) return max_area def largest_rectangles(test_cases): results = [] for grid in test_cases: results.append(maximal_rectangle(grid)) return results def process_input(t, test_cases_input): This function processes the raw input data and invokes the \`largest_rectangles\` function. test_cases = [] index = 0 for _ in range(t): n, m = map(int, test_cases_input[index].split()) index += 1 grid = [] for _ in range(n): grid.append(list(map(int, test_cases_input[index].split()))) index += 1 test_cases.append(grid) return largest_rectangles(test_cases)"},{"question":"def is_repeated_substring(s: str, sub: str) -> bool: Determines whether a string \`s\` can be formed by concatenating one string \`sub\` multiple times. :param s: The main string to be checked :param sub: The potential substring :return: True if \`s\` can be formed by repeating \`sub\`, False otherwise Examples: >>> is_repeated_substring(\\"ababab\\", \\"ab\\") True >>> is_repeated_substring(\\"aaaa\\", \\"a\\") True >>> is_repeated_substring(\\"abcdef\\", \\"abc\\") False >>> is_repeated_substring(\\"xyzxyzxyz\\", \\"xyz\\") True >>> is_repeated_substring(\\"abcabcabcd\\", \\"abc\\") False","solution":"def is_repeated_substring(s, sub): Determines whether the string \`s\` can be formed by concatenating \`sub\` multiple times. :param s: The main string to be checked :param sub: The potential substring :return: True if \`s\` can be formed by repeating \`sub\`, False otherwise if len(s) % len(sub) != 0: return False concatenated_sub = sub * (len(s) // len(sub)) return concatenated_sub == s"},{"question":"def find_substring_indices(s: str, substring: str) -> List[int]: Returns a list of starting indices where substring appears in s. If substring does not appear in s, returns an empty list. >>> find_substring_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_substring_indices(\\"hello world\\", \\"world\\") [6] >>> find_substring_indices(\\"hello\\", \\"bye\\") [] >>> find_substring_indices(\\"aaaa\\", \\"aa\\") [0, 1, 2] >>> find_substring_indices(\\"\\", \\"a\\") [] >>> find_substring_indices(\\"a\\", \\"\\") [] >>> find_substring_indices(\\"banana\\", \\"a\\") [1, 3, 5] >>> find_substring_indices(\\"banana\\", \\"b\\") [0] >>> find_substring_indices(\\"banana\\", \\"c\\") [] >>> find_substring_indices(\\"aaaa\\", \\"aaaa\\") [0] >>> find_substring_indices(\\"aaaa\\", \\"aaaaa\\") []","solution":"def find_substring_indices(s, substring): Returns a list of starting indices where substring appears in s. If substring does not appear in s, returns an empty list. if not substring: # Handle the case where substring is empty return [] indices = [] index = s.find(substring) while index != -1: indices.append(index) index = s.find(substring, index + 1) return indices"},{"question":"def dutch_flag_partition(arr: List[int], pivot: int) -> None: Partitions the array around the pivot into three groups: - Elements less than the pivot - Elements equal to the pivot - Elements greater than the pivot The function modifies the array in-place. Parameters: arr (List[int]): List of integers to be partitioned. pivot (int): The pivot value around which the partition is done. Examples: >>> arr = [4, 2, 3, 1, 3, 2, 4, 5] >>> dutch_flag_partition(arr, 3) >>> arr [2, 1, 2, 3, 3, 4, 5, 4] >>> arr = [1, 3, 2, 3, 6, 3, 4, 5] >>> dutch_flag_partition(arr, 3) >>> arr [1, 2, 3, 3, 3, 6, 4, 5]","solution":"def dutch_flag_partition(arr, pivot): Partitions the array around the pivot into three groups: - Elements less than the pivot - Elements equal to the pivot - Elements greater than the pivot The function modifies the array in-place. Parameters: arr (List[int]): List of integers to be partitioned. pivot (int): The pivot value around which the partition is done. Returns: None smaller, equal, larger = 0, 0, len(arr) while equal < larger: if arr[equal] < pivot: arr[smaller], arr[equal] = arr[equal], arr[smaller] smaller += 1 equal += 1 elif arr[equal] == pivot: equal += 1 else: larger -= 1 arr[equal], arr[larger] = arr[larger], arr[equal]"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Finds the length of the longest substring with at most k distinct characters. Arguments: s -- input string (only lowercase English letters) k -- number of distinct characters allowed in the substring Returns: Integer representing the length of the longest substring containing at most k distinct characters. >>> longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_k_distinct(\\"aa\\", 1) 2 pass # Unit tests to validate the solution def test_longest_substring_k_distinct(): assert longest_substring_k_distinct(\\"eceba\\", 2) == 3 assert longest_substring_k_distinct(\\"aa\\", 1) == 2 assert longest_substring_k_distinct(\\"aabacbebebe\\", 3) == 7 assert longest_substring_k_distinct(\\"aaaa\\", 1) == 4 assert longest_substring_k_distinct(\\"aabbcc\\", 1) == 2 assert longest_substring_k_distinct(\\"aabbcc\\", 2) == 4 assert longest_substring_k_distinct(\\"aabbcc\\", 3) == 6 assert longest_substring_k_distinct(\\"abc\\", 2) == 2 assert longest_substring_k_distinct(\\"\\", 2) == 0 assert longest_substring_k_distinct(\\"a\\", 0) == 0 assert longest_substring_k_distinct(\\"abcdef\\", 0) == 0 assert longest_substring_k_distinct(\\"abcdef\\", 10) == 6 def test_edge_cases(): assert longest_substring_k_distinct(\\"a\\", 1) == 1 assert longest_substring_k_distinct(\\"a\\", 2) == 1 assert longest_substring_k_distinct(\\"aa\\", 0) == 0 def test_no_distinct_allowed(): assert longest_substring_k_distinct(\\"aabbccdd\\", 0) == 0 assert longest_substring_k_distinct(\\"hello\\", 0) == 0 def test_single_repeated_char(): assert longest_substring_k_distinct(\\"bbbbbbb\\", 1) == 7 assert longest_substring_k_distinct(\\"bbbbbbb\\", 2) == 7","solution":"def longest_substring_k_distinct(s: str, k: int) -> int: Finds the length of the longest substring with at most k distinct characters. Arguments: s -- input string (only lowercase English letters) k -- number of distinct characters allowed in the substring Returns: Integer representing the length of the longest substring containing at most k distinct characters. if k == 0 or not s: return 0 n = len(s) left = 0 right = 0 max_length = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def flatten_dictionary(d, parent_key='', sep='.'): Flattens a nested dictionary. The keys in the flattened dictionary are the paths to the values in the original dictionary, separated by dots. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key for the current level of recursion. sep (str): The separator to use between keys. Returns: dict: A new dictionary with flattened keys. >>> flatten_dictionary({\\"a\\": {\\"b\\": {\\"c\\": \\"d\\", \\"e\\": \\"f\\"}, \\"g\\": \\"h\\"}, \\"i\\": \\"j\\"}) {'a.b.c': 'd', 'a.b.e': 'f', 'a.g': 'h', 'i': 'j'} >>> flatten_dictionary({\\"a\\": {\\"b\\": \\"c\\", \\"d\\": {\\"e\\": {\\"f\\": \\"g\\"}}}, \\"h\\": \\"i\\", \\"j\\": {\\"k\\": \\"l\\", \\"m\\": {\\"n\\": \\"o\\", \\"p\\": \\"q\\"}}}) {'a.b': 'c', 'a.d.e.f': 'g', 'h': 'i', 'j.k': 'l', 'j.m.n': 'o', 'j.m.p': 'q'}","solution":"def flatten_dictionary(d, parent_key='', sep='.'): Flattens a nested dictionary. The keys in the flattened dictionary are the paths to the values in the original dictionary, separated by dots. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key for the current level of recursion. sep (str): The separator to use between keys. Returns: dict: A new dictionary with flattened keys. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.max_group_size = 1 def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: # Union by rank if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u self.rank[root_u] += self.rank[root_v] self.max_group_size = max(self.max_group_size, self.rank[root_u]) else: self.parent[root_u] = root_v self.rank[root_v] += self.rank[root_u] self.max_group_size = max(self.max_group_size, self.rank[root_v]) return self.max_group_size def largest_groups(n: int, m: int, connections: List[Tuple[int, int]]) -> List[int]: Determine the largest group of devices that are connected via communication by the end of each day. Args: n (int): the number of devices. m (int): the number of days. connections (List[Tuple[int, int]]): list of tuples where each tuple (x_i, y_i) represents a communication between device x_i and device y_i. Returns: List[int]: list containing the size of the largest group of connected devices by the end of each day. Example: >>> largest_groups(5, 5, [(1, 2), (2, 3), (4, 5), (1, 3), (2, 4)]) [2, 3, 3, 3, 5] >>> largest_groups(6, 4, [(3, 4), (1, 2), (2, 3), (5, 6)]) [2, 2, 4, 4] pass","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.max_group_size = 1 def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: # Union by rank if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u self.rank[root_u] += self.rank[root_v] self.max_group_size = max(self.max_group_size, self.rank[root_u]) else: self.parent[root_u] = root_v self.rank[root_v] += self.rank[root_u] self.max_group_size = max(self.max_group_size, self.rank[root_v]) return self.max_group_size def largest_groups(n, m, connections): uf = UnionFind(n) results = [] for x, y in connections: max_group_size = uf.union(x - 1, y - 1) results.append(max_group_size) return results"},{"question":"class TemperatureTracker: A class that monitors and provides data on a series of recorded temperatures. It supports the following operations: 1. record(temperature: int) - Records a new temperature measurement. 2. getMaxTemp() - Returns the highest temperature recorded so far. 3. getMinTemp() - Returns the lowest temperature recorded so far. 4. getMeanTemp() - Returns the mean (average) of all recorded temperatures. 5. getModeTemp() - Returns the mode of the recorded temperatures. If there is a tie, return any one of the modes. >>> tracker = TemperatureTracker() >>> tracker.record(72) >>> tracker.record(76) >>> tracker.record(72) >>> tracker.record(68) >>> tracker.record(72) >>> tracker.getMaxTemp() == 76 True >>> tracker.getMinTemp() == 68 True >>> abs(tracker.getMeanTemp() - 72.0) < 1e-9 True >>> tracker.getModeTemp() == 72 True def record(self, temperature: int): pass def getMaxTemp(self): pass def getMinTemp(self): pass def getMeanTemp(self): pass def getModeTemp(self): pass def test_temperature_tracker(): tracker = TemperatureTracker() tracker.record(72) tracker.record(76) tracker.record(72) tracker.record(68) tracker.record(72) assert tracker.getMaxTemp() == 76 assert tracker.getMinTemp() == 68 assert abs(tracker.getMeanTemp() - 72.0) < 1e-9 # Allow numeric error margin assert tracker.getModeTemp() == 72 def test_empty_tracker(): tracker = TemperatureTracker() assert tracker.getMaxTemp() == float('-inf') assert tracker.getMinTemp() == float('inf') assert tracker.getMeanTemp() == None assert tracker.getModeTemp() == None def test_single_record(): tracker = TemperatureTracker() tracker.record(85) assert tracker.getMaxTemp() == 85 assert tracker.getMinTemp() == 85 assert tracker.getMeanTemp() == 85 assert tracker.getModeTemp() == 85 def test_multiple_modes(): tracker = TemperatureTracker() tracker.record(65) tracker.record(72) tracker.record(65) tracker.record(72) assert tracker.getMaxTemp() == 72 assert tracker.getMinTemp() == 65 assert abs(tracker.getMeanTemp() - 68.5) < 1e-9 # Allow numeric error margin assert tracker.getModeTemp() in [65, 72]","solution":"class TemperatureTracker: def __init__(self): self.temperatures = [] self.max_temp = float('-inf') self.min_temp = float('inf') self.sum_temp = 0 self.count_temp = 0 self.freq_map = {} self.mode_temp = None self.max_count = 0 def record(self, temperature: int): self.temperatures.append(temperature) self.max_temp = max(self.max_temp, temperature) self.min_temp = min(self.min_temp, temperature) self.sum_temp += temperature self.count_temp += 1 if temperature in self.freq_map: self.freq_map[temperature] += 1 else: self.freq_map[temperature] = 1 if self.freq_map[temperature] > self.max_count: self.max_count = self.freq_map[temperature] self.mode_temp = temperature def getMaxTemp(self): return self.max_temp def getMinTemp(self): return self.min_temp def getMeanTemp(self): if self.count_temp == 0: return None return self.sum_temp / self.count_temp def getModeTemp(self): return self.mode_temp"},{"question":"from typing import List def min_trucks(package_weights: List[int], truck_limit: int) -> int: Determines the minimum number of trucks required to transport all the packages without exceeding the weight limit of any truck. Args: package_weights (List[int]): List of package weights. truck_limit (int): Weight limit of each truck. Returns: int: Minimum number of trucks needed. # Function implementation here # Example usage packages = [4, 8, 15, 16, 23, 42] limit = 50 print(min_trucks(packages, limit)) # Expected output: 3 # Explanation: One possible way to load the trucks is: # Truck 1: [4, 8, 15, 16] (total weight = 43) # Truck 2: [23] (total weight = 23) # Truck 3: [42] (total weight = 42) # Unit Tests def test_basic_scenario(): packages = [4, 8, 15, 16, 23, 42] limit = 50 assert min_trucks(packages, limit) == 3 def test_single_package(): packages = [10] limit = 10 assert min_trucks(packages, limit) == 1 def test_all_packages_separately(): packages = [50, 50, 50, 50] limit = 50 assert min_trucks(packages, limit) == 4 def test_all_packages_in_one_truck(): packages = [10, 20, 30] limit = 60 assert min_trucks(packages, limit) == 1 def test_large_number_of_packages(): packages = [5] * 100 limit = 10 assert min_trucks(packages, limit) == 50 def test_mixed_package_weights(): packages = [9, 8, 7, 6] limit = 10 assert min_trucks(packages, limit) == 4 def test_not_possible_to_fit(): packages = [5, 15, 25] limit = 10 assert min_trucks(packages, limit) == 3","solution":"from typing import List def min_trucks(package_weights: List[int], truck_limit: int) -> int: Determines the minimum number of trucks required to transport all the packages without exceeding the weight limit of any truck. Args: package_weights (List[int]): List of package weights. truck_limit (int): Weight limit of each truck. Returns: int: Minimum number of trucks needed. package_weights.sort(reverse=True) trucks = [] for weight in package_weights: placed = False for i in range(len(trucks)): if trucks[i] + weight <= truck_limit: trucks[i] += weight placed = True break if not placed: trucks.append(weight) return len(trucks)"},{"question":"from typing import List def is_happy_number(num: int) -> bool: Determine if a number is a happy number. >>> is_happy_number(1) == True >>> is_happy_number(7) == True >>> is_happy_number(10) == True >>> is_happy_number(13) == True >>> is_happy_number(19) == True >>> is_happy_number(4) == False >>> is_happy_number(20) == False pass def happy_number_index(n: int) -> int: Return the nth happy number. >>> happy_number_index(1) == 1 >>> happy_number_index(2) == 7 >>> happy_number_index(3) == 10 >>> happy_number_index(4) == 13 >>> happy_number_index(5) == 19 >>> happy_number_index(10) == 44 >>> happy_number_index(20) == 100 pass","solution":"def is_happy_number(num): Determine if a number is a happy number. seen = set() while num != 1 and num not in seen: seen.add(num) num = sum(int(digit) ** 2 for digit in str(num)) return num == 1 def happy_number_index(n): Returns the nth happy number. count = 0 num = 1 while count < n: if is_happy_number(num): count += 1 if count == n: return num num += 1"},{"question":"def max_gold(houses: List[int]) -> int: Returns the maximum amount of gold the thief can rob without alerting the police. >>> max_gold([1, 2, 3, 1]) 4 >>> max_gold([1000000000, 1, 1, 1000000000]) 2000000000","solution":"def max_gold(houses): Returns the maximum amount of gold the thief can rob without alerting the police. :param houses: List[int] - List of integers where each integer represents the amount of gold in a house. :return: int - Maximum amount of gold that can be robbed. if not houses: return 0 if len(houses) == 1: return houses[0] prev1 = 0 prev2 = 0 for gold in houses: current = max(prev2 + gold, prev1) prev2 = prev1 prev1 = current return prev1"},{"question":"def rotate_matrix(matrix): Rotates a given NxN matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The input NxN matrix to be rotated. Returns: list of list of int: The rotated matrix. Example: >>> rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass # Unit Test def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_2x2(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_1x1(): matrix = [ [1] ] expected = [ [1] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_empty(): matrix = [] expected = [] assert rotate_matrix(matrix) == expected","solution":"def rotate_matrix(matrix): Rotates a given NxN matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The input NxN matrix to be rotated. Returns: list of list of int: The rotated matrix. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def word_frequency(s: str) -> dict: Given a string consisting of lowercase alphabets and spaces, count the frequency of each unique word. The words are sorted in alphabetical order in the final dictionary. >>> word_frequency(\\"this is a test this is only a test\\") { \\"a\\": 2, \\"is\\": 2, \\"only\\": 1, \\"test\\": 2, \\"this\\": 2 } >>> word_frequency(\\"hello\\") { \\"hello\\": 1 } >>> word_frequency(\\"\\") {} >>> word_frequency(\\"hello world\\") { \\"hello\\": 1, \\"world\\": 1 } >>> word_frequency(\\"repeat repeat repeat\\") { \\"repeat\\": 3 }","solution":"def word_frequency(s): Returns a dictionary with each unique word and its frequency from the input string s. The words are sorted in alphabetical order in the final dictionary. words = s.split() frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 sorted_frequency = dict(sorted(frequency.items())) return sorted_frequency"},{"question":"def numFullBinaryTrees(n: int) -> int: Create a function that takes an integer n and returns the number of structurally unique full binary trees having exactly n nodes where each node has either 0 or 2 children. >>> numFullBinaryTrees(1) == 1 >>> numFullBinaryTrees(3) == 1 >>> numFullBinaryTrees(5) == 2 >>> numFullBinaryTrees(7) == 5 >>> numFullBinaryTrees(2) == 0 >>> numFullBinaryTrees(4) == 0 >>> numFullBinaryTrees(6) == 0 >>> numFullBinaryTrees(9) == 14 >>> numFullBinaryTrees(11) == 42","solution":"from functools import lru_cache @lru_cache(None) def numFullBinaryTrees(n): if n % 2 == 0: return 0 # A full binary tree must have an odd number of nodes if n == 1: return 1 # A full binary tree with one node is just the root total_trees = 0 for left_nodes in range(1, n, 2): right_nodes = n - 1 - left_nodes left_trees = numFullBinaryTrees(left_nodes) right_trees = numFullBinaryTrees(right_nodes) total_trees += left_trees * right_trees return total_trees"},{"question":"from typing import List def min_chests_to_open(N: int, initial_state: str, unlocks: List[List[int]]) -> int: Determines the minimum number of chests that need to be opened initially so that all chests can be accessed. :param N: int - Number of chests. :param initial_state: str - Binary string representing the initial unlock state of chests. :param unlocks: list of list - Each sublist contains the chests that can be unlocked by a given chest. :return: int - Minimum number of chests to open initially, or -1 if not possible to access all chests. pass def test_sample_input(): N = 4 initial_state = \\"1000\\" unlocks = [ [2], # Chest 1 unlocks Chest 2 [3], # Chest 2 unlocks Chest 3 [4], # Chest 3 unlocks Chest 4 [] # Chest 4 unlocks no chest ] assert min_chests_to_open(N, initial_state, unlocks) == 1 def test_no_initial_unlocks(): N = 4 initial_state = \\"0000\\" unlocks = [ [2], # Chest 1 unlocks Chest 2 [3], # Chest 2 unlocks Chest 3 [4], # Chest 3 unlocks Chest 4 [] # Chest 4 unlocks no chest ] assert min_chests_to_open(N, initial_state, unlocks) == -1 def test_all_initially_unlocked(): N = 4 initial_state = \\"1111\\" unlocks = [ [2], # Chest 1 unlocks Chest 2 [3], # Chest 2 unlocks Chest 3 [4], # Chest 3 unlocks Chest 4 [] # Chest 4 unlocks no chest ] assert min_chests_to_open(N, initial_state, unlocks) == 4 def test_disconnected_chests(): N = 4 initial_state = \\"1000\\" unlocks = [ [2], # Chest 1 unlocks Chest 2 [], # Chest 2 unlocks no chest [4], # Chest 3 unlocks Chest 4 [] # Chest 4 unlocks no chest ] assert min_chests_to_open(N, initial_state, unlocks) == -1 def test_complex_case(): N = 6 initial_state = \\"100100\\" unlocks = [ [2, 3], # Chest 1 unlocks Chest 2 and Chest 3 [4], # Chest 2 unlocks Chest 4 [5, 6], # Chest 3 unlocks Chest 5 and Chest 6 [], # Chest 4 unlocks no chest [], # Chest 5 unlocks no chest [] # Chest 6 unlocks no chest ] assert min_chests_to_open(N, initial_state, unlocks) == 2","solution":"def min_chests_to_open(N, initial_state, unlocks): Determines the minimum number of chests that need to be opened initially so that all chests can be accessed. :param N: int - Number of chests. :param initial_state: str - Binary string representing the initial unlock state of chests. :param unlocks: list of list - Each sublist contains the chests that can be unlocked by a given chest. :return: int - Minimum number of chests to open initially, or -1 if not possible to access all chests. from collections import deque # Create a graph for the chests graph = [[] for _ in range(N)] for i in range(N): for chest in unlocks[i]: graph[i].append(chest - 1) # Convert 1-indexed to 0-indexed visited = [False] * N queue = deque() # Initialize the queue with already unlocked chests for i in range(N): if initial_state[i] == '1': queue.append(i) visited[i] = True opened_count = 0 while queue: current = queue.popleft() opened_count += 1 for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if all(visited): return initial_state.count('1') # Count of initial '1' characters else: return -1"},{"question":"from typing import List def max_rect_area(heights: List[int]) -> int: Computes the maximum rectangular area in the histogram represented by heights. Args: heights (List[int]): A list of non-negative integers representing the heights of buildings. Returns: int: The maximum rectangular area in the skyline. Examples: >>> max_rect_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rect_area([1, 2, 3, 4, 5]) 9 >>> max_rect_area([5, 4, 3, 2, 1]) 9 >>> max_rect_area([2, 4]) 4","solution":"from typing import List def max_rect_area(heights: List[int]) -> int: Computes the maximum rectangular area in the histogram represented by heights. n = len(heights) if n == 0: return 0 # Create an empty stack. The stack holds indexes of heights array. stack = [] max_area = 0 # Traverse all buildings in heights index = 0 while index < n: # If stack is empty or the current height is greater than or equal to the height of the building index at the top of the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest or minimum height area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area max_area = max(max_area, area) # Now pop the remaining bars from stack and calculate area with every popped bar as the smallest bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def find_ranges(nums: List[int]) -> str: Identify and return a string representation of the ranges formed by consecutive numbers in the list. >>> find_ranges([1, 2, 3, 6, 7, 8, 10, 12, 13, 14, 15]) == \\"1-3,6-8,10,12-15\\" >>> find_ranges([4, 5, 7, 8, 10]) == \\"4-5,7-8,10\\" >>> find_ranges([1, 3, 5, 7, 9]) == \\"1,3,5,7,9\\" >>> find_ranges([]) == \\"\\"","solution":"def find_ranges(nums): if not nums: return \\"\\" ranges = [] start = nums[0] end = nums[0] for num in nums[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return \\",\\".join(ranges)"},{"question":"def max_performance_sum(employeeScores: List[Tuple[int, int]], minRange: int, maxRange: int) -> int: Given a list of employee scores and a range, returns the maximum sum of performance scores for non-overlapping groups that fall entirely within the range. Args: employeeScores (List[Tuple[int, int]]): A list of tuples where each tuple contains an employee ID and a performance score. minRange (int): The minimum range of performance scores. maxRange (int): The maximum range of performance scores. Returns: int: The maximum sum of performance scores for non-overlapping groups. Example: >>> max_performance_sum([(1, 50), (2, 30), (3, 70), (4, 90)], 50, 100) 210 >>> max_performance_sum([(1, 40), (2, 60), (3, 55), (4, 75)], 50, 65) 115 >>> max_performance_sum([(1, 20), (2, 35), (3, 50)], 40, 60) 50 >>> max_performance_sum([(1, 200), (2, 250), (3, 300)], 100, 150) 0 # Implementation here","solution":"def max_performance_sum(employeeScores, minRange, maxRange): Given a list of employee scores and a range, returns the maximum sum of performance scores for non-overlapping groups that fall entirely within the range. max_sum = 0 for _, score in employeeScores: if minRange <= score <= maxRange: max_sum += score return max_sum"},{"question":"def longest_zigzag_sequence(arr: List[int]) -> int: Finds the length of the longest contiguous subarray which is a zigzag sequence. >>> longest_zigzag_sequence([1]) == 1 >>> longest_zigzag_sequence([1, 2]) == 2 >>> longest_zigzag_sequence([2, 1]) == 2 >>> longest_zigzag_sequence([1, 1]) == 1 >>> longest_zigzag_sequence([1, 2, 3, 4, 5]) == 2 >>> longest_zigzag_sequence([5, 4, 3, 2, 1]) == 2 >>> longest_zigzag_sequence([1, 3, 2, 4, 1, 5]) == 6 >>> longest_zigzag_sequence([1, 7, 4, 9, 2, 5, 1, 4, 8, 3]) == 9 >>> longest_zigzag_sequence([1, 7, 7, 4, 9, 2, 5, 1, 4, 4, 8, 3]) == 9","solution":"def longest_zigzag_sequence(arr): Finds the length of the longest contiguous subarray which is a zigzag sequence. n = len(arr) if n < 2: return n # Initialize lengths of the longest zig-zag ending at each position up = 1 down = 1 max_length = 1 for i in range(1, n): if arr[i] > arr[i - 1]: up = down + 1 max_length = max(max_length, up) elif arr[i] < arr[i - 1]: down = up + 1 max_length = max(max_length, down) return max_length"},{"question":"def reverse_substrings(s: str, k: int) -> str: This function splits the input string \`s\` into substrings of length \`k\`, reverses each substring, and then concatenates them to form the final modified string. >>> reverse_substrings(\\"abcdefghi\\", 3) 'cbafedihg' >>> reverse_substrings(\\"abcdefg\\", 3) 'cbafedg' >>> reverse_substrings(\\"abcdef\\", 2) 'badcfe' >>> reverse_substrings(\\"abcde\\", 2) 'badce' >>> reverse_substrings(\\"abcdef\\", 1) 'abcdef' >>> reverse_substrings(\\"abcdefgh\\", 4) 'dcbahgfe' >>> reverse_substrings(\\"abcdefghij\\", 4) 'dcbahgfeji' >>> reverse_substrings(\\"abc\\", 5) 'cba' >>> reverse_substrings(\\"a\\", 5) 'a' >>> reverse_substrings(\\"\\", 3) ''","solution":"def reverse_substrings(s: str, k: int) -> str: This function splits the input string \`s\` into substrings of length \`k\`, reverses each substring, and then concatenates them to form the final modified string. # Splitting the string into chunks of k characters substrings = [s[i:i+k] for i in range(0, len(s), k)] # Reversing each substring reversed_substrings = [substring[::-1] for substring in substrings] # Concatenating the reversed substrings return ''.join(reversed_substrings)"},{"question":"def swap_language_greeting(sentence: str) -> str: Swaps the greeting in the sentence based on predefined greetings. If the sentence contains \\"Hello\\", change it to \\"Hi\\". If the sentence contains \\"Hola\\", change it to \\"Buenos días\\". If the sentence contains \\"Bonjour\\", change it to \\"Salut\\". :param sentence: String containing the input sentence :return: String with the swapped greeting >>> swap_language_greeting(\\"Hello there!\\") 'Hi there!' >>> swap_language_greeting(\\"Hola amigo!\\") 'Buenos días amigo!' >>> swap_language_greeting(\\"Bonjour tout le monde!\\") 'Salut tout le monde!' >>> swap_language_greeting(\\"Goodbye!\\") 'Goodbye!'","solution":"def swap_language_greeting(sentence): Swaps the greeting in the sentence based on predefined greetings. If the sentence contains \\"Hello\\", change it to \\"Hi\\". If the sentence contains \\"Hola\\", change it to \\"Buenos días\\". If the sentence contains \\"Bonjour\\", change it to \\"Salut\\". :param sentence: String containing the input sentence :return: String with the swapped greeting if \\"Hello\\" in sentence: return sentence.replace(\\"Hello\\", \\"Hi\\") elif \\"Hola\\" in sentence: return sentence.replace(\\"Hola\\", \\"Buenos días\\") elif \\"Bonjour\\" in sentence: return sentence.replace(\\"Bonjour\\", \\"Salut\\") else: return sentence"},{"question":"from typing import List def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Examples: >>> longest_unique_substring(\\"abrkaabcdefghijjxxx\\") == 10 >>> longest_unique_substring(\\"abcabcbb\\") == 3 >>> longest_unique_substring(\\"bbbbb\\") == 1 pass # Unit tests def test_longest_unique_substring_example_1(): assert longest_unique_substring(\\"abrkaabcdefghijjxxx\\") == 10 def test_longest_unique_substring_example_2(): assert longest_unique_substring(\\"abcabcbb\\") == 3 def test_longest_unique_substring_example_3(): assert longest_unique_substring(\\"bbbbb\\") == 1 def test_longest_unique_substring_empty_string(): assert longest_unique_substring(\\"\\") == 0 def test_longest_unique_substring_single_character(): assert longest_unique_substring(\\"a\\") == 1 def test_longest_unique_substring_all_unique(): assert longest_unique_substring(\\"abcdef\\") == 6 def test_longest_unique_substring_overlap(): assert longest_unique_substring(\\"dvdf\\") == 3","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) longest = 0 char_index_map = {} start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"def hq9plus_interpreter(program: str) -> List[str]: Interpret and execute the given HQ9+ program. Args: program (str): The HQ9+ program as a string. Returns: List of strings representing the output of the program. Example: >>> hq9plus_interpreter(\\"H\\") [\\"Hello, World!\\"] >>> hq9plus_interpreter(\\"Q\\") [\\"Q\\"] >>> hq9plus_interpreter(\\"9\\") [\\"99 bottles of beer on the wall, 99 bottles of beer.nTake one down and pass it around, 98 bottles of beer on the wall.n...\\"] pass","solution":"def hq9plus_interpreter(program): Interpret and execute the given HQ9+ program. Args: program (str): The HQ9+ program as a string. Returns: List of strings representing the output of the program. def bottles_of_beer(): lyrics = \\"\\" for i in range(99, 0, -1): lyrics += f\\"{i} bottles of beer on the wall, {i} bottles of beer.n\\" if i == 1: lyrics += \\"Take one down and pass it around, no more bottles of beer on the wall.n\\" else: lyrics += f\\"Take one down and pass it around, {i-1} bottles of beer on the wall.n\\" lyrics += \\"No more bottles of beer on the wall, no more bottles of beer.n\\" lyrics += \\"Go to the store and buy some more, 99 bottles of beer on the wall.n\\" return lyrics output = [] accumulator = 0 for command in program: if command == 'H': output.append(\\"Hello, World!\\") elif command == 'Q': output.append(program) elif command == '9': output.append(bottles_of_beer()) elif command == '+': accumulator += 1 return output"},{"question":"class RobotPath: A class that simulates the movement of a robot on an infinite grid starting at position (0, 0). Methods ------- __init__: Initializes the robot at the starting position (0, 0). move(commands: str): Updates the robot's position based on the movement commands. current_position() -> tuple: Returns the robot's current position as a tuple (x, y). def __init__(self): Initializes the robot at the starting position (0, 0). pass def move(self, commands: str): Updates the robot's position based on the movement commands. :param commands: A string where each character is a movement instruction pass def current_position(self) -> tuple: Returns the robot's current position as a tuple (x, y). :return: (x, y) position of the robot pass # Example if __name__ == \\"__main__\\": # Initialize the robot robot = RobotPath() # Robot's initial position print(robot.current_position()) # Output: (0, 0) # Move the robot with commands 'UUDDLRLR' robot.move(\\"UUDDLRLR\\") # Robot's position after movements print(robot.current_position()) # Output: (0, 0) # Move the robot with command 'UUU' robot.move(\\"UUU\\") # Robot's position after movements print(robot.current_position()) # Output: (0, 3)","solution":"class RobotPath: def __init__(self): Initializes the robot at the starting position (0, 0). self.position = [0, 0] # x, y position def move(self, commands): Update the robot's position based on the movement commands. :param commands: A string where each character is a movement instruction for command in commands: if command == 'U': self.position[1] += 1 elif command == 'D': self.position[1] -= 1 elif command == 'L': self.position[0] -= 1 elif command == 'R': self.position[0] += 1 def current_position(self): Returns the robot's current position as a tuple (x, y). :return: (x, y) position of the robot return tuple(self.position)"},{"question":"from typing import List def array_transformation(n: int, q: int, arr: List[int], operations: str) -> List[int]: You are given a simple array transformation problem. You have an array of N integers and a set of Q operations. Each operation can either increase each element of the array by 1 or find the minimum element of the array. You need to execute these operations in the given order. '+': Increase each element of the array by 1 '?': Find and report the minimum element in the array Answer all queries of the second type. Args: n (int): The number of elements in the array. q (int): The number of operations. arr (List[int]): The array of integers. operations (str): The operations to perform on the array. Returns: List[int]: Results for the query operations. >>> array_transformation(5, 5, [3, 1, 4, 1, 5], \\"+?++?\\") [2, 4]","solution":"def array_transformation(n, q, arr, operations): min_results = [] increment = 0 for op in operations: if op == '+': increment += 1 elif op == '?': current_min = min(arr) + increment min_results.append(current_min) return min_results # Example use case n, q = 5, 5 arr = [3, 1, 4, 1, 5] operations = \\"+?++?\\" results = array_transformation(n, q, arr, operations) for result in results: print(result)"},{"question":"def racer_with_shortest_average_lap_time(N: int, racers_data: List[tuple]) -> int: Given the number of racers (N) and their corresponding lap times, returns the racer ID with the shortest average lap time. If multiple racers have the same average lap time, returns the racer with the smallest ID. Parameters: N (int): Number of racers racers_data (list): List of tuples. Each tuple contains the racer ID (int), number of laps (int) and the lap times (list of ints) Returns: int: Racer ID with the shortest average lap time >>> racer_with_shortest_average_lap_time(3, [(1, 3, 1000, 1500, 1200), (2, 3, 900, 1500, 1300), (3, 4, 1100, 1400, 1000, 1200)]) 3 >>> racer_with_shortest_average_lap_time(2, [(1, 2, 1000, 2000), (2, 2, 1500, 1500)]) 1 >>> racer_with_shortest_average_lap_time(1, [(1, 3, 1000, 1000, 1000)]) 1 >>> racer_with_shortest_average_lap_time(2, [(1, 2, 1000, 900), (2, 3, 900, 1000, 1100)]) 1 >>> racer_with_shortest_average_lap_time(2, [(1, 3, 1000000, 999999, 999998), (2, 3, 999997, 1000000, 999996)]) 2","solution":"def racer_with_shortest_average_lap_time(N, racers_data): Given the number of racers (N) and their corresponding lap times, returns the racer ID with the shortest average lap time. If multiple racers have the same average lap time, returns the racer with the smallest ID. Parameters: N (int): Number of racers racers_data (list): List of tuples. Each tuple contains the racer ID (int), number of laps (int) and the lap times (list of ints) Returns: int: Racer ID with the shortest average lap time min_avg_time = float('inf') racer_id_with_min_avg_time = float('inf') for data in racers_data: racer_id = data[0] lap_times = data[2:] average_time = sum(lap_times) / len(lap_times) if average_time < min_avg_time or (average_time == min_avg_time and racer_id < racer_id_with_min_avg_time): min_avg_time = average_time racer_id_with_min_avg_time = racer_id return racer_id_with_min_avg_time"},{"question":"def caesar_cipher(text: str) -> str: Encodes a given string using a Caesar Cipher with a shift of 3. Parameters: text (str): The input string containing only uppercase letters and spaces. Returns: str: The encoded string. Examples: >>> caesar_cipher('A') 'D' >>> caesar_cipher('XYZ') 'ABC' >>> caesar_cipher('HELLO WORLD') 'KHOOR ZRUOG' >>> caesar_cipher('CAESAR CIPHER') 'FDHVDU FLSKHU'","solution":"def caesar_cipher(text): Encodes a given string using a Caesar Cipher with a shift of 3. Parameters: text (str): The input string containing only uppercase letters and spaces. Returns: str: The encoded string. result = [] for char in text: if char == ' ': result.append(char) else: result.append(chr((ord(char) - ord('A') + 3) % 26 + ord('A'))) return ''.join(result)"},{"question":"def has_pair_with_product(nums: List[int], target: int) -> bool: Returns True if there exists a pair of numbers in the list 'nums' whose product is equal to 'target'. Otherwise, returns False. >>> has_pair_with_product([10, 2, 4, 5, 7], 20) True >>> has_pair_with_product([3, 1, 7, 11], 10) False >>> has_pair_with_product([0, 0, 1, 2], 0) True >>> has_pair_with_product([0, 1, 2, 3], 0) False >>> has_pair_with_product([], 5) False","solution":"def has_pair_with_product(nums, target): Returns True if there exists a pair of numbers in the list 'nums' whose product is equal to 'target'. Otherwise, returns False. if target == 0: return 0 in nums and nums.count(0) > 1 num_set = set() for num in nums: if num != 0 and target % num == 0: complement = target // num if complement in num_set: return True num_set.add(num) return False"},{"question":"def word_frequency(strings): Computes the frequency of each word in a list of strings, ignoring case and punctuation. Args: - strings (list of str): List of strings where each string may contain words separated by spaces. Returns: - dict: Dictionary with words as keys and their frequency as values. >>> word_frequency([\\"Hello world!\\"]) == {'hello': 1, 'world': 1} >>> word_frequency([\\"Hello world!\\", \\"This is a test. Hello again.\\", \\"Is this working? Yes, it is working!\\"]) == {'hello': 2, 'world': 1, 'this': 2, 'is': 3, 'a': 1, 'test': 1, 'again': 1, 'working': 2, 'yes': 1, 'it': 1} >>> word_frequency([\\"\\", \\"\\"]) == {} >>> word_frequency([\\"Hello\\", \\"hello\\"]) == {'hello': 2} >>> word_frequency([\\"Hello, world! Hello... world???\\"]) == {'hello': 2, 'world': 2} >>> word_frequency([\\"123! Apples...\\", \\"123 apples\\", \\"123 APPLES.\\"]) == {'123': 3, 'apples': 3}","solution":"import string def word_frequency(strings): Computes the frequency of each word in a list of strings, ignoring case and punctuation. Args: - strings (list of str): List of strings where each string may contain words separated by spaces. Returns: - dict: Dictionary with words as keys and their frequency as values. frequency_dict = {} translator = str.maketrans('', '', string.punctuation) for s in strings: words = s.translate(translator).lower().split() for word in words: if word in frequency_dict: frequency_dict[word] += 1 else: frequency_dict[word] = 1 return frequency_dict"},{"question":"def rephrase_number(n: int) -> str: Transform the number in a specific pattern of rounding to nearest 10 and reducing digits. >>> rephrase_number(123) \\"000\\" >>> rephrase_number(987) \\"000\\" >>> rephrase_number(555) \\"555\\" >>> rephrase_number(1) \\"0\\" >>> rephrase_number(9) \\"0\\" >>> rephrase_number(1000000000) \\"0000000000\\" >>> rephrase_number(999999999) \\"000000000\\" >>> rephrase_number(43897654) \\"00000000\\" >>> rephrase_number(275349270) \\"000000000\\" >>> rephrase_number(0) \\"0\\"","solution":"def rephrase_number(n): def round_digit(digit): # Round digit to the nearest 10 if digit < 5: return 0 else: return 0 def reduce_digit(digit): reduced = digit - digit // 2 if reduced < 0: return 9 + reduced + 1 return reduced digits = [int(x) for x in str(n)] while True: rounded_digits = [round_digit(digit) for digit in digits] reduced_digits = [reduce_digit(digit) for digit in rounded_digits] if rounded_digits == digits: break digits = rounded_digits return ''.join(map(str, digits))"},{"question":"def rearrange_list(nums: List[int]) -> List[int]: This function takes a list of integers and rearranges it so that all negative numbers appear before the positive numbers (maintaining the original order). >>> rearrange_list([-4, -9, -1, -2]) [-4, -9, -1, -2] >>> rearrange_list([1, 2, 3, 4]) [1, 2, 3, 4] >>> rearrange_list([3, -2, -1, 4, -5]) [-2, -1, -5, 3, 4] >>> rearrange_list([-1, 0, 2, -3, 4]) [-1, -3, 0, 2, 4] >>> rearrange_list([5]) [5] >>> rearrange_list([-5]) [-5] >>> rearrange_list([]) [] >>> rearrange_list([2, 4, 6, 8]) [2, 4, 6, 8] >>> rearrange_list([-2, -4, -6, -8]) [-2, -4, -6, -8] >>> rearrange_list([1, -1, 2, -2, 3, -3]) [-1, -2, -3, 1, 2, 3]","solution":"def rearrange_list(nums): This function takes a list of integers and rearranges it so that all negative numbers appear before the positive numbers (maintaining the original order). negatives = [n for n in nums if n < 0] non_negatives = [n for n in nums if n >= 0] return negatives + non_negatives"},{"question":"def findLongestUniqueSubstring(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple substrings of the same length, returns the one which appears first. >>> findLongestUniqueSubstring('abcabcbb') == 'abc' >>> findLongestUniqueSubstring('bbbbb') == 'b' >>> findLongestUniqueSubstring('pwwkew') == 'wke'","solution":"def findLongestUniqueSubstring(s): Returns the longest substring without repeating characters. If there are multiple substrings of the same length, returns the one which appears first. start = 0 max_length = 0 max_substring = '' char_index_map = {} for end in range(len(s)): if s[end] in char_index_map: # Move the start position right past the last occurrence of the current character to keep substring unique start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"from typing import List def binaryStrings(n: int) -> List[str]: Given an integer n, generate all possible binary strings of length n. Parameters: n (int): The length of the binary strings. Returns: List[str]: List of binary strings of length n in lexicographic order. Examples: >>> binaryStrings(2) [\\"00\\", \\"01\\", \\"10\\", \\"11\\"] >>> binaryStrings(3) [\\"000\\", \\"001\\", \\"010\\", \\"011\\", \\"100\\", \\"101\\", \\"110\\", \\"111\\"] >>> binaryStrings(4) [\\"0000\\", \\"0001\\", \\"0010\\", \\"0011\\", \\"0100\\", \\"0101\\", \\"0110\\", \\"0111\\", \\"1000\\", \\"1001\\", \\"1010\\", \\"1011\\", \\"1100\\", \\"1101\\", \\"1110\\", \\"1111\\"] pass","solution":"def binaryStrings(n): Generate all possible binary strings of length n. Parameters: n (int): The length of the binary strings. Returns: List[str]: List of binary strings of length n in lexicographic order. from itertools import product return [''.join(p) for p in product('01', repeat=n)]"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Check if two strings are anagrams, return True if they are anagrams, and False otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False","solution":"def are_anagrams(s1, s2): Returns True if s1 and s2 are anagrams, False otherwise. # If lengths of the strings are not equal, they cannot be anagrams if len(s1) != len(s2): return False # Create dictionaries to count the frequency of each character in both strings count1 = {} count2 = {} for char in s1: count1[char] = count1.get(char, 0) + 1 for char in s2: count2[char] = count2.get(char, 0) + 1 # Compare frequency dictionaries return count1 == count2"},{"question":"from typing import List def findDuplicates(nums: List[int]) -> List[int]: Finds all numbers in the array that appear exactly twice. Args: nums: List[int] - List of integers where some elements appear twice and others once. Returns: List[int] - List of integers that appear exactly twice. >>> findDuplicates([4,3,2,7,8,2,3,1]) [2, 3] >>> findDuplicates([1, 2, 3, 4, 5]) [] >>> findDuplicates([2, 2, 3, 3, 4, 4]) [2, 3, 4] >>> findDuplicates([1, 1, 2, 2, 3, 3, 4, 4]) [1, 2, 3, 4] >>> findDuplicates([]) [] >>> findDuplicates([1]) [] >>> nums = [i for i in range(1, 50001)] + [i for i in range(1, 50001)] >>> findDuplicates(nums) [i for i in range(1, 50001)]","solution":"def findDuplicates(nums): Finds all numbers in the array that appear exactly twice. Args: nums: List[int] - List of integers where some elements appear twice and others once. Returns: List[int] - List of integers that appear exactly twice. res = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: res.append(abs(num)) else: nums[index] = -nums[index] return res"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the contiguous subarray with the largest sum in the given list of integers. If the list is empty, returns 0. >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([5, 4, 3, 2, 1]) == 15 >>> max_subarray_sum([-3, -2, -1, -4]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([0, 0, 0, 0]) == 0 >>> max_subarray_sum([0, -1, -2, -3]) == 0 >>> max_subarray_sum([0, 1, 2, 3]) == 6","solution":"def max_subarray_sum(nums): Finds the contiguous subarray with the largest sum in the given list of integers. If the list is empty, returns 0. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def check_pairs_with_sum(arr, queries): For each query, check if there exists a pair of elements in the array whose sum equals the query value. Parameters: arr (list): The array of integers. queries (list): The list of query integers. Returns: list: List of strings \\"YES\\" or \\"NO\\" corresponding to each query. >>> check_pairs_with_sum([1, 5, 3, 7, 9], [8, 12, 20]) ['YES', 'YES', 'NO'] >>> check_pairs_with_sum([1, 2, 3, 4, 5], [10, 11, 6]) ['NO', 'NO', 'YES'] >>> check_pairs_with_sum([1, 2, 3], [3, 4, 5, 6]) ['YES', 'YES', 'YES', 'NO'] >>> check_pairs_with_sum([5], [5, 10, 0]) ['NO', 'NO', 'NO'] >>> check_pairs_with_sum([1, 2, 2, 3], [4, 5, 6]) ['YES', 'YES', 'NO']","solution":"def check_pairs_with_sum(arr, queries): For each query, check if there exists a pair of elements in the array whose sum equals the query value. Parameters: arr (list): The array of integers. queries (list): The list of query integers. Returns: list: List of strings \\"YES\\" or \\"NO\\" corresponding to each query. result = [] arr_set = set(arr) for X in queries: found = False for num in arr: complement = X - num if complement in arr_set and complement != num: found = True break result.append(\\"YES\\" if found else \\"NO\\") return result"},{"question":"def exist_path_in_grid(grid: List[str], words: List[str]) -> bool: Determine if there exists a path in the grid that spells out any of the given words. >>> exist_path_in_grid([\\"abce\\", \\"sfcs\\", \\"adee\\"], [\\"abc\\", \\"abfb\\", \\"see\\"]) True >>> exist_path_in_grid([\\"abc\\", \\"def\\", \\"ghi\\"], [\\"xyz\\", \\"kpi\\", \\"ghi\\"]) True >>> exist_path_in_grid([\\"abc\\", \\"def\\", \\"ghi\\"], [\\"xyz\\", \\"kpi\\"]) False >>> exist_path_in_grid([\\"abcd\\" * 12, \\"efgh\\" * 12, \\"ijkl\\" * 12, \\"mnop\\" * 12, \\"qrst\\" * 12, \\"uvwx\\" * 12, \\"yzab\\" * 12, \\"cdef\\" * 12], [\\"abcdefghijklmnopqrstuvwxypabcd\\" * 2]) False >>> exist_path_in_grid([\\"abcdef\\", \\"ghijkl\\", \\"mnopqr\\", \\"stuvwx\\", \\"yzabcd\\", \\"efghij\\"], [\\"yxwvutsrqponmlkjihgfedcba\\"]) False","solution":"def exist_path_in_grid(grid, words): Determine if there exists a path in the grid that spells out any of the given words. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def dfs(x, y, word, index, visited): if index == len(word): return True if not is_valid(x, y) or word[index] != grid[x][y] or visited[x][y]: return False visited[x][y] = True if (dfs(x+1, y, word, index+1, visited) or dfs(x-1, y, word, index+1, visited) or dfs(x, y+1, word, index+1, visited) or dfs(x, y-1, word, index+1, visited)): return True visited[x][y] = False return False for word in words: for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == word[0]: visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))] if dfs(i, j, word, 0, visited): return True return False"},{"question":"def deep_search(data, target): Recursively searches through all levels of a nested dictionary or list to determine if the target value exists. Returns True if the value is found, False otherwise. >>> data = {\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3, \\"f\\": 4}}, \\"g\\": [5, 6, {\\"h\\": 7}]} >>> deep_search(data, 4) True >>> deep_search(data, 8) False >>> deep_search(data, 7) True >>> deep_search(data, \\"e\\") False","solution":"def deep_search(data, target): Recursively searches through all levels of a nested dictionary or list to determine if the target value exists. Returns True if the value is found, False otherwise. if isinstance(data, dict): for value in data.values(): if deep_search(value, target): return True elif isinstance(data, list): for item in data: if deep_search(item, target): return True else: return data == target return False"},{"question":"def maximum_sum_rectangle(matrix): Returns the maximum sum of any rectangle within the given 2D matrix. >>> maximum_sum_rectangle([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 >>> maximum_sum_rectangle([ ... [2, 1, -3, -4, 5], ... [0, 6, 3, 4, 1], ... [2, -2, -1, 4, -5], ... [-3, 3, 1, 0, 3] ... ]) 18 def kadane(arr): Helper function to find the maximum sum of any contiguous subarray using Kadane's algorithm.","solution":"def maximum_sum_rectangle(matrix): Returns the maximum sum of any rectangle within the given 2D matrix. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) max_sum = float('-inf') for left in range(n): temp = [0] * m for right in range(left, n): for i in range(m): temp[i] += matrix[i][right] current_sum = kadane(temp) max_sum = max(max_sum, current_sum) return max_sum def kadane(arr): Helper function to find the maximum sum of any contiguous subarray using Kadane's algorithm. max_so_far = arr[0] max_ending_here = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"from typing import List def sort_by_length(strings: List[str]) -> List[str]: Returns a list of strings ordered by their length in ascending order. If two strings have the same length, their original relative order is maintained. >>> sort_by_length([\\"apple\\", \\"pie\\", \\"bananas\\", \\"hi\\"]) ['hi', 'pie', 'apple', 'bananas'] >>> sort_by_length([\\"hello\\", \\"world\\", \\"!\\", \\"python\\", \\"fun\\"]) ['!', 'fun', 'hello', 'world', 'python'] >>> sort_by_length([\\"a\\", \\"bbb\\", \\"cc\\", \\"dddd\\"]) ['a', 'cc', 'bbb', 'dddd'] pass","solution":"def sort_by_length(strings): Returns a list of strings ordered by their length in ascending order. If two strings have the same length, their original relative order is maintained. return sorted(strings, key=len)"},{"question":"def solve(s: str) -> int: Finds the length of the longest substring without repeating characters. >>> solve(\\"abcabcbb\\") 3 >>> solve(\\"bbbbb\\") 1 >>> solve(\\"pwwkew\\") 3 >>> solve(\\"\\") 0 >>> solve(\\"dvdf\\") 3","solution":"def solve(s: str) -> int: Finds the length of the longest substring without repeating characters. char_map = {} left = 0 max_len = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"def simulate_robot_movements(commands: str) -> tuple: Simulate the movements of a robot on a 2D grid and return its final position and direction. Parameters: commands (str): A string of commands consisting of 'G', 'L', and 'R' Returns: tuple: A tuple (x, y, direction) representing the final position (x, y) and direction of the robot. >>> simulate_robot_movements(\\"GLGR\\") (-1, 1, 'North') >>> simulate_robot_movements(\\"\\") (0, 0, 'North') >>> simulate_robot_movements(\\"G\\") (0, 1, 'North') >>> simulate_robot_movements(\\"L\\") (0, 0, 'West') >>> simulate_robot_movements(\\"R\\") (0, 0, 'East')","solution":"def simulate_robot_movements(commands): Simulates the movements of a robot on a 2D grid and returns its final position and direction. Parameters: - commands (str): A string of commands consisting of 'G', 'L', and 'R' Returns: - tuple: A tuple (x, y, direction) representing the final position (x, y) and direction of the robot. # Initial position and direction x, y = 0, 0 direction_index = 0 # 0: North, 1: East, 2: South, 3: West directions = [\\"North\\", \\"East\\", \\"South\\", \\"West\\"] movements = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Corresponding to N, E, S, W for command in commands: if command == 'G': x += movements[direction_index][0] y += movements[direction_index][1] elif command == 'L': direction_index = (direction_index - 1) % 4 elif command == 'R': direction_index = (direction_index + 1) % 4 return (x, y, directions[direction_index])"},{"question":"class MinStack: Implement a class \`MinStack\` that supports stack operations and can retrieve the minimum element in constant time. The class should support the following operations: push(val): Pushes an item val onto the stack. pop(): Removes the element on the top of the stack. top(): Retrieves the top element of the stack. getMin(): Retrieves the minimum element in the stack. All the operations must be performed in O(1) time complexity. def __init__(self): Initialize your data structure here. def push(self, val: int) -> None: Pushes an item val onto the stack. def pop(self) -> None: Removes the element on the top of the stack. def top(self) -> int: Retrieves the top element of the stack. def getMin(self) -> int: Retrieves the minimum element in the stack. # Unit tests def test_min_stack_operations(): minStack = MinStack() minStack.push(-2) minStack.push(0) minStack.push(-3) assert minStack.getMin() == -3 minStack.pop() assert minStack.top() == 0 assert minStack.getMin() == -2 def test_top_on_empty_stack(): minStack = MinStack() assert minStack.top() is None def test_get_min_on_empty_stack(): minStack = MinStack() assert minStack.getMin() is None def test_push_and_pop_single_element(): minStack = MinStack() minStack.push(1) assert minStack.top() == 1 assert minStack.getMin() == 1 minStack.pop() assert minStack.top() is None assert minStack.getMin() is None def test_mixed_operations(): minStack = MinStack() minStack.push(3) minStack.push(5) assert minStack.getMin() == 3 minStack.push(2) minStack.push(1) assert minStack.getMin() == 1 minStack.pop() assert minStack.getMin() == 2 minStack.pop() assert minStack.getMin() == 3 minStack.pop() assert minStack.top() == 3 assert minStack.getMin() == 3","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def getMin(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"def generate_nested_list(n): Generates a nested list structure based on the input integer n. Args: n : int : positive integer Returns: list : nested list structure Examples: >>> generate_nested_list(1) [1, []] >>> generate_nested_list(2) [1, [2, []]] >>> generate_nested_list(3) [1, [2, [3, []]]] >>> generate_nested_list(4) [1, [2, [3, [4, []]]]]","solution":"def generate_nested_list(n): Generates a nested list structure based on the input integer n. Args: n : int : positive integer Returns: list : nested list structure nested_list = [] current = nested_list for i in range(1, n + 1): current.append(i) new_list = [] current.append(new_list) current = new_list return nested_list"},{"question":"import re from typing import List def sort_alphabets_preserve_numbers(s: str) -> str: Sort the alphabets in the string in alphabetical order while preserving the positions of the numbers. >>> sort_alphabets_preserve_numbers(\\"a1c3b2\\") == \\"a1b3c2\\" >>> sort_alphabets_preserve_numbers(\\"dcba\\") == \\"abcd\\" >>> sort_alphabets_preserve_numbers(\\"1234\\") == \\"1234\\" >>> sort_alphabets_preserve_numbers(\\"\\") == \\"\\" >>> sort_alphabets_preserve_numbers(\\"2z1d3c7b5a6\\") == \\"2a1b3c7d5z6\\" >>> sort_alphabets_preserve_numbers(\\"a\\") == \\"a\\" >>> sort_alphabets_preserve_numbers(\\"1\\") == \\"1\\" >>> sort_alphabets_preserve_numbers(\\"a 3b c1d2\\") == \\"a 3b c1d2\\"","solution":"import re def sort_alphabets_preserve_numbers(s): Returns a string where the alphabets are sorted alphabetically, and the numbers remain in their original positions. # Extract all alphabets and sort them alphabets = sorted(re.findall(r'[a-zA-Z]', s)) # Create a list of the same length as input string result = list(s) # Iterate through result and replace alphabets with sorted ones alpha_index = 0 for i in range(len(result)): if result[i].isalpha(): result[i] = alphabets[alpha_index] alpha_index += 1 return ''.join(result)"},{"question":"def count_occurrences(N: int, arr: List[int], Q: int, queries: List[int]) -> List[int]: Given a list of integers and a series of queries, returns the number of occurrences of each queried integer in the list. Parameters: N (int): The number of elements in the list. arr (list of int): The list of integers. Q (int): The number of queries. queries (list of int): The list of queried integers. Returns: list of int: The results of each query, i.e., number of occurrences. >>> count_occurrences(5, [1, 2, 2, 3, 4], 3, [2, 3, 5]) [2, 1, 0] >>> count_occurrences(1, [1], 1, [1]) [1] >>> count_occurrences(1, [1], 1, [2]) [0]","solution":"def count_occurrences(N, arr, Q, queries): Given a list of integers and a series of queries, returns the number of occurrences of each queried integer in the list. Parameters: N (int): The number of elements in the list. arr (list of int): The list of integers. Q (int): The number of queries. queries (list of int): The list of queried integers. Returns: list of int: The results of each query, i.e., number of occurrences. from collections import Counter counts = Counter(arr) results = [] for query in queries: results.append(counts.get(query, 0)) return results"},{"question":"from typing import List def three_sum(nums: List[int], k: int) -> bool: Write a function that takes an array of integers and a target sum \`k\` and returns true if there are three distinct elements in the array that add up to the target sum \`k\`, and false otherwise. >>> three_sum([1, 2, 4, 5, 6], 10) True >>> three_sum([3, 7, 1, 2, 8], 15) False >>> three_sum([-1, 2, 1, -4, 3], 0) True pass # Unit Test def test_three_sum_example1(): assert three_sum([1, 2, 4, 5, 6], 10) == True # 1 + 2 + 7 = 10 def test_three_sum_example2(): assert three_sum([3, 7, 1, 2, 8], 15) == False # No combination sums to 15 def test_three_sum_example3(): assert three_sum([-1, 2, 1, -4, 3], 0) == True # -1 + 1 + 0 = 0 def test_three_sum_negative_numbers(): assert three_sum([-3, -2, -1, 0, 1, 2, 3], 0) == True # -3 + 1 + 2 = 0 def test_three_sum_no_solution(): assert three_sum([1, 2, 3, 4, 5], 50) == False # No combination sums to 50 def test_three_sum_repeated_elements(): assert three_sum([1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4], 6) == True # 1 + 2 + 3 = 6 def test_three_sum_single_element(): assert three_sum([1], 3) == False # Not enough elements to form a sum def test_three_sum_two_elements(): assert three_sum([1, 2], 3) == False # Not enough elements to form a sum","solution":"def three_sum(nums, k): Returns True if there are three distinct elements in the array that add up to the target sum k, and False otherwise. nums.sort() length = len(nums) for i in range(length - 2): left = i + 1 right = length - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"def add_sparse_matrices(mat1: dict, mat2: dict) -> dict: Adds two sparse matrices represented as dictionaries of dictionaries. Args: mat1 (dict): The first sparse matrix. mat2 (dict): The second sparse matrix. Returns: dict: The resulting sparse matrix.","solution":"def add_sparse_matrices(mat1, mat2): Adds two sparse matrices represented as dictionaries of dictionaries. Args: mat1 (dict): The first sparse matrix. mat2 (dict): The second sparse matrix. Returns: dict: The resulting sparse matrix. result = {} # Update result with entries of mat1 for i, row in mat1.items(): if i not in result: result[i] = {} for j, value in row.items(): result[i][j] = result[i].get(j, 0) + value # Update result with entries of mat2 for i, row in mat2.items(): if i not in result: result[i] = {} for j, value in row.items(): result[i][j] = result[i].get(j, 0) + value # Remove entries with zero values for i in list(result.keys()): for j in list(result[i].keys()): if result[i][j] == 0: del result[i][j] if not result[i]: del result[i] return result"},{"question":"def furthestBuilding(heights: List[int], bricks: int, ladders: int) -> int: Determine the furthest building you can reach using the given bricks and ladders. >>> furthestBuilding([4, 2, 7, 6, 9, 14, 12], 5, 1) 4 >>> furthestBuilding([4, 12, 2, 7, 3, 18, 20, 3, 19], 10, 2) 7 >>> furthestBuilding([1, 2, 3, 4, 5], 5, 0) 4 >>> furthestBuilding([1, 2, 3, 4], 0, 0) 0 >>> furthestBuilding([1, 1000000], 999999, 1) 1 >>> furthestBuilding([10, 20, 30, 40], 0, 3) 3","solution":"import heapq def furthestBuilding(heights, bricks, ladders): Determine the furthest building you can reach using the given bricks and ladders. min_heap = [] for i in range(len(heights) - 1): # Calculate the difference in height diff = heights[i + 1] - heights[i] if diff > 0: heapq.heappush(min_heap, diff) if len(min_heap) > ladders: bricks -= heapq.heappop(min_heap) if bricks < 0: return i return len(heights) - 1"},{"question":"from typing import List, Tuple def longest_unique_subarray(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the length of the longest subarray with unique elements for each query. >>> longest_unique_subarray([1, 2, 1, 3, 4], [(1, 3), (2, 5), (1, 5)]) [2, 4, 4] >>> longest_unique_subarray([1, 2, 3, 4, 5], [(1, 5), (1, 2), (4, 5)]) [5, 2, 2] >>> longest_unique_subarray([1, 2, 2, 3, 4], [(1, 4), (2, 5)]) [2, 3] def process_test_cases(T: int, cases: List[dict]) -> List[List[int]]: Process multiple test cases to determine the longest unique subarrays for each case. >>> process_test_cases(1, [{'N': 5, 'Q': 3, 'array': [1, 2, 1, 3, 4], 'queries': [(1, 3), (2, 5), (1, 5)]}]) [[2, 4, 4]]","solution":"def longest_unique_subarray(arr, queries): results = [] for L, R in queries: L -= 1 # Convert to zero-indexed R -= 1 # Convert to zero-indexed max_len = 0 current_set = set() left_pointer = L for right_pointer in range(L, R + 1): while arr[right_pointer] in current_set: current_set.remove(arr[left_pointer]) left_pointer += 1 current_set.add(arr[right_pointer]) max_len = max(max_len, right_pointer - left_pointer + 1) results.append(max_len) return results def process_test_cases(T, cases): all_results = [] for i in range(T): N, Q = cases[i]['N'], cases[i]['Q'] array = cases[i]['array'] queries = cases[i]['queries'] results = longest_unique_subarray(array, queries) all_results.append(results) return all_results"},{"question":"def separate_even_odd(numbers: List[int]) -> Dict[str, List[int]]: Separates the even and odd numbers from the input list and returns them in a dictionary. Args: numbers (list of int): The list of integers to separate. Returns: dict: A dictionary with keys \\"even\\" and \\"odd\\" containing lists of even and odd numbers respectively. >>> separate_even_odd([1, 2, 3, 4, 5, 6]) {'even': [2, 4, 6], 'odd': [1, 3, 5]} >>> separate_even_odd([10, 11, 12, 13, 14, 15]) {'even': [10, 12, 14], 'odd': [11, 13, 15]}","solution":"def separate_even_odd(numbers): Separates the even and odd numbers from the input list and returns them in a dictionary. Args: numbers (list of int): The list of integers to separate. Returns: dict: A dictionary with keys \\"even\\" and \\"odd\\" containing lists of even and odd numbers respectively. result = {'even': [], 'odd': []} for num in numbers: if num % 2 == 0: result['even'].append(num) else: result['odd'].append(num) return result"},{"question":"def unique_paths_robot(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Find the number of unique paths the robot can take to reach the bottom-right corner of the grid for multiple test cases. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): List of test cases where each test case contains: - Two integers M and N, the dimensions of the grid. - A grid of size MxN containing 0s (empty spaces) and 1s (obstacles). Returns: List[int]: List containing the number of unique paths for each test case modulo 10^9 + 7. Example: >>> unique_paths_robot(2, [(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]), (3, 3, [[0, 1, 0], [0, 1, 0], [0, 0, 0]])]) [2, 1]","solution":"def number_of_unique_paths(grid): Finds the number of unique paths from the top-left to the bottom-right corner of the grid. The robot can move either down or right at any point in time. M = len(grid) N = len(grid[0]) MODULO = 10**9 + 7 if grid[0][0] == 1 or grid[M-1][N-1] == 1: return 0 dp = [[0]*N for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: continue if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MODULO if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MODULO return dp[M-1][N-1] def unique_paths_robot(T, test_cases): results = [] for m, n, grid in test_cases: results.append(number_of_unique_paths(grid)) return results"},{"question":"def can_borrow_book(library_records, book_id, current_date): Check if a book is available for borrowing on the current date. :param library_records: List of dictionaries, where each dictionary represents a borrowed book. :param book_id: String, the unique ID of the book the user wants to borrow. :param current_date: String, the current date in \\"yyyy-mm-dd\\" format. :return: True if the book is available, else the due date as a string. >>> can_borrow_book([{'bookId': \\"1\\", 'dueDate': \\"2023-10-15\\", 'borrowerId': \\"1001\\"}, {'bookId': \\"2\\", 'dueDate': \\"2023-10-20\\", 'borrowerId': \\"1002\\"}], \\"1\\", \\"2023-10-10\\") \\"2023-10-15\\" >>> can_borrow_book([{'bookId': \\"1\\", 'dueDate': \\"2023-10-15\\", 'borrowerId': \\"1001\\"}, {'bookId': \\"2\\", 'dueDate': \\"2023-10-20\\", 'borrowerId': \\"1002\\"}], \\"3\\", \\"2023-10-10\\") True >>> can_borrow_book([], \\"1\\", \\"2023-10-10\\") True >>> can_borrow_book([{'bookId': \\"1\\", 'dueDate': \\"2023-10-05\\", 'borrowerId': \\"1001\\"}, {'bookId': \\"2\\", 'dueDate': \\"2023-10-25\\", 'borrowerId': \\"1002\\"}], \\"1\\", \\"2023-10-01\\") \\"2023-10-05\\"","solution":"def canBorrowBook(libraryRecords, bookId, currentDate): Check if a book is available for borrowing on the current date. :param libraryRecords: List of dictionaries, where each dictionary represents a borrowed book. :param bookId: String, the unique ID of the book the user wants to borrow. :param currentDate: String, the current date in \\"yyyy-mm-dd\\" format. :return: True if the book is available, else the due date as a string. for record in libraryRecords: if record['bookId'] == bookId: return record['dueDate'] return True"},{"question":"from typing import List def is_path_exist(matrix: List[str], N: int, M: int) -> str: Determine if there's a path from 'S' to 'E' in a labyrinth matrix. Args: matrix: List of strings where each string represents a row in the labyrinth. N: Number of rows in the matrix. M: Number of columns in the matrix. Returns: \\"YES\\" if there's a path from 'S' to 'E', \\"NO\\" otherwise. >>> matrix_1 = [ ... \\"#\\", ... \\"#S..#\\", ... \\"#.#\\", ... \\"#..E#\\", ... \\"#\\" ... ] >>> is_path_exist(matrix_1, 5, 5) == \\"YES\\" >>> matrix_2 = [ ... \\"#\\", ... \\"#S#\\", ... \\"#.#\\", ... \\"#..E#\\", ... \\"#\\" ... ] >>> is_path_exist(matrix_2, 5, 5) == \\"NO\\" >>> matrix_3 = [ ... \\"S#E#\\", ... \\"#.....\\", ... \\"#.#.\\", ... \\"#.....\\", ... \\"#.#.#.\\", ... \\"#.....\\" ... ] >>> is_path_exist(matrix_3, 6, 6) == \\"YES\\" >>> matrix_4 = [ ... \\"\\", ... \\"#S#..#\\", ... \\"#..#\\", ... \\"#.E#\\", ... \\"\\" ... ] >>> is_path_exist(matrix_4, 5, 6) == \\"NO\\" >>> matrix_5 = [ ... \\"S#E#\\", ... \\"#........#\\", ... \\"#.#..#\\", ... \\"#.......\\", ... \\"\\" ... ] >>> is_path_exist(matrix_5, 5, 10) == \\"YES\\"","solution":"def is_path_exist(matrix, N, M): from collections import deque def bfs(start): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) visited = set() visited.add(start) while queue: r, c = queue.popleft() if matrix[r][c] == 'E': return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and matrix[nr][nc] != '#' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) return False # Find the starting point 'S' start = None for i in range(N): for j in range(M): if matrix[i][j] == 'S': start = (i, j) break if start: break return \\"YES\\" if bfs(start) else \\"NO\\""},{"question":"from typing import List, Tuple def task_scheduler(tasks: List[Tuple[str, int]]) -> int: Simulates the management of a simple task queue for a single-threaded processor. The processor executes tasks in the order they arrive and returns the total run time of the processor from start until all tasks are completed. Args: tasks (List[Tuple[str, int]]): A list of tuples where each tuple contains a task name (string) and task duration (integer in milliseconds). Returns: int: The total run time of the processor in milliseconds. Example: >>> tasks = [('Task1', 150), ('Task2', 200), ('Task3', 50)] >>> task_scheduler(tasks) 400 >>> tasks2 = [('Alpha', 60), ('Bravo', 90), ('Charlie', 120), ('Delta', 30)] >>> task_scheduler(tasks2) 300","solution":"from typing import List, Tuple def task_scheduler(tasks: List[Tuple[str, int]]) -> int: This function accepts a list of tasks where each task is a tuple containing the task name and its duration in milliseconds. It returns the total runtime of the processor to complete all tasks. total_run_time = 0 for task in tasks: _, duration = task total_run_time += duration return total_run_time # Example usage: tasks = [('Task1', 150), ('Task2', 200), ('Task3', 50)] print(task_scheduler(tasks)) # Should print 400 tasks2 = [('Alpha', 60), ('Bravo', 90), ('Charlie', 120), ('Delta', 30)] print(task_scheduler(tasks2)) # Should print 300"},{"question":"from typing import List, Tuple def shortest_distances_to_school(n: int, m: int, c: int, paths: List[Tuple[int, int]]) -> List[int]: Calculate the shortest distance from any village to the new school. Args: n : int : the number of villages m : int : the number of bidirectional paths c : int : the village where the school is being built paths : List[Tuple[int, int]] : the bidirectional paths between the villages Returns: List[int] : the shortest distances from each village to the village 'c' Examples: >>> shortest_distances_to_school(6, 7, 3, [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (5, 6), (4, 6)]) [1, 1, 0, 1, 2, 2] >>> shortest_distances_to_school(4, 3, 1, [(1, 2), (2, 3), (3, 4)]) [0, 1, 2, 3] from solution import shortest_distances_to_school def test_example_case(): n, m, c = 6, 7, 3 paths = [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (5, 6), (4, 6)] expected_output = [1, 1, 0, 1, 2, 2] assert shortest_distances_to_school(n, m, c, paths) == expected_output def test_case_single_path(): n, m, c = 4, 3, 1 paths = [(1, 2), (2, 3), (3, 4)] expected_output = [0, 1, 2, 3] assert shortest_distances_to_school(n, m, c, paths) == expected_output def test_case_star_shape(): n, m, c = 5, 4, 3 paths = [(3, 1), (3, 2), (3, 4), (3, 5)] expected_output = [1, 1, 0, 1, 1] assert shortest_distances_to_school(n, m, c, paths) == expected_output def test_case_circle_shape(): n, m, c = 4, 4, 2 paths = [(1, 2), (2, 3), (3, 4), (4, 1)] expected_output = [1, 0, 1, 2] assert shortest_distances_to_school(n, m, c, paths) == expected_output def test_case_all_to_one(): n, m, c = 5, 4, 5 paths = [(5, 1), (5, 2), (5, 3), (5, 4)] expected_output = [1, 1, 1, 1, 0] assert shortest_distances_to_school(n, m, c, paths) == expected_output","solution":"from collections import deque def shortest_distances_to_school(n, m, c, paths): # Create adjacency list for the graph adj_list = [[] for _ in range(n + 1)] for u, v in paths: adj_list[u].append(v) adj_list[v].append(u) # Initialize distances with infinity distances = [-1] * (n + 1) # BFS initialization queue = deque([c]) distances[c] = 0 # Perform BFS while queue: current_village = queue.popleft() current_distance = distances[current_village] for neighbor in adj_list[current_village]: if distances[neighbor] == -1: # not visited yet distances[neighbor] = current_distance + 1 queue.append(neighbor) return distances[1:] # we ignore the 0-th index as village numbers are 1-based"},{"question":"class Email: A class to represent and manage email objects. >>> e = Email('john.doe', 'example.com') >>> print(e.full_email) 'john.doe@example.com' >>> e.is_valid() True >>> e2 = Email('john.doe', 'examplecom') >>> e2.is_valid() False >>> e3 = Email('', 'example.com') >>> e3.is_valid() False >>> e = Email('John.Doe', 'Example.COM') >>> e.to_lower() >>> print(e.full_email) 'john.doe@example.com' >>> e = Email('john.doe', 'example.com') >>> e.change_domain('newdomain.org') >>> print(e.full_email) 'john.doe@newdomain.org' >>> e = Email('john.doe', 'example.com') >>> print(str(e)) 'john.doe@example.com' def __init__(self, local_part: str, domain: str): self.local_part = local_part self.domain = domain self.full_email = f\\"{local_part}@{domain}\\" def is_valid(self) -> bool: pass def to_lower(self): pass def change_domain(self, new_domain: str): pass def __str__(self): pass # Unit Tests def test_constructor_and_full_email(): e = Email('john.doe', 'example.com') assert e.full_email == 'john.doe@example.com' def test_is_valid(): e1 = Email('john.doe', 'example.com') assert e1.is_valid() == True e2 = Email('john.doe', 'examplecom') assert e2.is_valid() == False e3 = Email('', 'example.com') assert e3.is_valid() == False def test_to_lower(): e = Email('John.Doe', 'Example.COM') e.to_lower() assert e.full_email == 'john.doe@example.com' def test_change_domain(): e = Email('john.doe', 'example.com') e.change_domain('newdomain.org') assert e.full_email == 'john.doe@newdomain.org' def test_str(): e = Email('john.doe', 'example.com') assert str(e) == 'john.doe@example.com'","solution":"class Email: def __init__(self, local_part, domain): self.local_part = local_part self.domain = domain self.full_email = f\\"{local_part}@{domain}\\" def is_valid(self): Validate the email address based on the simple rules: - local part must not be empty. - domain must contain at least one dot character. if not self.local_part: return False if '.' not in self.domain: return False return True def to_lower(self): Convert the entire email address to lower case. self.local_part = self.local_part.lower() self.domain = self.domain.lower() self.full_email = f\\"{self.local_part}@{self.domain}\\" def change_domain(self, new_domain): Change the domain of the email address. self.domain = new_domain self.full_email = f\\"{self.local_part}@{new_domain}\\" def __str__(self): Return the full email address as a string. return self.full_email"},{"question":"def rearrange_string(s: str) -> str: Rearranges the characters in a string so that all the digits come before the letters. Digits and letters remain in their original relative order. Example: >>> rearrange_string(\\"a1b2c3\\") '123abc' >>> rearrange_string(\\"abc123\\") '123abc' >>> rearrange_string(\\"3a7b1\\") '371ab' >>> rearrange_string(\\"123456\\") '123456' >>> rearrange_string(\\"abcdef\\") 'abcdef' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"1\\") '1' >>> rearrange_string(\\"a\\") 'a'","solution":"def rearrange_string(s): Rearranges the characters in a string so that all the digits come before the letters. Digits and letters remain in their original relative order. Parameters: s (str): The input string containing letters and digits only. Returns: str: The rearranged string with digits first, followed by letters. digits = [char for char in s if char.isdigit()] letters = [char for char in s if char.isalpha()] return ''.join(digits) + ''.join(letters)"},{"question":"def find_pair_with_sum(lst: List[int], target_sum: int) -> bool: Returns True if there are two distinct elements in the list that add up to target_sum, and False otherwise. >>> find_pair_with_sum([2, 4, 3, 5], 7) True >>> find_pair_with_sum([1, 2, 3, 4], 8) False pass # Test cases from solution import find_pair_with_sum def test_pair_exists(): assert find_pair_with_sum([2, 4, 3, 5], 7) == True def test_pair_does_not_exist(): assert find_pair_with_sum([1, 2, 3, 4], 8) == False def test_multiple_pairs_exist(): assert find_pair_with_sum([1, 2, 3, 4, 5], 6) == True def test_same_element_not_counted_twice(): assert find_pair_with_sum([1, 2, 3, 4], 2) == False def test_empty_list(): assert find_pair_with_sum([], 7) == False def test_list_with_one_element(): assert find_pair_with_sum([1], 1) == False def test_list_with_two_elements(): assert find_pair_with_sum([1, 2], 3) == True assert find_pair_with_sum([1, 2], 4) == False def test_negative_numbers(): assert find_pair_with_sum([-1, -2, -3, -4], -5) == True assert find_pair_with_sum([-1, 2, 3, -4], -1) == True def test_large_numbers(): assert find_pair_with_sum([1000000000, 3000000000], 4000000000) == True assert find_pair_with_sum([1000000000, 2000000000], 4000000000) == False","solution":"def find_pair_with_sum(lst, target_sum): Returns True if there are two distinct elements in lst that add up to target_sum, False otherwise seen_numbers = set() for number in lst: required_number = target_sum - number if required_number in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"def quickselect(nums: List[int], k: int) -> int: Returns the k-th largest element in the array using the Quickselect algorithm. :param nums: List[int] - List of integers. :param k: int - An integer to find the k-th largest element. :return: int - The k-th largest element in the array. >>> quickselect([3, 2, 1, 5, 6, 4], 2) 5 >>> quickselect([1], 1) 1 >>> quickselect([3, 2, 2, 3, 1, 4, 4], 2) 4 >>> quickselect([9, 3, 2, 1, 4, 5, 8, 7, 6], 5) 5 >>> quickselect([1, 2, 3, 4, 5, 6], 3) 4 >>> quickselect([6, 5, 4, 3, 2, 1], 2) 5","solution":"def quickselect(nums, k): Returns the k-th largest element in the array using the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = nums[pivot_index] # Move pivot to end nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left # Move all larger elements to the left for i in range(left, right): if nums[i] > nums[right]: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 # Move pivot to its final place nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def select(left, right, k): Returns the k-th largest element in the nums within left..right. if left == right: return nums[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k == pivot_index: return nums[k] elif k < pivot_index: return select(left, pivot_index - 1, k) else: return select(pivot_index + 1, right, k) return select(0, len(nums) - 1, k - 1)"},{"question":"def can_transform_grid(n: int, m: int, grid: List[str]) -> str: Determine if the entire grid can be transformed to all 0s using the specified operation. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid (list of str): initial state of the grid which is a list of strings Returns: str: \\"YES\\" if the grid can be transformed to all 0s, \\"NO\\" otherwise >>> can_transform_grid(3, 3, [\\"110\\", \\"111\\", \\"011\\"]) \\"YES\\" >>> can_transform_grid(2, 2, [\\"11\\", \\"10\\"]) \\"NO\\"","solution":"def can_transform_grid(n, m, grid): Determine if the entire grid can be transformed to all 0s using the specified operation. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid (list of str): initial state of the grid which is a list of strings Returns: str: \\"YES\\" if the grid can be transformed to all 0s, \\"NO\\" otherwise # Check the grid to identify any isolated 1s which cannot be part of a 2x2 sub-grid for i in range(n - 1): for j in range(m - 1): # Looking at a 2x2 grid starting at (i, j) if grid[i][j] == '1' and grid[i][j+1] == '1' and grid[i+1][j] == '1' and grid[i+1][j+1] == '1': continue # Check for remaining 1s for i in range(n): for j in range(m): if grid[i][j] == '1': # Check if this 1 can be part of any 2x2 block possible = False if i > 0 and j > 0 and grid[i-1][j-1] == '1' and grid[i-1][j] == '1' and grid[i][j-1] == '1': possible = True if i > 0 and j < m-1 and grid[i-1][j] == '1' and grid[i-1][j+1] == '1' and grid[i][j+1] == '1': possible = True if i < n-1 and j > 0 and grid[i][j-1] == '1' and grid[i+1][j-1] == '1' and grid[i+1][j] == '1': possible = True if i < n-1 and j < m-1 and grid[i][j+1] == '1' and grid[i+1][j] == '1' and grid[i+1][j+1] == '1': possible = True if not possible: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def can_serve_as_transfer_point(T: int, queries: List[Tuple[int, int, List[Tuple[int, int]], int]]) -> List[str]: Determines if a bus stop serves as a transfer point for each query. Input: - T: number of queries. - queries: List of queries, where each query is represented as a tuple containing: - N: number of bus stops - M: number of direct routes - edges: List of tuples representing direct routes between bus stops - x: the bus stop being queried as the potential transfer point Output: - List of strings \\"YES\\" or \\"NO\\" for each query indicating if the stop can serve as a transfer point. >>> can_serve_as_transfer_point(3, [ (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 3), (6, 7, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6), (5, 6)], 2), (4, 3, [(1, 2), (2, 3), (3, 4)], 4) ]) [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_serve_as_transfer_point(T, queries): from collections import defaultdict, deque def topological_sort(graph, N): in_degree = [0] * (N + 1) for u in graph: for v in graph[u]: in_degree[v] += 1 queue = deque() for i in range(1, N + 1): if in_degree[i] == 0: queue.append(i) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return topo_order results = [] for i in range(T): N, M, edges, x = queries[i] graph = defaultdict(list) rev_graph = defaultdict(list) for u, v in edges: graph[u].append(v) rev_graph[v].append(u) topo_order = topological_sort(graph, N) if not topo_order: results.append(\\"NO\\") continue def bfs_from_node(start, target): visited = [False] * (N + 1) queue = deque([start]) while queue: node = queue.popleft() if node == target: return True visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: queue.append(neighbor) return False if not bfs_from_node(1, N): results.append(\\"NO\\") continue def all_paths_pass_through_x(): if not bfs_from_node(1, x): return False reverse_topo_order = topo_order[::-1] visited = [False] * (N + 1) def dfs(node): if node == x: return True visited[node] = True for neighbor in rev_graph[node]: if not visited[neighbor]: if dfs(neighbor): return True return False for node in reverse_topo_order: if not visited[node]: if node != N: if dfs(node): return False return True if all_paths_pass_through_x(): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def palindromic_words(sentence: str) -> List[str]: Given a string of words separated by spaces, this function finds all palindromic words (words that read the same backward as forward) in the string and returns them in a list. The function is case-insensitive and considers only alphabetic characters. >>> palindromic_words(\\"Madam Arora teaches malayalam\\") ['Madam', 'Arora', 'malayalam'] >>> palindromic_words(\\"Nurses run\\") [] >>> palindromic_words(\\"A man a plan a canal Panama\\") ['A', 'a', 'a'] >>> palindromic_words(\\"Wow! level @@ Noon &\\") ['Wow', 'level', 'Noon'] >>> palindromic_words(\\"\\") [] >>> palindromic_words(\\"X Y Z\\") ['X', 'Y', 'Z']","solution":"def palindromic_words(sentence): Given a string of words separated by spaces, the function returns a list of all palindromic words. import re words = re.findall(r'bw+b', sentence) result = [word for word in words if word.lower() == word.lower()[::-1]] return result"},{"question":"def next_greater_element(arr): Write a function that takes a list of integers \`arr\` and returns a list such that each element in the output list is the next greater element of the corresponding input element. The next greater element of an element x in the list is the first greater element to its right. If there is no greater element to the right, return -1 for that position. The function should aim to achieve efficient performance. >>> next_greater_element([4, 5, 2, 25]) [5, 25, 25, -1] >>> next_greater_element([13, 7, 6, 12]) [-1, 12, 12, -1] >>> next_greater_element([11, 13, 21, 3]) [13, 21, -1, -1] def test_next_greater_element_all_cases(): assert next_greater_element([4, 5, 2, 25]) == [5, 25, 25, -1] assert next_greater_element([13, 7, 6, 12]) == [-1, 12, 12, -1] assert next_greater_element([11, 13, 21, 3]) == [13, 21, -1, -1] assert next_greater_element([1, 3, 2, 4]) == [3, 4, 4, -1] assert next_greater_element([6, 8, 0, 1, 3]) == [8, -1, 1, 3, -1] def test_next_greater_element_single_element(): assert next_greater_element([10]) == [-1] def test_next_greater_element_all_decreasing(): assert next_greater_element([10, 9, 8, 7]) == [-1, -1, -1, -1] def test_next_greater_element_all_increasing(): assert next_greater_element([1, 2, 3, 4]) == [2, 3, 4, -1] def test_next_greater_element_with_duplicates(): assert next_greater_element([2, 2, 2, 2]) == [-1, -1, -1, -1] assert next_greater_element([4, 5, 5, 2]) == [5, -1, -1, -1]","solution":"def next_greater_element(arr): Function to find the next greater element for each element in the array. If there is no greater element to the right, return -1 for that position. Parameters: arr (list): List of integers Returns: list: List of integers where each element is the next greater element of the corresponding input element or -1 if there is no greater element. n = len(arr) res = [-1] * n # Initialize result array with -1 stack = [] for i in range(n): # While stack is not empty and the current element is greater than # element represented by index stored on top of stack, then this # element is next greater element for the element represented by index on top of stack while stack and arr[i] > arr[stack[-1]]: index = stack.pop() res[index] = arr[i] stack.append(i) return res"},{"question":"def generate_report(sales_data): Generates a summary report from the daily sales data. Parameters: sales_data (list): List of dictionaries, each containing 'location', 'items_sold', and 'revenue'. Returns: dict: A summary report containing 'total_items_sold', 'total_revenue', and 'average_revenue_per_item'. pass def test_generate_report_with_normal_data(): sales_data = [ {'location': 'Cafe A', 'items_sold': 120, 'revenue': 300.0}, {'location': 'Cafe B', 'items_sold': 150, 'revenue': 450.0}, {'location': 'Cafe C', 'items_sold': 200, 'revenue': 600.0}, ] expected = { 'total_items_sold': 470, 'total_revenue': 1350.0, 'average_revenue_per_item': 2.87 } assert generate_report(sales_data) == expected def test_generate_report_with_zero_items_sold(): sales_data = [ {'location': 'Cafe A', 'items_sold': 0, 'revenue': 0.0}, {'location': 'Cafe B', 'items_sold': 0, 'revenue': 0.0} ] expected = { 'total_items_sold': 0, 'total_revenue': 0.0, 'average_revenue_per_item': 0.0 } assert generate_report(sales_data) == expected def test_generate_report_with_one_location(): sales_data = [ {'location': 'Cafe A', 'items_sold': 100, 'revenue': 250.0} ] expected = { 'total_items_sold': 100, 'total_revenue': 250.0, 'average_revenue_per_item': 2.50 } assert generate_report(sales_data) == expected def test_generate_report_with_large_numbers(): sales_data = [ {'location': 'Cafe A', 'items_sold': 100000, 'revenue': 250000.0}, {'location': 'Cafe B', 'items_sold': 200000, 'revenue': 500000.0} ] expected = { 'total_items_sold': 300000, 'total_revenue': 750000.0, 'average_revenue_per_item': 2.50 } assert generate_report(sales_data) == expected def test_generate_report_with_no_data(): sales_data = [] expected = { 'total_items_sold': 0, 'total_revenue': 0.0, 'average_revenue_per_item': 0.0 } assert generate_report(sales_data) == expected","solution":"def generate_report(sales_data): Generates a summary report from the daily sales data. Parameters: sales_data (list): List of dictionaries, each containing 'location', 'items_sold', and 'revenue'. Returns: dict: A summary report containing 'total_items_sold', 'total_revenue', and 'average_revenue_per_item'. total_items_sold = sum(location_data['items_sold'] for location_data in sales_data) total_revenue = sum(location_data['revenue'] for location_data in sales_data) average_revenue_per_item = round(total_revenue / total_items_sold, 2) if total_items_sold else 0.0 return { 'total_items_sold': total_items_sold, 'total_revenue': total_revenue, 'average_revenue_per_item': average_revenue_per_item }"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given 2D array (matrix) 90 degrees clockwise. Parameters: matrix (list of list of int): The 2D matrix to be rotated. Returns: list of list of int: The rotated matrix. Examples: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4], [5, 6]]) [[5, 3, 1], [6, 4, 2]]","solution":"def rotate_matrix(matrix): Rotates the given 2D matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The 2D matrix to be rotated. Returns: list of list of int: The rotated matrix. if not matrix or not matrix[0]: return [] rotated_matrix = [] num_rows = len(matrix) num_cols = len(matrix[0]) for col in range(num_cols): new_row = [] for row in reversed(range(num_rows)): new_row.append(matrix[row][col]) rotated_matrix.append(new_row) return rotated_matrix"},{"question":"from typing import List def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in the given string. A palindrome is a string that reads the same forwards and backwards. The function should return the longest substring within the input string that is a palindrome. Examples: >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"] True","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. if not s: return \\"\\" def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes palindrome1 = expand_around_center(i, i) if len(palindrome1) > len(longest): longest = palindrome1 # Even length palindromes palindrome2 = expand_around_center(i, i + 1) if len(palindrome2) > len(longest): longest = palindrome2 return longest"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression with addition and subtraction. Examples: >>> evaluate_expression(\\"3 + 5\\") 8 >>> evaluate_expression(\\"10 - 2 + 3\\") 11 >>> evaluate_expression(\\"1 + 2 - 3 + 4 - 5\\") -1 >>> evaluate_expression(\\"100 - 200 + 300 - 400\\") -200 >>> evaluate_expression(\\"7\\") 7 >>> evaluate_expression(\\" 1 + 1 + 1 \\") 3 >>> evaluate_expression(\\"1 + 2 - 1 \\") 2","solution":"def evaluate_expression(expression): Evaluates a mathematical expression with addition and subtraction. Parameters: expression (str): The input string containing the expression. Returns: int: The evaluated result. tokens = expression.split() result = int(tokens[0]) i = 1 while i < len(tokens): if tokens[i] == '+': result += int(tokens[i + 1]) elif tokens[i] == '-': result -= int(tokens[i + 1]) i += 2 return result"},{"question":"from typing import List, Tuple def min_max_boxes(N: int) -> Tuple[int, int]: Given N coins, returns a tuple containing the minimum and maximum number of boxes Alice can use. >>> min_max_boxes(5) == (3, 5) >>> min_max_boxes(12) == (5, 12) >>> min_max_boxes(25) == (7, 25) >>> min_max_boxes(1) == (1, 1) >>> min_max_boxes(1000000) == (1414, 1000000) def process_input_cases(T: int, cases: List[int]) -> List[str]: Given the number of test cases T and a list of cases where each case represents the number of coins, returns a list of results as strings for each test case. >>> process_input_cases(3, [5, 12, 25]) == [\\"3 5\\", \\"5 12\\", \\"7 25\\"] >>> process_input_cases(1, [1]) == [\\"1 1\\"] >>> process_input_cases(1, [1000000]) == [\\"1414 1000000\\"]","solution":"def min_max_boxes(N): Given N coins, returns a tuple containing the minimum and maximum number of boxes Alice can use. # Maximum number of boxes is N (1 coin in each box) max_boxes = N # Minimum number of boxes can be derived as follows: # If N = k * x where x is coins in each box and k is number of boxes # We need to find the smallest k such that k * (k - 1) / 2 < N <= k * (k + 1) / 2, simplifying for k gives # k >= sqrt(2 * N + 1/4) - 1/2 import math min_boxes = math.ceil(math.sqrt(2 * N + 0.25) - 0.5) return (min_boxes, max_boxes) def process_input_cases(T, cases): results = [] for i in range(T): N = cases[i] min_boxes, max_boxes = min_max_boxes(N) results.append(f\\"{min_boxes} {max_boxes}\\") return results"},{"question":"from typing import List def findLongestChain(pairs: List[List[int]]) -> int: Returns the length of the longest chain of pairs you can achieve. Each pair (a, b) can be in the chain if and only if b < c for every (a, b) and (c, d) in the chain. >>> findLongestChain([[1, 2], [2, 3], [3, 4]]) 2 >>> findLongestChain([[1, 2], [7, 8], [4, 5]]) 3 >>> findLongestChain([]) 0 >>> findLongestChain([[1, 2]]) 1 >>> findLongestChain([[1, 3], [2, 4], [3, 5]]) 1","solution":"def findLongestChain(pairs): Returns the length of the longest chain of pairs you can achieve. pairs.sort(key=lambda x: x[1]) # Sort pairs by their end value current_end = float('-inf') longest_chain = 0 for pair in pairs: if current_end < pair[0]: current_end = pair[1] longest_chain += 1 return longest_chain"},{"question":"def find_task_conflicts(tasks: List[str]) -> List[Tuple[str, str]]: Identify and return any conflicts among the tasks based on their scheduling times. Each task is provided as a string in the format \\"TaskDescription,StartTime,EndTime\\". StartTime and EndTime are in 24-hour format without delimiters (e.g., 0900 for 9:00 AM). Args: tasks (List[str]): List of tasks, each task being a string in the specified format. Returns: List[Tuple[str, str]]: List of tuples, each containing the descriptions of two conflicting tasks. If no conflicts are found, return an empty list. >>> find_task_conflicts([ \\"Meeting,0900,1000\\", \\"Workshop,1000,1100\\" ]) [] >>> find_task_conflicts([ \\"Meeting,0900,1100\\", \\"Workshop,1030,1230\\", \\"Launch,1300,1400\\", \\"Review,1200,1300\\" ]) [('Meeting', 'Workshop')] >>> find_task_conflicts([ \\"EarlyMeeting,0800,0900\\", \\"LateMeeting,0900,1000\\", \\"EarlyWorkshop,0845,0945\\", \\"LateWorkshop,0945,1045\\" ]) [(\\"EarlyMeeting\\", \\"EarlyWorkshop\\"), (\\"LateMeeting\\", \\"EarlyWorkshop\\"), (\\"LateMeeting\\", \\"LateWorkshop\\")]","solution":"from typing import List, Tuple def find_task_conflicts(tasks: List[str]) -> List[Tuple[str, str]]: conflicts = [] # Parse tasks into a more usable structure parsed_tasks = [] for task in tasks: description, start_time, end_time = task.split(',') parsed_tasks.append((description, int(start_time), int(end_time))) # Check for conflicts between tasks for i in range(len(parsed_tasks)): for j in range(i + 1, len(parsed_tasks)): desc1, start1, end1 = parsed_tasks[i] desc2, start2, end2 = parsed_tasks[j] # Check if tasks overlap if (start1 < end2 and start2 < end1): conflicts.append((desc1, desc2)) return conflicts"},{"question":"def generate_diamond(layers: int) -> list: Generates a diamond shape given the number of layers. Parameters: layers (int): number of layers for the diamond. It should be greater than 0. Returns: list: List of strings representing the diamond shape. >>> generate_diamond(1) ['*'] >>> generate_diamond(3) [' * ', ' *** ', '*****', ' *** ', ' * '] >>> generate_diamond(4) [' * ', ' *** ', ' ***** ', '*******', ' ***** ', ' *** ', ' * ']","solution":"def generate_diamond(layers): Generates a diamond shape given the number of layers. Parameters: layers (int): number of layers for the diamond. It should be greater than 0. Returns: list: List of strings representing the diamond shape. # Create the top half of the diamond including the middle diamond = [] for i in range(layers): stars = '*' * (2 * i + 1) spaces = ' ' * (layers - i - 1) diamond.append(f\\"{spaces}{stars}{spaces}\\") # Create the bottom half by reversing the top half excluding the middle bottom_half = diamond[:-1][::-1] # Concatenate both halves diamond.extend(bottom_half) return diamond"},{"question":"def can_transform(A: str, B: str) -> bool: Determines if it is possible to transform string A into string B using the given operations: removing a character from the beginning or end of A, or inserting any character at the beginning or end of A. Args: A (str): The original string. B (str): The target string. Returns: bool: True if A can be transformed into B, False otherwise. Examples: >>> can_transform(\\"abc\\", \\"cab\\") True >>> can_transform(\\"abc\\", \\"abcd\\") True >>> can_transform(\\"abc\\", \\"abd\\") False >>> can_transform(\\"\\", \\"a\\") True # Unit Tests if __name__ == \\"__main__\\": def test_can_transform_exact_match(): assert can_transform(\\"abc\\", \\"abc\\") == True def test_can_transform_reordered_characters(): assert can_transform(\\"abc\\", \\"cab\\") == True assert can_transform(\\"abc\\", \\"bca\\") == True def test_can_transform_extra_characters(): assert can_transform(\\"abc\\", \\"abcd\\") == False assert can_transform(\\"abc\\", \\"abcc\\") == False def test_can_transform_different_characters(): assert can_transform(\\"abc\\", \\"abd\\") == False def test_can_transform_empty_A(): assert can_transform(\\"\\", \\"a\\") == False assert can_transform(\\"\\", \\"\\") == True def test_can_transform_empty_B(): assert can_transform(\\"a\\", \\"\\") == False assert can_transform(\\"\\", \\"\\") == True def test_can_transform_longer_cases(): assert can_transform(\\"a\\" * 1000, \\"a\\" * 1000) == True assert can_transform(\\"a\\" * 500 + \\"b\\" * 500, \\"b\\" * 500 + \\"a\\" * 500) == True assert can_transform(\\"a\\" * 1000, \\"a\\" * 999 + \\"b\\") == False test_can_transform_exact_match() test_can_transform_reordered_characters() test_can_transform_extra_characters() test_can_transform_different_characters() test_can_transform_empty_A() test_can_transform_empty_B() test_can_transform_longer_cases() print(\\"All tests passed!\\")","solution":"def can_transform(A, B): Determines if it is possible to transform string A into string B using the given operations: removing a character from the beginning or end of A, or inserting any character at the beginning or end of A. Args: A (str): The original string. B (str): The target string. Returns: bool: True if A can be transformed into B, False otherwise. from collections import Counter # The condition to transform A into B is that they should have the same # character frequencies. return Counter(A) == Counter(B)"},{"question":"def max_subarray_sum(arr): Returns the sum of the longest contiguous subarray with the maximum sum. Args: arr (List[int]): An array of integers Returns: int: The sum of the longest contiguous subarray with the maximum sum Examples: >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1,2,3,4,-10]) 10 >>> max_subarray_sum([-1,-2,-3,-4]) -1 >>> max_subarray_sum([2,3,-2,-3,4,5]) 9 >>> max_subarray_sum([0,0,0,0]) 0 from solution import max_subarray_sum def test_max_subarray_sum_mixed_sign_numbers(): assert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 def test_max_subarray_sum_all_positive_numbers(): assert max_subarray_sum([1,2,3,4,-10]) == 10 def test_max_subarray_sum_all_negative_numbers(): assert max_subarray_sum([-1,-2,-3,-4]) == -1 def test_max_subarray_sum_mixed_sign_trend(): assert max_subarray_sum([2,3,-2,-3,4,5]) == 9 def test_max_subarray_sum_all_zero(): assert max_subarray_sum([0,0,0,0]) == 0 def test_max_subarray_sum_large_array(): large_array = [1] * 1000 assert max_subarray_sum(large_array) == 1000 def test_max_subarray_sum_single_element(): assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_max_subarray_sum_empty(): assert max_subarray_sum([]) == 0","solution":"def max_subarray_sum(arr): Returns the sum of the longest contiguous subarray with the maximum sum. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def primesLessThan(n: int) -> List[int]: Returns a list of all prime numbers less than n. A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself. Your function should be efficient and able to handle large values of \`n\`. Uses the Sieve of Eratosthenes algorithm for efficient computation. >>> primesLessThan(2) [] >>> primesLessThan(10) [2, 3, 5, 7] >>> primesLessThan(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primesLessThan(1) [] >>> primesLessThan(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] from solution import primesLessThan def test_primesLessThan(): assert primesLessThan(2) == [] assert primesLessThan(10) == [2, 3, 5, 7] assert primesLessThan(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert primesLessThan(1) == [] assert primesLessThan(0) == [] assert primesLessThan(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] def test_primesLessThan_large(): primes_up_to_100 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] assert primesLessThan(100) == primes_up_to_100 # Just to check the function handles larger \`n\` efficiently primes_beneath_200 = primesLessThan(200) assert 197 in primes_beneath_200 assert 199 in primes_beneath_200 assert len(primes_beneath_200) == 46 def test_primesLessThan_edge_cases(): assert primesLessThan(3) == [2] assert primesLessThan(4) == [2, 3] assert primesLessThan(5) == [2, 3] assert primesLessThan(6) == [2, 3, 5]","solution":"def primesLessThan(n): Returns a list of all prime numbers less than n. Uses the Sieve of Eratosthenes algorithm for efficient computation. if n <= 2: return [] # Initialize the sieve sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers # Implement the sieve algorithm for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False # Collect all prime numbers primes = [num for num in range(n) if sieve[num]] return primes"},{"question":"def maxConsecutiveSum(arr, k): Implement a function \`maxConsecutiveSum(arr, k)\` that takes an array of integers \`arr\` and an integer \`k\`, and returns the maximum sum of \`k\` consecutive elements in the array. The function should be efficient, taking care of edge cases where the array length is less than \`k\` by raising an Exception. Parameters: arr (List[int]): The array of integers k (int): The number of consecutive elements Returns: int: The maximum sum of k consecutive elements Example: >>> maxConsecutiveSum([2, 1, 5, 1, 3, 2], 3) 9 >>> maxConsecutiveSum([1, 3, 2, 1, 4, 1, 5, 3], 4) 13 Raises: Exception: \\"Invalid input\\" if the input is invalid pass","solution":"def maxConsecutiveSum(arr, k): Returns the maximum sum of k consecutive elements in the array \`arr\`. If \`arr\` length is smaller than \`k\`, raise an ArgumentException. if len(arr) < k or k <= 0 or len(arr) == 0: raise Exception(\\"Invalid input\\") max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def smallest_subarray_length(arr: List[int], target: int) -> int: Create a function that receives an array of integers and a target integer. The function should return the smallest subarray length for which the sum is greater than or equal to the target. If no such subarray exists, return 0. >>> smallest_subarray_length([2, 3, 1, 2, 4, 3], 7) == 2 >>> smallest_subarray_length([1, 4, 4], 8) == 2 >>> smallest_subarray_length([1, 1, 1, 1, 1, 1, 1], 11) == 0 >>> smallest_subarray_length([1, 2, 3, 4, 5], 11) == 3 >>> smallest_subarray_length([3, 1, 4, 1, 5, 9], 15) == 3","solution":"def smallest_subarray_length(arr, target): Find the smallest subarray length for which the sum is greater than or equal to the target. If no such subarray exists, return 0. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def call_durations(durations: List[int]) -> Tuple[List[int], List[int]]: Given a list of integers representing call durations, this function returns a tuple containing two lists: - The first list should have the top three longest call durations in descending order. - The second list should have the top three shortest call durations in ascending order. If there are fewer than three call durations, return the longest and shortest durations available without raising an error. >>> call_durations([23, 5, 88, 36, 8, 15, 77, 92, 49, 12, 18, 31, 30, 41]) ([92, 88, 77], [5, 8, 12]) >>> call_durations([10, 20]) ([20, 10], [10, 20])","solution":"def call_durations(durations): Returns a tuple containing two lists: - The first list: top three longest call durations in descending order. - The second list: top three shortest call durations in ascending order. durations_sorted_desc = sorted(durations, reverse=True) durations_sorted_asc = sorted(durations) top_three_longest = durations_sorted_desc[:3] top_three_shortest = durations_sorted_asc[:3] return (top_three_longest, top_three_shortest)"},{"question":"def string_transformations(s: str) -> tuple: Takes a string s and returns three transformations: 1. The string in lowercase. 2. The string with the first letter capitalized and the rest in lowercase. 3. The string with each letter's case swapped. >>> string_transformations(\\"Hello, World!\\") ('hello, world!', 'Hello, world!', 'hELLO, wORLD!') >>> string_transformations(\\"PYTHON PYTHON\\") ('python python', 'Python python', 'python python') >>> string_transformations(\\"test\\") ('test', 'Test', 'TEST') >>> string_transformations(\\"123abcXYZ\\") ('123abcxyz', '123abcxyz', '123ABCxyz') >>> string_transformations(\\"\\") ('', '', '') >>> string_transformations(\\"12345!@#%^\\") ('12345!@#%^', '12345!@#%^', '12345!@#%^')","solution":"def string_transformations(s): Takes a string s and prints three transformations: 1. The string in lowercase. 2. The string with the first letter capitalized and the rest in lowercase. 3. The string with each letter's case swapped. lowercase_s = s.lower() capitalized_s = s.capitalize() swappedcase_s = s.swapcase() # Print the transformations print(lowercase_s) print(capitalized_s) print(swappedcase_s) return lowercase_s, capitalized_s, swappedcase_s"},{"question":"def tally_votes(votes): Determines the result of the vote by counting the votes for each candidate and returns the name of the winning candidate. In case of a tie, the candidate whose name comes first alphabetically wins. Parameters: votes (list of str): List of votes where each vote is the name of a candidate. Returns: str: Name of the winning candidate. pass # Unit Tests def test_single_candidate(): votes = [\\"Alice\\"] assert tally_votes(votes) == \\"Alice\\" def test_two_candidates_tie(): votes = [\\"Alice\\", \\"Bob\\", \\"Bob\\", \\"Alice\\"] assert tally_votes(votes) == \\"Alice\\" def test_multiple_candidates(): votes = [\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Charlie\\", \\"Bob\\", \\"Alice\\"] assert tally_votes(votes) == \\"Alice\\" def test_alphabetical_tie(): votes = [\\"Charlie\\", \\"Charlie\\", \\"Bob\\", \\"Bob\\", \\"Alice\\", \\"Alice\\"] assert tally_votes(votes) == \\"Alice\\" def test_multiple_candidates_with_tie(): votes = [\\"Alice\\", \\"Bob\\", \\"Bob\\", \\"Charlie\\", \\"Charlie\\", \\"Alice\\", \\"Alice\\"] assert tally_votes(votes) == \\"Alice\\" def test_all_votes_for_different_candidates(): votes = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dave\\"] assert tally_votes(votes) == \\"Alice\\" def test_no_votes(): votes = [] assert tally_votes(votes) == None","solution":"def tally_votes(votes): Determines the result of the vote by counting the votes for each candidate and returns the name of the winning candidate. In case of a tie, the candidate whose name comes first alphabetically wins. Parameters: votes (list of str): List of votes where each vote is the name of a candidate. Returns: str: Name of the winning candidate. from collections import defaultdict vote_count = defaultdict(int) # Count the votes for each candidate for vote in votes: vote_count[vote] += 1 # Determine the candidate with the most votes, breaking ties alphabetically winner = None for candidate in vote_count: if (winner is None or vote_count[candidate] > vote_count[winner] or (vote_count[candidate] == vote_count[winner] and candidate < winner)): winner = candidate return winner"},{"question":"def calculateFactorial(n: int) -> int: Returns the factorial of the given number n using recursion. >>> calculateFactorial(0) 1 >>> calculateFactorial(1) 1 >>> calculateFactorial(2) 2 >>> calculateFactorial(3) 6 >>> calculateFactorial(4) 24 >>> calculateFactorial(5) 120 >>> calculateFactorial(6) 720 >>> calculateFactorial(10) 3628800","solution":"def calculateFactorial(n): Returns the factorial of the given number n using recursion. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0 or n == 1: return 1 return n * calculateFactorial(n - 1)"},{"question":"def elf_number_spiral(n: int, queries: List[Tuple[int, int]]) -> List[int]: Answer queries about the positions of numbers in an n×n number spiral. Args: n (int): The size of the spiral (an odd number). queries (List[Tuple[int, int]]): A list of queries where each query is a tuple (i, j). Returns: List[int]: A list of integers representing the numbers at the given (i, j) positions in the spiral. Examples: >>> elf_number_spiral(5, [(1, 1), (2, 3), (5, 4)]) [17, 4, 24] >>> elf_number_spiral(3, [(1, 3), (2, 2), (3, 1), (3, 3)]) [3, 1, 7, 9] >>> elf_number_spiral(1, [(1, 1)]) [1] pass import pytest def test_case_1(): n, t = 5, 3 queries = [(1, 1), (2, 3), (5, 4)] expected = [17, 4, 24] assert elf_number_spiral(n, queries) == expected def test_case_2(): n, t = 3, 4 queries = [(1, 3), (2, 2), (3, 1), (3, 3)] expected = [3, 1, 7, 9] assert elf_number_spiral(n, queries) == expected def test_case_3(): n, t = 1, 1 queries = [(1, 1)] expected = [1] assert elf_number_spiral(n, queries) == expected def test_case_large(): # some number to check large input n, t = 7, 3 queries = [(1, 1), (4, 4), (7, 7)] expected = [37, 1, 49] assert elf_number_spiral(n, queries) == expected @pytest.mark.parametrize(\\"n, queries, expected\\", [ (5, [(1, 1), (2, 3), (5, 4)], [17, 4, 24]), (3, [(1, 3), (2, 2), (3, 1), (3, 3)], [3, 1, 7, 9]), (1, [(1, 1)], [1]), (7, [(1, 1), (4, 4), (7, 7)], [37, 1, 49]), ]) def test_elf_number_spiral(n, queries, expected): assert elf_number_spiral(n, queries) == expected","solution":"def generate_spiral_matrix(n): spiral = [[0] * n for _ in range(n)] x, y = n // 2, n // 2 # starting at the center of the matrix spiral[x][y] = 1 number = 2 for layer in range(1, (n // 2) + 1): y += 1 # move right to the first new cell in this layer spiral[x][y] = number number += 1 # Move up - top edge of current layer for _ in range(2 * layer - 1): x -= 1 spiral[x][y] = number number += 1 # Move left - top-left to bottom-left for _ in range(2 * layer): y -= 1 spiral[x][y] = number number += 1 # Move down - bottom-left to bottom-right for _ in range(2 * layer): x += 1 spiral[x][y] = number number += 1 # Move right - bottom-right to top-right for _ in range(2 * layer): y += 1 spiral[x][y] = number number += 1 return spiral def elf_number_spiral(n, queries): spiral = generate_spiral_matrix(n) results = [] for i, j in queries: results.append(spiral[i-1][j-1]) return results"},{"question":"from typing import List def is_unique(s: str) -> bool: Check if a string has all unique characters. >>> is_unique(\\"abcdef\\") True >>> is_unique(\\"aabbcc\\") False >>> is_unique(\\"abcdeff\\") False >>> is_unique(\\"qwerty\\") True pass def longest_unique_string(test_cases: List[List[str]]) -> List[str]: For each test case, return the longest unique string. If none of the strings are unique, return 'NONE'. >>> longest_unique_string([[\\"abcdef\\", \\"abbac\\", \\"abade\\"]]) [\\"abcdef\\"] >>> longest_unique_string([[\\"mmnop\\", \\"qrstuv\\"]]) [\\"qrstuv\\"] >>> longest_unique_string([[\\"aaa\\", \\"bbb\\", \\"ccc\\"]]) [\\"NONE\\"] >>> longest_unique_string([[\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"eeeee\\"]]) [\\"a\\"] >>> longest_unique_string([[\\"abc\\", \\"def\\", \\"ghi\\", \\"abcfghi\\"]]) [\\"abcfghi\\"] >>> longest_unique_string([[\\"asdfghjkl\\", \\"poiuytrewq\\", \\"zxcvbnm\\"]]) [\\"poiuytrewq\\"] pass","solution":"def is_unique(s): Check if all characters in the string are unique. return len(s) == len(set(s)) def longest_unique_string(test_cases): For each test case, return the longest string with all unique characters. If no such string exists, return 'NONE'. results = [] for strings in test_cases: max_len = 0 longest_unique = 'NONE' for s in strings: if is_unique(s): if len(s) > max_len: max_len = len(s) longest_unique = s results.append(longest_unique) return results"},{"question":"def max_consecutive_rooms(M, N, costs): Returns the maximum number of consecutive rooms that can be fixed within a given budget M. pass def solve(test_cases): Processes multiple test cases and returns the results in a list. >>> solve([(10, 6, [2, 1, 3, 4, 5, 6]), (5, 6, [1, 2, 2, 2, 1, 1])]) == [4, 3] >>> solve([(5, 5, [0, 0, 0, 0, 0])]) == [5] >>> solve([(1, 1, [1]), (0, 1, [0])]) == [1, 1] >>> solve([(0, 5, [1, 2, 3, 4, 5])]) == [0] pass","solution":"def max_consecutive_rooms(M, N, costs): Returns the maximum number of consecutive rooms that can be fixed within a given budget M. max_rooms = 0 current_sum = 0 start = 0 for end in range(N): current_sum += costs[end] while current_sum > M: current_sum -= costs[start] start += 1 max_rooms = max(max_rooms, end - start + 1) return max_rooms def solve(test_cases): Processes multiple test cases and returns the results in a list. results = [] for M, N, costs in test_cases: result = max_consecutive_rooms(M, N, costs) results.append(result) return results"},{"question":"def search_range(nums: List[int], target: int) -> List[int]: Given an array of integers, nums, and an integer target, return the starting and ending position of a given target value in a non-decreasing array. If the target is not found in the array, return [-1, -1]. >>> search_range([5, 7, 7, 8, 8, 10], 8) == [3, 4] >>> search_range([5, 7, 7, 8, 8, 10], 6) == [-1, -1] >>> search_range([], 0) == [-1, -1] >>> search_range([1], 1) == [0, 0]","solution":"def search_range(nums, target): def find_left(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] < target: low = mid + 1 else: high = mid - 1 return low def find_right(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] <= target: low = mid + 1 else: high = mid - 1 return high left_index = find_left(nums, target) right_index = find_right(nums, target) if left_index <= right_index: return [left_index, right_index] else: return [-1, -1]"},{"question":"def is_strong_password(password: str) -> bool: Returns True if the password is strong. A strong password has at least one uppercase letter, one lowercase letter, one digit, and one special character. >>> is_strong_password(\\"\\") False >>> is_strong_password(\\"weakpass1@\\") False >>> is_strong_password(\\"WEAKPASS1@\\") False >>> is_strong_password(\\"Weakpass@\\") False >>> is_strong_password(\\"Weakpass1\\") False >>> is_strong_password(\\"Strong1@\\") True >>> is_strong_password(\\"S1@\\") False >>> is_strong_password(\\"A1a!\\") True >>> is_strong_password(\\"Weakpass1!\\") True >>> is_strong_password(\\"Weakpass1@\\") True >>> is_strong_password(\\"Weakpass1#\\") True >>> is_strong_password(\\"Weakpass1\\") True >>> is_strong_password(\\"Weakpass1%\\") True >>> is_strong_password(\\"Weakpass1^\\") True >>> is_strong_password(\\"Weakpass1&\\") True >>> is_strong_password(\\"Weakpass1*\\") True","solution":"import re def is_strong_password(password): Returns True if the password is strong. A strong password has at least one uppercase letter, one lowercase letter, one digit, and one special character. if len(password) < 1: return False has_upper = re.search(r'[A-Z]', password) is not None has_lower = re.search(r'[a-z]', password) is not None has_digit = re.search(r'd', password) is not None has_special = re.search(r'[!@#%^&*]', password) is not None return has_upper and has_lower and has_digit and has_special"},{"question":"def determine_winner(T: int, test_cases: List[Dict[str, Union[int, List[int]]]]) -> List[str]: Determine the winner of the programming competition between John and Jane. Args: T (int): Number of test cases test_cases (List[Dict[str, Union[int, List[int]]]]): Test cases containing N, John's scores, and Jane's scores Returns: List[str]: Result for each test case (\\"John\\", \\"Jane\\", or \\"Draw\\") >>> determine_winner(2, [ {'N': 3, 'John': [5, 6, 7], 'Jane': [4, 5, 6]}, {'N': 3, 'John': [2, 4, 8], 'Jane': [9, 1, 3]} ]) [\\"John\\", \\"Draw\\"] >>> determine_winner(1, [ {'N': 3, 'John': [5, 5, 5], 'Jane': [5, 5, 5]} ]) [\\"Draw\\"]","solution":"def determine_winner(T, test_cases): results = [] for case in test_cases: N = case['N'] John_scores = case['John'] Jane_scores = case['Jane'] total_John = sum(John_scores) total_Jane = sum(Jane_scores) max_John_boost = max(total_John + John_scores[i] for i in range(N)) max_Jane_boost = max(total_Jane + Jane_scores[i] for i in range(N)) if max_John_boost > max_Jane_boost: results.append(\\"John\\") elif max_John_boost < max_Jane_boost: results.append(\\"Jane\\") else: results.append(\\"Draw\\") return results # Example Usage T = 2 test_cases = [ {'N': 3, 'John': [5, 6, 7], 'Jane': [4, 5, 6]}, {'N': 3, 'John': [2, 4, 8], 'Jane': [9, 1, 3]} ] print(determine_winner(T, test_cases))"},{"question":"from typing import List, Tuple def find_triplets(nums: List[int], target: int) -> List[Tuple[int, int, int]]: Find all unique triplets in a list which sum to the target. Each triplet in the result must be an ordered tuple (a, b, c) such that \`a <= b <= c\` and the triplets themselves must be ordered in ascending order. The solution set must not contain duplicate triplets. Example: >>> find_triplets([1, 0, -1, 2, -1, -4], 0) [(-1, -1, 2), (-1, 0, 1)] >>> find_triplets([], 0) [] >>> find_triplets([1, 2, 3, 4, 5], 9) [(1, 3, 5), (2, 3, 4)] pass # Test cases def test_no_elements(): assert find_triplets([], 0) == [] def test_no_triplets(): assert find_triplets([1, 2, 3, 4, 5], 20) == [] def test_example_case(): assert find_triplets([1, 0, -1, 2, -1, -4], 0) == [(-1, -1, 2), (-1, 0, 1)] def test_one_triplet(): assert find_triplets([1, 2, 3, 4, 5], 9) == [(1, 3, 5), (2, 3, 4)] def test_multiple_triplets(): assert find_triplets([0, -1, 2, -3, 1], 0) == [(-3, 1, 2), (-1, 0, 1)] def test_duplicates(): assert find_triplets([-1, 0, 1, 2, -1, -4], 0) == [(-1, -1, 2), (-1, 0, 1)] def test_large_case(): nums = [1] * 1000 + [-1] * 1000 assert find_triplets(nums, 0) == []","solution":"from typing import List, Tuple def find_triplets(nums: List[int], target: int) -> List[Tuple[int, int, int]]: nums.sort() triplets = [] n = len(nums) for i in range(n-2): # Skip the same elements to avoid duplicate triplets. if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, n - 1 while left < right: temp_sum = nums[i] + nums[left] + nums[right] if temp_sum == target: triplets.append((nums[i], nums[left], nums[right])) left += 1 right -= 1 # Skip the same elements to avoid duplicate triplets. while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif temp_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"from typing import List, Tuple def max_possible_sum(N: int, M: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Given an undirected graph with N nodes and M edges, each node initially holds a value (which could be positive or negative). Find the maximum possible sum of values you can achieve by performing a series of operations where an operation consists of choosing two nodes u and v that are connected by an edge and swapping their values. >>> max_possible_sum(1, 0, [5], []) == 5 >>> max_possible_sum(2, 1, [1, -2], [(1, 2)]) == 1 >>> max_possible_sum(3, 0, [1, -2, 3], []) == 4 >>> max_possible_sum(5, 4, [1, -2, 3, -4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]) == 9 >>> max_possible_sum(3, 2, [-1, -2, -3], [(1, 2), (2, 3)]) == 0 >>> max_possible_sum(4, 4, [1, 2, 3, 4], [(1, 2), (1, 3), (1, 4), (2, 3)]) == 10","solution":"def max_possible_sum(N, M, values, edges): from collections import defaultdict # Helper function for DFS to find connected components def dfs(node, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.append(current) for neighbor in graph[current]: if neighbor not in visited: stack.append(neighbor) # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() components = [] # Find all connected components for i in range(1, N + 1): if i not in visited: component = [] dfs(i, component) components.append(component) # Calculate maximum possible sum by taking only the positive values in each component total_sum = 0 for component in components: total_sum += sum(value for node in component for value in [values[node - 1]] if value > 0) return total_sum"},{"question":"def is_toeplitz_matrix(matrix: List[List[int]]) -> bool: Returns True if the matrix is a Toeplitz matrix, otherwise False. >>> is_toeplitz_matrix([ ... [1, 2, 3, 4], ... [5, 1, 2, 3], ... [6, 5, 1, 2], ... [7, 6, 5, 1] ... ]) True >>> is_toeplitz_matrix([ ... [1, 2, 3, 4], ... [5, 1, 9, 3], ... [6, 5, 1, 2], ... [7, 6, 5, 1] ... ]) False >>> is_toeplitz_matrix([ ... [1, 2, 3], ... [4, 1, 2], ... [7, 4, 1] ... ]) True >>> is_toeplitz_matrix([ ... [1, 2, 3], ... [4, 1, 2], ... [7, 5, 1] ... ]) False >>> is_toeplitz_matrix([[1]]) True >>> is_toeplitz_matrix([[1, 2, 3, 4, 5]]) True >>> is_toeplitz_matrix([[1], [2], [3], [4], [5]]) True >>> is_toeplitz_matrix([]) True >>> is_toeplitz_matrix([[]]) True","solution":"def is_toeplitz_matrix(matrix): Returns True if the matrix is a Toeplitz matrix, otherwise False. rows = len(matrix) if rows == 0: return True cols = len(matrix[0]) for row in range(rows - 1): for col in range(cols - 1): if matrix[row][col] != matrix[row + 1][col + 1]: return False return True"},{"question":"def tribonacci(n: int) -> int: Compute the nth Tribonacci number. The Tribonacci sequence is defined as: - T(0) = 0 - T(1) = 1 - T(2) = 1 - T(n) = T(n - 1) + T(n - 2) + T(n - 3) for n >= 3 :param n: An integer (0 ≤ n ≤ 37). :return: The nth Tribonacci number. pass def test_tribonacci_base_cases(): assert tribonacci(0) == 0 assert tribonacci(1) == 1 assert tribonacci(2) == 1 def test_tribonacci_first_non_base_case(): assert tribonacci(3) == 2 def test_tribonacci_subsequent_cases(): assert tribonacci(4) == 4 assert tribonacci(5) == 7 assert tribonacci(6) == 13 def test_tribonacci_larger_cases(): assert tribonacci(10) == 149 assert tribonacci(20) == 66012 assert tribonacci(25) == 1389537 def test_tribonacci_max_case(): assert tribonacci(37) == 2082876103","solution":"def tribonacci(n: int) -> int: Compute the nth Tribonacci number. The Tribonacci sequence is defined as: - T(0) = 0 - T(1) = 1 - T(2) = 1 - T(n) = T(n - 1) + T(n - 2) + T(n - 3) for n >= 3 :param n: An integer (0 ≤ n ≤ 37). :return: The nth Tribonacci number. if n == 0: return 0 if n == 1 or n == 2: return 1 # Initializing the first three tribonacci numbers trib_0, trib_1, trib_2 = 0, 1, 1 # Using an iterative approach to compute the nth tribonacci number for _ in range(3, n + 1): trib_next = trib_0 + trib_1 + trib_2 trib_0, trib_1, trib_2 = trib_1, trib_2, trib_next return trib_2"},{"question":"from typing import List, Tuple def find_special_subsets(t: int, test_cases: List[Tuple[Tuple[int, int, int], List[int]]]) -> List[str]: Determine if there exists a subset of exactly k integers whose sum equals s for each test case. Args: t : int : the number of test cases test_cases : List[Tuple[Tuple[int, int, int], List[int]]] : List of test cases, each containing a tuple of n, k, s and a list of integers Returns: List[str] : List of \\"YES\\" or \\"NO\\" for each test case >>> find_special_subsets(4, [[(5, 3, 9), [1, 2, 3, 4, 5]], [(4, 2, 7), [1, 4, 2, 6]], [(6, 4, 15), [2, 3, 5, 7, 8, 9]], [(3, 1, 10), [10, 20, 30]]]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> find_special_subsets(1, [[(5, 3, 1), [1, 1, 1, 1, 1]]]) [\\"NO\\"] from solution import find_special_subsets def test_case_1(): t = 4 test_cases = [ [(5, 3, 9), [1, 2, 3, 4, 5]], [(4, 2, 7), [1, 4, 2, 6]], [(6, 4, 15), [2, 3, 5, 7, 8, 9]], [(3, 1, 10), [10, 20, 30]] ] expected = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert find_special_subsets(t, test_cases) == expected def test_case_2(): t = 1 test_cases = [ [(5, 2, 7), [1, 2, 3, 4, 5]] ] expected = [\\"YES\\"] assert find_special_subsets(t, test_cases) == expected def test_case_3(): t = 1 test_cases = [ [(5, 3, 1), [1, 1, 1, 1, 1]], ] expected = [\\"NO\\"] assert find_special_subsets(t, test_cases) == expected def test_case_4(): t = 1 test_cases = [ [(6, 3, 12), [3, 3, 3, 3, 3, 3]] ] expected = [\\"NO\\"] assert find_special_subsets(t, test_cases) == expected def test_case_5(): t = 2 test_cases = [ [(4, 2, 5), [2, 2, 1, 3]], [(4, 3, 6), [1, 2, 3, 4]], ] expected = [\\"YES\\", \\"YES\\"] assert find_special_subsets(t, test_cases) == expected","solution":"from itertools import combinations def find_special_subsets(t, test_cases): results = [] for i in range(t): n, k, s = test_cases[i][0] arr = test_cases[i][1] found = False for comb in combinations(arr, k): if sum(comb) == s: found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longest_unique_substring(s: str) -> str: Design a function that takes a string \`s\` and returns the longest substring without repeating characters. The function should return the substring itself and not its length. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> longest_unique_substring(\\"dvdf\\") \\"vdf\\"","solution":"def longest_unique_substring(s): Function to find the longest substring without repeating characters. Parameters: s (str): Input string Returns: str: Longest substring without repeating characters n = len(s) if n == 0: return \\"\\" start, max_len = 0, 0 longest = \\"\\" used_chars = {} for i in range(n): if s[i] in used_chars and start <= used_chars[s[i]]: start = used_chars[s[i]] + 1 else: if i - start + 1 > max_len: max_len = i - start + 1 longest = s[start:i+1] used_chars[s[i]] = i return longest"},{"question":"def smallest_lexicographical_rotation(s: str) -> str: Determines the smallest lexicographical rotation of the string s and returns it. >>> smallest_lexicographical_rotation(\\"bca\\") \\"abc\\" >>> smallest_lexicographical_rotation(\\"abcd\\") \\"abcd\\" >>> smallest_lexicographical_rotation(\\"cba\\") \\"acb\\" >>> smallest_lexicographical_rotation(\\"a\\") \\"a\\" >>> smallest_lexicographical_rotation(\\"ba\\") \\"ab\\" >>> smallest_lexicographical_rotation(\\"zxy\\") \\"xyz\\" >>> smallest_lexicographical_rotation(\\"xyzxyz\\") \\"xyzxyz\\"","solution":"def smallest_lexicographical_rotation(s): Returns the smallest lexicographical rotation of the string s. n = len(s) rotations = [s[i:] + s[:i] for i in range(n)] return min(rotations) # Example Usage # s = \\"bca\\" # Output should be \\"abc\\" smallest_lexicographical_rotation(\\"bca\\")"},{"question":"from typing import List, Tuple def zero_sum_pairs(numbers: List[int]) -> List[Tuple[int, int]]: This function accepts a list of integers and returns a list of tuples containing pairs of indices where the sum of the corresponding values at those indices is zero with a time complexity of at most O(n log n). >>> zero_sum_pairs([1, -1, 2, -2, 3, -3]) [(0, 1), (2, 3), (4, 5)] >>> zero_sum_pairs([3, 1, -4, -1, -3, 2]) [(0, 4), (1, 3)] >>> zero_sum_pairs([1, 2, 3, 4, 5]) [] pass # Unit tests def test_example_cases(): numbers = [1, -1, 2, -2, 3, -3] result = zero_sum_pairs(numbers) assert result == [(0, 1), (2, 3), (4, 5)] def test_no_pairs(): numbers = [1, 2, 3, 4, 5] result = zero_sum_pairs(numbers) assert result == [] def test_with_duplicates(): numbers = [3, 1, -4, -1, -3, 2] result = zero_sum_pairs(numbers) assert result == [(0, 4), (1, 3)] def test_single_pair(): numbers = [1, -1] result = zero_sum_pairs(numbers) assert result == [(0, 1)] def test_multiple_pairs(): numbers = [0, 0, 0, 0] result = zero_sum_pairs(numbers) assert result == [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)] def test_large_numbers(): numbers = [100000, -100000, 0] result = zero_sum_pairs(numbers) assert result == [(0, 1)] def test_unsorted_output(): numbers = [2, -1, -2, 1] result = zero_sum_pairs(numbers) assert result == [(0, 2), (1, 3)]","solution":"def zero_sum_pairs(numbers): This function returns a list of tuples containing pairs of indices where the sum of the corresponding values at those indices is zero. num_to_indices = {} pairs = [] for index, num in enumerate(numbers): if -num in num_to_indices: for partner_index in num_to_indices[-num]: pairs.append((partner_index, index)) if num in num_to_indices: num_to_indices[num].append(index) else: num_to_indices[num] = [index] pairs.sort() return pairs"},{"question":"def count_unique_chars(strings: List[str]) -> List[int]: Takes an array of strings and returns an array of integers representing the count of unique characters in each string. >>> count_unique_chars([\\"hello\\", \\"world\\", \\"abc\\", \\"aabbcc\\"]) [4, 5, 3, 3] >>> count_unique_chars([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) [1, 2, 3, 4]","solution":"def count_unique_chars(strings): Takes an array of strings and returns an array of integers representing the count of unique characters in each string. return [len(set(string)) for string in strings]"},{"question":"def distributeVegetables(harvested: [int], num_boxes: int) -> dict: Distributes harvested vegetables into boxes evenly. Parameters: harvested (list): List of integers representing the number of each type of vegetable harvested. num_boxes (int): The number of boxes to pack. Returns: dict: A dictionary with distribution details. >>> distributeVegetables([10, 20, 30, 40, 50], 5) {'carrots': {'per_box': 2, 'leftover': 0}, 'tomatoes': {'per_box': 4, 'leftover': 0}, 'cucumbers': {'per_box': 6, 'leftover': 0}, 'potatoes': {'per_box': 8, 'leftover': 0}, 'bell_peppers': {'per_box': 10, 'leftover': 0}} >>> distributeVegetables([12, 25, 37, 47, 53], 4) {'carrots': {'per_box': 3, 'leftover': 0}, 'tomatoes': {'per_box': 6, 'leftover': 1}, 'cucumbers': {'per_box': 9, 'leftover': 1}, 'potatoes': {'per_box': 11, 'leftover': 3}, 'bell_peppers': {'per_box': 13, 'leftover': 1}}","solution":"def distributeVegetables(harvested, num_boxes): Distributes harvested vegetables into boxes evenly. Parameters: harvested (list): List of integers representing the number of each type of vegetable harvested. num_boxes (int): The number of boxes to pack. Returns: dict: A dictionary with distribution details. vegetable_types = [\\"carrots\\", \\"tomatoes\\", \\"cucumbers\\", \\"potatoes\\", \\"bell_peppers\\"] distribution = {} for i, vegetable in enumerate(vegetable_types): per_box = harvested[i] // num_boxes leftover = harvested[i] % num_boxes distribution[vegetable] = {'per_box': per_box, 'leftover': leftover} return distribution"},{"question":"def sort_integers(input_string: str) -> List[int]: Converts a space-separated string of integers to a list of integers, sorts it in ascending order, and returns the sorted list. :param input_string: A string containing space-separated integers. :return: A sorted list of integers. >>> sort_integers(\\"4 1 3 5 2\\") [1, 2, 3, 4, 5] >>> sort_integers(\\"-1 -3 -2 -4 0\\") [-4, -3, -2, -1, 0] >>> sort_integers(\\"3 -1 2 0 -2 1\\") [-2, -1, 0, 1, 2, 3] >>> sort_integers(\\"1 3 3 2 2 1\\") [1, 1, 2, 2, 3, 3] >>> sort_integers(\\"7\\") [7]","solution":"def sort_integers(input_string): Converts a space-separated string of integers to a list of integers, sorts it in ascending order, and returns the sorted list. :param input_string: A string containing space-separated integers. :return: A sorted list of integers. # Convert the input string into a list of integers integer_list = list(map(int, input_string.split())) # Sort the list in ascending order integer_list.sort() # Return the sorted list return integer_list"},{"question":"def remove_leading_zeros(s: str) -> str: Removes all leading zeros from the string s. If the string is composed entirely of zeros, return a single \\"0\\". :param s: str - A string that contains only digits (0-9) :return: str - Resultant string with leading zeros removed >>> remove_leading_zeros(\\"000123\\") == \\"123\\" >>> remove_leading_zeros(\\"0000\\") == \\"0\\" >>> remove_leading_zeros(\\"100200\\") == \\"100200\\" >>> remove_leading_zeros(\\"0012300450067\\") == \\"12300450067\\" >>> remove_leading_zeros(\\"0\\") == \\"0\\" >>> remove_leading_zeros(\\"123456789\\") == \\"123456789\\" >>> remove_leading_zeros(\\"5\\") == \\"5\\" >>> remove_leading_zeros(\\"00000000000001\\") == \\"1\\"","solution":"def remove_leading_zeros(s): Removes all leading zeros from the string s. If the string is composed entirely of zeros, return a single \\"0\\". :param s: str - A string that contains only digits (0-9) :return: str - Resultant string with leading zeros removed stripped_string = s.lstrip('0') return stripped_string if stripped_string else '0'"},{"question":"def to_snake_case(s: str) -> str: Converts a given string into snake_case. Parameters: s (str): The input string to be converted. Returns: str: The converted snake_case string. Examples: >>> to_snake_case(\\"thisIsAnExample\\") \\"this_is_an_example\\" >>> to_snake_case(\\"Hello World\\") \\"hello_world\\" >>> to_snake_case(\\"snakeCase\\") \\"snake_case\\"","solution":"def to_snake_case(s): Converts a given string into snake_case. Parameters: s (str): The input string to be converted. Returns: str: The converted snake_case string. result = \\"\\" previous_char_space = False for i, char in enumerate(s): if char.isupper(): if i != 0 and not previous_char_space: result += \\"_\\" result += char.lower() previous_char_space = False elif char == \\" \\": if previous_char_space: continue result += \\"_\\" previous_char_space = True else: result += char previous_char_space = False return result.strip('_')"},{"question":"def is_valid_parentheses(T, test_cases): Determines if each string of parentheses in the test cases is valid. >>> is_valid_parentheses(1, [\\"()\\"]) [\\"Yes\\"] >>> is_valid_parentheses(6, [\\"()\\", \\"()[]{}\\", \\"(]\\", \\"([)]\\", \\"{[()]}\\", \\"{{[[(())]]}}\\"]) [\\"Yes\\", \\"Yes\\", \\"No\\", \\"No\\", \\"Yes\\", \\"Yes\\"]","solution":"def is_valid_parentheses(T, test_cases): def is_valid(s): stack = [] matching = {')': '(', '}': '{', ']': '['} for char in s: if char in matching: top_element = stack.pop() if stack else '#' if matching[char] != top_element: return False else: stack.append(char) return not stack results = [] for s in test_cases: if is_valid(s): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def single_number(arr: List[int]) -> int: Finds the element that appears exactly once in an array where every other element appears three times. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([-1, -1, -1, -2]) -2 >>> single_number([-1, -1, -1, 3, 3, 3, 4]) 4 >>> single_number([3000, 3000, 3000, 777]) 777 >>> single_number([-999]) -999","solution":"def single_number(arr): Finds the element that appears exactly once in an array where every other element appears three times. result = 0 for i in range(32): bit_sum = 0 for num in arr: bit_sum += (num >> i) & 1 bit_sum %= 3 if bit_sum != 0: result |= bit_sum << i if result >= 2**31: result -= 2**32 return result"},{"question":"def min_moves_to_unlock(start_sequence: str, target_sequence: str) -> int: Determine the minimum number of moves required to unlock the safe based on given start and target sequences. Args: start_sequence (str): the starting sequence of the lock. target_sequence (str): the target sequence to unlock the lock. Returns: int: Minimum number of moves required to unlock the lock. Examples: >>> min_moves_to_unlock('1234', '5678') 16 >>> min_moves_to_unlock('0000', '9999') 4","solution":"def min_moves_to_unlock(start_sequence: str, target_sequence: str) -> int: total_moves = 0 for s, t in zip(start_sequence, target_sequence): s_digit = int(s) t_digit = int(t) diff = abs(s_digit - t_digit) total_moves += min(diff, 10 - diff) return total_moves"},{"question":"from typing import List def sum_of_unique_prime_factors(n: int) -> int: Returns the sum of all unique prime factors of n. >>> sum_of_unique_prime_factors(7) 7 >>> sum_of_unique_prime_factors(13) 13 >>> sum_of_unique_prime_factors(28) 9 >>> sum_of_unique_prime_factors(30) 10 >>> sum_of_unique_prime_factors(1) 0 >>> sum_of_unique_prime_factors(0) 0 >>> sum_of_unique_prime_factors(-5) 0 >>> sum_of_unique_prime_factors(60) 10 >>> sum_of_unique_prime_factors(100) 7 >>> sum_of_unique_prime_factors(29) 29","solution":"def sum_of_unique_prime_factors(n): Returns the sum of all unique prime factors of n. if n <= 1: return 0 prime_factors = set() divisor = 2 while n > 1: while n % divisor == 0: prime_factors.add(divisor) n //= divisor divisor += 1 if divisor * divisor > n and n > 1: prime_factors.add(n) break return sum(prime_factors)"},{"question":"def apply_discounts(prices: List[float], discounts: List[float]) -> List[float]: Calculates the final prices after applying the discounts. Arguments: prices : list of float/int : original prices of items discounts : list of float/int : discount percentages Returns: list of float : final prices after discounts >>> apply_discounts([100, 50, 200], [10, 20, 0]) [90.0, 40.0, 200.0] >>> apply_discounts([100, 200], [0, 0]) [100.0, 200.0] >>> apply_discounts([100, 50, 200], [100, 100, 100]) [0.0, 0.0, 0.0] >>> apply_discounts([150, 80, 30], [25, 50, 10]) [112.5, 40.0, 27.0] >>> apply_discounts([], []) [] >>> apply_discounts([100, 100, 100], [0, 50, 100]) [100.0, 50.0, 0.0]","solution":"def apply_discounts(prices, discounts): Calculates the final prices after applying the discounts. Arguments: prices : list of float/int : original prices of items discounts : list of float/int : discount percentages Returns: list of float : final prices after discounts final_prices = [] for price, discount in zip(prices, discounts): final_price = price - (price * discount / 100) final_prices.append(final_price) return final_prices"},{"question":"from typing import List from collections import Counter def can_form_palindromes(words: List[str]) -> List[str]: Takes a list of strings and returns a new list containing only the strings that can be rearranged to form palindromes. A palindrome is a word that reads the same forwards and backwards. Examples: >>> can_form_palindromes([\\"civic\\", \\"ivic\\", \\"deed\\", \\"car\\", \\"madam\\", \\"hello\\"]) == [\\"civic\\", \\"deed\\", \\"madam\\"] >>> can_form_palindromes([\\"aaa\\", \\"bbbb\\", \\"cc\\", \\"abcd\\"]) == [\\"aaa\\", \\"bbbb\\", \\"cc\\"] >>> can_form_palindromes([\\"aabbcc\\", \\"abc\\", \\"xyz\\", \\"noon\\", \\"level\\"]) == [\\"aabbcc\\", \\"noon\\", \\"level\\"] >>> can_form_palindromes([\\"racecar\\", \\"palindrome\\", \\"radar\\", \\"refer\\", \\"stats\\"]) == [\\"racecar\\", \\"radar\\", \\"refer\\", \\"stats\\"]","solution":"from collections import Counter def can_form_palindromes(words): Takes a list of strings and returns a new list containing only the strings that can be rearranged to form palindromes. result = [] for word in words: counts = Counter(word) odd_count = sum(1 for count in counts.values() if count % 2 != 0) if odd_count <= 1: result.append(word) return result"},{"question":"def distribute_candies(ratings: List[int]) -> int: Given an array called \`ratings\` which contains N integers representing the ratings of students, determine the minimum number of candies you need to distribute in order to meet the following requirements: 1. Each student must have at least one candy. 2. Students with a higher rating get more candies than their neighbors. Example: >>> distribute_candies([1, 0, 2]) 5 >>> distribute_candies([1, 2, 2]) 4","solution":"from typing import List def distribute_candies(ratings: List[int]) -> int: if not ratings: return 0 # Step 1: Initialize candies array with 1 for each student n = len(ratings) candies = [1] * n # Step 2: Left to right pass - ensure right-rated higher gets more candies than left-rated for i in range(1, n): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 # Step 3: Right to left pass - ensure left-rated higher gets more candies than right-rated for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) # The minimum number of candies required is the sum of the candies array return sum(candies)"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the largest sum of any contiguous subarray within the list. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([4]) 4 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 6]) 10 >>> max_subarray_sum([1] * 10**5) 100000 >>> max_subarray_sum([-1] * 10**5) -1","solution":"def max_subarray_sum(nums): Returns the largest sum of any contiguous subarray within the list. max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"import json from typing import Union def format_json(data: Union[dict, list]) -> str: Formats a JSON object into a sorted and indented string. Args: data (Union[dict, list]): JSON object containing nested structures. Returns: str: formatted and sorted JSON string. Examples: >>> format_json({\\"b\\": 1, \\"a\\": 2}) { \\"a\\": 2, \\"b\\": 1 } >>> format_json({\\"name\\": \\"John\\", \\"age\\": 30, \\"children\\": [{\\"name\\": \\"Alice\\", \\"age\\": 10}, {\\"name\\": \\"Bob\\", \\"age\\": 8}], \\"education\\": {\\"degree\\": \\"Masters\\", \\"university\\": \\"XYZ University\\"}}) { \\"age\\": 30, \\"children\\": [ { \\"age\\": 10, \\"name\\": \\"Alice\\" }, { \\"age\\": 8, \\"name\\": \\"Bob\\" } ], \\"education\\": { \\"degree\\": \\"Masters\\", \\"university\\": \\"XYZ University\\" }, \\"name\\": \\"John\\" } >>> format_json([]) [] >>> format_json([3, 1, 2]) [ 3, 1, 2 ]","solution":"import json def format_json(data): Formats a JSON object into a sorted and indented string. Args: data (dict): JSON object containing nested structures. Returns: str: formatted and sorted JSON string. return json.dumps(data, sort_keys=True, indent=4)"},{"question":"from collections import Counter def is_quasi_palindrome(n: int) -> bool: Determine if the given integer n is a quasi-palindrome. A quasi-palindrome number is one that can be rearranged to form a palindrome. Args: n (int): The input integer. Returns: bool: True if n is a quasi-palindrome, False otherwise. Examples: >>> is_quasi_palindrome(12421) True >>> is_quasi_palindrome(12345) False def test_is_quasi_palindrome_true(): assert is_quasi_palindrome(12421) == True assert is_quasi_palindrome(121) == True assert is_quasi_palindrome(1221) == True assert is_quasi_palindrome(12321) == True def test_is_quasi_palindrome_false(): assert is_quasi_palindrome(12345) == False assert is_quasi_palindrome(123) == False assert is_quasi_palindrome(1232) == False def test_is_quasi_palindrome_single_digit(): assert is_quasi_palindrome(0) == True assert is_quasi_palindrome(7) == True def test_is_quasi_palindrome_all_same(): assert is_quasi_palindrome(1111) == True assert is_quasi_palindrome(999) == True def test_is_quasi_palindrome_large_numbers(): assert is_quasi_palindrome(12344321) == True assert is_quasi_palindrome(123456789) == False","solution":"def is_quasi_palindrome(n): Determine if the given integer n is a quasi-palindrome. A quasi-palindrome number is one that can be rearranged to form a palindrome. Args: n (int): The input integer. Returns: bool: True if n is a quasi-palindrome, False otherwise. from collections import Counter # Convert the integer to a string to count the frequency of each digit digit_counts = Counter(str(n)) # Ensure there's at most one digit with an odd frequency count odd_count = sum(1 for count in digit_counts.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def can_form_contiguous_subarray(S: str, P: str) -> str: Determines if the short string P can form a contiguous subarray within the long string S. Args: S (str): The long string consisting of lowercase English letters. P (str): The short string consisting of lowercase English letters. Returns: str: \\"YES\\" if P can form a contiguous subarray within S, otherwise \\"NO\\". if P in S: return \\"YES\\" else: return \\"NO\\" # Unit Test def test_contiguous_subarray_present(): assert can_form_contiguous_subarray(\\"hellothere\\", \\"there\\") == \\"YES\\" assert can_form_contiguous_subarray(\\"substringcheck\\", \\"check\\") == \\"YES\\" assert can_form_contiguous_subarray(\\"abcdefghijklmnopqrstuvwxyz\\", \\"mnop\\") == \\"YES\\" def test_contiguous_subarray_not_present(): assert can_form_contiguous_subarray(\\"abcdefghijk\\", \\"gfed\\") == \\"NO\\" assert can_form_contiguous_subarray(\\"hellothere\\", \\"hellohello\\") == \\"NO\\" assert can_form_contiguous_subarray(\\"substringcheck\\", \\"token\\") == \\"NO\\" def test_boundary_conditions(): assert can_form_contiguous_subarray(\\"a\\", \\"a\\") == \\"YES\\" assert can_form_contiguous_subarray(\\"a\\", \\"b\\") == \\"NO\\" assert can_form_contiguous_subarray(\\"aaaaa\\", \\"aaa\\") == \\"YES\\" assert can_form_contiguous_subarray(\\"abcabcabc\\", \\"cabcab\\") == \\"YES\\" def test_complex_cases(): assert can_form_contiguous_subarray(\\"abcdefghijklmnopqrstuvwxyz\\", \\"defgh\\") == \\"YES\\" assert can_form_contiguous_subarray(\\"abcdefghijklmnopqrstuvwxyz\\", \\"wxyz\\") == \\"YES\\" assert can_form_contiguous_subarray(\\"aquickbrownfoxjumpsoverthelazydog\\", \\"brownfoxjumps\\") == \\"YES\\" assert can_form_contiguous_subarray(\\"aquickbrownfoxjumpsoverthelazydog\\", \\"fxjumpsov\\") == \\"NO\\"","solution":"def can_form_contiguous_subarray(S, P): Determines if the short string P can form a contiguous subarray within the long string S. Args: S (str): The long string consisting of lowercase English letters. P (str): The short string consisting of lowercase English letters. Returns: str: \\"YES\\" if P can form a contiguous subarray within S, otherwise \\"NO\\". if P in S: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def max_unique_users(events: List[Tuple[str, int]], k: int) -> int: Returns the maximum number of unique users in any window of k consecutive events. :param events: List of tuples, where each tuple contains two elements: a user ID (string) and a timestamp (integer). :param k: Integer indicating the length of the window in number of events. :return: Maximum number of unique users in any window of k consecutive events. pass def test_example_1(): events = [(\\"user1\\", 1), (\\"user2\\", 2), (\\"user1\\", 3), (\\"user3\\", 4), (\\"user4\\", 5)] k = 3 assert max_unique_users(events, k) == 3 def test_example_2(): events = [(\\"user5\\", 1), (\\"user6\\", 2), (\\"user7\\", 3), (\\"user8\\", 4), (\\"user9\\", 5), (\\"user10\\", 6)] k = 2 assert max_unique_users(events, k) == 2 def test_single_event(): events = [(\\"user1\\", 1)] k = 1 assert max_unique_users(events, k) == 1 def test_all_unique_users(): events = [(\\"user1\\", 1), (\\"user2\\", 2), (\\"user3\\", 3), (\\"user4\\", 4)] k = 3 assert max_unique_users(events, k) == 3 def test_all_identical_users(): events = [(\\"user1\\", 1), (\\"user1\\", 2), (\\"user1\\", 3), (\\"user1\\", 4)] k = 2 assert max_unique_users(events, k) == 1 def test_smaller_k_than_events_length(): events = [(\\"user1\\", 1), (\\"user2\\", 2), (\\"user1\\", 3), (\\"user3\\", 4), (\\"user4\\", 5), (\\"user2\\", 6)] k = 4 assert max_unique_users(events, k) == 4 def test_larger_k_than_events_length(): events = [(\\"user1\\", 1), (\\"user2\\", 2), (\\"user3\\", 3)] k = 5 assert max_unique_users(events, k) == 3 def test_empty_events(): events = [] k = 1 assert max_unique_users(events, k) == 0","solution":"def max_unique_users(events, k): Returns the maximum number of unique users in any window of k consecutive events. :param events: List of tuples, where each tuple contains two elements: a user ID (string) and a timestamp (integer). :param k: Integer indicating the length of the window in the number of events. :return: Maximum number of unique users in any window of k consecutive events. if k > len(events): return len(set(user for user, _ in events)) user_count = {} unique_users = 0 max_unique = 0 for i in range(len(events)): user_id, _ = events[i] if user_id in user_count: user_count[user_id] += 1 else: user_count[user_id] = 1 unique_users += 1 if i >= k: old_user_id, _ = events[i - k] user_count[old_user_id] -= 1 if user_count[old_user_id] == 0: del user_count[old_user_id] unique_users -= 1 if i >= k - 1: max_unique = max(max_unique, unique_users) return max_unique"},{"question":"from typing import List, Union def flatten(nested_list: List[Union[int, List]]) -> List[int]: Flattens a nested list of integers into a single list of integers. Args: nested_list (list): A list that may contain nested lists. Returns: list: A flattened list containing all integers from the nested list. Examples: >>> flatten([1, [2, [3, [4]]]]) [1, 2, 3, 4] >>> flatten([1, 2, 3, 4]) [1, 2, 3, 4] >>> flatten([[]]) [] >>> flatten([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten([[[[[[1]]]]]]) [1] >>> flatten([1, [2, [3]], [4, [5, [6]]]]) [1, 2, 3, 4, 5, 6] >>> flatten([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> flatten([]) []","solution":"def flatten(nested_list): Flattens a nested list of integers. Args: nested_list (list): A list that may contain nested lists. Returns: list: A flattened list containing all integers from the nested list. # Create an empty list to store the flattened result flat_list = [] # Define a helper function to handle recursion def _flatten(sub_list): for item in sub_list: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(nested_list) return flat_list"},{"question":"def find_maximum_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of a contiguous subarray within the given numeric array. >>> find_maximum_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> find_maximum_subarray_sum([1]) 1 >>> find_maximum_subarray_sum([-1, -2, -3]) -1 >>> find_maximum_subarray_sum([5, 4, -1, 7, 8]) 23 # Your code here from solution import find_maximum_subarray_sum def test_example_cases(): assert find_maximum_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert find_maximum_subarray_sum([1]) == 1 assert find_maximum_subarray_sum([-1, -2, -3]) == -1 assert find_maximum_subarray_sum([5, 4, -1, 7, 8]) == 23 def test_all_negative_single_max(): assert find_maximum_subarray_sum([-1, -2, -3, -4, -5]) == -1 def test_mixed_numbers(): assert find_maximum_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5]) == 18 assert find_maximum_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_single_element(): assert find_maximum_subarray_sum([10]) == 10 assert find_maximum_subarray_sum([-10]) == -10 def test_large_array(): assert find_maximum_subarray_sum([1, 2, 3, 4, 5, -15, 6, 7, 8, 9, 10]) == 40","solution":"def find_maximum_subarray_sum(nums): Returns the maximum sum of a contiguous subarray within the given numeric array. max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_area_of_island(grid): Returns the maximum area of an island in the given grid. pass def max_area_of_island_in_grids(T, test_cases): Returns a list of maximum areas of islands for each test case. pass def test_max_area_of_island(): assert max_area_of_island([[1,1,0,0,0], [1,1,0,0,1], [0,0,0,1,1], [0,0,0,1,0]]) == 4 assert max_area_of_island([[0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0]]) == 0 assert max_area_of_island([[1]]) == 1 assert max_area_of_island([[1, 0], [0, 1]]) == 1 def test_max_area_of_island_in_grids(): T = 1 test_cases = [ ( 4, 5, [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 0] ] ) ] assert max_area_of_island_in_grids(T, test_cases) == [4] T = 2 test_cases = [ ( 4, 5, [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 0] ] ), ( 3, 3, [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] ) ] assert max_area_of_island_in_grids(T, test_cases) == [4, 1]","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the given grid. def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 area = 1 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: area += dfs(grid, x, y) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(grid, i, j)) return max_area def max_area_of_island_in_grids(T, test_cases): results = [] for tc in range(T): m, n, grid = test_cases[tc] results.append(max_area_of_island(grid)) return results"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Complete the function that accepts a list of integers, and returns a new list where each element is the product of all the integers in the original list except the element at the corresponding position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24]","solution":"def product_except_self(nums): Returns a list where each element is the product of all the integers in the original list except the element at the corresponding position. length = len(nums) answer = [1] * length prefix = 1 for i in range(length): answer[i] = prefix prefix *= nums[i] suffix = 1 for i in range(length - 1, -1, -1): answer[i] *= suffix suffix *= nums[i] return answer"},{"question":"def mrle_encode(input_string: str) -> str: Encodes a given string using the Modified Run-Length Encoding (MRLE) technique. >>> mrle_encode(\\"aaabbc\\") \\"a3b2c\\" >>> mrle_encode(\\"abcd\\") \\"abcd\\" >>> mrle_encode(\\"aabbcc\\") \\"a2b2c2\\" >>> mrle_encode(\\"a\\") \\"a\\" >>> mrle_encode(\\"aaaabbbbcc\\") \\"a4b4c2\\"","solution":"def mrle_encode(input_string: str) -> str: Encodes a given string using the Modified Run-Length Encoding (MRLE) technique. if not input_string: return \\"\\" encoded_str = \\"\\" current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: if count > 1: encoded_str += f\\"{current_char}{count}\\" else: encoded_str += current_char current_char = char count = 1 # Handle the last set of characters if count > 1: encoded_str += f\\"{current_char}{count}\\" else: encoded_str += current_char return encoded_str"},{"question":"def triangular_number(n: int) -> int: Given an integer n, return the nth triangular number. The nth triangular number is the sum of the first n natural numbers. >>> triangular_number(3) 6 >>> triangular_number(5) 15","solution":"def triangular_number(n: int) -> int: Returns the nth triangular number. The nth triangular number is the sum of the first n natural numbers. Formula for nth triangular number: n * (n + 1) / 2 return n * (n + 1) // 2"},{"question":"from typing import List, Tuple def max_profit(prices: List[int]) -> int: Calculate the maximum profit from a list of house prices where you can buy and sell once. Args: prices (List[int]): The list of house prices. Returns: int: The maximum profit possible from one transaction. If no profit is possible, return 0. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases for the max profit problem. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple containing the number of days and the respective house prices. Returns: List[int]: List of results for each test case. Examples: >>> process_test_cases(2, [(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1])]) [5, 0] from solution import max_profit, process_test_cases def test_max_profit_example_cases(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_edge_cases(): assert max_profit([]) == 0 assert max_profit([5]) == 0 assert max_profit([3, 3]) == 0 assert max_profit([1, 2, 3, 4, 5]) == 4 assert max_profit([5, 4, 3, 2, 1]) == 0 def test_process_test_cases(): test_cases = [(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1])] assert process_test_cases(2, test_cases) == [5, 0] test_cases = [(5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1])] assert process_test_cases(2, test_cases) == [4, 0] test_cases = [(3, [2, 4, 1]), (4, [7, 2, 3, 10])] assert process_test_cases(2, test_cases) == [2, 8] def test_various_cases(): assert max_profit([2, 3, 1, 4, 5, 8]) == 7 assert max_profit([1, 1, 1, 1, 1, 1]) == 0 assert max_profit([3, 8, 2, 10, 1]) == 8","solution":"def max_profit(prices): if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price profit = price - min_price if profit > max_profit: max_profit = profit return max_profit def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] prices = test_cases[i][1] result = max_profit(prices) results.append(result) return results"},{"question":"def replace_digits(s: str) -> str: Replaces digits in the string with '*' for even numbers and '#' for odd numbers. Args: s (str): The input string containing digits. Returns: str: The modified string after replacing digits based on the rules. Examples: >>> replace_digits('1234567890') '#*#*#*#*#*' >>> replace_digits('9876543210') '#*#*#*#*#*'","solution":"def replace_digits(s): Replaces digits in the string with '*' for even numbers and '#' for odd numbers. Args: s (str): The input string containing digits. Returns: str: The modified string after replacing digits based on the rules. # Mapping function for easy replacement def replace(char): if char in '02468': return '*' else: return '#' # Using list comprehension for efficient string transformation return ''.join(replace(char) for char in s)"},{"question":"def count_anagram_groups(n: int, user_ids: List[str]) -> int: Returns the number of unique groups of anagrams. >>> count_anagram_groups(6, [\\"abcd\\", \\"bcad\\", \\"dcba\\", \\"abdc\\", \\"xyz\\", \\"zyx\\"]) 2 >>> count_anagram_groups(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"ab\\", \\"ba\\"]) 2 >>> count_anagram_groups(3, [\\"aaa\\", \\"aa\\", \\"aaa\\"]) 2 >>> count_anagram_groups(1, [\\"abcd\\"]) 1 >>> count_anagram_groups(3, [\\"a\\", \\"b\\", \\"c\\"]) 3 >>> count_anagram_groups(4, [\\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\"]) 1","solution":"def count_anagram_groups(n, user_ids): Returns the number of unique groups of anagrams. anagram_dict = {} for user_id in user_ids: sorted_id = ''.join(sorted(user_id)) if sorted_id in anagram_dict: anagram_dict[sorted_id] += 1 else: anagram_dict[sorted_id] = 1 return len(anagram_dict)"},{"question":"def is_valid_identifier(identifier: str) -> bool: Determines if the given identifier is valid based on specific rules. Parameters: identifier (str): The identifier string to check Returns: bool: True if the identifier is valid, False otherwise Examples: >>> is_valid_identifier(\\"HELLO_WORLD\\") True >>> is_valid_identifier(\\"HELLO__WORLD\\") False >>> is_valid_identifier(\\"HELLO_WORLD_\\") False >>> is_valid_identifier(\\"HELLO WORLD\\") False >>> is_valid_identifier(\\"HELLOWORLD123\\") False >>> is_valid_identifier(\\"H\\") True >>> is_valid_identifier(\\"\\") False >>> is_valid_identifier(\\"A_VERY_LONG_IDENTIFIER_NAME\\") False","solution":"def is_valid_identifier(identifier: str) -> bool: Determines if the given identifier is valid based on specific rules. Parameters: identifier (str): The identifier string to check Returns: bool: True if the identifier is valid, False otherwise if len(identifier) < 1 or len(identifier) > 20: return False if not identifier[0].isupper(): return False if identifier[-1] == '_': return False if '__' in identifier: return False for char in identifier: if not (char.isupper() or char == '_'): return False return True"},{"question":"from typing import List def sum_odd_digit_numbers(nums: List[int]) -> int: Returns the sum of all integers in the list that have an odd number of digits. >>> sum_odd_digit_numbers([123, 4567, 89, 2]) 124 >>> sum_odd_digit_numbers([1, 22, 333, 4444]) 334 >>> sum_odd_digit_numbers([12, 345, 67, 8901]) 345 >>> sum_odd_digit_numbers([7, 5, 1, 0, -3]) 10 >>> sum_odd_digit_numbers([-111, -22, -3333, -4444]) -111 >>> sum_odd_digit_numbers([1000000001, -1000000001]) 0 >>> sum_odd_digit_numbers([12345, 6789, 123, 4567]) 12468","solution":"from typing import List def sum_odd_digit_numbers(nums: List[int]) -> int: Returns the sum of all integers in the list that have an odd number of digits. Args: nums (List[int]): List of integers. Returns: int: Sum of integers with an odd number of digits. def is_odd_digit_count(n: int) -> bool: # Convert number to string and remove the sign if negative n_str = str(abs(n)) return len(n_str) % 2 != 0 return sum(num for num in nums if is_odd_digit_count(num))"},{"question":"import math from typing import List def is_frond_number(n: int) -> bool: Check if a number is a Frond Number. A Frond Number is defined as a number for which the sum of the factorials of its digits equals the number itself. return n == sum(math.factorial(int(digit)) for digit in str(n)) def find_frond_numbers(start: int, end: int) -> List[int]: Find all Frond Numbers between start and end inclusive. >>> find_frond_numbers(1, 10) [1, 2] >>> find_frond_numbers(1, 150) [1, 2, 145] >>> find_frond_numbers(0, 1) [1] >>> find_frond_numbers(1, 100000) [1, 2, 145, 40585]","solution":"import math def is_frond_number(n): Check if a number is a Frond Number. A Frond Number is defined as a number for which the sum of the factorials of its digits equals the number itself. return n == sum(math.factorial(int(digit)) for digit in str(n)) def find_frond_numbers(start, end): Find all Frond Numbers between start and end inclusive. return [num for num in range(start, end + 1) if is_frond_number(num)] # Example usage: # find_frond_numbers(1, 100000) # Output: [1, 2, 145, 40585]"},{"question":"def generate_strings(s: str, n: int) -> list: Generates all possible strings of length n that can be formed using characters from string s in lexicographical order. Parameters: s (str): A string containing unique characters. n (int): The length of the strings to generate. Returns: list: A list containing all possible strings of length n formed using the characters from s. Example: >>> generate_strings(\\"ab\\", 2) [\\"aa\\", \\"ab\\", \\"ba\\", \\"bb\\"] >>> generate_strings(\\"abc\\", 3) [\\"aaa\\", \\"aab\\", \\"aac\\", \\"aba\\", \\"abb\\", \\"abc\\", \\"aca\\", \\"acb\\", \\"acc\\", \\"baa\\", \\"bab\\", \\"bac\\", \\"bba\\", \\"bbb\\", \\"bbc\\", \\"bca\\", \\"bcb\\", \\"bcc\\", \\"caa\\", \\"cab\\", \\"cac\\", \\"cba\\", \\"cbb\\", \\"cbc\\", \\"cca\\", \\"ccb\\", \\"ccc\\"]","solution":"from itertools import product def generate_strings(s: str, n: int) -> list: Generates all possible strings of length n that can be formed using characters from string s in lexicographical order. s = sorted(s) # Ensure the characters in s are sorted to get lexicographical order return [''.join(p) for p in product(s, repeat=n)]"},{"question":"from typing import List def rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix by 90 degrees clockwise. >>> rotate_matrix_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_clockwise([[1]]) [ [1] ] pass def rotate_matrix_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix by 90 degrees counterclockwise. >>> rotate_matrix_counterclockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] >>> rotate_matrix_counterclockwise([[1]]) [ [1] ] pass","solution":"def rotate_matrix_clockwise(matrix): Rotates a given NxN matrix by 90 degrees clockwise. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] return rotated_matrix def rotate_matrix_counterclockwise(matrix): Rotates a given NxN matrix by 90 degrees counterclockwise. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[N-1-j][i] = matrix[i][j] return rotated_matrix"},{"question":"def count_gaps(buildings: List[int], K: int) -> int: Returns the total number of gaps between consecutive buildings where the height difference is greater than a specified threshold K. >>> count_gaps([3, 1, 4, 7, 9], 2) 2 >>> count_gaps([3, 3, 3, 3], 0) 0 >>> count_gaps([3, 3, 3, 3], 5) 0 >>> count_gaps([1, 10, 1, 10], 5) 3 >>> count_gaps([10], 5) 0 >>> count_gaps([1, 2, 2, 5, 6, 7, 8], 10) 0","solution":"def count_gaps(buildings, K): Returns the total number of gaps between consecutive buildings where the height difference is greater than a specified threshold K. count = 0 for i in range(1, len(buildings)): if abs(buildings[i] - buildings[i - 1]) > K: count += 1 return count"},{"question":"def getLightColor(minutes: int) -> str: Determines the color of the light based on the number of minutes since midnight. >>> getLightColor(360) \\"blue\\" >>> getLightColor(1200) \\"blue\\" >>> getLightColor(1380) \\"green\\" >>> getLightColor(300) \\"green\\" >>> getLightColor(1439) \\"green\\"","solution":"def getLightColor(minutes: int) -> str: Determines the color of the light based on the number of minutes since midnight. :param minutes: int - The number of minutes since midnight :return: str - The color of the light (\\"blue\\", \\"red\\", or \\"green\\") if 360 <= minutes < 1140: # 6:00 AM to 6:59 PM return \\"blue\\" elif 1140 <= minutes < 1320: # 7:00 PM to 9:59 PM return \\"red\\" else: # 10:00 PM to 5:59 AM return \\"green\\""},{"question":"def generate_spiral_matrix(N): Generate a spiral matrix of size N x N. >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(0) [] pass def print_spiral_matrix(matrix): Print the spiral matrix with integers right-aligned in a field of width 3. >>> print_spiral_matrix([[1, 2, 3], [8, 9, 4], [7, 6, 5]]) 1 2 3 8 9 4 7 6 5 >>> print_spiral_matrix([]) \\"\\" pass","solution":"def generate_spiral_matrix(N): if N == 0: return [] spiral_matrix = [[0] * N for _ in range(N)] x, y = 0, 0 dx, dy = 0, 1 for i in range(1, N * N + 1): spiral_matrix[x][y] = i if not (0 <= x + dx < N and 0 <= y + dy < N and spiral_matrix[x + dx][y + dy] == 0): dx, dy = dy, -dx # Change direction counter-clockwise x += dx y += dy return spiral_matrix def print_spiral_matrix(matrix): result = \\"n\\".join([\\" \\".join([f\\"{num:3}\\" for num in row]) for row in matrix]) return result"},{"question":"def robot_return_to_origin(instructions: str) -> bool: Determines if the robot returns to the origin after performing a sequence of moves. Args: instructions (str): A string representing the sequence of moves Returns: bool: True if the robot returns to the origin, False otherwise >>> robot_return_to_origin(\\"NESW\\") True >>> robot_return_to_origin(\\"NNSS\\") True >>> robot_return_to_origin(\\"NNWW\\") False","solution":"def robot_return_to_origin(instructions): Determines if the robot returns to the origin after performing a sequence of moves. Params: instructions (str): A string representing the sequence of moves Returns: bool: True if the robot returns to the origin, False otherwise x, y = 0, 0 for move in instructions: if move == 'N': y += 1 elif move == 'S': y -= 1 elif move == 'E': x += 1 elif move == 'W': x -= 1 return x == 0 and y == 0"},{"question":"def balance_check(s: str) -> bool: Check if the provided string s has balanced brackets. Args: s (str): The string containing brackets. Returns: bool: True if the brackets are balanced, False otherwise. Examples: >>> balance_check(\\"()\\") True >>> balance_check(\\"(()\\") False >>> balance_check(\\"()[]{}\\") True >>> balance_check(\\"(]\\") False >>> balance_check(\\"{[()]}\\") True >>> balance_check(\\"{[(])}\\") False >>> balance_check(\\"\\") True >>> balance_check(\\"{a+(b*[c])}\\") True >>> balance_check(\\"{a+(b*[c])\\") False","solution":"def balance_check(s): Check if the provided string s has balanced brackets. Args: s (str): The string containing brackets. Returns: bool: True if the brackets are balanced, False otherwise. stack = [] bracket_pair = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_pair.values(): stack.append(char) elif char in bracket_pair.keys(): if stack == [] or bracket_pair[char] != stack.pop(): return False else: continue return stack == []"},{"question":"from typing import List, Tuple def bouncer_count(people: List[Tuple[str, int]]) -> int: Write a function named \`bouncer_count\` that takes in a list of tuples representing people trying to enter a club. Each tuple contains a name (string) and an age (integer). The function should return an integer representing the number of people denied entry based on the following rules: 1. Only people aged 21 or older are allowed entry. 2. If a person has the same name as someone already inside, they are denied entry regardless of age. 3. Nicknames are defined as strings that can match the first 3 letters of another name. For instance, \\"Alex\\" and \\"Alexander\\" are considered the same person. The function should be case-insensitive when comparing names and nicknames. Note: You may assume that names have at least 3 characters. Test cases: >>> bouncer_count([(\\"Alex\\", 22), (\\"Bob\\", 25), (\\"Alice\\", 23)]) == 0 >>> bouncer_count([(\\"Alex\\", 20), (\\"Bob\\", 18), (\\"Alice\\", 19)]) == 3 >>> bouncer_count([(\\"Alex\\", 22), (\\"Bob\\", 22), (\\"Alice\\", 25), (\\"Alexander\\", 21), (\\"Alicia\\", 22)]) == 2 >>> bouncer_count([(\\"Alex\\", 22), (\\"Bob\\", 20), (\\"Alice\\", 25), (\\"Alexander\\", 21), (\\"Alicia\\", 19)]) == 3 >>> bouncer_count([(\\"Alex\\", 22), (\\"alexander\\", 25), (\\"bob\\", 23), (\\"alice\\", 24), (\\"Bob\\", 21)]) == 2 >>> bouncer_count([]) == 0 >>> bouncer_count([(\\"Alex\\", 20)]) == 1 >>> bouncer_count([(\\"Alex\\", 22)]) == 0 pass","solution":"def bouncer_count(people): Return the number of people denied entry based on age and name/nickname rules. allowed_names = set() denied_count = 0 for name, age in people: name_lower = name.lower() nickname = name_lower[:3] if age < 21 or any(existing_name.startswith(nickname) for existing_name in allowed_names): denied_count += 1 else: allowed_names.add(name_lower) return denied_count"},{"question":"def shortest_path(num_cases, cases): Calculates the shortest travel time between two specified locations in a city's subway network. num_cases: int : Number of test cases cases: List[Tuple[int, int, List[Tuple[int, int, int]], int, int]] : Each test case with: - N: Number of locations (nodes) - M: Number of direct subway connections - connections: List of tuples (u_i, v_i, w_i) representing direct connections between locations with travel time - start: Starting location S - end: Destination location D Returns: List[int] : Shortest travel times for each test case >>> num_cases = 1 >>> cases = [ ... (4, 4, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1)], 1, 4) ... ] >>> shortest_path(num_cases, cases) [3] >>> num_cases = 2 >>> cases = [ ... (4, 4, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1)], 1, 4), ... (5, 6, [(1, 2, 3), (1, 3, 6), (2, 3, 2), (2, 4, 1), (3, 5, 4), (4, 5, 5)], 1, 5) ... ] >>> shortest_path(num_cases, cases) [3, 9] pass def test_shortest_path(): num_cases = 1 cases = [ (4, 4, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1)], 1, 4) ] assert shortest_path(num_cases, cases) == [3] def test_shortest_path_multiple_cases(): num_cases = 2 cases = [ (4, 4, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1)], 1, 4), (5, 6, [(1, 2, 3), (1, 3, 6), (2, 3, 2), (2, 4, 1), (3, 5, 4), (4, 5, 5)], 1, 5) ] assert shortest_path(num_cases, cases) == [3, 9] def test_shortest_path_large_input(): num_cases = 1 N, M = 1000, 10000 connections = [(i, i+1, 1) for i in range(1, 1000)] cases = [(N, M, connections, 1, 1000)] assert shortest_path(num_cases, cases) == [999] def test_shortest_path_direct_connection(): num_cases = 1 cases = [ (3, 3, [(1, 2, 4), (2, 3, 5), (1, 3, 9)], 1, 3) ] assert shortest_path(num_cases, cases) == [9] cases = [ (3, 3, [(1, 2, 4), (2, 3, 1), (1, 3, 9)], 1, 3) ] assert shortest_path(num_cases, cases) == [5] import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"import heapq def shortest_path(num_cases, cases): results = [] for case in cases: N, M, connections, S, D = case graph = [[] for _ in range(N + 1)] for u, v, w in connections: graph[u].append((v, w)) graph[v].append((u, w)) # Because the subway connection is bidirectional # Dijkstra's algorithm to find the shortest path def dijkstra(start, end): min_heap = [(0, start)] dist = {i: float('inf') for i in range(1, N + 1)} dist[start] = 0 while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(min_heap, (distance, v)) return dist[end] shortest_time = dijkstra(S, D) results.append(shortest_time) return results"},{"question":"def count_distinct_in_subarray(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of distinct elements in the subarray arr[L..R] for each [L, R] pair in queries. :param arr: List[int] - The input array :param queries: List[Tuple[int, int]] - The list of queries where each query is a tuple (L, R) :return: List[int] - The list with count of distinct elements for each query >>> count_distinct_in_subarray([1, 2, 1, 3, 2], [(1, 3), (2, 4), (1, 5)]) [2, 3, 3] >>> count_distinct_in_subarray([1], [(1, 1)]) [1] >>> count_distinct_in_subarray([7, 7, 7, 7, 7], [(1, 5), (2, 4), (3, 3)]) [1, 1, 1] >>> count_distinct_in_subarray([4, 5, 6, 7, 8], [(1, 2), (1, 3), (1, 4), (1, 5)]) [2, 3, 4, 5] >>> count_distinct_in_subarray([10, 20, 10, 30, 20], [(1, 5), (2, 4)]) [3, 3]","solution":"def count_distinct_in_subarray(arr, queries): Returns the number of distinct elements in the subarray arr[L..R] for each [L, R] pair in queries. :param arr: List[int] - The input array :param queries: List[Tuple[int, int]] - The list of queries where each query is a tuple (L, R) :return: List[int] - The list with count of distinct elements for each query distinct_counts = [] for L, R in queries: subarray = arr[L-1:R] distinct_counts.append(len(set(subarray))) return distinct_counts"},{"question":"def count_characters(s: str) -> dict: Complete the function so that it counts the number of occurrences of each character in a given string. The function should return a dictionary with characters as keys and their counts as values. >>> count_characters(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> count_characters(\\"Programming\\") {'P': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1}","solution":"def count_characters(s): Returns a dictionary with the count of each character in the input string s. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def can_form_sequence(difficulties: List[int]) -> bool: Determines if it is possible to arrange the problems to match the criteria: - The first problem should have the smallest difficulty level. - The last problem should have the largest difficulty level. - Each intermediate problem should have a difficulty level greater than or equal to the previous problem's difficulty level and less than or equal to the next problem's difficulty level. >>> can_form_sequence([1, 3, 2, 4, 5]) True >>> can_form_sequence([5, 3, 4, 2]) False >>> can_form_sequence([1, 2]) True >>> can_form_sequence([2, 1]) False","solution":"def can_form_sequence(difficulties): Determines if it is possible to arrange the problems to match the criteria: - The first problem should have the smallest difficulty level. - The last problem should have the largest difficulty level. - Each intermediate problem should have a difficulty level greater than or equal to the previous problem's difficulty level and less than or equal to the next problem's difficulty level. # Finding the minimum and maximum difficulty level min_difficulty = min(difficulties) max_difficulty = max(difficulties) # Check if the minimum and maximum difficulties are at the start and end, respectively return difficulties[0] == min_difficulty and difficulties[-1] == max_difficulty"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. >>> first_non_repeating_character(\\"leetcode\\") == \\"l\\" >>> first_non_repeating_character(\\"loveleetcode\\") == \\"v\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\"\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. # Create a dictionary to store the frequency of each character char_count = {} # Populate the dictionary with character counts for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that appears only once for char in s: if char_count[char] == 1: return char # No non-repeating character found return \\"\\""},{"question":"def lonely_sum(arr: List[int]) -> List[int]: Returns a new array where each element at index \`i\` is the sum of all elements of the input array except the one at index \`i\`. >>> lonely_sum([1, 2, 3, 4]) [9, 8, 7, 6] >>> lonely_sum([5]) [0] >>> lonely_sum([1, -1, 3, -3]) [-1, 1, -3, 3]","solution":"def lonely_sum(arr): Returns a new array where each element at index \`i\` is the sum of all elements of the input array except the one at index \`i\`. total_sum = sum(arr) return [total_sum - x for x in arr]"},{"question":"def most_frequent_word(s: str) -> str: Returns the most frequent word in the string s. If two words have the same frequency, it returns the first appearing one. >>> most_frequent_word(\\"the quick brown fox jumps over the lazy dog the quick fox\\") == \\"the\\" >>> most_frequent_word(\\"hello world hello\\") == \\"hello\\" >>> most_frequent_word(\\"a a a b b b b c c\\") == \\"b\\" >>> most_frequent_word(\\"coding coding coding code code\\") == \\"coding\\" >>> most_frequent_word(\\"apple banana apple banana banana\\") == \\"banana\\"","solution":"def most_frequent_word(s): Returns the most frequent word in the string s. If two words have the same frequency, it returns the first appearing one. :param s: Input string consisting of lowercase alphabets and spaces :return: The most frequent word in the string words = s.split() frequency = {} first_occurrences = {} for index, word in enumerate(words): if word in frequency: frequency[word] += 1 else: frequency[word] = 1 first_occurrences[word] = index max_freq = 0 most_frequent = None for word, freq in frequency.items(): if freq > max_freq or (freq == max_freq and first_occurrences[word] < first_occurrences[most_frequent]): max_freq = freq most_frequent = word return most_frequent"},{"question":"def calculate_typing_score(typed_string: str) -> int: This function calculates the typing score based on typed_text and intended_text. The format of the input string will be as follows: \\"typed_text|intended_text\\". Score criteria: - For each correct character (case-sensitive), add 5 points. - For each incorrect character, subtract 2 points. - Ignore any additional characters if the length of \\"typed_text\\" exceeds \\"intended_text\\". - Do not consider characters in \\"intended_text\\" beyond the length of \\"typed_text\\". Examples: >>> calculate_typing_score(\\"apple|appls\\") 18 >>> calculate_typing_score(\\"kitten|kittenz\\") 30","solution":"def calculate_typing_score(typed_string: str) -> int: This function calculates the typing score based on typed_text and intended_text. typed_text, intended_text = typed_string.split('|') score = 0 length = min(len(typed_text), len(intended_text)) for i in range(length): if typed_text[i] == intended_text[i]: score += 5 else: score -= 2 return score"},{"question":"def max_sum_of_importance(n, k, importance, edges): Returns the maximum possible sum of importance values of the k trees that can be cut down. Parameters: n (int): Number of trees. k (int): Number of trees to be cut down. importance (list of int): List of importance values of trees. edges (list of tuple): List of edges between trees. Returns: int: Maximum sum of importance values of the k trees to be cut down. >>> max_sum_of_importance(5, 2, [5, 3, 6, 9, 2], [(1, 2), (1, 3), (2, 4), (2, 5)]) 15 >>> max_sum_of_importance(7, 3, [1, 3, 5, 7, 2, 4, 6], [(1, 2), (1, 3), (3, 4), (3, 5), (2, 6), (4, 7)]) 18 >>> max_sum_of_importance(6, 1, [8, 2, 9, 3, 5, 1], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 9","solution":"from heapq import nlargest def max_sum_of_importance(n, k, importance, edges): Returns the maximum possible sum of importance values of the k trees that can be cut down. Parameters: n (int): Number of trees. k (int): Number of trees to be cut down. importance (list of int): List of importance values of trees. edges (list of tuple): List of edges between trees. Returns: int: Maximum sum of importance values of the k trees to be cut down. # Build the tree structure but it is not necessary for this solution # We can directly work with the importance values by considering we can just remove highest k values # We just need to find the k largest values in the importance list max_importance_sum = sum(nlargest(k, importance)) return max_importance_sum"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates the arithmetic expression according to the rules of arithmetic without any parentheses. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"5-3\\") == 2 >>> evaluate_expression(\\"2*3\\") == 6 >>> evaluate_expression(\\"6/3\\") == 2 >>> evaluate_expression(\\"3+5*2-8/4\\") == 11 >>> evaluate_expression(\\"2+3-1+7-4\\") == 7 >>> evaluate_expression(\\"3+2*2/2-1\\") == 4 >>> evaluate_expression(\\"10*2+5\\") == 25 pass","solution":"def evaluate_expression(expression: str) -> int: Evaluates the arithmetic expression according to the rules of arithmetic without any parentheses. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(int(a / b)) # Use int() to perform integer division operators = set('+-*/') precedence = {'+': 1, '-': 1, '*': 2, '/': 2} operands = [] ops = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] in operators: while (ops and precedence[ops[-1]] >= precedence[expression[i]]): apply_operator(operands, ops.pop()) ops.append(expression[i]) i += 1 while ops: apply_operator(operands, ops.pop()) return operands[0]"},{"question":"from typing import List def find_anagrams(word: str, candidates: List[str]) -> List[str]: Returns a list of candidates that are anagrams of the input word. Parameters: word (str): The word to find anagrams for. candidates (list of str): A list of candidate words to check. Returns: list of str: A list of anagrams of the word from the candidates. >>> find_anagrams('listen', ['enlists', 'google', 'inlets', 'banana']) ['inlets'] >>> find_anagrams('evil', ['vile', 'live', 'veil', 'villain']) ['vile', 'live', 'veil'] pass","solution":"def find_anagrams(word, candidates): Returns a list of candidates that are anagrams of the input word. Parameters: word (str): The word to find anagrams for. candidates (list of str): A list of candidate words to check. Returns: list of str: A list of anagrams of the word from the candidates. # Normalize the word by making it lowercase and sorting its characters normalized_word = sorted(word.lower()) # Initialize an empty list to store the anagrams anagrams = [] # Iterate over each candidate to check if it is an anagram for candidate in candidates: # Normalize the candidate by making it lowercase and sorting its characters normalized_candidate = sorted(candidate.lower()) # If the normalized word and candidate are the same, then it's an anagram if normalized_word == normalized_candidate: anagrams.append(candidate) return anagrams"},{"question":"from typing import List, Tuple def compute_fragment_positions(T: int, N: int, fragments: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int]]: Calculate the coordinates of each fragment after T seconds. Parameters: - T (int): The time in seconds after which the positions are to be calculated. - N (int): The number of fragments. - fragments (List[Tuple[int, int, int, int]]): List of tuples each containing four integers x, y, vx, vy, representing the initial coordinates and velocity vectors of each fragment. Returns: - List[Tuple[int, int]]: List of tuples each containing the coordinates of a fragment after T seconds, rounded to the nearest integer. Example: >>> compute_fragment_positions(2, 3, [(0, 0, 1, 1), (1, 2, -1, 0), (-1, -2, 0, -3)]) [(2, 2), (-1, 2), (-1, -8)] >>> compute_fragment_positions(0, 2, [(0, 0, 1, 1), (1, 2, -1, 0)]) [(0, 0), (1, 2)] from solution import compute_fragment_positions def test_basic_case(): T = 2 N = 3 fragments = [ (0, 0, 1, 1), (1, 2, -1, 0), (-1, -2, 0, -3) ] assert compute_fragment_positions(T, N, fragments) == [(2, 2), (-1, 2), (-1, -8)] def test_zero_time(): T = 0 N = 2 fragments = [ (0, 0, 1, 1), (1, 2, -1, 0) ] assert compute_fragment_positions(T, N, fragments) == [(0, 0), (1, 2)] def test_zero_velocity(): T = 10 N = 2 fragments = [ (0, 0, 0, 0), (10, -10, 0, 0) ] assert compute_fragment_positions(T, N, fragments) == [(0, 0), (10, -10)] def test_negative_velocity(): T = 5 N = 1 fragments = [ (3, 3, -2, -2) ] assert compute_fragment_positions(T, N, fragments) == [(-7, -7)] def test_large_input(): T = 1000 N = 3 fragments = [ (0, 0, 1, 1), (1, 1, -1, -1), (5, 5, 10, 10) ] assert compute_fragment_positions(T, N, fragments) == [(1000, 1000), (-999, -999), (10005, 10005)]","solution":"def compute_fragment_positions(T, N, fragments): result = [] for fragment in fragments: x, y, vx, vy = fragment new_x = x + T * vx new_y = y + T * vy result.append((round(new_x), round(new_y))) return result"},{"question":"def count_ways(n: int, m: int) -> int: Determine the total number of ways to choose two distinct cells in the grid such that they are in the same row or column. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: The number of valid pairs of cells. Examples: >>> count_ways(2, 2) 4 >>> count_ways(2, 3) 9 >>> count_ways(3, 3) 18 >>> count_ways(1, 10) 45 >>> count_ways(10, 1) 45 >>> count_ways(1000, 1000) 999000000 >>> count_ways(1, 1) 0","solution":"def count_ways(n, m): Returns the number of ways to choose two distinct cells in the grid such that they are in the same row or column. if n == 1 and m == 1: return 0 ways_in_rows = n * m * (m - 1) // 2 # ways to choose pairs in the same row ways_in_columns = m * n * (n - 1) // 2 # ways to choose pairs in the same column return ways_in_rows + ways_in_columns"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a simple arithmetic expression containing non-negative integers and the operators '+', '-', '*', '/' and returns the result as an integer. >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"3-2*2\\") == -1 >>> evaluate_expression(\\"3/2\\") == 1 >>> evaluate_expression(\\"3+5/2\\") == 5 >>> evaluate_expression(\\" 3 + 2 * 2 \\") == 7 >>> evaluate_expression(\\" 3 / 2 \\") == 1 >>> evaluate_expression(\\" 3 + 5 / 2 \\") == 5 >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"2*3+4\\") == 10 >>> evaluate_expression(\\"2+3*4-5\\") == 9 >>> evaluate_expression(\\"10/2+3*2\\") == 11 >>> evaluate_expression(\\"100000+200000*2\\") == 500000 >>> evaluate_expression(\\"200000*3/6\\") == 100000 >>> evaluate_expression(\\"50+10*6/3-20\\") == 50 >>> evaluate_expression(\\"14-3*2\\") == 8 pass","solution":"def evaluate_expression(expression: str) -> int: Evaluates a simple arithmetic expression containing non-negative integers and the operators '+', '-', '*', '/' and returns the result as an integer. tokens = [] num = 0 sign = '+' expression = expression.replace(\\" \\", \\"\\") # Remove any whitespaces for i, char in enumerate(expression): if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if sign == '+': tokens.append(num) elif sign == '-': tokens.append(-num) elif sign == '*': tokens[-1] = tokens[-1] * num elif sign == '/': tokens[-1] = int(tokens[-1] / num) # Truncate towards zero sign = char num = 0 return sum(tokens)"},{"question":"from typing import List class SlidingWindowMaximum: def __init__(self, nums: List[int], k: int): Initialize the object with the array nums and the size of the sliding window k. def maxSlidingWindow(self) -> List[int]: Return a list of the maximum values in each sliding window of size k in the array nums. >>> swm = SlidingWindowMaximum([1,3,-1,-3,5,3,6,7], 3) >>> swm.maxSlidingWindow() [3, 3, 5, 5, 6, 7] >>> swm = SlidingWindowMaximum([1,3,-1,-3,5,3,6,7], 1) >>> swm.maxSlidingWindow() [1, 3, -1, -3, 5, 3, 6, 7] >>> swm = SlidingWindowMaximum([1,2,3,4,5], 5) >>> swm.maxSlidingWindow() [5] >>> swm = SlidingWindowMaximum([-5, -1, -3, -4, -2], 3) >>> swm.maxSlidingWindow() [-1, -1, -2] >>> swm = SlidingWindowMaximum([4, -2, 2, -4, 5, 1], 2) >>> swm.maxSlidingWindow() [4, 2, 2, 5, 5] >>> swm = SlidingWindowMaximum([1, 2, 3, 4, 5, 6], 3) >>> swm.maxSlidingWindow() [3, 4, 5, 6]","solution":"from collections import deque from typing import List class SlidingWindowMaximum: def __init__(self, nums: List[int], k: int): self.nums = nums self.k = k def maxSlidingWindow(self) -> List[int]: result = [] dq = deque() # We will store indices here for i in range(len(self.nums)): # Remove elements not within the sliding window if dq and dq[0] < i - self.k + 1: dq.popleft() # Remove elements which are not required while dq and self.nums[dq[-1]] < self.nums[i]: dq.pop() # Add current element's index dq.append(i) # Start adding results to output list when we at least have one valid window if i >= self.k - 1: result.append(self.nums[dq[0]]) return result"},{"question":"def normalize_date(date_str: str) -> str: Converts date string to the format \\"YYYY-MM-DD\\". The input date string can be in any one of the formats: \\"YYYY/MM/DD\\", \\"DD-MM-YYYY\\", \\"MM.DD.YYYY\\". >>> normalize_date(\\"2023/03/15\\") '2023-03-15' >>> normalize_date(\\"15-03-2023\\") '2023-03-15' >>> normalize_date(\\"03.15.2023\\") '2023-03-15' >>> normalize_date(\\"2023-03-15\\") '2023-03-15'","solution":"def normalize_date(date_str): Converts date string to the format \\"YYYY-MM-DD\\". The input date string can be in any one of the formats: \\"YYYY/MM/DD\\", \\"DD-MM-YYYY\\", \\"MM.DD.YYYY\\". if '/' in date_str: # Format is \\"YYYY/MM/DD\\" year, month, day = date_str.split('/') return f\\"{year}-{month}-{day}\\" elif '-' in date_str: parts = date_str.split('-') if len(parts[0]) == 4: # Format is already \\"YYYY-MM-DD\\" return date_str else: # Format is \\"DD-MM-YYYY\\" day, month, year = parts return f\\"{year}-{month}-{day}\\" elif '.' in date_str: # Format is \\"MM.DD.YYYY\\" month, day, year = date_str.split('.') return f\\"{year}-{month}-{day}\\" # Example usage: # print(normalize_date(\\"2023/03/15\\")) # Output: \\"2023-03-15\\" # print(normalize_date(\\"15-03-2023\\")) # Output: \\"2023-03-15\\" # print(normalize_date(\\"03.15.2023\\")) # Output: \\"2023-03-15\\" # print(normalize_date(\\"2023-03-15\\")) # Output: \\"2023-03-15\\""},{"question":"def find_median_of_merged_rows(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[float]: Finds the median of merged lists from given test cases. Args: T (int): The number of test cases. test_cases (list of tuples): A list of tuples, where each tuple contains: N (int): The number of elements in the first list. N-elements list (list of int): The first row of sorted integers. M (int): The number of elements in the second list. M-elements list (list of int): The second row of sorted integers. Returns: list of floats: The medians for each test case. >>> find_median_of_merged_rows(2, [(3, [1, 3, 5], 4, [2, 4, 6, 8]), (2, [1, 2], 2, [3, 4])]) [4.0, 2.5] >>> find_median_of_merged_rows(1, [(1, [1], 1, [2])]) [1.5]","solution":"def find_median_of_merged_rows(T, test_cases): Finds the median of merged lists from given test cases. Args: T (int): The number of test cases. test_cases (list of tuples): A list of tuples, where each tuple contains: N (int): The number of elements in the first list. N-elements list (list of int): The first row of sorted integers. M (int): The number of elements in the second list. M-elements list (list of int): The second row of sorted integers. Returns: list of floats: The medians for each test case. results = [] for test_case in test_cases: N = test_case[0] row1 = test_case[1] M = test_case[2] row2 = test_case[3] # Merge the two sorted lists merged_list = sorted(row1 + row2) # Find the median total_length = N + M if total_length % 2 == 1: median = merged_list[total_length // 2] else: median = (merged_list[total_length // 2 - 1] + merged_list[total_length // 2]) / 2 results.append(round(median, 1)) return results"},{"question":"def findMostFrequentCharacter(s: str) -> str: Returns the character that appears most frequently in the string. In case of a tie, returns the character that appears first in the string. :param s: A string which may consist of letters, digits, spaces, and punctuation. :return: The character that appears the most frequently. >>> findMostFrequentCharacter(\\"hello world!\\") == \\"l\\" >>> findMostFrequentCharacter(\\"aabbcc\\") == \\"a\\" >>> findMostFrequentCharacter(\\"banana\\") == \\"a\\" >>> findMostFrequentCharacter(\\"a!a!b\\") == \\"a\\" >>> findMostFrequentCharacter(\\"!ab! b!\\") == \\"!\\" >>> findMostFrequentCharacter(\\" a\\") == \\" \\" >>> findMostFrequentCharacter(\\" a a \\") == \\" \\" >>> findMostFrequentCharacter(\\"\\") == None >>> findMostFrequentCharacter(\\"aabb\\") == \\"a\\" >>> findMostFrequentCharacter(\\"abcabc\\") == \\"a\\" >>> findMostFrequentCharacter(\\"aAa\\") == \\"a\\" >>> findMostFrequentCharacter(\\"Aaa\\") == \\"a\\"","solution":"def findMostFrequentCharacter(s): Returns the character that appears most frequently in the string. In case of a tie, returns the character that appears first in the string. :param s: A string which may consist of letters, digits, spaces, and punctuation. :return: The character that appears the most frequently. if not s: return None frequency = {} max_count = 0 most_frequent_char = s[0] for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 if frequency[char] > max_count: max_count = frequency[char] most_frequent_char = char elif frequency[char] == max_count: # tie case, return the char that appears first which is already stored in most_frequent_char continue return most_frequent_char"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Given a string \`s\`, find the length of the longest contiguous substring that is a palindrome. This function is case-insensitive. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"ac\\") 1 >>> longest_palindromic_substring_length(\\"\\") 0 >>> longest_palindromic_substring_length(\\"MadAm\\") 5 >>> longest_palindromic_substring_length(\\"racecar\\") 7 >>> longest_palindromic_substring_length(\\"aabb\\") 2 >>> longest_palindromic_substring_length(\\"AbaBa\\") 5 >>> longest_palindromic_substring_length(\\"noonabcnoondef\\") 4 pass","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the input string \`s\`. This is case-insensitive. s = s.lower() n = len(s) if n == 0: return 0 # A 2D array to store the results of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes max_length = 1 for i in range(n): dp[i][i] = True # Check for sub-strings of length 2 start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for k in range(3, n + 1): # k is the length of the substring for i in range(n - k + 1): j = i + k - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if k > max_length: start = i max_length = k return max_length"},{"question":"def manage_inventory(N, initial_items, M, restock_operations, K, queries): Manages inventory updates and answers queries about the current quantity of specific items. Parameters: N (int): number of different items in the warehouse initially initial_items (list of tuples): (item ID, quantity) for the initial items M (int): number of restock operations restock_operations (list of tuples): (item ID, restock quantity) for the restock operations K (int): number of queries queries (list of int): item IDs for which the current quantity is being queried Returns: list of int: current quantities of the queried item IDs >>> manage_inventory(3, [(101, 20), (102, 15), (103, 40)], 2, [(101, 30), (104, 50)], 3, [101, 104, 105]) [50, 50, 0] >>> manage_inventory(2, [(101, 20), (102, 30)], 0, [], 2, [101, 103]) [20, 0] >>> manage_inventory(0, [], 3, [(101, 20), (102, 40), (103, 30)], 3, [101, 102, 103]) [20, 40, 30] >>> manage_inventory(3, [(101, 20), (102, 15), (103, 40)], 3, [(101, 20), (102, 25), (103, 35)], 3, [101, 102, 103]) [40, 40, 75] >>> manage_inventory(1, [(101, 100)], 1, [(102, 200)], 1, [103]) [0] >>> manage_inventory(3, [(101, 10**9), (102, 10**9), (103, 10**9)], 2, [(101, 10**9), (104, 10**9)], 3, [101, 104, 105]) [2*10**9, 10**9, 0]","solution":"def manage_inventory(N, initial_items, M, restock_operations, K, queries): Manages inventory updates and answers queries about the current quantity of specific items. Parameters: N (int): number of different items in the warehouse initially initial_items (list of tuples): (item ID, quantity) for the initial items M (int): number of restock operations restock_operations (list of tuples): (item ID, restock quantity) for the restock operations K (int): number of queries queries (list of int): item IDs for which the current quantity is being queried Returns: list of int: current quantities of the queried item IDs inventory = {} # Add initial items to inventory for item_id, quantity in initial_items: inventory[item_id] = quantity # Process restock operations for item_id, restock_quantity in restock_operations: if item_id in inventory: inventory[item_id] += restock_quantity else: inventory[item_id] = restock_quantity # Answer queries results = [] for query in queries: results.append(inventory.get(query, 0)) return results"},{"question":"def calculate_max_unique_sequence(input_string: str) -> int: Calculate the maximum length of a sequence of unique characters from the given string. Args: input_string (str): The input string. Returns: int: The length of the longest sequence of unique consecutive characters. Examples: >>> calculate_max_unique_sequence(\\"abcabcbb\\") 3 >>> calculate_max_unique_sequence(\\"bbbbb\\") 1 >>> calculate_max_unique_sequence(\\"pwwkew\\") 3","solution":"def calculate_max_unique_sequence(input_string): Returns the maximum length of a sequence of unique characters from the given string. char_index_map = {} max_length = 0 start = 0 for end, char in enumerate(input_string): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def isValidBinaryString(s: str) -> bool: Determine if a binary string is valid. A valid binary string contains an equal number of '0's and '1's and can be divided into substrings, each of which contains an equal number of '0's and '1's. >>> isValidBinaryString(\\"1100\\") True >>> isValidBinaryString(\\"1010\\") True >>> isValidBinaryString(\\"1001\\") True >>> isValidBinaryString(\\"110011\\") False","solution":"def isValidBinaryString(s: str) -> bool: # First check if the string has an equal number of '0's and '1's if s.count('0') != s.count('1'): return False # Initialize counters count_0 = 0 count_1 = 0 # Traverse the string and make sure every substring can also be divided as required for char in s: if char == '0': count_0 += 1 if char == '1': count_1 += 1 if count_0 == count_1: count_0 = 0 count_1 = 0 # In a valid binary string this should end at zero return count_0 == 0 and count_1 == 0"},{"question":"from typing import List def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest subsequence common to both input strings str1 and str2. Examples: >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"xyz\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 # YOUR CODE HERE def test_lcs_common_subsequence(): assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 # \\"ace\\" def test_lcs_no_common_subsequence(): assert longest_common_subsequence(\\"abc\\", \\"xyz\\") == 0 # \\"\\" def test_lcs_entire_string(): assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 # \\"abc\\" def test_lcs_one_length(): assert longest_common_subsequence(\\"a\\", \\"a\\") == 1 # \\"a\\" def test_lcs_empty_strings(): assert longest_common_subsequence(\\"\\", \\"\\") == 0 # \\"\\" def test_lcs_one_empty_string1(): assert longest_common_subsequence(\\"abc\\", \\"\\") == 0 # \\"\\" def test_lcs_one_empty_string2(): assert longest_common_subsequence(\\"\\", \\"abc\\") == 0 # \\"\\" def test_lcs_partial_match(): assert longest_common_subsequence(\\"abcdef\\", \\"acef\\") == 4 # \\"acef\\" def test_lcs_repeating_characters(): assert longest_common_subsequence(\\"aabcc\\", \\"acacc\\") == 4 # \\"aacc\\" def test_lcs_large_input(): str1 = \\"a\\" * 1000 str2 = \\"a\\" * 1000 assert longest_common_subsequence(str1, str2) == 1000 # \\"aaaa....a\\" (1000 times)","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest subsequence common to both input strings str1 and str2. m = len(str1) n = len(str2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List, Tuple class Graph: def __init__(self, n: int, node_values: List[int]): self.nodes = n self.adj_list = [[] for _ in range(n)] self.values = node_values def add_edge(self, u: int, v: int): self.adj_list[u].append(v) self.adj_list[v].append(u) def dfs(self, start: int, visited: List[bool]) -> List[int]: stack = [start] path = [] while stack: node = stack.pop() if not visited[node]: visited[node] = True path.append(node) for neighbor in self.adj_list[node]: if not visited[neighbor]: stack.append(neighbor) return path def query_one(self, x: int, y: int) -> bool: visited = [False] * self.nodes path = self.dfs(x, visited) return y in path def query_two(self, x: int, y: int, val: int): visited = [False] * self.nodes path = self.dfs(x, visited) if y in path: path_to_y = path[:path.index(y) + 1] for node in path_to_y: self.values[node] += val def graph_from_input(n: int, m: int, node_values: List[int], edges: List[Tuple[int, int]]) -> Graph: graph = Graph(n, node_values) for u, v in edges: graph.add_edge(u - 1, v - 1) # converting to 0-based index return graph def process_queries(graph: Graph, queries: List[str]) -> List[str]: results = [] for query in queries: query = query.split() if query[0] == \\"1\\": x, y = int(query[1]) - 1, int(query[2]) - 1 # converting to 0-based index if graph.query_one(x, y): results.append(\\"YES\\") else: results.append(\\"NO\\") elif query[0] == \\"2\\": x, y, val = int(query[1]) - 1, int(query[2]) - 1, int(query[3]) # converting to 0-based index graph.query_two(x, y, val) return results # Unit tests import pytest def test_example_case(): n, m = 5, 4 node_values = [1, 2, 3, 4, 5] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] queries = [\\"1 1 5\\", \\"2 1 4 2\\", \\"1 1 5\\"] graph = graph_from_input(n, m, node_values, edges) results = process_queries(graph, queries) assert results == [\\"YES\\", \\"YES\\"] def test_no_path_case(): n, m = 5, 2 node_values = [1, 2, 3, 4, 5] edges = [(1, 2), (4, 5)] queries = [\\"1 1 5\\", \\"1 2 4\\", \\"1 3 5\\"] graph = graph_from_input(n, m, node_values, edges) results = process_queries(graph, queries) assert results == [\\"NO\\", \\"NO\\", \\"NO\\"] def test_path_then_update_values(): n, m = 3, 2 node_values = [1, 1, 1] edges = [(1, 2), (2, 3)] queries = [\\"1 1 3\\", \\"2 1 3 1\\", \\"1 1 3\\"] graph = graph_from_input(n, m, node_values, edges) results = process_queries(graph, queries) assert results == [\\"YES\\", \\"YES\\"] assert graph.values == [2, 2, 2] def test_complex_case(): n, m = 6, 5 node_values = [1, 1, 1, 1, 1, 1] edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] queries = [\\"1 1 6\\", \\"2 2 5 3\\", \\"1 1 6\\", \\"1 2 6\\"] graph = graph_from_input(n, m, node_values, edges) results = process_queries(graph, queries) assert results == [\\"YES\\", \\"YES\\", \\"YES\\"] assert graph.values == [1, 4, 4, 4, 4, 1]","solution":"class Graph: def __init__(self, n, node_values): self.nodes = n self.adj_list = [[] for _ in range(n)] self.values = node_values def add_edge(self, u, v): self.adj_list[u].append(v) self.adj_list[v].append(u) def dfs(self, start, visited): stack = [start] path = [] while stack: node = stack.pop() if not visited[node]: visited[node] = True path.append(node) for neighbor in self.adj_list[node]: if not visited[neighbor]: stack.append(neighbor) return path def query_one(self, x, y): visited = [False] * self.nodes path = self.dfs(x, visited) return y in path def query_two(self, x, y, val): visited = [False] * self.nodes path = self.dfs(x, visited) if y in path: path_to_y = path[:path.index(y) + 1] for node in path_to_y: self.values[node] += val def graph_from_input(n, m, node_values, edges): graph = Graph(n, node_values) for u, v in edges: graph.add_edge(u - 1, v - 1) # converting to 0-based index return graph def process_queries(graph, queries): results = [] for query in queries: query = query.split() if query[0] == \\"1\\": x, y = int(query[1]) - 1, int(query[2]) - 1 # converting to 0-based index if graph.query_one(x, y): results.append(\\"YES\\") else: results.append(\\"NO\\") elif query[0] == \\"2\\": x, y, val = int(query[1]) - 1, int(query[2]) - 1, int(query[3]) # converting to 0-based index graph.query_two(x, y, val) return results"},{"question":"import re from typing import List, Tuple def most_frequent_words(text: str) -> List[Tuple[str, int]]: Analyzes text for the most frequently occurring words. Parameters: text (str): Input string containing sentences or paragraphs. Returns: list: A list of tuples (word, frequency) sorted by frequency in descending order, then alphabetically in case of a tie. >>> most_frequent_words(\\"Hello, world! Hello world.\\") [('hello', 2), ('world', 2)] >>> most_frequent_words(\\"A cat in a hat.\\") [('a', 2), ('cat', 1), ('hat', 1), ('in', 1)] >>> most_frequent_words(\\"Test, test, TEST!\\") [('test', 3)] >>> most_frequent_words(\\"Testing 1 2 3 1 2 3 1 2 3\\") [('1', 3), ('2', 3), ('3', 3), ('testing', 1)] >>> most_frequent_words(\\"The quick brown fox jumps over the lazy dog. The quick brown fox!\\") [('the', 3), ('brown', 2), ('fox', 2), ('quick', 2), ('dog', 1), ('jumps', 1), ('lazy', 1), ('over', 1)] >>> most_frequent_words(\\"apple apple banana banana cherry\\") [('apple', 2), ('banana', 2), ('cherry', 1)]","solution":"import re from collections import Counter def most_frequent_words(text): Analyzes text for the most frequently occurring words. Parameters: text (str): Input string containing sentences or paragraphs. Returns: list: A list of tuples (word, frequency) sorted by frequency in descending order, then alphabetically in case of a tie. # Normalize the text: convert to lowercase text = text.lower() # Remove punctuation using regex and split text into words words = re.findall(r'bw+b', text) # Count the frequency of each word using Counter word_count = Counter(words) # Create a sorted list of (word, frequency) tuples sorted_word_count = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) return sorted_word_count"},{"question":"from typing import List, Tuple def navigate_warehouse(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determine the minimum number of moves required to reach the bottom-right corner of the warehouse grid from the top-left corner or determine if it's impossible. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[str]]]): List of test cases where each test case is a tuple containing: - N (int): Number of rows in the grid - M (int): Number of columns in the grid - grid (List[str]): N strings of length M representing the grid. Each character is either 'P' (denoting a package) or '.' (denoting an empty space). Returns: List[int]: For each test case, return the minimum number of moves required to reach the bottom-right corner, or -1 if it's impossible. Example: >>> navigate_warehouse(2, [ (3, 3, [ \\"...\\", \\"..P\\", \\"P..\\" ]), (3, 3, [ \\".P.\\", \\"PPP\\", \\"..P\\" ]) ]) [4, -1] >>> navigate_warehouse(1, [ (2, 2, [ \\".P\\", \\"P.\\" ]) ]) [-1]","solution":"from collections import deque def navigate_warehouse(T, test_cases): results = [] for k in range(T): N, M, grid = test_cases[k] que = deque([(0, 0, 0)]) # (row, col, moves) visited = set((0, 0)) while que: r, c, moves = que.popleft() if (r, c) == (N - 1, M - 1): results.append(moves) break for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == '.' and (nr, nc) not in visited: visited.add((nr, nc)) que.append((nr, nc, moves + 1)) else: results.append(-1) return results def main(tasks): T = len(tasks) results = navigate_warehouse(T, tasks) return results"},{"question":"def maxProduct(nums: List[int]) -> int: Given an array of integers, find the maximum product subarray. The maximum product subarray is the contiguous subarray within an array which has the largest product. >>> maxProduct([2, 3, -2, 4]) 6 >>> maxProduct([-2, 0, -1]) 0 >>> maxProduct([-2, 3, -4]) 24 >>> maxProduct([3]) 3 >>> maxProduct([-3]) -3 >>> maxProduct([]) 0 >>> maxProduct([2, -5, -2, -4, 3]) 24 >>> maxProduct([2, 1, -1, -1, 1, 1]) 2","solution":"def maxProduct(nums): if not nums: return 0 current_max = current_min = result = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) result = max(result, current_max) return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes all duplicate elements from the linked list, ensuring each value appears only once and preserving the original order of elements. pass def linked_list_to_list(head): Converts a linked list to a list of values. pass def list_to_linked_list(elements): Converts a list of values to a linked list. pass def test_remove_duplicates_empty_list(): assert remove_duplicates(None) is None def test_remove_duplicates_no_duplicates(): head = list_to_linked_list([1, 2, 3, 4]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1, 2, 3, 4] def test_remove_duplicates_with_duplicates(): head = list_to_linked_list([5, 2, 3, 2, 4, 5, 3]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [5, 2, 3, 4] def test_remove_duplicates_all_same_elements(): head = list_to_linked_list([1, 1, 1, 1]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1] def test_remove_duplicates_single_element(): head = list_to_linked_list([1]) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes all duplicate elements from the linked list, ensuring each value appears only once and preserving the original order of elements. if not head: return head seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"import re def is_palindrome(s: str) -> bool: Check if a given string is a valid palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. Parameters: s (str): The input string to check. Returns: bool: True if the processed string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"No 'x' in Nixon\\") True","solution":"import re def is_palindrome(s): Checks if the given string is a palindrome after conversion as described. Parameters: s (str): The input string to check. Returns: bool: True if the processed string is a palindrome, False otherwise. # Remove all non-alphanumeric characters and convert to lower case processed_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the processed string is equal to its reverse return processed_string == processed_string[::-1]"},{"question":"def find_possible_words(letters: str, wordList: list) -> list: This function finds all possible words that can be formed using exactly the given letters from the provided word list. Parameters: letters (str): A string of given letters. wordList (list): A list of valid words. Returns: list: A list of words that can be formed using exactly the given letters.","solution":"def find_possible_words(letters, wordList): This function finds all possible words that can be formed using exactly the given letters from the provided word list. Parameters: letters (str): A string of given letters. wordList (list): A list of valid words. Returns: list: A list of words that can be formed using exactly the given letters. from collections import Counter letters_count = Counter(letters) result = [] for word in wordList: if Counter(word) == letters_count: result.append(word) return result"},{"question":"from typing import List import re def extract_years(text: str) -> List[int]: Extracts unique years from dates in the given text where dates are in the format \\"dd-mm-yyyy\\". >>> extract_years(\\"I was born on 12-05-1990 and my sister on 23-11-1992.\\") [1990, 1992] >>> extract_years(\\"03-03-2001 is a date and 14-07-2001 is another date.\\") [2001] >>> extract_years(\\"There are no dates here!\\") [] >>> extract_years(\\"12-12-2019, 25-12-2020, 31-12-2021 and 01-01-2022.\\") [2019, 2020, 2021, 2022] >>> extract_years(\\"My birthdays: 01-01-2000, 01-01-2000, 01-01-2001\\") [2000, 2001]","solution":"import re def extract_years(text): Extracts unique years from dates in the given text where dates are in the format \\"dd-mm-yyyy\\". # Regex to match dates in the format dd-mm-yyyy date_pattern = re.compile(r'bd{2}-d{2}-(d{4})b') # Find all matches and extract the year (group 1) years = {int(match.group(1)) for match in date_pattern.finditer(text)} # Return the sorted list of years as integers return sorted(years)"},{"question":"def update_available_books(available_books, reserved_books): Returns a new list of available books after removing reserved books. Args: available_books (list of str): list of books currently available. reserved_books (list of str): list of books that have been reserved. Returns: list of str: updated list of available books. >>> available_books = [\\"Harry Potter\\", \\"To Kill a Mockingbird\\", \\"1984\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"] >>> reserved_books = [\\"1984\\", \\"The Lord of the Rings\\"] >>> update_available_books(available_books, reserved_books) [\\"Harry Potter\\", \\"To Kill a Mockingbird\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"]","solution":"def update_available_books(available_books, reserved_books): Returns a new list of available books after removing reserved books. Args: available_books (list of str): list of books currently available. reserved_books (list of str): list of books that have been reserved. Returns: list of str: updated list of available books. updated_available = [book for book in available_books if book not in reserved_books] return updated_available"},{"question":"def sum_polynomials(poly1: str, poly2: str) -> str: Given two strings representing simplified polynomials, sum them up and return the result as a string of a simplified polynomial in descending order of powers. >>> sum_polynomials(\\"3x^2+4x+1\\", \\"2x^2+5\\") \\"5x^2+4x+6\\" >>> sum_polynomials(\\"6a\\", \\"7a^2+2a+3\\") \\"7a^2+8a+3\\" >>> sum_polynomials(\\"5z^3+2z^1+1\\", \\"\\") \\"5z^3+2z+1\\" from solution import sum_polynomials def test_sum_polynomials(): assert sum_polynomials(\\"3x^2+4x+1\\", \\"2x^2+5\\") == \\"5x^2+4x+6\\" assert sum_polynomials(\\"6a\\", \\"7a^2+2a+3\\") == \\"7a^2+8a+3\\" assert sum_polynomials(\\"5z^3+2z^1+1\\", \\"\\") == \\"5z^3+2z+1\\" assert sum_polynomials(\\"\\", \\"3x^2+4z+1\\") == \\"3x^2+4z+1\\" assert sum_polynomials(\\"4y^2+3y\\", \\"2y^2+5y\\") == \\"6y^2+8y\\" assert sum_polynomials(\\"2m\\", \\"3m\\") == \\"5m\\" assert sum_polynomials(\\"5\\", \\"3\\") == \\"8\\" assert sum_polynomials(\\"a^2+a+1\\", \\"a^2+a+1\\") == \\"2a^2+2a+2\\" assert sum_polynomials(\\"3x^2\\", \\"4y^2\\") == \\"3x^2+4y^2\\" assert sum_polynomials(\\"2x^3+3x^2+4x+5\\", \\"3x^3+4x^2+5x+6\\") == \\"5x^3+7x^2+9x+11\\"","solution":"import re from collections import defaultdict def parse_polynomial(poly): Parses a polynomial string into a dictionary with keys as (variable, power) and values as coefficients. if not poly: return defaultdict(int) terms = poly.split('+') poly_dict = defaultdict(int) for term in terms: match = re.match(r'(d*)([a-z])(^(-?d+))?', term) if match: coef_str, var, _, power_str = match.groups() coef = int(coef_str) if coef_str else 1 power = int(power_str) if power_str else 1 poly_dict[(var, power)] += coef else: # constant term poly_dict[('', 0)] += int(term) return poly_dict def sum_polynomials(poly1, poly2): Sums up two polynomial strings and returns a simplified polynomial string. poly1_terms = parse_polynomial(poly1) poly2_terms = parse_polynomial(poly2) # Combine like terms from both polynomials result_terms = poly1_terms.copy() for key, value in poly2_terms.items(): result_terms[key] += value # Sort terms in descending order of power, and then assemble the result string sorted_terms = sorted(result_terms.items(), key=lambda x: (-x[0][1], x[0][0])) result = [] for (var, power), coef in sorted_terms: if coef != 0: if var: if power == 1: term = f\\"{coef}{var}\\" else: term = f\\"{coef}{var}^{power}\\" else: term = str(coef) result.append(term) return '+'.join(result)"},{"question":"def find_largest_k(n: int) -> int: Returns the largest number k such that k! <= n. Examples: >>> find_largest_k(3) 2 >>> find_largest_k(6) 3 >>> find_largest_k(24) 4 >>> find_largest_k(120) 5 >>> find_largest_k(720) 6 >>> find_largest_k(1) 0 pass","solution":"def find_largest_k(n: int) -> int: Returns the largest number k such that k! <= n. if n == 1: return 0 factorial = 1 k = 1 while True: factorial = factorial * k if factorial > n: return k - 1 k += 1"},{"question":"def min_operations_to_one(n: int) -> int: Determines the minimum number of operations required to reduce \`n\` to 1 using the allowed operations: if n is even, divide it by 2; if n is divisible by 3, divide it by 3; subtract 1 from n. >>> min_operations_to_one(10) 3 >>> min_operations_to_one(15) 4 >>> min_operations_to_one(1) 0 >>> min_operations_to_one(7) 3 >>> min_operations_to_one(27) 3 >>> min_operations_to_one(1000000) 19","solution":"def min_operations_to_one(n): Determines the minimum number of operations required to reduce \`n\` to 1 using the allowed operations. if n == 1: return 0 # Using dynamic programming to store minimum operations for each number up to n dp = [0] * (n + 1) for i in range(2, n + 1): # Start with the operation of subtracting 1 dp[i] = dp[i - 1] + 1 # If divisible by 2, consider the operation of division by 2 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) # If divisible by 3, consider the operation of division by 3 if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"def count_images_loaded(n: int, w: int, positions: List[int]) -> int: Counts the number of images that would be loaded as a viewport traverses the coordinate system. Parameters: n (int): number of images. w (int): width of the viewport. positions (list of int): positions of the images in non-decreasing order. Returns: int: total number of images loaded. >>> count_images_loaded(5, 3, [1, 2, 4, 5, 7]) 5 >>> count_images_loaded(6, 4, [1, 2, 3, 5, 8, 10]) 6","solution":"def count_images_loaded(n, w, positions): Counts the number of images that would be loaded as a viewport traverses the coordinate system. Parameters: n (int): number of images. w (int): width of the viewport. positions (list of int): positions of the images in non-decreasing order. Returns: int: total number of images loaded. # Variable to store the number of loaded images loaded_images = set() # Iterating over each position and checking if it's within the visible viewport for pos in positions: loaded_images.add(pos) return len(loaded_images)"},{"question":"def trailing_zeroes(n: int) -> int: Returns the number of trailing zeros in n!. >>> trailing_zeroes(3) 0 >>> trailing_zeroes(5) 1 >>> trailing_zeroes(100) 24","solution":"def trailing_zeroes(n): Returns the number of trailing zeros in n!. count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"def count_allowed_substrings(s: str, banned_substrings: List[str]) -> int: Returns the number of substrings of s that are not in the list of banned_substrings. :param s: Input string of lowercase alphabetic characters. :param banned_substrings: List of banned substrings. :return: Number of allowed substrings. >>> count_allowed_substrings(\\"abc\\", []) 6 >>> count_allowed_substrings(\\"abc\\", [\\"a\\", \\"bc\\"]) 4 >>> count_allowed_substrings(\\"\\", []) 0 >>> count_allowed_substrings(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"]) 0 >>> count_allowed_substrings(\\"abcd\\", [\\"a\\", \\"bc\\", \\"d\\"]) 7 >>> count_allowed_substrings(\\"abc\\", [\\"x\\", \\"y\\", \\"z\\"]) 6","solution":"def count_allowed_substrings(s, banned_substrings): Returns the number of substrings of s that are not in the list of banned_substrings. :param s: Input string of lowercase alphabetic characters. :param banned_substrings: List of banned substrings. :return: Number of allowed substrings. n = len(s) all_substrings = set() # Generate all possible substrings for i in range(n): for j in range(i + 1, n + 1): all_substrings.add(s[i:j]) # Subtract the banned substrings for banned in banned_substrings: if banned in all_substrings: all_substrings.remove(banned) return len(all_substrings)"},{"question":"def capitalize_concatenate(words): Receives a list of strings and returns a concatenated string with each word starting with an uppercase letter followed by lowercase letters. Non-alphabetic characters are removed. Args: words (list of str): List of words to be concatenated. Returns: str: Concatenated string with formatted words. >>> capitalize_concatenate([\\"hello\\"]) == \\"Hello\\" >>> capitalize_concatenate([\\"hello\\", \\"world\\"]) == \\"HelloWorld\\" >>> capitalize_concatenate([\\"PYTHON\\", \\"is\\", \\"Fun\\"]) == \\"PythonIsFun\\" >>> capitalize_concatenate([\\"hello123\\", \\"world!\\"]) == \\"HelloWorld\\" >>> capitalize_concatenate([\\"1PYTHON\\", \\"!is\\", \\"Fun*\\"]) == \\"PythonIsFun\\" >>> capitalize_concatenate([\\"hElLo\\", \\"wOrLd\\"]) == \\"HelloWorld\\" >>> capitalize_concatenate([\\"pyThOn\\", \\"is\\", \\"fUn\\"]) == \\"PythonIsFun\\" >>> capitalize_concatenate([]) == \\"\\" >>> capitalize_concatenate([\\"1234\\", \\"!!@@\\"]) == \\"\\" >>> capitalize_concatenate([\\"\\", \\"hello\\", \\"\\", \\"world\\"]) == \\"HelloWorld\\" pass","solution":"import re def capitalize_concatenate(words): Receives a list of strings and returns a concatenated string with each word starting with an uppercase letter followed by lowercase letters. Non-alphabetic characters are removed. Args: words (list of str): List of words to be concatenated. Returns: str: Concatenated string with formatted words. result = [] for word in words: cleaned_word = re.sub(r'[^A-Za-z]', '', word) if cleaned_word: result.append(cleaned_word.capitalize()) return ''.join(result)"},{"question":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams from the given list of words. Parameters: words (list of str): A list of strings. Returns: list of list of str: A list of lists where each inner list contains anagram words. Example: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"\\"]) [[\\"\\"]] >>> group_anagrams([\\"a\\"]) [[\\"a\\"]]","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams from the given list of words. Parameters: words (list of str): A list of strings. Returns: list of list of str: A list of lists where each inner list contains anagram words. anagram_groups = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_groups[sorted_word].append(word) return list(anagram_groups.values())"},{"question":"def can_arrange_strings(n: int, strings: List[str]) -> str: Determines whether it is possible to arrange the strings such that the resulting concatenated string contains no two adjacent \\"X\\" occurrences. Parameters: n (int): The number of strings. strings (list): A list of strings, each being \\"X\\" or a combination of \\"OX\\" and \\"XO\\". Returns: str: \\"YES\\" if it is possible to arrange the strings, otherwise \\"NO\\". >>> can_arrange_strings(5, [\\"X\\", \\"OX\\", \\"XO\\", \\"X\\", \\"OX\\"]) 'NO' >>> can_arrange_strings(3, [\\"OX\\", \\"XO\\", \\"OX\\"]) 'YES'","solution":"def can_arrange_strings(n, strings): Determines whether it is possible to arrange the strings such that the resulting concatenated string contains no two adjacent \\"X\\" occurrences. Parameters: n (int): The number of strings. strings (list): A list of strings, each being \\"X\\" or a combination of \\"OX\\" and \\"XO\\". Returns: str: \\"YES\\" if it is possible to arrange the strings, otherwise \\"NO\\". x_count = strings.count(\\"X\\") if x_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def find_pairs(lst: List[int], target: int) -> List[Tuple[int, int]]: Write a function that takes a list of integers and a target sum. The function should return all unique pairs of integers from the list that add up to the target sum. Each pair should be sorted in ascending order, and the list of pairs should be sorted lexicographically. >>> find_pairs([1, 2, -2, 0, -1, 1, 2], 0) [(-2, 2), (-1, 1)] >>> find_pairs([1, 2, 3, 4, 5], 10) [] >>> find_pairs([0, 0, 0, 0], 0) [(0, 0)] >>> find_pairs([-3, -1, 1, 2, 3, -2, 0, 4], 1) [(-3, 4), (-2, 3), (-1, 2), (0, 1)] >>> find_pairs([1, 1, 1, -1, -1, -1], 0) [(-1, 1)] >>> find_pairs([-5, -4, -3, -2, -1], -6) [(-5, -1), (-4, -2)]","solution":"from typing import List, Tuple def find_pairs(lst: List[int], target: int) -> List[Tuple[int, int]]: Returns all unique pairs of integers from the list that add up to the target sum. Each pair is sorted in ascending order, and the list of pairs is sorted lexicographically. seen = set() output = set() for number in lst: needed = target - number if needed in seen: pair = tuple(sorted((number, needed))) output.add(pair) seen.add(number) return sorted(output)"},{"question":"from typing import List, Tuple, Dict def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int, N: int) -> int: Uses Dijkstra's algorithm to find the shortest path in a graph. Parameters: graph (dict): Adjacency list of the graph with nodes as keys and list of (node, weight) as values. start (int): The starting node. end (int): The ending node. N (int): The number of nodes in the graph. Returns: int: The length of the shortest path from start to end, or -1 if there is no path. pass def shortest_path(T: int, test_cases: List[Dict[str, Tuple[int, int, int, List[Tuple[int, int, int]]]]]) -> List[int]: Finds the shortest path for multiple test cases in a directed graph with weighted edges. Parameters: T (int): The number of test cases. test_cases (list): A list of dictionaries containing 'meta' tuple with (N, M, S), 'end' node E, and 'edges' list. Returns: list: A list of the shortest path lengths for each test case. pass # Test cases def test_shortest_path_case_1(): T = 2 test_cases = [ { 'meta': (4, 4, 1), 'end': 3, 'edges': [ (1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 1) ] }, { 'meta': (5, 5, 1), 'end': 5, 'edges': [ (1, 2, 2), (2, 3, 1), (3, 4, 3), (4, 5, 4), (1, 5, 10) ] } ] assert shortest_path(T, test_cases) == [3, 10] def test_shortest_path_no_path(): T = 1 test_cases = [ { 'meta': (3, 2, 1), 'end': 3, 'edges': [ (1, 2, 1), (2, 1, 1) ] } ] assert shortest_path(T, test_cases) == [-1] def test_shortest_path_single_node(): T = 1 test_cases = [ { 'meta': (1, 0, 1), 'end': 1, 'edges': [] } ] assert shortest_path(T, test_cases) == [0] def test_shortest_path_single_edge(): T = 1 test_cases = [ { 'meta': (2, 1, 1), 'end': 2, 'edges': [ (1, 2, 5) ] } ] assert shortest_path(T, test_cases) == [5] def test_shortest_path_multiple_paths(): T = 1 test_cases = [ { 'meta': (4, 5, 1), 'end': 4, 'edges': [ (1, 2, 1), (2, 4, 10), (1, 3, 1), (3, 4, 1), (2, 3, 1) ] } ] assert shortest_path(T, test_cases) == [2]","solution":"import heapq def dijkstra(graph, start, end, N): # Initialize distances with infinity distance = {i: float('inf') for i in range(1, N+1)} distance[start] = 0 # Priority queue for the nodes to visit pq = [(0, start)] # (distance, node) while pq: current_distance, u = heapq.heappop(pq) if current_distance > distance[u]: continue for v, weight in graph[u]: distance_through_u = current_distance + weight if distance_through_u < distance[v]: distance[v] = distance_through_u heapq.heappush(pq, (distance_through_u, v)) return distance[end] if distance[end] != float('inf') else -1 def shortest_path(T, test_cases): results = [] for case in test_cases: N, M, S = case['meta'] E = case['end'] edges = case['edges'] graph = {i: [] for i in range(1, N+1)} for u, v, w in edges: graph[u].append((v, w)) shortest_distance = dijkstra(graph, S, E, N) results.append(shortest_distance) return results"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest subsequence such that all elements of the subsequence are consecutive integers. The consecutive numbers can be in any order in the original list. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([9, 1, 8, 7, 2, 3]) 3","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest subsequence such that all elements of the subsequence are consecutive integers. The consecutive numbers can be in any order in the original list. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # only check for the beginning of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def sieve_of_eratosthenes(max_num): Generate a list of boolean values representing the primality of numbers from 0 to max_num. is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False p = 2 while p * p <= max_num: if is_prime[p]: for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 return is_prime def prime_selection(n, q, elements, queries): For each query, output the k-th smallest prime number from the list if it exists, otherwise output -1. >>> prime_selection(6, 3, [2, 17, 11, 4, 7, 20], [1, 3, 5]) [2, 11, -1] >>> prime_selection(5, 2, [1, 5, 3, 9, 6], [2, 1]) [5, 3] from solution import prime_selection def test_prime_selection_example_1(): n = 6 q = 3 elements = [2, 17, 11, 4, 7, 20] queries = [1, 3, 5] assert prime_selection(n, q, elements, queries) == [2, 11, -1] def test_prime_selection_example_2(): n = 5 q = 2 elements = [1, 5, 3, 9, 6] queries = [2, 1] assert prime_selection(n, q, elements, queries) == [5, 3] def test_prime_selection_no_primes(): n = 4 q = 2 elements = [1, 4, 6, 8] queries = [1, 2] assert prime_selection(n, q, elements, queries) == [-1, -1] def test_prime_selection_single_prime(): n = 3 q = 3 elements = [9, 22, 11] queries = [1, 2, 3] assert prime_selection(n, q, elements, queries) == [11, -1, -1] def test_prime_selection_large_query(): n = 6 q = 1 elements = [2, 3, 5, 7, 11, 13] queries = [10] assert prime_selection(n, q, elements, queries) == [-1] def test_prime_selection_multiple_primes(): n = 5 q = 3 elements = [29, 11, 17, 23, 19] queries = [1, 4, 2] assert prime_selection(n, q, elements, queries) == [11, 23, 17]","solution":"import bisect def sieve_of_eratosthenes(max_num): is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False p = 2 while p * p <= max_num: if is_prime[p]: for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 return is_prime def prime_selection(n, q, elements, queries): max_element = max(elements) is_prime = sieve_of_eratosthenes(max_element) primes = sorted([x for x in elements if is_prime[x]]) results = [] for k in queries: if k <= len(primes): results.append(primes[k - 1]) else: results.append(-1) return results"},{"question":"def min_cuts_needed(N: int, heights: List[int]) -> int: Determine the minimum number of trees that need to be cut down to make sure that no two adjacent trees have the same height. >>> min_cuts_needed(5, [1, 2, 3, 2, 1]) == 0 >>> min_cuts_needed(6, [4, 4, 4, 4, 4, 4]) == 5 >>> min_cuts_needed(7, [4, 2, 4, 2, 4, 2, 4]) == 0 pass def process_queries(T: int, queries: List[Tuple[int, List[int]]]) -> List[int]: Process multiple queries to determine the minimum number of cuts required for each forest described in the queries. >>> process_queries(3, [(5, [1, 2, 3, 2, 1]), (6, [4, 4, 4, 4, 4, 4]), (7, [4, 2, 4, 2, 4, 2, 4])]) == [0, 5, 0] pass","solution":"def min_cuts_needed(N, heights): cuts = 0 for i in range(1, N): if heights[i] == heights[i-1]: cuts += 1 return cuts def process_queries(T, queries): results = [] for i in range(T): N = queries[i][0] heights = queries[i][1] results.append(min_cuts_needed(N, heights)) return results"},{"question":"def count_valid_subarrays(n, arr): Determine the number of contiguous subarrays such that the sum of the subarray is equal to its length multiplied by the maximum element in that subarray. >>> count_valid_subarrays(4, [1, 2, 3, 4]) 4 >>> count_valid_subarrays(5, [1, 1, 1, 1, 1]) 15 >>> count_valid_subarrays(3, [1, 2, 1]) 3 >>> count_valid_subarrays(4, [2, 2, 2, 2]) 10 >>> count_valid_subarrays(1, [1]) 1 >>> count_valid_subarrays(2, [1, 2]) 2 >>> count_valid_subarrays(3, [3, 3, 3]) 6 >>> count_valid_subarrays(4, [1, 3, 2, 5]) 4","solution":"def count_valid_subarrays(n, arr): def count_from(i, max_elem, curr_sum): valid_subarray_count = 0 for j in range(i, n): max_elem = max(max_elem, arr[j]) curr_sum += arr[j] if curr_sum == (j - i + 1) * max_elem: valid_subarray_count += 1 return valid_subarray_count total_valid_subarray_count = 0 for i in range(n): total_valid_subarray_count += count_from(i, 0, 0) return total_valid_subarray_count"},{"question":"def smallest_subarray_with_given_sum(arr: List[int], k: int) -> List[int]: Returns the smallest subarray whose sum is greater than or equal to k. If no such subarray exists, returns an empty list. >>> smallest_subarray_with_given_sum([2, 1, 5, 2, 8], 7) [8] >>> smallest_subarray_with_given_sum([2, 3, 1, 2, 4, 3], 7) [4, 3] >>> smallest_subarray_with_given_sum([1, 2, 3, 4, 5], 15) [1, 2, 3, 4, 5] >>> smallest_subarray_with_given_sum([1, 1, 1], 4) [] >>> smallest_subarray_with_given_sum([10], 9) [10] >>> smallest_subarray_with_given_sum([5], 5) [5] >>> smallest_subarray_with_given_sum([1], 10) [] >>> smallest_subarray_with_given_sum([1, 2, 1, 1], 10) [] >>> smallest_subarray_with_given_sum([2, 3, 1, 1], 7) [2, 3, 1, 1]","solution":"def smallest_subarray_with_given_sum(arr, k): Returns the smallest subarray whose sum is greater than or equal to k. If no such subarray exists, returns an empty list. from sys import maxsize n = len(arr) min_length = maxsize start_index = 0 current_sum = 0 result = [] for end_index in range(n): current_sum += arr[end_index] while current_sum >= k: if end_index - start_index + 1 < min_length: min_length = end_index - start_index + 1 result = arr[start_index:end_index + 1] current_sum -= arr[start_index] start_index += 1 return result"},{"question":"from typing import List, Tuple def find_gcds(pairs: List[Tuple[int, int]]) -> List[int]: Takes a list of integer pairs and returns a list of their greatest common divisors (GCD). Each pair consists of two positive integers. The order in the output list corresponds to the order of pairs in the input list. >>> find_gcds([(8, 12), (9, 27), (20, 30)]) [4, 9, 10] >>> find_gcds([(14, 35), (18, 24)]) [7, 6] pass def test_find_gcds(): assert find_gcds([(8, 12), (9, 27), (20, 30)]) == [4, 9, 10] assert find_gcds([(14, 35), (18, 24)]) == [7, 6] assert find_gcds([(42, 56), (100, 200)]) == [14, 100] assert find_gcds([(81, 27), (49, 21)]) == [27, 7] assert find_gcds([]) == [] def test_find_gcds_single_pair(): assert find_gcds([(6, 9)]) == [3] assert find_gcds([(10, 10)]) == [10] def test_find_gcds_coprime_pairs(): assert find_gcds([(8, 15), (7, 13)]) == [1, 1]","solution":"from typing import List, Tuple def gcd(a: int, b: int) -> int: Computes the Greatest Common Divisor (GCD) of two integers using the Euclidean algorithm. while b: a, b = b, a % b return a def find_gcds(pairs: List[Tuple[int, int]]) -> List[int]: Takes a list of integer pairs and returns a list of their greatest common divisors (GCD). return [gcd(a, b) for a, b in pairs]"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams together from the given list of words. Args: words: List[str] - List of words Returns: List[List[str]] - List of groups of anagrams Examples: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"\\"]) [['']] >>> group_anagrams([\\"a\\"]) [['a']] >>> group_anagrams([\\"ab\\", \\"ba\\", \\"abc\\", \\"cba\\", \\"bca\\", \\"cab\\", \\"a\\"]) [['ab', 'ba'], ['abc', 'cba', 'bca', 'cab'], ['a']] from solution import group_anagrams def test_group_anagrams_example1(): assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] def test_group_anagrams_example2(): assert group_anagrams([\\"\\"]) == [[\\"\\"]] def test_group_anagrams_example3(): assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] def test_group_anagrams_example4(): assert group_anagrams([\\"ab\\", \\"ba\\", \\"abc\\", \\"cba\\", \\"bca\\", \\"cab\\", \\"a\\"]) == [[\\"ab\\", \\"ba\\"], [\\"abc\\", \\"cba\\", \\"bca\\", \\"cab\\"], [\\"a\\"]] def test_group_anagrams_empty_list(): assert group_anagrams([]) == [] def test_group_anagrams_identical_words(): assert group_anagrams([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) == [[\\"aaa\\", \\"aaa\\", \\"aaa\\"]] def test_group_anagrams_no_anagrams(): assert group_anagrams([\\"cat\\", \\"dog\\", \\"bird\\"]) == [[\\"cat\\"], [\\"dog\\"], [\\"bird\\"]] def test_group_anagrams_mixed_lengths(): assert group_anagrams([\\"abc\\", \\"bac\\", \\"a\\", \\"bca\\", \\"cab\\", \\"c\\", \\"ab\\"]) == [['abc', 'bac', 'bca', 'cab'], ['a'], ['c'], ['ab']]","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams together from the given list of words. Args: words: List[str] - List of words Returns: List[List[str]] - List of groups of anagrams anagram_map = defaultdict(list) for word in words: # Create a sorted tuple of the word's characters key = tuple(sorted(word)) anagram_map[key].append(word) return list(anagram_map.values())"},{"question":"def has_pair_with_sum(nums, target): Determines if any two distinct elements in the list sum up to the target integer. Args: nums (list of int): List of integers. target (int): The target sum. Returns: bool: True if any two distinct elements sum up to the target, False otherwise. Examples: >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False from solution import has_pair_with_sum def test_has_pair_with_sum_examples(): assert has_pair_with_sum([10, 15, 3, 7], 17) == True assert has_pair_with_sum([1, 2, 3, 9], 8) == False def test_has_pair_with_sum_empty_list(): assert has_pair_with_sum([], 10) == False def test_has_pair_with_sum_single_element(): assert has_pair_with_sum([5], 10) == False def test_has_pair_with_sum_no_pair(): assert has_pair_with_sum([1, 2, 4, 5], 10) == False def test_has_pair_with_sum_contains_pair(): assert has_pair_with_sum([1, 2, 4, 5], 6) == True def test_has_pair_with_sum_multiple_elements(): assert has_pair_with_sum([-1, -2, -3, -4, 0, 1, 2, 3], 0) == True def test_has_pair_with_sum_large_numbers(): assert has_pair_with_sum([1000000, 2000000, -1000000, -2000000], 0) == True def test_has_pair_with_sum_same_elements(): assert has_pair_with_sum([5, 5, 5], 10) == True def test_has_pair_with_sum_no_self_pair(): assert has_pair_with_sum([1, 3, 5, 7], 2) == False","solution":"def has_pair_with_sum(nums, target): Determines if any two distinct elements in nums sum up to target. Args: nums (list): List of integers. target (int): The target sum. Returns: bool: True if any two distinct elements sum up to target, False otherwise. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"import re from typing import List def are_anagrams(word1: str, word2: str) -> bool: Check if two words are anagrams, ignoring case, spaces and punctuation. >>> are_anagrams(\\"Listen\\", \\"Silent\\") == True >>> are_anagrams(\\"A gentleman\\", \\"Elegant man!\\") == True >>> are_anagrams(\\"Hello\\", \\"Olelh\\") == True >>> are_anagrams(\\"World\\", \\"Word\\") == False pass def test_anagrams_case_insensitive(): assert are_anagrams(\\"Listen\\", \\"Silent\\") == True assert are_anagrams(\\"Triangle\\", \\"Integral\\") == True def test_anagrams_with_spaces_and_punctuation(): assert are_anagrams(\\"A gentleman\\", \\"Elegant man!\\") == True assert are_anagrams(\\"Dormitory\\", \\"Dirty room!!!\\") == True def test_not_anagrams_different_lengths(): assert are_anagrams(\\"Hello\\", \\"Olelh\\") == True assert are_anagrams(\\"World\\", \\"Word\\") == False def test_not_anagrams_same_lengths(): assert are_anagrams(\\"Hello\\", \\"Helol\\") == True assert are_anagrams(\\"Test\\", \\"Best\\") == False def test_anagrams_with_same_letters_different_counts(): assert are_anagrams(\\"aabbcc\\", \\"bbaacc\\") == True assert are_anagrams(\\"aabbcc\\", \\"abcd\\") == False def test_anagrams_empty_strings(): assert are_anagrams(\\"\\", \\"\\") == True assert are_anagrams(\\" \\", \\"!!!\\") == True","solution":"import re def are_anagrams(word1, word2): Check if the two words are anagrams, ignoring case, spaces and punctuation. # Remove non-alphabetic characters and convert to lowercase cleaned_word1 = re.sub(r'[^a-zA-Z]', '', word1).lower() cleaned_word2 = re.sub(r'[^a-zA-Z]', '', word2).lower() # Sort the letters of each word and compare return sorted(cleaned_word1) == sorted(cleaned_word2)"},{"question":"def longest_subarray_with_sum_at_most_x(arr: List[int], x: int) -> int: Returns the length of the longest subarray where the sum of the elements is less than or equal to x. >>> longest_subarray_with_sum_at_most_x([1, 2, 1, 0, 1, 1, 0], 4) == 5 >>> longest_subarray_with_sum_at_most_x([1, 2, 1, 0], 10) == 4 >>> longest_subarray_with_sum_at_most_x([5, 6, 7], 3) == 0 >>> longest_subarray_with_sum_at_most_x([1, 2, 3], 2) == 1 >>> longest_subarray_with_sum_at_most_x([], 5) == 0 >>> longest_subarray_with_sum_at_most_x([100, 200, 300, 400], 500) == 2 >>> longest_subarray_with_sum_at_most_x([2, 1, 1, 2], 2) == 2 >>> longest_subarray_with_sum_at_most_x([1, 2, 3, 4, 5], 7) == 3 >>> longest_subarray_with_sum_at_most_x([0, 0, 0, 0, 0], 0) == 5 pass","solution":"def longest_subarray_with_sum_at_most_x(arr, x): Returns the length of the longest subarray where the sum of the elements is less than or equal to x. n = len(arr) max_len = 0 current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum > x: current_sum -= arr[left] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def max_equal_substrings(s: str) -> int: Returns the maximum number of substrings that can be obtained by splitting the string s where each substring contains an equal number of 'a' and 'b'. :param s: str - input string consisting only of characters 'a' and 'b' :return: int - maximum number of substrings with equal number of 'a' and 'b' >>> max_equal_substrings(\\"aabb\\") 1 >>> max_equal_substrings(\\"ababab\\") 3 >>> max_equal_substrings(\\"aaaa\\") -1 pass def test_max_equal_substrings_example1(): assert max_equal_substrings(\\"aabb\\") == 1 def test_max_equal_substrings_example2(): assert max_equal_substrings(\\"ababab\\") == 3 def test_max_equal_substrings_example3(): assert max_equal_substrings(\\"aaaa\\") == -1 def test_max_equal_substrings_only_bs(): assert max_equal_substrings(\\"bbbb\\") == -1 def test_max_equal_substrings_no_balanced_part(): assert max_equal_substrings(\\"aabbb\\") == -1 def test_max_equal_substrings_large_input(): s = \\"ab\\" * 5000 # length = 10000 assert max_equal_substrings(s) == 5000 def test_max_equal_substrings_alternating_characters(): assert max_equal_substrings(\\"abababab\\") == 4 def test_max_equal_substrings_single_char(): assert max_equal_substrings(\\"a\\") == -1 assert max_equal_substrings(\\"b\\") == -1","solution":"def max_equal_substrings(s): Returns the maximum number of substrings that can be obtained by splitting the string s where each substring contains an equal number of 'a' and 'b'. count_a = 0 count_b = 0 max_substrings = 0 for char in s: if char == 'a': count_a += 1 else: count_b += 1 if count_a == count_b: max_substrings += 1 return max_substrings if count_a == count_b else -1"},{"question":"def update_inventory(inventory: List[int], orders: List[int]) -> List[int]: Returns the updated inventory after fulfilling as many orders as possible. >>> update_inventory([10, 5], [10, 5]) [0, 0] >>> update_inventory([4, 4, 4], [1, 1, 1]) [3, 3, 3] >>> update_inventory([10, 5, 8], [3, 6, 2]) [7, 0, 6]","solution":"def update_inventory(inventory, orders): Returns the updated inventory after fulfilling as many orders as possible. updated_inventory = [] for i, stock in enumerate(inventory): if orders[i] >= stock: updated_inventory.append(0) else: updated_inventory.append(stock - orders[i]) return updated_inventory"},{"question":"def solution(s: str) -> dict: Write a function that takes a string and returns a dictionary with the counts of each vowel (a, e, i, o, u) in the string. The function should be case-insensitive and ignore non-vowel characters. >>> solution(\\"Hello World!\\") {'a': 0, 'e': 1, 'i': 0, 'o': 2, 'u': 0} >>> solution(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1} >>> solution(\\"bcdfghjklmnpqrstvwxyz\\") {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0} >>> solution(\\"aeiouAAEEIIOOUU\\") {'a': 3, 'e': 3, 'i': 3, 'o': 3, 'u': 3} >>> solution(\\"\\") {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0} # Completion Task","solution":"def solution(s): Returns a dictionary with the counts of each vowel (a, e, i, o, u) in the string. The function is case-insensitive and ignores non-vowel characters. vowels = \\"aeiou\\" s = s.lower() vowel_counts = {vowel: s.count(vowel) for vowel in vowels} return vowel_counts"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Returns a list of duplicate elements in the input list nums. Each duplicate element will appear only once in the result. >>> find_duplicates([1, 2, 3, 3, 2, 4, 5, 6, 6, 7]) # returns [2, 3, 6] >>> find_duplicates([1, 2, 3, 4, 5]) # returns [] >>> find_duplicates([2, 2, 2, 2]) # returns [2] >>> find_duplicates([]) # returns [] >>> find_duplicates([1]) # returns [] >>> find_duplicates([1, 2, 3, 4, 5, 5]) # returns [5]","solution":"def find_duplicates(nums): Returns a list of duplicate elements in the input list nums. Each duplicate element will appear only once in the result. seen = set() duplicates = set() for num in nums: if num in seen: duplicates.add(num) else: seen.add(num) return list(duplicates)"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. pass def filter_primes(numbers: List[int]) -> List[int]: Given an array of integers, return a new array containing only the elements that are prime numbers. >>> filter_primes([2, 3, 4, 5, 6, 7]) [2, 3, 5, 7] >>> filter_primes([10, 12, 15, 17, 19, 20]) [17, 19] >>> filter_primes([1, 13, 22, 29]) [13, 29] pass","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the given list 'numbers'. return [num for num in numbers if is_prime(num)]"},{"question":"def max_robbery(n: int, money: List[int]) -> int: Determine the maximum amount of money the thief can rob without triggering alarms by robbing two consecutive houses. >>> max_robbery(5, [2, 7, 9, 3, 1]) 12 >>> max_robbery(4, [1, 2, 3, 1]) 4 pass # Unit Tests def test_single_house(): assert max_robbery(1, [5]) == 5 def test_two_houses(): assert max_robbery(2, [2, 3]) == 3 assert max_robbery(2, [3, 2]) == 3 def test_multiple_houses(): assert max_robbery(5, [2, 7, 9, 3, 1]) == 12 assert max_robbery(4, [1, 2, 3, 1]) == 4 assert max_robbery(6, [10, 2, 3, 50, 100, 100]) == 160 assert max_robbery(3, [10, 20, 30]) == 40 def test_no_money(): assert max_robbery(3, [0, 0, 0]) == 0 def test_alternating_values(): assert max_robbery(5, [10, 1, 10, 1, 10]) == 30 def test_large_input(): assert max_robbery(10, [1,2,3,4,5,6,7,8,9,10]) == 30 def test_edge_cases(): assert max_robbery(0, []) == 0 assert max_robbery(2, [1000, 1000]) == 1000 assert max_robbery(3, [1, 2, 3]) == 4 assert max_robbery(4, [2, 3, 2, 3]) == 6","solution":"def max_robbery(n, money): if n == 0: return 0 if n == 1: return money[0] if n == 2: return max(money[0], money[1]) dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"def scale_ingredient(original_amount: float, original_servings: int, desired_servings: int) -> float: Returns the scaled amount of the ingredient based on the desired number of servings. Args: original_amount (float): The original amount of the ingredient. original_servings (int): The original number of servings. desired_servings (int): The desired number of servings. Returns: float: The scaled amount of the ingredient, rounded to two decimal places. >>> scale_ingredient(200, 4, 2) 100.00 >>> scale_ingredient(150, 4, 6) 225.00 >>> scale_ingredient(100, 4, 1) 25.00 >>> scale_ingredient(75, 4, 8) 150.00 >>> scale_ingredient(200, 4, 0) 0.00 >>> scale_ingredient(200, 4, 4) 200.00 >>> scale_ingredient(1000, 4, 10) 2500.00","solution":"def scale_ingredient(original_amount, original_servings, desired_servings): Returns the scaled amount of the ingredient based on the desired number of servings. Args: original_amount (float): The original amount of the ingredient. original_servings (int): The original number of servings. desired_servings (int): The desired number of servings. Returns: float: The scaled amount of the ingredient, rounded to two decimal places. if desired_servings == 0: return 0.00 scaled_amount = (original_amount / original_servings) * desired_servings return round(scaled_amount, 2)"},{"question":"def has_pair_with_sum(numbers: List[int], target: int) -> str: Determines if any two distinct numbers in the list add up to the target. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) \\"NO\\" >>> has_pair_with_sum([0, -1, 2, -3, 1], -2) \\"YES\\" >>> has_pair_with_sum([1, 4, 45, 6, 10, -8], 16) \\"YES\\" >>> has_pair_with_sum([-3, 4, 3, 90], 0) \\"YES\\" >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) \\"YES\\" >>> has_pair_with_sum([1000, 2000, -1500, -500, 750], 250) \\"YES\\" >>> has_pair_with_sum([3, 1, -1, -3, 0], 0) \\"YES\\"","solution":"def has_pair_with_sum(numbers, target): Determines if any two distinct numbers in the list add up to the target. num_set = set() for num in numbers: if target - num in num_set: return \\"YES\\" num_set.add(num) return \\"NO\\""},{"question":"from typing import List def divisor_sort(arr: List[int]) -> List[int]: Sort an array based on the sum of divisors for each element. The sorting should maintain the relative order of elements in case of a tie. Args: arr (List[int]): A list of distinct positive integers. Returns: List[int]: A list of integers sorted based on the sum of their divisors. >>> divisor_sort([10, 6, 8]) [6, 8, 10] >>> divisor_sort([5]) [5] >>> divisor_sort([28, 12]) [12, 28] >>> divisor_sort([8, 15, 3]) [3, 8, 15] >>> divisor_sort([2, 3]) [2, 3] >>> divisor_sort([1, 2, 3, 6, 12, 24]) [1, 2, 3, 6, 12, 24] >>> divisor_sort([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11]","solution":"from typing import List def sum_of_divisors(n: int) -> int: Calculate the sum of all divisors of a given number n. total = 0 for i in range(1, n + 1): if n % i == 0: total += i return total def divisor_sort(arr: List[int]) -> List[int]: Sort array based on the sum of divisors of each element. # Create a list of tuples (element, sum_of_divisors) sum_divisors_list = [(x, sum_of_divisors(x)) for x in arr] # Sort based on the sum of divisors and maintain the relative order using 'stable' sort sorted_arr = sorted(sum_divisors_list, key=lambda x: x[1]) # Extract just the elements from the sorted list of tuples return [x[0] for x in sorted_arr]"},{"question":"def find_longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers. >>> find_longest_consecutive_subsequence([]) 0 >>> find_longest_consecutive_subsequence([10]) 1 >>> find_longest_consecutive_subsequence([1, 2, 3, 4, 5]) 5 >>> find_longest_consecutive_subsequence([10, 5, 20]) 1 >>> find_longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> find_longest_consecutive_subsequence([5, 4, 3, 2, 1]) 5 >>> find_longest_consecutive_subsequence([1, 2, 2, 3, 4]) 4 >>> find_longest_consecutive_subsequence([8, 100, 4, 200, 1, 3, 2, 0, 5, -1]) 7 pass","solution":"def find_longest_consecutive_subsequence(nums): Returns the length of the longest subsequence of consecutive integers. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from datetime import datetime from typing import List, Tuple def eligible_users_on_date(test_cases: List[Tuple[str, List[str]]]) -> List[int]: Find the number of users eligible to receive notifications on a given day. Args: test_cases: A list of tuples where each tuple contains the current date as a string and a list of user data strings. Returns: A list of integers representing the number of users eligible to receive a notification. >>> eligible_users_on_date([('2023-10-16', ['2023-10-14:1', '2023-10-15:1', '2023-10-16:0']), ('2023-10-20', ['2023-10-18:1', '2023-10-19:1', '2023-10-20:1'])]) [2, 3] >>> eligible_users_on_date([('2023-10-15', ['2023-10-14:1', '2023-10-15:1'])]) [0] >>> eligible_users_on_date([('2023-10-18', ['2023-10-17:0', '2023-10-18:0'])]) [0] >>> eligible_users_on_date([('2023-10-17', ['2023-10-16:1', '2023-10-17:1'])]) [2] >>> eligible_users_on_date([('2023-10-19', ['2023-10-16:1', '2023-10-17:0', '2023-10-19:1'])]) [2]","solution":"from datetime import datetime def eligible_users_on_date(test_cases): def is_weekday(date_str): date_object = datetime.strptime(date_str, \\"%Y-%m-%d\\") return date_object.weekday() < 5 # 0 = Monday, 4 = Friday results = [] for test in test_cases: current_date, user_data = test if not is_weekday(current_date): results.append(0) continue count = 0 for user in user_data: last_active, preference = user.split(':') if preference == '1': count += 1 results.append(count) return results # Example usage: test_cases = [ ('2023-10-16', ['2023-10-14:1', '2023-10-15:1', '2023-10-16:0']), ('2023-10-20', ['2023-10-18:1', '2023-10-19:1', '2023-10-20:1']) ] print(eligible_users_on_date(test_cases))"},{"question":"def fibonacci(n: int) -> List[int]: Returns a list of integers representing the Fibonacci sequence up to the n-th term. >>> fibonacci(1) [0] >>> fibonacci(2) [0, 1] >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of integers representing the Fibonacci sequence up to the n-th term. if n <= 0: return [] fib_sequence = [0] if n > 1: fib_sequence.append(1) for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def rotate_array(nums: List[int], k: int) -> List[int]: Given an array of integers, rotate the array to the right by k steps, where k is a non-negative integer. If the input array is null or empty, or if k is negative, return the array as it is. Example 1: >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] Example 2: >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] Example 3: >>> rotate_array([1, 2], 3) [2, 1] Example 4: >>> rotate_array([], 1) [] Example 5: >>> rotate_array([1, 2, 3], -1) [1, 2, 3] pass # Unit Test def test_rotate_array(): assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] assert rotate_array([1, 2], 3) == [2, 1] assert rotate_array([], 1) == [] assert rotate_array([1, 2, 3], -1) == [1, 2, 3] assert rotate_array([1], 100) == [1] assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3, 4, 5, 6, 7, 8], 3) == [6, 7, 8, 1, 2, 3, 4, 5]","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Parameters: nums (List[int]): The input array of integers. k (int): The number of steps to rotate the array. Returns: List[int]: The rotated array. if not nums or k < 0: return nums n = len(nums) k %= n # Reverse the entire array nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the remaining elements nums[k:] = reversed(nums[k:]) return nums"},{"question":"def is_case_sensitive_anagram(s1: str, s2: str) -> bool: Determines if two given strings are case-sensitive anagrams of each other. >>> is_case_sensitive_anagram(\\"Listen\\", \\"Silent\\") False >>> is_case_sensitive_anagram(\\"listen\\", \\"silent\\") True >>> is_case_sensitive_anagram(\\"Tom Marvolo Riddle\\", \\"I am Lord Voldemort\\") False >>> is_case_sensitive_anagram(\\"abc\\", \\"bca\\") True >>> is_case_sensitive_anagram(\\"abc\\", \\"abcd\\") False >>> is_case_sensitive_anagram(\\"abc\\", \\"abd\\") False # Insert your code here def test_is_case_sensitive_anagram_positive(): assert is_case_sensitive_anagram(\\"listen\\", \\"silent\\") == True assert is_case_sensitive_anagram(\\"abc\\", \\"bca\\") == True def test_is_case_sensitive_anagram_negative(): assert is_case_sensitive_anagram(\\"Listen\\", \\"Silent\\") == False assert is_case_sensitive_anagram(\\"Tom Marvolo Riddle\\", \\"I am Lord Voldemort\\") == False assert is_case_sensitive_anagram(\\"abc\\", \\"abcd\\") == False assert is_case_sensitive_anagram(\\"abc\\", \\"abd\\") == False def test_is_case_sensitive_anagram_edge_cases(): assert is_case_sensitive_anagram(\\"a\\", \\"a\\") == True assert is_case_sensitive_anagram(\\"A\\", \\"a\\") == False assert is_case_sensitive_anagram(\\"\\", \\"\\") == True assert is_case_sensitive_anagram(\\"a\\"*1000, \\"a\\"*1000) == True assert is_case_sensitive_anagram(\\"a\\"*999 + \\"b\\", \\"a\\"*1000) == False","solution":"def is_case_sensitive_anagram(s1, s2): Determines if two strings are case-sensitive anagrams of each other. Args: - s1: First string - s2: Second string Returns: - True if s1 and s2 are anagrams of each other considering case sensitivity, otherwise False. return sorted(s1) == sorted(s2)"},{"question":"def min_road_length(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Function to find the minimum total length of roads needed to ensure that the selected fortified cities remain connected. Parameters: - N: int, the number of cities - M: int, the number of roads - roads: list of tuple, each containing three integers u, v, w Returns: - int, the minimum total length of roads needed Example usage: >>> N = 4 >>> M = 5 >>> roads = [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)] >>> min_road_length(N, M, roads) 6 from typing import List, Tuple def test_example_case(): N = 4 M = 5 roads = [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)] assert min_road_length(N, M, roads) == 6 def test_single_road(): N = 2 M = 1 roads = [(1, 2, 10)] assert min_road_length(N, M, roads) == 10 def test_already_connected(): N = 3 M = 3 roads = [(1, 2, 1), (2, 3, 1), (1, 3, 1)] assert min_road_length(N, M, roads) == 2 def test_large_number_of_cities(): N = 6 M = 7 roads = [(1, 2, 3), (1, 3, 4), (4, 5, 2), (2, 5, 10), (3, 6, 1), (5, 6, 3), (2, 4, 5)] assert min_road_length(N, M, roads) == 13 def test_disconnected_cities(): N = 4 M = 3 roads = [(1, 2, 1), (2, 3, 4), (3, 4, 5)] assert min_road_length(N, M, roads) == 10","solution":"def min_road_length(N, M, roads): Function to find the minimum total length of roads needed to ensure that the selected fortified cities remain connected. Parameters: - N: int, the number of cities - M: int, the number of roads - roads: list of tuple, each containing three integers u, v, w Returns: - int, the minimum total length of roads needed # Helper function to find the root of a city def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to perform union of two subsets def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Sort the roads by their lengths in ascending order roads.sort(key=lambda x: x[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(N): parent.append(node) rank.append(0) mst_weight = 0 mst_edges = 0 for u, v, w in roads: if mst_edges == N - 1: break u_root = find(parent, u-1) v_root = find(parent, v-1) if u_root != v_root: mst_weight += w union(parent, rank, u_root, v_root) mst_edges += 1 return mst_weight"},{"question":"def word_mirror_madness(s: str) -> str: Returns a new string with each word reversed but with the words in the original order. >>> word_mirror_madness(\\"hello world\\") 'olleh dlrow' >>> word_mirror_madness(\\"coding is fun\\") 'gnidoc si nuf' >>> word_mirror_madness(\\"hello, world!\\") ',olleh !dlrow' >>> word_mirror_madness(\\" hello world \\") ' olleh dlrow ' >>> word_mirror_madness(\\"example\\") 'elpmaxe' >>> word_mirror_madness(\\"\\") \\"\\" pass","solution":"def word_mirror_madness(s): Returns a new string with each word reversed but with the words in the original order. return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"def nearest_palindrome(n: int) -> int: Returns the closest integer palindrome greater than or equal to \`n\`. >>> nearest_palindrome(123) 131 >>> nearest_palindrome(99) 99 >>> nearest_palindrome(678) 686 >>> nearest_palindrome(1001) 1001","solution":"def nearest_palindrome(n): Returns the closest integer palindrome greater than or equal to \`n\`. def is_palindrome(x): s = str(x) return s == s[::-1] while not is_palindrome(n): n += 1 return n"},{"question":"def is_palindrome(num: int) -> str: Determines if a given integer number is a palindrome. Args: num (int): The integer number to check. Returns: str: \\"YES\\" if the number is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(121) \\"YES\\" >>> is_palindrome(-121) \\"NO\\" >>> is_palindrome(123) \\"NO\\" pass def check_palindromes(test_cases: List[int]) -> List[str]: Checks if elements in the given list of integer numbers are palindromes. Args: test_cases (List[int]): List of integer numbers to check. Returns: List[str]: List of results for each integer in test_cases, where each result is \\"YES\\" if the number is a palindrome, \\"NO\\" otherwise. >>> check_palindromes([121, -121, 123]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> check_palindromes([12321, -12321]) [\\"YES\\", \\"NO\\"] >>> check_palindromes([1, -1, 0]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def is_palindrome(num): Determines if a given integer number is a palindrome. Returns \\"YES\\" if the number is a palindrome, \\"NO\\" otherwise. num_str = str(num) if num_str == num_str[::-1]: return \\"YES\\" else: return \\"NO\\" def check_palindromes(test_cases): results = [] for num in test_cases: results.append(is_palindrome(num)) return results"},{"question":"from typing import List, Tuple def can_rearrange(q: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it's possible to rearrange the array such that no two consecutive elements have the same greatest common divisor (GCD). Args: q: Number of test cases. test_cases: A list containing tuples, each with an integer representing the number of elements and a list of integers representing the array elements. Returns: A list of strings where each element is \\"YES\\" if it's possible to rearrange the respective test case array as described, otherwise \\"NO\\". Examples: >>> can_rearrange(4, [(3, [2, 3, 5]), (4, [6, 10, 15, 20]), (5, [4, 8, 12, 16, 20]), (4, [7, 14, 21, 28])]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> can_rearrange(1, [(3, [12, 15, 18])]) [\\"NO\\"]","solution":"import math from functools import reduce def find_gcd_of_array(arr): return reduce(math.gcd, arr) def can_rearrange(q, test_cases): results = [] for i in range(q): n = test_cases[i][0] arr = test_cases[i][1] array_gcd = find_gcd_of_array(arr) if array_gcd == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longest_subarray_with_k_distinct(test_cases: List[Dict[str, Any]]) -> List[int]: Determine the length of the longest contiguous subarray that contains at most k distinct integers for each test case. >>> test_cases = [ >>> {'n': 7, 'k': 2, 'array': [1, 2, 1, 2, 3, 4, 5]}, >>> {'n': 7, 'k': 3, 'array': [1, 2, 1, 2, 3, 4, 5]}, >>> {'n': 5, 'k': 1, 'array': [1, 2, 2, 3, 3]}, >>> ] >>> longest_subarray_with_k_distinct(test_cases) [4, 5, 2]","solution":"def longest_subarray_with_k_distinct(test_cases): results = [] for case in test_cases: n, k = case['n'], case['k'] array = case['array'] left = 0 right = 0 max_length = 0 frequency_map = {} while right < n: if array[right] in frequency_map: frequency_map[array[right]] += 1 else: frequency_map[array[right]] = 1 while len(frequency_map) > k: frequency_map[array[left]] -= 1 if frequency_map[array[left]] == 0: del frequency_map[array[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 results.append(max_length) return results"},{"question":"def check_checkpoints(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if participants visited all checkpoints exactly once. >>> check_checkpoints(1, [(5, [1, 2, 3, 4, 5])]) [\\"YES\\"] >>> check_checkpoints(1, [(4, [1, 2, 2, 4])]) [\\"NO\\"] >>> check_checkpoints(1, [(1, [1])]) [\\"YES\\"] >>> check_checkpoints(1, [(1000, list(range(1, 1001)))]) [\\"YES\\"] >>> check_checkpoints(3, [ (5, [1, 2, 3, 4, 5]), (4, [1, 2, 2, 4]), (3, [3, 1, 2]) ]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def check_checkpoints(T, test_cases): results = [] for i in range(T): N, checkpoints = test_cases[i] if len(set(checkpoints)) == N: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_2x2_subgrids_with_three_ones(grid): Returns the count of 2x2 subgrids that contain exactly three 1s. >>> count_2x2_subgrids_with_three_ones([[1, 1, 0, 1], [1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 1, 1]]) == 4 >>> count_2x2_subgrids_with_three_ones([[0, 0], [0, 0]]) == 0 >>> count_2x2_subgrids_with_three_ones([[1, 1], [1, 1]]) == 0 >>> count_2x2_subgrids_with_three_ones([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 0 >>> count_2x2_subgrids_with_three_ones([[1, 1, 0, 1], [1, 1, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]) == 3","solution":"def count_2x2_subgrids_with_three_ones(grid): Returns the count of 2x2 subgrids that contain exactly three 1s. N = len(grid) // 2 count = 0 for i in range(2 * N - 1): for j in range(2 * N - 1): subgrid = [ [grid[i][j], grid[i][j + 1]], [grid[i + 1][j], grid[i + 1][j + 1]] ] if sum(sum(row) for row in subgrid) == 3: count += 1 return count def from_input_string(input_str): lines = input_str.strip().split('n') N = int(lines[0]) grid = [list(map(int, line.split())) for line in lines[1:]] return grid def to_output_string(output): return str(output)"},{"question":"def case_permutations(s: str) -> List[str]: Generates all possible case permutations of the input string. Args: s (str): Input string containing only alphabetic characters. Returns: List[str]: All possible case permutations. Examples: >>> case_permutations('aB') ['ab', 'aB', 'Ab', 'AB'] >>> case_permutations('xyz') ['xyz', 'xyZ', 'xYz', 'xYZ', 'Xyz', 'XyZ', 'XYz', 'XYZ'] >>> case_permutations('a') ['a', 'A'] >>> case_permutations('Ab') ['ab', 'aB', 'Ab', 'AB'] >>> case_permutations('') ['']","solution":"def case_permutations(s): Generates all possible case permutations of the input string. def backtrack(sub=\\"\\", index=0): if index == len(s): permutations.append(sub) else: backtrack(sub + s[index].lower(), index + 1) backtrack(sub + s[index].upper(), index + 1) permutations = [] backtrack() return permutations"},{"question":"def find_pivot_index(nums: List[int]) -> int: Returns the pivot index of the given list where the sum of the elements to the left of the index is equal to the sum of the elements to the right of the index. If no such index exists, return -1. >>> find_pivot_index([1, 7, 3, 6, 5, 6]) 3 >>> find_pivot_index([1, 2, 3]) -1 >>> find_pivot_index([2, 1, -1]) 0 from solution import find_pivot_index def test_pivot_index_example1(): assert find_pivot_index([1, 7, 3, 6, 5, 6]) == 3 def test_pivot_index_example2(): assert find_pivot_index([1, 2, 3]) == -1 def test_pivot_index_example3(): assert find_pivot_index([2, 1, -1]) == 0 def test_pivot_index_single_element(): assert find_pivot_index([1]) == 0 def test_pivot_index_all_zeros(): assert find_pivot_index([0, 0, 0, 0, 0]) == 0 def test_pivot_index_left_heavy(): assert find_pivot_index([3, 1, 2, -1, -2, -3]) == -1 def test_pivot_index_right_heavy(): assert find_pivot_index([-3, -1, -2, 1, 2, 3]) == -1 def test_pivot_index_negative_numbers(): assert find_pivot_index([-1, -1, -1, 0, -1, -1, -1]) == 3 def test_pivot_index_large_list(): assert find_pivot_index(list(range(1, 10001))) == -1","solution":"def find_pivot_index(nums): Returns the pivot index of the given list where the sum of the elements to the left of the index is equal to the sum of the elements to the right of the index. If no such index exists, return -1. total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): # total_sum - left_sum - num will give us the right sum if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"def is_custom_palindrome(s: str, consider_spaces: bool) -> bool: Checks if the string s is a palindrome considering only alphabetic characters. If consider_spaces is True, spaces are considered in the comparison; otherwise, they are ignored. >>> is_custom_palindrome(\\"A man, a plan, a canal, Panama\\", False) == True >>> is_custom_palindrome(\\"A man, a plan, a canal, Panama\\", True) == False >>> is_custom_palindrome(\\"No 'x' in Nixon\\", False) == True >>> is_custom_palindrome(\\"Eva, can I see bees in a cave?\\", False) == True >>> is_custom_palindrome(\\"Eva, can I see bees in a cave!\\", True) == False","solution":"def is_custom_palindrome(s: str, consider_spaces: bool) -> bool: Checks if the string s is a palindrome considering only alphabetic characters. Parameters: s (str): The input string to check. consider_spaces (bool): If True, spaces are considered in the comparison, otherwise they are ignored. Returns: bool: True if s is a palindrome, False otherwise. filtered_chars = [] for char in s: if char.isalpha() or (consider_spaces and char == ' '): filtered_chars.append(char.lower()) filtered_str = ''.join(filtered_chars) return filtered_str == filtered_str[::-1]"},{"question":"def shift_string(s: str) -> str: Returns a new string where each alphabetic character is replaced with its subsequent alphabetic character in the alphabet, considering case-sensitivity. Non-alphabetic characters remain unchanged. >>> shift_string(\\"abcd\\") \\"bcde\\" >>> shift_string(\\"wxyz\\") \\"xyza\\" >>> shift_string(\\"Hello, World!\\") \\"Ifmmp, Xpsme!\\" >>> shift_string(\\"Zebra-493?\\") \\"Afcsb-493?\\" pass","solution":"def shift_string(s): Returns a new string where each alphabetic character is replaced with its subsequent alphabetic character in the alphabet, considering case-sensitivity. Non-alphabetic characters remain unchanged. def shift_char(c): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + 1) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + 1) % 26 + ord('A')) else: return c return ''.join(shift_char(c) for c in s)"},{"question":"def longest_palindromic_substring(S: str) -> str: Given a string S, return the longest palindromic substring in S. If there are multiple longest palindromic substrings, return the lexicographically smallest one. >>> longest_palindromic_substring(\\"babad\\") 'bab' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"aaaa\\") 'aaaa' def solve_palindromes(T: int, test_cases: List[str]) -> List[str]: Given number of test cases T and a list of strings containing test cases, returns a list of longest palindromic substrings for each test case.","solution":"def longest_palindromic_substring(S): Given a string S, return the longest palindromic substring in S. If there are multiple longest palindromic substrings, return the lexicographically smallest one. n = len(S) if n == 0: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(n): # Odd length palindromes odd_palindrome = expand_around_center(S, i, i) if len(odd_palindrome) > len(longest) or (len(odd_palindrome) == len(longest) and odd_palindrome < longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(S, i, i + 1) if len(even_palindrome) > len(longest) or (len(even_palindrome) == len(longest) and even_palindrome < longest): longest = even_palindrome return longest def solve_palindromes(T, test_cases): results = [] for S in test_cases: results.append(longest_palindromic_substring(S)) return results"},{"question":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([]) 0 >>> longest_consecutive([1]) 1 >>> longest_consecutive([10, 30, 50]) 1 >>> longest_consecutive([1, 2, 3, 4, 5]) 5 >>> longest_consecutive([1, 2, 2, 3, 4, 4, 5, 6]) 6 >>> longest_consecutive([6, 5, 4, 3, 2, 1]) 6","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. nums_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from collections import deque from typing import List def word_ladder_length(start: str, end: str, word_list: List[str]) -> int: Returns the length of the shortest transformation sequence from start to end using the given word list. :param start: The starting word. :param end: The end word. :param word_list: List of allowed words for transformation. :return: The length of the transformation sequence. >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0","solution":"from collections import deque def word_ladder_length(start, end, word_list): Returns the length of the shortest transformation sequence from start to end using the given word list. :param start: The starting word. :param end: The end word. :param word_list: List of allowed words for transformation. :return: The length of the transformation sequence. if end not in word_list: return 0 word_list = set(word_list) queue = deque([(start, 1)]) while queue: current_word, length = queue.popleft() if current_word == end: return length for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_list: queue.append((next_word, length + 1)) word_list.remove(next_word) return 0"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths for a robot to reach the bottom-right corner of a grid, considering obstacles. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0 >>> unique_paths_with_obstacles([[1, 0], [0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]]) 4","solution":"def unique_paths_with_obstacles(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def countDistinctIslands(grid: List[List[int]]) -> int: You are given an island represented as a two-dimensional grid of land (1) and water (0) cells. Your task is to count the number of distinct islands. An island is surrounded by water and is formed by connecting adjacent land cells horizontally or vertically. Each grid cell is either 0 or 1. Two islands are considered distinct if and only if one island is not a translation (shifted version) of the other. Args: - grid: A two-dimensional list of integers representing land and water. Returns: - An integer representing the number of distinct islands. Example: >>> grid = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 0, 0] ... ] >>> countDistinctIslands(grid) 3 pass","solution":"from typing import List, Tuple, Set def countDistinctIslands(grid: List[List[int]]) -> int: def dfs(r: int, c: int, origin_r: int, origin_c: int, shape: List[Tuple[int, int]]) -> None: stack = [(r, c)] while stack: x, y = stack.pop() if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1: grid[x][y] = -1 # mark as visited shape.append((x - origin_r, y - origin_c)) stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)]) shapes: Set[Tuple[Tuple[int, int], ...]] = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: shape: List[Tuple[int, int]] = [] dfs(r, c, r, c, shape) shapes.add(tuple(shape)) return len(shapes)"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") 'geeksskeeg' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"] True def find_longest_palindromic_substrings(test_cases: List[str]) -> List[str]: Finds the longest palindromic substrings for a list of test cases. >>> find_longest_palindromic_substrings([\\"babad\\", \\"cbbd\\", \\"forgeeksskeegfor\\"]) ['bab', 'bb', 'geeksskeeg'] >>> find_longest_palindromic_substrings([\\"a\\", \\"ac\\"]) ['a', 'a'] >>> find_longest_palindromic_substrings([\\"abacdfgdcaba\\", \\"abacdfgdcabba\\"]) ['aba', 'abba'] >>> find_longest_palindromic_substrings([\\"banana\\"]) ['anana']","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest def find_longest_palindromic_substrings(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_substring(s)) return results"},{"question":"def can_organize_books(T: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Determine if all the books can fit into the given bookshelves. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, int, int]]): A list of tuples, where each tuple contains: - S (int): the number of sections per bookshelf - B (int): the capacity of each section in terms of the number of books - N (int): the total number of books Returns: List[str]: A list of strings \\"Yes\\" or \\"No\\" for each test case. >>> can_organize_books(2, [(10, 50, 450), (5, 20, 200)]) [\\"Yes\\", \\"No\\"] >>> can_organize_books(1, [(1, 1, 1)]) [\\"Yes\\"] >>> can_organize_books(1, [(1000, 1000, 1000001)]) [\\"No\\"]","solution":"def can_organize_books(T, test_cases): results = [] for S, B, N in test_cases: capacity = S * B if N <= capacity: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def assemble_itinerary(segments: List[Tuple[str, str]]) -> List[str]: Given a list of flight segments, each represented as a tuple (origin, destination), assemble an itinerary that represents the full journey from a starting city to the final destination. >>> assemble_itinerary([(\\"New York\\", \\"Paris\\"), (\\"Moscow\\", \\"Tokyo\\"), (\\"Paris\\", \\"Berlin\\"), (\\"Berlin\\", \\"Moscow\\")]) [\\"New York\\", \\"Paris\\", \\"Berlin\\", \\"Moscow\\", \\"Tokyo\\"] >>> assemble_itinerary([(\\"New York\\", \\"Paris\\"), (\\"Paris\\", \\"New York\\")]) []","solution":"from typing import List, Tuple def assemble_itinerary(segments: List[Tuple[str, str]]) -> List[str]: if not segments: return [] # Create a map for each city's outgoing flight outgoing = {origin: destination for origin, destination in segments} # Find the starting city: a starting city has no other city pointing to it all_destinations = set(destination for _, destination in segments) all_origins = set(origin for origin, _ in segments) potential_starts = all_origins - all_destinations if len(potential_starts) != 1: return [] start = potential_starts.pop() # Assembling the itinerary itinerary = [start] while start in outgoing: next_city = outgoing[start] itinerary.append(next_city) start = next_city return itinerary"},{"question":"from typing import List def LongestCommonPrefix(strs: List[str]) -> str: Finds the longest common prefix among a list of strings. If there is no common prefix, returns an empty string. >>> LongestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> LongestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> LongestCommonPrefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> LongestCommonPrefix([\\"throne\\", \\"dungeon\\"]) '' >>> LongestCommonPrefix([\\"throne\\", \\"throne\\"]) 'throne' >>> LongestCommonPrefix([]) '' >>> LongestCommonPrefix([\\"\\"]) '' >>> LongestCommonPrefix([\\"a\\", \\"\\"]) '' >>> LongestCommonPrefix([\\"single\\"]) 'single' >>> LongestCommonPrefix([\\"s\\"]) 's' >>> LongestCommonPrefix([\\"abc\\",\\"Abc\\"]) '' >>> LongestCommonPrefix([\\"one\\", \\"two\\", \\"three\\"]) '' >>> LongestCommonPrefix([\\"test\\", \\"test\\", \\"test\\"]) 'test'","solution":"def LongestCommonPrefix(strs): Finds the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Start with the shortest string as the candidate for the longest common prefix shortest_str = min(strs, key=len) for i, char in enumerate(shortest_str): for other in strs: if other[i] != char: return shortest_str[:i] return shortest_str"},{"question":"def min_operations_to_equalize(A: List[int]) -> int: Returns the minimum number of operations needed to make all elements of the array A equal. In one operation, you can choose any subarray and add or subtract 1 from each element of the subarray. >>> min_operations_to_equalize([1, 2, 3]) == 2 >>> min_operations_to_equalize([4, 4, 4, 4, 4]) == 0 >>> min_operations_to_equalize([1, 1, 2, 2]) == 1","solution":"def min_operations_to_equalize(A): Returns the minimum number of operations needed to make all elements of the array A equal. from collections import Counter # Count the frequency of each element in the array counts = Counter(A) # Find the frequency of the most common element max_freq = max(counts.values()) # The minimum number of operations is the total number of elements minus the # number of occurrences of the most frequent element. return len(A) - max_freq"},{"question":"def reverse_words(s: str) -> str: Takes a string of comma-separated words and returns a new string where each word is reversed, but the order of words remains the same. >>> reverse_words('hello') 'olleh' >>> reverse_words('hello, world') 'olleh, dlrow' >>> reverse_words('hello, world, this, is, a, test') 'olleh, dlrow, siht, si, a, tset' >>> reverse_words('Hello, WoRld') 'olleH, dlRoW' >>> reverse_words('a, b, c') 'a, b, c' >>> reverse_words('') ''","solution":"def reverse_words(s): Takes a string of comma-separated words and returns a new string where each word is reversed, but the order of words remains the same. Args: s (str): A string of comma-separated words. Returns: str: A string where each word is reversed but order remains the same. words = s.split(', ') reversed_words = [word[::-1] for word in words] return ', '.join(reversed_words)"},{"question":"from typing import List def top_k_frequent(words: List[str], k: int) -> List[str]: Returns the k most frequent words in the list. Words with the same frequency are sorted alphabetically. >>> top_k_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"word\\", \\"word\\", \\"word\\", \\"banana\\"], 2) [\\"word\\", \\"apple\\"] >>> top_k_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"word\\", \\"word\\", \\"banana\\", \\"pineapple\\"], 3) [\\"apple\\", \\"banana\\", \\"word\\"] >>> top_k_frequent([\\"a\\", \\"aa\\", \\"aaa\\"], 1) [\\"a\\"] >>> top_k_frequent([\\"a\\", \\"aa\\", \\"aaa\\", \\"bb\\", \\"b\\", \\"bb\\"], 2) [\\"bb\\", \\"a\\"]","solution":"from typing import List from collections import Counter def top_k_frequent(words: List[str], k: int) -> List[str]: Returns the k most frequent words in the list. Words with the same frequency are sorted alphabetically. count = Counter(words) frequent_words = sorted(count.items(), key=lambda x: (-x[1], x[0])) return [word for word, _ in frequent_words[:k]]"},{"question":"def caterpillar_counter(arr: List[str]) -> str: Returns a special message based on the count of 'caterpillar' in the input array. >>> caterpillar_counter(['caterpillar'] * 10) 'Give me ten caterpillars!' >>> caterpillar_counter(['caterpillar'] * 11) 'Caterpillar heaven! 11' >>> caterpillar_counter(['caterpillar'] * 9) 'A disappointing 9' >>> caterpillar_counter(['Caterpillar', 'caterpillar', 'CATERPILLAR']) 'A disappointing 3' >>> caterpillar_counter(['butterfly', 'worm', 'insect']) 'A disappointing 0'","solution":"def caterpillar_counter(arr): Returns a special message based on the count of 'caterpillar' in the input array. Parameters: arr: List[str] - an array of strings Returns: str - a special message based on the count of 'caterpillar' count = sum(1 for item in arr if item.lower() == 'caterpillar') if count == 10: return 'Give me ten caterpillars!' elif count > 10: return f'Caterpillar heaven! {count}' else: return f'A disappointing {count}'"},{"question":"from typing import List def filter_unique_elements(arr: List[int]) -> List[int]: Creates a new array with duplicate elements removed while preserving the order of their first appearance. >>> filter_unique_elements([1, 2, 2, 3, 4, 4, 5]) # should return [1, 2, 3, 4, 5] >>> filter_unique_elements([4, 5, 6, 7, 4, 6, 8]) # should return [4, 5, 6, 7, 8] >>> filter_unique_elements([1, 2, 3]) # should return [1, 2, 3] >>> filter_unique_elements([1, 1, 1, 1]) # should return [1] >>> filter_unique_elements([])) # should return [] # Test cases print(filter_unique_elements([1, 2, 2, 3, 4, 4, 5])) # Should print [1, 2, 3, 4, 5] print(filter_unique_elements([4, 5, 6, 7, 4, 6, 8])) # Should print [4, 5, 6, 7, 8] print(filter_unique_elements([1, 2, 3])) # Should print [1, 2, 3] print(filter_unique_elements([1, 1, 1, 1])) # Should print [1] print(filter_unique_elements([])) # Should print []","solution":"def filter_unique_elements(arr): Filters unique elements from the given array while preserving their first occurrence order. :param arr: List[int] - Input array of integers. :return: List[int] - Array with duplicates removed. seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def track_parking_lot(events): Tracks the entries and exits of cars in a parking lot and returns the number of distinct cars present. Parameters: events - List of tuples where each tuple contains a string and another string (List[Tuple[str, str]]) Returns: int: Number of distinct cars currently present in the parking lot. >>> events = [(\\"enter\\", \\"AB1234\\"), (\\"enter\\", \\"CD5678\\"), (\\"exit\\", \\"AB1234\\"), (\\"enter\\", \\"EF9012\\")] >>> track_parking_lot(events) 2 >>> events = [(\\"enter\\", \\"GH3456\\"), (\\"exit\\", \\"GH3456\\"), (\\"enter\\", \\"GH3456\\"), (\\"exit\\", \\"GH3456\\")] >>> track_parking_lot(events) 0 # your code here pass","solution":"def track_parking_lot(events): Tracks the entries and exits of cars in a parking lot and returns the number of distinct cars present. Parameters: events (List[Tuple[str, str]]): List of events where each event is a tuple (action, license_plate) Returns: int: Number of distinct cars currently present in the parking lot parking_lot = set() for action, license_plate in events: if action == \\"enter\\": parking_lot.add(license_plate) elif action == \\"exit\\": parking_lot.discard(license_plate) return len(parking_lot)"},{"question":"from typing import List def minPathCost(grid: List[List[int]]) -> int: Returns the minimum cost path from the top-left to the bottom-right corner of the grid. Moves allowed are only to the right or down. Args: grid (List[List[int]]): 2D list representing the grid with cost values of each cell Returns: int: Minimum cost to reach the bottom-right corner of the grid from the top-left corner Example: >>> minPathCost([ ... [1,3,1], ... [1,5,1], ... [4,2,1] ... ]) 7 def test_minPathCost_simple(): grid = [ [1,3,1], [1,5,1], [4,2,1] ] assert minPathCost(grid) == 7 def test_minPathCost_single_row(): grid = [ [5, 3, 2] ] assert minPathCost(grid) == 10 def test_minPathCost_single_column(): grid = [ [3], [2], [1] ] assert minPathCost(grid) == 6 def test_minPathCost_single_element(): grid = [ [7] ] assert minPathCost(grid) == 7 def test_minPathCost_additional(): grid = [ [1, 2, 5], [3, 2, 1], [4, 2, 1] ] assert minPathCost(grid) == 7 def test_minPathCost_large_values(): grid = [ [100, 100, 100], [100, 5, 100], [100, 1, 1] ] assert minPathCost(grid) == 207","solution":"from typing import List def minPathCost(grid: List[List[int]]) -> int: Returns the minimum cost path from the top-left to the bottom-right corner of the grid. Moves allowed are only to the right or down. n = len(grid) m = len(grid[0]) # Create a 2D dp array to store minimum path costs dp = [[0]*m for _ in range(n)] # Initialize the dp with the cost of the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer will be in the bottom-right corner return dp[-1][-1]"},{"question":"def process_input(input_string: str) -> str: Calculate the number of islands in given binary matrices. Each island consists of 1s connected horizontally or vertically. Args: input_string: str : Input string containing the number of test cases, matrix dimensions and matrices. Returns: str : Output string containing the number of islands for each matrix. Example: >>> input_string = \\"2n4 5n11110n11010n11000n00000n4 4n1100n1100n0010n0000n\\" >>> process_input(input_string) '1n2' import pytest from solution import process_input def test_example_case_1(): input_string = \\"2n4 5n11110n11010n11000n00000n4 4n1100n1100n0010n0000n\\" expected_output = \\"1n2\\" assert process_input(input_string) == expected_output def test_case_all_water(): input_string = \\"1n3 3n000n000n000n\\" expected_output = \\"0\\" assert process_input(input_string) == expected_output def test_case_all_land(): input_string = \\"1n3 3n111n111n111n\\" expected_output = \\"1\\" assert process_input(input_string) == expected_output def test_multiple_islands(): input_string = \\"1n4 4n1100n1100n0011n0011n\\" expected_output = \\"2\\" assert process_input(input_string) == expected_output def test_no_islands(): input_string = \\"1n5 5n00000n00000n00000n00000n00000n\\" expected_output = \\"0\\" assert process_input(input_string) == expected_output def test_single_island(): input_string = \\"1n3 3n010n111n010n\\" expected_output = \\"1\\" assert process_input(input_string) == expected_output","solution":"def num_islands(matrix): def dfs(i, j): if i < 0 or j < 0 or i >= len(matrix) or j >= len(matrix[0]) or matrix[i][j] == '0': return matrix[i][j] = '0' dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) if not matrix: return 0 island_count = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == '1': island_count += 1 dfs(i, j) return island_count def process_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) idx = 1 results = [] for _ in range(T): N, M = map(int, input_lines[idx].split()) matrix = [list(input_lines[idx + i + 1]) for i in range(N)] results.append(str(num_islands(matrix))) idx += N + 1 return \\"n\\".join(results)"},{"question":"def minPathSum(grid: List[List[int]]) -> int: Returns the minimum sum of all numbers along a path from the top-left to the bottom-right corner of the grid. You can only move either down or right at any point in time. >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathSum([ ... [1, 2, 3], ... [4, 5, 6] ... ]) 12 >>> minPathSum([ ... [1, 2], ... [1, 1] ... ]) 3 >>> minPathSum([ ... [0, 0], ... [0, 0] ... ]) 0 >>> minPathSum([ ... [1] * 100 for _ in range(100) ... ]) 199","solution":"def minPathSum(grid): Returns the minimum sum of all numbers along a path from the top-left to the bottom-right corner of the grid. You can only move either down or right at any point in time. m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def dynamic_fizzbuzz(start: int, end: int, terms: dict) -> None: Prints the numbers from start to end inclusive. For multiples of any key in the terms dictionary, it prints the corresponding value from the dictionary instead of the number. >>> terms = {3: \\"Fizz\\", 5: \\"Buzz\\"} >>> dynamic_fizzbuzz(1, 15, terms) 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz >>> terms = {2: \\"Two\\", 3: \\"Three\\"} >>> dynamic_fizzbuzz(1, 5, terms) 1 Two Three Two 5 >>> terms = {3: \\"Fizz\\", 5: \\"Buzz\\", 7: \\"Whizz\\"} >>> dynamic_fizzbuzz(1, 21, terms) 1 2 Fizz 4 Buzz Fizz Whizz 8 Fizz Buzz 11 Fizz 13 Whizz FizzBuzz 16 17 Fizz 19 Buzz FizzWhizz >>> terms = {4: \\"Quad\\"} >>> dynamic_fizzbuzz(1, 8, terms) 1 2 3 Quad 5 6 7 Quad >>> terms = {} >>> dynamic_fizzbuzz(1, 3, terms) 1 2 3","solution":"def dynamic_fizzbuzz(start: int, end: int, terms: dict) -> None: Prints numbers from start to end inclusive. For multiples of any key in the terms dictionary, prints the corresponding term instead of the number. for num in range(start, end + 1): output = \\"\\" for key, value in terms.items(): if num % key == 0: output += value print(output or num)"},{"question":"class Stack: Implement a Stack Data Structure with operations: push, pop, and peek. >>> stack = Stack() >>> stack.push(1) >>> stack.push(2) >>> stack.peek() # 2 >>> stack.pop() # 2 >>> stack.pop() # 1 >>> stack.pop() # Raises IndexError: pop from an empty stack def __init__(self): # Initialize an empty stack pass def push(self, item): # Add item to the stack pass def pop(self): # Remove and return the last item from the stack pass def peek(self): # Return the last item without removing it pass def is_empty(self): # Check if the stack is empty pass # Example usage stack = Stack() stack.push(1) stack.push(2) print(stack.peek()) # Output: 2 print(stack.pop()) # Output: 2 print(stack.pop()) # Output: 1 print(stack.pop()) # Raises IndexError: pop from an empty stack","solution":"class Stack: def __init__(self): # Initialize an empty stack self.items = [] def push(self, item): # Add item to the stack self.items.append(item) def pop(self): # Remove and return the last item from the stack if not self.is_empty(): return self.items.pop() else: raise IndexError(\\"pop from an empty stack\\") def peek(self): # Return the last item without removing it if not self.is_empty(): return self.items[-1] else: raise IndexError(\\"peek from an empty stack\\") def is_empty(self): # Check if the stack is empty return len(self.items) == 0"},{"question":"def distribute_items(T: int, test_cases: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Calculate the number of items each box will contain and the surplus items left over for T test cases. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int]]): Each tuple contains two integers, B and I, where B is the number of boxes and I is the total number of items. Returns: List[Tuple[int, int]]: Each tuple in the list contains two integers, the number of items each box will contain and the number of surplus items. >>> distribute_items(3, [(8, 25), (5, 100), (3, 7)]) [(3, 1), (20, 0), (2, 1)] >>> distribute_items(2, [(4, 20), (3, 9)]) [(5, 0), (3, 0)] >>> distribute_items(2, [(0, 10), (0, 0)]) [(0, 10), (0, 0)] >>> distribute_items(2, [(5, 0), (3, 0)]) [(0, 0), (0, 0)] >>> distribute_items(1, [(10**9, 10**9)]) [(1, 0)] def format_output(results: List[Tuple[int, int]]) -> str: Helper function to format the output results. Args: results (List[Tuple[int, int]]): List of tuples containing the number of items each box will contain and the number of surplus items. Returns: str: Formatted string of the results. >>> format_output([(3, 1), (20, 0), (2, 1)]) \\"3 1n20 0n2 1\\"","solution":"def distribute_items(T, test_cases): results = [] for case in test_cases: B, I = case if B == 0: results.append((0, I)) # if no boxes, all items are surplus else: items_per_box = I // B surplus_items = I % B results.append((items_per_box, surplus_items)) return results # Helper function to format the output def format_output(results): return \\"n\\".join(f\\"{each[0]} {each[1]}\\" for each in results)"},{"question":"def two_sum(nums: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array 'nums' such that nums[i] + nums[j] equals 'target'. Args: nums: List[int] - The list of integers. target: int - The target sum we're looking for. Returns: bool - True if such a pair exists, False otherwise. pass def test_example_1(): assert two_sum([2, 7, 11, 15], 9) == True def test_example_2(): assert two_sum([3, 2, 4], 6) == True def test_example_3(): assert two_sum([1, 2, 3, 4, 5], 10) == False def test_example_4(): assert two_sum([3, 6, 3], 6) == True def test_no_pairs(): assert two_sum([1, 3, 5, 7], 2) == False def test_pair_with_zero(): assert two_sum([0, 4, -4, 10], 0) == True def test_negative_target(): assert two_sum([1, -2, 3, -4, 5], -1) == True def test_large_numbers(): assert two_sum([10**9, 10**9, 10**9], 2 * 10**9) == True def test_duplicates(): assert two_sum([1, 2, 3, 2], 4) == True","solution":"def two_sum(nums, target): Determines if there are two distinct indices i and j in the array 'nums' such that nums[i] + nums[j] equals 'target'. Args: nums: List[int] - The list of integers. target: int - The target sum we're looking for. Returns: bool - True if such a pair exists, False otherwise. num_dict = {} for index, num in enumerate(nums): complement = target - num if complement in num_dict: return True num_dict[num] = index return False"},{"question":"def isRotation(str1: str, str2: str) -> bool: Determines if str2 is a rotation of str1. >>> isRotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> isRotation(\\"hello\\", \\"lohel\\") True >>> isRotation(\\"hello\\", \\"world\\") False >>> isRotation(\\"abcde\\", \\"eabcd\\") True >>> isRotation(\\"abcd\\", \\"acbd\\") False from solution import isRotation def test_rotation_positive_cases(): assert isRotation(\\"waterbottle\\", \\"erbottlewat\\") == True assert isRotation(\\"hello\\", \\"lohel\\") == True assert isRotation(\\"abcde\\", \\"eabcd\\") == True assert isRotation(\\"aaab\\", \\"abaa\\") == True def test_rotation_negative_cases(): assert isRotation(\\"hello\\", \\"world\\") == False assert isRotation(\\"abcd\\", \\"acbd\\") == False assert isRotation(\\"abcd\\", \\"abdc\\") == False assert isRotation(\\"aabbcc\\", \\"abcabc\\") == False def test_rotation_same_strings(): assert isRotation(\\"rotation\\", \\"rotation\\") == True assert isRotation(\\"abc\\", \\"abc\\") == True def test_rotation_different_lengths(): assert isRotation(\\"abc\\", \\"abcd\\") == False assert isRotation(\\"a\\", \\"aa\\") == False def test_rotation_edge_cases(): assert isRotation(\\"a\\", \\"a\\") == True assert isRotation(\\"a\\", \\"b\\") == False","solution":"def isRotation(str1, str2): Determines if str2 is a rotation of str1. if len(str1) != len(str2): return False return str2 in (str1 + str1)"},{"question":"from typing import List def shortestSubarray(arr: List[int], k: int) -> int: Finds the length of the shortest contiguous subarray with a sum greater than or equal to k. If no such subarray exists, returns -1. >>> shortestSubarray([2, 1, 5, 2, 3, 2], 7) 2 >>> shortestSubarray([2, 1, 5, 2, 8], 7) 1 >>> shortestSubarray([1, 2, 3, 4, 5], 11) 3 >>> shortestSubarray([1, 2, 3, 4], 15) -1","solution":"def shortestSubarray(arr, k): Finds the length of the shortest contiguous subarray with a sum greater than or equal to k. If no such subarray exists, returns -1. from collections import deque n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] dq = deque() min_len = float('inf') for i in range(n + 1): while dq and prefix_sums[i] - prefix_sums[dq[0]] >= k: min_len = min(min_len, i - dq.popleft()) while dq and prefix_sums[i] <= prefix_sums[dq[-1]]: dq.pop() dq.append(i) return min_len if min_len != float('inf') else -1"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def count_paths(N: int, M: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given a directed acyclic graph (DAG) with N nodes and M edges, find the number of paths from a given start node to a given end node for each query. Args: N : int : The number of nodes in the graph. M : int : The number of edges in the graph. edges : List[Tuple[int, int]] : List of tuples where each tuple contains two integers representing a directed edge from node u to node v. queries : List[Tuple[int, int]] : List of tuples where each tuple contains two integers (s, t) representing a query to find the number of paths from node s to node t. Returns: List[int] : List of integers where each integer represents the number of paths from the start node to the end node for each query. Examples: >>> count_paths(4, 4, [(0, 1), (0, 2), (1, 3), (2, 3)], [(0, 3), (1, 3)]) [2, 1] >>> count_paths(4, 3, [(0, 1), (1, 2), (2, 3)], [(3, 0), (3, 1)]) [0, 0]","solution":"from collections import defaultdict, deque def count_paths(N, M, edges, queries): graph = defaultdict(list) for u, v in edges: graph[u].append(v) def dfs(start, end): stack = deque([(start, 1)]) path_count = 0 while stack: node, path_length = stack.pop() if node == end: path_count += path_length else: for neighbor in graph[node]: stack.append((neighbor, path_length)) return path_count results = [] for s, t in queries: results.append(dfs(s, t)) return results"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Write a function \`find_pairs_with_sum\` that takes an array of integers and a target sum, and returns a list of pairs (two-element tuples) that add up to the target sum. Each pair should be sorted in ascending order and the list of pairs should be sorted lexicographically. >>> find_pairs_with_sum([1, 5, 3, 7, -1, 5], 6) [(-1, 7), (1, 5)] >>> find_pairs_with_sum([2, 4, 3, 5, -2, 2, 4], 6) [(2, 4)] >>> find_pairs_with_sum([0, 0, 0, 0], 0) [(0, 0), (0, 0)] from typing import List, Tuple def test_find_pairs_with_sum_example_1(): assert find_pairs_with_sum([1, 5, 3, 7, -1, 5], 6) == [(-1, 7), (1, 5)] def test_find_pairs_with_sum_example_2(): assert find_pairs_with_sum([2, 4, 3, 5, -2, 2, 4], 6) == [(2, 4)] def test_find_pairs_with_sum_example_3(): assert find_pairs_with_sum([0, 0, 0, 0], 0) == [(0, 0)] def test_find_pairs_with_sum_no_pairs(): assert find_pairs_with_sum([1, 2, 3], 10) == [] def test_find_pairs_with_sum_duplicates(): assert find_pairs_with_sum([3, 3, 3, 3], 6) == [(3, 3)] def test_find_pairs_with_sum_mixed_sign_nums(): assert find_pairs_with_sum([-1, -2, -3, 3, 2, 1], 0) == [(-3, 3), (-2, 2), (-1, 1)] def test_find_pairs_with_sum_single_element(): assert find_pairs_with_sum([1], 2) == [] def test_find_pairs_with_sum_no_elements(): assert find_pairs_with_sum([], 2) == []","solution":"def find_pairs_with_sum(arr, target): Returns a list of pairs (tuples) where the sum is equal to the target sum. Each pair is sorted in ascending order, and the list of pairs is sorted lexicographically. arr.sort() pairs = [] seen = set() for num in arr: complement = target - num if complement in seen: pairs.append((min(num, complement), max(num, complement))) seen.add(num) # Remove duplicate pairs pairs = list(set(pairs)) # Sort the list of pairs lexicographically pairs.sort() return pairs"},{"question":"def get_importance(employees, id): Returns the total importance value of an employee and their subordinates. Parameters: employees (list of dict): The list of employees with their details. id (int): The id of the employee whose importance value is to be calculated. Returns: int: The total importance value. pass def test_get_importance_single_employee(): employees = [ {'id': 1, 'importance': 5, 'subordinates': []} ] assert get_importance(employees, 1) == 5 def test_get_importance_with_subordinates(): employees = [ {'id': 1, 'importance': 5, 'subordinates': [2, 3]}, {'id': 2, 'importance': 3, 'subordinates': [4]}, {'id': 3, 'importance': 4, 'subordinates': []}, {'id': 4, 'importance': 1, 'subordinates': []} ] assert get_importance(employees, 1) == 13 def test_get_importance_with_nested_subordinates(): employees = [ {'id': 1, 'importance': 5, 'subordinates': [2]}, {'id': 2, 'importance': 3, 'subordinates': [3]}, {'id': 3, 'importance': 4, 'subordinates': [4]}, {'id': 4, 'importance': 1, 'subordinates': []} ] assert get_importance(employees, 1) == 13 def test_get_importance_employee_with_no_subordinates(): employees = [ {'id': 1, 'importance': 5, 'subordinates': [2]}, {'id': 2, 'importance': 3, 'subordinates': []} ] assert get_importance(employees, 2) == 3 def test_get_importance_non_existent_employee(): employees = [ {'id': 1, 'importance': 5, 'subordinates': [2]}, {'id': 2, 'importance': 3, 'subordinates': []} ] assert get_importance(employees, 3) == 0 def test_get_importance_complex_structure(): employees = [ {'id': 1, 'importance': 15, 'subordinates': [2, 3]}, {'id': 2, 'importance': 10, 'subordinates': [4]}, {'id': 3, 'importance': 20, 'subordinates': []}, {'id': 4, 'importance': 5, 'subordinates': [5, 6]}, {'id': 5, 'importance': 1, 'subordinates': []}, {'id': 6, 'importance': 1, 'subordinates': []} ] assert get_importance(employees, 1) == 52 assert get_importance(employees, 2) == 17 assert get_importance(employees, 4) == 7","solution":"def get_importance(employees, id): Returns the total importance value of an employee and their subordinates. Parameters: employees (list of dict): The list of employees with their details. id (int): The id of the employee whose importance value is to be calculated. Returns: int: The total importance value. emp_dict = {emp['id']: emp for emp in employees} def dfs(emp_id): employee = emp_dict.get(emp_id, None) if not employee: return 0 total_importance = employee['importance'] for sub_id in employee['subordinates']: total_importance += dfs(sub_id) return total_importance return dfs(id)"},{"question":"def findAnagrams(wordList: List[str], target: str) -> List[str]: Returns a list of words from wordList that are anagrams of target. >>> findAnagrams(['listen', 'enlist', 'google', 'inlets', 'banana'], 'silent') ['listen', 'enlist', 'inlets'] >>> findAnagrams([], 'silent') [] >>> findAnagrams(['google', 'facebook', 'apple'], 'silent') [] >>> findAnagrams(['silent', 'listen', 'enlist', 'tinsel'], 'silent') ['silent', 'listen', 'enlist', 'tinsel'] >>> findAnagrams(['silent', 'listen', 'enlist', 'google'], 'silent') ['silent', 'listen', 'enlist'] >>> findAnagrams(['silent', 'listen', 'listen', 'silent'], 'silent') ['silent', 'listen', 'listen', 'silent']","solution":"def findAnagrams(wordList, target): Returns a list of words from wordList that are anagrams of target. target_sorted = sorted(target) return [word for word in wordList if sorted(word) == target_sorted]"},{"question":"def balance_checker(s: str) -> bool: Determines whether the parentheses, brackets, and braces in a given string are balanced. :param s: Input string containing brackets :return: True if the input string is balanced, False otherwise >>> balance_checker(\\"()\\") True >>> balance_checker(\\"([{}])\\") True >>> balance_checker(\\"(]\\") False >>> balance_checker(\\"[({})](]\\") False >>> balance_checker(\\"([{}])[]{}\\") True","solution":"def balance_checker(s): Determines whether the parentheses, brackets, and braces in a given string are balanced. :param s: Input string containing brackets :return: True if the input string is balanced, False otherwise stack = [] mapping = {')': '(', ']': '[', '}': '{'} for char in s: if char in mapping.values(): # opening brackets stack.append(char) elif char in mapping.keys(): # closing brackets if stack == [] or mapping[char] != stack.pop(): return False else: # ignore non-bracket characters continue return stack == []"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. Args: s (str): Input string containing ASCII characters. Returns: bool: True if the input string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") True","solution":"def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. Args: s (str): Input string containing ASCII characters. Returns: bool: True if the input string can be rearranged to form a palindrome, False otherwise. from collections import Counter import string # Normalize the string: remove spaces, punctuation, and convert to lowercase. normalized_s = ''.join(c.lower() for c in s if c.isalpha()) # Count frequencies of each character. char_count = Counter(normalized_s) # Check no more than one character has an odd count. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def sum_even_fibonacci(n: int) -> int: Returns the sum of all even Fibonacci numbers less than or equal to n. >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(34) 44 >>> sum_even_fibonacci(1) 0 >>> sum_even_fibonacci(2) 2 >>> sum_even_fibonacci(4) 2 >>> sum_even_fibonacci(60) 44 >>> sum_even_fibonacci(100) 44 >>> sum_even_fibonacci(4000000) 4613732","solution":"def sum_even_fibonacci(n): Returns the sum of all even Fibonacci numbers less than or equal to n. a, b = 1, 1 sum_even = 0 while b <= n: if b % 2 == 0: sum_even += b a, b = b, a + b return sum_even"},{"question":"import random def deal_bridge_hands() -> list: Shuffles a standard deck of 52 cards and deals them into 4 bridge hands. Each hand should have exactly 13 cards. Returns: list: A list of 4 strings, each string representing the cards in a hand dealt to each player. >>> len(deal_bridge_hands()) 4 >>> all(len(hand.split()) == 13 for hand in deal_bridge_hands()) True","solution":"import random def deal_bridge_hands(): Shuffles a standard deck of 52 cards and deals them into 4 bridge hands. Returns: list: A list of 4 strings, each string representing the cards in a hand dealt to each player. ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'] suits = ['H', 'D', 'C', 'S'] deck = [rank + suit for suit in suits for rank in ranks] random.shuffle(deck) hands = [deck[i * 13:(i + 1) * 13] for i in range(4)] return [' '.join(hand) for hand in hands]"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key def findMinAndMax(root: TreeNode) -> (int, int): Finds the minimum and maximum values in a Binary Search Tree. Args: root (TreeNode): The root of the Binary Search Tree. Returns: tuple: A tuple containing the minimum and maximum values. pass def test_find_min_and_max_single_node(): root = TreeNode(10) assert findMinAndMax(root) == (10, 10) def test_find_min_and_max_left_skewed(): root = TreeNode(10) root.left = TreeNode(5) root.left.left = TreeNode(2) assert findMinAndMax(root) == (2, 10) def test_find_min_and_max_right_skewed(): root = TreeNode(10) root.right = TreeNode(20) root.right.right = TreeNode(30) assert findMinAndMax(root) == (10, 30) def test_find_min_and_max_mixed(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(20) root.left.left = TreeNode(2) root.left.right = TreeNode(7) root.right.left = TreeNode(15) root.right.right = TreeNode(25) assert findMinAndMax(root) == (2, 25) def test_find_min_and_max_complex(): root = TreeNode(15) root.left = TreeNode(10) root.left.left = TreeNode(8) root.left.right = TreeNode(12) root.left.left.left = TreeNode(6) root.left.left.right = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(17) root.right.right = TreeNode(25) assert findMinAndMax(root) == (6, 25)","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key def findMin(root): current = root while current.left is not None: current = current.left return current.value def findMax(root): current = root while current.right is not None: current = current.right return current.value def findMinAndMax(root): Finds the minimum and maximum values in a Binary Search Tree. Args: root (TreeNode): The root of the Binary Search Tree. Returns: tuple: A tuple containing the minimum and maximum values. if root is None: return (None, None) # Returning None for empty tree min_value = findMin(root) max_value = findMax(root) return (min_value, max_value)"},{"question":"def replaceVowelsWithNext(sentence: str) -> str: Replace each vowel in the sentence with the next vowel in the sequence. The sequence of vowels is 'a', 'e', 'i', 'o', 'u' and wraps around. >>> replaceVowelsWithNext(\\"hello world\\") 'hillu wurld' >>> replaceVowelsWithNext(\\"AEiou\\") 'EIoua'","solution":"def replaceVowelsWithNext(sentence): Replace each vowel in the sentence with the next vowel in the sequence. The sequence of vowels is 'a', 'e', 'i', 'o', 'u' and wraps around. vowels = \\"aeiouAEIOU\\" next_vowels = \\"eiouaEIOUA\\" translation_table = str.maketrans(vowels, next_vowels) return sentence.translate(translation_table)"},{"question":"def compare_snapshots(n: int, snapshot1: List[Tuple[int, List[Tuple[str, int]]]], snapshot2: List[Tuple[int, List[Tuple[str, int]]]]) -> str: Compare two snapshots of directories and identify files that have been added, removed, or have their timestamps updated. Args: n: Number of directories. snapshot1: First snapshot containing directory identifier and list of files with timestamps. snapshot2: Second snapshot containing directory identifier and list of files with timestamps. Returns: str: Result indicating files that were added, removed, or updated for each directory. >>> n = 2 >>> snapshot1 = [ ... (1, [(\\"file1\\", 123), (\\"file2\\", 456), (\\"file3\\", 789)]), ... (2, [(\\"fileA\\", 111), (\\"fileB\\", 222)]), ... ] >>> snapshot2 = [ ... (1, [(\\"file1\\", 123), (\\"file2\\", 999), (\\"file4\\", 555), (\\"file5\\", 999)]), ... (2, [(\\"fileA\\", 111)]), ... ] >>> print(compare_snapshots(n, snapshot1, snapshot2)) 1 Added: file4 555 file5 999 Removed: file3 Updated: file2 999 2 Added: None Removed: fileB Updated: None >>> n = 1 >>> snapshot1 = [(1, [(\\"file1\\", 100), (\\"file2\\", 200)])] >>> snapshot2 = [(1, [(\\"file1\\", 100), (\\"file2\\", 200)])] >>> print(compare_snapshots(n, snapshot1, snapshot2)) 1 Added: None Removed: None Updated: None","solution":"def compare_snapshots(n, snapshot1, snapshot2): def parse_snapshot(snapshot): parsed_snapshot = {} for dir_id, files in snapshot: parsed_snapshot[dir_id] = {} for name, timestamp in files: parsed_snapshot[dir_id][name] = timestamp return parsed_snapshot result = [] snapshot1_parsed = parse_snapshot(snapshot1) snapshot2_parsed = parse_snapshot(snapshot2) for dir_id in range(1, n + 1): added = [] removed = [] updated = [] files1 = snapshot1_parsed.get(dir_id, {}) files2 = snapshot2_parsed.get(dir_id, {}) for file_name, timestamp in files2.items(): if file_name not in files1: added.append((file_name, timestamp)) elif files1[file_name] != timestamp: updated.append((file_name, timestamp)) for file_name in files1.keys(): if file_name not in files2: removed.append(file_name) result.append(f\\"{dir_id}\\") if added: result.append(\\"Added:\\") for file in added: result.append(f\\"{file[0]} {file[1]}\\") else: result.append(\\"Added:\\") result.append(\\"None\\") if removed: result.append(\\"Removed:\\") for file in removed: result.append(file) else: result.append(\\"Removed:\\") result.append(\\"None\\") if updated: result.append(\\"Updated:\\") for file in updated: result.append(f\\"{file[0]} {file[1]}\\") else: result.append(\\"Updated:\\") result.append(\\"None\\") return \\"n\\".join(result) # Example run n = 2 snapshot1 = [ (1, [(\\"file1\\", 123), (\\"file2\\", 456), (\\"file3\\", 789)]), (2, [(\\"fileA\\", 111), (\\"fileB\\", 222)]), ] snapshot2 = [ (1, [(\\"file1\\", 123), (\\"file2\\", 999), (\\"file4\\", 555), (\\"file5\\", 999)]), (2, [(\\"fileA\\", 111)]), ] print(compare_snapshots(n, snapshot1, snapshot2))"},{"question":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: Given a list of integers, return the maximum sum of non-adjacent elements. The integers can be negative or positive. If the list is empty, return 0. If all elements are negative, return 0 as well. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8 >>> max_non_adjacent_sum([-3, -2, -5, -10, -7]) 0 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([-5]) 0 >>> max_non_adjacent_sum([1, 5]) 5 pass","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the list. if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) # Initialize two variables to store the maximum sum till the previous and # the one before previous element. two_steps_back = max(0, nums[0]) one_step_back = max(two_steps_back, nums[1]) for i in range(2, n): current = max(one_step_back, two_steps_back + nums[i]) two_steps_back = one_step_back one_step_back = current return max(one_step_back, two_steps_back)"},{"question":"def min_moves_to_reach_target(n: int, m: int, x_s: int, y_s: int, x_t: int, y_t: int) -> int: Returns the minimum number of moves required for Tom to reach the target position. >>> min_moves_to_reach_target(5, 5, 1, 1, 1, 1) 1 >>> min_moves_to_reach_target(5, 5, 1, 1, 1, 5) 1 >>> min_moves_to_reach_target(5, 5, 1, 1, 5, 1) 1 >>> min_moves_to_reach_target(5, 5, 1, 1, 5, 5) 2 >>> min_moves_to_reach_target(1000, 1000, 1, 1, 1000, 1000) 2","solution":"def min_moves_to_reach_target(n, m, x_s, y_s, x_t, y_t): Returns the minimum number of moves required for Tom to reach the target position. # Tom can move to the target row in one move and then to the target column in another move # or alternatively, he can move to the target column first and then to the target row. return 1 if (x_s == x_t or y_s == y_t) else 2"},{"question":"def is_permutation(s1: str, s2: str) -> bool: Returns a boolean indicating whether one string is a permutation of the other. A permutation means that two strings must contain the same characters with the same frequency, but possibly in a different order. >>> is_permutation(\\"abc\\", \\"bac\\") == True >>> is_permutation(\\"hello\\", \\"ollhe\\") == True >>> is_permutation(\\"test\\", \\"tess\\") == False >>> is_permutation(\\"apple\\", \\"papel\\") == True >>> is_permutation(\\"python\\", \\"jython\\") == False","solution":"def is_permutation(s1, s2): Returns True if s1 and s2 are permutations of each other, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns a tuple of two distinct integers from the list that sum up to the target. Params: nums (List[int]): List of integers target (int): Target integer Returns: Tuple[int, int] or None: Tuple of two integers that sum up to the target or None if no valid pair exists >>> two_sum([2, 7, 11, 15], 9) (2, 7) >>> two_sum([-1, -2, -3, -4, -5], -8) (-3, -5) >>> two_sum([1, 2, 3, 4, 5], 5) (2, 3) >>> two_sum([1, 2, 3], 7) None >>> two_sum([], 3) None >>> two_sum([1, 1, 2, 3], 4) (1, 3)","solution":"def two_sum(nums, target): Returns a tuple of two distinct integers from the list that sum up to the target. Params: nums (List[int]): List of integers target (int): Target integer Returns: Tuple[int, int] or None: Tuple of two integers that sum up to the target or None if no valid pair exists num_dict = {} for num in nums: complement = target - num if complement in num_dict: return (complement, num) num_dict[num] = True return None"},{"question":"import math from typing import List, Tuple def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(13) True >>> is_prime(15) False def path_sums(grid: List[List[int]], n: int, m: int) -> int: Calculate the sum of the numbers on the path from top-left to bottom-right in the grid, moving only right or down. >>> path_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3) 21 >>> path_sums([[1, 1], [1, 1]], 2, 2) 3 def solve(test_cases: List[Tuple[List[List[int]], int, int]]) -> List[str]: Determine if there exists a path in each grid such that the sum of numbers on the path is a prime number. >>> solve([([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3), ([[1, 1], [1, 1]], 2, 2)]) [\\"NO\\", \\"YES\\"] def read_input(input_data: str) -> List[Tuple[List[List[int]], int, int]]: Parse the input data into test cases. def main(input_data: str) -> None: Read the input data, solve the problem for each test case, and print the results. def test_is_prime(): assert not is_prime(1) assert is_prime(2) assert is_prime(3) assert not is_prime(4) assert is_prime(5) assert is_prime(13) assert not is_prime(15) def test_path_sums(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert path_sums(grid, 3, 3) == 21 grid = [ [1, 1], [1, 1] ] assert path_sums(grid, 2, 2) == 3 def test_solve(): test_cases = [ ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3), ([[1, 1], [1, 1]], 2, 2) ] assert solve(test_cases) == [\\"NO\\", \\"YES\\"] def test_main(capsys): input_data = \\"2n3 3n1 2 3n4 5 6n7 8 9n2 2n1 1n1 1n\\" main(input_data) captured = capsys.readouterr() assert captured.out == \\"NOnYESn\\"","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def path_sums(grid, n, m): # Use dynamic programming to track path sums dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1] def solve(test_cases): results = [] for grid, n, m in test_cases: sum_path = path_sums(grid, n, m) if is_prime(sum_path): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def read_input(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] idx = 1 for _ in range(T): n, m = map(int, input_lines[idx].split()) grid = [] for i in range(n): grid.append(list(map(int, input_lines[idx + 1 + i].split()))) test_cases.append((grid, n, m)) idx += n + 1 return test_cases def main(input_data): test_cases = read_input(input_data) results = solve(test_cases) for result in results: print(result)"},{"question":"from typing import List def product_except_self(lst: List[int]) -> List[int]: Given a list of integers, returns a new list where each integer is replaced with the product of all the other integers in the original list. No division is allowed. If the list has fewer than two elements, return an empty list. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([5]) [] >>> product_except_self([]) [] >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 6, 9]) [54, 27, 18] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([0, 0, 0]) [0, 0, 0]","solution":"def product_except_self(lst): Given a list of integers, returns a new list where each integer is replaced with the product of all the other integers in the original list. No division is allowed. If the list has fewer than two elements, return an empty list. if len(lst) < 2: return [] length = len(lst) # Initialize the left and right product lists left_products = [1] * length right_products = [1] * length result = [1] * length # Compute the products of all the elements to the left of each index for i in range(1, length): left_products[i] = left_products[i - 1] * lst[i - 1] # Compute the products of all the elements to the right of each index for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * lst[i + 1] # Multiply the left and right products for each index for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels (a, e, i, o, u) in the input string. The function is case-insensitive. >>> count_vowels(\\"hello\\") 2 >>> count_vowels(\\"world\\") 1 >>> count_vowels(\\"HELLO\\") 2 >>> count_vowels(\\"WORLD\\") 1 >>> count_vowels(\\"HeLlO\\") 2 >>> count_vowels(\\"WoRLd\\") 1 >>> count_vowels(\\"bcdfg\\") 0 >>> count_vowels(\\"\\") 0 >>> count_vowels(\\"aeiou\\") 5 >>> count_vowels(\\"AEIOU\\") 5 >>> count_vowels(\\"The quick brown fox!\\") 5 >>> count_vowels(\\"sphinx of black quartz, judge my vow.\\") 8","solution":"def count_vowels(s): Returns the number of vowels (a, e, i, o, u) in the input string. The function is case-insensitive. vowels = \\"aeiou\\" return sum(1 for char in s.lower() if char in vowels)"},{"question":"def generate_spiral_matrix(n: int) -> list: Generate a n x n spiral matrix filled with elements from 1 to n² in a clockwise spiral order. >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generate_spiral_matrix(n): Generate a n x n spiral matrix filled with elements from 1 to n^2 in a clockwise spiral order. :param n: Size of the matrix :type n: int :return: A 2D list representing the spiral matrix :rtype: list of list of int matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def minimal_cycle_length(C: int, R: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimal road distance needed to visit all coffee shops in a cycle. Args: C (int): The number of coffee shops. R (int): The number of roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing a road between coffee shop u and coffee shop v with length w. Returns: int: The minimal total road length to visit all the coffee shops in a cycle, or -1 if it is not possible to form such a cycle. Examples: >>> minimal_cycle_length(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> minimal_cycle_length(4, 3, [(1, 2, 10), (3, 4, 20), (1, 3, 25)]) -1 # You can use the below test function to test your implementation. def test_minimal_cycle_length(): # Sample Test Case C = 4 R = 6 roads = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30) ] assert minimal_cycle_length(C, R, roads) == 80 # Test case with unconnected graphs C = 4 R = 3 roads = [ (1, 2, 10), (3, 4, 20), (1, 3, 25) ] assert minimal_cycle_length(C, R, roads) == -1 # Test case with minimum coffee shops C = 2 R = 1 roads = [ (1, 2, 5) ] assert minimal_cycle_length(C, R, roads) == 10 # Test case with a denser graph C = 5 R = 10 roads = [ (1, 2, 2), (1, 3, 9), (1, 4, 10), (1, 5, 15), (2, 3, 6), (2, 4, 7), (2, 5, 8), (3, 4, 4), (3, 5, 12), (4, 5, 3) ] assert minimal_cycle_length(C, R, roads) == 26","solution":"def minimal_cycle_length(C, R, roads): import sys from itertools import permutations # Initialize the adjacency matrix with sys.maxsize (to indicate no direct path initially) adj_matrix = [[sys.maxsize] * C for _ in range(C)] # Populate the adjacency matrix for u, v, w in roads: adj_matrix[u - 1][v - 1] = w adj_matrix[v - 1][u - 1] = w # Use a brute-force approach to solve the TSP problem due to small C coffee_shops = list(range(C)) min_cost = sys.maxsize for perm in permutations(coffee_shops): current_cost = 0 is_valid = True for i in range(C): if adj_matrix[perm[i - 1]][perm[i]] == sys.maxsize: is_valid = False break current_cost += adj_matrix[perm[i - 1]][perm[i]] if is_valid: min_cost = min(min_cost, current_cost) return min_cost if min_cost != sys.maxsize else -1"},{"question":"def unique_paths(m, n): Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, moving only down or right. >>> unique_paths(2, 3) 3 >>> unique_paths(3, 7) 28 >>> unique_paths(1, 1) 1","solution":"def unique_paths(m, n): Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, moving only down or right. # Initialize a 2D list to hold the number of ways dp = [[0 for _ in range(n)] for _ in range(m)] # There is exactly one way to reach any cell in the first row or first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the remainder of the grid using previously computed values for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def largest_square_subgrid_size(test_cases): Determine the size of the largest square sub-grid filled with 1s for multiple grids. Parameters: - test_cases: List of tuples, where each tuple contains: - N: int, number of rows in the grid - M: int, number of columns in the grid - grid: List of list of ints, the grid itself >>> largest_square_subgrid_size([(4, 5, [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]), ... (3, 3, [ ... [1, 1, 1], ... [1, 1, 0], ... [1, 1, 1], ... ])]) [2, 2] pass from solution import largest_square_subgrid_size def test_single_case(): test_cases = [ (4, 5, [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]), ] assert largest_square_subgrid_size(test_cases) == [2] def test_multiple_cases(): test_cases = [ (4, 5, [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]), (3, 3, [ [1, 1, 1], [1, 1, 0], [1, 1, 1], ]) ] assert largest_square_subgrid_size(test_cases) == [2, 2] def test_maximum_case(): N = M = 1000 grid = [[1 for _ in range(M)] for _ in range(N)] test_cases = [(N, M, grid)] assert largest_square_subgrid_size(test_cases) == [1000] def test_no_ones(): test_cases = [ (3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) ] assert largest_square_subgrid_size(test_cases) == [0] def test_one_large_square(): test_cases = [ (5, 5, [ [0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1] ]) ] assert largest_square_subgrid_size(test_cases) == [4]","solution":"def largest_square_subgrid_size(test_cases): results = [] for case in test_cases: N, M, grid = case dp = [[0] * M for _ in range(N)] max_side = 0 for i in range(N): for j in range(M): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) results.append(max_side) return results"},{"question":"def max_non_overlapping_segments(closures): Returns the maximum number of non-overlapping closed segments on any given day. closures: List of tuples where each tuple contains two integers (start_date, end_date) >>> max_non_overlapping_segments([(1, 5), (2, 6), (8, 10), (7, 9)]) 2 >>> max_non_overlapping_segments([(3, 4)]) 1 >>> max_non_overlapping_segments([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_segments([(1, 5), (2, 6), (3, 7), (4, 8)]) 1 >>> max_non_overlapping_segments([(1, 4), (2, 5), (6, 9), (7, 10), (11, 12)]) 3 >>> max_non_overlapping_segments([(i, i+1) for i in range(1, 100001, 2)]) 50000","solution":"def max_non_overlapping_segments(closures): Returns the maximum number of non-overlapping closed segments on any given day. closures: List of tuples where each tuple contains two integers (start_date, end_date) # Sort closures based on the end date closures.sort(key=lambda x: x[1]) # Initialize variables count = 0 last_end_time = -1 # Initialize to a time that's before any segment start time # Iterate over sorted segments for start, end in closures: if start > last_end_time: # No overlap condition count += 1 last_end_time = end return count"},{"question":"def reorder_string(s: str) -> str: Reorder the characters of the string so that all the digits appear before any letters. Digits should be in non-decreasing order and letters should be in non-increasing order. >>> reorder_string('d3c2b1a') '123dcba' >>> reorder_string('5z9y8x') '589zyx' >>> reorder_string('m5n4o3p2') '2345ponm' >>> reorder_string('abcdef') 'fedcba' >>> reorder_string('12345') '12345'","solution":"def reorder_string(s): digits = sorted([ch for ch in s if ch.isdigit()]) letters = sorted([ch for ch in s if ch.isalpha()], reverse=True) return ''.join(digits + letters)"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Write a function that takes a list of integers and an integer \`target\`, and returns a boolean indicating whether any two numbers in the list add up to the \`target\`. >>> has_pair_with_sum([10, 15, 3, 7], 17) == True >>> has_pair_with_sum([1, 2, 3, 9], 8) == False >>> has_pair_with_sum([5], 5) == False >>> has_pair_with_sum([], 5) == False >>> has_pair_with_sum([1, 2, 3, 4, 3], 6) == True >>> has_pair_with_sum([-1, -2, -3, -4], -6) == True >>> has_pair_with_sum([3, 5, -1, 7, 9], 2) == True","solution":"def has_pair_with_sum(arr, target): Returns True if there are any two numbers in the list that add up to the target. Otherwise, returns False. seen = set() for number in arr: if target - number in seen: return True seen.add(number) return False"},{"question":"def inventory_report(inventory: List[str]) -> Dict[str, Dict[str, Union[int, str]]]: Generates a report of the inventory with total quantities and highest quantity item per category. Args: inventory (list): A list of strings where each string represents item information in the format \\"item_code quantity category\\". Returns: dict: A dictionary with category as the key and another dictionary as the value containing: - total_quantity (int): Total quantity of items in that category. - highest_quantity_item (str): Item code of the item with the highest quantity in that category.","solution":"def inventory_report(inventory): Generates a report of the inventory with total quantities and highest quantity item per category. Args: inventory (list): A list of strings where each string represents item information in the format \\"item_code quantity category\\". Returns: dict: A dictionary with category as the key and another dictionary as the value containing: - total_quantity (int): Total quantity of items in that category. - highest_quantity_item (str): Item code of the item with the highest quantity in that category. report = {} for item in inventory: item_code, quantity, category = item.split() quantity = int(quantity) if category not in report: report[category] = { 'total_quantity': 0, 'highest_quantity_item': item_code, 'highest_quantity': quantity } report[category]['total_quantity'] += quantity if quantity > report[category]['highest_quantity']: report[category]['highest_quantity_item'] = item_code report[category]['highest_quantity'] = quantity for category in report: del report[category]['highest_quantity'] return report"},{"question":"def temperatureTrend(temperatures): Returns the temperature trend for each day compared to the previous day. Parameters: temperatures (list): A list of integers representing daily temperatures. Returns: list: A list of strings representing the trend (\\"warmer\\", \\"cooler\\", \\"same\\", \\"N/A\\"). >>> temperatureTrend([70, 72, 68, 68, 75, 73, 73]) [\\"N/A\\", \\"warmer\\", \\"cooler\\", \\"same\\", \\"warmer\\", \\"cooler\\", \\"same\\"] >>> temperatureTrend([70, 70, 70, 70, 70, 70, 70]) [\\"N/A\\", \\"same\\", \\"same\\", \\"same\\", \\"same\\", \\"same\\", \\"same\\"] >>> temperatureTrend([60, 61, 62, 63, 64, 65, 66]) [\\"N/A\\", \\"warmer\\", \\"warmer\\", \\"warmer\\", \\"warmer\\", \\"warmer\\", \\"warmer\\"] >>> temperatureTrend([80, 79, 78, 77, 76, 75, 74]) [\\"N/A\\", \\"cooler\\", \\"cooler\\", \\"cooler\\", \\"cooler\\", \\"cooler\\", \\"cooler\\"] >>> temperatureTrend([70, 72, 72, 69, 69, 77, 75]) [\\"N/A\\", \\"warmer\\", \\"same\\", \\"cooler\\", \\"same\\", \\"warmer\\", \\"cooler\\"] >>> temperatureTrend([70]) [\\"N/A\\"] >>> temperatureTrend([70, 70]) [\\"N/A\\", \\"same\\"] >>> temperatureTrend([70, 75]) [\\"N/A\\", \\"warmer\\"] >>> temperatureTrend([75, 70]) [\\"N/A\\", \\"cooler\\"]","solution":"def temperatureTrend(temperatures): Returns the temperature trend for each day compared to the previous day. Parameters: temperatures (list): A list of integers representing daily temperatures. Returns: list: A list of strings representing the trend (\\"warmer\\", \\"cooler\\", \\"same\\", \\"N/A\\"). trends = [\\"N/A\\"] for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: trends.append(\\"warmer\\") elif temperatures[i] < temperatures[i - 1]: trends.append(\\"cooler\\") else: trends.append(\\"same\\") return trends"},{"question":"def longest_common_prefix(strs: List[str]) -> str: Returns the longest common prefix from an array of strings. If no common prefix exists, returns an empty string. Args: strs (List[str]): A list of strings to find the common prefix of. Returns: str: The longest common prefix. Examples: >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) \\"inters\\" >>> longest_common_prefix([\\"throne\\", \\"dungeon\\", \\"throne\\"]) \\"\\" >>> longest_common_prefix([\\"throne\\", \\"throne\\", \\"throne\\"]) \\"throne\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"single\\"]) \\"single\\" >>> longest_common_prefix([\\"aaaa\\", \\"aaa\\", \\"aa\\"]) \\"aa\\"","solution":"def longest_common_prefix(strs): Returns the longest common prefix from an array of strings. If no common prefix exists, returns an empty string. if not strs: return \\"\\" # Sort the array so the comparison happens between the smallest and largest strings strs.sort() first = strs[0] last = strs[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"def maximize_sequence_sum(N: int, X: int, Y: int) -> int: Calculate the maximum possible sum of the sequence with given energy. >>> maximize_sequence_sum(10, 2, 3) 5 >>> maximize_sequence_sum(15, 1, 5) 15 >>> maximize_sequence_sum(8, 3, 2) 4 def process_input(input_data: str) -> list: Process the input data and return the output for each test case. >>> input_data = \\"3n10 2 3n15 1 5n8 3 2\\" >>> process_input(input_data) [5, 15, 4] def test_maximize_sequence_sum_case1(): assert maximize_sequence_sum(10, 2, 3) == 5 def test_maximize_sequence_sum_case2(): assert maximize_sequence_sum(15, 1, 5) == 15 def test_maximize_sequence_sum_case3(): assert maximize_sequence_sum(8, 3, 2) == 4 def test_maximize_sequence_sum_case4(): assert maximize_sequence_sum(100, 2, 3) == 50 def test_maximize_sequence_sum_case5(): assert maximize_sequence_sum(30, 6, 9) == 5 def test_process_input_case1(): input_data = \\"3n10 2 3n15 1 5n8 3 2\\" expected_output = [5, 15, 4] assert process_input(input_data) == expected_output def test_process_input_case2(): input_data = \\"2n100 2 3n30 6 9\\" expected_output = [50, 5] assert process_input(input_data) == expected_output # Running all tests if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def maximize_sequence_sum(N, X, Y): # If the cost of increment is less than or equal to double, just use increments if X <= Y: return N // X # Otherwise, calculate how many doubles and increments we can do max_sum = 0 while N >= Y: doubles = N // Y increments = (N % Y) // X max_sum += doubles + increments N -= (doubles * Y + increments * X) # Any remaining energy for increments max_sum += N // X return max_sum def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) results = [] for i in range(1, T + 1): N, X, Y = map(int, input_lines[i].split()) results.append(maximize_sequence_sum(N, X, Y)) return results"},{"question":"def numberOfSteps(num: int) -> int: Returns the number of steps required to reduce num to 0. In one step, you can either subtract 1 from it if it's odd, or divide it by 2 if it's even. >>> numberOfSteps(14) 6 >>> numberOfSteps(1) 1 >>> numberOfSteps(0) 0 >>> numberOfSteps(1000000) 26 >>> numberOfSteps(8) 4 >>> numberOfSteps(123) 12 pass","solution":"def numberOfSteps(num): Returns the number of steps required to reduce num to 0. steps = 0 while num > 0: if num % 2 == 0: num //= 2 else: num -= 1 steps += 1 return steps"},{"question":"def distribute_wealth(n_cases: int, cases: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Distribute the wealth equally among villagers and determine the remainder for the village elder. Args: n_cases (int): The number of test cases. cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers - total wealth W and number of villagers V. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two integers - wealth each villager receives and the wealth that the village elder receives. >>> distribute_wealth(3, [(1000, 3), (12345, 5), (999999, 100)]) [(333, 1), (2469, 0), (9999, 99)] >>> distribute_wealth(1, [(5, 10)]) [(0, 5)] >>> distribute_wealth(2, [(100, 10), (1000, 100)]) [(10, 0), (10, 0)] >>> distribute_wealth(1, [(100, 1)]) [(100, 0)] >>> distribute_wealth(1, [(10**15, 10**6)]) [(10**9, 0)]","solution":"def distribute_wealth(n_cases, cases): results = [] for W, V in cases: wealth_each = W // V wealth_elder = W % V results.append((wealth_each, wealth_elder)) return results"},{"question":"from typing import List def longest_increasing_path(matrix: List[List[int]]) -> int: Given a matrix represented as a list of lists, return the length of the longest increasing path in the matrix. An increasing path is one where each subsequent value is greater than the previous value. You can move in four possible directions: up, down, left, or right. >>> matrix = [ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ] >>> longest_increasing_path(matrix) 4 >>> matrix = [ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ] >>> longest_increasing_path(matrix) 4 >>> matrix = [ ... [1] ... ] >>> longest_increasing_path(matrix) 1 pass def test_example1(): matrix = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] assert longest_increasing_path(matrix) == 4 def test_example2(): matrix = [ [3, 4, 5], [3, 2, 6], [2, 2, 1] ] assert longest_increasing_path(matrix) == 4 def test_example3(): matrix = [ [1] ] assert longest_increasing_path(matrix) == 1 def test_single_row(): matrix = [[1, 2, 3, 4, 5]] assert longest_increasing_path(matrix) == 5 def test_single_column(): matrix = [[1], [2], [3], [4], [5]] assert longest_increasing_path(matrix) == 5 def test_increasing_diagonals(): matrix = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] assert longest_increasing_path(matrix) == 9 def test_all_same_values(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert longest_increasing_path(matrix) == 1","solution":"def longest_increasing_path(matrix): Given a matrix, returns the length of the longest increasing path in the matrix. if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) memo = [[-1 for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if memo[r][c] != -1: return memo[r][c] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_len = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] > matrix[r][c]: length = 1 + dfs(nr, nc) max_len = max(max_len, length) memo[r][c] = max_len return max_len longest_path = 0 for r in range(rows): for c in range(cols): longest_path = max(longest_path, dfs(r, c)) return longest_path"},{"question":"def trap(height: List[int]) -> int: Calculate the total volume of water that can be trapped after a rainfall. Args: height (list): A list of non-negative integers representing the elevation map. Returns: int: The total volume of trapped water. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9","solution":"def trap(height): Calculate the total volume of water that can be trapped after a rainfall. Args: height (list): A list of non-negative integers representing the elevation map. Returns: int: The total volume of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water water = 0 for i in range(n): water += min(left_max[i], right_max[i]) - height[i] return water"},{"question":"def compress_string(s: str) -> str: Perform basic string compression using the counts of repeated characters. If the compressed string is not shorter than the original, return the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"aaaaaaa\\") \\"a7\\" >>> compress_string(\\"aaaAAA\\") \\"a3A3\\" >>> compress_string(\\"aabbcc\\") \\"aabbcc\\" >>> compress_string(\\"aabbccccbb\\") \\"a2b2c4b2\\" # Your code here pass","solution":"def compress_string(s: str) -> str: Perform basic string compression using the counts of repeated characters. If the compressed string is not shorter than the original, return the original string. compressed = [] count_consecutive = 0 for i in range(len(s)): count_consecutive += 1 # If the next character is different than the current, append the result if i + 1 >= len(s) or s[i] != s[i + 1]: compressed.append(s[i]) compressed.append(str(count_consecutive)) count_consecutive = 0 compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"from typing import List, Tuple def max_sum_subarray_indices(a: List[int]) -> Tuple[int, int]: Returns the starting and ending (1-based) indices of the subarray with the maximum sum. >>> max_sum_subarray_indices([1, -2, 3, 4, -1]) (3, 4) >>> max_sum_subarray_indices([0, 0, 0]) (1, 1) >>> max_sum_subarray_indices([-2, -5, 6, -2, -3, 1]) (3, 3) pass def max_sum_subarrays(test_cases: List[List[int]]) -> List[Tuple[int, int]]: Given a list of test cases (each being a list of integers), returns a list of tuples where each tuple contains the starting and ending (1-based) indices of the subarray with the maximum sum for each test case. >>> max_sum_subarrays([[1, -2, 3, 4, -1], [0, 0, 0], [-2, -5, 6, -2, -3, 1]]) [(3, 4), (1, 1), (3, 3)] >>> max_sum_subarrays([[1, 2, 3], [-1, -2, -3]]) [(1, 3), (1, 1)] pass","solution":"def max_sum_subarray_indices(a): Returns the starting and ending (1-based) indices of the subarray with the maximum sum. max_sum = float('-inf') current_sum = 0 start = 0 end = 0 temp_start = 0 for i in range(len(a)): current_sum += a[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i if current_sum < 0: current_sum = 0 temp_start = i + 1 # Transforming to 1-based indexing return (start + 1, end + 1) def max_sum_subarrays(test_cases): results = [] for a in test_cases: results.append(max_sum_subarray_indices(a)) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. Arguments: root -- TreeNode, the root of the BST p -- TreeNode, one of the nodes for which we wish to find the LCA q -- TreeNode, the other node for which we wish to find the LCA Returns: TreeNode -- the lowest common ancestor of nodes p and q >>> root = TreeNode(6) >>> root.left = TreeNode(2) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> root.left.right.left = TreeNode(3) >>> root.left.right.right = TreeNode(5) >>> p = root.left # Node with value 2 >>> q = root.right # Node with value 8 >>> lowestCommonAncestor(root, p, q).val 6 >>> p = root.left # Node with value 2 >>> q = root.left.right # Node with value 4 >>> lowestCommonAncestor(root, p, q).val 2 >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> p = root # Node with value 2 >>> q = root.left # Node with value 1 >>> lowestCommonAncestor(root, p, q).val 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. Arguments: root -- TreeNode, the root of the BST p -- TreeNode, one of the nodes for which we wish to find the LCA q -- TreeNode, the other node for which we wish to find the LCA Returns: TreeNode -- the lowest common ancestor of nodes p and q while root: if p.val < root.val and q.val < root.val: root = root.left elif p.val > root.val and q.val > root.val: root = root.right else: return root"},{"question":"def generate_binary_strings(binary_strings): Generate all possible valid binary strings by replacing '?' with '0' and '1'. Args: binary_strings (list of str): List of binary strings containing '0', '1', and '?'. Returns: list of list of str: List of sub-lists containing all valid binary strings. str: 'No robots to communicate with' if input is empty. str: 'Invalid communication' if any string in input is invalid. >>> generate_binary_strings([\\"10?\\", \\"0?1?\\", \\"??\\"]) [[\\"100\\", \\"101\\"], [\\"0010\\", \\"0011\\", \\"0110\\", \\"0111\\"], [\\"00\\", \\"01\\", \\"10\\", \\"11\\"]] >>> generate_binary_strings([\\"1010\\", \\"1100\\"]) [[\\"1010\\"], [\\"1100\\"]] >>> generate_binary_strings([]) 'No robots to communicate with' >>> generate_binary_strings([\\"10?\\", \\"0A1?\\", \\"1?0!\\"]) 'Invalid communication' >>> generate_binary_strings([\\"??\\", \\"???\\"]) [[\\"00\\", \\"01\\", \\"10\\", \\"11\\"], [\\"000\\", \\"001\\", \\"010\\", \\"011\\", \\"100\\", \\"101\\", \\"110\\", \\"111\\"]]","solution":"def generate_binary_strings(binary_strings): Generate all possible valid binary strings by replacing '?' with '0' and '1'. Args: binary_strings (list of str): List of binary strings containing '0', '1', and '?'. Returns: list of list of str: List of sub-lists containing all valid binary strings. str: 'No robots to communicate with' if input is empty. str: 'Invalid communication' if any string in input is invalid. if not binary_strings: return 'No robots to communicate with' def generate_combinations(s): if '?' not in s: return [s] else: result = [] index = s.index('?') prefix = s[:index] suffix = s[index + 1:] for ch in '01': result.extend(generate_combinations(prefix + ch + suffix)) return result for binary_string in binary_strings: if not all(ch in '01?' for ch in binary_string): return 'Invalid communication' return [generate_combinations(s) for s in binary_strings]"},{"question":"def count_tours(N: int) -> int: Returns the number of distinct tours for visiting each of the N ruins starting and ending at ruin A. >>> count_tours(1) 1 >>> count_tours(2) 1 >>> count_tours(3) 2 >>> count_tours(4) 6 pass def distinct_tours(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]], int]]) -> List[int]: Returns a list containing the number of distinct tours for each test case. >>> distinct_tours(2, [(3, [(1, 2), (1, 3)], 1), (4, [(1, 2), (1, 3), (2, 4)], 1)]) [2, 6] pass from solution import count_tours, distinct_tours def test_count_tours_single(): assert count_tours(1) == 1 def test_count_tours_two(): assert count_tours(2) == 1 def test_count_tours_three(): assert count_tours(3) == 2 def test_count_tours_four(): assert count_tours(4) == 6 def test_distinct_tours_multiple_cases(): T = 2 test_cases = [ (3, [(1, 2), (1, 3)], 1), (4, [(1, 2), (1, 3), (2, 4)], 1) ] assert distinct_tours(T, test_cases) == [2, 6]","solution":"from math import factorial def count_tours(N): Returns the number of distinct tours for visiting each of the N ruins starting and ending at ruin A. MOD = 10**9 + 7 if N == 1: return 1 return factorial(N-1) % MOD def distinct_tours(T, test_cases): results = [] for i in range(T): N, _, A = test_cases[i] results.append(count_tours(N)) return results"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Calculate the largest rectangle area in a histogram given by the heights list. Args: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The area of the largest rectangle that can be formed by contiguous buildings. Examples: >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 pass","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Calculate the largest rectangle area in a histogram given by the heights list. stack = [] max_area = 0 heights.append(0) # Adding a sentinel value to make sure we process all buildings for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() # Clean up the sentinel value return max_area"},{"question":"def sum_of_odd_indexed_elements(arr: List[int]) -> int: Returns the sum of all elements at odd indices in the given array. >>> sum_of_odd_indexed_elements([1, 2, 3, 4, 5]) 6 >>> sum_of_odd_indexed_elements([0, 1, 2, 3, 4, 5]) 9 >>> sum_of_odd_indexed_elements([]) 0 >>> sum_of_odd_indexed_elements([10]) 0 >>> sum_of_odd_indexed_elements([10, 20]) 20","solution":"def sum_of_odd_indexed_elements(arr): Returns the sum of all elements at odd indices in the given array. return sum(arr[i] for i in range(1, len(arr), 2))"},{"question":"def longest_palindrome_substring(s: str) -> str: Find the longest palindrome substring within a given string. The function should ignore non-alphanumeric characters and treat uppercase and lowercase characters as equal. Examples: >>> longest_palindrome_substring(\\"A man, a plan, a canal, Panama!\\") \\"amanaplanacanalpanama\\" >>> longest_palindrome_substring(\\"racecar\\") \\"racecar\\" >>> longest_palindrome_substring(\\"noon\\") \\"noon\\"","solution":"def longest_palindrome_substring(s: str) -> str: def is_palindrome(sub): return sub == sub[::-1] def preprocess_string(s): return ''.join(c.lower() for c in s if c.isalnum()) processed_string = preprocess_string(s) n = len(processed_string) if n == 0: return \\"\\" longest_palindrome = \\"\\" for i in range(n): for j in range(i, n): substring = processed_string[i:j+1] if is_palindrome(substring) and len(substring) > len(longest_palindrome): longest_palindrome = substring return longest_palindrome"},{"question":"def intersect_lists(l1, l2): Write a function that takes two lists of integers and returns a list containing only the elements that appear in both lists. The order of elements in the returned list should be based on the order of their first appearance in the first input list. If there are no common elements, return an empty list. >>> intersect_lists([1, 2, 3, 4], [3, 4, 5, 6]) # returns [3, 4] >>> intersect_lists([10, 20, 30], [40, 50, 60]) # returns []","solution":"def intersect_lists(l1, l2): # Create a set from the second list for O(1) membership checking set_l2 = set(l2) # Initialize the result list result = [] # Iterate through the first list for item in l1: # If the item is in the set created from the second list and not already in the result list if item in set_l2 and item not in result: result.append(item) return result"},{"question":"def ladder_length(beginWord: str, endWord: str, wordList: List[str]) -> int: Returns the length of the shortest transformation sequence from beginWord to endWord, or 0 if no such transformation sequence exists. >>> ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 ... def process_cases(test_cases: List[Dict[str, Union[str, List[str]]]]) -> List[int]: Processes multiple test cases and returns a list of results for each case. >>> test_cases = [ ... {\\"beginWord\\": \\"hit\\", \\"endWord\\": \\"cog\\", \\"wordList\\": [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]}, ... {\\"beginWord\\": \\"hit\\", \\"endWord\\": \\"cog\\", \\"wordList\\": [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]} ... ] >>> process_cases(test_cases) [5, 0] ... from solution import ladder_length, process_cases def test_ladder_length_transform(): assert ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) == 5 def test_ladder_length_no_transform(): assert ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) == 0 def test_multiple_cases(): test_cases = [ {\\"beginWord\\": \\"hit\\", \\"endWord\\": \\"cog\\", \\"wordList\\": [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]}, {\\"beginWord\\": \\"hit\\", \\"endWord\\": \\"cog\\", \\"wordList\\": [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]} ] expected_results = [5, 0] assert process_cases(test_cases) == expected_results def test_no_end_word_in_list(): assert ladder_length(\\"hit\\", \\"dog\\", [\\"hot\\", \\"dot\\", \\"log\\"]) == 0 def test_direct_adjacency(): assert ladder_length(\\"hit\\", \\"hot\\", [\\"hot\\", \\"dot\\", \\"dog\\"]) == 2","solution":"from collections import deque, defaultdict def ladder_length(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord, or 0 if no such transformation sequence exists. if endWord not in wordList: return 0 L = len(beginWord) all_combo_dict = defaultdict(list) for word in wordList: for i in range(L): all_combo_dict[word[:i] + \\"*\\" + word[i+1:]].append(word) queue = deque([(beginWord, 1)]) visited = set() visited.add(beginWord) while queue: current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \\"*\\" + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word == endWord: return level + 1 if word not in visited: visited.add(word) queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] # clear to reduce unnecessary processing return 0 def process_cases(test_cases): results = [] for case in test_cases: beginWord, endWord, wordList = case['beginWord'], case['endWord'], case['wordList'] result = ladder_length(beginWord, endWord, wordList) results.append(result) return results"},{"question":"def can_be_palindrome(s: str) -> bool: Write a function that receives a string and checks if it can be made into a palindrome by removing at most one character. A string is a palindrome if it reads the same forward and backward. The function should return \`True\` if the string can become a palindrome within the conditions specified, or \`False\` otherwise. >>> can_be_palindrome(\\"radar\\") True >>> can_be_palindrome(\\"hello\\") False >>> can_be_palindrome(\\"abca\\") True >>> can_be_palindrome(\\"racecar\\") True >>> can_be_palindrome(\\"racecarr\\") True","solution":"def can_be_palindrome(s): def is_palindrome(sub): return sub == sub[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: one_removed_left = s[left+1:right+1] one_removed_right = s[left:right] return is_palindrome(one_removed_left) or is_palindrome(one_removed_right) left += 1 right -= 1 return True"},{"question":"class Matrix: def __init__(self, a, b, c, d): self.a = a self.b = b self.c = c self.d = d def multiply(self, other): Multiplies this 2x2 matrix with another 2x2 matrix. >>> m1 = Matrix(1, 2, 3, 4) >>> m2 = Matrix(5, 6, 7, 8) >>> m3 = m1.multiply(m2) >>> m3.a, m3.b, m3.c, m3.d (19, 22, 43, 50)","solution":"class Matrix: def __init__(self, a, b, c, d): self.a = a self.b = b self.c = c self.d = d def multiply(self, other): a_new = self.a * other.a + self.b * other.c b_new = self.a * other.b + self.b * other.d c_new = self.c * other.a + self.d * other.c d_new = self.c * other.b + self.d * other.d return Matrix(a_new, b_new, c_new, d_new)"},{"question":"def is_valid_ipv4_address(ip: str) -> bool: Evaluates if a given string is a valid IPv4 address. An IPv4 address is considered valid if it consists of four octets, separated by dots (.), with each octet ranging from 0 to 255, and no leading zeros. Parameters: ip (str): The input string to check. Returns: bool: True if the input string is a valid IPv4 address, False otherwise. >>> is_valid_ipv4_address(\\"192.168.1.1\\") True >>> is_valid_ipv4_address(\\"0.0.0.0\\") True >>> is_valid_ipv4_address(\\"255.255.255.255\\") True >>> is_valid_ipv4_address(\\"256.256.256.256\\") False >>> is_valid_ipv4_address(\\"192.168.1\\") False >>> is_valid_ipv4_address(\\"192.168.1.1.1\\") False >>> is_valid_ipv4_address(\\"192.168.01.1\\") False >>> is_valid_ipv4_address(\\"192.168.a.1\\") False >>> is_valid_ipv4_address(\\".192.168.1.1\\") False >>> is_valid_ipv4_address(\\"192.168.1.1.\\") False >>> is_valid_ipv4_address(\\"192.168..1.1\\") False >>> is_valid_ipv4_address(\\"1.1.1.1\\") True >>> is_valid_ipv4_address(\\"001.001.001.001\\") False >>> is_valid_ipv4_address(\\"255.0255.255.255\\") False","solution":"def is_valid_ipv4_address(ip): Evaluates if a given string is a valid IPv4 address. Parameters: ip (str): The input string to check. Returns: bool: True if the input string is a valid IPv4 address, False otherwise. parts = ip.split(\\".\\") if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False if len(part) > 1 and part[0] == '0': return False if not (0 <= int(part) <= 255): return False return True"},{"question":"def is_subsequence(s: str, t: str) -> bool: Helper function to check if s is a subsequence of t. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") == True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") == False >>> is_subsequence(\\"apple\\", \\"abpcplea\\") == True >>> is_subsequence(\\"plea\\", \\"abpcplea\\") == True def longestWordFromDict(s: str, dictionary: List[str]) -> str: Returns the longest word from the dictionary that can be formed by deleting some of the letters from the given string s without reordering the remaining letters. >>> longestWordFromDict(\\"abpcplea\\", [\\"ale\\",\\"apple\\",\\"monkey\\",\\"plea\\"]) == \\"apple\\" >>> longestWordFromDict(\\"abpcplea\\", [\\"a\\",\\"b\\",\\"c\\"]) == \\"a\\" >>> longestWordFromDict(\\"abpcplea\\", [\\"xyz\\", \\"qrs\\"]) == \\"\\"","solution":"def is_subsequence(s, t): Helper function to check if s is a subsequence of t. t_iter = iter(t) return all(char in t_iter for char in s) def longestWordFromDict(s, dictionary): Returns the longest word from the dictionary that can be formed by deleting some of the letters from the given string s without reordering the remaining letters. longest_word = \\"\\" for word in dictionary: if is_subsequence(word, s): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"def create_story(name: str, age: int, activity: str) -> str: Generates a short story based on the given character's name, age, and favorite activity. Parameters: name (str): Character's name. age (int): Character's age. activity (str): Character's favorite activity. Returns: str: A short story string. pass def test_create_story_standard(): assert create_story(\\"Alice\\", 7, \\"painting\\") == (\\"Once upon a time, there was a 7-year-old named Alice who loved to painting. \\" \\"Every single day, Alice would spend hours enjoying painting and would tell everyone about it!\\") def test_create_story_different_age_and_activity(): assert create_story(\\"Bob\\", 35, \\"cycling\\") == (\\"Once upon a time, there was a 35-year-old named Bob who loved to cycling. \\" \\"Every single day, Bob would spend hours enjoying cycling and would tell everyone about it!\\") def test_create_story_long_name(): assert create_story(\\"Christopher\\", 12, \\"sketching\\") == (\\"Once upon a time, there was a 12-year-old named Christopher who loved to sketching. \\" \\"Every single day, Christopher would spend hours enjoying sketching and would tell everyone about it!\\") def test_create_story_different_name_and_activity(): assert create_story(\\"Zara\\", 5, \\"dancing\\") == (\\"Once upon a time, there was a 5-year-old named Zara who loved to dancing. \\" \\"Every single day, Zara would spend hours enjoying dancing and would tell everyone about it!\\")","solution":"def create_story(name, age, activity): Generates a short story based on the given character's name, age, and favorite activity. Parameters: name (str): Character's name. age (int): Character's age. activity (str): Character's favorite activity. Returns: str: A short story string. return (f\\"Once upon a time, there was a {age}-year-old named {name} who loved to {activity}. \\" f\\"Every single day, {name} would spend hours enjoying {activity} and would tell everyone about it!\\")"},{"question":"def game_simulation(rolls): Simulate the Conwy Monopoly game based on the given dice rolls and return the winning player. Parameters: rolls (list of tuples): A list of tuples where each tuple contains two integers representing the outcome of two six-sided dice rolls. Returns: int: The player number (1 or 2) of the winner, or 0 if both players go bankrupt in the same turn. Example: >>> game_simulation([(3, 4), (5, 5), (1, 6), (1, 2)]) 2 >>> game_simulation([(6, 6), (3, 4), (1, 3), (2, 3), (3, 3)]) 1 from solution import game_simulation def test_both_bankrupt_same_turn(): rolls = [(3, 4), (4, 3), (3, 4), (4, 3), (3, 4), (4, 3)] assert game_simulation(rolls) == 0 def test_player_1_wins(): rolls = [(1, 1), (4, 3), (6, 6), (4, 3), (6, 6), (4, 3)] assert game_simulation(rolls) == 1 def test_player_2_wins(): rolls = [(4, 3), (1, 1), (4, 3), (6, 6), (4, 3), (6, 6)] assert game_simulation(rolls) == 2 def test_no_winner(): rolls = [(1, 1), (6, 6), (1, 1), (6, 6), (1, 1), (6, 6)] assert game_simulation(rolls) == 0 def test_player_1_bankrupt(): rolls = [(3, 4), (1, 1), (3, 4), (1, 1), (3, 4), (1, 1), (3, 4)] assert game_simulation(rolls) == 2 def test_player_2_bankrupt(): rolls = [(1, 1), (3, 4), (1, 1), (3, 4), (1, 1), (3, 4), (1, 1), (3, 4), (3, 4)] assert game_simulation(rolls) == 1 def test_example_case(): rolls = [(3, 4), (5, 5), (1, 6), (1, 2)] assert game_simulation(rolls) == 2","solution":"def game_simulation(rolls): Simulates the Conwy Monopoly game based on the given dice rolls. Args: rolls (list of tuples): A list of tuples where each tuple represents a dice roll (two integers between 1 and 6). Returns: int: The player number of the winner (1 or 2) or 0 if both players go bankrupt in the same turn. # Initial setup: both players start with 1000 dollars player1_money = 1000 player2_money = 1000 # Iterate over the rolls for i, roll in enumerate(rolls): current_player = 1 if i % 2 == 0 else 2 roll_sum = sum(roll) if current_player == 1: if roll_sum == 7: player1_money -= 200 elif roll[0] == roll[1]: player1_money += 100 else: if roll_sum == 7: player2_money -= 200 elif roll[0] == roll[1]: player2_money += 100 # Check if any player goes bankrupt if player1_money < 0 and player2_money < 0: return 0 elif player1_money < 0: return 2 elif player2_money < 0: return 1 # If the loop ends and no player has gone bankrupt, the player with higher money wins if player1_money > player2_money: return 1 elif player2_money > player1_money: return 2 else: return 0"},{"question":"import heapq from typing import List def task_scheduler(operations: List[List[str]]) -> List[int]: Simulates a task scheduler that can insert tasks with priorities and execute the task with the highest priority. >>> task_scheduler([[\\"I\\", \\"3\\"], [\\"E\\"]]) [3] >>> task_scheduler([[\\"I\\", \\"3\\"], [\\"I\\", \\"1\\"], [\\"E\\"], [\\"I\\", \\"2\\"], [\\"E\\"], [\\"I\\", \\"5\\"], [\\"E\\"], [\\"I\\", \\"4\\"], [\\"E\\"], [\\"E\\"]]) [3, 2, 5, 4, 1] max_heap = [] result = [] for operation in operations: if operation[0] == 'I': # Insert the value into the max_heap using negative values since heapq is a min-heap heapq.heappush(max_heap, -int(operation[1])) elif operation[0] == 'E': # Pop the max value from the heap (convert it back to positive) result.append(-heapq.heappop(max_heap)) return result def test_single_insert_and_execute(): operations = [[\\"I\\", \\"3\\"], [\\"E\\"]] assert task_scheduler(operations) == [3] def test_multiple_inserts_and_executes(): operations = [[\\"I\\", \\"3\\"], [\\"I\\", \\"1\\"], [\\"E\\"], [\\"I\\", \\"2\\"], [\\"E\\"], [\\"I\\", \\"5\\"], [\\"E\\"], [\\"I\\", \\"4\\"], [\\"E\\"], [\\"E\\"]] assert task_scheduler(operations) == [3, 2, 5, 4, 1] def test_all_executes_after_insert(): operations = [[\\"I\\", \\"3\\"], [\\"I\\", \\"1\\"], [\\"I\\", \\"4\\"], [\\"I\\", \\"5\\"], [\\"E\\"], [\\"E\\"], [\\"E\\"], [\\"E\\"]] assert task_scheduler(operations) == [5, 4, 3, 1] def test_alternating_inserts_and_executes(): operations = [[\\"I\\", \\"1\\"], [\\"E\\"], [\\"I\\", \\"2\\"], [\\"E\\"], [\\"I\\", \\"3\\"], [\\"E\\"]] assert task_scheduler(operations) == [1, 2, 3] def test_largest_number(): operations = [[\\"I\\", \\"1000000\\"], [\\"I\\", \\"999999\\"], [\\"E\\"], [\\"E\\"]] assert task_scheduler(operations) == [1000000, 999999]","solution":"import heapq def task_scheduler(operations): max_heap = [] result = [] for operation in operations: if operation[0] == 'I': # Insert the value into the max_heap using negative values since heapq is a min-heap heapq.heappush(max_heap, -int(operation[1])) elif operation[0] == 'E': # Pop the max value from the heap (convert it back to positive) result.append(-heapq.heappop(max_heap)) return result"},{"question":"def unique_pairs(n: int) -> list[tuple[int, int]]: Returns all unique pairs of integers (a, b) such that a * b == n and a <= b. >>> unique_pairs(6) [(1, 6), (2, 3)] >>> unique_pairs(16) [(1, 16), (2, 8), (4, 4)] >>> unique_pairs(13) [(1, 13)] >>> unique_pairs(1) [(1, 1)] >>> unique_pairs(30) [(1, 30), (2, 15), (3, 10), (5, 6)]","solution":"def unique_pairs(n): Returns all unique pairs of integers (a, b) such that a * b == n and a <= b. pairs = [] for a in range(1, int(n**0.5) + 1): if n % a == 0: b = n // a pairs.append((a, b)) if a <= b else None return pairs"},{"question":"from typing import List from collections import Counter def can_form_palindrome(s: str) -> str: Determines if any permutation of the given string of digits can form a palindrome. Args: s (str): A string of digits. Returns: str: \\"YES\\" if any permutation can form a palindrome, otherwise \\"NO\\". def process_test_cases(t: int, cases: List[str]) -> List[str]: Processes multiple test cases to check if each can form a palindrome. Args: t (int): Number of test cases. cases (list of str): List of string digits for each test case. Returns: list of str: List of results for each test case (\\"YES\\" or \\"NO\\"). def test_can_form_palindrome(): assert can_form_palindrome(\\"112\\") == \\"YES\\" assert can_form_palindrome(\\"212\\") == \\"YES\\" assert can_form_palindrome(\\"12345\\") == \\"NO\\" assert can_form_palindrome(\\"1\\") == \\"YES\\" assert can_form_palindrome(\\"1221\\") == \\"YES\\" assert can_form_palindrome(\\"11\\") == \\"YES\\" assert can_form_palindrome(\\"111\\") == \\"YES\\" def test_process_test_cases(): assert process_test_cases(3, [\\"112\\", \\"212\\", \\"12345\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(2, [\\"123\\", \\"44\\"]) == [\\"NO\\", \\"YES\\"] assert process_test_cases(4, [\\"1\\", \\"22\\", \\"333\\", \\"4444\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] assert process_test_cases(1, [\\"9876543210\\"]) == [\\"NO\\"]","solution":"def can_form_palindrome(s): Determines if any permutation of the given string of digits can form a palindrome. Args: s (str): A string of digits. Returns: str: \\"YES\\" if any permutation can form a palindrome, otherwise \\"NO\\". from collections import Counter count = Counter(s) odd_count = sum(1 for value in count.values() if value % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_test_cases(t, cases): Processes multiple test cases to check if each can form a palindrome. Args: t (int): Number of test cases. cases (list of str): List of string digits for each test case. Returns: list of str: List of results for each test case (\\"YES\\" or \\"NO\\"). results = [can_form_palindrome(case) for case in cases] return results"},{"question":"class InventoryManager: A system to manage product inventory with operations to add, remove, and query stock. Methods: - add(product_name: str, quantity: int): Adds specified quantity of the product to the inventory. - remove(product_name: str, quantity: int): Removes specified quantity of the product from the inventory. - query(product_name: str) -> int: Returns the current quantity of the specified product in the inventory. Example: >>> manager = InventoryManager() >>> manager.add(\\"apple\\", 10) >>> manager.add(\\"orange\\", 5) >>> manager.query(\\"apple\\") 10 >>> manager.remove(\\"apple\\", 3) >>> manager.query(\\"apple\\") 7 def __init__(self): self.inventory = {} def add(self, product_name: str, quantity: int): pass def remove(self, product_name: str, quantity: int): pass def query(self, product_name: str) -> int: pass","solution":"class InventoryManager: def __init__(self): self.inventory = {} def add(self, product_name, quantity): if product_name in self.inventory: self.inventory[product_name] += quantity else: self.inventory[product_name] = quantity def remove(self, product_name, quantity): if product_name in self.inventory: self.inventory[product_name] -= quantity def query(self, product_name): return self.inventory.get(product_name, 0)"},{"question":"def knight_moves(moves): Determine if a series of moves returns a knight to its starting position. >>> knight_moves(['U', 'L', 'D', 'R']) True >>> knight_moves(['L', 'L', 'U']) False >>> knight_moves(['U', 'R', 'D', 'L', 'L']) False >>> knight_moves([]) True >>> knight_moves(['U', 'D'] * 10 + ['L', 'R'] * 10) True","solution":"def knight_moves(moves): Determine if a series of moves returns a knight to its starting position. Parameters: moves (list): A list of single character moves (U, D, L, R) Returns: bool: True if the knight returns to the starting point, False otherwise. # Initial position x, y = 0, 0 # Define move map move_map = { 'U': (2, 1), 'D': (-2, -1), 'L': (-2, 1), 'R': (2, -1) } # Process each move in the list for move in moves: dx, dy = move_map[move] x += dx y += dy # Return True if back to origin, False otherwise return x == 0 and y == 0"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. If input is not a string, returns \\"Invalid input\\". Examples: >>> longest_unique_substring(\\"abcabcbb\\") == 3 >>> longest_unique_substring(\\"bbbbb\\") == 1 >>> longest_unique_substring(\\"pwwkew\\") == 3 >>> longest_unique_substring(\\"aab\\") == 2 >>> longest_unique_substring(12345) == \\"Invalid input\\" >>> longest_unique_substring(\\"\\") == 0","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. If input is not a string, returns \\"Invalid input\\". if not isinstance(s, str): return \\"Invalid input\\" if not s: return 0 start, max_length = 0, 0 used_chars = {} for index, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"def minimum_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of swaps required to sort the array in ascending order. >>> minimum_swaps_to_sort([4, 3, 2, 1]) 2 >>> minimum_swaps_to_sort([1, 3, 5, 2, 4, 6]) 3 >>> minimum_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> minimum_swaps_to_sort([1, 2, 3, 4]) 0 >>> minimum_swaps_to_sort([2, 3, 4, 1, 5]) 3 >>> minimum_swaps_to_sort([7, 1, 3, 2, 4, 5, 6]) 5","solution":"def minimum_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in ascending order. n = len(arr) arr_pos = [(value, index) for index, value in enumerate(arr)] arr_pos.sort(key=lambda x: x[0]) visited = {k: False for k in range(n)} swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def to_snake_case(s: str) -> str: Transforms a given string into snake_case. >>> to_snake_case(\\"Hello World\\") \\"hello_world\\" >>> to_snake_case(\\"snake_case\\") \\"snake_case\\" >>> to_snake_case(\\"This-is-snake-case\\") \\"this_is_snake_case\\"","solution":"def to_snake_case(s): Transforms a given string into snake_case. # Replace any hyphens or spaces with underscores s = s.replace(\\"-\\", \\"_\\").replace(\\" \\", \\"_\\") # Split the string by underscores to handle multiple delimiters parts = s.split(\\"_\\") # Join the parts back with underscores, ensuring no extra underscores result = \\"_\\".join(part.lower() for part in parts if part) return result"},{"question":"def is_palindrome(number: int) -> bool: Write an algorithm to check if a positive integer is a palindrome. A number is considered a palindrome when it reads the same backward as forward. >>> is_palindrome(12321) True >>> is_palindrome(12345) False","solution":"def is_palindrome(number): Returns True if number is a palindrome, otherwise False. # Convert the number to a string and reverse it reversed_number = str(number)[::-1] # Check if the original number (as a string) and the reversed string are the same return str(number) == reversed_number"},{"question":"def fibonacci(n: int) -> List[int]: Returns the first n elements of the Fibonacci sequence. >>> fibonacci(1) [0] >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns the first n elements of the Fibonacci sequence. if n <= 0: return [] sequence = [0, 1] while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence[:n]"},{"question":"def isNumber(s: str) -> bool: Determines if the input string can be interpreted as a valid number. >>> isNumber(\\"0\\") == True >>> isNumber(\\" 0.1 \\") == True >>> isNumber(\\"-90e3\\") == True >>> isNumber(\\"2e10\\") == True >>> isNumber(\\"3.\\") == True >>> isNumber(\\".1\\") == True >>> isNumber(\\"+.8\\") == True >>> isNumber(\\"abc\\") == False >>> isNumber(\\"1 a\\") == False >>> isNumber(\\"1e\\") == False >>> isNumber(\\"e3\\") == False >>> isNumber(\\"99e2.5\\") == False >>> isNumber(\\"--6\\") == False >>> isNumber(\\"-+3\\") == False >>> isNumber(\\"95a54e53\\") == False >>> isNumber(\\".\\") == False >>> isNumber(\\"..\\") == False >>> isNumber(\\".e\\") == False >>> isNumber(\\"-.\\") == False","solution":"import re def isNumber(s: str) -> bool: Determines if the input string can be interpreted as a valid number. # Remove leading and trailing whitespace s = s.strip() # Regular expression for validating a number pattern = re.compile(r'^[+-]?(d+(.d*)?|.d+)([eE][+-]?d+)?') # Match the pattern against the input string return bool(pattern.match(s))"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of water that can be trapped given a list of non-negative integers representing the heights. :param height: A list of non-negative integers representing the heights of blocks. :return: An integer representing the total amount of water trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([1, 1, 1, 1]) 0 >>> trap([2, 1, 2]) 1 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([1, 3, 5, 7, 9]) 0 >>> trap([9, 7, 5, 3, 1]) 0","solution":"def trap(height): Calculate the total amount of water that can be trapped. :param height: A list of non-negative integers representing the heights of blocks. :return: An integer representing the total amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the water trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def sort_songs(songs): Sorts a list of songs based on their popularity score (descending) and unique identifier (ascending). Args: songs (list of tuples): List of tuples where each tuple contains (unique identifier, popularity score). Returns: list: List of sorted unique identifiers based on the given rules. >>> sort_songs([(1001, 50), (1002, 60), (1003, 60), (1004, 40)]) [1002, 1003, 1001, 1004] >>> sort_songs([(1001, 60), (1003, 60), (1002, 60)]) [1001, 1002, 1003]","solution":"def sort_songs(songs): Sorts a list of songs based on their popularity score (descending) and unique identifier (ascending). Args: songs (list of tuples): List of tuples where each tuple contains (unique identifier, popularity score). Returns: list: List of sorted unique identifiers based on the given rules. # First sort by unique identifier ascending, then sort by popularity descending sorted_songs = sorted(songs, key=lambda x: (-x[1], x[0])) sorted_song_ids = [song[0] for song in sorted_songs] return sorted_song_ids"},{"question":"from typing import Dict, Set, List def suggest_friends(user: str, friends_network: Dict[str, Set[str]]) -> List[str]: Suggest new friends to a user based on mutual connections. Args: user (str): The name of the user. friends_network (Dict[str, Set[str]]): A dictionary where keys are user names and values are sets of direct friends. Returns: List[str]: A list of suggested friends ordered by the number of mutual friends in descending order. Example: >>> friends_network = { ... \\"Alice\\": {\\"Bob\\", \\"Charlie\\"}, ... \\"Bob\\": {\\"Alice\\", \\"Charlie\\", \\"David\\"}, ... \\"Charlie\\": {\\"Alice\\", \\"Bob\\", \\"Eve\\"}, ... \\"David\\": {\\"Bob\\"}, ... \\"Eve\\": {\\"Charlie\\"} ... } >>> suggest_friends(\\"Alice\\", friends_network) ['David', 'Eve'] def test_suggest_friends_basic_case(): friends_network = { \\"Alice\\": {\\"Bob\\", \\"Charlie\\"}, \\"Bob\\": {\\"Alice\\", \\"Charlie\\", \\"David\\"}, \\"Charlie\\": {\\"Alice\\", \\"Bob\\", \\"Eve\\"}, \\"David\\": {\\"Bob\\"}, \\"Eve\\": {\\"Charlie\\"} } assert suggest_friends(\\"Alice\\", friends_network) == [\\"David\\", \\"Eve\\"] def test_suggest_friends_with_no_mutuals(): friends_network = { \\"Alice\\": {\\"Bob\\"}, \\"Bob\\": {\\"Alice\\"}, \\"Charlie\\": {\\"David\\"}, \\"David\\": {\\"Charlie\\"} } assert suggest_friends(\\"Alice\\", friends_network) == [] def test_suggest_friends_with_multiple_mutuals(): friends_network = { \\"Alice\\": {\\"Bob\\", \\"Charlie\\"}, \\"Bob\\": {\\"Alice\\", \\"Charlie\\", \\"David\\"}, \\"Charlie\\": {\\"Alice\\", \\"Bob\\", \\"David\\", \\"Eve\\"}, \\"David\\": {\\"Bob\\", \\"Charlie\\"}, \\"Eve\\": {\\"Charlie\\"} } assert suggest_friends(\\"Alice\\", friends_network) == [\\"David\\", \\"Eve\\"] def test_suggest_friends_with_tiebreaker(): friends_network = { \\"Alice\\": {\\"Bob\\", \\"Charlie\\"}, \\"Bob\\": {\\"Alice\\", \\"David\\"}, \\"Charlie\\": {\\"Alice\\", \\"Eve\\"}, \\"David\\": {\\"Bob\\"}, \\"Eve\\": {\\"Charlie\\"} } suggestions = suggest_friends(\\"Alice\\", friends_network) assert suggestions == [\\"David\\", \\"Eve\\"] or suggestions == [\\"Eve\\", \\"David\\"] def test_suggest_friends_empty_network(): friends_network = {} assert suggest_friends(\\"Alice\\", friends_network) == [] def test_suggest_friends_no_friends(): friends_network = { \\"Alice\\": set(), \\"Bob\\": {\\"Charlie\\"}, \\"Charlie\\": {\\"Bob\\"} } assert suggest_friends(\\"Alice\\", friends_network) == []","solution":"from typing import Dict, Set, List from collections import defaultdict def suggest_friends(user: str, friends_network: Dict[str, Set[str]]) -> List[str]: mutual_friends_count = defaultdict(int) user_friends = friends_network.get(user, set()) for friend in user_friends: for mutual_friend in friends_network.get(friend, set()): if mutual_friend != user and mutual_friend not in user_friends: mutual_friends_count[mutual_friend] += 1 sorted_suggestions = sorted(mutual_friends_count.keys(), key=lambda x: (-mutual_friends_count[x], x)) return sorted_suggestions"},{"question":"def rotate_grid_90_clockwise(grid): Rotates the given N x M grid 90 degrees clockwise. >>> rotate_grid_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_grid_90_clockwise([ ... [1, 2, 3, 4], ... [5, 6, 7, 8] ... ]) == [ ... [5, 1], ... [6, 2], ... [7, 3], ... [8, 4] ... ] pass # Your code here def process_test_cases(t, test_cases): Processes multiple test cases and returns results. >>> process_test_cases(2, [ ... (3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), ... (2, 4, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8] ... ]) ... ]) == [ ... [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ], ... [ ... [5, 1], ... [6, 2], ... [7, 3], ... [8, 4] ... ] ... ] pass # Your code here def format_results(results): Formats the results into a string for output. >>> format_results([ ... [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ], ... [ ... [5, 1], ... [6, 2], ... [7, 3], ... [8, 4] ... ] ... ]) == \\"7 4 1n8 5 2n9 6 3nn5 1n6 2n7 3n8 4\\" pass # Your code here","solution":"def rotate_grid_90_clockwise(grid): Rotates the given N x M grid 90 degrees clockwise. rows, cols = len(grid), len(grid[0]) rotated_grid = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated_grid[c][rows - 1 - r] = grid[r][c] return rotated_grid def process_test_cases(t, test_cases): results = [] for test_case in test_cases: n, m, grid = test_case rotated_grid = rotate_grid_90_clockwise(grid) results.append(rotated_grid) return results # Function to format the results for output def format_results(results): formatted_results = [] for result in results: formatted_results.append(\\"n\\".join(\\" \\".join(map(str, row)) for row in result)) return \\"nn\\".join(formatted_results)"},{"question":"def missing_integers(src: List[int], n: int) -> List[int]: Create a function \`missing_integers(src, n)\` that takes two parameters: \`src\`, a list of integers, and \`n\`, an integer. The function should return a list of integers from 1 to \`n\` that are missing in the \`src\` list. If \`n\` is less than 1, return an empty list. >>> missing_integers([1, 3, 5], 5) [2, 4] >>> missing_integers([1, 2, 3], 3) [] >>> missing_integers([1, 5, 6], 6) [2, 3, 4] >>> missing_integers([], 3) [1, 2, 3] >>> missing_integers([1, 2, 3], 0) []","solution":"def missing_integers(src, n): Returns a list of integers from 1 to n that are missing in the src list. if n < 1: return [] return [i for i in range(1, n + 1) if i not in src]"},{"question":"def find_anagram_groups(words: List[str]) -> List[List[str]]: Returns a list of lists, where each sublist contains words that are anagrams of each other. The order of the words in each sublist follows the order they appear in the input list. The order of the sublists in the output also follows the order in which the first word of each group appears in the original list. Args: words (List[str]): A list of strings to group by anagrams. Returns: List[List[str]]: A list of lists with anagram groups. Example: >>> find_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooegl\\", \\"foo\\", \\"oof\\"]) [['listen', 'silent', 'enlist'], ['google', 'gooegl'], ['foo', 'oof']] >>> find_anagram_groups([\\"bob\\", \\"obb\\", \\"boo\\"]) [['bob', 'obb'], ['boo']] # Your code here from solution import find_anagram_groups def test_find_anagram_groups_with_anagrams(): result = find_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooegl\\", \\"foo\\", \\"oof\\"]) expected = [['listen', 'silent', 'enlist'], ['google', 'gooegl'], ['foo', 'oof']] assert result == expected def test_find_anagram_groups_with_case_insensitive_anagrams(): result = find_anagram_groups([\\"Listen\\", \\"Silent\\", \\"Enlist\\", \\"Google\\", \\"Gooegl\\", \\"Foo\\", \\"Oof\\"]) expected = [['Listen', 'Silent', 'Enlist'], ['Google', 'Gooegl'], ['Foo', 'Oof']] assert result == expected def test_find_anagram_groups_no_anagrams(): result = find_anagram_groups([\\"abc\\", \\"def\\", \\"ghi\\"]) expected = [['abc'], ['def'], ['ghi']] assert result == expected def test_find_anagram_groups_no_words(): result = find_anagram_groups([]) expected = [] assert result == expected def test_find_anagram_groups_single_word(): result = find_anagram_groups([\\"abc\\"]) expected = [['abc']] assert result == expected def test_find_anagram_groups_mixed_anagrams_no_anagrams(): result = find_anagram_groups([\\"bob\\", \\"obb\\", \\"boo\\"]) expected = [['bob', 'obb'], ['boo']] assert result == expected def test_find_anagram_groups_all_same_words(): result = find_anagram_groups([\\"bob\\", \\"bob\\", \\"bob\\"]) expected = [['bob', 'bob', 'bob']] assert result == expected","solution":"def find_anagram_groups(words): Returns a list of lists, where each sublist contains words that are anagrams of each other. The order of the words in each sublist follows the order they appear in the input list. The order of the sublists in the output also follows the order in which the first word of each group appears in the original list. from collections import defaultdict # Dictionary to group anagrams anagram_dict = defaultdict(list) # Iterate over each word to group them for word in words: # Use a sorted tuple of the word as the key sorted_word = tuple(sorted(word.lower())) anagram_dict[sorted_word].append(word) # Return the list of grouped anagrams return [group for group in anagram_dict.values()]"},{"question":"from typing import List, Tuple, Optional def match_keys_and_locks(keys: List[str], locks: List[str]) -> List[Tuple[Optional[str], Optional[str]]]: Returns a list of tuples where each tuple contains a key and its matching lock from the input lists. If a key does not match any lock or if there are more locks than keys, pairs with None. >>> match_keys_and_locks([\\"abc\\", \\"def\\", \\"ghi\\"], [\\"ghi\\", \\"abc\\", \\"def\\"]) [('abc', 'abc'), ('def', 'def'), ('ghi', 'ghi')] >>> match_keys_and_locks([\\"abc\\", \\"def\\"], [\\"ghi\\", 'abc']) [('abc', 'abc'), ('def', None), (None, 'ghi')] >>> match_keys_and_locks([\\"abc\\", \\"def\\"], [\\"xyz\\", \\"uvw\\"]) [('abc', None), ('def', None), (None, 'xyz'), (None, 'uvw')] >>> match_keys_and_locks([\\"abc\\"], [\\"abc\\", \\"def\\"]) [('abc', 'abc'), (None, 'def')] >>> match_keys_and_locks([\\"abc\\", \\"def\\", \\"ghi\\"], [\\"abc\\"]) [('abc', 'abc'), ('def', None), ('ghi', None)] >>> match_keys_and_locks([], []) [] >>> match_keys_and_locks([], [\\"abc\\"]) [(None, \\"abc\\")] >>> match_keys_and_locks([\\"abc\\"], []) [(\\"abc\\", None)]","solution":"def match_keys_and_locks(keys, locks): Returns a list of tuples where each tuple contains a key and its matching lock from the input lists. If a key does not match any lock or if there are more locks than keys, pairs with None. result = [] matched_locks = set() for key in keys: matched = False for lock in locks: if key == lock and lock not in matched_locks: result.append((key, lock)) matched_locks.add(lock) matched = True break if not matched: result.append((key, None)) for lock in locks: if lock not in matched_locks: result.append((None, lock)) return result"},{"question":"class Bank: def __init__(self): Initialize a Bank object pass def create_account(self, initial_deposit): Create a new account with a unique account number and an initial deposit >>> bank = Bank() >>> bank.create_account(1000) 1 pass def deposit(self, account_number, amount): Deposit money into a specific account >>> bank = Bank() >>> account_number = bank.create_account(1000) >>> bank.deposit(account_number, 500) \\"SUCCESS\\" pass def withdraw(self, account_number, amount): Withdraw money from a specific account >>> bank = Bank() >>> account_number = bank.create_account(1000) >>> bank.withdraw(account_number, 300) \\"SUCCESS\\" pass def balance(self, account_number): Check the balance of a specific account >>> bank = Bank() >>> account1 = bank.create_account(1000) >>> bank.balance(account1) 1000 pass import pytest def test_create_account(): bank = Bank() assert bank.create_account(1000) == 1 assert bank.create_account(1500) == 2 def test_deposit(): bank = Bank() account_number = bank.create_account(1000) assert bank.deposit(account_number, 500) == \\"SUCCESS\\" assert bank.balance(account_number) == 1500 assert bank.deposit(999, 500) == \\"FAILURE\\" def test_withdraw(): bank = Bank() account_number = bank.create_account(1000) assert bank.withdraw(account_number, 300) == \\"SUCCESS\\" assert bank.balance(account_number) == 700 assert bank.withdraw(account_number, 800) == \\"FAILURE\\" assert bank.withdraw(999, 300) == \\"FAILURE\\" def test_balance(): bank = Bank() account1 = bank.create_account(1000) account2 = bank.create_account(1500) assert bank.balance(account1) == 1000 assert bank.balance(account2) == 1500 assert bank.balance(999) == \\"FAILURE\\"","solution":"class Bank: def __init__(self): self.accounts = {} self.next_account_number = 1 def create_account(self, initial_deposit): account_number = self.next_account_number self.accounts[account_number] = initial_deposit self.next_account_number += 1 return account_number def deposit(self, account_number, amount): if account_number in self.accounts: self.accounts[account_number] += amount return \\"SUCCESS\\" else: return \\"FAILURE\\" def withdraw(self, account_number, amount): if account_number in self.accounts and self.accounts[account_number] >= amount: self.accounts[account_number] -= amount return \\"SUCCESS\\" else: return \\"FAILURE\\" def balance(self, account_number): if account_number in self.accounts: return self.accounts[account_number] else: return \\"FAILURE\\""},{"question":"def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers up to and including the given integer n. >>> sum_of_primes(10) 17 >>> sum_of_primes(11) 28 >>> sum_of_primes(0) 0 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 2 >>> sum_of_primes(3) 5 >>> sum_of_primes(4) 5","solution":"def sum_of_primes(n): Returns the sum of all prime numbers up to and including the given integer n. if n < 2: return 0 primes = [True] * (n + 1) primes[0] = primes[1] = False p = 2 while (p * p <= n): if primes[p] is True: for i in range(p * p, n + 1, p): primes[i] = False p += 1 prime_sum = sum(i for i in range(n + 1) if primes[i]) return prime_sum"},{"question":"def alphabet_positions(s: str) -> str: Write a function that takes a string consisting of only lowercase English letters and returns a new string where each character is replaced with its position in the alphabet. >>> alphabet_positions(\\"a\\") \\"1\\" >>> alphabet_positions(\\"z\\") \\"26\\" >>> alphabet_positions(\\"abc\\") \\"123\\" >>> alphabet_positions(\\"xyz\\") \\"242526\\" >>> alphabet_positions(\\"hello\\") \\"85121215\\" >>> alphabet_positions(\\"world\\") \\"231518124\\" >>> alphabet_positions(\\"\\") \\"\\"","solution":"def alphabet_positions(s): Returns a new string where each character in the input string s is replaced with its position in the alphabet. :param s: str - input string containing only lowercase English letters. :return: str - string with positions of each letter in the alphabet. return ''.join(str(ord(char) - ord('a') + 1) for char in s)"},{"question":"def solve(s: str, patterns: List[str]) -> List[bool]: Given a string \`s\` and a list of strings \`patterns\`, return a list of booleans where each boolean indicates whether the corresponding pattern in \`patterns\` appears as a substring in \`s\`. Args: s (str): The primary string to check against. patterns (list): A list of strings to check if they are substrings of \`s\`. Returns: list: A list of booleans where each boolean corresponds to whether the pattern is a substring in \`s\`. >>> solve(\\"hello there general kenobi\\", [\\"hello\\", \\"general\\", \\"kenobi\\", \\"hi\\", \\"there\\"]) [True, True, True, False, True] from typing import List def solve(s: str, patterns: List[str]) -> List[bool]: pass # Unit Test def test_solve_example_case(): s = \\"hello there general kenobi\\" patterns = [\\"hello\\", \\"general\\", \\"kenobi\\", \\"hi\\", \\"there\\"] expected = [True, True, True, False, True] assert solve(s, patterns) == expected def test_solve_with_no_patterns_in_s(): s = \\"abcdefg\\" patterns = [\\"hij\\", \\"klm\\", \\"nop\\"] expected = [False, False, False] assert solve(s, patterns) == expected def test_solve_with_all_patterns_in_s(): s = \\"abcdefghijklmnopqrstuvwxyz\\" patterns = [\\"abc\\", \\"def\\", \\"jkl\\", \\"xyz\\"] expected = [True, True, True, True] assert solve(s, patterns) == expected def test_solve_with_empty_patterns(): s = \\"test string\\" patterns = [] expected = [] assert solve(s, patterns) == expected def test_solve_with_empty_string(): s = \\"\\" patterns = [\\"a\\", \\"b\\", \\"c\\"] expected = [False, False, False] assert solve(s, patterns) == expected def test_solve_with_mixed_patterns(): s = \\"a quick brown fox\\" patterns = [\\"quick\\", \\"slow\\", \\"\\", \\"brown\\", \\"lazy\\"] expected = [True, False, True, True, False] assert solve(s, patterns) == expected","solution":"def solve(s, patterns): Given a string \`s\` and a list of strings \`patterns\`, return a list of booleans where each boolean indicates whether the corresponding pattern in \`patterns\` appears as a substring in \`s\`. Args: s (str): The primary string to check against. patterns (list): A list of strings to check if they are substrings of \`s\`. Returns: list: A list of booleans where each boolean corresponds to whether the pattern is a substring in \`s\`. return [pattern in s for pattern in patterns]"},{"question":"import re from collections import Counter from typing import Dict def word_count(text: str) -> Dict[str, int]: Returns a dictionary containing each unique word in the text as the key and the number of times it appears as the value. >>> word_count(\\"Hello, world! Hello world. HELLO world?\\") {'hello': 3, 'world': 3} >>> word_count(\\"\\") {} >>> word_count(\\"Good-bye! GOOD-bye, good-bye...\\") {'good': 3, 'bye': 3} >>> word_count(\\"There are 2 apples and 3 bananas, and 3 kiwis.\\") {'there': 1, 'are': 1, '2': 1, 'apples': 1, 'and': 2, '3': 2, 'bananas': 1, 'kiwis': 1} >>> word_count(\\"Repetition repetition repetition.\\") {'repetition': 3}","solution":"import re from collections import Counter def word_count(text): Returns a dictionary containing each unique word in the text as the key and the number of times it appears as the value. # Convert text to lowercase text = text.lower() # Remove punctuation using regular expressions and split into words words = re.findall(r'bw+b', text) # Count the occurrences of each word word_counts = Counter(words) return dict(word_counts)"},{"question":"def can_plant_every_day(n: int, m: int, bloomingPeriods: List[int]) -> str: Determines whether it's possible to have at least one flower blooming each day for the next n days. Parameters: n (int): Number of days m (int): Number of different flowering plant types bloomingPeriods (list): Blooming periods for each plant type Returns: str: \\"Possible\\" or \\"Not Possible\\" >>> can_plant_every_day(4, 3, [1, 2, 3]) \\"Possible\\" >>> can_plant_every_day(5, 2, [2, 4]) \\"Not Possible\\" from solution import can_plant_every_day def test_possible_scenario_1(): assert can_plant_every_day(4, 3, [1, 2, 3]) == \\"Possible\\" def test_not_possible_scenario_1(): assert can_plant_every_day(5, 2, [2, 4]) == \\"Not Possible\\" def test_possible_scenario_2(): assert can_plant_every_day(3, 2, [1, 2]) == \\"Possible\\" def test_not_possible_scenario_2(): assert can_plant_every_day(3, 1, [3]) == \\"Not Possible\\" def test_possible_scenario_with_single_type(): assert can_plant_every_day(4, 1, [1]) == \\"Possible\\" def test_edge_case_zero_days(): assert can_plant_every_day(0, 0, []) == \\"Possible\\" def test_edge_case_zero_days_nonzero_plants(): assert can_plant_every_day(0, 5, [1, 2, 3, 4, 5]) == \\"Possible\\" def test_edge_case_zero_plants(): assert can_plant_every_day(5, 0, []) == \\"Not Possible\\"","solution":"def can_plant_every_day(n, m, bloomingPeriods): Determines whether it's possible to have at least one flower blooming each day for the next n days. Parameters: n (int): Number of days m (int): Number of different flowering plant types bloomingPeriods (list): Blooming periods for each plant type Returns: str: \\"Possible\\" or \\"Not Possible\\" # Check if we have a flower blooming on each day up to n days = [0] * n # Array to keep track of whether a flower blooms on each day for period in bloomingPeriods: for start_day in range(period - 1, n, period): days[start_day] = 1 if all(days): return \\"Possible\\" else: return \\"Not Possible\\""},{"question":"def shortest_subsequence(arr: List[int], k: int) -> int: Determine the length of the shortest subsequence that contains exactly one occurrence of each number from 1 to k. Args: arr: A list of integers representing the sequence. k: An integer representing the range of numbers [1, k] to be covered. Returns: An integer representing the length of the shortest subsequence. Example: >>> shortest_subsequence([2, 1, 2, 3, 1], 3) 3","solution":"def shortest_subsequence(arr, k): Returns the length of the shortest subsequence that contains exactly one occurrence of every number from 1 to k. n = len(arr) left = 0 count = {} unique_count = 0 min_length = n + 1 for right in range(n): if arr[right] <= k: # Only consider valid elements if arr[right] not in count: count[arr[right]] = 0 if count[arr[right]] == 0: unique_count += 1 count[arr[right]] += 1 while unique_count == k: min_length = min(min_length, right - left + 1) if arr[left] <= k: count[arr[left]] -= 1 if count[arr[left]] == 0: unique_count -= 1 left += 1 return min_length if min_length <= n else 0 # Return 0 if there's no valid subsequence"},{"question":"from typing import List def max_defense_power(grid: List[List[int]]) -> int: Returns the maximum possible defense power that can be collected by traversing from the top-left corner to the bottom-right corner of the grid, moving only rightwards or downwards. Args: grid (List[List[int]]): 2D grid containing positive integers representing the defense power in each cell. Returns: int: Maximum possible defense power Example: >>> grid = [[1, 3, 1], [2, 5, 1], [4, 2, 1]] >>> max_defense_power(grid) 12 pass if __name__ == \\"__main__\\": # Sample usage grid = [[1, 3, 1], [2, 5, 1], [4, 2, 1]] print(max_defense_power(grid)) # Expected output: 12","solution":"from typing import List def max_defense_power(grid: List[List[int]]) -> int: Returns the maximum possible defense power that can be collected by traversing from the top-left corner to the bottom-right corner of the grid, moving only rightwards or downwards. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initiate the dp table with the value of the first cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1] # Sample usage grid = [[1, 3, 1], [2, 5, 1], [4, 2, 1]] print(max_defense_power(grid)) # Expected output: 12"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if there are two distinct integers in the array that add up to the target sum. :param nums: List of integers :param target: Target sum :return: True if there exists a pair with the target sum, otherwise False >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 10) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([0, 1, 2, 3, 4], 4) True >>> has_pair_with_sum([3, 3, 4, 4], 6) True >>> has_pair_with_sum([100000, -100000, 200000], 100000) True","solution":"def has_pair_with_sum(nums, target): Determines if there are two distinct integers in the array that add up to the target sum. :param nums: List of integers :param target: Target sum :return: True if there exists a pair with the target sum, otherwise False seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def find_repeated_substrings(s: str, k: int) -> list: Identify all the unique substrings of a given length \`k\` that appear more than once in the string \`s\`. Return these substrings in a list. Args: s (str): The input string containing only lowercase letters. k (int): The length of the substrings to find. Returns: list: A list of unique substrings of length \`k\` that appear more than once in the string. Examples: >>> find_repeated_substrings(\\"abcabc\\", 3) [\\"abc\\"] >>> find_repeated_substrings(\\"aaaa\\", 2) [\\"aa\\"] >>> find_repeated_substrings(\\"abcdef\\", 2) []","solution":"def find_repeated_substrings(s, k): Returns a list of unique substrings of length \`k\` that appear more than once in the string \`s\`. Args: s (str): The input string containing only lowercase letters. k (int): The length of the substrings to find. Returns: list: A list of unique substrings of length \`k\` that appear more than once in the string. if k <= 0 or len(s) < k: return [] substring_count = {} for i in range(len(s) - k + 1): substring = s[i:i+k] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 return [substring for substring, count in substring_count.items() if count > 1]"},{"question":"def median_of_matrix(matrix: List[List[int]]) -> int: Returns the median of a 2D matrix where each row is sorted in ascending order. Args: matrix (List[List[int]]): A 2D list of integers where each row is sorted in ascending order. Returns: int: The median of the matrix. Examples: >>> median_of_matrix([ ... [1, 4, 7], ... [2, 5, 8], ... [3, 6, 9] ... ]) 5 >>> median_of_matrix([ ... [1, 3], ... [2, 4] ... ]) 2.5 >>> median_of_matrix([[1]]) 1 >>> median_of_matrix([ ... [10, 20, 30], ... [15, 25, 35], ... [18, 22, 32] ... ]) 22 >>> median_of_matrix([ ... [1, 3, 5], ... [2, 4, 6] ... ]) 3.5 pass","solution":"def median_of_matrix(matrix): Returns the median of a 2D matrix where each row is sorted in ascending order. m = len(matrix) n = len(matrix[0]) # Flatten the matrix into a single list flat_list = [element for row in matrix for element in row] # Sort the flattened list flat_list.sort() # Find the median total_elements = m * n if total_elements % 2 == 1: median = flat_list[total_elements // 2] else: median = (flat_list[total_elements // 2] + flat_list[total_elements // 2 - 1]) / 2 return median"},{"question":"def largest_identical_square_subgrid(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: Finds the size of the largest square subgrid with all identical elements for each test case. Parameters: T (int): The number of test cases. test_cases (List[Dict[str, Any]]): A list of dictionaries. Each dictionary contains: - 'R' (int): The number of rows in the grid. - 'C' (int): The number of columns in the grid. - 'grid' (List[List[int]]): A 2D list representing the grid. Returns: List[int]: A list of integers. Each integer is the size of the largest square subgrid with all identical elements for the corresponding test case. >>> largest_identical_square_subgrid(2, [{'R': 3, 'C': 3, 'grid': [[1, 1, 1], [1, 1, 1], [1, 1, 1]]}, {'R': 4, 'C': 5, 'grid': [[1, 2, 3, 4, 5], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]}]) [3, 3] >>> largest_identical_square_subgrid(1, [{'R': 1, 'C': 1, 'grid': [[1]]}]) [1] >>> largest_identical_square_subgrid(1, [{'R': 3, 'C': 4, 'grid': [[1, 1, 1, 4], [1, 1, 1, 4], [1, 1, 1, 4]]}]) [3] >>> largest_identical_square_subgrid(1, [{'R': 2, 'C': 2, 'grid': [[1, 2], [3, 4]]}]) [1]","solution":"def largest_identical_square_subgrid(T, test_cases): def preprocess_grid(grid): R, C = len(grid), len(grid[0]) dp = [[0] * C for _ in range(R)] max_size = 0 for i in range(R): for j in range(C): if i == 0 or j == 0: dp[i][j] = 1 # Edges can only have size of 1 else: if grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_size = max(max_size, dp[i][j]) return max_size results = [] for tc in test_cases: R, C, grid = tc['R'], tc['C'], tc['grid'] results.append(preprocess_grid(grid)) return results # Example usage: T = 2 test_cases = [ {'R': 3, 'C': 3, 'grid': [[1, 1, 1], [1, 1, 1], [1, 1, 1]]}, {'R': 4, 'C': 5, 'grid': [[1, 2, 3, 4, 5], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]} ] print(largest_identical_square_subgrid(T, test_cases)) # Output: [3, 3]"},{"question":"def verify_transactions(test_cases): Verify if the send list and receive list contain exactly the same transactions for each test case. >>> verify_transactions([(3, [(1, 2), (2, 3), (3, 4)], [(3, 4), (1, 2), (2, 3)]), (4, [(3, 1), (4, 2), (2, 1), (1, 3)], [(1, 3), (3, 1), (2, 1), (1, 4)])]) [\\"YES\\", \\"NO\\"]","solution":"def verify_transactions(test_cases): results = [] for case in test_cases: n, send_list, receive_list = case if sorted(send_list) == sorted(receive_list): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression represented as a string containing non-negative integers and the operators +, -, *, /. Note: Integer division truncates toward zero. >>> evaluate_expression(\\"3+2\\") == 5 >>> evaluate_expression(\\"4-1\\") == 3 >>> evaluate_expression(\\" 3 + 5 / 2 \\") == 5 >>> evaluate_expression(\\"3+5 / 2 * 4 - 1\\") == 10 >>> evaluate_expression(\\"14-3/2\\") == 13 >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\" 12 / 4 * 2 -1 + 6 \\") == 11","solution":"def evaluate_expression(expression): Evaluates a mathematical expression represented as a string containing non-negative integers and the operators +, -, *, /. Note: Integer division truncates toward zero. # Removing spaces from the expression expression = expression.replace(' ', '') # Preparing operator precedence precedence = {'+': 1, '-': 1, '*': 2, '/': 2} # Converting infix expression to postfix expression using Shunting Yard algorithm output = [] operators = [] number = '' for char in expression: if char.isdigit(): number += char else: if number: output.append(int(number)) number = '' while operators and precedence[operators[-1]] >= precedence[char]: output.append(operators.pop()) operators.append(char) if number: output.append(int(number)) while operators: output.append(operators.pop()) # Evaluating the postfix expression stack = [] for token in output: if isinstance(token, int): stack.append(token) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) return stack[0]"},{"question":"def sum_of_digits_in_string(s: str) -> int: Write a function that takes a string containing letters and digits and returns an integer representing the sum of all the digits in the string. Ignore the letters in the string and consider only the digits. >>> sum_of_digits_in_string(\\"abc123xyz\\") 6 >>> sum_of_digits_in_string(\\"a1b2c3\\") 6 >>> sum_of_digits_in_string(\\"ab\\") 0 >>> sum_of_digits_in_string(\\"abc\\") 0 >>> sum_of_digits_in_string(\\"xyz\\") 0 >>> sum_of_digits_in_string(\\"12345\\") 15 >>> sum_of_digits_in_string(\\"0000\\") 0 >>> sum_of_digits_in_string(\\"\\") 0 >>> sum_of_digits_in_string(\\"a1!2@3#\\") 6 >>> sum_of_digits_in_string(\\"!@#%^&*()123\\") 6","solution":"def sum_of_digits_in_string(s): Returns the sum of all digits in the string s. Parameters: s (str): The input string containing letters and digits. Returns: int: The sum of all digits in the string. return sum(int(char) for char in s if char.isdigit())"},{"question":"from typing import List from itertools import permutations def generate_permutations(s: str) -> List[str]: Generates all permutations of the given string s in lexicographical order. >>> generate_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_permutations(\\"a\\") ['a'] >>> generate_permutations(\\"ab\\") ['ab', 'ba']","solution":"from itertools import permutations def generate_permutations(s): Generates all permutations of the given string s in lexicographical order. # Generate all permutations perms = sorted([''.join(p) for p in permutations(s)]) # Return the sorted list of permutations return perms"},{"question":"def find_min_shifts(s: str, t: str) -> int: Finds the minimum number of shifts required to make string s equal to string t by shifting the characters within s. Returns -1 if it's not possible. >>> find_min_shifts(\\"abcdef\\", \\"cdefab\\") 2 >>> find_min_shifts(\\"hello\\", \\"ohell\\") 4 >>> find_min_shifts(\\"shift\\", \\"shift\\") 0 >>> find_min_shifts(\\"abc\\", \\"abc\\") 0 >>> find_min_shifts(\\"abc\\", \\"cab\\") 2 >>> find_min_shifts(\\"abc\\", \\"acb\\") -1 >>> find_min_shifts(\\"abc\\", \\"bca\\") 1 >>> find_min_shifts(\\"a\\", \\"a\\") 0 >>> find_min_shifts(\\"a\\", \\"b\\") -1","solution":"def find_min_shifts(s: str, t: str) -> int: Finds the minimum number of shifts required to make string s equal to string t by shifting the characters within s. Returns -1 if it's not possible. # Initial check if lengths are not equal or they contain different character sets. if len(s) != len(t) or sorted(s) != sorted(t): return -1 # Concatenate s with itself to leverage substring search double_s = s + s # Search for t within the concatenated string index = double_s.find(t) # If t is found, the starting index of t in double_s is the number of shifts required return index if index != -1 else -1"},{"question":"def fibonacci(n): Returns the nth Fibonacci number. Args: n (int): The position in the Fibonacci sequence to retrieve. Returns: int: The nth Fibonacci number, or None if n is negative. Examples: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(10) 55 >>> fibonacci(-5) None pass def test_fibonacci_negative(): assert fibonacci(-1) == None assert fibonacci(-5) == None def test_fibonacci_base_cases(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 def test_fibonacci_small_numbers(): assert fibonacci(2) == 1 assert fibonacci(3) == 2 assert fibonacci(4) == 3 assert fibonacci(5) == 5 assert fibonacci(6) == 8 def test_fibonacci_large_numbers(): assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(30) == 832040 def test_fibonacci_very_large_number(): assert fibonacci(50) == 12586269025 assert fibonacci(100) == 354224848179261915075","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n < 0: return None elif n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def min_balanced_teams(n: int, k: int, skills: List[int]) -> int: Determines the minimum number of balanced teams needed to include all students. A team's skill level is balanced if the difference between the maximum skill level and minimum skill level within the team is less than or equal to k. :param n: Number of students :param k: Maximum allowed skill level difference for a balanced team :param skills: List of skill levels :return: Minimum number of balanced teams >>> min_balanced_teams(5, 3, [1, 5, 3, 8, 9]) 3 >>> min_balanced_teams(6, 4, [7, 3, 9, 1, 6, 2]) 2","solution":"def min_balanced_teams(n, k, skills): Determines the minimum number of balanced teams needed to include all students. :param n: Number of students :param k: Maximum allowed skill level difference for a balanced team :param skills: List of skill levels :return: Minimum number of balanced teams skills.sort() teams = 0 i = 0 while i < n: teams += 1 j = i while j < n and skills[j] - skills[i] <= k: j += 1 i = j return teams"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob without alerting the security system. Args: nums: List[int] - List of house values. Returns: int - Maximum amount of money that can be robbed. >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12","solution":"def rob(nums): Returns the maximum amount of money you can rob without alerting the security system. Args: nums: List[int] - List of house values. Returns: int - Maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def numIslands(grid): Returns the number of islands in the grid. An island is formed by a group of horizontally or vertically adjacent land cells. Example 1: >>> numIslands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 3 Example 2: >>> numIslands([ ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ... ]) 1 pass def test_example1(): grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] assert numIslands(grid) == 3 def test_example2(): grid = [ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ] assert numIslands(grid) == 1 def test_empty_grid(): grid = [] assert numIslands(grid) == 0 def test_single_cell(): assert numIslands([[\\"1\\"]]) == 1 assert numIslands([[\\"0\\"]]) == 0 def test_single_row(): assert numIslands([[\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"]]) == 3 def test_single_column(): assert numIslands([[\\"1\\"],[\\"0\\"],[\\"1\\"],[\\"0\\"],[\\"1\\"]]) == 3","solution":"def numIslands(grid): Returns the number of islands in the grid. if not grid: return 0 def dfs(grid, r, c): grid[r][c] = '0' directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == '1': dfs(grid, nr, nc) num_islands = 0 for r in range(len(grid)): for c in range(len(grid[r])): if grid[r][c] == '1': num_islands += 1 dfs(grid, r, c) return num_islands"},{"question":"import random from typing import Tuple def count_target_occurrences(target: int, num_rolls: int) -> int: Simulates rolling a pair of dice and returns the number of times the target number is rolled. :param target: Target sum of the two dice (integer between 2 and 12, inclusive) :param num_rolls: Number of times to roll the dice (positive integer) :return: Number of times the target number is rolled (integer) >>> count_target_occurrences(7, 1000) # Example output, actual output may vary 166 >>> count_target_occurrences(2, 10) 0 pass import pytest def test_count_target_occurrences_7_1000(): result = count_target_occurrences(7, 1000) assert 100 <= result <= 200 # Based on probability def test_count_target_occurrences_2_10(): result = count_target_occurrences(2, 10) assert 0 <= result <= 1 # Rare occurrence, but possible def test_count_target_occurrences_invalid_target(): with pytest.raises(ValueError): count_target_occurrences(13, 10) with pytest.raises(ValueError): count_target_occurrences(1, 10) def test_count_target_occurrences_invalid_rolls(): with pytest.raises(ValueError): count_target_occurrences(7, -1) with pytest.raises(ValueError): count_target_occurrences(7, 0) def test_count_target_occurrences_edge_cases(): result = count_target_occurrences(2, 100) assert 0 <= result <= 5 # Rare occurrence, but possible in 100 rolls result = count_target_occurrences(12, 100) assert 0 <= result <= 5 # Rare occurrence, but possible in 100 rolls","solution":"import random def count_target_occurrences(target, num_rolls): Simulates rolling a pair of dice and returns the number of times the target number is rolled. :param target: Target sum of the two dice (integer between 2 and 12, inclusive) :param num_rolls: Number of times to roll the dice (positive integer) :return: Number of times the target number is rolled (integer) if not (2 <= target <= 12): raise ValueError(\\"Target number must be between 2 and 12, inclusive\\") if not (num_rolls > 0): raise ValueError(\\"Number of rolls must be a positive integer\\") count = 0 for _ in range(num_rolls): die1 = random.randint(1, 6) die2 = random.randint(1, 6) if die1 + die2 == target: count += 1 return count"},{"question":"def arithmetic_progression(a1: int, d: int, n: int) -> int: Returns the nth term of the arithmetic progression. >>> arithmetic_progression(3, 4, 4) 15 >>> arithmetic_progression(1, 2, 5) 9 >>> arithmetic_progression(10, -2, 4) 4 >>> arithmetic_progression(7, 0, 3) 7 >>> arithmetic_progression(0, 0, 1) 0 >>> arithmetic_progression(1, 1, 1000) 1000 >>> arithmetic_progression(1, 5, 100) 496 pass","solution":"def arithmetic_progression(a1: int, d: int, n: int) -> int: Returns the nth term of the arithmetic progression. return a1 + (n - 1) * d"},{"question":"def binary_search(nums: List[int], target: int) -> int: Performs binary search on a sorted list to find the index of target. Parameters: nums (List[int]): A list of integers sorted in ascending order. target (int): The integer to be searched for in nums. Returns: int: The index of target if it is present in nums, otherwise -1. Example: nums = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 # binary_search(nums, target) should return 4 nums = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] target = 7 # binary_search(nums, target) should return -1 from typing import List def test_binary_search_found(): assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 4 def test_binary_search_not_found(): assert binary_search([2, 4, 6, 8, 10, 12, 14, 16, 18, 20], 7) == -1 def test_binary_search_empty_list(): assert binary_search([], 5) == -1 def test_binary_search_single_element_found(): assert binary_search([5], 5) == 0 def test_binary_search_single_element_not_found(): assert binary_search([1], 5) == -1 def test_binary_search_first_element(): assert binary_search([1, 2, 3, 4, 5], 1) == 0 def test_binary_search_last_element(): assert binary_search([1, 2, 3, 4, 5], 5) == 4 def test_binary_search_large_list(): large_list = list(range(100000)) assert binary_search(large_list, 99999) == 99999 assert binary_search(large_list, -1) == -1 def test_binary_search_negative_numbers(): assert binary_search([-10, -5, 0, 5, 10], -5) == 1 assert binary_search([-10, -5, 0, 5, 10], -1) == -1 assert binary_search([-10, -5, 0, 5, 10], 10) == 4","solution":"from typing import List def binary_search(nums: List[int], target: int) -> int: Performs binary search on a sorted list to find the index of target. Parameters: nums (List[int]): A list of integers sorted in ascending order. target (int): The integer to be searched for in nums. Returns: int: The index of target if it is present in nums, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def consolidate_logs(logs: List[str]) -> str: Processes a list of log entries and consolidates them into a single, summarized log entry. Values of the same key appearing multiple times in a log are concatenated into a comma-separated string, and the keys are ordered lexicographically. :param logs: List of log entries, where each entry is a string containing key-value pairs separated by commas. :return: A single string with consolidated key-value pairs. >>> consolidate_logs([ ... \\"time=12:00,level=info,message=start\\", ... \\"level=warning,message=delay,time=12:05\\", ... \\"time=12:10,level=info,message=resume\\" ... ]) 'level=info,warning,info,message=start,delay,resume,time=12:00,12:05,12:10' >>> consolidate_logs([\\"time=12:00,level=info,message=start\\"]) 'level=info,message=start,time=12:00' >>> consolidate_logs([\\"time=12:00,time=12:05,time=12:10\\"]) 'time=12:00,12:05,12:10' >>> consolidate_logs([]) '' >>> consolidate_logs([\\"a=1,b=2\\", \\"a=3,b=4\\", \\"c=5,a=6\\"]) 'a=1,3,6,b=2,4,c=5' >>> consolidate_logs([\\"a=1,a=1,a=2\\", \\"b=2,b=2\\"]) 'a=1,1,2,b=2,2' >>> consolidate_logs([\\"key1=val1,key2=val2\\", \\"key1=val3,key2=val4,key1=val5\\"]) 'key1=val1,val3,val5,key2=val2,val4' pass","solution":"from typing import List def consolidate_logs(logs: List[str]) -> str: from collections import defaultdict consolidated_log = defaultdict(list) for log in logs: entries = log.split(',') for entry in entries: key, value = entry.split('=') consolidated_log[key].append(value) sorted_keys = sorted(consolidated_log.keys()) result = \\",\\".join(f\\"{key}={','.join(consolidated_log[key])}\\" for key in sorted_keys) return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression string and return the result as an integer. The expression contains non-negative integers and the operators +, -, *, / and follows standard operator precedence. >>> evaluate_expression('3+2*2') 7 >>> evaluate_expression('3/2') 1 >>> evaluate_expression('3+5/2') 5","solution":"def evaluate_expression(expression: str) -> int: def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(int(left / right)) # integer division # Initialize two stacks for handling operators and operands operands = [] operators = [] i = 0 n = len(expression) while i < n: char = expression[i] if char.isdigit(): start = i while i < n and expression[i].isdigit(): i += 1 operands.append(int(expression[start:i])) continue if char in \\"+-*/\\": while (operators and operators[-1] in \\"*/\\" and char in \\"+-\\") or (operators and operators[-1] in \\"*/\\" and char in \\"*/\\"): apply_operator(operands, operators.pop()) operators.append(char) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def is_prime(num): Returns True if num is a prime number, else False. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def sum_at_prime_indices(lst): Given a list of integers, determine whether the sum of the integers at prime indices is even or odd. Returns 'even' if the sum is even, and 'odd' if the sum is odd. >>> sum_at_prime_indices([5, 3, 8, 7, 1, 2]) 'odd' >>> sum_at_prime_indices([]) 'even' >>> sum_at_prime_indices([10]) 'even' >>> sum_at_prime_indices([4, 4]) 'even' >>> sum_at_prime_indices([1, 1, 1, 1, 1, 1]) 'odd' >>> sum_at_prime_indices([2, 2, 2, 2, 2, 2]) 'even' >>> sum_at_prime_indices([100, 200, 300, 400, 500, 600, 700]) 'even' >>> sum_at_prime_indices([1, -3, 7, -7, 10, -2]) 'even'","solution":"def is_prime(num): Returns True if num is a prime number, else False. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def sum_at_prime_indices(lst): Given a list of integers, determine whether the sum of the integers at prime indices is even or odd. Returns 'even' if the sum is even, and 'odd' if the sum is odd. prime_sum = sum(lst[i] for i in range(len(lst)) if is_prime(i)) return 'even' if prime_sum % 2 == 0 else 'odd'"},{"question":"def find_min_difference(weights): Finds two distinct weights from the set such that the absolute difference between them is as small as possible. Params: weights (list of int): List of weights. Returns: tuple: A tuple containing the pair of weights (a, b) where a < b with the minimum difference. Examples: >>> find_min_difference([10, 3, 20, 50, 4]) (3, 4) >>> find_min_difference([1, 5, 3, 19, 18, 25]) (18, 19) >>> find_min_difference([30, 5, 20, 9]) (5, 9) >>> find_min_difference([1, 2]) (1, 2)","solution":"def find_min_difference(weights): Finds two distinct weights from the set such that the absolute difference between them is as small as possible. Params: weights (list of int): List of weights. Returns: tuple: A tuple containing the pair of weights (a, b) where a < b with the minimum difference. # Sort the weights to make it possible to find the minimum difference in O(n) time after sorting. weights.sort() # Initialize the minimum difference to a large value. min_diff = float('inf') best_pair = (None, None) # Iterate over the weights to find the smallest difference. for i in range(len(weights) - 1): diff = weights[i + 1] - weights[i] if diff < min_diff: min_diff = diff best_pair = (weights[i], weights[i + 1]) # In this context, as the list is already sorted, we don't need to handle tie cases explicitly. # The sorted order will ensure the lexicographically smallest pair is chosen. return best_pair"},{"question":"from typing import List, Tuple def top_n_users(data: List[Tuple[int, int]], n: int) -> List[int]: Given a list of interaction tuples and an integer n, return a list of IDs of the top n users who had the longest total interaction time. Args: data: List of tuples where each tuple contains two integers representing the user's ID and the duration of the interaction in seconds. n: Integer representing the number of top users to return. Returns: List of integers representing the user IDs of the top n users with the longest total interaction time, sorted by total interaction time and then by user ID. Examples: >>> top_n_users([(1, 30), (2, 20), (1, 40), (3, 10)], 2) [1, 2] >>> top_n_users([(1, 100), (2, 200), (1, 50), (3, 125)], 1) [2] >>> top_n_users([(1, 10), (2, 10), (3, 10), (4, 10)], 3) [1, 2, 3] >>> top_n_users([(1, 15)], 5) [1]","solution":"from typing import List, Tuple def top_n_users(data: List[Tuple[int, int]], n: int) -> List[int]: from collections import defaultdict user_interactions = defaultdict(int) # Sum up total interaction time for each user for user_id, duration in data: user_interactions[user_id] += duration # Sort the users first by total interaction time (descending), then by user ID (ascending) sorted_users = sorted(user_interactions.items(), key=lambda x: (-x[1], x[0])) # Get the top n users' IDs top_users = [user_id for user_id, _ in sorted_users[:n]] return top_users"},{"question":"from typing import List def longest_consecutive(nums: List[int]) -> int: Given an unsorted array of integers, find the length of the longest sequence of consecutive elements. Args: nums (List[int]): A list of integers. Returns: int: Length of the longest consecutive sequence. Examples: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([]) 0 >>> longest_consecutive([7]) 1 >>> longest_consecutive([1, 3, 5, 7, 9]) 1 >>> longest_consecutive([2, 1, 3, 4, 5]) 5 >>> longest_consecutive([10, 5, 12, 8, 6, 7, 11]) 4","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. Args: nums (List[int]): A list of integers. Returns: int: Length of the longest consecutive sequence. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: # only start counting streak if \`num\` is the start of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def longest_increasing_sequence(nums: List[int]) -> int: Returns the length of the longest consecutive sequence in the list of integers. The sequence must be strictly increasing. >>> longest_increasing_sequence([1, 9, 3, 10, 2, 20, 4]) 4 >>> longest_increasing_sequence([1, 2, 0, 1]) 3 >>> longest_increasing_sequence([42]) 1 >>> longest_increasing_sequence([5, 100, 101, 3, 2, 1]) 3 >>> longest_increasing_sequence([]) 0 >>> longest_increasing_sequence([1, 3, 5, 7]) 1","solution":"def longest_increasing_sequence(nums): Returns the length of the longest consecutive sequence in the list of integers. The sequence must be strictly increasing. if not nums: return 0 nums_set = set(nums) longest_length = 0 for num in nums: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"def analyze_scores(students): Analyze a list of students and their scores to determine the top student in each subject and the average score for each subject. Args: students (list): A list of dictionaries, where each dictionary represents a student with their name and their scores in Math, Science, and English. Returns: dict: A dictionary with the names of the top students in each subject and the average score for each subject. Example: >>> students = [ ... {\\"name\\": \\"Alice\\", \\"Math\\": 85, \\"Science\\": 92, \\"English\\": 88}, ... {\\"name\\": \\"Bob\\", \\"Math\\": 90, \\"Science\\": 85, \\"English\\": 85}, ... {\\"name\\": \\"Charlie\\", \\"Math\\": 82, \\"Science\\": 87, \\"English\\": 91} ... ] >>> analyze_scores(students) { \\"top_students\\": { \\"Math\\": \\"Bob\\", \\"Science\\": \\"Alice\\", \\"English\\": \\"Charlie\\" }, \\"average_scores\\": { \\"Math\\": 85.67, \\"Science\\": 88.00, \\"English\\": 88.00 } }","solution":"def analyze_scores(students): top_students = {} total_scores = {\\"Math\\": 0, \\"Science\\": 0, \\"English\\": 0} subject_counts = {\\"Math\\": 0, \\"Science\\": 0, \\"English\\": 0} for student in students: for subject in [\\"Math\\", \\"Science\\", \\"English\\"]: total_scores[subject] += student[subject] subject_counts[subject] += 1 if subject not in top_students or student[subject] > students[top_students[subject]][subject]: top_students[subject] = students.index(student) average_scores = {subject: round(total_scores[subject] / subject_counts[subject], 2) for subject in total_scores} top_students_names = {subject: students[index][\\"name\\"] for subject, index in top_students.items()} return { \\"top_students\\": top_students_names, \\"average_scores\\": average_scores }"},{"question":"def max_sum_subrectangle(matrix: List[List[int]]) -> int: Given a rectangular matrix of size \`n\` rows and \`m\` columns, where each cell contains an integer value, find the sum of the subrectangle with the maximum possible sum. Args: matrix: A list of lists of integers representing the matrix. Returns: An integer representing the maximum sum of any subrectangle in the given matrix. >>> max_sum_subrectangle([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) == 29 >>> max_sum_subrectangle([[5]]) == 5 >>> max_sum_subrectangle([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -1 >>> max_sum_subrectangle([ ... [1, -2, 3], ... [-4, 5, -6], ... [7, -8, 9] ... ]) == 9 >>> max_sum_subrectangle([ ... [-1, 0, 0], ... [0, -1, 0], ... [0, 0, -1] ... ]) == 0","solution":"def max_sum_subrectangle(matrix): def kadane(arr): max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum # Example usage: n = 4 m = 5 matrix = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] print(max_sum_subrectangle(matrix)) # Output: 29"},{"question":"def first_unique_char(s: str) -> int: Given a string s, return the first non-repeating character in it and return its index. If it doesn't exist, return -1. >>> first_unique_char(\\"leetcode\\") 0 >>> first_unique_char(\\"loveleetcode\\") 2 >>> first_unique_char(\\"aabb\\") -1","solution":"def first_unique_char(s): Returns the index of the first non-repeating character in the string s. If there's no such character, returns -1. from collections import Counter # Build a counter for all characters in the string char_count = Counter(s) # Iterate through the string to find the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"from typing import List, Tuple def max_odd_length_subarray_sum(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of integers \`arr\` of length \`n\`. You need to find the maximum possible sum of an odd-length subarray of \`arr\`. A subarray is a contiguous part of an array. Arguments: T: int - the number of test cases. test_cases: List of tuples - Each tuple contains an integer \`n\` indicating the length of the array followed by a list of \`n\` space-separated integers, the elements of the array \`arr\`. Returns: List of integers - The maximum possible sum of an odd-length subarray for each test case. >>> max_odd_length_subarray_sum(2, [(5, [1, 2, -3, 4, 5]), (3, [-1, -2, -3])]) [9, -1] def test_single_test_case(): T = 1 test_cases = [(5, [1, 2, -3, 4, 5])] assert max_odd_length_subarray_sum(T, test_cases) == [9] def test_multiple_test_case(): T = 2 test_cases = [(5, [1, 2, -3, 4, 5]), (3, [-1, -2, -3])] assert max_odd_length_subarray_sum(T, test_cases) == [9, -1] def test_all_negative_numbers(): T = 1 test_cases = [(4, [-1, -2, -3, -4])] assert max_odd_length_subarray_sum(T, test_cases) == [-1] def test_single_element_array(): T = 2 test_cases = [(1, [5]), (1, [-5])] assert max_odd_length_subarray_sum(T, test_cases) == [5, -5]","solution":"def max_odd_length_subarray_sum(T, test_cases): results = [] for i in range(T): n, arr = test_cases[i] max_sum = float('-inf') for start in range(n): current_sum = 0 for length in range(start, n): current_sum += arr[length] if (length - start + 1) % 2 != 0: max_sum = max(max_sum, current_sum) results.append(max_sum) return results"},{"question":"def old_calculator_divisibility(number): This function takes an integer number and returns a list of strings indicating its divisibility by 2, 3, and 5. >>> old_calculator_divisibility(10) [\\"Even\\", \\"Divisible by 5\\"] >>> old_calculator_divisibility(9) [\\"Odd\\", \\"Divisible by 3\\"] >>> old_calculator_divisibility(7) [\\"Odd\\"] >>> old_calculator_divisibility(15) [\\"Odd\\", \\"Divisible by 3\\", \\"Divisible by 5\\"] >>> old_calculator_divisibility(2) [\\"Even\\"] results = [] if number % 2 == 0: results.append(\\"Even\\") else: results.append(\\"Odd\\") if number % 3 == 0: results.append(\\"Divisible by 3\\") if number % 5 == 0: results.append(\\"Divisible by 5\\") return results def process_test_cases(T, cases): This function takes the number of test cases T and a list of integers cases. It processes each case using old_calculator_divisibility function and returns the results for all test cases. >>> process_test_cases(3, [10, 9, 7]) [\\"Even\\", \\"Divisible by 5\\", \\"\\", \\"Odd\\", \\"Divisible by 3\\", \\"\\", \\"Odd\\", \\"\\"] >>> process_test_cases(2, [5, 6]) [\\"Odd\\", \\"Divisible by 5\\", \\"\\", \\"Even\\", \\"Divisible by 3\\", \\"\\"] >>> process_test_cases(1, [1]) [\\"Odd\\", \\"\\"] results = [] for case in cases: results.extend(old_calculator_divisibility(case) + ['']) # Adding empty string to separate each test case return results","solution":"def old_calculator_divisibility(number): This function takes an integer number and returns a list of strings indicating its divisibility by 2, 3, and 5. results = [] if number % 2 == 0: results.append(\\"Even\\") else: results.append(\\"Odd\\") if number % 3 == 0: results.append(\\"Divisible by 3\\") if number % 5 == 0: results.append(\\"Divisible by 5\\") return results def process_test_cases(T, cases): This function takes the number of test cases T and a list of integers cases. It processes each case using old_calculator_divisibility function and returns the results for all test cases. results = [] for case in cases: results.extend(old_calculator_divisibility(case) + ['']) # Adding empty string to separate each test case return results"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, graph: List[List[Tuple[int, int]]], start: int) -> List[int]: Use Dijkstra's algorithm to find the shortest paths from start to all other nodes. distances = {node: float('infinity') for node in range(1, n+1)} distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def navigation_system(n: int, m: int, edges: List[Tuple[int, int, int]], q: int, queries: List[Tuple[int, int]]) -> List[int]: This function finds the shortest travel time between intersections. For each query, returns the shortest travel time between the intersections A and B. If there is no path between A and B, returns -1. Args: - n (int): Number of intersections (nodes) - m (int): Number of roads (edges) - edges (List[Tuple[int, int, int]]): List of roads, each defined by two intersections and travel time - q (int): Number of queries - queries (List[Tuple[int, int]]): List of queries, each defined by two intersections Returns: - List[int]: List of shortest travel times for each query Examples: >>> navigation_system(5, 6, [(1, 2, 10), (1, 3, 3), (2, 3, 1), (3, 4, 2), (4, 5, 5), (2, 5, 9)], 3, [(1, 5), (2, 4), (1, 4)]) [10, 3, 5] >>> navigation_system(3, 1, [(1, 2, 5)], 2, [(1, 3), (2, 3)]) [-1, -1]","solution":"import heapq def dijkstra(n, graph, start): Use Dijkstra's algorithm to find the shortest paths from start to all other nodes. distances = {node: float('infinity') for node in range(1, n+1)} distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def navigation_system(n, m, edges, q, queries): # Create adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # because the roads are bidirectional # Precompute shortest paths for all nodes all_pairs_shortest_paths = {node: dijkstra(n, graph, node) for node in range(1, n+1)} # Process each query results = [] for a, b in queries: shortest_distance = all_pairs_shortest_paths[a][b] if shortest_distance == float('infinity'): results.append(-1) else: results.append(shortest_distance) return results"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Generates a list of the first 'n' terms of the Fibonacci sequence. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(30) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229]","solution":"def fibonacci_sequence(n): Returns the first n terms of the Fibonacci sequence. if n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for i in range(2, n): next_term = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_term) return fib_sequence"},{"question":"def find_missing_number(sequence): Finds the missing number in an ascending sequence of integers starting from 1. Args: sequence (list): A list of integers where exactly one number is missing. Returns: int: The missing integer. def test_find_missing_number(): assert find_missing_number([1, 2, 4, 5, 6]) == 3 assert find_missing_number([1, 3, 4, 5, 6]) == 2 assert find_missing_number([2, 3, 4, 5, 6]) == 1 assert find_missing_number([1, 2, 3, 4, 6]) == 5 assert find_missing_number([1, 2, 3, 4, 5]) == 6","solution":"def find_missing_number(sequence): Finds the missing number in an ascending sequence of integers starting from 1. Args: sequence (list): A list of integers where exactly one number is missing. Returns: int: The missing integer. n = len(sequence) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum"},{"question":"import numpy as np def transpose_and_flatten(n: int, m: int, array: List[List[int]]) -> List[int]: Transpose a 2D array and then flatten it. :param n: Number of rows :param m: Number of columns :param array: 2D list of integers :return: Flattened 1D list of the transposed array >>> transpose_and_flatten(2, 3, [[1, 2, 3], [4, 5, 6]]) == [1, 4, 2, 5, 3, 6] >>> transpose_and_flatten(3, 2, [[1, 2], [3, 4], [5, 6]]) == [1, 3, 5, 2, 4, 6]","solution":"import numpy as np def transpose_and_flatten(n, m, array): Transpose a 2D array and then flatten it. :param n: Number of rows :param m: Number of columns :param array: 2D list of integers :return: Flattened 1D list of the transposed array arr = np.array(array) transposed = np.transpose(arr) flattened = transposed.flatten() return flattened.tolist()"},{"question":"def find_odd_occurrence(input_list): Returns the integer that occurs an odd number of times in the input_list. >>> find_odd_occurrence([2, 3, 4, 2, 3, 4, 3]) == 3 >>> find_odd_occurrence([1]) == 1 >>> find_odd_occurrence([4, 4, 4, 4, 5]) == 5 >>> find_odd_occurrence([7, 7, 7]) == 7 >>> find_odd_occurrence([5, 5, 6, 6, 6, 7, 7]) == 6","solution":"def find_odd_occurrence(input_list): Returns the integer that occurs an odd number of times in the input_list. for num in input_list: if input_list.count(num) % 2 != 0: return num"},{"question":"def max_sum_subarray_length_k(nums: List[int], k: int) -> int: Returns the maximum sum of a non-empty subarray of length k. Args: nums (List[int]): List of integers. k (int): Length of the subarray. Returns: int: Maximum sum of a subarray of length k. pass def test_example_1(): assert max_sum_subarray_length_k([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) == 39 def test_example_2(): assert max_sum_subarray_length_k([2, 3, 5, 1, 2], 2) == 8 def test_single_element_subarray(): assert max_sum_subarray_length_k([5, -1, 3, 4], 1) == 5 assert max_sum_subarray_length_k([-1, -2, -3, -4], 1) == -1 def test_all_elements_in_subarray(): assert max_sum_subarray_length_k([1, 2, 3, 4], 4) == 10 def test_negative_numbers_subarray(): assert max_sum_subarray_length_k([-1, -2, -3, -4, -5], 2) == -3","solution":"def max_sum_subarray_length_k(nums, k): Returns the maximum sum of a non-empty subarray of length k. Args: nums (List[int]): List of integers. k (int): Length of the subarray. Returns: int: Maximum sum of a subarray of length k. # Initial sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) # Sliding window to calculate the sum of remaining subarrays for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"import re from collections import Counter from typing import List def most_frequent_word(paragraph: str, banned: List[str]) -> str: Given a string paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. The words in paragraph are case-insensitive and the answer should be returned in lowercase. >>> most_frequent_word(\\"Bob hit a ball, the hit BALL flew far after it was hit.\\", [\\"hit\\"]) 'ball' >>> most_frequent_word(\\"Jack and Jill went up the hill to fetch a pail of water. Jack fell down and broke his crown, and Jill came tumbling after.\\", [\\"jack\\", \\"jill\\"]) 'and' from solution import most_frequent_word def test_example_1(): paragraph = \\"Bob hit a ball, the hit BALL flew far after it was hit.\\" banned = [\\"hit\\"] assert most_frequent_word(paragraph, banned) == \\"ball\\" def test_example_2(): paragraph = (\\"Jack and Jill went up the hill to fetch a pail of water. \\" \\"Jack fell down and broke his crown, and Jill came tumbling after.\\") banned = [\\"jack\\", \\"jill\\"] assert most_frequent_word(paragraph, banned) == \\"and\\" def test_single_word_paragraph(): paragraph = \\"Fly.\\" banned = [\\"hit\\"] assert most_frequent_word(paragraph, banned) == \\"fly\\" def test_paragraph_with_no_banned_words(): paragraph = \\"Sunshine is the best medicine.\\" banned = [] assert most_frequent_word(paragraph, banned) == \\"sunshine\\" def test_all_words_banned_except_one(): paragraph = \\"Apple apple orange orange banana.\\" banned = [\\"apple\\", \\"orange\\"] assert most_frequent_word(paragraph, banned) == \\"banana\\" def test_tied_word_repetition(): paragraph = \\"dog cat dog cat dog fish\\" banned = [\\"cat\\"] assert most_frequent_word(paragraph, banned) == \\"dog\\" def test_paragraph_with_multiple_punctuation(): paragraph = \\"Hello, world! The world says hello again; hello.\\" banned = [\\"hello\\"] assert most_frequent_word(paragraph, banned) == \\"world\\"","solution":"import re from collections import Counter def most_frequent_word(paragraph, banned): Returns the most frequent word in the paragraph that is not in the list of banned words. Words are case-insensitive and returned in lowercase. # Replace all punctuations with spaces, and convert to lowercase normalized_str = re.sub(r'[^ws]', ' ', paragraph).lower() # Split the normalized string into words words = normalized_str.split() # Create a set of banned words for quick lookup banned_set = set(banned) # Count the occurrences of each word that is not banned word_counts = Counter(word for word in words if word not in banned_set) # Return the most common word return word_counts.most_common(1)[0][0]"},{"question":"def product_except_extremes(lst: List[int]) -> int: Write a function that takes a list of integers and returns the product of all integers except for the highest and lowest value in the list. If the list has less than 3 integers, the function should return 0. >>> product_except_extremes([1, 2, 3, 4, 5]) == 24 >>> product_except_extremes([7, 10, -1, 3]) == 21 >>> product_except_extremes([5, 5, 5, 5]) == 25 >>> product_except_extremes([2]) == 0 >>> product_except_extremes([1, -1, 0]) == 0","solution":"def product_except_extremes(lst): Returns the product of all integers in lst except for the highest and lowest value in the list. If the list has less than 3 integers, returns 0. if len(lst) < 3: return 0 sorted_lst = sorted(lst) product = 1 for num in sorted_lst[1:-1]: product *= num return product"},{"question":"def is_prime_number(M: int) -> str: Returns \\"Prime Number\\" if M is a prime number, otherwise returns \\"Not a Prime Number\\". >>> is_prime_number(3) \\"Prime Number\\" >>> is_prime_number(4) \\"Not a Prime Number\\" def check_primes(X: int, test_cases: list) -> list: Takes the number of test cases X and a list of integers, and returns a list with \\"Prime Number\\" or \\"Not a Prime Number\\" for each integer respectively. >>> check_primes(3, [3, 4, 13]) [\\"Prime Number\\", \\"Not a Prime Number\\", \\"Prime Number\\"] >>> check_primes(2, [2, 15]) [\\"Prime Number\\", \\"Not a Prime Number\\"]","solution":"def is_prime_number(M): Returns \\"Prime Number\\" if M is a prime number, otherwise returns \\"Not a Prime Number\\". if M <= 1: return \\"Not a Prime Number\\" for i in range(2, int(M**0.5) + 1): if M % i == 0: return \\"Not a Prime Number\\" return \\"Prime Number\\" def check_primes(X, test_cases): Takes the number of test cases X and a list of integers, and returns a list with \\"Prime Number\\" or \\"Not a Prime Number\\" for each integer respectively. results = [] for M in test_cases: results.append(is_prime_number(M)) return results"},{"question":"def max_possible_value_after_one_move(arr: List[int]) -> int: Given an array of integers 'arr', returns the maximum possible value of any element in the array after at most one move. A move consists of choosing a pair of indices i and j (0 ≤ i < j < len(arr)) and incrementing arr[i] by arr[j]. >>> max_possible_value_after_one_move([1, 2, 3, 4]) 7 >>> max_possible_value_after_one_move([5, 1, 1, 3]) 8 # Unit tests def test_example_1(): assert max_possible_value_after_one_move([1, 2, 3, 4]) == 7 def test_example_2(): assert max_possible_value_after_one_move([5, 1, 1, 3]) == 8 def test_negative_numbers(): assert max_possible_value_after_one_move([-1, -2, -3, -4]) == -3 def test_mixed_numbers(): assert max_possible_value_after_one_move([-1, 2, 3, -4]) == 5 def test_all_zeros(): assert max_possible_value_after_one_move([0, 0, 0, 0]) == 0 def test_large_values(): assert max_possible_value_after_one_move([10000, 9999, -1, -10000]) == 19999 def test_two_elements(): assert max_possible_value_after_one_move([1, 2]) == 3 def test_minimum_input_size(): assert max_possible_value_after_one_move([-10000, 10000]) == 0","solution":"def max_possible_value_after_one_move(arr): Returns the maximum possible value of any element in the array after at most one move. n = len(arr) max_value = float('-inf') # Iterate through all possible pairs (i, j) for i in range(n): for j in range(i + 1, n): max_value = max(max_value, arr[i] + arr[j]) return max_value"},{"question":"def can_partition_k_subsets(nums: List[int], k: int) -> str: Determine if the array can be partitioned into k non-overlapping subsets such that each subset has an equal sum. >>> can_partition_k_subsets([2, 1, 4, 5, 6], 3).startswith(\\"Yes\\") True >>> can_partition_k_subsets([1, 2, 3, 5], 2) 'No' >>> can_partition_k_subsets([100], 1) 'Yesn100' >>> can_partition_k_subsets([2, 2, 2, 2], 2).startswith(\\"Yes\\") True >>> can_partition_k_subsets([2, 2, 2, 2], 3) 'No' >>> can_partition_k_subsets([1, -1, 2, -2, 3, -3], 3).startswith(\\"Yes\\") True","solution":"def can_partition_k_subsets(nums, k): Determine if the array can be partitioned into k non-overlapping subsets such that each subset has an equal sum. total_sum = sum(nums) if total_sum % k != 0: return \\"No\\" target = total_sum // k nums.sort(reverse=True) # Sort to optimize the search used = [False] * len(nums) def backtrack(start_index, k, current_sum): if k == 0: return True if current_sum == target: return backtrack(0, k-1, 0) for i in range(start_index, len(nums)): if not used[i] and current_sum + nums[i] <= target: used[i] = True if backtrack(i+1, k, current_sum + nums[i]): return True used[i] = False return False result = backtrack(0, k, 0) if not result: return \\"No\\" subsets = [] current_subset = [] current_sum = 0 k_count = k used = [False] * len(nums) for _ in range(k_count): current_subset = [] for i in range(len(nums)): if not used[i] and current_sum + nums[i] <= target: used[i] = True current_subset.append(nums[i]) current_sum += nums[i] if current_sum == target: break subsets.append(current_subset.copy()) current_sum = 0 output = \\"Yesn\\" for subset in subsets: output += \\" \\".join(map(str, subset)) + \\"n\\" return output.strip()"},{"question":"def single_number(nums: List[int]) -> int: Given a list of integers where every element appears three times except for one, find the element that appears exactly once. Examples: >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def single_number(nums): Given a list of integers where every element appears three times except for one, find the element that appears exactly once. ones, twos = 0, 0 for num in nums: # Update \`twos\` with bits which are going to be raised into \`twos\` twos |= ones & num # XOR the new number with the \`ones\` to store the single appearance ones ^= num # Clear the bits which have appeared three times in both \`ones\` and \`twos\` not_threes = ~(ones & twos) ones &= not_threes twos &= not_threes return ones"},{"question":"def calculate_bonus(scores): Calculates the bonus amount based on the average score. Args: scores (list): A list of integers representing the performance review scores of an employee. Returns: int: The bonus amount in dollars. >>> calculate_bonus([85, 90, 78, 92, 88]) 500 >>> calculate_bonus([60, 72, 68, 75]) 200 >>> calculate_bonus([45, 55, 60]) 0 >>> calculate_bonus([95, 97, 98, 100]) 1000","solution":"def calculate_bonus(scores): Calculates the bonus amount based on the average score. Args: scores (list): A list of integers representing the performance review scores of an employee. Returns: int: The bonus amount in dollars. average_score = sum(scores) / len(scores) if average_score >= 90: return 1000 elif average_score >= 75: return 500 elif average_score >= 60: return 200 else: return 0"},{"question":"def findFirstNPrimes(n: int) -> list: This function returns the first n prime numbers. :param n: int - The number of prime numbers to return :return: list of the first n prime numbers >>> findFirstNPrimes(0) [] >>> findFirstNPrimes(1) [2] >>> findFirstNPrimes(5) [2, 3, 5, 7, 11] >>> findFirstNPrimes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"def findFirstNPrimes(n: int) -> list: This function returns the first n prime numbers. :param n: int - The number of prime numbers to return :return: list of the first n prime numbers if n == 0: return [] primes = [2] num = 3 while len(primes) < n: is_prime = True for prime in primes: if prime * prime > num: break if num % prime == 0: is_prime = False break if is_prime: primes.append(num) num += 2 return primes[:n]"},{"question":"def is_right_angled_triangle(a: int, b: int, c: int) -> bool: Returns True if the triangle with sides a, b, and c is a right-angled triangle, otherwise returns False. >>> is_right_angled_triangle(3, 4, 5) True >>> is_right_angled_triangle(1, 1, 1) False pass def check_triangles(test_cases: List[Tuple[int, int, int]]) -> List[bool]: Takes a list of tuples with three integers each, representing sides of triangles, and returns a list of booleans indicating if each triangle is right-angled. >>> check_triangles([(3, 4, 5), (6, 8, 10), (1, 1, 1)]) [True, True, False] >>> check_triangles([(2, 3, 4), (5, 12, 13)]) [False, True] pass","solution":"def is_right_angled_triangle(a, b, c): Returns True if the triangle with sides a, b, and c is a right-angled triangle, otherwise returns False. sides = sorted([a, b, c]) return sides[0]**2 + sides[1]**2 == sides[2]**2 def check_triangles(test_cases): results = [] for a, b, c in test_cases: results.append(is_right_angled_triangle(a, b, c)) return results"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the string s can be rearranged to form a palindrome. Parameters: s (str): The input string containing only lowercase alphabetical characters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise.","solution":"def can_form_palindrome(s): Determines if the string s can be rearranged to form a palindrome. Parameters: s (str): The input string containing only lowercase alphabetical characters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string count = Counter(s) # A string can be rearranged to form a palindrome if at most one character # has an odd frequency. odd_count = 0 for freq in count.values(): if freq % 2 != 0: odd_count += 1 if odd_count > 1: return False return True"},{"question":"def has_duplicates(lst: list) -> bool: Function to determine if there are any duplicate integers in the list. Parameters: lst (list): A list of integers. Returns: bool: True if any integer appears at least twice in the list, False otherwise.","solution":"def has_duplicates(lst: list) -> bool: Function to determine if there are any duplicate integers in the list. Parameters: lst (list): A list of integers. Returns: bool: True if any integer appears at least twice in the list, False otherwise. seen = set() for num in lst: if num in seen: return True seen.add(num) return False"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Returns true if the target integer is in the matrix, false otherwise. The matrix is sorted such that each row and each column is in ascending order. >>> search_matrix([ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16], ... [10, 13, 14, 17] ... ], 5) True >>> search_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 13) False >>> search_matrix([], 1) False >>> search_matrix([[5]], 5) True >>> search_matrix([[5]], 1) False >>> search_matrix([ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16], ... [10, 13, 14, 17] ... ], 1) True >>> search_matrix([ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16], ... [10, 13, 14, 17] ... ], 17) True >>> search_matrix([ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16], ... [10, 13, 14, 17] ... ], 3) True >>> search_matrix([ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16], ... [10, 13, 14, 17] ... ], 14) True","solution":"def search_matrix(matrix, target): Returns true if the target integer is in the matrix, false otherwise. The matrix is sorted such that each row and each column is in ascending order. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def most_frequent_char(s: str) -> str: Returns the most frequent character in the given string. In case of a tie, returns the character that appears first. >>> most_frequent_char(\\"abracadabra\\") 'a' >>> most_frequent_char(\\"hello world\\") 'l' >>> most_frequent_char(\\"aabbccdd\\") 'a' >>> most_frequent_char(\\"xyz\\") 'x' >>> most_frequent_char(\\"112233\\") '1' >>> most_frequent_char(\\"\\") '' >>> most_frequent_char(\\"aabbbcc\\") 'b' >>> most_frequent_char(\\"abacadabra\\") 'a' >>> most_frequent_char(\\"a\\") 'a' >>> most_frequent_char(\\"bbbbbb\\") 'b' >>> most_frequent_char(\\"AaBbCcA\\") 'A' >>> most_frequent_char(\\"aAaaAA\\") 'a'","solution":"def most_frequent_char(s): Returns the most frequent character in the given string. In case of a tie, returns the character that appears first. from collections import Counter if not s: return '' counter = Counter(s) max_freq = max(counter.values()) for char in s: if counter[char] == max_freq: return char"},{"question":"from typing import List def find_anagrams(word_list: List[str]) -> List[List[str]]: Given a list of words, return a list of lists, where each sublist contains words from the original list that are anagrams of each other. >>> find_anagrams([\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"bat\\"]) [[\\"bat\\", \\"tab\\", \\"bat\\"], [\\"eat\\", \\"tea\\"], [\\"tan\\", \\"nat\\"]] >>> find_anagrams([\\"cat\\", \\"dog\\", \\"bird\\"]) [] >>> find_anagrams([\\"Bat\\", \\"tab\\", \\"Eat\\", \\"Tea\\", \\"TAN\\", \\"nat\\"]) [[\\"bat\\", \\"tab\\"], [\\"eat\\", \\"tea\\"], [\\"tan\\", \\"nat\\"]] >>> find_anagrams([\\"a\\", \\"A\\", \\"b\\", \\"B\\", \\"c\\", \\"C\\"]) [[\\"a\\", \\"a\\"], [\\"b\\", \\"b\\"], [\\"c\\", \\"c\\"]]","solution":"from collections import defaultdict def find_anagrams(word_list): Returns a list of lists, where each sublist contains words from the original list that are anagrams of each other. anagrams = defaultdict(list) word_list_lower = [word.lower() for word in word_list] for word in word_list_lower: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) result = [group for group in anagrams.values() if len(group) > 1] return result"},{"question":"def find_largest_sum_subarray(arr): Returns the largest sum of any continuous subarray within the given array. >>> find_largest_sum_subarray([1, 2, 3, 4, 5]) == 15 >>> find_largest_sum_subarray([-1, -2, -3, -4, -5]) == -1 >>> find_largest_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> find_largest_sum_subarray([5]) == 5 >>> find_largest_sum_subarray([-5]) == -5 >>> find_largest_sum_subarray([0, 0, 0, 0]) == 0 >>> find_largest_sum_subarray([100, -1, -2, 101, -200, 300, -300]) == 300 >>> find_largest_sum_subarray([]) == \\"Array must contain at least one element.\\"","solution":"def find_largest_sum_subarray(arr): Returns the largest sum of any continuous subarray within the given array. if len(arr) == 0: raise ValueError(\\"Array must contain at least one element.\\") max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_lex_order(n: int, s: str, k: int) -> str: Returns the minimum length of the lexicographically ordered string after deleting exactly k characters from the input string s. >>> min_lex_order(7, 'abcdefg', 3) 'abcd' >>> min_lex_order(10, 'becefghijk', 2) 'bcefghijk' >>> min_lex_order(5, 'abcde', 1) 'abcd'","solution":"def min_lex_order(n, s, k): Returns the minimum length of the lexicographically ordered string after deleting exactly k characters from the input string s. result = [] for char in s: while k and result and result[-1] > char: result.pop() k -= 1 result.append(char) return ''.join(result[:n - k])"},{"question":"def max_potency_of_potion(T: int, test_cases: List[Tuple[Tuple[int, int, int], List[int]]]) -> List[int]: Determine the maximum potency BThero can achieve when mixing ingredients. Args: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int, int], List[int]]]): Each test case contains a tuple with integers n, k, m followed by a list of potencies. Returns: List[int]: List of maximum potencies for each test case. Examples: >>> max_potency_of_potion(2, [((5, 3, 10), [1, 2, 3, 16, 25]), ((4, 2, 5), [4, 7, 8, 2])]) [6, 15] pass def test_max_potency_of_potion(): T = 2 test_cases = [ [(5, 3, 10), [1, 2, 3, 16, 25]], [(4, 2, 5), [4, 7, 8, 2]] ] expected = [6, 15] assert max_potency_of_potion(T, test_cases) == expected def test_max_potency_all_same_potency(): T = 1 test_cases = [ [(5, 3, 0), [5, 5, 5, 5, 5]] ] expected = [15] assert max_potency_of_potion(T, test_cases) == expected def test_max_potency_no_valid_combination(): T = 1 test_cases = [ [(4, 2, 3), [1, 5, 9, 13]] ] expected = [0] assert max_potency_of_potion(T, test_cases) == expected def test_max_potency_large_m(): T = 1 test_cases = [ [(4, 2, 1000000), [10, 20, 30, 40]] ] expected = [70] assert max_potency_of_potion(T, test_cases) == expected def test_max_potency_large_numbers(): T = 1 test_cases = [ [(3, 2, 2), [1000000, 999999, 999998]] ] expected = [1999999] assert max_potency_of_potion(T, test_cases) == expected","solution":"def max_potency_of_potion(T, test_cases): results = [] for i in range(T): n, k, m = test_cases[i][0] potencies = sorted(test_cases[i][1]) max_potency = 0 found = False for j in range(n - k + 1): for h in range(j + k, n + 1): selected = potencies[j:h] if len(selected) == k and max(selected) - min(selected) <= m: max_potency = max(max_potency, sum(selected)) found = True if found: break results.append(max_potency) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_super_balanced(tree: TreeNode) -> bool: Determine if the binary tree is a \\"super-balanced\\" binary tree. A binary tree is considered super-balanced if the difference between the depths of any two leaf nodes is at most 1. Examples: >>> node1 = TreeNode(3) >>> node2 = TreeNode(9) >>> node3 = TreeNode(20) >>> node4 = TreeNode(15) >>> node5 = TreeNode(7) >>> node1.left = node2 >>> node1.right = node3 >>> node3.left = node4 >>> node3.right = node5 >>> is_super_balanced(node1) True >>> node1 = TreeNode(1) >>> node2 = TreeNode(2) >>> node3 = TreeNode(2) >>> node4 = TreeNode(3) >>> node5 = TreeNode(3) >>> node6 = TreeNode(4) >>> node7 = TreeNode(4) >>> node1.left = node2 >>> node1.right = node3 >>> node2.left = node4 >>> node2.right = node5 >>> node4.left = node6 >>> node4.right = node7 >>> is_super_balanced(node1) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_super_balanced(tree: TreeNode) -> bool: def check_depths(node, depth, depths): # If the node is None, return True (Base case for non-existing node) if not node: return True # If it's a leaf node, add its depth to the list if not node.left and not node.right: if depth not in depths: depths.append(depth) # Check the depth differences if len(depths) > 2 or (len(depths) == 2 and abs(depths[0] - depths[1]) > 1): return False return True # Continue DFS search return check_depths(node.left, depth + 1, depths) and check_depths(node.right, depth + 1, depths) depths = [] return check_depths(tree, 0, depths)"},{"question":"def max_profit(prices: List[int]) -> int: You are given an array representing different stock prices on different days. Every day you can either buy one share of stock, sell any number of shares of stock that you own, or do nothing. However, you can only hold at most one share of the stock at any time (i.e., alternate buy and sell actions). Write a program that takes in a list of integers representing the stock prices on different days and returns the maximum profit that can be made by making the optimal buy/sell decisions over the entire period. >>> max_profit([1, 2, 3, 0, 2]) 3 >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 from solution import max_profit def test_max_profit_example1(): assert max_profit([1, 2, 3, 0, 2]) == 3 def test_max_profit_example2(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_max_profit_example3(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_empty(): assert max_profit([]) == 0 def test_max_profit_one_day(): assert max_profit([5]) == 0 def test_max_profit_all_same(): assert max_profit([7, 7, 7, 7, 7]) == 0 def test_max_profit_alternating(): assert max_profit([1, 3, 2, 8, 4, 9]) == 8 def test_max_profit_descending_then_ascending(): assert max_profit([9, 2, 4, 1, 5, 3, 6, 1, 7]) == 10","solution":"def max_profit(prices): if not prices: return 0 n = len(prices) hold, sold, reset = float('-inf'), 0, 0 for price in prices: pre_sold = sold sold = hold + price hold = max(hold, reset - price) reset = max(reset, pre_sold) return max(sold, reset)"},{"question":"def find_odd_occurrence(nums: List[int]) -> int: Returns an integer that appears an odd number of times in the list. >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 4]) 4 >>> find_odd_occurrence([5]) 5 >>> find_odd_occurrence([-1, -1, -2, -2, -3]) -3 >>> find_odd_occurrence([10, 20, 20, 10, 40, 40, 30]) 30 pass","solution":"def find_odd_occurrence(nums): Returns the integer that appears an odd number of times in the list. result = 0 for num in nums: result ^= num return result # Sample input for the function input_data = [1, 2, 3, 2, 3, 1, 4] print(find_odd_occurrence(input_data)) # Output should be 4"},{"question":"def pascal_triangle(n): Generates the first n rows of Pascal's Triangle. Args: n (int): The number of rows of Pascal's Triangle to generate. Returns: List[List[int]]: A list of lists, where each sublist represents a row of Pascal's Triangle. Raises: ValueError: If n is negative. pass import pytest def test_pascal_triangle_zero_rows(): assert pascal_triangle(0) == [] def test_pascal_triangle_one_row(): assert pascal_triangle(1) == [[1]] def test_pascal_triangle_two_rows(): assert pascal_triangle(2) == [[1], [1, 1]] def test_pascal_triangle_five_rows(): assert pascal_triangle(5) == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] def test_pascal_triangle_large_input(): result = pascal_triangle(10) assert len(result) == 10 assert result[9] == [1, 9, 36, 84, 126, 126, 84, 36, 9, 1] def test_pascal_triangle_negative_input_raises_value_error(): with pytest.raises(ValueError): pascal_triangle(-1)","solution":"def pascal_triangle(n): Generates the first n rows of Pascal's Triangle. Args: n (int): The number of rows of Pascal's Triangle to generate. Returns: List[List[int]]: A list of lists, where each sublist represents a row of Pascal's Triangle. Raises: ValueError: If n is negative. if n < 0: raise ValueError(\\"Number of rows cannot be negative\\") triangle = [] for i in range(n): row = [1] * (i + 1) for j in range(1, i): row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j] triangle.append(row) return triangle"},{"question":"def can_rearrange_to_palindrome(s: str) -> bool: Check if the characters of the string can be rearranged to form a palindrome. :param s: Input string :return: Boolean indicating if the string's characters can be rearranged to form a palindrome >>> can_rearrange_to_palindrome(\\"racecar\\") == True >>> can_rearrange_to_palindrome(\\"aabb\\") == True >>> can_rearrange_to_palindrome(\\"abc\\") == False >>> can_rearrange_to_palindrome(\\"aabbcc\\") == True >>> can_rearrange_to_palindrome(\\"aaabbb\\") == False","solution":"def can_rearrange_to_palindrome(s): Check if the characters of the string can be rearranged to form a palindrome. :param s: Input string :return: Boolean indicating if the string's characters can be rearranged to form a palindrome from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def largest_combination(arr: List[int]) -> str: Create a function that takes a list of non-negative integers and returns the largest integer that can be formed by concatenating the elements of the list. The function should handle integers of various lengths and should not use any built-in functions like \`sort()\`. >>> largest_combination([50, 2, 1, 9]) \\"95021\\" >>> largest_combination([34, 3, 30, 5, 9]) \\"9534330\\" >>> largest_combination([12, 121]) \\"12121\\"","solution":"from functools import cmp_to_key def largest_combination(arr): def compare(x, y): return 1 if x + y < y + x else -1 arr = map(str, arr) sorted_arr = sorted(arr, key=cmp_to_key(compare)) return ''.join(sorted_arr)"},{"question":"def product_details(info_str: str) -> str: Processes the product details string and returns the total number of products, the maximum price of any product, and the most expensive product's product_id. >>> product_details(\\"123|19.99|5,456|1.99|10,789|34.50|2\\") 'Total Products: 3 Max Price: 34.50 Product ID: 789' >>> product_details(\\"101|49.99|3\\") 'Total Products: 1 Max Price: 49.99 Product ID: 101' >>> product_details(\\"\\") 'Total Products: 0 Max Price: 0.00 Product ID: None' >>> product_details(\\"001|19.99|10,002|19.99|1,003|19.99|2\\") 'Total Products: 3 Max Price: 19.99 Product ID: 001' >>> product_details(\\"111|5.00|5,222|10.00|1,333|7.50|2\\") 'Total Products: 3 Max Price: 10.00 Product ID: 222'","solution":"def product_details(info_str): Processes the product details string and returns the total number of products, the maximum price of any product, and the most expensive product's product_id. if not info_str: return \\"Total Products: 0 Max Price: 0.00 Product ID: None\\" products = info_str.split(',') total_products = len(products) max_price = 0.00 max_price_id = 'None' for product in products: product_id, price, _ = product.split('|') price = float(price) if price > max_price: max_price = price max_price_id = product_id return f\\"Total Products: {total_products} Max Price: {max_price:.2f} Product ID: {max_price_id}\\""},{"question":"def has_unique_characters(s: str) -> bool: Determine if the input string contains all unique characters. :param s: the input string :return: True if all characters are unique, False otherwise >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"hello\\") False >>> has_unique_characters(\\"1234567890\\") True >>> has_unique_characters(\\"abcABC\\") True >>> has_unique_characters(\\"test case\\") False >>> has_unique_characters(\\"a\\") True >>> has_unique_characters(\\"aA\\") True >>> has_unique_characters(\\"\\") True","solution":"def has_unique_characters(s): Determines if the input string contains all unique characters. :param s: the input string :return: True if all characters are unique, False otherwise return len(s) == len(set(s))"},{"question":"def max_non_overlapping_subarrays(nums: List[int], k: int) -> int: Given an array of integers and an integer k, find the maximum number of non-overlapping subarrays with sum equal to k. >>> max_non_overlapping_subarrays([1, 1, 1, 1, 1], 2) 2 >>> max_non_overlapping_subarrays([1, 2, 3, 4], 3) 2 >>> max_non_overlapping_subarrays([-1, 1, 0, 2, -1, -1, 1, 0], 1) 3 >>> max_non_overlapping_subarrays([2], 2) 1 >>> max_non_overlapping_subarrays([1], 2) 0 >>> max_non_overlapping_subarrays([10, -10, 10, -10], 0) 2 >>> max_non_overlapping_subarrays([5, 5, 5], 10) 1 >>> max_non_overlapping_subarrays([1, 2, 3, 4, 5], 100) 0 >>> max_non_overlapping_subarrays([3, 3, 3], 3) 3","solution":"def max_non_overlapping_subarrays(nums, k): Given an array of integers and an integer k, find the maximum number of non-overlapping subarrays with sum equal to k. count, cum_sum, last_end = 0, 0, -1 prefix_sums = {0: -1} for i in range(len(nums)): cum_sum += nums[i] if (cum_sum - k) in prefix_sums and prefix_sums[cum_sum - k] >= last_end: count += 1 last_end = i prefix_sums[cum_sum] = i return count"},{"question":"def max_ticket_price_difference(T, test_cases): For each test case, determine the maximum possible price difference between two days such that the price on the second day is higher than the price on the first day. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N and a list of N integers representing ticket prices. Returns: List[int]: A list of integers representing the maximum price difference for each test case, or -1 if no such pair exists. >>> max_ticket_price_difference(2, [(6, [7, 1, 5, 3, 6, 4]), (4, [5, 4, 3, 2])]) [5, -1] >>> max_ticket_price_difference(1, [(3, [5, 5, 5])]) [-1]","solution":"def max_ticket_price_difference(T, test_cases): results = [] for case in test_cases: N, prices = case min_price_so_far = prices[0] max_diff = -1 for i in range(1, N): if prices[i] > min_price_so_far: max_diff = max(max_diff, prices[i] - min_price_so_far) min_price_so_far = min(min_price_so_far, prices[i]) results.append(max_diff) return results"},{"question":"def decode_sequence(s: str) -> str: Decodes a string where sections of digits followed by letters are transformed into repeated sequences of the corresponding letter. >>> decode_sequence(\\"3A4B2C5D\\") \\"AAABBBBCCDDDDD\\" >>> decode_sequence(\\"1A\\") \\"A\\" >>> decode_sequence(\\"5Z\\") \\"ZZZZZ\\" >>> decode_sequence(\\"2A3C1B4D\\") \\"AACCCBDDDD\\" >>> decode_sequence(\\"\\") \\"\\" >>> decode_sequence(\\"10A2B\\") \\"AAAAAAAAAABB\\" >>> decode_sequence(\\"12X7Y1Z\\") \\"XXXXXXXXXXXXYYYYYYYZ\\"","solution":"def decode_sequence(s: str) -> str: Decodes a string where sections of digits followed by letters are transformed into repeated sequences of the corresponding letter. Parameters: s (str): Encoded input string Returns: str: Decoded output string import re # Find all matches of groups: digits followed by a single uppercase letter matches = re.findall(r'(d+)([A-Z])', s) return ''.join(int(num) * letter for num, letter in matches)"},{"question":"def find_second_largest(numbers: List[int]) -> int: Given a list of integers, find the second largest number in the list. >>> find_second_largest([2, 3, 6, 6, 5]) 5 >>> find_second_largest([1, 2, 2, 3, 3, 4]) 3 >>> find_second_largest([5, 5, 5, 5]) -101 >>> find_second_largest([-10, -5, -4, -4, -2]) -4 >>> find_second_largest([-100, -100, -99, -98]) -99 >>> find_second_largest([3, -1, -4, 2, 1]) 2","solution":"def find_second_largest(numbers): Given a list of integers, find the second largest number in the list. first_largest = second_largest = -101 # initializing to less than the minimum possible value (-100) for num in numbers: if num > first_largest: second_largest = first_largest first_largest = num elif num > second_largest and num != first_largest: second_largest = num return second_largest"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. The integer input is guaranteed to be within the range from 1 to 3999. >>> int_to_roman(3) \\"III\\" >>> int_to_roman(58) \\"LVIII\\" >>> int_to_roman(1994) \\"MCMXCIV\\"","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. Parameters: num (int): The integer to be converted. Guaranteed to be in the range from 1 to 3999. Returns: str: The Roman numeral representation of the input integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' for i in range(len(val)): while num >= val[i]: num -= val[i] roman_num += syb[i] return roman_num"},{"question":"def min_depots_and_moves(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int, int]]]]) -> List[str]: Determine the minimum number of depots required and the minimum number of moves needed so that all drones can dock at these depots and ensure they can return. Args: T (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains the number of drones, the maximum fuel capacity, and the coordinates of the drones. Returns: list: List of strings, each containing two integers which are the minimum number of depots required and the minimum number of moves needed for each test case. >>> min_depots_and_moves(1, [((3, 2), [(0, 0, 0), (1, 1, 1), (1, 0, 2)])]) [\\"1 0\\"] >>> min_depots_and_moves(1, [((1, 1), [(0, 0, 0)])]) [\\"1 0\\"] >>> min_depots_and_moves(1, [((3, 1), [(0, 0, 0), (1, 1, 1), (2, 2, 2)])]) [\\"1 2\\"] >>> min_depots_and_moves(1, [((2, 3), [(0, 0, 0), (1, 1, 1)])]) [\\"1 0\\"] >>> min_depots_and_moves(1, [((200000, 1000000), [(i, i, i) for i in range(200000)])]) [\\"1 0\\"] >>> min_depots_and_moves(2, [((2, 5), [(0, 0, 0), (1, 1, 1)]), ((3, 2), [(0, 0, 0), (1, 1, 1), (1, 0, 2)])]) [\\"1 0\\", \\"1 0\\"]","solution":"def min_depots_and_moves(T, test_cases): results = [] for case in test_cases: N, F = case[0] coordinates = case[1] centroid_x = sum(pos[0] for pos in coordinates) / N centroid_y = sum(pos[1] for pos in coordinates) / N centroid_z = sum(pos[2] for pos in coordinates) / N centroid_x = round(centroid_x) centroid_y = round(centroid_y) centroid_z = round(centroid_z) depot_positions = set() for (x, y, z) in coordinates: if abs(x - centroid_x) + abs(y - centroid_y) + abs(z - centroid_z) <= F: depot_positions.add((centroid_x, centroid_y, centroid_z)) if len(depot_positions) == 0: depot_positions.add((coordinates[0])) moves = 0 for (x, y, z) in coordinates: if (x, y, z) not in depot_positions: valid_depot_found = False for (dep_x, dep_y, dep_z) in depot_positions: if abs(x - dep_x) + abs(y - dep_y) + abs(z - dep_z) <= F: valid_depot_found = True break if not valid_depot_found: moves += 1 results.append(f\\"{len(depot_positions)} {moves}\\") return results"},{"question":"def largest_connected_land_area(grid): Finds the size of the largest connected land area in the grid. >>> largest_connected_land_area([ ... ['1', '1', '0', '0'], ... ['1', '1', '0', '0'], ... ['0', '0', '1', '0'], ... ['0', '0', '1', '1'] ... ]) == 4 >>> largest_connected_land_area([ ... ['1', '0', '0', '0'], ... ['1', '0', '0', '0'], ... ['0', '0', '1', '1'], ... ['0', '0', '1', '1'] ... ]) == 4 >>> largest_connected_land_area([ ... ['0', '0', '1', '0', '1', '0'], ... ['0', '1', '1', '0', '1', '0'], ... ['0', '1', '1', '0', '0', '0'], ... ['1', '0', '0', '1', '1', '1'], ... ['1', '1', '0', '1', '0', '0'], ... ]) == 5 >>> largest_connected_land_area([ ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ]) == 0 >>> largest_connected_land_area([ ... ['1', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '1'] ... ]) == 9 >>> largest_connected_land_area([ ... ['0', '0', '0'], ... ['0', '1', '0'], ... ['0', '0', '0'] ... ]) == 1 >>> largest_connected_land_area([ ... ['1', '1', '1', '1'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ]) == 4 >>> largest_connected_land_area([ ... ['1', '0', '0'], ... ['1', '0', '0'], ... ['1', '0', '0'], ... ['1', '0', '0'] ... ]) == 4","solution":"def largest_connected_land_area(grid): Finds the size of the largest connected land area in the grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) def dfs(i, j): if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == '0': return 0 grid[i][j] = '0' # Mark the cell as visited size = 1 # Current cell size += dfs(i-1, j) size += dfs(i+1, j) size += dfs(i, j-1) size += dfs(i, j+1) return size largest_area = 0 for i in range(rows): for j in range(cols): if grid[i][j] == '1': largest_area = max(largest_area, dfs(i, j)) return largest_area"},{"question":"def min_trips(T: int, test_cases: List[List[int]]) -> List[int]: Calculate the minimum number of trips required to move all items. >>> min_trips(2, [ [3, 10, 4, 8, 5], [5, 15, 7, 10, 5, 5, 5] ]) [2, 3] >>> min_trips(1, [ [1, 5, 3] ]) [1] >>> min_trips(1, [ [0, 10] ]) [0] >>> min_trips(1, [ [5, 20, 1, 1, 1, 1, 1] ]) [3] >>> min_trips(1, [ [6, 20, 10, 5, 5, 5, 5, 4, 4] ]) [3] >>> min_trips(1, [ [6, 15, 5, 5, 5, 5, 5, 5] ]) [3] >>> min_trips(1, [ [5, 1000000000, 500000000, 500000000, 500000000, 500000000, 500000000] ]) [3]","solution":"def min_trips(T, test_cases): results = [] for i in range(T): N, W = test_cases[i][:2] weights = sorted(test_cases[i][2:], reverse=True) trips = 0 left, right = 0, N - 1 while left <= right: if weights[left] + weights[right] <= W: right -= 1 left += 1 trips += 1 results.append(trips) return results"},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Returns the minimum path sum from the top-left to the bottom-right corner of the grid. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> minPathSum(grid) 7 >>> grid = [ ... [100, 100], ... [100, 1] ... ] >>> minPathSum(grid) 201 def test_example_case(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert minPathSum(grid) == 7 def test_single_cell_grid(): grid = [ [42] ] assert minPathSum(grid) == 42 def test_two_by_two_grid(): grid = [ [1, 2], [1, 1] ] assert minPathSum(grid) == 3 def test_rectangular_grid(): grid = [ [1, 2, 3], [4, 5, 6] ] assert minPathSum(grid) == 12 def test_large_numbers(): grid = [ [100, 100], [100, 1] ] assert minPathSum(grid) == 201","solution":"def minPathSum(grid): Returns the minimum path sum from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Initialize a 2D dp array with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Set the starting point dp[0][0] = grid[0][0] # Fill the first column (only downward movement possible) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the first row (only rightward movement possible) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Iterate through the grid starting from (1, 1) and fill dp array # Each cell dp[i][j] is filled with minimum of top or left cell plus the grid's current cell value for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The minimum path sum to reach the bottom-right corner will be in dp[n-1][m-1] return dp[n-1][m-1]"},{"question":"from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Find the length of the shortest path from a start point to an end point in a grid, avoiding obstacles. >>> shortest_path([[0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]], (0, 0), (4, 3)) 7 >>> shortest_path([[0, 0, 1], [1, 0, 1], [0, 0, 0]], (0, 0), (2, 2)) 4 >>> shortest_path([[0, 1], [1, 0]], (0, 0), (1, 1)) -1 >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (0, 0), (2, 2)) 4 >>> shortest_path([[0, 1, 0], [1, 0, 1], [0, 0, 0]], (1, 1), (1, 1)) 0","solution":"from collections import deque def shortest_path(grid, start, end): rows, cols = len(grid), len(grid[0]) queue = deque([(start[0], start[1], 0)]) # (row, col, distance) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist if (r, c) in visited: continue visited.add((r, c)) for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and grid[rr][cc] == 0 and (rr, cc) not in visited: queue.append((rr, cc, dist + 1)) return -1"},{"question":"def count_books(N: int, titles: List[str]) -> dict: Count the number of each unique book title. Parameters: N (int): Total number of books titles (List[str]): Space-separated book titles. Returns: dict: Dictionary with book titles as keys and their respective counts as values. >>> count_books(7, [\\"HarryPotter\\", \\"HarryPotter\\", \\"LOTR\\", \\"LOTR\\", \\"LOTR\\", \\"Hobbit\\", \\"Hobbit\\"]) {'HarryPotter': 2, 'LOTR': 3, 'Hobbit': 2} >>> count_books(1, [\\"HarryPotter\\"]) {'HarryPotter': 1} >>> count_books(3, [\\"HarryPotter\\", \\"LOTR\\", \\"Hobbit\\"]) {'HarryPotter': 1, 'LOTR': 1, 'Hobbit': 1}","solution":"def count_books(N, titles): Count the number of each unique book title. Parameters: N (int): Total number of books titles (List[str]): Space-separated book titles. Returns: dict: Dictionary with book titles as keys and their respective counts as values. book_counts = {} for title in titles: if title in book_counts: book_counts[title] += 1 else: book_counts[title] = 1 return book_counts"},{"question":"def longest_zigzag_subsequence(arr: List[int]) -> int: Determine the length of the longest subsequence that is a zigzag sequence. >>> longest_zigzag_subsequence([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_subsequence([1, 4, 7, 2, 5]) 4 >>> longest_zigzag_subsequence([1, 2, 3, 4, 5, 6, 7, 8]) 2","solution":"def longest_zigzag_subsequence(arr): if not arr: return 0 if len(arr) == 1: return 1 up = [1] * len(arr) down = [1] * len(arr) for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j]: up[i] = max(up[i], down[j] + 1) elif arr[i] < arr[j]: down[i] = max(down[i], up[j] + 1) return max(up[-1], down[-1], max(up), max(down))"},{"question":"def pascal_value(row: int, col: int) -> int: Given the row and column number, return the value at that position in Pascal's triangle. >>> pascal_value(4, 2) 6 >>> pascal_value(5, 3) 10 >>> pascal_value(6, 0) 1 >>> pascal_value(6, 6) 1","solution":"def pascal_value(row: int, col: int) -> int: Given the row and column number, return the value at that position in Pascal's triangle. if col == 0 or col == row: return 1 else: return pascal_value(row - 1, col - 1) + pascal_value(row - 1, col)"},{"question":"def formatPhoneNumber(phone_number: str) -> str: Formats a phone number to the standardized form (XXX) XXX-XXXX. If the input string includes invalid characters or has an incorrect number of digits, the function should return \\"Invalid number\\". Parameters: - phone_number (str): A string representing a phone number. Returns: - str: The formatted phone number or \\"Invalid number\\" if the input is invalid. >>> formatPhoneNumber(\\"+1-234-567-8901\\") \\"(234) 567-8901\\" >>> formatPhoneNumber(\\"1234 567 890\\") \\"Invalid number\\" >>> formatPhoneNumber(\\"(345)6789012\\") \\"(345) 678-9012\\" >>> formatPhoneNumber(\\"456-789-0123\\") \\"(456) 789-0123\\"","solution":"def formatPhoneNumber(phone_number: str) -> str: Formats a phone number to the standardized form (XXX) XXX-XXXX. Parameters: phone_number (str): A string representing the phone number. Returns: str: The formatted phone number or \\"Invalid number\\" if the input is invalid. # Remove all non-numeric characters digits = ''.join(filter(str.isdigit, phone_number)) # Remove country code if present if len(digits) == 11 and digits.startswith(\\"1\\"): digits = digits[1:] # Check if the resulting number has exactly 10 digits if len(digits) != 10: return \\"Invalid number\\" # Format the number as (XXX) XXX-XXXX formatted_phone_number = f\\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\\" return formatted_phone_number"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string, find the length of the longest substring without repeating characters. :param s: A single string :return: An integer representing the length of the longest substring without repeating characters >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"aabcabcbb\\") == 3 >>> length_of_longest_substring(\\"dvdf\\") == 3","solution":"def length_of_longest_substring(s): Finds the length of the longest substring without repeating characters. :param s: A single string :return: An integer representing the length of the longest substring without repeating characters char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"def calculate(expression: str) -> int: Evaluates a mathematical expression string and returns the result as an integer. The string can contain integer numbers, the four basic arithmetic operations (+, -, *, /), and might include spaces. The integer division should truncate toward zero. >>> calculate(\\"3+5 / 2\\") 5 >>> calculate(\\"2-3*4+6 / 3\\") -8 def test_calculate_simple_addition(): assert calculate(\\"3+5\\") == 8 def test_calculate_simple_subtraction(): assert calculate(\\"10-4\\") == 6 def test_calculate_simple_multiplication(): assert calculate(\\"7*6\\") == 42 def test_calculate_simple_division(): assert calculate(\\"8/2\\") == 4 def test_calculate_addition_and_division(): assert calculate(\\"3+5/2\\") == 5 # 3 + (5 / 2) = 3 + 2 = 5 def test_calculate_combined_operations(): assert calculate(\\"2-3*4+6/3\\") == -8 # 2 - (3 * 4) + (6 / 3) = 2 - 12 + 2 = -8 def test_calculate_with_spaces(): assert calculate(\\" 3 + 5 / 2 \\") == 5 # Should handle spaces def test_calculate_division_with_truncation(): assert calculate(\\"14/4\\") == 3 # 14 / 4 = 3.5 which should truncate to 3 def test_calculate_order_of_operations(): assert calculate(\\"2+3*2\\") == 8 # 2 + (3 * 2) = 2 + 6 = 8 assert calculate(\\"8*2-3\\") == 13 # (8 * 2) - 3 = 16 - 3 = 13 def test_invalid_expression(): assert calculate(\\"abc\\") == None # Should return None for invalid input","solution":"def calculate(expression): Evaluates a mathematical expression string and returns the result as an integer. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # Ensure truncation toward zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def parse_expression(expression): operators, values = [], [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] in '0123456789': j = i while j < len(expression) and expression[j] in '0123456789': j += 1 values.append(int(expression[i:j])) i = j elif expression[i] in '+-*/': while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 else: return None # Invalid character while operators: apply_operator(operators, values) return values[0] return parse_expression(expression)"},{"question":"def maximize_absolute_difference(N: int, energies: List[int]) -> List[int]: Reorganize the order of the creatures' magical energies such that the absolute difference in magical energy between any two adjacent creatures is maximized. Parameters: N (int): The number of magical creatures. energies (List[int]): A list of integers representing the magical energy of each creature. Returns: List[int]: A new order of energies such that the absolute difference in magical energy between any two adjacent creatures is maximized. Example: >>> maximize_absolute_difference(5, [4, 8, 1, 6, 3]) [1, 8, 3, 6, 4] >>> maximize_absolute_difference(2, [1, 10]) [1, 10]","solution":"def maximize_absolute_difference(N, energies): Returns a new order of energies such that the absolute difference in magical energy between any two adjacent creatures is maximized. # Sort energies in ascending order energies.sort() # Use two pointers to select elements from the sorted list result = [] i, j = 0, N - 1 turn = True # Boolean to alternate picking between the smallest and largest remaining elements while i <= j: if turn: result.append(energies[i]) i += 1 else: result.append(energies[j]) j -= 1 turn = not turn return result"},{"question":"def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of \`n\` integers, find the maximum sum of a contiguous subarray with at most one element removed. Each test case consists of two lines. The first line contains an integer \`n\`, the length of the array. The second line contains \`n\` space-separated integers representing the elements of the array. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases, each including the number of elements (n) and the list of integers. Returns: List[int]: List of results, one for each test case, representing the maximum sum of a contiguous subarray with at most one element removed. Example: >>> solve(2, [(5, [1, -2, 0, 3, -1]), (3, [-2, -1, -2])]) [4, -1] >>> solve(1, [(1, [5])]) [5]","solution":"def max_sum_subarray_with_one_removal(arr): n = len(arr) if n == 1: return arr[0] # Arrays to store the maximum subarray sum ending at and starting from each index max_ending_here = [0] * n max_starting_here = [0] * n max_ending_here[0] = arr[0] for i in range(1, n): max_ending_here[i] = max(arr[i], max_ending_here[i - 1] + arr[i]) max_starting_here[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): max_starting_here[i] = max(arr[i], max_starting_here[i + 1] + arr[i]) # Initialize the result with the maximum subarray sum without any removal result = max(max_ending_here) # Try removing one element and check if the resulting subarray sum is higher for i in range(1, n - 1): result = max(result, max_ending_here[i - 1] + max_starting_here[i + 1]) return result def solve(T, test_cases): results = [] for case in test_cases: n = case[0] arr = case[1] results.append(max_sum_subarray_with_one_removal(arr)) return results"},{"question":"def contains_duplicates(nums: List[int]) -> bool: Given a list of integers, find if the array contains any duplicates. Your function should return True if any value appears at least twice in the array, and it should return False if every element is distinct. >>> contains_duplicates([1, 2, 3, 1]) True >>> contains_duplicates([1, 2, 3, 4]) False >>> contains_duplicates([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) True","solution":"def contains_duplicates(nums): Returns True if any value appears at least twice in the array, otherwise returns False. return len(nums) != len(set(nums))"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determine if the string \`s\` can be rearranged to form a palindrome. >>> can_form_palindrome('aabb') 'YES' >>> can_form_palindrome('abc') 'NO' >>> can_form_palindrome('racecar') 'YES' def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases to check if they can form palindromes. >>> process_test_cases(['aabb', 'abc', 'racecar', 'a', 'aa', 'aab', 'aabbc']) ['YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES'] >>> process_test_cases(['ab', 'abcabc']) ['NO', 'YES']","solution":"def can_form_palindrome(s): Determine if the string \`s\` can be rearranged to form a palindrome. Parameters: s (str): The input string Returns: str: 'YES' if the string can be rearranged to form a palindrome, 'NO' otherwise from collections import Counter # Count the frequency of each character char_count = Counter(s) # Check how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to a palindrome if it has at most one character with odd frequency return 'YES' if odd_count <= 1 else 'NO' def process_test_cases(test_cases): Processes multiple test cases to check if they can form palindromes. Parameters: test_cases (list of str): A list of test strings Returns: list of str: List of results for each test case, \\"YES\\" or \\"NO\\" return [can_form_palindrome(s) for s in test_cases]"},{"question":"def is_valid_braces(string: str) -> bool: Validates if a string of braces is valid. >>> is_valid_braces(\\"()\\") == True >>> is_valid_braces(\\"([{}])\\") == True >>> is_valid_braces(\\"(}\\") == False >>> is_valid_braces(\\"[(])\\") == False >>> is_valid_braces(\\"[({})](]\\") == False","solution":"def is_valid_braces(string): Validates if a string of braces is valid. Parameters: string (str): The input string containing braces Returns: bool: True if the string is valid, False otherwise stack = [] brace_map = {')': '(', '}': '{', ']': '['} for char in string: if char in brace_map: top_element = stack.pop() if stack else '#' if brace_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def calculate_shares(harvest: List[int], hours: List[int]) -> List[List[float]]: Calculate the share of each farmer for each crop. The harvest is divided based on the number of hours each farmer worked. >>> calculate_shares([100, 200, 300], [10, 20, 30]) [[16.67, 33.33, 50.0], [33.33, 66.67, 100.0], [50.0, 100.0, 150.0]] >>> calculate_shares([90, 180, 270], [10, 10, 10]) [[30.0, 60.0, 90.0], [30.0, 60.0, 90.0], [30.0, 60.0, 90.0]] >>> calculate_shares([100, 200, 300], [40]) [[100.0, 200.0, 300.0]] >>> calculate_shares([50, 75], [25]) [[50.0, 75.0]] from typing import List def test_calculate_shares_simple_case(): harvest = [100, 200, 300] hours = [10, 20, 30] expected = [ [16.67, 33.33, 50.0], [33.33, 66.67, 100.0], [50.0, 100.0, 150.0] ] assert calculate_shares(harvest, hours) == expected def test_calculate_shares_equal_hours(): harvest = [90, 180, 270] hours = [10, 10, 10] expected = [ [30.0, 60.0, 90.0], [30.0, 60.0, 90.0], [30.0, 60.0, 90.0] ] assert calculate_shares(harvest, hours) == expected def test_calculate_shares_single_farmer(): harvest = [100, 200, 300] hours = [40] expected = [ [100.0, 200.0, 300.0] ] assert calculate_shares(harvest, hours) == expected def test_calculate_shares_multiple_crops_one_farmer(): harvest = [50, 75] hours = [25] expected = [ [50.0, 75.0] ] assert calculate_shares(harvest, hours) == expected def test_calculate_shares_large_inputs(): harvest = [1000 * i for i in range(1, 11)] hours = [2 * i for i in range(1, 6)] expected = [ [round((2 / 30) * 1000 * i, 2) for i in range(1, 11)], [round((4 / 30) * 1000 * i, 2) for i in range(1, 11)], [round((6 / 30) * 1000 * i, 2) for i in range(1, 11)], [round((8 / 30) * 1000 * i, 2) for i in range(1, 11)], [round((10 / 30) * 1000 * i, 2) for i in range(1, 11)] ] assert calculate_shares(harvest, hours) == expected","solution":"from typing import List def calculate_shares(harvest: List[int], hours: List[int]) -> List[List[float]]: total_hours = sum(hours) shares = [] for farmer_hours in hours: farmer_share = [(farmer_hours / total_hours) * crop for crop in harvest] shares.append(farmer_share) # Adjusting to keep decimal precision similar to the example given, rounded to 2 decimal places shares = [[round(crop, 2) for crop in farmer_share] for farmer_share in shares] return shares"},{"question":"def match_case_insensitive(s1: str, s2: str) -> int: Checks whether the string \`s1\` can be found in \`s2\` irrespective of the case. Returns the starting index of the first occurrence if found, otherwise -1. >>> match_case_insensitive('abc', 'xyzABCdef') == 3 >>> match_case_insensitive('test', 'ThisIsATest') == 7 >>> match_case_insensitive('hello', 'worldHELLO') == 5 >>> match_case_insensitive('not', 'presentNOHere') == -1","solution":"def match_case_insensitive(s1, s2): Checks whether s1 can be found in s2 irrespective of the case. Returns the starting index of the first occurrence if found, otherwise -1. s1_lower = s1.lower() s2_lower = s2.lower() index = s2_lower.find(s1_lower) return index"},{"question":"def categorize_books(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[List[int], List[int]]]: Categorizes the present and missing books based on the IDs provided. -----Input----- The first line contains a single integer T (1 ≤ T ≤ 50) indicating the number of test cases. Each test case consists of two lines. The first line contains two integers n and m (0 ≤ m ≤ n ≤ 1000), where n is the total number of books and m is the number of present books. The second line contains a list of m distinct integers between 1 and n, representing the IDs of the present books. Consecutive integers are separated by a single space. -----Output----- For each test case, output two lines. The first line contains the IDs of the missing books in ascending order, and the second line contains the IDs of the present books in descending order. Each ID should be separated by a single space. If no books are missing or present, print a blank line for that list. -----Example----- >>> categorize_books(3, [(5, 3, [2, 3, 5]), (8, 4, [1, 2, 6, 7]), (4, 0, [])]) [([1, 4], [5, 3, 2]), ([3, 4, 5, 8], [7, 6, 2, 1]), ([1, 2, 3, 4], [])] def test_categorize_books(): cases = [ (3, [ (5, 3, [2, 3, 5]), (8, 4, [1, 2, 6, 7]), (4, 0, []) ]) ] expected_output = [ ([1, 4], [5, 3, 2]), ([3, 4, 5, 8], [7, 6, 2, 1]), ([1, 2, 3, 4], []) ] results = categorize_books(cases[0][0], cases[0][1]) for expected, result in zip(expected_output, results): assert expected == result def test_categorize_books_all_present(): cases = [ (1, [ (5, 5, [1, 2, 3, 4, 5]) ]) ] expected_output = [ ([], [5, 4, 3, 2, 1]) ] results = categorize_books(cases[0][0], cases[0][1]) for expected, result in zip(expected_output, results): assert expected == result def test_categorize_books_all_missing(): cases = [ (1, [ (5, 0, []) ]) ] expected_output = [ ([1, 2, 3, 4, 5], []) ] results = categorize_books(cases[0][0], cases[0][1]) for expected, result in zip(expected_output, results): assert expected == result def test_categorize_books_no_books(): cases = [ (1, [ (0, 0, []) ]) ] expected_output = [ ([], []) ] results = categorize_books(cases[0][0], cases[0][1]) for expected, result in zip(expected_output, results): assert expected == result","solution":"def categorize_books(T, test_cases): results = [] for case in test_cases: n, m, present_books = case present_books_set = set(present_books) all_books = set(range(1, n + 1)) missing_books = sorted(all_books - present_books_set) present_books_sorted = sorted(present_books, reverse=True) results.append((missing_books, present_books_sorted)) return results"},{"question":"def three_sum_zero(nums: List[int]) -> bool: Determines if there are three distinct elements in the list that sum up to zero. Examples: >>> three_sum_zero([-1, 0, 1, 2, -1, -4]) True >>> three_sum_zero([1, 2, -2, -1]) False pass # Unit tests def test_three_sum_zero_example_1(): assert three_sum_zero([-1, 0, 1, 2, -1, -4]) == True def test_three_sum_zero_example_2(): assert three_sum_zero([1, 2, -2, -1]) == False def test_three_sum_zero_single_element(): assert three_sum_zero([0]) == False def test_three_sum_zero_no_elements(): assert three_sum_zero([]) == False def test_three_sum_zero_two_elements(): assert three_sum_zero([-1, 1]) == False def test_three_sum_zero_mixture(): assert three_sum_zero([3, -1, -7, 0, 0, 2, 1]) == True assert three_sum_zero([0, -1, 2, -3, 1]) == True assert three_sum_zero([1, 1, -2, 4, -1, 0, 2]) == True assert three_sum_zero([1, 2, 3, 4, 5]) == False","solution":"def three_sum_zero(nums): Determines if there are three distinct elements in the list that sum up to zero. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: triplet_sum = nums[i] + nums[left] + nums[right] if triplet_sum == 0: return True elif triplet_sum < 0: left += 1 else: right -= 1 return False"},{"question":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds and returns a list of unique pairs from the input list \`nums\` that add up to the \`target\` sum. Each pair (a, b) is considered the same as (b, a) and should only be counted once, and the pairs are returned in ascending order. >>> find_pairs([2, 4, 3, 5, 7, 8, 9], 7) [(2, 5), (3, 4)] >>> find_pairs([1, 2, 3, 4, 5, 6], 10) [(4, 6)] >>> find_pairs([1, 1, 1, 1, 1], 2) [(1, 1)]","solution":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds and returns a list of unique pairs from input list \`nums\` that add up to \`target\`. seen = set() # To keep track of numbers we've seen so far pairs = set() # To collect unique pairs for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(pairs)"},{"question":"from typing import List def sort_by_length_and_lexicographical(words: List[str]) -> List[str]: Sorts a list of strings by their lengths in increasing order. If two strings have the same length, they are sorted lexicographically. >>> sort_by_length_and_lexicographical([\\"apple\\", \\"pie\\", \\"banana\\", \\"car\\", \\"apricot\\"]) ['car', 'pie', 'apple', 'banana', 'apricot'] >>> sort_by_length_and_lexicographical([\\"only\\"]) ['only'] >>> sort_by_length_and_lexicographical([\\"bake\\", \\"cake\\", \\"lake\\", \\"cake\\"]) ['bake', 'cake', 'cake', 'lake'] >>> sort_by_length_and_lexicographical([\\"a\\", \\"abc\\", \\"abcd\\", \\"ab\\", \\"c\\", \\"bc\\"]) ['a', 'c', 'ab', 'bc', 'abc', 'abcd'] >>> sort_by_length_and_lexicographical([\\"aaaa\\", \\"aaab\\", \\"aaa\\", \\"aabab\\", \\"aa\\"]) ['aa', 'aaa', 'aaaa', 'aaab', 'aabab'] >>> sort_by_length_and_lexicographical([\\"abcde\\", \\"abcd\\", \\"abc\\", \\"ab\\", \\"a\\"]) ['a', 'ab', 'abc', 'abcd', 'abcde'] >>> sort_by_length_and_lexicographical([\\"10\\", \\"2\\", \\"1\\", \\"21\\", \\"12\\"]) ['1', '2', '10', '12', '21'] # Your code here","solution":"def sort_by_length_and_lexicographical(words): Sorts a list of strings by their lengths in increasing order. If two strings have the same length, they are sorted lexicographically. :param words: List of strings to be sorted :return: List of sorted strings return sorted(words, key=lambda x: (len(x), x))"},{"question":"def find_pair_with_sum(arr, target): Given a sorted array of distinct integers and a target value, determine if there is a pair in the array whose sum equals the target value. >>> find_pair_with_sum([2, 7, 11, 15], 9) == [2, 7] >>> find_pair_with_sum([1, 2, 3, 4, 5, 6, 7], 10) == [3, 7] >>> find_pair_with_sum([1, 2, 3, 4, 5], 6) == [1, 5] >>> find_pair_with_sum([1, 3, 5, 7, 9, 11, 13, 15], 20) == [5, 15] >>> find_pair_with_sum([-10, -3, 0, 5, 9], 6) == [-3, 9] >>> find_pair_with_sum([-10, -3, 0, 5, 10, 15], 5) == [-10, 15]","solution":"def find_pair_with_sum(arr, target): Given a sorted array of distinct integers and a target value, determine if there is a pair in the array whose sum equals the target value. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return [arr[left], arr[right]] elif current_sum < target: left += 1 else: right -= 1 return None # Since we assume always one solution, this line is never reached."},{"question":"from typing import List def sort_by_even_odd(lst: List[int]) -> List[int]: Sorts the list such that all even numbers come before all odd numbers while maintaining their relative order. Args: lst (List[int]): The list of integers to be sorted. Returns: List[int]: A new sorted list with evens first, followed by odds, maintaining their original relative order. Examples: >>> sort_by_even_odd([3, 1, 2, 4]) [2, 4, 3, 1] >>> sort_by_even_odd([10, 3, 5, 8, 2, 6, 3]) [10, 8, 2, 6, 3, 5, 3] def test_sort_by_even_odd_mixed(): assert sort_by_even_odd([3, 1, 2, 4]) == [2, 4, 3, 1] assert sort_by_even_odd([10, 3, 5, 8, 2, 6, 3]) == [10, 8, 2, 6, 3, 5, 3] def test_sort_by_even_odd_all_even(): assert sort_by_even_odd([2, 4, 6, 8]) == [2, 4, 6, 8] def test_sort_by_even_odd_all_odd(): assert sort_by_even_odd([1, 3, 5, 7]) == [1, 3, 5, 7] def test_sort_by_even_odd_empty(): assert sort_by_even_odd([]) == [] def test_sort_by_even_odd_single_element(): assert sort_by_even_odd([1]) == [1] assert sort_by_even_odd([2]) == [2] def test_sort_by_even_odd_no_change(): assert sort_by_even_odd([2, 4, 1, 3]) == [2, 4, 1, 3] assert sort_by_even_odd([8, 6, 3, 1]) == [8, 6, 3, 1]","solution":"def sort_by_even_odd(lst): Sorts the list such that all even numbers come before all odd numbers while maintaining their relative order. Returns the sorted list without modifying the input list. evens = [x for x in lst if x % 2 == 0] odds = [x for x in lst if x % 2 != 0] return evens + odds"},{"question":"def find_duplicates(numbers: List[int]) -> List[int]: Returns a list of all the integers that appear more than once in the input list. The integers in the output list should be in the order that they first appeared in the input list. >>> find_duplicates([1, 2, 3, 4, 2, 5, 3, 6, 3]) [2, 3] >>> find_duplicates([1, 2, 3, 4, 5, 6]) [] >>> find_duplicates([1, 1, 2, 2, 3, 3, 3]) [1, 2, 3]","solution":"def find_duplicates(numbers): Returns a list of all the integers that appear more than once in the input list. The integers in the output list should be in the order that they first appeared in the input list. seen = set() duplicates = set() result = [] for number in numbers: if number in seen: if number not in duplicates: result.append(number) duplicates.add(number) else: seen.add(number) return result"},{"question":"def right_triangle(n: int) -> str: Returns a string representing a right triangle of asterisks ('*') with \`n\` rows, each row right-aligned. Examples: >>> right_triangle(1) '*' >>> right_triangle(2) ' *n**' >>> right_triangle(3) ' *n **n***' >>> right_triangle(5) ' *n **n ***n ****n*****'","solution":"def right_triangle(n): Returns a string representing a right triangle of asterisks ('*') with \`n\` rows, each row right-aligned. triangle = [] for i in range(1, n + 1): spaces = ' ' * (n - i) stars = '*' * i triangle.append(spaces + stars) return 'n'.join(triangle)"},{"question":"from typing import List def longestConsecutiveSubsequence(arr: List[int]) -> int: Given an array of integers, find the length of the longest subsequence such that elements in the subsequence are consecutive integers, though not necessarily contiguous in the array. >>> longestConsecutiveSubsequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> longestConsecutiveSubsequence([36, 41, 56, 35, 44, 33, 34, 92, 43, 32, 42]) 5 >>> longestConsecutiveSubsequence([-1, -2, 0, 2, 3, 1, -3]) 7 # Your code here pass def test_example_1(): assert longestConsecutiveSubsequence([1, 9, 3, 10, 4, 20, 2]) == 4 def test_example_2(): assert longestConsecutiveSubsequence([36, 41, 56, 35, 44, 33, 34, 92, 43, 32, 42]) == 5 def test_example_3(): assert longestConsecutiveSubsequence([-1, -2, 0, 2, 3, 1, -3]) == 7 def test_single_element(): assert longestConsecutiveSubsequence([10]) == 1 def test_no_consecutive(): assert longestConsecutiveSubsequence([10, 30, 50, 70]) == 1 def test_same_elements(): assert longestConsecutiveSubsequence([5, 5, 5, 5]) == 1 def test_already_consecutive(): assert longestConsecutiveSubsequence([5, 6, 7, 8, 9]) == 5 def test_negative_numbers(): assert longestConsecutiveSubsequence([-3, -2, -1, 0, 1, 2, 3, 4]) == 8","solution":"from typing import List def longestConsecutiveSubsequence(arr: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers in the given list. # Create a set of the array elements to allow O(1) look-up times num_set = set(arr) longest_streak = 0 # Check each number if it is a potential start of a sequence for num in arr: if num - 1 not in num_set: current_num = num current_streak = 1 # Count the length of the sequence while current_num + 1 in num_set: current_num += 1 current_streak += 1 # Update the longest streak if current one is longer longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List, Dict def calculate_total_compensation(employees: List[Dict[str, int]]) -> Dict[str, str]: Calculate total compensation for each employee and return the top 3 employees with the highest total compensation. The result is returned as a dictionary with keys \\"1st\\", \\"2nd\\", and \\"3rd\\", where the values are the names of the employees. In the case of a tie, the names should be listed in alphabetical order, separated by commas, and followed by the notation \\"(tie)\\". >>> calculate_total_compensation([{\\"name\\": \\"Alice\\", \\"salary\\": 50000, \\"bonus\\": 5}, {\\"name\\": \\"Bob\\", \\"salary\\": 70000, \\"bonus\\": 10}, {\\"name\\": \\"Charlie\\", \\"salary\\": 60000, \\"bonus\\": 8}]) {'1st': 'Bob', '2nd': 'Charlie', '3rd': 'Alice'} >>> calculate_total_compensation([{\\"name\\": \\"Alice\\", \\"salary\\": 50000, \\"bonus\\": 20}, {\\"name\\": \\"Bob\\", \\"salary\\": 50000, \\"bonus\\": 20}, {\\"name\\": \\"Charlie\\", \\"salary\\": 50000, \\"bonus\\": 20}]) {'1st': 'Alice, Bob, Charlie (tie)'} >>> calculate_total_compensation([{\\"name\\": \\"Alice\\", \\"salary\\": 50000, \\"bonus\\": 5}]) {'1st': 'Alice'}","solution":"def calculate_total_compensation(employees): Calculate total compensation for each employee and return the top 3 employees. for employee in employees: employee['total_compensation'] = employee['salary'] + (employee['salary'] * employee['bonus'] / 100) # Sort employees based on their total compensation in descending order sorted_employees = sorted(employees, key=lambda x: x['total_compensation'], reverse=True) result = {} ranks = [\\"1st\\", \\"2nd\\", \\"3rd\\"] i = 0 rank_index = 0 while i < len(sorted_employees) and rank_index < len(ranks): current_compensation = sorted_employees[i]['total_compensation'] same_rank_employees = [] while i < len(sorted_employees) and sorted_employees[i]['total_compensation'] == current_compensation: same_rank_employees.append(sorted_employees[i]['name']) i += 1 same_rank_employees.sort() # Alphabetical order for tie cases if len(same_rank_employees) > 1: result[ranks[rank_index]] = \\", \\".join(same_rank_employees) + \\" (tie)\\" else: result[ranks[rank_index]] = same_rank_employees[0] rank_index += 1 return result"},{"question":"from typing import List def moving_average(prices: List[float], window_size: int) -> List[float]: Calculate the moving averages of stock prices over a specified window size. :param prices: A list of stock prices. :param window_size: The size of the moving window. :return: A list of moving averages. >>> moving_average([1.0, 2.0, 3.0, 4.0, 5.0], 3) [2.0, 3.0, 4.0] >>> moving_average([5.0, 6.0, 7.0, 8.0, 9.0], 2) [5.5, 6.5, 7.5, 8.5] >>> moving_average([10.0, 20.0], 2) [15.0] >>> moving_average([1000.0, 2000.0, 3000.0, 4000.0, 5000.0], 3) [2000.0, 3000.0, 4000.0] >>> moving_average([1.1, 2.1, 3.1, 4.1, 5.1], 3) [2.1, 3.1, 4.1]","solution":"from typing import List def moving_average(prices: List[float], window_size: int) -> List[float]: Calculate the moving averages of stock prices over a specified window size. :param prices: A list of stock prices. :param window_size: The size of the moving window. :return: A list of moving averages. result = [] n = len(prices) for i in range(n - window_size + 1): window = prices[i:i+window_size] window_average = round(sum(window) / window_size, 1) result.append(window_average) return result"},{"question":"def rearrange_flights(flights: str) -> str: Takes a string of flight plans and rearranges them in chronological order based on their departure times. >>> rearrange_flights(\\"NewYork-LosAngeles-1230-05|Boston-Chicago-0945-02|LosAngeles-SanFrancisco-1420-01\\") 'Boston-Chicago at 09:45 for 2 hours | NewYork-LosAngeles at 12:30 for 5 hours | LosAngeles-SanFrancisco at 14:20 for 1 hour' >>> rearrange_flights(\\"NewYork-LosAngeles-1230-05\\") 'NewYork-LosAngeles at 12:30 for 5 hours' >>> rearrange_flights(\\"Chicago-NewYork-0730-02|Atlanta-Dallas-1400-03|Miami-Orlando-1100-01\\") 'Chicago-NewYork at 07:30 for 2 hours | Miami-Orlando at 11:00 for 1 hour | Atlanta-Dallas at 14:00 for 3 hours' >>> rearrange_flights(\\"LosAngeles-SanFrancisco-1430-01|NewYork-Chicago-1430-03|SanFrancisco-LosAngeles-1430-02\\") 'LosAngeles-SanFrancisco at 14:30 for 1 hour | NewYork-Chicago at 14:30 for 3 hours | SanFrancisco-LosAngeles at 14:30 for 2 hours' >>> rearrange_flights(\\"Houston-Dallas-1000-01|Austin-SanAntonio-1300-01|Jacksonville-Orlando-0900-01\\") 'Jacksonville-Orlando at 09:00 for 1 hour | Houston-Dallas at 10:00 for 1 hour | Austin-SanAntonio at 13:00 for 1 hour'","solution":"def rearrange_flights(flights): Takes a string of flight plans and rearranges them in chronological order based on their departure times. flight_list = flights.split('|') flight_info = [] for flight in flight_list: cityA, cityB, dep_time, duration = flight.split('-') flight_info.append((dep_time, cityA, cityB, dep_time, duration)) flight_info.sort() arranged_flights = [] for dep_time, cityA, cityB, dep_time, duration in flight_info: formatted_dep_time = f\\"{dep_time[:2]}:{dep_time[2:]}\\" formatted_duration = f\\"{int(duration)} hour\\" if int(duration) == 1 else f\\"{int(duration)} hours\\" arranged_flights.append(f\\"{cityA}-{cityB} at {formatted_dep_time} for {formatted_duration}\\") return \\" | \\".join(arranged_flights)"}]`),z={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},S={class:"card-container"},E={key:0,class:"empty-state"},j=["disabled"],P={key:0},I={key:1};function D(n,e,u,m,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",S,[(s(!0),r(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",E,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",I,"Loading...")):(s(),r("span",P,"See more"))],8,j)):l("",!0)])}const M=c(z,[["render",D],["__scopeId","data-v-d04a8271"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/62.md","filePath":"grok/62.md"}'),B={name:"grok/62.md"},G=Object.assign(B,{setup(n){return(e,u)=>(s(),r("div",null,[w(M)]))}});export{Y as __pageData,G as default};
