import{_ as c,o as s,c as r,a as t,m as _,t as d,C as p,M as g,U as b,f as u,F as x,p as v,e as y,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function A(n,e,l,m,i,a){return s(),r("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(d(l.poem.solution),1)])])])}const z=c(q,[["render",A],["__scopeId","data-v-e87b2155"]]),N=JSON.parse(`[{"question":"def longest_same_parity_subarray(arr: List[int]) -> int: Given an array of integers, determine the length of the longest contiguous subarray such that every element in the subarray is of the same parity (either all even or all odd). >>> longest_same_parity_subarray([1, 3, 5, 4, 6, 8]) == 3 >>> longest_same_parity_subarray([2, 4, 7, 7, 8]) == 2 >>> longest_same_parity_subarray([5, 9, 2, 2, 2, 3, 1]) == 3 >>> longest_same_parity_subarray([1, 3, 5, 7]) == 4 >>> longest_same_parity_subarray([2, 4, 6, 8]) == 4 >>> longest_same_parity_subarray([1]) == 1 >>> longest_same_parity_subarray([2]) == 1 >>> longest_same_parity_subarray([]) == 0 >>> longest_same_parity_subarray([1, 2, 3, 4, 5, 6]) == 1 >>> longest_same_parity_subarray([2, 1, 4, 3, 6, 5]) == 1","solution":"from typing import List def longest_same_parity_subarray(arr: List[int]) -> int: if not arr: return 0 max_length = 1 current_length = 1 current_parity = arr[0] % 2 for i in range(1, len(arr)): if (arr[i] % 2) == current_parity: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 current_parity = arr[i] % 2 # Final check after loop max_length = max(max_length, current_length) return max_length"},{"question":"def update_inventory(inventory: dict, new_shipment: dict) -> dict: Updates the inventory dictionary by adding the quantities from new_shipment. If an item in new_shipment is not present in inventory, it is added to the inventory. Args: inventory (dict): The original inventory of items. new_shipment (dict): The new shipment of items to be added to the inventory. Returns: dict: The updated inventory with quantities from new_shipment added. >>> inventory = {\\"apples\\": 5, \\"oranges\\": 3, \\"bananas\\": 2} >>> new_shipment = {\\"apples\\": 3, \\"oranges\\": 2, \\"grapes\\": 4} >>> update_inventory(inventory, new_shipment) {'apples': 8, 'oranges': 5, 'bananas': 2, 'grapes': 4}","solution":"def update_inventory(inventory, new_shipment): Updates the inventory dictionary by adding the quantities from new_shipment. If an item in new_shipment is not present in inventory, it is added to the inventory. Args: inventory (dict): The original inventory of items. new_shipment (dict): The new shipment of items to be added to the inventory. Returns: dict: The updated inventory with quantities from new_shipment added. for item, quantity in new_shipment.items(): if item in inventory: inventory[item] += quantity else: inventory[item] = quantity return inventory"},{"question":"from typing import List def common_prefix(strings: List[str]) -> str: Returns the longest common prefix shared among all the strings in the list. If there is no common prefix, returns an empty string. >>> common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> common_prefix([\\"throne\\", \\"throne\\"]) 'throne' >>> common_prefix([\\"hello\\", \\"Hello\\"]) '' >>> common_prefix([\\"single\\"]) 'single' >>> common_prefix([]) '' >>> common_prefix([\\"prefix\\", \\"pre\\", \\"prepare\\"]) 'pre' >>> common_prefix([\\"short\\", \\"shorten\\", \\"shortest\\"]) 'short'","solution":"def common_prefix(strings): Returns the longest common prefix shared among all the strings in the list. If there is no common prefix, returns an empty string. if not strings: return \\"\\" # Sort the list to easily compare the first and last strings strings.sort() first = strings[0] last = strings[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"def smallest_positive_integer_not_in_sum(lst: List[int]) -> int: Calculate the smallest positive integer that is not present in a given list and is not the sum of any subset of integers from the list. >>> smallest_positive_integer_not_in_sum([1, 2, 3, 10]) 7 >>> smallest_positive_integer_not_in_sum([1, 1, 1, 1]) 5 from solution import smallest_positive_integer_not_in_sum def test_case1(): assert smallest_positive_integer_not_in_sum([1, 2, 3, 10]) == 7 def test_case2(): assert smallest_positive_integer_not_in_sum([1, 1, 1, 1]) == 5 def test_case3(): assert smallest_positive_integer_not_in_sum([1, 2, 2, 5, 7]) == 18 def test_case4(): assert smallest_positive_integer_not_in_sum([2, 3, 4, 8]) == 1 # 1 is the smallest integer not in the list def test_case5(): assert smallest_positive_integer_not_in_sum([1, 2, 5, 10]) == 4 def test_case6(): assert smallest_positive_integer_not_in_sum([3, 3, 3, 3]) == 1 def test_case7(): assert smallest_positive_integer_not_in_sum([1, 3, 6, 10]) == 2 def test_case8(): assert smallest_positive_integer_not_in_sum([]) == 1 # Should handle empty list as 1","solution":"def smallest_positive_integer_not_in_sum(lst): Returns the smallest positive integer that is not present in the list and not the sum of any subset of integers from the list. lst.sort() smallest_missing = 1 for num in lst: if num > smallest_missing: break smallest_missing += num return smallest_missing"},{"question":"import math from typing import List, Union def is_square_free(num: int) -> bool: Determine if a number is square-free. A number is square-free if it is not divisible by any perfect square greater than 1. Args: - num (int): The number to check. Returns: - bool: True if num is square-free, False otherwise. Examples: >>> is_square_free(10) True >>> is_square_free(18) False >>> is_square_free(29) True >>> is_square_free(36) False","solution":"import math def is_square_free(num): Returns True if num is a square-free number, False otherwise. if num < 2: # 0 and 1 are trivially square-free by definition. return True for i in range(2, int(math.sqrt(num)) + 1): if num % (i * i) == 0: return False return True"},{"question":"def daily_temperatures(temperatures): Given an array of temperatures, returns an array of the number of days one would have to wait until a warmer temperature. If there is no future day with a warmer temperature, returns 0 for that day. Parameters: temperatures (list): List of integers representing daily temperatures. Returns: list: List of integers representing the wait times for a warmer temperature. Example: >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76]) [1, 1, 4, 2, 1, 1, 0] >>> daily_temperatures([73, 73, 73, 73, 73, 73, 73]) [0, 0, 0, 0, 0, 0, 0] >>> daily_temperatures([76, 75, 74, 73, 72, 71, 70]) [0, 0, 0, 0, 0, 0, 0] >>> daily_temperatures([70, 71, 72, 73, 74, 75, 76]) [1, 1, 1, 1, 1, 1, 0] >>> daily_temperatures([73, 70, 75, 71, 69, 72, 76]) [2, 1, 4, 2, 1, 1, 0]","solution":"def daily_temperatures(temperatures): Given an array of temperatures, returns an array of the number of days one would have to wait until a warmer temperature. If there is no future day with a warmer temperature, returns 0 for that day. Parameters: temperatures (list): List of integers representing daily temperatures. Returns: list: List of integers representing the wait times for a warmer temperature. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"def are_identical(list1: List[int], list2: List[int]) -> bool: Check if two lists are identical in both elements and order. >>> are_identical([1, 2, 3], [1, 2, 3]) True >>> are_identical([1, 2, 3], [1, 2, 4]) False >>> are_identical([], []) True >>> are_identical([1, 2, 3], []) False","solution":"def are_identical(list1, list2): Check if two lists are identical in both elements and order. if len(list1) != len(list2): return False for elem1, elem2 in zip(list1, list2): if elem1 != elem2: return False return True"},{"question":"from typing import List def format_ranges(lst: List[int]) -> str: Takes a list of integers and returns a string representing the range(s) of consecutive numbers found within the list. >>> format_ranges([1, 2, 3, 6, 7, 8, 10, 12, 13, 14]) '1-3, 6-8, 10, 12-14' >>> format_ranges([1, 3, 5, 7]) '1, 3, 5, 7' >>> format_ranges([]) '' >>> format_ranges([10]) '10'","solution":"def format_ranges(lst): if not lst: return \\"\\" lst.sort() result = [] start = lst[0] end = lst[0] for i in range(1, len(lst)): if lst[i] == end + 1: end = lst[i] else: if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") start = lst[i] end = lst[i] if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") return \\", \\".join(result)"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, where you can only move either down or right at any point in time and cannot move through obstacles (cells with value 1). >>> unique_paths_with_obstacles([[0,0,0],[0,0,0],[0,0,0]]) == 6 >>> unique_paths_with_obstacles([[0,1],[0,0]]) == 1 >>> unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]]) == 2 >>> unique_paths_with_obstacles([[0,1],[1,0]]) == 0 >>> unique_paths_with_obstacles([[1,0],[0,0]]) == 0 >>> unique_paths_with_obstacles([[0,0],[0,1]]) == 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, where you can only move either down or right at any point in time and cannot move through obstacles (cells with value 1). if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the given string can form a palindrome. :param s: input string composed of lowercase alphabets :return: True if any permutation can form a palindrome, False otherwise Example: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Determines if any permutation of the given string can form a palindrome. :param s: input string composed of lowercase alphabets :return: True if any permutation can form a palindrome, False otherwise from collections import Counter count = Counter(s) odd_count = sum(1 for char in count if count[char] % 2 != 0) return odd_count <= 1"},{"question":"def add_two_numbers(l1: List[int], l2: List[int]) -> List[int]: Adds two numbers represented by linked lists where each node contains a single digit, and the digits are stored in reverse order. Args: l1 : List[int] - First number represented as a list of digits in reverse order. l2 : List[int] - Second number represented as a list of digits in reverse order. Returns: List[int] - Sum of the numbers as a list of digits in reverse order. pass from solution import add_two_numbers def test_add_two_simple_numbers(): assert add_two_numbers([2, 4, 3], [5, 6, 4]) == [7, 0, 8] def test_add_two_numbers_with_carry(): assert add_two_numbers([9, 9], [1]) == [0, 0, 1] def test_add_two_numbers_with_diff_lengths(): assert add_two_numbers([1, 8], [0]) == [1, 8] assert add_two_numbers([1], [9, 9]) == [0, 0, 1] def test_add_when_first_number_is_zero(): assert add_two_numbers([0, 0, 0], [7, 3, 2]) == [7, 3, 2] def test_add_when_second_number_is_zero(): assert add_two_numbers([7, 3, 2], [0, 0, 0]) == [7, 3, 2] def test_add_both_are_zeros(): assert add_two_numbers([0, 0, 0], [0, 0, 0]) == [0, 0, 0] def test_add_single_digit_numbers(): assert add_two_numbers([1], [9]) == [0, 1] assert add_two_numbers([5], [5]) == [0, 1]","solution":"def add_two_numbers(l1, l2): Adds two numbers represented by linked lists where each node contains a single digit, and the digits are stored in reverse order. Args: l1 : List[int] - First number represented as a list of digits in reverse order. l2 : List[int] - Second number represented as a list of digits in reverse order. Returns: List[int] - Sum of the numbers as a list of digits in reverse order. result = [] carry = 0 max_length = max(len(l1), len(l2)) for i in range(max_length): digit1 = l1[i] if i < len(l1) else 0 digit2 = l2[i] if i < len(l2) else 0 total = digit1 + digit2 + carry carry = total // 10 result.append(total % 10) if carry: result.append(carry) return result"},{"question":"def min_operations_to_non_decreasing(n: int, sequence: List[int]) -> int: Determines the minimum number of operations required to transform the sequence into a non-decreasing sequence. Parameters: n (int): The length of the sequence. sequence (List[int]): The list of integers. Returns: int: The minimum number of operations required. >>> min_operations_to_non_decreasing(5, [2, 3, 5, 4, 6]) 1 >>> min_operations_to_non_decreasing(6, [1, 2, 3, 4, 5, 6]) 0 >>> min_operations_to_non_decreasing(4, [4, 3, 2, 1]) 3 >>> min_operations_to_non_decreasing(3, [7, 1, 9]) 1 >>> min_operations_to_non_decreasing(5, [5, 4, 6, 3, 7]) 2 >>> min_operations_to_non_decreasing(1, [1]) 0","solution":"def min_operations_to_non_decreasing(n, sequence): Determines the minimum number of operations required to transform the sequence into a non-decreasing sequence. Parameters: n (int): The length of the sequence. sequence (List[int]): The list of integers. Returns: int: The minimum number of operations required. # Initialize the last seen value as the first element in the sequence. last_seen = sequence[0] operations = 0 for i in range(1, n): if sequence[i] < last_seen: operations += 1 else: last_seen = sequence[i] return operations"},{"question":"def maxTalksInSession(max_duration: int, talks: List[Dict[str, Union[str, int]]]) -> int: Find the maximum number of talks that can be included in a session without exceeding the given time limit. Args: max_duration (int): The maximum duration of the session in minutes. talks (List[Dict[str, Union[str, int]]]): A list of dictionaries each containing 'speaker', 'topic', and 'duration' of the talk. Returns: int: The maximum number of talks that can be included in the session without exceeding the given time limit. Example: >>> talks = [ ... {'speaker': 'Alice', 'topic': 'AI and Robotics', 'duration': 45}, ... {'speaker': 'Bob', 'topic': 'Quantum Computing', 'duration': 40}, ... {'speaker': 'Charlie', 'topic': 'Blockchain Technology', 'duration': 50}, ... {'speaker': 'David', 'topic': 'Cybersecurity', 'duration': 30} ... ] >>> maxTalksInSession(90, talks) 2 >>> maxTalksInSession(45, talks) 1 >>> maxTalksInSession(150, talks) 3 >>> maxTalksInSession(30, talks) 1 >>> maxTalksInSession(20, talks) 0","solution":"def maxTalksInSession(max_duration, talks): talks = sorted(talks, key=lambda x: x['duration']) total_duration = 0 num_talks = 0 for talk in talks: if total_duration + talk['duration'] <= max_duration: total_duration += talk['duration'] num_talks += 1 else: break return num_talks"},{"question":"def solve(arr: List[int], target: int) -> int: Given an array of integers, find the smallest subarray having a sum equal to or greater than a given target sum. If such a subarray does not exist, return 0. >>> solve([2, 1, 5, 2, 3, 2], 7) == 2 >>> solve([1, 2, 3, 4], 15) == 0 >>> solve([1, 2, 3, 4, 5], 9) == 2 >>> solve([1, 2, 3, 4, 5], 15) == 5 >>> solve([1, 4, 4], 8) == 2 >>> solve([8], 7) == 1 >>> solve([5], 7) == 0","solution":"def solve(arr, target): Given an array of integers, find the smallest subarray having a sum equal to or greater than a given target sum. If such a subarray does not exist, return 0. n = len(arr) min_length = float('inf') current_sum = 0 start_index = 0 for end_index in range(n): current_sum += arr[end_index] while current_sum >= target: min_length = min(min_length, end_index - start_index + 1) current_sum -= arr[start_index] start_index += 1 return min_length if min_length != float('inf') else 0"},{"question":"from typing import List def largest_square_block(matrix: List[List[int]]) -> int: Find the size of the largest square sub-matrix where all elements are the same. >>> largest_square_block([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 3 >>> largest_square_block([[1, 2, 2], [2, 2, 2], [2, 2, 3]]) 2 def process_test_cases(test_cases: List[List[List[int]]]) -> List[int]: Processes multiple test cases for the largest_square_block function. >>> process_test_cases([[[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[1, 2, 2], [2, 2, 2], [2, 2, 3]]]) [3, 2]","solution":"def largest_square_block(matrix): if not matrix: return 0 M = len(matrix) N = len(matrix[0]) dp = [[0] * N for _ in range(M)] max_side = 0 for i in range(M): for j in range(N): if i == 0 or j == 0: dp[i][j] = 1 else: if matrix[i][j] == matrix[i-1][j] == matrix[i][j-1] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side = max(max_side, dp[i][j]) return max_side def process_test_cases(test_cases): results = [] for matrix in test_cases: result = largest_square_block(matrix) results.append(result) return results"},{"question":"def to_roman(n: int) -> str: Converts a positive integer n to its Roman numeral representation. >>> to_roman(9) == \\"IX\\" >>> to_roman(58) == \\"LVIII\\" >>> to_roman(1994) == \\"MCMXCIV\\"","solution":"def to_roman(n: int) -> str: Converts a positive integer n to its Roman numeral representation. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \\"\\" i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syms[i] n -= val[i] i += 1 return roman_num"},{"question":"def count_points_in_circles(points, queries): For each query, count how many points lie inside or on the boundary of the circle defined by the query. Parameters: points (list of list of int): A list of [xi, yi] coordinates of points. queries (list of list of int): A list of [xj, yj, rj] where each defines a circle query. Returns: list: A list of integers counting the points inside each circle query. >>> count_points_in_circles([[1, 3], [3, 3], [5, 3], [2, 2]], [[2, 3, 1], [4, 3, 1], [1, 1, 2]]) [3, 2, 2] >>> count_points_in_circles([[1, 1], [2, 2], [3, 3]], [[2, 2, 5]]) [3] >>> count_points_in_circles([[10, 10], [20, 20], [30, 30]], [[0, 0, 1]]) [0] >>> count_points_in_circles([[0, 0], [500, 500], [250, 250]], [[0, 0, 0], [500, 500, 1], [250, 250, 0], [250, 250, 500]]) [1, 1, 1, 3] >>> count_points_in_circles([[5, 5], [10, 10], [15, 15]], [[10, 10, 100], [15, 15, 150], [5, 5, 200]]) [3, 3, 3] >>> count_points_in_circles([[2, 2]], [[1, 1, 1], [2, 2, 0], [2, 2, 1]]) [0, 1, 1] pass # Implement the function here","solution":"import math def count_points_in_circles(points, queries): For each query, count how many points lie inside or on the boundary of the circle defined by the query. Parameters: points (list of list of int): A list of [xi, yi] coordinates of points. queries (list of list of int): A list of [xj, yj, rj] where each defines a circle query. Returns: list: A list of integers counting the points inside each circle query. result = [] for xj, yj, rj in queries: count = 0 rj_squared = rj ** 2 for xi, yi in points: # Calculate the squared distance to avoid computing the square root distance_squared = (xi - xj) ** 2 + (yi - yj) ** 2 if distance_squared <= rj_squared: count += 1 result.append(count) return result"},{"question":"def separate_even_odd(numbers: List[int]) -> Dict[str, List[int]]: Separates a list of integers into even and odd numbers. Args: numbers (list of int): A list of integers. Returns: dict: A dictionary with keys 'evens' and 'odds', containing lists of even and odd numbers, respectively. Examples: >>> separate_even_odd([1, 2, 3, 4, 5, 6]) {'evens': [2, 4, 6], 'odds': [1, 3, 5]} >>> separate_even_odd([7, 8, 9, 10, 1]) {'evens': [8, 10], 'odds': [7, 9, 1]}","solution":"def separate_even_odd(numbers): Separates a list of integers into even and odd numbers. Args: numbers (list of int): A list of integers. Returns: dict: A dictionary with keys 'evens' and 'odds', containing lists of even and odd numbers, respectively. result = {\\"evens\\": [], \\"odds\\": []} for number in numbers: if number % 2 == 0: result[\\"evens\\"].append(number) else: result[\\"odds\\"].append(number) return result"},{"question":"def mode_of_array(arr): Given an integer array of size 5, write a function to determine the mode (the number that appears most frequently). If there's a tie, return the smallest number among them. >>> mode_of_array([4, 5, 2, 2, 3]) == 2 >>> mode_of_array([1, 1, 2, 2, 3]) == 1 >>> mode_of_array([1, 2, 3, 4, 5]) == 1 >>> mode_of_array([2, 2, 4, 4, 1]) == 2 >>> mode_of_array([3, 3, 3, 3, 3]) == 3","solution":"from collections import Counter def mode_of_array(arr): Returns the mode of the given integer array. If there's a tie, returns the smallest number among the modes. if len(arr) != 5: raise ValueError(\\"Array must be of size 5.\\") count = Counter(arr) max_frequency = max(count.values()) modes = [num for num, freq in count.items() if freq == max_frequency] return min(modes)"},{"question":"def rearrange_books(books: List[int]) -> List[int]: Rearrange a list of books by heights where: - All books with even heights come before those with odd heights. - Even-height books are sorted in ascending order. - Odd-height books are sorted in descending order. >>> rearrange_books([7, 2, 3, 8, 1, 5, 6]) [2, 6, 8, 7, 5, 3, 1] >>> rearrange_books([12, 11, 8, 7, 6, 5, 4]) [4, 6, 8, 12, 11, 7, 5]","solution":"def rearrange_books(books): Rearrange the books such that: - Even height books come before odd height books - Even height books are sorted in ascending order - Odd height books are sorted in descending order even_books = sorted([book for book in books if book % 2 == 0]) odd_books = sorted([book for book in books if book % 2 != 0], reverse=True) return even_books + odd_books"},{"question":"def count_palindromic_binaries(arr: List[int]) -> int: Count how many numbers in the given list have palindromic binary representations. :param arr: List of non-negative integers :return: Integer count of numbers with palindromic binary representations >>> count_palindromic_binaries([1, 2, 3, 4, 5, 6, 7]) 4 >>> count_palindromic_binaries([10, 22, 33, 44, 55]) 2 >>> count_palindromic_binaries([123, 456, 789, 101]) 1","solution":"def count_palindromic_binaries(arr): Count how many numbers in the given list have palindromic binary representations. :param arr: List of non-negative integers :return: Integer count of numbers with palindromic binary representations def is_binary_palindrome(n): binary_str = bin(n)[2:] # Convert to binary and strip the '0b' prefix return binary_str == binary_str[::-1] # Check if the binary string is a palindrome return sum(1 for num in arr if is_binary_palindrome(num))"},{"question":"def min_delivery_time(N: int, demands_travel: [(int, int)]) -> int: Determine the minimum time needed to deliver products to all distribution centers. Parameters: N (int): Number of distribution centers. demands_travel (list of tuples): List of tuples where each tuple contains two integers (Demand of the ith center, Travel time to the ith center). Returns: int: Minimum time needed to deliver products to all distribution centers. >>> min_delivery_time(3, [(10, 5), (20, 10), (15, 5)]) 20 >>> min_delivery_time(1, [(30, 7)]) 14 >>> min_delivery_time(3, [(10, 3), (20, 3), (15, 3)]) 6 >>> min_delivery_time(5, [(10, 1), (20, 2), (15, 3), (11, 4), (21, 10)]) 20 >>> min_delivery_time(4, [(10, 8), (10, 2), (10, 5), (10, 3)]) 16","solution":"def min_delivery_time(N, demands_travel): Returns the minimum time needed to deliver products to all distribution centers. Parameters: N (int): Number of distribution centers demands_travel (list of tuples): List of tuples where each tuple contains two integers (Demand of the ith center, Travel time to the ith center) Returns: int: Minimum time needed to deliver products to all distribution centers # Find the maximum travel time amongst all the distribution centers max_time = max([t for d, t in demands_travel]) # Since truck can carry multiple products and service multiple centers in one go, # it will always be feasible to go to the farthest center first. return max_time * 2"},{"question":"def length_of_longest_word(s: str) -> int: Returns the length of the longest word in the string \`s\`. If there are multiple words of the same maximum length, returns the length of the first one encountered. >>> length_of_longest_word(\\"Find the length of the longest word here\\") 7 >>> length_of_longest_word(\\"hello\\") 5 >>> length_of_longest_word(\\"cat bat rat mat\\") 3 >>> length_of_longest_word(\\"the quick brown fox jumps over the lazy dog\\") 5 >>> length_of_longest_word(\\"a b c d e\\") 1 >>> length_of_longest_word(\\"\\") 0 >>> length_of_longest_word(\\"a b c d e f g h i j k l m n o p q r s t u v w x y z\\") 1","solution":"def length_of_longest_word(s): Returns the length of the longest word in the string \`s\`. If there are multiple words of the same maximum length, returns the length of the first one encountered. words = s.split() max_length = 0 for word in words: if len(word) > max_length: max_length = len(word) return max_length"},{"question":"def trailing_zeroes(n: int) -> int: Returns the number of trailing zeroes in the factorial of n. >>> trailing_zeroes(5) 1 >>> trailing_zeroes(100) 24 from solution import trailing_zeroes def test_trailing_zeroes_example_cases(): assert trailing_zeroes(5) == 1 assert trailing_zeroes(100) == 24 def test_trailing_zeroes_small_numbers(): assert trailing_zeroes(0) == 0 assert trailing_zeroes(1) == 0 assert trailing_zeroes(4) == 0 def test_trailing_zeroes_large_numbers(): assert trailing_zeroes(101) == 24 assert trailing_zeroes(200) == 49 assert trailing_zeroes(1000) == 249 def test_trailing_zeroes_boundary_cases(): assert trailing_zeroes(9) == 1 assert trailing_zeroes(10) == 2 assert trailing_zeroes(25) == 6 def test_trailing_zeroes_complex_cases(): assert trailing_zeroes(50) == 12 assert trailing_zeroes(60) == 14 assert trailing_zeroes(75) == 18","solution":"def trailing_zeroes(n): Returns the number of trailing zeroes in the factorial of n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"def longestCommonPrefix(strs): Implement a function \`longestCommonPrefix\` which accepts an array of strings and returns the longest common prefix string among them. If there is no common prefix, return an empty string \`\\"\\"\`. Parameters: strs (List[str]): A list of strings. Returns: str: The longest common prefix among the input strings. >>> longestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longestCommonPrefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longestCommonPrefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> longestCommonPrefix([\\"\\", \\"b\\", \\"c\\"]) '' >>> longestCommonPrefix([]) '' >>> longestCommonPrefix([\\"single\\"]) 'single' >>> longestCommonPrefix([\\"a\\", \\"ab\\", \\"abc\\"]) 'a'","solution":"def longestCommonPrefix(strs): if not strs: return \\"\\" prefix = strs[0] for string in strs[1:]: while string[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] if not prefix: break return prefix"},{"question":"def create_mirror_image(s: str) -> str: Given a string s, return the string concatenated with its mirror image, which is the reversed version of the string s. >>> create_mirror_image(\\"abc\\") == \\"abccba\\" >>> create_mirror_image(\\"hello\\") == \\"helloolleh\\" >>> create_mirror_image(\\"xyz\\") == \\"xyzzyx\\"","solution":"def create_mirror_image(s: str) -> str: Given a string s, return the string concatenated with its mirror image, which is the reversed version of the string s. return s + s[::-1]"},{"question":"def can_alice_win(N: int, M: int, grid: List[str]) -> str: Determine if Alice can create a winning path under optimal play. >>> can_alice_win(4, 5, [\\".#..#\\", \\"...\\", \\".#..#\\", \\"#.#..\\"]) 'Alice' >>> can_alice_win(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) 'Bob' pass","solution":"def can_alice_win(N, M, grid): # Check for vertical path possibility for col in range(M): stack = [] visited = set() for row in range(N): if grid[row][col] == '.': stack.append((row, col)) visited.add((row, col)) while stack: r, c = stack.pop() if r == N - 1: return \\"Alice\\" for next_r in [r - 1, r + 1]: if 0 <= next_r < N and grid[next_r][c] == '#' and (next_r, c) not in visited: visited.add((next_r, c)) stack.append((next_r, c)) # Check for horizontal path possibility for row in range(N): stack = [] visited = set() for col in range(M): if grid[row][col] == '.': stack.append((row, col)) visited.add((row, col)) while stack: r, c = stack.pop() if c == M - 1: return \\"Alice\\" for next_c in [c - 1, c + 1]: if 0 <= next_c < M and grid[r][next_c] == '#' and (r, next_c) not in visited: visited.add((r, next_c)) stack.append((r, next_c)) return \\"Bob\\""},{"question":"def most_frequent_char(s: str) -> str: Write a function that takes a string as an input and returns the most frequently occurring character in that string. In case of a tie, return the character that appears first in the string. Your function should consider all characters including punctuation and whitespace, but it should treat uppercase and lowercase characters as distinct. >>> most_frequent_char(\\"Hello, World!\\") 'l' >>> most_frequent_char(\\"character\\") 'c'","solution":"def most_frequent_char(s: str) -> str: Returns the most frequently occurring character in the string \`s\`. In case of a tie, returns the character that appears first in the string. from collections import Counter # Create a Counter object to count the frequency of each character char_count = Counter(s) # Get the maximum frequency max_freq = max(char_count.values()) # Find the first character in the string with the maximum frequency for char in s: if char_count[char] == max_freq: return char"},{"question":"def longest_subarray(weights: List[int], capacity: int) -> int: Returns the length of the longest subarray where the sum of weights is less than or equal to the given capacity. >>> longest_subarray([1, 2, 3, 4, 5], 10) 4 >>> longest_subarray([4, 8, 5, 1, 7], 6) 2 >>> longest_subarray([7, 3, 4, 8], 6) 1 >>> longest_subarray([5, 6, 7, 8], 4) 0 >>> longest_subarray([3], 5) 1 >>> longest_subarray([7], 6) 0 >>> longest_subarray([1, 1, 1, 1, 1], 5) 5 >>> longest_subarray([1, 2, 3], 1000) 3 >>> longest_subarray([], 5) 0 return","solution":"def longest_subarray(weights, capacity): Returns the length of the longest subarray where the sum of weights is less than or equal to the given capacity. n = len(weights) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += weights[end] while current_sum > capacity: current_sum -= weights[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List, Tuple, Union def find_two_sum_indices(arr: List[int], target: int) -> Union[Tuple[int, int], str]: Given an array of integers and a target value, return the indices (1-based) of the two numbers such that they add up to the target value. If no such pair exists, return \\"None\\". >>> find_two_sum_indices([2, 7, 11, 15], 9) (1, 2) >>> find_two_sum_indices([3, 2, 4], 6) (2, 3) >>> find_two_sum_indices([3, 3], 6) (1, 2) >>> find_two_sum_indices([1, 2, 3], 7) \\"None\\" >>> find_two_sum_indices([-1, -2, -3, -4, -5], -8) (3, 5) pass def process_test_cases(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Process multiple test cases to find the indices of two numbers that add up to the given target. >>> T = 2 >>> test_cases = [ ... [(4, 9), [2, 7, 11, 15]], ... [(3, 6), [3, 2, 4]] ... ] >>> process_test_cases(T, test_cases) [\\"1 2\\", \\"2 3\\"] >>> T = 3 >>> test_cases = [ ... [(3, 7), [1, 2, 3]], ... [(2, 6), [3, 3]], ... [(5, -8), [-1, -2, -3, -4, -5]] ... ] >>> process_test_cases(T, test_cases) [\\"None\\", \\"1 2\\", \\"3 5\\"] pass","solution":"def find_two_sum_indices(arr, target): Given an array of integers and a target value, return the indices (1-based) of the two numbers such that they add up to the target value. If no such pair exists, return \\"None\\". num_to_index = {} for i, num in enumerate(arr): difference = target - num if difference in num_to_index: return (num_to_index[difference] + 1, i + 1) num_to_index[num] = i return \\"None\\" def process_test_cases(T, test_cases): results = [] for i in range(T): n, x = test_cases[i][0] arr = test_cases[i][1] result = find_two_sum_indices(arr, x) if result == \\"None\\": results.append(\\"None\\") else: results.append(f\\"{result[0]} {result[1]}\\") return results"},{"question":"def trap(height: List[int]) -> int: Return the total amount of rainwater trapped. :param height: List[int] - List of non-negative integers representing the elevation map :return: int - Total amount of trapped rainwater >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([0,1,2,3,4,5]) 0 >>> trap([1,1,1,1]) 0 >>> trap([]) 0 >>> trap([5]) 0 >>> trap([5,4]) 0","solution":"def trap(height): Return the total amount of rainwater trapped. :param height: List[int] - List of non-negative integers representing the elevation map :return: int - Total amount of trapped rainwater if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) trapped_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) trapped_water += right_max - height[right] return trapped_water"},{"question":"def can_form_rotated_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a rotated palindrome. >>> can_form_rotated_palindrome(\\"aabb\\") True >>> can_form_rotated_palindrome(\\"abc\\") False >>> can_form_rotated_palindrome(\\"aaa\\") True >>> can_form_rotated_palindrome(\\"abba\\") True >>> can_form_rotated_palindrome(\\"racecar\\") True >>> can_form_rotated_palindrome(\\"civic\\") True >>> can_form_rotated_palindrome(\\"ivicc\\") True >>> can_form_rotated_palindrome(\\"a\\") True >>> can_form_rotated_palindrome(\\"hello\\") False >>> can_form_rotated_palindrome(\\"world\\") False","solution":"def can_form_rotated_palindrome(s): Determines if a given string can be rearranged to form a rotated palindrome. # Step 1: Count the frequency of each character in the string. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Step 2: Check the conditions for forming a palindrome. odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can form a palindrome if at most one character has an odd frequency. return odd_count <= 1"},{"question":"def longest_path_in_grid(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Given a grid of size N x M consisting of '.' and '#', where '.' represents a passable cell and '#' represents an impassable cell, determine the length of the longest path from the top-left corner to the bottom-right corner. You can only move right or down at each step. If it is impossible to reach the bottom-right corner, return -1. >>> T = 2 >>> test_cases = [ ... (3, 3, [\\"...\\", \\".#.\\", \\"...\\"]), ... (4, 4, [\\"....\\", \\"..\\", \\".#..\\", \\"....\\"]) ... ] >>> longest_path_in_grid(T, test_cases) [4, 6] >>> T = 1 >>> test_cases = [ ... (3, 3, [\\"...\\", \\"#\\", \\"...\\"]) ... ] >>> longest_path_in_grid(T, test_cases) [-1]","solution":"def longest_path_in_grid(T, test_cases): results = [] for case in test_cases: N, M, grid = case if grid[0][0] == '#' or grid[N-1][M-1] == '#': results.append(-1) continue # DP array to store the longest path length to each cell dp = [[-1] * M for _ in range(N)] dp[0][0] = 0 for i in range(N): for j in range(M): if grid[i][j] == '#': continue if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + 1) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + 1) result = dp[N-1][M-1] results.append(result if result != -1 else -1) return results"},{"question":"def fibonacci(n: int) -> int: Returns the nth number in the Fibonacci sequence. The Fibonacci sequence starts as 0, 1, 1, 2, 3, 5, 8, 13,... Args: n (int): The position in the Fibonacci sequence to retrieve. Returns: int: The nth Fibonacci number. Examples: >>> fibonacci(5) 5 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the nth number in the Fibonacci sequence. The Fibonacci sequence starts as 0, 1, 1, 2, 3, 5, 8, 13,... if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def all_unique_characters(s: str) -> bool: Determines if a given string contains only unique characters. >>> all_unique_characters(\\"abcdef\\") True >>> all_unique_characters(\\"apple\\") False >>> all_unique_characters(\\"uniq\\") True >>> all_unique_characters(\\"banana\\") False >>> all_unique_characters(\\"a\\") True >>> all_unique_characters(\\"z\\") True Parameters: s (str): The input string containing only lowercase alphabetic characters. Returns: bool: True if all characters in the string are unique, False otherwise.","solution":"def all_unique_characters(s): Determines if a given string contains only unique characters. Parameters: s (str): The input string containing only lowercase alphabetic characters. Returns: bool: True if all characters in the string are unique, False otherwise. char_seen = [False] * 26 # Since only lowercase alphabets are used, we use a fixed size list of 26. for char in s: index = ord(char) - ord('a') if char_seen[index]: return False char_seen[index] = True return True"},{"question":"from typing import List def shortest_to_char(s: str, c: str) -> List[int]: Returns a list of integers representing the shortest distance from each character in the string \`s\` to the character \`c\`. >>> shortest_to_char(\\"loveleetcode\\", 'e') [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_to_char(\\"a\\", 'a') [0] >>> shortest_to_char(\\"aaaaa\\", 'a') [0, 0, 0, 0, 0] >>> shortest_to_char(\\"exxxxxx\\", 'e') [0, 1, 2, 3, 4, 5, 6] >>> shortest_to_char(\\"xxxxxxe\\", 'e') [6, 5, 4, 3, 2, 1, 0] >>> shortest_to_char(\\"abacabadabacaba\\", 'b') [1, 0, 1, 2, 1, 0, 1, 2, 1, 0, 1, 2, 1, 0, 1] >>> shortest_to_char(\\"xyzzyxex\\", 'e') [6, 5, 4, 3, 2, 1, 0, 1]","solution":"def shortest_to_char(s, c): Returns a list of integers representing the shortest distance from each character in the string \`s\` to the character \`c\`. n = len(s) answer = [float('inf')] * n # First pass to find the shortest distance to the closest \`c\` on the left prev_position = float('-inf') for i in range(n): if s[i] == c: prev_position = i answer[i] = min(answer[i], i - prev_position) # Second pass to find the shortest distance to the closest \`c\` on the right prev_position = float('inf') for i in range(n-1, -1, -1): if s[i] == c: prev_position = i answer[i] = min(answer[i], prev_position - i) return answer"},{"question":"def dna_to_rna(dna_sequence: str) -> str: Converts a DNA sequence to an RNA sequence by replacing all occurrences of 'T' with 'U'. If the DNA sequence contains invalid characters, returns None. >>> dna_to_rna(\\"ACGTACGT\\") \\"ACGUACGU\\" >>> dna_to_rna(\\"ACGTACGX\\") None >>> dna_to_rna(\\"\\") \\"\\" >>> dna_to_rna(\\"ATCG\\") \\"AUCG\\" def validate_dna(dna_sequence: str) -> bool: Validates a DNA sequence to ensure it contains only 'A', 'C', 'G', and 'T' characters. Returns True if the sequence is valid, otherwise False. >>> validate_dna(\\"ACGTACGT\\") True >>> validate_dna(\\"ACGTACGX\\") False >>> validate_dna(\\"\\") True >>> validate_dna(\\"AGCTAGCT\\") True >>> validate_dna(\\"ACGT123\\") False >>> validate_dna(\\"ACGT@#\\") False","solution":"def dna_to_rna(dna_sequence): Converts a DNA sequence to an RNA sequence by replacing all occurrences of 'T' with 'U'. If the DNA sequence contains invalid characters, returns None. valid_bases = {'A', 'C', 'G', 'T'} if not validate_dna(dna_sequence): return None return dna_sequence.replace('T', 'U') def validate_dna(dna_sequence): Validates a DNA sequence to ensure it contains only 'A', 'C', 'G', and 'T' characters. Returns True if the sequence is valid, otherwise False. valid_bases = {'A', 'C', 'G', 'T'} return all(base in valid_bases for base in dna_sequence)"},{"question":"def min_servers_needed(N, M, W, workloads, capacities): Given the number of servers N, the number of workloads M, and the maximum number of servers W that can be used, determine the minimum number of servers needed from the available N servers to handle these workloads sequentially. Args: N (int): Number of servers M (int): Number of workloads W (int): The maximum number of servers that can be used workloads (List[int]): List of workload capacities capacities (List[int]): List of server capacities Returns: int: Minimum number of servers needed or -1 if itâ€™s not possible to handle all workloads with given constraints >>> min_servers_needed(3, 5, 3, [10, 20, 30, 40, 50], [50, 50, 50]) 3 >>> min_servers_needed(2, 4, 2, [100, 200, 300, 400], [500, 500]) 2 >>> min_servers_needed(2, 2, 3, [20, 20], [50, 50, 50]) 1 >>> min_servers_needed(1, 3, 1, [60, 60, 60], [50]) -1 >>> min_servers_needed(1, 1, 1, [10], [10]) 1 >>> min_servers_needed(3, 3, 3, [30, 20, 10], [30, 20, 10]) 3 def process_cases(test_cases): Processes multiple test cases for the min_servers_needed function. Args: test_cases (List[Dict]): List of test cases, where each test case is a dictionary containing 'N', 'M', 'W', 'workloads', 'capacities'. Returns: List[int]: List of results from min_servers_needed function for each test case. def test_min_servers_needed(): test_cases = [ {'N': 3, 'M': 5, 'W': 3, 'workloads': [10, 20, 30, 40, 50], 'capacities': [50, 50, 50]}, {'N': 2, 'M': 4, 'W': 2, 'workloads': [100, 200, 300, 400], 'capacities': [500, 500]} ] results = process_cases(test_cases) assert results[0] == 3 assert results[1] == 2 def test_more_servers_than_needed(): test_cases = [ {'N': 2, 'M': 2, 'W': 3, 'workloads': [20, 20], 'capacities': [50, 50, 50]} ] results = process_cases(test_cases) assert results[0] == 1 def test_not_enough_capacity(): test_cases = [ {'N': 1, 'M': 3, 'W': 1, 'workloads': [60, 60, 60], 'capacities': [50]} ] results = process_cases(test_cases) assert results[0] == -1 def test_single_server_sufficient(): test_cases = [ {'N': 1, 'M': 1, 'W': 1, 'workloads': [10], 'capacities': [10]} ] results = process_cases(test_cases) assert results[0] == 1 def test_exact_fit(): test_cases = [ {'N': 3, 'M': 3, 'W': 3, 'workloads': [30, 20, 10], 'capacities': [30, 20, 10]} ] results = process_cases(test_cases) assert results[0] == 3","solution":"def min_servers_needed(N, M, W, workloads, capacities): # Sort the server capacities and workloads in descending order capacities.sort(reverse=True) workloads.sort(reverse=True) # Initialize array to keep track of the used capacity in each server used_capacity = [0] * W for workload in workloads: assigned = False for i in range(W): if used_capacity[i] + workload <= capacities[i]: used_capacity[i] += workload assigned = True break if not assigned: return -1 num_servers_used = sum(1 for capacity in used_capacity if capacity > 0) return num_servers_used def process_cases(test_cases): results = [] for case in test_cases: N, M, W = case['N'], case['M'], case['W'] workloads = case['workloads'] capacities = case['capacities'] results.append(min_servers_needed(N, M, W, workloads, capacities)) return results"},{"question":"def longest_parade_length(n, heights): Determines the length of the longest parade of cows where the height alternates between strictly increasing and strictly decreasing. Args: n (int): The number of cows. heights (List[int]): The heights of the cows. Returns: int: The length of the longest possible parade. >>> longest_parade_length(5, [1, 3, 2, 5, 4]) 5 >>> longest_parade_length(6, [1, 2, 3, 4, 5, 6]) 2 pass def process_input(test_cases): Processes multiple test cases and returns a list of results. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing a number of cows and their heights. Returns: List[int]: A list of the lengths of the longest possible parades for each test case. >>> process_input([(5, [1, 3, 2, 5, 4]), (6, [1, 2, 3, 4, 5, 6])]) [5, 2] pass def parse_input(input_string): Parses input string into a list of test cases. Args: input_string (str): The input data as a string. Returns: List[Tuple[int, List[int]]]: Parsed test cases. >>> parse_input(\\"2n5n1 3 2 5 4n6n1 2 3 4 5 6n\\") [(5, [1, 3, 2, 5, 4]), (6, [1, 2, 3, 4, 5, 6])] pass","solution":"def longest_parade_length(n, heights): if n == 0: return 0 if n == 1: return 1 count = 1 prev_diff = 0 for i in range(1, n): diff = heights[i] - heights[i - 1] if (diff > 0 and prev_diff <= 0) or (diff < 0 and prev_diff >= 0): count += 1 prev_diff = diff return count def process_input(test_cases): results = [] for n, heights in test_cases: results.append(longest_parade_length(n, heights)) return results # Reading input and returning the results for all test cases def parse_input(input_string): lines = input_string.strip().split(\\"n\\") t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) index += 1 heights = list(map(int, lines[index].strip().split())) index += 1 test_cases.append((n, heights)) return test_cases"},{"question":"def count_even_sum_pairs(A: List[int]) -> int: Returns the number of pairs (i, j) where i < j and A[i] + A[j] is even. >>> count_even_sum_pairs([2, 4, 6, 8]) 6 >>> count_even_sum_pairs([1, 3, 5, 7]) 6 >>> count_even_sum_pairs([1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs([2, 2, 2, 2]) 6","solution":"def count_even_sum_pairs(A): Returns the number of pairs (i, j) where i < j and A[i] + A[j] is even. even_count = 0 odd_count = 0 for num in A: if num % 2 == 0: even_count += 1 else: odd_count += 1 # Calculation of pairs: nC2 = n*(n-1) / 2 even_pairs = even_count * (even_count - 1) // 2 odd_pairs = odd_count * (odd_count - 1) // 2 return even_pairs + odd_pairs"},{"question":"def apply_queries(m: int, n: int, queries: List[Tuple[int, int, int, int]]) -> List[List[int]]: Given a grid of size m x n initialized with all 0's and several queries, each query defined by a rectangle (r1, c1, r2, c2) representing the top-left and bottom-right corners respectively, increment the value of each element within the defined rectangle by 1. Return the updated grid after all queries have been processed. >>> apply_queries(3, 3, []) [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] >>> apply_queries(3, 3, [(0, 0, 1, 1)]) [ [1, 1, 0], [1, 1, 0], [0, 0, 0] ] >>> apply_queries(3, 3, [(0, 0, 1, 1), (1, 1, 2, 2), (0, 0, 2, 2)]) [ [2, 2, 1], [2, 3, 2], [1, 2, 2] ] >>> apply_queries(3, 3, [(0, 0, 2, 2)]) [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] >>> apply_queries(3, 3, [(0, 0, 0, 0), (2, 2, 2, 2)]) [ [1, 0, 0], [0, 0, 0], [0, 0, 1] ]","solution":"from typing import List, Tuple def apply_queries(m: int, n: int, queries: List[Tuple[int, int, int, int]]) -> List[List[int]]: # Initialize grid with all zeros grid = [[0 for _ in range(n)] for _ in range(m)] # Apply each query to the grid for r1, c1, r2, c2 in queries: for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): grid[r][c] += 1 return grid"},{"question":"def decode_message(encoded: str) -> str: Decodes a run-length encoded string. Parameters: encoded (str): The run-length encoded string. Returns: str: The decoded message. Examples: >>> decode_message(\\"a4b3c2\\") 'aaaabbbcc' >>> decode_message(\\"h8i2a1\\") 'hhhhhhhhiia' >>> decode_message(\\"x1y2z3\\") 'xyyzzz'","solution":"def decode_message(encoded: str) -> str: Decodes a run-length encoded string. Parameters: encoded (str): The run-length encoded string. Returns: str: The decoded message. decoded_message = [] i = 0 while i < len(encoded): char = encoded[i] i += 1 num_start = i while i < len(encoded) and encoded[i].isdigit(): i += 1 count = int(encoded[num_start:i]) decoded_message.append(char * count) return ''.join(decoded_message)"},{"question":"def find_max_diff(lst: List[int]) -> List[int]: Returns the two numbers in ascending order that have the maximum difference along with their difference in a list. If the input list contains fewer than two elements, return an empty list. Examples: >>> find_max_diff([2, 3, 10, 6, 4, 8, 1, 12]) [1, 12, 11] >>> find_max_diff([7, 2, 3, 4, 6]) [2, 7, 5] >>> find_max_diff([3]) [] >>> find_max_diff([]) [] pass # Unit Tests def test_find_max_diff_regular_case(): assert find_max_diff([2, 3, 10, 6, 4, 8, 1, 12]) == [1, 12, 11] def test_find_max_diff_with_negatives_elements(): assert find_max_diff([7, 2, 3, 4, 6]) == [2, 7, 5] def test_find_max_diff_single_element(): assert find_max_diff([3]) == [] def test_find_max_diff_empty_list(): assert find_max_diff([]) == [] def test_find_max_diff_all_negative_numbers(): assert find_max_diff([-1, -3, -4, -2, -5]) == [-5, -1, 4] def test_find_max_diff_mixed_sign_numbers(): assert find_max_diff([-1, 0, 1, -2, 2]) == [-2, 2, 4] def test_find_max_diff_duplicates(): assert find_max_diff([1, 1, 1, 1, 0]) == [0, 1, 1] def test_find_max_diff_large_numbers(): assert find_max_diff([1000000, 500000, -1000000]) == [-1000000, 1000000, 2000000]","solution":"def find_max_diff(lst): Returns the two numbers in ascending order that have the maximum difference along with their difference in a list. If the input list contains fewer than two elements, return an empty list. if len(lst) < 2: return [] min_num = min(lst) max_num = max(lst) max_diff = max_num - min_num return [min_num, max_num, max_diff]"},{"question":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def sum_of_powers_and_prime_check(number_string: str) -> bool: Calculate the sum of digits raised to the power of their positions. Check if the resulting sum is a prime number. >>> sum_of_powers_and_prime_check(\\"123\\") False >>> sum_of_powers_and_prime_check(\\"11\\") True >>> sum_of_powers_and_prime_check(\\"357\\") False >>> sum_of_powers_and_prime_check(\\"1001\\") True >>> sum_of_powers_and_prime_check(\\"57\\") False","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def sum_of_powers_and_prime_check(number_string): Calculate the sum of digits raised to the power of their positions. Check if the resulting sum is a prime number. total_sum = sum(int(digit) ** (index + 1) for index, digit in enumerate(number_string)) return is_prime(total_sum)"},{"question":"def longest_increasing_streak(temperatures: List[int]) -> int: Given a list of integers representing daily temperatures recorded over a period, find the longest streak of days with continuously increasing temperatures. If multiple streaks have the same length, return the longest streak that occurs first. If no such streak exists, return 0. >>> longest_increasing_streak([]) == 0 >>> longest_increasing_streak([70]) == 1 >>> longest_increasing_streak([70, 70, 70, 70]) == 1 >>> longest_increasing_streak([70, 69, 68, 67]) == 1 >>> longest_increasing_streak([60, 61, 62, 59, 58, 63, 64, 66, 65, 68, 70, 69]) == 4 >>> longest_increasing_streak([58, 59, 60, 61, 62, 50, 51, 55]) == 5 >>> longest_increasing_streak([58, 59, 60, 55, 56, 57, 54, 55, 56]) == 3 >>> longest_increasing_streak([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 >>> longest_increasing_streak([5, 3, 4, 6, 2, 9]) == 3 >>> longest_increasing_streak([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1 pass","solution":"def longest_increasing_streak(temperatures): if not temperatures: return 0 max_length = 0 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) # For the last streak return max_length"},{"question":"def find_pairs(nums: List[int], target: int) -> List[List[int]]: Returns a list of all unique pairs of values from nums whose sum is equal to target. Each pair is presented as a list, sorted in non-descending order, and the overall list of pairs is also sorted by the first element of each pair. >>> find_pairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([-1, 0, 1, 2, -2, -3], -1) [[-3, 2], [-2, 1], [-1, 0]] >>> find_pairs([3, 1, 4, 1, 5, 9, -2], 7) [[-2, 9], [3, 4]]","solution":"def find_pairs(nums, target): nums.sort() pairs = [] seen = set() for num in nums: complement = target - num if complement in seen: pairs.append([min(num, complement), max(num, complement)]) seen.add(num) pairs.sort() return pairs"},{"question":"def largest_number(nums): Given a list of non-negative integers, arrange them such that they form the largest possible number. >>> largest_number([3, 30, 34, 5, 9]) # \\"9534330\\" >>> largest_number([10, 2]) # \\"210\\" # Implement your solution here pass # Unit tests def test_single_digit_numbers(): assert largest_number([1, 2, 3, 4, 5, 6, 7, 8, 9]) == '987654321' def test_multiple_digits_numbers(): assert largest_number([3, 30, 34, 5, 9]) == '9534330' def test_zeros_and_ones(): assert largest_number([0, 0, 1, 1]) == '1100' def test_all_zeros(): assert largest_number([0, 0, 0]) == '0' def test_large_numbers(): assert largest_number([10, 2]) == '210' assert largest_number([999, 99, 9]) == '999999' def test_mix_large_and_small(): assert largest_number([432, 43243]) == '43243432' def test_duplicates(): assert largest_number([20, 20, 220]) == '2202020' def test_common_prefix(): assert largest_number([121, 12]) == '12121'","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of non-negative integers, arrange them such that they form the largest possible number. def compare(x, y): return 1 if x + y < y + x else -1 if x + y > y + x else 0 # Convert all integers to strings nums_str = list(map(str, nums)) # Sort numbers using custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join sorted numbers into a single string result = ''.join(nums_str) # Edge case for a bunch of zeros return '0' if result[0] == '0' else result"},{"question":"def isMountainArray(arr: List[int]) -> bool: Given an array of integers, determine whether the array is a perfect mountain array. An array is considered a perfect mountain if there is its peak element at index \`k\` (0 < k < n - 1), such that: - Elements strictly increase from the start of the array to the peak (\`arr[0] < arr[1] < ... < arr[k]\`). - Elements strictly decrease from the peak to the end of the array (\`arr[k] > arr[k+1] > ... > arr[n-1]\`). >>> isMountainArray([0, 2, 3, 4, 5, 2, 1, 0]) True >>> isMountainArray([0, 2, 3, 3, 5, 2, 1, 0]) False >>> isMountainArray([0, 1, 2, 3, 4, 5, 3, 3]) False >>> isMountainArray([5, 4, 3, 2, 1]) False from typing import List def test_isMountainArray(): assert isMountainArray([0, 2, 3, 4, 5, 2, 1, 0]) == True assert isMountainArray([0, 2, 3, 3, 5, 2, 1, 0]) == False assert isMountainArray([0, 1, 2, 3, 4, 5, 3, 3]) == False assert isMountainArray([5, 4, 3, 2, 1]) == False assert isMountainArray([1, 2, 3]) == False assert isMountainArray([3, 2, 1]) == False assert isMountainArray([1, 3, 2, 1]) == True assert isMountainArray([1, 2, 2, 3, 4]) == False assert isMountainArray([0, 1, 2, 1, 0]) == True assert isMountainArray([0, 2, 2, 0]) == False assert isMountainArray([]) == False assert isMountainArray([1, 2]) == False test_isMountainArray()","solution":"def isMountainArray(arr): n = len(arr) if n < 3: return False peak_index = 0 # Find the peak for i in range(1, n - 1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: peak_index = i break # not finding a peak means it's not a mountain array if peak_index == 0: return False # Check if strictly increasing to the peak for i in range(1, peak_index + 1): if arr[i] <= arr[i-1]: return False # Check if strictly decreasing from the peak for i in range(peak_index + 1, n): if arr[i] >= arr[i-1]: return False return True"},{"question":"def remove_repeats(input_string: str) -> str: Returns a string where all repeated characters in the input string are replaced by a single occurrence of that character. >>> remove_repeats('programming') 'progamin' >>> remove_repeats('aabccba') 'abc' >>> remove_repeats('hello world!') 'helo wrd!'","solution":"def remove_repeats(input_string): Returns a string where all repeated characters in the input string are replaced by a single occurrence of that character. Parameters: input_string (str): The input string. Returns: str: The processed string with repeated characters removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \\"\\".join(result)"},{"question":"def min_operations_to_all_ones(binary_strings): Calculate the minimal number of operations needed to transform a binary string into a string of all '1's. Parameters: binary_strings (list of str): A list of binary strings. Returns: list of int: A list containing the minimal number of operations for each binary string. >>> min_operations_to_all_ones([\\"00011\\", \\"010101\\", \\"11111\\"]) [1, 3, 0] >>> min_operations_to_all_ones([\\"1010\\", \\"110011\\", \\"001100\\"]) [2, 1, 2]","solution":"def min_operations_to_all_ones(binary_strings): Calculate the minimal number of operations needed to transform a binary string into a string of all '1's. Parameters: binary_strings (list of str): A list of binary strings. Returns: list of int: A list containing the minimal number of operations for each binary string. results = [] for binary_string in binary_strings: zeroblocks = 0 in_zero_block = False for char in binary_string: if char == '0': if not in_zero_block: zeroblocks += 1 in_zero_block = True else: in_zero_block = False results.append(zeroblocks) return results # Example of how the function can be used: # binary_strings = [\\"00011\\", \\"010101\\", \\"11111\\"] # print(min_operations_to_all_ones(binary_strings)) # Output: [1, 3, 0]"},{"question":"from typing import List def is_well_formed(s: str) -> bool: Determine if the string s is a well-formed sequence of parentheses. A well-formed sequence means each type of bracket has a corresponding and correctly ordered matching pair. >>> is_well_formed(\\"(){}[]\\") == True >>> is_well_formed(\\"[({})]\\") == True >>> is_well_formed(\\"([)]\\") == False >>> is_well_formed(\\"{[}\\") == False","solution":"def is_well_formed(s): Returns True if the string s is a well-formed sequence of parentheses, otherwise False. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if stack == [] or stack.pop() != matching_bracket[char]: return False return stack == []"},{"question":"def max_total_weight(W: int, weights: List[int]) -> int: Determine the maximum total weight that can be placed on the shelf without exceeding the capacity W. Args: W (int): Maximum weight the shelf can hold. weights (list of int): List of weights of the products. Returns: int: Maximum total weight that can be placed on the shelf without exceeding W. from typing import List def test_example_case(): assert max_total_weight(50, [10, 20, 30, 40, 50, 60]) == 50 def test_all_items_fit(): assert max_total_weight(100, [10, 20, 30, 40]) == 100 def test_no_items_fit(): assert max_total_weight(5, [10, 20, 30, 40, 50]) == 0 def test_multiple_items_fit(): assert max_total_weight(50, [10, 15, 20, 25, 30]) == 50 def test_single_item_can_take_all_space(): assert max_total_weight(30, [10, 30, 20, 5]) == 30 def test_with_different_weights(): assert max_total_weight(65, [5, 20, 30, 10, 25]) == 65","solution":"def max_total_weight(W, weights): Determine the maximum total weight that can be placed on the shelf without exceeding the capacity W. Args: W (int): Maximum weight the shelf can hold. weights (list of int): List of weights of the products. Returns: int: Maximum total weight that can be placed on the shelf without exceeding W. num_items = len(weights) dp = [0] * (W + 1) for weight in weights: for current_capacity in range(W, weight-1, -1): dp[current_capacity] = max(dp[current_capacity], dp[current_capacity - weight] + weight) return dp[W]"},{"question":"def find_subarray_with_given_sum(arr: List[int], target_sum: int) -> List[int]: Finds the first continuous subarray that sums up to the target_sum. >>> find_subarray_with_given_sum([1, 2, 3, 4, 5], 9) [2, 3, 4] >>> find_subarray_with_given_sum([1, 2, 3, 4, 5], 15) [1, 2, 3, 4, 5] >>> find_subarray_with_given_sum([1, 2, 3, 4, 5], 20) []","solution":"def find_subarray_with_given_sum(arr, target_sum): Finds the first continuous subarray that sums up to the target_sum. :param arr: List of integers :param target_sum: An integer representing the target sum :return: A subarray that sums up to the target_sum, else an empty array current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > target_sum and start <= end: current_sum -= arr[start] start += 1 if current_sum == target_sum: return arr[start:end + 1] return []"},{"question":"def balanced_splits(s: str) -> int: Determines the maximum number of times the string can be split into balanced substrings. Args: s (str): A string composed only of the characters 'R' and 'L'. Returns: int: The maximum number of balanced substrings. >>> balanced_splits(\\"RLRRLLRLRL\\") # Should return 4 >>> balanced_splits(\\"RLLLLRRRLR\\") # Should return 3 >>> balanced_splits(\\"LLLLRRRR\\") # Should return 1 >>> balanced_splits(\\"RLRRRLLRLL\\") # Should return 2","solution":"def balanced_splits(s): Determines the maximum number of times the string can be split into balanced substrings. Args: s (str): A string composed only of the characters 'R' and 'L'. Returns: int: The maximum number of balanced substrings. balance = 0 count = 0 for char in s: if char == 'R': balance += 1 elif char == 'L': balance -= 1 if balance == 0: count += 1 return count"},{"question":"from typing import List, Tuple def solve(n: int, values: List[int], edges: List[Tuple[int, int]]) -> List[int]: Calculate the sum of values of nodes along the path from the root node to each node in a binary tree. >>> solve(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) [1, 3, 4, 7, 8] >>> solve(3, [2, 1, 4], [(1, 2), (1, 3)]) [2, 3, 6] >>> solve(1, [5], []) [5] >>> solve(2, [10, 20], [(1, 2)]) [10, 30] >>> solve(4, [10000, 9999, 9998, 9997], [(1, 2), (1, 3), (2, 4)]) [10000, 19999, 19998, 29996]","solution":"def path_sums(n, values, edges): from collections import defaultdict, deque # Create adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Initialize sum array with None path_sum = [None] * (n + 1) path_sum[1] = values[0] # BFS to calculate the path sums queue = deque([1]) while queue: current = queue.popleft() for neighbor in tree[current]: if path_sum[neighbor] is None: path_sum[neighbor] = path_sum[current] + values[neighbor - 1] queue.append(neighbor) # Ignore the zeroth index as nodes are numbered from 1 to n return path_sum[1:] # Function to parse the inputs and return the results def solve(n, values, edges): return path_sums(n, values, edges)"},{"question":"def prime_factors(n: int) -> list: Write a function that takes a positive integer \`n\` and returns a list of all unique prime factors of \`n\` in ascending order. >>> prime_factors(28) # returns [2, 7] >>> prime_factors(44) # returns [2, 11] >>> prime_factors(13) # returns [13] pass # Test cases def test_prime_factors_with_prime_number(): assert prime_factors(13) == [13] def test_prime_factors_with_composite_number(): assert prime_factors(28) == [2, 7] assert prime_factors(44) == [2, 11] def test_prime_factors_with_multiple_same_primes(): assert prime_factors(64) == [2] def test_prime_factors_with_different_primes(): assert prime_factors(30) == [2, 3, 5] def test_prime_factors_input_validation(): import pytest with pytest.raises(ValueError, match=\\"Input must be a positive integer greater than 1\\"): prime_factors(-10) with pytest.raises(ValueError, match=\\"Input must be a positive integer greater than 1\\"): prime_factors(0) with pytest.raises(ValueError, match=\\"Input must be a positive integer greater than 1\\"): prime_factors(1) with pytest.raises(ValueError, match=\\"Input must be a positive integer greater than 1\\"): prime_factors(1.5) with pytest.raises(ValueError, match=\\"Input must be a positive integer greater than 1\\"): prime_factors(\\"string\\")","solution":"def prime_factors(n: int) -> list: Returns a list of unique prime factors of n in ascending order. if not isinstance(n, int) or n <= 1: raise ValueError(\\"Input must be a positive integer greater than 1\\") factors = [] divisor = 2 while n > 1: if n % divisor == 0: if divisor not in factors: factors.append(divisor) n //= divisor else: divisor += 1 return factors"},{"question":"def doubleVowels(input_str): Returns a new string where all vowel occurrences have been doubled. Parameters: - input_str (str): The input string to process. Returns: - str: The modified string with doubled vowels, or -1 for non-string or empty string input. # Test cases def test_double_vowels_with_vowels(): assert doubleVowels(\\"hello\\") == \\"heelloo\\" assert doubleVowels(\\"world\\") == \\"woorld\\" def test_double_vowels_no_vowels(): assert doubleVowels(\\"gym\\") == \\"gym\\" def test_double_vowels_Empty_String(): assert doubleVowels(\\"\\") == -1 def test_double_vowels_non_string_input(): assert doubleVowels(None) == -1 assert doubleVowels(123) == -1 assert doubleVowels([]) == -1 def test_double_vowels_mixed_case(): assert doubleVowels(\\"AeIoU\\") == \\"AAeeIIooUU\\" def test_double_vowels_with_numbers_and_symbols(): assert doubleVowels(\\"hello123\\") == \\"heelloo123\\" assert doubleVowels(\\"world!\\") == \\"woorld!\\"","solution":"def doubleVowels(input_str): Returns a new string where all vowel occurrences have been doubled. Parameters: - input_str (str): The input string to process. Returns: - str: The modified string with doubled vowels, or -1 for non-string or empty string input. if not isinstance(input_str, str) or input_str == \\"\\": return -1 vowels = \\"aeiouAEIOU\\" result = [] for char in input_str: if char in vowels: result.append(char * 2) else: result.append(char) return ''.join(result)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_element(root, k): Returns the k-th smallest element in the BST. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest_element(root, 1) 1 >>> kth_smallest_element(root, 2) 2 >>> kth_smallest_element(root, 3) 3 >>> kth_smallest_element(root, 4) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_element(root, k): Returns the k-th smallest element in the BST. def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) sorted_elements = in_order_traversal(root) return sorted_elements[k - 1]"},{"question":"from typing import List, Tuple import math def classify_points(x_center: float, y_center: float, radius: float, points: List[Tuple[float, float]]) -> Tuple[List[Tuple[float, float]], List[Tuple[float, float]], List[Tuple[float, float]]]: Classify points based on their relationship to a circle. Parameters: x_center (float): x-coordinate of the circle's center y_center (float): y-coordinate of the circle's center radius (float): radius of the circle points (list of tuples): list of points to classify, each represented as a tuple (x, y) Returns: tuple: A tuple of three lists: - List of points inside the circle - List of points on the circumference of the circle - List of points outside the circle >>> classify_points(0.0, 0.0, 1.0, [(0.0, 0.0), (1.0, 0.0), (0.5, 0.5), (2.0, 2.0)]) ([(0.0, 0.0), (0.5, 0.5)], [(1.0, 0.0)], [(2.0, 2.0)]) >>> classify_points(0.0, 0.0, 1.0, [(0.0, 0.0), (0.0, 1.0), (2.0, 0.0)]) ([(0.0, 0.0)], [(0.0, 1.0)], [(2.0, 0.0)]) pass","solution":"import math def classify_points(x_center, y_center, radius, points): Classify points based on their relationship to a circle. Parameters: x_center (float): x-coordinate of the circle's center y_center (float): y-coordinate of the circle's center radius (float): radius of the circle points (list of tuples): list of points to classify, each represented as a tuple (x, y) Returns: tuple: A tuple of three lists: - List of points inside the circle - List of points on the circumference of the circle - List of points outside the circle if radius <= 0: raise ValueError(\\"Radius must be a positive number\\") epsilon = 1e-7 inside = [] on_circumference = [] outside = [] for (x, y) in points: distance = math.hypot(x - x_center, y - y_center) if distance < radius - epsilon: inside.append((x, y)) elif abs(distance - radius) <= epsilon: on_circumference.append((x, y)) else: outside.append((x, y)) return inside, on_circumference, outside"},{"question":"def spiralOrder(matrix): Given a matrix of m x n elements (m rows, n columns), return the elements of the matrix in spiral order. >>> spiralOrder([ ... [ 1, 2, 3 ], ... [ 4, 5, 6 ], ... [ 7, 8, 9 ] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] from solution import spiralOrder def test_spiral_empty_matrix(): assert spiralOrder([]) == [] def test_spiral_single_element(): assert spiralOrder([[1]]) == [1] def test_spiral_single_row(): mat = [[1, 2, 3, 4]] assert spiralOrder(mat) == [1, 2, 3, 4] def test_spiral_single_column(): mat = [[1], [2], [3], [4]] assert spiralOrder(mat) == [1, 2, 3, 4] def test_spiral_3x3_matrix(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert spiralOrder(mat) == [1, 2, 3, 6, 9, 8, 7, 4, 5] def test_spiral_3x4_matrix(): mat = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] assert spiralOrder(mat) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] def test_spiral_4x4_matrix(): mat = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert spiralOrder(mat) == [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]","solution":"def spiralOrder(matrix): if not matrix: return [] result = [] m, n = len(matrix), len(matrix[0]) top, bottom, left, right = 0, m - 1, 0, n - 1 while top <= bottom and left <= right: for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def min_shifts_to_bottom_right(t: int, cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determine the minimum number of shifts required to move all items from the top-left cell to the bottom-right cell in a warehouse grid. Args: t (int): The number of test cases. cases (List[Tuple[int, int, List[List[int]]]]): A list containing the test cases. Each test case is a tuple with the number of rows (M), number of columns (N), and the grid of items. Returns: List[int]: A list containing the minimum number of shifts required for each test case. >>> min_shifts_to_bottom_right(1, [(2, 2, [[1, 2], [3, 4]])]) [10] >>> min_shifts_to_bottom_right(1, [(3, 2, [[1, 2], [3, 4], [5, 6]])]) [21]","solution":"def min_shifts_to_bottom_right(t, cases): results = [] for case in cases: M, N, grid = case total_items = sum(sum(row) for row in grid) results.append(total_items) return results # Example cases t = 2 cases = [ (2, 2, [ [1, 2], [3, 4] ]), (3, 2, [ [1, 2], [3, 4], [5, 6] ]) ] print(min_shifts_to_bottom_right(t, cases))"},{"question":"def sum_positive_numbers(numbers: List[int]) -> int: Create a function that takes a list of integers and returns the sum of all positive numbers in the list. If the list contains no positive numbers, the function should return 0. >>> sum_positive_numbers([3, 5, 2]) 10 >>> sum_positive_numbers([3, -1, 5, -9, 2]) 10 >>> sum_positive_numbers([-3, -1, -5, -9]) 0 >>> sum_positive_numbers([]) 0","solution":"def sum_positive_numbers(numbers): Returns the sum of all positive numbers in the list. If the list contains no positive numbers, returns 0. return sum(num for num in numbers if num > 0)"},{"question":"def distinct_squared_sorted(arr): This function takes a list of integers, computes the number of distinct integers, and returns a sorted list of their squared values. :param arr: List[int] - List of integers. :return: (int, List[int]) - Number of distinct integers and list of squared values sorted. def format_output(n, squared_values): This function formats the output strings for the number of distinct integers and their squared values. :param n: int - Number of distinct integers. :param squared_values: List[int] - Squared values sorted. :return: (str, str) - Output strings. # Helper function to directly use the main functionality def process_integers(n, arr): This function processes the input list of integers and provides the formatted output for the number of distinct integers and their sorted squares. :param n: int - Number of integers. :param arr: List[int] - List of integers. :return: (str, str) - Distinct count and sorted squared values as strings. def test_distinct_squared_sorted_example_case(): arr = [1, -2, 3, -2, 4] expected_count = 4 expected_squares = [1, 4, 9, 16] assert distinct_squared_sorted(arr) == (expected_count, expected_squares) def test_distinct_squared_sorted_single_element(): arr = [5] expected_count = 1 expected_squares = [25] assert distinct_squared_sorted(arr) == (expected_count, expected_squares) def test_distinct_squared_sorted_all_duplicates(): arr = [2, 2, 2, 2] expected_count = 1 expected_squares = [4] assert distinct_squared_sorted(arr) == (expected_count, expected_squares) def test_distinct_squared_sorted_all_negatives(): arr = [-1, -2, -3, -4, -5] expected_count = 5 expected_squares = [1, 4, 9, 16, 25] assert distinct_squared_sorted(arr) == (expected_count, expected_squares) def test_format_output_case(): n = 4 squared_values = [1, 4, 9, 16] expected_output = (\\"4\\", \\"1 4 9 16\\") assert format_output(n, squared_values) == expected_output def test_process_integers_example_case(): n = 5 arr = [1, -2, 3, -2, 4] expected_output = (\\"4\\", \\"1 4 9 16\\") assert process_integers(n, arr) == expected_output","solution":"def distinct_squared_sorted(arr): This function takes a list of integers, computes the number of distinct integers, and returns a sorted list of their squared values. :param arr: List[int] - List of integers. :return: (int, List[int]) - Number of distinct integers and list of squared values sorted. distinct_integers = set(arr) squared_values = sorted([x**2 for x in distinct_integers]) return len(distinct_integers), squared_values def format_output(n, squared_values): This function formats the output strings for the number of distinct integers and their squared values. :param n: int - Number of distinct integers. :param squared_values: List[int] - Squared values sorted. :return: (str, str) - Output strings. distinct_count_str = str(n) squared_values_str = ' '.join(map(str, squared_values)) return distinct_count_str, squared_values_str # Helper function to directly use the main functionality def process_integers(n, arr): This function processes the input list of integers and provides the formatted output for the number of distinct integers and their sorted squares. :param n: int - Number of integers. :param arr: List[int] - List of integers. :return: (str, str) - Distinct count and sorted squared values as strings. distinct_count, squared_values = distinct_squared_sorted(arr) return format_output(distinct_count, squared_values)"},{"question":"def find_shortest_word_length(s: str) -> int: Write a function that takes a string consisting of words separated by spaces and returns the length of the shortest word in the string. The input string will not contain leading or trailing spaces, and there will always be at least one word. >>> find_shortest_word_length(\\"I love programming\\") 1 >>> find_shortest_word_length(\\"Coding is fun and educational\\") 2 >>> find_shortest_word_length(\\"Hello\\") 5 >>> find_shortest_word_length(\\"dog cat bat rat\\") 3 >>> find_shortest_word_length(\\"a quick brown fox\\") 1 >>> find_shortest_word_length(\\"the quick brown fox jumps over the lazy dog\\") 3","solution":"def find_shortest_word_length(s): Returns the length of the shortest word in the string s. words = s.split() return min(len(word) for word in words)"},{"question":"def calc_tools(dirt_blocks): Calculate the minimum amount of tools Steve needs to remove a specified number of dirt blocks. This function should return a dictionary of the form {\\"wooden_shovel\\": 2, \\"stone_shovel\\": 1, \\"iron_shovel\\": 0, \\"diamond_shovel\\": 0} >>> calc_tools(200) {\\"wooden_shovel\\": 20, \\"stone_shovel\\": 0, \\"iron_shovel\\": 0, \\"diamond_shovel\\": 0} >>> calc_tools(0) {\\"wooden_shovel\\": 0, \\"stone_shovel\\": 0, \\"iron_shovel\\": 0, \\"diamond_shovel\\": 0} >>> calc_tools(20) {\\"wooden_shovel\\": 2, \\"stone_shovel\\": 0, \\"iron_shovel\\": 0, \\"diamond_shovel\\": 0} >>> calc_tools(1661) {\\"wooden_shovel\\": 0, \\"stone_shovel\\": 0, \\"iron_shovel\\": 1, \\"diamond_shovel\\": 1} >>> calc_tools(5) {\\"wooden_shovel\\": 1, \\"stone_shovel\\": 0, \\"iron_shovel\\": 0, \\"diamond_shovel\\": 0} >>> calc_tools(-5) {\\"wooden_shovel\\": 0, \\"stone_shovel\\": 0, \\"iron_shovel\\": 0, \\"diamond_shovel\\": 0}","solution":"def calc_tools(dirt_blocks): Calculates the minimum amount of tools needed to remove the specified number of dirt blocks. Returns a dictionary with the number of each type of tool needed. total_dirt_blocks = dirt_blocks tools = { \\"diamond_shovel\\": 0, \\"iron_shovel\\": 0, \\"stone_shovel\\": 0, \\"wooden_shovel\\": 0, } if total_dirt_blocks <= 0: return tools # Diamond Shovel: 1561 uses if total_dirt_blocks > 0: tools[\\"diamond_shovel\\"] = total_dirt_blocks // 1561 total_dirt_blocks %= 1561 # Iron Shovel: 100 uses if total_dirt_blocks > 0: tools[\\"iron_shovel\\"] = total_dirt_blocks // 100 total_dirt_blocks %= 100 # Stone Shovel: 50 uses if total_dirt_blocks > 0: tools[\\"stone_shovel\\"] = total_dirt_blocks // 50 total_dirt_blocks %= 50 # Wooden Shovel: 10 uses if total_dirt_blocks > 0: tools[\\"wooden_shovel\\"] = total_dirt_blocks // 10 total_dirt_blocks %= 10 if total_dirt_blocks > 0: tools[\\"wooden_shovel\\"] += 1 return tools"},{"question":"def first_unique_character(s: str) -> int: Determines the first unique character in a given string. A unique character is a character that appears exactly once in the string. Returns the index of the first unique character, or -1 if there are no unique characters. >>> first_unique_character(\\"leetcode\\") == 0 >>> first_unique_character(\\"loveleetcode\\") == 2 >>> first_unique_character(\\"aabbcc\\") == -1","solution":"def first_unique_character(s: str) -> int: Returns the index of the first unique character in a given string \`s\`. If there are no unique characters, returns -1. # Dictionary to store the count of each character char_count = {} # First pass to count all characters for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"def factorial_trailing_zeros(n: int) -> int: Calculate the number of trailing zeros in the factorial of n. :param n: non-negative integer representing the number to calculate the factorial trailing zeros for. :return: integer count of trailing zeros in n! >>> factorial_trailing_zeros(5) # returns 1 because 5! = 120 has 1 trailing zero >>> factorial_trailing_zeros(10) # returns 2 because 10! = 3628800 has 2 trailing zeros >>> factorial_trailing_zeros(20) # returns 4 because 20! = 2432902008176640000 has 4 trailing zeros","solution":"def factorial_trailing_zeros(n): Calculate the number of trailing zeros in the factorial of n. :param n: non-negative integer representing the number to calculate the factorial trailing zeros for. :return: integer count of trailing zeros in n! count = 0 base = 5 while n >= base: count += n // base base *= 5 return count"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determine if the given strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False from solution import are_anagrams def test_anagrams_simple(): assert are_anagrams(\\"listen\\", \\"silent\\") == True def test_not_anagrams_simple(): assert are_anagrams(\\"hello\\", \\"billion\\") == False def test_anagrams_with_repeated_chars(): assert are_anagrams(\\"aabbcc\\", \\"baccab\\") == True def test_not_anagrams_different_lengths(): assert are_anagrams(\\"abc\\", \\"abca\\") == False def test_anagrams_single_chars(): assert are_anagrams(\\"a\\", \\"a\\") == True def test_not_anagrams_same_lengths(): assert are_anagrams(\\"abc\\", \\"def\\") == False def test_anagrams_palindromes(): assert are_anagrams(\\"civic\\", \\"vicic\\") == True","solution":"def are_anagrams(str1, str2): Returns True if str1 and str2 are anagrams, else returns False. return sorted(str1) == sorted(str2)"},{"question":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using an iterative approach. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55","solution":"def fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def can_convert(s: str, t: str) -> bool: Checks if it is possible to convert string s to t using a sequence of the allowed operations. Args: s (str): The initial string. t (str): The target string. Returns: bool: True if it is possible to convert s to t using the allowed operations, False otherwise. Examples: >>> can_convert(\\"\\", \\"abc\\") True >>> can_convert(\\"abc\\", \\"ab\\") True >>> can_convert(\\"abc\\", \\"def\\") False >>> can_convert(\\"abc\\", \\"abc\\") True >>> can_convert(\\"abc\\", \\"abcd\\") True >>> can_convert(\\"abcd\\", \\"abc\\") True >>> can_convert(\\"a\\", \\"aaaaa\\") True >>> can_convert(\\"abc\\", \\"abx\\") False","solution":"def can_convert(s, t): Checks if it is possible to convert string s to t using a sequence of the allowed operations. Args: s (str): The initial string. t (str): The target string. Returns: bool: True if it is possible to convert s to t using the allowed operations, False otherwise. if s == t: return True # Check for the possibility of conversion if len(s) <= len(t) and t.startswith(s): return True if len(s) > len(t) and s.startswith(t): return True return False"},{"question":"from typing import List def longest_increasing_subsequence(nums: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the given list of integers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([10, 20]) 2 >>> longest_increasing_subsequence([20, 10]) 1 >>> longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) 4 >>> longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6 >>> longest_increasing_subsequence([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) 6 >>> longest_increasing_subsequence([1, 1, 1, 1]) 1 >>> longest_increasing_subsequence([1, 2, 1, 2]) 2","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest strictly increasing subsequence in the given list of integers. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_oldest_and_youngest(people: List[Tuple[str, int]]) -> Tuple[str, str]: Returns the oldest and youngest person's names from the list. Parameters: - people: A list of tuples where each tuple contains a name (string) and birth year (int) Returns: - A tuple containing two elements: the name of the oldest person and the name of the youngest person Example: >>> find_oldest_and_youngest([(\\"Alice\\", 1986)]) (\\"Alice\\", \\"Alice\\") >>> find_oldest_and_youngest([(\\"Alice\\", 1986), (\\"Bob\\", 1978)]) (\\"Bob\\", \\"Alice\\") >>> find_oldest_and_youngest([(\\"Alice\\", 1986), (\\"Bob\\", 1978), (\\"Charlie\\", 1990), (\\"David\\", 1983)]) ('Bob', 'Charlie')","solution":"def find_oldest_and_youngest(people): Returns the oldest and youngest person's names from the list. Parameters: - people: A list of tuples where each tuple contains a name (string) and birth year (int) Returns: - A tuple containing two elements: the name of the oldest person and the name of the youngest person # Initialize variables to store the names and corresponding birth years of the oldest and youngest person oldest_person = people[0] youngest_person = people[0] # iterate through the list to find the oldest and youngest based on birth year for person in people: if person[1] < oldest_person[1]: oldest_person = person if person[1] > youngest_person[1]: youngest_person = person return (oldest_person[0], youngest_person[0])"},{"question":"def deep_sum(nested_list): Returns the sum of all integers in the nested list. Args: nested_list (list): A list containing integers or other nested lists. Returns: int: The sum of all integers in the nested list. Examples: >>> deep_sum([[1, 2, [3, 4]], [5, 6], 7]) 28 >>> deep_sum([1, [2, [3, 4]], 5]) 15 >>> deep_sum([1, 2, 3, 4]) 10 >>> deep_sum([]) 0","solution":"def deep_sum(nested_list): Returns the sum of all integers in the nested list. Args: nested_list (list): A list containing integers or other nested lists. Returns: int: The sum of all integers in the nested list. total = 0 for element in nested_list: if isinstance(element, list): total += deep_sum(element) else: total += element return total"},{"question":"def sum_of_squared_digits(n: int) -> int: Write a function that takes an integer as input and returns the sum of all the digits of the squared value of that number. >>> sum_of_squared_digits(12) 9 >>> sum_of_squared_digits(0) 0 >>> sum_of_squared_digits(-12) 9","solution":"def sum_of_squared_digits(n): Returns the sum of all the digits of the squared value of the input integer. squared_value = n ** 2 return sum(int(digit) for digit in str(squared_value))"},{"question":"def sum_pairs(arr: List[int], target_sum: int) -> Union[Tuple[int, int], None]: Returns the first pair of numbers in the array that adds up to the target_sum as a tuple (a, b). If no such pair exists, returns None. >>> sum_pairs([10, 5, 2, 3, 7, 5], 10) (3, 7) >>> sum_pairs([11, 3, 7, 5], 10) (3, 7) >>> sum_pairs([1, 4, 8, 7, 3, 15], 11) (4, 7) >>> sum_pairs([1, -2, 3, 0, -6, 1], -6) (0, -6) >>> sum_pairs([20, -13, 40], -7) None","solution":"def sum_pairs(arr, target_sum): Returns the first pair of numbers in the array that adds up to the target_sum as a tuple (a, b). If no such pair exists, returns None. seen = set() for number in arr: complement = target_sum - number if complement in seen: return (complement, number) seen.add(number) return None"},{"question":"def letter_positions(s: str) -> dict: Takes a string consisting of lowercase and uppercase alphabets and returns a dictionary where the keys are the positions of each variation of each letter in the original string, and the values are the corresponding letters. >>> letter_positions(\\"aAbBccCa\\") {0: 'a', 1: 'A', 2: 'b', 3: 'B', 4: 'c', 5: 'c', 6: 'C', 7: 'a'} >>> letter_positions(\\"xyzXYZ\\") {0: 'x', 1: 'y', 2: 'z', 3: 'X', 4: 'Y', 5: 'Z'} pass","solution":"def letter_positions(s): Takes a string consisting of lowercase and uppercase alphabets and returns a dictionary where the keys are the positions of each variation of each letter in the original string, and the values are the corresponding letters. return {i: char for i, char in enumerate(s)}"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def sum_of_depths(self): return self._sum_of_depths(self.root, 0) def _sum_of_depths(self, node, depth): if node is None: return 0 return depth + self._sum_of_depths(node.left, depth + 1) + self._sum_of_depths(node.right, depth + 1) def sum_of_depths(lst): Constructs a BST from the given list of integers and calculates the sum of depths of all nodes. Args: lst (List[int]): List of integers Returns: int: Sum of depths of all nodes in the BST >>> sum_of_depths([3, 2, 5, 1, 4]) 6 >>> sum_of_depths([10]) 0 >>> sum_of_depths([5, 3]) 1 >>> sum_of_depths([5, 7]) 1 >>> sum_of_depths([1, 2, 3, 4, 5]) 10 >>> sum_of_depths([5, 4, 3, 2, 1]) 10 >>> sum_of_depths([4, 2, 6, 1, 3, 5, 7]) 10 bst = BST() for val in lst: bst.insert(val) return bst.sum_of_depths()","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def sum_of_depths(self): return self._sum_of_depths(self.root, 0) def _sum_of_depths(self, node, depth): if node is None: return 0 return depth + self._sum_of_depths(node.left, depth + 1) + self._sum_of_depths(node.right, depth + 1) def sum_of_depths(lst): bst = BST() for val in lst: bst.insert(val) return bst.sum_of_depths()"},{"question":"from typing import List def length_of_LIS(sequence: List[int]) -> int: Returns the length of the longest increasing subsequence in the given sequence. :param sequence: List of integers representing the yields. :return: An integer representing the length of the longest increasing subsequence. >>> length_of_LIS([10, 22, 9, 33, 21, 50, 41]) 4 >>> length_of_LIS([1, 2, 3, 4, 5]) 5 >>> length_of_LIS([10, 9, 8, 7, 6, 5]) 1 >>> length_of_LIS([5, 1, 6, 2, 7, 3, 8, 4]) 4 >>> length_of_LIS([]) 0 >>> length_of_LIS([10]) 1","solution":"def length_of_LIS(sequence): Returns the length of the longest increasing subsequence in the given sequence. :param sequence: List of integers representing the yields. :return: An integer representing the length of the longest increasing subsequence. if not sequence: return 0 from bisect import bisect_left lis = [] for yield_value in sequence: pos = bisect_left(lis, yield_value) if pos == len(lis): lis.append(yield_value) else: lis[pos] = yield_value return len(lis)"},{"question":"def elements_more_than_n(lst: List[int], n: int) -> List[int]: Returns a list of elements that appear more than \`n\` times in the input list \`lst\`. The order of the elements in the returned list is the same as their first occurrence in the input list. Parameters: - lst: List of integers - n: Integer threshold for minimum number of occurrences Returns: - A list of integers >>> elements_more_than_n([4, 5, 6, 7, 5, 6, 5, 6, 6, 7], 2) [5, 6] >>> elements_more_than_n([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> elements_more_than_n([1, 1, 1, 2, 2, 3], 1) [1, 2] >>> elements_more_than_n([1, 2, 3, 4, 5], 1) [] >>> elements_more_than_n([10, 20, 10, 20, 10, 30, 30, 30], 2) [10, 30]","solution":"def elements_more_than_n(lst, n): Returns a list of elements that appear more than \`n\` times in the input list \`lst\`. The order of the elements in the returned list is the same as their first occurrence in the input list. Parameters: - lst: List of integers - n: Integer threshold for minimum number of occurrences Returns: - A list of integers from collections import Counter # Count the occurrences of each element count = Counter(lst) # Find elements that appear more than \`n\` times result = [] seen = set() for element in lst: if count[element] > n and element not in seen: result.append(element) seen.add(element) return result"},{"question":"def format_text(text: str, line_width: int) -> list: Formats the input text into lines with the specified maximum line width. Args: text (str): The block of text to be formatted. line_width (int): The maximum width of each line. Returns: list of str: A list of formatted lines. >>> format_text(\\"The quick brown fox jumps over the lazy dog\\", 10) ['The quick', 'brown fox', 'jumps over', 'the lazy', 'dog'] >>> format_text(\\"The quick brown fox jumps over the lazy dog\\", 15) ['The quick brown', 'fox jumps over', 'the lazy dog'] >>> format_text(\\"The quick brown fox\\", 5) ['The', 'quick', 'brown', 'fox'] >>> format_text(\\"The quick brown fox\\", 16) ['The quick brown', 'fox'] >>> format_text(\\"antidisestablishmentarianism\\", 10) ['antidisestablishmentarianism'] >>> format_text(\\"supercalifragilisticexpialidocious pseudopseudohypoparathyroidism\\", 15) ['supercalifragilisticexpialidocious', 'pseudopseudohypoparathyroidism']","solution":"def format_text(text, line_width): Formats the input text into lines with the specified maximum line width. Args: text (str): The block of text to be formatted. line_width (int): The maximum width of each line. Returns: list of str: A list of formatted lines. words = text.split() lines = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > line_width: if current_line: lines.append(\\" \\".join(current_line)) current_line = [word] current_length = len(word) else: current_line.append(word) current_length += len(word) if current_line: lines.append(\\" \\".join(current_line)) return lines"},{"question":"from typing import List def rotateArray(arr: List[int], k: int) -> List[int]: Rotates the elements of the array to the right by k steps. >>> rotateArray([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotateArray([1, 2, 3, 4, 5, 6], 3) [4, 5, 6, 1, 2, 3] # Example Usage # rotateArray([1, 2, 3, 4, 5], 2) should return [4, 5, 1, 2, 3] # rotateArray([1, 2, 3, 4, 5, 6], 3) should return [4, 5, 6, 1, 2, 3] # Unit Tests def test_rotateArray_basic(): assert rotateArray([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotateArray([1, 2, 3, 4, 5, 6], 3) == [4, 5, 6, 1, 2, 3] def test_rotateArray_large_k(): assert rotateArray([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] # 7 % 5 = 2 assert rotateArray([1, 2, 3, 4, 5, 6], 8) == [5, 6, 1, 2, 3, 4] # 8 % 6 = 2 def test_rotateArray_edge_cases(): assert rotateArray([], 3) == [] assert rotateArray([1], 3) == [1] assert rotateArray([1, 2, 3], 0) == [1, 2, 3] assert rotateArray([1, 2, 3], 3) == [1, 2, 3] # Because 3 % 3 = 0, it remains unchanged def test_rotateArray_no_rotation_needed(): assert rotateArray([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] # k = length of the array -> no change def test_rotateArray_single_element(): assert rotateArray([1], 0) == [1] assert rotateArray([1], 1) == [1] assert rotateArray([1], 2) == [1] def test_rotateArray_same_elements(): assert rotateArray([5, 5, 5, 5], 2) == [5, 5, 5, 5]","solution":"def rotateArray(arr, k): Rotates the elements of the array to the right by k steps. if not arr: return arr n = len(arr) k = k % n # To handle cases where k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"def generate_pascals_triangle(n: int): Generates Pascal's Triangle up to n rows. Args: n (int): Number of rows of Pascal's Triangle to generate. Returns: List[List[int]]: Pascal's Triangle. >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> generate_pascals_triangle(6) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]]","solution":"def generate_pascals_triangle(n): Generates Pascal's Triangle up to n rows. Args: n (int): Number of rows of Pascal's Triangle to generate. Returns: List[List[int]]: Pascal's Triangle. if n <= 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"def has_session_expired(lastActivity: int, timeout: int, currentTime: int) -> bool: Check if a session has expired based on the last activity timestamp and the timeout duration in minutes. Parameters: lastActivity (int): Unix timestamp of the last activity timeout (int): Timeout duration in minutes currentTime (int): Current Unix timestamp Returns: bool: True if session has expired, False otherwise >>> has_session_expired(1622540000, 30, 1622540800) False >>> has_session_expired(1622540000, 30, 1622541800) True >>> has_session_expired(1622540000, 30, 1622543600) True >>> has_session_expired(1622540000, 30, 1622541799) False >>> has_session_expired(1622540000, 60, 1622543000) False >>> has_session_expired(1622540000, 1, 1622540060) True","solution":"def has_session_expired(lastActivity, timeout, currentTime): Returns True if the session has expired based on the last activity timestamp and the timeout duration in minutes, otherwise False. Parameters: lastActivity (int): Unix timestamp of the last activity timeout (int): Timeout duration in minutes currentTime (int): Current Unix timestamp Returns: bool: True if session has expired, False otherwise timeout_seconds = timeout * 60 expired = (currentTime - lastActivity) >= timeout_seconds return expired"},{"question":"def common_elements(list1: List[int], list2: List[int]) -> List[int]: Given two lists of integers, return a new list that contains only the elements that are present in both input lists (\`list1\` and \`list2\`). The elements in the resulting list should maintain their order of appearance as they do in \`list1\`. >>> common_elements([1, 2, 3, 4, 5], [4, 3, 5, 1]) [1, 3, 4, 5] >>> common_elements([7, 8, 2, 3, 7], [7, 2, 2, 8]) [7, 8, 2, 7] >>> common_elements([5, 1, 2], [3, 6, 9]) []","solution":"def common_elements(list1, list2): Returns a list of elements that are present in both list1 and list2, maintaining the order of appearance in list1. result = [] set_list2 = set(list2) for element in list1: if element in set_list2: result.append(element) return result"},{"question":"def max_product_of_three(nums: List[int]) -> int: Write a function that takes a list of integers and returns the greatest product of any three integers in the list. >>> max_product_of_three([1, 10, 3, 5, 2]) 150 >>> max_product_of_three([-10, -10, 1, 3, 2]) 300 >>> max_product_of_three([-1, -2, -3, -4, -5]) -6 >>> max_product_of_three([-10, -10, 1, 0, 3, 2]) 300 >>> max_product_of_three([1, 2, 3]) 6 >>> max_product_of_three([-1000, -998, 1, 200, 300]) 299400000 >>> max_product_of_three([1, 6, 5, 6, 3, 2, 6]) 216 # Your code here","solution":"def max_product_of_three(nums): nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def max_items_with_bids(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Calculate the maximum number of items that can receive at least one bid for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): A list of test cases. Each test case is a tuple containing: - n (int): The number of items. - m (int): The number of bidders. - List of bidders' preferences. Each preference is a list of integers. Returns: List[int]: A list containing the maximum number of items receiving at least one bid for each test case. >>> max_items_with_bids(2, [(3, 3, [[1, 2], [2, 3], [1]]), (4, 4, [[1], [2], [3], [4]])]) [3, 4] >>> max_items_with_bids(1, [(3, 3, [[1, 2], [1], [1]])]) [2] >>> max_items_with_bids(1, [(5, 1, [[1, 3, 5]])]) [3] >>> max_items_with_bids(1, [(4, 0, [])]) [0]","solution":"def max_items_with_bids(T, test_cases): results = [] for case in test_cases: n, m, bidders = case item_count = [0] * (n + 1) for bidder in bidders: for item in bidder: item_count[item] += 1 max_bids = sum(1 for count in item_count[1:] if count > 0) results.append(max_bids) return results # Input Parsing Function def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n, m = map(int, lines[index].strip().split()) index += 1 bidders = [] for __ in range(m): parts = list(map(int, lines[index].strip().split())) bidders.append(parts[1:]) index += 1 test_cases.append((n, m, bidders)) return T, test_cases"},{"question":"class MovieRatings: A class to store and retrieve movie ratings. Methods: addRating(movieTitle: str, rating: float): Adds a rating for the specified movie. getRating(movieTitle: str): Returns the average rating of the specified movie. getTopRatedMovies(N: int): Returns the top N rated movies. def __init__(self): Initializes a new instance of MovieRatings with no initial movie ratings. pass def addRating(self, movieTitle: str, rating: float): Updates the rating for the given movie title, allowing multiple ratings for a single title. Args: movieTitle: The title of the movie. rating: The rating to add for the movie. pass def getRating(self, movieTitle: str): Returns the average rating for the given movie title, or None if there are no ratings yet for that movie. Args: movieTitle: The title of the movie. pass def getTopRatedMovies(self, N: int): Returns the titles of the top N movies sorted by their average ratings in descending order. If there are multiple movies with the same average rating, return them in lexicographical order. Args: N: The number of top rated movies to return. pass # Example usage # movieRatings = MovieRatings() # movieRatings.addRating(\\"Inception\\", 4.8) # movieRatings.addRating(\\"Inception\\", 4.6) # movieRatings.addRating(\\"Interstellar\\", 4.9) # movieRatings.addRating(\\"Interstellar\\", 5.0) # movieRatings.addRating(\\"Dunkirk\\", 4.2) # print(movieRatings.getRating(\\"Inception\\")) # returns 4.7 # print(movieRatings.getRating(\\"Interstellar\\")) # returns 4.95 # print(movieRatings.getRating(\\"Dunkirk\\")) # returns 4.2 # print(movieRatings.getTopRatedMovies(2)) # returns [\\"Interstellar\\", \\"Inception\\"] # print(movieRatings.getTopRatedMovies(1)) # returns [\\"Interstellar\\"]","solution":"class MovieRatings: def __init__(self): self.ratings = {} def addRating(self, movieTitle, rating): if movieTitle not in self.ratings: self.ratings[movieTitle] = [] self.ratings[movieTitle].append(rating) def getRating(self, movieTitle): if movieTitle not in self.ratings: return None ratings_list = self.ratings[movieTitle] return sum(ratings_list) / len(ratings_list) def getTopRatedMovies(self, N): avg_ratings = {} for movie, ratings in self.ratings.items(): avg_ratings[movie] = sum(ratings) / len(ratings) sorted_movies = sorted(avg_ratings.items(), key=lambda x: (-x[1], x[0])) return [movie for movie, rating in sorted_movies[:N]] # Example usage # movieRatings = MovieRatings() # movieRatings.addRating(\\"Inception\\", 4.8) # movieRatings.addRating(\\"Inception\\", 4.6) # movieRatings.addRating(\\"Interstellar\\", 4.9) # movieRatings.addRating(\\"Interstellar\\", 5.0) # movieRatings.addRating(\\"Dunkirk\\", 4.2) # print(movieRatings.getRating(\\"Inception\\")) # returns 4.7 # print(movieRatings.getRating(\\"Interstellar\\")) # returns 4.95 # print(movieRatings.getRating(\\"Dunkirk\\")) # returns 4.2 # print(movieRatings.getTopRatedMovies(2)) # returns [\\"Interstellar\\", \\"Inception\\"] # print(movieRatings.getTopRatedMovies(1)) # returns [\\"Interstellar\\"]"},{"question":"def max_subarray_sum(arr): Takes a list of integers and returns the maximum sum of any contiguous subarray. >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([1000, -1, 1000]) 1999 >>> max_subarray_sum([0, 0, 0, 0]) 0","solution":"def max_subarray_sum(arr): Takes a list of integers and returns the maximum sum of any contiguous subarray. if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def subarray_sum_zero(arr: List[int]) -> bool: Determines if there exists a subarray with a sum of zero. >>> subarray_sum_zero([1, 2, -3, 4]) True >>> subarray_sum_zero([1, 2, 3]) False >>> subarray_sum_zero([0, 1, 2]) True >>> subarray_sum_zero([3, 4, -7, 1, 2, -6, 3]) True >>> subarray_sum_zero([]) False >>> subarray_sum_zero([1, -1]) True >>> subarray_sum_zero([1, 2, 3, 4, 5]) False >>> subarray_sum_zero([-1, -2, 3, 5, -3]) True >>> subarray_sum_zero([-3, 1, 2, -2]) True >>> subarray_sum_zero([4, -6, 3, 1, -2, 3]) True","solution":"from typing import List def subarray_sum_zero(arr: List[int]) -> bool: Determines if there exists a subarray with a sum of zero. Args: arr (List[int]): A list of integers. Returns: bool: True if there is a subarray that sums to zero, otherwise False. prefix_sum = 0 seen_sums = set() for num in arr: prefix_sum += num # If the prefix sum is 0 or exists in the set, we have found a zero-sum subarray if prefix_sum == 0 or prefix_sum in seen_sums: return True seen_sums.add(prefix_sum) return False"},{"question":"from typing import List def is_escape_possible(maze: List[List[int]]) -> bool: Determines if escape from the top-left corner to the bottom-right corner of the maze is possible. Args: maze (List[List[int]]): A 2D grid representing the maze. Returns: bool: True if escape is possible, otherwise False. Example: >>> maze = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> is_escape_possible(maze) True >>> maze = [ ... [0, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 0] ... ] >>> is_escape_possible(maze) False pass","solution":"from typing import List from collections import deque def is_escape_possible(maze: List[List[int]]) -> bool: Determines if escape from the top-left corner to the bottom-right corner of the maze is possible. Args: maze (List[List[int]]): A 2D grid representing the maze. Returns: bool: True if escape is possible, otherwise False. if not maze or not maze[0]: return False rows, cols = len(maze), len(maze[0]) # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the BFS with the starting point queue = deque([(0, 0)]) visited = set([(0, 0)]) while queue: x, y = queue.popleft() # If we've reached the bottom-right corner if x == rows - 1 and y == cols - 1: return True # Explore the neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"from typing import List def can_construct_target(words: List[str], target: str) -> bool: Determine if the target string can be constructed by concatenating words from the list. Each word from the list can be used multiple times. >>> can_construct_target([\\"abc\\", \\"def\\", \\"abcd\\"], \\"abcdef\\") True >>> can_construct_target([\\"cat\\", \\"dog\\", \\"fish\\"], \\"catdogcat\\") True >>> can_construct_target([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"], \\"aaaaaaaab\\") False def test_can_construct_target_example1(): words = [\\"abc\\", \\"def\\", \\"abcd\\"] target = \\"abcdef\\" assert can_construct_target(words, target) == True def test_can_construct_target_example2(): words = [\\"cat\\", \\"dog\\", \\"fish\\"] target = \\"catdogcat\\" assert can_construct_target(words, target) == True def test_can_construct_target_example3(): words = [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"] target = \\"aaaaaaaab\\" assert can_construct_target(words, target) == False def test_can_construct_target_single_letter_repeats(): words = [\\"a\\"] target = \\"aaaaaaa\\" assert can_construct_target(words, target) == True def test_can_construct_target_empty_target(): words = [\\"a\\", \\"abc\\", \\"def\\"] target = \\"\\" assert can_construct_target(words, target) == True def test_can_construct_target_target_is_single_word(): words = [\\"hello\\", \\"world\\"] target = \\"world\\" assert can_construct_target(words, target) == True def test_can_construct_target_complex_case(): words = [\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\", \\"abcd\\"] target = \\"abcdabcdef\\" assert can_construct_target(words, target) == True def test_can_construct_target_no_possible_construction(): words = [\\"a\\", \\"b\\"] target = \\"c\\" assert can_construct_target(words, target) == False","solution":"from typing import List def can_construct_target(words: List[str], target: str) -> bool: Determines if the target string can be constructed by concatenating words from the list. Each word from the list can be used multiple times. dp = [False] * (len(target) + 1) dp[0] = True # Empty string can always be constructed for i in range(1, len(target) + 1): for word in words: if i >= len(word) and target[i - len(word):i] == word and dp[i - len(word)]: dp[i] = True break return dp[len(target)]"},{"question":"def process_commands(command_string: str) -> str: Parse and interpret commands embedded in a string. >>> process_commands(\\"BEGIN:ADD5:SUB2:MUL3:DIV6:END\\") 'BEGIN:RESULT1:END' >>> process_commands(\\"BEGIN:ADD10:SUB5:MUL2:DIV2:END\\") 'BEGIN:RESULT5:END' >>> process_commands(\\"BEGIN:ADD10:SUB20:END\\") 'BEGIN:RESULT0:END' >>> process_commands(\\"BEGIN:ADD5:DIV0:END\\") 'BEGIN:ERROR_DIV_BY_ZERO:END' >>> process_commands(\\"BEGIN:DIV0:END\\") 'BEGIN:ERROR_DIV_BY_ZERO:END' >>> process_commands(\\"BEGIN:ADD15:SUB5:MUL3:END\\") 'BEGIN:RESULT30:END' >>> process_commands(\\"BEGIN:ADD8:SUB3:MUL2:DIV2:END\\") 'BEGIN:RESULT5:END' >>> process_commands(\\"BEGIN:ADD10:SUB5:MUL2:DIV2\\") 'BEGIN:ERROR_INVALID_FORMAT:END' >>> process_commands(\\"ADD10:SUB5:MUL2:DIV2:END\\") 'BEGIN:ERROR_INVALID_FORMAT:END' >>> process_commands(\\"BEGIN:MOD10:END\\") 'BEGIN:ERROR_INVALID_OPERATION:END' >>> process_commands(\\"BEGIN:ADD10:SQR5:END\\") 'BEGIN:ERROR_INVALID_OPERATION:END'","solution":"def process_commands(command_string: str) -> str: parts = command_string.split(\\":\\") header = parts[0] footer = parts[-1] if header != \\"BEGIN\\" or footer != \\"END\\": return \\"BEGIN:ERROR_INVALID_FORMAT:END\\" accumulator = 0 for part in parts[1:-1]: operation = part[:3] value = int(part[3:]) if operation == \\"ADD\\": accumulator += value elif operation == \\"SUB\\": accumulator -= value elif operation == \\"MUL\\": accumulator *= value elif operation == \\"DIV\\": if value == 0: return \\"BEGIN:ERROR_DIV_BY_ZERO:END\\" accumulator //= value else: return \\"BEGIN:ERROR_INVALID_OPERATION:END\\" accumulator = max(accumulator, 0) return f\\"{header}:RESULT{accumulator}:{footer}\\""},{"question":"def is_palindromic(x: int) -> bool: Returns True if x is a palindromic number, False otherwise. A palindromic number is a number that remains the same when its digits are reversed. >>> is_palindromic(121) True >>> is_palindromic(123) False >>> is_palindromic(0) True >>> is_palindromic(11) True >>> is_palindromic(-121) False","solution":"def is_palindromic(x): Returns True if x is a palindromic number, False otherwise. A palindromic number is a number that remains the same when its digits are reversed. x_str = str(x) return x_str == x_str[::-1]"},{"question":"def find_longest_odd_sum_subsequence_length(arr: List[int]) -> int: Determine the length of the longest strictly increasing subsequence with an odd sum. >>> find_longest_odd_sum_subsequence_length([2, 1, 4, 7, 6]) 3 >>> find_longest_odd_sum_subsequence_length([2, 4, 6, 8, 10]) 0 >>> find_longest_odd_sum_subsequence_length([1, 3, 5, 7, 9]) 5 >>> find_longest_odd_sum_subsequence_length([4, 3, 2, 5, 1, 7]) 3 >>> find_longest_odd_sum_subsequence_length([2]) 0 >>> find_longest_odd_sum_subsequence_length([1]) 1 >>> find_longest_odd_sum_subsequence_length([1, 3, 2, 4, 5, 7, 6]) 5 >>> find_longest_odd_sum_subsequence_length([9, 7, 5, 3, 1]) 1","solution":"def find_longest_odd_sum_subsequence_length(arr): from itertools import combinations N = len(arr) max_length = 0 for length in range(1, N + 1): for subseq in combinations(arr, length): if all(subseq[i] < subseq[i + 1] for i in range(len(subseq) - 1)) and sum(subseq) % 2 == 1: max_length = max(max_length, length) return max_length"},{"question":"def first_non_repeating(s: str) -> str: Returns the first non-repeating character in a given string. If there is no non-repeating character, returns an empty string. >>> first_non_repeating(\\"leetcode\\") 'l' >>> first_non_repeating(\\"loveleetcode\\") 'v' >>> first_non_repeating(\\"aabbcc\\") '' >>> first_non_repeating(\\"\\") '' >>> first_non_repeating(\\"z\\") 'z' >>> first_non_repeating(\\"abcdabc\\") 'd' >>> first_non_repeating(\\"abacabad\\") 'c'","solution":"def first_non_repeating(s): Returns the first non-repeating character in a string s. If there is no non-repeating character, return an empty string. char_count = {} # Count the frequency of each character for char in s: char_count[char] = char_count.get(char, 0) + 1 # Find the first character with count 1 for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"def custom_sort_with_fives_at_end(lst: List[int]) -> List[int]: Returns a new list of integers sorted in ascending order with all instances of the number 5 moved to the end. >>> custom_sort_with_fives_at_end([3, 5, 2, 5, 8, 1]) [1, 2, 3, 8, 5, 5] >>> custom_sort_with_fives_at_end([5, 3, 4, 5, 1]) [1, 3, 4, 5, 5]","solution":"def custom_sort_with_fives_at_end(lst): Returns a new list of integers sorted in ascending order with all instances of the number 5 moved to the end. # Separate the fives from other numbers non_fives = [x for x in lst if x != 5] fives = [x for x in lst if x == 5] # Sort the non-fives list sorted_non_fives = sorted(non_fives) # Concatenate the sorted non-fives list with the list of fives return sorted_non_fives + fives"},{"question":"def max_tasks(N: int, M: int, task_times: List[int]) -> int: Determines the maximum number of tasks that can be completed without exceeding the time limit. :param N: number of tasks :param M: maximum time available :param task_times: list of integers representing the time required for each task :return: maximum number of tasks that can be completed without exceeding the time limit >>> max_tasks(5, 50, [10, 20, 30, 40, 50]) 2 >>> max_tasks(3, 60, [10, 20, 30]) 3 >>> max_tasks(4, 10, [15, 20, 25, 30]) 0 >>> max_tasks(4, 40, [10, 10, 10, 10]) 4 >>> max_tasks(4, 25, [10, 10, 10, 10]) 2 >>> max_tasks(1, 10, [5]) 1 >>> max_tasks(1, 5, [10]) 0 >>> max_tasks(3, 100000, [1, 1, 1]) 3 >>> max_tasks(4, 5, [2, 2, 2, 2]) 2","solution":"def max_tasks(N, M, task_times): Determines the maximum number of tasks that can be completed without exceeding the time limit. :param N: number of tasks :param M: maximum time available :param task_times: list of integers representing the time required for each task :return: maximum number of tasks that can be completed without exceeding the time limit task_times.sort() total_time = 0 count = 0 for time in task_times: if total_time + time <= M: total_time += time count += 1 else: break return count"},{"question":"def min_sum_path(mat): Returns the minimum sum of all numbers along the path starting from the top-left to the bottom-right corner of the matrix. >>> min_sum_path([[1,3,1], [1,5,1], [4,2,1]]) 7 >>> min_sum_path([[1,2,5], [3,2,1]]) 6 >>> min_sum_path([[5]]) 5 >>> min_sum_path([[1, 2, 3]]) 6 >>> min_sum_path([[1], [2], [3]]) 6 >>> min_sum_path([[1]*100 for _ in range(100)]) 199 >>> min_sum_path([]) 0 >>> min_sum_path([[]]) 0","solution":"def min_sum_path(mat): Returns the minimum sum of all numbers along the path starting from the top-left to the bottom-right corner of the matrix. if not mat or not mat[0]: return 0 n = len(mat) m = len(mat[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = mat[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + mat[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + mat[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[-1][-1]"},{"question":"from typing import List def subarray_sum(nums: List[int], target: int) -> int: Returns the number of continuous subarrays whose sum equals to target. >>> subarray_sum([1, 1, 1], 2) == 2 >>> subarray_sum([1, 2, 3], 3) == 2 >>> subarray_sum([-1, -1, 1], 0) == 1 >>> subarray_sum([1, 2, 3], 7) == 0 >>> subarray_sum([5], 5) == 1 >>> subarray_sum([1, 2, 1, 2, 1], 3) == 4 >>> subarray_sum([-1, -1, -1, -1], -2) == 3","solution":"def subarray_sum(nums, target): Returns the number of continuous subarrays whose sum equals to target. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if current_sum - target in prefix_sums: count += prefix_sums[current_sum - target] prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 return count"},{"question":"def maxFrequencyChar(s: str) -> str: Returns the character which appears the most frequently in the string s. If multiple characters have the same highest frequency, returns the lexicographically smallest one. pass # Unit tests def test_maxFrequencyChar_single_char(): assert maxFrequencyChar(\\"a\\") == \\"a\\" def test_maxFrequencyChar_mixed_frequencies(): assert maxFrequencyChar(\\"test\\") == \\"t\\" assert maxFrequencyChar(\\"bbaaccdd\\") == \\"a\\" assert maxFrequencyChar(\\"abcd\\") == \\"a\\" def test_maxFrequencyChar_empty_string(): assert maxFrequencyChar(\\"\\") is None def test_maxFrequencyChar_same_frequency_single_candidate(): assert maxFrequencyChar(\\"cccaaa\\") == \\"a\\" assert maxFrequencyChar(\\"bbaaa\\") == \\"a\\" def test_maxFrequencyChar_same_frequency_multiple_candidates(): assert maxFrequencyChar(\\"aabbcc\\") == \\"a\\" assert maxFrequencyChar(\\"abac\\") == \\"a\\" assert maxFrequencyChar(\\"abcabc\\") == \\"a\\"","solution":"def maxFrequencyChar(s): Returns the character which appears the most frequently in the string s. If multiple characters have the same highest frequency, returns the lexicographically smallest one. from collections import Counter if not s: return None frequency = Counter(s) max_freq = max(frequency.values()) candidates = [char for char, freq in frequency.items() if freq == max_freq] return min(candidates)"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Determine whether the array contains any duplicates within k indices of each other. Args: nums: List[int] - List of integers. k: int - Range within which to check for duplicates. Returns: bool - True if a duplicate is found within k indices apart, False otherwise. Examples: >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) False >>> contains_nearby_duplicate([4, 5, 6, 7, 8, 9, 4], 5) False >>> contains_nearby_duplicate([1, 2, 3, 4, 5, 1], 5) True","solution":"def contains_nearby_duplicate(nums, k): Determine whether the array contains any duplicates within k indices of each other. Args: nums: List[int] - List of integers. k: int - Range within which to check for duplicates. Returns: bool - True if a duplicate is found within k indices apart, False otherwise. index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"def is_prime(n): Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False def digit_sum(n): Return the sum of the digits of a number. >>> digit_sum(34) 7 >>> digit_sum(123) 6 def fibonacci(n): Generate the first n Fibonacci numbers. >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def sum_special_fibonacci(a, b): Sum all special Fibonacci numbers from position a to b (1-indexed). A \\"special Fibonacci\\" number is an even Fibonacci number whose digit sum is a prime number. >>> sum_special_fibonacci(1, 10) 36 >>> sum_special_fibonacci(4, 5) 2 >>> sum_special_fibonacci(8, 10) 34","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def digit_sum(n): Return the sum of the digits of a number. return sum(int(digit) for digit in str(n)) def fibonacci(n): Generate the first n Fibonacci numbers. fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence def sum_special_fibonacci(a, b): Sum all special Fibonacci numbers from position a to b (1-indexed). A \\"special Fibonacci\\" number is an even Fibonacci number whose digit sum is a prime number. # Generate Fibonacci numbers up to position b if b <= 2: b = 3 # We need at least two initial Fibonacci numbers fib_sequence = fibonacci(b) special_sum = 0 for i in range(a - 1, b): # Convert to 0-indexed if fib_sequence[i] % 2 == 0 and is_prime(digit_sum(fib_sequence[i])): special_sum += fib_sequence[i] return special_sum"},{"question":"def game_of_life(board): Compute the next state of the grid according to the rules of the Game of Life. Parameters: board (List[List[int]]): The input grid with live (1) and dead (0) cells. Returns: List[List[int]]: The next state of the grid after one update step. Examples: >>> game_of_life([ ... [0, 1, 0], ... [0, 0, 1], ... [1, 1, 1], ... [0, 0, 0] ... ]) == [ ... [0, 0, 0], ... [1, 0, 1], ... [0, 1, 1], ... [0, 1, 0] ... ] >>> game_of_life([ ... [1, 1], ... [1, 0] ... ]) == [ ... [1, 1], ... [1, 1] ... ] def test_game_of_life_example_1(): board = [ [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0] ] expected = [ [0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0] ] assert game_of_life(board) == expected def test_game_of_life_example_2(): board = [ [1, 1], [1, 0] ] expected = [ [1, 1], [1, 1] ] assert game_of_life(board) == expected def test_game_of_life_all_dead(): board = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] expected = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert game_of_life(board) == expected def test_game_of_life_all_live(): board = [ [1, 1], [1, 1] ] expected = [ [1, 1], [1, 1] ] assert game_of_life(board) == expected def test_game_of_life_oscillator(): board = [ [0, 1, 0], [0, 1, 0], [0, 1, 0] ] expected = [ [0, 0, 0], [1, 1, 1], [0, 0, 0] ] assert game_of_life(board) == expected","solution":"def game_of_life(board): Compute the next state of the grid according to the rules of the Game of Life. def count_live_neighbors(board, r, c): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_count = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < len(board) and 0 <= nc < len(board[0]): if board[nr][nc] == 1: live_count += 1 return live_count m, n = len(board), len(board[0]) new_board = [[0] * n for _ in range(m)] for r in range(m): for c in range(n): live_neighbors = count_live_neighbors(board, r, c) if board[r][c] == 1: if live_neighbors < 2 or live_neighbors > 3: new_board[r][c] = 0 else: new_board[r][c] = 1 else: if live_neighbors == 3: new_board[r][c] = 1 for r in range(m): for c in range(n): board[r][c] = new_board[r][c] return board"},{"question":"def find_extra_character(A: str, B: str) -> str: Finds the extra character in string B, which is a permutation of string A with one additional character. Parameters: A (str): The original string. B (str): The string that is a permutation of A with one additional character. Returns: char: The extra character in string B. >>> find_extra_character(\\"abcde\\", \\"abcdef\\") \\"f\\" >>> find_extra_character(\\"bcde\\", \\"abcde\\") \\"a\\" >>> find_extra_character(\\"abcdf\\", \\"abcdef\\") \\"e\\" >>> find_extra_character(\\"aabbcc\\", \\"aabbccd\\") \\"d\\" >>> find_extra_character(\\"\\", \\"a\\") \\"a\\" >>> find_extra_character(\\"zzzzz\\", \\"zzzzzo\\") \\"o\\"","solution":"def find_extra_character(A, B): Finds the extra character in string B, which is a permutation of string A with one additional character. Parameters: A (str): The original string. B (str): The string that is a permutation of A with one additional character. Returns: char: The extra character in string B. # Convert the strings to lists of characters and sort them a_sorted = sorted(A) b_sorted = sorted(B) # Iterate through the pairs of characters for a_char, b_char in zip(a_sorted, b_sorted): if a_char != b_char: return b_char # If all characters matched, the extra character is the last one in the sorted B list return b_sorted[-1]"},{"question":"def format_us_phone_number(phone_number: str) -> str: Validates and formats a US phone number to (XXX) XXX-XXXX. If the phone number is invalid, returns 'Invalid phone number'. >>> format_us_phone_number(\\"415-555-1234\\") \\"(415) 555-1234\\" >>> format_us_phone_number(\\"(415) 555-1234\\") \\"(415) 555-1234\\" >>> format_us_phone_number(\\"415.555.1234\\") \\"(415) 555-1234\\" >>> format_us_phone_number(\\"415 555 1234\\") \\"(415) 555-1234\\" >>> format_us_phone_number(\\"+1 415 555 1234\\") \\"(415) 555-1234\\" >>> format_us_phone_number(\\"555-1234\\") \\"Invalid phone number\\"","solution":"import re def format_us_phone_number(phone_number): Validates and formats a US phone number to (XXX) XXX-XXXX. If the phone number is invalid, returns 'Invalid phone number'. pattern = re.compile(r'^(?:+?1s*[-.]?)?(?(d{3}))?[-.s]?(d{3})[-.s]?(d{4})') match = pattern.match(phone_number) if match: return f\\"({match.group(1)}) {match.group(2)}-{match.group(3)}\\" return \\"Invalid phone number\\""},{"question":"def greeting(name, n): Returns a greeting with the person's name based on the value of n. Parameters: name (str): The name of the person. n (int): An integer between 1 and 5 representing the type of greeting. Returns: str: The greeting with the person's name. >>> greeting(\\"Alice\\", 1) 'Hello, Alice!' >>> greeting(\\"David\\", 2) 'Hi, David!' >>> greeting(\\"Bob\\", 3) 'Greetings, Bob!' >>> greeting(\\"Eve\\", 4) 'Welcome, Eve!' >>> greeting(\\"Charlie\\", 5) 'Hey, Charlie!' >>> greeting(\\"Invalid\\", 0) Traceback (most recent call last): ... ValueError: n must be between 1 and 5 >>> greeting(\\"Invalid\\", 6) Traceback (most recent call last): ... ValueError: n must be between 1 and 5","solution":"def greeting(name, n): Returns a greeting with the person's name based on the value of n. Parameters: name (str): The name of the person. n (int): An integer between 1 and 5 representing the type of greeting. Returns: str: The greeting with the person's name. greetings = [ \\"Hello, {}!\\", \\"Hi, {}!\\", \\"Greetings, {}!\\", \\"Welcome, {}!\\", \\"Hey, {}!\\" ] if n < 1 or n > 5: raise ValueError(\\"n must be between 1 and 5\\") return greetings[n-1].format(name)"},{"question":"def max_trees_standing(n: int, heights: List[int]) -> int: Returns the maximum number of trees that can be kept standing such that no two consecutive trees remain standing. >>> max_trees_standing(5, [3, 4, 5, 4, 3]) 3 >>> max_trees_standing(6, [1, 2, 3, 4, 5, 6]) 3 >>> max_trees_standing(1, [3]) 1 >>> max_trees_standing(2, [3, 4]) 1 >>> max_trees_standing(4, [1, 10, 1, 10]) 2 >>> max_trees_standing(0, []) 0 >>> max_trees_standing(3, [10**9, 10**9, 10**9]) 2 >>> max_trees_standing(4, [5, 5, 5, 5]) 2 >>> max_trees_standing(7, [1, 6, 2, 7, 3, 8, 4]) 4","solution":"def max_trees_standing(n, heights): Returns the maximum number of trees that can be kept standing such that no two consecutive trees remain standing. if n == 0: return 0 if n == 1: return 1 # Using a dynamic programming approach where dp[i] represents the maximum # number of trees that can be kept up to the i-th tree. dp = [0] * n dp[0] = 1 # Only one tree can be kept if there's only one tree dp[1] = 1 # Only one tree can be kept if there are two trees for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + 1) return dp[n-1]"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Determine the size of the largest rectangle composed entirely of 1s in a binary matrix. >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0]]) 6 >>> maximalRectangle([[0, 1, 1, 1, 0]]) 3 >>> maximalRectangle([[ ... 1], ... [1], ... [1], ... [0]]) 3 >>> maximalRectangle([[0, 0], ... [0, 0]]) 0 >>> maximalRectangle([[1, 1], ... [1, 1]]) 4 >>> maximalRectangle([]) 0 >>> maximalRectangle([[0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) 0 >>> maximalRectangle([[1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]]) 9","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) height = [0] * (n + 1) max_area = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: height[j] += 1 else: height[j] = 0 stack = [-1] for j in range(n + 1): while height[j] < height[stack[-1]]: h = height[stack.pop()] w = j - 1 - stack[-1] max_area = max(max_area, h * w) stack.append(j) return max_area"},{"question":"def can_form_hexadecimal(s: str) -> str: Determines if the string can be converted into a valid hexadecimal number by reordering its characters. Parameters: s (str): The input string consisting of lowercase Latin letters and digits. Returns: str: \\"yes\\" if the string can be rearranged to form a valid hexadecimal number, otherwise \\"no\\". >>> can_form_hexadecimal(\\"1a3f\\") \\"yes\\" >>> can_form_hexadecimal(\\"abc12\\") \\"yes\\" >>> can_form_hexadecimal(\\"xyz45\\") \\"no\\" >>> can_form_hexadecimal(\\"abcdef\\") \\"no\\" >>> can_form_hexadecimal(\\"fe12y7\\") \\"no\\"","solution":"def can_form_hexadecimal(s): Determines if the string can be converted into a valid hexadecimal number by reordering its characters. Parameters: s (str): The input string consisting of lowercase Latin letters and digits. Returns: str: \\"yes\\" if the string can be rearranged to form a valid hexadecimal number, otherwise \\"no\\". valid_hex_chars = set(\\"0123456789abcdef\\") has_digit = any(char.isdigit() for char in s) for char in s: if char not in valid_hex_chars: return \\"no\\" return \\"yes\\" if has_digit else \\"no\\""},{"question":"def transpose(matrix): Returns the transpose of a given NxN matrix. Args: matrix (list of list of int): NxN matrix Returns: list of list of int: Transposed NxN matrix Example: >>> transpose([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] >>> transpose([ ... [1, 2], ... [3, 4] ... ]) [ [1, 3], [2, 4] ] >>> transpose([[1]]) [[1]] >>> transpose([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [ [1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16] ] # Test cases def test_transpose_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transposed = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] assert transpose(matrix) == transposed def test_transpose_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] transposed = [ [1, 3], [2, 4] ] assert transpose(matrix) == transposed def test_transpose_1x1_matrix(): matrix = [[1]] transposed = [[1]] assert transpose(matrix) == transposed def test_transpose_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] transposed = [ [1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16] ] assert transpose(matrix) == transposed","solution":"def transpose(matrix): Returns the transpose of a given NxN matrix. Args: matrix (list of list of int): NxN matrix Returns: list of list of int: Transposed NxN matrix n = len(matrix) transposed_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix"},{"question":"from typing import List, Tuple def merge_overlapping_ranges(ranges: List[Tuple[str, str]]) -> List[Tuple[str, str]]: Given a list of strings, create a function that will merge all overlapping string ranges and return the minimal list containing non-overlapping string ranges in sorted order. A string range is a tuple of two strings (start, end), which represents all strings that are greater than or equal to start and less than or equal to end. Two ranges (start1, end1) and (start2, end2) are considered overlapping if \`start1 <= end2\` and \`start2 <= end1\`. Merging two overlapping ranges means finding a new range that covers both, which would be (min(start1, start2), max(end1, end2)). >>> merge_overlapping_ranges([(\\"apple\\", \\"banana\\"), (\\"banana\\", \\"cherry\\"), (\\"cherry\\", \\"date\\")]) [(\\"apple\\", \\"date\\")] >>> merge_overlapping_ranges([(\\"kiwi\\", \\"mango\\"), (\\"apple\\", \\"banana\\"), (\\"banana\\", \\"orange\\"), (\\"grape\\", \\"kiwi\\")]) [(\\"apple\\", \\"orange\\")] >>> merge_overlapping_ranges([(\\"a\\", \\"c\\"), (\\"e\\", \\"g\\"), (\\"d\\", \\"f\\")]) [(\\"a\\", \\"c\\"), (\\"d\\", \\"g\\")] >>> merge_overlapping_ranges([(\\"orange\\", \\"peach\\"), (\\"apple\\", \\"banana\\"), (\\"banana\\", \\"mango\\")]) [(\\"apple\\", \\"mango\\"), (\\"orange\\", \\"peach\\")] pass def test_merge_simple_overlap(): assert merge_overlapping_ranges([(\\"apple\\", \\"banana\\"), (\\"banana\\", \\"cherry\\"), (\\"cherry\\", \\"date\\")]) == [(\\"apple\\", \\"date\\")] def test_merge_multiple_ranges(): assert merge_overlapping_ranges([(\\"kiwi\\", \\"mango\\"), (\\"apple\\", \\"banana\\"), (\\"banana\\", \\"orange\\"), (\\"grape\\", \\"kiwi\\")]) == [(\\"apple\\", \\"orange\\")] def test_merge_no_overlap(): assert merge_overlapping_ranges([(\\"a\\", \\"c\\"), (\\"e\\", \\"g\\"), (\\"d\\", \\"f\\")]) == [(\\"a\\", \\"c\\"), (\\"d\\", \\"g\\")] def test_merge_partial_overlap(): assert merge_overlapping_ranges([(\\"orange\\", \\"peach\\"), (\\"apple\\", \\"banana\\"), (\\"banana\\", \\"mango\\")]) == [(\\"apple\\", \\"mango\\"), (\\"orange\\", \\"peach\\")] def test_merge_single_range(): assert merge_overlapping_ranges([(\\"a\\", \\"z\\")]) == [(\\"a\\", \\"z\\")] def test_merge_empty_list(): assert merge_overlapping_ranges([]) == [] def test_merge_multiple_single_character_ranges(): assert merge_overlapping_ranges([(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")]) == [(\\"a\\", \\"d\\")]","solution":"def merge_overlapping_ranges(ranges): Merges overlapping string ranges and returns the minimal list of non-overlapping string ranges in sorted order. :param ranges: List of tuples containing string ranges :return: List of merged non-overlapping string ranges # Step 1: Sort the ranges by their start value sorted_ranges = sorted(ranges, key=lambda x: x[0]) # Step 2: Initialize the merged list merged_ranges = [] for current_range in sorted_ranges: # If merged_ranges is empty or there's no overlap with the last range, add the current range. if not merged_ranges or merged_ranges[-1][1] < current_range[0]: merged_ranges.append(current_range) else: # Otherwise, there is overlap, so merge the current range with the last range. merged_ranges[-1] = (merged_ranges[-1][0], max(merged_ranges[-1][1], current_range[1])) return merged_ranges"},{"question":"def formatNumbers(N): Returns a string of numbers from 1 to N separated by a comma and a space. Examples: >>> formatNumbers(1) \\"1\\" >>> formatNumbers(3) \\"1, 2, 3\\" >>> formatNumbers(5) \\"1, 2, 3, 4, 5\\" >>> formatNumbers(10) \\"1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\" >>> formatNumbers(0) \\"\\" >>> formatNumbers(-5) \\"\\"","solution":"def formatNumbers(N): Returns a string of numbers from 1 to N separated by a comma and a space. return ', '.join(str(i) for i in range(1, N + 1))"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, return the length of the longest substring of s that contains only unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\" \\") 1 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"aab\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_index = {} max_length = start = 0 for end, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def sort_even_odd(lst: List[int]) -> List[int]: Write a function that takes a list of integers and returns a list containing the even numbers followed by the odd numbers, both groups sorted in ascending order. Maintain this sequence even if the original list contains negative integers. >>> sort_even_odd([7, -3, 4, 2, -1, 0, -5, 8, -6]) [-6, 0, 2, 4, 8, -5, -3, -1, 7] >>> sort_even_odd([4, 2, 0, -4, -6]) [-6, -4, 0, 2, 4] >>> sort_even_odd([7, -3, -1, -5, 9]) [-5, -3, -1, 7, 9] >>> sort_even_odd([10, -10, -5, 5, 3, -3]) [-10, 10, -5, -3, 3, 5] >>> sort_even_odd([3]) [3] >>> sort_even_odd([-4]) [-4] >>> sort_even_odd([]) []","solution":"def sort_even_odd(lst): Returns a list containing the even numbers followed by the odd numbers, both groups sorted in ascending order. evens = sorted([x for x in lst if x % 2 == 0]) odds = sorted([x for x in lst if x % 2 != 0]) return evens + odds"},{"question":"from typing import List def largest_rectangle_of_same_color(board: List[List[str]]) -> int: Find the area of the largest rectangular sub-board where all the tiles are of the same color. Args: board: A 2D array of strings representing the board. Returns: An integer representing the area of the largest rectangular sub-board where all tiles are of the same color. Examples: >>> largest_rectangle_of_same_color([ ... [\\"red\\", \\"blue\\", \\"blue\\", \\"red\\"], ... [\\"red\\", \\"blue\\", \\"blue\\", \\"blue\\"], ... [\\"red\\", \\"blue\\", \\"blue\\", \\"blue\\"], ... [\\"red\\", \\"red\\", \\"blue\\", \\"blue\\"]]) == 6 >>> largest_rectangle_of_same_color([ ... [\\"green\\", \\"green\\", \\"red\\"], ... [\\"green\\", \\"blue\\", \\"blue\\"], ... [\\"green\\", \\"blue\\", \\"blue\\"]]) == 4","solution":"def largest_rectangle_of_same_color(board): def calculate_histogram_heights(board, color): m, n = len(board), len(board[0]) heights = [[0] * n for _ in range(m)] for col in range(n): for row in range(m): if board[row][col] == color: if row == 0: heights[row][col] = 1 else: heights[row][col] = heights[row - 1][col] + 1 return heights def max_histogram_area(heights_row): stack = [] max_area = 0 index = 0 while index < len(heights_row): if not stack or heights_row[index] >= heights_row[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() if stack: area = heights_row[top_of_stack] * (index - stack[-1] - 1) else: area = heights_row[top_of_stack] * index max_area = max(max_area, area) while stack: top_of_stack = stack.pop() if stack: area = heights_row[top_of_stack] * (index - stack[-1] - 1) else: area = heights_row[top_of_stack] * index max_area = max(max_area, area) return max_area m, n = len(board), len(board[0]) colors = set() for row in board: colors.update(row) max_area = 0 for color in colors: heights = calculate_histogram_heights(board, color) for heights_row in heights: max_area = max(max_area, max_histogram_area(heights_row)) return max_area"},{"question":"from typing import List def square_odds_desc(lst: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list that contains the squares of only the odd numbers from the original list, sorted in descending order. If the list is empty, the function should return an empty list. For example: >>> square_odds_desc([1, 2, 3, 4, 5]) [25, 9, 1] >>> square_odds_desc([12, 11, 10, 9]) [121, 81] >>> square_odds_desc([]) [] >>> square_odds_desc([-1, -2, 3, 4, -5]) [25, 9, 1]","solution":"def square_odds_desc(lst): Returns a list containing the squares of the odd numbers from the input list, sorted in descending order. return sorted([x ** 2 for x in lst if x % 2 != 0], reverse=True)"},{"question":"def evaluate_expression(expression: str) -> float: Evaluate a mathematical expression containing non-negative integers and the operators +, -, *, /. The expression may include parentheses to denote precedence, and spaces should be ignored. Returns the evaluated result as a float. Examples: >>> evaluate_expression(\\"3 + 5 * 2\\") 13.0 >>> evaluate_expression(\\"(1 + 3) * (6 / 2)\\") 12.0 >>> evaluate_expression(\\"8 / 4 + (2 * 3)\\") 8.0 >>> evaluate_expression(\\"7 + (3 * (5 - 2))\\") 16.0","solution":"def evaluate_expression(expression: str) -> float: def evaluate(tokens): stack = [] num = 0 sign = '+' i = 0 while i < len(tokens): token = tokens[i] if token.isdigit(): num = int(token) if token == '(': num, j = evaluate(tokens[i+1:]) i += j if token in '+-*/)' or i == len(tokens) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = float(stack[-1]) / num # explicitly converting to float if token == ')': return sum(stack), i + 1 sign = token num = 0 i += 1 return sum(stack), i # Removing spaces from the expression expression = expression.replace(' ', '') # Convert the string expression into a list of tokens tokens = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = '' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 tokens.append(num) else: tokens.append(expression[i]) i += 1 result, _ = evaluate(tokens) # Return the result rounded to one decimal place return round(result, 1)"},{"question":"def number_of_vowels(s: str) -> int: Returns the number of vowels in the string s. Vowels are 'a', 'e', 'i', 'o', 'u' in both uppercase and lowercase. >>> number_of_vowels('Vowels') == 2 >>> number_of_vowels('aeiouAEIOU') == 10 >>> number_of_vowels('Example') == 3 >>> number_of_vowels('') == 0 >>> number_of_vowels('bcdfgh') == 0 >>> number_of_vowels('aeioauoeiAIEOU') == 14","solution":"def number_of_vowels(s): Returns the number of vowels in the string s. Vowels are 'a', 'e', 'i', 'o', 'u' in both uppercase and lowercase. vowels = 'aeiouAEIOU' return sum(1 for char in s if char in vowels)"},{"question":"def find_pairs(nums: List[int], target: int) -> Set[Tuple[int, int]]: Returns a set of unique pairs of integers from the list 'nums' that add up to the 'target' sum. >>> find_pairs([1, 2, 3, 4, 5], 6) {(1, 5), (2, 4)} >>> find_pairs([1, 2, 3], 7) set() >>> find_pairs([1, 2, 3, 4], 5) {(1, 4), (2, 3)} >>> find_pairs([-1, 1, 0, 0], 0) {(-1, 1), (0, 0)} >>> find_pairs([-3, -1, 1, 3], 0) {(-3, 3), (-1, 1)} >>> find_pairs([1, 1, 2, 2, 3, 3, 4, 4], 5) {(1, 4), (2, 3)} # Implementation here","solution":"def find_pairs(nums, target): Returns a set of unique pairs of integers from the list 'nums' that add up to the 'target' sum. nums_seen = set() pairs = set() for num in nums: complement = target - num if complement in nums_seen: pairs.add((min(num, complement), max(num, complement))) nums_seen.add(num) return pairs"},{"question":"import re def extract_emails(text: str) -> List[str]: Extracts and returns all email addresses from the given text. # Regular expression pattern to match email addresses pattern = r'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b' return re.findall(pattern, text) def print_emails(emails: List[str]) -> None: Prints each email address on a new line. for email in emails: print(email) Example usage: text = \\"Hello from alice@example.com, you can also reach bob.smith@web-co.edu or at charlie12@service.co.uk for more information.\\" emails = extract_emails(text) print_emails(emails) >>> extract_emails(\\"Hello from alice@example.com, you can also reach bob.smith@web-co.edu or at charlie12@service.co.uk for more information.\\") [\\"alice@example.com\\", \\"bob.smith@web-co.edu\\", \\"charlie12@service.co.uk\\"] # Unit tests def test_extract_emails(): text = \\"Hello from alice@example.com, you can also reach bob.smith@web-co.edu or at charlie12@service.co.uk for more information.\\" extracted = extract_emails(text) expected = [\\"alice@example.com\\", \\"bob.smith@web-co.edu\\", \\"charlie12@service.co.uk\\"] assert extracted == expected def test_extract_emails_with_special_chars(): text = \\"Contact alice@example.com! Alternatively, use bob.smith@web-co.edu. Don't forget charlie12@service.co.uk.\\" extracted = extract_emails(text) expected = [\\"alice@example.com\\", \\"bob.smith@web-co.edu\\", \\"charlie12@service.co.uk\\"] assert extracted == expected def test_extract_emails_with_numbers(): text = \\"Users like user123@mail.com, example456.test@domain.org and test789_email@company.net are all valid.\\" extracted = extract_emails(text) expected = [\\"user123@mail.com\\", \\"example456.test@domain.org\\", \\"test789_email@company.net\\"] assert extracted == expected def test_extract_invalid_emails(): text = \\"Invalid emails like user@@domain.com, user@.com, and just text should not be extracted.\\" extracted = extract_emails(text) expected = [] assert extracted == expected def test_extract_no_emails(): text = \\"There are no email addresses in this string.\\" extracted = extract_emails(text) expected = [] assert extracted == expected def test_extract_emails_varied_cases(): text = \\"Different cases: Alice@Example.Com, Bob.Smith@Web-Co.Edu, charlie12@Service.Co.Uk\\" extracted = extract_emails(text) expected = [\\"Alice@Example.Com\\", \\"Bob.Smith@Web-Co.Edu\\", \\"charlie12@Service.Co.Uk\\"] assert extracted == expected","solution":"import re def extract_emails(text): Extracts and returns all email addresses from the given text. # Regular expression pattern to match email addresses pattern = r'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b' # Find all matches in the text emails = re.findall(pattern, text) return emails def print_emails(emails): Prints each email address on a new line. for email in emails: print(email) # Example usage text = \\"Hello from alice@example.com, you can also reach bob.smith@web-co.edu or at charlie12@service.co.uk for more information.\\" emails = extract_emails(text) print_emails(emails)"},{"question":"def swap_case(s: str) -> str: This function takes a string and returns a new string with all uppercase letters converted to lowercase and all lowercase letters converted to uppercase. :param s: str: Input string with mixed case letters :return: str: String with swapped letter cases >>> swap_case(\\"AaBbCc\\") == \\"aAbBcC\\" >>> swap_case(\\"HelloWorld\\") == \\"hELLOwORLD\\" >>> swap_case(\\"UPPERCASE\\") == \\"uppercase\\" >>> swap_case(\\"lowercase\\") == \\"LOWERCASE\\" >>> swap_case(\\"\\") == \\"\\" >>> swap_case(\\"PyThOn\\") == \\"pYtHoN\\" >>> swap_case(\\"a\\") == \\"A\\" >>> swap_case(\\"A\\") == \\"a\\"","solution":"def swap_case(s): This function takes a string and returns a new string with all uppercase letters converted to lowercase and all lowercase letters converted to uppercase. :param s: str: Input string with mixed case letters :return: str: String with swapped letter cases return s.swapcase()"},{"question":"import heapq from collections import Counter def rearrange_string(s: str) -> str: Rearranges the string 's' such that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> result = rearrange_string(\\"aabb\\") >>> result in {\\"abab\\", \\"baba\\"} True >>> result = rearrange_string(\\"aaabbc\\") >>> valid_results = {\\"ababac\\", \\"abacab\\", \\"acabab\\", \\"acbaab\\", \\"bacaba\\", \\"bacbaa\\", \\"bacaab\\"} >>> result in valid_results and all(result[i] != result[i + 1] for i in range(len(result) - 1)) True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"abcde\\") 'abcde' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"aaaa\\") '' >>> result = rearrange_string(\\"aaaabbbbcccc\\") >>> all(result[i] != result[i + 1] for i in range(len(result) - 1)) True >>> Counter(result) == Counter(\\"aaaabbbbcccc\\") True","solution":"import heapq from collections import Counter def rearrange_string(s: str) -> str: Rearranges the string 's' such that no two adjacent characters are the same. If it is not possible, returns an empty string. counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged_str = ''.join(result) if len(rearranged_str) != len(s): return \\"\\" return rearranged_str"},{"question":"def first_non_repeating_character(s): Write a function that takes a string containing only lowercase letters and returns the first non-repeating character. If there is no non-repeating character, return an underscore. Example: >>> first_non_repeating_character(\\"leetcode\\") 'l' >>> first_non_repeating_character(\\"loveleetcode\\") 'v' >>> first_non_repeating_character(\\"aabbcc\\") '_'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating, return '_'. :param str s: A string containing only lowercase letters :return: First non-repeating character or '_' :rtype: str char_count = {} # Record the count of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return '_'"},{"question":"def min_trips(t, test_cases): Determine the minimum number of trips needed to deliver all containers. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): Each test case contains the number of containers, the maximum weight the spaceship can carry in one trip, and a list of container weights. Returns: List[int]: A list of integers, each representing the minimum number of trips for a test case. Example: >>> min_trips(2, [(5, 10, [1, 1, 1, 9, 8]), (3, 7, [2, 3, 5])]) [3, 2] >>> min_trips(1, [(3, 10, [2, 3, 5])]) [1] pass from solution import min_trips def test_example_cases(): assert min_trips(2, [(5, 10, [1, 1, 1, 9, 8]), (3, 7, [2, 3, 5])]) == [3, 2] def test_larger_weights(): assert min_trips(1, [(3, 5, [5, 5, 5])]) == [3] def test_just_one_trip(): assert min_trips(1, [(3, 10, [2, 3, 5])]) == [1] def test_mixed_container_weights(): assert min_trips(1, [(6, 9, [3, 1, 4, 1, 5, 2])]) == [2] def test_single_container(): assert min_trips(1, [(1, 100, [99])]) == [1] def test_many_containers_one_trip_each(): assert min_trips(1, [(5, 3, [3, 3, 3, 3, 3])]) == [5] def test_large_values(): assert min_trips(1, [(4, 1000000000, [500000000, 500000000, 500000000, 500000000])]) == [2]","solution":"def min_trips(t, test_cases): results = [] for case in test_cases: n, W, weights = case weights.sort(reverse=True) # Sort weights in descending order trips = 0 i = 0 while i < n: remaining_capacity = W while i < n and weights[i] <= remaining_capacity: remaining_capacity -= weights[i] i += 1 trips += 1 results.append(trips) return results"},{"question":"def isUnique(s: str) -> bool: Checks if all characters in the given string are unique. The function is case-insensitive, meaning 'A' and 'a' are considered the same character. >>> isUnique(\\"abcdefg\\") True >>> isUnique(\\"aAbBcCdD\\") False >>> isUnique(\\"\\") True >>> isUnique(\\"xyZ\\") True >>> isUnique(\\"hello\\") False","solution":"def isUnique(s): Returns True if all characters in the given string are unique, case-insensitively, otherwise returns False. seen_characters = set() for char in s.lower(): if char in seen_characters: return False seen_characters.add(char) return True"},{"question":"def can_measure_exact_volume(capacities, volume): Determines if the exact volume can be measured using the provided containers. Args: capacities (list): List of integer capacities of the containers. volume (int): The exact volume of water needed. Returns: bool: True if the exact volume can be measured using the containers, False otherwise. >>> can_measure_exact_volume([1, 3, 4, 5], 7) True >>> can_measure_exact_volume([2, 3, 5], 1) False >>> can_measure_exact_volume([5, 10, 20], 25) True >>> can_measure_exact_volume([9, 12, 2], 11) True >>> can_measure_exact_volume([7, 14, 21], 20) False >>> can_measure_exact_volume([1], 0) True >>> can_measure_exact_volume([2, 5, 8], 10) True >>> can_measure_exact_volume([6, 4, 3], 50) True >>> can_measure_exact_volume([10, 20, 30], 35) False >>> can_measure_exact_volume([1, 2, 3, 4, 5], 15) True","solution":"def can_measure_exact_volume(capacities, volume): Determines if the exact volume can be measured using the provided containers. Args: capacities (list): List of integer capacities of the containers. volume (int): The exact volume of water needed. Returns: bool: True if the exact volume can be measured using the containers, False otherwise. dp = [False] * (volume + 1) dp[0] = True for cap in capacities: for j in range(cap, volume + 1): if dp[j - cap]: dp[j] = True return dp[volume]"},{"question":"def longestUniqueSubstring(s: str) -> int: Given a string, determine the length of the longest substring without repeating characters. >>> longestUniqueSubstring(\\"abcabcbb\\") 3 >>> longestUniqueSubstring(\\"bbbbb\\") 1 >>> longestUniqueSubstring(\\"pwwkew\\") 3 >>> longestUniqueSubstring(\\"\\") 0 >>> longestUniqueSubstring(\\"abcdefg\\") 7 >>> longestUniqueSubstring(\\"aab\\") 2 >>> longestUniqueSubstring(\\"dvdf\\") 3 >>> longestUniqueSubstring(\\" \\") 1 >>> longestUniqueSubstring(\\"aababcabcd\\") 4 >>> longestUniqueSubstring(\\"1234567890\\") 10 >>> longestUniqueSubstring(\\"!@#%^&*()\\") 10 >>> longestUniqueSubstring(\\"AAAAAAAAB\\") 2 >>> longestUniqueSubstring(\\"abcdefabcdefgghijk\\") 7 # Implement the function here","solution":"def longestUniqueSubstring(s): Returns the length of the longest substring with all unique characters. n = len(s) max_len = 0 start = 0 char_index_map = {} for i in range(n): if s[i] in char_index_map and char_index_map[s[i]] >= start: start = char_index_map[s[i]] + 1 char_index_map[s[i]] = i max_len = max(max_len, i - start + 1) return max_len"},{"question":"def memoize(f): Memoizes the given function f. Caches results of function calls based on arguments. Example: >>> def slow_add(a, b): >>> return a + b >>> memoized_slow_add = memoize(slow_add) >>> result1 = memoized_slow_add(2, 3) # First call, should compute the result >>> result2 = memoized_slow_add(2, 3) # Second call, should return cached result immediately cache = {} def memoized_function(*args): if args in cache: return cache[args] result = f(*args) cache[args] = result return result return memoized_function import time def test_memoize_initial_call(): def slow_add(a, b): time.sleep(2) return a + b memoized_slow_add = memoize(slow_add) start_time = time.time() result = memoized_slow_add(2, 3) end_time = time.time() assert result == 5 assert (end_time - start_time) >= 2 # Should take at least 2 seconds def test_memoize_cached_call(): def slow_add(a, b): time.sleep(2) return a + b memoized_slow_add = memoize(slow_add) memoized_slow_add(2, 3) # Initial call to cache the result start_time = time.time() result = memoized_slow_add(2, 3) end_time = time.time() assert result == 5 assert (end_time - start_time) < 2 # Should return immediately def test_memoize_different_arguments(): def slow_add(a, b): time.sleep(2) return a + b memoized_slow_add = memoize(slow_add) result1 = memoized_slow_add(2, 3) result2 = memoized_slow_add(3, 4) start_time = time.time() result3 = memoized_slow_add(2, 3) end_time = time.time() assert result1 == 5 assert result2 == 7 assert result3 == 5 assert (end_time - start_time) < 2 # Should return immediately for cached call def test_memoize_no_arguments(): def slow_compute(): time.sleep(2) return \\"done\\" memoized_slow_compute = memoize(slow_compute) start_time = time.time() result1 = memoized_slow_compute() end_time = time.time() assert result1 == \\"done\\" assert (end_time - start_time) >= 2 # Initial call should take time start_time = time.time() result2 = memoized_slow_compute() end_time = time.time() assert result2 == \\"done\\" assert (end_time - start_time) < 2 # Cached call should return immediately","solution":"def memoize(f): Memoizes the given function f. Caches results of function calls based on arguments. cache = {} def memoized_function(*args): if args in cache: return cache[args] result = f(*args) cache[args] = result return result return memoized_function"},{"question":"def maxProduct(arr: list) -> int: Given an array/list of integers, find the product of the maximum and minimum numbers in the array. >>> maxProduct([3, 10, 5, 2, 7]) 20 >>> maxProduct([-3, 5, -1, 7]) -21 >>> maxProduct([-7, -4, -2, -6]) 14 >>> maxProduct([0, 4, -2, 5]) -10 def test_maxProduct_positive_numbers(): assert maxProduct([3, 10, 5, 2, 7]) == 20 def test_maxProduct_mixed_sign_numbers(): assert maxProduct([-3, 5, -1, 7]) == -21 def test_maxProduct_all_negative_numbers(): assert maxProduct([-7, -4, -2, -6]) == 14 def test_maxProduct_with_zero(): assert maxProduct([0, 4, -2, 5]) == -10 def test_maxProduct_repeated_numbers(): assert maxProduct([1, 1, 1, 1]) == 1 def test_maxProduct_negative_and_positive(): assert maxProduct([-10, -5, 0, 5, 10]) == -100 def test_maxProduct_with_large_numbers(): assert maxProduct([1000, 2000, -1000, -2000]) == -4000000","solution":"def maxProduct(arr): Returns the product of the maximum and minimum numbers in an array. Parameters: arr (list): List of integers. Returns: int: Product of the maximum and minimum numbers in the array. max_num = max(arr) min_num = min(arr) return max_num * min_num"},{"question":"from typing import List def powerSet(input_list: List[int]) -> List[List[int]]: Given an array of distinct integers, identify and return all possible subsets of the array (the power set). Each subset should be sorted in non-descending order, and the entire collection of subsets should be sorted lexicographically (as strings). >>> powerSet([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> powerSet([3, 1, 2]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> powerSet([]) [[]] >>> powerSet([5, -1, 0]) [[], [-1], [0], [5], [-1, 0], [-1, 5], [0, 5], [-1, 0, 5]] >>> powerSet([1]) [[], [1]] >>> powerSet([2, 1]) [[], [1], [2], [1, 2]]","solution":"from itertools import chain, combinations def powerSet(input_list): Returns the power set of the input_list. Each subset is sorted and the entire collection of subsets is sorted lexicographically. input_list = sorted(input_list) subsets = list(chain.from_iterable(combinations(input_list, r) for r in range(len(input_list) + 1))) sorted_subsets = sorted(subsets, key=lambda x: (len(x), x)) return [list(subset) for subset in sorted_subsets]"},{"question":"def intersection(nums1: List[int], nums2: List[int]) -> List[int]: Returns the intersection of two arrays as a list of unique elements. >>> intersection([1,2,2,1], [2,2]) [2] >>> intersection([4,9,5], [9,4,9,8,4]) [9,4]","solution":"def intersection(nums1, nums2): Returns the intersection of two arrays as a list of unique elements. set1 = set(nums1) set2 = set(nums2) return list(set1 & set2)"},{"question":"def convert_to_roman(num: int) -> str: Convert an integer to a Roman numeral. Parameters: num (int): A positive integer less than or equal to 3999 Returns: str: The Roman numeral representation of the integer Examples: >>> convert_to_roman(3) \\"III\\" >>> convert_to_roman(4) \\"IV\\" >>> convert_to_roman(9) \\"IX\\" >>> convert_to_roman(58) \\"LVIII\\" >>> convert_to_roman(3999) \\"MMMCMXCIX\\" # Unit tests def test_convert_single_digits(): assert convert_to_roman(1) == \\"I\\" assert convert_to_roman(3) == \\"III\\" assert convert_to_roman(4) == \\"IV\\" assert convert_to_roman(9) == \\"IX\\" def test_convert_tens(): assert convert_to_roman(10) == \\"X\\" assert convert_to_roman(40) == \\"XL\\" assert convert_to_roman(58) == \\"LVIII\\" assert convert_to_roman(90) == \\"XC\\" def test_convert_hundreds(): assert convert_to_roman(100) == \\"C\\" assert convert_to_roman(400) == \\"CD\\" assert convert_to_roman(500) == \\"D\\" assert convert_to_roman(900) == \\"CM\\" def test_convert_thousands(): assert convert_to_roman(1000) == \\"M\\" assert convert_to_roman(1984) == \\"MCMLXXXIV\\" assert convert_to_roman(2021) == \\"MMXXI\\" assert convert_to_roman(3999) == \\"MMMCMXCIX\\"","solution":"def convert_to_roman(num): Convert an integer to a Roman numeral. Parameters: num (int): A positive integer less than or equal to 3999 Returns: str: The Roman numeral representation of the integer val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num"},{"question":"def count_visible_buildings(heights: List[int]) -> int: Consider an array of integers representing the height of buildings in a row. An observer can see a building if and only if it is taller than all the buildings to its left. Your task is to return the number of buildings that can be seen from the left side of the row. >>> count_visible_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_visible_buildings([1, 1, 1, 1]) 1 >>> count_visible_buildings([4, 3, 2, 1]) 1 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([1, 3, 2, 5, 4, 6]) 4 pass from typing import List def test_empty_list(): assert count_visible_buildings([]) == 0 def test_single_building(): assert count_visible_buildings([5]) == 1 def test_increasing_heights(): assert count_visible_buildings([1, 2, 3, 4, 5]) == 5 def test_decreasing_heights(): assert count_visible_buildings([5, 4, 3, 2, 1]) == 1 def test_all_same_height(): assert count_visible_buildings([1, 1, 1, 1]) == 1 def test_mixed_heights(): assert count_visible_buildings([3, 7, 8, 3, 6, 1]) == 3 assert count_visible_buildings([1, 3, 2, 5, 4, 6]) == 4 def test_alternating_heights(): assert count_visible_buildings([1, 5, 2, 6, 3, 7]) == 4 def test_random_heights(): assert count_visible_buildings([4, 2, 3, 1, 5, 3, 6]) == 3","solution":"def count_visible_buildings(heights): Returns the number of buildings visible from the left side. if not heights: return 0 count = 1 max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"def replace_vowels(input_string: str) -> str: Replaces all vowels in the input string with '@' and returns the modified string. The replacement is done in a case-insensitive manner. >>> replace_vowels(\\"Programming is fun!\\") == \\"Pr@gr@mm@ng @s f@n!\\" >>> replace_vowels(\\"C0d1ng is c00l!\\") == \\"C0d1ng @s c00l!\\" >>> replace_vowels(\\"aeiouAEIOU\\") == \\"@@@@@@@@@@\\" >>> replace_vowels(\\"bcdfgh\\") == \\"bcdfgh\\" >>> replace_vowels(\\"\\") == \\"\\"","solution":"def replace_vowels(input_string): Replaces all vowels in the input string with '@' and returns the modified string. The replacement is done in a case-insensitive manner. vowels = \\"aeiouAEIOU\\" return ''.join('@' if char in vowels else char for char in input_string)"},{"question":"def count_pairs(n, k, arr): Count the number of distinct pairs (a, b) in the array such that a + b = k. Parameters: n (int): Size of the array k (int): Target sum arr (list of int): Array of integers Returns: int: Number of distinct pairs # Your code here def solve(test_cases): Solve multiple test cases of the count_pairs function. Parameters: test_cases (list of tuples): Each tuple contains (n, k, arr) for a test case Returns: list of int: List of results for each test case # Your code here # Unit Tests def test_count_pairs(): assert count_pairs(5, 10, [1, 2, 3, 7, 8]) == 2 assert count_pairs(4, 4, [1, 2, 3, 3]) == 1 assert count_pairs(6, 0, [-1, 1, -1, 1, 2, -2]) == 3 def test_solve(): test_cases = [ (5, 10, [1, 2, 3, 7, 8]), (4, 4, [1, 2, 3, 3]), (6, 0, [-1, 1, -1, 1, 2, -2]) ] expected_results = [2, 1, 3] assert solve(test_cases) == expected_results","solution":"def count_pairs(n, k, arr): Count the number of distinct pairs (a, b) in the array such that a + b = k. Parameters: n (int): Size of the array k (int): Target sum arr (list of int): Array of integers Returns: int: Number of distinct pairs seen = {} count = 0 for num in arr: target = k - num if target in seen and seen[target] > 0: count += 1 seen[target] -= 1 else: if num in seen: seen[num] += 1 else: seen[num] = 1 return count def solve(test_cases): Solve multiple test cases of the count_pairs function. Parameters: test_cases (list of tuples): Each tuple contains (n, k, arr) for a test case Returns: list of int: List of results for each test case results = [] for n, k, arr in test_cases: results.append(count_pairs(n, k, arr)) return results"},{"question":"def longest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Write a function that takes a list of integers \`arr\` and an integer \`k\` and returns the length of the longest subarray that contains at most \`k\` distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 3, 4], 2) 3 >>> longest_subarray_with_k_distinct([], 2) 0 >>> longest_subarray_with_k_distinct([1], 1) 1 >>> longest_subarray_with_k_distinct([2, 2, 2, 2], 1) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4], 2) 2 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 5) 5 pass","solution":"def longest_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if n * k == 0: return 0 left, right = 0, 0 hashmap = defaultdict(int) max_length = 1 while right < n: hashmap[arr[right]] += 1 while len(hashmap) > k: hashmap[arr[left]] -= 1 if hashmap[arr[left]] == 0: del hashmap[arr[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def forestPaths(h: int, w: int, paths: List[str]) -> int: Determines the number of distinct paths through a forest grid. You are given a forest in the form of a 2D grid with \`h\` rows and \`w\` columns. Each cell in the grid can either be walkable ('.') or contain an obstacle ('#'). Paths can only move right ('R') or down ('D') from the starting point at the top-left cell (0, 0) to the destination at the bottom-right cell (h-1, w-1). >>> forestPaths(3, 3, [\\"...\\",\\".#.\\",\\"...\\"]) 2 >>> forestPaths(3, 3, [\\".#.\\",\\".#.\\",\\"...\\"]) 1 >>> forestPaths(2, 2, [\\"..\\",\\"\\"]) 0 >>> forestPaths(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 6 >>> forestPaths(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) 0 >>> forestPaths(1, 1, [\\".\\"]) 1 >>> forestPaths(2, 2, [\\"#.\\", \\"..\\"]) 0 >>> forestPaths(2, 2, [\\"..\\", \\".#\\"]) 0","solution":"from typing import List def forestPaths(h: int, w: int, paths: List[str]) -> int: if paths[0][0] == '#' or paths[h-1][w-1] == '#': return 0 dp = [[0] * w for _ in range(h)] dp[0][0] = 1 for i in range(h): for j in range(w): if paths[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[h-1][w-1]"},{"question":"def sum_of_unique_elements(matrix): Returns the sum of all unique elements in the matrix. An element is considered unique if it appears exactly once in the entire matrix. pass def parse_input(input_data): Parses the input data to extract matrix dimensions and the matrix itself. Returns N, M and the matrix. pass # Unit tests def test_sum_of_unique_elements(): input_data = \\"3 3n1 2 3n4 5 6n7 2 4\\" N, M, matrix = parse_input(input_data) assert sum_of_unique_elements(matrix) == 22 def test_all_elements_unique(): input_data = \\"3 3n1 2 3n4 5 6n7 8 9\\" N, M, matrix = parse_input(input_data) assert sum_of_unique_elements(matrix) == 45 def test_no_unique_elements(): input_data = \\"3 3n1 1 1n1 1 1n1 1 1\\" N, M, matrix = parse_input(input_data) assert sum_of_unique_elements(matrix) == 0 def test_some_duplicates(): input_data = \\"3 3n1 2 3n1 5 6n7 8 2\\" N, M, matrix = parse_input(input_data) assert sum_of_unique_elements(matrix) == 29 def test_single_element_matrix(): input_data = \\"1 1n5\\" N, M, matrix = parse_input(input_data) assert sum_of_unique_elements(matrix) == 5 def test_large_matrix(): input_data = \\"2 5n1 2 3 4 5n5 4 3 2 1\\" N, M, matrix = parse_input(input_data) assert sum_of_unique_elements(matrix) == 0","solution":"def sum_of_unique_elements(matrix): Returns the sum of all unique elements in the matrix. An element is considered unique if it appears exactly once in the entire matrix. element_count = {} # Count the frequency of each element in the matrix for row in matrix: for element in row: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 # Sum up only the unique elements unique_sum = sum(key for key, value in element_count.items() if value == 1) return unique_sum def parse_input(input_data): Parses the input data to extract matrix dimensions and the matrix itself. Returns N, M and the matrix. data = input_data.strip().split('n') N, M = map(int, data[0].split()) matrix = [list(map(int, row.split())) for row in data[1:]] return N, M, matrix"},{"question":"def calculate_times(m: int, d: int, speeds: List[int]) -> List[int]: Given the number of participants, distance to cover, and list of maximum speeds, this function computes the minimum time required for each participant to cover the distance d. Parameters: m (int): Number of participants d (int): Distance to be covered speeds (list): List of maximum speeds for each participant Returns: list: List of minimum times for each participant to cover the distance pass # Unit Tests def test_calculate_times_example1(): result = calculate_times(4, 100, [10, 20, 5, 25]) assert result == [10, 5, 20, 4] def test_calculate_times_example2(): result = calculate_times(3, 150, [15, 50, 30]) assert result == [10, 3, 5] def test_calculate_times_single_participant(): result = calculate_times(1, 100, [10]) assert result == [10] def test_calculate_times_large_distance(): result = calculate_times(2, 1000000000, [10, 1]) assert result == [100000000, 1000000000] def test_calculate_times_large_number_of_participants(): result = calculate_times(5, 100, [10, 20, 30, 40, 50]) assert result == [10, 5, 4, 3, 2] def test_calculate_times_varied_speeds(): result = calculate_times(4, 120, [10, 15, 25, 30]) assert result == [12, 8, 5, 4]","solution":"def calculate_times(m, d, speeds): Given the number of participants, distance to cover, and list of maximum speeds, this function computes the minimum time required for each participant to cover the distance d. Parameters: m (int): Number of participants d (int): Distance to be covered speeds (list): List of maximum speeds for each participant Returns: list: List of minimum times for each participant to cover the distance times = [] for s in speeds: time = (d + s - 1) // s # Ceiling division times.append(time) return times"},{"question":"from typing import List, Tuple def find_overlaps(events: List[Tuple[str, str, str, str]]) -> List[str]: Analyzes a list of employee check-ins to identify any employees who have overlapping or conflicting check-ins. Args: events (List[Tuple[str, str, str, str]]): A list of tuples where each tuple contains: - employee_id (string): the unique ID of the employee, - room_id (string): the identifier of the room, - start_time (string in the format \\"HH:MM\\"): the check-in start time, - end_time (string in the format \\"HH:MM\\"): the check-in end time Returns: List[str]: A list of employee IDs who have conflicting check-ins. The output list is sorted in ascending order and does not contain duplicates. Examples: >>> find_overlaps([ (\\"E1\\", \\"Room1\\", \\"09:00\\", \\"10:00\\"), (\\"E2\\", \\"Room1\\", \\"09:30\\", \\"10:30\\"), (\\"E1\\", \\"Room2\\", \\"09:45\\", \\"10:45\\"), (\\"E3\\", \\"Room3\\", \\"11:00\\", \\"12:00\\"), (\\"E2\\", \\"Room2\\", \\"11:15\\", \\"12:15\\"), (\\"E3\\", \\"Room4\\", \\"11:30\\", \\"12:30\\") ]) [\\"E1\\", \\"E3\\"] >>> find_overlaps([ (\\"E1\\", \\"Room1\\", \\"09:00\\", \\"10:00\\"), (\\"E2\\", \\"Room1\\", \\"10:00\\", \\"11:00\\"), (\\"E3\\", \\"Room2\\", \\"11:00\\", \\"12:00\\") ]) [] >>> find_overlaps([ (\\"E1\\", \\"Room1\\", \\"09:00\\", \\"10:00\\"), (\\"E1\\", \\"Room2\\", \\"09:45\\", \\"10:45\\") ]) [\\"E1\\"]","solution":"from collections import defaultdict from datetime import datetime def parse_time(t): return datetime.strptime(t, \\"%H:%M\\") def find_overlaps(events): employee_events = defaultdict(list) for event in events: employee_id, room_id, start_time, end_time = event start_time = parse_time(start_time) end_time = parse_time(end_time) employee_events[employee_id].append((start_time, end_time)) conflicts = set() for employee_id, times in employee_events.items(): times.sort() for i in range(len(times) - 1): if times[i][1] > times[i+1][0]: conflicts.add(employee_id) break return sorted(conflicts)"},{"question":"def can_make_all_cells_equal(grid): Determine if it's possible to make all cells of the grid equal using the given operation. :param grid: The grid of integers. :return: \\"YES\\" if it's possible to make all cells equal, \\"NO\\" otherwise. >>> can_make_all_cells_equal([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) \\"NO\\" >>> can_make_all_cells_equal([[4, 4, 4, 4], [4, 4, 4, 4], [4, 4, 4, 3], [4, 4, 4, 3]]) \\"NO\\" >>> can_make_all_cells_equal([[1, 2], [3, 1]]) \\"YES\\" pass # Implementation required def solve(test_cases): Solve all the test cases. :param test_cases: List containing multiple grids. :return: List containing results for each test case (\\"YES\\" or \\"NO\\"). pass # Implementation required def read_input(input_string): Read input from string and format it into test cases. :param input_string: String input for test cases. :return: List of test cases. pass # Implementation required def main(input_string): Main function to read input string and solve test cases. :param input_string: The complete input as string. pass # Implementation required def test_valid_all_equal(): input_data = \\"1n2 2n1 1n1 1\\" expected_output = \\"YES\\" assert main(input_data) == expected_output def test_valid_single_row(): input_data = \\"1n1 3n1 1 1\\" expected_output = \\"YES\\" assert main(input_data) == expected_output def test_valid_single_column(): input_data = \\"1n3 1n1n1n1\\" expected_output = \\"YES\\" assert main(input_data) == expected_output def test_invalid_different_values(): input_data = \\"1n2 2n1 2n3 1\\" expected_output = \\"NO\\" assert main(input_data) == expected_output def test_mixed_cases(): input_data = \\"3n2 2n1 2n2 1n3 3n1 1 1n1 1 1n1 1 1n2 2n1 2n2 2\\" expected_output = \\"NOnYESnNO\\" assert main(input_data) == expected_output if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def can_make_all_cells_equal(grid): N = len(grid) M = len(grid[0]) target = grid[0][0] for row in grid: for value in row: if value != target: return \\"NO\\" return \\"YES\\" def solve(test_cases): results = [] for grid in test_cases: results.append(can_make_all_cells_equal(grid)) return results # Read input def read_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] idx = 1 for _ in range(T): N, M = map(int, input_lines[idx].split()) grid = [] idx += 1 for _ in range(N): row = list(map(int, input_lines[idx].split())) grid.append(row) idx += 1 test_cases.append(grid) return test_cases def main(input_string): test_cases = read_input(input_string) results = solve(test_cases) return \\"n\\".join(results)"},{"question":"def max_subarray_sum(nums): Find the sum of the contiguous subarray within a one-dimensional integer array which has the largest sum. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([3, -4, 2, 6, -8, 7]) 8 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([0, 0, 0, 0]) 0 >>> max_subarray_sum([-1, -1, -1, -1, 4, -1, -1, -1, -1]) 4","solution":"def max_subarray_sum(nums): Find the sum of the contiguous subarray within a one-dimensional integer array which has the largest sum. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def remove_odd_even(arr: List[int]) -> List[int]: Returns an array with only even elements if all elements are even, or only odd elements if all elements are odd, or an empty array if there are mixed even and odd elements. >>> remove_odd_even([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] >>> remove_odd_even([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9] >>> remove_odd_even([1, 2, 3, 4, 5]) == [] def test_all_even(): assert remove_odd_even([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] def test_all_odd(): assert remove_odd_even([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9] def test_mixed_even_odd(): assert remove_odd_even([1, 2, 3, 4, 5]) == [] def test_empty_list(): assert remove_odd_even([]) == [] def test_single_even_element(): assert remove_odd_even([2]) == [2] def test_single_odd_element(): assert remove_odd_even([1]) == [1] def test_large_mixed_array(): assert remove_odd_even([2, 4, 1, 3, 6, 8, 5]) == [] def test_large_all_even_array(): assert remove_odd_even([2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) == [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] def test_large_all_odd_array(): assert remove_odd_even([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]) == [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]","solution":"def remove_odd_even(arr): Returns an array with only even elements if all elements are even, or only odd elements if all elements are odd, or an empty array if there are mixed even and odd elements. if not arr: return [] is_all_even = all(x % 2 == 0 for x in arr) is_all_odd = all(x % 2 != 0 for x in arr) if is_all_even: return [x for x in arr if x % 2 == 0] elif is_all_odd: return [x for x in arr if x % 2 != 0] else: return []"},{"question":"def subset_sum_possible(spices, N, K): Check if it is possible to select a subset of spices that adds up to the exact target taste value K. # Your code here def chef_spices(T, test_cases): Determine for each test case whether a subset of spices can sum up to the target taste value and return 'YES' or 'NO' >>> chef_spices(2, [((4, 10), [2, 3, 7, 8]), ((5, 9), [1, 2, 3, 4, 5])]) == [\\"YES\\", \\"YES\\"] >>> chef_spices(2, [((3, 7), [1, 2, 3]), ((3, 5), [1, 2, 3])]) == [\\"NO\\", \\"YES\\"] >>> chef_spices(2, [((4, 11), [1, 2, 5, 6]), ((6, 13), [1, 2, 2, 5, 6, 7])]) == [\\"YES\\", \\"YES\\"] >>> chef_spices(2, [((4, 15), [1, 2, 3, 8]), ((4, 1), [2, 3, 4, 5])]) == [\\"NO\\", \\"NO\\"] # Your code here","solution":"def subset_sum_possible(spices, N, K): Check if it is possible to select a subset of spices that adds up to the exact target taste value K. dp = [False] * (K + 1) dp[0] = True for spice in spices: for j in range(K, spice - 1, -1): dp[j] = dp[j] or dp[j - spice] return dp[K] def chef_spices(T, test_cases): Determine for each test case whether a subset of spices can sum up to the target taste value and return 'YES' or 'NO' results = [] for i in range(T): N, K = test_cases[i][0] spices = test_cases[i][1] result = \\"YES\\" if subset_sum_possible(spices, N, K) else \\"NO\\" results.append(result) return results"},{"question":"def determine_wealth_outcome(citizens_queue: str) -> str: Determines which type of citizen has higher collective wealth by the end of the event. Parameters: citizens_queue (str): A string representing the sequence of citizens in the queue ('M' for Merchant, 'F' for Farmer) Returns: str: 'Merchant', 'Farmer' or 'Tie' based on which type has higher collective wealth. Examples: >>> determine_wealth_outcome(\\"MF\\") 'Tie' >>> determine_wealth_outcome(\\"MMF\\") 'Merchant' >>> determine_wealth_outcome(\\"FMM\\") 'Tie'","solution":"def determine_wealth_outcome(citizens_queue): Determines which type of citizen has higher collective wealth by the end of the event. Parameters: citizens_queue (str): A string representing the sequence of citizens in the queue ('M' for Merchant, 'F' for Farmer) Returns: str: 'Merchant', 'Farmer' or 'Tie' based on which type has higher collective wealth. merchants = citizens_queue.count('M') farmers = citizens_queue.count('F') if merchants > farmers: return \\"Merchant\\" elif farmers > merchants: return \\"Farmer\\" else: return \\"Tie\\""},{"question":"def generateBookCode(book_id: int, title: str, author: str) -> str: Generates a unique code for a book according to the specified format. Parameters: book_id (int): The unique ID of the book. title (str): The title of the book. author (str): The author of the book. Returns: str: The unique code for the book. >>> generateBookCode(150, \\"Harry Potter\\", \\"J.K. Rowling\\") == \\"00150-HARRY-POTTER_ROW\\" >>> generateBookCode(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") == \\"00001-TO-KILL-A-MOCKINGBIRD_LEE\\"","solution":"def generateBookCode(book_id, title, author): Generates a unique code for a book according to the specified format. Parameters: book_id (int): The unique ID of the book. title (str): The title of the book. author (str): The author of the book. Returns: str: The unique code for the book. book_id_str = str(book_id).zfill(5) title_str = title.upper().replace(\\" \\", \\"-\\") author_last_name = author.split()[-1] author_code = author_last_name[:3].upper() return f\\"{book_id_str}-{title_str}_{author_code}\\""},{"question":"from typing import List def rotate_grid(grid: List[List[int]]) -> List[List[int]]: Rotate the grid 90 degrees clockwise. Args: grid (List[List[int]]): 2D list representing the grid of integers. Returns: List[List[int]]: A new 2D list which is the result of rotating the input grid 90 degrees clockwise. >>> rotate_grid([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_grid([[1]]) [[1]] >>> rotate_grid([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]] >>> rotate_grid([ ... [1, 2, 3, 4, 5, 6, 7], ... [8, 9, 10, 11, 12, 13, 14], ... [15, 16, 17, 18, 19, 20, 21], ... [22, 23, 24, 25, 26, 27, 28], ... [29, 30, 31, 32, 33, 34, 35], ... [36, 37, 38, 39, 40, 41, 42], ... [43, 44, 45, 46, 47, 48, 49] ... ]) [[43, 36, 29, 22, 15, 8, 1], [44, 37, 30, 23, 16, 9, 2], [45, 38, 31, 24, 17, 10, 3], [46, 39, 32, 25, 18, 11, 4], [47, 40, 33, 26, 19, 12, 5], [48, 41, 34, 27, 20, 13, 6], [49, 42, 35, 28, 21, 14, 7]]","solution":"def rotate_grid(grid): n = len(grid) rotated_grid = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_grid[j][n - 1 - i] = grid[i][j] return rotated_grid"},{"question":"from typing import List, Tuple def cumulative_sum_and_product(lst: List[int]) -> Tuple[List[int], List[int]]: Takes a list of integers and returns a tuple containing two lists: one list of the cumulative sums and another list of their cumulative products. >>> cumulative_sum_and_product([1, 2, 3, 4]) == ([1, 3, 6, 10], [1, 2, 6, 24]) >>> cumulative_sum_and_product([5, 10, 15]) == ([5, 15, 30], [5, 50, 750]) >>> cumulative_sum_and_product([1]) == ([1], [1]) >>> cumulative_sum_and_product([]) == ([], [])","solution":"def cumulative_sum_and_product(lst): Returns a tuple of two lists: - the cumulative sums of the input list - the cumulative products of the input list if not lst: return ([], []) cumulative_sum = [] cumulative_product = [] sum_so_far = 0 product_so_far = 1 for num in lst: sum_so_far += num product_so_far *= num cumulative_sum.append(sum_so_far) cumulative_product.append(product_so_far) return (cumulative_sum, cumulative_product)"},{"question":"def filterNumbers(arr, toRemove): Filters out all instances of numbers from toRemove in the array arr. :param arr: List of integers to filter. :param toRemove: List of integers to be removed from arr. :return: A new list with the numbers from toRemove removed. pass def test_filter_basic(): assert filterNumbers([1, 2, 3, 4, 5, 6], [2, 4, 6]) == [1, 3, 5] def test_with_no_removal(): assert filterNumbers([10, 20, 30, 40, 50], []) == [10, 20, 30, 40, 50] def test_with_no_result(): assert filterNumbers([5, 5, 5, 5, 5], [5]) == [] def test_with_partial_removal(): assert filterNumbers([10, 20, 30, 40, 50], [25, 30, 60]) == [10, 20, 40, 50] def test_with_empty_array(): assert filterNumbers([], [1, 2, 3, 4, 5]) == [] def test_with_large_input_size(): data = list(range(1000)) remove_data = list(range(500, 1000)) assert filterNumbers(data, remove_data) == list(range(500))","solution":"def filterNumbers(arr, toRemove): Filters out all instances of numbers from toRemove in the array arr. :param arr: List of integers to filter. :param toRemove: List of integers to be removed from arr. :return: A new list with the numbers from toRemove removed. to_remove_set = set(toRemove) return [num for num in arr if num not in to_remove_set]"},{"question":"def find_longest_substring(s: str) -> int: Finds the length of the longest substring without repeating characters. >>> find_longest_substring('abcabcbb') == 3 >>> find_longest_substring('bbbbb') == 1 >>> find_longest_substring('pwwkew') == 3 >>> find_longest_substring('dvdf') == 3 >>> find_longest_substring('anviaj') == 5 >>> find_longest_substring('clementisacap') == 8 >>> find_longest_substring('') == 0 >>> find_longest_substring('a') == 1 >>> find_longest_substring('1234!@#') == 8 >>> find_longest_substring('1231!@2') == 5 >>> find_longest_substring('abcd%^abcd') == 7","solution":"def find_longest_substring(s): Finds the length of the longest substring without repeating characters. n = len(s) longest = 0 start = 0 seen = {} for end in range(n): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1 seen[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"from typing import List, Dict def count_fruits(fruit_list: List[str]) -> Dict[str, int]: Takes a list of strings representing different types of fruits, and returns a dictionary with the count of each type of fruit. The fruit names are case-insensitive. >>> count_fruits([\\"Apple\\", \\"Banana\\", \\"apple\\", \\"Orange\\", \\"banana\\", \\"BANANA\\", \\"orange\\", \\"ORANGE\\", \\"apple\\"]) == {'apple': 3, 'banana': 3, 'orange': 3} >>> count_fruits([\\"kiwi\\", \\"mango\\", \\"Kiwi\\", \\"MANGO\\", \\"kiWI\\", \\"ManGO\\"]) == {'kiwi': 3, 'mango': 3} >>> count_fruits([]) == {}","solution":"from typing import List, Dict def count_fruits(fruit_list: List[str]) -> Dict[str, int]: fruit_count = {} for fruit in fruit_list: fruit_lower = fruit.lower() if fruit_lower in fruit_count: fruit_count[fruit_lower] += 1 else: fruit_count[fruit_lower] = 1 return fruit_count"},{"question":"def next_permutation(nums): Transforms the input list 'nums' to its next lexicographically greater permutation. If no such permutation exists, transforms 'nums' to the smallest possible permutation. >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] >>> next_permutation([1]) [1] >>> next_permutation([2, 2, 2]) [2, 2, 2] >>> next_permutation([1, 3, 2]) [2, 1, 3] >>> next_permutation([2, 1, 3]) [2, 3, 1] >>> next_permutation([2, 3, 1]) [3, 1, 2]","solution":"def next_permutation(nums): Transforms the input list 'nums' to its next lexicographically greater permutation. If no such permutation exists, transforms 'nums' to the smallest possible permutation. # Step 1: Find the first decreasing element from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # Step 2: If such element exists, find the element just larger than itself if i >= 0: j = len(nums) - 1 while j >= 0 and nums[j] <= nums[i]: j -= 1 # Step 3: Swap these two elements nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the elements after the first found element nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def fizz_buzz() -> List[str]: Returns a list with the numbers from 1 to 100 transformed based on the FizzBuzz rules: - Multiples of 3 are replaced with \\"Fizz\\". - Multiples of 5 are replaced with \\"Buzz\\". - Multiples of both 3 and 5 are replaced with \\"FizzBuzz\\".","solution":"def fizz_buzz(): Returns a list with the numbers from 1 to 100 transformed based on the FizzBuzz rules: - Multiples of 3 are replaced with \\"Fizz\\". - Multiples of 5 are replaced with \\"Buzz\\". - Multiples of both 3 and 5 are replaced with \\"FizzBuzz\\". result = [] for num in range(1, 101): if num % 3 == 0 and num % 5 == 0: result.append(\\"FizzBuzz\\") elif num % 3 == 0: result.append(\\"Fizz\\") elif num % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(num)) return result"},{"question":"def sum_of_squares(lst: List[int]) -> int: Returns the sum of squares of all even numbers in a given list of integers. Non-integer values in the list are ignored. >>> sum_of_squares([1, 2, 'x', 3.5, 4, 5, -6.1, 8, -10]) == 184 >>> sum_of_squares([2, 4, 6, 8]) == 4 + 16 + 36 + 64 >>> sum_of_squares([1, 3, 5, 7, 9, 'a', 3.3]) == 0 >>> sum_of_squares(['x', 3.5, -6.1]) == 0 >>> sum_of_squares([2, 1, 4, 3, 6, 5]) == 4 + 16 + 36","solution":"def sum_of_squares(lst): Returns the sum of squares of all even numbers in a given list of integers. Non-integer values in the list are ignored. return sum(x**2 for x in lst if isinstance(x, int) and x % 2 == 0)"},{"question":"def find_duplicate(nums: List[int]) -> int: Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive, return the duplicate number. You must solve the problem without modifying the array nums and use only constant extra space. >>> find_duplicate([1, 3, 4, 2, 2]) 2 >>> find_duplicate([3, 1, 3, 4, 2]) 3 >>> find_duplicate([1, 1]) 1 >>> find_duplicate([1, 1, 2]) 1 from solution import find_duplicate def test_find_duplicate_example1(): assert find_duplicate([1, 3, 4, 2, 2]) == 2 def test_find_duplicate_example2(): assert find_duplicate([3, 1, 3, 4, 2]) == 3 def test_find_duplicate_example3(): assert find_duplicate([1, 1]) == 1 def test_find_duplicate_example4(): assert find_duplicate([1, 1, 2]) == 1 def test_find_duplicate_large_input(): assert find_duplicate(list(range(1, 100001)) + [50000]) == 50000","solution":"def find_duplicate(nums): Find the duplicate number in an array where there's exactly one duplicated integer. :param nums: List[int] - List of integers :return: int - The duplicated integer # Using Floyd's Tortoise and Hare (Cycle Detection) Algorithm # Phase 1: Finding the intersection point of the two runners. tortoise = nums[0] hare = nums[0] while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Phase 2: Finding the entrance to the cycle. tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"def max_distinct_substrings(s: str) -> int: Determines the maximum number of distinct substrings of string s after rearranging its characters, modulo 10^9 + 7. >>> max_distinct_substrings(\\"ab\\") 4 >>> max_distinct_substrings(\\"abc\\") 15 pass","solution":"def max_distinct_substrings(s): Determines the maximum number of distinct substrings of string s after rearranging its characters. n = len(s) MOD = 10**9 + 7 # The number of distinct substrings is given by sum of first N natural numbers total_substrings = (n * (n + 1) // 2) % MOD return total_substrings"},{"question":"from typing import List, Tuple def next_streets(T: int, test_cases: List[int]) -> List[Tuple[int, int, int]]: Determines the next three streets in the order the friends will explore. Args: T (int): The number of test cases. test_cases (List[int]): A list of starting street numbers. Returns: List[Tuple[int, int, int]]: A list of tuples containing the next three streets for each test case. Examples: >>> next_streets(1, [2]) [(4, 3, 49)] >>> next_streets(3, [2, 5, 10]) [(4, 3, 49), (10, 6, 56), (20, 11, 61)]","solution":"def next_streets(T, test_cases): vowels = set('aeiouAEIOU') results = [] for N in test_cases: street_name = f\\"{N}a\\" vowel_count = sum(1 for char in street_name if char in vowels) first_street = 2 * N second_street = N + vowel_count third_street = (first_street + second_street) ** 2 % 100 results.append((first_street, second_street, third_street)) return results"},{"question":"def digits_to_words(input_str: str) -> str: Converts all digits in a string to their word equivalents. Parameters: input_str (str): The string containing digits to be converted. Returns: str: The string with digits replaced by their word equivalents. >>> digits_to_words(\\"1\\") 'one' >>> digits_to_words(\\"5\\") 'five' >>> digits_to_words(\\"123\\") 'onetwothree' >>> digits_to_words(\\"007\\") 'zerozeroseven' >>> digits_to_words(\\"Hello2World\\") 'HellotwoWorld' >>> digits_to_words(\\"H3ll5\\") 'Hthreellfive' >>> digits_to_words(\\"HelloWorld\\") 'HelloWorld' >>> digits_to_words(\\"\\") ''","solution":"def digits_to_words(input_str): Converts all digits in a string to their word equivalents. Parameters: input_str (str): The string containing digits to be converted. Returns: str: The string with digits replaced by their word equivalents. digit_to_word = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } return ''.join(digit_to_word.get(char, char) for char in input_str)"},{"question":"def find_median(numbers: str) -> float: Returns the median of a list of integers found in the input string. The integers are separated by commas. >>> find_median(\\"1,3,3,6,7,8,9\\") == 6.0 >>> find_median(\\"1,2,3\\") == 2.0 >>> find_median(\\"7,8,9,10,11\\") == 9.0 >>> find_median(\\"3,1,2\\") == 2.0 >>> find_median(\\"9,7,8,10,11\\") == 9.0 >>> find_median(\\"-1,-3,-2,-4,-5\\") == -3.0 >>> find_median(\\"-10,-20,-30\\") == -20.0 >>> find_median(\\"-1,3,2,0,1\\") == 1.0 >>> find_median(\\"-1,-2,0,1,2\\") == 0.0","solution":"def find_median(numbers: str) -> float: Returns the median of a list of integers found in the input string. The integers are separated by commas. nums = list(map(int, numbers.split(','))) nums.sort() n = len(nums) median = float(nums[n // 2]) return median"},{"question":"def calculate_ascii_score(user_id: str) -> int: Calculate the ASCII score of a user ID by summing the ASCII values of all characters in the user ID. >>> calculate_ascii_score(\\"A3B\\") 182 >>> calculate_ascii_score(\\"a\\") 97 pass def find_highest_score_user(ids: List[str]) -> List[str]: Given a list of user IDs, find the user ID(s) with the highest ASCII value score. In case of a tie, return all user IDs with the highest score. >>> find_highest_score_user([\\"Alice123\\", \\"Bob456\\", \\"Charlie789\\", \\"Delta0\\", \\"Echo999\\"]) [\\"Charlie789\\"] >>> find_highest_score_user([\\"Bob\\", \\"Charlie\\", \\"David\\"]) [\\"Charlie\\"] >>> find_highest_score_user([]) [] pass","solution":"def calculate_ascii_score(user_id): Calculate the ASCII score of a user ID by summing ASCII values of all characters. return sum(ord(char) for char in user_id) def find_highest_score_user(ids): Given a list of user IDs, find the one(s) with the highest ASCII value score. if not ids: return [] highest_score = float('-inf') highest_scoring_ids = [] for user_id in ids: score = calculate_ascii_score(user_id) if score > highest_score: highest_score = score highest_scoring_ids = [user_id] elif score == highest_score: highest_scoring_ids.append(user_id) return highest_scoring_ids"},{"question":"def can_construct(word: str, magazine: str) -> bool: Determines if a word can be constructed using letters from the magazine string. Each letter in the magazine can only be used once. :param word: The word to be constructed. :param magazine: The string containing letters that can be used to construct the word. :return: True if the word can be constructed, False otherwise. from collections import Counter >>> can_construct(\\"hello\\", \\"hleolowo\\") True >>> can_construct(\\"hello\\", \\"world\\") False >>> can_construct(\\"abc\\", \\"bac\\") True >>> can_construct(\\"aabb\\", \\"ab\\") False >>> can_construct(\\"test\\", \\"tesstest\\") True >>> can_construct(\\"\\", \\"anyletters\\") True >>> can_construct(\\"word\\", \\"\\") False >>> can_construct(\\"\\", \\"\\") True >>> can_construct(\\"a\\", \\"aaaaa\\") True >>> can_construct(\\"aaa\\", \\"aaaaa\\") True >>> can_construct(\\"aaaaaa\\", \\"aaaaa\\") False","solution":"def can_construct(word, magazine): Determines if a word can be constructed using letters from the magazine string. Each letter in the magazine can only be used once. :param word: The word to be constructed. :param magazine: The string containing letters that can be used to construct the word. :return: True if the word can be constructed, False otherwise. from collections import Counter word_counter = Counter(word) magazine_counter = Counter(magazine) for char in word_counter: if word_counter[char] > magazine_counter.get(char, 0): return False return True"},{"question":"def replace_forbidden_words(sentence: str, forbiddenWords: List[str]) -> str: Replaces each forbidden word in the sentence with a string of asterisks (*) of the same length as the forbidden word. Parameters: sentence (str): The input sentence. forbiddenWords (list): A list of forbidden words to be replaced. Returns: str: The sentence with forbidden words replaced by asterisks. >>> replace_forbidden_words(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"fox\\", \\"lazy\\"]) \\"The ***** brown *** jumps over the **** dog\\" >>> replace_forbidden_words(\\"The clever cat\\", []) \\"The clever cat\\" >>> replace_forbidden_words(\\"hello world\\", [\\"hello\\", \\"world\\"]) \\"***** *****\\" >>> replace_forbidden_words(\\"My password is secret\\", [\\"password\\", \\"secret\\"]) \\"My ******** is ******\\" >>> replace_forbidden_words(\\"I am happy and happy\\", [\\"happy\\"]) \\"I am ***** and *****\\" >>> replace_forbidden_words(\\"Imposibilities are possible\\", [\\"possibilities\\"]) \\"Imposibilities are possible\\"","solution":"def replace_forbidden_words(sentence, forbiddenWords): Replaces each forbidden word in the sentence with a string of asterisks (*) of the same length as the forbidden word. Parameters: sentence (str): The input sentence. forbiddenWords (list): A list of forbidden words to be replaced. Returns: str: The sentence with forbidden words replaced by asterisks. words = sentence.split() for i in range(len(words)): if words[i] in forbiddenWords: words[i] = '*' * len(words[i]) return ' '.join(words)"},{"question":"def can_transform(str1: str, str2: str) -> bool: Determine if str1 can be transformed into str2 by rearranging its characters. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 can be transformed into str2, otherwise False. Examples: >>> can_transform(\\"listen\\", \\"silent\\") True >>> can_transform(\\"triangle\\", \\"integral\\") True >>> can_transform(\\"apple\\", \\"papel\\") True >>> can_transform(\\"rat\\", \\"car\\") False >>> can_transform(\\"aabb\\", \\"abab\\") True >>> can_transform(\\"abcd\\", \\"abcde\\") False >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"a\\", \\"a\\") True >>> can_transform(\\"a\\", \\"b\\") False >>> can_transform(\\"Aa\\", \\"aA\\") True >>> can_transform(\\"aA\\", \\"AA\\") False >>> can_transform(\\"abc\\", \\"Abc\\") False","solution":"def can_transform(str1, str2): Determine if str1 can be transformed into str2 by rearranging its characters. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 can be transformed into str2, otherwise False. return sorted(str1) == sorted(str2)"},{"question":"class LibrarySystem: def __init__(self, books): Initialize the library system with a list of available book IDs. def borrow_book(self, book_id): Borrows a book from the library if it is available. Prints \\"BORROWED\\" if the book was successfully borrowed, otherwise prints \\"ALREADY BORROWED\\". def return_book(self, book_id): Returns a borrowed book to the library. Prints \\"RETURNED\\" if the book was successfully returned, otherwise prints \\"NOT BORROWED\\". # Unit Test import pytest from io import StringIO def test_library_system_operations(capsys): # Initialize LibrarySystem with a list of books library = LibrarySystem([1, 2, 3, 4, 5]) # Test borrow operations library.borrow_book(2) captured = capsys.readouterr() assert captured.out.strip() == \\"BORROWED\\" library.borrow_book(2) captured = capsys.readouterr() assert captured.out.strip() == \\"ALREADY BORROWED\\" library.borrow_book(3) captured = capsys.readouterr() assert captured.out.strip() == \\"BORROWED\\" library.borrow_book(5) captured = capsys.readouterr() assert captured.out.strip() == \\"BORROWED\\" # Test return operations library.return_book(2) captured = capsys.readouterr() assert captured.out.strip() == \\"RETURNED\\" library.return_book(2) captured = capsys.readouterr() assert captured.out.strip() == \\"NOT BORROWED\\" library.return_book(5) captured = capsys.readouterr() assert captured.out.strip() == \\"RETURNED\\" # Test borrowing a returned book library.borrow_book(2) captured = capsys.readouterr() assert captured.out.strip() == \\"BORROWED\\" pytest.main()","solution":"class LibrarySystem: def __init__(self, books): Initialize the library system with a list of available book IDs. self.available_books = set(books) self.borrowed_books = set() def borrow_book(self, book_id): Borrows a book from the library if it is available. Prints \\"BORROWED\\" if the book was successfully borrowed, otherwise prints \\"ALREADY BORROWED\\". if book_id in self.available_books: self.available_books.remove(book_id) self.borrowed_books.add(book_id) print(\\"BORROWED\\") else: print(\\"ALREADY BORROWED\\") def return_book(self, book_id): Returns a borrowed book to the library. Prints \\"RETURNED\\" if the book was successfully returned, otherwise prints \\"NOT BORROWED\\". if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) self.available_books.add(book_id) print(\\"RETURNED\\") else: print(\\"NOT BORROWED\\")"},{"question":"def max_path_sum(N: int, M: int, grid: List[List[int]]) -> int: Finds the maximum sum of values collected by moving from the top-left to the bottom-right of the grid, by only moving down or right. >>> max_path_sum(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_path_sum(1, 5, [ ... [1, 2, 3, 4, 5] ... ]) 15 >>> max_path_sum(5, 1, [ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) 15 >>> max_path_sum(2, 2, [ ... [1000, 1000], ... [1000, 1000] ... ]) 3000 >>> max_path_sum(3, 3, [ ... [1, 2, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 11","solution":"def max_path_sum(N, M, grid): # Create a DP table with the same dimensions as the grid dp = [[0] * M for _ in range(N)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, M): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The value at the bottom-right corner is the result return dp[N - 1][M - 1]"},{"question":"def max_relative_score_difference(scores: List[int]) -> float: Given an array \`scores\` where each element represents the score of a problem, return the maximum relative score difference one can obtain by selecting one problem's score and dividing it by another problem's score. The relative score difference is calculated as \`score[i] / score[j]\` where \`i\` and \`j\` are indices in the \`scores\` array and \`i != j\`. >>> max_relative_score_difference([2, 3, 6, 8]) 4.0 >>> max_relative_score_difference([1, 5]) 5.0","solution":"def max_relative_score_difference(scores): Returns the maximum relative score difference one can obtain by dividing the highest score by the lowest score in the array 'scores'. max_score = max(scores) min_score = min(scores) return max_score / min_score"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Given a list of non-negative integers nums, arrange them such that they form the largest possible number. The result should be represented as a string, not an integer. Example: >>> largest_number([10, 2]) \\"210\\" >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\" >>> largest_number([1]) \\"1\\" >>> largest_number([10]) \\"10\\" >>> largest_number([0, 0]) \\"0\\" >>> largest_number([111, 111, 111]) \\"111111111\\" >>> largest_number([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) \\"9876543210\\"","solution":"from functools import cmp_to_key def largest_number(nums): def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert numbers to strings for easy comparison nums_str = list(map(str, nums)) # Sort the numbers based on the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Concatenate the results result = ''.join(nums_str) # Handle the case where the result is leading with multiple zeros return '0' if result[0] == '0' else result"},{"question":"def is_prime(n: int) -> bool: Helper function to determine if a number is prime. # Your implementation def filter_primes(lst: list) -> list: Takes a list of integers as input and returns a list of prime numbers. If the input is not a list, returns \\"Please enter a valid list\\". >>> filter_primes([10, 15, 3, 7, 8, \\"abc\\", 2, 4.5]) [3, 7, 2] >>> filter_primes(\\"12345\\") \\"Please enter a valid list\\" >>> filter_primes([20, 30, 40]) [] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] # Your implementation","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def filter_primes(lst): Takes a list of integers and returns a list of prime numbers. If the input is not a list, returns \\"Please enter a valid list\\". if not isinstance(lst, list): return \\"Please enter a valid list\\" return [x for x in lst if isinstance(x, int) and is_prime(x)]"},{"question":"def find_pair_with_sum(lst: List[int], target: int) -> Union[Tuple[int, int], None]: Returns a pair of integers from the list that sum up to the target value, or None if no such pair exists. >>> find_pair_with_sum([1, 2, 3, 9], 8) == None >>> find_pair_with_sum([1, 2, 4, 4], 8) == (4, 4) >>> find_pair_with_sum([1, 2, 3, 4, 6], 10) == (4, 6) from solution import find_pair_with_sum def test_find_pair_with_sum_no_pair(): assert find_pair_with_sum([1, 2, 3, 9], 8) == None def test_find_pair_with_sum_pair_exists(): assert find_pair_with_sum([1, 2, 4, 4], 8) == (4, 4) assert find_pair_with_sum([1, 2, 3, 4, 6], 10) == (4, 6) def test_find_pair_with_sum_negative_numbers(): assert find_pair_with_sum([-1, -2, -3, -4], -5) == (-2, -3) def test_find_pair_with_sum_empty_list(): assert find_pair_with_sum([], 10) == None def test_find_pair_with_sum_single_element(): assert find_pair_with_sum([5], 10) == None def test_find_pair_with_sum_multiple_possible_pairs(): result = find_pair_with_sum([1, 2, 3, 4, 5], 6) assert result in [(1, 5), (2, 4)]","solution":"def find_pair_with_sum(lst, target): Returns a pair of integers from the list that sum up to the target value, or None if no such pair exists. seen = set() for num in lst: complement = target - num if complement in seen: return (complement, num) seen.add(num) return None"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n grid, starting from the top-left corner to the bottom-right corner, moving only down or right. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(3, 3) 6 >>> unique_paths(100, 1) 1 >>> unique_paths(1, 100) 1","solution":"def unique_paths(m, n): Calculate the number of unique paths in an m x n grid, starting from the top-left corner to the bottom-right corner, moving only down or right. # Create a 2D array to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # There's only one way to reach any cell in the first row or first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the number of unique paths to reach it return dp[m-1][n-1]"},{"question":"def find_pair_with_sum(arr, S): Given an integer array \`arr\` and a target sum \`S\`, determine if there are two distinct elements in the array such that their sum is equal to \`S\`. If a pair is found, return the pair, otherwise return \\"No pair found\\". >>> find_pair_with_sum([1, 2, 3, 4, 5], 7) (2, 5) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) \\"No pair found\\" >>> find_pair_with_sum([-1, -2, -3, -4, 1, 2, 3, 4], -5) (-2, -3) >>> find_pair_with_sum([10**9, 2*10**9, -10**9, -2*10**9], 0) (1000000000, -1000000000)","solution":"def find_pair_with_sum(arr, S): Given an integer array \`arr\` and a target sum \`S\`, determine if there are two distinct elements in the array such that their sum is equal to \`S\`. If a pair is found, return the pair, otherwise return \\"No pair found\\". seen = {} for number in arr: complement = S - number if complement in seen: return (complement, number) seen[number] = True return \\"No pair found\\""},{"question":"def canFormPalindrome(s: str) -> bool: Returns True if the string s can be rearranged to form a palindrome, False otherwise. >>> canFormPalindrome(\\"civic\\") # True >>> canFormPalindrome(\\"ivicc\\") # True >>> canFormPalindrome(\\"hello\\") # False","solution":"def canFormPalindrome(s): Returns True if the string s can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find how many characters have an odd count odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be rearranged into a palindrome, # there should be at most one character with an odd count return odd_counts <= 1"},{"question":"def encode_roman(num: int) -> str: Converts an integer number to a Roman numeral representation. Handles numbers from 1 to 3999 (inclusive). >>> encode_roman(3) 'III' >>> encode_roman(4) 'IV' >>> encode_roman(9) 'IX' >>> encode_roman(58) 'LVIII' >>> encode_roman(1994) 'MCMXCIV'","solution":"def encode_roman(num: int) -> str: Converts an integer number to a Roman numeral representation. Handles numbers from 1 to 3999 (inclusive). roman_numerals = [ ('M', 1000), ('CM', 900), ('D', 500), ('CD', 400), ('C', 100), ('XC', 90), ('L', 50), ('XL', 40), ('X', 10), ('IX', 9), ('V', 5), ('IV', 4), ('I', 1) ] result = [] for roman, value in roman_numerals: while num >= value: result.append(roman) num -= value return ''.join(result)"},{"question":"def spiral_matrix(n: int) -> str: Generates an n x n spiral matrix and returns its string representation. Args: n (int): The size of the spiral matrix. Returns: str: The string representation of the n x n spiral matrix. Examples: >>> spiral_matrix(1) '1' >>> spiral_matrix(2) '1 2n4 3' >>> spiral_matrix(3) '1 2 3n8 9 4n7 6 5' >>> spiral_matrix(4) ' 1 2 3 4n12 13 14 5n11 16 15 6n10 9 8 7' >>> spiral_matrix(5) ' 1 2 3 4 5n16 17 18 19 6n15 24 25 20 7n14 23 22 21 8n13 12 11 10 9'","solution":"def spiral_matrix(n): Generates an n x n spiral matrix and returns its string representation. if n == 1: return \\"1\\" # Initialize the matrix with zeros matrix = [[0]*n for _ in range(n)] # Set the boundaries for the spiral movement top, bottom, left, right = 0, n-1, 0, n-1 num = 1 # Loop until all numbers are filled in the matrix while num <= n * n: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 # Transform matrix into required formatted string largest_num_width = len(str(n * n)) result = [] for row in matrix: formatted_row = ' '.join(f'{num:>{largest_num_width}}' for num in row) result.append(formatted_row) return \\"n\\".join(result)"},{"question":"def minimal_path_sum(grid): Given a 2D grid of integers, find the minimal path sum from the top-left corner to the bottom-right corner, where you can only move either right or down. >>> minimal_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minimal_path_sum([[1, 2], [1, 1]]) 3 pass def solve_minimal_path_sum(test_cases): Given multiple test cases represented as a list of grids, find the minimal path sum for each grid. The function should return a list of minimal path sums for each grid. >>> solve_minimal_path_sum([[[1, 3, 1], [1, 5, 1], [4, 2, 1]], [[1, 2], [1, 1]]]) [7, 3] pass def parse_input(input_data): Parses the input data into the required format. >>> parse_input(\\"2n3n1 3 1n1 5 1n4 2 1n2n1 2n1 1\\") [[[1, 3, 1], [1, 5, 1], [4, 2, 1]], [[1, 2], [1, 1]]] pass","solution":"def minimal_path_sum(grid): Given a 2D grid of integers, find the minimal path sum from the top-left corner to the bottom-right corner, where you can only move either right or down. n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row and first column for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] def solve_minimal_path_sum(test_cases): results = [] for grid in test_cases: results.append(minimal_path_sum(grid)) return results def parse_input(input_data): Parses the input data into the required format. lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) grid = [] for i in range(n): grid.append(list(map(int, lines[index + 1 + i].split()))) test_cases.append(grid) index += n + 1 return test_cases"},{"question":"def evaluate_expression(expression: str) -> int: Write a function \`evaluate_expression\` that takes a string representing a mathematically valid infix expression and returns the result of evaluating the expression as an integer. The infix expression will contain only non-negative integers, parentheses \`()\`, and the operators for addition \`+\`, subtraction \`-\`, multiplication \`*\`, and division \`/\`. The division should be integer division. The function should consider operator precedence and handle whitespace within the expression. Example: >>> evaluate_expression(\\" 3 + 5 * 2 / ( 7 - 3 ) \\") 5","solution":"def evaluate_expression(expression: str) -> int: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # use int() to perform integer division def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue elif expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): value = 0 while i < len(expression) and expression[i].isdigit(): value = value * 10 + int(expression[i]) i += 1 values.append(value) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def calculate_active_time(events: List[Tuple[int, int, int]]) -> Dict[int, int]: Calculate the active time for each event given the list of event logs. :param events: List of tuples where each tuple represents an event (event ID, entry/exit, timestamp) :return: Dictionary where keys are event IDs and values are total active time in seconds","solution":"from typing import List, Tuple, Dict def calculate_active_time(events: List[Tuple[int, int, int]]) -> Dict[int, int]: Calculate the active time for each event given the list of event logs. :param events: List of tuples where each tuple represents an event (event ID, entry/exit, timestamp) :return: Dictionary where keys are event IDs and values are total active time in seconds active_times = {} event_start_times = {} for event_id, status, timestamp in events: if status == 1: # Entry event event_start_times[event_id] = timestamp elif status == 0: # Exit event if event_id in event_start_times: if event_id in active_times: active_times[event_id] += timestamp - event_start_times[event_id] else: active_times[event_id] = timestamp - event_start_times[event_id] event_start_times.pop(event_id, None) return active_times"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Finds the area of the largest rectangle that can be formed within the bounds of the histogram. :param heights: List[int] - a list representing the heights of the bars in the histogram :return: int - the area of the largest rectangle >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2,4]) 4","solution":"def largestRectangleArea(heights): Finds the area of the largest rectangle that can be formed within the bounds of the histogram. :param heights: List[int] - a list representing the heights of the bars in the histogram :return: int - the area of the largest rectangle stack = [] max_area = 0 heights.append(0) # Append a 0 to pop all remaining bars in the stack at the end for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) return max_area"},{"question":"def min_operations_to_transform(A: str, B: str) -> int: Returns the minimum number of operations required to transform string A into string B by reversing any contiguous substring. >>> min_operations_to_transform(\\"abc\\", \\"bca\\") 2 >>> min_operations_to_transform(\\"ab\\", \\"ba\\") 1 >>> min_operations_to_transform(\\"abcd\\", \\"dcba\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"abcdef\\", \\"fedcba\\") 1 >>> min_operations_to_transform(\\"abcdef\\", \\"abcfed\\") 1 # Your code here def solve(test_cases: List[Tuple[int, str, str]]) -> List[int]: Returns a list of results for multiple test cases, each containing the integer N, string A, and string B. >>> solve([(3, \\"abc\\", \\"bca\\"), (2, \\"ab\\", \\"ba\\"), (4, \\"abcd\\", \\"dcba\\")]) [2, 1, 1] # Your code here","solution":"def min_operations_to_transform(A, B): Returns the minimum number of operations required to transform string A into string B. n = len(A) # Initialize the number of operations to 0 operations = 0 # Convert A and B into lists to easily swap elements A_list = list(A) B_list = list(B) # Use two pointers to find the mismatched segments left, right = 0, n - 1 while left < right: if A_list[left] != B_list[left] or A_list[right] != B_list[right]: # Find the segment to reverse l, r = left, right while l <= r and A_list[l] == B_list[l]: l += 1 while l <= r and A_list[r] == B_list[r]: r -= 1 # Reverse the segment A_list[l:r+1] = A_list[l:r+1][::-1] operations += 1 # Move the pointers inwards left += 1 right -= 1 # Check if the entire string matches if A_list == B_list: return operations return operations + 1 def solve(test_cases): results = [] for N, A, B in test_cases: results.append(min_operations_to_transform(A, B)) return results"},{"question":"def sum_of_odd_elements(lst: List[int]) -> Union[int, str]: Returns the sum of all odd elements in the list. If the sum exceeds 50, returns \\"Limit Exceeded\\". If there are no odd numbers, returns 0. >>> sum_of_odd_elements([1, 2, 3, 4, 5]) 9 >>> sum_of_odd_elements([10, 20, 30]) 0 >>> sum_of_odd_elements([9, 3, 15, 7, 1, 23, 5]) \\"Limit Exceeded\\" >>> sum_of_odd_elements([11, 13, 17]) 41 # Your code here","solution":"def sum_of_odd_elements(lst): Returns the sum of all odd elements in the list. If the sum exceeds 50, returns \\"Limit Exceeded\\". If there are no odd numbers, returns 0. odd_sum = sum(x for x in lst if x % 2 != 0) if odd_sum > 50: return \\"Limit Exceeded\\" return odd_sum"},{"question":"def sort_by_length(strings: List[str]) -> List[str]: Sorts a list of strings by their lengths in ascending order. If two strings have the same length, their original order is preserved. >>> sort_by_length([\\"apple\\", \\"dog\\", \\"banana\\", \\"cat\\"]) ['dog', 'cat', 'apple', 'banana'] >>> sort_by_length([\\"dog\\", \\"cat\\", \\"bat\\"]) ['dog', 'cat', 'bat'] >>> sort_by_length([\\"a\\", \\"abcd\\", \\"abc\\", \\"ab\\", \\"abcde\\"]) ['a', 'ab', 'abc', 'abcd', 'abcde'] pass","solution":"def sort_by_length(strings): Sorts a list of strings by their lengths in ascending order. If two strings have the same length, their original order is preserved. Parameters: strings (list of str): The list of strings to sort. Returns: list of str: The sorted list of strings. return sorted(strings, key=len)"},{"question":"from typing import List, Union def transform_array(k: int, array: List[int]) -> Union[List[int], int]: Transform the array so that no integer in the array is repeated more than K times. If this condition cannot be satisfied, return the 1-based index of the first violation. Parameters: k (int): Maximum allowed repetitions for each integer. array (list): List of integers to be transformed. Returns: list or int: Transformed list, or the 1-based index of the first violation. pass def process_test_cases(input_data: List[tuple]) -> List[Union[List[int], int]]: Process multiple test cases according to the problem specifications. Parameters: input_data (list of tuple): Contains test cases where each tuple has an integer K and a list representing the array. Returns: list: List of results for each test case. pass def test_transform_array_no_violation(): assert transform_array(2, [1, 2, 3, 4, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 1, 2, 3, 4, 5] def test_transform_array_with_violation(): assert transform_array(1, [1, 1, 2, 2, 3, 3, 4, 4, 5]) == 2 assert transform_array(3, [1, 1, 1, 1, 2, 2, 3, 3, 3, 3]) == 4 def test_transform_array_boundary_conditions(): assert transform_array(1, [1]) == [1] assert transform_array(2, [1, 1, 1]) == 3 def test_process_test_cases(): input_data = [ (2, [1, 2, 3, 4, 1, 2, 3, 4, 5]), (1, [1, 1, 2, 2, 3, 3, 4, 4, 5]), (3, [1, 1, 1, 1, 2, 2, 3, 3, 3, 3]) ] expected_output = [ [1, 2, 3, 4, 1, 2, 3, 4, 5], 2, 4 ] assert process_test_cases(input_data) == expected_output","solution":"def transform_array(k, array): Transform the array so that no integer in the array is repeated more than K times. If this condition cannot be satisfied, return the 1-based index of the first violation. Parameters: k (int): Maximum allowed repetitions for each integer. array (list): List of integers to be transformed. Returns: list or int: Transformed list, or the 1-based index of the first violation. from collections import defaultdict frequency = defaultdict(int) for index, num in enumerate(array): frequency[num] += 1 if frequency[num] > k: return index + 1 return array def process_test_cases(input_data): Process multiple test cases according to the problem specifications. Parameters: input_data (list of tuple): Contains test cases where each tuple has an integer K and a list representing the array. Returns: list: List of results for each test case. results = [] for k, array in input_data: result = transform_array(k, array) results.append(result) return results"},{"question":"def max_min_cpu_utilization(server_id: int, data: List[Tuple[int, int, int]]) -> Tuple[int, int]: Returns the maximum and minimum CPU utilization for the given server ID within the given data. Parameters: server_id (int): The server ID data (list of tuples): Each tuple contains a timestamp (int), cpu_utilization (int), and a server ID (int) Returns: tuple: (max_cpu_utilization, min_cpu_utilization) if server_id is found, otherwise an empty tuple Examples: >>> max_min_cpu_utilization(2, [(1, 50, 2), (2, 20, 1), (3, 30, 2), (4, 10, 3), (5, 60, 2)]) (60, 30) >>> max_min_cpu_utilization(4, [(1, 50, 2), (2, 20, 1), (3, 30, 2), (4, 10, 3), (5, 60, 2)]) ()","solution":"def max_min_cpu_utilization(server_id, data): Returns the maximum and minimum CPU utilization for the given server ID within the given data. Parameters: server_id (int): The server ID data (list of tuples): Each tuple contains a timestamp (int), cpu_utilization (int), and a server ID (int) Returns: tuple: (max_cpu_utilization, min_cpu_utilization) if server_id is found, otherwise an empty tuple cpu_utilizations = [cpu for timestamp, cpu, sid in data if sid == server_id] if not cpu_utilizations: return () return max(cpu_utilizations), min(cpu_utilizations)"},{"question":"from typing import List def orangesRotting(grid: List[List[int]]) -> int: Return the minimum number of minutes that is required for all the fresh oranges to become rotten. If it is impossible for all the fresh oranges to rot, return -1. >>> orangesRotting([[2,1,1],[1,1,0],[0,1,1]]) 4 >>> orangesRotting([[2,1,1],[0,1,1],[1,0,1]]) -1 >>> orangesRotting([[0,2]]) 0 def test_all_oranges_rot(): grid = [[2,1,1],[1,1,0],[0,1,1]] assert orangesRotting(grid) == 4 def test_isolated_oranges(): grid = [[2,1,1],[0,1,1],[1,0,1]] assert orangesRotting(grid) == -1 def test_no_fresh_oranges(): grid = [[0,2]] assert orangesRotting(grid) == 0 def test_all_rotten_oranges(): grid = [[2,2],[2,2]] assert orangesRotting(grid) == 0 def test_all_fresh_oranges(): grid = [[1,1],[1,1]] assert orangesRotting(grid) == -1 def test_single_fresh_orange(): grid = [[1]] assert orangesRotting(grid) == -1 def test_single_rotten_orange(): grid = [[2]] assert orangesRotting(grid) == 0","solution":"from typing import List from collections import deque def orangesRotting(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Initialize queue with all initially rotten oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 if fresh_oranges == 0: return 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] minutes_passed = 0 while queue: minutes_passed += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh_oranges -= 1 queue.append((nx, ny)) return minutes_passed - 1 if fresh_oranges == 0 else -1"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, addition (+) and multiplication (*) operations, following the usual arithmetic rules of precedence. Args: - expression (str): The mathematical expression in string format. Returns: - int: The result of the evaluated expression. Examples: >>> evaluate_expression(\\"2+3\\") -> 5 >>> evaluate_expression(\\"2+3*4\\") -> 14 >>> evaluate_expression(\\"10+2*6+3\\") -> 25 >>> evaluate_expression(\\"3+3*3*3+1\\") -> 31 >>> evaluate_expression(\\"1+2*3+4*5+6\\") -> 33 pass from evaluate_expression import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"2+3\\") == 5 def test_simple_multiplication(): assert evaluate_expression(\\"2*3\\") == 6 def test_multiplication_then_addition(): assert evaluate_expression(\\"2+3*4\\") == 14 def test_addition_then_multiplication(): assert evaluate_expression(\\"10+2*6+3\\") == 25 def test_complex_expression(): assert evaluate_expression(\\"3+3*3*3+1\\") == 31 assert evaluate_expression(\\"1+2*3+4*5+6\\") == 33 def test_single_number(): assert evaluate_expression(\\"5\\") == 5 def test_zero_in_expression(): assert evaluate_expression(\\"10+2*0*6+3\\") == 13 assert evaluate_expression(\\"0+0*0+0\\") == 0 def test_multidigit_numbers(): assert evaluate_expression(\\"10+20*3+4\\") == 74 assert evaluate_expression(\\"1+23*4+5\\") == 98","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, addition (+) and multiplication (*) operations, following the usual arithmetic rules of precedence. Args: - expression (str): The mathematical expression in string format. Returns: - int: The result of the evaluated expression. def tokenize(expr): tokens = [] num = 0 for ch in expr: if ch.isdigit(): num = num * 10 + int(ch) else: tokens.append(num) tokens.append(ch) num = 0 tokens.append(num) return tokens def parse_term(tokens): term = tokens.pop(0) while tokens and tokens[0] == '*': tokens.pop(0) # Remove '*' term *= tokens.pop(0) return term tokens = tokenize(expression) result = 0 while tokens: term = parse_term(tokens) result += term if tokens and tokens[0] == '+': tokens.pop(0) # Remove '+' return result"},{"question":"def is_balanced(code: str) -> bool: Checks if the brackets in the given code string are balanced. The function considers the brackets (), {}, and []. Parameters: code (str): A string containing the code to be checked. Returns: bool: True if the brackets are balanced, False otherwise. >>> is_balanced(\\"if (a == b) { return [1, 2, 3]; }\\") True >>> is_balanced(\\"for (i = 0; i < n; i++) { array[i] = i * 2;\\") False >>> is_balanced(\\"function test() { if (a > b) { return 'error'; } }\\") True >>> is_balanced(\\"while (x != y [ { ] }\\") False","solution":"def is_balanced(code): Checks if the brackets in the given code string are balanced. The function considers the brackets (), {}, and []. Parameters: code (str): A string containing the code to be checked. Returns: bool: True if the brackets are balanced, False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in code: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def generate_palindrome(n: int) -> str: Generate a palindrome number with n digits, or return -1 if not possible. >>> generate_palindrome(1) '9' >>> generate_palindrome(2) '11' >>> generate_palindrome(3) '111' >>> generate_palindrome(4) '1111' def get_palindromes(test_cases: List[int]) -> List[str]: Return a list of palindrome numbers for each test case. >>> get_palindromes([1, 2, 3, 4]) ['9', '11', '111', '1111'] >>> get_palindromes([5, 6, 7]) ['11111', '111111', '1111111'] >>> get_palindromes([9, 10]) ['111111111', '1111111111']","solution":"def generate_palindrome(n): Generate a palindrome number with n digits, or return -1 if not possible. if n == 1: return \\"9\\" if n % 2 == 0: return \\"1\\" * (n // 2) + \\"1\\" * (n // 2) else: return \\"1\\" * (n // 2) + \\"1\\" + \\"1\\" * (n // 2) def get_palindromes(test_cases): results = [] for n in test_cases: results.append(generate_palindrome(n)) return results"},{"question":"def min_repaints(N: int, colors: List[int]) -> int: Determine the minimum number of segments Shreya needs to repaint to ensure no two consecutive segments have the same color. >>> min_repaints(6, [1, 2, 2, 3, 3, 1]) 2 >>> min_repaints(5, [1, 2, 3, 4, 5]) 0 >>> min_repaints(5, [1, 1, 1, 1, 1]) 4 >>> min_repaints(6, [1, 2, 1, 2, 1, 2]) 0 >>> min_repaints(1, [1]) 0 >>> min_repaints(2, [1, 1]) 1","solution":"def min_repaints(N, colors): repaints = 0 for i in range(1, N): if colors[i] == colors[i - 1]: repaints += 1 return repaints"},{"question":"def judge_circle(moves: str) -> bool: Determine if a series of moves on a 2D grid returns to the origin. :param moves: string, representing the sequence of moves ('U', 'D', 'L', 'R') :return: True if returns to origin, False otherwise >>> judge_circle(\\"UD\\") True >>> judge_circle(\\"LL\\") False >>> judge_circle(\\"RRDD\\") False >>> judge_circle(\\"UDLR\\") True >>> judge_circle(\\"\\") True >>> judge_circle(\\"UUDD\\" * 1000) True >>> judge_circle(\\"UUDDRR\\" * 1000 + \\"L\\") False","solution":"def judge_circle(moves): Determine if a series of moves on a 2D grid returns to the origin. :param moves: string, representing the sequence of moves ('U', 'D', 'L', 'R') :return: True if returns to origin, False otherwise x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"from collections import deque from typing import List def is_one_letter_diff(word1: str, word2: str) -> bool: Determines if word1 and word2 differ by exactly one letter. diff_count = sum(1 for a, b in zip(word1, word2) if a != b) return diff_count == 1 def shortest_transformation_sequence(S: str, D: List[str]) -> int: Returns the shortest transformation sequence from S to a word in D, with transformations that exist in the dictionary and only change one letter at a time. >>> shortest_transformation_sequence(\\"hit\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 1 >>> shortest_transformation_sequence(\\"lead\\", [\\"load\\", \\"goad\\", \\"gold\\"]) 1 >>> shortest_transformation_sequence(\\"game\\", [\\"fame\\", \\"lame\\", \\"same\\"]) 1 >>> shortest_transformation_sequence(\\"hit\\", [\\"hit\\", \\"hot\\"]) 0 >>> shortest_transformation_sequence(\\"hit\\", [\\"abc\\", \\"def\\", \\"ghi\\"]) -1","solution":"from collections import deque def is_one_letter_diff(word1, word2): Determines if word1 and word2 differ by exactly one letter. diff_count = sum(1 for a, b in zip(word1, word2) if a != b) return diff_count == 1 def shortest_transformation_sequence(S, D): Returns the shortest transformation sequence from S to a word in D, with transformations that exist in the dictionary and only change one letter at a time. if S in D: return 0 queue = deque([(S, 0)]) visited = set(S) while queue: current_word, steps = queue.popleft() for word in list(D): if word not in visited and is_one_letter_diff(current_word, word): if word in D: return steps + 1 queue.append((word, steps + 1)) visited.add(word) return -1 # In case there is no possible transformation"},{"question":"def is_balanced(s: str) -> bool: Determines if a given string of parentheses is balanced and properly nested. :param s: Input string consisting only of '(', ')', '{', '}', '[' and ']' :return: True if the string is balanced and properly nested, False otherwise Examples: >>> is_balanced(\\"([]){}\\") True >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"{[()]}\\") True","solution":"def is_balanced(s): Determines if a given string of parentheses is balanced and properly nested. :param s: Input string consisting only of '(', ')', '{', '}', '[' and ']' :return: True if the string is balanced and properly nested, False otherwise stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return False else: return False return stack == []"},{"question":"def can_book_room(current_bookings, new_booking): Returns True if the new_booking can be added without conflict, otherwise False. current_bookings: List[Dict[str, Any]], a list of current bookings. new_booking: Dict[str, Any], a dictionary with the new booking's details. >>> can_book_room( [ {\\"student_id\\": 1, \\"room_number\\": 101, \\"time_slot\\": 9}, {\\"student_id\\": 2, \\"room_number\\": 102, \\"time_slot\\": 10}, {\\"student_id\\": 3, \\"room_number\\": 101, \\"time_slot\\": 11} ], {\\"student_id\\": 4, \\"room_number\\": 101, \\"time_slot\\": 10} ) True >>> can_book_room( [ {\\"student_id\\": 1, \\"room_number\\": 101, \\"time_slot\\": 9}, {\\"student_id\\": 2, \\"room_number\\": 102, \\"time_slot\\": 10}, {\\"student_id\\": 3, \\"room_number\\": 101, \\"time_slot\\": 11} ], {\\"student_id\\": 4, \\"room_number\\": 101, \\"time_slot\\": 9} ) False","solution":"def can_book_room(current_bookings, new_booking): Returns True if the new_booking can be added without conflict, otherwise False. for booking in current_bookings: if booking['room_number'] == new_booking['room_number'] and booking['time_slot'] == new_booking['time_slot']: return False return True"},{"question":"from typing import List, Dict def map_sum(list1: List[int], list2: List[int]) -> Dict[int, int]: Returns a dictionary where each key is an element from list1 and the corresponding value is the sum of elements in list2 at positions in indexes where list1 contains the respective key. >>> map_sum([1, 2, 1, 3, 1, 2, 3], [5, 6, 7, 8, 9, 10, 11]) {1: 21, 2: 16, 3: 19} >>> map_sum([4, 4, 5], [-1, 1, 3]) {4: 0, 5: 3} >>> map_sum([1, 2, 3, 4], [10, 20, 30, 40]) {1: 10, 2: 20, 3: 30, 4: 40} >>> map_sum([7], [99]) {7: 99} pass","solution":"from typing import List, Dict def map_sum(list1: List[int], list2: List[int]) -> Dict[int, int]: Returns a dictionary where each key is an element from list1 and the corresponding value is the sum of elements in list2 at positions in indexes where list1 contains the respective key. result = {} for i in range(len(list1)): key = list1[i] if key in result: result[key] += list2[i] else: result[key] = list2[i] return result"},{"question":"def findUnsortedSubarray(nums) -> int: Given an integer array \`nums\`, find one continuous subarray that if you only sort this subarray in ascending order, the whole array will be sorted in ascending order. Return the length of the shortest such subarray. Examples: >>> findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) 5 >>> findUnsortedSubarray([1, 2, 3, 4]) 0 >>> findUnsortedSubarray([1]) 0","solution":"def findUnsortedSubarray(nums): Finds the length of the shortest subarray which, when sorted, results in the entire array being sorted in ascending order. sorted_nums = sorted(nums) n = len(nums) start, end = -1, -1 for i in range(n): if nums[i] != sorted_nums[i]: if start == -1: start = i end = i if start == -1: return 0 return end - start + 1"},{"question":"def rearrange_sentence(sentence: str) -> str: Rearranges the letters in each word of the sentence in alphabetical order while maintaining the original word order in the sentence. Parameters: sentence (str): A sentence with words separated by single spaces. Each word is a non-empty string of lowercase English letters. Returns: str: The sentence with each word's letters rearranged in alphabetical order. >>> rearrange_sentence(\\"the quick brown fox\\") 'eht cikqu bnorw fox' >>> rearrange_sentence(\\"jumps over the lazy dog\\") 'jmpsu eorv eht alyz dgo'","solution":"def rearrange_sentence(sentence): Rearranges the letters in each word of the sentence in alphabetical order while maintaining the original word order in the sentence. Parameters: sentence (str): A sentence with words separated by single spaces. Each word is a non-empty string of lowercase English letters. Returns: str: The sentence with each word's letters rearranged in alphabetical order. words = sentence.split(\\" \\") rearranged_words = [''.join(sorted(word)) for word in words] return \\" \\".join(rearranged_words)"},{"question":"def max_pairs(sequence: str) -> int: Returns the maximum number of pairs that can be formed from given sequence representing 'W' as women and 'M' as men. A pair consists of one 'M' and one 'W'. >>> max_pairs(\\"WMWMWWMW\\") 3 >>> max_pairs(\\"WWMMMMMM\\") 2 >>> max_pairs(\\"WWWWWW\\") 0","solution":"def max_pairs(sequence: str) -> int: Returns the maximum number of pairs that can be formed from given sequence representing 'W' as women and 'M' as men. A pair consists of one 'M' and one 'W'. count_W = sequence.count('W') count_M = sequence.count('M') # The maximum number of pairs is the minimum of the count of 'W' and 'M' return min(count_W, count_M)"},{"question":"from collections import deque from typing import List, Tuple def min_moves_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determines the minimum number of moves required to reach the bottom-right cell from the top-left cell in a grid. If it is not possible to reach the bottom-right cell, returns -1. Arguments: n -- number of rows in the grid m -- number of columns in the grid grid -- list of strings representing the grid where '.' is a free cell and '#' is an obstacle Returns: int -- minimum number of moves required to reach the bottom-right cell, or -1 if not possible Example: >>> min_moves_to_reach_end(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves_to_reach_end(3, 3, [\\".\\", \\"..#\\", \\".#.\\"]) -1 pass def process_input(test_cases: List[Tuple[Tuple[int, int], List[str]]]) -> List[int]: Processes multiple test cases for the min_moves_to_reach_end function. Arguments: test_cases -- list of tuples, each containing grid dimensions and grid layout Returns: List[int] -- list of results for each test case Example: >>> process_input([((3, 3), [\\"...\\", \\".#.\\", \\"...\\"]), ((3, 3), [\\".\\", \\"..#\\", \\".#.\\"])]) [4, -1] pass def test_min_moves_basic(): assert min_moves_to_reach_end(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) == 4 assert min_moves_to_reach_end(3, 3, [\\".\\", \\"..#\\", \\".#.\\"]) == -1 assert min_moves_to_reach_end(2, 2, [\\"..\\", \\"..\\"]) == 2 def test_min_moves_single_row(): assert min_moves_to_reach_end(1, 3, [\\".#.\\"]) == -1 assert min_moves_to_reach_end(1, 3, [\\"...\\"]) == 2 def test_min_moves_single_column(): assert min_moves_to_reach_end(3, 1, [\\".\\", \\"#\\", \\".\\"]) == -1 assert min_moves_to_reach_end(3, 1, [\\".\\", \\".\\", \\".\\"]) == 2 def test_min_moves_start_or_end_blocked(): assert min_moves_to_reach_end(3, 3, [\\"#..\\", \\"...\\", \\"...\\"]) == -1 assert min_moves_to_reach_end(3, 3, [\\"...\\", \\"...\\", \\"..#\\"]) == -1 def test_process_input(): input_data = [ ((3, 3), [\\"...\\", \\".#.\\", \\"...\\"]), ((3, 3), [\\".\\", \\"..#\\", \\".#.\\"]) ] results = process_input(input_data) assert results == [4, -1]","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, column, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1 def process_input(test_cases): results = [] for tc in test_cases: n, m = tc[0] grid = tc[1] result = min_moves_to_reach_end(n, m, grid) results.append(result) return results"},{"question":"def largest_perimeter(nums): Returns the largest perimeter of a triangle with a non-zero area formed from three of the lengths in the input array. If no such triangle exists, returns 0. Examples: >>> largest_perimeter([2, 1, 2]) 5 >>> largest_perimeter([1, 2, 1]) 0 >>> largest_perimeter([3, 2, 3, 4]) 10 >>> largest_perimeter([3, 6, 2, 3]) 8 >>> largest_perimeter([2, 2, 4]) 0 >>> largest_perimeter([3, 3, 3]) 9 >>> largest_perimeter([6, 2, 8, 4, 1, 7, 10, 3]) 25","solution":"def largest_perimeter(nums): Returns the largest perimeter of a triangle with a non-zero area formed from three of the lengths in the input array. If no such triangle exists, returns 0. nums.sort(reverse=True) # sort the array in descending order for i in range(len(nums) - 2): if nums[i] < nums[i+1] + nums[i+2]: return nums[i] + nums[i+1] + nums[i+2] return 0"},{"question":"def min_swaps_to_uniform_string(S: str) -> int: This function takes in a string S and calculates the minimal number of character swaps required to transform the string into a string composed entirely of 'x' or entirely of 'y'. >>> min_swaps_to_uniform_string(\\"xyyx\\") 2 >>> min_swaps_to_uniform_string(\\"yyyx\\") 1 def process_test_cases(n: int, strings: List[str]) -> List[int]: This function processes multiple test cases. >>> process_test_cases(2, [\\"xyyx\\", \\"yyyx\\"]) [2, 1] >>> process_test_cases(3, [\\"xxxyyy\\", \\"yyxx\\", \\"xyxyxy\\"]) [3, 2, 3]","solution":"def min_swaps_to_uniform_string(S): This function takes in a string S and calculates the minimal number of character swaps required to transform the string into a string composed entirely of 'x' or entirely of 'y'. count_x = S.count('x') count_y = S.count('y') # To make the string uniform, we would need to change all 'x' to 'y' or all 'y' to 'x' # The minimal swaps required is the smaller of the two counts return min(count_x, count_y) def process_test_cases(n, strings): This function processes multiple test cases. results = [] for s in strings: results.append(min_swaps_to_uniform_string(s)) return results"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations to transform the string s into a palindrome. >>> min_operations_to_palindrome(\\"ab\\") == 1 >>> min_operations_to_palindrome(\\"racecar\\") == 0 >>> min_operations_to_palindrome(\\"hello\\") == 3 >>> min_operations_to_palindrome(\\"a\\") == 0 >>> min_operations_to_palindrome(\\"aa\\") == 0 >>> min_operations_to_palindrome(\\"abc\\") == 2 def main(t: int, test_cases: List[str]) -> List[int]: Returns a list of results for each test case given t and test_cases. >>> main(3, [\\"ab\\", \\"racecar\\", \\"hello\\"]) == [1, 0, 3] >>> main(2, [\\"a\\", \\"abcdef\\"]) == [0, 5]","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations to transform the string s into a palindrome. n = len(s) # Create a dp table to store the minimum number of insertions required dp = [[0] * n for _ in range(n)] for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1] def main(t, test_cases): results = [] for case in test_cases: results.append(min_operations_to_palindrome(case)) return results"},{"question":"def min_transport_hubs(n: int, m: int, k: int, roads: List[Tuple[int, int]]) -> int: Determine the least number of transport hubs required to ensure that the travel time between any two cities is no more than k hours after the transport hubs are built. >>> min_transport_hubs(4, 3, 2, [(1, 2), (2, 3), (3, 4)]) == 1 >>> min_transport_hubs(5, 5, 2, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == 0 >>> min_transport_hubs(6, 5, 1, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == -1 >>> min_transport_hubs(4, 6, 1, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) == 0 >>> min_transport_hubs(3, 3, 1, [(1, 2), (2, 3), (1, 3)]) == 0","solution":"from collections import deque def bfs_shortest_path(graph, start, n): Perform BFS to find the shortest path from start to all other vertices in an unweighted graph. visited = [False] * (n + 1) distance = [float('inf')] * (n + 1) queue = deque([start]) visited[start] = True distance[start] = 0 while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) distance[neighbor] = distance[current] + 1 return distance def min_transport_hubs(n, m, k, roads): graph = [[] for _ in range(n + 1)] for a, b in roads: graph[a].append(b) graph[b].append(a) max_distance = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): distances = bfs_shortest_path(graph, i, n) for j in range(1, n + 1): max_distance[i][j] = distances[j] # Determine the minimum number of hubs required for hubs in range(n + 1): for mask in range(1 << n): if bin(mask).count('1') != hubs: continue valid = True for i in range(1, n + 1): for j in range(1, n + 1): min_time = max_distance[i][j] for hub in range(n): if ((1 << hub) & mask) != 0: min_time = min(min_time, max_distance[i][hub + 1] // 2 + max_distance[hub + 1][j]) if min_time > k: valid = False break if not valid: break if valid: return hubs return -1"},{"question":"def max_candies(n: int, candies: List[int]) -> int: Returns the maximum total amount of candies the kids can collect by visiting the houses in order from 1 to n. :param n: int, number of houses. :param candies: List[int], amount of candies in each house. :return: int, maximum total amount of candies. >>> max_candies(5, [1, 2, 3, 2, 5]) 11 >>> max_candies(5, [2, 2, 2, 2, 2]) 2 from solution import max_candies def test_max_candies_basic(): assert max_candies(5, [1, 2, 3, 2, 5]) == 11 def test_max_candies_same_candy_amount(): assert max_candies(5, [2, 2, 2, 2, 2]) == 2 def test_max_candies_decreasing_candies(): assert max_candies(5, [5, 4, 3, 2, 1]) == 5 def test_max_candies_increasing_candies(): assert max_candies(5, [1, 2, 3, 4, 5]) == 15 def test_max_candies_single_house(): assert max_candies(1, [10]) == 10 def test_max_candies_all_houses_with_one_candy(): assert max_candies(4, [1, 1, 1, 1]) == 1","solution":"def max_candies(n, candies): Returns the maximum total amount of candies the kids can collect. :param n: int, number of houses. :param candies: List[int], amount of candies in each house. :return: int, maximum total amount of candies. if n == 0: return 0 max_total = candies[0] prev_candies = candies[0] for i in range(1, n): if candies[i] > prev_candies: max_total += candies[i] prev_candies = candies[i] return max_total"},{"question":"def generate_shopping_list(input_list): Returns a dictionary with item names as keys and total quantities as values. >>> generate_shopping_list([\\"apple:2\\", \\"banana:3\\", \\"apple:4\\", \\"orange:1\\", \\"banana:2\\"]) {'apple': 6, 'banana': 5, 'orange': 1} >>> generate_shopping_list([\\"mango:2\\", \\"grape:3\\", \\"kiwi:1\\"]) {'mango': 2, 'grape': 3, 'kiwi': 1} >>> generate_shopping_list([\\"apple:1\\", \\"apple:2\\", \\"apple:3\\"]) {'apple': 6} >>> generate_shopping_list([]) {} >>> generate_shopping_list([\\"watermelon:1000\\", \\"watermelon:2000\\", \\"watermelon:3000\\"]) {'watermelon': 6000}","solution":"def generate_shopping_list(input_list): Returns a dictionary with item names as keys and total quantities as values. shopping_dict = {} for item in input_list: item_name, quantity = item.split(':') quantity = int(quantity) if item_name in shopping_dict: shopping_dict[item_name] += quantity else: shopping_dict[item_name] = quantity return shopping_dict"},{"question":"def group_and_sort_employees(employees): Groups employees by their position and then sorts each group by age in ascending order. Parameters: employees (list): A list of dictionaries where each dictionary contains 'name', 'age', and 'position' keys. Returns: dict: A dictionary where the keys are positions and the values are lists of employees sorted by age within each position. # Test Cases def test_group_and_sort_employees(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"position\\": \\"Manager\\"}, {\\"name\\": \\"David\\", \\"age\\": 29, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Eve\\", \\"age\\": 28, \\"position\\": \\"Manager\\"} ] expected_output = { \\"Engineer\\": [ {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"David\\", \\"age\\": 29, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"position\\": \\"Engineer\\"} ], \\"Manager\\": [ {\\"name\\": \\"Eve\\", \\"age\\": 28, \\"position\\": \\"Manager\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"position\\": \\"Manager\\"} ] } assert group_and_sort_employees(employees) == expected_output def test_empty_input(): employees = [] expected_output = {} assert group_and_sort_employees(employees) == expected_output def test_single_position(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"David\\", \\"age\\": 29, \\"position\\": \\"Engineer\\"}, ] expected_output = { \\"Engineer\\": [ {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"David\\", \\"age\\": 29, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"position\\": \\"Engineer\\"} ] } assert group_and_sort_employees(employees) == expected_output def test_single_employee_each_position(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"position\\": \\"Manager\\"}, {\\"name\\": \\"Eve\\", \\"age\\": 28, \\"position\\": \\"HR\\"} ] expected_output = { \\"Engineer\\": [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"position\\": \\"Engineer\\"} ], \\"Manager\\": [ {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"position\\": \\"Manager\\"} ], \\"HR\\": [ {\\"name\\": \\"Eve\\", \\"age\\": 28, \\"position\\": \\"HR\\"} ] } assert group_and_sort_employees(employees) == expected_output def test_unsorted_input(): employees = [ {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"position\\": \\"Manager\\"}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Eve\\", \\"age\\": 28, \\"position\\": \\"Manager\\"}, {\\"name\\": \\"David\\", \\"age\\": 29, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"position\\": \\"Engineer\\"} ] expected_output = { \\"Engineer\\": [ {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"David\\", \\"age\\": 29, \\"position\\": \\"Engineer\\"}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"position\\": \\"Engineer\\"} ], \\"Manager\\": [ {\\"name\\": \\"Eve\\", \\"age\\": 28, \\"position\\": \\"Manager\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"position\\": \\"Manager\\"} ] } assert group_and_sort_employees(employees) == expected_output","solution":"def group_and_sort_employees(employees): Groups employees by their position and then sorts each group by age in ascending order. Parameters: employees (list): A list of dictionaries where each dictionary contains 'name', 'age', and 'position' keys. Returns: dict: A dictionary where the keys are positions and the values are lists of employees sorted by age within each position. from collections import defaultdict # Group employees by position grouped_employees = defaultdict(list) for employee in employees: position = employee['position'] grouped_employees[position].append(employee) # Sort each group by age for position in grouped_employees: grouped_employees[position].sort(key=lambda x: x['age']) return dict(grouped_employees)"},{"question":"def totalOverflow(usage: list, limit: int) -> int: Calculate the total overflow of water usage over the allowed limit. Parameters: usage (list): A list of integers representing daily water usage by residents. limit (int): The maximum allowed liters of water per resident per day. Returns: int: The total overflow of water usage over the limit. Examples: >>> totalOverflow([50, 60, 55, 70], 50) 35 >>> totalOverflow([30, 35, 40, 45], 50) 0","solution":"def totalOverflow(usage, limit): Calculate the total overflow of water usage over the allowed limit. Parameters: usage (list): A list of integers representing daily water usage by residents. limit (int): The maximum allowed liters of water per resident per day. Returns: int: The total overflow of water usage over the limit. return sum(max(0, u - limit) for u in usage)"},{"question":"def shortest_substring_k_distinct(s: str, k: int) -> int: Given a string s consisting of lowercase alphabets and an integer k (1 <= k <= 26), determines the length of the shortest substring that contains exactly k distinct characters. >>> shortest_substring_k_distinct(\\"aabc\\", 2) 2 >>> shortest_substring_k_distinct(\\"aabc\\", 3) 3 >>> shortest_substring_k_distinct(\\"abcdef\\", 2) 2 >>> shortest_substring_k_distinct(\\"abaccc\\", 3) 3 >>> shortest_substring_k_distinct(\\"abaccc\\", 4) -1 >>> shortest_substring_k_distinct(\\"a\\", 1) 1 pass","solution":"def shortest_substring_k_distinct(s, k): from collections import defaultdict n = len(s) min_length = float('inf') left = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 while len(char_count) >= k: if len(char_count) == k: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: Optional[TreeNode], target_sum: int) -> bool: Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> has_path_sum(root, 22) True","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: Optional[TreeNode], target_sum: int) -> bool: Returns whether the binary tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. if not root: return False if not root.left and not root.right: return root.val == target_sum target_sum -= root.val return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum)"},{"question":"def digital_root(n: int) -> int: Returns the digital root of a given integer n. >>> digital_root(16) 7 >>> digital_root(942) 6 >>> digital_root(132189) 6 >>> digital_root(493193) 2","solution":"def digital_root(n): Returns the digital root of a given integer n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def is_prime(num): Returns True if num is a prime number. pass def product_of_primes(n): Returns the product of all prime numbers less than or equal to n. >>> product_of_primes(10) 210 >>> product_of_primes(5) 30 >>> product_of_primes(2) 2 >>> product_of_primes(1) 1 >>> product_of_primes(11) 2310 >>> product_of_primes(20) 9699690 pass","solution":"def is_prime(num): Returns True if num is a prime number. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def product_of_primes(n): Returns the product of all prime numbers less than or equal to n. product = 1 for i in range(2, n + 1): if is_prime(i): product *= i return product"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Removes duplicates from a list while preserving the original order. Args: lst (list of int): List of integers with possible duplicates. Returns: list of int: List of integers without duplicates, preserving order. >>> remove_duplicates([1, 3, 3, 5, 2, 1, 4]) [1, 3, 5, 2, 4] >>> remove_duplicates([1, 1, 1, 1]) [1] pass def test_remove_duplicates(): assert remove_duplicates([1, 3, 3, 5, 2, 1, 4]) == [1, 3, 5, 2, 4] assert remove_duplicates([1, 1, 1, 1]) == [1] assert remove_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4] assert remove_duplicates([]) == [] assert remove_duplicates([5, 5, 5, 5, 5, 5, 5]) == [5] assert remove_duplicates([1, 2, 2, 3, 3, 4]) == [1, 2, 3, 4] assert remove_duplicates([1]) == [1] assert remove_duplicates([1, 2, 3, 2, 1, 4, 5]) == [1, 2, 3, 4, 5]","solution":"def remove_duplicates(lst): Removes duplicates from a list while preserving the original order. Args: lst (list of int): List of integers with possible duplicates. Returns: list of int: List of integers without duplicates, preserving order. seen = set() unique_lst = [] for num in lst: if num not in seen: seen.add(num) unique_lst.append(num) return unique_lst"},{"question":"from typing import List def count_pairs_divisible_by_k(inputArr: List[int], k: int) -> int: This function counts the number of pairs (i, j) in the given array such that i < j and the sum of the elements at these indices is divisible by k. Parameters: inputArr (list): A list of positive integers k (int): An integer divisor Returns: int: The number of pairs (i, j) with i < j whose sum is divisible by k Examples: >>> count_pairs_divisible_by_k([1, 2, 3, 4, 5, 6], 5) 3 >>> count_pairs_divisible_by_k([1, 2, 3], 10) 0 >>> count_pairs_divisible_by_k([5, 10, 15, 20], 5) 6 >>> count_pairs_divisible_by_k([10], 2) 0 >>> count_pairs_divisible_by_k([1, 2, 3, 4, 5, 6], 15) 0 >>> count_pairs_divisible_by_k([6, 6, 6, 6], 6) 6","solution":"def count_pairs_divisible_by_k(inputArr, k): This function counts the number of pairs (i, j) in the given array such that i < j and the sum of the elements at these indices is divisible by k. Parameters: inputArr (list): A list of positive integers k (int): An integer divisor Returns: int: The number of pairs (i, j) with i < j whose sum is divisible by k count = 0 n = len(inputArr) for i in range(n): for j in range(i + 1, n): if (inputArr[i] + inputArr[j]) % k == 0: count += 1 return count"},{"question":"def trap_water(heights): Returns the total volume of water that can be trapped. :param heights: List of positive integers representing the height of buildings. :return: Total volume of water that can be trapped between buildings. >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([1, 1, 1, 1, 1]) 0 >>> trap_water([]) 0 >>> trap_water([5]) 0 >>> trap_water([5, 2]) 0 >>> trap_water([3, 3, 3, 3]) 0 >>> trap_water([5, 0, 5, 0, 5]) 10 >>> trap_water([1, 2, 3, 4, 5]) 0 >>> trap_water([5, 4, 3, 2, 1]) 0 >>> trap_water([3, 0, 2, 0, 4]) 7","solution":"def trap_water(heights): Returns the total volume of water that can be trapped. :param heights: List of positive integers representing the height of buildings. :return: Total volume of water that can be trapped between buildings. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water = 0 for i in range(n): water += min(left_max[i], right_max[i]) - heights[i] return water"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other. Ignores non-alphabetic characters and case differences. >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Hello\\", \\"Olelh!\\") True >>> are_anagrams(\\"Apple\\", \\"Papel\\") True >>> are_anagrams(\\"Test\\", \\"Tast\\") False","solution":"def are_anagrams(str1, str2): Determines if two strings are anagrams of each other. Ignores non-alphabetic characters and case differences. Parameters: str1 (string): The first string. str2 (string): The second string. Returns: bool: True if the strings are anagrams, False otherwise. # Helper function to clean and sort a string def clean_string(s): return sorted([char.lower() for char in s if char.isalpha()]) return clean_string(str1) == clean_string(str2)"},{"question":"def maximum_non_conflicting_road_length(n: int, m: int, edges: List[Tuple[int, int, int, int]]) -> int: Determine the maximum length of any colored road that does not result in a town having roads of the same color meeting at it. >>> maximum_non_conflicting_road_length(4, 5, [(1, 2, 4, 1), (1, 3, 3, 2), (2, 4, 2, 1), (3, 4, 5, 1), (1, 4, 8, 2)]) 8 >>> maximum_non_conflicting_road_length(5, 5, [(1, 2, 10, 1), (2, 3, 8, 1), (3, 4, 6, 2), (4, 5, 5, 2), (1, 5, 7, 1)]) 10 >>> maximum_non_conflicting_road_length(4, 5, [(1, 2, 5, 1), (1, 3, 6, 2), (2, 4, 7, 1), (3, 4, 4, 2), (1, 4, 9, 3)]) 9 >>> maximum_non_conflicting_road_length(5, 4, [(1, 2, 3, 1), (2, 3, 3, 1), (3, 4, 3, 1), (4, 5, 4, 2)]) 4 >>> maximum_non_conflicting_road_length(5, 4, [(1, 2, 1, 1), (2, 3, 2, 2), (3, 4, 1, 2), (4, 5, 2, 1)]) 2","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 return root_u != root_v def max_road_length(n, m, roads): roads.sort(key=lambda x: -x[2]) # Sort roads by length in descending order color_used = [{} for _ in range(n)] # Track used colors at each town uf = UnionFind(n) for u, v, l, c in roads: u -= 1 v -= 1 if uf.find(u) != uf.find(v): if c not in color_used[u] and c not in color_used[v]: uf.union(u, v) color_used[u][c] = True color_used[v][c] = True return l return -1 # This line should theoretically never be reached def maximum_non_conflicting_road_length(n, m, edges): return max_road_length(n, m, edges)"},{"question":"def list_pages(ranges: List[str]) -> List[int]: Takes a list of strings, where each string represents a range of pages in a book (e.g., \\"1-4\\" or \\"6-8\\"), and returns a list of individual page numbers without duplicates. >>> list_pages([\\"1-4\\", \\"6-8\\"]) [1, 2, 3, 4, 6, 7, 8] >>> list_pages([\\"1-3\\", \\"2-5\\"]) [1, 2, 3, 4, 5] pass # Test cases def test_single_range(): assert list_pages([\\"1-4\\"]) == [1, 2, 3, 4] def test_multiple_ranges(): assert list_pages([\\"1-4\\", \\"6-8\\"]) == [1, 2, 3, 4, 6, 7, 8] def test_overlapping_ranges(): assert list_pages([\\"1-3\\", \\"2-5\\"]) == [1, 2, 3, 4, 5] def test_continuous_ranges(): assert list_pages([\\"10-12\\", \\"11-13\\"]) == [10, 11, 12, 13] def test_mixed_and_single_page_ranges(): assert list_pages([\\"2-4\\", \\"6-6\\", \\"3-5\\"]) == [2, 3, 4, 5, 6] def test_no_overlap(): assert list_pages([\\"1-3\\", \\"5-7\\"]) == [1, 2, 3, 5, 6, 7] def test_reverse_order_input(): assert list_pages([\\"6-8\\", \\"1-4\\"]) == [1, 2, 3, 4, 6, 7, 8] def test_identical_ranges(): assert list_pages([\\"1-3\\", \\"1-3\\"]) == [1, 2, 3]","solution":"def list_pages(ranges): Takes a list of strings, where each string represents a range of pages in a book (e.g., \\"1-4\\" or \\"6-8\\"), and returns a list of individual page numbers without duplicates. pages = set() for r in ranges: start, end = map(int, r.split('-')) pages.update(range(start, end+1)) return sorted(pages)"},{"question":"from typing import List def adjust_list(numbers: List[int]) -> List[int]: Adjust the list of numbers according to specific rules. - For each even-indexed number in the list, increase it by 1 if it's even and decrease it by 1 if it's odd. - For each odd-indexed number in the list, increase it by 2 if it's even and decrease it by 2 if it's odd. Args: numbers: List[int] - a list of integers Returns: List[int] - the modified list following the described rules Examples: >>> adjust_list([1, 2, 3, 4, 5, 6]) [0, 4, 2, 6, 4, 8] >>> adjust_list([10, 21, 32, 45, 50]) [11, 19, 33, 43, 51] >>> adjust_list([7, 8, 9, 10]) [6, 10, 8, 12]","solution":"from typing import List def adjust_list(numbers: List[int]) -> List[int]: Adjust the list of numbers according to specific rules. for i in range(len(numbers)): if i % 2 == 0: # Even index if numbers[i] % 2 == 0: numbers[i] += 1 else: numbers[i] -= 1 else: # Odd index if numbers[i] % 2 == 0: numbers[i] += 2 else: numbers[i] -= 2 return numbers"},{"question":"def add_user(users: dict, age: int, username: str) -> bool: Adds a new user to the dictionary if the username is not already taken and the age is a positive integer. Args: users (dict): Dictionary of existing users with usernames as keys and ages as values. age (int): The age of the new user. username (str): The username of the new user. Returns: bool: True if the user was successfully added, False otherwise. >>> users = {\\"alice\\": 30, \\"bob\\": 25} >>> add_user(users, 22, \\"charlie\\") == True >>> add_user(users, 35, \\"alice\\") == False >>> add_user(users, -5, \\"dave\\") == False from solution import add_user def test_add_new_user_successfully(): users = {\\"alice\\": 30, \\"bob\\": 25} assert add_user(users, 22, \\"charlie\\") == True assert users == {\\"alice\\": 30, \\"bob\\": 25, \\"charlie\\": 22} def test_add_existing_username(): users = {\\"alice\\": 30, \\"bob\\": 25} assert add_user(users, 35, \\"alice\\") == False assert users == {\\"alice\\": 30, \\"bob\\": 25} def test_add_user_with_invalid_age(): users = {\\"alice\\": 30, \\"bob\\": 25} assert add_user(users, -5, \\"dave\\") == False assert users == {\\"alice\\": 30, \\"bob\\": 25} def test_add_user_with_non_integer_age(): users = {\\"alice\\": 30, \\"bob\\": 25} assert add_user(users, \\"twenty\\", \\"dave\\") == False assert users == {\\"alice\\": 30, \\"bob\\": 25} def test_add_user_with_zero_age(): users = {\\"alice\\": 30, \\"bob\\": 25} assert add_user(users, 0, \\"dave\\") == False assert users == {\\"alice\\": 30, \\"bob\\": 25} def test_add_user_with_duplicate_name_different_case(): users = {\\"alice\\": 30, \\"bob\\": 25} assert add_user(users, 22, \\"Alice\\") == True assert users == {\\"alice\\": 30, \\"bob\\": 25, \\"Alice\\": 22}","solution":"def add_user(users, age, username): Adds a new user to the dictionary if the username is not already taken and the age is a positive integer. Args: users (dict): Dictionary of existing users with usernames as keys and ages as values. age (int): The age of the new user. username (str): The username of the new user. Returns: bool: True if the user was successfully added, False otherwise. if isinstance(age, int) and age > 0 and username not in users: users[username] = age return True return False"},{"question":"def move_zeros(arr): Moves all zeros in the list to the end while maintaining the order of other elements. Args: arr: list of ints Returns: list of ints Examples: >>> move_zeros([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeros([4, 2, 5, 0, 0, 6, 7]) [4, 2, 5, 6, 7, 0, 0] >>> move_zeros([]) [] >>> move_zeros([0]) [0] >>> move_zeros([1]) [1] >>> move_zeros([0, 0, 1, 2]) [1, 2, 0, 0] # You can test your implementation with these test cases def test_move_zeros_basic(): assert move_zeros([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0] def test_move_zeros_no_zeros(): assert move_zeros([1, 2, 3]) == [1, 2, 3] def test_move_zeros_all_zeros(): assert move_zeros([0, 0, 0]) == [0, 0, 0] def test_move_zeros_mixed(): assert move_zeros([4, 2, 5, 0, 0, 6, 7]) == [4, 2, 5, 6, 7, 0, 0] def test_move_zeros_empty(): assert move_zeros([]) == [] def test_move_zeros_single_zero(): assert move_zeros([0]) == [0] def test_move_zeros_single_non_zero(): assert move_zeros([1]) == [1] def test_move_zeros_starting_zeros(): assert move_zeros([0, 0, 1, 2]) == [1, 2, 0, 0]","solution":"def move_zeros(arr): Moves all zeros in the list to the end while maintaining the order of other elements. non_zeros = [num for num in arr if num != 0] zeros = [0] * (len(arr) - len(non_zeros)) return non_zeros + zeros"},{"question":"def add_item(grocery_list, item_name, quantity): Adds an item to the grocery list or updates its quantity if it already exists. :param grocery_list: dict, the current grocery list :param item_name: str, the name of the item :param quantity: int, the quantity of the item to add def remove_item(grocery_list, item_name): Removes an item from the grocery list if it exists. :param grocery_list: dict, the current grocery list :param item_name: str, the name of the item to remove :return: str, a message indicating the result of the operation def display_list(grocery_list): Displays the items in the grocery list along with their quantities. :param grocery_list: dict, the current grocery list","solution":"def add_item(grocery_list, item_name, quantity): Adds an item to the grocery list or updates its quantity if it already exists. :param grocery_list: dict, the current grocery list :param item_name: str, the name of the item :param quantity: int, the quantity of the item to add if item_name in grocery_list: grocery_list[item_name] += quantity else: grocery_list[item_name] = quantity def remove_item(grocery_list, item_name): Removes an item from the grocery list if it exists. :param grocery_list: dict, the current grocery list :param item_name: str, the name of the item to remove :return: str, a message indicating the result of the operation if item_name in grocery_list: del grocery_list[item_name] return f\\"Item '{item_name}' removed from the list.\\" else: return f\\"Item '{item_name}' not found in the list.\\" def display_list(grocery_list): Displays the items in the grocery list along with their quantities. :param grocery_list: dict, the current grocery list for item_name, quantity in grocery_list.items(): print(f\\"Item: {item_name}, Quantity: {quantity}\\")"},{"question":"def count_duplicates(s: str) -> int: Returns the count of characters that appear more than once in the string, regardless of case. >>> count_duplicates(\\"aA11\\") -> 2 >>> count_duplicates(\\"abcde\\") -> 0 >>> count_duplicates(\\"aabBcde\\") -> 2 >>> count_duplicates(\\"aA11bbb\\") -> 3 # Implementation goes here. def test_count_duplicates_no_duplicates(): assert count_duplicates(\\"abcde\\") == 0 def test_count_duplicates_all_duplicates(): assert count_duplicates(\\"aabbcc\\") == 3 def test_count_duplicates_mixed_case(): assert count_duplicates(\\"aA11\\") == 2 def test_count_duplicates_mixed_case_and_numbers(): assert count_duplicates(\\"aabBcde\\") == 2 def test_count_duplicates_repeat_chars_and_numbers(): assert count_duplicates(\\"aA11bbb\\") == 3 def test_count_duplicates_single_char(): assert count_duplicates(\\"a\\") == 0 def test_count_duplicates_empty_string(): assert count_duplicates(\\"\\") == 0","solution":"def count_duplicates(s): Returns the count of characters that appear more than once in the string, regardless of case. s = s.lower() char_count = {} duplicates_count = 0 for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for count in char_count.values(): if count > 1: duplicates_count += 1 return duplicates_count"},{"question":"def evaluate_expression(expr: str) -> int: Evaluates a mathematical expression involving +, -, *, /, (, and ). >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"5 - 2\\") 3 >>> evaluate_expression(\\"4 * 2\\") 8 >>> evaluate_expression(\\"9 / 3\\") 3 >>> evaluate_expression(\\"2 + 3 * 4\\") 14 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\"(2 + 3) * (2 + 3)\\") 25 >>> evaluate_expression(\\"((2 + 3) * 2) + 1\\") 11 >>> evaluate_expression(\\"7 / 2\\") 3 >>> evaluate_expression(\\"7 / 3\\") 2 >>> evaluate_expression(\\"3 + (6 * 2 + (4 / 2) - 10) / 2\\") 5 pass","solution":"def evaluate_expression(expr: str) -> int: Evaluates a mathematical expression involving +, -, *, /, (, and ). def evaluate(tokens): def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': operators.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = val * 10 + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() # Remove the '(' else: while operators and precedence(operators[-1]) >= precedence(tokens[i]): apply_operator(operators, values) operators.append(tokens[i]) i += 1 while operators: apply_operator(operators, values) return values[0] return evaluate(expr)"},{"question":"def matrix_diagonal_sum(matrix: List[List[int]]) -> int: Calculate the sum of the elements on both the main diagonal and the secondary diagonal of a matrix. >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 30 >>> matrix_diagonal_sum([[5]]) 10 >>> matrix_diagonal_sum([[1,2], [3,4]]) 10 >>> matrix_diagonal_sum([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 68 >>> matrix_diagonal_sum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -30 >>> matrix_diagonal_sum([[i for i in range(100)] for _ in range(100)]) 9900","solution":"def matrix_diagonal_sum(matrix): n = len(matrix) main_diagonal = sum(matrix[i][i] for i in range(n)) secondary_diagonal = sum(matrix[i][n-i-1] for i in range(n)) return main_diagonal + secondary_diagonal # Example usage # N = 3 # matrix = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # print(matrix_diagonal_sum(matrix)) # Output should be 30"},{"question":"def elevator_sequence(up, down): Determine the sequence of floors visited by the elevator based on given requests. Parameters: up (list): A list of integers representing the floors requested in the upward direction. down (list): A list of integers representing the floors requested in the downward direction. Returns: list: A list representing the sequence of floors visited by the elevator. pass # Unit Tests def test_elevator_sequence_example_1(): up_requests = [3, 5, 7] down_requests = [1, 6] assert elevator_sequence(up_requests, down_requests) == [3, 5, 7, 6, 1] def test_elevator_sequence_example_2(): up_requests = [1, 3] down_requests = [2] assert elevator_sequence(up_requests, down_requests) == [1, 3, 2] def test_elevator_sequence_example_3(): up_requests = [] down_requests = [4, 2] assert elevator_sequence(up_requests, down_requests) == [4, 2] def test_elevator_sequence_no_requests(): up_requests = [] down_requests = [] assert elevator_sequence(up_requests, down_requests) == [] def test_elevator_sequence_only_up_requests(): up_requests = [10, 5, 15] down_requests = [] assert elevator_sequence(up_requests, down_requests) == [5, 10, 15] def test_elevator_sequence_only_down_requests(): up_requests = [] down_requests = [10, 5, 15] assert elevator_sequence(up_requests, down_requests) == [15, 10, 5] def test_elevator_sequence_mixed_requests(): up_requests = [2, 4, 6, 8] down_requests = [5, 3, 1] assert elevator_sequence(up_requests, down_requests) == [2, 4, 6, 8, 5, 3, 1]","solution":"def elevator_sequence(up, down): Determine the sequence of floors visited by the elevator based on given requests. Parameters: up (list): A list of integers representing the floors requested in the upward direction. down (list): A list of integers representing the floors requested in the downward direction. Returns: list: A list representing the sequence of floors visited by the elevator. # Elevator starts moving up and then moves down after handling all up requests. sequence = [] # Add up requests in ascending order. sequence.extend(sorted(up)) # Add down requests in descending order. sequence.extend(sorted(down, reverse=True)) return sequence"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths in a m x n grid from the top-left to the bottom-right corner. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(1, 1) 1 >>> unique_paths(5, 5) 70 >>> unique_paths(10, 10) 48620 >>> unique_paths(100, 1) 1 >>> unique_paths(1, 100) 1 >>> unique_paths(15, 15) 40116600 >>> unique_paths(23, 12) 193536720","solution":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths in a m x n grid from the top-left to the bottom-right corner. # Create a 2D list to store the number of ways to reach each cell dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from cell (1,1) for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"def digital_root(n: int) -> int: Compute the digital root of a non-negative integer n. The digital root is obtained by recursively summing the digits of n until a single-digit result is produced. Args: n (int): The non-negative integer whose digital root is to be calculated. Returns: int: The single-digit digital root of n. >>> digital_root(0) 0 >>> digital_root(16) 7 >>> digital_root(942) 6 >>> digital_root(132189) 6 >>> digital_root(987654321) 9 >>> digital_root(999999999) 9 >>> digital_root(123456789) 9","solution":"def digital_root(n): Compute the digital root of a non-negative integer n. The digital root is obtained by recursively summing the digits of n until a single-digit result is produced. Args: n (int): The non-negative integer whose digital root is to be calculated. Returns: int: The single-digit digital root of n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def length_of_strings(strings): Returns a list of integers representing the length of each string in the input list, except for those strings that contain 'x'. >>> length_of_strings([\\"hello\\", \\"world\\", \\"example\\", \\"python\\"]) [5, 5, 6] >>> length_of_strings([\\"test\\", \\"text\\", \\"code\\", \\"examine\\"]) [4, 4] >>> length_of_strings([\\"alpha\\", \\"beta\\", \\"gamma\\"]) [5, 4, 5] >>> length_of_strings([\\"xenon\\", \\"complex\\", \\"max\\"]) [] >>> length_of_strings([\\"\\"]) [] >>> length_of_strings([\\"piano\\"]) [5]","solution":"def length_of_strings(strings): Returns a list of integers representing the length of each string in the input list, except for those strings that contain 'x'. return [len(s) for s in strings if 'x' not in s]"},{"question":"def max_profit(prices: List[int]) -> int: Calculates the maximum profit with at most two transactions. >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([]) 0 >>> max_profit([5]) 0 >>> max_profit([5, 3]) 0 >>> max_profit([3, 5]) 2 >>> max_profit([5, 5, 5, 1, 2, 3, 4, 5]) 4 >>> max_profit([2, 1, 4, 5, 2, 9, 7]) 11","solution":"def max_profit(prices): Calculates the maximum profit with at most two transactions. Args: prices: List[int] - List of stock prices. Returns: int - Maximum profit. if not prices: return 0 n = len(prices) buy1, buy2 = float('inf'), float('inf') profit1, profit2 = 0, 0 for price in prices: buy1 = min(buy1, price) profit1 = max(profit1, price - buy1) buy2 = min(buy2, price - profit1) profit2 = max(profit2, price - buy2) return profit2"},{"question":"def flatten_dict(d: dict, parent_key: str = '', sep: str = '.') -> dict: Write a function to flatten a nested dictionary. The keys of the nested dictionary should be joined by a period ('.') in the flattened dictionary. Handle any level of nesting and preserve the order of keys in the nested dictionaries. Args: - d (dict): The dictionary to flatten. - parent_key (str): The base key to prefix for nested keys (used in recursion). - sep (str): The separator to use between keys. Returns: - dict: The flattened dictionary. Examples: >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}) {\\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3} >>> flatten_dict({\\"x\\": {\\"y\\": {\\"z\\": 7}}, \\"w\\": 8}) {\\"x.y.z\\": 7, \\"w\\": 8}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary by joining the keys with a period ('.'). Args: - d (dict): The dictionary to flatten. - parent_key (str): The base key to prefix for nested keys (used in recursion). - sep (str): The separator to use between keys. Returns: - dict: The flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in the array which gives the sum of the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] quadruplets = [] n = len(nums) nums.sort() for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets def test_four_sum_example1(): nums = [1, 0, -1, 0, -2, 2] target = 0 expected = [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] assert sorted(four_sum(nums, target)) == sorted(expected) def test_four_sum_example2(): nums = [2, 2, 2, 2, 2] target = 8 expected = [[2, 2, 2, 2]] assert four_sum(nums, target) == expected def test_four_sum_no_result(): nums = [1, 2, 3, 4] target = 20 expected = [] assert four_sum(nums, target) == expected def test_four_sum_with_negatives(): nums = [-1, 2, 2, -5, 0, -1, 4] target = 3 expected = [[-5, 2, 2, 4], [-1, 0, 2, 2]] assert sorted(four_sum(nums, target)) == sorted(expected) def test_four_sum_large_input(): nums = [1]*50 + [-1]*50 + [0]*50 + [2]*50 target = 2 # Manually calculate a plausible expected value if necessary # This large input test is to ensure function doesn't crash and is performant assert len(four_sum(nums, target)) > 0","solution":"def four_sum(nums, target): nums.sort() quadruplets = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def filter_divisible_by_3_and_above_threshold(lst: List[int], threshold: int) -> List[int]: Filter the list of integers to include only those that are divisible by 3 and above a given threshold. >>> filter_divisible_by_3_and_above_threshold([3, 10, 15, 22, 33, 50], 10) [15, 33] >>> filter_divisible_by_3_and_above_threshold([1, 2, 4, 7, 10], 5) []","solution":"def filter_divisible_by_3_and_above_threshold(lst, threshold): return [x for x in lst if x % 3 == 0 and x > threshold]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: TreeNode) -> int: Finds the maximum sum path from the root to a leaf node in a binary tree. :param root: TreeNode, the root node of the binary tree. :return: int, the maximum sum path from root to leaf. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> maxPathSum(root) 4 >>> root = TreeNode(10) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxPathSum(root) 45 >>> root = TreeNode(-10) >>> root.left = TreeNode(-9) >>> root.right = TreeNode(-20) >>> root.left.left = TreeNode(-15) >>> root.left.right = TreeNode(-7) >>> maxPathSum(root) -26","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: TreeNode) -> int: Finds the maximum sum path from the root to a leaf node in a binary tree. :param root: TreeNode, the root node of the binary tree. :return: int, the maximum sum path from root to leaf. if not root: return 0 if not root.left and not root.right: return root.val left_sum = -float('inf') right_sum = -float('inf') if root.left: left_sum = maxPathSum(root.left) if root.right: right_sum = maxPathSum(root.right) return root.val + max(left_sum, right_sum)"},{"question":"def parse_csv(data: str) -> list: A simplified CSV parsing function. The function takes a string representing a CSV file and returns a list of lists representing the data. CSV Format Rules: 1. Fields are separated by commas (\`,\`). 2. Fields may contain double quotes (\`\\"\`). Fields containing commas or double quotes must be enclosed in double quotes. 3. A double quote character in a field must be represented by two double quote characters (\`\\"\\"\`). 4. Fields with leading or trailing whitespace should preserve those spaces. >>> parse_csv('name,age,city') [['name', 'age', 'city']] >>> parse_csv('name,age,cityn\\"John Doe\\",30,\\"New York\\"') [['name', 'age', 'city'], ['John Doe', '30', 'New York']] >>> parse_csv('product,quantity,pricen\\"Apple, Red\\",12,0.5n\\"Banana\\",30,\\"0.2\\"') [['product', 'quantity', 'price'], ['Apple, Red', '12', '0.5'], ['Banana', '30', '0.2']] >>> parse_csv('product,quantity,pricen\\"Grape, \\"\\"Special,100,\\"0.3\\"') [['product', 'quantity', 'price'], ['Grape, \\"Special\\"', '100', '0.3']] >>> parse_csv('a,b,c,dn1,\\"two, three\\", 4,\\"five\\"\\"six') [['a', 'b', 'c', 'd'], ['1', 'two, three', ' 4', 'five\\"six\\"']] pass","solution":"def parse_csv(data: str) -> list: import csv from io import StringIO f = StringIO(data) reader = csv.reader(f, quoting=csv.QUOTE_MINIMAL) return [row for row in reader]"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Write a function \`group_anagrams\` that takes a list of words and returns a list of lists, where each sublist contains words that are anagrams of each other. >>> group_anagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']) [['ate', 'eat', 'tea'], ['nat', 'tan'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams(['abc']) [['abc']] >>> group_anagrams(['abc', 'def', 'ghi']) [['abc'], ['def'], ['ghi']] >>> group_anagrams(['abc', 'cab', 'bca']) [['abc', 'bca', 'cab']] >>> group_anagrams(['abc', 'cab', 'bac', 'bat', 'tab']) [['abc', 'bac', 'cab'], ['bat', 'tab']]","solution":"def group_anagrams(words): from collections import defaultdict # Dictionary to hold sorted word as key and list of anagrams as value anagram_dict = defaultdict(list) # Group words by their sorted version for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) # Return the grouped anagrams sorted lexicographically return [sorted(group) for group in anagram_dict.values()]"},{"question":"def find_pair_with_difference(arr: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array such that the difference between the elements at those indices is exactly the target number. :param arr: List of integers :param target: Integer :return: Boolean >>> find_pair_with_difference([1, 5, 3, 4, 2], 3) True >>> find_pair_with_difference([1, 2, 3, 4, 5], 1) True >>> find_pair_with_difference([1, 5, 3, 4, 2], 7) False >>> find_pair_with_difference([1, 5, 3, 4, 2], 10) False >>> find_pair_with_difference([1], 1) False >>> find_pair_with_difference([], 3) False >>> find_pair_with_difference([1000000000, 999999997, 2], 999999998) True >>> find_pair_with_difference([1, 2, 3, 4, 5], 0) False >>> find_pair_with_difference([1, 1, 2, 3], 0) True","solution":"def find_pair_with_difference(arr, target): Determines if there are two distinct indices i and j in the array such that the difference between the elements at those indices is exactly the target number. :param arr: List of integers :param target: Integer :return: Boolean seen = set() for num in arr: if (num + target) in seen or (num - target) in seen: return True seen.add(num) return False"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted linked lists into one sorted linked list. >>> list_to_linked_list([1, 2, 4]) ListNode object representing 1->2->4 >>> list_to_linked_list([1, 3, 4]) ListNode object representing 1->3->4 >>> merge_two_sorted_lists(list_to_linked_list([1, 2, 4]), list_to_linked_list([1, 3, 4])) ListNode object representing 1->1->2->3->4->4 # Implementation here def list_to_linked_list(lst): Helper function to convert a list to a linked list. if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(node): Helper function to convert a linked list to a list. result = [] while node: result.append(node.val) node = node.next return result def test_merge_two_sorted_lists(): # Test case 1 l1 = list_to_linked_list([1, 2, 4]) l2 = list_to_linked_list([1, 3, 4]) merged = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged) == [1, 1, 2, 3, 4, 4] # Test case 2 l1 = list_to_linked_list([2, 6, 9]) l2 = list_to_linked_list([1, 3, 7, 10]) merged = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged) == [1, 2, 3, 6, 7, 9, 10] # Test case 3 l1 = list_to_linked_list([5]) l2 = list_to_linked_list([1, 2, 3]) merged = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged) == [1, 2, 3, 5] # Test case 4: Both lists are empty l1 = list_to_linked_list([]) l2 = list_to_linked_list([]) merged = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged) == [] # Test case 5: One list is empty l1 = list_to_linked_list([1, 2, 3]) l2 = list_to_linked_list([]) merged = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged) == [1, 2, 3] l1 = list_to_linked_list([]) l2 = list_to_linked_list([1, 2, 3]) merged = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged) == [1, 2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1, l2): Merges two sorted linked lists into one sorted linked list. # Create a dummy node to serve as the starting point for the merged list dummy = ListNode(0) current = dummy # Traverse both lists and attach the smaller node to the merged list while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If one list is exhausted, attach the remaining elements of the other list if l1: current.next = l1 elif l2: current.next = l2 # Return the head of the merged list return dummy.next"},{"question":"def even_squares(numbers: list) -> list: Returns a new list containing the squares of even numbers from the input list. Args: numbers (list): A list of integers. Returns: list: A list containing the squares of all even integers from the input list. >>> even_squares([1, 2, 3, 4, 5, 6]) [4, 16, 36] >>> even_squares([11, 22, 33, 44, 55]) [484, 1936] >>> even_squares([13, 15, 17]) [] >>> even_squares([10, -4, 13, 0]) [100, 16, 0] from even_squares import even_squares def test_even_squares_with_mixed_numbers(): assert even_squares([1, 2, 3, 4, 5, 6]) == [4, 16, 36] def test_even_squares_with_no_even_numbers(): assert even_squares([11, 33, 55]) == [] assert even_squares([13, 15, 17]) == [] def test_even_squares_with_all_even_numbers(): assert even_squares([2, 4, 6, 8, 10]) == [4, 16, 36, 64, 100] def test_even_squares_with_negative_and_zero_values(): assert even_squares([10, -4, 13, 0]) == [100, 16, 0] assert even_squares([-2, -4, -6]) == [4, 16, 36] def test_even_squares_with_large_numbers(): assert even_squares([100, 200, 300]) == [10000, 40000, 90000] def test_even_squares_with_repeated_even_numbers(): assert even_squares([1, 2, 2, 3, 4, 4]) == [4, 4, 16, 16] def test_even_squares_with_empty_list(): assert even_squares([]) == []","solution":"def even_squares(numbers): Returns a new list containing the squares of even numbers from the input list. Args: numbers (list): A list of integers. Returns: list: A list containing the squares of all even integers from the input list. return [x**2 for x in numbers if x % 2 == 0]"},{"question":"def count_common_books(fiction_books, non_fiction_books): This function takes two lists of book IDs representing fiction and non-fiction sections, and returns the count of unique book IDs that are present in both sections. >>> count_common_books([\\"book1\\", \\"book2\\", \\"book3\\", \\"book4\\"], [\\"book3\\", \\"book4\\", \\"book5\\", \\"book6\\"]) 2 >>> count_common_books([\\"book1\\", \\"book2\\", \\"book7\\", \\"book8\\"], [\\"book3\\", \\"book4\\", \\"book5\\", \\"book6\\"]) 0 >>> count_common_books([\\"book1\\", \\"book2\\", \\"book3\\"], [\\"book1\\", \\"book2\\", \\"book3\\"]) 3 >>> count_common_books([], [\\"book1\\", \\"book2\\", \\"book3\\"]) 0 >>> count_common_books([\\"book1\\", \\"book2\\", \\"book3\\"], []) 0","solution":"def count_common_books(fiction_books, non_fiction_books): This function takes two lists of book IDs representing fiction and non-fiction sections, and returns the count of unique book IDs that are present in both sections. # Convert lists to sets fiction_set = set(fiction_books) non_fiction_set = set(non_fiction_books) # Find the intersection of both sets common_books = fiction_set.intersection(non_fiction_set) # Return the number of unique common books return len(common_books)"},{"question":"def increment_array(arr: List[int]) -> List[int]: Returns a new array with each element in the input array incremented by 1. Parameters: arr (list of int): List of integers to be incremented. Returns: list of int: New list of incremented integers. >>> increment_array([1, 2, 3]) -> [2, 3, 4] >>> increment_array([7, 0, -5]) -> [8, 1, -4] >>> increment_array([0]) -> [1] >>> increment_array([]) -> [] >>> increment_array([0, 0, 0, 0]) -> [1, 1, 1, 1] >>> increment_array([-1, -2, -3]) -> [0, -1, -2] >>> increment_array([1000000, 2000000]) -> [1000001, 2000001] pass","solution":"def increment_array(arr): Returns a new array with each element in the input array incremented by 1. Parameters: arr (list of int): List of integers to be incremented. Returns: list of int: New list of incremented integers. return [x + 1 for x in arr]"},{"question":"def char_frequency(s: str) -> dict: Determines the frequency of each character in a given string. The string should only contain lowercase alphabetical characters. Returns a dictionary where the keys are the characters and the values are the frequencies. If the input contains any character other than lowercase alphabetical characters, the function returns \\"Invalid input\\". Examples: >>> char_frequency(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_frequency(\\"banana\\") {'b': 1, 'a': 3, 'n': 2} >>> char_frequency(\\"\\") {} >>> char_frequency(\\"Hello123\\") \\"Invalid input\\" >>> char_frequency(\\"Hello!\\") \\"Invalid input\\"","solution":"def char_frequency(s): Returns the frequency of each character in the given string. Parameters: s (str): The input string containing only lowercase alphabetical characters. Returns: dict: A dictionary with characters as keys and their frequencies as values if input is valid. str: \\"Invalid input\\" if the input string contains characters other than lowercase alphabetical characters. if any(c < 'a' or c > 'z' for c in s): return \\"Invalid input\\" frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Determines whether str1 and str2 are anagrams of each other. Ignores white spaces and is case-insensitive. Args: str1 (str): The first input string. str2 (str): The second input string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. Examples: >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"Hello\\", \\"Olelh\\") True >>> is_anagram(\\"Dormitory\\", \\"Dirty room\\") True >>> is_anagram(\\"The eyes\\", \\"They see\\") True >>> is_anagram(\\"Hello\\", \\"World\\") False","solution":"def is_anagram(str1, str2): Determines whether str1 and str2 are anagrams of each other. Ignores white spaces and is case-insensitive. Args: str1 (str): The first input string. str2 (str): The second input string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. # Remove white spaces and convert to lowercase str1 = ''.join(str1.split()).lower() str2 = ''.join(str2.split()).lower() # Sort characters and compare return sorted(str1) == sorted(str2)"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Create a function that takes a list of intervals and merges all overlapping intervals, returning the resulting list of merged intervals. Each interval is represented as a two-element list [start, end], where start is less than or equal to end. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]] >>> merge_intervals([[1, 2], [3, 4]]) [[1, 2], [3, 4]] >>> merge_intervals([[1, 4], [2, 3], [3, 5]]) [[1, 5]] >>> merge_intervals([[1, 4], [5, 6], [7, 8], [2, 5]]) [[1, 6], [7, 8]] >>> merge_intervals([[1, 4]]) [[1, 4]] >>> merge_intervals([]) [] pass","solution":"def merge_intervals(intervals): Merges all overlapping intervals. :param intervals: List of intervals represented as [start, end] :return: List of merged intervals if not intervals: return [] # Sort intervals by starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] if current[0] <= last_merged[1]: # There is an overlap last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating, returns an empty string. >>> first_non_repeating_character(\\"swiss\\") == \\"w\\" >>> first_non_repeating_character(\\"effort\\") == \\"e\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\"\\" >>> first_non_repeating_character(\\"x\\") == \\"x\\" >>> first_non_repeating_character(\\"\\") == \\"\\" >>> first_non_repeating_character(\\"abcdefg\\") == \\"a\\" >>> first_non_repeating_character(\\"abcdabefg\\") == \\"c\\" >>> first_non_repeating_character(\\"aabbccd\\") == \\"d\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating, returns an empty string. # Create a dictionary to count the occurrences of each character char_count = {} # Count the characters in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find and return the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"def reverse_sequence(s: str) -> str: Takes a string containing a sequence of integers separated by commas and returns a new string with the integers reversed in sequence but not reversed themselves. >>> reverse_sequence(\\"1,2,3,4,5\\") '5,4,3,2,1' >>> reverse_sequence(\\"-1,20,-300,4000,5\\") '5,4000,-300,20,-1' >>> reverse_sequence(\\"10,-20,30,-40,50,-60\\") '-60,50,-40,30,-20,10' >>> reverse_sequence(\\"42\\") '42' >>> reverse_sequence(\\"1,-1\\") '-1,1' >>> reverse_sequence(\\"0,0,0,0,0\\") '0,0,0,0,0'","solution":"def reverse_sequence(s): Takes a string containing a sequence of integers separated by commas and returns a new string with the integers reversed in sequence but not reversed themselves. # Split the input string by commas to get individual integers as strings integer_list = s.split(',') # Reverse the list of integer strings integer_list.reverse() # Join the reversed list back into a single string with commas reversed_sequence = ','.join(integer_list) return reversed_sequence"},{"question":"def num_valid_parentheses(N: int) -> int: Returns the number of valid parentheses strings of length 2*N, modulo 10^9 + 7. >>> num_valid_parentheses(1) 1 >>> num_valid_parentheses(2) 2 >>> num_valid_parentheses(3) 5 >>> num_valid_parentheses(4) 14 >>> num_valid_parentheses(5) 42 >>> num_valid_parentheses(10) 16796 >>> num_valid_parentheses(0) 1 def test_num_valid_parentheses(): assert num_valid_parentheses(1) == 1 assert num_valid_parentheses(2) == 2 assert num_valid_parentheses(3) == 5 assert num_valid_parentheses(4) == 14 assert num_valid_parentheses(5) == 42 assert num_valid_parentheses(10) == 16796 assert num_valid_parentheses(0) == 1 def test_large_n(): assert num_valid_parentheses(1000) >= 0 # Just to check performance and valid output without overflow","solution":"MOD = 10**9 + 7 def num_valid_parentheses(N): Returns the number of valid parentheses strings of length 2*N. if N == 0: return 1 catalan = [0] * (N + 1) catalan[0] = 1 for i in range(1, N + 1): for j in range(i): catalan[i] = (catalan[i] + catalan[j] * catalan[i - 1 - j]) % MOD return catalan[N]"},{"question":"def max_sum_subarray_length_k(N: int, K: int, A: List[int]) -> int: Returns the maximum sum of a subarray of length exactly K. N: Size of array A. K: Length of the subarray. A: The array of integers. >>> max_sum_subarray_length_k(5, 3, [1, 2, 3, -2, 5]) == 6 >>> max_sum_subarray_length_k(4, 2, [1, 2, 3, 4]) == 7 >>> max_sum_subarray_length_k(5, 2, [-1, -2, -3, -4, -5]) == -3 >>> max_sum_subarray_length_k(6, 3, [2, -1, 3, -4, 5, 6]) == 7 >>> max_sum_subarray_length_k(5, 1, [1, -2, 3, -4, 5]) == 5 >>> A = [i for i in range(1, 100001)] >>> max_sum_subarray_length_k(100000, 3, A) == 299997 # Your code here","solution":"def max_sum_subarray_length_k(N, K, A): Returns the maximum sum of a subarray of length exactly K. Parameters: N (int): Size of array A. K (int): Length of the subarray. A (list of int): The array of integers. Returns: int: The maximum possible sum of a subarray of length exactly K. # Calculate the sum of the first subarray of length K current_sum = sum(A[:K]) max_sum = current_sum # Sliding window to calculate the sum of subsequent subarrays of length K for i in range(K, N): current_sum += A[i] - A[i - K] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List, Tuple def min_new_bus_lines(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of new bus lines needed so that every bus stop in the city can be reached from any other bus stop either directly or indirectly. :param n: Number of bus stops :param m: Number of direct bus lines :param edges: List of tuples where each tuple contains two integers denoting a direct bus line between two stops :return: The minimum number of new bus lines needed pass def test_no_lines(): assert min_new_bus_lines(4, 0, []) == 3 def test_one_missing_line(): assert min_new_bus_lines(5, 3, [(1, 2), (2, 3), (3, 4)]) == 1 def test_almost_connected(): assert min_new_bus_lines(3, 1, [(1, 2)]) == 1 def test_fully_connected(): assert min_new_bus_lines(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) == 0 def test_single_bus_stop(): assert min_new_bus_lines(1, 0, []) == 0 def test_disconnected_graph(): assert min_new_bus_lines(6, 2, [(1, 2), (3, 4)]) == 3","solution":"def min_new_bus_lines(n, m, edges): Returns the minimum number of new bus lines needed so that every bus stop can be reached from any other bus stop either directly or indirectly. from collections import defaultdict, deque if n == 1: # Only one bus stop, no lines needed. return 0 # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Function to perform BFS and mark all reachable nodes from a given starting node def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (n + 1) components = 0 # Find all connected components for i in range(1, n + 1): if not visited[i]: components += 1 bfs(i, visited) # Minimum number of edges to add to connect 'components' components is (components - 1) return components - 1"},{"question":"def best_product(products: List[Dict[str, Union[str, float]]]) -> str: Returns the name of the product with the highest rating-to-price ratio. :param products: List of dictionaries, each containing \\"name\\", \\"price\\", and \\"rating\\" of a product :return: The name of the product with the highest rating-to-price ratio >>> best_product([{\\"name\\": \\"Product A\\", \\"price\\": 10.0, \\"rating\\": 4.5}]) 'Product A' >>> best_product([ {\\"name\\": \\"Product A\\", \\"price\\": 10.0, \\"rating\\": 4.5}, {\\"name\\": \\"Product B\\", \\"price\\": 20.0, \\"rating\\": 4.7}, {\\"name\\": \\"Product C\\", \\"price\\": 5.0, \\"rating\\": 3.8} ]) 'Product C' >>> best_product([ {\\"name\\": \\"Product A\\", \\"price\\": 10.0, \\"rating\\": 4.5}, {\\"name\\": \\"Product B\\", \\"price\\": 20.0, \\"rating\\": 9.0} ]) 'Product A' >>> best_product([ {\\"name\\": \\"Product A\\", \\"price\\": 15.0, \\"rating\\": 4.5}, {\\"name\\": \\"Product B\\", \\"price\\": 10.0, \\"rating\\": 3.0}, {\\"name\\": \\"Product C\\", \\"price\\": 5.0, \\"rating\\": 4.0} ]) 'Product C'","solution":"def best_product(products): Returns the name of the product with the highest rating-to-price ratio. :param products: List of dictionaries, each containing \\"name\\", \\"price\\", and \\"rating\\" of a product :return: The name of the product with the highest rating-to-price ratio best_product_name = \\"\\" best_ratio = 0 for product in products: ratio = product['rating'] / product['price'] if ratio > best_ratio: best_ratio = ratio best_product_name = product['name'] return best_product_name"},{"question":"def can_form_palindrome(S: str) -> bool: Checks if a string can be rearranged to form a palindrome by moving characters to the front. >>> can_form_palindrome(\\"aabc\\") True >>> can_form_palindrome(\\"ab\\") False def test_single_character(): assert can_form_palindrome(\\"a\\") == True def test_two_characters_same(): assert can_form_palindrome(\\"aa\\") == True def test_two_characters_different(): assert can_form_palindrome(\\"ab\\") == False def test_three_characters_one_odd(): assert can_form_palindrome(\\"aab\\") == True def test_three_characters_all_unique(): assert can_form_palindrome(\\"abc\\") == False def test_palindrome_possible(): assert can_form_palindrome(\\"racecar\\") == True def test_large_even_characters(): assert can_form_palindrome(\\"aabbcc\\") == True def test_large_odd_characters(): assert can_form_palindrome(\\"aabbc\\") == True def test_large_palindrome(): assert can_form_palindrome(\\"aabbbaa\\") == True def test_all_different_large_string(): assert can_form_palindrome(\\"abcdefghijklmnopqrstuvwxyz\\") == False","solution":"def can_form_palindrome(S): Checks if a string can be rearranged to form a palindrome by moving characters to the front. from collections import Counter count = Counter(S) odd_count = sum(1 for value in count.values() if value % 2 != 0) return odd_count <= 1"},{"question":"def can_form_palindrome(s: str) -> str: Determines if it is possible to rearrange the characters of a string to form a palindrome. >>> can_form_palindrome(\\"civic\\") 'YES' >>> can_form_palindrome(\\"ivicc\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO' >>> can_form_palindrome(\\"aabbcc\\") 'YES' >>> can_form_palindrome(\\"aabbc\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO'","solution":"def can_form_palindrome(s: str) -> str: Determines if it is possible to rearrange the characters of a string to form a palindrome. Parameters: s (str): A string consisting of lowercase English letters. Returns: str: \\"YES\\" if a palindrome can be formed, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def sum_of_distances(arr: List[int]) -> int: Given an array of integers, return the sum of the distances between consecutive elements in the sorted version of this array. >>> sum_of_distances([4, 2, 9, 7]) 7 >>> sum_of_distances([1, 5, 3]) 4 >>> sum_of_distances([10, 20, 30]) 20 >>> sum_of_distances([5]) 0 >>> sum_of_distances([]) 0 >>> sum_of_distances([3, 3, 3]) 0 >>> sum_of_distances([-10, -20, -30]) 20 >>> sum_of_distances([-1, 0, 1]) 2 >>> sum_of_distances([1000000, 500000, 100000]) 900000","solution":"def sum_of_distances(arr): Returns the sum of the distances between consecutive elements in the sorted version of the array. if not arr: return 0 sorted_arr = sorted(arr) sum_distances = 0 for i in range(1, len(sorted_arr)): sum_distances += sorted_arr[i] - sorted_arr[i - 1] return sum_distances"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Returns the area of the largest rectangle that can be formed within the histogram bounds. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 from solution import largestRectangleArea def test_example1(): assert largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 def test_example2(): assert largestRectangleArea([2, 4]) == 4 def test_single_bar(): assert largestRectangleArea([5]) == 5 def test_uneven_bars(): assert largestRectangleArea([2, 1, 2]) == 3 def test_all_equal(): assert largestRectangleArea([3, 3, 3, 3]) == 12 def test_decreasing_heights(): assert largestRectangleArea([6, 5, 4, 3, 2, 1]) == 12 def test_increasing_heights(): assert largestRectangleArea([1, 2, 3, 4, 5, 6]) == 12 def test_empty_input(): assert largestRectangleArea([]) == 0","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed within the histogram bounds. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def detectSoundEvent(samples, threshold, duration): Detect sound events in the given samples. :param samples: List of amplitudes :param threshold: Amplitude threshold to detect a sound event :param duration: Minimum duration that amplitudes must exceed the threshold to be considered an event :return: List of tuples representing the start and end indices of detected sound events >>> detectSoundEvent([1, 3, 7, 8, 2, 10, 6, 5], 5, 2) [(2, 3), (5, 6)] >>> detectSoundEvent([1, 2, 3, 4, 5, 6], 7, 2) [] >>> detectSoundEvent([7, 8, 7, 8, 7, 8], 6, 2) [(0, 3), (4, 5)]","solution":"def detectSoundEvent(samples, threshold, duration): Detect sound events in the given samples. :param samples: List of amplitudes :param threshold: Amplitude threshold to detect a sound event :param duration: Minimum duration that amplitudes must exceed the threshold to be considered an event :return: List of tuples representing the start and end indices of detected sound events events = [] start = None count = 0 for i in range(len(samples)): if samples[i] > threshold: if start is None: start = i count += 1 else: if count >= duration: events.append((start, i - 1)) start = None count = 0 if count >= duration: events.append((start, len(samples) - 1)) return events"},{"question":"def splitArray(nums: List[int], k: int) -> int: Partition the array into k contiguous subarrays such that the largest sum among these subarrays is minimized. Args: nums (List[int]): A list of positive integers. k (int): The number of subarrays. Returns: int: The minimized largest sum among the k subarrays. >>> splitArray([7, 2, 5, 10, 8], 2) 18 >>> splitArray([1, 2, 3, 4, 5], 2) 9 >>> splitArray([10], 1) 10 >>> splitArray([10, 20, 30], 3) 30 >>> splitArray([5, 5, 5, 5], 2) 10","solution":"def can_split(nums, k, max_sum): Helper function to determine if it's possible to split the array into k or fewer parts with all parts having sums not exceeding max_sum. current_sum = 0 required_splits = 1 for num in nums: if current_sum + num <= max_sum: current_sum += num else: required_splits += 1 current_sum = num if required_splits > k: return False return True def splitArray(nums, k): Function to find the minimized largest sum among k contiguous subarrays. left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def rotate_string(s: str, k: int) -> str: Rotates the string s to the right by k positions. Parameters: s (str): The input string to be rotated. k (int): Number of positions to rotate the string. Returns: str: The rotated string. >>> rotate_string(\\"hello\\", 2) 'lohel' >>> rotate_string(\\"abcde\\", 3) 'cdeab' >>> rotate_string(\\"rotate\\", 6) 'rotate' >>> rotate_string(\\"a\\", 1) 'a' >>> rotate_string(\\"\\", 0) ''","solution":"def rotate_string(s, k): Rotates the string s to the right by k positions. Parameters: s (str): The input string to be rotated. k (int): Number of positions to rotate the string. Returns: str: The rotated string. # Edge cases: empty string or k is 0 if not s or k == 0: return s n = len(s) k = k % n # When k is larger than the length of s return s[-k:] + s[:-k]"},{"question":"def moves(sequence): Determines whether a given sequence of moves causes the robot to return to the origin. Args: sequence (str): Sequence of moves consisting of characters 'U', 'D', 'L', 'R'. Returns: bool: True if the moves bring the robot back to the origin, False otherwise. >>> moves(\\"UD\\") == True >>> moves(\\"LL\\") == False >>> moves(\\"RRDD\\") == False >>> moves(\\"LDRU\\") == True","solution":"def moves(sequence): Determines whether a given sequence of moves causes the robot to return to the origin. Args: sequence (str): Sequence of moves consisting of characters 'U', 'D', 'L', 'R'. Returns: bool: True if the moves bring the robot back to the origin, False otherwise. x, y = 0, 0 for move in sequence: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def min_changes(s1: str, s2: str) -> int: Determines the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform string s1 into string s2 using dynamic programming. >>> min_changes(\\"horse\\", \\"ros\\") 3 >>> min_changes(\\"\\", \\"\\") 0 >>> min_changes(\\"a\\", \\"\\") 1 >>> min_changes(\\"\\", \\"a\\") 1 >>> min_changes(\\"abc\\", \\"abc\\") 0 >>> min_changes(\\"abcd\\", \\"a\\") 3 >>> min_changes(\\"a\\", \\"abcd\\") 3 >>> min_changes(\\"a\\", \\"b\\") 1 >>> min_changes(\\"intention\\", \\"execution\\") 5","solution":"def min_changes(s1, s2): Determines the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform string s1 into string s2 using dynamic programming. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Inserting all characters of s2 elif j == 0: dp[i][j] = i # Deleting all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no edit needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Substitute return dp[m][n]"},{"question":"def letter_combinations(digits: str) -> List[str]: Given a string containing digits from '2' to '9', returns all possible letter combinations that the phone number could represent based on T9 predictive text method on a traditional mobile phone. >>> sorted(letter_combinations(\\"23\\")) ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> sorted(letter_combinations(\\"7\\")) ['p', 'q', 'r', 's'] >>> sorted(letter_combinations(\\"47\\")) ['gp', 'gq', 'gr', 'gs', 'hp', 'hq', 'hr', 'hs', 'ip', 'iq', 'ir', 'is']","solution":"def letter_combinations(digits): Given a string containing digits from '2' to '9', returns all possible letter combinations that the phone number could represent. if not digits: return [] phone_map = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_map[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def get_oldest_books_by_author(books): Returns the titles of the oldest books by each unique author from the input list of book dictionaries. Args: books (list): A list of dictionaries where each dictionary contains 'title', 'author', and 'year' keys. Returns: list: A list of strings where each string is the title of the oldest book by a unique author. Examples: >>> books = [ ... {\\"title\\": \\"Book A\\", \\"author\\": \\"Author X\\", \\"year\\": 1999}, ... {\\"title\\": \\"Book B\\", \\"author\\": \\"Author Y\\", \\"year\\": 2005}, ... {\\"title\\": \\"Book C\\", \\"author\\": \\"Author X\\", \\"year\\": 1995}, ... {\\"title\\": \\"Book D\\", \\"author\\": \\"Author Z\\", \\"year\\": 2010}, ... {\\"title\\": \\"Book E\\", \\"author\\": \\"Author Y\\", \\"year\\": 2001} ... ] >>> get_oldest_books_by_author(books) ['Book C', 'Book E', 'Book D'] >>> books = [ ... {\\"title\\": \\"Book A\\", \\"author\\": \\"Author X\\", \\"year\\": 2000}, ... {\\"title\\": \\"Book B\\", \\"author\\": \\"Author Y\\", \\"year\\": 2000}, ... {\\"title\\": \\"Book C\\", \\"author\\": \\"Author X\\", \\"year\\": 2000}, ... ] >>> get_oldest_books_by_author(books) ['Book A', 'Book B'] >>> books = [] >>> get_oldest_books_by_author(books) [] >>> books = [ ... {\\"title\\": \\"Book A\\", \\"author\\": \\"Author X\\", \\"year\\": 2000}, ... ] >>> get_oldest_books_by_author(books) ['Book A'] >>> books = [ ... {\\"title\\": \\"Book A\\", \\"author\\": \\"Author W\\", \\"year\\": 1993}, ... {\\"title\\": \\"Book B\\", \\"author\\": \\"Author X\\", \\"year\\": 1999}, ... {\\"title\\": \\"Book C\\", \\"author\\": \\"Author Y\\", \\"year\\": 1990}, ... {\\"title\\": \\"Book D\\", \\"author\\": \\"Author Z\\", \\"year\\": 2010}, ... {\\"title\\": \\"Book E\\", \\"author\\": \\"Author X\\", \\"year\\": 1995}, ... {\\"title\\": \\"Book F\\", \\"author\\": \\"Author Y\\", \\"year\\": 1985}, ... {\\"title\\": \\"Book G\\", \\"author\\": \\"Author Z\\", \\"year\\": 2005}, ... {\\"title\\": \\"Book H\\", \\"author\\": \\"Author W\\", \\"year\\": 1980} ... ] >>> get_oldest_books_by_author(books) ['Book H', 'Book E', 'Book F', 'Book G']","solution":"def get_oldest_books_by_author(books): Returns the titles of the oldest books by each unique author from the input list of book dictionaries. Args: books (list): A list of dictionaries where each dictionary contains 'title', 'author', and 'year' keys. Returns: list: A list of strings where each string is the title of the oldest book by a unique author. author_oldest_books = {} for book in books: author = book['author'] year = book['year'] if author not in author_oldest_books: author_oldest_books[author] = book else: if book['year'] < author_oldest_books[author]['year']: author_oldest_books[author] = book return [book['title'] for book in author_oldest_books.values()]"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. Parameters: num (int): The integer to be converted. Should be in the range 1 to 3999. Returns: str: The Roman numeral representation of the input integer. Examples: >>> int_to_roman(1) == \\"I\\" >>> int_to_roman(1987) == \\"MCMLXXXVII\\" >>> int_to_roman(3999) == \\"MMMCMXCIX\\"","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. Parameters: num (int): The integer to be converted. Should be in the range 1 to 3999. Returns: str: The Roman numeral representation of the input integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the count of palindromic substrings in the given string. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abccba\\") 9 >>> count_palindromic_substrings(\\"abcd\\") 4 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the result as a list. >>> process_test_cases([\\"abc\\", \\"aaa\\", \\"abba\\", \\"abcd\\"]) [3, 6, 6, 4] >>> process_test_cases([\\"a\\", \\"aaaa\\", \\"\\"]) [1, 10, 0]","solution":"def count_palindromic_substrings(s): Returns the count of palindromic substrings in the given string s. n = len(s) count = 0 # Create a 2D table to store the palindromic status of substrings dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromic for i in range(n): dp[i][i] = True count += 1 # Check for substring of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count def process_test_cases(test_cases): Processes multiple test cases and returns the result as a list. results = [] for s in test_cases: result = count_palindromic_substrings(s) results.append(result) return results"},{"question":"from typing import List, Tuple def max_profit_stock_transaction(prices: List[int]) -> Tuple[int, int]: Write a code that simulates a simplified stock transaction system. The code should process a list of stock prices, determine the maximum possible profit from one buy-and-sell transaction, and output the days to buy and sell for achieving this maximum profit. The code receives an array where each element represents the stock prices of a company over successive days. The objective is to find the pair of days (buy day and sell day) such that buying on the first day and selling later would yield the maximum profit. If no profit can be made, the function should return a tuple with both values set to -1. Rules: - You can only buy once and sell once. - You cannot sell a stock before you buy it. Examples: - Input: [8, 1, 2, 4, 6, 3] Output: (1, 4) - Input: [7, 6, 5, 4, 3, 2, 1] Output: (-1, -1) pass","solution":"def max_profit_stock_transaction(prices): Returns the days to buy and sell to achieve the maximum profit. Args: prices (List[int]): List of stock prices. Returns: Tuple[int, int]: A tuple containing the day to buy and the day to sell. if not prices or len(prices) < 2: return (-1, -1) min_price_day = 0 max_profit = 0 buy_day = -1 sell_day = -1 for current_day in range(1, len(prices)): if prices[current_day] < prices[min_price_day]: min_price_day = current_day current_profit = prices[current_day] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = current_day if max_profit <= 0: return (-1, -1) return (buy_day, sell_day)"},{"question":"def encrypt_message(message: str, key: int) -> str: Encrypts the message using a Caesar cipher with the given key. >>> encrypt_message(\\"Hello, World!\\", 3) \\"Khoor, Zruog!\\" >>> encrypt_message(\\"abcXYZ\\", 2) \\"cdeZAB\\" >>> encrypt_message(\\"Python\\", 0) \\"Python\\" pass def decrypt_message(message: str, key: int) -> str: Decrypts the message that was encrypted using a Caesar cipher with the given key. >>> decrypt_message(\\"Khoor, Zruog!\\", 3) \\"Hello, World!\\" >>> decrypt_message(\\"cdeZAB\\", 2) \\"abcXYZ\\" >>> decrypt_message(\\"Python\\", 0) \\"Python\\" pass def test_encrypt_message(): assert encrypt_message(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert encrypt_message(\\"abcXYZ\\", 2) == \\"cdeZAB\\" assert encrypt_message(\\"Python\\", 0) == \\"Python\\" def test_decrypt_message(): assert decrypt_message(\\"Khoor, Zruog!\\", 3) == \\"Hello, World!\\" assert decrypt_message(\\"cdeZAB\\", 2) == \\"abcXYZ\\" assert decrypt_message(\\"Python\\", 0) == \\"Python\\" assert decrypt_message(\\"cdeZAB\\", 2) == \\"abcXYZ\\" def test_encrypt_and_decrypt_messages(): original_message_1 = \\"SecretMessage123!\\" key_1 = 4 encrypted_message_1 = encrypt_message(original_message_1, key_1) decrypted_message_1 = decrypt_message(encrypted_message_1, key_1) assert decrypted_message_1 == original_message_1 original_message_2 = \\"TEST, this is a Test!\\" key_2 = 5 encrypted_message_2 = encrypt_message(original_message_2, key_2) decrypted_message_2 = decrypt_message(encrypted_message_2, key_2) assert decrypted_message_2 == original_message_2","solution":"def encrypt_message(message, key): Encrypts the message using a Caesar cipher with the given key. encrypted_message = [] for char in message: if char.isalpha(): shift = ord('A') if char.isupper() else ord('a') encrypted_char = chr((ord(char) - shift + key) % 26 + shift) encrypted_message.append(encrypted_char) else: encrypted_message.append(char) return ''.join(encrypted_message) def decrypt_message(message, key): Decrypts the message that was encrypted using a Caesar cipher with the given key. decrypted_message = [] for char in message: if char.isalpha(): shift = ord('A') if char.isupper() else ord('a') decrypted_char = chr((ord(char) - shift - key) % 26 + shift) decrypted_message.append(decrypted_char) else: decrypted_message.append(char) return ''.join(decrypted_message)"},{"question":"def calculate_smaller_angle(h: int, m: int) -> float: Calculate the smaller angle between the hour and minute hands of a clock given the time. >>> calculate_smaller_angle(3, 0) 90 >>> calculate_smaller_angle(6, 15) 97.5 >>> calculate_smaller_angle(12, 45) 112.5 def get_smaller_angles(times: List[str]) -> List[float]: Calculate the smaller angles for a list of times. >>> get_smaller_angles([\\"3:00\\", \\"6:15\\", \\"12:45\\"]) [90, 97.5, 112.5] >>> get_smaller_angles([\\"9:00\\", \\"1:30\\", \\"11:59\\"]) [90, 135, 5.5]","solution":"def calculate_smaller_angle(h, m): # Calculate the positions of the hour and minute hands in degrees hour_angle = (h % 12) * 30 + (m / 60) * 30 minute_angle = m * 6 # Calculate the absolute difference between the two angles angle = abs(hour_angle - minute_angle) # Return the smaller angle of the two possible angles return min(angle, 360 - angle) def get_smaller_angles(times): results = [] for time in times: h, m = map(int, time.split(':')) results.append(calculate_smaller_angle(h, m)) return results"},{"question":"from typing import List def separate_even_odd(values: List[int]) -> List[int]: Given a list of integers, return a list of integers containing all the even numbers from the original list followed by all the odd numbers, while retaining their original order. >>> separate_even_odd([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [4, 2, 6, 3, 1, 1, 5, 9, 5, 3, 5] >>> separate_even_odd([10, 22, 35, 9, 14, 20, 3]) [10, 22, 14, 20, 35, 9, 3] # Test Cases: def test_separate_even_odd_mixed(): assert separate_even_odd([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [4, 2, 6, 3, 1, 1, 5, 9, 5, 3, 5] def test_separate_even_odd_all_evens(): assert separate_even_odd([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] def test_separate_even_odd_all_odds(): assert separate_even_odd([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9] def test_separate_even_odd_empty(): assert separate_even_odd([]) == [] def test_separate_even_odd_no_evens(): assert separate_even_odd([1, 3, 5, 7, 9, 11]) == [1, 3, 5, 7, 9, 11] def test_separate_even_odd_no_odds(): assert separate_even_odd([2, 4, 6, 8, 10, 12]) == [2, 4, 6, 8, 10, 12] def test_separate_even_odd_mixed_single_digit(): assert separate_even_odd([10, 22, 35, 9, 14, 20, 3]) == [10, 22, 14, 20, 35, 9, 3]","solution":"def separate_even_odd(values): Returns a list with all even numbers first, followed by all odd numbers, retaining their original order within each group. :param values: List of integers :return: List of integers evens = [x for x in values if x % 2 == 0] odds = [x for x in values if x % 2 != 0] return evens + odds"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two input strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"listen\\", \\"silents\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"abc\\", \\"abc\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\") False >>> are_anagrams(\\"a gentleman\\", \\"elegant man\\") True >>> are_anagrams(\\"a!b@c#\\", \\"#c@b!a\\") True","solution":"def are_anagrams(str1, str2): Returns True if str1 and str2 are anagrams, otherwise returns False. # Check if the lengths of both strings are the same if len(str1) != len(str2): return False # Sort the characters of both strings and compare them return sorted(str1) == sorted(str2)"},{"question":"def bonus_calculation(records, base_bonus): Calculate the total bonus for each employee based on their performance rating. Args: records (list of tuples): List of tuples where each tuple contains the employee name and rating. base_bonus (int): The base bonus amount for the lowest performance rating (1). Returns: dict: A dictionary with employee names as keys and their total bonus as values. Example: >>> bonus_calculation([('Alice', 1), ('Bob', 3), ('Charlie', 5)], 100) {'Alice': 100, 'Bob': 400, 'Charlie': 1600} >>> bonus_calculation([('David', 2), ('Eva', 4)], 50) {'David': 100, 'Eva': 400} >>> bonus_calculation([('Frank', 3), ('Grace', 2), ('Helen', 1)], 200) {'Frank': 800, 'Grace': 400, 'Helen': 200}","solution":"def bonus_calculation(records, base_bonus): Calculate the total bonus for each employee based on their performance rating. Args: records (list of tuples): List of tuples where each tuple contains the employee name and rating. base_bonus (int): The base bonus amount for the lowest performance rating (1). Returns: dict: A dictionary with employee names as keys and their total bonus as values. bonus_mapping = { 1: 1, 2: 2, 3: 4, 4: 8, 5: 16 } bonuses = {} for name, rating in records: if rating in bonus_mapping: bonuses[name] = base_bonus * bonus_mapping[rating] return bonuses"},{"question":"import math from typing import List, Tuple def minimum_jars(N: int, M: int, ingredients: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of jars Chef needs to open per ingredient to distribute the required quantities to all N contestants. Args: N (int): Number of contestants. M (int): Number of ingredients. ingredients (List[Tuple[int, int]]): A list of tuples where each tuple consists of: R_i (int): Amount of ingredient i required by one contestant. Q_i (int): Quantity of ingredient i available in one jar. Returns: List[int]: A list of integers where the ith integer is the minimum number of jars needed to fulfill the requirement for the ith ingredient. Example: >>> minimum_jars(3, 2, [(4, 10), (5, 20)]) [2, 1] >>> minimum_jars(4, 2, [(1, 1), (2, 8)]) [4, 1] from solution import minimum_jars def test_case_1(): # Given sample test case N = 3 M = 2 ingredients = [(4, 10), (5, 20)] assert minimum_jars(N, M, ingredients) == [2, 1] def test_case_2(): # Test case where one ingredient requires multiple jars and the other needs exactly one N = 4 M = 2 ingredients = [(1, 1), (2, 8)] assert minimum_jars(N, M, ingredients) == [4, 1] def test_case_3(): # Test case where the number of jars exactly matches the required amount N = 5 M = 1 ingredients = [(3, 15)] assert minimum_jars(N, M, ingredients) == [1] def test_case_4(): # Test case with high amounts to check precision N = 100000 M = 1 ingredients = [(7, 700000)] assert minimum_jars(N, M, ingredients) == [1] def test_case_5(): # Test case with ingredients needing exactly number of jars equal to contestant count N = 10 M = 2 ingredients = [(10, 50), (5, 10)] assert minimum_jars(N, M, ingredients) == [2, 5] def test_case_6(): # Test case with single contestant multiple ingredients N = 1 M = 3 ingredients = [(1, 2), (2, 3), (3, 4)] assert minimum_jars(N, M, ingredients) == [1, 1, 1]","solution":"import math def minimum_jars(N, M, ingredients): result = [] for R_i, Q_i in ingredients: total_required = N * R_i jars_needed = math.ceil(total_required / Q_i) result.append(jars_needed) return result"},{"question":"from typing import List def max_water_area(heights: List[int]) -> int: This function returns the maximum area of water that can be contained between two blocks while keeping the water contained within the block heights. Examples: >>> max_water_area([1,8,6,2,5,4,8,3,7]) 49 >>> max_water_area([1,1]) 1","solution":"from typing import List def max_water_area(heights: List[int]) -> int: This function returns the maximum area of water that can be contained between two blocks while keeping the water contained within the block heights. left = 0 right = len(heights) - 1 max_area = 0 while left < right: # Calculate the width and height width = right - left height = min(heights[left], heights[right]) # Calculate the area current_area = width * height # Update maximum area max_area = max(max_area, current_area) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def calculate_total_score(n: int, scores: List[List[int]]) -> int: Calculate the total score by summing the highest scores for each level. >>> calculate_total_score(3, [[50, 60, 70], [80, 40], [90, 100, 80]]) == 250 >>> calculate_total_score(2, [[30, 20, 10], [40, 50, 60]]) == 90","solution":"def calculate_total_score(n, scores): Calculate the total score by summing the highest scores for each level. Parameters: n (int): Number of levels in the game. scores (list of list of int): 2D list where each inner list contains scores of a specific level. Returns: int: Total score. total_score = 0 for level_scores in scores: total_score += max(level_scores) return total_score"},{"question":"def generate_seating_patterns(T, test_cases): Generates the seating patterns for multiple test cases. Parameters: T (int): The number of test cases. test_cases (List[int]): A list containing the number of rows for each test case. Returns: str: A string representing the seating arrangements for all test cases, separated by newlines. Examples: >>> generate_seating_patterns(3, [2, 3, 4]) \\"#nnn#nn#nn#nn#n\\" >>> generate_seating_patterns(1, [2]) \\"#n\\" from solution import generate_seating_patterns def test_case_1(): T = 3 test_cases = [2, 3, 4] expected_output = \\"#nnn#nn#nn#nn#n\\" assert generate_seating_patterns(T, test_cases) == expected_output def test_case_2(): T = 2 test_cases = [1, 3] expected_output = \\"#nn#nn#\\" assert generate_seating_patterns(T, test_cases) == expected_output def test_case_3(): T = 1 test_cases = [5] expected_output = \\"#nn#nn#\\" assert generate_seating_patterns(T, test_cases) == expected_output def test_case_4(): T = 1 test_cases = [1] expected_output = \\"#\\" assert generate_seating_patterns(T, test_cases) == expected_output def test_case_5(): T = 4 test_cases = [2, 4, 3, 2] expected_output = \\"#nnn#nn#nnn#nn#nn#n\\" assert generate_seating_patterns(T, test_cases) == expected_output","solution":"def generate_seating_pattern(n): Returns the seating arrangement pattern for N rows. pattern = [] for i in range(1, n+1): pattern.append('#' * i) return pattern def generate_patterns_for_test_cases(test_cases): Given a list of test cases, generates seating patterns for each case. results = [] for N in test_cases: results.extend(generate_seating_pattern(N)) results.append(\\"\\") # To add a separator between patterns return results def generate_seating_patterns(T, test_cases): Generates the seating patterns for multiple test cases. all_patterns = generate_patterns_for_test_cases(test_cases) # Join and return the full pattern string return \\"n\\".join(all_patterns).strip()"},{"question":"from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together. :param strs: List of strings :return: List of lists with grouped anagrams >>> group_anagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams(['listen', 'silent', 'enlist']) [['listen', 'silent', 'enlist']] >>> group_anagrams(['cat', 'dog', 'bird']) [['cat'], ['dog'], ['bird']] >>> group_anagrams(['','b','bb','bbb','abba','baba','aabb']) [[''], ['b'], ['bb'], ['bbb'], ['abba', 'baba', 'aabb']]","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams together. :param strs: List of strings :return: List of lists with grouped anagrams anagrams = defaultdict(list) for word in strs: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def find_item_location(S: int, C: int, P: int) -> (int, int): Determines the shelf number and compartment number of the given item. Parameters: S (int): Number of shelves. C (int): Number of compartments per shelf. P (int): Position of the item. Returns: tuple: (shelf_number, compartment_number) Examples: >>> find_item_location(3, 4, 8) (2, 4) >>> find_item_location(5, 5, 22) (5, 2) >>> find_item_location(2, 1000, 1000) (1, 1000) >>> find_item_location(2, 1000, 1001) (2, 1)","solution":"def find_item_location(S, C, P): Determines the shelf number and compartment number of the given item. Parameters: S (int): Number of shelves. C (int): Number of compartments per shelf. P (int): Position of the item. Returns: tuple: (shelf_number, compartment_number) shelf_number = (P - 1) // C + 1 compartment_number = (P - 1) % C + 1 return shelf_number, compartment_number"},{"question":"def factorial_zeros(n: int) -> int: Calculate the number of trailing zeros in the factorial of a given number n. >>> factorial_zeros(5) 1 >>> factorial_zeros(10) 2 >>> factorial_zeros(20) 4 >>> factorial_zeros(100) 24 >>> factorial_zeros(0) 0 >>> factorial_zeros(1000) 249","solution":"def factorial_zeros(n): Returns the number of trailing zeros in n! count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"def common_prefix(lst: List[str]) -> str: Returns the longest common prefix from a list of strings. If no common prefix exists, returns an empty string. >>> common_prefix(['apple', 'ape', 'april']) 'ap' >>> common_prefix(['car', 'dog', 'racecar']) ''","solution":"from typing import List def common_prefix(lst: List[str]) -> str: Returns the longest common prefix from a list of strings. If no common prefix exists, returns an empty string. if not lst: return \\"\\" # Sort the list to bring lexicographically smallest and largest strings # at the ends for comparison lst.sort() # The smallest and largest string in sorted list will help determine # the minimum common prefix length first = lst[0] last = lst[-1] # Compare characters one by one between the smallest and largest string i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 # The common prefix is the substring from start to the point where they differ return first[:i]"},{"question":"from typing import List, Tuple def min_steps_to_k_distinct(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of steps required to form a substring that contains exactly K distinct characters. If it is impossible, return -1. >>> min_steps_to_k_distinct(2, [(3, \\"abcabcabc\\"), (4, \\"aabbcc\\")]) [0, -1] >>> min_steps_to_k_distinct(1, [(2, \\"aaaabbbbcccc\\")]) [0] def process_input_and_get_results(input_data: str) -> List[int]: Process the input data and return the results for each test case. >>> input_data = \\"2n3nabcabcabcn4naabbccn\\" >>> process_input_and_get_results(input_data) [0, -1] >>> input_data = \\"1n2naaaabbbbccccn\\" >>> process_input_and_get_results(input_data) [0]","solution":"def min_steps_to_k_distinct(T, test_cases): from collections import Counter results = [] for K, S in test_cases: unique_chars = len(set(S)) if unique_chars < K: results.append(-1) elif unique_chars == K: results.append(0) else: # This is a simplification as we assume the removal may be zero since we can rearrange. results.append(0) return results # Function to process input and output for multiple test cases def process_input_and_get_results(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): K = int(input_lines[index]) S = input_lines[index + 1] test_cases.append((K, S)) index += 2 return min_steps_to_k_distinct(T, test_cases)"},{"question":"def find_missing_numbers(arr: List[int]) -> List[int]: Given a list of integers, find all missing numbers in the list. The list contains integers from 1 to n, where n is the length of the list plus the count of missing numbers. Returns the missing numbers as a list sorted in ascending order. >>> find_missing_numbers([4, 3, 2, 7, 8, 2, 3, 1]) [5, 6] >>> find_missing_numbers([1, 1, 2, 2]) [3, 4] >>> find_missing_numbers([1, 2, 3, 4, 6, 7, 8, 9]) [5]","solution":"def find_missing_numbers(arr): Returns the missing numbers in the given list of integers where the list contains integers from 1 to n, where n is the length of the list plus the count of missing numbers. n = len(arr) all_numbers = set(range(1, n + 1)) present_numbers = set(arr) missing_numbers = sorted(all_numbers - present_numbers) return missing_numbers"},{"question":"def is_palindrome(s: str) -> bool: Implement a function \`is_palindrome\` that takes a single \`string\` as input and returns \`True\` if the string is a palindrome, and \`False\` otherwise. A palindrome is a string that reads the same backward as forward. Ignore spaces and case sensitivity when determining if the string is a palindrome. >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False","solution":"def is_palindrome(s): Returns True if the given string is a palindrome, False otherwise. Ignores spaces and case sensitivity. # Removing spaces and converting to lowercase cleaned_s = ''.join(s.split()).lower() # Checking if the string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"import numpy as np def array_operations(n, m, array): Given a 2-D array of size NxM, this function returns: - The max along axis 0 - The min along axis 1 - The min along axis None pass # Example unit tests def test_example_case(): n, m = 2, 2 array = [[1, 2], [3, 4]] max_axis_0, min_axis_1, min_none = array_operations(n, m, array) assert np.array_equal(max_axis_0, np.array([3, 4])) assert np.array_equal(min_axis_1, np.array([1, 3])) assert min_none == 1 def test_larger_case(): n, m = 3, 3 array = [[1, 9, 7], [4, 5, 6], [2, 8, 3]] max_axis_0, min_axis_1, min_none = array_operations(n, m, array) assert np.array_equal(max_axis_0, np.array([4, 9, 7])) assert np.array_equal(min_axis_1, np.array([1, 4, 2])) assert min_none == 1 def test_single_row(): n, m = 1, 4 array = [[1, 2, 3, 4]] max_axis_0, min_axis_1, min_none = array_operations(n, m, array) assert np.array_equal(max_axis_0, np.array([1, 2, 3, 4])) assert np.array_equal(min_axis_1, np.array([1])) assert min_none == 1 def test_single_column(): n, m = 4, 1 array = [[2], [3], [1], [4]] max_axis_0, min_axis_1, min_none = array_operations(n, m, array) assert np.array_equal(max_axis_0, np.array([4])) assert np.array_equal(min_axis_1, np.array([2, 3, 1, 4])) assert min_none == 1 def test_same_elements(): n, m = 2, 2 array = [[6, 6], [6, 6]] max_axis_0, min_axis_1, min_none = array_operations(n, m, array) assert np.array_equal(max_axis_0, np.array([6, 6])) assert np.array_equal(min_axis_1, np.array([6, 6])) assert min_none == 6","solution":"import numpy as np def array_operations(n, m, array): Given a 2-D array of size NxM, this function returns: - The max along axis 0 - The min along axis 1 - The min along axis None my_array = np.array(array) max_axis_0 = np.max(my_array, axis=0) min_axis_1 = np.min(my_array, axis=1) min_none = np.min(my_array, axis=None) return max_axis_0, min_axis_1, min_none"},{"question":"def decipher_message(encoded_message: str) -> str: Decipher the encoded message by shifting each character back by one position in the alphabet. If the character is 'a', it wraps around to 'z'. Args: encoded_message (str): The encoded message containing only lowercase English letters. Returns: str: The original message. Examples: >>> decipher_message(\\"bcd\\") \\"abc\\" >>> decipher_message(\\"efg\\") \\"def\\" >>> decipher_message(\\"a\\") \\"z\\"","solution":"def decipher_message(encoded_message: str) -> str: Decipher the encoded message by shifting each character back by one position in the alphabet. If the character is 'a', it wraps around to 'z'. Args: encoded_message (str): The encoded message containing only lowercase English letters. Returns: str: The original message. deciphered_message = [] for char in encoded_message: if char == 'a': deciphered_message.append('z') else: deciphered_message.append(chr(ord(char) - 1)) return ''.join(deciphered_message)"},{"question":"def findLongestSubarray(nums: List[int]) -> int: Write a function named \`findLongestSubarray\` that takes a list of integers as input and returns the length of the longest subarray that consists of contiguous elements with the same value. >>> findLongestSubarray([]) 0 >>> findLongestSubarray([1]) 1 >>> findLongestSubarray([1, 2, 3, 4, 5]) 1 >>> findLongestSubarray([7, 7, 7, 7, 7]) 5 >>> findLongestSubarray([1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5]) 4 >>> findLongestSubarray([1, 1, 2, 2, 3, 3]) 2 >>> findLongestSubarray([6, 6, 6, 2, 1, 1]) 3 >>> findLongestSubarray([1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5]) 4 >>> findLongestSubarray([-1, -1, -1, -2, -3, -3]) 3 pass","solution":"def findLongestSubarray(nums): Returns the length of the longest subarray consisting of contiguous elements with the same value. If the input list is empty, the function returns 0. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(current_length, max_length)"},{"question":"def rearrange_array(n: int, a: List[int], x: int) -> Union[NoReturn, List[int]]: Ujan needs to determine if it is possible to rearrange the array \`a\` such that no two adjacent elements have a difference equal to \`x\`. If it is possible, return the rearranged array, otherwise return \\"No\\". Args: n (int): The length of the array. a (List[int]): The array of distinct integers. x (int): The integer value to avoid as difference between adjacent elements. Returns: Union[NoReturn, List[int]]: The rearranged array or \\"No\\". >>> rearrange_array(5, [1, 2, 3, 4, 5], 1) \\"No\\" >>> rearrange_array(4, [10, 20, 30, 40], 5) [10, 30, 20, 40] from typing import List, Union, NoReturn","solution":"def rearrange_array(n, a, x): a.sort() # Check if starting from leftmost element can form a valid configuration for i in range(1, n): if abs(a[i] - a[i - 1]) == x: break else: # If no break happened, it means array is suitable return a # Check if starting from second element to last element can form a valid configuration for i in range(n - 1): if abs(a[i] - a[i + 1]) == x: break else: # If no break happened, it means array is suitable return a[::-1] return \\"No\\""},{"question":"def max_strength_for_team_size(n: int, challenges: List[int]) -> List[int]: Finds the maximum strength of a team for each possible team size from 1 to n. Args: n : int : The number of participants challenges : list : The list of integers representing the number of challenges solved by each participant (sorted in non-decreasing order) Returns: list : A list of n integers representing the maximum strength of a team of each size from 1 to n. >>> max_strength_for_team_size(8, [1, 2, 2, 3, 3, 3, 4, 5]) [5, 4, 3, 3, 3, 2, 2, 1] >>> max_strength_for_team_size(1, [5]) [5] >>> max_strength_for_team_size(5, [3, 3, 3, 3, 3]) [3, 3, 3, 3, 3] >>> max_strength_for_team_size(4, [1, 2, 3, 4]) [4, 3, 2, 1] >>> max_strength_for_team_size(4, [1, 1, 1, 1]) [1, 1, 1, 1] pass","solution":"def max_strength_for_team_size(n, challenges): Finds the maximum strength of a team for each possible team size from 1 to n. Args: n : int : The number of participants challenges : list : The list of integers representing the number of challenges solved by each participant (sorted in non-decreasing order) Returns: list : A list of n integers representing the maximum strength of a team of each size from 1 to n # The strength of the team of size x is the element at position -x (because the list is sorted in non-decreasing order) result = [challenges[-i] for i in range(1, n + 1)] return result # Example of usage n = 8 challenges = [1, 2, 2, 3, 3, 3, 4, 5] print(max_strength_for_team_size(n, challenges)) # Output: [5, 4, 3, 3, 3, 2, 2, 1]"},{"question":"def numTrees(n: int) -> int: Returns the number of structurally unique BSTs that store values 1 to n. >>> numTrees(0) 1 >>> numTrees(1) 1 >>> numTrees(2) 2 >>> numTrees(3) 5 >>> numTrees(4) 14 >>> numTrees(5) 42 >>> numTrees(19) 1767263190","solution":"def numTrees(n): Returns the number of structurally unique BSTs that store values 1 to n. if n == 0 or n == 1: return 1 # dp[i] will store the number of unique BSTs that can be constructed with i nodes. dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"def repeated_pattern(s: str) -> bool: Determines if the string can be constructed by repeating a substring of it. >>> repeated_pattern(\\"abab\\") True >>> repeated_pattern(\\"aba\\") False >>> repeated_pattern(\\"abcabcabcabc\\") True","solution":"def repeated_pattern(s): Determines if the string can be constructed by repeating a substring of it. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"def min_operations(s1: str, s2: str) -> int: Determine the minimum number of operations required to transform s1 into s2. An operation consists of picking any character of s1 and changing it to any other lowercase English character. :param s1: str: The initial string. :param s2: str: The target string. :return: int: The minimum number of operations required. def test_min_operations_example_1(): assert min_operations(\\"abcdef\\", \\"azcedf\\") == 3 def test_min_operations_example_2(): assert min_operations(\\"hello\\", \\"world\\") == 4 def test_min_operations_example_3(): assert min_operations(\\"aaa\\", \\"aaa\\") == 0 def test_min_operations_edge_case_empty(): assert min_operations(\\"\\", \\"\\") == 0 def test_min_operations_edge_case_single_char_different(): assert min_operations(\\"a\\", \\"b\\") == 1 def test_min_operations_edge_case_single_char_same(): assert min_operations(\\"a\\", \\"a\\") == 0 def test_min_operations_large_input(): s1 = \\"a\\" * 10**5 s2 = \\"b\\" * 10**5 assert min_operations(s1, s2) == 10**5 def test_min_operations_partial_match(): s1 = \\"abcd\\" * 10 s2 = \\"abcd\\" * 10 assert min_operations(s1, s2) == 0","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. An operation consists of picking any character of s1 and changing it to any other lowercase English character. :param s1: str: The initial string. :param s2: str: The target string. :return: int: The minimum number of operations required. # Assuming both s1 and s2 have the same length operations = 0 for ch1, ch2 in zip(s1, s2): if ch1 != ch2: operations += 1 return operations"},{"question":"def roman_to_int(roman: str) -> int: Converts a Roman numeral to an integer. >>> roman_to_int('I') 1 >>> roman_to_int('V') 5 >>> roman_to_int('X') 10 >>> roman_to_int('L') 50 >>> roman_to_int('C') 100 >>> roman_to_int('D') 500 >>> roman_to_int('M') 1000 >>> roman_to_int('III') 3 >>> roman_to_int('IV') 4 >>> roman_to_int('IX') 9 >>> roman_to_int('LVIII') 58 >>> roman_to_int('XC') 90 >>> roman_to_int('CD') 400 >>> roman_to_int('CM') 900 >>> roman_to_int('MCMXCIV') 1994 >>> roman_to_int('MMXX') 2020 >>> roman_to_int('XLII') 42 >>> roman_to_int('XCIX') 99 >>> roman_to_int('CCCXXXIII') 333 >>> roman_to_int('MMMCMXCIX') 3999 >>> roman_to_int('MMM') 3000","solution":"def roman_to_int(roman): Converts a Roman numeral to an integer. roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def maxScore(cards: List[int], k: int) -> int: You are given an array of integers cards where cards[i] represents the value of the ith card. You are also given an integer k indicating the number of cards you can draw from the deck. In each turn, you can choose to draw one card from either the beginning or the end of the deck and add its value to your score. Your goal is to maximize your score by drawing exactly k cards. Return the maximum score you can achieve after drawing k cards. >>> maxScore([1, 2, 3, 4, 5, 6, 1], 3) 12 >>> maxScore([2, 2, 2], 2) 4 >>> maxScore([9, 7, 7, 9, 7, 7, 9], 7) 55","solution":"def maxScore(cards, k): Returns the maximum score achievable by drawing exactly k cards. You can only draw from either the beginning or the end of the deck. # Initial score choosing first k cards from the start current_score = sum(cards[:k]) max_score = current_score # We move one card from the start to end until we exhaust k cards for i in range(1, k + 1): current_score += cards[-i] - cards[k - i] max_score = max(max_score, current_score) return max_score"},{"question":"def transform_array(n: int) -> List[int]: Generates an array of size \`n\` with elements [1, 2, 3, ..., n], reverses the array, and then replaces each element with the cumulative sum up to that element. >>> transform_array(5) [5, 9, 12, 14, 15] >>> transform_array(3) [3, 5, 6]","solution":"def transform_array(n): Generates an array of size \`n\` with elements [1, 2, 3, ..., n], reverses the array, and then replaces each element with the cumulative sum up to that element. # Generate the initial array [1, 2, ..., n] arr = list(range(1, n + 1)) # Reverse the array arr.reverse() # Replace each element with the cumulative sum for i in range(1, n): arr[i] += arr[i - 1] return arr"},{"question":"def retain_and_sort(lst: list) -> list: Returns a new list with only the elements that are either integers or floats, and in ascending order. >>> retain_and_sort([3, 'hello', 5.6, 7, '42', 1.2]) == [1.2, 3, 5.6, 7] >>> retain_and_sort(['world', 4.4, 'test', 2.2, 2, 8]) == [2, 2.2, 4.4, 8] >>> retain_and_sort(['abc', 'xyz']) == [] >>> retain_and_sort([]) == [] >>> retain_and_sort([4, 2, 8, 6, 1]) == [1, 2, 4, 6, 8] >>> retain_and_sort([4.5, 2.1, 8.3, 6.7, 1.2]) == [1.2, 2.1, 4.5, 6.7, 8.3] >>> retain_and_sort([4, 4.5, 2.1, 1, 8.3]) == [1, 2.1, 4, 4.5, 8.3] >>> retain_and_sort([-1, 'abc', -2.5, 3, 0]) == [-2.5, -1, 0, 3]","solution":"def retain_and_sort(lst): Returns a new list with only the elements that are either integers or floats, and in ascending order. Parameters: lst (list): The input list containing mixed data types. Returns: list: A list of integers and floats in ascending order. result = [x for x in lst if isinstance(x, (int, float))] return sorted(result)"},{"question":"def find_shortest_path(graph, landmarks): Find the shortest path that connects a set of given landmarks, visiting each landmark exactly once and returning to the starting point. >>> graph = { ... ('A', 'B'): 10, ... ('A', 'C'): 15, ... ('B', 'C'): 35, ... ('B', 'D'): 25, ... ('C', 'D'): 30, ... ('D', 'A'): 20 ... } >>> landmarks = ['A', 'B', 'C', 'D'] >>> find_shortest_path(graph, landmarks) ['A', 'B', 'D', 'C', 'A'] pass def calculate_path_length(graph, path): total_length = 0 for i in range(len(path) - 1): segment = (path[i], path[i + 1]) if segment in graph: total_length += graph[segment] else: total_length += graph[(path[i + 1], path[i])] # assuming the graph is undirected return total_length def test_find_shortest_path(): graph = { ('A', 'B'): 10, ('A', 'C'): 15, ('B', 'C'): 35, ('B', 'D'): 25, ('C', 'D'): 30, ('D', 'A'): 20 # Adding D -> A for completeness } landmarks = ['A', 'B', 'C', 'D'] result = find_shortest_path(graph, landmarks) expected = ['A', 'B', 'D', 'C', 'A'] # Shortest path len: 10 + 25 + 30 + 15 = 80 assert result == expected def test_find_shortest_path_with_different_lengths(): graph = { ('A', 'B'): 5, ('A', 'C'): 10, ('A', 'D'): 20, ('B', 'C'): 15, ('B', 'D'): 35, ('C', 'D'): 25 } landmarks = ['A', 'B', 'C', 'D'] result = find_shortest_path(graph, landmarks) expected_permutation = [('A', 'B', 'C', 'D', 'A'), ('A', 'C', 'B', 'D', 'A')] expected_lengths = [5 + 15 + 25 + 20, 10 + 15 + 35 + 20] assert result[0] == 'A' assert result[-1] == 'A' assert len(result) == len(landmarks) + 1 assert any(result == list(perm) for perm in expected_permutation) assert calculate_path_length(graph, result) in expected_lengths def test_find_shortest_path_with_no_segment(): graph = { ('A', 'B'): 10, ('A', 'C'): 15, ('B', 'C'): 35 } landmarks = ['A', 'B', 'C'] result = find_shortest_path(graph, landmarks) expected = ['A', 'B', 'C', 'A'] # Shortest path len: 10 + 35 + 15 = 60 assert result == expected","solution":"import itertools def calculate_path_length(graph, path): total_length = 0 for i in range(len(path) - 1): segment = (path[i], path[i + 1]) if segment in graph: total_length += graph[segment] else: total_length += graph[(path[i + 1], path[i])] # assuming the graph is undirected return total_length def find_shortest_path(graph, landmarks): shortest_path = None shortest_length = float('inf') all_permutations = itertools.permutations(landmarks[1:]) for perm in all_permutations: path = [landmarks[0]] + list(perm) + [landmarks[0]] length = calculate_path_length(graph, path) if length < shortest_length: shortest_length = length shortest_path = path return shortest_path"},{"question":"def min_window(s: str, t: str) -> str: Returns the minimum window in s which contains all the characters present in t. If there are multiple such windows of the same length, return the one which occurs first. If no such window exists, return an empty string. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" >>> min_window(\\"ADOBECODEBANC\\", \\"XYZ\\") == \\"\\" >>> min_window(\\"ABC\\", \\"ABC\\") == \\"ABC\\" >>> min_window(\\"AAAAAAAAAAABBB\\", \\"AAB\\") == \\"AAB\\" >>> min_window(\\"\\", \\"ABC\\") == \\"\\" >>> min_window(\\"ABC\\", \\"\\") == \\"\\" >>> min_window(\\"\\", \\"\\") == \\"\\"","solution":"from collections import Counter, defaultdict def min_window(s, t): Returns the minimum window in s which contains all the characters present in t. If there are multiple such windows of the same length, return the one which occurs first. If no such window exists, return an empty string. if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None while r < len(s): char = s[r] window_counts[char] += 1 if char in dict_t and window_counts[char] == dict_t[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[char] -= 1 if char in dict_t and window_counts[char] < dict_t[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"def second_largest(nums: List[int]) -> int: Returns the second largest unique integer in the list. If there are less than 2 unique integers, return None. >>> second_largest([3, 1, 4, 1, 5, 9, 2, 6, 5]) == 6 >>> second_largest([1, 2, 3, 3, 3]) == 2 >>> second_largest([1, 1, 1]) == None >>> second_largest([1, 3]) == 1 >>> second_largest([1]) == None >>> second_largest([]) == None","solution":"def second_largest(nums): Returns the second largest unique integer in the list. If there are less than 2 unique integers, return None. unique_nums = list(set(nums)) if len(unique_nums) < 2: return None unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"def min_operations_to_even_blocks(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Compute the minimum number of operations required to make all blocks have the same height for each test case. >>> min_operations_to_even_blocks(2, [(3, [5, 2, 1]), (4, [10, 10, 10, 10])]) [1, 0] >>> min_operations_to_even_blocks(1, [(1, [7])]) [0] >>> min_operations_to_even_blocks(1, [(2, [1, 1])]) [0] >>> min_operations_to_even_blocks(1, [(5, [3, 6, 9, 12, 15])]) [1] >>> min_operations_to_even_blocks(1, [(3, [4, 4, 4])]) [0] >>> min_operations_to_even_blocks(1, [(2, [1000000, 0])]) [1] >>> min_operations_to_even_blocks(1, [(3, [0, 0, 0])]) [0]","solution":"def min_operations_to_even_blocks(T, test_cases): def even_out_heights(heights): max_height = max(heights) min_height = min(heights) if max_height == min_height: return 0 return 1 results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] results.append(even_out_heights(heights)) return results"},{"question":"def fizzBuzzCustom(start: int, end: int): Prints 'fizz' for multiples of three, 'buzz' for multiples of five, and 'fizzbuzz' for multiples of both three and five for numbers in the inclusive range from \`start\` to \`end\`. For numbers that are not multiples of three or five, it prints the number itself. >>> fizzBuzzCustom(1, 5) 1 2 fizz 4 buzz","solution":"def fizzBuzzCustom(start, end): Prints 'fizz' for multiples of three, 'buzz' for multiples of five, and 'fizzbuzz' for multiples of both three and five for numbers in the inclusive range from \`start\` to \`end\`. For numbers that are not multiples of three or five, it prints the number itself. for num in range(start, end + 1): if num % 3 == 0 and num % 5 == 0: print(\\"fizzbuzz\\") elif num % 3 == 0: print(\\"fizz\\") elif num % 5 == 0: print(\\"buzz\\") else: print(num)"},{"question":"books = [ {'isbn': \\"978-3-16-148410-0\\", 'title': \\"To Kill a Mockingbird\\"}, {'isbn': \\"978-0-7432-7356-5\\", 'title': \\"The Da Vinci Code\\"} # Add more books as needed ] def find_book_by_isbn(isbn: str) -> str: Returns the title of the book for the given ISBN. If no book is found, returns \\"Book not available\\". >>> find_book_by_isbn(\\"978-3-16-148410-0\\") \\"To Kill a Mockingbird\\" >>> find_book_by_isbn(\\"978-0-7432-7356-5\\") \\"The Da Vinci Code\\" >>> find_book_by_isbn(\\"978-1-2345-6789-0\\") \\"Book not available\\" >>> find_book_by_isbn(\\"\\") \\"Book not available\\" >>> find_book_by_isbn(None) \\"Book not available\\"","solution":"books = [ {'isbn': \\"978-3-16-148410-0\\", 'title': \\"To Kill a Mockingbird\\"}, {'isbn': \\"978-0-7432-7356-5\\", 'title': \\"The Da Vinci Code\\"} # Add more books as needed ] def find_book_by_isbn(isbn): Returns the title of the book for the given ISBN. If no book is found, returns \\"Book not available\\". for book in books: if book['isbn'] == isbn: return book['title'] return \\"Book not available\\""},{"question":"def has_zero_sum_subset(arr): Determines if there exists a non-empty subset of the array such that the sum is zero. >>> has_zero_sum_subset([3, 1, -4, 2, 5]) == \\"YES\\" >>> has_zero_sum_subset([1, 2, 3]) == \\"NO\\" ... def process_test_cases(T, test_cases): Processes multiple test cases to determine if there exists a non-empty subset with a sum of zero. >>> T = 2 >>> test_cases = [(5, [3, 1, -4, 2, 5]), (3, [1, 2, 3])] >>> process_test_cases(T, test_cases) == [\\"YES\\", \\"NO\\"] ...","solution":"def has_zero_sum_subset(arr): Determines if there exists a non-empty subset of the array such that the sum is zero. n = len(arr) # Using a set to store the prefix sums prefix_sums = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] results.append(has_zero_sum_subset(A)) return results"},{"question":"from typing import List def unique_paths(m: int, n: int) -> int: Returns the number of unique paths in an m x n grid. >>> unique_paths(3, 3) 6 >>> unique_paths(2, 2) 2 >>> unique_paths(1, 1) 1 >>> unique_paths(4, 4) 20 >>> unique_paths(5, 5) 70 >>> unique_paths(3, 7) 28 >>> unique_paths(7, 3) 28 def main(input_values: List[str]) -> List[int]: Process the input values and return a list of results for each test case. >>> main([\\"2\\", \\"3 3\\", \\"2 2\\"]) [6, 2] >>> main([\\"3\\", \\"1 1\\", \\"4 4\\", \\"5 5\\"]) [1, 20, 70]","solution":"def unique_paths(m, n): Returns the number of unique paths in an m x n grid. dp = [[1]*n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] def main(input_values): Process the input values and return a list of results for each test case. results = [] index = 1 T = int(input_values[0]) for _ in range(T): m, n = map(int, input_values[index].split()) index += 1 results.append(unique_paths(m, n)) return results"},{"question":"def is_balanced(arr: List[int]) -> bool: Check if the array is balanced. An array is defined as a \\"balanced array\\" if the sum of the elements on the left half is equal to the sum of the elements on the right half. The array is divided into two halves at its midpoint. If the array has an odd length, the middle element is not considered in either half. >>> is_balanced([1, 2, 2, 1]) True >>> is_balanced([1, 2, 3, 2, 1]) True >>> is_balanced([1, 2, 3, 4]) False >>> is_balanced([1, 2, 3, 4, 5]) False >>> is_balanced([]) True >>> is_balanced([1]) True >>> is_balanced([1, 1]) True >>> is_balanced([1, 2]) False >>> is_balanced([10, 20, 30, 10, 20, 30]) True >>> is_balanced([10, 20, 30, 40, 50, 60]) False pass","solution":"def is_balanced(arr): Check if the array is balanced. n = len(arr) if n == 0: return True mid = n // 2 left_sum = sum(arr[:mid]) right_sum = sum(arr[mid + (n % 2):]) return left_sum == right_sum"},{"question":"from typing import List def sort_digits_descending(n: int) -> List[int]: Given an integer \`n\`, returns an array of its digits sorted in descending order. >>> sort_digits_descending(12345) [5, 4, 3, 2, 1] >>> sort_digits_descending(987650) [9, 8, 7, 6, 5, 0] >>> sort_digits_descending(102) [2, 1, 0] pass def test_sort_digits_descending_all_unique(): assert sort_digits_descending(12345) == [5, 4, 3, 2, 1] def test_sort_digits_descending_with_zero(): assert sort_digits_descending(987650) == [9, 8, 7, 6, 5, 0] def test_sort_digits_descending_mixed_digits(): assert sort_digits_descending(102) == [2, 1, 0] def test_sort_digits_descending_single_digit(): assert sort_digits_descending(5) == [5] assert sort_digits_descending(0) == [0] def test_sort_digits_descending_same_digits(): assert sort_digits_descending(111) == [1, 1, 1] def test_sort_digits_descending_large_number(): assert sort_digits_descending(987654321098765432) == [9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0]","solution":"from typing import List def sort_digits_descending(n: int) -> List[int]: Returns the digits of the integer \`n\` sorted in descending order. # Convert the integer to a string to easily iterate over the digits digits_str = str(n) # Convert each character to an integer and put in a list digits = [int(d) for d in digits_str] # Sort the digits in descending order digits.sort(reverse=True) return digits"},{"question":"def diamond(n): Generates a diamond pattern given an odd number n. If n is not an odd number, returns an empty string. >>> diamond(1) '*' >>> diamond(3) ' *n***n *' >>> diamond(5) ' *n ***n*****n ***n *' >>> diamond(7) ' *n ***n *****n*******n *****n ***n *' >>> diamond(4) '' >>> diamond(0) '' >>> diamond(-1) '' >>> diamond(-5) ''","solution":"def diamond(n): Generates a diamond pattern given an odd number n. If n is not an odd number, returns an empty string. if n <= 0 or n % 2 == 0: return \\"\\" lines = [] mid_point = n // 2 for i in range(n): if i <= mid_point: num_stars = 2 * i + 1 else: num_stars = 2 * (n - i) - 1 line = \\" \\" * ((n - num_stars) // 2) + \\"*\\" * num_stars lines.append(line) return \\"n\\".join(lines)"},{"question":"class InfinityTree: def __init__(self): self.parent = {1: None} self.depth = {1: 0} def add(self, u, v): Add a node v as a child of node u. Args: u (int): The parent node. v (int): The node to be added as a child of u. pass def find_lca(self, u, v): Find the lowest common ancestor (LCA) of nodes u and v. Args: u (int): The first node. v (int): The second node. Returns: int: The label of the LCA of nodes u and v. pass def infinity_tree_operations(operations): Perform a series of operations on the Infinity Tree and return the results of QUERY operations. Args: operations (list): A list of operations in the form of strings. Returns: list: Results of the QUERY operations. >>> infinity_tree_operations([ \\"ADD 1 2\\", \\"ADD 1 3\\", \\"ADD 2 4\\", \\"ADD 2 5\\", \\"QUERY 4 5\\", \\"QUERY 4 3\\", \\"QUERY 5 1\\" ]) [2, 1, 1] >>> infinity_tree_operations([\\"QUERY 1 1\\"]) [1] pass","solution":"class InfinityTree: def __init__(self): self.parent = {1: None} self.depth = {1: 0} def add(self, u, v): self.parent[v] = u self.depth[v] = self.depth[u] + 1 def find_lca(self, u, v): # Function to find the LCA # Bring both nodes to the same depth while self.depth[u] > self.depth[v]: u = self.parent[u] while self.depth[v] > self.depth[u]: v = self.parent[v] # Now move up together until we find the LCA while u != v: u = self.parent[u] v = self.parent[v] return u def infinity_tree_operations(operations): tree = InfinityTree() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"ADD\\": u = int(parts[1]) v = int(parts[2]) tree.add(u, v) elif parts[0] == \\"QUERY\\": u = int(parts[1]) v = int(parts[2]) lca = tree.find_lca(u, v) results.append(lca) return results"},{"question":"from typing import List def has_pair_with_sum(nums: List[int], target: int) -> bool: Determine if there are two distinct elements in the list that add up to the given target sum. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 5, 3, 8], 10) False >>> has_pair_with_sum([-3, 4, 3, 90], 0) True","solution":"def has_pair_with_sum(nums, target): Determine if there are two distinct elements in the list that add up to the given target sum. :param nums: List of integers :param target: Integer target sum :return: Boolean indicating if such a pair exists seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def longest_balanced_substring(s: str) -> str: Given a string \`s\` consisting of lower-case alphabets and digits, find the longest substring that contains equal numbers of alphabets and digits. If there are multiple substrings with the same length, return the leftmost one. If there is no such substring, return an empty string. >>> longest_balanced_substring(\\"a1b2c\\") \\"a1b2\\" >>> longest_balanced_substring(\\"abc123\\") \\"abc123\\" >>> longest_balanced_substring(\\"a123bc45\\") \\"a123bc\\" >>> longest_balanced_substring(\\"abcdef\\") \\"\\"","solution":"def longest_balanced_substring(s: str) -> str: Finds the longest substring with equal numbers of alphabets and digits. If multiple substrings have the same length, returns the leftmost one. If no such substring exists, returns an empty string. # Stores the first index where a certain balance appears balance_to_index = {0: -1} balance = 0 max_length = 0 start_index = 0 for i, char in enumerate(s): if char.isalpha(): balance += 1 else: balance -= 1 if balance in balance_to_index: current_length = i - balance_to_index[balance] if current_length > max_length: max_length = current_length start_index = balance_to_index[balance] + 1 else: balance_to_index[balance] = i return s[start_index:start_index + max_length]"},{"question":"def reduce_array(arr: List[int]) -> List[int]: Reduces the array by collapsing consecutive duplicates into one instance of each. Parameters: arr (list): A list of integers representing the array. Returns: list: A reduced list with consecutive duplicates removed. >>> reduce_array([2, 2, 1, 1, 1, 3, 3, 2, 2]) == [2, 1, 3, 2] >>> reduce_array([1, 1, 2, 2, 3]) == [1, 2, 3] >>> reduce_array([4, 4, 4, 5, 5, 1]) == [4, 5, 1] pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Processes multiple test cases for the array reduction. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains the number of elements in the array and the array itself. Returns: list: A list of reduced arrays for all test cases. >>> process_test_cases(2, [(5, [1, 1, 2, 2, 3]), (6, [4, 4, 4, 5, 5, 1])]) == [ ... [1, 2, 3], ... [4, 5, 1] ... ] >>> process_test_cases(1, [(3, [1, 1, 1])]) == [ ... [1] ... ] >>> process_test_cases(0, []) == [] pass","solution":"def reduce_array(arr): Reduces the array by collapsing consecutive duplicates into one instance of each. Parameters: arr (list): A list of integers representing the array. Returns: list: A reduced list with consecutive duplicates removed. if not arr: return [] reduced = [arr[0]] for i in range(1, len(arr)): if arr[i] != arr[i - 1]: reduced.append(arr[i]) return reduced def process_test_cases(T, test_cases): Processes multiple test cases for the array reduction. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains the number of elements in the array and the array itself. Returns: list: A list of reduced arrays for all test cases. results = [] for N, arr in test_cases: reduced = reduce_array(arr) results.append(reduced) return results"},{"question":"from typing import List, Union, Tuple def find_indices(nums: List[int], target: int) -> Union[Tuple[int, int], int]: Determines whether there is a pair of distinct elements in the array that sum up to the given target integer. If such a pair exists, returns the indices of the two numbers. If no such pair exists, returns -1. >>> find_indices([2, 7, 11, 15, 1], 9) (0, 1) >>> find_indices([1, 2, 3, 4], 8) -1 def test_example_case_1(): nums = [2, 7, 11, 15, 1] target = 9 result = find_indices(nums, target) expected = (0, 1) assert result == expected or result == (1, 0) def test_example_case_2(): nums = [1, 2, 3, 4] target = 8 result = find_indices(nums, target) assert result == -1 def test_no_pair_exists(): nums = [1, 3, 5, 7] target = 14 result = find_indices(nums, target) assert result == -1 def test_pair_at_beginning(): nums = [5, 2, 4, 9] target = 7 result = find_indices(nums, target) expected = (0, 1) assert result == expected or result == (1, 0) def test_pair_at_end(): nums = [3, 1, 7, 2] target = 9 result = find_indices(nums, target) expected = (2, 3) assert result == expected or result == (3, 2) def test_large_numbers(): nums = [1000000, 500000, 500000] target = 1000000 result = find_indices(nums, target) expected = (1, 2) assert result == expected or result == (2, 1)","solution":"from typing import List, Union, Tuple def find_indices(nums: List[int], target: int) -> Union[Tuple[int, int], int]: Determines whether there is a pair of distinct elements in the array that sum up to the given target integer. If such a pair exists, returns the indices of the two numbers. If no such pair exists, returns -1. seen = {} for i, num in enumerate(nums): difference = target - num if difference in seen: return (seen[difference], i) seen[num] = i return -1"},{"question":"def subset_sum(nums: List[int], target: int) -> List[int]: Find if there exists a subset of elements in nums that sums up to target. If such a subset exists, return a list of indices of the subset elements; otherwise, return an empty list. >>> subset_sum([1, 2, 3, 7, 8], 10) [1, 3] >>> subset_sum([1, 2, 5, 6], 11) [1, 2, 3] >>> subset_sum([2, 4, 6], 9) []","solution":"def subset_sum(nums, target): Finds a subset of nums that sums up to target. If such a subset exists, returns a list of indices of the subset elements. Otherwise, returns an empty list. n = len(nums) dp = [[[False, []] for _ in range(target + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if j < nums[i-1]: dp[i][j] = dp[i-1][j] else: if dp[i-1][j][0]: dp[i][j] = dp[i-1][j] if dp[i-1][j-nums[i-1]][0]: dp[i][j] = [True, dp[i-1][j-nums[i-1]][1] + [i-1]] if dp[n][target][0]: return dp[n][target][1] else: return [] # Example usage: # nums = [1, 2, 3, 7, 8] # target = 10 # print(subset_sum(nums, target))"},{"question":"def longest_increasing_subsequence(arr: list[int]) -> int: Given an array of integers, find the length of the longest increasing subsequence (LIS). A subsequence is derived from another sequence by deleting some or none of the elements without changing the order of the remaining elements. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 # Your code goes here. def test_longest_increasing_subsequence(): arr1 = [10, 9, 2, 5, 3, 7, 101, 18] assert longest_increasing_subsequence(arr1) == 4 arr2 = [0, 1, 0, 3, 2, 3] assert longest_increasing_subsequence(arr2) == 4 arr3 = [7, 7, 7, 7, 7, 7, 7] assert longest_increasing_subsequence(arr3) == 1 arr4 = [3, 10, 2, 1, 20] assert longest_increasing_subsequence(arr4) == 3 arr5 = [50, 3, 10, 7, 40, 80] assert longest_increasing_subsequence(arr5) == 4 arr6 = [1, 2, 3, 4, 5] assert longest_increasing_subsequence(arr6) == 5 arr7 = [5, 4, 3, 2, 1] assert longest_increasing_subsequence(arr7) == 1 arr8 = [10, 9, 2, 5, 3, 4] assert longest_increasing_subsequence(arr8) == 3 arr9 = [] assert longest_increasing_subsequence(arr9) == 0","solution":"def longest_increasing_subsequence(arr: list[int]) -> int: if not arr: return 0 n = len(arr) # dp array to store the length of LIS ending at each index dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def rearrange_even_odd(arr: List[int]) -> List[int]: Rearranges the array so that all even numbers appear before all odd numbers, while maintaining the relative order of both even and odd numbers. >>> rearrange_even_odd([3, 1, 2, 4]) [2, 4, 3, 1] >>> rearrange_even_odd([1, 3, 5, 7]) [1, 3, 5, 7] >>> rearrange_even_odd([2, 4, 6, 8]) [2, 4, 6, 8] >>> rearrange_even_odd([]) []","solution":"def rearrange_even_odd(arr): Rearranges the array so that all even numbers appear before all odd numbers, while maintaining the relative order of both even and odd numbers. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def max_sum_pair(array: List[int]) -> List[int]: Finds a pair of elements in the array that produce the highest possible sum. >>> max_sum_pair([1, 4, 3, 2]) [4, 3] >>> max_sum_pair([10, 20, 30, 5]) [30, 20] >>> max_sum_pair([-1, -2, -3, -4]) [-1, -2] >>> max_sum_pair([-10, 100, -50, 70, 30]) [100, 70] >>> max_sum_pair([5, 5, 5, 5]) [5, 5] >>> max_sum_pair([2, 1]) [2, 1] >>> max_sum_pair(list(range(-1000, 1000))) [999, 998] >>> max_sum_pair([-1000, -1000, 1000]) [1000, -1000]","solution":"def max_sum_pair(array): Finds a pair of elements in the array that produce the highest possible sum. if len(array) < 2: raise ValueError(\\"Array must contain at least 2 elements\\") first_max = -float('inf') second_max = -float('inf') for num in array: if num > first_max: second_max = first_max first_max = num elif num > second_max: second_max = num return [first_max, second_max]"},{"question":"def calculate_averages(grades: dict) -> (dict, float): Calculate the average grade for each subject and the overall average grade for all subjects combined. >>> grades = { ... 'Math': [90, 85, 92], ... 'Science': [88, 79, 85], ... 'English': [85, 90, 88], ... 'History': [70, 75, 80], ... 'Art': [100, 95, 85] ... } >>> calculate_averages(grades) ({'Math': 89.0, 'Science': 84.0, 'English': 87.67, 'History': 75.0, 'Art': 93.33}, 85.8) pass import pytest def test_calculate_averages_basic(): grades = { 'Math': [90, 85, 92], 'Science': [88, 79, 85], 'English': [85, 90, 88], 'History': [70, 75, 80], 'Art': [100, 95, 85] } subject_averages, overall_average = calculate_averages(grades) assert subject_averages == {'Math': 89.0, 'Science': 84.0, 'English': 87.67, 'History': 75.0, 'Art': 93.33} assert overall_average == 85.8 def test_single_subject(): grades = {'Math': [95]} subject_averages, overall_average = calculate_averages(grades) assert subject_averages == {'Math': 95.0} assert overall_average == 95.0 def test_single_grade_per_subject(): grades = { 'Math': [100], 'Science': [90], 'English': [80], 'History': [70], 'Art': [60] } subject_averages, overall_average = calculate_averages(grades) assert subject_averages == {'Math': 100.0, 'Science': 90.0, 'English': 80.0, 'History': 70.0, 'Art': 60.0} assert overall_average == 80.0 def test_all_grades_same(): grades = { 'Math': [85, 85, 85], 'Science': [85, 85, 85], 'English': [85, 85, 85], 'History': [85, 85, 85], 'Art': [85, 85, 85] } subject_averages, overall_average = calculate_averages(grades) assert subject_averages == {'Math': 85.0, 'Science': 85.0, 'English': 85.0, 'History': 85.0, 'Art': 85.0} assert overall_average == 85.0 def test_various_grades(): grades = { 'Math': [90, 100, 95], 'Science': [80, 85, 90], 'English': [70, 75, 80], 'History': [60, 65, 70], 'Art': [50, 55, 60] } subject_averages, overall_average = calculate_averages(grades) assert subject_averages == {'Math': 95.0, 'Science': 85.0, 'English': 75.0, 'History': 65.0, 'Art': 55.0} assert overall_average == 75.0","solution":"def calculate_averages(grades): Calculate the average grade for each subject and the overall average grade for all subjects combined. Parameters: grades (dict): A dictionary where keys are subjects and values are lists of grades. Returns: tuple: A tuple containing: - subject_averages (dict): A dictionary with the average grade for each subject. - overall_average (float): The overall average grade for all subjects combined, rounded to two decimal places. subject_averages = {} total_sum = 0 total_count = 0 for subject, marks in grades.items(): avg = sum(marks) / len(marks) subject_averages[subject] = round(avg, 2) total_sum += sum(marks) total_count += len(marks) overall_average = round(total_sum / total_count, 2) return subject_averages, overall_average"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> str: Returns the longest common subsequence (LCS) of s1 and s2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") \\"ace\\" >>> longest_common_subsequence(\\"abcdef\\", \\"acbcf\\") \\"abcf\\" >>> longest_common_subsequence(\\"xyz\\", \\"xyz\\") \\"xyz\\" >>> longest_common_subsequence(\\"\\", \\"ace\\") \\"\\" >>> longest_common_subsequence(\\"abcde\\", \\"\\") \\"\\" >>> longest_common_subsequence(\\"\\", \\"\\") \\"\\" >>> longest_common_subsequence(\\"abc\\", \\"def\\") \\"\\" >>> longest_common_subsequence(\\"ghijkl\\", \\"mnopqr\\") \\"\\" >>> longest_common_subsequence(\\"aaaa\\", \\"aaaa\\") \\"aaaa\\" >>> longest_common_subsequence(\\"abcd\\", \\"abcd\\") \\"abcd\\" >>> longest_common_subsequence(\\"abcxyz\\", \\"axyzbc\\") in [\\"axyz\\", \\"bc\\"] >>> longest_common_subsequence(\\"abcdefg\\", \\"aceg\\") \\"aceg\\" >>> longest_common_subsequence(\\"axbycz\\", \\"abc\\") \\"abc\\" # Your code goes here","solution":"def longest_common_subsequence(s1, s2): Returns the longest common subsequence (LCS) of s1 and s2. n = len(s1) m = len(s2) # Create a DP table to store lengths of longest common subsequence. dp = [[0] * (m + 1) for _ in range(n + 1)] # Build the DP table for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct LCS from the DP table i, j = n, m lcs = [] while i > 0 and j > 0: if s1[i - 1] == s2[j - 1]: lcs.append(s1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 lcs.reverse() return ''.join(lcs) # Example usage print(longest_common_subsequence(\\"abcde\\", \\"ace\\")) # Output: \\"ace\\" print(longest_common_subsequence(\\"abcdef\\", \\"acbcf\\")) # Output: \\"abcf\\" print(longest_common_subsequence(\\"xyz\\", \\"xyz\\")) # Output: \\"xyz\\""},{"question":"def scheduleClasses(students): Generates a weekly schedule for each student based on their available hours and favorite subject. :param students: list of dicts, each with 'name', 'favoriteSubject', and 'availableHours' :return: list of dicts, each with 'name' and 'schedule' (list of scheduled subjects) Example: >>> students = [ ... {'name': 'Alice', 'favoriteSubject': 'Math', 'availableHours': 5}, ... {'name': 'Bob', 'favoriteSubject': 'Science', 'availableHours': 3}, ... {'name': 'Charlie', 'favoriteSubject': 'History', 'availableHours': 4} ... ] >>> scheduleClasses(students) [ {'name': 'Alice', 'schedule': ['Math', 'Math', 'General Studies', 'General Studies', 'General Studies']}, {'name': 'Bob', 'schedule': ['Science', 'Science', 'General Studies']}, {'name': 'Charlie', 'schedule': ['History', 'History', 'General Studies', 'General Studies']} ]","solution":"def scheduleClasses(students): Generates a weekly schedule for each student based on their available hours and favorite subject. :param students: list of dicts, each with 'name', 'favoriteSubject', and 'availableHours' :return: list of dicts, each with 'name' and 'schedule' (list of scheduled subjects) output = [] for student in students: name = student['name'] favorite_subject = student['favoriteSubject'] available_hours = student['availableHours'] # Create the schedule schedule = [favorite_subject] * 2 # Start with their favorite subject twice remaining_hours = available_hours - 2 # Fill the rest with \\"General Studies\\" if remaining_hours > 0: schedule.extend([\\"General Studies\\"] * remaining_hours) # Ensure the schedule has exactly 'available_hours' length schedule = schedule[:available_hours] output.append({ 'name': name, 'schedule': schedule }) return output"},{"question":"def remove_duplicates(nums: List[int]) -> int: Removes duplicates in a sorted list in-place and returns the new length of the array. Example 1: >>> nums = [1, 1, 2] >>> new_length = remove_duplicates(nums) >>> new_length 2 >>> nums[:new_length] [1, 2] Example 2: >>> nums = [0,0,1,1,1,2,2,3,3,4] >>> new_length = remove_duplicates(nums) >>> new_length 5 >>> nums[:new_length] [0, 1, 2, 3, 4] Example 3: >>> nums = [0,0,0,0,0] >>> new_length = remove_duplicates(nums) >>> new_length 1 >>> nums[:new_length] [0] :type nums: List[int] :rtype: int","solution":"def remove_duplicates(nums): Removes duplicates in a sorted list in-place and returns the new length of the array. :type nums: List[int] :rtype: int if not nums: return 0 write_index = 1 # Initialize the write index to the position where the next unique element will be written. for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"def generate_sequence(n): Generates a sequence of numbers where each number is the sum of the previous two numbers, starting from 1, with the first two numbers being 1 and 1. >>> generate_sequence(1) [1] >>> generate_sequence(2) [1, 1] >>> generate_sequence(5) [1, 1, 2, 3, 5] pass def sequence_for_test_cases(test_cases): Generate sequences for multiple test cases. Args: test_cases (list): A list of integers where each integer represents the number of terms in the sequence. Returns: list: A list of lists, where each list is the sequence for the corresponding test case. >>> sequence_for_test_cases([1]) [[1]] >>> sequence_for_test_cases([1, 2]) [[1], [1, 1]] >>> sequence_for_test_cases([5, 10]) [[1, 1, 2, 3, 5], [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]] pass","solution":"def generate_sequence(n): Generates a sequence of numbers where each number is the sum of the previous two numbers, starting from 1, with the first two numbers being 1 and 1. sequence = [] a, b = 1, 1 for i in range(n): sequence.append(a) a, b = b, a + b return sequence def sequence_for_test_cases(test_cases): Generate sequences for multiple test cases. Args: test_cases (list): A list of integers where each integer represents the number of terms in the sequence. Returns: list: A list of lists, where each list is the sequence for the corresponding test case. results = [] for n in test_cases: sequence = generate_sequence(n) results.append(sequence) return results"},{"question":"def sum_even_fibonacci(n: int) -> int: Returns the sum of all even Fibonacci numbers less than or equal to n. >>> sum_even_fibonacci(10) == 10 >>> sum_even_fibonacci(8) == 10 >>> sum_even_fibonacci(4000000) == 4613732 >>> sum_even_fibonacci(0) == 0 >>> sum_even_fibonacci(1) == 0 >>> sum_even_fibonacci(2) == 2 >>> sum_even_fibonacci(15) == 10","solution":"def sum_even_fibonacci(n): Returns the sum of all even Fibonacci numbers less than or equal to n. a, b = 1, 2 sum_even = 0 while a <= n: if a % 2 == 0: sum_even += a a, b = b, a + b return sum_even"},{"question":"def longest_arith_seq_length(array: List[int]) -> int: Return the length of the longest contiguous subarray that forms an arithmetic progression. >>> longest_arith_seq_length([3, 6, 9, 12, 15, 10, 20, 5, 15, 25]) == 5 >>> longest_arith_seq_length([1, 2, 4, 7, 11]) == 2 >>> longest_arith_seq_length([20, 15, 10, 5, 0, -5, -10]) == 7 >>> longest_arith_seq_length([1, 3, 1, 3, 1, 3]) == 2 >>> longest_arith_seq_length([]) == 0 >>> longest_arith_seq_length([1, 3]) == 2 >>> longest_arith_seq_length([10]) == 1 >>> longest_arith_seq_length([3, 6, 9, 12]) == 4 pass","solution":"def longest_arith_seq_length(array): if len(array) <= 1: return len(array) max_length = 1 current_length = 1 current_diff = None for i in range(1, len(array)): diff = array[i] - array[i - 1] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 2 # reset, including current pair max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def max_increasing_students(heights: List[int]) -> int: Find the maximum number of students whose heights are strictly increasing. >>> max_increasing_students([4, 3, 7, 5, 6, 2, 8, 10]) 5 >>> max_increasing_students([1, 2, 3, 4, 5]) 5 >>> max_increasing_students([5, 4, 3, 2, 1]) 1 >>> max_increasing_students([]) 0 >>> max_increasing_students([10]) 1 >>> max_increasing_students([5, 5, 5, 5]) 1 >>> max_increasing_students([1, 3, 2, 4, 3, 5]) 4 >>> max_increasing_students([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 pass","solution":"from typing import List import bisect def max_increasing_students(heights: List[int]) -> int: if not heights: return 0 dp = [] for height in heights: pos = bisect.bisect_left(dp, height) if pos < len(dp): dp[pos] = height else: dp.append(height) return len(dp)"},{"question":"def product_in_range(arr, queries): Compute the product of elements in a given range for multiple queries, and return the results modulo 10^9 + 7. >>> product_in_range([1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 24, 120] >>> product_in_range([10000] * 100000, [(1, 100000)]) [pow(10000, 100000, 10**9 + 7)] >>> product_in_range([1, 2, 3, 4, 5], [(1, 1)]) [1] >>> product_in_range([i+1 for i in range(10)], [(1, 10), (1, 5), (5, 10)]) [(1*2*3*4*5*6*7*8*9*10) % (10**9 + 7), (1*2*3*4*5) % (10**9 + 7), (5*6*7*8*9*10) % (10**9 + 7)] >>> product_in_range([2, 2, 2, 2, 2], [(1, 3), (2, 5)]) [8, 16]","solution":"def product_in_range(arr, queries): Compute the product of elements in a given range for multiple queries, and return the results modulo 10^9 + 7. MOD = 10**9 + 7 n = len(arr) # Precompute prefix products modulo MOD prefix_products = [1] * (n + 1) for i in range(1, n + 1): prefix_products[i] = (prefix_products[i-1] * arr[i-1]) % MOD results = [] for L, R in queries: product = (prefix_products[R] * pow(prefix_products[L-1], MOD-2, MOD)) % MOD results.append(product) return results # Example usage N = 5 Q = 3 arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] print(product_in_range(arr, queries)) # Output should be: [6, 24, 120]"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determine whether a list of integers can be partitioned into two equal subsets such that the sum of the elements in both subsets is equal. >>> can_partition([1, 5, 11, 5]) == True >>> can_partition([1, 2, 3, 5]) == False >>> can_partition([1]) == False >>> can_partition([10, 10]) == True >>> can_partition([3, 3, 3, 4, 5]) == True >>> can_partition([2]*100) == True >>> can_partition([1, 2, 5]) == False","solution":"from typing import List def can_partition(nums: List[int]) -> bool: Determine whether the list of integers can be partitioned into two subsets such that the sum of the elements in both subsets is equal. total_sum = sum(nums) # If total sum is odd, can't partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"from typing import List def fibonacci(n: int) -> int: Returns the nth Fibonacci number using an iterative approach. This function is optimized with O(n) time complexity. >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 def fibonacci_tree_heights(queries: List[int]) -> List[int]: Given a list of days, returns the heights of the Fibonacci Tree for those days. >>> fibonacci_tree_heights([1, 5, 10]) == [1, 5, 55] >>> fibonacci_tree_heights([1, 2, 3, 4, 5]) == [1, 1, 2, 3, 5] >>> fibonacci_tree_heights([50, 100]) == [12586269025, 354224848179261915075]","solution":"def fibonacci(n): Returns the nth Fibonacci number using an iterative approach. This function is optimized with O(n) time complexity. if n == 1 or n == 2: return 1 a, b = 1, 1 for _ in range(3, n+1): a, b = b, a + b return b def fibonacci_tree_heights(queries): Given a list of days, returns the heights of the Fibonacci Tree for those days. return [fibonacci(day) for day in queries]"},{"question":"def highest_valid_score(N: int, scores: List[int]) -> int: Return the highest valid score from the given list of scores. A valid score is a non-negative integer. If no valid scores are present, return -1. >>> highest_valid_score(5, [12, -5, 23, 10, -100]) == 23 >>> highest_valid_score(4, [-10, -20, -30, -40]) == -1 >>> highest_valid_score(6, [-50, 45, -12, 14, 0, -2]) == 45 >>> highest_valid_score(3, [5, 8, 3]) == 8 >>> highest_valid_score(2, [0, 0]) == 0 >>> highest_valid_score(1, [100]) == 100 >>> highest_valid_score(1, [-1]) == -1","solution":"def highest_valid_score(N, scores): Return the highest valid score from the given list of scores. A valid score is a non-negative integer. If no valid scores are present, return -1. valid_scores = [score for score in scores if score >= 0] if valid_scores: return max(valid_scores) return -1"},{"question":"def is_valid_parenthesis_sequence(s: str) -> str: Returns 'VALID' if the input string is a valid parenthesis sequence, otherwise returns 'INVALID'. >>> is_valid_parenthesis_sequence(\\"()()(()())\\") 'VALID' >>> is_valid_parenthesis_sequence(\\"(())\\") 'VALID' >>> is_valid_parenthesis_sequence(\\"\\") 'VALID' >>> is_valid_parenthesis_sequence(\\"(()\\") 'INVALID' >>> is_valid_parenthesis_sequence(\\")(\\") 'INVALID' >>> is_valid_parenthesis_sequence(\\"())\\") 'INVALID' >>> is_valid_parenthesis_sequence(\\"(\\") 'INVALID' >>> is_valid_parenthesis_sequence(\\")\\") 'INVALID'","solution":"def is_valid_parenthesis_sequence(s): Returns 'VALID' if the input string is a valid parenthesis sequence, otherwise returns 'INVALID'. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return 'INVALID' stack.pop() return 'VALID' if not stack else 'INVALID'"},{"question":"Python class MinHeap: def __init__(self): Initializes an empty heap. self.heap = [] def insert(self, value): Inserts an element into the heap. self.heap.append(value) self.heapify_up(len(self.heap) - 1) def get_min(self): Returns the smallest element in the heap without removing it. >>> heap = MinHeap() >>> heap.insert(3) >>> heap.insert(1) >>> heap.insert(5) >>> heap.get_min() 1 if not self.heap: return None return self.heap[0] def extract_min(self): Removes and returns the smallest element from the heap. >>> heap = MinHeap() >>> heap.insert(3) >>> heap.insert(1) >>> heap.insert(5) >>> heap.extract_min() 1 if len(self.heap) == 0: return None min_elem = self.heap[0] self.heap[0] = self.heap.pop() self.heapify_down(0) return min_elem def heapify_up(self, index): Ensures the tree satisfies the heap property after insertion. raise NotImplementedError(\\"To be implemented by the candidate\\") def heapify_down(self, index): Ensures the tree satisfies the heap property after removal. raise NotImplementedError(\\"To be implemented by the candidate\\") def test_min_heap(): heap = MinHeap() # Test insert and get_min heap.insert(3) heap.insert(1) heap.insert(5) assert heap.get_min() == 1 # Test extract_min assert heap.extract_min() == 1 assert heap.get_min() == 3 # Test after extracting min assert heap.extract_min() == 3 assert heap.get_min() == 5 # Test extract_min on last element assert heap.extract_min() == 5 assert heap.get_min() is None # Test extract_min on empty heap assert heap.extract_min() is None # Additional tests heap.insert(2) heap.insert(4) heap.insert(1) heap.insert(7) assert heap.get_min() == 1 assert heap.extract_min() == 1 assert heap.get_min() == 2 heap.insert(0) assert heap.get_min() == 0 assert heap.extract_min() == 0 assert heap.get_min() == 2","solution":"class MinHeap: def __init__(self): Initializes an empty heap self.heap = [] def insert(self, value): Inserts an element into the heap self.heap.append(value) self.heapify_up(len(self.heap) - 1) def get_min(self): Returns the smallest element in the heap without removing it if not self.heap: return None return self.heap[0] def extract_min(self): Removes and returns the smallest element from the heap if len(self.heap) == 0: return None min_elem = self.heap[0] if len(self.heap) == 1: self.heap.pop() else: self.heap[0] = self.heap.pop() self.heapify_down(0) return min_elem def heapify_up(self, index): Ensures the tree satisfies the heap property after insertion while index > 0: parent_index = (index - 1) // 2 if self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] index = parent_index else: break def heapify_down(self, index): Ensures the tree satisfies the heap property after removal size = len(self.heap) while index < size: left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < size and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < size and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] index = smallest else: break"},{"question":"def caesar_cipher(text: str, shift: int, encrypt: bool) -> str: Encrypt or decrypt a message using Caesar cipher. Parameters: - text: The input string consisting of alphabetic characters and spaces. - shift: The number of positions each letter should be shifted. - encrypt: Boolean flag; if True, encrypt the message; if False, decrypt it. Returns: - Encrypted or decrypted string based on the value of the encrypt flag. >>> caesar_cipher(\\"HELLO WORLD\\", 3, True) 'KHOOR ZRUOG' >>> caesar_cipher(\\"KHOOR ZRUOG\\", 3, False) 'HELLO WORLD' >>> caesar_cipher(\\"ZEBRA\\", 1, True) 'AFCSB' >>> caesar_cipher(\\"AFCSB\\", 1, False) 'ZEBRA'","solution":"def caesar_cipher(text: str, shift: int, encrypt: bool) -> str: Encrypt or decrypt a message using Caesar cipher. Parameters: - text: The input string consisting of alphabetic characters and spaces. - shift: The number of positions each letter should be shifted. - encrypt: Boolean flag; if True, encrypt the message; if False, decrypt it. Returns: - Encrypted or decrypted string based on the value of the encrypt flag. def shift_char(c, shift_amt): if c.isalpha(): start = ord('A') if c.isupper() else ord('a') return chr((ord(c) - start + shift_amt) % 26 + start) else: return c if not encrypt: shift = -shift return ''.join(shift_char(c, shift) for c in text)"},{"question":"def find_missing_numbers(nums: List[int], N: int) -> List[int]: Given a list of integers, find all the numbers from 1 to N that are missing in the list. Args: nums: List[int] - The list of numbers in the range 1 to N. N: int - The maximum number in the range. Returns: List[int] - The missing numbers from 1 to N. Examples: >>> find_missing_numbers([4, 3, 1], 5) [2, 5] >>> find_missing_numbers([2, 5, 1, 3], 6) [4, 6] >>> find_missing_numbers([1, 2, 3], 3) [] >>> find_missing_numbers([], 4) [1, 2, 3, 4] pass","solution":"def find_missing_numbers(nums, N): Returns a list of missing numbers from 1 to N. Parameters: nums (list of int): The list of numbers in the range 1 to N. N (int): The maximum number in the range. Returns: list of int: The missing numbers from 1 to N. all_numbers = set(range(1, N+1)) present_numbers = set(nums) missing_numbers = all_numbers - present_numbers return sorted(list(missing_numbers))"},{"question":"def maxDifference(arr: List[int]) -> int: Write a function named \`maxDifference\` that takes an array of integers as input and returns the maximum difference between two elements in the array where the larger element comes after the smaller one. >>> maxDifference([2, 3, 10, 6, 4, 8, 1]) 8 >>> maxDifference([7, 9, 5, 6, 3, 2]) 2 >>> maxDifference([1, 2, 6, 4]) 5 >>> maxDifference([5, 4, 3, 2, 1]) 0 Args: arr: List[int] - A list of integers to find the maximum difference in. Returns: int - The maximum difference between two elements where the larger element follows the smaller one, or 0 if no such pair exists. pass # Unit tests def test_maxDifference_with_various_cases(): assert maxDifference([2, 3, 10, 6, 4, 8, 1]) == 8 assert maxDifference([7, 9, 5, 6, 3, 2]) == 2 assert maxDifference([1, 2, 6, 4]) == 5 assert maxDifference([5, 4, 3, 2, 1]) == 0 assert maxDifference([-1, -2, -6, -4]) == 2 assert maxDifference([1, 2, 6, -4, 8]) == 12 assert maxDifference([5, 1, 5, 1, 5]) == 4 def test_maxDifference_with_only_two_elements(): assert maxDifference([1, 2]) == 1 assert maxDifference([2, 1]) == 0 def test_maxDifference_with_identical_elements(): assert maxDifference([5, 5, 5, 5, 5]) == 0 def test_maxDifference_with_mixed_positive_and_negative_elements(): assert maxDifference([1, -1, -2, -3, 10]) == 13 def test_maxDifference_with_single_increasing_sequence(): assert maxDifference([1, 2, 3, 4, 5]) == 4 def test_maxDifference_with_single_decreasing_sequence(): assert maxDifference([5, 4, 3, 2, 1]) == 0","solution":"from typing import List def maxDifference(arr: List[int]) -> int: if len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for num in arr[1:]: if num - min_element > max_diff: max_diff = num - min_element if num < min_element: min_element = num return max_diff"},{"question":"class TaskManager: Task management system to keep track of tasks assigned to different employees. Functionalities: 1. Add a new task. 2. Update the status of a task. 3. Retrieve tasks based on their status. 4. Remove a completed task. >>> manager = TaskManager() >>> manager.add_task(1, \\"Complete report\\", \\"high\\", \\"to do\\") >>> manager.add_task(2, \\"Test new software\\", \\"medium\\", \\"to do\\") >>> manager.add_task(3, \\"Prepare presentation\\", \\"high\\", \\"in progress\\") >>> manager.update_task_status(2, \\"done\\") >>> manager.get_tasks_by_status(\\"to do\\") [{'id': 1, 'description': 'Complete report', 'priority': 'high', 'status': 'to do'}] >>> manager.get_tasks_by_status(\\"done\\") [{'id': 2, 'description': 'Test new software', 'priority': 'medium', 'status': 'done'}] >>> manager.remove_task(2) VALID_PRIORITIES = [\\"low\\", \\"medium\\", \\"high\\"] VALID_STATUSES = [\\"to do\\", \\"in progress\\", \\"done\\"] def __init__(self): self.tasks = {} def add_task(self, task_id, description, priority, status): pass def update_task_status(self, task_id, new_status): pass def get_tasks_by_status(self, status): pass def remove_task(self, task_id): pass","solution":"class TaskManager: VALID_PRIORITIES = [\\"low\\", \\"medium\\", \\"high\\"] VALID_STATUSES = [\\"to do\\", \\"in progress\\", \\"done\\"] def __init__(self): self.tasks = {} def add_task(self, task_id, description, priority, status): if priority not in self.VALID_PRIORITIES: raise ValueError(f\\"Invalid priority level: {priority}\\") if status not in self.VALID_STATUSES: raise ValueError(f\\"Invalid status: {status}\\") if task_id in self.tasks: raise ValueError(f\\"Task ID {task_id} already exists\\") self.tasks[task_id] = { \\"description\\": description, \\"priority\\": priority, \\"status\\": status } def update_task_status(self, task_id, new_status): if new_status not in self.VALID_STATUSES: raise ValueError(f\\"Invalid status: {new_status}\\") if task_id not in self.tasks: raise KeyError(f\\"Task ID {task_id} does not exist\\") self.tasks[task_id][\\"status\\"] = new_status def get_tasks_by_status(self, status): if status not in self.VALID_STATUSES: raise ValueError(f\\"Invalid status: {status}\\") return [ {\\"id\\": task_id, \\"description\\": task[\\"description\\"], \\"priority\\": task[\\"priority\\"], \\"status\\": task[\\"status\\"] } for task_id, task in self.tasks.items() if task[\\"status\\"] == status ] def remove_task(self, task_id): if task_id not in self.tasks: raise KeyError(f\\"Task ID {task_id} does not exist\\") if self.tasks[task_id][\\"status\\"] != \\"done\\": raise ValueError(f\\"Can only remove tasks that are 'done'\\") del self.tasks[task_id]"},{"question":"def maximize_deliveries(packages: List[int], capacity: int) -> int: Returns the maximum number of packages that can be delivered without exceeding the truck's capacity. >>> maximize_deliveries([2, 3, 4, 5], 5) 2 >>> maximize_deliveries([1, 2, 3, 4], 7) 3 >>> maximize_deliveries([9, 8, 7], 5) 0 >>> maximize_deliveries([], 10) 0","solution":"def maximize_deliveries(packages, capacity): Returns the maximum number of packages that can be delivered without exceeding the given capacity. Parameters: packages (list of int): List of weights of the packages. capacity (int): Maximum capacity of the delivery truck. Returns: int: Maximum number of packages deliverable. packages.sort() # Sort packages in ascending order of weights total_weight = 0 count = 0 for weight in packages: if total_weight + weight <= capacity: total_weight += weight count += 1 else: break # truck's capacity exceeded return count"},{"question":"from typing import List def shortestPath(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1), avoiding obstacles. >>> grid = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 1], ... [0, 0, 0, 0, 0] ... ] >>> shortestPath(grid) 8 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> shortestPath(grid) -1 ...","solution":"from collections import deque from typing import List def shortestPath(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n, m = len(grid), len(grid[0]) directions = [(0,1), (1,0), (0,-1), (-1,0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def isBalancedString(s: str) -> bool: Returns True if the string has an equal number of 'a' and 'b' characters, False otherwise. Examples: >>> isBalancedString(\\"aabbab\\") True >>> isBalancedString(\\"abcbaa\\") False >>> isBalancedString(\\"bbbaaa\\") True >>> isBalancedString(\\"aaaabbbb\\") True >>> isBalancedString(\\"ab\\") True >>> isBalancedString(\\"\\") True","solution":"def isBalancedString(s: str) -> bool: Returns True if the string has an equal number of 'a' and 'b' characters, False otherwise. return s.count('a') == s.count('b')"},{"question":"def count_visible_buildings(heights: List[int]) -> int: Returns the number of buildings visible to the observer standing to the left. >>> count_visible_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([5, 4, 3, 2, 1]) 1","solution":"def count_visible_buildings(heights): Returns the number of buildings visible to the observer standing to the left. if not heights: return 0 max_height = heights[0] count = 1 # The first building is always visible for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"import math from collections import defaultdict, deque def sum_of_sizes_of_connected_components(n, toy_ids): Determine the sum of the sizes of all connected components in the graph formed by toys with IDs. Two nodes belong to the same connected component if there is a path of edges between them, and an undirected edge exists between two nodes if the absolute difference between their IDs is a perfect square. Args: n (int): The number of toys. toy_ids (List[int]): The list of unique toy IDs. Returns: int: The sum of the sizes of all connected components. Example: >>> sum_of_sizes_of_connected_components(5, [1, 4, 9, 16, 23]) 5 >>> sum_of_sizes_of_connected_components(3, [1, 2, 3]) 3","solution":"import math from collections import defaultdict, deque def is_perfect_square(x): return int(math.isqrt(x)) ** 2 == x def sum_of_sizes_of_connected_components(n, toy_ids): def bfs(node): queue = deque([node]) visited[node] = True size = 0 while queue: current = queue.popleft() size += 1 for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return size graph = defaultdict(list) toy_ids = sorted(toy_ids) for i in range(n): for j in range(i + 1, n): if is_perfect_square(abs(toy_ids[j] - toy_ids[i])): graph[toy_ids[i]].append(toy_ids[j]) graph[toy_ids[j]].append(toy_ids[i]) visited = {toy_id: False for toy_id in toy_ids} total_size = 0 for toy_id in toy_ids: if not visited[toy_id]: total_size += bfs(toy_id) return total_size"},{"question":"def max_clear_view(heights) -> int: Returns the index of the building that has the maximum clear view to the right. Arguments: heights -- list of integers representing the heights of buildings Examples: >>> max_clear_view([3, 2, 4, 2, 1]) 2 >>> max_clear_view([5, 3, 4, 4, 2]) 0 >>> max_clear_view([1, 1, 1, 1, 1]) 4 >>> max_clear_view([7, 1, 2, 4, 6, 5]) 0 >>> max_clear_view([10]) 0","solution":"def max_clear_view(heights): Returns the index of the building that has the maximum clear view to the right. max_index = len(heights) - 1 max_height = heights[-1] for i in range(len(heights) - 2, -1, -1): if heights[i] > max_height: max_index = i max_height = heights[i] return max_index"},{"question":"from typing import List, Tuple def min_travel_time(roads: List[Tuple[int, int, int]], start: int, target: int) -> int: Return the minimum travel time from start city to target city. If no path exists, return -1. >>> min_travel_time([(1, 2, 5), (2, 3, 10), (1, 3, 15)], 1, 3) 15 >>> min_travel_time([(1, 2, 5), (2, 3, 10), (1, 4, 5), (1, 3, 15), (4, 3, 5)], 1, 3) 10 >>> min_travel_time([(1, 2, 5), (2, 3, 10), (1, 3, 15)], 1, 4) -1 >>> min_travel_time([(1, 2, 5), (2, 3, 10), (1, 3, 15)], 1, 1) 0 >>> min_travel_time([(1, 2, 5), (2, 3, 10), (3, 4, 7)], 1, 5) -1","solution":"import heapq from collections import defaultdict def min_travel_time(roads, start, target): Returns the minimum travel time from start city to target city. If no path exists, returns -1. if start == target: return 0 # Construct the graph graph = defaultdict(list) for city1, city2, travel_time in roads: graph[city1].append((travel_time, city2)) graph[city2].append((travel_time, city1)) # Priority queue to get the minimum travel time pq = [(0, start)] visited = set() while pq: current_time, current_city = heapq.heappop(pq) if current_city in visited: continue visited.add(current_city) if current_city == target: return current_time for time, neighbor in graph[current_city]: if neighbor not in visited: heapq.heappush(pq, (current_time + time, neighbor)) return -1"},{"question":"def diagonal_sum(matrix: List[List[int]]) -> int: Calculate the sum of the primary diagonal elements of a square matrix. Args: matrix (list of list of int): A 2D list representing the square matrix. Returns: int: Sum of the primary diagonal elements. Examples: >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> diagonal_sum([[5, 4, 3], [2, 1, 0], [9, 8, 7]]) 13 >>> diagonal_sum([[3]]) 3","solution":"def diagonal_sum(matrix): Calculate the sum of the primary diagonal elements of a square matrix. Args: matrix (list of list of int): A 2D list representing the square matrix. Returns: int: Sum of the primary diagonal elements. n = len(matrix) return sum(matrix[i][i] for i in range(n))"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths in a m x n grid from top-left to bottom-right corner. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28","solution":"def unique_paths(m, n): Returns the number of unique paths in a m x n grid from top-left to bottom-right corner # Create a 2D array \`dp\` with \`m\` rows and \`n\` columns initialized to 1 dp = [[1] * n for _ in range(m)] # Start filling the dp array from the cell at (1, 1) for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return the value in the bottom-right cell return dp[m-1][n-1]"},{"question":"def length_of_longest_substring(s: str) -> int: Finds the length of the longest substring without repeating characters in an input string. Parameters: s (str): Input string Returns: int: Length of the longest substring without repeating characters Examples: >>> length_of_longest_substring('abcabcbb') 3 >>> length_of_longest_substring('bbbbb') 1 >>> length_of_longest_substring('pwwkew') 3 pass from solution import length_of_longest_substring def test_example_cases(): assert length_of_longest_substring('abcabcbb') == 3 assert length_of_longest_substring('bbbbb') == 1 assert length_of_longest_substring('pwwkew') == 3 def test_empty_string(): assert length_of_longest_substring('') == 0 def test_single_character_string(): assert length_of_longest_substring('a') == 1 def test_same_characters(): assert length_of_longest_substring('aaaaa') == 1 def test_no_repeats(): assert length_of_longest_substring('abcdefg') == 7 def test_substring_at_end(): assert length_of_longest_substring('aabbccddeeffg') == 2 def test_mixed_string(): assert length_of_longest_substring('dvdf') == 3 def test_repeating_patterns(): assert length_of_longest_substring('abacababc') == 3 def test_long_input(): assert length_of_longest_substring('a' * 1000) == 1 assert length_of_longest_substring(''.join(chr(i) for i in range(128))) == 128","solution":"def length_of_longest_substring(s: str) -> int: Finds the length of the longest substring without repeating characters in an input string. Parameters: s (str): Input string Returns: int: Length of the longest substring without repeating characters char_index_map = {} left = 0 longest = 0 for right, char in enumerate(s): if char in char_index_map and char_index_map[char] >= left: left = char_index_map[char] + 1 char_index_map[char] = right longest = max(longest, right - left + 1) return longest"},{"question":"def min_operations_to_consecutive_evens(n: int) -> int: Returns the minimum number of operations needed to convert the array to consecutive even numbers starting from 2. Param n: Length of the array Returns: Minimum number of operations >>> min_operations_to_consecutive_evens(4) 8 >>> min_operations_to_consecutive_evens(3) 6 >>> min_operations_to_consecutive_evens(1) 2 >>> min_operations_to_consecutive_evens(10) 20 >>> min_operations_to_consecutive_evens(10**4) 20000","solution":"def min_operations_to_consecutive_evens(n): Returns the minimum number of operations needed to convert the array to consecutive even numbers starting from 2. Param n: Length of the array Returns: Minimum number of operations return 2 * n"},{"question":"def utc_to_local(utc_time, city): Converts a time in UTC to local time for a given city. :param utc_time: str, time in UTC in the format \\"HH:MM\\" :param city: str, name of the city :return: str, converted local time in the format \\"HH:MM\\" or None if city is not supported >>> utc_to_local(\\"15:30\\", \\"New York\\") \\"10:30\\" >>> utc_to_local(\\"08:00\\", \\"Sydney\\") \\"19:00\\" >>> utc_to_local(\\"13:15\\", \\"London\\") \\"13:15\\" >>> utc_to_local(\\"19:45\\", \\"Tokyo\\") \\"04:45\\" >>> utc_to_local(\\"22:00\\", \\"Mumbai\\") None","solution":"def utc_to_local(utc_time, city): Converts a time in UTC to local time for a given city. :param utc_time: str, time in UTC in the format \\"HH:MM\\" :param city: str, name of the city :return: str, converted local time in the format \\"HH:MM\\" or None if city is not supported time_offsets = { \\"New York\\": -5, \\"London\\": 0, \\"Paris\\": +1, \\"Tokyo\\": +9, \\"Sydney\\": +11 } if city not in time_offsets: return None hours, minutes = map(int, utc_time.split(':')) local_hours = (hours + time_offsets[city]) % 24 return f\\"{local_hours:02}:{minutes:02}\\""},{"question":"def circular_left_shift(arr, k): Performs circular left shift of the array \`k\` times. >>> circular_left_shift([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] >>> circular_left_shift([10, 20, 30, 40], 4) == [10, 20, 30, 40] >>> circular_left_shift([1, 2, 3], 10) == [2, 3, 1] def process_test_cases(test_cases): Process multiple test cases for circular left shift operations. >>> test_cases = [ ... {'n': 5, 'k': 2, 'array': [1, 2, 3, 4, 5]}, ... {'n': 4, 'k': 4, 'array': [10, 20, 30, 40]}, ... {'n': 3, 'k': 10, 'array': [1, 2, 3]}, ... ] >>> expected_results = [ ... \\"3 4 5 1 2\\", ... \\"10 20 30 40\\", ... \\"2 3 1\\", ... ] >>> process_test_cases(test_cases) == expected_results","solution":"def circular_left_shift(arr, k): Performs circular left shift of the array \`k\` times. n = len(arr) k = k % n # Normalize k in case it's greater than n return arr[k:] + arr[:k] def process_test_cases(test_cases): Process multiple test cases for circular left shift operations. results = [] for case in test_cases: n, k, array = case['n'], case['k'], case['array'] shifted_array = circular_left_shift(array, k) results.append(\\" \\".join(map(str, shifted_array))) return results"},{"question":"def format_duration(duration_sec: int) -> str: Convert a given time duration in seconds into a formatted string representing days, hours, minutes, and seconds. >>> format_duration(93784) \\"1 days, 2 hours, 3 minutes, and 4 seconds\\" >>> format_duration(75) \\"0 days, 0 hours, 1 minutes, and 15 seconds\\" >>> format_duration(900000) \\"10 days, 10 hours, 0 minutes, and 0 seconds\\"","solution":"def format_duration(duration_sec): Converts a duration from seconds into a formatted string of 'DD days, HH hours, MM minutes, and SS seconds'. Parameters: duration_sec (int): Duration in seconds (must be non-negative). Returns: str: Formatted time duration. days = duration_sec // (24 * 3600) duration_sec %= (24 * 3600) hours = duration_sec // 3600 duration_sec %= 3600 minutes = duration_sec // 60 seconds = duration_sec % 60 return f\\"{days} days, {hours} hours, {minutes} minutes, and {seconds} seconds\\""},{"question":"def evaluate_rpn(expression: list) -> int: Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression. Division should truncate towards zero. If the input is invalid, raise a ValueError with the message \\"Invalid RPN expression\\". >>> evaluate_rpn([\\"2\\", \\"3\\", \\"+\\"]) 5 >>> evaluate_rpn([\\"4\\", \\"3\\", \\"-\\"]) 1 >>> evaluate_rpn([\\"2\\", \\"3\\", \\"*\\"]) 6 >>> evaluate_rpn([\\"8\\", \\"3\\", \\"/\\"]) 2 >>> evaluate_rpn([\\"7\\", \\"-3\\", \\"/\\"]) -2 >>> evaluate_rpn([\\"4\\", \\"2\\", \\"/\\", \\"6\\", \\"3\\", \\"-\\"]) Traceback (most recent call last): ... ValueError: Invalid RPN expression pass # Test cases import pytest def test_evaluate_rpn_addition(): assert evaluate_rpn([\\"2\\", \\"3\\", \\"+\\"]) == 5 def test_evaluate_rpn_subtraction(): assert evaluate_rpn([\\"4\\", \\"3\\", \\"-\\"]) == 1 def test_evaluate_rpn_multiplication(): assert evaluate_rpn([\\"2\\", \\"3\\", \\"*\\"]) == 6 def test_evaluate_rpn_integer_division_positive(): assert evaluate_rpn([\\"8\\", \\"3\\", \\"/\\"]) == 2 def test_evaluate_rpn_integer_division_negative(): assert evaluate_rpn([\\"7\\", \\"-3\\", \\"/\\"]) == -2 def test_evaluate_rpn_complex_expression(): with pytest.raises(ValueError, match=\\"Invalid RPN expression\\"): evaluate_rpn([\\"4\\", \\"2\\", \\"/\\", \\"6\\", \\"3\\", \\"-\\"]) def test_evaluate_rpn_extra_operators(): with pytest.raises(ValueError, match=\\"Invalid RPN expression\\"): evaluate_rpn([\\"4\\", \\"2\\", \\"+\\", \\"+\\"]) def test_evaluate_rpn_not_enough_operators(): with pytest.raises(ValueError, match=\\"Invalid RPN expression\\"): evaluate_rpn([\\"4\\", \\"+\\"]) def test_evaluate_rpn_invalid_operator(): with pytest.raises(ValueError, match=\\"Invalid RPN expression\\"): evaluate_rpn([\\"4\\", \\"2\\", \\"%\\"]) def test_evaluate_rpn_single_number(): assert evaluate_rpn([\\"42\\"]) == 42 def test_evaluate_rpn_multiple_operations(): assert evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) == 9 assert evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) == 6","solution":"def evaluate_rpn(expression: list) -> int: Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression. Division should truncate towards zero. If the input is invalid, raise a ValueError with the message \\"Invalid RPN expression\\". stack = [] for token in expression: if token.lstrip('-').isdigit(): # This will cover negative numbers as well stack.append(int(token)) else: if len(stack) < 2: raise ValueError(\\"Invalid RPN expression\\") b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # Ensure division truncates towards zero else: raise ValueError(\\"Invalid RPN expression\\") if len(stack) != 1: raise ValueError(\\"Invalid RPN expression\\") return stack[0]"},{"question":"import re positive_words = [\\"good\\", \\"great\\", \\"excellent\\", \\"awesome\\", \\"fantastic\\", \\"marvelous\\", \\"wonderful\\"] def highlight_positives(text: str) -> str: Wraps all occurrences of positive words in the text with <b></b> tags. >>> highlight_positives(\\"This is a good day. An excellent opportunity awaits.\\") \\"This is a <b>good</b> day. An <b>excellent</b> opportunity awaits.\\" >>> highlight_positives(\\"Everything is awesome! We are having a fantastic time.\\") \\"Everything is <b>awesome</b>! We are having a <b>fantastic</b> time.\\"","solution":"import re positive_words = [\\"good\\", \\"great\\", \\"excellent\\", \\"awesome\\", \\"fantastic\\", \\"marvelous\\", \\"wonderful\\"] def highlight_positives(text: str) -> str: Wraps all occurrences of positive words in the text with <b></b> tags. def bold_match(match): return f\\"<b>{match.group(0)}</b>\\" # Create pattern to match whole words from positive_words pattern = r'b(' + '|'.join(re.escape(word) for word in positive_words) + r')b' # Use re.sub with case insensitive flag to substitute matches with bold tags highlighted_text = re.sub(pattern, bold_match, text, flags=re.IGNORECASE) return highlighted_text"},{"question":"def balanced_average(ratings): Returns the average rating excluding the highest and lowest rating from the list. If the list has fewer than 3 ratings, returns 0.0. >>> balanced_average([4, 1, 5, 5, 1, 3, 4]) 3.4 >>> balanced_average([4, 2]) 0.0 >>> balanced_average([4, 3, 5, 1, 2]) 3.0 >>> balanced_average([1, 2, 3, 4, 5, 6, 7]) 4.0 >>> balanced_average([]) 0.0","solution":"def balanced_average(ratings): Returns the average rating excluding the highest and lowest rating from the list. If the list has fewer than 3 ratings, returns 0.0. if len(ratings) < 3: return 0.0 ratings_copy = sorted(ratings) ratings_copy.pop(0) # Remove the lowest rating ratings_copy.pop(-1) # Remove the highest rating if len(ratings_copy) == 0: return 0.0 return sum(ratings_copy) / len(ratings_copy)"},{"question":"from typing import List def max_consecutive_timestamps(timestamps: List[int], n: int) -> int: Find the maximum number of consecutive timestamps where the differences between consecutive timestamps are less than or equal to n seconds. >>> max_consecutive_timestamps([10, 20, 30, 40, 70, 80], 15) 4 >>> max_consecutive_timestamps([10, 100, 200, 300], 50) 1 >>> max_consecutive_timestamps([], 30) 0 >>> max_consecutive_timestamps([0, 100, 200, 300, 400, 500], 10) 1 >>> max_consecutive_timestamps([0, 5, 10, 15, 20, 25, 30], 5) 7 >>> max_consecutive_timestamps([0, 10, 20, 4000, 4010, 4020], 15) 3","solution":"def max_consecutive_timestamps(timestamps, n): if not timestamps: return 0 max_count = 1 current_count = 1 for i in range(1, len(timestamps)): if timestamps[i] - timestamps[i-1] <= n: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max_count"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string s is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): Input string to check Returns: bool: True if s is a palindrome, False otherwise >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False","solution":"import re def is_palindrome(s): Determines if the given string s is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): Input string to check Returns: bool: True if s is a palindrome, False otherwise # Remove all non-alphanumeric characters and convert to lowercase filtered_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the filtered string reads the same forwards and backwards return filtered_s == filtered_s[::-1]"},{"question":"def sortHeights(heights): Sort the heights but maintain the position of trees (-1). Parameters: heights (List[int]): An array of integers containing heights and trees (-1). Returns: List[int]: A sorted list of heights maintaining tree positions. Examples: >>> sortHeights([-1, 150, 190, 170, -1, -1, 160, 180]) [-1, 150, 160, 170, -1, -1, 180, 190] >>> sortHeights([120, 180, -1, 160, -1, 150, 130]) [120, 130, -1, 150, -1, 160, 180] >>> sortHeights([-1, -1, -1, -1, -1]) [-1, -1, -1, -1, -1] >>> sortHeights([160, 140, 170, 150]) [140, 150, 160, 170]","solution":"def sortHeights(heights): Sorts the heights but maintains the position of trees (-1). # Extract all heights that are not -1 only_heights = [height for height in heights if height != -1] # Sort the extracted heights only_heights.sort() # Create an iterator from the sorted heights height_iter = iter(only_heights) # Replace the non-tree positions in the original list with sorted heights sorted_heights = [next(height_iter) if height != -1 else -1 for height in heights] return sorted_heights"},{"question":"def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. >>> sum_of_primes(10) 17 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 2 >>> sum_of_primes(5) 10 >>> sum_of_primes(20) 77 >>> sum_of_primes(1000) 76127 >>> sum_of_primes(0) 0","solution":"def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for i in range(2, int(n**0.5) + 1): if sieve[i]: for j in range(i*i, n + 1, i): sieve[j] = False return sum(i for i in range(2, n + 1) if sieve[i])"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([10, 20, 30, 40, 50, 60]) 6 >>> longest_increasing_subsequence([1, 3, 5, 4, 7]) 4 >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([-10, -5, 0, 5, 10]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given list. if not arr: return 0 n = len(arr) lis = [1] * n # Initialize LIS values for all indexes # Compute optimized LIS values in a bottom-up manner for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis[] return max(lis)"},{"question":"from typing import List def can_achieve_target_sum(tickets: List[str], target_sum: int) -> bool: Given a list of lottery tickets, each represented by a string of digits, and a target integer sum, determine if there is a way to pick a combination of these tickets such that the sum of the chosen tickets' digits equals the target sum. Args: tickets (List[str]): The list of lottery tickets represented as strings of digits. target_sum (int): The target sum integer. Returns: bool: True if there is a combination of tickets that meets the target sum, False otherwise. Example 1: >>> can_achieve_target_sum([\\"123\\", \\"456\\", \\"789\\"], 15) True Example 2: >>> can_achieve_target_sum([\\"111\\", \\"222\\", \\"333\\"], 10) False","solution":"from itertools import combinations def can_achieve_target_sum(tickets, target_sum): Determine if there is a combination of tickets such that the sum of their digits equals the target sum. Args: tickets (list of str): The list of lottery tickets represented as strings of digits. target_sum (int): The target sum integer. Returns: bool: True if there is a combination of tickets that meets the target sum, False otherwise. # Step 1: Calculate the sum of digits for each ticket ticket_sums = [sum(map(int, ticket)) for ticket in tickets] # Step 2: Check combinations of tickets' sums to see if any combination meets the target sum for r in range(1, len(tickets) + 1): for combination in combinations(ticket_sums, r): if sum(combination) == target_sum: return True return False"},{"question":"def sort_even_before_odd(lst: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list with the elements sorted in non-decreasing order. It ensures that all even numbers appear before all odd numbers, while maintaining their relative order from the original list. >>> sort_even_before_odd([8, 3, 2, 5, 4, 7]) [8, 2, 4, 3, 5, 7] >>> sort_even_before_odd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> sort_even_before_odd([9, 11, 5, 3, 2, 6]) [2, 6, 9, 11, 5, 3]","solution":"def sort_even_before_odd(lst): Returns a new list with sorted elements such that all even numbers come before all odd numbers, while maintaining their relative order from the original list. evens = [x for x in lst if x % 2 == 0] odds = [x for x in lst if x % 2 != 0] return evens + odds"},{"question":"def three_sum(nums: List[int]) -> List[List[int]]: Returns all unique triplets in the array which sum to zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([0, 1, 1]) == [] >>> three_sum([0, 0, 0]) == [[0, 0, 0]]","solution":"def three_sum(nums): Returns all unique triplets in the array which sum to zero. nums.sort() result = [] length = len(nums) for i in range(length - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, length - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def longest_str_chain(words): Returns the length of the longest string chain that can be formed with words from the given list. >>> longest_str_chain([\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"]) 4 >>> longest_str_chain([\\"abcd\\",\\"dbqca\\"]) 1 >>> longest_str_chain([\\"a\\"]) 1 >>> longest_str_chain([\\"x\\", \\"y\\", \\"xy\\", \\"yz\\", \\"xyz\\"]) 3 >>> longest_str_chain([\\"abc\\", \\"def\\", \\"ghi\\"]) 1 >>> longest_str_chain([\\"a\\"] * 1000) 1 pass","solution":"def longest_str_chain(words): Returns the length of the longest string chain that can be formed with words from the given list. words.sort(key=len) # Sort words by length longest_chain = {} max_length = 1 # At least each word can be a chain of length 1 for word in words: current_length = 1 # Start with the current word itself for i in range(len(word)): prev_word = word[:i] + word[i+1:] # Remove one character if prev_word in longest_chain: # Check if the predecessor exists in the chain current_length = max(current_length, longest_chain[prev_word] + 1) longest_chain[word] = current_length max_length = max(max_length, current_length) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isValidBST(root: TreeNode) -> bool: Determines if a binary tree is a valid Binary Search Tree (BST). >>> root = TreeNode(2, TreeNode(1), TreeNode(3)) >>> isValidBST(root) True >>> root = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6))) >>> isValidBST(root) False >>> root = TreeNode(10, TreeNode(5), TreeNode(15, TreeNode(6), TreeNode(20))) >>> isValidBST(root) False # Your implementation here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isValidBST(root: TreeNode) -> bool: def validate(node, low=float('-inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"def longest_increasing_subsequence_length(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. >>> longest_increasing_subsequence_length([5, 2, 8, 6, 3, 6]) 3 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence_length([3, 2]) 1 >>> longest_increasing_subsequence_length([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence_length([]) 0 >>> longest_increasing_subsequence_length([10]) 1 >>> longest_increasing_subsequence_length([10, 10, 10, 10]) 1 >>> longest_increasing_subsequence_length([1, 9, 2, 8, 3, 7, 4, 6, 5]) 5","solution":"def longest_increasing_subsequence_length(arr): Returns the length of the longest strictly increasing subsequence. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Write a function 'transpose_matrix' that takes a 2D matrix (a list of lists) as input and returns its transpose. The transpose of a matrix is obtained by swapping the rows and columns. For example, if matrix 'A' is of size 'm x n', its transpose 'A^T' will be of size 'n x m'. The function should handle any size of the input matrix, including edge cases such as an empty matrix. Examples: >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([]) [] pass # Unit Tests def test_transpose_square_matrix(): input_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] expected_output = [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert transpose_matrix(input_matrix) == expected_output def test_transpose_rectangular_matrix(): input_matrix = [[1, 2], [3, 4], [5, 6]] expected_output = [[1, 3, 5], [2, 4, 6]] assert transpose_matrix(input_matrix) == expected_output def test_transpose_single_element_matrix(): input_matrix = [[1]] expected_output = [[1]] assert transpose_matrix(input_matrix) == expected_output def test_transpose_empty_matrix(): input_matrix = [] expected_output = [] assert transpose_matrix(input_matrix) == expected_output def test_transpose_row_vector(): input_matrix = [[1, 2, 3, 4]] expected_output = [[1], [2], [3], [4]] assert transpose_matrix(input_matrix) == expected_output def test_transpose_column_vector(): input_matrix = [[1], [2], [3], [4]] expected_output = [[1, 2, 3, 4]] assert transpose_matrix(input_matrix) == expected_output","solution":"def transpose_matrix(matrix): Returns the transpose of the given 2D matrix. :param matrix: List[List[int]] - The input matrix to be transposed :return: List[List[int]] - The transposed matrix if not matrix: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [] for c in range(cols): new_row = [] for r in range(rows): new_row.append(matrix[r][c]) transposed.append(new_row) return transposed"},{"question":"def simplify_path(path: str) -> str: Simplifies a given filesystem path according to the described rules. Args: path (str): A string representing the filesystem path. Returns: str: The simplified canonical path. Examples: >>> simplify_path(\\"/home/\\") '/home' >>> simplify_path(\\"/../\\") '/' >>> simplify_path(\\"/home//foo/\\") '/home/foo' >>> simplify_path(\\"/a/./b/../../c/\\") '/c' from solution import simplify_path def test_simplify_path_with_trailing_slash(): assert simplify_path(\\"/home/\\") == \\"/home\\" def test_simplify_path_root_parent_reference(): assert simplify_path(\\"/../\\") == \\"/\\" def test_simplify_path_with_multiple_consecutive_slashes(): assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" def test_simplify_path_with_current_and_parent_directory(): assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" def test_simplify_path_root_directory(): assert simplify_path(\\"/\\") == \\"/\\" def test_simplify_path_complex(): assert simplify_path(\\"/a//b////c/d//././/..\\") == \\"/a/b/c\\" def test_simplify_path_with_only_double_dots(): assert simplify_path(\\"/../../../../../\\") == \\"/\\" def test_simplify_path_empty_directory(): assert simplify_path(\\"/home/user/projects/Code/.././../..\\") == \\"/home\\" def test_simplify_path_dot_end(): assert simplify_path(\\"/a/b/c/.\\") == \\"/a/b/c\\" def test_simplify_path_with_trailing_parent_reference(): assert simplify_path(\\"/a/b/..\\") == \\"/a\\"","solution":"def simplify_path(path: str) -> str: Simplifies a given filesystem path according to the described rules. Args: path (str): A string representing the filesystem path. Returns: str: The simplified canonical path. parts = path.split('/') stack = [] for part in parts: if part == '..': if stack: stack.pop() elif part == '.' or part == '': continue else: stack.append(part) return '/' + '/'.join(stack)"},{"question":"def lastIndexOf(text: str, substring: str) -> int: Returns the last index at which the substring is found in the text. If the substring is not found, returns -1. If the substring is empty, returns the length of the text. >>> lastIndexOf(\\"hello world, hello!\\", \\"hello\\") 13 >>> lastIndexOf(\\"hello world, hello!\\", \\"Hello\\") -1 >>> lastIndexOf(\\"abracadabra\\", \\"abra\\") 7 >>> lastIndexOf(\\"abracadabra\\", \\"xyz\\") -1 >>> lastIndexOf(\\"abracadabra\\", \\"\\") 11 >>> lastIndexOf(\\"hello world, hello!\\", \\"world\\") 6 >>> lastIndexOf(\\" \\", \\" \\") 2","solution":"def lastIndexOf(text, substring): Returns the last index at which the substring is found in the text. If the substring is not found, returns -1. If the substring is empty, returns the length of the text. if substring == \\"\\": return len(text) return text.rfind(substring)"},{"question":"def max_points(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Calculate the maximum points that can be collected in a grid for each test case. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): List of test cases where each test case is a tuple containing number of rows, number of columns, and the grid. Returns: List[int]: List of maximum points that can be collected for each test case. Example: >>> max_points(2, [(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (2, 2, [[5, 3], [2, 1]])]) [29, 9] pass def solve(input_data: str) -> str: Parse the input data and return the result for each test case. Parameters: input_data (str): Input data as a string with multiple lines. Returns: str: Output results for each test case as a string where each value is in a new line. Example: >>> input_data = \\"2n3 3n1 2 3n4 5 6n7 8 9n2 2n5 3n2 1\\" >>> solve(input_data) \\"29n9\\" pass","solution":"def max_points(T, test_cases): results = [] for case in test_cases: N, M, grid = case dp = [[0] * M for _ in range(N)] dp[0][0] = grid[0][0] # Initialize first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] results.append(dp[N-1][M-1]) return results # Helper function for handling input and output formats def solve(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, lines[index].strip().split(' ')) grid = [] for i in range(1, N + 1): grid.append(list(map(int, lines[index + i].strip().split(' ')))) test_cases.append((N, M, grid)) index += (N + 1) results = max_points(T, test_cases) return \\"n\\".join(map(str, results))"},{"question":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): The array of integers. k (int): Number of steps to rotate the array. Returns: list: The array after being rotated. Examples: >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3], 3) [1, 2, 3] from rotate_array import rotate_array def test_rotate_array_basic(): assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] def test_rotate_array_negative_values(): assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] def test_rotate_array_no_rotation(): assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] def test_rotate_array_full_rotation(): assert rotate_array([1, 2, 3], 3) == [1, 2, 3] def test_rotate_array_more_than_length(): assert rotate_array([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] def test_rotate_array_empty_array(): assert rotate_array([], 3) == [] def test_rotate_array_single_element(): assert rotate_array([1], 3) == [1]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): The array of integers. k (int): Number of steps to rotate the array. Returns: list: The array after being rotated. if not arr: return [] n = len(arr) k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"def process_queries(N: int, array: List[int], Q: int, queries: List[List[int]]) -> List[int]: Processes the list of queries on the given array. Parameters: - N: int, the length of the array. - array: list of int, the initial array. - Q: int, the number of queries. - queries: list of queries, where each query is a list where: - The first element is the type of the query (1 or 2). - If the type is 1, it's followed by L, R, and X - If the type is 2, it's followed by L and R Returns: - list of int, the results of the type 2 queries. pass from typing import List def test_process_queries_example(): N = 5 array = [1, 2, 3, 4, 5] Q = 4 queries = [ [2, 1, 3], [1, 2, 4, 1], [2, 2, 5], [2, 1, 5], ] expected_output = [6, 17, 18] assert process_queries(N, array, Q, queries) == expected_output def test_process_single_addition_query(): N = 3 array = [1, 1, 1] Q = 1 queries = [ [1, 1, 3, 2], ] expected_array = [3, 3, 3] process_queries(N, array, Q, queries) assert array == expected_array def test_process_mixed_queries(): N = 4 array = [1, 2, 3, 4] Q = 3 queries = [ [1, 1, 2, 1], # [2, 3, 3, 4] [2, 1, 3], # sum([2, 3, 3]) = 8 [1, 3, 4, 2], # [2, 3, 5, 6] ] results = process_queries(N, array, Q, queries) assert results == [8] def test_process_queries_no_operation(): N = 2 array = [10, 20] Q = 0 queries = [] results = process_queries(N, array, Q, queries) assert results == [] def test_process_queries_with_large_values(): N = 3 array = [10**5, 10**5, 10**5] Q = 2 queries = [ [1, 1, 3, 10**5], [2, 1, 3], ] results = process_queries(N, array, Q, queries) assert results == [3 * 2 * 10**5]","solution":"def process_queries(N, array, Q, queries): Processes the list of queries on the given array. Parameters: - N: int, the length of the array. - array: list of int, the initial array. - Q: int, the number of queries. - queries: list of queries, where each query is a list where: - The first element is the type of the query (1 or 2). - If the type is 1, it's followed by L, R, and X - If the type is 2, it's followed by L and R Returns: - list of int, the results of the type 2 queries. results = [] for query in queries: if query[0] == 1: _, L, R, X = query for i in range(L-1, R): array[i] += X elif query[0] == 2: _, L, R = query results.append(sum(array[L-1:R])) return results"},{"question":"def island_perimeter(grid): Calculate the perimeter of an island in a grid. :param grid: A list of lists representing the grid. :return: An integer representing the perimeter of the island. >>> island_perimeter([[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]) == 16 >>> island_perimeter([[1,0]]) == 4","solution":"def island_perimeter(grid): Calculate the perimeter of an island in a grid. :param grid: A list of lists representing the grid. :return: An integer representing the perimeter of the island. perimeter = 0 rows = len(grid) cols = len(grid[0]) for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Each cell is initially assumed to add 4 to the perimeter perimeter += 4 # Check adjacent cells to subtract shared sides if r > 0 and grid[r-1][c] == 1: # Top neighbor perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # Left neighbor perimeter -= 2 return perimeter"},{"question":"import itertools def is_palindrome(s): Helper function to check if a string is a palindrome. cleaned = ''.join(filter(str.isalnum, s)).lower() return cleaned == cleaned[::-1] def palindrome_permutations(S: str) -> None: Generate all possible permutations of the characters in S. For each permutation, check if it is a palindrome. Print each unique palindrome permutation on a new line. >>> palindrome_permutations(\\"a\\") a >>> palindrome_permutations(\\"aa\\") aa >>> palindrome_permutations(\\"ab\\") -1 >>> palindrome_permutations(\\"aab\\") aba aab >>> palindrome_permutations(\\"abc\\") -1","solution":"import itertools def is_palindrome(s): cleaned = ''.join(filter(str.isalnum, s)).lower() return cleaned == cleaned[::-1] def palindrome_permutations(S): permutations = set(itertools.permutations(S)) palindrome_perms = [\\"\\".join(p) for p in permutations if is_palindrome(\\"\\".join(p))] if not palindrome_perms: print(\\"-1\\") else: for perm in palindrome_perms: print(perm)"},{"question":"def unique_paths_with_obstacles(m: int, n: int, obstacles: List[Tuple[int, int]]) -> int: Calculate the number of unique paths in a grid from top-left to bottom-right avoiding obstacles. :param m: Number of rows. :param n: Number of columns. :param obstacles: List of tuples representing obstacle positions. :return: Number of unique paths. >>> unique_paths_with_obstacles(3, 3, [(1, 1)]) 2 >>> unique_paths_with_obstacles(3, 3, []) 6 >>> unique_paths_with_obstacles(3, 3, [(0, 0)]) 0 >>> unique_paths_with_obstacles(3, 3, [(2, 2)]) 0 >>> unique_paths_with_obstacles(3, 3, [(1, 1), (1, 2)]) 1 >>> unique_paths_with_obstacles(1, 5, []) 1 >>> unique_paths_with_obstacles(1, 5, [(0, 2)]) 0 >>> unique_paths_with_obstacles(5, 1, []) 1 >>> unique_paths_with_obstacles(5, 1, [(2, 0)]) 0","solution":"def unique_paths_with_obstacles(m, n, obstacles): Calculate the number of unique paths in a grid from top-left to bottom-right avoiding obstacles. :param m: Number of rows. :param n: Number of columns. :param obstacles: List of tuples representing obstacle positions. :return: Number of unique paths. # Create a grid initialized with 0's grid = [[0] * n for _ in range(m)] # Mark obstacles in the grid for i, j in obstacles: grid[i][j] = -1 # Marked as an obstacle # Start position is (0, 0) if grid[0][0] == -1: return 0 grid[0][0] = 1 # Compute paths for the first row for j in range(1, n): if grid[0][j] == 0: grid[0][j] = grid[0][j - 1] # Compute paths for the first column for i in range(1, m): if grid[i][0] == 0: grid[i][0] = grid[i - 1][0] # Compute paths for all other cells for i in range(1, m): for j in range(1, n): if grid[i][j] != -1: if grid[i - 1][j] != -1: grid[i][j] += grid[i - 1][j] if grid[i][j - 1] != -1: grid[i][j] += grid[i][j - 1] return grid[-1][-1] if grid[-1][-1] != -1 else 0"},{"question":"from typing import List def communicationGroups(ids: List[int]) -> int: Determine the number of distinct communication groups based on the unique set of digits in each ID. >>> communicationGroups([123, 321, 213, 456, 654, 789]) 3 >>> communicationGroups([123]) 1 >>> communicationGroups([123, 231, 312]) 1 >>> communicationGroups([111, 222, 333]) 3 >>> communicationGroups([111, 222, 333, 123, 231, 321]) 4 >>> communicationGroups([123456, 654321, 23456, 345612]) 2 >>> communicationGroups([12, 21, 13, 31, 14]) 3 >>> communicationGroups([1, 1, 1]) 1","solution":"def communicationGroups(ids): Returns the number of distinct communication groups based on the unique set of digits in each ID. unique_digit_sets = set() for id in ids: digit_set = frozenset(str(id)) # Convert ID to frozenset of its digits unique_digit_sets.add(digit_set) # Add the frozenset to the set of unique digit sets return len(unique_digit_sets)"},{"question":"from typing import List def has_rectangle(grid: List[List[int]]) -> bool: Determines if the grid contains any rectangles formed by four corners with value of 1. >>> has_rectangle([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == True >>> has_rectangle([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == False >>> has_rectangle([[1, 0, 1]]) == False >>> has_rectangle([[1], [0], [1]]) == False >>> has_rectangle([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == False >>> has_rectangle([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == True >>> has_rectangle([[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]]) == True","solution":"from typing import List def has_rectangle(grid: List[List[int]]) -> bool: Determines if the grid contains any rectangles formed by four corners with value of 1. Parameters: grid (List[List[int]]): The input grid of 0s and 1s. Returns: bool: True if at least one rectangle exists, otherwise False. if not grid or len(grid) < 2 or len(grid[0]) < 2: # Edge case: grid too small for any rectangle return False m, n = len(grid), len(grid[0]) # Check every combination of rows for r1 in range(m): for r2 in range(r1 + 1, m): # Check every combination of columns for c1 in range(n): if grid[r1][c1] == 1 and grid[r2][c1] == 1: for c2 in range(c1 + 1, n): if grid[r1][c2] == 1 and grid[r2][c2] == 1: return True return False"},{"question":"def rle_encode(input_string: str) -> str: Encodes the input string using Run-Length Encoding (RLE). Args: input_string (str): The string to be encoded. Returns: str: The RLE encoded string. Examples: >>> rle_encode(\\"AAABBBCCDAA\\") '3A3B2C1D2A' >>> rle_encode(\\"A\\") '1A' >>> rle_encode(\\"AABBAAC\\") '2A2B2A1C' >>> rle_encode(\\"\\") '' pass def rle_decode(encoded_string: str) -> str: Decodes the input string from Run-Length Encoding (RLE) format. Args: encoded_string (str): The RLE encoded string. Returns: str: The decoded original string. Examples: >>> rle_decode(\\"3A3B2C1D2A\\") 'AAABBBCCDAA' >>> rle_decode(\\"1A\\") 'A' >>> rle_decode(\\"2A2B2A1C\\") 'AABBAAC' >>> rle_decode(\\"\\") '' pass","solution":"def rle_encode(input_string: str) -> str: Encodes the input string using Run-Length Encoding (RLE). Args: input_string (str): The string to be encoded. Returns: str: The RLE encoded string. if not input_string: return \\"\\" encoded_string = \\"\\" count = 1 current_char = input_string[0] for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string += str(count) + current_char current_char = char count = 1 encoded_string += str(count) + current_char return encoded_string def rle_decode(encoded_string: str) -> str: Decodes the input string from Run-Length Encoding (RLE) format. Args: encoded_string (str): The RLE encoded string. Returns: str: The decoded original string. decoded_string = \\"\\" count = \\"\\" for char in encoded_string: if char.isdigit(): count += char else: decoded_string += char * int(count) count = \\"\\" return decoded_string"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. Parameters: s (str): The input string consisting of lowercase English letters. k (int): Maximum number of distinct characters allowed in a substring. Returns: int: Length of the longest substring with at most k distinct characters. Examples: >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aa\\", 1) 2 >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 2) 4 pass from solution import length_of_longest_substring_k_distinct def test_example_1(): assert length_of_longest_substring_k_distinct(\\"eceba\\", 2) == 3 def test_example_2(): assert length_of_longest_substring_k_distinct(\\"aa\\", 1) == 2 def test_example_3(): assert length_of_longest_substring_k_distinct(\\"aabbcc\\", 2) == 4 def test_empty_string(): assert length_of_longest_substring_k_distinct(\\"\\", 2) == 0 def test_k_zero(): assert length_of_longest_substring_k_distinct(\\"abc\\", 0) == 0 def test_single_character_string(): assert length_of_longest_substring_k_distinct(\\"aaaaa\\", 1) == 5 def test_no_restriction(): assert length_of_longest_substring_k_distinct(\\"abcdef\\", 6) == 6 def test_large_k(): assert length_of_longest_substring_k_distinct(\\"abcabcabc\\", 3) == 9 def test_non_maximal_use_of_k(): assert length_of_longest_substring_k_distinct(\\"abcabcabc\\", 5) == 9","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. if k == 0: return 0 n = len(s) left = 0 right = 0 max_length = 0 char_map = {} while right < n: char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def rotateMatrix(matrix): Rotates the given n x n matrix 90 degrees clockwise. Args: matrix (list of list of ints): The input n x n matrix. Returns: list of list of ints: The rotated matrix. Examples: >>> rotateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]]","solution":"def rotateMatrix(matrix): Rotates the given n x n matrix 90 degrees clockwise. Args: matrix (list of list of ints): The input n x n matrix. Returns: list of list of ints: The rotated matrix. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"def max_good_houses(n: int, k: int, houses: str) -> int: Returns the maximum number of houses that can be in good condition after repairing at most k consecutive houses. >>> max_good_houses(5, 2, 'GBGBG') 4 >>> max_good_houses(6, 3, 'BBBGBG') 5 from solution import max_good_houses def test_example_1(): assert max_good_houses(5, 2, 'GBGBG') == 4 def test_example_2(): assert max_good_houses(6, 3, 'BBBGBG') == 5 def test_all_good_houses(): assert max_good_houses(5, 2, 'GGGGG') == 5 def test_all_bad_houses(): assert max_good_houses(5, 2, 'BBBBB') == 2 def test_no_repair_needed(): assert max_good_houses(5, 0, 'GBGBG') == 3 def test_repair_every_house(): assert max_good_houses(5, 5, 'BBBBB') == 5 def test_wrap_around(): assert max_good_houses(5, 2, 'GGBGG') == 5 def test_large_input(): houses = 'B' * 100000 + 'G' * 100000 assert max_good_houses(200000, 100000, houses) == 200000","solution":"def max_good_houses(n, k, houses): Returns the maximum number of houses that can be in good condition after repairing at most k consecutive houses. max_good = 0 current_good = houses.count('G') # Calculate initial 'B' to be repaired in the first k segment repair_count = sum(1 for i in range(k) if houses[i] == 'B') max_good = max(max_good, current_good + repair_count) for i in range(1, n): if i + k - 1 < n: if houses[i-1] == 'B': repair_count -= 1 if houses[i + k - 1] == 'B': repair_count += 1 else: if houses[i-1] == 'B': repair_count -= 1 if houses[(i + k - 1) % n] == 'B': repair_count += 1 max_good = max(max_good, current_good + repair_count) return max_good"},{"question":"class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def parse_tree(preorder_str: str) -> Node: Parse the string representation of the binary tree into a tree structure. def parse_subtrees(subtree_str: str) -> Tuple[str, str]: Parse the left and right subtrees from the given subtree string representation. def isBST(root: Node, mini: float = float('-inf'), maxi: float = float('inf')) -> bool: Check if the given binary tree is a Binary Search Tree (BST). def check_binary_search_tree(preorder_str: str) -> str: Given a binary tree, check if it is a Binary Search Tree (BST). >>> check_binary_search_tree(\\"(10,(5,(1,null,null),(8,null,null)),(15,(12,null,null),(20,null,null)))\\") 'True' >>> check_binary_search_tree(\\"(10,(5,(1,null,null),(12,null,null)),(15,(7,null,null),(20,null,null)))\\") 'False' from typing import Tuple def test_case_1(): input_str = \\"(10,(5,(1,null,null),(8,null,null)),(15,(12,null,null),(20,null,null)))\\" assert check_binary_search_tree(input_str) == \\"True\\" def test_case_2(): input_str = \\"(10,(5,(1,null,null),(12,null,null)),(15,(7,null,null),(20,null,null)))\\" assert check_binary_search_tree(input_str) == \\"False\\" def test_case_3(): input_str = \\"(10,null,null)\\" assert check_binary_search_tree(input_str) == \\"True\\" def test_case_4(): input_str = \\"(10,(5,(3,null,null),(7,null,null)),(15,null,(20,null,null)))\\" assert check_binary_search_tree(input_str) == \\"True\\" def test_case_5(): input_str = \\"(10,(5,null,null),(5,null,null))\\" assert check_binary_search_tree(input_str) == \\"False\\"","solution":"class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def parse_tree(preorder_str): if preorder_str == 'null': return None if preorder_str[0] != '(' and preorder_str[-1] != ')': return Node(int(preorder_str)) stack = [] i = 0 while i < len(preorder_str): if preorder_str[i] == '(': stack.append(i) elif preorder_str[i] == ')': start = stack.pop() if not stack: root_tuple = preorder_str[start + 1:i].split(',', 1) root_value = int(root_tuple[0]) if len(root_tuple) == 1: return Node(root_value) left_subtree, right_subtree = parse_subtrees(root_tuple[1]) return Node(root_value, parse_tree(left_subtree), parse_tree(right_subtree)) i += 1 return None def parse_subtrees(subtree_str): counter = 0 i = 0 for char in subtree_str: if char == '(': counter += 1 if char == ')': counter -= 1 if char == ',' and counter == 0: return subtree_str[:i], subtree_str[i + 1:] i += 1 def isBST(root, mini=float('-inf'), maxi=float('inf')): if not root: return True if root.value <= mini or root.value >= maxi: return False return isBST(root.left, mini, root.value) and isBST(root.right, root.value, maxi) def check_binary_search_tree(preorder_str): root = parse_tree(preorder_str) return \\"True\\" if isBST(root) else \\"False\\""},{"question":"def validate_password(password: str) -> bool: Validate the password based on specific criteria. The password should: 1. Contain at least one lowercase letter. 2. Contain at least one uppercase letter. 3. Contain at least one digit. 4. Contain at least one special character from the set: [@, #, , %, &, *]. 5. Have a length between 8 to 16 characters (inclusive). >>> validate_password(\\"Password@123\\") True >>> validate_password(\\"password\\") False","solution":"import re def validate_password(password: str) -> bool: Validate the password based on the given criteria. if not 8 <= len(password) <= 16: return False if not re.search(r\\"[a-z]\\", password): return False if not re.search(r\\"[A-Z]\\", password): return False if not re.search(r\\"d\\", password): return False if not re.search(r\\"[@#%&*]\\", password): return False return True"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a simple mathematical expression string consisting of positive integers and the operators +, -, *, and /. Operator precedence is respected. Examples: >>> evaluate_expression(\\"3+5\\") 8.0 >>> evaluate_expression(\\"10+2*6\\") 22.0 >>> evaluate_expression(\\"100*2+12\\") 212.0 >>> evaluate_expression(\\"100*2/5\\") 40.0 >>> evaluate_expression(\\"10*2-5/5+3\\") 22.0 pass","solution":"def evaluate_expression(expression): Evaluates a simple mathematical expression string consisting of positive integers and the operators +, -, *, and /. Operator precedence is respected. import re # Split expression into tokens of numbers and operators tokens = re.findall(r'd+|+|-|*|/', expression) # Lists to hold numbers and operators separately values = [] operators = [] def apply_operator(operators, values): rhs = values.pop() lhs = values.pop() op = operators.pop() if op == '+': values.append(lhs + rhs) elif op == '-': values.append(lhs - rhs) elif op == '*': values.append(lhs * rhs) elif op == '/': values.append(lhs / rhs) # Precedences for operators precedence = {'+': 1, '-': 1, '*': 2, '/': 2} for token in tokens: if token.isdigit(): # Push number to values stack values.append(float(token)) else: # Token is an operator while (operators and precedence[operators[-1]] >= precedence[token]): apply_operator(operators, values) operators.append(token) # Apply remaining operators while operators: apply_operator(operators, values) # The final value on the values stack is the result return values[0]"},{"question":"from typing import List, Tuple def largest_number(nums: List[int]) -> str: Form the largest possible number by concatenating given integers. >>> largest_number([3, 30, 34]) '34330' >>> largest_number([54, 546, 548, 60]) '6054854654' pass def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Solve the problem for the given test cases. >>> solve(2, [(3, [3, 30, 34]), (4, [54, 546, 548, 60])]) ['34330', '6054854654'] >>> solve(1, [(5, [1, 20, 23, 4, 8])]) ['8423201'] pass def test_largest_number(): assert largest_number([3, 30, 34]) == \\"34330\\" assert largest_number([54, 546, 548, 60]) == \\"6054854654\\" assert largest_number([1, 20, 23, 4, 8]) == \\"8423201\\" assert largest_number([0, 0] * 500) == \\"0\\" assert largest_number([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) == \\"9609938824824769735703560743981399\\" def test_solve(): assert solve(2, [(3, [3, 30, 34]), (4, [54, 546, 548, 60])]) == [\\"34330\\", \\"6054854654\\"] assert solve(1, [(5, [1, 20, 23, 4, 8])]) == [\\"8423201\\"] assert solve(1, [(2, [0, 0] * 500)]) == [\\"0\\"] assert solve(2, [(9, [824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]), (3, [3, 33, 333])]) == [\\"9609938824824769735703560743981399\\", \\"333333\\"]","solution":"from functools import cmp_to_key def largest_number(nums): # Compare two strings by their concatenated order def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert integers to strings for comparison nums = list(map(str, nums)) # Sort using the custom comparator nums.sort(key=cmp_to_key(compare)) # Join the sorted list into a single string largest_num = ''.join(nums) # Handle the case where the largest number is '0' (meaning all numbers are zero) if largest_num[0] == '0': return '0' else: return largest_num def solve(T, test_cases): results = [] for i in range(T): N, nums = test_cases[i] results.append(largest_number(nums)) return results"},{"question":"def find_indices(nums, target): Given an array of integers, find two indices such that the elements at these indices sum up to the target number. Indices start from 1. :param nums: List[int] - list of integers :param target: int - target sum :return: Tuple[int, int] - tuple of indices sorted in ascending order >>> find_indices([2, 7, 11, 15], 9) (1, 2) >>> find_indices([3, 2, 4], 6) (2, 3) >>> find_indices([3, 3], 6) (1, 2)","solution":"def find_indices(nums, target): Given an array of integers, find two indices such that the elements at these indices sum up to the target number. Indices start from 1. :param nums: List[int] - list of integers :param target: int - target sum :return: Tuple[int, int] - tuple of indices sorted in ascending order num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: index1 = num_to_index[complement] + 1 index2 = i + 1 return (index1, index2) if index1 < index2 else (index2, index1) num_to_index[num] = i"},{"question":"def trap_water(heights: List[int]) -> int: Calculate the total units of water that can be trapped. :param heights: List of non-negative integers representing the height map of blocks. :return: Integer representing the total units of water that can be trapped. >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_water([0, 0, 0, 0, 0]) == 0 >>> trap_water([1, 2, 3, 4, 5]) == 0 >>> trap_water([5, 4, 3, 2, 1]) == 0 >>> trap_water([5]) == 0 >>> trap_water([5, 5]) == 0 >>> trap_water([2, 0, 2]) == 2 >>> trap_water([3, 0, 3, 0, 3]) == 6 >>> trap_water([]) == 0","solution":"def trap_water(heights): Calculate the total units of water that can be trapped. :param heights: List of non-negative integers representing the height map of blocks. :return: Integer representing the total units of water that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def basic_calculator(expression: str) -> float: Simulates a basic calculator that can handle simple arithmetic operations. Parameters: expression (str): A string representing a mathematical expression (e.g., \\"5+6\\") Returns: float: The result of the calculation. >>> basic_calculator(\\"5+6\\") 11.0 >>> basic_calculator(\\"12-4\\") 8.0 >>> basic_calculator(\\"7*3\\") 21.0 >>> basic_calculator(\\"20/5\\") 4.0 >>> basic_calculator(\\"5/2\\") 2.5","solution":"def basic_calculator(expression): Simulates a basic calculator that can handle simple arithmetic operations. Parameters: expression (str): A string representing a mathematical expression (e.g., \\"5+6\\") Returns: float: The result of the calculation. if '+' in expression: numbers = expression.split('+') return float(numbers[0]) + float(numbers[1]) elif '-' in expression: numbers = expression.split('-') return float(numbers[0]) - float(numbers[1]) elif '*' in expression: numbers = expression.split('*') return float(numbers[0]) * float(numbers[1]) elif '/' in expression: numbers = expression.split('/') return float(numbers[0]) / float(numbers[1])"},{"question":"def process_queries(T: int, test_cases: List[Tuple[str, int, List[Tuple[int]]]]) -> List[str]: Processes queries to alter or inspect a string based on given instructions. Args: T: The number of test cases. test_cases: A list of tuples where each tuple contains: - A string S which is the initial state of the string - An integer Q representing the number of queries - A list of Q queries to be performed on S, where each query is represented as a tuple Returns: A list of results from type 1 queries (characters at specified positions). Example: >>> process_queries(1, [(\\"abcdef\\", 3, [(1, 2), (2, 3, 'x'), (3, 4)])]) ['c'] >>> process_queries(2, [(\\"abcdef\\", 3, [(1, 1), (2, 3, 'x'), (1, 3)]), (\\"zyxwvu\\", 2, [(1, 0), (3, 2)])]) ['b', 'x', 'z'] results = [] for case in test_cases: S, Q, queries = case S = list(S) # Convert string to list to allow mutation for query in queries: if query[0] == 1: # Query type 1 _, i = query results.append(S[i]) elif query[0] == 2: # Query type 2 _, i, c = query S[i] = c elif query[0] == 3: # Query type 3 _, k = query S[:k+1] = reversed(S[:k+1]) return results # Unit tests def test_single_case(): T = 1 test_cases = [ (\\"abcdef\\", 3, [ (1, 2), (2, 3, 'x'), (3, 4) ]) ] assert process_queries(T, test_cases) == ['c'] def test_multiple_cases(): T = 2 test_cases = [ (\\"abcdef\\", 3, [ (1, 1), (2, 3, 'x'), (1, 3) ]), (\\"zyxwvu\\", 2, [ (1, 0), (3, 2) ]) ] assert process_queries(T, test_cases) == ['b', 'x', 'z'] def test_reverse_whole_string(): T = 1 test_cases = [ (\\"abcdef\\", 1, [ (3, 5) ]) ] assert process_queries(T, test_cases) == [] def test_replacements_and_reversals(): T = 1 test_cases = [ (\\"abc\\", 6, [ (2, 1, 'x'), # abc -> axc (2, 0, 'y'), # axc -> yxc (1, 1), # x (1, 0), # y (3, 2), # yxc -> cxy (1, 1), # x ]) ] assert process_queries(T, test_cases) == ['x', 'y', 'x']","solution":"def process_queries(T, test_cases): results = [] for case in test_cases: S, Q, queries = case S = list(S) # Convert string to list to allow mutation for query in queries: if query[0] == 1: # Query type 1 _, i = query results.append(S[i]) elif query[0] == 2: # Query type 2 _, i, c = query S[i] = c elif query[0] == 3: # Query type 3 _, k = query S[:k+1] = reversed(S[:k+1]) return results"},{"question":"def length_of_lis(arr): Returns the length of longest increasing subsequence in the given array. >>> length_of_lis([10, 22, 9, 33, 21, 50]) 4 >>> length_of_lis([3, 10, 2, 1, 20]) 3 >>> length_of_lis([2, 2, 2, 2, 2, 2, 2, 2]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([1]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 pass def process_library_cases(cases): Processes multiple test cases and returns a list with the length of longest increasing subsequence for each case. >>> process_library_cases([(6, [10, 22, 9, 33, 21, 50]), (5, [3, 10, 2, 1, 20]), (8, [2, 2, 2, 2, 2, 2, 2, 2])]) [4, 3, 1] >>> process_library_cases([(0, []), (1, [1]), (5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1])]) [0, 1, 5, 1] pass","solution":"def length_of_lis(arr): Returns the length of longest increasing subsequence in the given array. if not arr: return 0 # Create an array to store our subsequence lis = [] for num in arr: # Use binary search to find the insertion point of the num in lis left, right = 0, len(lis) while left < right: mid = (left + right) // 2 if lis[mid] < num: left = mid + 1 else: right = mid if left == len(lis): lis.append(num) else: lis[left] = num return len(lis) def process_library_cases(cases): Processes multiple test cases and returns a list with the length of longest increasing subsequence for each case. results = [] for case in cases: N, books = case results.append(length_of_lis(books)) return results"},{"question":"def find_balanced_sequence(n): Determines if a balanced sequence of length n exists. If exists, returns the sequence as a list of integers. If not, returns -1. >>> find_balanced_sequence(1) [0] >>> find_balanced_sequence(2) -1 >>> find_balanced_sequence(3) [1, 0, 1] >>> find_balanced_sequence(4) -1 >>> find_balanced_sequence(5) [1, 1, 0, 1, 1]","solution":"def find_balanced_sequence(n): Determines if a balanced sequence of length n exists. If exists, returns the sequence as a list of integers. If not, returns -1. if n % 2 == 0: return -1 else: half = n // 2 sequence = [1] * half + [0] + [1] * half return sequence"},{"question":"country_borders = { \\"Nepal\\": [\\"China\\", \\"India\\"], \\"Bhutan\\": [\\"China\\", \\"India\\"], \\"China\\": [\\"Nepal\\", \\"India\\", \\"Pakistan\\", \\"Bhutan\\", \\"Afghanistan\\"], \\"India\\": [\\"Nepal\\", \\"China\\", \\"Bhutan\\", \\"Pakistan\\"], \\"Canada\\": [\\"USA\\"], \\"USA\\": [\\"Canada\\", \\"Mexico\\"], \\"Mexico\\": [\\"USA\\"], # Add more countries as needed } coastal_countries = { \\"Nepal\\": False, \\"Bhutan\\": False, \\"China\\": True, \\"India\\": True, \\"Canada\\": True, \\"USA\\": True, \\"Mexico\\": True, # Add more countries as needed } def isLandlocked(country): Determines if a country is landlocked. Parameters: - country (str): The name of the country. Returns: - bool: True if the country is landlocked, otherwise False. pass def test_isLandlocked_landlocked_countries(): assert isLandlocked(\\"Nepal\\") == True assert isLandlocked(\\"Bhutan\\") == True def test_isLandlocked_coastal_countries(): assert isLandlocked(\\"China\\") == False assert isLandlocked(\\"India\\") == False assert isLandlocked(\\"Canada\\") == False assert isLandlocked(\\"USA\\") == False assert isLandlocked(\\"Mexico\\") == False def test_isLandlocked_unknown_country(): assert isLandlocked(\\"Atlantis\\") == True # Since it's not in the provided list, assume it's landlocked by default","solution":"country_borders = { \\"Nepal\\": [\\"China\\", \\"India\\"], \\"Bhutan\\": [\\"China\\", \\"India\\"], \\"China\\": [\\"Nepal\\", \\"India\\", \\"Pakistan\\", \\"Bhutan\\", \\"Afghanistan\\"], \\"India\\": [\\"Nepal\\", \\"China\\", \\"Bhutan\\", \\"Pakistan\\"], \\"Canada\\": [\\"USA\\"], \\"USA\\": [\\"Canada\\", \\"Mexico\\"], \\"Mexico\\": [\\"USA\\"], # Add more countries as needed } coastal_countries = { \\"Nepal\\": False, \\"Bhutan\\": False, \\"China\\": True, \\"India\\": True, \\"Canada\\": True, \\"USA\\": True, \\"Mexico\\": True, # Add more countries as needed } def isLandlocked(country): Determines if a country is landlocked. Parameters: - country (str): The name of the country. Returns: - bool: True if the country is landlocked, otherwise False. return not coastal_countries.get(country, False)"},{"question":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. The allowed operations are insertion, deletion, and substitution of a single character. >>> minDistance(\\"kitten\\", \\"sitting\\") 3 >>> minDistance(\\"flaw\\", \\"lawn\\") 2 >>> minDistance(\\"\\", \\"\\") 0 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"abc\\", \\"\\") 3 >>> minDistance(\\"example\\", \\"example\\") 0 >>> minDistance(\\"a\\", \\"b\\") 1 >>> minDistance(\\"a\\", \\"\\") 1 >>> minDistance(\\"\\", \\"a\\") 1 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"abcdef\\", \\"azced\\") 3","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. The allowed operations are insertion, deletion, and substitution of a single character. m, n = len(word1), len(word2) # Initialize the dp table with size (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the base cases where one of the words is empty for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] # No operation required else: dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1) # Insert, Delete, or Substitute return dp[m][n]"},{"question":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a new array, sorted in non-decreasing order. :param arr1: List[int] - The first sorted array. :param arr2: List[int] - The second sorted array. :return: List[int] - The merged and sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0, 8, 10], [1, 5, 7, 12]) [0, 1, 5, 7, 8, 10, 12] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([2], [1, 3, 4]) [1, 2, 3, 4] >>> merge_sorted_arrays([1, 2, 3], [4]) [1, 2, 3, 4]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a new array, sorted in non-decreasing order. :param arr1: List[int] - The first sorted array. :param arr2: List[int] - The second sorted array. :return: List[int] - The merged and sorted array. merged_array = [] i, j = 0, 0 # Traverse both arrays and insert smaller of both elements into merged_array while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Store remaining elements of first array while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Store remaining elements of second array while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"from typing import List, Optional def max_product_of_two(arr: List[int]) -> Optional[int]: Returns the maximum product of any two distinct numbers in the array. >>> max_product_of_two([3, 5, -2, 8, 11]) 88 >>> max_product_of_two([-10, -3, 5, 6, -2]) 30 >>> max_product_of_two([-10, -3, 1, 2, 5]) 30 >>> max_product_of_two([-1, 10, 20, 2, -10]) 200 >>> max_product_of_two([1, 2, 3, 4, 5]) 20 >>> max_product_of_two([10, 20, 30]) 600 >>> max_product_of_two([-5, -10, -20]) 200 >>> max_product_of_two([0, -1, 2, 3]) 6 >>> max_product_of_two([-10, 0, 2, 3]) 6 >>> max_product_of_two([42]) None","solution":"def max_product_of_two(arr): Returns the maximum product of any two distinct numbers in the array. if len(arr) < 2: return None arr.sort(reverse=True) max1 = arr[0] * arr[1] # Product of the two largest numbers max2 = arr[-1] * arr[-2] # Product of the two smallest numbers (which could be negative) return max(max1, max2)"},{"question":"def max_assignments_completed(n: int, m: int, deadlines: List[int], unavailable_days: List[List[int]]) -> int: Determine the maximum number of assignments that can be completed by the class before the deadlines. Parameters: - n: number of students - m: number of assignments - deadlines: list of deadlines for each assignment - unavailable_days: list of lists with each student's unavailable days Returns: - Maximum number of assignments that can be completed before the deadlines. >>> max_assignments_completed(3, 3, [3, 3, 5], [[1, 2], [3], []]) 3 >>> max_assignments_completed(2, 2, [4, 5], [[1], [2]]) 2 >>> max_assignments_completed(2, 2, [4, 2], [[], []]) 2 >>> max_assignments_completed(1, 3, [1, 1, 1], [[]]) 1 >>> max_assignments_completed(2, 2, [1, 1], [[1], [1]]) 0 >>> max_assignments_completed(3, 3, [4, 4, 4], [[1, 2, 3], [2, 3, 4], [1, 4]]) 3 pass","solution":"def max_assignments_completed(n, m, deadlines, unavailable_days): Determine the maximum number of assignments that can be completed by the class before the deadlines. Parameters: - n: number of students - m: number of assignments - deadlines: list of deadlines for each assignment - unavailable_days: list of lists with each student's unavailable days Returns: - Maximum number of assignments that can be completed before the deadlines. # Sort the deadlines to prioritize the assignments to be completed first deadlines.sort() # Construct a list of all days students are available available_days = [[] for _ in range(366)] # 1-based index for days in a year for student_id in range(n): unavailable = set(unavailable_days[student_id]) for day in range(1, 366): if day not in unavailable: available_days[day].append(student_id) assignments_completed = 0 for deadline in deadlines: # Check from day 1 to deadline day if there is any student available to do the assignment for day in range(1, deadline + 1): if available_days[day]: # Assign the assignment to one of the available students student_id = available_days[day].pop(0) # Student does the assignment assignments_completed += 1 break return assignments_completed"},{"question":"def evenSum(lst): Returns the sum of elements at even indices in the list. >>> evenSum([1, 2, 3, 4, 5]) == 9 >>> evenSum([10, 20, 30, 40]) == 40 >>> evenSum([]) == 0 >>> evenSum([7]) == 7 pass def oddSum(lst): Returns the sum of elements at odd indices in the list. >>> oddSum([1, 2, 3, 4, 5]) == 6 >>> oddSum([10, 20, 30, 40]) == 60 >>> oddSum([]) == 0 >>> oddSum([7]) == 0 pass","solution":"def evenSum(lst): Returns the sum of elements at even indices in the list. if not lst: return 0 return lst[0] + oddSum(lst[1:]) def oddSum(lst): Returns the sum of elements at odd indices in the list. if not lst: return 0 return evenSum(lst[1:])"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> str: Find the longest substring of a given string \`s\` that contains exactly \`k\` distinct characters. If there are multiple substrings with the same maximum length, return any one of them. If the given string \`s\` is empty or \`k\` is less than or equal to 0, return an empty string \`''\`. >>> longest_substring_with_k_distinct('eceba', 2) 'ece' >>> longest_substring_with_k_distinct('aa', 1) 'aa' >>> longest_substring_with_k_distinct('a', 0) '' from solution import longest_substring_with_k_distinct def test_longest_substring_with_k_distinct_2_chars(): assert longest_substring_with_k_distinct('eceba', 2) == 'ece' def test_longest_substring_with_k_distinct_1_char(): assert longest_substring_with_k_distinct('aa', 1) == 'aa' def test_longest_substring_with_k_distinct_zero_chars(): assert longest_substring_with_k_distinct('a', 0) == '' def test_longest_substring_with_k_distinct_empty_string(): assert longest_substring_with_k_distinct('', 1) == '' def test_longest_substring_with_k_distinct_k_greater_than_string_length(): assert longest_substring_with_k_distinct('abc', 4) == 'abc' def test_longest_substring_with_k_distinct_same_chars(): assert longest_substring_with_k_distinct('aaaaa', 2) == 'aaaaa' def test_longest_substring_with_k_distinct_multiple_options(): result = longest_substring_with_k_distinct('aabacbebebe', 3) assert result == 'cbebebe' or result == 'bacbebe' def test_longest_substring_with_k_distinct_all_unique(): result = longest_substring_with_k_distinct('abcdef', 6) assert result == 'abcdef'","solution":"def longest_substring_with_k_distinct(s, k): if not s or k <= 0: return \\"\\" n = len(s) left = 0 right = 0 max_length = 0 start_index = 0 char_count = {} while right < n: char = s[right] if char not in char_count: char_count[char] = 0 char_count[char] += 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 if right - left + 1 > max_length: max_length = right - left + 1 start_index = left right += 1 return s[start_index:start_index + max_length]"},{"question":"def can_partition(nums: List[int]) -> bool: Determines whether you can partition the list into two subsets such that the sum of the elements in both subsets is equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1]) False >>> can_partition([0]) True >>> can_partition([]) True >>> can_partition([1, 1, 3, 4, 7]) True >>> can_partition([2, 3, 4, 6]) False >>> can_partition([1] * 200) True >>> can_partition([1, 1, 1]) False","solution":"def can_partition(nums): Determines whether the list can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If total sum is odd, we cannot partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array to store subproblems results dp = [False] * (target + 1) dp[0] = True for num in nums: # Traverse backwards to not overwrite previous results for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def two_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Determine whether there are two distinct elements in the array that add up to the target sum. If such elements exist, return their indices as a tuple (index1, index2). If no such pair exists, return None. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([1, 4, 5, 6], 10) (1, 3) >>> two_sum([0, 0, 3, 4], 0) (0, 1)","solution":"def two_sum(nums, target): Finds two distinct elements in the array that add up to the target sum and returns their indices. :param nums: List of integers :param target: Integer target sum :return: Tuple of indices of the two numbers that add up to target or None if no such pair exists. lookup = {} for i, num in enumerate(nums): needed = target - num if needed in lookup: return (lookup[needed], i) lookup[num] = i return None"},{"question":"def most_frequent_word(sentence: str) -> tuple: Find the most frequent word in the sentence, ignoring punctuation and case. >>> most_frequent_word(\\"The cat and the dog both chased the mouse in the house\\") ('the', 4) >>> most_frequent_word(\\"Hello, hello! How are you? I hope you are doing well. Well, well, hello again!\\") ('hello', 3)","solution":"import re from collections import Counter def most_frequent_word(sentence): Find the most frequent word in the sentence, ignoring punctuation and case. Parameters: sentence (str): A sentence containing words. Returns: tuple: The most frequent word and its frequency. # Remove punctuation and lower the cases words = re.findall(r'bw+b', sentence.lower()) # Count the frequency of each word word_count = Counter(words) # Find the word with the highest frequency; in case of tie, return the first one that appears in the sentence. most_common_word, most_common_count = None, 0 for word in words: if word_count[word] > most_common_count: most_common_word = word most_common_count = word_count[word] return most_common_word, most_common_count"},{"question":"def count_vowels(input_string: str) -> int: Returns the count of vowels (a, e, i, o, u, both uppercase and lowercase) in the input string. >>> count_vowels(\\"hello world\\") 3 >>> count_vowels(\\"HELLO\\") 2 >>> count_vowels(\\"bcdfg\\") 0 >>> count_vowels(\\"python\\") 1 >>> count_vowels(\\"\\") 0 >>> count_vowels(\\"PyThOn\\") 1 >>> count_vowels(\\"aeiouAEIOU\\") 10","solution":"def count_vowels(input_string): Returns the count of vowels (a, e, i, o, u, both uppercase and lowercase) in the input string. vowels = \\"aeiouAEIOU\\" return sum(1 for char in input_string if char in vowels)"},{"question":"class Employee: def __init__(self, name, manager=None): self.name = name self.manager = manager def find_reporting_chain(employee): Returns a list of the reporting chain from the employee up to the CEO. >>> ceo = Employee(\\"CEO\\") >>> employee = Employee(\\"Employee\\", ceo) >>> find_reporting_chain(employee) [\\"Employee\\", \\"CEO\\"] >>> ceo = Employee(\\"CEO\\") >>> manager_a = Employee(\\"Manager A\\", ceo) >>> manager_b = Employee(\\"Manager B\\", manager_a) >>> employee = Employee(\\"Employee\\", manager_b) >>> find_reporting_chain(employee) [\\"Employee\\", \\"Manager B\\", \\"Manager A\\", \\"CEO\\"] >>> ceo = Employee(\\"CEO\\") >>> find_reporting_chain(ceo) [\\"CEO\\"] >>> ceo = Employee(\\"CEO\\") >>> manager = Employee(\\"Manager\\", ceo) >>> find_reporting_chain(manager) [\\"Manager\\", \\"CEO\\"]","solution":"class Employee: def __init__(self, name, manager=None): self.name = name self.manager = manager def find_reporting_chain(employee): Returns a list of the reporting chain from the employee up to the CEO. chain = [] current_employee = employee while current_employee is not None: chain.append(current_employee.name) current_employee = current_employee.manager return chain"},{"question":"def double_characters(s: str) -> str: Given a string, return a new string where each character in the original string is repeated twice. :param s: Original string :return: String with each character repeated twice >>> double_characters(\\"hello\\") 'hheelllloo' >>> double_characters(\\"1234!\\") '11223344!!' pass from solution import double_characters def test_double_characters_regular_string(): assert double_characters(\\"hello\\") == \\"hheelllloo\\" def test_double_characters_numbers_and_symbols(): assert double_characters(\\"1234!\\") == \\"11223344!!\\" def test_double_characters_empty_string(): assert double_characters(\\"\\") == \\"\\" def test_double_characters_single_character(): assert double_characters(\\"A\\") == \\"AA\\" def test_double_characters_mixed_case(): assert double_characters(\\"AbC\\") == \\"AAbbCC\\" def test_double_characters_spaces(): assert double_characters(\\"a b c\\") == \\"aa bb cc\\"","solution":"def double_characters(s): Given a string, return a new string where each character in the original string is repeated twice. :param s: Original string :return: String with each character repeated twice return ''.join([char * 2 for char in s])"},{"question":"def total_throws(K: int) -> int: Calculate the total number of throws needed for Alice to hold the ball K times. >>> total_throws(1) 0 >>> total_throws(2) 2 >>> total_throws(3) 4 >>> total_throws(10**6) 1999998 def process_test_cases(T: int, cases: List[int]) -> List[int]: Process each test case and compute the number of throws required for each provided number of times Alice should hold the ball. >>> process_test_cases(2, [1, 2]) [0, 2] >>> process_test_cases(3, [1, 3, 10**6]) [0, 4, 1999998] >>> process_test_cases(1, [5]) [8]","solution":"def total_throws(K): Returns the total number of throws needed for Alice to hold the ball K times. if K == 1: return 0 return 2 * (K - 1) def process_test_cases(T, cases): Process each test case and compute the number of throws required for each provided number of times Alice should hold the ball. results = [] for K in cases: results.append(total_throws(K)) return results"},{"question":"class Matrix: A class used to represent a Matrix and perform basic matrix operations Methods ------- transpose(): Returns a new \`Matrix\` object that is the transpose of the current matrix. trace(): Returns the trace of the matrix (sum of the diagonal elements). Assume the matrix is square. multiply(matrix): Multiplies the current matrix by another \`Matrix\` object \`matrix\` and returns the resultant \`Matrix\` object. Assume the matrices are of compatible dimensions. Examples -------- >>> m1 = Matrix([[1, 2], [3, 4]]) >>> m2 = Matrix([[2, 0], [1, 2]]) >>> m1.transpose().matrix [[1, 3], [2, 4]] >>> m1.trace() 5 >>> m1.multiply(m2).matrix [[4, 4], [10, 8]] def __init__(self, matrix): self.matrix = matrix def transpose(self): pass def trace(self): pass def multiply(self, other): pass def test_transpose(): m1 = Matrix([[1, 2], [3, 4]]) transposed_m1 = m1.transpose() assert transposed_m1.matrix == [[1, 3], [2, 4]] def test_trace(): m1 = Matrix([[1, 2], [3, 4]]) assert m1.trace() == 5 def test_multiply(): m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[2, 0], [1, 2]]) product = m1.multiply(m2) assert product.matrix == [[4, 4], [10, 8]] def test_transpose_non_square(): m1 = Matrix([[1, 2, 3], [4, 5, 6]]) transposed_m1 = m1.transpose() assert transposed_m1.matrix == [[1, 4], [2, 5], [3, 6]] def test_trace_single_element(): m1 = Matrix([[7]]) assert m1.trace() == 7 def test_multiply_identity(): identity = Matrix([[1, 0], [0, 1]]) m1 = Matrix([[5, 6], [7, 8]]) product = m1.multiply(identity) assert product.matrix == [[5, 6], [7, 8]]","solution":"class Matrix: def __init__(self, matrix): self.matrix = matrix def transpose(self): rows, cols = len(self.matrix), len(self.matrix[0]) transposed = [[self.matrix[j][i] for j in range(rows)] for i in range(cols)] return Matrix(transposed) def trace(self): return sum(self.matrix[i][i] for i in range(len(self.matrix))) def multiply(self, other): result_matrix = [[sum(a * b for a, b in zip(self_row, other_col)) for other_col in zip(*other.matrix)] for self_row in self.matrix] return Matrix(result_matrix)"},{"question":"import re from collections import Counter from typing import Dict def top_3_common_words(text: str) -> Dict[str, int]: Returns a dictionary of the top 3 most common words along with their frequencies. Ignores case, punctuation, and common stop words. >>> top_3_common_words(\\"apple orange banana apple apple orange\\") == {\\"apple\\": 3, \\"orange\\": 2, \\"banana\\": 1} >>> top_3_common_words(\\"the apple in the basket is red\\") == {\\"apple\\": 1, \\"basket\\": 1, \\"red\\": 1} >>> top_3_common_words(\\"hello, world! hello... world?\\") == {\\"hello\\": 2, \\"world\\": 2} >>> top_3_common_words(\\"Hello hELLo HeLLo\\") == {\\"hello\\": 3} >>> top_3_common_words(\\"\\") == {} >>> top_3_common_words(\\"cat dog bird cat dog bird lion fish\\") == {\\"cat\\": 2, \\"dog\\": 2, \\"bird\\": 2} >>> top_3_common_words(\\"apple apple\\") == {\\"apple\\": 2} >>> top_3_common_words(\\"the the is in at on which\\") == {}","solution":"import re from collections import Counter def top_3_common_words(text): Returns a dictionary of the top 3 most common words along with their frequencies. Ignores case, punctuation, and common stop words. # Define the common stop words stop_words = set(['the', 'is', 'in', 'at', 'which', 'on']) # Clean the text by removing punctuation and converting to lower case cleaned_text = re.sub(r'[^ws]', '', text).lower() # Split the text into words words = cleaned_text.split() # Filter out stop words filtered_words = [word for word in words if word not in stop_words] # Count the frequencies of each word word_counts = Counter(filtered_words) # Get the top 3 most common words and their frequencies most_common = word_counts.most_common(3) # If there are ties in frequencies within the top 3, include all the tied words in the output result = {} freq_counter = 0 for word, freq in most_common: if len(result) < 3: result[word] = freq freq_counter = freq else: if freq == freq_counter: result[word] = freq return result"},{"question":"def pack_chocolates(N: int, chocolates: List[int]) -> Tuple[List[List[int]], List[int]]: Simulates the process of boxing chocolates. Arguments: N -- an integer representing the number of chocolates in the bin. chocolates -- a list of integers representing types of chocolates. Returns: A tuple with a list of packed boxes and a list of remaining chocolates. >>> pack_chocolates(23, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) ([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], [1, 1, 1]) >>> pack_chocolates(20, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) ([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]], []) >>> pack_chocolates(8, [1, 2, 3, 4, 5, 6, 7, 8]) ([], [1, 2, 3, 4, 5, 6, 7, 8])","solution":"def pack_chocolates(N, chocolates): Simulates the process of boxing chocolates. Arguments: N -- an integer representing the number of chocolates in the bin. chocolates -- a list of integers representing types of chocolates. Returns: A tuple with a list of packed boxes and a list of remaining chocolates. boxes = [] size = 10 while N >= size: box = chocolates[:size] boxes.append(box) chocolates = chocolates[size:] N -= size return boxes, chocolates"},{"question":"def sum_of_squares(input_string: str) -> int: Returns the sum of the squares of the numbers in the comma-separated string. Parameters: input_string (str): A string of comma-separated numbers. Returns: int: The sum of the squares of the input numbers. >>> sum_of_squares(\\"1,2,3,4\\") 30 >>> sum_of_squares(\\"10,20,30\\") 1400 >>> sum_of_squares(\\"-1,-2,-3,-4\\") 30 >>> sum_of_squares(\\"1,-2,3,-4\\") 30 >>> sum_of_squares(\\"0,1,2,3\\") 14 pass","solution":"def sum_of_squares(input_string): Returns the sum of the squares of the numbers in the comma-separated string. Parameters: input_string (str): A string of comma-separated numbers. Returns: int: The sum of the squares of the input numbers. numbers = map(int, input_string.split(',')) return sum(number ** 2 for number in numbers)"},{"question":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeated or the string is empty, returns an empty string. >>> first_non_repeating_character(\\"aabbcdd\\") == \\"c\\" >>> first_non_repeating_character(\\"abcabc\\") == \\"\\" >>> first_non_repeating_character(\\"aA\\") == \\"a\\" >>> first_non_repeating_character(\\"aab\\") == \\"b\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\"\\" >>> first_non_repeating_character(\\"\\") == \\"\\" >>> first_non_repeating_character(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"a\\" >>> first_non_repeating_character(\\"aA\\") == \\"a\\" >>> first_non_repeating_character(\\"abAB\\") == \\"a\\" >>> first_non_repeating_character(\\"a\\") == \\"a\\" >>> first_non_repeating_character(\\"aaaaa\\") == \\"\\" >>> first_non_repeating_character(\\"aAa\\") == \\"A\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeated or the string is empty, returns an empty string. # Dictionary to store the frequency of each character char_count = {} # Count the frequency of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a frequency of 1 for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"def interleave_strings(A: str, B: str) -> str: Generate an interleaved string C from A and B. pass def count_distinct_characters(C: str) -> int: Count the number of distinct characters in the string C. pass def process_queries(N: int, A: str, B: str, queries: List[str]) -> List[int]: Process a list of queries to update strings A and B, and count distinct characters in the interleaved string C. >>> N, A, B, queries = 5, \\"abcde\\", \\"fghij\\", [\\"1 3 k\\", \\"3\\", \\"2 5 z\\", \\"3\\"] >>> process_queries(N, A, B, queries) [10, 10] >>> N, A, B, queries = 3, \\"abc\\", \\"def\\", [\\"1 2 x\\", \\"3\\"] >>> process_queries(N, A, B, queries) [6] >>> N, A, B, queries = 3, \\"abc\\", \\"def\\", [\\"2 1 x\\", \\"3\\"] >>> process_queries(N, A, B, queries) [6] >>> N, A, B, queries = 4, \\"abcd\\", \\"efgh\\", [\\"1 1 x\\", \\"2 4 y\\", \\"3\\"] >>> process_queries(N, A, B, queries) [8] >>> N, A, B, queries = 2, \\"ab\\", \\"cd\\", [\\"3\\"] >>> process_queries(N, A, B, queries) [4] >>> N, A, B, queries = 3, \\"aaa\\", \\"bbb\\", [\\"1 1 x\\", \\"1 2 y\\", \\"1 3 z\\", \\"2 1 u\\", \\"2 2 v\\", \\"2 3 w\\", \\"3\\"] >>> process_queries(N, A, B, queries) [6] pass","solution":"def interleave_strings(A, B): Generate an interleaved string C from A and B. return ''.join([A[i] + B[i] for i in range(len(A))]) def count_distinct_characters(C): Count the number of distinct characters in the string C. return len(set(C)) def process_queries(N, A, B, queries): results = [] for query in queries: parts = query.split() if parts[0] == '1': # Update A x = int(parts[1]) - 1 C = parts[2] A = A[:x] + C + A[x+1:] elif parts[0] == '2': # Update B y = int(parts[1]) - 1 D = parts[2] B = B[:y] + D + B[y+1:] elif parts[0] == '3': # Count distinct characters in interleaved string interleaved = interleave_strings(A, B) results.append(count_distinct_characters(interleaved)) return results"},{"question":"def word_ladder_length(begin_word: str, end_word: str, word_list: list) -> int: Write a function called \`word_ladder_length\` that calculates the minimum number of transformations required to convert one word (the \`begin_word\`) into another word (the \`end_word\`) using a given list of words as intermediate steps. Each transformation can only change one letter at a time, and each intermediate word must exist in the given list (\`word_list\`). >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 >>> word_ladder_length(\\"hit\\", \\"hot\\", [\\"hot\\"]) 2 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cot\\", \\"cog\\"]) 4 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"hog\\"]) 0 >>> word_ladder_length(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) 2","solution":"from collections import deque def word_ladder_length(begin_word: str, end_word: str, word_list: list) -> int: if end_word not in word_list: return 0 word_set = set(word_list) queue = deque([(begin_word, 1)]) # queue holds tuples of (current_word, current_length) while queue: current_word, current_length = queue.popleft() if current_word == end_word: return current_length for i in range(len(current_word)): for char in 'abcdefghijklmnopqrstuvwxyz': # Change one letter at a time next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, current_length + 1)) return 0"},{"question":"def inventory_count(inventory): Returns a dictionary where keys are the unique inventory amounts and values are the counts of each unique amount. >>> inventory_count([1, 2, 3, 1, 2, 5, 1]) == {1: 3, 2: 2, 3: 1, 5: 1} >>> inventory_count([10, 20, 30, 10, 20, 10]) == {10: 3, 20: 2, 30: 1} >>> inventory_count([]) == {} >>> inventory_count([5, 5, 5, 5, 5]) == {5: 5} >>> inventory_count([4, 6, 8, 6, 10, 8, 4]) == {4: 2, 6: 2, 8: 2, 10: 1}","solution":"def inventory_count(inventory): Returns a dictionary where keys are the unique inventory amounts and values are the counts of each unique amount. count_dict = {} for item in inventory: if item in count_dict: count_dict[item] += 1 else: count_dict[item] = 1 return count_dict"},{"question":"def generate_matrix(n): Generates an n x n spiral matrix filled with numbers from 1 to nÂ². Args: n (int): The size of the matrix. Returns: list: A 2D list representing the generated spiral matrix. >>> generate_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] >>> generate_matrix(0) []","solution":"def generate_matrix(n): Generates an n x n spiral matrix filled with numbers from 1 to nÂ². Args: n (int): The size of the matrix. Returns: list: A 2D list representing the generated spiral matrix. if n <= 0: return [] matrix = [[0] * n for _ in range(n)] num = 1 left, right = 0, n - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def smallest_repetitive_unit(word: str) -> str: Determines the smallest unit of repetition for a given word. Parameters: word (str): The input word composed of lowercase alphabets. Returns: str: The smallest unit of repetition. >>> smallest_repetitive_unit(\\"abcabcabc\\") 'abc' >>> smallest_repetitive_unit(\\"aaaaaa\\") 'a' >>> smallest_repetitive_unit(\\"b\\") 'b' >>> smallest_repetitive_unit(\\"abcdefghij\\") 'abcdefghij' >>> smallest_repetitive_unit(\\"abababab\\") 'ab' >>> smallest_repetitive_unit(\\"abcdefgabcdefg\\") 'abcdefg' >>> smallest_repetitive_unit(\\"xyzxyzxyzxyz\\") 'xyz' >>> smallest_repetitive_unit(\\"abacabadabacabad\\") 'abacabad'","solution":"def smallest_repetitive_unit(word): Determines the smallest unit of repetition for a given word. Parameters: word (str): The input word composed of lowercase alphabets. Returns: str: The smallest unit of repetition. length = len(word) for i in range(1, length // 2 + 1): unit = word[:i] if length % i == 0: if unit * (length // i) == word: return unit return word"},{"question":"def exact_age(people_ages: dict, target_age: int) -> list: Returns a list of names of people who are exactly the target age, sorted alphabetically. :param people_ages: Dictionary of people's names and their respective ages. :type people_ages: dict :param target_age: The age to filter on. :type target_age: int :return: List of names of people who are exactly the target age, sorted in alphabetical order. :rtype: list >>> exact_age({'Alice': 30, 'Bob': 25, 'Charlie': 30, 'David': 25, 'Eve': 35}, 30) ['Alice', 'Charlie'] >>> exact_age({'Alice': 30, 'Bob': 25, 'Charlie': 30, 'David': 25, 'Eve': 35}, 25) ['Bob', 'David'] >>> exact_age({'Alice': 30, 'Bob': 25, 'Charlie': 30, 'David': 25, 'Eve': 35}, 35) ['Eve'] >>> exact_age({'Alice': 22, 'Bob': 25, 'Charlie': 23, 'David': 22, 'Eve': 33}, 22) ['Alice', 'David'] >>> exact_age({'Alice': 22, 'Bob': 25, 'Charlie': 23, 'David': 22, 'Eve': 33}, 40) [] >>> exact_age({}, 30) [] >>> exact_age({'Alice': 25, 'Bob': 25, 'Charlie': 25}, 25) ['Alice', 'Bob', 'Charlie']","solution":"def exact_age(people_ages, target_age): Returns a list of names of people who are exactly the target age, sorted alphabetically. :param people_ages: Dictionary of people's names and their respective ages. :type people_ages: dict :param target_age: The age to filter on. :type target_age: int :return: List of names of people who are exactly the target age, sorted in alphabetical order. :rtype: list return sorted(name for name, age in people_ages.items() if age == target_age)"},{"question":"def is_magic_square(grid: List[List[int]]) -> bool: Determine if a given n x n grid is a magic square. >>> is_magic_square([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ]) == True >>> is_magic_square([ ... [3, 5, 7], ... [8, 1, 6], ... [4, 9, 2] ... ]) == False >>> is_magic_square([ ... [4, 9, 2], ... [3, 5, 7], ... [8, 1, 6] ... ]) == True >>> is_magic_square([ ... [16, 3, 2, 13], ... [5, 10, 11, 8], ... [9, 6, 7, 12], ... [4, 15, 14, 1] ... ]) == True >>> is_magic_square([ ... [16, 3, 2, 13], ... [5, 10, 11, 8], ... [9, 6, 18, 12], ... [4, 15, 14, 1] ... ]) == False >>> is_magic_square([ ... [1, 2], ... [3, 4] ... ]) == False >>> is_magic_square([ ... [1] ... ]) == True","solution":"def is_magic_square(grid): n = len(grid) # Calculate the magic constant (sum expected for every row, column, and diagonal) magic_constant = n * (n**2 + 1) // 2 # Check if all numbers from 1 to n^2 are present numbers = set() for row in grid: for num in row: numbers.add(num) if numbers != set(range(1, n**2 + 1)): return False # Check sums of rows for i in range(n): if sum(grid[i]) != magic_constant: return False # Check sums of columns for j in range(n): if sum(grid[i][j] for i in range(n)) != magic_constant: return False # Check sums of diagonals if sum(grid[i][i] for i in range(n)) != magic_constant: return False if sum(grid[i][n-i-1] for i in range(n)) != magic_constant: return False return True"},{"question":"from typing import List def stable_rearrange(s: str) -> str: Rearrange the characters of the string such that no two adjacent characters are the same. If it is not possible, return 'IMPOSSIBLE'. >>> stable_rearrange(\\"aab\\") \\"aba\\" >>> stable_rearrange(\\"aaab\\") \\"IMPOSSIBLE\\" >>> stable_rearrange(\\"a\\") \\"a\\" >>> stable_rearrange(\\"aaa\\") \\"IMPOSSIBLE\\" >>> stable_rearrange(\\"aabbcc\\") in {\\"abcabc\\", \\"acbacb\\", \\"bacabc\\", \\"bcaacb\\", \\"cabacb\\", \\"cabcab\\"} >>> stable_rearrange(\\"abcdef\\") in {\\"abcdef\\"} >>> rearranged = stable_rearrange(\\"abb\\") rearranged[0] != rearranged[1] and rearranged[1] != rearranged[2]","solution":"from heapq import heappop, heappush from collections import Counter def stable_rearrange(s): # Count frequency of each character freq = Counter(s) # Create a max heap based on character frequency (negative for max heap) max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) result = [] prev_count, prev_char = 0, '' while max_heap: count, char = heappop(max_heap) result.append(char) # Since we used one instance of \`char\`, decrement the count if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 prev_char = char result_str = ''.join(result) if len(result_str) != len(s): return \\"IMPOSSIBLE\\" return result_str"},{"question":"def sum_nested_list(nested_list): Returns the sum of all integers in a nested list. Example usage: >>> sum_nested_list([1, 2, 3]) 6 >>> sum_nested_list([1, 2, [3, 4], [5, [6, 7]]]) 28 >>> sum_nested_list([[1], [2, [3, 4], [5, [6, 7]], 8], 9]) 45 >>> sum_nested_list([]) 0 >>> sum_nested_list([[], []]) 0 >>> sum_nested_list([[[5]]]) 5 >>> sum_nested_list([1, [2, [3], 4], 5, [6, [7, 8], 9], 10]) 55 >>> sum_nested_list([1, 2, [3, 4, [5, [6, 1000000000]]]]) 1000000021","solution":"def sum_nested_list(nested_list): Returns the sum of all integers in a nested list. total = 0 for element in nested_list: if isinstance(element, list): total += sum_nested_list(element) else: total += element return total"},{"question":"def smallest_non_negative_integer_to_make_elements_distinct(n: int, a: List[int]) -> int: Find the smallest non-negative integer that can be used to replace any element in the array to ensure all elements are distinct. >>> smallest_non_negative_integer_to_make_elements_distinct(5, [1, 2, 2, 3, 4]) 0 >>> smallest_non_negative_integer_to_make_elements_distinct(5, [0, 1, 2, 3, 4]) 5 >>> smallest_non_negative_integer_to_make_elements_distinct(6, [0, 1, 2, 3, 5, 5]) 4 >>> smallest_non_negative_integer_to_make_elements_distinct(5, [10, 20, 30, 40, 50]) 0 >>> smallest_non_negative_integer_to_make_elements_distinct(6, [1, 1, 1, 2, 2, 2]) 0 >>> smallest_non_negative_integer_to_make_elements_distinct(1, [0]) 1 >>> smallest_non_negative_integer_to_make_elements_distinct(3, [1000000000, 1000000000, 1]) 0","solution":"def smallest_non_negative_integer_to_make_elements_distinct(n, a): Function to find the smallest non-negative integer that can be used to replace any element in the array to ensure all elements are distinct. # Creating a set for the elements in the list to get distinct elements element_set = set(a) # Starting from 0, find the smallest non-negative integer not in the set m = 0 while m in element_set: m += 1 return m"},{"question":"def fib_word(n: int) -> str: Returns the n-th Fibonacci Word. Parameters: n (int): The index of the Fibonacci Word to generate. Returns: str: The n-th Fibonacci Word. Examples: >>> fib_word(0) '0' >>> fib_word(1) '01' >>> fib_word(2) '010' >>> fib_word(3) '01001' >>> fib_word(4) '01001010'","solution":"def fib_word(n): Returns the n-th Fibonacci Word. Parameters: n (int): The index of the Fibonacci Word to generate. Returns: str: The n-th Fibonacci Word. if n == 0: return \\"0\\" elif n == 1: return \\"01\\" a, b = \\"0\\", \\"01\\" for i in range(2, n + 1): a, b = b, b + a return b"},{"question":"def maximal_occurrences(s: str) -> tuple: Given a string, find the character that appears the most frequently. Return the character and its count as a tuple. If there are multiple characters with the same highest frequency, return the character that comes first in alphabetical order. Consider only the alphabetical characters (a-z and A-Z) and ignore case (i.e., 'A' and 'a' should be considered the same character). Non-alphabetical characters should be ignored. >>> maximal_occurrences(\\"aabbCC\\") ('a', 2) >>> maximal_occurrences(\\"Hello, World!\\") ('l', 3) >>> maximal_occurrences(\\"12345\\") None","solution":"def maximal_occurrences(s): from collections import Counter import string # Normalize the string to lowercase and filter only alphabetical characters normalized_str = ''.join(c for c in s.lower() if c in string.ascii_lowercase) # If there are no alphabetical characters, return None if not normalized_str: return None # Count the occurrences of each character counts = Counter(normalized_str) # Find the character with the maximum frequency. If there's a tie, min will select alphabetically first one. max_char = min([char for char in counts if counts[char] == max(counts.values())]) return (max_char, counts[max_char])"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Returns the area of the largest rectangle that can be formed within the skyline profile. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> largestRectangleArea([2, 4]) == 4","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can fit in the skyline profile given by heights. stack = [] max_area = 0 index = 0 while index < len(heights): # Push current building index to stack if building is not smaller than the building at stack top if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top height top_of_stack = stack.pop() # Calculate area with heights[top_of_stack] as the smallest height area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) # Now pop the remaining buildings from stack and calculate area while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"def min_max_pair_diff(nums: List[int]) -> int: Finds the minimum possible maximum difference between smallest and largest elements in each pair when the array is divided into pairs. >>> min_max_pair_diff([1, 3, 6, 19, 20, 22]) 2 >>> min_max_pair_diff([4, 7, 10, 12, 15, 20]) 2 >>> min_max_pair_diff([1, 2, 3, 4, 5, 6]) 1","solution":"def min_max_pair_diff(nums): Finds the minimum possible maximum difference between smallest and largest elements in each pair when the array is divided into pairs. n = len(nums) nums.sort() # Ensure the array is sorted in non-decreasing order min_max_diff = float('inf') for i in range(0, n, 2): # Step through the array in increments of 2 diff = nums[i+1] - nums[i] # Calculate the difference between the pair min_max_diff = min(min_max_diff, diff) return min_max_diff"},{"question":"def length_of_lis(arr): Given an array of integers, returns the length of the longest increasing subsequence. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> length_of_lis([]) 0 >>> length_of_lis([1]) 1 >>> length_of_lis([5, 8, 3, 7, 9, 1]) 3 >>> length_of_lis([2, 2, 2, 2, 2]) 1","solution":"def length_of_lis(arr): Given an array of integers, returns the length of the longest increasing subsequence. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will be the length of the longest increasing subsequence ending at i for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage: # arr = [10, 9, 2, 5, 3, 7, 101, 18] # print(length_of_lis(arr)) # Output: 4"},{"question":"def min_time_to_complete_tasks(N, M, tasks): Given the number of developers N and the list of tasks with their respective time requirements, determine the minimum amount of time required to complete all tasks. >>> min_time_to_complete_tasks(3, 5, [2, 14, 4, 16, 6]) == 16 >>> min_time_to_complete_tasks(1, 1, [10]) == 10 >>> min_time_to_complete_tasks(3, 3, [8, 5, 3]) == 8 >>> min_time_to_complete_tasks(2, 4, [1, 2, 3, 4]) == 5 >>> min_time_to_complete_tasks(2, 5, [5, 5, 5, 5, 5]) == 15 pass # Testing def test_min_time_case1(): assert min_time_to_complete_tasks(3, 5, [2, 14, 4, 16, 6]) == 16 def test_min_time_single_task(): assert min_time_to_complete_tasks(1, 1, [10]) == 10 def test_min_time_equal_tasks_and_developers(): assert min_time_to_complete_tasks(3, 3, [8, 5, 3]) == 8 def test_min_time_more_tasks_than_developers(): assert min_time_to_complete_tasks(2, 4, [1, 2, 3, 4]) == 5 # Assign 1+4 and 2+3 def test_min_time_multiple_equal_times(): assert min_time_to_complete_tasks(2, 5, [5, 5, 5, 5, 5]) == 15 # Assign 3 to one dev and 2 to the other","solution":"def min_time_to_complete_tasks(N, M, tasks): Given the number of developers N and the list of tasks with their respective time requirements, determine the minimum amount of time required to complete all tasks. from heapq import heappop, heappush # Min heap for the working times of the developers work_times = [0] * N # Assign the largest tasks first to minimize the maximum working time tasks.sort(reverse=True) for task in tasks: min_work = heappop(work_times) heappush(work_times, min_work + task) return max(work_times)"},{"question":"def first_uniq_char(s: str) -> int: Given a string consisting of lowercase English letters, find the first non-repeating character and return its index. If it does not exist, return -1. >>> first_uniq_char(\\"leetcode\\") 0 >>> first_uniq_char(\\"loveleetcode\\") 2 >>> first_uniq_char(\\"aabb\\") -1 from solution import first_uniq_char def test_first_uniq_char_example_cases(): assert first_uniq_char(\\"leetcode\\") == 0 assert first_uniq_char(\\"loveleetcode\\") == 2 assert first_uniq_char(\\"aabb\\") == -1 def test_first_uniq_char_single_char(): assert first_uniq_char(\\"x\\") == 0 assert first_uniq_char(\\"z\\") == 0 def test_first_uniq_char_no_unique_char(): assert first_uniq_char(\\"aabbccddeeff\\") == -1 def test_first_uniq_char_all_unique_chars(): assert first_uniq_char(\\"abcde\\") == 0 assert first_uniq_char(\\"abcdefghijklmnopqrstuvwxyz\\") == 0 def test_first_uniq_char_long_string(): long_string = \\"a\\" * 100000 + \\"b\\" assert first_uniq_char(long_string) == 100000","solution":"def first_uniq_char(s): Returns the index of the first non-repeating character in the string s. If there is no non-repeating character, return -1. # Dictionary to store frequency of each character char_count = {} # Pass 1: Count the frequency of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Pass 2: Find the index of the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index # If no non-repeating character is found, return -1 return -1"},{"question":"def min_operations_to_transform(S: str, T: str) -> int: Calculate the minimum number of operations required to transform string S into string T. >>> min_operations_to_transform(\\"abc\\", \\"def\\") 3 >>> min_operations_to_transform(\\"hello\\", \\"world\\") 4 >>> min_operations_to_transform(\\"abcdef\\", \\"abcxyz\\") 3 >>> min_operations_to_transform(\\"test\\", \\"tent\\") 1 >>> min_operations_to_transform(\\"same\\", \\"same\\") 0 pass def handle_multiple_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Given a list of test cases where each test case is a tuple of two strings, returns a list of the minimum number of operations required for each test case to transform the first string into the second string. >>> handle_multiple_cases([(\\"abc\\", \\"def\\"), (\\"hello\\", \\"world\\"), (\\"abcdef\\", \\"abcxyz\\")]) [3, 4, 3] >>> handle_multiple_cases([(\\"a\\", \\"a\\")]) [0] >>> handle_multiple_cases([(\\"a\\", \\"b\\")]) [1] >>> handle_multiple_cases([]) [] pass","solution":"def min_operations_to_transform(S, T): Calculate the minimum number of operations required to transform string S into string T. if len(S) != len(T): raise ValueError(\\"Strings S and T must be of the same length\\") operations_count = 0 for s_char, t_char in zip(S, T): if s_char != t_char: operations_count += 1 return operations_count def handle_multiple_cases(test_cases): results = [] for S, T in test_cases: result = min_operations_to_transform(S, T) results.append(result) return results # Wrapper function to read input and call the solution function def main(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) test_cases = [tuple(line.split()) for line in data[1:T+1]] results = handle_multiple_cases(test_cases) for result in results: print(result)"},{"question":"def minimize_height_difference(n: int, heights: List[int]) -> List[int]: Rearranges the students such that the difference in height between any two adjacent students is minimized. Args: n (int): The number of students. heights (List[int]): The heights of the students. Returns: List[int]: The rearranged list of heights. >>> minimize_height_difference(5, [4, 2, 1, 3, 8]) == [1, 2, 3, 4, 8] >>> minimize_height_difference(7, [10, 1, 9, 6, 2, 4, 3]) == [1, 2, 3, 4, 6, 9, 10] >>> minimize_height_difference(1, [5]) == [5] >>> minimize_height_difference(4, [7, 7, 7, 7]) == [7, 7, 7, 7] >>> minimize_height_difference(3, [1, 2, 3]) == [1, 2, 3] >>> minimize_height_difference(3, [3, 2, 1]) == [1, 2, 3] pass","solution":"def minimize_height_difference(n, heights): Rearranges the students such that the difference in height between any two adjacent students is minimized. sorted_heights = sorted(heights) return sorted_heights"},{"question":"def minimize_max_difference(arr): Sorts the array such that the maximum difference between any two consecutive elements in the sorted array is minimized. >>> minimize_max_difference([4, 2, 1, 3]) [1, 2, 3, 4] >>> minimize_max_difference([10, 1, 5, 3]) [1, 3, 5, 10] >>> minimize_max_difference([1, 10, 2, 9]) [1, 2, 9, 10]","solution":"def minimize_max_difference(arr): Sorts the array such that the maximum difference between any two consecutive elements in the sorted array is minimized. return sorted(arr)"},{"question":"def numberToWords(num: int) -> str: Converts a non-negative integer less than 1000 to its English words representation. >>> numberToWords(0) \\"zero\\" >>> numberToWords(5) \\"five\\" >>> numberToWords(13) \\"thirteen\\" >>> numberToWords(85) \\"eighty-five\\" >>> numberToWords(100) \\"one hundred\\" >>> numberToWords(342) \\"three hundred forty-two\\" >>> numberToWords(999) \\"nine hundred ninety-nine\\"","solution":"def numberToWords(num): if num == 0: return \\"zero\\" below_20 = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] def words(n): if n < 20: return below_20[n] elif n < 100: return tens[n // 10] + (\\"-\\" + below_20[n % 10] if (n % 10 != 0) else \\"\\") else: return below_20[n // 100] + \\" hundred\\" + (\\" \\" + words(n % 100) if (n % 100 != 0) else \\"\\") return words(num)"},{"question":"def longest_non_decreasing_sequence(m: int, fields: List[int]) -> int: Find the length of the longest non-decreasing sequence of fields after replanting at most one plant. >>> longest_non_decreasing_sequence(6, [3, 1, 2, 4, 3, 5]) 4 >>> longest_non_decreasing_sequence(1, [7]) 1 >>> longest_non_decreasing_sequence(5, [1, 1, 1, 1, 1]) 5 >>> longest_non_decreasing_sequence(4, [5, 3, 4, 2]) 2 >>> longest_non_decreasing_sequence(6, [3, 4, 2, 5, 1, 6]) 3 >>> longest_non_decreasing_sequence(7, [10, 5, 5, 5, 5, 7, 8]) 6","solution":"def longest_non_decreasing_sequence(m, fields): if m == 1: return 1 max_len = 0 current_len = 1 modified = [0] * m for i in range(1, m): if fields[i] >= fields[i - 1]: current_len += 1 else: current_len = 1 modified[i] = current_len max_len = max(modified) for j in range(1, m): if fields[j] < fields[j - 1]: if j > 1 and fields[j - 2] <= fields[j]: max_len = max(max_len, modified[j - 2] + 1) if j < m - 1 and fields[j - 1] <= fields[j + 1]: max_len = max(max_len, modified[j - 1] + 1) return max_len"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in s. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in s. n = len(s) if n == 0: return 0 # Create a table to store results of subproblems dp = [[False for _ in range(n)] for __ in range(n)] max_length = 1 # At least every single character is a palindrome # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: max_length = length start = i return max_length"},{"question":"def is_match(s: str, p: str) -> bool: Given a word s and a pattern p, determine if the pattern matches the entire word. The pattern includes '.' which matches any single character and '*' which matches zero or more of the preceding element. >>> is_match(\\"aa\\", \\"a*\\") True >>> is_match(\\"ab\\", \\".*\\") True >>> is_match(\\"aab\\", \\"c*a*b\\") True >>> is_match(\\"mississippi\\", \\"mis*is*p*.\\") False","solution":"def is_match(s: str, p: str) -> bool: Given a word s and a pattern p, determine if the pattern matches the entire word. The pattern includes '.' which matches any single character and '*' which matches zero or more of the preceding element. # Initialize a 2D DP table with False values dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Empty string matches with empty pattern # Handle cases where the pattern contains '*' at the beginning for j in range(1, len(p) + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 2] # Fill the DP table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == '.': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == '*': dp[i][j] = dp[i][j - 2] # Consider '*' matches zero characters if p[j - 2] == s[i - 1] or p[j - 2] == '.': dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"from typing import List, Dict def update_books(logs: List[str]) -> Dict[str, int]: Update the library's book inventory based on a list of borrow and return logs. Args: logs: A list of strings representing borrow and return events. Returns: A dictionary representing the current inventory of books. The key is a string in the format \\"<book_title> by <author_name>\\", and the value is an integer indicating: - Positive numbers -> copies available in the library. - Negative numbers -> copies currently borrowed. >>> update_books([ 'borrowed \\"The Catcher in the Rye\\" by J.D. Salinger', 'borrowed \\"To Kill a Mockingbird\\" by Harper Lee', 'returned \\"The Catcher in the Rye\\" by J.D. Salinger', 'borrowed \\"1984\\" by George Orwell' ]) { 'The Catcher in the Rye by J.D. Salinger': 1, 'To Kill a Mockingbird by Harper Lee': -1, '1984 by George Orwell': -1 }","solution":"from typing import List, Dict def update_books(logs: List[str]) -> Dict[str, int]: inventory = {} for log in logs: action, details = log.split(\\" \\", 1) title, author = details.split('\\" by ') title = title.strip('\\"') author = author.strip() book_key = f'{title} by {author}' if action == \\"borrowed\\": inventory[book_key] = inventory.get(book_key, 0) - 1 elif action == \\"returned\\": inventory[book_key] = inventory.get(book_key, 0) + 1 return inventory"},{"question":"def reverseWords(sentence: str) -> str: Returns the sentence with the order of words reversed. >>> reverseWords(\\"Hello world this is a test\\") \\"test a is this world Hello\\" >>> reverseWords(\\"Hello world\\") \\"world Hello\\" >>> reverseWords(\\"Hello\\") \\"Hello\\" >>> reverseWords(\\"\\") \\"\\" >>> reverseWords(\\" Leading and trailing spaces \\") \\"spaces trailing and Leading\\"","solution":"def reverseWords(sentence): Returns the sentence with the order of words reversed. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Write a function that takes an array of integers and returns the length of the longest contiguous subsequence where the difference between consecutive elements is exactly 1. >>> longest_consecutive_subsequence([1, 2, 3, 4, 5, 6]) 6 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5, 6, 9, 10, 11]) 6 >>> longest_consecutive_subsequence([1, 2, 3, 7, 8, 9, 10, 1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence([10, 20, 30, 40, 50]) 1 >>> longest_consecutive_subsequence([100]) 1 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([-2, -1, 0, 1, 2]) 5 >>> longest_consecutive_subsequence([1, 1, 2, 2, 3, 4, 4, 5]) 3","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest contiguous subsequence where the difference between consecutive elements is exactly 1. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] - arr[i - 1] == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def numDecodings(s: str) -> int: Calculates the total number of ways to decode a given string containing only digits. Each digit or group of digits can be decoded based on the mapping '1' -> 'A', ..., '26' -> 'Z'. >>> numDecodings(\\"123\\") 3 >>> numDecodings(\\"06\\") 0 Examples: - '123' can be decoded as \\"ABC\\", \\"LC\\", or \\"AW\\". - '226' can be decoded as \\"BZ\\", \\"VF\\", or \\"BBF\\".","solution":"def numDecodings(s: str) -> int: if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and '10' <= s[i - 2:i] <= '26': dp[i] += dp[i - 2] return dp[n]"},{"question":"def inverse_word_order(sentence: str) -> str: Rearrange the words in the sentence in the reverse order of their appearance. >>> inverse_word_order(\\"hello\\") \\"hello\\" >>> inverse_word_order(\\"hello world\\") \\"world hello\\" >>> inverse_word_order(\\"the quick brown fox\\") \\"fox brown quick the\\" >>> inverse_word_order(\\"the quick brown fox jumps over the lazy dog\\") \\"dog lazy the over jumps fox brown quick the\\" >>> inverse_word_order(\\"Hello, world!\\") \\"world! Hello,\\" >>> inverse_word_order(\\"this this can can can happen happen\\") \\"happen happen can can can this this\\"","solution":"def inverse_word_order(sentence): Returns the sentence with its words in the reverse order. Parameters: sentence (str): A string containing words separated by spaces. Returns: str: A string with the words in the reverse order, maintaining the same spacing. # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a single string separated by spaces reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"import math from typing import List def generate_sequence(n: int) -> List[int]: Generates the sequence for a given number n, where the 1st and 2nd elements are 1 and from the 3rd element onwards, each element is the factorial of its position. def process_test_cases(tc: List[int]) -> List[List[int]]: Processes the list of test cases and generates the sequences for each test case. # Test cases def test_generate_sequence(): assert generate_sequence(1) == [1] assert generate_sequence(2) == [1, 1] assert generate_sequence(3) == [1, 1, 2] assert generate_sequence(4) == [1, 1, 2, 6] assert generate_sequence(5) == [1, 1, 2, 6, 24] assert generate_sequence(6) == [1, 1, 2, 6, 24, 120] def test_process_test_cases(): assert process_test_cases([1, 2, 3]) == [[1], [1, 1], [1, 1, 2]] assert process_test_cases([3, 4]) == [[1, 1, 2], [1, 1, 2, 6]] assert process_test_cases([5, 6]) == [[1, 1, 2, 6, 24], [1, 1, 2, 6, 24, 120]] assert process_test_cases([2, 2, 2]) == [[1, 1], [1, 1], [1, 1]]","solution":"import math def generate_sequence(n): Generates the sequence for a given number n, where the 1st and 2nd elements are 1 and from the 3rd element onwards, each element is the factorial of its position. sequence = [] for i in range(1, n+1): if i <= 2: sequence.append(1) else: sequence.append(math.factorial(i-1)) return sequence def process_test_cases(tc): results = [] for n in tc: results.append(generate_sequence(n)) return results"},{"question":"from typing import List def largest_rectangle(histogram: List[int]) -> int: Find the largest rectangular area that can be formed inside a histogram. >>> largest_rectangle([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largest_rectangle(histogram): Find the largest rectangle area in a histogram. :param histogram: List[int] - List of non-negative integers representing histogram bar heights. :return: int - The area of the largest rectangle that can be formed within the bins of the histogram. stack = [] max_area = 0 index = 0 while index < len(histogram): # If this bar is higher than the bar at stack's top, push it to the stack if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with histogram[top_of_stack] stack as the smallest (or minimum height) bar 'h' area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now pop the remaining bars from stack and calculate area while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def filter_words(words: List[str], character: str) -> List[str]: Returns an array of words from the input list that start with the given character (case insensitive). >>> filter_words(['apple', 'banana', 'apricot', 'blueberry', 'cherry'], 'a') ['apple', 'apricot'] >>> filter_words(['apple', 'banana', 'Apricot', 'Blueberry', 'cherry'], 'B') ['banana', 'Blueberry'] # Your code goes here","solution":"def filter_words(words, character): Returns an array of words from the input list that start with the given character (case insensitive). return [word for word in words if word.lower().startswith(character.lower())]"},{"question":"def construct_grid(t: int, dimensions: List[Tuple[int, int]]) -> str: Construct an n x m grid such that the sum of elements in each row is equal to the sum of elements in each column. Args: t (int): Number of test cases. dimensions (List[Tuple[int, int]]): A list of tuples with dimensions (n, m). Returns: str: \\"YES\\" and the constructed grid if possible, \\"NO\\" otherwise. Example: >>> construct_grid(1, [(3, 3)]) \\"YESn1 1 1n1 1 1n1 1 1\\" >>> construct_grid(1, [(2, 2)]) \\"YESn1 1n1 1\\"","solution":"def construct_grid(t, dimensions): results = [] for n, m in dimensions: # we can always construct a grid where each element is 1, which satisfies the sum condition grid = [[1] * m for _ in range(n)] result_str = \\"YESn\\" + \\"n\\".join(\\" \\".join(map(str, row)) for row in grid) results.append(result_str) return \\"n\\".join(results) # Read input in the format of test cases and dimensions (for actual implementation) # t = int(input()) # dimensions = [tuple(map(int, input().split())) for _ in range(t)] # output = construct_grid(t, dimensions) # print(output)"},{"question":"def findUniqueElement(arr): Returns the element that appears only once in the array. Args: arr (list of int): The array of integers where every element appears twice except for one. Returns: int: The unique element that appears only once. Examples: >>> findUniqueElement([2, 2, 1]) 1 >>> findUniqueElement([4, 1, 2, 1, 2]) 4 >>> findUniqueElement([1]) 1","solution":"def findUniqueElement(arr): Returns the element that appears only once in the array. Args: arr (list of int): The array of integers where every element appears twice except for one. Returns: int: The unique element that appears only once. unique = 0 for num in arr: unique ^= num return unique"},{"question":"def longest_increasing_subsequence(lst: List[int]) -> int: Returns the length of the longest increasing subsequence. Args: lst: List of integers. Returns: Integer representing the length of the longest increasing subsequence. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([5, 5, 5, 5, 5]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6]) 6 >>> longest_increasing_subsequence([6, 5, 4, 3, 2, 1]) 1","solution":"def longest_increasing_subsequence(lst): Returns the length of the longest increasing subsequence. Args: lst: List of integers. Returns: Integer representing the length of the longest increasing subsequence. if not lst: return 0 n = len(lst) lis = [1] * n for i in range(1, n): for j in range(0, i): if lst[i] > lst[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def rotate_array(arr: List[int], steps: int) -> List[int]: Rotates the elements of a list to the right by the given number of steps. Args: arr (list of int): The list to be rotated. steps (int): The number of steps to rotate the array. Returns: list of int: The rotated list. >>> rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3], 5) == [2, 3, 1] >>> rotate_array([7, 9, 11], 0) == [7, 9, 11] >>> rotate_array([], 3) == []","solution":"def rotate_array(arr, steps): Rotates the elements of a list to the right by the given number of steps. Args: arr (list of int): The list to be rotated. steps (int): The number of steps to rotate the array. Returns: list of int: The rotated list. if not arr: return [] n = len(arr) steps = steps % n # To handle cases where steps > len(arr) return arr[-steps:] + arr[:-steps]"},{"question":"def square_and_remove_duplicates(lst: List[int]) -> List[int]: Given a list of integers, returns a list with the squares of the original integers, but with any duplicate values removed. The order of numbers in the output list will be the same as their first occurrence in the input list. :param lst: List of integers :return: List of squared integers with duplicates removed pass # Test cases def test_square_and_remove_duplicates(): assert square_and_remove_duplicates([4, 5, 9, 10, 4, 5, 9]) == [16, 25, 81, 100] assert square_and_remove_duplicates([1, 2, 2, 3, 1, 3, 4]) == [1, 4, 9, 16] assert square_and_remove_duplicates([]) == [] assert square_and_remove_duplicates([2, 2, 2]) == [4] assert square_and_remove_duplicates([0, -1, -1, 2, -2]) == [0, 1, 4] def test_square_and_remove_duplicates_single_element(): assert square_and_remove_duplicates([7]) == [49] def test_square_and_remove_duplicates_no_duplicates(): assert square_and_remove_duplicates([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25]","solution":"def square_and_remove_duplicates(lst): Returns a list of the squares of integers in the input list, with duplicate values removed, preserving the order of first occurrence. :param lst: List of integers :return: List of squared integers with duplicates removed seen = set() result = [] for num in lst: sq = num * num if sq not in seen: seen.add(sq) result.append(sq) return result"},{"question":"from typing import List, Tuple def minimum_rows(boxes: List[Tuple[int, int, str]], row_capacity: int) -> int: Determine the minimum number of rows required to store all boxes while satisfying the constraints. - All boxes of the same category must be in the same row. - No row should exceed its capacity. >>> minimum_rows([(1, 3, 'A'), (2, 4, 'A'), (3, 2, 'B'), (4, 1, 'B'), (5, 5, 'C')], 6) 3 >>> minimum_rows([(1, 2, 'A'), (2, 2, 'A'), (3, 2, 'A'), (4, 2, 'A'), (5, 2, 'A'), (6, 2, 'A')], 4) 3 pass def test_example_1(): boxes = [(1, 3, 'A'), (2, 4, 'A'), (3, 2, 'B'), (4, 1, 'B'), (5, 5, 'C')] row_capacity = 6 assert minimum_rows(boxes, row_capacity) == 4 def test_example_2(): boxes = [(1, 2, 'A'), (2, 2, 'A'), (3, 2, 'A'), (4, 2, 'A'), (5, 2, 'A'), (6, 2, 'A')] row_capacity = 4 assert minimum_rows(boxes, row_capacity) == 3 def test_single_category_fits_in_one_row(): boxes = [(1, 1, 'A'), (2, 2, 'A'), (3, 2, 'A')] row_capacity = 5 assert minimum_rows(boxes, row_capacity) == 1 def test_single_category_multiple_rows(): boxes = [(1, 3, 'A'), (2, 4, 'A'), (3, 2, 'A')] row_capacity = 5 assert minimum_rows(boxes, row_capacity) == 2 def test_multiple_categories(): boxes = [(1, 3, 'A'), (2, 4, 'B'), (3, 2, 'C'), (4, 1, 'A'), (5, 5, 'B'), (6, 3, 'C')] row_capacity = 6 assert minimum_rows(boxes, row_capacity) == 4 def test_boxes_with_exact_fit(): boxes = [(1, 1, 'A'), (2, 2, 'B'), (3, 3, 'C'), (4, 4, 'D')] row_capacity = 10 assert minimum_rows(boxes, row_capacity) == 4 def test_large_input_efficiency(): # Create a large test case with 10**5 boxes in a single category, each with size 1 boxes = [(i, 1, 'A') for i in range(1, 100001)] row_capacity = 1000 assert minimum_rows(boxes, row_capacity) == 100","solution":"from typing import List, Tuple from collections import defaultdict def minimum_rows(boxes: List[Tuple[int, int, str]], row_capacity: int) -> int: Determine the minimum number of rows required to store all boxes while satisfying the constraints. - All boxes of the same category must be in the same row. - No row should exceed its capacity. # Create a dictionary to group the size of boxes by their category category_sizes = defaultdict(list) for ID, size, category in boxes: category_sizes[category].append(size) min_rows = 0 # For each category, determine the number of rows needed for sizes in category_sizes.values(): sizes.sort() # Sort the sizes to facilitate packing rows efficiently current_capacity = 0 for size in sizes: if current_capacity + size > row_capacity: # If adding this size exceeds row capacity, start a new row min_rows += 1 current_capacity = size else: current_capacity += size if current_capacity > 0: min_rows += 1 # Count the last row if it has any boxes return min_rows"},{"question":"from typing import List def singleNumber(nums: List[int]) -> int: Given an integer array \`nums\` where each integer appears exactly three times except for one integer which appears only once, find and return the single instance integer. You must implement a solution with a linear runtime complexity and use only constant extra space. >>> singleNumber([2, 2, 3, 2]) 3 >>> singleNumber([0, 1, 0, 1, 0, 1, 99]) 99 >>> singleNumber([-1, -1, -1, -2]) -2 pass","solution":"def singleNumber(nums): Returns the single instance integer in the list of integers \`nums\` where each integer appears exactly three times except for one integer which appears only once. ones, twos = 0, 0 for num in nums: # \`twos\` holds the num that appears twice twos |= ones & num # \`ones\` holds the num that appears once ones ^= num # \`threes\` holds the num appeared three times threes = ones & twos # if num appeared three times # remove it ones &= ~threes twos &= ~threes return ones"},{"question":"def generate_flower_bed_pattern(T: int, test_cases: List[int]) -> str: Generate triangular patterns of flowers for given number of rows. Parameters: T (int): Number of test cases. test_cases (list of int): List of integers where each integer represents the number of rows. Returns: list of str: List of flower bed patterns where each pattern is separated by a blank line. >>> generate_flower_bed_pattern(1, [3]) == \\"*n**n***\\" >>> generate_flower_bed_pattern(2, [3, 4]) == \\"*n**n***nn*n**n***n****\\" >>> generate_flower_bed_pattern(1, [1]) == \\"*\\" >>> max_pattern = 'n'.join('*' * i for i in range(1, 21)) >>> generate_flower_bed_pattern(1, [20]) == max_pattern >>> generate_flower_bed_pattern(3, [1, 2, 3]) == \\"*nn*n**nn*n**n***\\"","solution":"def generate_flower_bed_pattern(T, test_cases): Generate triangular patterns of flowers for given number of rows. Parameters: T (int): Number of test cases. test_cases (list of int): List of integers where each integer represents the number of rows. Returns: list of str: List of flower bed patterns where each pattern is separated by a blank line. results = [] for N in test_cases: pattern = [] for i in range(1, N+1): pattern.append('*' * i) results.append('n'.join(pattern)) return 'nn'.join(results)"},{"question":"def most_frequent_integer(nums: List[int]) -> int: Returns the integer that appears most frequently. If there are multiple integers with the same highest frequency, returns the smallest one. Parameters: nums (list): A list of integers. Returns: int: The integer that appears most frequently, or the smallest one if there is a tie. >>> most_frequent_integer([1, 3, 2, 2, 4, 3, 3]) 3 >>> most_frequent_integer([1, 1, 2, 2]) 1 >>> most_frequent_integer([5, 5, 5, 1, 1, 1]) 1 >>> most_frequent_integer([7]) 7","solution":"def most_frequent_integer(nums): Returns the integer that appears most frequently. If there are multiple integers with the same highest frequency, returns the smallest one. Parameters: nums (list): A list of integers. Returns: int: The integer that appears most frequently, or the smallest one if there is a tie. from collections import Counter count = Counter(nums) max_frequency = max(count.values()) # Return the smallest integer among those with the maximum frequency return min(key for key, value in count.items() if value == max_frequency)"},{"question":"def max_profit(prices: List[int]) -> int: Calculates the maximum possible profit from a single buy-sell transaction. Args: prices (list of int): List of stock prices where each element is the stock price on a given day. Returns: int: The maximum profit possible. If no profit is possible, returns 0. Example: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 from solution import max_profit def test_example_cases(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 def test_single_day(): assert max_profit([5]) == 0 def test_empty_list(): assert max_profit([]) == 0 def test_no_profit_possible(): assert max_profit([5, 4, 3, 2, 1]) == 0 def test_all_times_high(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_min_max_same_day(): assert max_profit([2, 1, 2, 0, 1]) == 1 assert max_profit([5, 5, 5, 5, 5]) == 0 assert max_profit([1, 2, 3, 4, 1, 4, 7, 2, 5]) == 6","solution":"def max_profit(prices): Calculates the maximum possible profit from a single buy-sell transaction. Args: prices (list of int): List of stock prices where each element is the stock price on a given day. Returns: int: The maximum profit possible. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"def does_route_return_to_start(routes: List[str]) -> List[str]: Determines if the given routes form a closed loop returning to the start. Parameters: routes (list of str): A list of strings representing the routes taken by scouts. Returns: list of str: A list of \\"Yes\\" or \\"No\\" indicating if each route forms a closed loop. >>> does_route_return_to_start(['NESW']) [\\"Yes\\"] >>> does_route_return_to_start(['NNESWW']) [\\"No\\"] >>> does_route_return_to_start(['NESW', 'NNESWW', '']) [\\"Yes\\", \\"No\\", \\"Yes\\"] from solution import does_route_return_to_start # Import statement for testing def test_single_closed_loop_route(): assert does_route_return_to_start(['NESW']) == [\\"Yes\\"] def test_single_not_closed_loop_route(): assert does_route_return_to_start(['NNESWW']) == [\\"No\\"] def test_multiple_routes(): assert does_route_return_to_start(['NESW', 'NNESWW', '']) == [\\"Yes\\", \\"No\\", \\"Yes\\"] def test_long_route(): assert does_route_return_to_start(['N' * 50000 + 'S' * 50000]) == [\\"Yes\\"] def test_another_long_route(): assert does_route_return_to_start(['N' * 50000 + 'S' * 49999 + 'E']) == [\\"No\\"] def test_empty_route(): assert does_route_return_to_start(['']) == [\\"Yes\\"] def test_balanced_directions(): assert does_route_return_to_start(['NSEW']) == [\\"Yes\\"]","solution":"def does_route_return_to_start(routes): Determines if the given routes form a closed loop returning to the start. Parameters: routes (list of str): A list of strings representing the routes taken by scouts. Returns: list of str: A list of \\"Yes\\" or \\"No\\" indicating if each route forms a closed loop. results = [] for route in routes: x, y = 0, 0 for move in route: if move == 'N': y += 1 elif move == 'S': y -= 1 elif move == 'E': x += 1 elif move == 'W': x -= 1 if x == 0 and y == 0: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def max_overlap_trips(n: int, trips: List[Tuple[int, int]]) -> int: Find the maximum number of overlapping trips at any point in time. >>> max_overlap_trips(5, [(1, 5), (2, 6), (4, 7), (3, 8), (5, 9)]) 4 >>> max_overlap_trips(3, [(1, 2), (3, 4), (5, 6)]) 1 >>> max_overlap_trips(4, [(1, 4), (1, 4), (1, 4), (1, 4)]) 4 >>> max_overlap_trips(3, [(1, 10), (2, 3), (4, 5)]) 2 >>> max_overlap_trips(4, [(1, 4), (2, 5), (5, 8), (6, 9)]) 2","solution":"def max_overlap_trips(n, trips): events = [] # Creating events for each trip's start and end for start, end in trips: events.append((start, 1)) # 1 indicates start of a trip events.append((end, -1)) # -1 indicates end of a trip # Sorting events, prioritize start (-1) before end (1) if times are equal events.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 for event in events: current_overlap += event[1] if current_overlap > max_overlap: max_overlap = current_overlap return max_overlap # Sample usage: # N = 5 # trips = [(1, 5), (2, 6), (4, 7), (3, 8), (5, 9)] # print(max_overlap_trips(N, trips)) # Output should be 4"},{"question":"def time_addition(current_time: str, minutes_to_add: int) -> str: Adds the given minutes to the current time represented in HH:MM format. The function should handle changes across midnight correctly. Args: current_time (str): The initial time in \\"HH:MM\\" format. minutes_to_add (int): The number of minutes to add, it can be positive or negative. Returns: str: The new time in \\"HH:MM\\" format. Examples: >>> time_addition(\\"14:30\\", 40) '15:10' >>> time_addition(\\"23:50\\", 20) '00:10' >>> time_addition(\\"00:30\\", -40) '23:50'","solution":"def time_addition(current_time, minutes_to_add): Adds minutes_to_add to the current_time. # Split the current time into hours and minutes hours, minutes = map(int, current_time.split(':')) # Convert everything to minutes total_minutes = hours * 60 + minutes + minutes_to_add # Adjust for overflow/underflow total_minutes = total_minutes % 1440 # Convert back to hours and minutes new_hours = total_minutes // 60 new_minutes = total_minutes % 60 return f\\"{new_hours:02d}:{new_minutes:02d}\\""},{"question":"def count_teams_with_sum_greater_than_S(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the number of unique unordered teams with a speed sum greater than S for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of test cases, where each test case contains a tuple with two integers N and S, and a list of N integers representing the speeds of participants. Returns: List[int]: A list of integers, where each integer represents the number of unique teams for the corresponding test case. Example: >>> T = 2 >>> test_cases = [((4, 5), [1, 3, 5, 7]), ((3, 8), [4, 2, 6])] >>> count_teams_with_sum_greater_than_S(T, test_cases) [5, 1]","solution":"def count_teams_with_sum_greater_than_S(T, test_cases): results = [] for t in range(T): N, S = test_cases[t][0] speeds = sorted(test_cases[t][1]) count = 0 left, right = 0, N - 1 # Use two-pointer technique to count valid teams while left < right: if speeds[left] + speeds[right] > S: count += (right - left) right -= 1 else: left += 1 results.append(count) return results"},{"question":"def combine_and_sort(arr1, arr2): Combines two arrays, removes duplicates, and returns a sorted array of unique elements. >>> combine_and_sort([4, 2, 9, 10, 2, 4], [3, 2, 8, 10, 6, 4]) [2, 3, 4, 6, 8, 9, 10] >>> combine_and_sort([4, 2, 9, 10], [3, 8, 6]) [2, 3, 4, 6, 8, 9, 10] >>> combine_and_sort([], []) [] >>> combine_and_sort([], [3, 2, 8, 10, 6, 4]) [2, 3, 4, 6, 8, 10] >>> combine_and_sort([1], [1]) [1] >>> combine_and_sort([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6]","solution":"def combine_and_sort(arr1, arr2): Combines two arrays, removes duplicates, and returns a sorted array of unique elements. # Combine both arrays and convert to a set to remove duplicates combined_set = set(arr1) | set(arr2) # Convert the set back to a sorted list sorted_list = sorted(combined_set) return sorted_list"},{"question":"def rotateMatrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given 2D matrix 90 degrees clockwise. >>> rotateMatrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([ [1, 2], [3, 4], [5, 6] ]) [[5, 3, 1], [6, 4, 2]] >>> rotateMatrix([ [1, 2, 3] ]) [[1], [2], [3]] >>> rotateMatrix([ [1], [2], [3] ]) [[3, 2, 1]] >>> rotateMatrix([]) [] >>> rotateMatrix([ [1] ]) [[1]]","solution":"def rotateMatrix(matrix): Rotates the given 2D matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The input 2D array. Returns: list of list of int: The rotated 2D array. if not matrix or not matrix[0]: return matrix rows = len(matrix) cols = len(matrix[0]) rotated_matrix = [] for col in range(cols): new_row = [] for row in range(rows - 1, -1, -1): new_row.append(matrix[row][col]) rotated_matrix.append(new_row) return rotated_matrix"},{"question":"from typing import List, Tuple def find_closest(origin: Tuple[int, int], pois: List[Tuple[str, Tuple[int, int]]]) -> str: Returns the name of the closest point of interest (POI) from the given list. Parameters: origin (Tuple[int, int]): The origin point in the form (x, y). pois (List[Tuple[str, Tuple[int, int]]]): A list of POIs where each POI is a tuple containing the name and coordinates. Returns: str: The name of the closest POI to the origin. Examples: >>> find_closest((0, 0), [(\\"Library\\", (1, 2)), (\\"Cafe\\", (2, 2)), (\\"Bookstore\\", (1, 3))]) \\"Library\\" >>> find_closest((0, 0), [(\\"Library\\", (1, 1)), (\\"Cafe\\", (1, 1))]) \\"Cafe\\" >>> find_closest((0, 0), [(\\"Library\\", (-1, -2)), (\\"Cafe\\", (-2, -2)), (\\"Bookstore\\", (-1, -3))]) \\"Library\\"","solution":"from typing import List, Tuple def find_closest(origin: Tuple[int, int], pois: List[Tuple[str, Tuple[int, int]]]) -> str: Returns the name of the closest point of interest (POI) from the given list. Parameters: origin (Tuple[int, int]): The origin point in the form (x, y). pois (List[Tuple[str, Tuple[int, int]]]): A list of POIs where each POI is a tuple containing the name and coordinates. Returns: str: The name of the closest POI to the origin. def distance_squared(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 closest_poi = min(pois, key=lambda poi: (distance_squared(origin, poi[1]), poi[0])) return closest_poi[0]"},{"question":"from typing import List def rearrange_list(n: int, a: List[int]) -> List[int]: Reorder the list by swapping two elements such that the sum of every prefix of the list is unique. Args: n (int): The size of the list. a (List[int]): The elements of the list. Returns: List[int]: The reordered list with unique prefix sums. >>> rearrange_list(3, [3, 1, 2]) [1, 3, 2] >>> rearrange_list(4, [4, 1, 3, 2]) [1, 4, 2, 3]","solution":"def rearrange_list(n, a): # Check if there's only one element which automatically satisfies the condition if n == 1: return a # Sort the list to easily generate distinct prefix sums a.sort() # Prefix sums have to be unique, sorted unique elements guarantee it. rearranged = a return rearranged"},{"question":"def sort_tasks(tasks): Returns a list of tasks sorted by priority (highest first) and date added (earliest first). Args: tasks (list of tuple): A list of tasks where each task is represented by a tuple (priority, date_added) Returns: list of tuple: Sorted list of tasks. Examples: >>> sort_tasks([(2, \\"2023-01-15\\"), (1, \\"2023-01-10\\"), (1, \\"2023-01-12\\"), (3, \\"2023-01-01\\")]) [(1, \\"2023-01-10\\"), (1, \\"2023-01-12\\"), (2, \\"2023-01-15\\"), (3, \\"2023-01-01\\")] >>> sort_tasks([(2, \\"2023-06-07\\"), (3, \\"2023-05-01\\"), (2, \\"2023-04-12\\")]) [(2, \\"2023-04-12\\"), (2, \\"2023-06-07\\"), (3, \\"2023-05-01\\")] >>> sort_tasks([(1, \\"2023-01-01\\")]) [(1, \\"2023-01-01\\")] >>> sort_tasks([(1, \\"2023-01-01\\"), (2, \\"2023-01-01\\"), (3, \\"2023-01-01\\"), (1, \\"2023-01-01\\")]) [(1, \\"2023-01-01\\"), (1, \\"2023-01-01\\"), (2, \\"2023-01-01\\"), (3, \\"2023-01-01\\")] >>> sort_tasks([]) []","solution":"def sort_tasks(tasks): Returns a list of tasks sorted by priority (highest first) and date added (earliest first). Args: tasks (list of tuple): A list of tasks where each task is represented by a tuple (priority, date_added) Returns: list of tuple: Sorted list of tasks. # Sorting the tasks with a composite key: primary key is priority (descending), secondary key is date (ascending) sorted_tasks = sorted(tasks, key=lambda task: (task[0], task[1])) return sorted_tasks"},{"question":"def max_sum_subarray(arr, k): Develop a function that takes an array of integers and an integer k, and returns the maximum sum of any subarray of size k. >>> max_sum_subarray([1, 2, 3, 4, 5, 6, 7, 8], 3) 21 >>> max_sum_subarray([1, 2, 3, -2, 5], 3) 6 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([1, 1, 1, 1, 1], 1) 1 >>> max_sum_subarray([1, 5, -3, 7, 8, -2, 4], 2) 15 >>> max_sum_subarray([1, -1, 1, -1, 1, -1, 1, -1, 1, -1], 2) 0 >>> max_sum_subarray([5, 4, 3, 2, 1], 3) 12 >>> max_sum_subarray([10], 1) 10 >>> max_sum_subarray([], 1) 0 >>> max_sum_subarray([1, 2, 3, 4, 5], 0) 0","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any subarray of size k. :param arr: List of integers :param k: Size of the subarray :return: Maximum sum of any subarray of size k if not arr or k <= 0: return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def subarray_sum(nums: List[int], target: int) -> int: Returns the number of continuous subarrays that sum up to the target. Example 1: >>> subarray_sum([1,1,1], 2) 2 Example 2: >>> subarray_sum([1,2,3], 3) 2 Example 3: >>> subarray_sum([-1,-1,1], 0) 1 Constraints: - The length of the array should be between 1 and 10^4. - The range of integer values in the array can be between -10^5 and 10^5. - The target integer can be any value within the range of -10^7 to 10^7. ...","solution":"def subarray_sum(nums, target): Returns the number of continuous subarrays that sum up to the target. count = 0 current_sum = 0 sum_dict = {0: 1} for num in nums: current_sum += num if current_sum - target in sum_dict: count += sum_dict[current_sum - target] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"def total_distance(distance_jumps: list, can_double_jump: bool) -> int: Calculate the total distance traveled by a frog in a series of jumps. Args: distance_jumps (list): A list of integers representing the distance of each jump. can_double_jump (bool): A boolean indicating if the frog can double-jump. Returns: int: The total distance traveled by the frog. Examples: >>> total_distance([5, 3, 8, 2], True) == 23 >>> total_distance([7, 4, 5, 3], False) == 19","solution":"def total_distance(distance_jumps: list, can_double_jump: bool) -> int: Calculate the total distance traveled by a frog in a series of jumps. Args: distance_jumps (list): A list of integers representing the distance of each jump. can_double_jump (bool): A boolean indicating if the frog can double-jump. Returns: int: The total distance traveled by the frog. total_distance = 0 for i in range(len(distance_jumps)): if can_double_jump and i % 2 == 1: total_distance += distance_jumps[i] * 2 else: total_distance += distance_jumps[i] return total_distance"},{"question":"def generate_palindromes(n: int) -> List[int]: Returns a list of palindromic numbers from 1 to n inclusive. >>> generate_palindromes(10) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> generate_palindromes(22) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22] >>> generate_palindromes(101) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101] >>> generate_palindromes(0) [] >>> generate_palindromes(5) [1, 2, 3, 4, 5] >>> generate_palindromes(121) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121]","solution":"def generate_palindromes(n): Returns a list of palindromic numbers from 1 to n inclusive. if n < 1: return [] palindromes = [] for num in range(1, n + 1): if str(num) == str(num)[::-1]: palindromes.append(num) return palindromes"},{"question":"def evaluate_expression(expression: str) -> int: Write a function that simulates a basic arithmetic expression evaluator. The function should accept a string containing a simple arithmetic expression with non-negative integers and the operators +, -, *, and / (integer division). The expression will not have any parentheses and the operators will perform arithmetic calculations obeying the standard operator precedence rules (*/ before +-). The function should return the result of evaluating the expression as an integer. >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"10/2-3\\") == 2 >>> evaluate_expression(\\"3+5*2-4/2\\") == 11 >>> evaluate_expression(\\"42\\") == 42 >>> evaluate_expression(\\"3*4/2*5\\") == 30 >>> evaluate_expression(\\"1+2*3-4/2+5*6/3-7\\") == 8 # Your implementation here","solution":"def evaluate_expression(expression): import re def parse_expression(expression): tokens = re.findall(r'd+|[+/*-]', expression) return tokens def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left // right) tokens = parse_expression(expression) values = [] operators = [] precedence = {'+': 1, '-': 1, '*': 2, '/': 2} for token in tokens: if token.isdigit(): values.append(int(token)) else: while (operators and precedence[operators[-1]] >= precedence[token]): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"def can_sum_to_x(test_cases: List[Dict[str, Union[int, List[int]]]]) -> List[str]: Determine if a given integer X can be expressed as the sum of two elements from an array for multiple test cases. Args: test_cases (List[Dict[str, Union[int, List[int]]]]): A list of test cases where each test case is a dictionary containing 'N', 'X', and 'A' describing the problem constraints. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case depending on whether the sum can be obtained. >>> can_sum_to_x([{'N': 5, 'X': 9, 'A': [2, 7, 11, 15, 4]}, {'N': 4, 'X': 8, 'A': [1, 2, 3, 4]}, {'N': 4, 'X': 10, 'A': [1, 2, 3, 4]}]) ['YES', 'NO', 'NO']","solution":"def can_sum_to_x(test_cases): results = [] for case in test_cases: N, X, A = case['N'], case['X'], case['A'] found = False seen = set() for number in A: if (X - number) in seen: found = True break seen.add(number) results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def calculate_final_bill(total_bill: int) -> float: Calculate the final bill amount after applying the appropriate discount. The discount categories are as follows: - If the total bill is less than 50: no discount. - If the total bill is between 50 and 100 (inclusive): 10% discount. - If the total bill is between 101 and 200 (inclusive): 20% discount. - If the total bill is more than 200: 30% discount. Parameters: total_bill (int): The total bill amount in dollars before the discount. Returns: float: The final bill amount after the discount, rounded to two decimal places. >>> calculate_final_bill(45) 45.00 >>> calculate_final_bill(75) 67.50 >>> calculate_final_bill(150) 120.00 >>> calculate_final_bill(250) 175.00","solution":"def calculate_final_bill(total_bill): Returns the final bill amount after applying the appropriate discount. Parameters: total_bill: int - The total bill amount in dollars before the discount. Returns: float - The final bill amount after the discount, rounded to two decimal places. if total_bill < 50: discount = 0 elif 50 <= total_bill <= 100: discount = 0.10 elif 101 <= total_bill <= 200: discount = 0.20 else: discount = 0.30 final_bill = total_bill * (1 - discount) return round(final_bill, 2)"},{"question":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Write a function called \`spiralOrder\` that takes a square matrix (2D list) as an input and returns a list representing the elements of the matrix traversed in a spiral order. You can assume the matrix will contain integer values only. >>> spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] pass","solution":"def spiralOrder(matrix): Returns a list of elements of the matrix traversed in a spiral order. res = [] while matrix: res += matrix.pop(0) if matrix and matrix[0]: for row in matrix: res.append(row.pop()) if matrix: res += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: res.append(row.pop(0)) return res"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be made by buying and selling the stock exactly once. If no profit can be made, returns 0. :param prices: List[int] - list of stock prices on consecutive days :return: int - maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 2]) 1 >>> max_profit([2, 1]) 0 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 4 >>> max_profit([2, 4, 1]) 2 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1, 2, 3, 4, 5]) 4","solution":"def max_profit(prices): Returns the maximum profit that can be made by buying and selling the stock exactly once. If no profit can be made, returns 0. :param prices: List[int] - list of stock prices on consecutive days :return: int - maximum profit if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def intersection(nums1: List[int], nums2: List[int]) -> List[int]: Returns an array of unique elements that are common to both nums1 and nums2. >>> intersection([1,2,2,1], [2,2]) [2] >>> intersection([4,9,5], [9,4,9,8,4]) [9, 4]","solution":"def intersection(nums1, nums2): Returns an array of unique elements that are common to both nums1 and nums2. return list(set(nums1) & set(nums2))"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree_from_input(lines): This function builds a binary tree from a list of input lines. Parameters: lines: List[str] : A list of strings representing the nodes of the binary tree. Each string contains three integers N, L, and R where: - N is the value of the node. - L is the value of the left child of the node, or -1 if there is no left child. - R is the value of the right child of the node, or -1 if there is no right child. Returns: TreeNode : The root of the binary tree. def inorder_traversal(root): This function performs an in-order traversal of the binary tree without using recursion. Parameters: root: TreeNode : The root of the binary tree. Returns: List[int] : An array of integers representing the in-order traversal of the binary tree. def binary_tree_inorder_traversal(input_lines): Build the binary tree from input lines and return the in-ordered traversal list of node values. Parameters: input_lines : List[str] : A series of lines representing the nodes of the binary tree. Returns: List[int] : An array of integers representing the in-order traversal.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree_from_input(lines): if not lines: return None nodes = {} for line in lines: N, L, R = map(int, line.split()) if N not in nodes: nodes[N] = TreeNode(N) node = nodes[N] if L != -1: if L not in nodes: nodes[L] = TreeNode(L) node.left = nodes[L] if R != -1: if R not in nodes: nodes[R] = TreeNode(R) node.right = nodes[R] return nodes[int(lines[0].split()[0])] def inorder_traversal(root): stack = [] current = root result = [] while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.value) current = current.right return result def binary_tree_inorder_traversal(input_lines): root = build_tree_from_input(input_lines) return inorder_traversal(root)"},{"question":"def unscramble(sentence: str) -> str: Unscramble the sentence based on the digit in each word. Each word in the input string will contain exactly one digit \`1-9\` that signifies its position in the original sentence. The function should remove these digits and return the words in the correct order. Args: sentence (str): A scrambled sentence with each word containing exactly one digit (1-9). Returns: str: The original sentence with words ordered by their digits and digits removed. >>> unscramble(\\"is2 Thi1s T4est 3a\\") 'This is a Test' >>> unscramble(\\"4of Fo1r pe6ople g3ood th5e the2\\") 'For the good of the people' >>> unscramble(\\"Hel1lo\\") 'Hello' >>> unscramble(\\"Hey!1 W2orld\\") 'Hey! World' >>> unscramble(\\"Hello World\\") '' >>> unscramble(\\"He12llo Th3is\\") '' >>> unscramble(\\"\\") ''","solution":"import re def unscramble(sentence): Unscramble the sentence based on the digit in each word. Args: sentence (str): A scrambled sentence with each word containing exactly one digit (1-9). Returns: str: The original sentence with words ordered by their digits and digits removed. words = sentence.split() ordered_words = [] # Create a dictionary to store words based on their position word_dict = {} for word in words: match = re.search(r'd', word) if match is None or len(re.findall(r'd', word)) != 1: return \\"\\" # if word does not contain exactly one digit position = int(match.group()) word_dict[position] = re.sub(r'd', '', word) # Sort words by their position and join into a sentence ordered_sentence = ' '.join(word_dict[pos] for pos in sorted(word_dict.keys())) return ordered_sentence"},{"question":"def isAnagram(str1: str, str2: str) -> bool: Determine if one string is an anagram of the other. >>> isAnagram(\\"listen\\", \\"silent\\") True >>> isAnagram(\\"Hello\\", \\"Olelh\\") True >>> isAnagram(\\"apple\\", \\"pale\\") False >>> isAnagram(\\"schoolmaster\\", \\"theclassroom\\") True >>> isAnagram(\\"astronomer\\", \\"moon starer\\") True from solution import isAnagram def test_is_anagram(): assert isAnagram(\\"listen\\", \\"silent\\") == True assert isAnagram(\\"Hello\\", \\"Olelh\\") == True assert isAnagram(\\"apple\\", \\"pale\\") == False assert isAnagram(\\"schoolmaster\\", \\"theclassroom\\") == True assert isAnagram(\\"astronomer\\", \\"moon starer\\") == True def test_is_anagram_case_insensitivity(): assert isAnagram(\\"Listen\\", \\"Silent\\") == True assert isAnagram(\\"Astronomer\\", \\"Moon starer\\") == True def test_is_anagram_with_spaces(): assert isAnagram(\\"a gentleman\\", \\"elegant man\\") == True assert isAnagram(\\"conversation\\", \\"voices rant on\\") == True def test_is_anagram_false_cases(): assert isAnagram(\\"hello\\", \\"bye\\") == False assert isAnagram(\\"rat\\", \\"car\\") == False assert isAnagram(\\"anagram\\", \\"nagaramm\\") == False","solution":"def isAnagram(str1, str2): Returns True if str1 is an anagram of str2, False otherwise. # Normalize the strings: Remove spaces and convert to lower case normalized_str1 = ''.join(str1.split()).lower() normalized_str2 = ''.join(str2.split()).lower() # Sort the characters and compare return sorted(normalized_str1) == sorted(normalized_str2)"},{"question":"def compress_rolls(rolls: str) -> str: You are organizing a small competition where participants roll a single six-sided die multiple times, and you want to keep track of the results in a unique way. The function compress_rolls takes a string representing the rolls of the die and returns the compressed format that displays each consecutive series of the same number in the format of \`number:count\`. >>> compress_rolls(\\"1112233\\") '1:3,2:2,3:2' >>> compress_rolls(\\"5566661\\") '5:2,6:4,1:1' >>> compress_rolls(\\"1\\") '1:1' >>> compress_rolls(\\"666\\") '6:3' >>> compress_rolls(\\"123\\") '1:1,2:1,3:1' >>> compress_rolls(\\"1112233\\") '1:3,2:2,3:2' >>> compress_rolls(\\"\\") ''","solution":"def compress_rolls(rolls: str) -> str: if not rolls: return \\"\\" result = [] current_char = rolls[0] count = 1 for char in rolls[1:]: if char == current_char: count += 1 else: result.append(f\\"{current_char}:{count}\\") current_char = char count = 1 result.append(f\\"{current_char}:{count}\\") return \\",\\".join(result)"},{"question":"def parse_and_sum(s: str) -> dict: Parses a given string consisting of pairs of words and numbers, then sums the values associated with each unique word. Parameters: s (str): The input string Returns: dict: A dictionary with words as keys and their corresponding summed values as values. >>> parse_and_sum(\\"sugar:3, salt:2, sugar:5, salt:1, pepper:4\\") == {\\"sugar\\": 8, \\"salt\\": 3, \\"pepper\\": 4} >>> parse_and_sum(\\"pen:1, pencil:1, pen:2\\") == {\\"pen\\": 3, \\"pencil\\": 1} >>> parse_and_sum(\\"apple:5, apple:5, apple:5\\") == {\\"apple\\": 15} >>> parse_and_sum(\\"orange:3\\") == {\\"orange\\": 3} >>> parse_and_sum(\\"banana:2, banana:2, grape:1, banana:1, grape:3\\") == {\\"banana\\": 5, \\"grape\\": 4} >>> parse_and_sum(\\"carrot:4, broccoli:2, spinach:1\\") == {\\"carrot\\": 4, \\"broccoli\\": 2, \\"spinach\\": 1} >>> parse_and_sum(\\"watermelon:1000, pineapple:500, watermelon:1234\\") == {\\"watermelon\\": 2234, \\"pineapple\\": 500} pass","solution":"def parse_and_sum(s: str) -> dict: Parses a given string consisting of pairs of words and numbers, then sums the values associated with each unique word. Parameters: s (str): The input string Returns: dict: A dictionary with words as keys and their corresponding summed values as values. pairs = s.split(\\", \\") result = {} for pair in pairs: word, number = pair.split(\\":\\") number = int(number) if word in result: result[word] += number else: result[word] = number return result"},{"question":"from datetime import datetime, timedelta from collections import defaultdict from typing import List, Dict def calculate_total_time(logs: List[str]) -> Dict[int, str]: Calculate the total time each employee spent inside the building. Args: logs: List of strings where each string contains an employee ID, an action, and a timestamp. Returns: A dictionary where each key is an employee ID and the value is the total time in HH:MM format. time_format = \\"%H:%M\\" employee_times = defaultdict(timedelta) enter_times = {} for log in logs: if log == \\"END\\": break emp_id, action, timestamp = log.split() emp_id = int(emp_id) timestamp = datetime.strptime(timestamp, time_format) if action == \\"enter\\": enter_times[emp_id] = timestamp elif action == \\"exit\\": if emp_id in enter_times: enter_time = enter_times.pop(emp_id) time_spent = timestamp - enter_time employee_times[emp_id] += time_spent result = {} for emp_id, total_time in sorted(employee_times.items()): hours, remainder = divmod(total_time.seconds, 3600) minutes = remainder // 60 result[emp_id] = f\\"{hours:02}:{minutes:02}\\" return result def test_example_case(): logs = [ \\"1 enter 09:00\\", \\"2 enter 09:30\\", \\"1 exit 12:00\\", \\"2 exit 13:00\\", \\"1 enter 14:00\\", \\"1 exit 17:00\\", \\"END\\" ] result = calculate_total_time(logs) assert result == {1: \\"06:00\\", 2: \\"03:30\\"} def test_single_entry_exit(): logs = [ \\"1 enter 08:00\\", \\"1 exit 10:00\\", \\"END\\" ] result = calculate_total_time(logs) assert result == {1: \\"02:00\\"} def test_multiple_intervals_same_employee(): logs = [ \\"1 enter 08:00\\", \\"1 exit 10:00\\", \\"1 enter 12:00\\", \\"1 exit 13:30\\", \\"END\\" ] result = calculate_total_time(logs) assert result == {1: \\"03:30\\"} def test_no_entries(): logs = [ \\"END\\" ] result = calculate_total_time(logs) assert result == {} def test_multiple_employees(): logs = [ \\"1 enter 08:00\\", \\"2 enter 09:00\\", \\"1 exit 10:00\\", \\"2 exit 12:00\\", \\"END\\" ] result = calculate_total_time(logs) assert result == {1: \\"02:00\\", 2: \\"03:00\\"} def test_exact_hour(): logs = [ \\"3 enter 13:00\\", \\"3 exit 15:00\\", \\"END\\" ] result = calculate_total_time(logs) assert result == {3: \\"02:00\\"}","solution":"from datetime import datetime, timedelta from collections import defaultdict def calculate_total_time(logs): Calculate the total time each employee spent inside the building. Args: logs: List of strings where each string contains an employee ID, an action, and a timestamp. Returns: A dictionary where each key is an employee ID and the value is the total time in HH:MM format. time_format = \\"%H:%M\\" employee_times = defaultdict(timedelta) enter_times = {} for log in logs: if log == \\"END\\": break emp_id, action, timestamp = log.split() emp_id = int(emp_id) timestamp = datetime.strptime(timestamp, time_format) if action == \\"enter\\": enter_times[emp_id] = timestamp elif action == \\"exit\\": if emp_id in enter_times: enter_time = enter_times.pop(emp_id) time_spent = timestamp - enter_time employee_times[emp_id] += time_spent result = {} for emp_id, total_time in sorted(employee_times.items()): hours, remainder = divmod(total_time.seconds, 3600) minutes = remainder // 60 result[emp_id] = f\\"{hours:02}:{minutes:02}\\" return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing integers and operators +, -, *, /. The expression will not contain any spaces and will always be a valid mathematical expression. Division (/) performs integer division and truncates towards zero. >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100*2+12\\") 212 >>> evaluate_expression(\\"100*(2+12)/14\\") 100 >>> evaluate_expression(\\"4*2/2+3-1\\") 6 >>> evaluate_expression(\\"2-3+5*2\\") 9 def test_evaluate_expression_simple(): assert evaluate_expression(\\"3+5/2\\") == 5 def test_evaluate_expression_with_multiplication(): assert evaluate_expression(\\"10+2*6\\") == 22 def test_evaluate_expression_complex(): assert evaluate_expression(\\"100*2+12\\") == 212 def test_evaluate_expression_with_parentheses(): assert evaluate_expression(\\"100*(2+12)/14\\") == 100 def test_evaluate_expression_multiple_operations(): assert evaluate_expression(\\"4*2/2+3-1\\") == 6 def test_evaluate_expression_with_subtraction(): assert evaluate_expression(\\"2-3+5*2\\") == 9 def test_evaluate_expression_nested_parentheses(): assert evaluate_expression(\\"2*(3+(4*5))\\") == 46 def test_evaluate_expression_division_truncation(): assert evaluate_expression(\\"7/3\\") == 2 def test_evaluate_expression_negative_result(): assert evaluate_expression(\\"5-8\\") == -3 def test_evaluate_expression_single_number(): assert evaluate_expression(\\"42\\") == 42","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string with operators +, -, *, /. Division (/) performs integer division and truncates towards zero. import re # Parsing the expression into tokens of numbers and operators tokens = re.findall(r'd+|[+*/()-]', expression) def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # integer division def precedence(operator): if operator in ('+', '-'): return 1 elif operator in ('*', '/'): return 2 return 0 values = [] operators = [] for token in tokens: if re.match(r'd+', token): values.append(int(token)) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() # pop '(' else: # operator is +, -, *, / while (operators and precedence(operators[-1]) >= precedence(token)): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"def find_longest_consecutive_substring(s: str) -> str: Find and return the longest substring made up of consecutive characters from the given string. A consecutive substring contains characters whose ASCII values increase by exactly 1 from the previous character. If the string contains only one character or does not have any consecutive characters, return the first character of the string. >>> find_longest_consecutive_substring(\\"abcdxyzab\\") == \\"abcd\\" >>> find_longest_consecutive_substring(\\"hijabcdefklmno\\") == \\"abcdef\\" >>> find_longest_consecutive_substring(\\"a\\") == \\"a\\" >>> find_longest_consecutive_substring(\\"ab\\") == \\"ab\\" >>> find_longest_consecutive_substring(\\"az\\") == \\"a\\" >>> find_longest_consecutive_substring(\\"abcdef\\") == \\"abcdef\\" >>> find_longest_consecutive_substring(\\"zyxw\\") == \\"z\\" >>> find_longest_consecutive_substring(\\"abacdfegklmn\\") == \\"klmn\\" >>> find_longest_consecutive_substring(\\"aab\\") == \\"ab\\" >>> find_longest_consecutive_substring(\\"ba\\") == \\"b\\"","solution":"def find_longest_consecutive_substring(s: str) -> str: n = len(s) if n == 0: return \\"\\" max_len = 1 current_len = 1 max_substr = s[0] current_substr = s[0] for i in range(1, n): if ord(s[i]) == ord(s[i-1]) + 1: current_len += 1 current_substr += s[i] else: if current_len > max_len: max_len = current_len max_substr = current_substr current_len = 1 current_substr = s[i] if current_len > max_len: max_substr = current_substr return max_substr"},{"question":"def reverse_sentence(sentence: str) -> str: Returns a new string with the words of the sentence in reverse order. >>> reverse_sentence('The quick brown fox jumps over the lazy dog') 'dog lazy the over jumps fox brown quick The' >>> reverse_sentence('Hello World') 'World Hello' >>> reverse_sentence('') '' >>> reverse_sentence('OneWord') 'OneWord' >>> reverse_sentence('Testing is fun') 'fun is Testing' >>> reverse_sentence(' ') '' >>> reverse_sentence(' A B C D ') 'D C B A'","solution":"def reverse_sentence(sentence): Returns a new string with the words of the sentence in reverse order. Parameters: sentence (str): A string containing the sentence to be reversed. Returns: str: A new string with words in reverse order. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words) # Example usage: # reverse_sentence('The quick brown fox jumps over the lazy dog') # Output: 'dog lazy the over jumps fox brown quick The'"},{"question":"from itertools import permutations from typing import List, Tuple def generate_permutations(s: str, r: int) -> List[Tuple[str]]: Generate all possible permutations of string s of length r. Parameters: s (str): The input string. r (int): The length of each permutation. Returns: List[Tuple[str]]: A list of tuples, each containing a permutation of length r. Examples: >>> generate_permutations('ABCD', 2) [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'A'), ('B', 'C'), ('B', 'D'), ('C', 'A'), ('C', 'B'), ('C', 'D'), ('D', 'A'), ('D', 'B'), ('D', 'C')] >>> generate_permutations('ABC', 3) [('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')] >>> generate_permutations('AB', 1) [('A',), ('B',)] >>> generate_permutations('ABC', 0) [()] >>> generate_permutations('', 0) [()] >>> generate_permutations('A', 1) [('A',)]","solution":"from itertools import permutations def generate_permutations(s, r): Generate all possible permutations of string s of length r. Parameters: s (str): The input string. r (int): The length of each permutation. Returns: List[Tuple]: A list of tuples, each containing a permutation of length r. return list(permutations(s, r))"},{"question":"def longest_non_decreasing_subarray(queries): For each query in the input, determines the length of the longest subarray of non-decreasing integers. Parameters: queries (list of tuples): Each tuple contains (n, arr) where n is the number of hours and arr is the list of integers representing traffic data. Returns: list of int: Each element is the length of the longest non-decreasing subarray for the corresponding query. >>> longest_non_decreasing_subarray([(5, [1, 2, 3, 2, 3])]) [3] >>> longest_non_decreasing_subarray([(6, [3, 3, 4, 2, 2, 5])]) [3] >>> longest_non_decreasing_subarray([(4, [8, 7, 6, 5])]) [1]","solution":"def longest_non_decreasing_subarray(queries): For each query in the input, determines the length of the longest subarray of non-decreasing integers. Parameters: queries (list of tuples): Each tuple contains (n, arr) where n is the number of hours and arr is the list of integers representing traffic data. Returns: list of int: Each element is the length of the longest non-decreasing subarray for the corresponding query. results = [] for n, arr in queries: max_length = 1 current_length = 1 for i in range(1, n): if arr[i] >= arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 results.append(max_length) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression in infix notation and returns the result as an integer. The expression contains only positive integers and the operators +, -, *, / (integer division), and may contain parentheses to indicate precedence. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"4*5\\") == 20 >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"(2+3)*4\\") == 20 >>> evaluate_expression(\\"10+(2*5)-3\\") == 17 >>> evaluate_expression(\\"20/(4+1)\\") == 4 >>> evaluate_expression(\\"10/(2+3)\\") == 2 >>> evaluate_expression(\\"((10+2)*3)/4\\") == 9","solution":"def evaluate_expression(expression): Evaluates a mathematical expression in infix notation and returns the result as an integer. The expression contains only positive integers and the operators +, -, *, / (integer division), and may contain parentheses to indicate precedence. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operation(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b def calculate(values, operators): right = values.pop() left = values.pop() op = operators.pop() values.append(apply_operation(left, right, op)) values = [] operators = [] i = 0 while i < len(expression): if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operators) != 0 and operators[-1] != '(': calculate(values, operators) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): calculate(values, operators) operators.append(expression[i]) i += 1 while len(operators) != 0: calculate(values, operators) return values[-1]"},{"question":"from typing import List, Tuple def min_path_length(t: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Given a grid of size n x m, where each cell contains a number representing the height of that cell, find a path from the top-left corner (1, 1) to the bottom-right corner (n, m). The path must be such that the difference in height between any two adjacent cells on the path is at most 1. You can move from one cell to another if the cells are adjacent horizontally or vertically. The starting cell and the ending cell are always included in the path. It is guaranteed that a path always exists for the given constraints. >>> min_path_length(2, [((3, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]]), ... ((2, 2), [[5, 6], [6, 7]])]) [5, 3] >>> min_path_length(1, [((4, 4), [[1, 2, 3, 2], [2, 3, 4, 3], [3, 4, 3, 4], ... [4, 5, 4, 3]])]) [7]","solution":"from collections import deque def min_path_length(t, test_cases): results = [] for case in test_cases: n, m = case[0] grid = case[1] def bfs(): queue = deque([(0, 0, 1)]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False]*m for _ in range(n)] visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: if abs(grid[nx][ny] - grid[x][y]) <= 1: visited[nx][ny] = True queue.append((nx, ny, dist+1)) result = bfs() results.append(result) return results"},{"question":"def generate_playlist(N: int, songs: List[Tuple[str, int]]) -> List[str]: Returns a rank-based playlist. Parameters: - N: int, number of songs - songs: list of tuples, each tuple containing a string S (song name) and an int R (rank) Output: - A list of song names sorted by their rank. If two songs have the same rank, they are sorted alphabetically. >>> generate_playlist(5, [(\\"SongA\\", 2), (\\"SongB\\", 1), (\\"SongC\\", 2), (\\"SongD\\", 3), (\\"SongE\\", 2)]) [\\"SongB\\", \\"SongA\\", \\"SongC\\", \\"SongE\\", \\"SongD\\"] >>> generate_playlist(1, [(\\"SongZ\\", 5)]) [\\"SongZ\\"] >>> generate_playlist(3, [(\\"SongZ\\", 1), (\\"SongY\\", 1), (\\"SongX\\", 1)]) [\\"SongX\\", \\"SongY\\", \\"SongZ\\"] >>> generate_playlist(5, [(\\"SongA\\", 3), (\\"SongB\\", 2), (\\"SongC\\", 1), (\\"SongD\\", 2), (\\"SongE\\", 3)]) [\\"SongC\\", \\"SongB\\", \\"SongD\\", \\"SongA\\", \\"SongE\\"] >>> generate_playlist(3, [(\\"Alpha\\", 2), (\\"Bravo\\", 2), (\\"Charlie\\", 2)]) [\\"Alpha\\", \\"Bravo\\", \\"Charlie\\"]","solution":"def generate_playlist(N, songs): Returns a rank-based playlist. Parameters: - N: int, number of songs - songs: list of tuples, each tuple containing a string S (song name) and an int R (rank) Output: - A list of song names sorted by their rank. If two songs have the same rank, they are sorted alphabetically. # Sort the list of songs first by rank, and then alphabetically within the same rank sorted_songs = sorted(songs, key=lambda x: (x[1], x[0])) # Extract the song names in the sorted order playlist = [song[0] for song in sorted_songs] return playlist"},{"question":"def find_pair_with_target_sum(arr: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to target. Args: arr: List of integers. target: Target integer sum. Returns: A list with two indices if a pair is found; otherwise, an empty list. Examples: >>> find_pair_with_target_sum([2, 7, 11, 15], 9) [0, 1] >>> find_pair_with_target_sum([1, 2, 3, 4, 6], 6) [1, 3] >>> find_pair_with_target_sum([3, 3], 6) [0, 1]","solution":"def find_pair_with_target_sum(arr, target): Returns the indices of the two numbers such that they add up to target. Args: arr: List of integers. target: Target integer sum. Returns: A list with two indices if a pair is found; otherwise, an empty list. index_map = {} for index, number in enumerate(arr): difference = target - number if difference in index_map: return [index_map[difference], index] index_map[number] = index return []"},{"question":"def isPalindrome(n: int) -> bool: Returns True if the integer n is a palindrome number, False otherwise. A palindrome number is a number that remains the same when its digits are reversed. >>> isPalindrome(121) True >>> isPalindrome(-121) False >>> isPalindrome(10) False","solution":"def isPalindrome(n): Returns True if the integer n is a palindrome number, False otherwise. A palindrome number is a number that remains the same when its digits are reversed. str_n = str(n) return str_n == str_n[::-1]"},{"question":"def optimize_backpack(weights, values, max_weight): Returns the maximum total value that can be carried in the backpack without exceeding max_weight. Args: weights (List[int]): An array of integers representing the weights of the items. values (List[int]): An array of integers representing the values of the items. max_weight (int): The maximum weight capacity of the backpack. Returns: int: The maximum total value that can be carried in the backpack without exceeding the weight limit. Examples: >>> optimize_backpack([2, 3, 4, 5], [3, 4, 5, 6], 5) 7 >>> optimize_backpack([1, 2], [10, 20], 5) 30 from solution import optimize_backpack def test_optimize_backpack_example(): weights = [2, 3, 4, 5] values = [3, 4, 5, 6] max_weight = 5 assert optimize_backpack(weights, values, max_weight) == 7 def test_optimize_backpack_no_items(): weights = [] values = [] max_weight = 5 assert optimize_backpack(weights, values, max_weight) == 0 def test_optimize_backpack_zero_capacity(): weights = [2, 3, 4, 5] values = [3, 4, 5, 6] max_weight = 0 assert optimize_backpack(weights, values, max_weight) == 0 def test_optimize_backpack_exact_weight(): weights = [1, 2, 3, 4] values = [10, 20, 30, 40] max_weight = 5 assert optimize_backpack(weights, values, max_weight) == 50 def test_optimize_backpack_all_items_fit(): weights = [1, 2] values = [10, 20] max_weight = 5 assert optimize_backpack(weights, values, max_weight) == 30","solution":"def optimize_backpack(weights, values, max_weight): Returns the maximum total value that can be carried in the backpack without exceeding max_weight. n = len(weights) dp = [[0 for w in range(max_weight + 1)] for i in range(n+1)] for i in range(1, n+1): for w in range(max_weight + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], values[i-1] + dp[i-1][w - weights[i-1]]) else: dp[i][w] = dp[i-1][w] return dp[n][max_weight]"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum possible sum of a contiguous subarray in the given list. >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([10, -2, -1, 5, -10, 7, -1, -4]) 12 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1","solution":"def max_subarray_sum(nums): Returns the maximum possible sum of a contiguous subarray in the given list. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs of numbers from the input list that add up to the target sum. Each pair is represented as a sorted tuple, and the result is a list of these tuples sorted in ascending order. >>> find_pairs([1, 2, 3, 4, 5], 6) [(1, 5), (2, 4)] >>> find_pairs([5, 6, 7, 8, 9], 12) [(3, 9), (5, 7)] >>> find_pairs([1, 1, 2, 45, 46, 46], 47) [(1, 46), (2, 45)] >>> find_pairs([1, 2, 3, 4], 8) []","solution":"def find_pairs(nums, target): Returns a list of unique pairs of numbers from the input list that add up to the target sum. Each pair is represented as a sorted tuple, and the result is a list of these tuples sorted in ascending order. nums.sort() left, right = 0, len(nums) - 1 pairs = [] seen = set() while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pair = (nums[left], nums[right]) if pair not in seen: pairs.append(pair) seen.add(pair) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return pairs"},{"question":"def find_max_length_contiguous_equal_01(s: str) -> int: Returns the length of the longest contiguous substring that has an equal number of '0's and '1's. >>> find_max_length_contiguous_equal_01(\\"110100110\\") 8 >>> find_max_length_contiguous_equal_01(\\"10101\\") 4 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list. >>> process_test_cases(2, [\\"110100110\\", \\"10101\\"]) [8, 4] >>> process_test_cases(3, [\\"000111\\", \\"1001\\", \\"0000\\"]) [6, 4, 0]","solution":"def find_max_length_contiguous_equal_01(s): Returns the length of the longest contiguous substring that has an equal number of '0's and '1's. max_len = 0 count = 0 count_map = {0: -1} # To handle the case when the longest sequence starts from index 0 for i in range(len(s)): if s[i] == '0': count -= 1 else: count += 1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(find_max_length_contiguous_equal_01(s)) return results"},{"question":"def calculate_min_coins(coins: List[int], amount: int) -> int: Calculate the minimum number of coins needed to make up the given amount of change. If it's not possible, return -1. If the amount is zero, return 0. If the list of denominations is empty, return -1. >>> calculate_min_coins([1, 5, 10, 25], 36) == 3 >>> calculate_min_coins([1, 3, 4], 6) == 2 >>> calculate_min_coins([2, 5, 10], 1) == -1 >>> calculate_min_coins([1, 5, 10, 25], 0) == 0 >>> calculate_min_coins([], 10) == -1","solution":"def calculate_min_coins(coins, amount): Calculate the minimum number of coins needed to make up the given amount. If it's not possible, return -1. if amount == 0: return 0 if not coins: return -1 # Initialize DP array with a value greater than the maximum possible coins needed dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: no coins needed for amount 0 for coin in coins: for x in range(coin, amount + 1): if dp[x - coin] != float('inf'): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def find_highest_and_second_highest(scores: List[int]) -> str: Find the highest and second highest scores. >>> find_highest_and_second_highest([10, 20, 20, 30, 30]) '30 20' >>> find_highest_and_second_highest([50, 50, 50]) 'NO SECOND HIGHEST' >>> find_highest_and_second_highest([100, 100, 100, 100]) 'NO SECOND HIGHEST' >>> find_highest_and_second_highest([10, 20]) '20 10' >>> find_highest_and_second_highest([15, 30, 25, 40, 10]) '40 30' >>> find_highest_and_second_highest([99]) 'NO SECOND HIGHEST' def process_input_lines(lines: List[str]) -> str: Process input lines to find the highest and second highest scores. >>> process_input_lines([\\"5\\", \\"10 20 20 30 30\\"]) '30 20' >>> process_input_lines([\\"3\\", \\"50 50 50\\"]) 'NO SECOND HIGHEST' >>> process_input_lines([\\"1\\", \\"99\\"]) 'NO SECOND HIGHEST' >>> process_input_lines([\\"4\\", \\"80 50 70 90\\"]) '90 80'","solution":"def find_highest_and_second_highest(scores): unique_scores = sorted(set(scores), reverse=True) if len(unique_scores) < 2: return \\"NO SECOND HIGHEST\\" else: return f\\"{unique_scores[0]} {unique_scores[1]}\\" def process_input_lines(lines): n = int(lines[0].strip()) scores = list(map(int, lines[1].strip().split())) return find_highest_and_second_highest(scores)"},{"question":"def partition_possible(nums: List[int]) -> str: Determine if a list of integers can be partitioned into two sublists with equal sum. Args: nums (list): A list of integers. Returns: string: \\"Possible\\" if the partition exists, \\"Impossible\\" otherwise. >>> partition_possible([1, 5, 11, 5]) 'Possible' >>> partition_possible([1, 2, 3, 5]) 'Impossible' def test_partition_possible_basic(): assert partition_possible([1, 5, 11, 5]) == \\"Possible\\" assert partition_possible([1, 2, 3, 5]) == \\"Impossible\\" def test_partition_possible_single_element(): assert partition_possible([2]) == \\"Impossible\\" assert partition_possible([0]) == \\"Possible\\" def test_partition_possible_all_same_elements(): assert partition_possible([5, 5, 5, 5]) == \\"Possible\\" assert partition_possible([4, 4, 4, 4]) == \\"Possible\\" def test_partition_possible_large_numbers(): assert partition_possible([100000, 100000]) == \\"Possible\\" assert partition_possible([100000, 50000]) == \\"Impossible\\" def test_partition_possible_edge_cases(): assert partition_possible([]) == \\"Possible\\" assert partition_possible([1, 1, 1, 1, 1, 1]) == \\"Possible\\" assert partition_possible([1, 1, 1, 1, 1]) == \\"Impossible\\"","solution":"def partition_possible(nums): Determine if a list of integers can be partitioned into two sublists with equal sum. Args: nums (list): A list of integers. Returns: string: \\"Possible\\" if the partition exists, \\"Impossible\\" otherwise. total_sum = sum(nums) # If the total sum is odd, we cannot partition it into equal sublists if total_sum % 2 != 0: return \\"Impossible\\" target = total_sum // 2 n = len(nums) # Create a DP array where dp[i] will be True if there is a subset of the list with sum i dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return \\"Possible\\" if dp[target] else \\"Impossible\\""},{"question":"from typing import List def mergeAndReverseOnCommon(arr1: List[int], arr2: List[int]) -> List[int]: Merges two arrays in reverse order starting from the largest common element if it exists. If there are no common elements, concatenates arr2 to arr1 in reverse order separately. >>> mergeAndReverseOnCommon([3, 4, 2, 9], [8, 4, 10]) [10, 4, 8, 9, 2, 4, 3] >>> mergeAndReverseOnCommon([1, 3, 5], [2, 4, 6]) [6, 4, 2, 5, 3, 1] >>> mergeAndReverseOnCommon([1, 4, 7, 9], [2, 7, 5, 4]) [4, 5, 7, 2, 9, 7, 4, 1] >>> mergeAndReverseOnCommon([], [1, 2, 3]) [3, 2, 1] >>> mergeAndReverseOnCommon([1, 2, 3], []) [3, 2, 1] >>> mergeAndReverseOnCommon([], []) [] >>> mergeAndReverseOnCommon([1, 2, 3], [1, 2, 3]) [3, 2, 1, 3, 2, 1] >>> mergeAndReverseOnCommon([5], [5]) [5, 5]","solution":"def mergeAndReverseOnCommon(arr1, arr2): Merges two arrays in reverse order starting from the largest common element if it exists. If there are no common elements, concatenates arr2 to arr1 in reverse order separately. common_elements = set(arr1) & set(arr2) if common_elements: largest_common = max(common_elements) return arr2[::-1] + arr1[::-1] else: return arr2[::-1] + arr1[::-1]"},{"question":"def first_missing_positive(nums: List[int]) -> int: Finds the first missing positive integer from the list of integers. Args: nums (List[int]): List of integers. Returns: int: The first missing positive integer. Examples: >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 from solution import first_missing_positive def test_example_1(): assert first_missing_positive([3, 4, -1, 1]) == 2 def test_example_2(): assert first_missing_positive([1, 2, 0]) == 3 def test_example_3(): assert first_missing_positive([7, 8, 9, 11, 12]) == 1 def test_all_positive(): assert first_missing_positive([1, 2, 3, 4, 5]) == 6 def test_all_negative(): assert first_missing_positive([-1, -2, -3, -4]) == 1 def test_mixed_numbers(): assert first_missing_positive([3, 1, 4, 2, 1]) == 5 def test_large_range(): assert first_missing_positive(list(range(1, 301))) == 301 def test_with_zeros(): assert first_missing_positive([0, 0, 0, 0]) == 1 def test_with_duplicates(): assert first_missing_positive([1, 1, 1, 2, 2, 2]) == 3","solution":"def first_missing_positive(nums): Finds the first missing positive integer from the list of integers. Args: nums (List[int]): List of integers. Returns: int: The first missing positive integer. n = len(nums) # Step 1: Mark numbers (num < 1 or num > n) with a special marker number (n+1) # (we can ignore those because if all numbers are 1 to n, then the first missing positive # integer must be in the range from 1 to n+1 (which is n+1 itself) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark each cell appearing in the array, by converting the index for that number to negative for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first cell which isn't negative (i.e. the first missing positive) for i in range(n): if nums[i] > 0: return i + 1 # Step 4: If no positive cells are found, then that means the array contains all numbers from 1 to n return n + 1"},{"question":"def min_operations_to_transform(S: str, T: str) -> int: Determine the minimum number of operations required to transform string S into string T. Parameters: S (str): the starting string T (str): the target string Returns: int: The minimum number of operations required >>> min_operations_to_transform(\\"abcd\\", \\"abcd\\") 0 >>> min_operations_to_transform(\\"aaaa\\", \\"bbbb\\") 4 >>> min_operations_to_transform(\\"abcdef\\", \\"abcxyz\\") 3 >>> min_operations_to_transform(\\"a\\", \\"b\\") 1 >>> min_operations_to_transform(\\"a\\", \\"a\\") 0 >>> N = 100000 >>> S = \\"a\\" * N >>> T = \\"b\\" * N >>> min_operations_to_transform(S, T) 100000 >>> min_operations_to_transform(\\"abababab\\", \\"babababa\\") 8","solution":"def min_operations_to_transform(S, T): Determine the minimum number of operations required to transform string S into string T. Parameters: S (str): the starting string T (str): the target string Returns: int: The minimum number of operations required operations_needed = 0 # Loop through each character in both strings and count the differences for s_char, t_char in zip(S, T): if s_char != t_char: operations_needed += 1 return operations_needed # Example usage S = \\"abcde\\" T = \\"bcdae\\" print(min_operations_to_transform(S, T)) # Output: 5"},{"question":"def strictly_increasing_strings(strings: list) -> list: Given a list of strings, return a new list with only those strings that have strictly increasing ASCII values when read from left to right. If none of the strings meet the criteria, return an empty list. >>> strictly_increasing_strings([\\"abc\\", \\"def\\", \\"axa\\", \\"ghi\\"]) [\\"abc\\", \\"def\\", \\"ghi\\"] >>> strictly_increasing_strings([\\"hello\\", \\"world\\", \\"a\\", \\"xyz\\"]) [\\"a\\", \\"xyz\\"]","solution":"def strictly_increasing_strings(strings: list) -> list: def is_strictly_increasing(s): return all(ord(s[i]) < ord(s[i+1]) for i in range(len(s) - 1)) return [s for s in strings if is_strictly_increasing(s)]"},{"question":"def even_sum_odd_product(s: str) -> tuple: Returns a tuple containing the sum of even integers and the product of odd integers from a string of comma-separated integers. Args: s (str): string of comma-separated integers. Returns: tuple: (sum of even integers, product of odd integers) >>> even_sum_odd_product(\\"1,2,3,4,5\\") == (6, 15) >>> even_sum_odd_product(\\"6,7,8,9\\") == (14, 63) >>> even_sum_odd_product(\\"10,11,12\\") == (22, 11) >>> even_sum_odd_product(\\"1,3,5\\") == (0, 15) >>> even_sum_odd_product(\\"2,4,6\\") == (12, 1)","solution":"def even_sum_odd_product(s): Returns a tuple containing the sum of even integers and the product of odd integers from a string of comma-separated integers. Args: s (str): string of comma-separated integers. Returns: tuple: (sum of even integers, product of odd integers) numbers = list(map(int, s.split(','))) even_sum = sum(n for n in numbers if n % 2 == 0) odd_product = 1 odd_found = False for n in numbers: if n % 2 == 1: odd_product *= n odd_found = True if not odd_found: odd_product = 1 return even_sum, odd_product"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. Parameters: - list1: A sorted list of integers. - list2: A sorted list of integers. Returns: - A new list containing all integers from list1 and list2, sorted in non-decreasing order. Examples: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], [4, 5, 6]) [4, 5, 6] >>> merge_sorted_lists([1, 2, 2, 3], [2, 2, 4]) [1, 2, 2, 2, 2, 3, 4] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([2], [1]) [1, 2] >>> merge_sorted_lists([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_sorted_lists([1, 4, 5], [2]) [1, 2, 4, 5] >>> merge_sorted_lists([3], [2, 6, 8, 10]) [2, 3, 6, 8, 10]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Parameters: - list1: A sorted list of integers. - list2: A sorted list of integers. Returns: - A new list containing all integers from list1 and list2, sorted in non-decreasing order. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def countVowelsAndConsonants(s: str) -> dict: Returns a dictionary with counts of vowels and consonants in the given string. Parameters: s (str): The input string containing only alphabetical characters. Returns: dict: A dictionary with keys 'vowels' and 'consonants', containing their respective counts. Examples: >>> countVowelsAndConsonants(\\"HappyEnd\\") {'vowels': 2, 'consonants': 6} >>> countVowelsAndConsonants(\\"Rhythm\\") {'vowels': 0, 'consonants': 6} >>> countVowelsAndConsonants(\\"Beautiful\\") {'vowels': 5, 'consonants': 4}","solution":"def countVowelsAndConsonants(s): Returns a dictionary with counts of vowels and consonants in the given string. Parameters: s (str): The input string containing only alphabetical characters. Returns: dict: A dictionary with keys 'vowels' and 'consonants', containing their respective counts. vowels = \\"aeiou\\" s = s.lower() vowel_count = sum(1 for char in s if char in vowels) consonant_count = sum(1 for char in s if char.isalpha() and char not in vowels) return {'vowels': vowel_count, 'consonants': consonant_count}"},{"question":"def fibonacci(n: int) -> List[int]: Write a function that accepts an integer \`n\` as input and returns a list containing the fibonacci sequence up to the \`n\`th term. Parameters: n (int): the number of terms in the Fibonacci sequence to generate Returns: list: a list containing the Fibonacci sequence up to the nth term >>> fibonacci(1) [0] >>> fibonacci(2) [0, 1] >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list containing the Fibonacci sequence up to the nth term. Parameters: n (int): the number of terms in the Fibonacci sequence to generate Returns: list: a list containing the Fibonacci sequence up to the nth term if n == 1: return [0] elif n == 2: return [0, 1] fib_seq = [0, 1] for i in range(2, n): fib_seq.append(fib_seq[-1] + fib_seq[-2]) return fib_seq"},{"question":"def diamondPattern(n: int) -> str: Generates a diamond pattern up to n rows. :param n: number of rows to generate the diamond pattern. :return: A string representation of the diamond pattern. >>> diamondPattern(3) ' * n *** n*****n *** n * ' >>> diamondPattern(5) ' * n *** n ***** n ******* n*********n ******* n ***** n *** n * ' >>> diamondPattern(0) '' >>> diamondPattern(2) ' * n***n * '","solution":"def diamondPattern(n): Generates a diamond pattern up to n rows. :param n: number of rows to generate the diamond pattern. :return: A string representation of the diamond pattern. if n <= 0: return \\"\\" diamond = [] width = 2 * n - 1 for i in range(n): stars = '*' * (2 * i + 1) diamond.append(stars.center(width)) for i in range(n - 2, -1, -1): stars = '*' * (2 * i + 1) diamond.append(stars.center(width)) return 'n'.join(diamond)"},{"question":"import re from typing import List def findLongestWord(s: str) -> str: Write a function that takes a single string argument and returns the longest word in the string. If there are multiple words of the same maximum length, return the first one that appears. For the sake of this task, a word is defined as a sequence of alphanumeric characters (letters and digits) separated by spaces or punctuation. You can assume that the input will contain at least one word. Examples: >>> findLongestWord(\\"The quick brown fox.\\") 'quick' >>> findLongestWord(\\"A journey of a thousand miles begins with a single step.\\") 'thousand' >>> findLongestWord(\\"Hello, world!\\") 'Hello' def test_findLongestWord_single_word(): assert findLongestWord(\\"Hello\\") == \\"Hello\\" def test_findLongestWord_multiple_words(): assert findLongestWord(\\"The quick brown fox.\\") == \\"quick\\" def test_findLongestWord_multiple_same_length_words(): assert findLongestWord(\\"cat hat bat\\") == \\"cat\\" def test_findLongestWord_with_punctuation(): assert findLongestWord(\\"Hello, world!\\") == \\"Hello\\" def test_findLongestWord_long_sentence(): assert findLongestWord(\\"A journey of a thousand miles begins with a single step.\\") == \\"thousand\\" def test_findLongestWord_numbers_and_letters(): assert findLongestWord(\\"abc123 is longer than 123abc\\") == \\"abc123\\" def test_findLongestWord_mixed_content(): assert findLongestWord(\\"abc abcdef, !@#\\") == \\"abcdef\\"","solution":"import re def findLongestWord(s): Returns the longest word in the string s. If there are multiple words with the same maximum length, returns the first one that appears. words = re.findall(r'bw+b', s) longest_word = max(words, key=len) return longest_word"},{"question":"def matrixDiagonalSum(matrix: List[List[int]]) -> int: Calculates the sum of the primary and secondary diagonals of a square matrix. Args: matrix (List[List[int]]): A 2D list of integers representing the square matrix Returns: int: Sum of the two diagonals Example: >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> matrixDiagonalSum(matrix) 25 >>> matrix = [ [1, 2], [3, 4] ] >>> matrixDiagonalSum(matrix) 10 >>> matrix = [ [1] ] >>> matrixDiagonalSum(matrix) 5 >>> matrix = [] >>> matrixDiagonalSum(matrix) 0 pass","solution":"def matrixDiagonalSum(matrix): Calculates the sum of the primary and secondary diagonals of a square matrix. :param matrix: 2D list of integers :return: integer sum of the two diagonals n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] if n % 2 == 1: # If odd dimensions, remove the double-counted middle element middle_index = n // 2 secondary_diagonal_sum -= matrix[middle_index][middle_index] return primary_diagonal_sum + secondary_diagonal_sum"},{"question":"def longest_substring_without_repeating(s: str) -> int: Write a function that takes a string of characters and finds the length of the longest substring without repeating characters. >>> longest_substring_without_repeating(\\"abrkaabcdefghijjxxx\\") 10 >>> longest_substring_without_repeating(\\"bbbbb\\") 1 >>> longest_substring_without_repeating(\\"pwwkew\\") 3","solution":"def longest_substring_without_repeating(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def areAnagrams(str1: str, str2: str) -> bool: Write a function that takes two strings and returns true if they are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of another, typically using all original letters exactly once. >>> areAnagrams(\\"listen\\", \\"silent\\") True >>> areAnagrams(\\"triangle\\", \\"integral\\") True >>> areAnagrams(\\"apple\\", \\"pale\\") False","solution":"def areAnagrams(str1, str2): Returns true if str1 and str2 are anagrams of each other. # Clean strings by converting to lower case and removing spaces str1 = str1.replace(\\" \\", \\"\\").lower() str2 = str2.replace(\\" \\", \\"\\").lower() # Anagrams should have the same length if len(str1) != len(str2): return False # Sort and compare return sorted(str1) == sorted(str2)"},{"question":"def is_balanced(s: str) -> bool: Check if the input string has balanced brackets. Args: s (str): Input string to be checked. Returns: bool: True if the input string has balanced brackets, False otherwise.","solution":"def is_balanced(s: str) -> bool: Check if the input string has balanced brackets. Args: s (str): Input string to be checked. Returns: bool: True if the input string has balanced brackets, False otherwise. stack = [] brackets = {')': '(', '}': '{', ']': '['} for char in s: if char in brackets.values(): stack.append(char) elif char in brackets.keys(): if stack == [] or brackets[char] != stack.pop(): return False return stack == []"},{"question":"def sum_alternating_subtraction(t, test_cases): For a given sequence A of length n, create a new sequence B where: B[i] = A[i] + A[i+1] if i is odd and i < n A[i] - A[i+1] if i is even and i < n A[i] if i = n >>> sum_alternating_subtraction(3, [(5, [1, 3, 2, 8, 5]), (4, [4, 7, 1, 3]), (1, [10])]) [[4, -1, 10, -3, 5], [11, -6, 4, -3], [10]] >>> sum_alternating_subtraction(1, [(1, [100])]) [[100]] pass def test_example_cases(): test_cases = [ (5, [1, 3, 2, 8, 5]), (4, [4, 7, 1, 3]), (1, [10]), ] expected = [ [4, -1, 10, -3, 5], [11, -6, 4, -3], [10] ] assert sum_alternating_subtraction(3, test_cases) == expected def test_single_element_case(): test_cases = [ (1, [100]), ] expected = [ [100] ] assert sum_alternating_subtraction(1, test_cases) == expected def test_two_elements_case(): test_cases = [ (2, [5, -5]), ] expected = [ [0, -5] ] assert sum_alternating_subtraction(1, test_cases) == expected def test_two_test_cases(): test_cases = [ (3, [1, 2, 3]), (5, [5, 10, 15, 20, 25]) ] expected = [ [3, -1, 3], [15, -5, 35, -5, 25] ] assert sum_alternating_subtraction(2, test_cases) == expected def test_negative_numbers(): test_cases = [ (4, [-1, -2, -3, -4]), ] expected = [ [-3, 1, -7, -4] ] assert sum_alternating_subtraction(1, test_cases) == expected","solution":"def sum_alternating_subtraction(t, test_cases): results = [] for i in range(t): n, A = test_cases[i] B = [] for j in range(n): if j < n - 1: if j % 2 == 0: B.append(A[j] + A[j+1]) else: B.append(A[j] - A[j+1]) else: B.append(A[j]) results.append(B) return results"},{"question":"def shelf_arrangement(inventory: List[int]) -> str: Returns a string representing the shelf arrangement of fruits. Each fruit type is represented by a lowercase letter starting from 'a'. >>> shelf_arrangement([3, 2, 1]) \\"aaabbc\\" >>> shelf_arrangement([1, 1, 1, 1]) \\"abcd\\" >>> shelf_arrangement([5]) \\"aaaaa\\" >>> shelf_arrangement([2]) \\"aa\\" >>> shelf_arrangement([3, 1, 2]) \\"aaabcc\\" >>> shelf_arrangement([1] * 26) \\"abcdefghijklmnopqrstuvwxyz\\" >>> shelf_arrangement([10, 5]) \\"aaaaaaaaaabbbbb\\"","solution":"def shelf_arrangement(inventory): Returns a string representing the shelf arrangement of fruits. Each fruit type is represented by a lowercase letter starting from 'a'. Params: inventory (list of int): List representing the count of each type of fruit. Returns: str: A string representing the shelf arrangement. shelf = [] for i, count in enumerate(inventory): shelf.append(chr(97 + i) * count) # 'a' -> 97 + i gives the alphabet corresponding to the type return ''.join(shelf)"},{"question":"def merge_dicts(*dicts): Merges any number of dictionaries into a single dictionary. If the same key is present in multiple dictionaries, the value from the last dictionary containing the key is used. Examples: >>> merge_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4}, {'a': 5, 'd': 6}) {'a': 5, 'b': 3, 'c': 4, 'd': 6} >>> merge_dicts({'x': 7}, {'y': 8, 'z': 9}, {'y': 10, 'x': 11}) {'x': 11, 'y': 10, 'z': 9}","solution":"def merge_dicts(*dicts): Merges any number of dictionaries into a single dictionary. If the same key is present in multiple dictionaries, the value from the last dictionary containing the key is used. result = {} for d in dicts: result.update(d) return result"},{"question":"def is_anagram(s: str, t: str) -> bool: Determine if t is an anagram of s. Args: s: string t: string Returns: bool: True if t is an anagram of s, False otherwise. >>> is_anagram(\\"anagram\\", \\"nagaram\\") True >>> is_anagram(\\"rat\\", \\"car\\") False >>> is_anagram(\\"abc\\", \\"abc\\") True >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"a\\", \\"ab\\") False >>> is_anagram(\\"a\\", \\"a\\") True >>> is_anagram(\\"a\\", \\"b\\") False >>> is_anagram(\\"abcdefg\\", \\"gfedcba\\") True >>> is_anagram(\\"abcdefg\\", \\"gfedcbaa\\") False","solution":"def is_anagram(s, t): Determine if t is an anagram of s. Args: s: string t: string Returns: bool: True if t is an anagram of s, False otherwise. return sorted(s) == sorted(t)"},{"question":"def is_valid_hex(s: str) -> bool: Determine if a given string is a valid hexadecimal number. :param s: The input string. :return: True if the string is a valid hexadecimal number, False otherwise. Examples: >>> is_valid_hex(\\"0x1A3F\\") True >>> is_valid_hex(\\"0Xabc123\\") True >>> is_valid_hex(\\"123abc\\") True >>> is_valid_hex(\\"GHI\\") False >>> is_valid_hex(\\"\\") False >>> is_valid_hex(\\"0x\\") False","solution":"def is_valid_hex(s: str) -> bool: Returns True if the provided string is a valid hexadecimal number, False otherwise. if not s: return False # Strip the optional \\"0x\\" or \\"0X\\" prefix if present if s.startswith('0x') or s.startswith('0X'): s = s[2:] if not s: # If the string is empty after removing the prefix return False return False valid_hex_chars = set('0123456789abcdefABCDEF') for char in s: if char not in valid_hex_chars: return False return True"},{"question":"from typing import List def max_sum_subarrays(nums: List[int], k: int) -> List[List[int]]: Given an integer array \`nums\`, find all subarrays of length \`k\` that contain the maximum possible sum. Args: nums (list): List of integers. k (int): Length of subarrays. Returns: list: List of subarrays of length k with the maximum possible sum. Example: >>> max_sum_subarrays([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) [[4, 2, 10, 23]] >>> max_sum_subarrays([2, 1, 5, 1, 3, 2], 3) [[5, 1, 3]] >>> max_sum_subarrays([1, 1, 1, 1], 2) [[1, 1], [1, 1], [1, 1]] pass","solution":"def max_sum_subarrays(nums, k): Finds all subarrays of length k with the maximum possible sum. Args: nums (list): List of integers. k (int): Length of subarrays. Returns: list: List of subarrays of length k with the maximum possible sum. if not nums or k > len(nums): return [] n = len(nums) max_sum = float('-inf') subarrays = [] # Compute sum of first subarray of length k current_sum = sum(nums[:k]) max_sum = current_sum # Store first subarray subarrays.append(nums[:k]) # Use sliding window to find other subarrays with length k and their sums for i in range(1, n - k + 1): current_sum = current_sum - nums[i-1] + nums[i+k-1] if current_sum > max_sum: max_sum = current_sum subarrays = [nums[i:i+k]] elif current_sum == max_sum: subarrays.append(nums[i:i+k]) return subarrays"},{"question":"from typing import List def count_increasing_subarrays(arr: List[int]) -> int: Given a list of integers, find all the contiguous subarrays within which the elements are in strictly increasing order and return the count of such subarrays. >>> count_increasing_subarrays([1, 2, 3, 4, 1]) 6 >>> count_increasing_subarrays([3, 3, 3]) 0 >>> count_increasing_subarrays([1, 2, 4, 3, 5, 7]) 6 >>> count_increasing_subarrays([1]) 0 >>> count_increasing_subarrays([1, 2]) 1 >>> count_increasing_subarrays(list(range(1, 10001))) 49995000 >>> count_increasing_subarrays([5, 4, 3, 2, 1]) 0 >>> count_increasing_subarrays([1, 1, 1, 1]) 0 >>> count_increasing_subarrays([1, 2, 1, 2, 1, 2]) 3","solution":"def count_increasing_subarrays(arr): Returns the count of strictly increasing contiguous subarrays. n = len(arr) if n < 2: return 0 count = 0 length = 1 # Length of current increasing subarray for i in range(1, n): if arr[i] > arr[i - 1]: length += 1 else: if length > 1: count += (length - 1) * length // 2 length = 1 if length > 1: count += (length - 1) * length // 2 return count"},{"question":"def can_rearrange_no_adjacent(T: int, test_cases: List[str]) -> List[str]: Determine whether it is possible to rearrange the characters in each string so that no two adjacent characters are the same. >>> can_rearrange_no_adjacent(2, [\\"aabb\\", \\"aaab\\"]) [\\"YES\\", \\"NO\\"] >>> can_rearrange_no_adjacent(1, [\\"a\\"]) [\\"YES\\"] >>> can_rearrange_no_adjacent(1, [\\"aa\\"]) [\\"NO\\"] >>> can_rearrange_no_adjacent(1, [\\"ab\\"]) [\\"YES\\"] >>> can_rearrange_no_adjacent(1, [\\"aaaaaaab\\"]) [\\"NO\\"] >>> can_rearrange_no_adjacent(1, [\\"aaabbb\\"]) [\\"YES\\"] >>> input_string = \\"a\\" * 50000 + \\"b\\" * 50000 >>> can_rearrange_no_adjacent(1, [input_string]) [\\"YES\\"] >>> can_rearrange_no_adjacent(3, [\\"abac\\", \\"aa\\", \\"aabbcc\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"from collections import Counter def can_rearrange_no_adjacent(T, test_cases): results = [] for S in test_cases: char_count = Counter(S) max_count = max(char_count.values()) if max_count <= (len(S) + 1) // 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import itertools from typing import List, Set def longest_valid_word(s: str, dictionary: Set[str]) -> str: Finds the longest valid dictionary word that can be formed using the given string \`s\`. If multiple words have the same maximum length, the lexicographically smallest one is chosen. >>> longest_valid_word(\\"example\\", {\\"example\\", \\"exemplar\\", \\"apple\\", \\"maple\\", \\"exam\\"}) == \\"example\\" >>> longest_valid_word(\\"xyz\\", {\\"cat\\", \\"dog\\", \\"fish\\"}) == \\"No valid words\\" >>> longest_valid_word(\\"example\\", {\\"maple\\", \\"example\\", \\"exempla\\"}) == \\"example\\" >>> longest_valid_word(\\"apt\\", {\\"tap\\", \\"pat\\", \\"apt\\"}) == \\"apt\\" >>> longest_valid_word(\\"a\\", {\\"a\\"}) == \\"a\\" >>> longest_valid_word(\\"tabbat\\", {\\"bat\\", \\"tab\\", \\"tabbat\\"}) == \\"tabbat\\" pass def test_longest_valid_word_example(): dictionary = {\\"example\\", \\"exemplar\\", \\"apple\\", \\"maple\\", \\"exam\\"} assert longest_valid_word(\\"example\\", dictionary) == \\"example\\" def test_no_valid_word(): dictionary = {\\"cat\\", \\"dog\\", \\"fish\\"} assert longest_valid_word(\\"xyz\\", dictionary) == \\"No valid words\\" def test_multiple_max_length_words(): dictionary = {\\"maple\\", \\"example\\", \\"exempla\\"} assert longest_valid_word(\\"example\\", dictionary) == \\"example\\" def test_lexicographically_smaller_word(): dictionary = {\\"tap\\", \\"pat\\", \\"apt\\"} assert longest_valid_word(\\"apt\\", dictionary) == \\"apt\\" def test_single_character(): dictionary = {\\"a\\"} assert longest_valid_word(\\"a\\", dictionary) == \\"a\\" def test_full_string_used(): dictionary = {\\"bat\\", \\"tab\\", \\"tabbat\\"} assert longest_valid_word(\\"tabbat\\", dictionary) == \\"tabbat\\"","solution":"def longest_valid_word(s, dictionary): Finds the longest valid dictionary word that can be formed using the given string \`s\`. If multiple words have the same maximum length, the lexicographically smallest one is chosen. from itertools import permutations max_word = \\"No valid words\\" for length in range(len(s), 0, -1): perms = set(permutations(s, length)) for perm in perms: word = ''.join(perm) if word in dictionary: if max_word == \\"No valid words\\" or len(word) > len(max_word) or (len(word) == len(max_word) and word < max_word): max_word = word if max_word != \\"No valid words\\": break return max_word"},{"question":"def find_majority_element(nums: List[int]) -> int: Finds and returns the majority element in an array. The majority element is the element that appears more than half the time in the array. If no such element exists, returns None. Args: nums (list): List of integers Returns: int: Majority element or None if no majority element exists. Examples: >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 2]) None >>> find_majority_element([1]) 1","solution":"def find_majority_element(nums): Finds and returns the majority element in an array. The majority element is the element that appears more than half the time in the array. If no such element exists, returns None. Args: nums (list): List of integers Returns: int: Majority element or None if no majority element exists. count = 0 candidate = None # Phase 1: Find a candidate for majority element for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Phase 2: Verify if the candidate is the majority element if nums.count(candidate) > len(nums) // 2: return candidate else: return None"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Returns the area of the largest rectangle that can be formed in the histogram represented by the heights array. >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2,4]) 4 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([2,4,2,1,10,6,10]) 18 >>> largestRectangleArea([3, 3, 3, 3, 3]) 15 >>> largestRectangleArea([100000, 100000, 100000, 100000, 100000]) 500000","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed in the histogram represented by the heights array. stack = [] max_area = 0 heights.append(0) # Append a zero height to ensure the stack is emptied at the end. for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area"},{"question":"def longest_asc_subsequence(arr): Returns the longest strictly ascending subsequence in the given list of integers. Examples: >>> longest_asc_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> longest_asc_subsequence([3, 10, 2, 1, 20]) [3, 10, 20] >>> longest_asc_subsequence([3, 2]) [3] >>> longest_asc_subsequence([]) [] >>> longest_asc_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_asc_subsequence([5, 4, 3, 2, 1]) [5] >>> longest_asc_subsequence([1]) [1] >>> longest_asc_subsequence([10, 22, 5, 75, 60, 80]) [10, 22, 75, 80] >>> longest_asc_subsequence([-10, -22, -9, -33, -21, -50, -41, -60, -8]) [-10, -9, -8] >>> longest_asc_subsequence([-1, 3, -2, 4, -3, 5]) [-1, 3, 4, 5] pass","solution":"def longest_asc_subsequence(arr): Returns the longest strictly ascending subsequence in the given list of integers. if not arr: return [] n = len(arr) # dp[i] will store the longest ascending subsequence that ends with arr[i] dp = [[] for _ in range(n)] # Initialize dp with each element being the subsequence containing only itself for i in range(n): dp[i] = [arr[i]] # Build the dp array for i in range(1, n): for j in range(i): if arr[i] > arr[j] and len(dp[i]) < len(dp[j]) + 1: dp[i] = dp[j] + [arr[i]] # Find the longest subsequence in dp longest_subseq = [] for subseq in dp: if len(subseq) > len(longest_subseq): longest_subseq = subseq return longest_subseq"},{"question":"def hanoi(n, source, target, auxiliary): Solve the Tower of Hanoi problem and print the sequence of moves. Args: n (int): number of disks source (str): name of the source rod target (str): name of the target rod auxiliary (str): name of the auxiliary rod >>> hanoi(1, 'A', 'C', 'B') Move disk 1 from A to C >>> hanoi(2, 'A', 'C', 'B') Move disk 1 from A to B Move disk 2 from A to C Move disk 1 from B to C >>> hanoi(3, 'A', 'C', 'B') Move disk 1 from A to C Move disk 2 from A to B Move disk 1 from C to B Move disk 3 from A to C Move disk 1 from B to A Move disk 2 from B to C Move disk 1 from A to C >>> hanoi(4, 'A', 'C', 'B') Move disk 1 from A to B Move disk 2 from A to C Move disk 1 from B to C Move disk 3 from A to B Move disk 1 from C to A Move disk 2 from C to B Move disk 1 from A to B Move disk 4 from A to C Move disk 1 from B to C Move disk 2 from B to A Move disk 1 from C to A Move disk 3 from B to C Move disk 1 from A to B Move disk 2 from A to C Move disk 1 from B to C","solution":"def hanoi(n, source, target, auxiliary): Solve the Tower of Hanoi problem and print the sequence of moves. Args: n (int): number of disks source (str): name of the source rod target (str): name of the target rod auxiliary (str): name of the auxiliary rod if n == 1: print(f\\"Move disk 1 from {source} to {target}\\") return hanoi(n-1, source, auxiliary, target) print(f\\"Move disk {n} from {source} to {target}\\") hanoi(n-1, auxiliary, target, source)"},{"question":"def smallest_missing_positive(nums: List[int]) -> int: Write a function that takes a list of integers and returns the smallest positive integer (greater than 0) that does not appear in the list. Your solution should have a time complexity less than O(n^2). >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([-1, -2, -3]) 1 >>> smallest_missing_positive([1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive([1, 3, 6, 4, 1, 2]) 5 >>> smallest_missing_positive([]) 1 >>> smallest_missing_positive([1]) 2 >>> smallest_missing_positive([2]) 1 >>> smallest_missing_positive([-1]) 1 >>> smallest_missing_positive([1, 2, 3, 100000, 100001]) 4","solution":"def smallest_missing_positive(nums): Returns the smallest positive integer (greater than 0) that does not appear in the list. nums = [num for num in nums if num > 0] num_set = set(nums) smallest_missing = 1 while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"def calculate_sum(lst: List[int]) -> int: Returns the sum of each distinct element in a list after removing duplicates. Parameters: lst (list): A list of integers Returns: int: Sum of the distinct elements of the list >>> calculate_sum([4, 5, 7, 5, 4, 8]) 24 >>> calculate_sum([]) 0 >>> calculate_sum([1, 2, 3, 4, 5]) 15 >>> calculate_sum([2, 2, 2, 2]) 2 >>> calculate_sum([1, 2, 2, 3, 1]) 6 >>> calculate_sum([-1, -2, -3, -1, -2]) -6 >>> calculate_sum(list(range(1000)) + list(range(500))) 499500","solution":"def calculate_sum(lst): Returns the sum of each distinct element in a list after removing duplicates. Parameters: lst (list): A list of integers Returns: int: Sum of the distinct elements of the list return sum(set(lst))"},{"question":"from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Given an array of strings, group the anagrams together. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams([\\"hello\\", \\"world\\"]) [['hello'], ['world']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) [['abc', 'bca', 'cab']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"def\\", \\"fed\\", \\"ghi\\"]) [['abc', 'bca'], ['def', 'fed'], ['ghi']]","solution":"from typing import List, Dict def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from the given list of strings. Args: strs : List[str] - list of strings to group Returns: List[List[str]] - list of groups of anagrams anagram_map: Dict[str, List[str]] = {} for word in strs: # Sort the word to get the base form of the anagram sorted_word = ''.join(sorted(word)) if sorted_word not in anagram_map: anagram_map[sorted_word] = [] anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"def can_remove_all_characters(S: str) -> str: Determine if it is possible to completely remove all characters from the string S. >>> can_remove_all_characters(\\"abba\\") == \\"YES\\" >>> can_remove_all_characters(\\"abc\\") == \\"NO\\" >>> can_remove_all_characters(\\"aabbcc\\") == \\"YES\\" >>> can_remove_all_characters(\\"aaabbbccc\\") == \\"NO\\" >>> can_remove_all_characters(\\"\\") == \\"YES\\" >>> can_remove_all_characters(\\"a\\") == \\"NO\\" pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases. >>> test_cases = [\\"abba\\", \\"abc\\"] >>> process_test_cases(2, test_cases) [\\"YES\\", \\"NO\\"] >>> test_cases = [\\"aabbcc\\", \\"xyzxyz\\"] >>> process_test_cases(2, test_cases) [\\"YES\\", \\"YES\\"] >>> test_cases = [\\"aabb\\", \\"aab\\"] >>> process_test_cases(2, test_cases) [\\"YES\\", \\"NO\\"] pass","solution":"def can_remove_all_characters(S): Returns \\"YES\\" if it is possible to remove all characters from the string S, otherwise returns \\"NO\\". from collections import Counter char_count = Counter(S) for count in char_count.values(): if count % 2 != 0: return \\"NO\\" return \\"YES\\" def process_test_cases(T, test_cases): Processes multiple test cases. results = [] for S in test_cases: results.append(can_remove_all_characters(S)) return results"},{"question":"def alienOrder(words: List[str]) -> str: Derive the order of characters in an alien language from the given lexicographically sorted list of words. :param words: List[str] - a list of words sorted lexicographically according to the rules of the alien language :return: str - a string representing the characters in the alien language in the correct order >>> alienOrder([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) \\"wertf\\" >>> alienOrder([\\"z\\", \\"x\\", \\"z\\"]) \\"\\" >>> alienOrder([\\"abc\\", \\"ab\\"]) \\"\\"","solution":"from collections import defaultdict, deque def alienOrder(words): # Initialize the graph and the in-degree dictionary graph = defaultdict(list) in_degree = {char: 0 for word in words for char in word} # Build the graph for first, second in zip(words, words[1:]): for c1, c2 in zip(first, second): if c1 != c2: if c2 not in graph[c1]: graph[c1].append(c2) in_degree[c2] += 1 break else: if len(second) < len(first): return \\"\\" # Initialize the queue with nodes of 0 in-degree queue = deque([char for char in in_degree if in_degree[char] == 0]) # Perform topological sort order = [] while queue: char = queue.popleft() order.append(char) for neighbor in graph[char]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == len(in_degree): return \\"\\".join(order) else: return \\"\\""},{"question":"def scoreParentheses(s: str) -> int: Computes the score of a balanced parentheses string s based on the rules: - \\"()\\" has a score of 1. - \\"AB\\" has a score equal to A + B, where A and B are balanced parentheses strings. - \\"(A)\\" has a score equal to 2 * score(A), where A is a balanced parentheses string. :param s: str: A balanced parentheses string :return: int: The score of the parentheses string >>> scoreParentheses(\\"()\\") 1 >>> scoreParentheses(\\"(())\\") 2 >>> scoreParentheses(\\"()()\\") 2 >>> scoreParentheses(\\"(()(()))\\") 6 >>> scoreParentheses(\\"((()))\\") 4 >>> scoreParentheses(\\"()(())\\") 3 >>> scoreParentheses(\\"()((()))\\") 5","solution":"def scoreParentheses(s): Computes the score of a balanced parentheses string s based on the rules: - \\"()\\" has a score of 1. - \\"AB\\" has a score equal to A + B, where A and B are balanced parentheses strings. - \\"(A)\\" has a score equal to 2 * score(A), where A is a balanced parentheses string. :param s: str: A balanced parentheses string :return: int: The score of the parentheses string stack = [] for char in s: if char == '(': stack.append(char) else: if stack[-1] == '(': stack.pop() stack.append(1) else: score = 0 while isinstance(stack[-1], int): score += stack.pop() stack.pop() # pop the '(' stack.append(2 * score) return sum(stack)"},{"question":"def min_shelves_required(n: int, m: int, box_weights: List[int], shelf_capacities: List[int]) -> int: Determine the minimum number of shelves required to store all boxes without exceeding any shelf's weight limit. >>> min_shelves_required(6, 3, [2, 3, 5, 6, 7, 8], [10, 15, 20]) 2 >>> min_shelves_required(0, 2, [], [10, 20]) 0 >>> min_shelves_required(4, 2, [2, 2, 2, 2], [10, 10]) 1 >>> min_shelves_required(3, 3, [5, 5, 5], [6, 6, 6]) 3 >>> min_shelves_required(4, 2, [10, 10, 10, 10], [15, 15]) -1 >>> min_shelves_required(4, 2, [3, 3, 3, 6], [6, 9]) 2","solution":"def min_shelves_required(n, m, box_weights, shelf_capacities): boxes = sorted(box_weights, reverse=True) shelves = sorted(shelf_capacities, reverse=True) used_shelves = [0] * m for box in boxes: placed = False for i in range(m): if used_shelves[i] + box <= shelves[i]: used_shelves[i] += box placed = True break if not placed: return -1 # We want to return the count of non-zero shelves used return len([shelf_weight for shelf_weight in used_shelves if shelf_weight > 0])"},{"question":"def is_valid_email(email: str) -> bool: Returns True if the email is valid according to the defined rules, False otherwise. >>> is_valid_email('test.email@example.com') == True >>> is_valid_email('username@domain.com') == True >>> is_valid_email('.invalid@domain.com') == False >>> is_valid_email('username@domain,com') == False >>> is_valid_email('invalid@domain..com') == False >>> is_valid_email('email@domain.com.') == False >>> is_valid_email('email@domain.c') == False >>> is_valid_email('email@domaincom') == False >>> is_valid_email('email@domain..com') == False >>> is_valid_email('email@domain-.co') == False >>> is_valid_email('user.na.me@do.main.co') == True def filter_valid_emails(emails: List[str]) -> List[str]: Filters and returns a list of valid emails according to the defined rules. >>> input_emails = ['test.email@example.com', 'username@domain.com', '.invalid@domain.com', 'username@domain,com', 'invalid@domain..com', 'email@domain.com.'] >>> filter_valid_emails(input_emails) == ['test.email@example.com', 'username@domain.com'] >>> input_emails = ['valid.email@domain.com', 'another.valid@domain.io', 'invalid..dots@domain.com', 'noat.com', 'missingpart@.com', 'user@domaincom'] >>> filter_valid_emails(input_emails) == ['valid.email@domain.com', 'another.valid@domain.io'] >>> input_emails = [] >>> filter_valid_emails(input_emails) == [] >>> input_emails = ['a@b.co', '123@domain.com', 'user-name@domain.org'] >>> filter_valid_emails(input_emails) == ['a@b.co', '123@domain.com', 'user-name@domain.org']","solution":"import re def is_valid_email(email): Returns True if the email is valid according to the defined rules, False otherwise. try: local, domain = email.split('@') except ValueError: return False # Validate local part if not re.match(r'^[a-zA-Z0-9]+([._-]?[a-zA-Z0-9]+)*', local): return False # Validate domain part if not re.match(r'^[a-zA-Z0-9]+(.[a-zA-Z0-9]+)*.[a-zA-Z]{2,}', domain): return False if '..' in domain: # Consecutive dots in domain are not allowed return False return True def filter_valid_emails(emails): Filters and returns a list of valid emails according to the defined rules. return [email for email in emails if is_valid_email(email)]"},{"question":"def remove_duplicate_characters(s): Takes a string and returns a new string with all duplicate characters removed. The order of characters in the returned string is the same as the first appearance in the original string. Parameters: s (str): Input string Returns: str: String with all duplicate characters removed pass from solution import remove_duplicate_characters def test_remove_duplicates_basic(): assert remove_duplicate_characters(\\"programming\\") == \\"progamin\\" def test_remove_duplicates_repeating_characters(): assert remove_duplicate_characters(\\"aabbcc\\") == \\"abc\\" def test_remove_duplicates_mixed_characters(): assert remove_duplicate_characters(\\"hello\\") == \\"helo\\" def test_remove_duplicates_empty_string(): assert remove_duplicate_characters(\\"\\") == \\"\\" def test_remove_duplicates_single_character(): assert remove_duplicate_characters(\\"a\\") == \\"a\\" def test_remove_duplicates_no_duplicates(): assert remove_duplicate_characters(\\"abcdef\\") == \\"abcdef\\"","solution":"def remove_duplicate_characters(s): Takes a string and returns a new string with all duplicate characters removed. The order of characters in the returned string is the same as the first appearance in the original string. Parameters: s (str): Input string Returns: str: String with all duplicate characters removed seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def max_energy(N: int, energy_levels: List[int]) -> int: Returns the maximum energy that can be gathered from any contiguous subsequence of construction steps. Parameters: N (int): The number of construction steps. energy_levels (list of int): The energy required for each construction step. Return: int: The maximum energy that can be gathered. >>> max_energy(5, [1, -2, 3, 5, -1]) 8 >>> max_energy(1, [10]) 10 >>> max_energy(5, [1, 2, 3, 4, 5]) 15 >>> max_energy(5, [-1, -2, -3, -4, -5]) -1 >>> max_energy(6, [3, -1, 4, -1, 2, 1]) 8 >>> max_energy(8, [-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_energy(9, [10**9, -10**9, 10**9, -10**9, 10**9, -10**9, 10**9, -10**9, 10**9]) 10**9","solution":"def max_energy(N, energy_levels): Returns the maximum energy that can be gathered from any contiguous subsequence of construction steps. Parameters: N (int): The number of construction steps. energy_levels (list of int): The energy required for each construction step. Return: int: The maximum energy that can be gathered. max_current = max_global = energy_levels[0] for i in range(1, N): max_current = max(energy_levels[i], max_current + energy_levels[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def decode_string(s: str) -> str: Given an encoded string, return its decoded string where encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. Example: >>> decode_string(\\"3[a]2[bc]\\") \\"aaabcbc\\" >>> decode_string(\\"3[a2[c]]\\") \\"accaccacc\\" >>> decode_string(\\"2[abc]3[cd]ef\\") \\"abcabccdcdcdef\\" >>> decode_string(\\"abc3[cd]xyz\\") \\"abccdcdcdxyz\\" >>> decode_string(\\"1[a]\\") \\"a\\"","solution":"def decode_string(s): Given an encoded string, return its decoded string where encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. stack = [] current_string = \\"\\" current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == ']': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"def numIslands(grid: List[List[str]]) -> int: Returns the number of distinct islands in the grid. >>> numIslands([[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"],[\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"]]) 3 >>> numIslands([[\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"],[\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"],[\\"0\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"]]) 5 pass","solution":"def numIslands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # mark as visited dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': count += 1 dfs(grid, i, j) return count"},{"question":"from typing import List def count_unique_prices(prices: List[int]) -> int: Determines the number of unique stock prices in the given list. >>> count_unique_prices([100, 200, 100, 300, 200, 400]) 4 >>> count_unique_prices([50, 50, 50, 50, 50]) 1 >>> count_unique_prices([75, 85, 95, 85, 75]) 3 >>> count_unique_prices([]) 0 >>> count_unique_prices([100]) 1 >>> count_unique_prices([1, 50, 30, 1, 50, 100]) 4 >>> count_unique_prices([1, 2, 3, 4, 5]) 5 >>> count_unique_prices([-1, -2, 0, -1, 0, 2, 3]) 5 >>> count_unique_prices([10**6, 10**7, 10**6, 10**9]) 3","solution":"from typing import List def count_unique_prices(prices: List[int]) -> int: Returns the number of unique stock prices in the given list. return len(set(prices))"},{"question":"def can_construct_message(message: str, magazine: str) -> bool: Determine whether a message can be constructed from the letters in a given magazine. Each letter in the magazine string can only be used once in the message. >>> can_construct_message(\\"hello\\", \\"heohlleo\\") True >>> can_construct_message(\\"baby\\", \\"bba\\") False >>> can_construct_message(\\"aabbcc\\", \\"abacbcabc\\") True Args: message (str): The message to be constructed. magazine (str): The magazine string to use for constructing the message. Returns: bool: True if the message can be constructed, False otherwise.","solution":"def can_construct_message(message, magazine): from collections import Counter message_counter = Counter(message) magazine_counter = Counter(magazine) for char, count in message_counter.items(): if magazine_counter[char] < count: return False return True"},{"question":"def create_prefix_sum(grid, n): Create a prefix sum matrix for the given grid. >>> grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] >>> create_prefix_sum(grid, 4) [ [0, 0, 0, 0, 0], [0, 1, 3, 6, 10], [0, 6, 14, 24, 36], [0, 15, 33, 54, 78], [0, 28, 60, 96, 136] ] pass def compute_subgrid_sum(prefix_sum, x1, y1, x2, y2): Compute the sum of the subgrid (x1, y1, x2, y2) using the prefix sum matrix. >>> prefix_sum = [ [0, 0, 0, 0, 0], [0, 1, 3, 6, 10], [0, 6, 14, 24, 36], [0, 15, 33, 54, 78], [0, 28, 60, 96, 136] ] >>> compute_subgrid_sum(prefix_sum, 1, 1, 2, 2) 14 >>> compute_subgrid_sum(prefix_sum, 1, 1, 4, 4) 136 >>> compute_subgrid_sum(prefix_sum, 2, 2, 3, 3) 34 pass def process_queries(n, q, grid_values, queries): Process the queries to find the sum of values in each subgrid. >>> n = 4 >>> q = 3 >>> grid_values = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ] >>> queries = [ (1, 1, 2, 2), (1, 1, 4, 4), (2, 2, 3, 3) ] >>> process_queries(n, q, grid_values, queries) [14, 136, 34] pass from solution import create_prefix_sum, compute_subgrid_sum, process_queries def test_create_prefix_sum(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] n = 4 expected = [ [0, 0, 0, 0, 0], [0, 1, 3, 6, 10], [0, 6, 14, 24, 36], [0, 15, 33, 54, 78], [0, 28, 60, 96, 136] ] prefix_sum = create_prefix_sum(grid, n) assert prefix_sum == expected def test_compute_subgrid_sum(): prefix_sum = [ [0, 0, 0, 0, 0], [0, 1, 3, 6, 10], [0, 6, 14, 24, 36], [0, 15, 33, 54, 78], [0, 28, 60, 96, 136] ] assert compute_subgrid_sum(prefix_sum, 1, 1, 2, 2) == 14 assert compute_subgrid_sum(prefix_sum, 1, 1, 4, 4) == 136 assert compute_subgrid_sum(prefix_sum, 2, 2, 3, 3) == 34 def test_process_queries(): n = 4 q = 3 grid_values = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ] queries = [ (1, 1, 2, 2), (1, 1, 4, 4), (2, 2, 3, 3) ] expected = [14, 136, 34] assert process_queries(n, q, grid_values, queries) == expected","solution":"def create_prefix_sum(grid, n): MOD = 10**9 + 7 prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): prefix_sum[i][j] = (grid[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) % MOD return prefix_sum def compute_subgrid_sum(prefix_sum, x1, y1, x2, y2): MOD = 10**9 + 7 return (prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]) % MOD def process_queries(n, q, grid_values, queries): MOD = 10**9 + 7 grid = [grid_values[i * n:(i + 1) * n] for i in range(n)] prefix_sum = create_prefix_sum(grid, n) results = [] for query in queries: x1, y1, x2, y2 = query result = compute_subgrid_sum(prefix_sum, x1, y1, x2, y2) results.append(result) return results"},{"question":"def max_interactions(initialTreats: int, multiplier: int, limit: int) -> int: Determine the maximum number of interactions you can make while not exceeding the total treat limit. Args: initialTreats (int): The number of treats the vending machine provides on the first interaction. multiplier (int): The multiplier for the number of treats given in each subsequent interaction. limit (int): The maximum total number of treats the vending machine can give out. Returns: int: The maximum number of interactions. Examples: >>> max_interactions(2, 3, 20) 2 >>> max_interactions(1, 2, 20) 4 >>> max_interactions(5, 2, 100) 4 >>> max_interactions(2, 5, 500) 4 >>> max_interactions(10, 3, 350) 3 >>> max_interactions(3, 4, 500) 4 pass","solution":"def max_interactions(initialTreats, multiplier, limit): total_treats = 0 count = 0 current_treats = initialTreats while total_treats + current_treats <= limit: total_treats += current_treats count += 1 current_treats *= multiplier return count"},{"question":"def region_sum(matrix, topLeft, bottomRight): Find the sum of all the values in a specific region within the matrix, determined by two opposite corners of the region. The region is defined by the coordinates of its corners, where (0,0) refers to the top-left cell of the matrix and the coordinates (i,j) refer to the cell at the ith row and jth column. The input will provide these corners as (r1, c1) and (r2, c2), where (r1, c1) is the top-left corner of the region and (r2, c2) is the bottom-right corner of the region. >>> region_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...], (1, 1), (2, 2)) 28 >>> region_sum([ ... [1, 2], ... [3, 4] ...], (1, 1), (1, 1)) 4 >>> region_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...], (0, 0), (2, 2)) 45 >>> region_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...], (1, 0), (1, 2)) 15 >>> region_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...], (0, 1), (2, 1)) 15","solution":"def region_sum(matrix, topLeft, bottomRight): r1, c1 = topLeft r2, c2 = bottomRight total_sum = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): total_sum += matrix[i][j] return total_sum"},{"question":"def minimum_steps(initial_value, target_value, I, D): Determine the minimum steps (router transitions) required to convert a packet's initial value to the target value. Args: initial_value (int): Initial value of the packet. target_value (int): Target value of the packet. I (int): Number of routers that can increment values. D (int): Number of routers that can decrement values. Returns: int: Minimum number of steps required to achieve the target value, or \`-1\` if not possible. >>> minimum_steps(3, 7, 5, 0) 4 >>> minimum_steps(10, 3, 3, 10) 7 >>> minimum_steps(5, 5, 1, 1) 0 pass def process_test_cases(test_cases): Process multiple test cases to determine the minimum steps required for each case. Args: test_cases (list): List of tuples, each containing (initial_value, target_value, I, D). Returns: list: List of results for each test case. >>> test_cases = [(3, 7, 5, 0), (10, 3, 3, 10), (5, 5, 1, 1)] >>> process_test_cases(test_cases) [4, 7, 0] >>> test_cases = [(0, 0, 0, 0), (4, 10, 6, 2), (10, 4, 2, 6)] >>> process_test_cases(test_cases) [0, 6, 6] >>> test_cases = [(0, 1, 1, 0), (1, 0, 0, 1), (0, 2, 1, 1), (2, 0, 1, 1)] >>> process_test_cases(test_cases) [1, 1, -1, -1] pass","solution":"def minimum_steps(initial_value, target_value, I, D): diff = target_value - initial_value if diff > 0: # Need to increment if diff <= I: return diff else: return -1 elif diff < 0: # Need to decrement if -diff <= D: return -diff else: return -1 else: # initial_value == target_value return 0 def process_test_cases(test_cases): results = [] for test_case in test_cases: initial_value, target_value, I, D = test_case results.append(minimum_steps(initial_value, target_value, I, D)) return results"},{"question":"def expand_string(s: str) -> str: Expands the string such that each integer, n, follows by the sequence of letters and repeats them n times. For example: Input: \\"a2b1\\" Output: \\"aab\\" >>> expand_string(\\"a2b1\\") \\"aab\\" >>> expand_string(\\"x3y2z1\\") \\"xxxyyz\\" >>> expand_string(\\"m5n3p2\\") \\"mmmmmnnnpp\\" >>> expand_string(\\"a2b2c3\\") \\"aabbccc\\"","solution":"def expand_string(s): Expands the string such that each integer, n, follows by the sequence of letters and repeats them n times. For example: Input: \\"a2b1\\" Output: \\"aab\\" result = [] i = 0 while i < len(s): if s[i].isalpha(): seq_start = i while i + 1 < len(s) and s[i + 1].isdigit(): i += 1 seq_end = i number = int(s[seq_start + 1:seq_end + 1]) if seq_end > seq_start else 1 result.append(s[seq_start] * number) i += 1 return ''.join(result)"},{"question":"def minimal_difference(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Divide stones into two subsets to minimize the absolute difference between their power levels. Args: test_cases (List[Tuple[int, List[int]]]): A list containing the number of stones and their power levels. Returns: List[int]: A list containing the minimal absolute difference for each test case. Examples: >>> minimal_difference([(5, [1, 2, 3, 4, 5])]) [1] >>> minimal_difference([(4, [10, 20, 15, 25])]) [0]","solution":"def minimal_difference(test_cases): def subset_sum(arr, n, total_sum): dp = [[False for _ in range(total_sum + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] diff = float('inf') for j in range(total_sum // 2, -1, -1): if dp[n][j] == True: diff = total_sum - 2 * j break return diff results = [] for case in test_cases: n, *arr = case total_sum = sum(arr) results.append(subset_sum(arr, n, total_sum)) return results"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix([ ... [1] ... ]) [[1]]","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise. N = len(matrix) # Create a new matrix to store the result rotated_matrix = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] return rotated_matrix"},{"question":"def categorize_flowers(test_cases: List[List[Tuple[str, str]]]) -> List[str]: Categorize and sort flowers based on their type and color. >>> categorize_flowers([[(\\"rose\\", \\"red\\"), (\\"lily\\", \\"white\\"), (\\"rose\\", \\"yellow\\")]]) [\\"lily white\\", \\"rose red yellow\\"] >>> categorize_flowers([[(\\"tulip\\", \\"purple\\"), (\\"daffodil\\", \\"yellow\\"), (\\"rose\\", \\"pink\\"), (\\"daffodil\\", \\"white\\")]]) [\\"daffodil white yellow\\", \\"rose pink\\", \\"tulip purple\\"] pass def process_input(input_data: str) -> List[List[Tuple[str, str]]]: Process input data into structured test cases. >>> input_data = \\"2n3nrose rednlily whitenrose yellown4ntulip purplendaffodil yellownrose pinkndaffodil white\\" >>> process_input(input_data) [[(\\"rose\\", \\"red\\"), (\\"lily\\", \\"white\\"), (\\"rose\\", \\"yellow\\")], [(\\"tulip\\", \\"purple\\"), (\\"daffodil\\", \\"yellow\\"), (\\"rose\\", \\"pink\\"), (\\"daffodil\\", \\"white\\")]] pass","solution":"def categorize_flowers(test_cases): result = [] for flowers in test_cases: flower_dict = {} for flower in flowers: flower_type, flower_color = flower if flower_type not in flower_dict: flower_dict[flower_type] = [] flower_dict[flower_type].append(flower_color) sorted_flower_types = sorted(flower_dict.keys()) for flower_type in sorted_flower_types: colors = sorted(flower_dict[flower_type]) result.append(f'{flower_type} {\\" \\".join(colors)}') return result def process_input(input_data): lines = input_data.strip().split('n') idx = 0 num_tests = int(lines[idx]) idx += 1 test_cases = [] for _ in range(num_tests): num_flowers = int(lines[idx]) idx += 1 flowers = [] for _ in range(num_flowers): flower_type, flower_color = lines[idx].split() flowers.append((flower_type, flower_color)) idx += 1 test_cases.append(flowers) return test_cases"},{"question":"def find_first_non_repeating_letter(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating or the string is empty, returns an empty string. >>> find_first_non_repeating_letter(\\"stress\\") 't' >>> find_first_non_repeating_letter(\\"moonmen\\") 'o' >>> find_first_non_repeating_letter(\\"aabbcc\\") '' >>> find_first_non_repeating_letter(\\"\\") '' >>> find_first_non_repeating_letter(\\"sTreSS\\") 'T' >>> find_first_non_repeating_letter(\\"MoonmEn\\") 'M'","solution":"def find_first_non_repeating_letter(s): Returns the first non-repeating character in the string s. If all characters are repeating or the string is empty, returns an empty string. s_lower = s.lower() for index, char in enumerate(s_lower): if s_lower.count(char) == 1: return s[index] return \\"\\""},{"question":"def find_odd_occurrence(lst: List[int]) -> int: Returns the integer from the list that appears an odd number of times. >>> find_odd_occurrence([2, 2, 3, 4, 3, 3, 4]) == 3 >>> find_odd_occurrence([6, 1, 1, 6, 6, 1, 1]) == 6 >>> find_odd_occurrence([5, 7, 7, 5, 9, 9, 4, 4, 8]) == 8 >>> find_odd_occurrence([10] * 10 + [20] * 20 + [30] * 15) == 30 >>> find_odd_occurrence([4, 4, 5, 5, 5]) == 5","solution":"def find_odd_occurrence(lst): Returns the integer from the list that appears an odd number of times. result = 0 for number in lst: result ^= number return result"},{"question":"def sum_even_fibs(limit: int) -> int: Returns the sum of all even Fibonacci numbers that are less than or equal to the given limit. >>> sum_even_fibs(0) == 0 >>> sum_even_fibs(1) == 0 >>> sum_even_fibs(2) == 2 >>> sum_even_fibs(8) == 10 >>> sum_even_fibs(33) == 10 >>> sum_even_fibs(34) == 44 >>> sum_even_fibs(89) == 44 >>> sum_even_fibs(-5) == 0 >>> sum_even_fibs(1000000) == 1089154 >>> sum_even_fibs(144) == 188 pass","solution":"def sum_even_fibs(limit): Returns the sum of all even Fibonacci numbers that are less than or equal to the given limit. Parameters: limit (int): The upper limit for Fibonacci numbers. Returns: int: Sum of all even Fibonacci numbers up to the given limit. if limit < 2: return 0 a, b = 0, 1 sum_even = 0 while b <= limit: if b % 2 == 0: sum_even += b a, b = b, a + b return sum_even"},{"question":"def countSquares(grid: List[List[int]]) -> int: Returns the number of square submatrices with all ones. >>> countSquares([ [0, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1] ]) == 15 >>> countSquares([ [1, 0, 1], [1, 1, 0], [1, 1, 0] ]) == 7","solution":"def countSquares(grid): Returns the number of square submatrices with all ones. rows = len(grid) cols = len(grid[0]) dp = [[0] * cols for _ in range(rows)] total_squares = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 total_squares += dp[i][j] return total_squares"},{"question":"def find_max_product(nums: List[int]) -> int: Write a function \`find_max_product\` that takes in a list of integers and returns the maximum product that can be obtained from any pair of numbers in the list. >>> find_max_product([1, 10, 2, 6, 5, 3]) 60 >>> find_max_product([-10, -20, 5, 7]) 200 >>> find_max_product([-10, -20, 5, 2, -3]) 200 >>> find_max_product([-1, -3, -4, -2]) 12 >>> find_max_product([1, 2]) 2 >>> find_max_product([-1, 2]) -2","solution":"def find_max_product(nums): n = len(nums) if n < 2: raise ValueError(\\"The input list must have at least two integers.\\") # Initialize the highest and lowest products of two numbers max1 = max2 = float('-inf') min1 = min2 = float('inf') for num in nums: # Update maximum values if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num # Update minimum values if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2)"},{"question":"def final_position(commands: str) -> (int, int): Determines the robot's final position on a 2D grid after a sequence of commands. >>> final_position(\\"\\") == (0, 0) >>> final_position(\\"U\\") == (0, 1) >>> final_position(\\"UUU\\") == (0, 3) >>> final_position(\\"D\\") == (0, -1) >>> final_position(\\"DDD\\") == (0, -3) >>> final_position(\\"L\\") == (-1, 0) >>> final_position(\\"LLL\\") == (-3, 0) >>> final_position(\\"R\\") == (1, 0) >>> final_position(\\"RRR\\") == (3, 0) >>> final_position(\\"UDLR\\") == (0, 0) >>> final_position(\\"URDL\\") == (0, 0) >>> final_position(\\"UUDDLRLR\\") == (0, 0) >>> final_position(\\"RRUULLDD\\") == (0, 0) >>> final_position(\\"RRUUDDLL\\") == (0, 0) >>> final_position(\\"UUU\\") == (0, 3) >>> final_position(\\"RRDD\\") == (2, -2)","solution":"def final_position(commands: str) -> (int, int): Determines the robot's final position on a 2D grid after a sequence of commands. Arguments: commands -- A string consisting of the characters 'U', 'D', 'L', 'R'. Returns: A tuple representing the final coordinates (x, y). x, y = 0, 0 # start at origin for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x, y"},{"question":"def canArrange(nums: List[int], k: int) -> bool: Determines if the elements of \`nums\` can be arranged into pairs such that the sum of each pair is divisible by \`k\`. >>> canArrange([1,2,3,4,5,10,6,7,8,9], 5) True >>> canArrange([1,2,3,4,5,6], 7) True >>> canArrange([1,2,3,4,5,6], 10) False >>> canArrange([2,4,6,8], 2) True","solution":"from collections import Counter def canArrange(nums, k): Determines if the elements of \`nums\` can be arranged into pairs such that the sum of each pair is divisible by \`k\`. remainder_count = Counter(num % k for num in nums) for remainder in remainder_count: if remainder == 0: if remainder_count[remainder] % 2 != 0: return False else: if remainder_count[remainder] != remainder_count[k - remainder]: return False return True"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping intervals on a number line and return the resulting collection of merged intervals. >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 5), (2, 6), (3, 7), (8, 10), (9, 11)]) [(1, 7), (8, 11)] >>> merge_intervals([(6, 8), (1, 3), (2, 4), (4, 7)]) [(1, 8)] >>> merge_intervals([(8, 10), (15, 18), (1, 4), (2, 6), (17, 20)]) [(1, 6), (8, 10), (15, 20)]","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # Sort intervals by the start points intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last = merged[-1] if current[0] <= last[1]: # Overlapping intervals merged[-1] = (last[0], max(last[1], current[1])) else: merged.append(current) return merged"},{"question":"def max_histogram_area(arr: List[int]) -> int: Calculate the largest rectangular area that can be formed from the contiguous bars of a histogram. Parameters: arr (List[int]): A list of integers where each integer represents the height of a bar in a histogram. Returns: int: The maximum rectangular area that can be formed. >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([2, 4]) 4 >>> max_histogram_area([1, 2, 3, 4, 5]) 9 >>> max_histogram_area([5, 4, 1, 2]) 8 >>> max_histogram_area([6]) 6 import unittest class TestMaxHistogramArea(unittest.TestCase): def test_max_histogram_area_example_1(self): self.assertEqual(max_histogram_area([2, 1, 5, 6, 2, 3]), 10) def test_max_histogram_area_example_2(self): self.assertEqual(max_histogram_area([2, 4]), 4) def test_max_histogram_area_example_3(self): self.assertEqual(max_histogram_area([1, 2, 3, 4, 5]), 9) def test_max_histogram_area_example_4(self): self.assertEqual(max_histogram_area([5, 4, 1, 2]), 8) def test_max_histogram_area_example_5(self): self.assertEqual(max_histogram_area([6]), 6) def test_max_histogram_area_repeated_height(self): self.assertEqual(max_histogram_area([2, 2, 2, 2]), 8) def test_max_histogram_area_all_same_height(self): self.assertEqual(max_histogram_area([5, 5, 5, 5, 5]), 25) def test_max_histogram_area_single_peak(self): self.assertEqual(max_histogram_area([1, 3, 2, 1]), 4) def test_max_histogram_area_valley(self): self.assertEqual(max_histogram_area([6, 2, 5, 4, 5, 1, 6]), 12) def test_max_histogram_area_decreasing_heights(self): self.assertEqual(max_histogram_area([5, 4, 3, 2, 1]), 9) if __name__ == \\"__main__\\": unittest.main()","solution":"from typing import List def max_histogram_area(arr: List[int]) -> int: Returns the maximum rectangular area in a histogram given its heights. # This function uses a stack to keep track of the indices of the bars. stack = [] max_area = 0 index = 0 while index < len(arr): # If this bar is higher than the bar at stack top, push it to the stack. if not stack or arr[index] >= arr[stack[-1]]: stack.append(index) index += 1 else: # Pop the top index. top_of_stack = stack.pop() # Calculate the area with arr[top_of_stack] as the smallest bar (height). area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed. max_area = max(max_area, area) # Now, pop the remaining bars from the stack and calculate area. while stack: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a grid with obstacles. Args: grid (List[List[int]]): The obstacle grid. Returns: int: The number of unique paths. Examples: >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1], ... [0, 0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [1, 0], ... [0, 0] ... ]) 0","solution":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def reverse_sentence(sentence: str) -> str: Returns the sentence with words in reversed order. >>> reverse_sentence(\\"The quick brown fox jumps over the lazy dog\\") \\"dog lazy the over jumps fox brown quick The\\" >>> reverse_sentence(\\"Hello\\") \\"Hello\\" >>> reverse_sentence(\\"\\") \\"\\" >>> reverse_sentence(\\"Hello world\\") \\"world Hello\\" >>> reverse_sentence(\\"Hello, world!\\") \\"world! Hello,\\" >>> reverse_sentence(\\"123 456 789\\") \\"789 456 123\\"","solution":"def reverse_sentence(sentence): Returns the sentence with words in reversed order. :param sentence: str, the input sentence :return: str, the sentence with words reversed words = sentence.split() reversed_words = words[::-1] reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"from typing import List def num_unique_emails(emails: List[str]) -> int: Determines the number of unique email addresses. Args: emails (list of str): a list of email address strings Returns: int: the number of unique email addresses Examples: >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.e.mail+bob.cathy@leetcode.com\\", \\"testemail+david@lee.tcode.com\\"]) 2 >>> num_unique_emails([\\"a@leetcode.com\\", \\"b@leetcode.com\\", \\"c@leetcode.com\\"]) 3 >>> num_unique_emails([\\"a@leetcode.com\\", \\"a@leet.code.com\\", \\"a+b@leet.code.com\\"]) 2 >>> num_unique_emails([\\"simpleemail@leetcode.com\\", \\"simpleemail2@leetcode.com\\"]) 2 >>> num_unique_emails([\\"email+xyz@leetcode.com\\", \\"em.ail+e@leetcode.com\\", \\"e.mail+b@leetcode.com\\"]) 1","solution":"def num_unique_emails(emails): Determines the number of unique email addresses. Args: emails (list of str): a list of email address strings Returns: int: the number of unique email addresses unique_emails = set() for email in emails: local_part, domain = email.split('@') local_part = local_part.split('+')[0].replace('.', '') unique_emails.add(f\\"{local_part}@{domain}\\") return len(unique_emails)"},{"question":"def findLargestLandmass(N: int, M: int, grid: List[str]) -> int: You are given a rectangular grid consisting of 'N' rows and 'M' columns with each cell either being land ('L') or water ('W'). You need to find the largest rectangular landmass (contiguous section of 'L' cells) that can be formed on the grid. A landmass is defined as a rectangle containing only 'L' cells. >>> findLargestLandmass(4, 5, [\\"LWLWL\\", \\"LLLWW\\", \\"WLLWL\\", \\"LLLWL\\"]) 6 >>> findLargestLandmass(3, 3, [\\"LLL\\", \\"LLL\\", \\"LLL\\"]) 9 >>> findLargestLandmass(3, 4, [\\"WWWW\\", \\"WWWW\\", \\"WWWW\\"]) 0 >>> findLargestLandmass(1, 5, [\\"LLWLL\\"]) 2 >>> findLargestLandmass(5, 1, [\\"L\\", \\"L\\", \\"W\\", \\"L\\", \\"L\\"]) 2 >>> findLargestLandmass(6, 6, [\\"LWWWLL\\", \\"LLLWLL\\", \\"LWLWLL\\", \\"LLLWLL\\", \\"LLLWWL\\", \\"LLLWLW\\"]) 9","solution":"def maximalRectangle(grid): if not grid: return 0 max_area = 0 N = len(grid) M = len(grid[0]) heights = [0] * M for row in grid: for idx in range(M): if row[idx] == 'L': heights[idx] += 1 else: heights[idx] = 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area # Function to take grid as input and return the area of the largest rectangle of 'L' def findLargestLandmass(N, M, grid): return maximalRectangle(grid)"},{"question":"from typing import List def determine_grade(scores: List[float]) -> str: Determines the letter grade for a student based on the average of the given scores. Parameters: scores (List[float]): A list of floating-point numbers representing the percentages of scores obtained by a student for the quiz Returns: str: The letter grade based on the average score according to the criteria: - 'A' for scores 90% and above. - 'B' for scores between 80% and 89%. - 'C' for scores between 70% and 79%. - 'D' for scores between 60% and 69%. - 'F' for scores below 60%. >>> determine_grade([85.0, 92.0, 88.0]) 'B' >>> determine_grade([55.0, 65.0, 70.0]) 'D' >>> determine_grade([95.0, 93.0, 97.0]) 'A' pass from solution import determine_grade def test_determine_grade_A(): assert determine_grade([95.0, 93.0, 97.0]) == 'A' assert determine_grade([90.0, 91.0, 92.0]) == 'A' def test_determine_grade_B(): assert determine_grade([85.0, 92.0, 88.0]) == 'B' assert determine_grade([80.0, 82.0, 85.0]) == 'B' def test_determine_grade_C(): assert determine_grade([70.0, 75.0, 78.0]) == 'C' assert determine_grade([72.0, 70.0, 74.0]) == 'C' def test_determine_grade_D(): assert determine_grade([65.0, 64.0, 60.0]) == 'D' assert determine_grade([61.0, 68.0, 69.0]) == 'D' def test_determine_grade_F(): assert determine_grade([55.0, 50.0, 45.0]) == 'F' assert determine_grade([59.0, 58.0, 55.0]) == 'F' def test_determine_grade_border_cases(): assert determine_grade([89.9, 89.9, 89.9]) == 'B' assert determine_grade([79.9, 79.9, 79.9]) == 'C' assert determine_grade([69.9, 69.9, 69.9]) == 'D' assert determine_grade([59.9, 59.9, 59.9]) == 'F' def test_determine_grade_single_score(): assert determine_grade([100.0]) == 'A' assert determine_grade([0.0]) == 'F' def test_empty_scores_list(): with pytest.raises(ValueError): determine_grade([])","solution":"from typing import List def determine_grade(scores: List[float]) -> str: Determines the letter grade for a student based on the average of the given scores. Parameters: scores (List[float]): A list of floating-point numbers representing the percentages of scores Returns: str: The letter grade based on the average score if not scores: raise ValueError(\\"The list of scores cannot be empty.\\") average_score = sum(scores) / len(scores) if average_score >= 90: return 'A' elif average_score >= 80: return 'B' elif average_score >= 70: return 'C' elif average_score >= 60: return 'D' else: return 'F'"},{"question":"from typing import List def is_perfect_number(num: int) -> bool: Determines if a number is a Perfect Number. A Perfect Number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself. >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(10) False def check_perfect_numbers(numbers: List[int]) -> List[str]: Given a list of integers, determine if each integer is a \\"Perfect Number\\". Returns a list of \\"YES\\" or \\"NO\\". >>> check_perfect_numbers([6, 28, 10]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_perfect_numbers([12, 496, 20, 8128]) [\\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> check_perfect_numbers([1, 0, -6, 2]) [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def is_perfect_number(num): Determines if a number is a Perfect Number. A Perfect Number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself. if num <= 1: return False divisor_sum = 1 # Start with 1, which is a proper divisor of any positive integer sqrt_num = int(num**0.5) for i in range(2, sqrt_num + 1): if num % i == 0: divisor_sum += i + (num // i if i != num // i else 0) return divisor_sum == num def check_perfect_numbers(numbers): Given a list of integers, determine if each integer is a \\"Perfect Number\\". Returns a list of \\"YES\\" or \\"NO\\". return [\\"YES\\" if is_perfect_number(num) else \\"NO\\" for num in numbers]"},{"question":"def max_product(nums: List[int]) -> int: Given a list of non-negative integers, return the maximum product that can be achieved by multiplying any two different elements from the list. Examples: >>> max_product([3, 4, 5, 2]) 20 >>> max_product([1, 5, 4, 5]) 25 >>> max_product([7, 1, 8, 3, 6, 4]) 56","solution":"def max_product(nums): Returns the maximum product of two distinct elements in the list nums. # Sort the list in descending order and pick the first two elements nums.sort(reverse=True) return nums[0] * nums[1]"},{"question":"from typing import List def longest_increasing_subsequence(sequence: List[int]) -> int: Find the length of the longest increasing subsequence in a list of integers. A subsequence is derived from a sequence by deleting some or no elements without changing the order of the remaining elements. Examples: >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 # Your code here pass","solution":"def longest_increasing_subsequence(sequence): if not sequence: return 0 dp = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def shift_digits(number: int, positions: int) -> int: Shifts the digits of an integer to the left by a given number of positions. If the number is positive, the shifted digits remain positive. If the number is negative, the shifted digits remain negative. If positions exceed the length of the number, return 0. >>> shift_digits(12345, 2) == 34512 >>> shift_digits(-98765, 3) == -65219 >>> shift_digits(1234, 5) == 0 from solution import shift_digits def test_shift_digits_positive_numbers(): assert shift_digits(12345, 2) == 34512 assert shift_digits(987654, 3) == 654987 def test_shift_digits_negative_numbers(): assert shift_digits(-12345, 2) == -34512 assert shift_digits(-987654, 3) == -654987 def test_shift_digits_exceeds_length(): assert shift_digits(1234, 5) == 0 assert shift_digits(-987, 4) == 0 def test_shift_digits_zero_positions(): assert shift_digits(12345, 0) == 12345 assert shift_digits(-98765, 0) == -98765 def test_shift_digits_single_digit(): assert shift_digits(5, 1) == 0 assert shift_digits(-9, 1) == 0","solution":"def shift_digits(number, positions): Shifts the digits of an integer to the left by a given number of positions. If the number is positive, the shifted digits remain positive. If the number is negative, the shifted digits remain negative. If positions exceed the length of the number, return 0. is_negative = number < 0 number_str = str(abs(number)) if positions >= len(number_str): return 0 shifted_str = number_str[positions:] + number_str[:positions] result = int(shifted_str) return -result if is_negative else result"},{"question":"def num_pits(matrix): Returns the number of pits in the matrix. A pit is defined as a group of connected cells with the same height surrounded entirely by cells with higher height. from solution import num_pits def test_example_1(): matrix = [ [1, 2, 3], [2, 1, 2], [3, 2, 1] ] assert num_pits(matrix) == 1 def test_example_2(): matrix = [ [1, 2, 3, 2, 1], [2, 1, 2, 1, 2], [3, 2, 1, 2, 3], [2, 1, 2, 1, 2], [1, 2, 3, 2, 1] ] assert num_pits(matrix) == 5 def test_empty_matrix(): matrix = [] assert num_pits(matrix) == 0 def test_all_same_height(): matrix = [ [1, 1], [1, 1] ] assert num_pits(matrix) == 0 def test_no_pits(): matrix = [ [1, 2, 3], [2, 3, 2], [3, 2, 1] ] assert num_pits(matrix) == 0 def test_multiple_pits(): matrix = [ [3, 3, 3, 3, 3], [3, 1, 2, 1, 3], [3, 2, 3, 2, 3], [3, 1, 2, 1, 3], [3, 3, 3, 3, 3] ] assert num_pits(matrix) == 4","solution":"def num_pits(matrix): Returns the number of pits in the matrix. A pit is defined as a group of connected cells with the same height surrounded entirely by cells with higher height. if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) visited = [[False] * cols for _ in range(rows)] def is_pit(r, c): Check if the cell (r, c) is part of a pit. queue = [(r, c)] height = matrix[r][c] cells = [(r, c)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] is_surrounded = True while queue: cr, cc = queue.pop(0) for dr, dc in directions: nr, nc = cr + dr, cc + dc if 0 <= nr < rows and 0 <= nc < cols: if matrix[nr][nc] < height: is_surrounded = False elif matrix[nr][nc] == height and not visited[nr][nc]: visited[nr][nc] = True queue.append((nr, nc)) cells.append((nr, nc)) else: is_surrounded = False return is_surrounded pit_count = 0 for r in range(rows): for c in range(cols): if not visited[r][c]: visited[r][c] = True if is_pit(r, c): pit_count += 1 return pit_count"},{"question":"from typing import List, Tuple def total_ribbon_length(boxes: List[Tuple[int, int, int]]) -> int: Compute the total ribbon length required to wrap a given set of boxes. Each box is represented as a tuple of three integers (length, width, height). >>> total_ribbon_length([(2, 3, 4)]) == 34 >>> total_ribbon_length([(1, 1, 10)]) == 14 >>> total_ribbon_length([(2, 3, 4), (1, 1, 10)]) == 48 >>> total_ribbon_length([]) == 0 >>> total_ribbon_length([(2, 3)]) == -1 >>> total_ribbon_length([(2, -3, 4)]) == -1 >>> total_ribbon_length([(2, 3, 4, 5)]) == -1 >>> total_ribbon_length([(2, 3, 4), (2, -3, 4)]) == -1","solution":"from typing import List, Tuple def total_ribbon_length(boxes: List[Tuple[int, int, int]]) -> int: def ribbon_length_for_box(length: int, width: int, height: int) -> int: perimeters = [ 2 * (length + width), 2 * (width + height), 2 * (height + length) ] smallest_perimeter = min(perimeters) volume = length * width * height return smallest_perimeter + volume total_length = 0 for box in boxes: if len(box) != 3 or not all(isinstance(dimension, int) and dimension > 0 for dimension in box): return -1 length, width, height = box total_length += ribbon_length_for_box(length, width, height) return total_length"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([4, 5, 6]) [30, 24, 20]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. if not nums: return [] length = len(nums) result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"from typing import List def find_pair_with_sum(arr: List[int], k: int) -> bool: Returns True if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k >>> find_pair_with_sum([10, 15, 3, 7], 17) True >>> find_pair_with_sum([1, 2, 3, 9], 8) False >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> find_pair_with_sum([], 1) False >>> find_pair_with_sum([1], 1) False >>> find_pair_with_sum([1, 4, 5, 6], 7) True >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) False pass","solution":"from typing import List def find_pair_with_sum(arr: List[int], k: int) -> bool: Returns True if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"def find_minimum_toll(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Find the minimum sum of toll fees required to connect all cities. Parameters: n (int): Number of cities. m (int): Number of roads. roads (list of tuples): Each tuple contains three integers a, b, and c signifying a road between cities a and b with a toll fee of c. Returns: int: Minimum sum of toll fees required to connect all cities. If not possible, return -1. from typing import List, Tuple def test_example_case(): n = 4 m = 5 roads = [ (1, 2, 1), (1, 3, 4), (2, 3, 3), (2, 4, 2), (3, 4, 5) ] assert find_minimum_toll(n, m, roads) == 6 def test_connected_cities(): n = 3 m = 3 roads = [ (1, 2, 1), (2, 3, 2), (1, 3, 3) ] assert find_minimum_toll(n, m, roads) == 3 def test_not_enough_roads(): n = 4 m = 2 roads = [ (1, 2, 1), (3, 4, 2) ] assert find_minimum_toll(n, m, roads) == -1 def test_single_city(): n = 1 m = 0 roads = [] assert find_minimum_toll(n, m, roads) == 0 def test_disconnected_components(): n = 4 m = 2 roads = [ (1, 2, 1), (3, 4, 2) ] assert find_minimum_toll(n, m, roads) == -1","solution":"def find_minimum_toll(n, m, roads): Find the minimum sum of toll fees required to connect all cities. Parameters: n (int): Number of cities. m (int): Number of roads. roads (list of tuples): Each tuple contains three integers a, b, and c signifying a road between cities a and b with a toll fee of c. Returns: int: Minimum sum of toll fees required to connect all cities. If not possible, return -1. # Sorting the roads based on the toll fee roads.sort(key=lambda x: x[2]) parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY total_toll = 0 edges_used = 0 for a, b, toll in roads: if find(a) != find(b): union(a, b) total_toll += toll edges_used += 1 if edges_used == n - 1: break # Check if we have used enough edges to connect all cities if edges_used == n - 1: return total_toll else: return -1"},{"question":"from collections import Counter def can_rearrange_palindrome(s: str) -> str: Determines if a given string can be rearranged to form a palindrome. Args: s (str): input string containing only lowercase alphabets Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_rearrange_palindrome(\\"aabbcc\\") \\"YES\\" >>> can_rearrange_palindrome(\\"aabbc\\") \\"YES\\" >>> can_rearrange_palindrome(\\"abc\\") \\"NO\\" >>> can_rearrange_palindrome(\\"a\\") \\"YES\\" >>> can_rearrange_palindrome(\\"aabbccddeeff\\") \\"YES\\" >>> can_rearrange_palindrome(\\"aabbccddeeffg\\") \\"YES\\" >>> can_rearrange_palindrome(\\"aaabbbccc\\") \\"NO\\" >>> can_rearrange_palindrome(\\"abcdefghijklmnopqrstuvwxyz\\") \\"NO\\" >>> can_rearrange_palindrome(\\"aaaaa\\") \\"YES\\" >>> can_rearrange_palindrome(\\"aaabbbbcccd\\") \\"NO\\"","solution":"def can_rearrange_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Args: s (str): input string containing only lowercase alphabets Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def highest_frequency_number(n: int, arr: List[int]) -> int: Finds the integer \`k\` that is the highest frequency number in the array. If multiple numbers have the highest frequency, returns the smallest one among them. :param n: int, number of integers in the array :param arr: list of int, the elements of the array :return: int, the number with the highest frequency Examples: >>> highest_frequency_number(5, [4, 4, 1, 1, 2]) 1 >>> highest_frequency_number(6, [1, 2, 2, 3, 3, 3]) 3 >>> highest_frequency_number(8, [7, 7, 8, 8, 9, 9, 9, 1]) 9 pass def test_case_1(): assert highest_frequency_number(5, [4, 4, 1, 1, 2]) == 1 def test_case_2(): assert highest_frequency_number(6, [1, 2, 2, 3, 3, 3]) == 3 def test_case_3(): assert highest_frequency_number(8, [7, 7, 8, 8, 9, 9, 9, 1]) == 9 def test_case_single_element(): assert highest_frequency_number(1, [1]) == 1 def test_case_all_elements_same(): assert highest_frequency_number(5, [2, 2, 2, 2, 2]) == 2 def test_case_multiple_high_freq(): assert highest_frequency_number(7, [2, 2, 3, 3, 4, 4, 1]) == 2","solution":"def highest_frequency_number(n, arr): Finds the integer k that is the highest frequency number in the array. If multiple numbers have the highest frequency, returns the smallest one among them. :param n: int, number of integers in the array :param arr: list of int, the elements of the array :return: int, the number with the highest frequency from collections import Counter # Count frequencies of each number frequency = Counter(arr) # Find the number with the highest frequency most_common = frequency.most_common() max_frequency = most_common[0][1] # Find the smallest number with the highest frequency candidates = [num for num, count in most_common if count == max_frequency] return min(candidates)"},{"question":"def detect_the_escape_artist(description: str) -> bool: Identifies whether the given description contains references to Houdini, escape artist, or master of escape. >>> detect_the_escape_artist(\\"He performed extraordinary feats, truly embodying the spirit of a master of escape!\\") True >>> detect_the_escape_artist(\\"This magician could rival even Houdini himself with his tricks.\\") True >>> detect_the_escape_artist(\\"His acts of illusion were unparalleled.\\") False","solution":"def detect_the_escape_artist(description): Identifies whether the given description contains references to Houdini, escape artist, or master of escape. Parameters: description (str): the description text to be analyzed Returns: bool: True if any of the terms are present, False otherwise terms = [\\"houdini\\", \\"escape artist\\", \\"master of escape\\"] description_lower = description.lower() for term in terms: if term in description_lower: return True return False"},{"question":"def is_balanced(expression: str) -> bool: Checks if all parentheses in the expression are correctly balanced. >>> is_balanced(\\"(a + b)\\") == True >>> is_balanced(\\"(a + (b + c))\\") == True >>> is_balanced(\\"((a + b) + c)\\") == True >>> is_balanced(\\"(a + b\\") == False >>> is_balanced(\\"a + b)\\") == False >>> is_balanced(\\"(a + (b + c)\\") == False >>> is_balanced(\\"a + (b + c))\\") == False","solution":"def is_balanced(expression): Checks if all parentheses in the expression are balanced. Parameters: expression (str): The input string representing a mathematical expression. Returns: bool: True if the parentheses are balanced, False otherwise. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def rearrange_list(N: int, integers: List[int]) -> List[int]: Rearranges the list such that all odd numbers come before the even numbers, while maintaining the relative order of odds and evens from the original list. >>> rearrange_list(5, [1, 2, 3, 4, 5]) [1, 3, 5, 2, 4] >>> rearrange_list(6, [4, 1, 3, 2, 7, 6]) [1, 3, 7, 4, 2, 6] def process_input(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Handles multiple test cases for rearrange_list function. >>> process_input(1, [(5, [1, 2, 3, 4, 5])]) [[1, 3, 5, 2, 4]] >>> process_input(2, [(5, [1, 2, 3, 4, 5]), (6, [4, 1, 3, 2, 7, 6])]) [[1, 3, 5, 2, 4], [1, 3, 7, 4, 2, 6]]","solution":"def rearrange_list(N, integers): Rearranges the list such that all odd numbers come before the even numbers, while maintaining the relative order of odds and evens from the original list. odd_numbers = [x for x in integers if x % 2 != 0] even_numbers = [x for x in integers if x % 2 == 0] return odd_numbers + even_numbers def process_input(T, test_cases): Handles multiple test cases for rearrange_list function. results = [] for i in range(T): N = test_cases[i][0] integers = test_cases[i][1] rearranged_list = rearrange_list(N, integers) results.append(rearranged_list) return results"},{"question":"def find_majority_element(nums: List[int]) -> Optional[int]: Create a function find_majority_element(nums) that takes a list of integers nums and returns the majority element, if it exists. The majority element is the element that appears more than n // 2 times, where n is the length of the list. If no such element exists, return None. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) None >>> find_majority_element([]) None >>> find_majority_element([1]) 1 >>> find_majority_element([2, 2, 2, 2, 2]) 2 >>> find_majority_element([1, 1, 2, 2, 3, 3]) None >>> find_majority_element([2, 2, 1, 1]) None >>> find_majority_element([1, 2, 2, 2, 3, 2, 2]) 2","solution":"def find_majority_element(nums): Returns the majority element if it exists, else returns None. A majority element is an element that appears more than n // 2 times, where n is the length of the list. n = len(nums) if n == 0: return None element_count = {} for num in nums: element_count[num] = element_count.get(num, 0) + 1 if element_count[num] > n // 2: return num return None"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if it's possible to make the string a palindrome by removing at most one character. >>> can_form_palindrome(\\"abca\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"abcdef\\") False def follow_decree(test_cases: List[str]) -> List[str]: For given test cases, checks if each string can be transformed into a palindrome by removing at most one character. >>> follow_decree([\\"abca\\", \\"racecar\\", \\"abcdef\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> follow_decree([\\"a\\", \\"aa\\", \\"ba\\", \\"ac\\", \\"bb\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if it's possible to make the string a palindrome by removing at most one character. def is_palindrome_range(s, i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # try removing either left or right character return is_palindrome_range(s, left+1, right) or is_palindrome_range(s, left, right-1) left += 1 right -= 1 return True def follow_decree(test_cases): For given test cases, checks if each string can be transformed into a palindrome by removing at most one character. results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def replica_function(a, b): Mimics the behavior of hidden_function based on deduced logic. pass # Unit tests to validate the replica_function def test_replica_function_positive_numbers(): assert replica_function(2, 3) == hidden_function(2, 3) def test_replica_function_with_zero(): assert replica_function(0, 5) == hidden_function(0, 5) assert replica_function(5, 0) == hidden_function(5, 0) def test_replica_function_negative_numbers(): assert replica_function(-1, -1) == hidden_function(-1, -1) def test_replica_function_mixed_sign_numbers(): assert replica_function(-1, 3) == hidden_function(-1, 3) def test_replica_function_large_numbers(): assert replica_function(1000000, 2000000) == hidden_function(1000000, 2000000)","solution":"def hidden_function(a, b): # This implementation is a placeholder. # Replace with the actual logic for real testing. return a + b # Example behavior, needs to be deduced. def replica_function(a, b): Mimics the behavior of hidden_function based on deduced logic. return a + b # Based on initial guessed behavior"},{"question":"def find_median(nums: List[int]) -> float: Returns the median value of a list of integers. If the list has an odd number of elements, the median is the middle element. If the list has an even number of elements, the median is the average of the two middle elements. >>> find_median([12, 4, 5, 3, 8, 7]) 6.0 >>> find_median([7, 1, 3, 4]) 3.5 >>> find_median([1]) 1 >>> find_median([1, 2, 3, 4, 5]) 3 >>> find_median([5, 4, 3, 2, 1]) 3 >>> find_median([5, 5, 5, 5, 5, 5]) 5 >>> find_median([10, 2, 4, 6]) 5.0 >>> find_median([-5, -1, -1, -2]) -1.5 >>> find_median([1.5, 3.5, 2.5, 4.5]) 3.0","solution":"def find_median(nums): Returns the median value of a list of integers. If the list has an odd number of elements, the median is the middle element. If the list has an even number of elements, the median is the average of the two middle elements. nums = sorted(nums) n = len(nums) mid = n // 2 if n % 2 == 1: return nums[mid] else: return (nums[mid - 1] + nums[mid]) / 2"},{"question":"import math from typing import List def sum_factorial_digits(n: int) -> int: Write a function that receives a positive integer \`n\` and returns the sum of all the digits in the factorial of \`n\`. Example: >>> sum_factorial_digits(5) # returns 3 (5! = 120, sum of digits = 1 + 2 + 0 = 3) >>> sum_factorial_digits(10) # returns 27 (10! = 3628800, sum of digits = 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27) def test_sum_factorial_digits(): assert sum_factorial_digits(5) == 3 assert sum_factorial_digits(10) == 27 assert sum_factorial_digits(0) == 1 # 0! is 1, so the sum of digits is 1 assert sum_factorial_digits(1) == 1 # 1! is 1, so the sum of digits is 1 assert sum_factorial_digits(4) == 6 # 4! is 24, so the sum of digits is 2 + 4 = 6 assert sum_factorial_digits(6) == 9 # 6! is 720, so the sum of digits is 7 + 2 + 0 = 9 assert sum_factorial_digits(15) == 45 # 15! is a large number but the sum of its digits is 45 assert sum_factorial_digits(20) == 54 # 20! sum of digits","solution":"import math def sum_factorial_digits(n): Returns the sum of all the digits in the factorial of n. Parameters: n (int): A positive integer Returns: int: The sum of all the digits in the factorial of n factorial_value = math.factorial(n) # Convert the factorial value to string and sum up the individual digits return sum(int(digit) for digit in str(factorial_value))"},{"question":"def max_absolute_difference_permutation(n): Returns a permutation of numbers from 1 to n that maximizes the sum of absolute differences between consecutive elements. def process_cases(t, cases): results = [] for n in cases: results.append(max_absolute_difference_permutation(n)) return results # Unit Tests def test_max_absolute_difference_permutation(): assert max_absolute_difference_permutation(2) == [2, 1] assert max_absolute_difference_permutation(3) == [3, 1, 2] assert max_absolute_difference_permutation(4) == [4, 1, 3, 2] assert max_absolute_difference_permutation(5) == [5, 1, 4, 2, 3] assert max_absolute_difference_permutation(6) == [6, 1, 5, 2, 4, 3] def test_process_cases(): cases = [2, 3, 4] results = process_cases(3, cases) assert results == [[2, 1], [3, 1, 2], [4, 1, 3, 2]] cases = [5, 6] results = process_cases(2, cases) assert results == [[5, 1, 4, 2, 3], [6, 1, 5, 2, 4, 3]]","solution":"def max_absolute_difference_permutation(n): Returns a permutation of numbers from 1 to n that maximizes the sum of absolute differences between consecutive elements. result = [] left = 1 right = n while left <= right: if left == right: result.append(left) else: result.append(right) result.append(left) left += 1 right -= 1 return result def process_cases(t, cases): results = [] for n in cases: results.append(max_absolute_difference_permutation(n)) return results"},{"question":"from typing import List def kth_largest_element(nums: List[int], k: int) -> int: Given an integer array nums of length n and an integer k, return the k-th largest element in the array. >>> kth_largest_element([3, 2, 1, 5, 6, 4], 2) 5 >>> kth_largest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 # Example usage: # print(kth_largest_element([3, 2, 1, 5, 6, 4], 2)) # Output: 5 # print(kth_largest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 4)) # Output: 4","solution":"import random def partition(nums, left, right): pivot_index = random.randint(left, right) pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[store_index], nums[right] = nums[right], nums[store_index] return store_index def quickselect(nums, left, right, k_smallest): if left == right: return nums[left] pivot_index = partition(nums, left, right) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(nums, left, pivot_index - 1, k_smallest) else: return quickselect(nums, pivot_index + 1, right, k_smallest) def kth_largest_element(nums, k): n = len(nums) index_to_find = n - k return quickselect(nums, 0, n - 1, index_to_find)"},{"question":"from typing import List, Union def product(numbers: List[Union[int, float]]) -> Union[int, float]: Compute the product of a list of numbers using recursion. If the list is empty, returns 1. >>> product([]) 1 >>> product([4, 5, 6]) 120 >>> product([-2, 3, -4]) 24 >>> product([1.5, 2.0, 3.0]) 9.0","solution":"def product(numbers): Returns the product of a list of numbers using recursion. If the list is empty, returns 1. if not numbers: return 1 return numbers[0] * product(numbers[1:])"},{"question":"def find_winner(votes: List[str]) -> Union[str, List[str]]: Write a function that simulates a simple voting system for a small club election. The function should accept a list of votes where each vote is a string representing the candidate voted for. The function should return the name of the candidate with the most votes. In case of a tie, return a list of names of the candidates who have the highest number of votes, sorted in alphabetical order. If no votes are cast, the function should return \\"No votes\\". Ensure to handle case sensitivity, i.e., \\"alice\\" and \\"Alice\\" should be considered different candidates. >>> find_winner([\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Eve\\", \\"Bob\\", \\"Alice\\"]) == \\"Alice\\" >>> find_winner([]) == \\"No votes\\" >>> find_winner([\\"Alice\\", \\"Bob\\", \\"Eve\\", \\"Bob\\", \\"Alice\\", \\"Eve\\"]) == [\\"Alice\\", \\"Bob\\", \\"Eve\\"] >>> find_winner([\\"Alice\\", \\"Alice\\", \\"Alice\\"]) == \\"Alice\\" >>> find_winner([\\"Alice\\", \\"bob\\", \\"Bob\\", \\"alice\\"]) == [\\"Alice\\", \\"Bob\\", \\"alice\\", \\"bob\\"]","solution":"from collections import Counter def find_winner(votes): Returns the candidate with the most votes, or a list of candidates sorted alphabetically in case of a tie. If no votes are cast, returns \\"No votes\\". if not votes: return \\"No votes\\" vote_count = Counter(votes) max_votes = max(vote_count.values()) winners = [candidate for candidate, count in vote_count.items() if count == max_votes] if len(winners) == 1: return winners[0] else: return sorted(winners)"},{"question":"def convert_to_12_hour_format(time_24: str) -> str: Converts a time from 24-hour format to 12-hour format with AM/PM. :param time_24: A string representing time in 24-hour format (e.g., \\"14:30\\"). :return: A string representing time in 12-hour format with AM/PM (e.g., \\"2:30 PM\\"). :raises ValueError: If the input time is not in the correct 24-hour format. >>> convert_to_12_hour_format(\\"00:00\\") \\"12:00 AM\\" >>> convert_to_12_hour_format(\\"12:00\\") \\"12:00 PM\\" >>> convert_to_12_hour_format(\\"13:45\\") \\"1:45 PM\\" >>> convert_to_12_hour_format(\\"00:05\\") \\"12:05 AM\\" >>> convert_to_12_hour_format(\\"23:59\\") \\"11:59 PM\\" pass","solution":"def convert_to_12_hour_format(time_24): Converts a time from 24-hour format to 12-hour format with AM/PM. :param time_24: A string representing time in 24-hour format (e.g., \\"14:30\\"). :return: A string representing time in 12-hour format with AM/PM (e.g., \\"2:30 PM\\"). :raises ValueError: If the input time is not in the correct 24-hour format. try: hours, minutes = map(int, time_24.split(\\":\\")) except ValueError: raise ValueError(\\"Invalid time format. Expected 'HH:MM'.\\") if not (0 <= hours < 24) or not (0 <= minutes < 60): raise ValueError(\\"Hour should be between 00 and 23, and minutes between 00 and 59.\\") period = \\"AM\\" if hours < 12 else \\"PM\\" hours = hours % 12 hours = 12 if hours == 0 else hours return f\\"{hours}:{minutes:02d} {period}\\""},{"question":"def is_balanced(s: str) -> bool: Determines if all characters in the input string appear the same number of times. Args: s (str): The input string containing only lowercase alphabetical characters. Returns: bool: True if the string is balanced; otherwise, False. >>> is_balanced(\\"aabbcc\\") True >>> is_balanced(\\"aabbccc\\") False","solution":"def is_balanced(s): Determines if all characters in the input string appear the same number of times. Args: s (str): The input string containing only lowercase alphabetical characters. Returns: bool: True if the string is balanced; otherwise, False. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Get the frequency of the first character to compare with others initial_count = next(iter(char_count.values())) # Check if all characters have the same frequency for count in char_count.values(): if count != initial_count: return False return True"},{"question":"def remove_consecutive_duplicates(lst: List[int]) -> List[int]: Returns a list of integers without any consecutive duplicates. >>> remove_consecutive_duplicates([1, 2, 2, 3, 3, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_consecutive_duplicates([7, 7, 6, 6, 6, 5, 5, 5, 5, 4, 3]) [7, 6, 5, 4, 3] pass","solution":"def remove_consecutive_duplicates(lst): Returns a list of integers without any consecutive duplicates. if not lst: return [] result = [lst[0]] for num in lst[1:]: if num != result[-1]: result.append(num) return result"},{"question":"class ProblemCollection: A class to manage a collection of favorite problems for users. Methods: add_problem_to_favorites(user_id: int, problem_id: int) Adds a problem to the user's favorite list if not already added. remove_problem_from_favorites(user_id: int, problem_id: int) Removes a problem from the user's favorite list if it exists. get_favorites_order(user_id: int) -> List[int] Returns the list of problem IDs in the order they were added to the favorites. def __init__(self): self.user_favorites = {} def add_problem_to_favorites(self, user_id: int, problem_id: int): Adds a problem to the user's favorite list if not already added. pass # Implement the function def remove_problem_from_favorites(self, user_id: int, problem_id: int): Removes a problem from the user's favorite list if it exists. pass # Implement the function def get_favorites_order(self, user_id: int) -> List[int]: Returns the list of problem IDs in the order they were added to the favorites. pass # Implement the function # Example Unit Tests def test_add_and_get_favorites(): pc = ProblemCollection() pc.add_problem_to_favorites(1, 101) pc.add_problem_to_favorites(1, 102) pc.add_problem_to_favorites(1, 103) assert pc.get_favorites_order(1) == [101, 102, 103] def test_add_duplicate_problem(): pc = ProblemCollection() pc.add_problem_to_favorites(1, 101) pc.add_problem_to_favorites(1, 102) pc.add_problem_to_favorites(1, 101) assert pc.get_favorites_order(1) == [101, 102] def test_remove_problem(): pc = ProblemCollection() pc.add_problem_to_favorites(1, 101) pc.add_problem_to_favorites(1, 102) pc.add_problem_to_favorites(1, 103) pc.remove_problem_from_favorites(1, 102) assert pc.get_favorites_order(1) == [101, 103] def test_remove_nonexistent_problem(): pc = ProblemCollection() pc.add_problem_to_favorites(1, 101) pc.add_problem_to_favorites(1, 102) pc.remove_problem_from_favorites(1, 999) assert pc.get_favorites_order(1) == [101, 102] def test_get_favorites_order_for_nonexistent_user(): pc = ProblemCollection() assert pc.get_favorites_order(999) == []","solution":"class ProblemCollection: def __init__(self): self.user_favorites = {} def add_problem_to_favorites(self, user_id, problem_id): if user_id not in self.user_favorites: self.user_favorites[user_id] = [] if problem_id not in self.user_favorites[user_id]: self.user_favorites[user_id].append(problem_id) def remove_problem_from_favorites(self, user_id, problem_id): if user_id in self.user_favorites: if problem_id in self.user_favorites[user_id]: self.user_favorites[user_id].remove(problem_id) def get_favorites_order(self, user_id): if user_id in self.user_favorites: return self.user_favorites[user_id] return []"},{"question":"def extract_subsequence(s: str, k: int) -> str: Returns the lexicographically smallest subsequence of length k that maintains the relative order of characters in the original string s. >>> extract_subsequence(\\"bacd\\", 2) 'ac' >>> extract_subsequence(\\"bcabc\\", 3) 'abc' >>> extract_subsequence(\\"a\\", 1) 'a' >>> extract_subsequence(\\"abc\\", 3) 'abc' >>> extract_subsequence(\\"zyx\\", 1) 'x' >>> extract_subsequence(\\"cba\\", 1) 'a' >>> extract_subsequence(\\"abacb\\", 3) 'aab' >>> extract_subsequence(\\"aaaaa\\", 2) 'aa' >>> extract_subsequence(\\"dcaebd\\", 3) 'abd' >>> extract_subsequence(\\"bca\\" * 100, 50) 'a' * 50 >>> extract_subsequence(\\"bbbbb\\", 3) 'bbb' >>> extract_subsequence(\\"ccccc\\", 1) 'c'","solution":"def extract_subsequence(s: str, k: int) -> str: Returns the lexicographically smallest subsequence of length k that maintains the relative order of characters in the original string s. stack = [] remaining = len(s) for char in s: while stack and stack[-1] > char and len(stack) + remaining - 1 >= k: stack.pop() if len(stack) < k: stack.append(char) remaining -= 1 return ''.join(stack)"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Find the length of the longest substring that contains at most k distinct characters. >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"abcdef\\", 3) 3 >>> length_of_longest_substring_k_distinct(\\"aaaa\\", 1) 4 >>> length_of_longest_substring_k_distinct(\\"abcdef\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"\\", 3) 0 >>> length_of_longest_substring_k_distinct(\\"abcd\\", 5) 4 >>> length_of_longest_substring_k_distinct(\\"aaa\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 2) 4","solution":"def length_of_longest_substring_k_distinct(s, k): Finds the length of the longest substring that contains at most k distinct characters. :param s: Input string consisting of lowercase letters. :param k: Integer indicating the maximum number of distinct characters. :return: Length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 char_map = {} left = 0 max_len = 0 for right in range(len(s)): char = s[right] if char in char_map: char_map[char] += 1 else: char_map[char] = 1 # While we have more than k distinct characters while len(char_map) > k: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 # Update max_len max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def number_of_valid_rearrangements(test_cases: List[str]) -> List[int]: Determine in how many ways the characters in each string can be rearranged such that no two adjacent characters are the same. Parameters: test_cases (List[str]): A list of strings consisting of characters 'a', 'b', and 'c'. Returns: List[int]: A list containing the number of valid rearrangements for each input string. >>> number_of_valid_rearrangements([\\"aabbcc\\"]) [90] >>> number_of_valid_rearrangements([\\"aaab\\"]) [0] >>> number_of_valid_rearrangements([\\"abc\\"]) [6] >>> number_of_valid_rearrangements([\\"a\\"]) [1] >>> number_of_valid_rearrangements([\\"aabbcc\\", \\"aaab\\", \\"abc\\"]) [90, 0, 6] def test_valid_rearrangement(): assert number_of_valid_rearrangements([\\"aabbcc\\"]) == [90] assert number_of_valid_rearrangements([\\"aaab\\"]) == [0] assert number_of_valid_rearrangements([\\"abc\\"]) == [6] def test_single_character(): assert number_of_valid_rearrangements([\\"a\\"]) == [1] def test_multiple_test_cases(): assert number_of_valid_rearrangements([\\"aabbcc\\", \\"aaab\\", \\"abc\\"]) == [90, 0, 6] def test_all_same_characters(): assert number_of_valid_rearrangements([\\"aaaa\\"]) == [0] assert number_of_valid_rearrangements([\\"bbbb\\"]) == [0] def test_two_same_characters(): assert number_of_valid_rearrangements([\\"aa\\", \\"bb\\"]) == [0, 0] def test_mixed_with_non_repeating(): assert number_of_valid_rearrangements([\\"aabc\\"]) == [12]","solution":"from collections import Counter from math import factorial def rearrange_count(s): counter = Counter(s) a, b, c = counter['a'], counter['b'], counter['c'] if max(a, b, c) > (len(s) + 1) // 2: return 0 num_permutations = factorial(len(s)) for count in counter.values(): num_permutations //= factorial(count) return num_permutations def number_of_valid_rearrangements(test_cases): results = [] for s in test_cases: results.append(rearrange_count(s)) return results"},{"question":"def max_score(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum score Alexa can achieve given the constraints. Parameters: ----------- T : int The number of test cases. test_cases : List[Tuple[Tuple[int, int], List[int]]] A list where each element is a tuple with two elements: - A tuple (N, K) where N is the number of questions and K is the maximum number of questions that can be skipped. - A list of integers representing the point values of the questions. Returns: -------- List[int] List of integers where each integer is the maximum score Alexa can achieve for each test case. >>> max_score(2, [((5, 2), [10, 20, 30, 40, 50]), ((4, 1), [5, 15, 10, 25])]) [120, 50] >>> max_score(1, [((3, 1), [1000, 999, 998])]) [1999] >>> max_score(1, [((3, 2), [1, 2, 3])]) [3] >>> max_score(1, [((1, 0), [500])]) [500] >>> max_score(1, [((5, 4), [1, 1, 1, 1, 1000])]) [1000]","solution":"def max_score(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] points = test_cases[i][1] # Sort points in descending order points.sort(reverse=True) # Alexa can skip at most K questions, so she will answer the highest N-K questions max_points = sum(points[:N-K]) # Record the result for this test case results.append(max_points) return results"},{"question":"def manipulate_array(N, arr): Manipulate the array based on the instruction N. - If N is 1, reverse the array. - If N is 2, find the sum of the array elements. - If N is 3, find the product of the array elements. Parameters: - N: int - Instruction for the manipulation - arr: list of int - The array to be manipulated Returns: - list or int: Result of the manipulation >>> manipulate_array(1, [1, 2, 3, 4]) [4, 3, 2, 1] >>> manipulate_array(2, [10, 20, 30]) 60 >>> manipulate_array(3, [1, 2, 3, 4, 5]) 120","solution":"def manipulate_array(N, arr): Manipulate the array based on the instruction N. - If N is 1, reverse the array. - If N is 2, find the sum of the array elements. - If N is 3, find the product of the array elements. Parameters: - N: int - Instruction for the manipulation - arr: list of int - The array to be manipulated Returns: - list or int: Result of the manipulation if N == 1: return arr[::-1] elif N == 2: return sum(arr) elif N == 3: product = 1 for number in arr: product *= number return product else: raise ValueError(\\"Invalid operation code. Supported codes are 1, 2, and 3.\\")"},{"question":"def find_duplicate(n: int, arr: List[int]) -> int: Finds the integer that appears exactly twice in the array. Parameters: n (int): The maximum number in the array. arr (list): List of integers with the elements ranging from 1 to n, each appearing at most twice. Returns: int: The number that appears exactly twice in the array. pass def test_find_duplicate_1(): assert find_duplicate(5, [1, 2, 3, 4, 5, 3]) == 3 def test_find_duplicate_2(): assert find_duplicate(6, [1, 6, 2, 6, 4, 5, 3]) == 6 def test_find_duplicate_edge_case_min_n(): assert find_duplicate(2, [1, 2, 2]) == 2 def test_find_duplicate_first_and_last(): assert find_duplicate(4, [1, 2, 3, 1]) == 1 def test_find_duplicate_middle_of_array(): assert find_duplicate(7, [1, 2, 3, 4, 5, 6, 7, 4]) == 4","solution":"def find_duplicate(n, arr): Finds the integer that appears exactly twice in the array. Parameters: n (int): The maximum number in the array. arr (list): List of integers with the elements ranging from 1 to n, each appearing at most twice. Returns: int: The number that appears exactly twice in the array. frequency = [0] * (n + 1) for number in arr: frequency[number] += 1 if frequency[number] == 2: return number"},{"question":"from typing import List, Tuple def reachable_airports(flight_routes: List[Tuple[str, str]], starting_airport: str) -> List[str]: You are given a list of flight routes represented by pairs of cities. Each pair (airport1, airport2) means there is a direct flight from airport1 to airport2. Write a function that takes the list of flight routes and a starting airport and returns a list of all the airports that are directly or indirectly reachable from the starting airport. Airports should be listed in the order they are first reached. >>> reachable_airports([(\\"JFK\\", \\"LAX\\"), (\\"JFK\\", \\"ATL\\"), (\\"LAX\\", \\"SFO\\"), (\\"SFO\\", \\"SEA\\"), (\\"ATL\\", \\"DFW\\"), (\\"DFW\\", \\"HOU\\")], \\"JFK\\") [\\"LAX\\", \\"ATL\\", \\"SFO\\", \\"SEA\\", \\"DFW\\", \\"HOU\\"] >>> reachable_airports([(\\"JFK\\", \\"LAX\\"), (\\"ATL\\", \\"DFW\\"), (\\"SFO\\", \\"SEA\\")], \\"JFK\\") [\\"LAX\\"] >>> reachable_airports([(\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\"), (\\"C\\", \\"D\\")], \\"A\\") [\\"B\\", \\"C\\", \\"D\\"] >>> reachable_airports([], \\"A\\") [] >>> reachable_airports([(\\"A\\", \\"B\\"), (\\"C\\", \\"D\\"), (\\"E\\", \\"F\\")], \\"A\\") [\\"B\\"]","solution":"def reachable_airports(flight_routes, starting_airport): from collections import defaultdict, deque # Build adjacency list for the flight routes adjacency_list = defaultdict(list) for airport1, airport2 in flight_routes: adjacency_list[airport1].append(airport2) adjacency_list[airport2].append(airport1) # Since flights are bidirectional # BFS to find all reachable nodes reachable = [] visited = set() queue = deque([starting_airport]) visited.add(starting_airport) while queue: current_airport = queue.popleft() for neighbor in adjacency_list[current_airport]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) reachable.append(neighbor) return reachable"},{"question":"def bst_inorder_from_level_order(n, level_order): Construct a BST from a given level order traversal and return the in-order traversal of the BST. >>> bst_inorder_from_level_order(7, [4, 2, 6, 1, 3, 5, 7]) [1, 2, 3, 4, 5, 6, 7] >>> bst_inorder_from_level_order(1, [10]) [10] >>> bst_inorder_from_level_order(3, [3, 2, 1]) [1, 2, 3] >>> bst_inorder_from_level_order(4, [1, 2, 3, 4]) [1, 2, 3, 4] >>> bst_inorder_from_level_order(7, [8, 4, 12, 2, 6, 10, 14]) [2, 4, 6, 8, 10, 12, 14]","solution":"from collections import deque class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def construct_bst_from_level_order(level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = deque([root]) index = 1 while index < len(level_order): node = queue.popleft() # Check and insert left child if index < len(level_order) and level_order[index] < node.val: node.left = TreeNode(level_order[index]) queue.append(node.left) index += 1 # Check and insert right child if index < len(level_order) and level_order[index] > node.val: node.right = TreeNode(level_order[index]) queue.append(node.right) index += 1 return root def inorder_traversal(root): if not root: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def bst_inorder_from_level_order(n, level_order): root = construct_bst_from_level_order(level_order) return inorder_traversal(root)"},{"question":"def max_bonus_sum(t: int, cases: List[Tuple[int, int, int]]) -> List[int]: Determine the maximum possible sum of bonuses distributed to all employees while adhering to given constraints, or determine if it is impossible to distribute the bonuses. >>> max_bonus_sum(2, [(4, 7, 2), (3, 5, 3)]) [18, 12] >>> max_bonus_sum(3, [(5, 3, 1), (2, 2, 0), (1, 10, 5)]) [-1, -1, 1]","solution":"def max_bonus_sum(t, cases): results = [] for case in cases: N, B, D = case if N > B: results.append(-1) continue bonuses = [] current_bonus = 1 for i in range(N): bonuses.append(current_bonus) current_bonus += 1 if any((bonuses[i+1] - bonuses[i] > D for i in range(N-1))) or bonuses[-1] > B: results.append(-1) else: results.append(sum(bonuses)) return results # Example usage (uncomment to run) # cases = [ # (4, 7, 2), # (3, 5, 3) # ] # t = len(cases) # print(max_bonus_sum(t, cases)) # Output should be [18, 12]"},{"question":"def find_anagrams(word: str, candidates: List[str]) -> List[str]: Returns a list of anagrams of the given word from a list of candidate words. >>> find_anagrams(\\"listen\\", [\\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\"]) == [\\"inlets\\"] >>> find_anagrams(\\"race\\", [\\"care\\", \\"acer\\", \\"nice\\", \\"hello\\"]) == [\\"care\\", \\"acer\\"] pass # Unit Test def test_find_anagrams_no_anagrams(): assert find_anagrams(\\"apple\\", [\\"banana\\", \\"cherry\\", \\"date\\"]) == [] def test_find_anagrams_single_anagram(): assert find_anagrams(\\"listen\\", [\\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\"]) == [\\"inlets\\"] def test_find_anagrams_multiple_anagrams(): assert find_anagrams(\\"race\\", [\\"care\\", \\"acer\\", \\"nice\\", \\"hello\\"]) == [\\"care\\", \\"acer\\"] def test_find_anagrams_anagram_is_same_word(): assert find_anagrams(\\"word\\", [\\"word\\", \\"wrdo\\", \\"dowr\\", \\"whatever\\"]) == [\\"word\\", \\"wrdo\\", \\"dowr\\"] def test_find_anagrams_empty_list(): assert find_anagrams(\\"test\\", []) == [] def test_find_anagrams_empty_word(): assert find_anagrams(\\"\\", [\\"\\"]) == [\\"\\"] assert find_anagrams(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == []","solution":"def find_anagrams(word, candidates): Returns a list of anagrams of the given word from the list of candidate words. sorted_word = sorted(word) return [candidate for candidate in candidates if sorted(candidate) == sorted_word]"},{"question":"def max_subarray_sum(nums: List[int]) -> Tuple[int, int, int]: Returns the maximum sum of a contiguous subarray in the given array \`nums\` and the starting and ending indices (1-indexed) of that subarray. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) (6, 4, 7) >>> max_subarray_sum([1]) (1, 1, 1) >>> max_subarray_sum([5,4,-1,7,8]) (23, 1, 5) >>> max_subarray_sum([-1,-2,-3,-4]) (-1, 1, 1) >>> max_subarray_sum([-5]) (-5, 1, 1) >>> max_subarray_sum([1, 2, 3, 4, 5]) (15, 1, 5) >>> max_subarray_sum([3, -2, 5, -1, 4, -3]) (9, 1, 5) >>> max_subarray_sum([0, -2, 3, 0, 4, -1]) (7, 3, 5)","solution":"def max_subarray_sum(nums): Returns the maximum sum of a contiguous subarray in the given array \`nums\` and the starting and ending indices (1-indexed) of that subarray. max_sum = float('-inf') current_sum = 0 start = 0 max_start = 0 end = 0 for i in range(len(nums)): if current_sum <= 0: current_sum = nums[i] start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum max_start = start end = i return (max_sum, max_start + 1, end + 1)"},{"question":"def findFirstUniqueChar(s: str) -> str: Returns the first character in the string \`s\` that does not repeat. If every character repeats, returns None. >>> findFirstUniqueChar('swiss') 'w' >>> findFirstUniqueChar('aabb') None >>> findFirstUniqueChar('x') 'x' >>> findFirstUniqueChar('aabbcc') None >>> findFirstUniqueChar('aabbc') 'c' >>> findFirstUniqueChar('a1b2c3231b') 'a'","solution":"def findFirstUniqueChar(s): Returns the first character in the string s that does not repeat. If every character repeats, returns None. :param s: string :return: character or None # Create a hash map to store frequency of each character char_count = {} # Fill the hash map with the frequency of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find and return the first unique character for char in s: if char_count[char] == 1: return char return None"},{"question":"def find_triplets(nums): Returns a list of unique Pythagorean triplets (a, b, c) from the list of integers such that a^2 + b^2 = c^2. The triplets are returned in lexicographic order. >>> find_triplets([3, 1, 4, 6, 5]) [(3, 4, 5)] >>> find_triplets([10, 4, 6, 12, 5]) [] >>> find_triplets([5, 12, 13, 9, 40, 41]) [(5, 12, 13), (9, 40, 41)] >>> find_triplets([3, 4, 5, 6, 8, 10]) [(3, 4, 5), (6, 8, 10)] >>> find_triplets([1, 2, 3, 4, 7]) [] >>> find_triplets([3, 4, 5, 4, 3, 6, 8, 10]) [(3, 4, 5), (6, 8, 10)]","solution":"def find_triplets(nums): Returns a list of unique Pythagorean triplets (a, b, c) from the list of integers such that a^2 + b^2 = c^2. The triplets are returned in lexicographic order. nums.sort() n = len(nums) triplets = set() for i in range(n - 2): for j in range(i + 1, n - 1): a, b = nums[i], nums[j] c_squared = a ** 2 + b ** 2 c = int(c_squared ** 0.5) if c * c == c_squared and c in nums[j + 1:]: triplets.add((a, b, c)) return sorted(triplets)"},{"question":"from typing import List def digitCount(arr: List[int]) -> List[int]: Given an integer array \`arr\` of \`n\` positive integers, return another integer array with the count of each digit (0-9) appearing in the numbers. Examples: >>> digitCount([123, 456, 789, 0]) [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> digitCount([11, 22, 33]) [0, 2, 2, 2, 0, 0, 0, 0, 0, 0] >>> digitCount([99, 999]) [0, 0, 0, 0, 0, 0, 0, 0, 0, 5]","solution":"def digitCount(arr): Returns an array with the count of each digit (0-9) appearing in the numbers. :param arr: List[int] - a list of positive integers. :return: List[int] - a list of length 10 where the i-th element is the count of digit i. digit_counts = [0] * 10 for number in arr: for char in str(number): digit_counts[int(char)] += 1 return digit_counts"},{"question":"def find_anagrams(word_list: List[str]) -> List[List[str]]: Groups words into sets of anagrams, ignoring case. >>> find_anagrams(['listen', 'silent', 'enlist', 'google', 'goo', 'elgoog', 'inlets']) [['listen', 'silent', 'enlist', 'inlets'], ['google', 'elgoog'], ['goo']] >>> find_anagrams([]) [] >>> find_anagrams(['cat', 'dog', 'bird']) [['cat'], ['dog'], ['bird']]","solution":"from collections import defaultdict def find_anagrams(word_list): Groups words into sets of anagrams, ignoring case. Parameters: word_list (list of str): List of words to group into anagrams. Returns: list of list of str: A list of sets of anagrams. anagrams = defaultdict(list) for word in word_list: sorted_word = ''.join(sorted(word.lower())) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def findMaxLength(s: str) -> int: Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string containing only lowercase English letters. Returns: int: The length of the longest substring without repeating characters. >>> findMaxLength(\\"abcabcbb\\") 3 >>> findMaxLength(\\"bbbbb\\") 1 >>> findMaxLength(\\"pwwkew\\") 3","solution":"def findMaxLength(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string containing only lowercase English letters. Returns: int: The length of the longest substring without repeating characters. char_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_map: start = max(start, char_map[char] + 1) char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def frequency_count(s: str) -> dict: Returns a dictionary with the frequency of each alphanumeric character in the string. The function is case-insensitive and ignores spaces. >>> frequency_count(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> frequency_count(\\"Python 3.8\\") {'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1, '3': 1, '8': 1} >>> frequency_count(\\"Data Science\\") {'d': 1, 'a': 2, 't': 1, 's': 1, 'c': 2, 'i': 1, 'e': 2, 'n': 1} from solution import frequency_count def test_frequency_count_simple(): assert frequency_count(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} def test_frequency_count_with_numbers(): assert frequency_count(\\"Python 3.8\\") == {'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1, '3': 1, '8': 1} def test_frequency_count_mixed_case(): assert frequency_count(\\"Data Science\\") == {'d': 1, 'a': 2, 't': 1, 's': 1, 'c': 2, 'i': 1, 'e': 2, 'n': 1} def test_frequency_count_empty_string(): assert frequency_count(\\"\\") == {} def test_frequency_count_ignores_punctuation(): assert frequency_count(\\"Hello, World!\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} def test_frequency_count_only_spaces(): assert frequency_count(\\" \\") == {} def test_frequency_count_special_characters(): assert frequency_count(\\"123 !@# abc ABC\\") == {'1': 1, '2': 1, '3': 1, 'a': 2, 'b': 2, 'c': 2}","solution":"def frequency_count(s): Returns a dictionary with the frequency of each alphanumeric character in the string. The function is case-insensitive and ignores spaces. from collections import defaultdict freq = defaultdict(int) for char in s: if char.isalnum(): freq[char.lower()] += 1 return dict(freq)"},{"question":"def transform_string(sentence: str) -> str: Transforms the given string by replacing each occurrence of 'A' with 'B', 'B' with 'C', and 'C' with 'A'. The transformation respects the case of the letters. :param sentence: Input string to transform :return: Transformed string # Your implementation here # Example usage and test cases if __name__ == \\"__main__\\": assert transform_string(\\"ABCA\\") == \\"BCAB\\" assert transform_string(\\"Hello World!\\") == \\"Hello World!\\" assert transform_string(\\"abcABC\\") == \\"bcaBCA\\" assert transform_string(\\"AaBbCc\\") == \\"BbCcAa\\" assert transform_string(\\"XYZ\\") == \\"XYZ\\"","solution":"def transform_string(sentence: str) -> str: Transforms the given string by replacing each occurrence of 'A' with 'B', 'B' with 'C', and 'C' with 'A'. The transformation respects the case of the letters. :param sentence: Input string to transform :return: Transformed string transformation = { 'A': 'B', 'B': 'C', 'C': 'A', 'a': 'b', 'b': 'c', 'c': 'a' } return ''.join(transformation.get(char, char) for char in sentence)"},{"question":"from typing import List def longest_substring_k_distinct(s: str, queries: List[int]) -> List[int]: Determine the length of the longest substring that contains at most k distinct characters for each query. >>> longest_substring_k_distinct('abcbaa', [1, 2, 3]) [2, 3, 6] >>> longest_substring_k_distinct('abcdef', [1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> longest_substring_k_distinct('aaaaa', [1, 2, 3]) [5, 5, 5] >>> longest_substring_k_distinct('abaccc', [1, 2, 3]) [3, 4, 6] >>> longest_substring_k_distinct('', [1, 2, 3]) [0, 0, 0] >>> longest_substring_k_distinct('abcbaa', [0]) [0] pass def test_longest_substring_k_distinct_basic(): s = 'abcbaa' queries = [1, 2, 3] assert longest_substring_k_distinct(s, queries) == [2, 3, 6] def test_longest_substring_k_distinct_all_distinct(): s = 'abcdef' queries = [1, 2, 3, 4, 5, 6] assert longest_substring_k_distinct(s, queries) == [1, 2, 3, 4, 5, 6] def test_longest_substring_k_distinct_single_char(): s = 'aaaaa' queries = [1, 2, 3] assert longest_substring_k_distinct(s, queries) == [5, 5, 5] def test_longest_substring_k_distinct_mixed(): s = 'abaccc' queries = [1, 2, 3] assert longest_substring_k_distinct(s, queries) == [3, 4, 6] def test_longest_substring_k_distinct_empty_string(): s = '' queries = [1, 2, 3] assert longest_substring_k_distinct(s, queries) == [0, 0, 0] def test_longest_substring_k_distinct_k_zero(): s = 'abcbaa' queries = [0] assert longest_substring_k_distinct(s, queries) == [0]","solution":"def longest_substring_k_distinct(s, queries): Returns a list of integers where each integer corresponds to the length of the longest substring that contains at most k distinct characters for each query. def longest_substring_with_k_distinct(s, k): n = len(s) if k == 0: return 0 if n == 0: return 0 left, right = 0, 0 char_count = {} max_len = 0 while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len results = [] for query in queries: results.append(longest_substring_with_k_distinct(s, query)) return results"},{"question":"def matrix_multiply(matrix_a, matrix_b): Multiplies two matrices if they can be multiplied. Parameters: matrix_a (list of lists): The first matrix. matrix_b (list of lists): The second matrix. Returns: list of lists: The resulting matrix after multiplication, or None if the matrices cannot be multiplied. pass if __name__ == \\"__main__\\": def test_matrix_multiply_valid_matrices(): matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] assert matrix_multiply(matrix_a, matrix_b) == [ [58, 64], [139, 154] ] def test_matrix_multiply_invalid_matrices(): matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [5, 6], [7, 8], [9, 10] ] assert matrix_multiply(matrix_a, matrix_b) == None def test_matrix_multiply_square_matrices(): matrix_a = [ [2, 4], [1, 3] ] matrix_b = [ [5, 6], [7, 8] ] assert matrix_multiply(matrix_a, matrix_b) == [ [38, 44], [26, 30] ] def test_matrix_multiply_single_element_matrices(): matrix_a = [[3]] matrix_b = [[4]] assert matrix_multiply(matrix_a, matrix_b) == [[12]] def test_matrix_multiply_row_vector_and_col_vector(): matrix_a = [[1, 2, 3]] matrix_b = [ [4], [5], [6] ] assert matrix_multiply(matrix_a, matrix_b) == [[32]] test_matrix_multiply_valid_matrices() test_matrix_multiply_invalid_matrices() test_matrix_multiply_square_matrices() test_matrix_multiply_single_element_matrices() test_matrix_multiply_row_vector_and_col_vector()","solution":"def matrix_multiply(matrix_a, matrix_b): Multiplies two matrices if they can be multiplied. Parameters: matrix_a (list of lists): The first matrix. matrix_b (list of lists): The second matrix. Returns: list of lists: The resulting matrix after multiplication, or None if the matrices cannot be multiplied. # Getting the dimensions of the matrices rows_a = len(matrix_a) cols_a = len(matrix_a[0]) rows_b = len(matrix_b) cols_b = len(matrix_b[0]) # Matrices can be multiplied only if cols_a == rows_b if cols_a != rows_b: return None # Initializing the resulting matrix with zeroes result_matrix = [[0 for _ in range(cols_b)] for _ in range(rows_a)] # Performing the matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j] return result_matrix"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return an array such that each element at index i is the product of all the numbers in the original array except the one at i, without using division and in O(n) time. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6] >>> product_except_self([1]) [1] >>> product_except_self([]) [] >>> product_except_self([1, 2]) [2, 1] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6]","solution":"def product_except_self(nums): Returns an array such that each element at index i is the product of all numbers in the original array except the one at i, without using division and in O(n) time. if not nums: return [] n = len(nums) if n == 1: return [1] left_products = [1] * n right_products = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] result = [left_products[i] * right_products[i] for i in range(n)] return result"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all elements in the original list except the one at that position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3, 4]) [24, 0, 0, 0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([1, 5, 2]) [10, 2, 5] >>> product_except_self([9]) [1] >>> product_except_self([1, 2, 3, 0]) [0, 0, 0, 6] pass","solution":"def product_except_self(nums): Returns a list where each element is the product of all elements in the original list except the one at that position. length = len(nums) if length == 0: return [] # Edge case: empty list # Initialize the output array with 1's result = [1] * length # Initialize prefix and postfix products prefix = 1 postfix = 1 # Compute prefix products for i in range(length): result[i] = prefix prefix *= nums[i] # Compute postfix products and the final result for i in range(length - 1, -1, -1): result[i] *= postfix postfix *= nums[i] return result"},{"question":"from typing import List def days_until_warmer(temperatures: List[int]) -> List[int]: You are given a list of daily temperatures, \`temperatures\`, that represents the average temperatures for each day of a given period. Write a function \`days_until_warmer(temperatures)\` that returns a list where, for each day in the input list, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. >>> days_until_warmer([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> days_until_warmer([30, 40, 50, 60]) [1, 1, 1, 0] >>> days_until_warmer([30, 20, 10, 0]) [0, 0, 0, 0] >>> days_until_warmer([50, 50, 50, 50]) [0, 0, 0, 0] >>> days_until_warmer([60, 50, 40, 30]) [0, 0, 0, 0] >>> days_until_warmer([20, 30, 25, 28, 35, 22, 30]) [1, 3, 1, 1, 0, 1, 0]","solution":"from typing import List def days_until_warmer(temperatures: List[int]) -> List[int]: n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"from typing import List def find_shortest_paths(T: int, test_cases: List[tuple]) -> List[int]: Find the shortest path for the drone from the starting point to the destination avoiding buildings. The grid is represented as an MxN grid where each cell either has a building (1) or open space (0). >>> T = 2 >>> test_cases = [ ... (3, 3, [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]), ... (3, 3, [ ... [0, 1, 0], ... [1, 0, 0], ... [0, 1, 0] ... ]) ... ] >>> find_shortest_paths(T, test_cases) [4, -1]","solution":"from collections import deque def shortest_path_in_grid(grid): M = len(grid) N = len(grid[0]) if grid[0][0] == 1 or grid[M-1][N-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Down, Right, Up, Left queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == M-1 and y == N-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def find_shortest_paths(T, test_cases): results = [] for case in test_cases: M, N, grid = case results.append(shortest_path_in_grid(grid)) return results"},{"question":"def pacific_atlantic_water_flow(matrix: List[List[int]]) -> int: Determine the number of cells from which water can flow to both the Pacific and Atlantic Oceans. >>> pacific_atlantic_water_flow([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]) == 7 >>> pacific_atlantic_water_flow([[0]]) == 1 >>> pacific_atlantic_water_flow([]) == 0 >>> pacific_atlantic_water_flow([[1, 2, 3]]) == 3 >>> pacific_atlantic_water_flow([[1], [2], [3]]) == 3 >>> pacific_atlantic_water_flow([[1, 1], [1, 1]]) == 4 pass def rect_grid_from_input(input_str: str) -> List[List[int]]: Parse the input string to create a rectangular grid of elevations. >>> rect_grid_from_input(\\"5 5n1 2 2 3 5n3 2 3 4 4n2 4 5 3 1n6 7 1 4 5n5 1 1 2 4n\\") [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]] pass def solve(input_str: str) -> int: Main function to solve the problem based on the input string >>> solve(\\"5 5n1 2 2 3 5n3 2 3 4 4n2 4 5 3 1n6 7 1 4 5n5 1 1 2 4n\\") == 7 >>> solve(\\"1 1n0n\\") == 1 >>> solve(\\"0 0n\\") == 0 pass","solution":"def pacific_atlantic_water_flow(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) def dfs(x, y, visited): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] stack = [(x, y)] visited.add((x, y)) while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and matrix[nx][ny] >= matrix[cx][cy]: stack.append((nx, ny)) visited.add((nx, ny)) pacific_reachable = set() atlantic_reachable = set() for i in range(m): dfs(i, 0, pacific_reachable) dfs(i, n-1, atlantic_reachable) for j in range(n): dfs(0, j, pacific_reachable) dfs(m-1, j, atlantic_reachable) return len(pacific_reachable & atlantic_reachable) # Reading input format def rect_grid_from_input(input_str): lines = input_str.strip().split('n') m, n = map(int, lines[0].split()) matrix = [list(map(int, line.split())) for line in lines[1:]] return matrix def solve(input_str): matrix = rect_grid_from_input(input_str) return pacific_atlantic_water_flow(matrix)"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using dynamic programming. >>> fibonacci(0) # --> 0 >>> fibonacci(1) # --> 1 >>> fibonacci(2) # --> 1 >>> fibonacci(3) # --> 2 >>> fibonacci(10) # --> 55 >>> fibonacci(20) # --> 6765","solution":"def fibonacci(n): Returns the nth Fibonacci number. # Base cases if n == 0: return 0 elif n == 1: return 1 # Initialize cache to store Fibonacci values fib_cache = [0] * (n + 1) fib_cache[1] = 1 # Compute Fibonacci values using dynamic programming for i in range(2, n + 1): fib_cache[i] = fib_cache[i - 1] + fib_cache[i - 2] return fib_cache[n]"},{"question":"def group_and_print(nums): Groups integers by the number of digits they contain and prints each group on a new line in ascending order of the integers within the group. >>> group_and_print([123, 56, 1, 7890, 23, 456, 12, 6, 789]) 1 6 12 23 56 123 456 789 7890 >>> group_and_print([5, 3, 8]) 3 5 8 >>> group_and_print([103, 2, 10, 205]) 2 10 103 205 >>> group_and_print([]) >>> group_and_print([22, 33, 44, 55]) 22 33 44 55","solution":"def group_and_print(nums): Groups integers by the number of digits they contain and prints each group on a new line in ascending order of the integers within the group. from collections import defaultdict # Dictionary to hold numbers grouped by their digit length groups = defaultdict(list) for num in nums: length = len(str(abs(num))) # Get digit length groups[length].append(num) # Sort and print each group for length in sorted(groups.keys()): group = sorted(groups[length]) print(\\" \\".join(map(str, group)))"},{"question":"def determine_rankings(T: int, cases: List[Tuple[int, List[str], List[List[int]]]]) -> str: Determine the rankings of the teams based on their total points. If two or more teams have the same total points, rank them alphabetically by their team names. Parameters: T (int): The number of test cases. cases (List[Tuple[int, List[str], List[List[int]]]]): List of test case tuples. Each tuple contains: N (int): The number of teams. team_names (List[str]): The names of the teams. points_matrix (List[List[int]]): The points of matches between the teams in the form of a matrix. Returns: str: Rankings of the teams for each test case. Example: >>> T = 2 >>> cases = [ ... (3, ['TEAM-A', 'TEAM-B', 'TEAM-C'], ... [ ... [0, 1, 1], ... [0, 0, 0], ... [0, 1, 0] ... ]), ... (4, ['ALPHA', 'BETA', 'GAMMA', 'DELTA'], ... [ ... [0, 1, 1, 1], ... [0, 0, 1, 1], ... [0, 0, 0, 0], ... [0, 0, 1, 0] ... ]) ... ] >>> determine_rankings(T, cases) \\"Case #1:n1 TEAM-An2 TEAM-Cn3 TEAM-BnCase #2:n1 ALPHAn2 BETAn3 DELTAn4 GAMMA\\"","solution":"def determine_rankings(T, cases): results = [] for case_num in range(T): N = cases[case_num][0] team_names = cases[case_num][1] points_matrix = cases[case_num][2] # Calculate total points for each team total_points = [] for i in range(N): total_points.append((sum(points_matrix[i]), team_names[i])) # Sort by points (descending) then by name (alphabetically) total_points.sort(key=lambda x: (-x[0], x[1])) # Append the results results.append(f\\"Case #{case_num + 1}:\\") for rank, (points, name) in enumerate(total_points, start=1): results.append(f\\"{rank} {name}\\") return \\"n\\".join(results)"},{"question":"def min_cost_to_transform(S: str, T: str) -> int: Calculates the minimum cost to transform string S into string T using the given operations. >>> min_cost_to_transform(\\"abc\\", \\"yabd\\") 2 >>> min_cost_to_transform(\\"horse\\", \\"ros\\") 3 >>> min_cost_to_transform(\\"intention\\", \\"execution\\") 5","solution":"def min_cost_to_transform(S, T): Calculates the minimum cost to transform string S into string T using the given operations. # Get the lengths of both strings m, n = len(S), len(T) # Initialize a 2D array to store the minimum cost up to each position dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the first row and first column of the array for i in range(m + 1): dp[i][0] = i # Deleting all characters from S to get an empty T for j in range(n + 1): dp[0][j] = j # Inserting all characters to get T from an empty S # Fill the rest of the dp array for i in range(1, m + 1): for j in range(1, n + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If characters are equal, no cost else: dp[i][j] = min(dp[i - 1][j] + 1, # Deleting a character from S dp[i][j - 1] + 1, # Inserting a character into S dp[i - 1][j - 1] + 1) # Replacing a character in S # The answer is the cost to transform S[0..m] to T[0..n] return dp[m][n]"},{"question":"from typing import List, Tuple def min_number_of_rows(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: A gardener is planning the layout of a new garden. He wants to plant rows of flowers, each row having the same total height, but he also wants the least number of rows possible. Given an array of integers that represent the height of each flower, help the gardener find the smallest number of rows needed to plant all the flowers so that the sum of heights in each row is equal. Args: T : int : The number of test cases. test_cases : List[Tuple[int, List[int]]] : A list of tuples where each tuple contains: - an integer N, the number of flowers. - a list of N integers representing the height of each flower. Returns: List[int] : A list of integers where each integer represents the minimum number of rows required for the corresponding test case. >>> min_number_of_rows(2, [(5, [1, 2, 2, 3, 3]), (4, [2, 2, 1, 1])]) [3, 2] >>> min_number_of_rows(1, [(5, [3, 3, 3, 3, 3])]) [5]","solution":"from collections import Counter def min_number_of_rows(T, test_cases): results = [] for i in range(T): N, heights = test_cases[i] height_counter = Counter(heights) max_count = max(height_counter.values()) results.append(max_count) return results"},{"question":"def binary_to_decimal(binary_str): Convert a binary string to its decimal equivalent. Parameters: binary_str (str): A string representing a binary number. Returns: int: Decimal equivalent of the binary number, or a string 'Invalid binary number!' if input is invalid. Examples: >>> binary_to_decimal(\\"1101\\") == 13 >>> binary_to_decimal(\\"0\\") == 0 >>> binary_to_decimal(\\"1\\") == 1 >>> binary_to_decimal(\\"10201\\") == 'Invalid binary number!' >>> binary_to_decimal(\\"\\") == 'Invalid binary number!' >>> binary_to_decimal(\\"abc\\") == 'Invalid binary number!' >>> binary_to_decimal(\\" 1010\\") == 'Invalid binary number!'","solution":"def binary_to_decimal(binary_str): Convert a binary string to its decimal equivalent. Parameters: binary_str (str): A string representing a binary number. Returns: int: Decimal equivalent of the binary number, or a string 'Invalid binary number!' if input is invalid. if not binary_str: return 'Invalid binary number!' for char in binary_str: if char not in ('0', '1'): return 'Invalid binary number!' return int(binary_str, 2)"},{"question":"from typing import List, Tuple def doIntervalsOverlap(intervals: List[Tuple[int, int]]) -> bool: Returns True if any intervals in the given list overlap, False otherwise. >>> doIntervalsOverlap([(1, 3), (2, 4)]) True >>> doIntervalsOverlap([(1, 2), (3, 4), (5, 6)]) False >>> doIntervalsOverlap([(1, 2), (2, 3)]) False","solution":"from typing import List, Tuple def doIntervalsOverlap(intervals: List[Tuple[int, int]]) -> bool: Returns True if any intervals in the given list overlap, False otherwise. # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) # Iterate through the sorted intervals and check for overlap for i in range(1, len(intervals)): # Fetch previous and current intervals prev = intervals[i-1] curr = intervals[i] # If the end time of the previous interval is greater than the start time of the current interval if prev[1] > curr[0]: return True return False"},{"question":"def find_pairs(target: int, numbers: List[int]) -> List[Tuple[int, int]]: Return a list of all unique pairs of numbers from the list that add up to the target number. Each pair should be a tuple (a, b), where a <= b, and the pairs should be sorted in ascending order. >>> find_pairs(5, [1, 2, 3, 4, -1, 0, 2, 3, 4, 5]) == [(0, 5), (1, 4), (2, 3)] >>> find_pairs(7, [0, 1, 6, 2, 5, -1, 3, 4, 2, 7]) == [(0, 7), (1, 6), (2, 5), (3, 4)] >>> find_pairs(0, [2, -2, 4, -4, 5, -5]) == [(-5, 5), (-4, 4), (-2, 2)] >>> find_pairs(10, [1, 2, 3, 4]) == [] >>> find_pairs(5, []) == [] >>> find_pairs(0, [0, 0, 0, 0]) == [(0, 0)]","solution":"def find_pairs(target, numbers): Return a list of all unique pairs of numbers from the list that add up to the target number. Each pair should be a tuple (a, b), where a <= b, and the pairs should be sorted in ascending order. numbers.sort() pairs = set() seen = set() for number in numbers: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) return sorted(pairs)"},{"question":"def find_palindrome_segment(n, s): Given a string s of length n, find the minimum segment that needs to be reversed to make the string a palindrome. :param n: Length of the string (an integer) :param s: The string (a string of lowercase Latin letters) :return: A tuple (l, r) representing the segment to reverse >>> find_palindrome_segment(5, \\"abcba\\") (1, 5) >>> find_palindrome_segment(4, \\"abba\\") (1, 4) >>> find_palindrome_segment(3, \\"abc\\") (1, 3) >>> find_palindrome_segment(1, \\"a\\") (1, 1) >>> find_palindrome_segment(6, \\"abccba\\") (1, 6) >>> find_palindrome_segment(7, \\"aabbbaa\\") (1, 7) >>> find_palindrome_segment(8, \\"abcdcbef\\") (1, 8)","solution":"def find_palindrome_segment(n, s): Given a string s of length n, find the minimum segment that needs to be reversed to make the string a palindrome. :param n: Length of the string (an integer) :param s: The string (a string of lowercase Latin letters) :return: A tuple (l, r) representing the segment to reverse # Initialize pointers to traverse from left and right left, right = 0, n - 1 # Find the first and last mismatched characters while left < right: if s[left] == s[right]: left += 1 right -= 1 else: break # If no mismatch was found, the whole string should be reversed to itself is a palindrome if left >= right: return (1, n) # Check reversing the found mismatched segment segment_start, segment_end = left, right while left < right: if s[left] == s[right]: left += 1 right -= 1 else: return (segment_start + 1, segment_end + 1) return (segment_start + 1, segment_end + 1)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing only positive integers and the operators '+', '-', '*', '/'. >>> evaluate_expression('3+5*2-8/4') == 11 >>> evaluate_expression('10+2*6') == 22 >>> evaluate_expression('100*2+12') == 212 pass # Test Cases import pytest def test_simple_expression(): assert evaluate_expression('3+5*2-8/4') == 11 def test_expression_without_spaces(): assert evaluate_expression('10+2*6') == 22 def test_expression_with_large_numbers(): assert evaluate_expression('100*2+12') == 212 def test_expression_with_multiplication(): assert evaluate_expression('3*5') == 15 def test_expression_with_division(): assert evaluate_expression('10/2') == 5 def test_expression_with_addition_and_subtraction(): assert evaluate_expression('3+2-1') == 4 def test_expression_with_all_operations(): assert evaluate_expression('7+3*2-1/1') == 12 def test_expression_with_only_additions(): assert evaluate_expression('1+2+3+4+5') == 15 def test_expression_with_only_subtractions(): assert evaluate_expression('10-3-2-1') == 4 def test_expression_start_with_multiplication(): assert evaluate_expression('2*3+5') == 11 def test_expression_start_with_division(): assert evaluate_expression('8/4+6') == 8","solution":"def evaluate_expression(expression: str) -> int: Evaluate the given mathematical expression string containing positive integers and the operators '+', '-', '*', '/'. def apply_operation(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(a // b) import re tokens = re.findall(r'd+|[+*/-]', expression) precedence = {'+': 1, '-': 1, '*': 2, '/': 2} operands = [] operators = [] for token in tokens: if token.isdigit(): operands.append(int(token)) else: while operators and precedence[operators[-1]] >= precedence[token]: apply_operation(operands, operators.pop()) operators.append(token) while operators: apply_operation(operands, operators.pop()) return operands[0]"},{"question":"def find_min_path_sum(R: int, C: int, grid_values: List[int]) -> int: Find the minimum path sum from the top-left corner of grid to the bottom-right corner. The grid is represented by its values in a flat list traversed row-wise. >>> find_min_path_sum(3, 3, [1, 3, 1, 1, 5, 1, 4, 2, 1]) 7 >>> find_min_path_sum(1, 1, [5]) 5 >>> find_min_path_sum(1, 4, [1, 2, 3, 4]) 10 >>> find_min_path_sum(4, 1, [1, 2, 3, 4]) 10 >>> find_min_path_sum(2, 2, [5, 5, 5, 5]) 15 >>> find_min_path_sum(3, 3, [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]) 5000 pass","solution":"def min_path_sum(grid): R = len(grid) C = len(grid[0]) dp = [[0] * C for _ in range(R)] dp[0][0] = grid[0][0] for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, R): for j in range(1, C): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[R-1][C-1] def find_min_path_sum(R, C, grid_values): grid = [] for i in range(R): grid.append(grid_values[i * C:(i + 1) * C]) return min_path_sum(grid)"},{"question":"def parse_input(input_str: str) -> list: Parses input string and returns list of test cases. Parameters: input_str: str Input string containing the number of test cases followed by test case data Returns: List of tuples [(n, isbn_list), ...] >>> parse_input(\\"2n5n9780345391803 9780261103573 9780316769174 9780261102217 9780544003415n4n9780451524935 9780140283334 9780385472579 9780679783275\\") [(5, [9780345391803, 9780261103573, 9780316769174, 9780261102217, 9780544003415]), (4, [9780451524935, 9780140283334, 9780385472579, 9780679783275])] pass def sort_isbn(test_cases: list) -> list: Sorts list of ISBNs for each test case in ascending order. Parameters: test_cases: List of tuples [(n, isbn_list), ...] n - number of books isbn_list - list of ISBN numbers Returns: List of sorted ISBN lists corresponding to each test case. >>> sort_isbn([(5, [9780345391803, 9780261103573, 9780316769174, 9780261102217, 9780544003415]), (4, [9780451524935, 9780140283334, 9780385472579, 9780679783275])]) [[9780261102217, 9780261103573, 9780316769174, 9780345391803, 9780544003415], [9780140283334, 9780385472579, 9780451524935, 9780679783275]] pass def output_result(sorted_lists: list) -> str: Formats the sorted lists into an output string. Parameters: sorted_lists: List of sorted ISBN lists Returns: str >>> output_result([[9780261102217, 9780261103573, 9780316769174, 9780345391803, 9780544003415], [9780140283334, 9780385472579, 9780451524935, 9780679783275]]) \\"9780261102217 9780261103573 9780316769174 9780345391803 9780544003415n9780140283334 9780385472579 9780451524935 9780679783275\\" pass # Example usage: input_str = 2 5 9780345391803 9780261103573 9780316769174 9780261102217 9780544003415 4 9780451524935 9780140283334 9780385472579 9780679783275 test_cases = parse_input(input_str) sorted_isbns = sort_isbn(test_cases) print(output_result(sorted_isbns))","solution":"def sort_isbn(test_cases): Sorts list of ISBNs for each test case in ascending order. Parameters: test_cases: List of tuples [(n, isbn_list), ...] n - number of books isbn_list - list of ISBN numbers Returns: List of sorted ISBN lists corresponding to each test case. result = [] for n, isbn_list in test_cases: sorted_list = sorted(isbn_list) result.append(sorted_list) return result def parse_input(input_str): Parses input string and returns list of test cases. Parameters: input_str: str Input string containing the number of test cases followed by each test case data Returns: List of tuples [(n, isbn_list), ...] lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) isbn_list = list(map(int, lines[index + 1].split())) test_cases.append((n, isbn_list)) index += 2 return test_cases def output_result(sorted_lists): Formats the sorted lists into an output string. Parameters: sorted_lists: List of sorted ISBN lists Returns: str output_lines = [] for sorted_list in sorted_lists: output_lines.append(\\" \\".join(map(str, sorted_list))) return \\"n\\".join(output_lines) # Example usage: input_str = 2 5 9780345391803 9780261103573 9780316769174 9780261102217 9780544003415 4 9780451524935 9780140283334 9780385472579 9780679783275 test_cases = parse_input(input_str) sorted_isbns = sort_isbn(test_cases) print(output_result(sorted_isbns))"},{"question":"def determine_winner(num_stones): Determines the winner given the number of stones. Parameters: num_stones (int): The number of stones in the pile. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. >>> determine_winner(1) \\"Alice\\" >>> determine_winner(4) \\"Bob\\" >>> determine_winner(7) \\"Alice\\" >>> determine_winner(8) \\"Bob\\" >>> determine_winner(5) \\"Alice\\" pass def main(T, test_cases): Processes multiple test cases and returns the results. Parameters: T (int): The number of test cases. test_cases (list): The list of the number of stones for each test case. Returns: list of str: List containing the results of each test case. >>> main(5, [1, 2, 3, 4, 5]) [\\"Alice\\", \\"Alice\\", \\"Alice\\", \\"Bob\\", \\"Alice\\"] pass","solution":"def determine_winner(num_stones): Determines the winner given the number of stones. Parameters: num_stones (int): The number of stones in the pile. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. # Alice wins if the number of stones is not a multiple of 4 # Alice loses if the number of stones is a multiple of 4 if num_stones % 4 == 0: return \\"Bob\\" else: return \\"Alice\\" def main(T, test_cases): Processes multiple test cases and returns the results. Parameters: T (int): The number of test cases. test_cases (list): The list of the number of stones for each test case. Returns: list of str: List containing the results of each test case. results = [] for num_stones in test_cases: results.append(determine_winner(num_stones)) return results"},{"question":"def count_unique_elements(lst: List[int]) -> int: Returns the number of unique elements in the list. >>> count_unique_elements([1, 2, 2, 3, 4, 4, 5]) 5 >>> count_unique_elements([7, 8, 9, 10, 7, 8, 11]) 5 >>> count_unique_elements([1, 1, 1, 1, 1, 1]) 1","solution":"def count_unique_elements(lst): Returns the number of unique elements in the list. return len(set(lst))"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups the words that are anagrams of each other. :param words: List of words as strings. :return: List of lists, each containing words that are anagrams of each other. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"\\"]) [[\\"\\"]] >>> group_anagrams([\\"a\\"]) [[\\"a\\"]]","solution":"from collections import defaultdict def group_anagrams(words): Groups the words that are anagrams of each other. :param words: List of words as strings. :return: List of lists, each containing words that are anagrams of each other. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"from typing import List def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 >>> length_of_longest_substring_two_distinct(\\"a\\") == 1 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") == 2 >>> length_of_longest_substring_two_distinct(\\"aabbcc\\") == 4 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") == 4 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") == 4 >>> length_of_longest_substring_two_distinct(\\"\\") == 0 >>> length_of_longest_substring_two_distinct(\\"abcba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") == 4 pass","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. if not s: return 0 left = 0 right = 0 max_length = 0 char_map = {} while right < len(s): if len(char_map) < 2 or s[right] in char_map: char_map[s[right]] = char_map.get(s[right], 0) + 1 right += 1 else: while len(char_map) >= 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def hiking_summary(altitudes: List[int]) -> List[str]: Bob is an avid hiker. He likes to plan his hiking activities and make sure he's well-prepared for the terrain he will be encountering. Bob has a map with altitude information of his hiking trail. He needs to know when he will encounter an uphill, a downhill, or flat ground, based on the altitude changes of each section of the trail. Write a method \`hiking_summary\` that receives a list representing the altitudes at each checkpoint of the trail and returns a list of strings representing each section as \`\\"Uphill\\"\`, \`\\"Downhill\\"\`, or \`\\"Flat\\"\`. >>> hiking_summary([100, 105, 102, 102, 108, 107]) [\\"Uphill\\", \\"Downhill\\", \\"Flat\\", \\"Uphill\\", \\"Downhill\\"] >>> hiking_summary([90, 90, 92, 88, 87]) [\\"Flat\\", \\"Uphill\\", \\"Downhill\\", \\"Downhill\\"] >>> hiking_summary([120, 115, 115, 120, 125, 125, 122]) [\\"Downhill\\", \\"Flat\\", \\"Uphill\\", \\"Uphill\\", \\"Flat\\", \\"Downhill\\"] from solution import hiking_summary def test_hiking_summary_mixed_trail(): assert hiking_summary([100, 105, 102, 102, 108, 107]) == [\\"Uphill\\", \\"Downhill\\", \\"Flat\\", \\"Uphill\\", \\"Downhill\\"] def test_hiking_summary_initial_flat_then_downhill(): assert hiking_summary([90, 90, 92, 88, 87]) == [\\"Flat\\", \\"Uphill\\", \\"Downhill\\", \\"Downhill\\"] def test_hiking_summary_mixed_trail_with_multiple_flats(): assert hiking_summary([120, 115, 115, 120, 125, 125, 122]) == [\\"Downhill\\", \\"Flat\\", \\"Uphill\\", \\"Uphill\\", \\"Flat\\", \\"Downhill\\"] def test_hiking_summary_all_flat(): assert hiking_summary([100, 100, 100]) == [\\"Flat\\", \\"Flat\\"] def test_hiking_summary_all_uphill(): assert hiking_summary([100, 110, 120]) == [\\"Uphill\\", \\"Uphill\\"] def test_hiking_summary_all_downhill(): assert hiking_summary([100, 90, 80]) == [\\"Downhill\\", \\"Downhill\\"] def test_hiking_summary_single_element(): assert hiking_summary([100]) == []","solution":"def hiking_summary(altitudes): This function receives a list of altitudes and returns a list of strings categorizing each section of the trail as \\"Uphill\\", \\"Downhill\\", or \\"Flat\\". result = [] for i in range(1, len(altitudes)): if altitudes[i] > altitudes[i - 1]: result.append(\\"Uphill\\") elif altitudes[i] < altitudes[i - 1]: result.append(\\"Downhill\\") else: result.append(\\"Flat\\") return result"},{"question":"def trap(height): Calculate how much water can be trapped after raining. Parameters: height (list): List of non-negative integers representing the height of bars. Returns: int: Total units of trapped water. Example: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([]) 0 >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([2, 1, 2]) 1","solution":"def trap(height): Calculate how much water can be trapped after raining. Parameters: height (list): List of non-negative integers representing the height of bars. Returns: int: Total units of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"import math def count_permutations(T: int, cases: [(int, int)]) -> [int]: Returns the number of distinct permutations possible for each case. Parameters: T (int): Number of test cases. cases (list of tuples): Each tuple contains two integers N and R. Returns: list of int: List containing the results for each test case. >>> count_permutations(3, [(3, 2), (5, 3), (4, 4)]) == [6, 60, 24] >>> count_permutations(1, [(3, 4)]) == [0] >>> count_permutations(2, [(3, 0), (5, 0)]) == [1, 1] >>> count_permutations(2, [(4, 4), (5, 5)]) == [24, 120] >>> count_permutations(1, [(1, 0)]) == [1] >>> count_permutations(1, [(12, 12)]) == [math.factorial(12)]","solution":"import math def count_permutations(T, cases): Returns the number of distinct permutations possible for each case. Parameters: T (int): Number of test cases. cases (list of tuples): Each tuple contains two integers N and R. Returns: list of int: List containing the results for each test case. results = [] for N, R in cases: if R > N: results.append(0) else: results.append(math.factorial(N) // math.factorial(N - R)) return results"},{"question":"def process_operations(n, sequence, q, operations): Processes a series of operations on a sequence of integers. Parameters: n (int): Length of the sequence. sequence (list of int): The initial sequence. q (int): Number of operations. operations (list of str): List of operations to be performed. Returns: list of int: The sequence after applying all operations. pass # Example usage and test cases n = 5 sequence = [1, 2, 3, 4, 5] q = 3 operations = [\\"add 3 1\\", \\"mult 2 2\\", \\"swap 0 4\\"] print(process_operations(n, sequence, q, operations)) # Output should be [5, 5, 6, 4, 1] # Unit tests def test_example_case(): n = 5 sequence = [1, 2, 3, 4, 5] q = 3 operations = [\\"add 3 1\\", \\"mult 2 2\\", \\"swap 0 4\\"] assert process_operations(n, sequence, q, operations) == [5, 5, 6, 4, 1] def test_add_operations(): n = 3 sequence = [0, 0, 0] q = 2 operations = [\\"add 5 0\\", \\"add 3 2\\"] assert process_operations(n, sequence, q, operations) == [5, 0, 3] def test_mult_operations(): n = 4 sequence = [1, 2, 3, 4] q = 2 operations = [\\"mult 3 1\\", \\"mult -1 2\\"] assert process_operations(n, sequence, q, operations) == [1, 6, -3, 4] def test_swap_operations(): n = 3 sequence = [9, 8, 7] q = 1 operations = [\\"swap 0 2\\"] assert process_operations(n, sequence, q, operations) == [7, 8, 9] def test_mixed_operations(): n = 4 sequence = [1, 1, 1, 1] q = 4 operations = [\\"add 5 0\\", \\"mult 2 1\\", \\"swap 0 3\\", \\"add -1 2\\"] assert process_operations(n, sequence, q, operations) == [1, 2, 0, 6]","solution":"def process_operations(n, sequence, q, operations): Processes a series of operations on a sequence of integers. Parameters: n (int): Length of the sequence. sequence (list of int): The initial sequence. q (int): Number of operations. operations (list of str): List of operations to be performed. Returns: list of int: The sequence after applying all operations. for operation in operations: parts = operation.split() command = parts[0] if command == \\"add\\": x = int(parts[1]) idx = int(parts[2]) sequence[idx] += x elif command == \\"mult\\": x = int(parts[1]) idx = int(parts[2]) sequence[idx] *= x elif command == \\"swap\\": idx1 = int(parts[1]) idx2 = int(parts[2]) sequence[idx1], sequence[idx2] = sequence[idx2], sequence[idx1] return sequence # Example usage n = 5 sequence = [1, 2, 3, 4, 5] q = 3 operations = [\\"add 3 1\\", \\"mult 2 2\\", \\"swap 0 4\\"] print(process_operations(n, sequence, q, operations)) # Output: [5, 5, 6, 4, 1]"},{"question":"from typing import List, Tuple def sum_of_distances(coords: List[Tuple[int, int]]) -> int: Calculates the sum of the Manhattan distances from every point to every other point in a given list of 2D coordinates. Parameters: coords (list of tuples): A list of tuples, where each tuple contains two integers representing the coordinates (x, y). Returns: int: The sum of the Manhattan distances for all unique pairs of points in the list. Examples: >>> sum_of_distances([(0, 0), (1, 1), (2, 2)]) 8 >>> sum_of_distances([(1, 2), (3, 4), (5, 6)]) 16","solution":"def sum_of_distances(coords): Calculates the sum of the Manhattan distances from every point to every other point in the list of 2D coordinates. Parameters: coords (list of tuples): A list of tuples, where each tuple contains two integers representing the coordinates (x, y). Returns: int: The sum of the Manhattan distances for all unique pairs of points in the list. total_distance = 0 n = len(coords) for i in range(n): for j in range(i + 1, n): x1, y1 = coords[i] x2, y2 = coords[j] total_distance += abs(x1 - x2) + abs(y1 - y2) return total_distance"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression given as a string and returns the result. The expression contains integers and the operators +, -, *, and / with no whitespace. >>> evaluate_expression(\\"3+5*2-6\\") 7 >>> evaluate_expression(\\"10+20/5*3-1\\") 21.0","solution":"def evaluate_expression(expression): Evaluates a mathematical expression given as a string and returns the result. The expression contains integers and the operators +, -, *, and / with no whitespace. return eval(expression)"},{"question":"def repeat_characters(s: str) -> str: Given a string \`s\`, output a new string where each character in \`s\` is repeated a number of times equal to its position in the original string (1-based index). Parameters: s (str): A non-empty string consisting of lowercase English letters. Returns: str: A new string with the specified repetition pattern. Examples: >>> repeat_characters(\\"abc\\") \\"abbccc\\" >>> repeat_characters(\\"a\\") \\"a\\" >>> repeat_characters(\\"ab\\") \\"abb\\" >>> repeat_characters(\\"abcd\\") \\"abbcccdddd\\" >>> repeat_characters(\\"aaa\\") \\"a\\" + \\"aa\\" + \\"aaa\\"","solution":"def repeat_characters(s): Returns a new string where each character in \`s\` is repeated a number of times equal to its position in the original string (1-based index). result = [] for i, char in enumerate(s): result.append(char * (i + 1)) return ''.join(result)"},{"question":"def first_non_repeating(s: str) -> str: Write a function that takes a string containing only lowercase alphabets and returns the first non-repeating character. If there is no non-repeating character, return an underscore (\\"_\\"). >>> first_non_repeating(\\"aabcc\\") == \\"b\\" >>> first_non_repeating(\\"xxyz\\") == \\"y\\" >>> first_non_repeating(\\"aabbcc\\") == \\"_\\" >>> first_non_repeating(\\"lover\\") == \\"l\\" >>> first_non_repeating(\\"abcdef\\") == \\"a\\"","solution":"def first_non_repeating(s): Returns the first non-repeating character in the given string. If there is no non-repeating character, returns an underscore (\\"_\\"). char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: if char_count[char] == 1: return char return \\"_\\""},{"question":"def evaluate_rpn(tokens: List[str]) -> int: Evaluates an arithmetic expression in Reverse Polish Notation (RPN). Args: tokens (list of str): A list of strings representing the RPN expression. Returns: int: The result of the RPN expression evaluation. Examples: >>> evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> evaluate_rpn([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22","solution":"def evaluate_rpn(tokens): Evaluates an arithmetic expression in Reverse Polish Notation (RPN). Args: tokens (list of str): A list of strings representing the RPN expression. Returns: int: The result of the RPN expression evaluation. stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # Integer division else: stack.append(int(token)) return stack[0]"},{"question":"def filter_primes(arr): Takes an array of integers and returns a new array containing only the prime numbers from the original array. If there are no prime numbers in the input array, the function should return an empty array. >>> filter_primes([2, 3, 4, 5, 6]) == [2, 3, 5] >>> filter_primes([1, 4, 6, 8, 9, 10]) == [] >>> filter_primes([7, 11, 13, 17, 19]) == [7, 11, 13, 17, 19] >>> filter_primes([15, 18, 20, 22, 24, 25]) == [] >>> filter_primes([-5, -3, 0, 1, 2, 3]) == [2, 3] >>> filter_primes([101, 103, 107, 109, 113, 127, 131, 137]) == [101, 103, 107, 109, 113, 127, 131, 137] >>> filter_primes([29, 4, 5, 27, 37, -11, 0, 1, 18]) == [29, 5, 37] pass","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def filter_primes(arr): Returns a list containing only the prime numbers in the given array. return [x for x in arr if is_prime(x)]"},{"question":"def extract_and_transform(text: str, instructions: dict) -> str: Extracts and transforms a substring from the provided text based on the instructions. Args: text (str): The input text from which to extract and transform a substring. instructions (dict): The instructions specifying the extraction and transformation rules. Returns: str: The resulting transformed substring or the original text if no instructions. Examples: >>> extract_and_transform(\\"Hello, World!\\", {'start': 7, 'end': 12, 'transform': 'uppercase'}) 'WORLD' >>> extract_and_transform(\\"Python Programming\\", {'start': 0, 'end': 6, 'transform': 'reverse'}) 'nohtyP' >>> extract_and_transform(\\"abcdef\\", {'transform': 'lowercase'}) 'abcdef' >>> extract_and_transform(\\"Data Science\\", {'start': 5}) 'Science' >>> extract_and_transform(\\"Machine Learning\\", None) 'Machine Learning' def test_extract_and_transform_with_uppercase(): assert extract_and_transform(\\"Hello, World!\\", {'start': 7, 'end': 12, 'transform': 'uppercase'}) == \\"WORLD\\" def test_extract_and_transform_with_reverse(): assert extract_and_transform(\\"Python Programming\\", {'start': 0, 'end': 6, 'transform': 'reverse'}) == \\"nohtyP\\" def test_extract_and_transform_with_lowercase(): assert extract_and_transform(\\"abcdef\\", {'transform': 'lowercase'}) == \\"abcdef\\" def test_extract_and_transform_with_start_only(): assert extract_and_transform(\\"Data Science\\", {'start': 5}) == \\"Science\\" def test_extract_and_transform_with_none_instructions(): assert extract_and_transform(\\"Machine Learning\\", None) == \\"Machine Learning\\" def test_extract_and_transform_with_empty_instructions(): assert extract_and_transform(\\"Machine Learning\\", {}) == \\"Machine Learning\\" def test_extract_and_transform_with_out_of_range_start_end(): assert extract_and_transform(\\"Boundary Test\\", {'start': 20, 'end': 25, 'transform': 'uppercase'}) == \\"\\" def test_extract_and_transform_with_negative_start(): assert extract_and_transform(\\"Negative Start\\", {'start': -5, 'end': 7, 'transform': 'lowercase'}) == \\"negativ\\"","solution":"def extract_and_transform(text, instructions): Extracts and transforms a substring from the provided text based on the instructions. Args: text (str): The input text from which to extract and transform a substring. instructions (dict): The instructions specifying the extraction and transformation rules. Returns: str: The resulting transformed substring or the original text if no instructions. if not instructions: return text start = instructions.get('start', 0) end = instructions.get('end', len(text)) # Adjust start and end to be within valid range start = max(0, min(start, len(text))) end = max(0, min(end, len(text))) extracted_text = text[start:end] transform = instructions.get('transform') if transform == 'uppercase': return extracted_text.upper() elif transform == 'lowercase': return extracted_text.lower() elif transform == 'reverse': return extracted_text[::-1] return extracted_text"},{"question":"def adjust_positions(ages: List[int], threshold: int) -> List[int]: Adjusts the positions of people in the list such that people older than or equal to the threshold remain in their positions, while the rest are rearranged in non-descending order. :param ages: List of integers representing ages. :param threshold: Integer representing the age threshold. :return: List of ages with the positions adjusted as per the given condition. pass # Unit Tests def test_adjust_positions_example(): assert adjust_positions([25, 50, 35, 45, 20, 60], 45) == [20, 50, 25, 45, 35, 60] def test_adjust_positions_all_under_threshold(): assert adjust_positions([25, 20, 35], 40) == [20, 25, 35] def test_adjust_positions_all_over_threshold(): assert adjust_positions([50, 55, 60], 45) == [50, 55, 60] def test_adjust_positions_some_under_and_over(): assert adjust_positions([25, 18, 45, 50], 45) == [18, 25, 45, 50] def test_adjust_positions_with_same_ages(): assert adjust_positions([30, 45, 45, 30], 45) == [30, 45, 45, 30] def test_adjust_positions_min_max_threshold(): assert adjust_positions([10, 20, 30, 40, 50], 30) == [10, 20, 30, 40, 50] def test_adjust_positions_single_element(): assert adjust_positions([45], 45) == [45] def test_adjust_positions_multiple_elements_threshold_edge(): assert adjust_positions([30, 25, 40, 35], 35) == [25, 30, 40, 35]","solution":"def adjust_positions(ages, threshold): Adjusts the positions of people in the list such that people older than or equal to the threshold remain in their positions, while the rest are rearranged in non-descending order. :param ages: List of integers representing ages. :param threshold: Integer representing the age threshold. :return: List of ages with the positions adjusted as per the given condition. # Collect the ages that can be rearranged rearrange_ages = [age for age in ages if age < threshold] # Sort these ages rearrange_ages.sort() # Initialize the result list result = [] i = 0 # Iterate over the ages and build the result list for age in ages: if age < threshold: result.append(rearrange_ages[i]) i += 1 else: result.append(age) return result"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"ac\\") 1 >>> longest_palindromic_substring_length(\\"racecar\\") 7 >>> longest_palindromic_substring_length(\\"abcd\\") 1 >>> longest_palindromic_substring_length(\\"\\") 0 >>> longest_palindromic_substring_length(\\"tattarrattat\\") 12","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string s. n = len(s) if n == 0: return 0 # Create a table to store the results of subproblems dp = [[0] * n for _ in range(n)] max_length = 1 for i in range(n): dp[i][i] = True # Single letter is palindrome # Check for a window of size 2 start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check windows of size greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # Ending index of the current window # Check if s[i] to s[j] is a palindrome if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length"},{"question":"def min_switches_to_consecutive_green(n: int, k: int, state: str) -> int: Given the initial state of traffic lights, return the minimum number of switches required to get at least one segment of \`k\` consecutive green lights. Args: n (int): The number of traffic lights. k (int): The required segment length of consecutive green lights. state (str): A string of 'R' (red) and 'G' (green) representing the initial state of each traffic light. Returns: int: The minimum number of switches from red to green needed. Examples: >>> min_switches_to_consecutive_green(7, 3, 'RRGGRRR') 1 >>> min_switches_to_consecutive_green(5, 3, 'RRRRR') 3 >>> min_switches_to_consecutive_green(4, 2, 'GGGG') 0 >>> min_switches_to_consecutive_green(6, 3, 'RRGGGG') 0 >>> min_switches_to_consecutive_green(8, 4, 'RGRGRGRG') 2 >>> min_switches_to_consecutive_green(5, 5, 'RRRRR') 5 >>> min_switches_to_consecutive_green(5, 5, 'GGGGG') 0 >>> min_switches_to_consecutive_green(4, 1, 'RRGR') 0 >>> min_switches_to_consecutive_green(4, 1, 'RRRR') 1","solution":"def min_switches_to_consecutive_green(n, k, state): Returns the minimum number of switches required to get at least one segment of k consecutive green lights. min_switches = float('inf') for i in range(n - k + 1): segment = state[i:i + k] switches = segment.count('R') min_switches = min(min_switches, switches) return min_switches"},{"question":"def encrypt(text: str, shift: int) -> str: Encrypt the input text using Caesar cipher with the given shift value. >>> encrypt(\\"Hello, World!\\", 3) 'Khoor, Zruog!' >>> encrypt(\\"abcXYZ\\", -5) 'vwxSTU' pass def decrypt(text: str, shift: int) -> str: Decrypt the encrypted text using Caesar cipher with the given shift value. >>> decrypt(\\"Khoor, Zruog!\\", 3) 'Hello, World!' >>> decrypt(\\"vwxSTU\\", -5) 'abcXYZ' pass # Unit tests def test_encrypt_positive_shift(): assert encrypt(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert encrypt(\\"abcXYZ\\", 2) == \\"cdeZAB\\" def test_encrypt_negative_shift(): assert encrypt(\\"Hello, World!\\", -3) == \\"Ebiil, Tloia!\\" assert encrypt(\\"abcXYZ\\", -2) == \\"yzaVWX\\" def test_encrypt_with_large_shift(): assert encrypt(\\"Hello, World!\\", 29) == \\"Khoor, Zruog!\\" assert encrypt(\\"abcXYZ\\", 52) == \\"abcXYZ\\" # Shift equivalent to 0 def test_decrypt_positive_shift(): assert decrypt(\\"Khoor, Zruog!\\", 3) == \\"Hello, World!\\" assert decrypt(\\"cdeZAB\\", 2) == \\"abcXYZ\\" def test_decrypt_negative_shift(): assert decrypt(\\"Ebiil, Tloia!\\", -3) == \\"Hello, World!\\" assert decrypt(\\"yzaVWX\\", -2) == \\"abcXYZ\\" def test_decrypt_with_large_shift(): assert decrypt(\\"Khoor, Zruog!\\", 29) == \\"Hello, World!\\" assert decrypt(\\"abcXYZ\\", 52) == \\"abcXYZ\\" # Shift equivalent to 0","solution":"def encrypt(text, shift): Encrypts the text using Caesar cipher with the given shift value. encrypted_text = [] for char in text: if char.isalpha(): shift_amount = shift % 26 if char.islower(): new_char = chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a')) elif char.isupper(): new_char = chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A')) encrypted_text.append(new_char) else: encrypted_text.append(char) return ''.join(encrypted_text) def decrypt(text, shift): Decrypts the text using Caesar cipher with the given shift value. return encrypt(text, -shift)"},{"question":"def is_palindrome(n: int) -> bool: Helper function to check if a number is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(123) == False pass def next_palindrome(num: int) -> int: Returns the next palindrome greater than the input number. >>> next_palindrome(123) == 131 >>> next_palindrome(808) == 818 pass # Unit Tests def test_single_digit(): assert next_palindrome(8) == 9 assert next_palindrome(9) == 11 def test_double_digit(): assert next_palindrome(10) == 11 assert next_palindrome(12) == 22 def test_triple_digit(): assert next_palindrome(123) == 131 assert next_palindrome(808) == 818 def test_four_digit(): assert next_palindrome(1234) == 1331 assert next_palindrome(1001) == 1111 def test_edge_cases(): assert next_palindrome(99) == 101 assert next_palindrome(999) == 1001 assert next_palindrome(9999) == 10001","solution":"def is_palindrome(n): Helper function to check if a number is a palindrome. return str(n) == str(n)[::-1] def next_palindrome(num): Returns the next palindrome greater than the input number. num += 1 while not is_palindrome(num): num += 1 return num"},{"question":"def count_substrings(text: str, pattern: str) -> int: Returns the number of occurrences of the pattern string within the text string. The search is case-sensitive and counts overlapping patterns. >>> count_substrings(\\"abababa\\", \\"aba\\") == 3 >>> count_substrings(\\"hello\\", \\"ll\\") == 1 >>> count_substrings(\\"aaaaa\\", \\"aa\\") == 4 >>> count_substrings(\\"abc\\", \\"d\\") == 0","solution":"def count_substrings(text, pattern): Returns the number of occurrences of the pattern string within the text string. The search is case-sensitive and counts overlapping patterns. count = 0 i = 0 while i <= len(text) - len(pattern): if text[i:i + len(pattern)] == pattern: count += 1 i += 1 # Move just one step forward to enable overlapping match else: i += 1 return count"},{"question":"from typing import List from collections import Counter, defaultdict import heapq def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Find the top k most frequent elements in the array. If there are multiple elements with the same frequency, prioritize the elements that appear first in the array. :param nums: List of integers :param k: Integer representing the number of top frequent elements to return :return: List of k integers representing the top k most frequent elements Examples: >>> top_k_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent_elements([1, 2, 3, 4, 5, 5, 5, 6, 6, 6, 6], 3) [6, 5, 1] >>> top_k_frequent_elements([4, 4, 4, 5, 5, 6], 1) [4] def test_top_k_frequent_elements(): nums1 = [1, 1, 1, 2, 2, 3] k1 = 2 assert top_k_frequent_elements(nums1, k1) == [1, 2] nums2 = [1, 2, 3, 4, 5, 5, 5, 6, 6, 6, 6] k2 = 3 assert top_k_frequent_elements(nums2, k2) == [6, 5, 1] nums3 = [4, 4, 4, 5, 5, 6] k3 = 1 assert top_k_frequent_elements(nums3, k3) == [4] nums4 = [1, 2, 3, 4, 5] k4 = 3 assert top_k_frequent_elements(nums4, k4) == [1, 2, 3] nums5 = [i for i in range(10000)] + [i for i in range(5000)] k5 = 5 assert top_k_frequent_elements(nums5, k5) == [0, 1, 2, 3, 4] nums6 = [1, 2, 3, 1, 2, 3, 4] k6 = 2 assert top_k_frequent_elements(nums6, k6) == [1, 2]","solution":"from typing import List from collections import Counter, defaultdict import heapq def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the top k most frequent elements in nums. If multiple elements have the same frequency, prioritizes the elements that appear first. # Count frequencies of elements freq_counter = Counter(nums) # Using default dict to keep track of the order of first appearance order_dict = {} for idx, num in enumerate(nums): if num not in order_dict: order_dict[num] = idx # Preparing a min-heap to find the top k elements heap = [(-count, order_dict[num], num) for num, count in freq_counter.items()] heapq.heapify(heap) top_k = [heapq.heappop(heap)[2] for _ in range(k)] return top_k"},{"question":"def is_valid_bst(node_data): Determine if a binary tree is a valid binary search tree (BST). Args: node_data: List of tuples, where each tuple contains three integers (V, L, R) representing a node value and its left and right children. Returns: str: \\"YES\\" if the tree is a valid BST, otherwise \\"NO\\". >>> is_valid_bst([(4, 2, 5), (2, 1, 3), (5, -1, -1), (1, -1, -1), (3, -1, -1)]) \\"YES\\" >>> is_valid_bst([(1, 2, 3), (2, -1, -1), (3, -1, -1)]) \\"NO\\" pass def check_bst(n, node_data): Wrapper function to determine if a binary tree with N nodes is a valid binary search tree (BST). Args: n: Integer, number of nodes in the tree. node_data: List of tuples, where each tuple contains three integers (V, L, R) representing a node value and its left and right children. Returns: str: \\"YES\\" if the tree is a valid BST, otherwise \\"NO\\". pass def test_check_bst_valid(): n = 5 node_data = [ (4, 2, 5), (2, 1, 3), (5, -1, -1), (1, -1, -1), (3, -1, -1) ] assert check_bst(n, node_data) == \\"YES\\" def test_check_bst_invalid(): n = 3 node_data = [ (1, 2, 3), (2, -1, -1), (3, -1, -1) ] assert check_bst(n, node_data) == \\"NO\\" def test_check_bst_single_node(): n = 1 node_data = [ (1, -1, -1) ] assert check_bst(n, node_data) == \\"YES\\" def test_check_bst_invalid_with_subtree(): n = 4 node_data = [ (10, 5, 15), (5, -1, -1), (15, 6, -1), (6, -1, -1) ] assert check_bst(n, node_data) == \\"NO\\" def test_check_bst_large_tree(): n = 6 node_data = [ (6, 4, 8), (4, 2, 5), (2, 1, 3), (8, 7, 9), (7, -1, -1), (9, -1, -1) ] assert check_bst(n, node_data) == \\"YES\\"","solution":"def is_valid_bst(node_data): from collections import defaultdict # Building the tree tree = {} for data in node_data: V, L, R = data tree[V] = (L, R) # Helper function to validate a BST def validate(node, low, high): if node == -1: return True if not (low < node < high): return False left, right = tree.get(node, (-1, -1)) return validate(left, low, node) and validate(right, node, high) # Assuming the first item in node_data as root node. root = node_data[0][0] return validate(root, float('-inf'), float('inf')) def check_bst(n, node_data): return \\"YES\\" if is_valid_bst(node_data) else \\"NO\\""},{"question":"def longest_increasing_subsequence_length(n: int, sequence: List[int]) -> int: Finds the length of the longest contiguous subsequence that is strictly increasing. Parameters: n (int): The length of the sequence. sequence (list): A list of integers representing the sequence. Returns: int: The length of the longest contiguous subsequence that is strictly increasing. pass # Example usage: n = 9 sequence = [1, 2, 3, 4, 1, 2, 3, 4, 5] print(longest_increasing_subsequence_length(n, sequence)) # Output: 5 # Unit Test: def test_example_case(): n = 9 sequence = [1, 2, 3, 4, 1, 2, 3, 4, 5] assert longest_increasing_subsequence_length(n, sequence) == 5 def test_single_element(): n = 1 sequence = [1] assert longest_increasing_subsequence_length(n, sequence) == 1 def test_decreasing_sequence(): n = 5 sequence = [5, 4, 3, 2, 1] assert longest_increasing_subsequence_length(n, sequence) == 1 def test_increasing_sequence(): n = 5 sequence = [1, 2, 3, 4, 5] assert longest_increasing_subsequence_length(n, sequence) == 5 def test_all_equal_elements(): n = 5 sequence = [2, 2, 2, 2, 2] assert longest_increasing_subsequence_length(n, sequence) == 1 def test_mixed_sequence(): n = 7 sequence = [1, 3, 2, 3, 4, 5, 1] assert longest_increasing_subsequence_length(n, sequence) == 4 def test_empty_sequence(): n = 0 sequence = [] assert longest_increasing_subsequence_length(n, sequence) == 0 def test_sequence_with_duplicate_but_increasing(): n = 6 sequence = [1, 2, 2, 3, 4, 5] assert longest_increasing_subsequence_length(n, sequence) == 4","solution":"def longest_increasing_subsequence_length(n, sequence): Finds the length of the longest contiguous subsequence that is strictly increasing. Parameters: n (int): The length of the sequence. sequence (list): A list of integers representing the sequence. Returns: int: The length of the longest contiguous subsequence that is strictly increasing. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sequence[i] > sequence[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length # Example usage: n = 9 sequence = [1, 2, 3, 4, 1, 2, 3, 4, 5] print(longest_increasing_subsequence_length(n, sequence)) # Output: 5"},{"question":"def count_primes_in_range(T: int, ranges: List[Tuple[int, int]]) -> List[int]: Count the number of prime numbers in each specified range. >>> count_primes_in_range(1, [(1, 10)]) [4] >>> count_primes_in_range(3, [(1, 10), (11, 20), (21, 30)]) [4, 4, 2]","solution":"def sieve_of_eratosthenes(max_range): sieve = [True] * (max_range + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime p = 2 while (p * p <= max_range): if (sieve[p] == True): for i in range(p * p, max_range + 1, p): sieve[i] = False p += 1 return sieve def prime_count_in_range(L, R, sieve): return sum(sieve[L:R+1]) def count_primes_in_range(T, ranges): max_r = max(R for L, R in ranges) sieve = sieve_of_eratosthenes(max_r) result = [] for L, R in ranges: result.append(prime_count_in_range(L, R, sieve)) return result"},{"question":"def trap_rainwater(heights): Calculate the total amount of rainwater trapped between buildings. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 pass # Your code here def process_test_cases(T, test_cases): Process multiple test cases to find the rainwater trapped for each. >>> process_test_cases(2, [(6, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), (5, [4, 2, 0, 3, 2, 5])]) [6, 9] pass # Your code here from solution import trap_rainwater, process_test_cases def test_trap_rainwater_case1(): assert trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_rainwater_case2(): assert trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 def test_trap_rainwater_no_buildings(): assert trap_rainwater([]) == 0 def test_trap_rainwater_no_trapping(): assert trap_rainwater([1, 2, 3, 4, 5]) == 0 def test_trap_rainwater_flat_surface(): assert trap_rainwater([2, 2, 2, 2]) == 0 def test_process_test_cases(): T = 2 test_cases = [ (6, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), (5, [4, 2, 0, 3, 2, 5]) ] assert process_test_cases(T, test_cases) == [6, 9]","solution":"def trap_rainwater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped def process_test_cases(T, test_cases): results = [] for test_case in test_cases: N, heights = test_case results.append(trap_rainwater(heights)) return results"},{"question":"def find_pattern_occurrences(pattern: str, text: str) -> List[int]: Returns a list of starting indices of all occurrences of \`pattern\` in \`text\`. >>> find_pattern_occurrences(\\"abc\\", \\"ababcabcabc\\") [2, 5, 8] >>> find_pattern_occurrences(\\"a\\", \\"aaa\\") [0, 1, 2] >>> find_pattern_occurrences(\\"abc\\", \\"defghijkl\\") [] >>> find_pattern_occurrences(\\"abcdefgh\\", \\"abcdefgh\\") [0] >>> find_pattern_occurrences(\\"aa\\", \\"aaaa\\") [0, 1, 2] >>> find_pattern_occurrences(\\"aba\\", \\"ababa\\") [0, 2]","solution":"def find_pattern_occurrences(pattern, text): Returns a list of starting indices of all occurrences of \`pattern\` in \`text\`. pattern_length = len(pattern) text_length = len(text) result = [] for i in range(text_length - pattern_length + 1): match = True for j in range(pattern_length): if text[i + j] != pattern[j]: match = False break if match: result.append(i) return result"},{"question":"def fizz_buzz(n: int) -> List[str]: Write a function that takes an integer \`n\` and returns a list of strings representing all numbers from 1 to \`n\`. However, for multiples of 3, the string should be \\"Fizz\\" and for multiples of 5, the string should be \\"Buzz\\". For numbers which are multiples of both 3 and 5, the string should be \\"FizzBuzz\\". Examples: >>> fizz_buzz(5) ['1', '2', 'Fizz', '4', 'Buzz'] >>> fizz_buzz(15) ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz'] from solution import fizz_buzz def test_fizz_buzz_up_to_5(): assert fizz_buzz(5) == ['1', '2', 'Fizz', '4', 'Buzz'] def test_fizz_buzz_up_to_15(): assert fizz_buzz(15) == ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz'] def test_fizz_buzz_up_to_3(): assert fizz_buzz(3) == ['1', '2', 'Fizz'] def test_fizz_buzz_up_to_1(): assert fizz_buzz(1) == ['1'] def test_fizz_buzz_only_fizzbuzz(): assert fizz_buzz(30) == ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz', '16', '17', 'Fizz', '19', 'Buzz', 'Fizz', '22', '23', 'Fizz', 'Buzz', '26', 'Fizz', '28', '29', 'FizzBuzz']","solution":"def fizz_buzz(n): Returns a list of strings representing numbers from 1 to n with special rules: - For multiples of 3, the string is \\"Fizz\\". - For multiples of 5, the string is \\"Buzz\\". - For multiples of both 3 and 5, the string is \\"FizzBuzz\\". result = [] for i in range(1, n + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def min_cost_to_distribute_gels(N, M, D, S, B, C): Calculate the minimal total cost to distribute the energy gels so that each runner can complete their chosen distance. from solution import min_cost_to_distribute_gels def test_example_1(): N = 3 M = 3 D = [10000, 20000, 15000] S = [5000, 10000, 7500] B = [1000, 5000, 7500] C = [15, 10, 8] assert min_cost_to_distribute_gels(N, M, D, S, B, C) == 33 def test_example_2(): N = 2 M = 2 D = [30000, 25000] S = [15000, 12000] B = [5000, 7500] C = [20, 25] assert min_cost_to_distribute_gels(N, M, D, S, B, C) == 45 def test_example_3(): N = 2 M = 1 D = [30000, 25000] S = [15000, 12000] B = [10000] C = [30] assert min_cost_to_distribute_gels(N, M, D, S, B, C) == -1 def test_no_additional_gels_needed(): N = 2 M = 2 D = [15000, 20000] S = [15000, 20000] B = [5000, 7500] C = [20, 25] assert min_cost_to_distribute_gels(N, M, D, S, B, C) == 0 def test_insufficient_gels(): N = 3 M = 1 D = [15000, 20000, 25000] S = [10000, 10000, 10000] B = [1000] C = [10] assert min_cost_to_distribute_gels(N, M, D, S, B, C) == -1","solution":"def min_cost_to_distribute_gels(N, M, D, S, B, C): import heapq requirements = [] for i in range(N): if S[i] < D[i]: requirements.append((D[i] - S[i], i)) if not requirements: return 0 requirements.sort(reverse=True) gels = sorted(zip(B, C)) heap = [] idx = 0 total_cost = 0 for req, runner in requirements: while idx < M and gels[idx][0] <= req: heapq.heappush(heap, gels[idx][1]) idx += 1 if not heap: return -1 total_cost += heapq.heappop(heap) return total_cost"},{"question":"def find_two_sum_indices(numbers: List[int], target: int) -> List[int]: Write a function that accepts a list of integers and a target integer. The function should return the two distinct indices of the list that add up to the target integer. If there are no such indices, return \`None\`. Examples: >>> find_two_sum_indices([2, 7, 11, 15], 9) [0, 1] >>> find_two_sum_indices([3, 2, 4], 6) [1, 2] >>> find_two_sum_indices([1, 2, 3], 7) None >>> find_two_sum_indices([0, 4, 3, 0], 0) [0, 3] >>> find_two_sum_indices([3, 3], 6) [0, 1] >>> find_two_sum_indices([-1, -2, -3, -4, -5], -8) [2, 4] >>> find_two_sum_indices([1, -2, 3, 5, -6, 7], 1) [1, 2]","solution":"def find_two_sum_indices(numbers, target): Returns the indices of two distinct elements from the list that add up to the target. If no such elements exist, returns None. num_to_index = {} for i, num in enumerate(numbers): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return None"},{"question":"from typing import List, Tuple def longest_prerequisite_path(relations: List[Tuple[str, str]]) -> int: Determine the longest path of prerequisite tasks. If no cyclic dependency exists, return the number of tasks in the longest possible prerequisite path. If a cycle is detected, return -1. Example: >>> longest_prerequisite_path([(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"a\\", \\"d\\"), (\\"d\\", \\"e\\"), (\\"c\\", \\"e\\")]) 4 >>> longest_prerequisite_path([(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\")]) -1","solution":"from typing import List, Tuple def longest_prerequisite_path(relations: List[Tuple[str, str]]) -> int: from collections import defaultdict, deque # Build a graph and in-degree count graph = defaultdict(list) indegree = defaultdict(int) for a, b in relations: graph[a].append(b) indegree[b] += 1 if a not in indegree: indegree[a] = 0 # Topological sort using Kahn's algorithm zero_indegree = deque([node for node in indegree if indegree[node] == 0]) longest_path = defaultdict(int) while zero_indegree: node = zero_indegree.popleft() for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree.append(neighbor) longest_path[neighbor] = max(longest_path[neighbor], longest_path[node] + 1) # Check for cycle if any(indegree[node] > 0 for node in indegree): return -1 # Return the length of the longest path return max(longest_path.values(), default=0)"},{"question":"def remove_duplicates(input_list: list[int]) -> list[int]: Returns a new list with duplicates removed and the original order preserved. Parameters: - input_list: list of integers Returns: - list of integers with duplicates removed Examples: >>> remove_duplicates([1, 2, 3, 2, 4, 1]) == [1, 2, 3, 4] >>> remove_duplicates([7, 9, 7, 1, 9, 1]) == [7, 9, 1] >>> remove_duplicates([5, 5, 5, 5, 5]) == [5] >>> remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([]) == []","solution":"def remove_duplicates(input_list): Returns a new list with duplicates removed and the original order preserved. Parameters: - input_list: list of integers Returns: - list of integers with duplicates removed seen = set() result = [] for item in input_list: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def total_water(camel_drinks, d): Calculates the total amount of water the camel can drink from start to finish. Parameters: camel_drinks (list of integers): Amount of water available at each station d (integer): Maximum amount of water the camel can drink at each station Returns: int: Total amount of water the camel can drink along the route pass # your code here # Unit tests def test_total_water_with_maximum_capacity(): assert total_water([10, 20, 5, 30, 15], 10) == 45 def test_total_water_with_different_stations(): assert total_water([5, 8, 2, 12], 6) == 19 def test_total_water_with_no_water_available(): assert total_water([0, 0, 0, 0], 10) == 0 def test_total_water_with_all_water_within_capacity(): assert total_water([1, 2, 3, 4, 5], 10) == 15 def test_total_water_with_large_capacities(): assert total_water([10]*10000, 5) == 50000","solution":"def total_water(camel_drinks, d): Calculates the total amount of water the camel can drink from start to finish. Parameters: camel_drinks (list of integers): Amount of water available at each station d (integer): Maximum amount of water the camel can drink at each station Returns: int: Total amount of water the camel can drink along the route total = 0 for water in camel_drinks: total += min(water, d) return total"},{"question":"def price_calculator(items, discounts): Calculate the final price of items after applying given discounts. Parameters: items (list of tuples): List of pairs where each pair contains an item name and its initial price. discounts (dict): Dictionary where keys are item names and values are discount rates in percentage. Returns: list of tuples: List of pairs where each pair contains an item name and its final price after applying discounts. pass # Example usage: items = [(\\"apple\\", 100), (\\"banana\\", 80), (\\"orange\\", 90)] discounts = {\\"apple\\": 10, \\"orange\\": 20} print(price_calculator(items, discounts)) # Unit Tests: def test_no_discounts(): items = [(\\"apple\\", 100), (\\"banana\\", 80), (\\"orange\\", 90)] discounts = {} assert price_calculator(items, discounts) == [(\\"apple\\", 100), (\\"banana\\", 80), (\\"orange\\", 90)] def test_some_discounts(): items = [(\\"apple\\", 100), (\\"banana\\", 80), (\\"orange\\", 90)] discounts = {\\"apple\\": 10, \\"orange\\": 20} assert price_calculator(items, discounts) == [(\\"apple\\", 90.0), (\\"banana\\", 80), (\\"orange\\", 72.0)] def test_all_discounts(): items = [(\\"apple\\", 100), (\\"banana\\", 80), (\\"orange\\", 90)] discounts = {\\"apple\\": 10, \\"banana\\": 50, \\"orange\\": 20} assert price_calculator(items, discounts) == [(\\"apple\\", 90.0), (\\"banana\\", 40.0), (\\"orange\\", 72.0)] def test_large_discount(): items = [(\\"apple\\", 100)] discounts = {\\"apple\\": 100} assert price_calculator(items, discounts) == [(\\"apple\\", 0.0)] def test_no_items(): items = [] discounts = {\\"apple\\": 10} assert price_calculator(items, discounts) == []","solution":"def price_calculator(items, discounts): Calculate the final price of items after applying given discounts. Parameters: items (list of tuples): List of pairs where each pair contains an item name and its initial price. discounts (dict): Dictionary where keys are item names and values are discount rates in percentage. Returns: list of tuples: List of pairs where each pair contains an item name and its final price after applying discounts. final_prices = [] for item, price in items: discount = discounts.get(item, 0) final_price = price - (price * discount / 100) final_prices.append((item, final_price)) return final_prices"},{"question":"def has_unique_characters(s: str) -> bool: Determines if a string has all unique characters. >>> has_unique_characters(\\"leetcode\\") False >>> has_unique_characters(\\"abc\\") True >>> has_unique_characters(\\"aA\\") True >>> has_unique_characters(\\"\\") True","solution":"def has_unique_characters(s): Determines if a string has all unique characters. :param s: the input string :return: True if the string has all unique characters, False otherwise # If the length of the string exceeds the number of possible unique ascii characters (128), return False if len(s) > 128: return False for i in range(len(s)): if s[i] in s[i+1:]: return False return True"},{"question":"def count_islands(grid: List[str]) -> int: Count the number of distinct \\"islands\\" in the grid. An island is defined as a group of connected non-empty cells ('1') surrounded by water ('0'). Cells are considered connected if they are adjacent horizontally or vertically (but not diagonally). >>> count_islands([ ... \\"11110\\", ... \\"11010\\", ... \\"11000\\", ... \\"00000\\" ... ]) == 1 >>> count_islands([ ... \\"11000\\", ... \\"11000\\", ... \\"00100\\", ... \\"00001\\", ... \\"00011\\" ... ]) == 4 pass","solution":"from typing import List def count_islands(grid: List[str]) -> int: if not grid: return 0 num_rows, num_cols = len(grid), len(grid[0]) visited = [[False]*num_cols for _ in range(num_rows)] def dfs(r, c): if r < 0 or c < 0 or r >= num_rows or c >= num_cols or grid[r][c] == '0' or visited[r][c]: return visited[r][c] = True dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) island_count = 0 for r in range(num_rows): for c in range(num_cols): if grid[r][c] == '1' and not visited[r][c]: island_count += 1 dfs(r, c) return island_count"},{"question":"def check_tic_tac_toe_winner(board: list) -> str: Determines the winner of a Tic-Tac-Toe game or returns \\"Draw\\" if there is no winner. >>> check_tic_tac_toe_winner([[\\"X\\", \\"X\\", \\"X\\"], [\\"O\\", \\"O\\", \\" \\"], [\\" \\", \\" \\", \\" \\"]]) == \\"X\\" >>> check_tic_tac_toe_winner([[\\"O\\", \\"X\\", \\"X\\"], [\\"O\\", \\" \\", \\" \\"], [\\"O\\", \\" \\", \\"X\\"]]) == \\"O\\" >>> check_tic_tac_toe_winner([[\\"X\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\" \\"], [\\"O\\", \\" \\", \\"X\\"]]) == \\"X\\" >>> check_tic_tac_toe_winner([[\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\"]]) == \\"Draw\\" >>> check_tic_tac_toe_winner([[\\"X\\", \\"X\\", \\"O\\"], [\\"X\\", \\"O\\", \\" \\"], [\\"O\\", \\" \\", \\"X\\"]]) == \\"O\\" >>> check_tic_tac_toe_winner([[\\" \\", \\" \\", \\" \\"], [\\" \\", \\" \\", \\" \\"], [\\" \\", \\" \\", \\" \\"]]) == \\"Draw\\"","solution":"def check_tic_tac_toe_winner(board: list) -> str: Determines the winner of a Tic-Tac-Toe game or returns \\"Draw\\" if there is no winner. :param board: A 3x3 list of lists representing the Tic-Tac-Toe board. :return: \\"X\\", \\"O\\", or \\"Draw\\" # Check rows and columns for i in range(3): if board[i][0] == board[i][1] == board[i][2] != \\" \\": return board[i][0] if board[0][i] == board[1][i] == board[2][i] != \\" \\": return board[0][i] # Check diagonals if board[0][0] == board[1][1] == board[2][2] != \\" \\": return board[0][0] if board[0][2] == board[1][1] == board[2][0] != \\" \\": return board[0][2] return \\"Draw\\""},{"question":"def product_except_self(arr): Given an array \`arr\` of integers, computes the product of every integer in \`arr\` excluding the one at each index. This function returns a new array where each element \`i\` contains the product of all elements in the original array except the one at index \`i\`. >>> product_except_self([1, 2, 3, 4]) # should return [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) # should return [60, 40, 30, 24] >>> product_except_self([1, 0]) # should return [0, 1] >>> product_except_self([0, 0, 1]) # should return [0, 0, 0] pass def test_product_except_self(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] assert product_except_self([1, 0]) == [0, 1] assert product_except_self([0, 0, 1]) == [0, 0, 0] assert product_except_self([2, 2, 2, 2]) == [8, 8, 8, 8] assert product_except_self([4]) == [1] def test_product_except_self_empty(): assert product_except_self([]) == [] def test_product_except_self_negatives(): assert product_except_self([-1, -2, -3, -4]) == [-24, -12, -8, -6] assert product_except_self([-1, 1]) == [1, -1]","solution":"def product_except_self(arr): Returns an array where each index contains the product of all elements in the original array except the element at that index. length = len(arr) if length == 0: return [] # Initialize the result array with 1s result = [1] * length # Compute the prefix products prefix = 1 for i in range(length): result[i] = prefix prefix *= arr[i] # Compute the suffix products and multiply with result suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= arr[i] return result"},{"question":"from typing import List, Tuple def create_bouquets(s: str) -> Tuple[int, List[Tuple[str, str]]]: Given a string 's' with unique characters representing flower types, this function returns the smallest number of bouquets and the pairs of flower types that form each bouquet. >>> create_bouquets(\\"abc\\") (3, [('a', 'b'), ('a', 'c'), ('b', 'c')]) >>> create_bouquets(\\"ab\\") (1, [('a', 'b')]) pass","solution":"def create_bouquets(s): Given a string 's' with unique characters representing flower types, this function returns the smallest number of bouquets and the pairs of flower types that form each bouquet. flower_list = sorted(s) bouquets = [] for i in range(len(flower_list)): for j in range(i + 1, len(flower_list)): bouquets.append((flower_list[i], flower_list[j])) return len(bouquets), bouquets"},{"question":"def remove_duplicates(T: int, test_cases: list) -> list: Removes duplicates from data log IDs while retaining the first occurrence of each. Args: T: Integer representing the number of test cases. test_cases: A list of tuples, where each tuple contains an integer N (number of data logs) and a list of N integers representing the unique IDs of the data logs. Returns: A list of lists, where each inner list contains the unique data log IDs in the order of their first appearance for each test case. Examples: >>> remove_duplicates(1, [(5, [1, 2, 2, 1, 3])]) [[1, 2, 3]] >>> remove_duplicates(1, [(4, [5, 5, 5, 5])]) [[5]] >>> remove_duplicates(1, [(6, [1, 1000000, 1, 1000000, 500000, 500000])]) [[1, 1000000, 500000]]","solution":"def remove_duplicates(t, test_cases): result = [] for i in range(t): N = test_cases[i][0] logs = test_cases[i][1] seen = set() unique_logs = [] for log in logs: if log not in seen: seen.add(log) unique_logs.append(log) result.append(unique_logs) return result"},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Given a string, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 True >>> length_of_longest_substring(\\"bbbbb\\") == 1 True >>> length_of_longest_substring(\\"pwwkew\\") == 3 True >>> length_of_longest_substring(\\"abcde\\") == 5 True >>> length_of_longest_substring(\\"a\\") == 1 True >>> length_of_longest_substring(\\"\\") == 0 True >>> length_of_longest_substring(\\"au\\") == 2 True >>> length_of_longest_substring(\\"dvdf\\") == 3 True >>> length_of_longest_substring(\\"anviaj\\") == 5 True >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 True","solution":"def length_of_longest_substring(s): Given a string, find the length of the longest substring without repeating characters. char_index = {} max_length = 0 start = 0 for index, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"def normalize_paths(paths: List[str]) -> List[str]: Normalize a list of UNIX-like file paths. >>> normalize_paths([\\"/a//b////c/d//././/..\\", \\"/../\\", \\"/home//foo/\\"]) [\\"/a/b/c\\", \\"/\\", \\"/home/foo\\"] >>> normalize_paths([\\"/a/./b/../../c/\\"]) [\\"/c\\"] >>> normalize_paths([\\"/../\\"]) [\\"/\\"] >>> normalize_paths([\\"/\\"]) [\\"/\\"] >>> normalize_paths([\\"/a//b////c/d//././/..//\\"]) [\\"/a/b/c\\"] >>> normalize_paths([\\"/a//b////c///../d/\\"]) [\\"/a/b/d\\"] >>> normalize_paths([\\"//a//..//b//c/./d/..//\\"]) [\\"/b/c\\"] >>> normalize_paths([\\"/a/../../b/../c//.//\\"]) [\\"/c\\"] >>> normalize_paths([\\"//\\"]) [\\"/\\"] >>> normalize_paths([\\"/a/b/c/../d/../../e\\"]) [\\"/a/e\\"] >>> normalize_paths([\\"/..//../\\"]) [\\"/\\"] >>> normalize_paths([\\"/a/b/c/../../../\\"]) [\\"/\\"] >>> normalize_paths([\\"/a/b/../../c/d/../e/f/./\\"]) [\\"/c/e/f\\"]","solution":"from typing import List def normalize_paths(paths: List[str]) -> List[str]: def normalize_path(path: str) -> str: parts = path.split('/') stack = [] for part in parts: if part == \\"..\\": if stack: stack.pop() elif part and part != \\".\\": stack.append(part) return \\"/\\" + \\"/\\".join(stack) return [normalize_path(path) for path in paths]"},{"question":"from typing import List def process_input(input_string: str) -> List[str]: Determine the final order of clips based on their priorities. Args: input_string (str): A multiline string with test cases as described in the prompt. Returns: List[str]: A list where each element is a space-separated string of clip indices for each test case in the input. Example: >>> process_input(\\"2n5n4 2 3 1 5n4n10 5 10 15\\") [\\"4 2 3 1 5\\", \\"2 1 3 4\\"] pass def test_sample_case_1(): input_data = \\"2n5n4 2 3 1 5n4n10 5 10 15\\" expected_output = [\\"4 2 3 1 5\\", \\"2 1 3 4\\"] assert process_input(input_data) == expected_output def test_same_priority(): input_data = \\"1n5n1 1 1 1 1\\" expected_output = [\\"1 2 3 4 5\\"] assert process_input(input_data) == expected_output def test_reverse_priority(): input_data = \\"1n5n5 4 3 2 1\\" expected_output = [\\"5 4 3 2 1\\"] assert process_input(input_data) == expected_output def test_alternating_priority(): input_data = \\"1n6n1 3 1 3 1 3\\" expected_output = [\\"1 3 5 2 4 6\\"] assert process_input(input_data) == expected_output def test_large_number_of_test_cases(): input_data = \\"3n3n2 1 3n4n4 3 2 1n2n10 20\\" expected_output = [\\"2 1 3\\", \\"4 3 2 1\\", \\"1 2\\"] assert process_input(input_data) == expected_output","solution":"def merge_clips(test_cases): results = [] for case in test_cases: n, priorities = case # Create a list of (priority, index) tuples clips = [(priorities[i], i + 1) for i in range(n)] # Sort by (priority, index) since index is unique for all clips clips.sort() # Collect the indices in the sorted order sorted_indices = [clip[1] for clip in clips] results.append(\\" \\".join(map(str, sorted_indices))) return results # Function to parse the input and process the test cases def process_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] line_index = 1 for _ in range(T): n = int(lines[line_index]) priorities = list(map(int, lines[line_index + 1].split())) test_cases.append((n, priorities)) line_index += 2 return merge_clips(test_cases)"},{"question":"def min_operations_to_fix_string(s: str) -> int: Determine the minimum number of operations required to make the string such that no character appears more than twice consecutively. >>> min_operations_to_fix_string(\\"aaabbc\\") == 1 >>> min_operations_to_fix_string(\\"aaaaaa\\") == 4 >>> min_operations_to_fix_string(\\"aabbcc\\") == 0 >>> min_operations_to_fix_string(\\"abcabc\\") == 0 >>> min_operations_to_fix_string(\\"aaaa\\") == 2 >>> min_operations_to_fix_string(\\"aaaabbbb\\") == 4 >>> min_operations_to_fix_string(\\"eee\\") == 1 >>> min_operations_to_fix_string(\\"bbbbbb\\") == 4 >>> min_operations_to_fix_string(\\"ccccccccc\\") == 7 >>> min_operations_to_fix_string(\\"aaapppeerrrr\\") == 4 >>> min_operations_to_fix_string(\\"xxxyyzzzz\\") == 3 pass","solution":"def min_operations_to_fix_string(s): Determine the minimum number of operations required to make the string such that no character appears more than twice consecutively. count = 0 i = 0 while i < len(s): repeat_length = 1 # Count the length of the current run of the same character while i + repeat_length < len(s) and s[i] == s[i + repeat_length]: repeat_length += 1 # For every third or more consecutive characters, one operation is needed. if repeat_length > 2: count += (repeat_length - 2) # Move to the next group of characters. i += repeat_length return count"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Checks if one string is a rotation of another string using only one call to a string handling method. :param s1: Original string :param s2: String to check if it is a rotation of s1 :return: True if s2 is a rotation of s1, otherwise False >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"hello\\", \\"helol\\") False >>> is_rotation(\\"abc\\", \\"bca\\") True >>> is_rotation(\\"abc\\", \\"acb\\") False","solution":"def is_rotation(s1, s2): Checks if s2 is a rotation of s1. :param s1: Original string :param s2: String to check if it is a rotation of s1 :return: True if s2 is a rotation of s1, otherwise False if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"def longestSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longestSubstring(\\"abcabcbb\\") 3 >>> longestSubstring(\\"bbbbb\\") 1 >>> longestSubstring(\\"pwwkew\\") 3 >>> longestSubstring(\\"\\") 0 >>> longestSubstring(\\"abcdef\\") 6 >>> longestSubstring(\\"abcaabcd\\") 4 >>> longestSubstring(\\"aaaa\\") 1 >>> longestSubstring(\\"abc def ghi\\") 7","solution":"def longestSubstring(s): Returns the length of the longest substring without repeating characters. n = len(s) char_index_map = {} max_len = 0 start = 0 for end in range(n): if s[end] in char_index_map: # Move the start pointer to the right of the last occurrence start = max(start, char_index_map[s[end]] + 1) # Update the last occurrence of the character char_index_map[s[end]] = end # Update the maximum length max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List def primes_between(a: int, b: int) -> List[int]: Returns a list of all prime numbers between a and b (including a and b, if they themselves are prime). >>> primes_between(10, 20) [11, 13, 17, 19] >>> primes_between(30, 50) [31, 37, 41, 43, 47] >>> primes_between(1, 10) [2, 3, 5, 7] def test_primes_between_10_and_20(): assert primes_between(10, 20) == [11, 13, 17, 19] def test_primes_between_30_and_50(): assert primes_between(30, 50) == [31, 37, 41, 43, 47] def test_primes_between_1_and_10(): assert primes_between(1, 10) == [2, 3, 5, 7] def test_primes_between_0_and_1(): assert primes_between(0, 1) == [] def test_primes_between_23_and_29(): assert primes_between(23, 29) == [23, 29] def test_primes_between_negative_and_positive(): assert primes_between(-10, 10) == [2, 3, 5, 7] def test_primes_between_single_value_prime(): assert primes_between(5, 5) == [5] def test_primes_between_single_value_non_prime(): assert primes_between(4, 4) == []","solution":"def is_prime(n): Helper function to check if a number is a prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_between(a, b): Returns a list of all prime numbers between a and b (inclusive). return [num for num in range(a, b + 1) if is_prime(num)]"},{"question":"def max_product_of_two(lst): Returns the maximum product of two distinct elements from the list. >>> max_product_of_two([1, 2, 3, 4, 5]) == 20 # 4*5 >>> max_product_of_two([-10, -20, 1, 3, 2]) == 200 # -10*-20 >>> max_product_of_two([-1, -2, -3, -4, -5]) == 20 # -4*-5 >>> max_product_of_two([2, 3]) == 6 # 2*3 >>> max_product_of_two([-1000, -999, 1000, 999]) == 999000 # 1000*999 >>> max_product_of_two([0, 0, 1, 2, 3]) == 6 # 2*3 >>> max_product_of_two([0, 1]) == 0 # 0*1 >>> max_product_of_two([-1, 1]) == -1 # -1*1","solution":"def max_product_of_two(lst): Returns the maximum product of two distinct elements from the list. if len(lst) < 2: return None max1 = max2 = float('-inf') min1 = min2 = float('inf') for num in lst: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2)"},{"question":"from typing import List def minimal_cut_to_alternate_heights(heights: List[int]) -> int: Given a sequence of integers in an array representing the heights of trees in a forest, find the minimum total amount of height that needs to be cut off from the trees to make sure no two adjacent trees have the same height. Args: heights (List[int]): A list of integers where each integer represents the height of a tree. Returns: int: The minimum sum of height reductions required. Example: >>> minimal_cut_to_alternate_heights([5, 4, 3, 5, 4, 5]) 0 >>> minimal_cut_to_alternate_heights([3, 3, 3, 3, 3]) 6 >>> minimal_cut_to_alternate_heights([1, 2, 1, 2, 1, 2, 1, 2]) 0 >>> minimal_cut_to_alternate_heights([4, 4, 4, 4, 4]) 6 >>> minimal_cut_to_alternate_heights([5, 5, 6, 6, 7, 7, 8, 8]) 6","solution":"from typing import List def minimal_cut_to_alternate_heights(heights: List[int]) -> int: n = len(heights) if n <= 1: return 0 cuts = 0 for i in range(1, n): if heights[i] == heights[i - 1]: # A tree must be cut so that the current one is different from the previous one cuts += 1 heights[i] -= 1 # Cut the current tree by 1 return cuts"},{"question":"def calculate_max_score(N, M, difficulties, scores, skills): Calculate the maximum total score each participant can achieve. Args: N (int): Number of participants. M (int): Number of problems. difficulties (List[int]): A list of difficulties for each problem. scores (List[int]): A list of scores for each problem. skills (List[int]): A list of skill levels for each participant. Returns: List[int]: A list of maximum total scores for each participant. >>> calculate_max_score(5, 3, [2, 1, 3], [10, 5, 15], [1, 2, 3, 2, 1]) [5, 15, 30, 15, 5] >>> calculate_max_score(1, 3, [1, 2, 3], [10, 20, 30], [2]) [30] pass def process_input(input_data): Process the input data and calculate the results for multiple test cases. Args: input_data (str): The input data as a string. Returns: List[int]: A list of maximum total scores for all participants in all test cases. >>> input_data = \\"1n5 3n2 1 3n10 5 15n1n2n3n2n1n\\" >>> process_input(input_data) [5, 15, 30, 15, 5] pass import pytest from solution import process_input, calculate_max_score def test_example_case(): input_data = \\"1n5 3n2 1 3n10 5 15n1n2n3n2n1n\\" expected_output = [5, 15, 30, 15, 5] assert process_input(input_data) == expected_output def test_single_participant(): input_data = \\"1n1 3n1 2 3n10 20 30n2n\\" expected_output = [30] assert process_input(input_data) == expected_output def test_single_problem(): input_data = \\"1n3 1n1n10n1n2n3n\\" expected_output = [10, 10, 10] assert process_input(input_data) == expected_output def test_no_problems_can_be_solved(): input_data = \\"1n2 2n5 6n10 15n1n2n\\" expected_output = [0, 0] assert process_input(input_data) == expected_output def test_all_problems_solved(): input_data = \\"1n3 3n1 2 3n10 20 30n5n5n5n\\" expected_output = [60, 60, 60] assert process_input(input_data) == expected_output def test_multiple_test_cases(): input_data = \\"2n3 3n1 2 3n10 20 30n3n2n1n2 2n1 2n5 10n1n2n\\" expected_output = [60, 30, 10, 5, 15] assert process_input(input_data) == expected_output","solution":"def calculate_max_score(N, M, difficulties, scores, skills): # Create tuples of (difficulty, score) and sort them by difficulty in ascending order problems = sorted(zip(difficulties, scores)) # Calculate cumulative score array cumulative_scores = [0] * (M + 1) for index in range(1, M + 1): cumulative_scores[index] = cumulative_scores[index - 1] + problems[index - 1][1] # Function to find the maximum total score for a given skill def max_total_score(skill): low, high = 0, M while low < high: mid = (low + high + 1) // 2 if problems[mid - 1][0] <= skill: low = mid else: high = mid - 1 return cumulative_scores[low] return [max_total_score(skill) for skill in skills] def process_input(input_data): result = [] lines = input_data.strip().split('n') index = 0 T = int(lines[index]) index += 1 for _ in range(T): N, M = map(int, lines[index].split()) index += 1 difficulties = list(map(int, lines[index].split())) index += 1 scores = list(map(int, lines[index].split())) index += 1 skills = [int(lines[index + i]) for i in range(N)] index += N result.extend(calculate_max_score(N, M, difficulties, scores, skills)) return result"},{"question":"def spiral_matrix(m: int, n: int, arr: List[int]) -> str: Returns a string representation of a spiral matrix formed with the given integers. >>> spiral_matrix(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) '1 2 3n8 9 4n7 6 5' >>> spiral_matrix(4, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) '1 2 3 4n12 13 14 5n11 16 15 6n10 9 8 7' >>> spiral_matrix(2, 3, [1, 2, 3, 4, 5, 6]) '1 2 3n6 5 4' >>> spiral_matrix(3, 2, [1, 2, 3, 4, 5, 6]) '1 2n6 3n5 4' >>> spiral_matrix(1, 4, [1, 2, 3, 4]) '1 2 3 4' >>> spiral_matrix(4, 1, [1, 2, 3, 4]) '1n2n3n4' >>> spiral_matrix(1, 1, [1]) '1' >>> spiral_matrix(0, 0, []) '' >>> spiral_matrix(2, 3, [1, 2, 3]) '' >>> spiral_matrix(-1, 3, [1, 2, 3]) ''","solution":"def spiral_matrix(m, n, arr): if m < 1 or n < 1 or len(arr) != m * n: return \\"\\" matrix = [[0] * n for _ in range(m)] top, bottom, left, right = 0, m-1, 0, n-1 index = 0 while index < len(arr): for i in range(left, right+1): if index < len(arr): matrix[top][i] = arr[index] index += 1 top += 1 for i in range(top, bottom+1): if index < len(arr): matrix[i][right] = arr[index] index += 1 right -= 1 for i in range(right, left-1, -1): if index < len(arr): matrix[bottom][i] = arr[index] index += 1 bottom -= 1 for i in range(bottom, top-1, -1): if index < len(arr): matrix[i][left] = arr[index] index += 1 left += 1 return 'n'.join([' '.join(map(str, row)) for row in matrix])"},{"question":"def max_subarray_with_negative(T: int, test_cases: list) -> list: For each test case, find the maximum sum of a contiguous subarray that contains at least one negative number. Args: T (int): Number of test cases. test_cases (list): A list of tuples, each tuple containing: - an integer n (size of the array) - a list of n integers (the array elements) Returns: list: A list of integers representing the result for each test case. Example: >>> max_subarray_with_negative(3, [(5, [1, 2, 3, -4, 5]), (4, [-1, -2, -3, -4]), (3, [1, 2, 3])]) [7, -1, -1] >>> max_subarray_with_negative(1, [(1, [5])]) [-1] >>> max_subarray_with_negative(1, [(1, [-5])]) [-5]","solution":"def max_subarray_with_negative(T: int, test_cases: list) -> list: For each test case, find the maximum sum of a contiguous subarray that contains at least one negative number. Args: T (int): Number of test cases. test_cases (list): A list of tuples, each tuple containing: - an integer n (size of the array) - a list of n integers (the array elements) Returns: list: A list of integers representing the result for each test case. results = [] for i in range(T): n, array = test_cases[i] found_negative = False max_ending_here = float('-inf') max_so_far = float('-inf') for x in array: if x < 0: found_negative = True max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) if not found_negative: results.append(-1) else: results.append(max_so_far) return results"},{"question":"def convert_to_minutes(time: str) -> int: Convert a time in the format of hh:mmAM or hh:mmPM into minutes past midnight. >>> convert_to_minutes(\\"12:00AM\\") == 0 >>> convert_to_minutes(\\"01:00AM\\") == 60 >>> convert_to_minutes(\\"12:00PM\\") == 720 >>> convert_to_minutes(\\"01:00PM\\") == 780 >>> convert_to_minutes(\\"11:59PM\\") == 1439 pass","solution":"def convert_to_minutes(time): Convert a time in the format of hh:mmAM or hh:mmPM into minutes past midnight. period = time[-2:] # \\"AM\\" or \\"PM\\" hours = int(time[:2]) minutes = int(time[3:5]) if period == \\"AM\\": if hours == 12: hours = 0 else: if hours != 12: hours += 12 return hours * 60 + minutes"},{"question":"from typing import List def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing integers, '+', '-', '*', '/', and parentheses. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string containing integers, '+', '-', '*', '/', and parentheses. def evaluate(tokens): stack = [] num = 0 sign = '+' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == '(': num = evaluate(tokens) if not token.isdigit() or not tokens: # end of token or end of expression if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] *= num elif sign == '/': stack[-1] = int(stack[-1] / num) # use int() for floor division sign = token num = 0 if token == ')': break return sum(stack) # preprocess expression into tokens tokens = [] num = '' for char in expression: if char.isdigit(): num += char else: if num: tokens.append(num) num = '' tokens.append(char) if num: tokens.append(num) return evaluate(tokens)"},{"question":"def visualize_bubble_sort(arr: List[int]) -> List[List[int]]: Performs bubble sort on the input list and visualizes the state of the list after each full pass. Parameters: arr (list): List of integers to sort. Returns: list of lists: Each sublist represents the state of the list after each full pass of the bubble sort. >>> visualize_bubble_sort([4, 3, 1, 2]) [[3, 1, 2, 4], [1, 2, 3, 4], [1, 2, 3, 4]] >>> visualize_bubble_sort([]) [] >>> visualize_bubble_sort([1]) [[1]] >>> visualize_bubble_sort([1, 2, 3, 4]) [[1, 2, 3, 4]] >>> visualize_bubble_sort([4, 3, 2, 1]) [[3, 2, 1, 4], [2, 1, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]","solution":"def visualize_bubble_sort(arr): Performs bubble sort on the input list and visualizes the state of the list after each full pass. Parameters: arr (list): List of integers to sort. Returns: list of lists: Each sublist represents the state of the list after each full pass of the bubble sort. n = len(arr) result = [] for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True result.append(arr[:]) if not swapped: break return result"},{"question":"from typing import List def calculate_mean(sequence: List[int]) -> float: Calculate the mean of a sequence of numbers. >>> calculate_mean([1, 2, 3, 4]) 2.5 >>> calculate_mean([2, 3, 4, 5]) 3.5 def calculate_std_dev(sequence: List[int], mean: float) -> float: Calculate the standard deviation of a sequence of numbers. >>> calculate_std_dev([1, 2, 3, 4], 2.5) 1.118033988749895 >>> calculate_std_dev([2, 3, 4, 5], 3.5) 1.118033988749895 def are_sequences_similar(n: int, sequence1: List[int], sequence2: List[int]) -> str: Determine if two sequences generated by random number generators are statistically similar by comparing their mean and standard deviation. The sequences are considered similar if the absolute difference of the means is at most 0.01 and the absolute difference of their standard deviations is at most 0.01. >>> are_sequences_similar(4, [1, 2, 3, 4], [2, 3, 4, 5]) 'Different' >>> are_sequences_similar(4, [1, 1, 1, 1], [1, 1, 1, 1]) 'Similar' >>> are_sequences_similar(4, [2, 2, 2, 2], [2, 2, 2, 2]) 'Similar' >>> are_sequences_similar(4, [1, 2, 3, 4], [1, 2, 3, 4]) 'Similar' # Unit tests def test_calculate_mean(): assert calculate_mean([1, 2, 3, 4]) == 2.5 assert calculate_mean([2, 3, 4, 5]) == 3.5 assert calculate_mean([-1, -2, -3, -4]) == -2.5 assert calculate_mean([0, 0, 0, 0]) == 0.0 def test_calculate_std_dev(): assert abs(calculate_std_dev([1, 2, 3, 4], 2.5) - 1.118033988749895) < 1e-9 assert abs(calculate_std_dev([2, 3, 4, 5], 3.5) - 1.118033988749895) < 1e-9 assert abs(calculate_std_dev([-1, -2, -3, -4], -2.5) - 1.118033988749895) < 1e-9 assert calculate_std_dev([0, 0, 0, 0], 0.0) == 0.0 def test_are_sequences_similar(): assert are_sequences_similar(4, [1, 2, 3, 4], [2, 3, 4, 5]) == \\"Different\\" assert are_sequences_similar(4, [1, 1, 1, 1], [1, 1, 1, 1]) == \\"Similar\\" assert are_sequences_similar(4, [2, 2, 2, 2], [2, 2, 2, 2]) == \\"Similar\\" assert are_sequences_similar(4, [1, 2, 3, 4], [1, 2, 3, 4]) == \\"Similar\\" if __name__ == \\"__main__\\": test_calculate_mean() test_calculate_std_dev() test_are_sequences_similar() print(\\"All tests passed.\\")","solution":"def calculate_mean(sequence): return sum(sequence) / len(sequence) def calculate_std_dev(sequence, mean): variance = sum((x - mean) ** 2 for x in sequence) / len(sequence) return variance ** 0.5 def are_sequences_similar(n, sequence1, sequence2): mean1 = calculate_mean(sequence1) mean2 = calculate_mean(sequence2) std_dev1 = calculate_std_dev(sequence1, mean1) std_dev2 = calculate_std_dev(sequence2, mean2) if abs(mean1 - mean2) <= 0.01 and abs(std_dev1 - std_dev2) <= 0.01: return \\"Similar\\" else: return \\"Different\\" # Example usage: n = 4 sequence1 = [1, 2, 3, 4] sequence2 = [2, 3, 4, 5] print(are_sequences_similar(n, sequence1, sequence2))"},{"question":"def can_assign_tables(n: int, m: int, constraints: List[List[int]]) -> str: Determines if it is possible to assign each attendee to a table such that all constraints are met. Parameters: - n (int): Number of attendees. - m (int): Number of tables. - constraints (list of list of int): List of constraints for each attendee. Returns: - str: \\"YES\\" if assignment is possible, otherwise \\"NO\\". pass from solution import can_assign_tables def test_example_1(): n = 3 m = 4 constraints = [ [1, 2], [2, 3], [4] ] assert can_assign_tables(n, m, constraints) == \\"YES\\" def test_example_2(): n = 2 m = 2 constraints = [ [1], [2] ] assert can_assign_tables(n, m, constraints) == \\"YES\\" def test_example_3(): n = 3 m = 3 constraints = [ [1], [2], [] ] assert can_assign_tables(n, m, constraints) == \\"NO\\" def test_case_all_attendees_with_multiple_choices(): n = 3 m = 3 constraints = [ [1, 2], [2, 3], [1, 3] ] assert can_assign_tables(n, m, constraints) == \\"YES\\" def test_case_last_attendee_with_no_choices(): n = 3 m = 3 constraints = [ [1, 2], [2, 3], [] ] assert can_assign_tables(n, m, constraints) == \\"NO\\" def test_case_multiple_constraints_identical_options(): n = 3 m = 1 constraints = [ [1], [1], [1] ] assert can_assign_tables(n, m, constraints) == \\"YES\\"","solution":"def can_assign_tables(n, m, constraints): Determines if it is possible to assign each attendee to a table such that all constraints are met. Parameters: - n (int): Number of attendees. - m (int): Number of tables. - constraints (list of list of int): List of constraints for each attendee. Returns: - str: \\"YES\\" if assignment is possible, otherwise \\"NO\\". # Check if any attendee has no possible tables for attendee in constraints: if not attendee: return \\"NO\\" return \\"YES\\""},{"question":"def reverse_string(s: str) -> str: Returns the reversed string of s. >>> reverse_string('hello world') 'dlrow olleh' >>> reverse_string('python') 'nohtyp' >>> reverse_string('12345') '54321' >>> reverse_string('') '' >>> reverse_string('a') 'a' >>> reverse_string(' A B ') ' B A '","solution":"def reverse_string(s): Returns the reversed string of s. return s[::-1]"},{"question":"def is_palindrome(number: int) -> bool: Checks if a given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(0) True >>> is_palindrome(-121) False pass def filter_palindromes(numbers: List[int]) -> List[int]: Returns a new list containing the integers that are palindromes. Parameters: - numbers: List of integers Returns: - List of integers that are palindromes >>> filter_palindromes([123, 121, 454, 32, 303]) [121, 454, 303] >>> filter_palindromes([10, 101, 20]) [101] >>> filter_palindromes([123, 456, 789]) [] >>> filter_palindromes([1, 2, 3, 4, 5, 6, 7, 8, 9]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> filter_palindromes([]) [] >>> filter_palindromes([-121, 121, -131, -454, 454]) [121, 454] >>> filter_palindromes([0, 10, 20, 30, 101]) [0, 101] pass","solution":"def is_palindrome(number): Checks if a given number is a palindrome. number_str = str(number) return number_str == number_str[::-1] def filter_palindromes(numbers): Returns a new list containing the integers that are palindromes. Parameters: - numbers: List of integers Returns: - List of integers that are palindromes return [number for number in numbers if is_palindrome(number)]"},{"question":"from typing import List, Tuple def shortest_path_in_maze(test_cases: List[Tuple[int, int, List[List[str]]]]) -> List[int]: Finds the shortest path from the top-left corner to the bottom-right corner in a maze. The maze is represented as a grid with '.' for open paths and '#' for blocked paths. Args: test_cases: A list of tuples, where each tuple contains the dimensions of the grid (N, M) and the grid itself as a list of lists of strings. Returns: A list of integers where each integer represents the length of the shortest path for each test case, or -1 if no such path exists. >>> test_cases = [ (4, 4, [ ['.', '.', '.', '#'], ['.', '#', '#', '.'], ['.', '.', '.', '.'], ['#', '.', '#', '.'] ]), (3, 3, [ ['.', '#', '.'], ['#', '.', '#'], ['.', '#', '.'] ]) ] >>> shortest_path_in_maze(test_cases) [7, -1] from solution import shortest_path_in_maze def test_shortest_path_in_maze_basic_cases(): test_cases = [ (4, 4, [ ['.', '.', '.', '#'], ['.', '#', '#', '.'], ['.', '.', '.', '.'], ['#', '.', '#', '.'] ]), (3, 3, [ ['.', '#', '.'], ['#', '.', '#'], ['.', '#', '.'] ]) ] expected_results = [7, -1] assert shortest_path_in_maze(test_cases) == expected_results def test_shortest_path_in_maze_single_path(): test_cases = [ (3, 3, [ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ]) ] expected_result = [5] assert shortest_path_in_maze(test_cases) == expected_result def test_shortest_path_in_maze_no_path(): test_cases = [ (3, 3, [ ['.', '#', '.'], ['#', '#', '#'], ['.', '#', '.'] ]) ] expected_result = [-1] assert shortest_path_in_maze(test_cases) == expected_result def test_shortest_path_in_maze_blocked_start_or_end(): test_cases = [ (3, 3, [ ['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ]), (3, 3, [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '#'] ]) ] expected_results = [-1, -1] assert shortest_path_in_maze(test_cases) == expected_results def test_shortest_path_in_maze_edge_cases(): test_cases = [ (2, 2, [ ['.', '.'], ['.', '.'] ]), (2, 2, [ ['.', '#'], ['#', '.'] ]) ] expected_results = [3, -1] assert shortest_path_in_maze(test_cases) == expected_results","solution":"from collections import deque def shortest_path_in_maze(test_cases): results = [] for n, m, grid in test_cases: result = bfs_shortest_path(n, m, grid) results.append(result) return results def bfs_shortest_path(n, m, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) end = (n - 1, m - 1) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 queue = deque([(start[0], start[1], 1)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List def two_sum_exists(arr: List[int], target: int) -> bool: Determine if there are two distinct elements in the array that sum up to the target value. Args: arr (List[int]): Array of integers. target (int): Target sum. Returns: bool: True if there are two distinct elements whose sum is equal to the target, False otherwise. Examples: >>> two_sum_exists([2, 7, 11, 15], 9) True >>> two_sum_exists([1, 2, 3, 4], 8) False >>> two_sum_exists([1, -2, 3, 6, 8], 4) True def test_two_sum_exists_example_1(): assert two_sum_exists([2, 7, 11, 15], 9) == True def test_two_sum_exists_example_2(): assert two_sum_exists([1, 2, 3, 4], 8) == False def test_two_sum_exists_example_3(): assert two_sum_exists([1, -2, 3, 6, 8], 4) == True def test_two_sum_exists_with_duplicates(): assert two_sum_exists([1, 3, 3, 3, 6], 6) == True assert two_sum_exists([1, 1, 1, 1], 2) == True def test_two_sum_exists_with_negative_numbers(): assert two_sum_exists([-5, -3, -1, -7], -10) == True assert two_sum_exists([-5, -3, -1, -7], 2) == False def test_two_sum_exists_with_large_numbers(): assert two_sum_exists([100000, -100000, 50000], 0) == True assert two_sum_exists([99999, 1, 2, 3], 100000) == True assert two_sum_exists([100000, 100000], 200000) == True assert two_sum_exists([100000, 100000], 100000) == False # Need two distinct elements def test_two_sum_exists_empty_array(): assert two_sum_exists([], 1) == False def test_two_sum_exists_single_element(): assert two_sum_exists([1000], 1000) == False assert two_sum_exists([1000], 2000) == False","solution":"from typing import List def two_sum_exists(arr: List[int], target: int) -> bool: seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def days_to_reach_max_height(T: int, test_cases: List[Tuple[int, int, int]]) -> List[Union[int, str]]: Determine the day on which each plant reaches its maximum height. Parameters: - T: Number of test cases - test_cases: List of tuples where each tuple contains three integers (H, G, L), representing the initial height, daily growth rate, and maximum height limit of the plant. Returns: - List of results for each test case where each result is either an integer representing the day on which the plant reaches its maximum height or \\"Infinity\\" if it never reaches the maximum height. >>> days_to_reach_max_height(3, [(10, 5, 50), (5, 0, 20), (15, 2, 15)]) == [8, 'Infinity', 0] >>> days_to_reach_max_height(2, [(1, 1, 1)]) == [0]","solution":"def days_to_reach_max_height(T, test_cases): results = [] for H, G, L in test_cases: if H >= L: results.append(0) elif G == 0: results.append('Infinity') else: days = (L - H + G - 1) // G # This ensures we use ceiling division results.append(days) return results"},{"question":"from typing import List, Tuple def polygonal_numbers(N: int, M: int) -> List[int]: Return the first M N-gonal numbers. >>> polygonal_numbers(3, 5) [1, 3, 6, 10, 15] >>> polygonal_numbers(4, 4) [1, 4, 9, 16] def generate_polygonal_numbers(test_cases: List[Tuple[int, int]]) -> List[List[int]]: Generate the first M N-gonal numbers for each test case. >>> generate_polygonal_numbers([(3, 5)]) [[1, 3, 6, 10, 15]] >>> generate_polygonal_numbers([(4, 4)]) [[1, 4, 9, 16]] # Unit tests def test_case_1(): assert generate_polygonal_numbers([(3, 5)]) == [[1, 3, 6, 10, 15]] def test_case_2(): assert generate_polygonal_numbers([(4, 4)]) == [[1, 4, 9, 16]] def test_case_3(): assert generate_polygonal_numbers([(5, 3)]) == [[1, 5, 12]] def test_case_4(): assert generate_polygonal_numbers([(6, 6)]) == [[1, 6, 15, 28, 45, 66]] def test_multiple_cases(): assert generate_polygonal_numbers([(3, 5), (4, 4)]) == [[1, 3, 6, 10, 15], [1, 4, 9, 16]] def test_case_with_boundary_values(): assert generate_polygonal_numbers([(3, 1), (20, 1)]) == [[1], [1]]","solution":"def polygonal_numbers(N, M): Return the first M N-gonal numbers. numbers = [] for k in range(1, M + 1): pn = (k * ((N - 2) * k - (N - 4))) // 2 numbers.append(pn) return numbers def generate_polygonal_numbers(test_cases): Generate the first M N-gonal numbers for each test case. results = [] for N, M in test_cases: results.append(polygonal_numbers(N, M)) return results"},{"question":"def restore_permutation(n: int, permutation: List[int]) -> List[int]: Restore the missing values in the permutation while maintaining the permutation property. Parameters: - n: int, length of the permutation - permutation: list of int, the permutation with some values replaced with 0 Returns: - list of int, the restored permutation >>> restore_permutation(5, [0, 2, 3, 0, 5]) [1, 2, 3, 4, 5] >>> restore_permutation(6, [0, 2, 0, 4, 0, 6]) [1, 2, 3, 4, 5, 6] >>> restore_permutation(4, [0, 0, 3, 0]) [1, 2, 3, 4] >>> restore_permutation(3, [0, 2, 1]) [3, 2, 1] >>> restore_permutation(1, [0]) [1]","solution":"def restore_permutation(n, permutation): Restore the missing values in the permutation. Parameters: - n: int, length of the permutation - permutation: list of int, the permutation with some values replaced with 0 Returns: - list of int, the restored permutation # Determine which numbers are missing missing_numbers = set(range(1, n+1)) - set(permutation) missing_numbers = sorted(list(missing_numbers)) restored_permutation = [] for value in permutation: if value == 0: restored_permutation.append(missing_numbers.pop(0)) else: restored_permutation.append(value) return restored_permutation"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the maximum sum of a contiguous subarray within the given list of integers. Parameters: nums (list): A list of integers. Returns: int: The maximum sum of any contiguous subarray. >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6","solution":"def max_subarray_sum(nums): Finds the maximum sum of a contiguous subarray within the given list of integers. Parameters: nums (list): A list of integers. Returns: int: The maximum sum of any contiguous subarray. if not nums: return 0 max_sum = cur_sum = nums[0] for num in nums[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum"},{"question":"from typing import List def canPartition(nums: List[int]) -> bool: Determines if it is possible to partition the array into two subsets such that the sum of elements in both subsets is equal. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False >>> canPartition([2, 2, 3, 5]) False >>> canPartition([1]) False >>> canPartition([1, 1]) True >>> canPartition([0, 0, 0, 0]) True >>> canPartition([100, 100, 100, 100, 100, 100, 100, 100, 100, 100]) True >>> canPartition([1, 2, 5, 7, 13, 19]) False","solution":"from typing import List def canPartition(nums: List[int]) -> bool: Determines if it is possible to partition the array into two subsets such that the sum of elements in both subsets is equal. :param nums: List of integers :return: Boolean indicating whether the array can be partitioned total_sum = sum(nums) # If the total sum is odd, it can't be partitioned into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 # Initialize a dp array to store if a sum is achievable dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for j in range(target_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target_sum]"},{"question":"def longestCommonSpan(nums: List[int]) -> int: Finds the length of the longest subarray with an equal number of 0s and 1s. :param nums: List of integers (only 0s and 1s) :return: Length of the longest subarray with equal number of 0s and 1s. >>> longestCommonSpan([0, 1, 0, 1, 0, 1]) 6 >>> longestCommonSpan([0, 0, 1, 0, 0, 1, 1]) 6 >>> longestCommonSpan([0, 0, 1, 1, 0]) 4","solution":"def longestCommonSpan(nums): Finds the length of the longest subarray with an equal number of 0s and 1s. :param nums: List of integers (only 0s and 1s) :return: Length of the longest subarray with equal number of 0s and 1s. # Initialize an empty dictionary to store the first occurrence of each cumulative sum. sum_indices = {} # Initialize variables to track the maximum length and the cumulative sum. max_length = 0 cumulative_sum = 0 for i, num in enumerate(nums): # Replace 0 with -1 to use the cumulative sum approach cumulative_sum += -1 if num == 0 else 1 # If cumulative_sum is 0, then from the start to the current index, number of 0s and 1s are equal if cumulative_sum == 0: max_length = i + 1 # If cumulative_sum already exists in the dictionary, update the max_length if cumulative_sum in sum_indices: max_length = max(max_length, i - sum_indices[cumulative_sum]) else: # Store the first occurrence of the cumulative_sum sum_indices[cumulative_sum] = i return max_length"},{"question":"from typing import List, Tuple def max_price_fluctuations(n: int, m: int, price_changes: List[List[int]]) -> Tuple[int, int]: Calculates the highest price increase and highest price decrease experienced by any product during the promotional event. Parameters: n (int): Number of products. m (int): Number of time intervals. price_changes (list of list of int): A list where each sublist represents the price changes of a product over m time intervals. Returns: tuple: A tuple of two integers: the highest price increase and the highest price decrease. pass # Unit tests def test_example_case(): n = 4 m = 3 price_changes = [ [5, -3, 4], [-2, 6, -3], [3, 3, -2], [0, -4, 7] ] assert max_price_fluctuations(n, m, price_changes) == (7, -4) def test_single_product_increase(): n = 1 m = 3 price_changes = [ [1, 1, 1] ] assert max_price_fluctuations(n, m, price_changes) == (3, 0) def test_single_product_decrease(): n = 1 m = 3 price_changes = [ [-1, -1, -1] ] assert max_price_fluctuations(n, m, price_changes) == (0, -3) def test_single_product_mixed(): n = 1 m = 4 price_changes = [ [1, -2, 3, -1] ] assert max_price_fluctuations(n, m, price_changes) == (3, -1) def test_multiple_products(): n = 2 m = 4 price_changes = [ [2, 3, -5, 1], [-3, 2, 4, -2] ] assert max_price_fluctuations(n, m, price_changes) == (6, -3) def test_all_zero_changes(): n = 3 m = 3 price_changes = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_price_fluctuations(n, m, price_changes) == (0, 0)","solution":"def max_price_fluctuations(n, m, price_changes): Calculates the highest price increase and highest price decrease experienced by any product during the promotional event. Parameters: n (int): Number of products. m (int): Number of time intervals. price_changes (list of list of int): A list where each sublist represents the price changes of a product over m time intervals. Returns: tuple: A tuple of two integers: the highest price increase and the highest price decrease. max_increase = float('-inf') max_decrease = float('inf') for changes in price_changes: current_increase = 0 current_sum = 0 current_min = 0 for change in changes: current_sum += change if current_sum - current_min > current_increase: current_increase = current_sum - current_min if current_sum < current_min: current_min = current_sum max_increase = max(max_increase, current_increase) max_decrease = min(max_decrease, current_min) return max_increase, max_decrease # Example usage: # n = 4 # m = 3 # price_changes = [ # [5, -3, 4], # [-2, 6, -3], # [3, 3, -2], # [0, -4, 7] # ] # print(max_price_fluctuations(n, m, price_changes)) # Output: (7, -4)"},{"question":"def validate_sudoku(board): Write a function to validate a potentially solved Sudoku puzzle. A valid Sudoku solution must satisfy the following criteria: 1. Each of the digits from 1 to 9 must appear exactly once in each row. 2. Each of the digits from 1 to 9 must appear exactly once in each column. 3. Each of the digits from 1 to 9 must appear exactly once in each of the nine 3x3 sub-grids of the grid. >>> valid_board = [ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ] >>> validate_sudoku(valid_board) True >>> invalid_board = [ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 7, 7, 9] # Invalid: number 7 appears twice in the last sub-grid ... ] >>> validate_sudoku(invalid_board) False","solution":"def validate_sudoku(board): def is_valid_group(group): return sorted(group) == list(range(1, 10)) # Check rows for row in board: if not is_valid_group(row): return False # Check columns for col in range(9): column = [board[row][col] for row in range(9)] if not is_valid_group(column): return False # Check 3x3 sub-grids for box_row in range(0, 9, 3): for box_col in range(0, 9, 3): sub_grid = [ board[r][c] for r in range(box_row, box_row + 3) for c in range(box_col, box_col + 3) ] if not is_valid_group(sub_grid): return False return True"},{"question":"def longest_subarray_rainfall(rainfall: List[int], threshold: int) -> int: Returns the length of the longest continuous subarray where the sum of the rainfall amounts is less than or equal to the given threshold. >>> longest_subarray_rainfall([1, 2, 3, 1], 10) == 4 >>> longest_subarray_rainfall([10, 20, 30], 5) == 0 >>> longest_subarray_rainfall([4, 2, 1, 6, 5], 8) == 3 >>> longest_subarray_rainfall([1, 2, 3, 4, 5], 5) == 2 >>> longest_subarray_rainfall([], 5) == 0 >>> longest_subarray_rainfall([1, 2, 3], 0) == 0 >>> longest_subarray_rainfall([1, 2, 3], 2) == 1 >>> longest_subarray_rainfall([1, 2, 3], 1) == 1 >>> longest_subarray_rainfall([3, 1, 2, 4, 1], 7) == 3 pass","solution":"def longest_subarray_rainfall(rainfall, threshold): Returns the length of the longest continuous subarray where the sum of the rainfall amounts is less than or equal to the given threshold. n = len(rainfall) max_len = 0 current_sum = 0 left = 0 for right in range(n): current_sum += rainfall[right] while current_sum > threshold and left <= right: current_sum -= rainfall[left] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def trap_rainwater(nums: List[int]) -> int: Calculate the maximum amount of rainwater that can be trapped after raining. >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([4,2,0,3,2,5]) 9 >>> trap_rainwater([2,0,2]) 2 >>> trap_rainwater([]) 0 >>> trap_rainwater([1,2,3,4,5]) 0 >>> trap_rainwater([5,5,5,5,5]) 0 >>> trap_rainwater([5,0,5]) 5","solution":"def trap_rainwater(nums): if not nums: return 0 n = len(nums) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = nums[0] for i in range(1, n): left_max[i] = max(left_max[i-1], nums[i]) right_max[n-1] = nums[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], nums[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - nums[i] return water_trapped"},{"question":"def getSortedSubstrings(s: str) -> List[str]: Generate all unique substrings of the input string s and return them sorted in lexicographical order. >>> getSortedSubstrings('abc') ['a', 'ab', 'abc', 'b', 'bc', 'c'] >>> getSortedSubstrings('banana') ['a', 'an', 'ana', 'anan', 'anana', 'b', 'ba', 'ban', 'bana', 'banan', 'banana', 'n', 'na', 'nan', 'nana']","solution":"def getSortedSubstrings(s): Generate all unique substrings of the input string s and return them sorted in lexicographical order. Parameters: s (str): The input string Returns: List[str]: A list of unique substrings sorted in lexicographical order substrings = set() length = len(s) for i in range(length): for j in range(i + 1, length + 1): substrings.add(s[i:j]) return sorted(substrings)"},{"question":"def did_alice_win(coin1: str, coin2: str) -> bool: Returns True if Alice wins the game, i.e., one coin is heads (H) and the other is tails (T). Otherwise, returns False. :param str coin1: Outcome of the first coin flip ('H' or 'T'). :param str coin2: Outcome of the second coin flip ('H' or 'T'). :return: Whether Alice wins the game. :rtype: bool >>> did_alice_win('H', 'T') True >>> did_alice_win('T', 'H') True >>> did_alice_win('H', 'H') False >>> did_alice_win('T', 'T') False","solution":"def did_alice_win(coin1, coin2): Returns True if Alice wins the game, i.e., one coin is heads (H) and the other is tails (T). Otherwise, returns False. :param str coin1: Outcome of the first coin flip ('H' or 'T'). :param str coin2: Outcome of the second coin flip ('H' or 'T'). :return: Whether Alice wins the game. :rtype: bool return (coin1 == 'H' and coin2 == 'T') or (coin1 == 'T' and coin2 == 'H')"},{"question":"def rotate_array(nums: list[int], k: int) -> list[int]: Given a list of integers \`nums\` and an integer \`k\`, rotate the list to the right by \`k\` steps. >>> rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5]","solution":"def rotate_array(nums: list[int], k: int) -> list[int]: Rotates the array to the right by k steps. if not nums or k <= 0: return nums n = len(nums) k = k % n # In case k is greater than the length of the list return nums[-k:] + nums[:-k]"},{"question":"def update_inventory(inventory: List[dict], title: str, adjustment: int) -> List[dict]: Updates the inventory of books by either adding a new book, updating an existing book's quantity, or removing a book if its quantity drops to zero or below. :param inventory: List of dictionaries representing the inventory. :param title: Title of the book to add or update. :param adjustment: Number of copies to add or remove. :return: Updated inventory list. >>> inventory = [ ... {'title': \\"1984\\", 'author': \\"George Orwell\\", 'quantity': 5}, ... {'title': \\"Brave New World\\", 'author': \\"Aldous Huxley\\", 'quantity': 3} ... ] >>> update_inventory(inventory, \\"1984\\", -2) [{'title': \\"1984\\", 'author': \\"George Orwell\\", 'quantity': 3}, {'title': \\"Brave New World\\", 'author': \\"Aldous Huxley\\", 'quantity': 3}] >>> update_inventory(inventory, \\"Fahrenheit 451\\", 4) [{'title': \\"1984\\", 'author': \\"George Orwell\\", 'quantity': 3}, {'title': \\"Brave New World\\", 'author': \\"Aldous Huxley\\", 'quantity': 3}, {'title': \\"Fahrenheit 451\\", 'author': \\"Unknown\\", 'quantity': 4}] >>> update_inventory(inventory, \\"Brave New World\\", -3) [{'title': \\"1984\\", 'author': \\"George Orwell\\", 'quantity': 3}, {'title': \\"Fahrenheit 451\\", 'author': \\"Unknown\\", 'quantity': 4}]","solution":"def update_inventory(inventory, title, adjustment): Updates the inventory of books by either adding a new book, updating an existing book's quantity, or removing a book if its quantity drops to zero or below. :param inventory: List of dictionaries representing the inventory. :param title: Title of the book to add or update. :param adjustment: Number of copies to add or remove. :return: Updated inventory list. for book in inventory: if book['title'] == title: book['quantity'] += adjustment if book['quantity'] <= 0: inventory.remove(book) return inventory if adjustment > 0: inventory.append({'title': title, 'author': \\"Unknown\\", 'quantity': adjustment}) return inventory"},{"question":"def longest_arith_seq_length(lst: List[int]) -> int: Determine the length of the longest subsequence that forms an arithmetic progression. >>> longest_arith_seq_length([1, 7, 10, 13, 14, 19]) == 4 >>> longest_arith_seq_length([1, 3, 5, 7, 9]) == 5 >>> longest_arith_seq_length([1, 4, 7, 10, 13, 16, 19]) == 7 >>> longest_arith_seq_length([]) == 0 >>> longest_arith_seq_length([5]) == 1 >>> longest_arith_seq_length([5, 10]) == 2 >>> longest_arith_seq_length([1, 2, 4, 8, 16]) == 2 >>> longest_arith_seq_length([100, 300, 500, 700, 1100]) == 4 >>> longest_arith_seq_length([-1, -4, -7, -10, -13]) == 5 >>> longest_arith_seq_length([10, 7, 1, 8, 5, 4, 2, -1]) == 4","solution":"def longest_arith_seq_length(lst): if not lst: return 0 n = len(lst) if n == 1: return 1 # Dictionary to store the length of the longest arithmetic subsequence dp = [{} for _ in range(n)] longest = 1 for i in range(n): for j in range(i): diff = lst[i] - lst[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest = max(longest, dp[i][diff]) return longest"},{"question":"def sort_books(books): This function takes a list of tuples containing book titles and author names and returns a list of tuples sorted by book title, and then by author name if titles are identical. Parameters: books (list of tuple): List of tuples containing (title, author) Returns: list of tuple: Sorted list of books by title and then by author Examples: >>> books = [(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), (\\"Moby Dick\\", \\"Herman Melville\\"), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\"), (\\"Moby Dick\\", \\"Anonymous\\")] >>> sort_books(books) [(\\"Moby Dick\\", \\"Anonymous\\"), (\\"Moby Dick\\", \\"Herman Melville\\"), (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\")] >>> books = [] >>> sort_books(books) []","solution":"def sort_books(books): This function takes a list of tuples containing book titles and author names and returns a list of tuples sorted by book title, and then by author name if titles are identical. Parameters: books (list of tuple): List of tuples containing (title, author) Returns: list of tuple: Sorted list of books by title and then by author return sorted(books, key=lambda x: (x[0], x[1]))"},{"question":"def calculate_positions(initials, directions, speeds, t): Given initial positions, directions, speeds, and time duration, calculate the final positions of celestial bodies. initials: List of tuples (initial positions) e.g. [(x1, y1), (x2, y2)] directions: List of tuples (direction vectors) e.g. [(dx1, dy1), (dx2, dy2)] speeds: List of integers (speeds) e.g. [v1, v2] t: Integer (time duration) return: List of tuples (final positions) e.g. [(x1', y1'), (x2', y2')] >>> calculate_positions([(0, 0), (1, 1)], [(1, 0), (0, 1)], [1, 2], 3) [(3, 0), (1, 7)] >>> calculate_positions([(0, 0), (1, 1)], [(1, 1), (-1, -1)], [1, 1], 1) [(1, 1), (0, 0)]","solution":"def calculate_positions(initials, directions, speeds, t): Given initial positions, directions, speeds, and time duration, calculate the final positions of celestial bodies. initials: List of tuples (initial positions) e.g. [(x1, y1), (x2, y2)] directions: List of tuples (direction vectors) e.g. [(dx1, dy1), (dx2, dy2)] speeds: List of integers (speeds) e.g. [v1, v2] t: Integer (time duration) return: List of tuples (final positions) e.g. [(x1', y1'), (x2', y2')] final_positions = [] for i in range(len(initials)): xi, yi = initials[i] dxi, dyi = directions[i] vi = speeds[i] xf = xi + dxi * vi * t yf = yi + dyi * vi * t final_positions.append((xf, yf)) return final_positions"},{"question":"def count_confirmed_attendees(invitations: dict) -> int: Returns the total number of confirmed attendees based on their RSVP status. Parameters: invitations (dict): A dictionary where keys are participant names and values are their RSVP status. Returns: int: The total number of participants who RSVP'd \\"Yes\\". >>> count_confirmed_attendees({\\"Alice\\": \\"Yes\\", \\"Bob\\": \\"No\\", \\"Charlie\\": \\"Maybe\\", \\"David\\": \\"Yes\\"}) == 2 >>> count_confirmed_attendees({\\"Alice\\": \\"No\\", \\"Bob\\": \\"No\\", \\"Charlie\\": \\"Maybe\\"}) == 0 >>> count_confirmed_attendees({\\"Alice\\": \\"Yes\\", \\"Bob\\": \\"Yes\\"}) == 2 >>> count_confirmed_attendees({\\"Alice\\": \\"Maybe\\", \\"Bob\\": \\"Maybe\\"}) == 0 >>> count_confirmed_attendees({\\"Alice\\": \\"Yes\\"}) == 1 >>> count_confirmed_attendees({}) == 0","solution":"def count_confirmed_attendees(invitations): Returns the total number of confirmed attendees based on their RSVP status. Parameters: invitations (dict): A dictionary where keys are participant names and values are their RSVP status. Returns: int: The total number of participants who RSVP'd \\"Yes\\". return sum(1 for rsvp in invitations.values() if rsvp == \\"Yes\\")"},{"question":"class Library: A class to represent a library with book borrowing functionality. Methods ------- __init__(books: List[int]) Initializes the library with a list of book ids. borrow_book(book_id: int) -> bool: Allows a user to borrow a book. Returns true if the book is successfully borrowed (i.e., it was available), and false otherwise. return_book(book_id: int) -> bool: Allows a user to return a book. Returns true if the book is successfully returned (i.e., it was borrowed), and false otherwise. check_availability(book_id: int) -> bool: Returns true if the specified book is available, false otherwise. def __init__(self, books): Initializes the library with a list of book ids. pass def borrow_book(self, book_id): Allows a user to borrow a book. Returns true if the book is successfully borrowed (i.e., it was available), and false otherwise. pass def return_book(self, book_id): Allows a user to return a book. Returns true if the book is successfully returned (i.e., it was borrowed), and false otherwise. pass def check_availability(self, book_id): Returns true if the specified book is available, false otherwise. pass # Example usage: library = Library([101, 102, 103, 104, 105]) # Borrowing books print(library.borrow_book(101)) # Output: True (Book 101 is now borrowed) print(library.borrow_book(101)) # Output: False (Book 101 is already borrowed) # Checking availability print(library.check_availability(101)) # Output: False (Book 101 is borrowed) print(library.check_availability(102)) # Output: True (Book 102 is available) # Returning books print(library.return_book(101)) # Output: True (Book 101 is now returned) print(library.return_book(101)) # Output: False (Book 101 was already returned) # Final availability check print(library.check_availability(101)) # Output: True (Book 101 is available again) def test_borrow_book(): library = Library([101, 102, 103]) assert library.borrow_book(101) == True # Successful borrow assert library.borrow_book(101) == False # Book already borrowed def test_return_book(): library = Library([101, 102, 103]) assert library.borrow_book(101) == True # Successful borrow assert library.return_book(101) == True # Successful return assert library.return_book(101) == False # Book was already returned def test_check_availability(): library = Library([101, 102, 103]) assert library.check_availability(101) == True # Book is available library.borrow_book(101) assert library.check_availability(101) == False # Book is not available anymore library.return_book(101) assert library.check_availability(101) == True # Book is available again def test_borrow_nonexistent_book(): library = Library([101, 102, 103]) assert library.borrow_book(104) == False # Trying to borrow a book not in the library (by assumption) def test_return_nonexistent_book(): library = Library([101, 102, 103]) assert library.return_book(104) == False # Trying to return a book not in the library (by assumption)","solution":"class Library: def __init__(self, books): Initializes the library with a list of book ids. self.books_status = {book_id: True for book_id in books} # True indicates the book is available def borrowBook(self, bookId): Allows a user to borrow a book. Returns True if the book is successfully borrowed (i.e., it was available), and False otherwise. if self.books_status.get(bookId, False): # Check if the book is available self.books_status[bookId] = False return True return False def returnBook(self, bookId): Allows a user to return a book. Returns True if the book is successfully returned (i.e., it was borrowed), and False otherwise. if bookId in self.books_status and not self.books_status[bookId]: # Check if the book was borrowed self.books_status[bookId] = True return True return False def checkAvailability(self, bookId): Returns True if the specified book is available, False otherwise. return self.books_status.get(bookId, False)"},{"question":"def even_digit_numbers(nums: List[int]) -> List[int]: Returns a new list with integers from the input list that have an even number of digits. Args: nums (list of int): List of integers Returns: list of int: List of integers with an even number of digits Examples: >>> even_digit_numbers([12, 345, 2, 6, 7896]) [12, 7896] >>> even_digit_numbers([1234, 56, 789]) [1234, 56]","solution":"def even_digit_numbers(nums): Returns a new list with integers from the input list that have an even number of digits. Args: nums (list of int): List of integers Returns: list of int: List of integers with an even number of digits return [num for num in nums if len(str(abs(num))) % 2 == 0]"},{"question":"def process_transactions(transactions): Process a series of transactions and determine the final balance and overdraft status. Parameters: transactions (list of int): List of integer transactions (positive for deposit, negative for withdrawal) Returns: tuple: Final balance and \\"YES/NO\\" indicating if there was an overdraft # Your code here def main(input_lines): Main function to process multiple test cases of transactions from input lines. Parameters: input_lines (List[str]): List of input strings, with the first being the number of test cases and the subsequent lines being the transactions Returns: List[str]: List of output results for each test case, formatted as \\"balance YES/NO\\" # Your code here # Unit tests def test_process_transactions(): assert process_transactions([500, -300, 200, -1000, 300]) == (-300, \\"YES\\") assert process_transactions([100, 200, -50, -25, 75]) == (300, \\"NO\\") assert process_transactions([-200, 100, -100]) == (-200, \\"YES\\") assert process_transactions([1000, -2000, 1000]) == (0, \\"YES\\") def test_main(): input_lines = [ \\"3\\", \\"500 -300 200 -1000 300\\", \\"100 200 -50 -25 75\\", \\"-200 100 -100\\" ] expected_output = [ \\"-300 YES\\", \\"300 NO\\", \\"-200 YES\\" ] assert main(input_lines) == expected_output input_lines = [ \\"2\\", \\"1000 -500 -600 100\\", \\"500 -200 200 0\\" ] expected_output = [ \\"0 YES\\", \\"500 NO\\" ] assert main(input_lines) == expected_output def test_edge_cases(): assert process_transactions([1, -2, 1]) == (0, \\"YES\\") assert process_transactions([-1, 2]) == (1, \\"YES\\") input_lines = [ \\"1\\", \\"-1000000 1000000\\" ] expected_output = [ \\"0 YES\\" ] assert main(input_lines) == expected_output","solution":"def process_transactions(transactions): Process a series of transactions and determine the final balance and overdraft status. Parameters: transactions (list of int): List of integer transactions (positive for deposit, negative for withdrawal) Returns: tuple: Final balance and \\"YES/NO\\" indicating if there was an overdraft balance = 0 overdraft_occurred = False for transaction in transactions: balance += transaction if balance < 0: overdraft_occurred = True return (balance, \\"YES\\" if overdraft_occurred else \\"NO\\") def main(input_lines): Main function to process multiple test cases of transactions from input lines. Parameters: input_lines (List[str]): List of input strings, with the first being the number of test cases and the subsequent lines being the transactions Returns: List[str]: List of output results for each test case, formatted as \\"balance YES/NO\\" T = int(input_lines[0]) results = [] for i in range(1, T + 1): transactions = list(map(int, input_lines[i].split())) balance, overdraft_status = process_transactions(transactions) results.append(f\\"{balance} {overdraft_status}\\") return results"},{"question":"from typing import Dict import re from collections import defaultdict def word_frequency(text: str) -> Dict[str, int]: Write a function that receives a string containing sentence(s) and returns a dictionary, where the keys are the words in the string and the values are the number of times each word appears. The function should ignore punctuation and be case-insensitive. Examples: >>> word_frequency(\\"Hello, hello! How are you?\\") {\\"hello\\": 2, \\"how\\": 1, \\"are\\": 1, \\"you\\": 1} >>> word_frequency(\\"This is a test. This test is only a test.\\") {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1} def test_word_frequency_basic(): result = word_frequency(\\"Hello, hello! How are you?\\") expected = {\\"hello\\": 2, \\"how\\": 1, \\"are\\": 1, \\"you\\": 1} assert result == expected def test_word_frequency_with_periods(): result = word_frequency(\\"This is a test. This test is only a test.\\") expected = {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1} assert result == expected def test_word_frequency_mixed_case(): result = word_frequency(\\"Hello HELLO Hello\\") expected = {\\"hello\\": 3} assert result == expected def test_word_frequency_no_punctuation(): result = word_frequency(\\"hello how are you\\") expected = {\\"hello\\": 1, \\"how\\": 1, \\"are\\": 1, \\"you\\": 1} assert result == expected def test_word_frequency_empty_string(): result = word_frequency(\\"\\") expected = {} assert result == expected def test_word_frequency_various_punctuations(): result = word_frequency(\\"Hello! Hello? Hello.\\") expected = {\\"hello\\": 3} assert result == expected","solution":"import re from collections import defaultdict def word_frequency(text): Returns a dictionary where the keys are the words in the string and the values are the number of times each word appears. # Remove punctuation and make lowercase text = re.sub(r'[^ws]', '', text).lower() words = text.split() frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"from typing import List def prime_factors_descending(n: int) -> List[int]: Write a function that takes an integer as input and returns a list of its prime factors sorted in descending order. A prime factor is a factor of a number that is a prime number. Parameters: n (int): the integer to find prime factors for. Returns: List[int]: A list of prime factors sorted in descending order. Examples: >>> prime_factors_descending(28) [7, 2, 2] >>> prime_factors_descending(100) [5, 5, 2, 2] pass from solution import prime_factors_descending def test_prime_factors_of_28(): assert prime_factors_descending(28) == [7, 2, 2] def test_prime_factors_of_100(): assert prime_factors_descending(100) == [5, 5, 2, 2] def test_prime_factors_of_37(): # 37 is a prime number, hence should return [37] itself. assert prime_factors_descending(37) == [37] def test_prime_factors_of_1_000_000(): # 1_000_000 = 2^6 * 5^6 = [5, 5, 5, 5, 5, 5, 2, 2, 2, 2, 2, 2] assert prime_factors_descending(1_000_000) == [5, 5, 5, 5, 5, 5, 2, 2, 2, 2, 2, 2] def test_prime_factors_of_2(): assert prime_factors_descending(2) == [2] def test_prime_factors_of_997_3_2(): # 997*3*2 = [997, 3, 2] assert prime_factors_descending(997*3*2) == [997, 3, 2] def test_prime_factors_of_large_composite_number(): # 2310 = 2 * 3 * 5 * 7 * 11 = [11, 7, 5, 3, 2] assert prime_factors_descending(2310) == [11, 7, 5, 3, 2]","solution":"def prime_factors_descending(n): Returns a list of prime factors of n sorted in descending order. Parameters: n (int): The integer to find prime factors for. Returns: List[int]: A list of prime factors sorted in descending order. i = 2 factors = [] while i * i <= n: while n % i == 0: factors.append(i) n //= i i += 1 if n > 1: factors.append(n) factors.sort(reverse=True) return factors"},{"question":"def sum_of_numbers(s: str) -> int: Returns the sum of all numbers in the given string. The string contains both lowercase words and integer numbers, which can be positive or negative. >>> sum_of_numbers(\\"abc123xyz\\") 123 >>> sum_of_numbers(\\"a1b2c3\\") 6 >>> sum_of_numbers(\\"aa11bb22cc-33\\") 0","solution":"import re def sum_of_numbers(s): Returns the sum of all numbers in the given string. The string contains both lowercase words and integer numbers, which can be positive or negative. # Find all numbers in the string, including negative ones numbers = re.findall(r'-?d+', s) # Convert the numbers to integers and return their sum return sum(int(num) for num in numbers)"},{"question":"def convert_to_military_time(time_str: str) -> str: Converts a 12-hour AM/PM time format string to a 24-hour military time format string. Args: time_str (str): A string representing time in 12-hour AM/PM format (e.g., \\"07:05:45PM\\") Returns: str: The corresponding time in 24-hour military time format (e.g., \\"19:05:45\\") >>> convert_to_military_time(\\"07:05:45PM\\") '19:05:45' >>> convert_to_military_time(\\"12:00:00AM\\") '00:00:00' >>> convert_to_military_time(\\"12:00:00PM\\") '12:00:00' >>> convert_to_military_time(\\"01:00:00AM\\") '01:00:00' >>> convert_to_military_time(\\"11:59:59PM\\") '23:59:59' >>> convert_to_military_time(\\"06:30:00AM\\") '06:30:00' >>> convert_to_military_time(\\"06:30:00PM\\") '18:30:00'","solution":"def convert_to_military_time(time_str): Converts a 12-hour AM/PM time format string to a 24-hour military time format string. Args: time_str (str): A string representing time in 12-hour AM/PM format (e.g., \\"07:05:45PM\\") Returns: str: The corresponding time in 24-hour military time format (e.g., \\"19:05:45\\") period = time_str[-2:] hour = int(time_str[:2]) minute_seconds = time_str[2:-2] if period == \\"AM\\": if hour == 12: hour = 0 return \\"{:02d}{}\\".format(hour, minute_seconds) else: # PM if hour != 12: hour += 12 return \\"{:02d}{}\\".format(hour, minute_seconds)"},{"question":"def max_even_product(test_cases): You are given an array of integers, and you need to determine the maximum possible product of any non-empty subset of its elements such that the product is even. If no such subset exists, return -1. Args: test_cases: List of lists, each containing the integers of a test case. Returns: List of integers, each representing the maximum possible even product for the corresponding test case, or -1 if no such product exists. >>> max_even_product([[1, 3, 5]]) [-1] >>> max_even_product([[2, 3, 5]]) [30] >>> max_even_product([[2, 4, 5]]) [40] >>> max_even_product([[2, 4, 6]]) [48] >>> max_even_product([[0, 1, 3, 5]]) [0]","solution":"def max_even_product(test_cases): results = [] for arr in test_cases: even_numbers = [num for num in arr if num % 2 == 0] if not even_numbers: results.append(-1) else: product = 1 for num in arr: product *= num results.append(product) return results"},{"question":"def max_non_overlapping_meetings(t, test_cases): Determines the maximum number of non-overlapping meetings for multiple test cases. Args: t (int): The number of test cases. test_cases (list): List of tuples where each tuple contains a list of start and end times for meetings. Returns: list: A list of integers where each integer represents the maximum number of non-overlapping meetings for the corresponding test case. pass def test_case_1(): t = 2 test_cases = [ [(1, 2), (3, 4), (0, 6)], [(1, 3), (2, 4), (3, 5), (7, 8)] ] expected = [2, 3] assert max_non_overlapping_meetings(t, test_cases) == expected def test_case_single_meeting(): t = 1 test_cases = [[(1, 2)]] expected = [1] assert max_non_overlapping_meetings(t, test_cases) == expected def test_case_no_meeting(): t = 1 test_cases = [[]] expected = [0] assert max_non_overlapping_meetings(t, test_cases) == expected def test_case_all_meetings_overlap(): t = 1 test_cases = [[(1, 5), (2, 6), (3, 7), (4, 8)]] expected = [1] assert max_non_overlapping_meetings(t, test_cases) == expected def test_case_non_overlapping_meetings(): t = 1 test_cases = [[(1, 2), (2, 3), (3, 4), (4, 5)]] expected = [4] assert max_non_overlapping_meetings(t, test_cases) == expected def test_case_mixed_lengths(): t = 1 test_cases = [[(1, 10), (2, 3), (4, 5), (6, 7)]] expected = [3] assert max_non_overlapping_meetings(t, test_cases) == expected","solution":"def max_non_overlapping_meetings(t, test_cases): Determines the maximum number of non-overlapping meetings for multiple test cases. Args: t (int): The number of test cases. test_cases (list): List of tuples where each tuple contains a list of start and end times for meetings. Returns: list: A list of integers where each integer represents the maximum number of non-overlapping meetings for the corresponding test case. result = [] for case in test_cases: meetings = sorted(case, key=lambda x: x[1]) end_time = 0 count = 0 for s, e in meetings: if s >= end_time: count += 1 end_time = e result.append(count) return result"},{"question":"def zip_lists(list1, list2): Given two lists of equal length, returns a dictionary where the elements of the first list are the keys and the elements of the second list are the corresponding values. >>> zip_lists(['a', 'b', 'c'], [1, 2, 3]) {'a': 1, 'b': 2, 'c': 3} >>> zip_lists([1, 2, 3], [4, 5, 6]) {1: 4, 2: 5, 3: 6} >>> zip_lists(['key1', 'key2'], ['value1', 'value2']) {'key1': 'value1', 'key2': 'value2'} >>> zip_lists(['', ''], ['val1', 'val2']) {'': 'val2'} >>> zip_lists(['key1', 2, (3, 4)], ['val1', 'val2', 'val3']) {'key1': 'val1', 2: 'val2', (3, 4): 'val3'}","solution":"def zip_lists(list1, list2): Returns a dictionary where the elements of the first list are the keys and the elements of the second list are the corresponding values. return dict(zip(list1, list2))"},{"question":"def longest_unique_substring_length(s: str) -> int: Determine the length of the longest substring that contains only unique characters. >>> longest_unique_substring_length(\\"abcabcbb\\") == 3 >>> longest_unique_substring_length(\\"bbbbb\\") == 1 >>> longest_unique_substring_length(\\"pwwkew\\") == 3 pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases to find the longest unique substring length for each. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) == [3, 1, 3] pass","solution":"def longest_unique_substring_length(s): Determine the length of the longest substring that contains only unique characters. n = len(s) char_index = {} max_len = 0 start = 0 for i in range(n): if s[i] in char_index and start <= char_index[s[i]]: start = char_index[s[i]] + 1 else: max_len = max(max_len, i - start + 1) char_index[s[i]] = i return max_len def process_test_cases(t, test_cases): Process multiple test cases. t: number of test cases. test_cases: list of test case strings. results = [] for case in test_cases: results.append(longest_unique_substring_length(case)) return results"},{"question":"def is_zebra_array(arr): Determines if the array is a zebra array. Parameters: arr (list): A list of integers. Returns: bool: True if the array is a zebra array, False otherwise. >>> is_zebra_array([3, 3, 1, 1, 2, 2]) True >>> is_zebra_array([3, 3, 1, 2, 2, 2]) False >>> is_zebra_array([5, 5, 5, 6, 6]) False >>> is_zebra_array([4, 4, 4, 4]) True >>> is_zebra_array([]) True >>> is_zebra_array([1]) True >>> is_zebra_array([1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6]) True","solution":"def is_zebra_array(arr): Determines if the array is a zebra array. Parameters: arr (list): A list of integers. Returns: bool: True if the array is a zebra array, False otherwise. from collections import Counter if not arr: return True # An empty array can be considered a zebra array count = Counter(arr) count_values = list(count.values()) return len(set(count_values)) == 1"},{"question":"import re from collections import Counter from typing import Tuple def find_most_frequent_word(s: str) -> Tuple[str, int]: Given a string containing alphanumeric characters and spaces, return the most frequently occurring word and its frequency. Ignore case and punctuation. Consider only letters and digits for the words and ignore the spaces or punctuations. Returned words should also be in lowercase. >>> find_most_frequent_word(\\"Hello World! Hello.\\") ('hello', 2) >>> find_most_frequent_word(\\"A quick brown fox jumps over the lazy dog.\\") ('a', 1) >>> find_most_frequent_word(\\"To be, or not to be, that is the question.\\") ('to', 2)","solution":"import re from collections import Counter def find_most_frequent_word(s): Returns the most frequently occurring word and its frequency in the string s. # Remove punctuation and convert to lowercase processed_string = re.sub(r'[^a-zA-Z0-9s]', '', s).lower() # Split into words words = processed_string.split() # Use Counter to find the frequency of each word word_counts = Counter(words) # Get the most common word and its frequency most_common_word, frequency = word_counts.most_common(1)[0] return most_common_word, frequency"},{"question":"def find_path(n: int, m: int, blocked: List[Tuple[int, int]]) -> str: Determine if there is a path from (1, 1) to (n, n) avoiding blocked cells. >>> find_path(5, 4, [(2, 2), (3, 2), (4, 2), (4, 3)]) == \\"YES\\" >>> find_path(3, 3, [(1, 2), (2, 2), (3, 2)]) == \\"NO\\" >>> find_path(2, 0, []) == \\"YES\\"","solution":"def find_path(n, m, blocked): from collections import deque grid = [[0] * n for _ in range(n)] for x, y in blocked: grid[x-1][y-1] = 1 if grid[0][0] == 1 or grid[n-1][n-1] == 1: return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, n-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def get_tree_levels(height): Generates the levels of a binary tree of given height in reverse order from bottom to top, and left to right within each level. >>> get_tree_levels(1) == [[1]] >>> get_tree_levels(2) == [[2, 3], [1]] >>> get_tree_levels(3) == [[4, 5, 6, 7], [2, 3], [1]] >>> get_tree_levels(4) == [ [8, 9, 10, 11, 12, 13, 14, 15], [4, 5, 6, 7], [2, 3], [1] ] def process_test_cases(test_cases): Processes multiple test cases for binary tree levels organized in reverse order. >>> process_test_cases([2]) == [\\"2 3\\", \\"1\\"] >>> process_test_cases([3]) == [\\"4 5 6 7\\", \\"2 3\\", \\"1\\"] >>> process_test_cases([2, 3]) == [ \\"2 3\\", \\"1\\", \\"4 5 6 7\\", \\"2 3\\", \\"1\\", ] >>> process_test_cases([0]) == []","solution":"def get_tree_levels(height): Generates the levels of a binary tree of given height in reverse order from bottom to top, and left to right within each level. if height == 0: return [] levels = [] value = 1 for level in range(height): levels.append([value + i for i in range(2**level)]) value += 2**level return levels[::-1] def process_test_cases(test_cases): results = [] for height in test_cases: levels = get_tree_levels(height) for level in levels: results.append(\\" \\".join(map(str, level))) return results"},{"question":"class Department: def __init__(self, name: str): self.name = name def __str__(self): return self.name class Employee: def __init__(self, name: str, age: int, salary: float, department: Department): self.name = name self.age = age self.salary = salary self.department = department def display(self) -> str: Display the information of the Employee. >>> dept = Department(\\"Engineering\\") >>> emp = Employee(\\"John Doe\\", 30, 50000, dept) >>> emp.display() 'Name: John DoenAge: 30nSalary: 50000nDepartment: Engineering' info = [ f\\"Name: {self.name}\\", f\\"Age: {self.age}\\", f\\"Salary: {self.salary}\\", f\\"Department: {self.department}\\" ] return \\"n\\".join(info)","solution":"# Explanation of Code Smells in the given Employee class: # 1. Long Method: The \`display\` method performs multiple tasks - displaying name, age, salary, and department. # 2. Large Class: The Employee class has multiple responsibilities â€” holding employee details and displaying them. # 3. Primitive Obsession: The \`department\` attribute is a primitive string instead of an entity that could encapsulate more related data and behavior. # Refactored Version of Employee Class class Department: def __init__(self, name): self.name = name def __str__(self): return self.name class Employee: def __init__(self, name, age, salary, department): self.name = name self.age = age self.salary = salary self.department = department def display(self): info = [ f\\"Name: {self.name}\\", f\\"Age: {self.age}\\", f\\"Salary: {self.salary}\\", f\\"Department: {self.department}\\" ] return \\"n\\".join(info)"},{"question":"def sort_letters_and_digits(s: str) -> str: Sorts the letters in alphabetical order and the digits in numerical order, and concatenates them together with letters first. :param s: The input string containing both letters and digits. :return: A string with sorted letters followed by sorted digits. Examples: >>> sort_letters_and_digits(\\"dcba4321\\") \\"abcd1234\\" >>> sort_letters_and_digits(\\"fgeh5764\\") \\"efgh4567\\"","solution":"def sort_letters_and_digits(s): Sorts the letters in alphabetical order and the digits in numerical order, and concatenates them together with letters first. :param s: The input string containing both letters and digits. :return: A string with sorted letters followed by sorted digits. letters = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return ''.join(letters + digits) # Examples # sort_letters_and_digits(\\"dcba4321\\") => \\"abcd1234\\" # sort_letters_and_digits(\\"fgeh5764\\") => \\"efgh4567\\""},{"question":"def trap_water(heights: List[int]) -> int: Calculates the total amount of trapped rainwater given the heights of columns. :param heights: List of integers representing the heights of columns. :return: Integer representing the total amount of trapped rainwater. >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_water(heights): Calculates the total amount of trapped rainwater given the heights of columns. :param heights: List of integers representing the heights of columns. :return: Integer representing the total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water = 0 # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water for i in range(n): water += min(left_max[i], right_max[i]) - heights[i] return water"},{"question":"class Playlist: A class to manage a music playlist. Methods: - __init__: Initializes an empty playlist. - addTrack: Adds a track with the given trackId and trackName to the playlist. - removeTrack: Removes the track with the given trackId from the playlist. - playNext: Plays the next track in the playlist and removes it from the list. - getPlaylist: Returns a list of all track names currently in the playlist. >>> playlist = Playlist() >>> playlist.addTrack(1, \\"Song A\\") >>> playlist.addTrack(2, \\"Song B\\") >>> playlist.getPlaylist() [\\"Song A\\", \\"Song B\\"] >>> playlist.playNext() \\"Song A\\" >>> playlist.getPlaylist() [\\"Song B\\"] >>> playlist.removeTrack(2) True >>> playlist.getPlaylist() [] >>> playlist.removeTrack(4) False Example Usage: >>> playlist = Playlist() >>> playlist.addTrack(1, \\"Song A\\") >>> playlist.addTrack(2, \\"Song B\\") >>> playlist.addTrack(3, \\"Song C\\") >>> playlist.getPlaylist() [\\"Song A\\", \\"Song B\\", \\"Song C\\"] >>> playlist.playNext() \\"Song A\\" >>> playlist.getPlaylist() [\\"Song B\\", \\"Song C\\"] >>> playlist.removeTrack(2) True >>> playlist.getPlaylist() [\\"Song C\\"] >>> playlist.removeTrack(4) False >>> playlist.getPlaylist() [\\"Song C\\"] def __init__(self): pass def addTrack(self, trackId, trackName): pass def removeTrack(self, trackId): pass def playNext(self): pass def getPlaylist(self): pass","solution":"class Playlist: def __init__(self): self.playlist = [] self.track_map = {} def addTrack(self, trackId, trackName): if trackId not in self.track_map: self.playlist.append(trackName) self.track_map[trackId] = trackName def removeTrack(self, trackId): if trackId in self.track_map: trackName = self.track_map.pop(trackId) self.playlist.remove(trackName) return True return False def playNext(self): if not self.playlist: return \\"No tracks to play\\" next_track = self.playlist.pop(0) for trackId, trackName in list(self.track_map.items()): if trackName == next_track: del self.track_map[trackId] break return next_track def getPlaylist(self): return self.playlist"},{"question":"def longest_word(s: str) -> str: Finds the longest word in the given string s. If there are multiple words with the same maximum length, returns the first one encountered. Parameters: s (str): A string containing alphabetic characters and spaces. Returns: str: The longest word in the input string. >>> longest_word(\\"Which is the longest word\\") \\"longest\\" >>> longest_word(\\"Find the maximum length word\\") \\"maximum\\" >>> longest_word(\\"singleword\\") \\"singleword\\" >>> longest_word(\\"\\") \\"\\" >>> longest_word(\\"one two six ten\\") \\"one\\" >>> longest_word(\\"Which WORD is the LONGEST\\") \\"LONGEST\\" # Your code here","solution":"def longest_word(s): Finds the longest word in the given string s. If there are multiple words with the same maximum length, returns the first one encountered. Parameters: s (str): A string containing alphabetic characters and spaces. Returns: str: The longest word in the input string. words = s.split() max_length = 0 longest = \\"\\" for word in words: if len(word) > max_length: max_length = len(word) longest = word return longest"},{"question":"import numpy as np from typing import List, Tuple def sum_and_product_of_matrix_elements(matrix: List[List[int]]) -> Tuple[List[int], List[int]]: Returns the sum of elements for each row and the product of elements for each column. Args: matrix (List[List[int]]): 2D list representing the matrix, where N is the number of rows and M is the number of columns. Returns: Tuple[List[int], List[int]]: Two lists, where the first list contains the sum of each row and the second list contains the product of each column. Examples: >>> sum_and_product_of_matrix_elements([[1, 2, 3, 4], [2, 3, 4, 5]]) ([10, 14], [2, 6, 12, 20]) >>> sum_and_product_of_matrix_elements([[1, 2, 3, 4]]) ([10], [1, 2, 3, 4]) >>> sum_and_product_of_matrix_elements([[1], [2], [3]]) ([1, 2, 3], [6]) >>> sum_and_product_of_matrix_elements([[5]]) ([5], [5]) >>> sum_and_product_of_matrix_elements([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) ([0, 0, 0], [0, 0, 0]) >>> sum_and_product_of_matrix_elements([[1, -2, 3], [-1, 2, -3], [4, 5, 6]]) ([2, -2, 15], [-4, -20, -54])","solution":"import numpy as np def sum_and_product_of_matrix_elements(matrix): Returns the sum of elements for each row and the product of elements for each column of the input matrix. Args: matrix (list of lists of int): 2D list representing the matrix. Returns: tuple: (row_sums, column_products) row_sums is a list of sums of each row. column_products is a list of products of each column. np_matrix = np.array(matrix) row_sums = np.sum(np_matrix, axis=1).tolist() column_products = np.prod(np_matrix, axis=0).tolist() return row_sums, column_products"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if a given string can be used to form a palindrome. A palindrome is a word or phrase that reads the same backward as forward, ignoring spaces, punctuation, and capitalization. The function should take a single argument which is a string containing only lowercase alphabets and return a boolean value indicating whether the string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"racecar\\") == True >>> can_form_palindrome(\\"civic\\") == True >>> can_form_palindrome(\\"ivicc\\") == True >>> can_form_palindrome(\\"aabb\\") == True >>> can_form_palindrome(\\"abc\\") == False >>> can_form_palindrome(\\"ab\\") == False >>> can_form_palindrome(\\"aba\\") == True","solution":"def can_form_palindrome(s): Determine if the given string can be rearranged to form a palindrome. :param s: str :return: bool from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # A counter for the odd frequency characters odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # If more than one character has an odd count, it cannot form a palindrome if odd_count > 1: return False return True"},{"question":"class CircularBuffer: def __init__(self, size): Initializes the buffer with a given size. Args: size (int): The size of the circular buffer. self.size = size self.buffer = [None] * size self.read_pos = 0 self.write_pos = 0 self.is_full = False def write(self, value): Writes a value to the buffer. Args: value (Any): The value to write to the buffer. raise NotImplementedError(\\"Write method not implemented\\") def read(self): Reads and removes the oldest value from the buffer. Returns: Any: The oldest value from the buffer, or \`None\` if the buffer is empty. raise NotImplementedError(\\"Read method not implemented\\") # Example usage: cb = CircularBuffer(3) cb.write(1) cb.write(2) print(cb.read()) # Output: 1 cb.write(3) cb.write(4) print(cb.read()) # Output: 2 print(cb.read()) # Output: 3 print(cb.read()) # Output: 4 print(cb.read()) # Output: None (buffer is empty)","solution":"class CircularBuffer: def __init__(self, size): Initializes the buffer with a given size. Args: size (int): The size of the circular buffer. self.size = size self.buffer = [None] * size self.read_pos = 0 self.write_pos = 0 self.is_full = False def write(self, value): Writes a value to the buffer. Args: value (Any): The value to write to the buffer. self.buffer[self.write_pos] = value if self.is_full: self.read_pos = (self.read_pos + 1) % self.size self.write_pos = (self.write_pos + 1) % self.size self.is_full = self.write_pos == self.read_pos def read(self): Reads and removes the oldest value from the buffer. Returns: Any: The oldest value from the buffer, or \`None\` if the buffer is empty. if self.read_pos == self.write_pos and not self.is_full: return None value = self.buffer[self.read_pos] self.buffer[self.read_pos] = None self.read_pos = (self.read_pos + 1) % self.size self.is_full = False return value # Example usage: cb = CircularBuffer(3) cb.write(1) cb.write(2) print(cb.read()) # Output: 1 cb.write(3) cb.write(4) print(cb.read()) # Output: 2 print(cb.read()) # Output: 3 print(cb.read()) # Output: 4 print(cb.read()) # Output: None (buffer is empty)"},{"question":"def count_palindromic_substrings(s: str) -> int: Count how many substrings in a given string are palindromes. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 def test_count_palindromic_substrings_single_char(): assert count_palindromic_substrings(\\"a\\") == 1 def test_count_palindromic_substrings_all_unique_chars(): assert count_palindromic_substrings(\\"abc\\") == 3 def test_count_palindromic_substrings_all_same_chars(): assert count_palindromic_substrings(\\"aaa\\") == 6 def test_count_palindromic_substrings_mixed_chars(): assert count_palindromic_substrings(\\"abccba\\") == 9 def test_count_palindromic_substrings_complex(): assert count_palindromic_substrings(\\"racecar\\") == 10","solution":"def count_palindromic_substrings(s: str) -> int: def is_palindrome(sub: str) -> bool: return sub == sub[::-1] count = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if is_palindrome(s[i:j]): count += 1 return count"},{"question":"from typing import List def calculate_ranks(scores: List[int]) -> List[int]: Determine the rank of each player based on their scores. >>> calculate_ranks([100, 90, 90, 80]) [1, 2, 2, 4] >>> calculate_ranks([70, 70, 100, 90]) [3, 3, 1, 2] >>> calculate_ranks([100, 90, 80, 70, 60]) [1, 2, 3, 4, 5] >>> calculate_ranks([100]) [1] >>> calculate_ranks([50, 50, 50, 50]) [1, 1, 1, 1] >>> calculate_ranks([100, 99, 98, 97, 90]) [1, 2, 3, 4, 5] >>> calculate_ranks([10, 20, 30, 40, 50]) [5, 4, 3, 2, 1] >>> calculate_ranks([100, 50, 100, 50, 100]) [1, 4, 1, 4, 1] pass","solution":"from typing import List def calculate_ranks(scores: List[int]) -> List[int]: Calculate the ranks based on the scores provided. sorted_scores = sorted(enumerate(scores), key=lambda x: x[1], reverse=True) ranks = [0] * len(scores) rank = 1 for i, (index, score) in enumerate(sorted_scores): if i > 0 and score < sorted_scores[i-1][1]: rank = i + 1 ranks[index] = rank return ranks"},{"question":"import re from typing import Union def calculate_expression(expression: str) -> Union[int, str]: Evaluates a mathematical expression string containing non-negative integers and +, -, *, / operators. Follows the correct order of operations and handles division by zero gracefully. >>> calculate_expression(\\"3+5*2/1-4\\") 9 >>> calculate_expression(\\"10+2/0-3\\") \\"Division by zero error\\"","solution":"def calculate_expression(expression): Evaluates a mathematical expression string containing non-negative integers and +, -, *, / operators. Follows the correct order of operations and handles division by zero gracefully. import re # Before splitting the expression, replace division by zero with a special case if \\"/0\\" in expression: return \\"Division by zero error\\" # Split the expression by operators, this will get the numbers numbers = list(map(int, re.split(r'[+-*/]', expression))) # Split the expression by numbers, this will get the operators operators = re.findall(r'[+-*/]', expression) # Function for applying an operator between two numbers def apply_operator(a, operator, b): if operator == '+': return a + b elif operator == '-': return a - b elif operator == '*': return a * b elif operator == '/': if b == 0: return \\"Division by zero error\\" return a // b # Process multiplication and division first i = 0 while i < len(operators): if operators[i] in '*/': numbers[i] = apply_operator(numbers[i], operators[i], numbers[i + 1]) del numbers[i + 1] del operators[i] else: i += 1 # Process addition and subtraction next i = 0 while i < len(operators): numbers[i] = apply_operator(numbers[i], operators[i], numbers[i + 1]) del numbers[i + 1] del operators[i] return numbers[0]"},{"question":"def rearrange_heights(heights: List[int], order: List[int]) -> List[int]: Rearranges the heights of students according to the new positions specified in the order list. :param heights: List of integers representing the heights of students. :param order: List of integers representing the new positions of the students. :return: List of integers representing the heights of students in their new order. >>> rearrange_heights([150, 160, 155, 165], [2, 0, 3, 1]) [160, 165, 150, 155] >>> rearrange_heights([170, 180, 160], [1, 2, 0]) [160, 170, 180] >>> rearrange_heights([130, 120, 140, 110], [3, 2, 1, 0]) [110, 140, 120, 130]","solution":"def rearrange_heights(heights, order): Rearranges the heights of students according to the new positions specified in the order list. :param heights: List of integers representing the heights of students. :param order: List of integers representing the new positions of the students. :return: List of integers representing the heights of students in their new order. n = len(heights) new_heights = [0] * n for i in range(n): new_heights[order[i]] = heights[i] return new_heights"},{"question":"import re from typing import List def is_valid_email(email: str) -> bool: Check if an email address is valid based on the given rules. >>> is_valid_email(\\"john.doe@example.com\\") == True >>> is_valid_email(\\"my-email@domain.co\\") == True >>> is_valid_email(\\"hello_world123@sub.domain.com\\") == True >>> is_valid_email(\\"john..doe@example.com\\") == False >>> is_valid_email(\\"my-email@domain..com\\") == False >>> is_valid_email(\\"hello@world@domain.com\\") == False >>> is_valid_email(\\"-abc@domain.com\\") == False >>> is_valid_email(\\"abc@domain-.com\\") == False pass def filter_valid_emails(emails: List[str]) -> List[str]: Filters a list of email addresses, returning only the valid ones. >>> filter_valid_emails([\\"john.doe@example.com\\",\\"john..doe@example.com\\",\\"my-email@domain..com\\",\\"my-email@domain.co\\",\\"hello_world123@sub.domain.com\\"]) == [\\"john.doe@example.com\\",\\"my-email@domain.co\\",\\"hello_world123@sub.domain.com\\"] pass","solution":"import re def is_valid_email(email): Check if an email address is valid based on the given rules. pattern = re.compile( r'^[a-zA-Z0-9]+(?:[._-][a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:.[a-zA-Z0-9]+)+' ) return pattern.match(email) is not None def filter_valid_emails(emails): Filters a list of email addresses, returning only the valid ones. return [email for email in emails if is_valid_email(email)]"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Find a contiguous subarray that has the largest sum and return that sum. :param nums: List[int] - List of integers :return: int - The largest sum of the contiguous subarray >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 # Explanation: [4,-1,2,1] has largest sum = 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([-2, -3, -1, -4]) == -1 >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([8, -19, 5, -4, 20]) == 21 >>> max_subarray_sum([0, -3, 1, 2]) == 3","solution":"def max_subarray_sum(nums): Function to find the sum of the contiguous subarray within a one-dimensional numeric array \`nums\` that has the largest sum. :param nums: List[int] - List of integers :return: int - The largest sum of the contiguous subarray if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"import re def is_palindrome(s: str) -> bool: Returns True if the string s is a palindrome, False otherwise. This function ignores spaces, punctuation, and case. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Hello, World!\\") False","solution":"import re def is_palindrome(s: str) -> bool: Returns True if the string s is a palindrome, False otherwise. This function ignores spaces, punctuation, and case. # Remove non-alphanumeric characters and convert to lower case cleaned_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_string == cleaned_string[::-1]"},{"question":"def can_rearrange_to_palindrome(s): Determine if the input string can be rearranged to form a palindrome. Parameters: s (str): Input string containing printable ASCII characters. Returns: bool: True if the input string can be rearranged to form a palindrome, False otherwise. Examples: >>> can_rearrange_to_palindrome(\\"Tact Coa\\") True >>> can_rearrange_to_palindrome(\\"hello\\") False from solution import can_rearrange_to_palindrome def test_example_1(): assert can_rearrange_to_palindrome(\\"Tact Coa\\") == True def test_example_2(): assert can_rearrange_to_palindrome(\\"hello\\") == False def test_single_character(): assert can_rearrange_to_palindrome(\\"a\\") == True def test_two_different_characters(): assert can_rearrange_to_palindrome(\\"ab\\") == False def test_two_same_characters(): assert can_rearrange_to_palindrome(\\"aa\\") == True def test_ignores_spaces_and_punctuation(): assert can_rearrange_to_palindrome(\\"A man, a plan, a canal, Panama!\\") == True def test_empty_string(): assert can_rearrange_to_palindrome(\\"\\") == True def test_mixed_case_characters(): assert can_rearrange_to_palindrome(\\"AaBbCc\\") == True def test_more_complex_string(): assert can_rearrange_to_palindrome(\\"aabbccddeeffgg\\") == True def test_no_palindrome_possible(): assert can_rearrange_to_palindrome(\\"abcdefghijklmnopqrstuvwxyz\\") == False","solution":"def can_rearrange_to_palindrome(s): Determine if the input string can be rearranged to form a palindrome. :param s: Input string. :return: Boolean indicating if the rearrangement to palindrome is possible. import re from collections import Counter # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Count the frequency of each character char_count = Counter(cleaned_s) # At most one character can have an odd frequency to be able to form a palindrome odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels in the provided string \`s\`. >>> count_vowels(\\"hello world\\") 3 >>> count_vowels(\\"python\\") 1 >>> count_vowels(\\"aeiou\\") 5 >>> count_vowels(\\"xyz\\") 0","solution":"def count_vowels(s: str) -> int: Returns the number of vowels in the provided string \`s\`. vowels = 'aeiou' count = 0 for char in s: if char in vowels: count += 1 return count"},{"question":"def attractiveness(strings): Compute and return the attractiveness of each string in the list. :param strings: List of strings :return: List of attractiveness values corresponding to each string # Your code goes here # Unit Tests def test_single_character_strings(): assert attractiveness(['a', 'b', 'c']) == [(97*1), (98*1), (99*1)] def test_mixed_strings(): assert attractiveness(['abc', 'xyz', 'hello']) == [(97+98+99)*3, (120+121+122)*3, (104+101+108+108+111)*5] def test_empty_strings(): assert attractiveness(['']) == [0] assert attractiveness(['', 'abc']) == [0, (97+98+99)*3] def test_strings_with_same_characters(): assert attractiveness(['aaa', 'bbb']) == [(97*3)*3, (98*3)*3] def test_strings_with_special_characters(): assert attractiveness(['@', '#', '!!!']) == [(64*1), (35+36)*2, (33*3)*3]","solution":"def attractiveness(strings): Compute and return the attractiveness of each string in the list. :param strings: List of strings :return: List of attractiveness values corresponding to each string results = [] for s in strings: ascii_sum = sum(ord(char) for char in s) attractiveness_value = ascii_sum * len(s) results.append(attractiveness_value) return results"},{"question":"def evaluateRPN(expression: str) -> float: Evaluates a mathematical expression in Reverse Polish Notation (RPN). Parameters: expression (str): A string representing the RPN expression. Returns: float: The result of the RPN evaluation. >>> evaluateRPN(\\"3 4 +\\") 7.0 >>> evaluateRPN(\\"2 3 + 4 *\\") 20.0 >>> evaluateRPN(\\"5 1 2 + 4 * + 3 -\\") 14.0 >>> evaluateRPN(\\"4 3 /\\") 1.3333333333333333","solution":"def evaluateRPN(expression): Evaluates a mathematical expression in Reverse Polish Notation (RPN). Parameters: expression (str): A string representing the RPN expression. Returns: float: The result of the RPN evaluation. stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = a / b stack.append(result) else: stack.append(float(token)) return stack[0]"},{"question":"def sum_except_self(arr): Write a function that takes an array of integers and returns a new array where each element is replaced by the sum of all the integers in the original array except for the element at the same index. >>> sum_except_self([1, 2, 3, 4]) [9, 8, 7, 6] >>> sum_except_self([1]) [] >>> sum_except_self([]) [] >>> sum_except_self([-1, -2, -3, -4]) [-9, -8, -7, -6] >>> sum_except_self([-1, 2, -3, 4]) [3, 0, 5, -2]","solution":"def sum_except_self(arr): if len(arr) < 2: return [] total_sum = sum(arr) return [total_sum - x for x in arr]"},{"question":"from collections import deque, defaultdict def spread_time(graph, initial_infected): Determine the amount of time taken for the entire population to be infected. Args: graph: List of pairs representing edges between nodes. initial_infected: List of initially infected nodes. Returns: Integer representing the amount of time taken for the entire population to be infected, or -1 if not all nodes can become infected. Examples: >>> spread_time([(0, 1), (1, 2), (2, 3), (2, 4)], [0]) 3 >>> spread_time([(0, 1), (0, 2), (1, 2), (2, 3)], [0]) 2 >>> spread_time([(0, 1), (2, 3)], [0]) -1","solution":"from collections import deque, defaultdict def spread_time(graph, initial_infected): if not graph or not initial_infected: return -1 # Convert the graph to adjacency list representation adjacency_list = defaultdict(list) all_nodes = set() for src, dest in graph: adjacency_list[src].append(dest) adjacency_list[dest].append(src) all_nodes.update([src, dest]) if set(initial_infected) == all_nodes: return 0 infected = set(initial_infected) queue = deque((node, 0) for node in initial_infected) max_time = 0 while queue: current_node, current_time = queue.popleft() for neighbor in adjacency_list[current_node]: if neighbor not in infected: infected.add(neighbor) queue.append((neighbor, current_time + 1)) max_time = max(max_time, current_time + 1) if len(infected) == len(all_nodes): return max_time else: return -1"},{"question":"def reverse_words_with_punctuation(sentence: str) -> str: Reverses the characters in each word of the input sentence, retaining punctuation in place. >>> reverse_words_with_punctuation(\\"Hello, world!\\")} \\"olleH, dlrow!\\" >>> reverse_words_with_punctuation(\\"Python is fun.\\") \\"nohtyP si nuf.\\" >>> reverse_words_with_punctuation(\\"Wow! Amazing!\\") \\"woW! gnizamA!\\" >>> reverse_words_with_punctuation(\\"Can you do it?\\") \\"naC uoy od ti?\\" >>> reverse_words_with_punctuation(\\"Hello, world. Let's see!\\") \\"olleH, dlrow. s'teL ees!\\" >>> reverse_words_with_punctuation(\\"Palindrome\\") \\"emordnilaP\\" >>> reverse_words_with_punctuation(\\"Amazing!\\") \\"gnizamA!\\"","solution":"def reverse_words_with_punctuation(sentence): Reverses the characters in each word of the input sentence, retaining punctuation in place. def reverse_word(word): # Detect if there's punctuation at the end of the word if word[-1] in '.,!?': return word[:-1][::-1] + word[-1] else: return word[::-1] words = sentence.split() reversed_words = [reverse_word(word) for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List def are_items_unique(guest_items: List[str]) -> bool: Checks if all items in the guest_items list are unique. >>> are_items_unique([\\"spiderman\\", \\"ironman\\", \\"batman\\", \\"frodo\\", \\"harry\\", \\"hermione\\"]) True >>> are_items_unique([\\"spiderman\\", \\"ironman\\", \\"batman\\", \\"frodo\\", \\"harry\\", \\"frodo\\"]) False >>> are_items_unique([]) True","solution":"def are_items_unique(guest_items): Checks if all items in the guest_items list are unique. Parameters: guest_items (List[str]): A list of strings where each string represents an item. Returns: bool: True if all items are unique, False otherwise. return len(guest_items) == len(set(guest_items))"},{"question":"def groupByLength(arr): Group strings by their lengths. Args: arr (list of str): Input list of strings. Returns: dict: Dictionary where keys are lengths of strings and values are lists of strings of that length. pass # Example Test Cases assert groupByLength([\\"apple\\", \\"banana\\", \\"pear\\", \\"kiwi\\", \\"peach\\"]) == { 5: [\\"apple\\", \\"peach\\"], 6: [\\"banana\\"], 4: [\\"pear\\", \\"kiwi\\"] } assert groupByLength([\\"tree\\", \\"bush\\", \\"flower\\", \\"seed\\"]) == { 4: [\\"tree\\", \\"bush\\", \\"seed\\"], 6: [\\"flower\\"] } assert groupByLength([]) == {} assert groupByLength([\\"hello\\"]) == {5: [\\"hello\\"]} assert groupByLength([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) == { 1: [\\"a\\"], 2: [\\"ab\\"], 3: [\\"abc\\"], 4: [\\"abcd\\"] } assert groupByLength([\\"hi\\", \\"he\\", \\"ho\\"]) == {2: [\\"hi\\", \\"he\\", \\"ho\\"]}","solution":"def groupByLength(arr): Group strings by their lengths. Args: arr (list of str): Input list of strings. Returns: dict: Dictionary where keys are lengths of strings and values are lists of strings of that length. result = {} for s in arr: length = len(s) if length not in result: result[length] = [] result[length].append(s) return result"},{"question":"def check_password(password: str) -> str: Checks the validity of a given password based on the specified criteria and returns a relevant message. The password is considered valid if: 1. The password length should be between 8 and 15 characters. 2. The password should contain at least one uppercase letter (A-Z). 3. The password should contain at least one lowercase letter (a-z). 4. The password should contain at least one digit (0-9). 5. The password should contain at least one special character from the set: #, @, !, &, % >>> check_password(\\"Valid1@Password\\") \\"Password is valid.\\" >>> check_password(\\"short1!\\") \\"Password must password length should be between 8 and 15 characters.\\" >>> check_password(\\"validpassword1@\\") \\"Password must contain at least one uppercase letter (A-Z).\\"","solution":"import re def check_password(password): Function to check the validity of a password based on specific criteria. Args: password (str): The password to check. Returns: str: A string indicating whether the password is valid or what criteria were not met. errors = [] if not (8 <= len(password) <= 15): errors.append(\\"password length should be between 8 and 15 characters\\") if not re.search(r'[A-Z]', password): errors.append(\\"contain at least one uppercase letter (A-Z)\\") if not re.search(r'[a-z]', password): errors.append(\\"contain at least one lowercase letter (a-z)\\") if not re.search(r'[0-9]', password): errors.append(\\"contain at least one digit (0-9)\\") if not re.search(r'[#@!&%]', password): errors.append(\\"contain at least one special character from the set: #, @, !, &, %\\") if errors: return \\"Password must \\" + ' and '.join(errors) + '.' return \\"Password is valid.\\""},{"question":"def reverse_characters_in_words(s: str) -> str: Reverse the order of characters in each word in a string, while maintaining the original word order. Preserve the original whitespace and punctuation. Examples: >>> reverse_characters_in_words(\\"Hello World!\\") == \\"olleH !dlroW\\" >>> reverse_characters_in_words(\\"Python coding is fun\\") == \\"nohtyP gnidoc si nuf\\" >>> reverse_characters_in_words(\\"Keep calm and code on\\") == \\"peeK mlac dna edoc no\\" >>> reverse_characters_in_words(\\" Leading and trailing spaces \\") == \\" gnidaeL dna gniliart secaps \\" >>> reverse_characters_in_words(\\"123 abc 456 def\\") == \\"321 cba 654 fed\\" from solution import reverse_characters_in_words def test_reverse_characters_in_words(): assert reverse_characters_in_words(\\"Hello World!\\") == \\"olleH !dlroW\\" assert reverse_characters_in_words(\\"Python coding is fun\\") == \\"nohtyP gnidoc si nuf\\" assert reverse_characters_in_words(\\"Keep calm and code on\\") == \\"peeK mlac dna edoc no\\" assert reverse_characters_in_words(\\" Leading and trailing spaces \\") == \\" gnidaeL dna gniliart secaps \\" assert reverse_characters_in_words(\\"123 abc 456 def\\") == \\"321 cba 654 fed\\" assert reverse_characters_in_words(\\"\\") == \\"\\" assert reverse_characters_in_words(\\"Single\\") == \\"elgniS\\"","solution":"def reverse_characters_in_words(s): Reverse characters in each word while maintaining the original word order. Preserve the original whitespace and punctuation. words = s.split(\\" \\") reversed_words = [word[::-1] for word in words] return \\" \\".join(reversed_words)"},{"question":"def alternate_sort(arr: List[int]) -> List[int]: Given an unsorted array of integers, rearrange the array elements such that the greatest element appears at the first position, followed by the smallest element, the second greatest element, the second smallest element, and so on. >>> alternate_sort([1, 2, 3, 4, 5]) [5, 1, 4, 2, 3] >>> alternate_sort([9, 7, 2, 3, 6]) [9, 2, 7, 3, 6]","solution":"def alternate_sort(arr): Returns a new list that is rearranged such that the greatest element appears first, followed by the smallest element, the second greatest element, the second smallest element, and so on. arr.sort() result = [] left, right = 0, len(arr) - 1 while left <= right: if left != right: result.append(arr[right]) result.append(arr[left]) else: result.append(arr[left]) left += 1 right -= 1 return result"},{"question":"def convert_temperature(value, scale): Convert the given temperature value to other two scales. Parameters: value (float): Temperature value to be converted. scale (str): The scale of the given temperature value, 'C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin. Returns: dict: A dictionary with converted temperature values. Empty dictionary if input is invalid. Examples: >>> convert_temperature(25.0, 'C') {'F': 77.0, 'K': 298.15} >>> convert_temperature(77.0, 'F') {'C': 25.0, 'K': 298.15} >>> convert_temperature(298.15, 'K') {'C': 25.0, 'F': 77.0} >>> convert_temperature(25.0, 'X') {} >>> convert_temperature('abc', 'C') {} >>> convert_temperature(0.0, 'C') {'F': 32.0, 'K': 273.15} >>> convert_temperature(0.0, 'F') {'C': -17.78, 'K': 255.37} >>> convert_temperature(0.0, 'K') {'C': -273.15, 'F': -459.67}","solution":"def convert_temperature(value, scale): Convert the given temperature value to other two scales. Parameters: value (float): Temperature value to be converted. scale (str): The scale of the given temperature value, 'C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin. Returns: dict: A dictionary with converted temperature values. Empty dictionary if input is invalid. try: value = float(value) # Ensure the temperature value is float except ValueError: return {} if scale not in ('C', 'F', 'K'): return {} conversions = {} if scale == 'C': conversions['F'] = round((value * 9/5) + 32, 2) conversions['K'] = round(value + 273.15, 2) elif scale == 'F': conversions['C'] = round((value - 32) * 5/9, 2) conversions['K'] = round(((value - 32) * 5/9) + 273.15, 2) elif scale == 'K': conversions['C'] = round(value - 273.15, 2) conversions['F'] = round(((value - 273.15) * 9/5) + 32, 2) return conversions"},{"question":"from typing import List, Tuple def min_adjacent_swaps(initial: List[int], desired: List[int]) -> int: Returns the minimum number of adjacent swaps required to transform the initial list to the desired list. >>> min_adjacent_swaps([4, 3, 2, 1], [1, 2, 3, 4]) 6 >>> min_adjacent_swaps([3, 1, 2], [1, 2, 3]) 2 pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Process multiple test cases and return the results as a list. >>> process_test_cases(2, [(4, [4, 3, 2, 1], [1, 2, 3, 4]), (3, [3, 1, 2], [1, 2, 3])]) [6, 2] pass def test_min_adjacent_swaps_case1(): initial = [4, 3, 2, 1] desired = [1, 2, 3, 4] assert min_adjacent_swaps(initial, desired) == 6 def test_min_adjacent_swaps_case2(): initial = [3, 1, 2] desired = [1, 2, 3] assert min_adjacent_swaps(initial, desired) == 2 def test_min_adjacent_swaps_no_swaps_needed(): initial = [1, 2, 3] desired = [1, 2, 3] assert min_adjacent_swaps(initial, desired) == 0 def test_min_adjacent_swaps_single_item(): initial = [1] desired = [1] assert min_adjacent_swaps(initial, desired) == 0 def test_process_test_cases(): T = 2 test_cases = [ (4, [4, 3, 2, 1], [1, 2, 3, 4]), (3, [3, 1, 2], [1, 2, 3]) ] assert process_test_cases(T, test_cases) == [6, 2]","solution":"def min_adjacent_swaps(initial, desired): Returns the minimum number of adjacent swaps required to transform the initial list to the desired list. position = {value: i for i, value in enumerate(initial)} swaps = 0 for i in range(len(desired)): while position[desired[i]] != i: pos = position[desired[i]] # Swap desired[i] with the element at pos-1. initial[pos], initial[pos - 1] = initial[pos - 1], initial[pos] # Update positions position[initial[pos]] = pos position[initial[pos - 1]] = pos - 1 swaps += 1 return swaps def process_test_cases(T, test_cases): results = [] for case in test_cases: N, initial, desired = case result = min_adjacent_swaps(initial, desired) results.append(result) return results"},{"question":"from typing import List def prime_factors(n: int) -> List[int]: Create a function that takes an integer input n and returns a list of all unique prime factors of n. Prime factors are prime numbers that divide n exactly, without leaving a remainder. >>> prime_factors(28) [2, 7] >>> prime_factors(45) [3, 5] >>> prime_factors(100) [2, 5]","solution":"def prime_factors(n): Returns a list of all unique prime factors of n. factors = [] # Check for number of 2s that divide n while n % 2 == 0: if 2 not in factors: factors.append(2) n //= 2 # n must be odd at this point, so we can skip one element (i.e., we can check i = i + 2) for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: if i not in factors: factors.append(i) n //= i # This condition is to check if n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"def min_steps_to_one(n: int) -> int: Given a positive integer n, find the minimal number of steps to reduce n to 1 following the rules: 1. If n is divisible by 2, you may reduce it to n / 2. 2. If n is divisible by 3, you may reduce it to n / 3. 3. Decrement n by 1. Args: n (int): Positive integer n. Returns: int: Minimal number of steps to reduce n to 1. >>> min_steps_to_one(10) 3 >>> min_steps_to_one(15) 4 >>> min_steps_to_one(1) 0 >>> min_steps_to_one(2) 1 >>> min_steps_to_one(3) 1 >>> min_steps_to_one(4) 2 >>> min_steps_to_one(5) 3 >>> min_steps_to_one(6) 2 >>> min_steps_to_one(100) 7","solution":"def min_steps_to_one(n): Given a positive integer n, find the minimal number of steps to reduce n to 1 following the rules: 1. If n is divisible by 2, you may reduce it to n / 2. 2. If n is divisible by 3, you may reduce it to n / 3. 3. Decrement n by 1. Args: n (int): Positive integer n. Returns: int: Minimal number of steps to reduce n to 1. dp = [0] * (n + 1) for i in range(2, n + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"from typing import List def max_non_consecutive_subsequence_sum(nums: List[int]) -> int: Given a list of n integers, return the maximum sum of any non-empty subsequence with the condition that the selected subsequence does not contain any consecutive numbers from the original list. >>> max_non_consecutive_subsequence_sum([3, 2, 7, 10]) 13 >>> max_non_consecutive_subsequence_sum([3, 2, 5, 10, 7]) 15 >>> max_non_consecutive_subsequence_sum([2, 1, 4, 9]) 11 >>> max_non_consecutive_subsequence_sum([-1, -2, -3, -4]) 0 >>> max_non_consecutive_subsequence_sum([4, -1, 2, 6]) 10 >>> max_non_consecutive_subsequence_sum([]) 0 >>> max_non_consecutive_subsequence_sum([5]) 5 >>> max_non_consecutive_subsequence_sum([-5]) 0","solution":"def max_non_consecutive_subsequence_sum(nums): Returns the maximum sum of any non-empty subsequence with the condition that the selected subsequence does not contain any consecutive numbers from the original list. if not nums: return 0 incl = 0 # Maximum sum including the current element excl = 0 # Maximum sum excluding the current element for num in nums: # Current max excluding i (No neighboring element constraint) new_excl = max(incl, excl) # Current max including i incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"def max_scores_up_to_each_round(scores): Given a list of scores, return a list of the maximum scores up to and including each round. :param scores: List of integers representing scores in each round. :return: List of integers representing the maximum scores up to and including each round. >>> max_scores_up_to_each_round([2, 3, 1, 5, 4]) [2, 3, 3, 5, 5] >>> max_scores_up_to_each_round([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> max_scores_up_to_each_round([5]) [5] >>> max_scores_up_to_each_round([5, 4, 3, 2, 1]) [5, 5, 5, 5, 5]","solution":"def max_scores_up_to_each_round(scores): Given a list of scores, return a list of the maximum scores up to and including each round. :param scores: List of integers representing scores in each round. :return: List of integers representing the maximum scores up to and including each round. max_up_to_now = [] current_max = scores[0] for score in scores: if score > current_max: current_max = score max_up_to_now.append(current_max) return max_up_to_now"},{"question":"def is_leap_year(year: int) -> str: Determines if the given year is a leap year. A year is a leap year if: - It is divisible by 400, or - It is divisible by 4 but not divisible by 100. >>> is_leap_year(2000) \\"Leap Year\\" >>> is_leap_year(1999) \\"Not a Leap Year\\" >>> is_leap_year(2020) \\"Leap Year\\" >>> is_leap_year(1900) \\"Not a Leap Year\\" >>> is_leap_year(2100) \\"Not a Leap Year\\" >>> is_leap_year(2400) \\"Leap Year\\" >>> is_leap_year(2004) \\"Leap Year\\" >>> is_leap_year(2021) \\"Not a Leap Year\\" pass def leap_years_test_cases(T: int, years: List[int]) -> List[str]: Determines if each year in the list \`years\` is a leap year, for a total of T test cases. >>> leap_years_test_cases(4, [2000, 1999, 2020, 1900]) [\\"Leap Year\\", \\"Not a Leap Year\\", \\"Leap Year\\", \\"Not a Leap Year\\"] >>> leap_years_test_cases(3, [2100, 2400, 2001]) [\\"Not a Leap Year\\", \\"Leap Year\\", \\"Not a Leap Year\\"] >>> leap_years_test_cases(2, [1600, 1700]) [\\"Leap Year\\", \\"Not a Leap Year\\"] >>> leap_years_test_cases(1, [2024]) [\\"Leap Year\\"] >>> leap_years_test_cases(5, [1996, 2000, 1600, 1800, 1904]) [\\"Leap Year\\", \\"Leap Year\\", \\"Leap Year\\", \\"Not a Leap Year\\", \\"Leap Year\\"] pass","solution":"def is_leap_year(year): Determines if the given year is a leap year. A year is a leap year if: - It is divisible by 400, or - It is divisible by 4 but not divisible by 100. if (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0): return \\"Leap Year\\" else: return \\"Not a Leap Year\\" def leap_years_test_cases(T, years): Determines if each year in the list \`years\` is a leap year, for a total of T test cases. results = [] for year in years: results.append(is_leap_year(year)) return results"},{"question":"def can_transform_matrix(N, M, A, B): Determine if there exists a permutation of the rows and columns of matrix A to transform it into matrix B. Arguments: - N: int - Number of rows in the matrices. - M: int - Number of columns in the matrices. - A: List[List[int]] - The first matrix. - B: List[List[int]] - The second matrix. Returns: - bool - True if A can be transformed into B, otherwise False. pass def matrix_permutation_possible(test_cases): Check for multiple test cases whether the matrix can be transformed. Arguments: - test_cases: List[Tuple[int, int, List[List[int]], List[List[int]]]] - List of tuples containing N, M, A, B for each test case. Returns: - List[str] - A list of \\"YES\\" or \\"NO\\" indicating if the transformation is possible for each test case. pass def solve_problem(input_data): Parse the input data and implement the solution. Arguments: - input_data: str - Input data as a single string. Returns: - str - The result of each test case concatenated in a single string. >>> input_data = \\"2n2 2n1 2n3 4n3 4n1 2n2 3n4 1n2 3n1 2n3n1 2n3 4n5 6n3 4n5 6n1 2\\" >>> solve_problem(input_data) 'YESnNO' pass import pytest from solution import solve_problem def test_example_1(): input_data = \\"2n2 2n1 2n3 4n3 4n1 2n2 3n4 1n2 3n1 2n3n1 2n3 4n5 6n3 4n5 6n1 2\\" expected_output = \\"YESnNO\\" assert solve_problem(input_data) == expected_output def test_case_same_matrices(): input_data = \\"1n3 3n1 2 3n4 5 6n7 8 9n1 2 3n4 5 6n7 8 9\\" expected_output = \\"YES\\" assert solve_problem(input_data) == expected_output def test_case_no_permutation(): input_data = \\"1n2 2n1 2n3 4n5 6n7 8\\" expected_output = \\"NO\\" assert solve_problem(input_data) == expected_output def test_case_single_element(): input_data = \\"1n1 1n5n5\\" expected_output = \\"YES\\" assert solve_problem(input_data) == expected_output def test_case_different_sizes(): input_data = \\"1n2 2n1 2n3 3n2 1n3 3\\" expected_output = \\"YES\\" assert solve_problem(input_data) == expected_output def test_case_permutation_but_not_lexicographically(): input_data = \\"1n2 3n1 2 3n4 5 6n2 3 1n5 4 6\\" expected_output = \\"YES\\" assert solve_problem(input_data) == expected_output","solution":"def can_transform_matrix(N, M, A, B): # Sort each row in both matrices sorted_A = [sorted(row) for row in A] sorted_B = [sorted(row) for row in B] # Sort the rows lexicographically sorted_A.sort() sorted_B.sort() # Compare sorted versions of A and B return sorted_A == sorted_B def matrix_permutation_possible(test_cases): results = [] for N, M, A, B in test_cases: if can_transform_matrix(N, M, A, B): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to parse input and execute the solution def solve_problem(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, lines[index].split()) A = [] B = [] for i in range(N): A.append(list(map(int, lines[index + 1 + i].split()))) for j in range(N): B.append(list(map(int, lines[index + 1 + N + j].split()))) index += 1 + 2 * N test_cases.append((N, M, A, B)) result = matrix_permutation_possible(test_cases) return \\"n\\".join(result)"},{"question":"def longest_subarray(arr: List[int]) -> List[int]: Returns the longest contiguous subarray where the absolute difference between every two adjacent elements is less than or equal to 1. >>> longest_subarray([4, 7, 5, 6, 5, 6, 3, 8]) [5, 6, 5, 6] >>> longest_subarray([1, 2, 2, 3, 4, 1, 2, 2, 1]) [1, 2, 2, 3, 4] >>> longest_subarray([10]) [10] >>> longest_subarray([1, 1, 1, 1, 1]) [1, 1, 1, 1, 1] >>> longest_subarray([]) [] >>> longest_subarray([1, 3, 5, 7]) [1] >>> longest_subarray([1, 2, 1, 2, 1, 2, 1]) [1, 2, 1, 2, 1, 2, 1]","solution":"def longest_subarray(arr): if not arr: return [] max_len = 1 current_start = 0 result_start = 0 for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) <= 1: if i - current_start + 1 > max_len: max_len = i - current_start + 1 result_start = current_start else: current_start = i return arr[result_start:result_start + max_len]"},{"question":"from typing import List def rearrange_numbers(arr: List[int]) -> List[int]: Reorders the numbers in such a way that even-indexed positions are filled with the even numbers in ascending order and odd-indexed positions are filled with the odd numbers in descending order. >>> rearrange_numbers([3, 8, 5, 13, 12, 10]) == [8, 13, 10, 5, 12, 3] >>> rearrange_numbers([5, 2, 9, 4, 3]) == [2, 9, 4, 5, 0]","solution":"from typing import List def rearrange_numbers(arr: List[int]) -> List[int]: evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0], reverse=True) result = [] even_index, odd_index = 0, 0 for i in range(len(arr)): if i % 2 == 0: if even_index < len(evens): result.append(evens[even_index]) even_index += 1 else: result.append(0) else: if odd_index < len(odds): result.append(odds[odd_index]) odd_index += 1 else: result.append(0) return result"},{"question":"def transpose(matrix: List[List[int]]) -> List[List[int]]: Transpose a given rectangular matrix. >>> transpose([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) [[1, 3, 5], [2, 4, 6]] >>> transpose([ ... [1, 2, 3, 4] ... ]) [[1], [2], [3], [4]] >>> transpose([ ... [1], ... [2], ... [3], ... [4] ... ]) [[1, 2, 3, 4]]","solution":"def transpose(matrix): Returns the transpose of the given matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"def set_operations(a, b): Returns the union, intersection, difference, and symmetric difference of two sets, sorted in ascending order. >>> set_operations([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [5, 6, 7, 8, 9, 10], [1, 2, 3, 4], [1, 2, 3, 4, 11, 12, 13, 14]) >>> set_operations([1, 11, 21, 31, 41, 51, 61, 71, 81, 91], [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) ([1, 10, 11, 20, 21, 30, 31, 40, 41, 50, 51, 60, 61, 70, 71, 80, 81, 90, 91, 100], [], [1, 11, 21, 31, 41, 51, 61, 71, 81, 91], [1, 10, 11, 20, 21, 30, 31, 40, 41, 50, 51, 60, 61, 70, 71, 80, 81, 90, 91, 100]) pass","solution":"def set_operations(a, b): Returns the union, intersection, difference, and symmetric difference of two sets, sorted in ascending order. a_set = set(a) b_set = set(b) union_result = sorted(a_set.union(b_set)) intersection_result = sorted(a_set.intersection(b_set)) difference_result = sorted(a_set.difference(b_set)) sym_difference_result = sorted(a_set.symmetric_difference(b_set)) return union_result, intersection_result, difference_result, sym_difference_result"},{"question":"def longestUniqueSubstring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longestUniqueSubstring(\\"abcabcbb\\") == 3 >>> longestUniqueSubstring(\\"bbbbb\\") == 1 >>> longestUniqueSubstring(\\"pwwkew\\") == 3 >>> longestUniqueSubstring(\\"\\") == 0 >>> longestUniqueSubstring(\\"abcdef\\") == 6 >>> longestUniqueSubstring(\\"aab\\") == 2 >>> longestUniqueSubstring(\\"dvdf\\") == 3 pass","solution":"def longestUniqueSubstring(s: str) -> int: Returns the length of the longest substring with all unique characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def generate_sequence(N: int) -> str: Generates a sequence up to the given number N, interspersed with \\"xyz\\". >>> generate_sequence(1) \\"1xyz\\" >>> generate_sequence(2) \\"1xyz2xyz\\" >>> generate_sequence(3) \\"1xyz2xyz3xyz\\" def process_test_cases(T: int, cases: List[int]) -> List[str]: Processes multiple test cases to generate sequences based on the given numbers. >>> process_test_cases(3, [1, 2, 3]) [\\"1xyz\\", \\"1xyz2xyz\\", \\"1xyz2xyz3xyz\\"] >>> process_test_cases(2, [4, 5]) [\\"1xyz2xyz3xyz4xyz\\", \\"1xyz2xyz3xyz4xyz5xyz\\"] >>> process_test_cases(0, []) []","solution":"def generate_sequence(N): Generates a sequence up to the given number N, interspersed with \\"xyz\\". result = \\"\\" for i in range(1, N+1): result += f\\"{i}xyz\\" return result def process_test_cases(T, cases): results = [] for N in cases: results.append(generate_sequence(N)) return results"},{"question":"def isLeapYear(year: int) -> bool: Returns True if the given year is a leap year, otherwise False. A year is a leap year if it is divisible by 4, except if it is divisible by 100, then it must also be divisible by 400. >>> isLeapYear(2020) == True >>> isLeapYear(1900) == False >>> isLeapYear(2000) == True >>> isLeapYear(2021) == False","solution":"def isLeapYear(year): Returns True if the given year is a leap year, otherwise False. A year is a leap year if it is divisible by 4, except if it is divisible by 100, then it must also be divisible by 400. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False"},{"question":"def pascal_row(n: int) -> list: Returns the nth row of Pascal's triangle as a list. Parameters: n (int): the row index (0-indexed) Returns: list: the nth row of Pascal's triangle >>> pascal_row(0) [1] >>> pascal_row(1) [1, 1] >>> pascal_row(2) [1, 2, 1] >>> pascal_row(3) [1, 3, 3, 1] >>> pascal_row(4) [1, 4, 6, 4, 1] >>> pascal_row(5) [1, 5, 10, 10, 5, 1] >>> pascal_row(10) [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1] >>> pascal_row(20) [ 1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1 ]","solution":"from math import comb def pascal_row(n): Returns the nth row of Pascal's triangle as a list. Parameters: n (int): the row index (0-indexed) Returns: list: the nth row of Pascal's triangle return [comb(n, i) for i in range(n + 1)]"},{"question":"def min_window(s: str, t: str) -> str: Finds the minimum window in \`s\` that contains all the characters from \`t\`. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"A\\", \\"AA\\") \\"\\" >>> min_window(\\"XYZ\\", \\"XYZ\\") \\"XYZ\\" >>> min_window(\\"AAADOBECODEBANCBB\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"\\", \\"A\\") \\"\\" >>> min_window(\\"ADOBECODEBANC\\", \\"\\") \\"\\"","solution":"from collections import Counter, defaultdict def min_window(s, t): Finds the minimum window in \`s\` that contains all the characters from \`t\`. if not s or not t: return \\"\\" t_count = Counter(t) current_count = defaultdict(int) start = 0 min_len = float('inf') min_window_start = 0 required = len(t_count) formed = 0 l = 0 for r in range(len(s)): char = s[r] current_count[char] += 1 if char in t_count and current_count[char] == t_count[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < min_len: min_len = r - l + 1 min_window_start = l current_count[char] -= 1 if char in t_count and current_count[char] < t_count[char]: formed -= 1 l += 1 if min_len == float('inf'): return \\"\\" return s[min_window_start:min_window_start + min_len]"},{"question":"def find_smallest_difference_pair(arr: List[int]) -> Tuple[int, int]: Given an array of integers, find the pair of numbers that have the smallest absolute difference between them. >>> find_smallest_difference_pair([2, 4, 7, 5, 10, 11]) in [(4, 5), (5, 4)] >>> find_smallest_difference_pair([6, 2, 4, 10]) in [(2, 4), (4, 2)] >>> find_smallest_difference_pair([-1, -5, -3, -2]) in [(-3, -2), (-2, -3)]","solution":"from typing import List, Tuple def find_smallest_difference_pair(arr: List[int]) -> Tuple[int, int]: Returns a pair of numbers with the smallest absolute difference. # Sort the array to make it easier to find the smallest difference pair arr.sort() # Initialize variables to store the minimum difference and the resulting pair min_diff = float('inf') result_pair = (arr[0], arr[1]) # Traverse the sorted array and find the pair with the smallest difference for i in range(len(arr) - 1): diff = abs(arr[i+1] - arr[i]) if diff < min_diff: min_diff = diff result_pair = (arr[i], arr[i+1]) return result_pair"},{"question":"def find_palindromes(words): Returns a list of strings that are palindromes from the given list. A palindrome is a word that reads the same forward and backward, case-insensitively. :param words: List of strings to be checked. :return: List of palindromic strings. pass # Example usage palindromes = find_palindromes([\\"Racecar\\", \\"Hello\\", \\"Level\\", \\"World\\", \\"Deified\\"]) print(palindromes) # --> ['Racecar', 'Level', 'Deified']","solution":"def find_palindromes(words): Returns a list of strings that are palindromes from the given list. A palindrome is a word that reads the same forward and backward, case-insensitively. :param words: List of strings to be checked. :return: List of palindromic strings. return [word for word in words if word.lower() == word.lower()[::-1]]"},{"question":"def calculate_inventory(candies, wrappers, stems): Returns a dictionary with the count of candy packages and fruits. :param candies: total number of candies :param wrappers: total number of wrappers :param stems: total number of stems :return: dictionary with 'packages' and 'fruit' >>> calculate_inventory(40, 10, 8) {\\"packages\\": 10, \\"fruit\\": 8} >>> calculate_inventory(32, 8, 15) {\\"packages\\": 8, \\"fruit\\": 15} >>> calculate_inventory(20, 5, 0) {\\"packages\\": 5, \\"fruit\\": 0} >>> calculate_inventory(0, 0, 10) {\\"packages\\": 0, \\"fruit\\": 10} >>> calculate_inventory(1000, 250, 400) {\\"packages\\": 250, \\"fruit\\": 400} # Your implementation here","solution":"def calculate_inventory(candies, wrappers, stems): Returns a dictionary with the count of candy packages and fruits. :param candies: total number of candies :param wrappers: total number of wrappers :param stems: total number of stems :return: dictionary with 'packages' and 'fruit' # Since each package contains exactly 4 candies and 1 wrapper packages = wrappers # Each fruit contains exactly 1 stem fruits = stems return {\\"packages\\": packages, \\"fruit\\": fruits}"},{"question":"def can_reach(roads, start, target, closed_roads): Determine if there is a path from start to target considering the closed roads. Args: roads (List[Tuple[int, int]]): List of tuples representing the roads in the city. start (int): Starting intersection. target (int): Target intersection. closed_roads (List[Tuple[int, int]]): List of tuples representing the closed roads. Returns: bool: True if there is still a path from start to target considering the closed roads, False otherwise. Examples: >>> can_reach([(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], 1, 4, [(2, 3), (4, 5)]) False >>> can_reach([], 1, 4, []) False >>> can_reach([(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], 1, 4, []) True >>> can_reach([(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], 1, 1, []) True >>> can_reach([(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], 1, 4, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]) False","solution":"def can_reach(roads, start, target, closed_roads): from collections import defaultdict, deque # Step 1: Build the graph from the roads graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Step 2: Remove the closed roads from the graph for u, v in closed_roads: if v in graph[u]: graph[u].remove(v) if u in graph[v]: graph[v].remove(u) # Step 3: Perform BFS to check if there is a path from start to target queue = deque([start]) visited = set() while queue: current = queue.popleft() if current == target: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"def is_leap_year(year: int) -> bool: Determines whether or not the given year is a leap year. A leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400. >>> is_leap_year(2020) True >>> is_leap_year(2019) False >>> is_leap_year(2000) True >>> is_leap_year(1900) False","solution":"def is_leap_year(year): Returns True if the given year is a leap year, False otherwise. A leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False"},{"question":"def max_sum_subgrid(M: int, N: int, grid: [[int]]) -> int: Identify a rectangular subgrid within the grid that has the maximum sum of processing power and return the sum. Args: M: int - the number of rows in the grid N: int - the number of columns in the grid grid: List of lists - the processing power grid Returns: int - the maximum sum of processing power from any rectangular subgrid. >>> max_sum_subgrid(4, 5, [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]) 29 >>> max_sum_subgrid(1, 1, [[5]]) 5 >>> max_sum_subgrid(2, 2, [[-1, -2], [-3, -4]]) -1 >>> max_sum_subgrid(3, 3, [[1, 2, 3], [4, 5, 6], [-1, -2, -3]]) 21 >>> max_sum_subgrid(2, 3, [[1, 2, 3], [4, 5, 6]]) 21","solution":"def max_sum_subgrid(M, N, grid): # Initialize max sum as the smallest possible value max_sum = -float('inf') # Prefix sums for rows for top in range(M): temp_sums = [0] * N for bottom in range(top, M): for col in range(N): temp_sums[col] += grid[bottom][col] # Use Kadane's algorithm to find the max sum subarray in temp_sums max_sum = max(max_sum, kadane(temp_sums)) return max_sum def kadane(arr): max_ending_here = max_so_far = -float('inf') for x in arr: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far # input processing function for testing def process_input(input_data): input_lines = input_data.strip().split('n') M, N = map(int, input_lines[0].split()) grid = [list(map(int, line.split())) for line in input_lines[1:]] return M, N, grid # Handle the given example input and output M = 4 N = 5 grid = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] print(max_sum_subgrid(M, N, grid)) # Output: 29"},{"question":"def to_binary(numbers: List[int]) -> List[str]: Given a list of non-negative integers, returns a list of strings representing the binary representation of each integer. Args: numbers (list): A list of non-negative integers Returns: list: A list of binary string representations of the input integers Examples: >>> to_binary([5, 2, 7]) ['101', '10', '111'] >>> to_binary([0, 1, 3]) ['0', '1', '11'] >>> to_binary([10, 4]) ['1010', '100'] >>> to_binary([100]) ['1100100'] >>> to_binary([]) []","solution":"def to_binary(numbers): Given a list of non-negative integers, returns a list of strings representing the binary representation of each integer. Args: numbers (list): A list of non-negative integers Returns: list: A list of binary string representations of the input integers return [bin(number)[2:] for number in numbers]"},{"question":"def solve_inversions(num_cases: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the number of inversions in an array for each test case. An inversion is when for any indices i and j (1 â‰¤ i < j â‰¤ N), arr[i] > arr[j]. Args: num_cases (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer N (the size of the array) and a list of N integers representing the elements of the array. Returns: List[int]: A list of integers, each representing the number of inversions in the corresponding input array. Example: -------- >>> solve_inversions(2, [(5, [2, 4, 1, 3, 5]), (3, [3, 1, 2])]) [3, 2] >>> solve_inversions(1, [(4, [4, 3, 2, 1])]) [6] def merge_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 inv_count = merge_and_count(arr, temp_arr, left, mid) inv_count += merge_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_merge(arr, temp_arr, left, mid, right) return inv_count def merge_and_merge(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def count_inversions(arr): n = len(arr) temp_arr = [0] * n return merge_and_count(arr, temp_arr, 0, n - 1) results = [] for case in test_cases: n, arr = case inv_count = count_inversions(arr) results.append(inv_count) return results from typing import List, Tuple def test_case_1(): test_input = (2, [(5, [2, 4, 1, 3, 5]), (3, [3, 1, 2])]) expected = [3, 2] assert solve_inversions(*test_input) == expected def test_case_2(): test_input = (1, [(4, [4, 3, 2, 1])]) expected = [6] assert solve_inversions(*test_input) == expected def test_case_3(): test_input = (1, [(5, [5, 4, 3, 2, 1])]) expected = [10] assert solve_inversions(*test_input) == expected def test_case_4(): test_input = (1, [(7, [1, 2, 3, 4, 5, 6, 7])]) expected = [0] assert solve_inversions(*test_input) == expected def test_case_5(): test_input = (1, [(6, [1, 3, 5, 2, 4, 6])]) expected = [3] assert solve_inversions(*test_input) == expected","solution":"def merge_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 inv_count = merge_and_count(arr, temp_arr, left, mid) inv_count += merge_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_merge(arr, temp_arr, left, mid, right) return inv_count def merge_and_merge(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def count_inversions(arr): n = len(arr) temp_arr = [0] * n return merge_and_count(arr, temp_arr, 0, n - 1) def solve_inversions(num_cases, test_cases): results = [] for case in test_cases: n, arr = case inv_count = count_inversions(arr) results.append(inv_count) return results"},{"question":"def splitArray(nums: List[int], k: int) -> int: You are given an integer array nums sorted in non-decreasing order and an integer k. Your task is to split the array into exactly k non-empty continuous subarrays such that the largest sum among these subarrays is minimized. Return the minimized largest sum. >>> splitArray([7, 2, 5, 10, 8], 2) 18 >>> splitArray([1, 2, 3, 4, 5], 2) 9 >>> splitArray([1, 4, 4], 3) 4 from solution import splitArray def test_example_1(): nums = [7, 2, 5, 10, 8] k = 2 assert splitArray(nums, k) == 18 def test_example_2(): nums = [1, 2, 3, 4, 5] k = 2 assert splitArray(nums, k) == 9 def test_example_3(): nums = [1, 4, 4] k = 3 assert splitArray(nums, k) == 4 def test_single_element(): nums = [10] k = 1 assert splitArray(nums, k) == 10 def test_all_elements_equal(): nums = [5, 5, 5, 5] k = 2 assert splitArray(nums, k) == 10 def test_larger_input(): nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] k = 5 assert splitArray(nums, k) == 15","solution":"def splitArray(nums, k): def can_split(mid): current_sum = 0 partitions = 1 for num in nums: if current_sum + num > mid: partitions += 1 current_sum = num if partitions > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_split(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def reverse_words_with_punctuation(s: str) -> str: Takes a string of words separated by a single space and reverses the letters in every word while maintaining the order of the words and retaining punctuation in their original positions. >>> reverse_words_with_punctuation(\\"Hello, World!\\") == \\"olleH, dlroW!\\" >>> reverse_words_with_punctuation(\\"The quick brown. fox jumps, over!\\") == \\"ehT kciuq nworb. xof spmuj, revo!\\" >>> reverse_words_with_punctuation(\\"Keep, track! of punctuation.\\") == \\"peeK, kcart! fo noitautcnup.\\" >>> reverse_words_with_punctuation(\\"Hello\\") == \\"olleH\\" >>> reverse_words_with_punctuation(\\"!!!\\") == \\"!!!\\" >>> reverse_words_with_punctuation(\\"A man, a plan, a canal, Panama!\\") == \\"A nam, a nalp, a lanac, amanaP!\\" >>> reverse_words_with_punctuation(\\"\\") == \\"\\"","solution":"import re def reverse_words_with_punctuation(s): Takes a string of words separated by a single space and reverses the letters in every word while maintaining the order of the words and retaining punctuation in their original positions. def reverse_word(word): # Extract letters and reverse them letters = ''.join(re.findall(r'[a-zA-Z]', word)) reversed_letters = letters[::-1] # Replace letters back into their positions in the word result = [] letter_index = 0 for char in word: if char.isalpha(): result.append(reversed_letters[letter_index]) letter_index += 1 else: result.append(char) return ''.join(result) words = s.split(' ') reversed_words = [reverse_word(word) for word in words] return ' '.join(reversed_words)"},{"question":"def generate_unique_pairs(n): Generates all unique pairs (a, b) for given n students, where 1 <= a < b <= n. >>> generate_unique_pairs(3) == [(1, 2), (1, 3), (2, 3)] >>> generate_unique_pairs(4) == [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] pass def solve(t, test_cases): Process multiple test cases to generate unique pairs for each number of students. >>> solve(2, [3, 4]) == [ >>> [(1, 2), (1, 3), (2, 3)], >>> [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] >>> ] pass","solution":"def generate_unique_pairs(n): Generates all unique pairs (a, b) for given n students, where 1 <= a < b <= n. pairs = [] for a in range(1, n): for b in range(a + 1, n + 1): pairs.append((a, b)) return pairs def solve(t, test_cases): Process multiple test cases to generate unique pairs for each number of students. result = [] for n in test_cases: pairs = generate_unique_pairs(n) result.append(pairs) return result"},{"question":"def max_sum_less_than_k(nums, k): Returns the maximum possible sum of two distinct elements from the array nums that adds up to less than k. If no such elements exist, return -1. >>> max_sum_less_than_k([34, 23, 1, 24, 75, 33, 54, 8], 60) 58 >>> max_sum_less_than_k([10, 20, 30], 15) -1","solution":"def max_sum_less_than_k(nums, k): Returns the maximum possible sum of two distinct elements from the array nums that adds up to less than k. If no such elements exist, return -1. nums.sort() left, right = 0, len(nums) - 1 max_sum = -1 while left < right: current_sum = nums[left] + nums[right] if current_sum < k: max_sum = max(max_sum, current_sum) left += 1 else: right -= 1 return max_sum"},{"question":"def convert_to_roman(num): Converts an integer to its Roman numeral representation. :param num: int - an integer between 1 and 3999 inclusive :return: str - Roman numeral representation of the given integer >>> convert_to_roman(3) 'III' >>> convert_to_roman(58) 'LVIII' >>> convert_to_roman(1994) 'MCMXCIV' pass def test_convert_to_roman_small_numbers(): assert convert_to_roman(1) == \\"I\\" assert convert_to_roman(3) == \\"III\\" assert convert_to_roman(4) == \\"IV\\" assert convert_to_roman(9) == \\"IX\\" def test_convert_to_roman_medium_numbers(): assert convert_to_roman(58) == \\"LVIII\\" assert convert_to_roman(199) == \\"CXCIX\\" assert convert_to_roman(276) == \\"CCLXXVI\\" def test_convert_to_roman_large_numbers(): assert convert_to_roman(3999) == \\"MMMCMXCIX\\" assert convert_to_roman(1987) == \\"MCMLXXXVII\\" assert convert_to_roman(2022) == \\"MMXXII\\" def test_convert_to_roman_boundaries(): assert convert_to_roman(1) == \\"I\\" assert convert_to_roman(3999) == \\"MMMCMXCIX\\"","solution":"def convert_to_roman(num): Converts an integer to its Roman numeral representation. :param num: int - an integer between 1 and 3999 inclusive :return: str - Roman numeral representation of the given integer val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num"},{"question":"def generate_grid(N: int) -> List[List[int]]: Generates an N x N grid where each row and each column have at least one active cell (1). >>> generate_grid(3) [[1, 0, 0], [0, 1, 0], [0, 0, 1]] >>> generate_grid(4) [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]] >>> generate_grid(1) [[1]]","solution":"def generate_grid(N): Generates an N x N grid where each row and each column have at least one active cell (1). The simplest way to achieve this is by placing the 1s on the diagonal. :param N: The size of the grid :return: A list of lists representing the N x N grid grid = [[0 for _ in range(N)] for _ in range(N)] for i in range(N): grid[i][i] = 1 return grid"},{"question":"def transform_strings(test_cases: List[Tuple[str, str]]) -> List[int]: Given a list of tuples, each containing two strings (s1, s2), return a list of the minimum number of operations required to transform s1 into s2. >>> transform_strings([(\\"horse\\", \\"ros\\"), (\\"intention\\", \\"execution\\")]) [3, 5] >>> transform_strings([(\\"a\\", \\"ab\\"), (\\"abc\\", \\"abcd\\")]) [1, 1] >>> transform_strings([(\\"ab\\", \\"a\\"), (\\"abcd\\", \\"abc\\")]) [1, 1] >>> transform_strings([(\\"a\\", \\"b\\"), (\\"abc\\", \\"abd\\")]) [1, 1] >>> transform_strings([(\\"abc\\", \\"yabd\\"), (\\"kitten\\", \\"sitting\\")]) [2, 3] >>> transform_strings([(\\"\\", \\"abc\\"), (\\"abc\\", \\"\\")]) [3, 3] >>> transform_strings([(\\"abc\\", \\"abc\\"), (\\"\\", \\"\\")]) [0, 0]","solution":"def min_steps(s1, s2): Returns the minimum number of steps required to transform s1 into s2. # Length of the strings m, n = len(s1), len(s2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with base cases for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Insert all characters of s2 elif j == 0: dp[i][j] = i # Remove all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n] def transform_strings(test_cases): Given a list of tuples, each containing two strings (s1, s2), return a list of the minimum number of operations required to transform s1 into s2. results = [] for s1, s2 in test_cases: results.append(min_steps(s1, s2)) return results"},{"question":"from typing import List, Tuple def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks. >>> max_non_overlapping_tasks([(1, 3), (2, 4), (3, 5)]) == 2 >>> max_non_overlapping_tasks([(5, 9), (1, 2), (3, 7), (4, 6)]) == 2 pass","solution":"from typing import List, Tuple def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks. # Sort tasks by their end times tasks.sort(key=lambda x: x[1]) # Initialize variables max_tasks = 0 current_end_time = 0 # Iterate over sorted tasks for start, end in tasks: if start >= current_end_time: max_tasks += 1 current_end_time = end return max_tasks"},{"question":"def tree_statistics(N, heights): Computes and returns the height of the shortest tree, the height of the tallest tree, and the average height of the trees rounded down to the nearest integer. Parameters: N (int): The number of trees. heights (list of int): List of tree heights. Returns: tuple: (shortest_height, tallest_height, average_height) pass def test_tree_statistics_all_same_height(): assert tree_statistics(3, [5, 5, 5]) == (5, 5, 5) def test_tree_statistics_different_heights(): assert tree_statistics(4, [3, 6, 9, 12]) == (3, 12, 7) def test_tree_statistics_two_trees(): assert tree_statistics(2, [100, 200]) == (100, 200, 150) def test_tree_statistics_single_tree(): assert tree_statistics(1, [10]) == (10, 10, 10) def test_tree_statistics_large_dataset(): heights = [i * 10 for i in range(1, 101)] assert tree_statistics(100, heights) == (10, 1000, 505) def test_tree_statistics_varied_heights(): assert tree_statistics(5, [10, 20, 30, 40, 50]) == (10, 50, 30)","solution":"import math def tree_statistics(N, heights): Computes and returns the height of the shortest tree, the height of the tallest tree, and the average height of the trees rounded down to the nearest integer. Parameters: N (int): The number of trees. heights (list of int): List of tree heights. Returns: tuple: (shortest_height, tallest_height, average_height) shortest_height = min(heights) tallest_height = max(heights) average_height = math.floor(sum(heights) / N) return shortest_height, tallest_height, average_height"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_left(self, value): self.left = TreeNode(value) return self.left def insert_right(self, value): self.right = TreeNode(value) return self.right class Tom: def __init__(self): self.root = None def insert(self, value): Inserts a node with the given value in the binary search tree. def _insert(self, node, value): Helper function for inserting a node in the binary search tree. def sum(self): Computes and returns the sum of all node values in the tree. def _sum(self, node): Helper function to compute the sum of all node values in the tree. def inorder(self): Returns a list of node values in inorder traversal (left, root, right). def _inorder(self, node, result): Helper function for inorder traversal. def preorder(self): Returns a list of node values in preorder traversal (root, left, right). def _preorder(self, node, result): Helper function for preorder traversal. def postorder(self): Returns a list of node values in postorder traversal (left, right, root). def _postorder(self, node, result): Helper function for postorder traversal. def execute(self, command): Executes a command on the binary search tree. from solution import TreeNode, Tom def test_insert_and_sum(): tom = Tom() tom.execute('insert 5') tom.execute('insert 3') tom.execute('insert 7') assert tom.execute('sum') == 15 def test_inorder_traversal(): tom = Tom() tom.execute('insert 5') tom.execute('insert 3') tom.execute('insert 7') assert tom.execute('inorder') == [3, 5, 7] def test_preorder_traversal(): tom = Tom() tom.execute('insert 5') tom.execute('insert 3') tom.execute('insert 7') assert tom.execute('preorder') == [5, 3, 7] def test_postorder_traversal(): tom = Tom() tom.execute('insert 5') tom.execute('insert 3') tom.execute('insert 7') assert tom.execute('postorder') == [3, 7, 5] def test_complex_tree_operations(): tom = Tom() tom.execute('insert 10') tom.execute('insert 5') tom.execute('insert 15') tom.execute('insert 3') tom.execute('insert 7') tom.execute('insert 12') tom.execute('insert 17') assert tom.execute('sum') == 69 assert tom.execute('inorder') == [3, 5, 7, 10, 12, 15, 17] assert tom.execute('preorder') == [10, 5, 3, 7, 15, 12, 17] assert tom.execute('postorder') == [3, 7, 5, 12, 17, 15, 10]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_left(self, value): self.left = TreeNode(value) return self.left def insert_right(self, value): self.right = TreeNode(value) return self.right class Tom: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.insert_left(value) else: self._insert(node.left, value) elif value > node.value: if node.right is None: node.insert_right(value) else: self._insert(node.right, value) def sum(self): return self._sum(self.root) def _sum(self, node): if node is None: return 0 return node.value + self._sum(node.left) + self._sum(node.right) def inorder(self): return self._inorder(self.root, []) def _inorder(self, node, result): if node is None: return result self._inorder(node.left, result) result.append(node.value) self._inorder(node.right, result) return result def preorder(self): return self._preorder(self.root, []) def _preorder(self, node, result): if node is None: return result result.append(node.value) self._preorder(node.left, result) self._preorder(node.right, result) return result def postorder(self): return self._postorder(self.root, []) def _postorder(self, node, result): if node is None: return result self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.value) return result def execute(self, command): parts = command.split() if parts[0] == 'insert': self.insert(int(parts[1])) elif parts[0] == 'sum': return self.sum() elif parts[0] == 'inorder': return self.inorder() elif parts[0] == 'preorder': return self.preorder() elif parts[0] == 'postorder': return self.postorder()"},{"question":"def rotate_and_validate(n: int, k: int, nums: List[int]) -> List[int]: Rotates the array \`nums\` \`k\` positions to the right and ensures that no element remains in its original position. >>> rotate_and_validate(5, 3, [1, 2, 3, 4, 5]) in [[3, 4, 5, 1, 2], [4, 5, 1, 2, 3]] >>> rotate_and_validate(4, 1, [10, 20, 30, 40]) in [[40, 10, 20, 30], [30, 40, 10, 20]] >>> rotate_and_validate(1, 0, [10]) == -1 >>> rotate_and_validate(2, 1, [1, 2]) in [[2, 1], [-1]] >>> rotate_and_validate(6, 3, [1, 2, 3, 4, 5, 6]) in [[4, 5, 6, 1, 2, 3], [5, 6, 1, 2, 3, 4]]","solution":"def rotate_and_validate(n, k, nums): Rotates the array \`nums\` \`k\` positions to the right and makes sure no element remains in its original position. if n == 1: return -1 k = k % n rotated = nums[-k:] + nums[:-k] for i in range(n): if nums[i] == rotated[i]: return -1 return rotated"},{"question":"def sort_strings_lexicographically(t: int, strings: List[str]) -> List[str]: Sort a list of strings in lexicographical order, ignoring case. Args: t: the number of strings in the list. strings: the list of strings. Returns: The sorted list of strings in lexicographical order. >>> sort_strings_lexicographically(5, [\\"apple\\", \\"Banana\\", \\"grape\\", \\"cherry\\", \\"Fig\\"]) [\\"apple\\", \\"Banana\\", \\"cherry\\", \\"Fig\\", \\"grape\\"] >>> sort_strings_lexicographically(3, [\\"Zoo\\", \\"apple\\", \\"Zebra\\"]) [\\"apple\\", \\"Zebra\\", \\"Zoo\\"] >>> sort_strings_lexicographically(4, [\\"dog\\", \\"cat\\", \\"bat\\", \\"ant\\"]) [\\"ant\\", \\"bat\\", \\"cat\\", \\"dog\\"] >>> sort_strings_lexicographically(3, [\\"A\\", \\"b\\", \\"a\\"]) [\\"A\\", \\"a\\", \\"b\\"] >>> sort_strings_lexicographically(0, []) []","solution":"def sort_strings_lexicographically(t, strings): Sorts a list of strings in lexicographical order ignoring case. Parameters: t (int): The number of strings in the list. strings (List[str]): The list of strings. Returns: List[str]: The sorted list of strings. return sorted(strings, key=lambda s: s.lower())"},{"question":"import threading import time class Fork: def __init__(self): self.lock = threading.Lock() class Philosopher(threading.Thread): def __init__(self, index, leftFork, rightFork, eatTime, thinkTime, maxRounds): threading.Thread.__init__(self) self.index = index self.name = f\\"Philosopher {index}\\" self.leftFork = leftFork self.rightFork = rightFork self.eatTime = eatTime self.thinkTime = thinkTime self.maxRounds = maxRounds def run(self): rounds = 0 while self.maxRounds == -1 or rounds < self.maxRounds: print(f\\"{self.name} is Thinking\\") time.sleep(self.thinkTime) firstFork, secondFork = (self.leftFork, self.rightFork) if self.index % 2 == 0 else (self.rightFork, self.leftFork) with firstFork.lock: with secondFork.lock: print(f\\"{self.name} is Eating\\") time.sleep(self.eatTime) rounds += 1 def diningPhilosophers(n, eatTime, thinkTime, maxRounds): Simulates the dining philosophers problem where philosophers alternately think and eat. Args: n (int): Number of philosophers (and forks). eatTime (int): Time in seconds a philosopher spends eating. thinkTime (int): Time in seconds a philosopher spends thinking. maxRounds (int): Number of rounds a philosopher will try to eat. -1 for infinite. >>> diningPhilosophers(3, 5, 3, 2) Philosopher 0 is Thinking Philosopher 1 is Thinking Philosopher 2 is Thinking Philosopher 0 is Eating Philosopher 1 is Eating Philosopher 2 is Eating ... forks = [Fork() for _ in range(n)] philosophers = [Philosopher(i, forks[i], forks[(i+1) % n], eatTime, thinkTime, maxRounds) for i in range(n)] for philosopher in philosophers: philosopher.start() for philosopher in philosophers: philosopher.join()","solution":"import threading import time class Fork: def __init__(self): self.lock = threading.Lock() class Philosopher(threading.Thread): def __init__(self, index, leftFork, rightFork, eatTime, thinkTime, maxRounds): threading.Thread.__init__(self) self.index = index self.name = f\\"Philosopher {index}\\" self.leftFork = leftFork self.rightFork = rightFork self.eatTime = eatTime self.thinkTime = thinkTime self.maxRounds = maxRounds def run(self): rounds = 0 while self.maxRounds == -1 or rounds < self.maxRounds: print(f\\"{self.name} is Thinking\\") time.sleep(self.thinkTime) firstFork, secondFork = (self.leftFork, self.rightFork) if self.index % 2 == 0 else (self.rightFork, self.leftFork) with firstFork.lock: with secondFork.lock: print(f\\"{self.name} is Eating\\") time.sleep(self.eatTime) rounds += 1 def diningPhilosophers(n, eatTime, thinkTime, maxRounds): forks = [Fork() for _ in range(n)] philosophers = [Philosopher(i, forks[i], forks[(i+1) % n], eatTime, thinkTime, maxRounds) for i in range(n)] for philosopher in philosophers: philosopher.start() for philosopher in philosophers: philosopher.join()"},{"question":"def memoize_decorator(func): Memoization decorator to cache function results. # Implement the memoize decorator return func @memoize_decorator def fib(n): Returns the nth Fibonacci number. >>> fib(0) 0 >>> fib(1) 1 >>> fib(2) 1 >>> fib(3) 2 >>> fib(50) 12586269025 if n <= 0: return 0 elif n == 1: return 1 else: return fib(n - 1) + fib(n - 2) @memoize_decorator def factorial(n): Returns the factorial of n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(10) 3628800 if n == 0: return 1 else: return n * factorial(n - 1)","solution":"def memoize_decorator(func): Memoization decorator to cache function results. cache = {} def memoized_func(x): if x not in cache: cache[x] = func(x) return cache[x] return memoized_func @memoize_decorator def fib(n): Returns the nth Fibonacci number. if n <= 0: return 0 elif n == 1: return 1 else: return fib(n - 1) + fib(n - 2)"},{"question":"def max_efficient_days(hours: List[int], T: int, K: int) -> int: Calculate the maximum number of days an employee could be considered to have worked efficiently. :param hours: List of integers representing hours worked each day. :param T: Minimum hours needed to consider a day worked efficiently. :param K: Number of consecutive days where the special technique can be applied. :return: Maximum number of days worked efficiently. >>> max_efficient_days([6, 4, 8, 7, 5, 9, 3], 6, 3) 5 >>> max_efficient_days([1, 2, 3, 4, 2, 1, 0], 5, 2) 2 >>> max_efficient_days([8, 9, 7, 10, 11, 7, 12], 6, 3) 7 >>> max_efficient_days([1, 1, 1, 1, 1, 1, 1], 2, 1) 1 >>> max_efficient_days([24, 24, 24, 24, 24, 24, 24], 24, 7) 7 >>> max_efficient_days([5, 5, 5, 5, 5, 5, 5], 5, 3) 7","solution":"def max_efficient_days(hours, T, K): Calculate the maximum number of days an employee could be considered to have worked efficiently. :param hours: List of integers representing hours worked each day. :param T: Minimum hours needed to consider a day worked efficiently. :param K: Number of consecutive days where the special technique can be applied. :return: Maximum number of days worked efficiently. n = len(hours) current_efficiency_count = sum(1 for hour in hours if hour >= T) max_efficiency_count = current_efficiency_count for i in range(n - K + 1): additional_efficiency = 0 for j in range(i, i + K): if hours[j] < T: additional_efficiency += 1 total_efficiency = current_efficiency_count + additional_efficiency for j in range(i, i + K): if hours[j] >= T: total_efficiency -= 1 max_efficiency_count = max(max_efficiency_count, total_efficiency) return max_efficiency_count"},{"question":"def search_matrix(m: int, n: int, flattened_matrix: List[int], target: int) -> bool: Searches for the target value in the matrix represented by the flattened_matrix of size m x n. Returns True if the target is found, otherwise False. >>> search_matrix(3, 3, [1, 4, 7, 2, 5, 8, 3, 6, 9], 5) True >>> search_matrix(3, 3, [1, 4, 7, 2, 5, 8, 3, 6, 9], 10) False >>> search_matrix(1, 1, [1], 1) True >>> search_matrix(1, 1, [1], 2) False","solution":"def search_matrix(m, n, flattened_matrix, target): Searches for the target value in the matrix represented by the flattened_matrix of size m x n. Returns True if the target is found, otherwise False. # Convert the flattened list into a matrix form matrix = [] index = 0 for i in range(m): row = flattened_matrix[index:index+n] matrix.append(row) index += n # Start search from top right corner row = 0 col = n - 1 while row < m and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def findSingle(nums: List[int]) -> int: Finds the single element in the array where every element appears exactly three times except for one, which appears exactly once. :param nums: List of integers :return: The single integer that appears exactly once # Your code here from typing import List def test_findSingle(): assert findSingle([2, 2, 3, 2]) == 3 assert findSingle([0, 1, 0, 1, 0, 1, 99]) == 99 assert findSingle([30000, 500, 100, 30000, 100, 30000, 100]) == 500 assert findSingle([7, 7, 7, 8]) == 8 assert findSingle([1, 2, 2, 2]) == 1 def test_findSingle_single_number(): # Test when a single number is the only element in the list assert findSingle([42]) == 42 def test_findSingle_large_input(): # Test a large input size large_input = [i for i in range(1, 10001) for _ in range(3)] + [123456] assert findSingle(large_input) == 123456","solution":"def findSingle(nums): Finds the single element in the array where every element appears exactly three times except for one, which appears exactly once. :param nums: List of integers :return: The single integer that appears exactly once one = two = 0 for num in nums: # add num to \`one\` if num has not been added to \`two\` one = (one ^ num) & ~two # add num to \`two\` if num has not been added to \`one\` two = (two ^ num) & ~one return one"},{"question":"def min_edit_distance(str1: str, str2: str) -> int: Returns the minimum edit distance between str1 and str2. >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> min_edit_distance(\\"abc\\", \\"abc\\") 0 >>> min_edit_distance(\\"a\\", \\"abc\\") 2 >>> min_edit_distance(\\"abcd\\", \\"ab\\") 2 >>> min_edit_distance(\\"abc\\", \\"xyz\\") 3 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_edit_distance(str1, str2): Returns the minimum edit distance between str1 and str2. m, n = len(str1), len(str2) # Create a dp array of size (m+1) x (n+1) dp = [[0] * (n+1) for _ in range(m+1)] # Initialize the dp array for i in range(m+1): for j in range(n+1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return dp[m][n]"},{"question":"def convert(s: str, numRows: int) -> str: Convert a string into a zigzag pattern on a given number of rows. Args: s (str): input string numRows (int): number of rows for zigzag pattern Returns: str: the string read in a zigzag pattern row by row >>> convert(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 1) == \\"PAYPALISHIRING\\" >>> convert(\\"PAYPALISHIRING\\", 14) == \\"PAYPALISHIRING\\" >>> convert(\\"PAYPALISHIRING\\", 2) == \\"PYAIHRNAPLSIIG\\" >>> convert(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\" >>> convert(\\"\\", 3) == \\"\\"","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s rows = [''] * min(numRows, len(s)) cur_row, going_down = 0, False for char in s: rows[cur_row] += char if cur_row == 0 or cur_row == numRows - 1: going_down = not going_down cur_row += 1 if going_down else -1 return ''.join(rows)"},{"question":"def generate_primes(n: int) -> List[int]: Generates all prime numbers up to and including n. Parameters: n (int): The upper limit to generate prime numbers. Returns: List[int]: A list of prime numbers up to and including n. Examples: >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> generate_primes(1) []","solution":"def generate_primes(n): Generates all prime numbers up to and including n. Parameters: n (int): The upper limit to generate prime numbers. Returns: List[int]: A list of prime numbers up to and including n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(n + 1) if sieve[num]]"},{"question":"from typing import List def is_valid_hexadecimal(s: str) -> bool: Checks if the given string is a valid hexadecimal number. A valid hexadecimal number can be prefixed with \\"0x\\" or \\"0X\\" (case insensitive), and must consist of digits [0-9] and letters [a-f] or [A-F]. Parameters: s (str): The string to check. Returns: bool: True if the string is a valid hexadecimal number, False otherwise. Examples: >>> is_valid_hexadecimal(\\"0x1A3F\\") True >>> is_valid_hexadecimal(\\"1A3G\\") False >>> is_valid_hexadecimal(\\"0Xabc123\\") True","solution":"import re def is_valid_hexadecimal(s): Checks if the given string is a valid hexadecimal number. A valid hexadecimal number can be prefixed with \\"0x\\" or \\"0X\\" (case insensitive), and must consist of digits [0-9] and letters [a-f] or [A-F]. Parameters: s (str): The string to check. Returns: bool: True if the string is a valid hexadecimal number, False otherwise. pattern = re.compile(r'^(0x|0X)?[0-9a-fA-F]+') return bool(pattern.match(s))"},{"question":"def split_string(s: str) -> List[str]: Splits the string into pairs of two characters. If the string has an odd number of characters, the final pair should end with an underscore ('_'). >>> split_string('abc') ['ab', 'c_'] >>> split_string('abcdef') ['ab', 'cd', 'ef'] >>> split_string('') []","solution":"def split_string(s): Splits the string into pairs of two characters. If the string has an odd number of characters, the final pair should end with an underscore ('_'). result = [] for i in range(0, len(s), 2): pair = s[i:i+2] if len(pair) == 1: pair += '_' result.append(pair) return result"},{"question":"from typing import List, Tuple def detect_fraud(transactions: List[Tuple[str, float, int]], time_frame: int, limit: float) -> List[str]: Identify the account IDs involved in fraudulent activities, where a transaction is considered fraudulent if any transaction amount is negative or the sum of transactions for an account exceeds a given limit within a specified time frame. Args: transactions: A list of tuples, where each tuple contains: - account_id: str, a unique identifier for the account - amount: float, the amount in USD - timestamp: int, the time of the transaction in seconds since the epoch time_frame: int, the time frame in seconds for evaluating the maximum allowable sum of transaction amounts. limit: float, the maximum allowable sum of transaction amounts within the given time frame. Returns: A list of account IDs that are involved in fraudulent activities, sorted in lexicographical order. Examples: >>> transactions = [ ... (\\"acc1\\", 200.0, 1609459200), ... (\\"acc2\\", -100.0, 1609459201), ... (\\"acc1\\", 300.0, 1609459900), ... (\\"acc3\\", 400.0, 1609459905), ... (\\"acc1\\", 100.0, 1609460200), ... (\\"acc2\\", 500.0, 1609460800) ... ] >>> time_frame = 3600 >>> limit = 500.0 >>> detect_fraud(transactions, time_frame, limit) ['acc1', 'acc2'] pass # Unit tests import pytest def test_example_case(): transactions = [ (\\"acc1\\", 200.0, 1609459200), (\\"acc2\\", -100.0, 1609459201), (\\"acc1\\", 300.0, 1609459900), (\\"acc3\\", 400.0, 1609459905), (\\"acc1\\", 100.0, 1609460200), (\\"acc2\\", 500.0, 1609460800) ] time_frame = 3600 limit = 500.0 assert detect_fraud(transactions, time_frame, limit) == [\\"acc1\\", \\"acc2\\"] def test_all_legitimate_transactions(): transactions = [ (\\"acc1\\", 100.0, 1609459200), (\\"acc1\\", 200.0, 1609459300), (\\"acc1\\", 150.0, 1609459400), (\\"acc2\\", 50.0, 1609459500), (\\"acc2\\", 60.0, 1609459600), ] time_frame = 3600 limit = 600.0 assert detect_fraud(transactions, time_frame, limit) == [] def test_negative_transaction(): transactions = [ (\\"acc1\\", 100.0, 1609459200), (\\"acc1\\", -200.0, 1609459300), (\\"acc2\\", 150.0, 1609459400), (\\"acc2\\", 50.0, 1609459500), ] time_frame = 3600 limit = 500.0 assert detect_fraud(transactions, time_frame, limit) == [\\"acc1\\"] def test_sum_exceeds_limit(): transactions = [ (\\"acc1\\", 100.0, 1609459200), (\\"acc1\\", 200.0, 1609459300), (\\"acc1\\", 250.0, 1609459400), (\\"acc2\\", 50.0, 1609459500), ] time_frame = 3600 limit = 500.0 assert detect_fraud(transactions, time_frame, limit) == [\\"acc1\\"] def test_multiple_fraudulent_accounts(): transactions = [ (\\"acc1\\", 100.0, 1609459200), (\\"acc1\\", 200.0, 1609459300), (\\"acc1\\", 250.0, 1609459400), (\\"acc2\\", 50.0, 1609459500), (\\"acc2\\", -100.0, 1609459600), (\\"acc3\\", 500.0, 1609459700), (\\"acc3\\", 100.0, 1609459800), ] time_frame = 3600 limit = 500.0 assert detect_fraud(transactions, time_frame, limit) == [\\"acc1\\", \\"acc2\\", \\"acc3\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import deque, defaultdict def detect_fraud(transactions, time_frame, limit): fraudulent_accounts = set() account_transactions = defaultdict(deque) for account_id, amount, timestamp in transactions: if amount < 0: fraudulent_accounts.add(account_id) account_transactions[account_id].append((amount, timestamp)) current_sum = 0 valid_transactions = deque() while account_transactions[account_id]: t_amount, t_timestamp = account_transactions[account_id].popleft() if t_timestamp >= timestamp - time_frame: valid_transactions.append((t_amount, t_timestamp)) current_sum += t_amount account_transactions[account_id] = valid_transactions if current_sum > limit: fraudulent_accounts.add(account_id) return sorted(fraudulent_accounts)"},{"question":"def sum_of_digits(num): Returns the sum of the digits of the given number. pass def transform_array(arr): Transforms the given array according to the described rule: Each element at index i is replaced by the sum of its digits raised to the power of i. >>> transform_array([3]) [1] >>> transform_array([3, 25]) [1, 7] >>> transform_array([3, 25, 18]) [1, 7, 81] >>> transform_array([]) [] >>> transform_array([9, 34, 56, 78]) [1, 7, 121, 3375] >>> transform_array([123, 456, 789, 987]) [1, 15, 576, 13824] pass","solution":"def sum_of_digits(num): Returns the sum of the digits of the given number. return sum(int(digit) for digit in str(num)) def transform_array(arr): Transforms the given array according to the described rule: Each element at index i is replaced by the sum of its digits raised to the power of i. return [(sum_of_digits(num)) ** i for i, num in enumerate(arr)]"},{"question":"def max_non_adjacent_sum(nums: List[int]) -> int: Returns the maximum sum of a subsequence such that no two elements are adjacent. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([1, 2, 3]) 4 >>> max_non_adjacent_sum([-1, 4, -5, 4, 10]) 14 >>> max_non_adjacent_sum([-2, -1, -3]) 0 >>> max_non_adjacent_sum([10]) 10 >>> max_non_adjacent_sum([3, 10]) 10","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of a subsequence such that no two elements are adjacent. if not nums: return 0 incl = 0 # Max sum including the previous element excl = 0 # Max sum excluding the previous element for num in nums: # Current max excluding the current element new_excl = max(incl, excl) # Current max including the current element incl = excl + num excl = new_excl return max(incl, excl) def solve_problem(N, nums): return max_non_adjacent_sum(nums)"},{"question":"from typing import List def maximum_product_of_three(arr: List[int]) -> int: Given a positive integer array, find and return the maximum product of any three distinct elements. The product should be the highest possible product that can be formed from any three elements in the array. >>> maximum_product_of_three([1, 2, 3]) 6 >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([1, -4, 3, -6, 7, 0]) 168 >>> maximum_product_of_three([-4, -4, 2, 8]) 128 >>> maximum_product_of_three([-5, -6, -2, -3]) -30 >>> maximum_product_of_three([0, 0, 2, 3, 4]) 24","solution":"def maximum_product_of_three(arr): Returns the maximum product of any three distinct elements. if len(arr) < 3: raise ValueError(\\"Array must have at least three elements\\") arr.sort() # The highest product of three numbers can either be: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers (both can be negative, thus their product is positive) and the largest number max_product = max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]) return max_product"},{"question":"def filter_stock(stock_list: List[Tuple[str, int]], target: int) -> List[Tuple[str, int]]: Returns a list of items whose quantities are less than or equal to the target quantity in reverse alphabetical order. :param stock_list: List of tuples where each tuple contains the item name and its quantity :param target: Integer representing the target quantity :return: Filtered and sorted list of items in reverse alphabetical order >>> filter_stock([('Apple', 10), ('Banana', 5), ('Orange', 3), ('Pineapple', 12), ('Grapes', 8)], 8) [('Orange', 3), ('Grapes', 8), ('Banana', 5)] >>> filter_stock([('Apple', 10), ('Banana', 15), ('Orange', 13), ('Pineapple', 12), ('Grapes', 18)], 8) [] >>> filter_stock([('Apple', 1), ('Banana', 2), ('Orange', 3), ('Pineapple', 4), ('Grapes', 5)], 10) [('Pineapple', 4), ('Orange', 3), ('Grapes', 5), ('Banana', 2), ('Apple', 1)] >>> filter_stock([('Apple', 10), ('Banana', 10), ('Orange', 10), ('Pineapple', 10), ('Grapes', 10)], 10) [('Pineapple', 10), ('Orange', 10), ('Grapes', 10), ('Banana', 10), ('Apple', 10)] >>> filter_stock([], 10) []","solution":"def filter_stock(stock_list, target): Returns a list of items whose quantities are less than or equal to the target quantity in reverse alphabetical order. :param stock_list: List of tuples where each tuple contains the item name and its quantity :param target: Integer representing the target quantity :return: Filtered and sorted list of items in reverse alphabetical order filtered_list = [(item, quantity) for item, quantity in stock_list if quantity <= target] return sorted(filtered_list, key=lambda x: x[0], reverse=True)"},{"question":"def longest_substr_two_distinct(s: str) -> str: Returns the longest substring with at most two distinct characters. >>> longest_substr_two_distinct(\\"eceba\\") \\"ece\\" >>> longest_substr_two_distinct(\\"ccaabbb\\") \\"aabbb\\" >>> longest_substr_two_distinct(\\"a\\") \\"a\\" >>> longest_substr_two_distinct(\\"aa\\") \\"aa\\" >>> longest_substr_two_distinct(\\"abc\\") \\"ab\\" # or \\"bc\\" >>> longest_substr_two_distinct(\\"\\") \\"\\" >>> longest_substr_two_distinct(\\"ab\\" * 50000) \\"ab\\" * 50000 >>> longest_substr_two_distinct(\\"abcabcabc\\") \\"ab\\" # or \\"bc\\" or \\"ca\\" >>> longest_substr_two_distinct(\\"abacccccc\\") \\"acccccc\\"","solution":"def longest_substr_two_distinct(s: str) -> str: Returns the longest substring with at most two distinct characters. n = len(s) if n < 3: return s # Use two pointers technique left = 0 right = 0 max_length = 2 start = 0 # HashMap to keep track of the last occurrence of each character hash_map = {} while right < n: # Add the character at the right pointer to the hash map hash_map[s[right]] = right right += 1 # Check if there are more than 2 distinct characters in the current window if len(hash_map) > 2: # Remove the leftmost character del_idx = min(hash_map.values()) del hash_map[s[del_idx]] left = del_idx + 1 # Update max_length and starting index of the longest substring if right - left > max_length: max_length = right - left start = left return s[start:start + max_length]"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers nums and an integer target, return the two numbers such that they add up to the target. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: List[int]: A list containing the two integers that add up to the target. Examples: >>> two_sum([2, 7, 11, 15], 9) [2, 7] >>> two_sum([3, 2, 4], 6) [2, 4] >>> two_sum([3, 3], 6) [3, 3] from solution import two_sum def test_two_sum_case1(): assert sorted(two_sum([2, 7, 11, 15], 9)) == [2, 7] def test_two_sum_case2(): assert sorted(two_sum([3, 2, 4], 6)) == [2, 4] def test_two_sum_case3(): assert sorted(two_sum([3, 3], 6)) == [3, 3] def test_two_sum_case4(): assert sorted(two_sum([1, 5, 3, 4], 8)) == [3, 5] def test_two_sum_large_numbers(): assert sorted(two_sum([1000000, 999999], 1999999)) == [999999, 1000000]","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, return the two numbers such that they add up to the target. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: List[int]: A list containing the two integers that add up to the target. num_dict = {} for num in nums: complement = target - num if complement in num_dict: return [complement, num] num_dict[num] = True # Example usage: # nums = [2, 7, 11, 15], target = 9 # Output: [2, 7]"},{"question":"def find_words(sentence: str): Given a sentence, returns a dictionary with word lengths as keys and lists of words of that length as values. >>> find_words(\\"\\") == {} >>> find_words(\\"Hello\\") == {5: ['Hello']} >>> find_words(\\"The quick brown fox jumps over the lazy dog\\") == { 3: ['The', 'fox', 'the', 'dog'], 5: ['quick', 'brown', 'jumps'], 4: ['over', 'lazy'] } >>> find_words(\\"Hello hello\\") == {5: ['Hello', 'hello']} >>> find_words(\\"A quick brown fox jumps over the lazy dog\\") == { 1: ['A'], 5: ['quick', 'brown', 'jumps'], 3: ['fox', 'the', 'dog'], 4: ['over', 'lazy'] } >>> find_words(\\"Cat bat mat\\") == {3: ['Cat', 'bat', 'mat']}","solution":"def find_words(sentence: str): Given a sentence, returns a dictionary with word lengths as keys and lists of words of that length as values. if not sentence: return {} words = sentence.split() word_dict = {} for word in words: length = len(word) if length in word_dict: word_dict[length].append(word) else: word_dict[length] = [word] return word_dict"},{"question":"def uniquePaths(m: int, n: int) -> int: Calculates the number of unique paths a robot can take to reach from the top-left corner to the bottom-right corner of an m x n grid. The robot can only move either down or right at any point in time. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: Number of unique paths from top-left to bottom-right corner. >>> uniquePaths(3, 7) 28 >>> uniquePaths(3, 2) 3 >>> uniquePaths(1, 1) 1 >>> uniquePaths(100, 100) 22750883079422934966181954039568885395604168260154104734000 >>> uniquePaths(2, 2) 2 >>> uniquePaths(3, 3) 6 >>> uniquePaths(5, 5) 70 >>> uniquePaths(20, 20) 35345263800","solution":"def uniquePaths(m, n): Returns the number of unique paths for a robot to move from the top-left corner to the bottom-right corner of an m x n grid. :param m: Number of rows in the grid :param n: Number of columns in the grid :return: Number of unique paths from top-left to bottom-right corner if m == 1 or n == 1: return 1 dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"from typing import List def paint_wall(sections: List[str]) -> List[str]: Determines if it's possible to paint the wall sections such that no two adjacent sections are painted the same color using up to three different colors. Args: sections (List[str]): List of wall sections. Returns: List[str]: A possible painting scheme as a list of colors corresponding to each wall section or an empty list if it's not possible. >>> paint_wall([]) [] >>> paint_wall([\\"A\\"]) [\\"Red\\"] >>> paint_wall([\\"A\\", \\"B\\"]) [\\"Red\\", \\"Green\\"] >>> paint_wall([\\"A\\", \\"B\\", \\"C\\"]) [\\"Red\\", \\"Green\\", \\"Red\\"] >>> paint_wall([\\"A\\", \\"B\\", \\"C\\", \\"D\\"]) [\\"Red\\", \\"Green\\", \\"Red\\", \\"Green\\"]","solution":"from typing import List def paint_wall(sections: List[str]) -> List[str]: Determines if it's possible to paint the wall sections such that no two adjacent sections are painted the same color using up to three different colors. Args: sections (List[str]): List of wall sections. Returns: List[str]: A possible painting scheme as a list of colors corresponding to each wall section or an empty list if it's not possible. if not sections: return [] n = len(sections) colors = [\\"Red\\", \\"Green\\", \\"Blue\\"] scheme = [] for i in range(n): for color in colors: if i > 0 and scheme[-1] == color: continue scheme.append(color) break if i > 0 and scheme[i] == scheme[i - 1]: return [] return scheme"},{"question":"def largestRectangleArea(heights): Given an array of integers representing the heights of skyscrapers, returns the maximum area of a rectangle that can be formed using the heights of the skyscrapers. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([4]) 4 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([2, 4, 2, 1, 10, 6, 10, 5]) 20 >>> largestRectangleArea([3, 3]) 6","solution":"def largestRectangleArea(heights): Given an array of integers representing the heights of skyscrapers, returns the maximum area of a rectangle that can be formed using the heights of the skyscrapers. stack = [] max_area = 0 index = 0 while index < len(heights): # If the current building height is greater than the building height at index of stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] stack as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # update max_area, if needed max_area = max(max_area, area) # Now pop the remaining bars from stack and calculate area with every popped bar as the smallest bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def filter_items_by_category(items, allowed_categories): Filters the items based on the allowed categories. Parameters: items (list of tuples): A list where each tuple contains an item and its category. allowed_categories (list of str): A list of allowed categories. Returns: list: A list of items that belong to one of the allowed categories. >>> items = [('apple', 'fruit'), ('carrot', 'vegetable'), ('orange', 'fruit'), ('celery', 'vegetable')] >>> allowed_categories = ['fruit', 'vegetable'] >>> filter_items_by_category(items, allowed_categories) ['apple', 'carrot', 'orange', 'celery'] >>> items = [('apple', 'fruit'), ('carrot', 'vegetable'), ('orange', 'fruit'), ('celery', 'vegetable')] >>> allowed_categories = ['fruit'] >>> filter_items_by_category(items, allowed_categories) ['apple', 'orange'] >>> items = [('apple', 'fruit'), ('carrot', 'vegetable'), ('orange', 'fruit'), ('celery', 'vegetable')] >>> allowed_categories = ['dairy'] >>> filter_items_by_category(items, allowed_categories) [] >>> items = [('apple', 'fruit'), ('carrot', 'vegetable'), ('cheese', 'dairy'), ('milk', 'dairy')] >>> allowed_categories = ['fruit', 'dairy'] >>> filter_items_by_category(items, allowed_categories) ['apple', 'cheese', 'milk'] >>> items = [] >>> allowed_categories = ['fruit', 'vegetable'] >>> filter_items_by_category(items, allowed_categories) [] >>> items = [('apple', 'fruit'), ('carrot', 'vegetable')] >>> allowed_categories = [] >>> filter_items_by_category(items, allowed_categories) []","solution":"def filter_items_by_category(items, allowed_categories): Filters the items based on the allowed categories. Parameters: items (list of tuples): A list where each tuple contains an item and its category. allowed_categories (list of str): A list of allowed categories. Returns: list: A list of items that belong to one of the allowed categories. allowed_set = set(allowed_categories) result = [item for item, category in items if category in allowed_set] return result"},{"question":"from typing import List def categorize_books(titles: List[str]) -> List[str]: Categorize books based on the presence of the word 'magic' in the title. >>> categorize_books([\\"the magic of thinking big\\", \\"a brief history of time\\", \\"magic in the air\\"]) [\\"Magical Book\\", \\"Ordinary Book\\", \\"Magical Book\\"] >>> categorize_books([\\"magic kingdom\\", \\"magic and mystery\\", \\"the power of magic\\"]) [\\"Magical Book\\", \\"Magical Book\\", \\"Magical Book\\"] >>> categorize_books([\\"the great gatsby\\", \\"to kill a mockingbird\\", \\"pride and prejudice\\"]) [\\"Ordinary Book\\", \\"Ordinary Book\\", \\"Ordinary Book\\"] >>> categorize_books([\\"MAGIC\\", \\"it is all about magic\\", \\"and that's it\\", \\"m\\"]) [\\"Ordinary Book\\", \\"Magical Book\\", \\"Ordinary Book\\", \\"Ordinary Book\\"]","solution":"def categorize_books(titles): Categorize books based on the presence of the word 'magic' in the title. results = [] for title in titles: if 'magic' in title: results.append(\\"Magical Book\\") else: results.append(\\"Ordinary Book\\") return results"},{"question":"import heapq from typing import List def kth_smallest(mat: List[List[int]], k: int) -> int: Finds the kth smallest element in an n x n matrix where each row and column is sorted. >>> kth_smallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kth_smallest([ ... [1, 2], ... [1, 3] ... ], 2) 1","solution":"import heapq def kth_smallest(mat, k): Finds the kth smallest element in an n x n matrix where each row and column is sorted. n = len(mat) min_heap = [] # Initialize the heap with the smallest element of each row for r in range(min(k, n)): heapq.heappush(min_heap, (mat[r][0], r, 0)) # Iterate k-1 times to pop the smallest element from the heap # and add the next element from the same row to the heap for i in range(k - 1): val, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (mat[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths in a grid with obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> unique_paths_with_obstacles([ ... [0, 1], ... [0, 1], ... [0, 0] ... ]) == 1 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [0] ... ]) == 1 >>> unique_paths_with_obstacles([ ... [1] ... ]) == 0 pass","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths in a grid with obstacles. :param grid: List[List[int]] - 2D grid where 0 is free space and 1 is an obstacle :return: int - Number of unique paths from top-left to bottom-right. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def eval_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. Parameters: expression (str): The mathematical expression to evaluate. Returns: float: The result of the evaluated expression. Examples: >>> eval_expression(\\"3 + 5\\") 8.0 >>> eval_expression(\\"10 + 2 * 6\\") 22.0 >>> eval_expression(\\"100 * ( 2 + 12 ) / 14\\") 100.0 >>> eval_expression(\\"(2.5 * 4) - (2 + 3.5)\\") 4.5","solution":"def eval_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. Parameters: expression (str): The mathematical expression to evaluate. Returns: float: The result of the evaluated expression. import re def parse_expression(expression): # Remove spaces for easier processing expression = expression.replace(\\" \\", \\"\\") # Tokenize the expression tokens = re.findall(r'd*.d+|d+|[+-*/()]', expression) # Process tokens with operator precedence def shunting_yard(tokens): precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output_queue = [] operator_stack = [] for token in tokens: if re.match(r'd*.d+|d+', token): output_queue.append(float(token)) elif token in \\"+-*/\\": while (operator_stack and operator_stack[-1] in precedence and precedence[operator_stack[-1]] >= precedence[token]): output_queue.append(operator_stack.pop()) operator_stack.append(token) elif token == \\"(\\": operator_stack.append(token) elif token == \\")\\": while operator_stack and operator_stack[-1] != \\"(\\": output_queue.append(operator_stack.pop()) operator_stack.pop() # pop the '(' from the stack while operator_stack: output_queue.append(operator_stack.pop()) return output_queue def evaluate_rpn(rpn): stack = [] for token in rpn: if isinstance(token, float): stack.append(token) elif token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": stack.append(a / b) return stack[0] rpn = shunting_yard(tokens) return evaluate_rpn(rpn) return parse_expression(expression)"},{"question":"def factorial(n): Calculate the factorial of a given positive integer n. Returns 1 if n is 0 or 1. If n is not a positive integer, return None. >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(-3) None >>> factorial(\\"NA\\") None >>> factorial(3.5) None >>> factorial([5]) None","solution":"def factorial(n): Calculate the factorial of a given positive integer n. Returns 1 if n is 0 or 1. If n is not a positive integer, return None. if not isinstance(n, int) or n < 0: return None if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aabbc\\") True >>> can_form_palindrome(\\"aaabbbccc\\") False >>> can_form_palindrome(\\"aabbccdde\\") True","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. from collections import Counter count = Counter(s) odd_count = 0 for freq in count.values(): if freq % 2 != 0: odd_count += 1 return odd_count <= 1"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Finds the length of the longest substring that contains at most two distinct characters. :param s: str, input string consisting of lowercase alphabets :return: int, length of the longest substring Examples: >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"aabbcc\\") 4","solution":"def length_of_longest_substring_two_distinct(s): Finds the length of the longest substring that contains at most two distinct characters. :param s: str, input string consisting of lowercase alphabets :return: int, length of the longest substring if len(s) < 3: return len(s) # Sliding window approach left = 0 max_length = 2 char_map = {} for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def fizzBuzz(n: int) -> List[str]: Returns a list of strings representing the numbers from 1 to n with: - \\"Fizz\\" for multiples of 3, - \\"Buzz\\" for multiples of 5, - \\"FizzBuzz\\" for multiples of both 3 and 5. Returns an empty list if n < 1. >>> fizzBuzz(5) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\"] >>> fizzBuzz(15) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"]","solution":"def fizzBuzz(n): Returns a list of strings representing the numbers from 1 to n with: - \\"Fizz\\" for multiples of 3, - \\"Buzz\\" for multiples of 5, - \\"FizzBuzz\\" for multiples of both 3 and 5. Returns an empty list if n < 1. if n < 1: return [] result = [] for i in range(1, n + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> List[int]: Find the position of the target in a sorted matrix. Parameters: matrix (list of list of int): The matrix of integers. target (int): The target integer. Returns: list: A list containing the row and column indices of the target or [-1, -1] if the target is not found. Examples: >>> search_matrix([ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ], 3) [0, 1] >>> search_matrix([ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ], 13) [-1, -1] >>> search_matrix([ [1, 3] ], 3) [0, 1]","solution":"def search_matrix(matrix, target): Find the position of the target in a sorted matrix. Parameters: matrix (list of list of int): The matrix of integers. target (int): The target integer. Returns: list: A list containing the row and column indices of the target or [-1, -1] if the target is not found. if not matrix or not matrix[0]: return [-1, -1] n, m = len(matrix), len(matrix[0]) left, right = 0, n * m - 1 while left <= right: mid = (left + right) // 2 mid_val = matrix[mid // m][mid % m] if mid_val == target: return [mid // m, mid % m] elif mid_val < target: left = mid + 1 else: right = mid - 1 return [-1, -1]"},{"question":"def string_lengths(words: list[str]) -> list[int]: Takes a list of strings and returns a list of integers representing the length of each string. If the input list is empty, the function should return an empty list. >>> string_lengths([\\"apple\\", \\"banana\\", \\"cherry\\"]) [5, 6, 6] >>> string_lengths([]) [] >>> string_lengths([\\"kiwi\\"]) [4] >>> string_lengths([\\"kiwi\\", \\"strawberry\\", \\"fig\\"]) [4, 10, 3] >>> string_lengths([\\"hello world\\", \\" \\"]) [11, 3] >>> string_lengths(None) Traceback (most recent call last): ... ValueError: Input list cannot be None pass","solution":"def string_lengths(words): Takes a list of strings and returns a list of integers representing the length of each string. Parameters: words (list of str): The list of strings whose lengths are to be calculated. Returns: list of int: A list of integers representing the lengths of each string. if words is None: raise ValueError(\\"Input list cannot be None\\") return [len(word) for word in words]"},{"question":"import heapq from collections import Counter def rearrange_string(s): Determine whether the given string can be transformed into a string in which no two adjacent characters are the same. If it's possible to rearrange the characters in such a manner, return the rearranged string. If it's impossible, return \\"Not posible\\". If the input is not a string, return \\"Not valid\\". Examples: >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaaabc\\") \\"Not posible\\" >>> rearrange_string(\\"aaab\\") \\"Not posible\\" >>> rearrange_string(\\"abcd\\") in [\\"abcd\\", \\"abdc\\", \\"acbd\\"] True >>> rearrange_string(\\"112233\\") in [\\"121323\\", \\"123132\\", \\"131232\\", ...] True >>> rearrange_string(1234) \\"Not valid\\"","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. Returns \\"Not posible\\" if not possible, or \\"Not valid\\" if the input is not a string. if not isinstance(s, str): return \\"Not valid\\" # Frequency counter for the characters freq = Counter(s) maxHeap = [(-count, char) for char, count in freq.items()] heapq.heapify(maxHeap) prev_count, prev_char = 0, '' result = [] while maxHeap: count, char = heapq.heappop(maxHeap) # Append current character to result result.append(char) # Since we're using max-heap as equivalent to a priority queue, we use negative count if prev_count < 0: heapq.heappush(maxHeap, (prev_count, prev_char)) count += 1 # Use one occurrence prev_count, prev_char = count, char rearranged_string = \\"\\".join(result) if len(rearranged_string) != len(s): return \\"Not posible\\" return rearranged_string"},{"question":"def balancedStringSplit(s: str) -> int: Returns the maximum number of balanced substrings from the given string s. A balanced substring contains the same number of 'L' and 'R' characters. >>> balancedStringSplit(\\"RLRRLLRLRL\\") 4 >>> balancedStringSplit(\\"RLLLLRRRLR\\") 3 >>> balancedStringSplit(\\"LLLLRRRR\\") 1","solution":"def balancedStringSplit(s): Returns the maximum number of balanced substrings from the given string s. A balanced substring contains the same number of 'L' and 'R' characters. balance = 0 count = 0 for char in s: if char == 'L': balance += 1 else: balance -= 1 if balance == 0: count += 1 return count"},{"question":"def generate_ticket(existing_tickets): Generates a unique lottery ticket number not present in the list of existing_tickets. The ticket number is a string of 6 digits where the first digit is between 1 and 9 (inclusive), and the following 5 digits are between 0 and 9 (inclusive). Parameters: existing_tickets (List[str]): A list of existing lottery ticket numbers. Returns: str: A unique lottery ticket number.","solution":"import random def generate_ticket(existing_tickets): Generates a unique lottery ticket number not present in the list of existing_tickets. The ticket number is a string of 6 digits where the first digit is between 1 and 9 (inclusive), and the following 5 digits are between 0 and 9 (inclusive). existing_set = set(existing_tickets) while True: ticket = str(random.randint(1, 9)) + ''.join(str(random.randint(0, 9)) for _ in range(5)) if ticket not in existing_set: return ticket"},{"question":"def maximum_product(nums: List[int]) -> int: Returns the maximum product of two distinct elements from the list nums. If the list has fewer than two elements, it returns None. >>> maximum_product([1, 2, 3, 4]) == 12 >>> maximum_product([-10, -20, 5, 3, -1]) == 200 >>> maximum_product([0, 4, 3, 2]) == 12 >>> maximum_product([1]) == None","solution":"def maximum_product(nums): Returns the maximum product of two distinct elements from the list nums. If the list has fewer than two elements, it returns None. if len(nums) < 2: return None nums.sort() # The maximum product can be either from the two largest numbers # or from the two smallest numbers (which might be negative) return max(nums[0] * nums[1], nums[-1] * nums[-2])"},{"question":"from collections import OrderedDict from typing import Callable def with_cache(func: Callable[[int], int]) -> Callable[[int], int]: Decorator to cache results of the function following LRU eviction policy. Args: func (Callable[[int], int]): The function to be optimized with cache. Returns: Callable[[int], int]: A new function with caching applied. # Implement the caching mechanism here pass @with_cache def expensive_function(x: int) -> int: Dummy expensive function to illustrate caching mechanism. Args: x (int): Input to the expensive function. Returns: int: Result of the expensive computation. pass # Example usage: # result = expensive_function(10) # This will compute the result # repeat_result = expensive_function(10) # This should return cached result # result = expensive_function(20) # New computation # result = expensive_function(10) # Should still use cached result # Unit Tests def test_expensive_function_initial_computation(): assert expensive_function(2) == 4 # Should compute and return 4 def test_expensive_function_return_cached_result(): # First call to cache result result = expensive_function(3) assert result == 9 # Should compute and return 9 # Second call should return cached result cached_result = expensive_function(3) assert cached_result == 9 def test_expensive_function_cache_limit(): # Calls to fill up cache expensive_function(1) expensive_function(2) expensive_function(3) expensive_function(4) expensive_function(5) # Cache is now full, next call should evict the oldest (1) assert expensive_function(6) == 36 assert expensive_function(2) == 4 # Should still be cached assert expensive_function(1) == 1 # Should recompute as it was evicted def test_expensive_function_eviction_policy(): # Refill cache expensive_function(1) expensive_function(2) expensive_function(3) expensive_function(4) expensive_function(5) # Access some elements to change their recency expensive_function(1) expensive_function(2) # Adding a new element to the cache, 3 should be evicted now assert expensive_function(6) == 36 assert expensive_function(3) == 9 # Should recompute as it was evicted def test_expensive_function_edge_cases(): assert expensive_function(0) == 0 # Edge case for zero assert expensive_function(-1) == 1 # Edge case for negative number","solution":"from collections import OrderedDict def with_cache(func): cache = OrderedDict() max_cache_size = 5 def wrapper(x): if x in cache: # Move to the end to indicate recent use cache.move_to_end(x) return cache[x] result = func(x) cache[x] = result if len(cache) > max_cache_size: # Pop the first item (least recently used) cache.popitem(last=False) return result return wrapper @with_cache def expensive_function(x): # Placeholder for an expensive computation return x * x"},{"question":"def longest_zigzag_sequence(nums: List[int]) -> int: Determine the length of the longest contiguous subsequence that forms a zigzag pattern. >>> longest_zigzag_sequence([1, 7, 4, 9, 2, 5]) == 6 >>> longest_zigzag_sequence([1, 17, 5, 10, 13, 15, 10, 5, 16, 8]) == 7 >>> longest_zigzag_sequence([44]) == 1 >>> longest_zigzag_sequence([1, 1, 1, 1]) == 1 >>> longest_zigzag_sequence([1, 3, 2, 4, 3, 5]) == 6 >>> longest_zigzag_sequence([5, 4, 3, 2, 1]) == 2 >>> longest_zigzag_sequence([1, 2, 3, 4, 5]) == 2 >>> longest_zigzag_sequence([]) == 0","solution":"def longest_zigzag_sequence(nums): if not nums: return 0 n = len(nums) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): if nums[i] > nums[i-1]: up[i] = down[i-1] + 1 down[i] = down[i-1] elif nums[i] < nums[i-1]: down[i] = up[i-1] + 1 up[i] = up[i-1] else: up[i] = up[i-1] down[i] = down[i-1] return max(up[-1], down[-1])"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Implement a simplified version of the A* algorithm to find the shortest path for navigating a robot in a 2D grid. The robot starts at (0, 0) and needs to reach the bottom-right corner (n-1, n-1). The cells marked as 0 are walkable, and those marked as 1 are obstacles. Args: grid (List[List[int]]): A 2D grid where 0 indicates a walkable cell and 1 indicates an obstacle. Returns: int: The length of the shortest path from (0, 0) to (n-1, n-1) or -1 if no path exists. Examples: >>> shortest_path([[0,0,0], [0,1,0], [0,0,0]]) 4 >>> shortest_path([[0,1], [1,0]]) -1 def test_shortest_path(): assert shortest_path([[0,0,0], [0,1,0], [0,0,0]]) == 4 assert shortest_path([[0,1], [1,0]]) == -1 assert shortest_path([[0,0,1], [1,0,1], [1,0,0]]) == 4 assert shortest_path([[0]]) == 0 assert shortest_path([[1,0,0], [0,1,0], [0,0,0]]) == -1 assert shortest_path([[0,1,1], [1,0,1], [1,1,0]]) == -1 assert shortest_path([[0,0,1,0], [0,1,0,0], [0,1,0,1], [0,0,0,0]]) == 6 assert shortest_path([[0,1,0,0], [0,1,0,1], [0,0,0,1], [1,0,0,0]]) == 6","solution":"from heapq import heappush, heappop from typing import List, Tuple def manhattan_distance(x1: int, y1: int, x2: int, y2: int) -> int: return abs(x1 - x2) + abs(y1 - y2) def shortest_path(grid: List[List[int]]) -> int: n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(0,1), (1,0), (0,-1), (-1,0)] open_set = [(0 + manhattan_distance(0, 0, n-1, n-1), 0, 0, 0)] while open_set: f, g, x, y = heappop(open_set) if (x, y) == (n-1, n-1): return g if grid[x][y] == 2: continue grid[x][y] = 2 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0: heappush(open_set, (g + 1 + manhattan_distance(nx, ny, n-1, n-1), g + 1, nx, ny)) return -1"},{"question":"def sumEverySecond(numbers: List[int]) -> int: Sums every second number in the array starting from the first element. If the array is empty or contains only one element, returns 0. Args: numbers (list): List of numbers. Returns: int: The sum of every second number starting from the first. >>> sumEverySecond([]) == 0 >>> sumEverySecond([4]) == 4 >>> sumEverySecond([1, 2, 3, 4, 5]) == 9 >>> sumEverySecond([1, 3, 5, 7, 9]) == 15 >>> sumEverySecond([2, 2, 2, 2, 2]) == 6 >>> sumEverySecond([-1, -2, -3, -4, -5]) == -9 >>> sumEverySecond([-1, 2, -3, 4, -5, 6]) == -9","solution":"def sumEverySecond(numbers): Sums every second number in the array starting from the first element. If the array is empty or contains only one element, returns 0. Args: numbers (list): List of numbers. Returns: int: The sum of every second number starting from the first. if not numbers: return 0 # Take every second element starting from the first (index 0) return sum(numbers[::2])"},{"question":"def min_operations_to_equalize(sequence: List[int]) -> int: Determines the minimum number of operations required to make all integers in the input sequence equal by incrementing each element of any single contiguous subarray by 1. Parameters: sequence (list of int): The sequence of integers. Returns: int: The minimum number of operations required. >>> min_operations_to_equalize([1, 2, 3, 4, 5]) 10 >>> min_operations_to_equalize([7, 7, 7]) 0 >>> min_operations_to_equalize([1, 3, 2, 4]) 6 >>> min_operations_to_equalize([10, 9, 8, 7, 6, 5]) 15 >>> min_operations_to_equalize([10]) 0 >>> min_operations_to_equalize([1000000000, 999999999, 1000000000]) 1","solution":"def min_operations_to_equalize(sequence): Determines the minimum number of operations required to make all integers in the input sequence equal by incrementing each element of any single contiguous subarray by 1. Parameters: sequence (list of int): The sequence of integers. Returns: int: The minimum number of operations required. max_value = max(sequence) operations = [max_value - num for num in sequence] return sum(operations)"},{"question":"from typing import List, Tuple class VendingMachine: def __init__(self): Initializes an empty inventory. def add_drink(self, drink_id: str, name: str, quantity: int): Adds a new drink to the inventory. Args: drink_id (str): The ID of the drink. name (str): The name of the drink. quantity (int): The initial quantity of the drink. def dispense(self, drink_id: str) -> str: Dispenses a drink and returns \\"Dispensed\\" if successful, otherwise returns \\"Drink not available\\". Args: drink_id (str): The ID of the drink to be dispensed. Returns: str: \\"Dispensed\\" if a drink is successfully dispensed, otherwise \\"Drink not available\\". def get_inventory(self) -> List[Tuple[str, str, int]]: Returns a list of tuples, each containing the drink ID, name, and quantity. Returns: List[Tuple[str, str, int]]: The inventory of drinks. pass # Example usage: vm = VendingMachine() vm.add_drink(\\"001\\", \\"Coca-Cola\\", 10) vm.add_drink(\\"002\\", \\"Pepsi\\", 5) vm.add_drink(\\"003\\", \\"Sprite\\", 8) print(vm.get_inventory()) # Expected output: [('001', 'Coca-Cola', 10), ('002', 'Pepsi', 5), ('003', 'Sprite', 8)] print(vm.dispense(\\"002\\")) # Expected output: \\"Dispensed\\" print(vm.get_inventory()) # Expected output: [('001', 'Coca-Cola', 10), ('002', 'Pepsi', 4), ('003', 'Sprite', 8)] print(vm.dispense(\\"004\\")) # Expected output: \\"Drink not available\\"","solution":"from typing import List, Tuple class VendingMachine: def __init__(self): Initializes an empty inventory. self.inventory = {} def add_drink(self, drink_id: str, name: str, quantity: int): Adds a new drink to the inventory. If the drink already exists, it updates the name and quantity. if drink_id in self.inventory: self.inventory[drink_id]['name'] = name self.inventory[drink_id]['quantity'] += quantity else: self.inventory[drink_id] = {'name': name, 'quantity': quantity} def dispense(self, drink_id: str) -> str: Dispenses a drink and returns \\"Dispensed\\" if successful, otherwise returns \\"Drink not available\\". if drink_id in self.inventory and self.inventory[drink_id]['quantity'] > 0: self.inventory[drink_id]['quantity'] -= 1 return \\"Dispensed\\" else: return \\"Drink not available\\" def get_inventory(self) -> List[Tuple[str, str, int]]: Returns a list of tuples, each containing the drink ID, name, and quantity. return [(drink_id, item['name'], item['quantity']) for drink_id, item in self.inventory.items()]"},{"question":"def productArray(arr): Returns a new array where each element is replaced with the product of all other elements in the original array. >>> productArray([1, 2, 3, 4]) [24, 12, 8, 6] >>> productArray([5]) [1] >>> productArray([1, 1, 1, 1]) [1, 1, 1, 1] >>> productArray([1, 2, 3, 0]) [0, 0, 0, 6] >>> productArray([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> productArray([0, 0, 0]) [0, 0, 0] >>> productArray([]) [] def test_product_array(): assert productArray([1, 2, 3, 4]) == [24, 12, 8, 6] assert productArray([5]) == [1] assert productArray([1, 1, 1, 1]) == [1, 1, 1, 1] assert productArray([1, 2, 3, 0]) == [0, 0, 0, 6] assert productArray([-1, 2, -3, 4]) == [-24, 12, -8, 6] assert productArray([0, 0, 0]) == [0, 0, 0] assert productArray([]) == [] def test_edge_cases(): assert productArray([1000000, 1000000, 1000000]) == [1000000000000, 1000000000000, 1000000000000] assert productArray([-1, 1]) == [1, -1]","solution":"def productArray(arr): Returns a new array where each element is replaced with the product of all other elements in the original array. length = len(arr) if length == 0: return [] # Initialize two lists to keep track of the product of all elements # to the left and to the right of each element in the array. left_products = [1] * length right_products = [1] * length result = [1] * length # Calculate the left products for i in range(1, length): left_products[i] = arr[i - 1] * left_products[i - 1] # Calculate the right products for i in range(length - 2, -1, -1): right_products[i] = arr[i + 1] * right_products[i + 1] # Calculate the product of elements except self for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def length_of_longest_subarray(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with unique elements. >>> length_of_longest_subarray([4, 2, 1, 6, 5]) 5 >>> length_of_longest_subarray([4, 2, 1, 2, 5, 6]) 4 >>> length_of_longest_subarray([1, 2, 1, 3, 4, 2, 3]) 4","solution":"def length_of_longest_subarray(nums): Returns the length of the longest contiguous subarray with unique elements. if not nums: return 0 num_set = set() left = 0 max_length = 0 for right in range(len(nums)): while nums[right] in num_set: num_set.remove(nums[left]) left += 1 num_set.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_efficiency_in_range(efficiencies, queries): For given ranges, return the maximum efficiency within each range. efficiencies: List[int] - list of efficiencies of students queries: List[tuple] - list of queries represented as tuples (L, R) Returns: List[int] - list of maximum efficiencies for each range query >>> max_efficiency_in_range([3, 1, 4, 1, 5, 9], [(1, 4), (2, 5), (3, 6)]) [4, 5, 9] >>> max_efficiency_in_range([2, 2, 2, 2, 2, 2], [(1, 3), (2, 6)]) [2, 2]","solution":"def max_efficiency_in_range(efficiencies, queries): For given ranges, return the maximum efficiency within each range. efficiencies: List[int] - list of efficiencies of students queries: List[tuple] - list of queries represented as tuples (L, R) Returns: List[int] - list of maximum efficiencies for each range query results = [] for L, R in queries: max_efficiency = max(efficiencies[L-1:R]) # L and R are 1-based index results.append(max_efficiency) return results"},{"question":"def roundGrades(grades: List[int]) -> List[int]: Given a list of integers representing grades of students in a class, return the new list with the grades rounded according to these rules: 1. If the difference between the grade and the next multiple of 5 is less than 3, round the grade up to the next multiple of 5. 2. If the grade is less than 38, don't round it up since the result will still be a failing grade. >>> roundGrades([73, 67, 38, 33]) [75, 67, 40, 33] >>> roundGrades([84, 29, 57]) [85, 29, 57] pass","solution":"def roundGrades(grades): Given a list of grades, return the list with the grades rounded according to the specified rules. rounded_grades = [] for grade in grades: if grade >= 38: next_multiple_of_5 = ((grade // 5) + 1) * 5 if next_multiple_of_5 - grade < 3: grade = next_multiple_of_5 rounded_grades.append(grade) return rounded_grades"},{"question":"def reverse_words(input_string: str) -> str: Reverses each word in the input string but preserves the order of words. Args: input_string (str): The input string containing words separated by spaces. Returns: str: A single line string with all the words reversed but in the preserved order. Examples: >>> reverse_words(\\"Hello World\\") 'olleH dlroW' >>> reverse_words(\\"Python is fun\\") 'nohtyP si nuf' >>> reverse_words(\\"a b c\\") 'a b c' >>> reverse_words(\\"Practice makes perfect\\") 'ecitcarP sekam tcefrep'","solution":"def reverse_words(input_string: str) -> str: Reverses each word in the input string but preserves the order of words. Args: input_string (str): The input string containing words separated by spaces. Returns: str: A single line string with all the words reversed but in the preserved order. words = input_string.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def CommonElements(list1, list2): Returns a new list containing only the elements that appear in both of the input lists with no duplicates. Args: list1 (list): First list of integers list2 (list): Second list of integers Returns: list: A list containing the common elements in both list1 and list2 without duplicates Examples: >>> sorted(CommonElements([1, 2, 2, 3], [2, 3, 3, 4])) [2, 3] >>> CommonElements([1, 2, 3], [4, 5, 6]) [] >>> sorted(CommonElements([1, 1, 1, 2, 2, 3], [2, 2, 3, 3, 4])) [2, 3] >>> CommonElements([], []) [] >>> CommonElements([1, 2, 3], []) [] >>> CommonElements([], [1, 2, 3]) [] >>> sorted(CommonElements([1, 2, 3], [1, 2, 3])) [1, 2, 3] >>> CommonElements([1, 1, 1], [1, 1, 1]) [1]","solution":"def CommonElements(list1, list2): Returns a list containing the common elements in both list1 and list2, without duplicates. set1 = set(list1) set2 = set(list2) common_elements = list(set1 & set2) # Use intersection of sets to find common elements return common_elements"},{"question":"def highest_revenue_day(N: int, customers: List[int], discount_rates: List[int]) -> int: Determine the earliest day with the highest total revenue. Parameters: N (int): Number of days. customers (list): List of integers representing the number of customers visiting each day. discount_rates (list): List of integers representing the discount rates for each day. Returns: int: The earliest day with the highest total revenue. >>> highest_revenue_day(5, [100, 200, 150, 180, 130], [10, 5, 20, 15, 30]) 5 >>> highest_revenue_day(3, [100, 100, 100], [10, 10, 10]) 1 >>> highest_revenue_day(4, [100, 200, 150, 150], [10, 5, 20, 20]) 3 >>> highest_revenue_day(1, [100], [15]) 1 >>> highest_revenue_day(2, [10**6, 10**6], [10**6, 10**6 - 1]) 1","solution":"def highest_revenue_day(N, customers, discount_rates): Returns the earliest day with the highest total revenue. Parameters: N (int): Number of days. customers (list): List of integers representing the number of customers visiting each day. discount_rates (list): List of integers representing the discount rates for each day. Returns: int: The earliest day with the highest total revenue. max_revenue = 0 best_day = 0 for i in range(N): revenue = customers[i] * discount_rates[i] if revenue > max_revenue: max_revenue = revenue best_day = i + 1 return best_day"},{"question":"import re def are_anagrams(str1: str, str2: str) -> bool: Determines if a given string is an anagram of another string. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. The comparison is case-insensitive and ignores spaces, punctuation, and special characters. >>> are_anagrams(\\"Listen\\", \\"Silent\\") == True >>> are_anagrams(\\"A Man, A Plan, A Canal, Panama!\\", \\"A Plan, A Canal, Panama! A Man\\") == True >>> are_anagrams(\\"Hello\\", \\"World\\") == False >>> are_anagrams(\\"Listen\\", \\"silent\\") == True >>> are_anagrams(\\"Listen!!\\", \\"Silent?!\\") == True >>> are_anagrams(\\"Listen\\", \\"Listenss\\") == False >>> are_anagrams(\\"\\", \\"\\") == True >>> are_anagrams(\\"123@! Listen\\", \\"Silent!!321@\\") == True","solution":"import re def are_anagrams(str1, str2): Determines if str1 and str2 are anagrams of each other, ignoring case, spaces, and punctuation. # Remove non-alphabetic characters and convert to lowercase clean_str1 = re.sub(r'[^a-zA-Z]', '', str1).lower() clean_str2 = re.sub(r'[^a-zA-Z]', '', str2).lower() # Check if sorted cleaned strings are equal return sorted(clean_str1) == sorted(clean_str2)"},{"question":"def manage_inventory(operations): Manage inventory with various operations such as adding, increasing, decreasing, and removing products. >>> manage_inventory([(\\"ADD\\", \\"apple\\", 10), (\\"ADD\\", \\"banana\\", 5), (\\"INCREASE\\", \\"banana\\", 3), (\\"DECREASE\\", \\"apple\\", 8), (\\"REMOVE\\", \\"banana\\"), (\\"ADD\\", \\"orange\\", 7)]) {'apple': 2, 'orange': 7} >>> manage_inventory([(\\"ADD\\", \\"apple\\", 10)]) {'apple': 10} >>> manage_inventory([(\\"ADD\\", \\"apple\\", 10), (\\"ADD\\", \\"apple\\", 5)]) {'apple': 15} >>> manage_inventory([(\\"ADD\\", \\"banana\\", 5), (\\"INCREASE\\", \\"banana\\", 3)]) {'banana': 8} >>> manage_inventory([(\\"ADD\\", \\"apple\\", 10), (\\"DECREASE\\", \\"apple\\", 8)]) {'apple': 2} >>> manage_inventory([(\\"ADD\\", \\"banana\\", 5), (\\"REMOVE\\", \\"banana\\")]) {} >>> manage_inventory([(\\"ADD\\", \\"apple\\", 10), (\\"DECREASE\\", \\"apple\\", 10)]) {} >>> manage_inventory([(\\"ADD\\", \\"apple\\", 10), (\\"DECREASE\\", \\"apple\\", 5)]) {'apple': 5} >>> manage_inventory([(\\"ADD\\", \\"apple\\", 10), (\\"DECREASE\\", \\"apple\\", 10), (\\"DECREASE\\", \\"banana\\", 1)]) {}","solution":"def manage_inventory(operations): inventory = {} for operation in operations: action = operation[0] product = operation[1] if action == \\"ADD\\": quantity = operation[2] if product in inventory: inventory[product] += quantity else: inventory[product] = quantity elif action == \\"INCREASE\\": quantity = operation[2] if product in inventory: inventory[product] += quantity elif action == \\"DECREASE\\": quantity = operation[2] if product in inventory: inventory[product] -= quantity if inventory[product] <= 0: del inventory[product] elif action == \\"REMOVE\\": if product in inventory: del inventory[product] return inventory"},{"question":"def visible_buildings(buildings: List[int]) -> int: Returns the count of buildings that would be visible from the left side. Parameters: buildings (list of int): List of building heights. Returns: int: Count of visible buildings. >>> visible_buildings([3, 5, 4, 2, 6, 1]) 3 >>> visible_buildings([1, 2, 3, 4, 5]) 5 >>> visible_buildings([5, 4, 3, 2, 1]) 1 >>> visible_buildings([10, 12, 15, 20, 10, 30]) 5 >>> visible_buildings([5, 5, 5, 5]) 1","solution":"def visible_buildings(buildings): Returns the count of buildings that would be visible from the left side. Parameters: buildings (list of int): List of building heights. Returns: int: Count of visible buildings. if not buildings: return 0 visible_count = 1 # The first building is always visible max_height = buildings[0] for height in buildings[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"from typing import List def action_summary(log_entries: List[str]) -> str: Given a list of log entries, determine the frequency of each action for every user and sort the actions in descending order based on the overall frequency. If two actions have the same frequency, they should be ordered alphabetically. >>> action_summary([\\"alice login\\", \\"bob view\\", \\"alice view\\", \\"alice view\\", \\"bob login\\", \\"charlie view\\"]) \\"alice: view 2 login 1nbob: view 1 login 1ncharlie: view 1\\"","solution":"def action_summary(log_entries): from collections import defaultdict, Counter user_actions = defaultdict(Counter) overall_action_counts = Counter() for entry in log_entries: if isinstance(entry, str): username, action = entry.split() user_actions[username][action] += 1 overall_action_counts[action] += 1 sorted_actions = sorted(overall_action_counts.items(), key=lambda x: (-x[1], x[0])) output = [] for user, actions in sorted(user_actions.items()): actions_repr = \\" \\".join(f\\"{action} {actions[action]}\\" for action, _ in sorted_actions if action in actions) output.append(f\\"{user}: {actions_repr}\\") return \\"n\\".join(output) log_entries = [\\"alice login\\", \\"bob view\\", \\"alice view\\", \\"alice view\\", \\"bob login\\", \\"charlie view\\"] print(action_summary(log_entries))"},{"question":"def sum_of_multiples(n: int) -> int: Returns the sum of all integers from 1 up to n that are divisible by either 3 or 5. >>> sum_of_multiples(10) # 33 >>> sum_of_multiples(15) # 60 >>> sum_of_multiples(1) # 0 >>> sum_of_multiples(-5) # 0 >>> sum_of_multiples(0) # 0 >>> sum_of_multiples(1000) # 234168","solution":"def sum_of_multiples(n): Returns the sum of all integers from 1 up to n that are divisible by either 3 or 5. return sum(i for i in range(1, n + 1) if i % 3 == 0 or i % 5 == 0)"},{"question":"def convert_to_shorthand(T: int, test_cases: List[Dict[str, Union[int, List[Tuple[str, str]]]]]) -> List[str]: Convert a message into shorthand notation using the provided dictionary. Args: T: The number of test cases. test_cases: A list of dictionaries containing: - 'N': Number of words in the message. - 'words': A list of words representing the message. - 'D': Number of dictionary entries. - 'dictionary': A list of tuples where each tuple contains a word and its abbreviation. Returns: A list of strings representing each message in shorthand notation. >>> convert_to_shorthand(2, [ ... {'N': 5, 'words': ['I', 'love', 'to', 'code', 'daily'], 'D': 3, 'dictionary': [('love', 'lv'), ('code', 'cd'), ('daily', 'dly')]}, ... {'N': 4, 'words': ['Hello', 'world', 'good', 'morning'], 'D': 2, 'dictionary': [('Hello', 'Hlo'), ('morning', 'mrng')]}, ... ]) ['I lv to cd dly', 'Hlo world good mrng']","solution":"def convert_to_shorthand(T, test_cases): results = [] for i in range(T): N = test_cases[i]['N'] words = test_cases[i]['words'] D = test_cases[i]['D'] dictionary = test_cases[i]['dictionary'] shorthand_dict = {} for word, abbrev in dictionary: shorthand_dict[word] = abbrev converted_message = [] for word in words: if word in shorthand_dict: converted_message.append(shorthand_dict[word]) else: converted_message.append(word) results.append(\\" \\".join(converted_message)) return results # Sample dictionary to demonstrate usage test_cases = [ { 'N': 5, 'words': ['I', 'love', 'to', 'code', 'daily'], 'D': 3, 'dictionary': [ ('love', 'lv'), ('code', 'cd'), ('daily', 'dly') ] }, { 'N': 4, 'words': ['Hello', 'world', 'good', 'morning'], 'D': 2, 'dictionary': [ ('Hello', 'Hlo'), ('morning', 'mrng') ] } ] # Example usage T = 2 print(convert_to_shorthand(T, test_cases))"},{"question":"def adjacent_elements_product(array): Returns the largest product of two adjacent numbers in the array. >>> adjacent_elements_product([3, 6, -2, -5, 7, 3]) 21 >>> adjacent_elements_product([1, 2, 3, 4, 5]) 20 >>> adjacent_elements_product([-10, -20, -30, -40, -50]) 2000 >>> adjacent_elements_product([0, 1, 2, 3, 4]) 12 >>> adjacent_elements_product([-1, 2]) -2","solution":"def adjacent_elements_product(array): Returns the largest product of two adjacent numbers in the array. max_product = float('-inf') for i in range(len(array) - 1): product = array[i] * array[i + 1] if product > max_product: max_product = product return max_product"},{"question":"def is_k_diff_pair(nums: List[int], k: int) -> bool: Returns true if there are distinct pairs (i, j) in the list where |nums[i] - nums[j]| = k. >>> is_k_diff_pair([1, 5, 2, 9, 7], 2) True >>> is_k_diff_pair([3, 1, 4, 1, 5], 2) True >>> is_k_diff_pair([1, 1, 1, 1], 0) True >>> is_k_diff_pair([1, 5, 3, 9], 4) True >>> is_k_diff_pair([1, 2, 3, 4], 5) False","solution":"def is_k_diff_pair(nums, k): Returns true if there are distinct pairs (i, j) in the list where |nums[i] - nums[j]| = k. if not nums: # Early return for empty array return False num_set = set(nums) if k == 0: # If k is 0, we need at least one duplicate element return len(nums) != len(num_set) for num in nums: if (num + k) in num_set or (num - k) in num_set: return True return False"},{"question":"def maxDistinctChars(s: str, k: int) -> [int, int]: Returns the maximum number of distinct characters in any substring of length k of the given string, as well as the number of such substrings. >>> maxDistinctChars(\\"araaci\\", 2) [2, 4] >>> maxDistinctChars(\\"cbbebi\\", 3) [3, 1] >>> maxDistinctChars(\\"\\", 2) [0, 0] >>> maxDistinctChars(\\"abc\\", 4) [0, 0] >>> maxDistinctChars(\\"abc\\", 0) [0, 0] >>> maxDistinctChars(\\"aaaaa\\", 2) [1, 4] >>> maxDistinctChars(\\"abcdef\\", 3) [3, 4] pass","solution":"def maxDistinctChars(s, k): Returns the maximum number of distinct characters in any substring of length k of the given string, as well as the number of such substrings. from collections import defaultdict if not s or k <= 0 or k > len(s): return [0, 0] max_distinct = 0 substr_freq = defaultdict(int) for i in range(len(s) - k + 1): substring = s[i:i + k] distinct_chars = len(set(substring)) if distinct_chars > max_distinct: max_distinct = distinct_chars substr_freq[max_distinct] = 1 elif distinct_chars == max_distinct: substr_freq[max_distinct] += 1 return [max_distinct, substr_freq[max_distinct]]"},{"question":"def customHash(s: str) -> int: Calculates the custom hash code as described in the task. Each character in the string contributes to the hash value by its ASCII value multiplied by its 1-based index. >>> customHash(\\"abc\\") 294 >>> customHash(\\"Hello\\") 1585","solution":"def customHash(s): Calculates the custom hash code as described in the task. Each character in the string contributes to the hash value by its ASCII value multiplied by its 1-based index. hash_value = 0 for idx, char in enumerate(s): hash_value += ord(char) * (idx + 1) return hash_value"},{"question":"def shortest_path(m: int, n: int, grid: List[List[int]]) -> int: Finds the shortest path from top-left to bottom-right in a given grid. >>> shortest_path(5, 6, [ ... [0, 0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1, 0], ... [0, 0, 0, 0, 0, 0], ... [0, 1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0, 0] ... ]) == 9 >>> shortest_path(3, 3, [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 4 >>> shortest_path(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == -1 pass import pytest def test_shortest_path_example_1(): grid = [ [0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0] ] assert shortest_path(5, 6, grid) == 9 def test_shortest_path_example_2(): grid = [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] assert shortest_path(3, 3, grid) == 4 def test_shortest_path_example_3(): grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert shortest_path(3, 3, grid) == -1 def test_shortest_path_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert shortest_path(3, 3, grid) == 4 def test_shortest_path_start_or_end_blocked(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert shortest_path(3, 3, grid) == -1 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert shortest_path(3, 3, grid) == -1 def test_shortest_path_large_grid(): grid = [ [0] * 1000 for _ in range(1000) ] assert shortest_path(1000, 1000, grid) == 1998","solution":"from collections import deque def shortest_path(m, n, grid): Finds the shortest path from top-left to bottom-right in a given grid. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] q = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while q: x, y, dist = q.popleft() if x == m-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) q.append((nx, ny, dist+1)) return -1"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given 2D matrix clockwise by 90 degrees. Parameters: matrix (list of list of int): The 2D matrix to be rotated. Returns: list of list of int: The rotated 2D matrix. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8] ... ]) [[5, 1], [6, 2], [7, 3], [8, 4]] >>> rotate_matrix([ ... [1] ... ]) [[1]] >>> rotate_matrix([]) [] >>> rotate_matrix([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) [[5, 3, 1], [6, 4, 2]] >>> rotate_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] pass","solution":"def rotate_matrix(matrix): Rotates the given 2D matrix clockwise by 90 degrees. Parameters: matrix (list of list of int): The 2D matrix to be rotated. Returns: list of list of int: The rotated 2D matrix. return [list(reversed(col)) for col in zip(*matrix)]"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> bool: Determines if the string s can be segmented into a sequence of one or more dictionary words. >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True >>> wordBreak(\\"word\\", [\\"word\\"]) == True >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False >>> wordBreak(\\"leetcodes\\", [\\"leet\\", \\"code\\"]) == False >>> wordBreak(\\"aaaaaaa\\", [\\"aaaa\\", \\"aaa\\"]) == True >>> wordBreak(\\"\\", [\\"word\\"]) == True >>> wordBreak(\\"word\\", []) == False","solution":"from collections import deque def wordBreak(s, wordDict): Determines if the string s can be segmented into a sequence of one or more dictionary words. Parameters: s (str): the string to be segmented. wordDict (list): the list of dictionary words. Returns: bool: True if s can be segmented, False otherwise. wordSet = set(wordDict) visited = [False] * len(s) queue = deque([0]) while queue: start = queue.popleft() if start == len(s): return True if visited[start]: continue visited[start] = True for end in range(start + 1, len(s) + 1): if s[start:end] in wordSet: queue.append(end) return False"},{"question":"def max_consecutive_ones(n: int, m: int, grid: List[str]) -> int: Find the maximum number of consecutive 1s in a binary grid (horizontally, vertically, or diagonally). Args: n: The number of rows in the grid. m: The number of columns in the grid. grid: A list of strings representing the grid, where each string is a row. Returns: The maximum number of consecutive 1s in the grid. >>> max_consecutive_ones(3, 5, [\\"10001\\", \\"11111\\", \\"00001\\"]) 5 >>> max_consecutive_ones(4, 4, [\\"0110\\", \\"1111\\", \\"1101\\", \\"0110\\"]) 4","solution":"def max_consecutive_ones(n, m, grid): def count_consecutive_ones(x, y, dx, dy): length = 0 max_length = 0 while 0 <= x < n and 0 <= y < m: if grid[x][y] == '1': length += 1 max_length = max(max_length, length) else: length = 0 x += dx y += dy return max_length max_length = 0 # check rows for i in range(n): max_length = max(max_length, count_consecutive_ones(i, 0, 0, 1)) # check columns for j in range(m): max_length = max(max_length, count_consecutive_ones(0, j, 1, 0)) # check diagonals (from top-left to bottom-right) for i in range(n): max_length = max(max_length, count_consecutive_ones(i, 0, 1, 1)) for j in range(1, m): max_length = max(max_length, count_consecutive_ones(0, j, 1, 1)) # check diagonals (from top-right to bottom-left) for i in range(n): max_length = max(max_length, count_consecutive_ones(i, m-1, 1, -1)) for j in range(m-1): max_length = max(max_length, count_consecutive_ones(0, j, 1, -1)) return max_length"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] >>> rotate_matrix([ ... [1] ... ]) [ [1] ] >>> rotate_matrix([ ... [ 1, 2, 3, 4], ... [ 5, 6, 7, 8], ... [ 9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] >>> rotate_matrix([ ... [ 1, 2, 3, 4, 5], ... [ 6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix 90 degrees clockwise. n = len(matrix) # Layer by layer approach for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first # Save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top return matrix"},{"question":"from typing import List, Tuple def minConferenceRooms(events: List[Tuple[int, int]]) -> int: Determine the minimum number of rooms required to host all events scheduled for a given day. >>> minConferenceRooms([(1, 4), (2, 5), (7, 8)]) == 2 >>> minConferenceRooms([(0, 30), (5, 10), (15, 20), (30, 35)]) == 2 >>> minConferenceRooms([]) == 0 >>> minConferenceRooms([(1, 10)]) == 1 >>> minConferenceRooms([(1, 2), (3, 4), (5, 6)]) == 1 >>> minConferenceRooms([(1, 10), (2, 9), (3, 8), (4, 7)]) == 4 >>> minConferenceRooms([(0, 1), (1, 2), (2, 3), (3, 4)]) == 1 >>> minConferenceRooms([(0, 1), (1, 2), (2, 3), (4, 5), (5, 6)]) == 1 >>> minConferenceRooms([(0, 1), (0, 1), (0, 1), (0, 1)]) == 4","solution":"from typing import List, Tuple def minConferenceRooms(events: List[Tuple[int, int]]) -> int: if not events: return 0 start_times = sorted(event[0] for event in events) end_times = sorted(event[1] for event in events) s_ptr, e_ptr = 0, 0 used_rooms = 0 max_rooms = 0 while s_ptr < len(events): if start_times[s_ptr] < end_times[e_ptr]: used_rooms += 1 s_ptr += 1 else: used_rooms -= 1 e_ptr += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"def longest_unique_sublist(nums: List[int]) -> int: Returns the length of the longest contiguous sublist that contains only unique elements. >>> longest_unique_sublist([1, 2, 3, 1, 2, 3, 4, 5]) == 5 >>> longest_unique_sublist([1, 2, 2, 3, 4, 5, 5]) == 4 >>> longest_unique_sublist([4, 4, 4, 4]) == 1 >>> longest_unique_sublist([1, 2, 3, 4, 5]) == 5 >>> longest_unique_sublist([5, 4, 3, 2, 1]) == 5 >>> longest_unique_sublist([1]) == 1 >>> longest_unique_sublist([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == 10 >>> longest_unique_sublist([2, 2, 2, 2, 2, 2]) == 1 >>> longest_unique_sublist(list(range(1000))) == 1000 >>> longest_unique_sublist([1, 2, 3, 4, 2, 3, 4, 5, 6]) == 5","solution":"def longest_unique_sublist(nums): Returns the length of the longest contiguous sublist that contains only unique elements. seen = set() left = 0 max_length = 0 for right in range(len(nums)): while nums[right] in seen: seen.remove(nums[left]) left += 1 seen.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"import math from typing import List def replace_with_largest_prime_factor(arr: List[int]) -> List[int]: Write a function that takes an array of integers and returns a new array consisting of all the positive integers in the original array, each replaced by the largest prime factor of that integer. If the integer is negative or zero, the output array should have the integer unchanged at its corresponding index. Examples: >>> replace_with_largest_prime_factor([10, -7, 15, 0, 33]) [5, -7, 5, 0, 11] >>> replace_with_largest_prime_factor([20, 25, 77, 8, 100]) [5, 5, 11, 2, 5]","solution":"import math def largest_prime_factor(n): if n <= 1: return None while n % 2 == 0: max_prime = 2 n //= 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: max_prime = i n //= i if n > 2: max_prime = n return int(max_prime) def replace_with_largest_prime_factor(arr): result = [] for num in arr: if num > 0: result.append(largest_prime_factor(num)) else: result.append(num) return result"},{"question":"def findMissingNumbers(arr): Returns the missing numbers in ascending order from the given array. The given array contains numbers from 1 to N+K with K numbers missing. Args: arr: List of integers. Returns: List of missing integers in ascending order. >>> findMissingNumbers([1, 3, 4, 6]) [2, 5] >>> findMissingNumbers([2, 3, 5, 6, 7, 9, 10]) [1, 4, 8]","solution":"def findMissingNumbers(arr): Returns the missing numbers in ascending order from the given array. The given array contains numbers from 1 to N+K with K numbers missing. Args: arr: List of integers. Returns: List of missing integers in ascending order. if not arr: return [] N = max(arr) full_set = set(range(1, N + 1)) given_set = set(arr) missing_numbers = sorted(list(full_set - given_set)) return missing_numbers"},{"question":"from typing import List def rearrangeString(s: str, k: int) -> str: Given a string s and an integer k, rearrange the characters of s such that the same characters are at least k distance apart. If it is not possible to rearrange the string, return an empty string \\"\\". >>> rearrangeString(\\"aabbcc\\", 3) == \\"abcabc\\" >>> rearrangeString(\\"aaabc\\", 3) == \\"\\" >>> rearrangeString(\\"aaadbbcc\\", 2) == \\"abacabcd\\" >>> rearrangeString(\\"aaaaa\\", 1) == \\"aaaaa\\" >>> rearrangeString(\\"aabbcc\\", 0) == \\"aabbcc\\" >>> rearrangeString(\\"aabbcc\\", 1) == \\"abcabc\\" >>> rearrangeString(\\"aaa\\", 2) == \\"\\" # Unit tests def test_rearrangeString_no_rearrangement_needed(): assert rearrangeString(\\"aaaaa\\", 1) == \\"aaaaa\\" assert rearrangeString(\\"aabbcc\\", 0) == \\"aabbcc\\" def test_rearrangeString_k_1(): result = rearrangeString(\\"aabbcc\\", 1) assert sorted(result) == sorted(\\"abcabc\\") def test_rearrangeString_normal_cases(): assert rearrangeString(\\"aabbcc\\", 3) == \\"abcabc\\" assert rearrangeString(\\"aaadbbcc\\", 2) == \\"abacabcd\\" def test_rearrangeString_impossible_case(): assert rearrangeString(\\"aaabc\\", 3) == \\"\\" assert rearrangeString(\\"aaa\\", 2) == \\"\\" def test_rearrangeString_edge_cases(): assert rearrangeString(\\"\\", 0) == \\"\\" assert rearrangeString(\\"a\\", 1) == \\"a\\" assert rearrangeString(\\"aa\\", 0) == \\"aa\\"","solution":"from collections import Counter import heapq def rearrangeString(s, k): if k == 0: return s counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) rearranged = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) rearranged.append(char) wait_queue.append((count + 1, char)) if len(wait_queue) >= k: released = wait_queue.pop(0) if released[0] < 0: heapq.heappush(max_heap, released) if len(rearranged) != len(s): return \\"\\" return \\"\\".join(rearranged)"},{"question":"import numpy as np def transpose_and_flatten(n: int, m: int, array: list) -> tuple: Transpose the given N x M array and then flatten the transposed array. Parameters: n (int): Number of rows. m (int): Number of columns. array (list of lists of int): The N x M array. Returns: tuple: Transposed array and flattened transposed array. # Your code goes here def test_transpose_and_flatten(): array = [ [1, 2, 3], [4, 5, 6] ] transposed, flattened = transpose_and_flatten(2, 3, array) assert np.array_equal(transposed, np.array([[1, 4], [2, 5], [3, 6]])) assert np.array_equal(flattened, np.array([1, 4, 2, 5, 3, 6])) def test_transpose_and_flatten_single_element(): array = [ [1] ] transposed, flattened = transpose_and_flatten(1, 1, array) assert np.array_equal(transposed, np.array([[1]])) assert np.array_equal(flattened, np.array([1])) def test_transpose_and_flatten_large_array(): array = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] transposed, flattened = transpose_and_flatten(3, 4, array) assert np.array_equal(transposed, np.array([[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]])) assert np.array_equal(flattened, np.array([1, 5, 9, 2, 6, 10, 3, 7, 11, 4, 8, 12]))","solution":"import numpy as np def transpose_and_flatten(n, m, array): Transpose the given N x M array and then flatten the transposed array. Parameters: n (int): Number of rows. m (int): Number of columns. array (list of lists of int): The N x M array. Returns: tuple: Transposed array and flattened transposed array. np_array = np.array(array) transposed_array = np.transpose(np_array) flattened_transposed_array = transposed_array.flatten() return transposed_array, flattened_transposed_array"},{"question":"def filter_array(arr, threshold): Filters the array to include only elements greater than the specified threshold. Parameters: arr (list of int): The input list of integers. threshold (int): The threshold value. Returns: list of int: A new list with elements from the input list that are greater than the threshold. >>> filter_array([1, 5, 8, 3, 10, 2], 5) [8,10] >>> filter_array([7, 3, 9, 4], 4) [7,9] >>> filter_array([10, 20, 30], 25) [30]","solution":"def filter_array(arr, threshold): Filters the array to include only elements greater than the specified threshold. Parameters: arr (list of int): The input list of integers. threshold (int): The threshold value. Returns: list of int: A new list with elements from the input list that are greater than the threshold. return [x for x in arr if x > threshold]"},{"question":"def sum_even_numbers(arr: List[int]) -> int: Returns the sum of all even numbers in the array. Parameters: - arr: list of integers Returns: int: sum of all even numbers in the list >>> sum_even_numbers([2, 4, 6]) == 12 >>> sum_even_numbers([1, 2, 3, 4, 5, 6]) == 12 >>> sum_even_numbers([1, 3, 5, 7]) == 0 >>> sum_even_numbers([0, 0, 0]) == 0 >>> sum_even_numbers([-2, -3, -4, -5]) == -6 >>> sum_even_numbers([]) == 0 >>> sum_even_numbers([1000000, 2000000, 3000001]) == 3000000","solution":"def sum_even_numbers(arr): Returns the sum of all even numbers in the array. Parameters: - arr: list of integers Returns: int: sum of all even numbers in the list return sum(num for num in arr if num % 2 == 0)"},{"question":"def manhattan_distance(x1, y1, x2, y2): Returns the Manhattan distance between two points (x1, y1) and (x2, y2). >>> manhattan_distance(1, 2, 4, 6) 7 >>> manhattan_distance(0, 0, 3, 3) 6 >>> manhattan_distance(5, 5, 5, 5) 0 >>> manhattan_distance(-1, -2, -4, -6) 7 >>> manhattan_distance(1, -2, -4, 6) 13","solution":"def manhattan_distance(x1, y1, x2, y2): Returns the Manhattan distance between two points (x1, y1) and (x2, y2). return abs(x1 - x2) + abs(y1 - y2)"},{"question":"def increment_by_index(arr: List[int]) -> List[int]: Create a function that takes an integer array and returns a new array with each element incremented by the value of its index. >>> increment_by_index([2, 4, 6, 8]) [2, 5, 8, 11] >>> increment_by_index([10]) [10] >>> increment_by_index([0, 0, 0, 0]) [0, 1, 2, 3] >>> increment_by_index([0, 1, 2, 3, 4]) [0, 2, 4, 6, 8] >>> increment_by_index([100, 200, 300, 400, 500]) [100, 201, 302, 403, 504]","solution":"def increment_by_index(arr): Returns a new array where each element is incremented by its index value. :param arr: List of non-negative integers :return: List of integers, each incremented by its index return [num + idx for idx, num in enumerate(arr)]"},{"question":"def final_health_points(h): Given the health points array h, returns the minimum possible health points of the final remaining player. pass def process_queries(queries): Processes multiple queries where each query consists of \`h\` (health points array) Returns the minimum health points of the final remaining player for each query. pass # Test cases def test_final_health_points(): assert final_health_points([5, 2, 8]) == 2 assert final_health_points([1, 4, 3, 2]) == 1 assert final_health_points([9, 1, 7, 6, 1]) == 1 assert final_health_points([5, 3, 7, 10, 4]) == 3 assert final_health_points([8, 8, 8, 8, 8]) == 8 def test_process_queries(): queries = [ [5, 2, 8], [1, 4, 3, 2], [9, 1, 7, 6, 1], [5, 3, 7, 10, 4], [8, 8, 8, 8, 8] ] assert process_queries(queries) == [2, 1, 1, 3, 8] large_query = [10**9] * 100000 assert process_queries([large_query]) == [10**9]","solution":"def final_health_points(h): Given the health points array h, returns the minimum possible health points of the final remaining player. return min(h) def process_queries(queries): Processes multiple queries where each query consists of \`h\` (health points array) Returns the minimum health points of the final remaining player for each query. results = [] for h in queries: results.append(final_health_points(h)) return results"},{"question":"def sum_nested_dict_values(data): Recursively calculates the sum of all numeric values in a nested dictionary. If the input is not a dictionary, the function returns 0. Example: >>> data = { ... 'a': 1, ... 'b': { ... 'c': 2, ... 'd': { ... 'e': 3, ... 'f': 'not a number' ... }, ... 'g': 4.5 ... }, ... 'h': 'ignore this', ... 'i': { ... 'j': { 'k': 5 } ... } ... } >>> sum_nested_dict_values(data) 15.5 pass # Unit Tests def test_sum_with_nested_dicts(): data = { 'a': 1, 'b': { 'c': 2, 'd': { 'e': 3, 'f': 'not a number' }, 'g': 4.5 }, 'h': 'ignore this', 'i': { 'j': { 'k': 5 } } } expected_result = 15.5 # 1 + 2 + 3 + 4.5 + 5 assert sum_nested_dict_values(data) == expected_result def test_sum_with_non_dict_input(): assert sum_nested_dict_values(123) == 0 assert sum_nested_dict_values([1, 2, 3]) == 0 assert sum_nested_dict_values(\\"string\\") == 0 def test_sum_with_empty_dict(): assert sum_nested_dict_values({}) == 0 def test_sum_with_single_level_dict(): data = {'a': 1, 'b': 2.5, 'c': 'ignore', 'd': 3} expected_result = 6.5 # 1 + 2.5 + 3 assert sum_nested_dict_values(data) == expected_result def test_sum_with_deeply_nested_empty_dicts(): data = {'a': {'b': {'c': {'d': {}}}}} assert sum_nested_dict_values(data) == 0 def test_sum_with_mixed_types(): data = {'a': 1, 'b': {'c': '2', 'd': 3.5, 'e': {'f': [6, 7], 'g': 8}}} expected_result = 12.5 # 1 + 3.5 + 8 assert sum_nested_dict_values(data) == expected_result","solution":"def sum_nested_dict_values(data): Recursively calculates the sum of all numeric values in a nested dictionary. If the input is not a dictionary, the function returns 0. if not isinstance(data, dict): return 0 total = 0 for key, value in data.items(): if isinstance(value, (int, float)): total += value elif isinstance(value, dict): total += sum_nested_dict_values(value) return total"},{"question":"class LongestIncreasingSubsequence: def __init__(self, nums): Initialize the class with the input list of integers. :param nums: List[int] - list of integers self.nums = nums def longest_increasing_subsequence(self) -> int: Find the length of the longest strictly increasing subsequence. :return: int - the length of the longest strictly increasing subsequence. >>> lis_instance = LongestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18]) >>> lis_instance.longest_increasing_subsequence() 4 >>> lis_instance = LongestIncreasingSubsequence([1, 2, 3, 4, 5]) >>> lis_instance.longest_increasing_subsequence() 5 >>> lis_instance = LongestIncreasingSubsequence([5, 4, 3, 2, 1]) >>> lis_instance.longest_increasing_subsequence() 1 pass from solution import LongestIncreasingSubsequence def test_longest_increasing_subsequence_basic(): lis_instance = LongestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18]) assert lis_instance.longest_increasing_subsequence() == 4 def test_longest_increasing_subsequence_single_element(): lis_instance = LongestIncreasingSubsequence([10]) assert lis_instance.longest_increasing_subsequence() == 1 def test_longest_increasing_subsequence_empty(): lis_instance = LongestIncreasingSubsequence([]) assert lis_instance.longest_increasing_subsequence() == 0 def test_longest_increasing_subsequence_all_increasing(): lis_instance = LongestIncreasingSubsequence([1, 2, 3, 4, 5]) assert lis_instance.longest_increasing_subsequence() == 5 def test_longest_increasing_subsequence_all_decreasing(): lis_instance = LongestIncreasingSubsequence([5, 4, 3, 2, 1]) assert lis_instance.longest_increasing_subsequence() == 1 def test_longest_increasing_subsequence_mixed(): lis_instance = LongestIncreasingSubsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) assert lis_instance.longest_increasing_subsequence() == 6","solution":"class LongestIncreasingSubsequence: def __init__(self, nums): self.nums = nums def longest_increasing_subsequence(self): if not self.nums: return 0 subsequence = [] for num in self.nums: pos = self.binary_search(subsequence, num) if pos < len(subsequence): subsequence[pos] = num else: subsequence.append(num) return len(subsequence) def binary_search(self, subsequence, num): left, right = 0, len(subsequence) - 1 while left <= right: mid = (left + right) // 2 if subsequence[mid] < num: left = mid + 1 else: right = mid - 1 return left"},{"question":"def count_days_above_average(temperatures): Returns the number of days the temperature was above the monthly average. temperatures: List[int] List of daily temperatures recorded for a month. return: int Number of days the temperature was above the monthly average. >>> count_days_above_average([30, 32, 35, 31, 33, 34, 29, 28, 35, 36, 30, 29, 31, 33, 34, 30, 31, 32, 33, 35, 36, 31, 30, 29, 28, 30, 32, 34, 35, 31, 33]) 16 >>> count_days_above_average([30]) 0 >>> count_days_above_average([30, 31]) 1 >>> count_days_above_average([30, 30, 30, 30, 30]) 0 >>> count_days_above_average([50, -50, 0, 50, -50]) 2","solution":"def count_days_above_average(temperatures): Returns the number of days the temperature was above the monthly average. temperatures: List[int] List of daily temperatures recorded for a month. return: int Number of days the temperature was above the monthly average. if not temperatures: return 0 average_temp = sum(temperatures) / len(temperatures) count = sum(1 for temp in temperatures if temp > average_temp) return count"},{"question":"def longest_increasing_rainfall(rainfall: List[int]) -> List[int]: Returns the longest sequence of days with increasing rainfall amounts. Args: rainfall (List[int]): A list of integers representing the rainfall amounts each day. Returns: List[int]: Longest sequence of days with increasing rainfall amounts. Examples: >>> longest_increasing_rainfall([1, 2, 3, 2, 5, 6, 7]) [1, 2, 3] >>> longest_increasing_rainfall([10, 5, 6, 1, 2, 3, 4, 1, 2]) [1, 2, 3, 4] >>> longest_increasing_rainfall([9, 5, 4, 3, 3, 2, 1]) [9] from longest_increasing_rainfall import longest_increasing_rainfall def test_single_element(): assert longest_increasing_rainfall([5]) == [5] def test_all_equal_elements(): assert longest_increasing_rainfall([2, 2, 2, 2]) == [2] def test_increasing_sequence(): assert longest_increasing_rainfall([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_decreasing_sequence(): assert longest_increasing_rainfall([5, 4, 3, 2, 1]) == [5] def test_mixed_sequence(): assert longest_increasing_rainfall([10, 5, 6, 1, 2, 3, 4, 1, 2]) == [1, 2, 3, 4] def test_multiple_increasing_sequences(): assert longest_increasing_rainfall([1, 2, 3, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_no_increase_inside_sequence(): assert longest_increasing_rainfall([1, 3, 2, 4, 3, 5]) == [1, 3] def test_longer_increasing_at_end(): assert longest_increasing_rainfall([1, 2, 1, 2, 3, 4]) == [1, 2, 3, 4]","solution":"def longest_increasing_rainfall(rainfall): Returns the longest sequence of days with increasing rainfall amounts. Parameters: rainfall (list): A list of integers representing the rainfall amounts each day. Returns: list: Longest sequence of days with increasing rainfall amounts. if not rainfall: return [] longest_sequence = [] current_sequence = [] for i in range(len(rainfall)): if i == 0 or rainfall[i] > rainfall[i - 1]: current_sequence.append(rainfall[i]) else: if len(current_sequence) > len(longest_sequence): longest_sequence = current_sequence current_sequence = [rainfall[i]] if len(current_sequence) > len(longest_sequence): longest_sequence = current_sequence return longest_sequence"},{"question":"def robot_journey(objects): Returns the total time (in seconds) it will take for a robot to pick up all objects and return to the origin after each pickup. Parameters: objects (list of tuples): A list of tuples where each tuple contains two integers representing the coordinates of an object. Returns: int: Total time in seconds. pass # Test Cases def test_robot_journey_single_object(): assert robot_journey([(1, 3)]) == 8 def test_robot_journey_multiple_objects(): assert robot_journey([(1, 3), (2, 2), (3, 1)]) == 24 def test_robot_journey_objects_on_axes(): assert robot_journey([(0, 5), (5, 0), (10, 10)]) == 60 def test_robot_journey_no_objects(): assert robot_journey([]) == 0 def test_robot_journey_same_objects_multiple_times(): assert robot_journey([(1, 1), (1, 1), (1, 1)]) == 12","solution":"def robot_journey(objects): Returns the total time (in seconds) it will take for a robot to pick up all objects and return to the origin after each pickup. Parameters: objects (list of tuples): A list of tuples where each tuple contains two integers representing the coordinates of an object. Returns: int: Total time in seconds. total_time = 0 for x, y in objects: # Calculate the time to go to the object and come back to the origin time_to_object_and_back = (abs(x) + abs(y)) * 2 total_time += time_to_object_and_back return total_time"},{"question":"def max_gold(caves): Returns the maximum amount of gold that can be stolen without robbing two consecutive caves. Args: caves (List[int]): List of integers representing the amount of gold in each cave. Returns: int: The maximum amount of gold that can be stolen. Examples: >>> max_gold([2, 7, 9, 3, 1]) 12 >>> max_gold([10]) 10 >>> max_gold([]) 0","solution":"def max_gold(caves): Returns the maximum amount of gold that can be stolen without robbing two consecutive caves. if not caves: return 0 n = len(caves) if n == 1: return caves[0] # dp array to store the maximum gold that can be stolen up to each cave dp = [0] * n # initialize the first two values dp[0] = caves[0] dp[1] = max(caves[0], caves[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + caves[i]) return dp[-1]"},{"question":"def rearrangeString(s: str) -> str: Rearrange the characters such that no two adjacent characters are the same. If it is not possible, return an empty string. Args: s (str): The input string consisting of lowercase English letters Returns: str: Rearranged string or an empty string if not possible. Examples: >>> rearrangeString(\\"aab\\") \\"aba\\" >>> rearrangeString(\\"aaab\\") \\"\\" pass from collections import Counter from heapq import heappop, heappush # Unit Tests def test_rearrange_1(): assert rearrangeString(\\"aab\\") in [\\"aba\\", \\"baa\\"] def test_rearrange_2(): assert rearrangeString(\\"aaab\\") == \\"\\" def test_rearrange_3(): assert rearrangeString(\\"aaabbc\\") in [\\"abacab\\", \\"ababac\\", \\"bacaba\\", \\"bacbaa\\"] def test_rearrange_4(): assert rearrangeString(\\"a\\") == \\"a\\" def test_rearrange_5(): assert rearrangeString(\\"aaa\\") == \\"\\" def test_rearrange_6(): rearranged = rearrangeString(\\"aabbcc\\") is_valid = all(rearranged[i] != rearranged[i + 1] for i in range(len(rearranged) - 1)) assert is_valid and set(rearranged) == {\\"a\\", \\"b\\", \\"c\\"} def test_rearrange_7(): rearranged = rearrangeString(\\"aaabc\\") is_valid = all(rearranged[i] != rearranged[i + 1] for i in range(len(rearranged) - 1)) assert is_valid and set(rearranged) == {\\"a\\", \\"b\\", \\"c\\"} def test_rearrange_empty(): assert rearrangeString(\\"\\") == \\"\\"","solution":"from heapq import heappush, heappop from collections import Counter def rearrangeString(s: str) -> str: # Count frequency of each character counter = Counter(s) max_heap = [] # Create a max heap based on the count of characters for char, freq in counter.items(): heappush(max_heap, (-freq, char)) result = [] prev_freq, prev_char = 0, '' while max_heap: freq, char = heappop(max_heap) result.append(char) # Since we used one instance of \`char\`, we need to update the previous frequency (if valid) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # Update previous character and its frequency for the next round prev_freq, prev_char = freq + 1, char # Decrease frequency as we've used one char rearranged_string = ''.join(result) # If the rearranged string's length is equal to the original string's length, it's successfully rearranged if len(rearranged_string) == len(s): return rearranged_string else: return \\"\\" # Example usage: # print(rearrangeString(\\"aab\\")) # Should print something like \\"aba\\" # print(rearrangeString(\\"aaab\\")) # Should print \\"\\""},{"question":"def three_sum_exists(arr, k): Determines if there exist three distinct elements in the array whose sum is exactly k. Parameters: arr: List[int], the list of numbers k: int, the target sum Returns: str: \\"YES\\" if there exist such three elements, \\"NO\\" otherwise def test_three_sum_exists_positive_case(): arr = [1, 4, 45, 6, 10, 8, 12, -3] k = 22 result = three_sum_exists(arr, k) assert result == \\"YES\\" def test_three_sum_exists_no_case(): arr = [1, 2, 3, 4, 5] k = 50 result = three_sum_exists(arr, k) assert result == \\"NO\\" def test_three_sum_exists_with_duplicates(): arr = [1, 2, 4, 2, 1, 6, 7] k = 13 result = three_sum_exists(arr, k) assert result == \\"YES\\" def test_three_sum_exists_negative_numbers(): arr = [-5, 1, 10, -3, 7, 5, 2] k = 12 result = three_sum_exists(arr, k) assert result == \\"YES\\" def test_three_sum_exists_large_numbers(): arr = [10**9, 10**9, 10**9] k = 3 * (10**9) result = three_sum_exists(arr, k) assert result == \\"YES\\" def test_three_sum_exists_no_valid_triplet(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] k = 100 result = three_sum_exists(arr, k) assert result == \\"NO\\"","solution":"def three_sum_exists(arr, k): Determines if there exist three distinct elements in the array whose sum is exactly k. Parameters: arr: List[int], the list of numbers k: int, the target sum Returns: str: \\"YES\\" if there exist such three elements, \\"NO\\" otherwise n = len(arr) arr.sort() for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: return \\"YES\\" elif current_sum < k: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def findLongestWord(s: str, dictionary: List[str]) -> str: Given a string s and an array of strings dict, return the longest string in dict that can be formed by deleting some characters of the given string s. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. >>> findLongestWord(\\"abpcplea\\", [\\"ale\\",\\"apple\\",\\"monkey\\",\\"plea\\"]) \\"apple\\" >>> findLongestWord(\\"abpcplea\\", [\\"a\\",\\"b\\",\\"c\\"]) \\"a\\" pass # Your code here from typing import List def test_example_1(): s = \\"abpcplea\\" dictionary = [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"] assert findLongestWord(s, dictionary) == \\"apple\\" def test_example_2(): s = \\"abpcplea\\" dictionary = [\\"a\\", \\"b\\", \\"c\\"] assert findLongestWord(s, dictionary) == \\"a\\" def test_no_possible_result(): s = \\"xyz\\" dictionary = [\\"a\\", \\"b\\", \\"c\\"] assert findLongestWord(s, dictionary) == \\"\\" def test_lexicographical_order(): s = \\"abpcplea\\" dictionary = [\\"ale\\", \\"apples\\", \\"apple\\"] assert findLongestWord(s, dictionary) == \\"apple\\" def test_multiple_longest_words(): s = \\"abpcplea\\" dictionary = [\\"plea\\", \\"alea\\", \\"banana\\"] assert findLongestWord(s, dictionary) == \\"alea\\"","solution":"def findLongestWord(s, dictionary): def is_subsequence(x): it = iter(s) return all(char in it for char in x) dictionary.sort(key=lambda x: (-len(x), x)) for word in dictionary: if is_subsequence(word): return word return \\"\\""},{"question":"def min_candies(ratings): Calculate the minimum number of candies required for the given ratings list such that each individual gets at least one candy and individuals with higher ratings get more candies than their neighbors. >>> min_candies([1, 0, 2]) 5 >>> min_candies([1, 2, 2]) 4 >>> min_candies([5]) 1 >>> min_candies([3, 3, 3, 3, 3]) 5 >>> min_candies([5, 4, 3, 2, 1]) 15 >>> min_candies([1, 2, 3, 4, 5]) 15 >>> min_candies([1, 3, 2, 2, 2, 1]) 8","solution":"def min_candies(ratings): Calculate the minimum number of candies required for the given ratings list such that each individual gets at least one candy and individuals with higher ratings get more candies than their neighbors. n = len(ratings) candies = [1] * n # First pass: Scan from left to right for i in range(1, n): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 # Second pass: Scan from right to left for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) return sum(candies)"},{"question":"def shift_string(s: str, k: int) -> str: Perform a shift on a string consisting of English alphabets, replacing each character with the character that is \`k\` positions ahead in the alphabet. >>> shift_string(\\"abz\\", 1) \\"bca\\" >>> shift_string(\\"Zebra\\", 2) \\"Bgdtc\\" >>> shift_string(\\"Hello\\", 5) \\"Mjqqt\\" >>> shift_string(\\"world\\", 0) \\"world\\"","solution":"def shift_string(s: str, k: int) -> str: def shift_char(c, k): if 'a' <= c <= 'z': # Lowercase letters return chr((ord(c) - ord('a') + k) % 26 + ord('a')) elif 'A' <= c <= 'Z': # Uppercase letters return chr((ord(c) - ord('A') + k) % 26 + ord('A')) else: return c # Non-alphabetic characters stay the same return ''.join(shift_char(c, k) for c in s)"},{"question":"def is_valid_mountain(heights) -> str: Determine if the given height pattern is valid according to the mountain range rules. >>> is_valid_mountain([1, 2, 3, 2, 1]) == \\"valid\\" >>> is_valid_mountain([1, 1, 1, 2, 1, 1]) == \\"invalid\\" >>> is_valid_mountain([1, 2, 4, 2, 1]) == \\"valid\\" >>> is_valid_mountain([1, 2, 1, 2]) == \\"invalid\\" pass def validate_rails(R, rails) -> [str]: Validate multiple rail height patterns. >>> validate_rails(4, [ [5, [1, 2, 3, 2, 1]], [6, [1, 1, 1, 2, 1, 1]], [5, [1, 2, 4, 2, 1]], [4, [1, 2, 1, 2]] ]) == [\\"valid\\", \\"invalid\\", \\"valid\\", \\"invalid\\"] pass","solution":"def is_valid_mountain(heights): n = len(heights) if n < 3 or heights[0] != 1 or heights[-1] != 1: return \\"invalid\\" peak_found = False for i in range(1, n): if peak_found: if heights[i] > heights[i-1]: return \\"invalid\\" else: if heights[i] < heights[i-1]: peak_found = True elif heights[i] == heights[i-1]: return \\"invalid\\" if not peak_found: return \\"invalid\\" return \\"valid\\" def validate_rails(R, rails): results = [] for i in range(R): n = rails[i][0] heights = rails[i][1] results.append(is_valid_mountain(heights)) return results"},{"question":"def optimize_schedule(tasks: List[Tuple[int, bool]], threshold: int) -> Tuple[List[Tuple[int, bool]], List[Tuple[int, bool]]]: Returns two lists: one for filtered mandatory tasks and another for optional tasks. :param tasks: List[Tuple[int, bool]], a list of tasks each represented as a tuple (cost, mandatory) :param threshold: int, maximum total cost for mandatory tasks :return: Tuple[List[Tuple[int, bool]], List[Tuple[int, bool]]], a tuple containing two lists >>> optimize_schedule([(10, True), (15, False), (20, True), (5, False), (30, True)], 40) ([(10, True), (20, True)], [(15, False), (5, False), (30, True)]) >>> optimize_schedule([(10, False), (20, True), (35, True), (5, True), (50, False)], 30) ([(20, True), (5, True)], [(10, False), (35, True), (50, False)])","solution":"def optimize_schedule(tasks, threshold): Returns two lists: one for filtered mandatory tasks and another for optional tasks. :param tasks: List[Tuple[int, bool]], a list of tasks each represented as a tuple (cost, mandatory) :param threshold: int, maximum total cost for mandatory tasks :return: Tuple[List[Tuple[int, bool]], List[Tuple[int, bool]]], a tuple containing two lists mandatory_tasks = [] optional_tasks = [] for task in tasks: cost, mandatory = task if mandatory: if sum(t[0] for t in mandatory_tasks) + cost <= threshold: mandatory_tasks.append(task) else: optional_tasks.append(task) else: optional_tasks.append(task) return mandatory_tasks, optional_tasks"},{"question":"def full_crates_packed(widgets_per_hour, crate_capacity, total_hours): Calculate the number of full crates packed after a given number of hours. Parameters: widgets_per_hour (int): The rate at which widgets are produced per hour (1 â‰¤ widgets_per_hour â‰¤ 10^6). crate_capacity (int): The capacity of each crate (1 â‰¤ crate_capacity â‰¤ 10^6). total_hours (int): Total hours the factory has been operating (1 â‰¤ total_hours â‰¤ 10^6). Returns: int: The number of full crates packed. Examples: >>> full_crates_packed(5, 10, 24) 12 >>> full_crates_packed(7, 3, 48) 112 >>> full_crates_packed(100, 1000, 25) 2 pass","solution":"def full_crates_packed(widgets_per_hour, crate_capacity, total_hours): Calculate the number of full crates packed after a given number of hours. Parameters: widgets_per_hour (int): The rate at which widgets are produced per hour. crate_capacity (int): The capacity of each crate. total_hours (int): Total hours the factory has been operating. Returns: int: The number of full crates packed. total_widgets = widgets_per_hour * total_hours return total_widgets // crate_capacity"},{"question":"def count_zero_filled_subarrays(nums: List[int]) -> int: Returns the number of distinct zero-filled subarrays in the given list of integers. >>> count_zero_filled_subarrays([1, 3, 0, 0, 2, 0, 0, 4]) 6 >>> count_zero_filled_subarrays([0, 0, 0, 2, 0, 0]) 9 >>> count_zero_filled_subarrays([2, 10, 2019]) 0","solution":"def count_zero_filled_subarrays(nums): Returns the number of distinct zero-filled subarrays in the given list of integers. count = 0 zero_streak = 0 for num in nums: if num == 0: zero_streak += 1 count += zero_streak else: zero_streak = 0 return count"},{"question":"from typing import List def find_unique_subsets(arr: List[int]) -> List[List[int]]: Returns all unique subsets of the given list in lexicographical order. def format_subsets_for_output(subsets: List[List[int]]) -> str: Converts each subset into a string in the form of space-separated integers. def unique_subsets(N: int, elements: List[int]) -> str: Finds all unique subsets and formats them for output. >>> unique_subsets(3, [4, 4, 4]) '[]n[4]n[4 4]n[4 4 4]' >>> unique_subsets(0, []) '[]' >>> unique_subsets(3, [1, 2, 3]) '[]n[1]n[1 2]n[1 2 3]n[1 3]n[2]n[2 3]n[3]'","solution":"def find_unique_subsets(arr): Returns all unique subsets of the given list in lexicographical order. def backtrack(start, path): result.append(path[:]) for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue path.append(arr[i]) backtrack(i + 1, path) path.pop() arr.sort() result = [] backtrack(0, []) return result def format_subsets_for_output(subsets): Converts each subset into a string in the form of space-separated integers. formatted_subsets = [] for subset in subsets: if subset: formatted_subsets.append(\\"[{}]\\".format(\\" \\".join(map(str, subset)))) else: formatted_subsets.append(\\"[]\\") return \\"n\\".join(formatted_subsets) # Example solution function to be used with input def unique_subsets(N, elements): if N == 0: return \\"[]\\" subsets = find_unique_subsets(elements) return format_subsets_for_output(subsets)"},{"question":"def sum_odd_indices(lst: List[int]) -> Union[int, str]: Returns the sum of all integers at odd indices (1-based index) in the list. If the list is empty or contains more than 50 elements, returns \\"invalid list\\". >>> sum_odd_indices([10, 20, 30, 40, 50, 60]) 90 >>> sum_odd_indices([1]) 0 >>> sum_odd_indices([]) \\"invalid list\\" >>> sum_odd_indices(list(range(51))) \\"invalid list\\" >>> sum_odd_indices([1, 2, 3]) 2 >>> sum_odd_indices([10, 20, 30, 40, 50]) 60 >>> sum_odd_indices([1000000, 2000000, 3000000, 4000000]) 6000000","solution":"def sum_odd_indices(lst): Returns the sum of all integers at odd indices (1-based index) in the list. If the list is empty or contains more than 50 elements, returns \\"invalid list\\". if len(lst) == 0 or len(lst) > 50: return \\"invalid list\\" return sum(lst[i] for i in range(1, len(lst), 2))"},{"question":"def binary_to_decimal(binary_str: str) -> int: Converts a binary string to its equivalent decimal number. Handles both positive and negative binary numbers. Args: binary_str (str): A string representing a binary number, starting with '0' or '1' for positive numbers, or '-' for negative numbers. Returns: int: The decimal equivalent of the binary number. >>> binary_to_decimal(\\"1101\\") 13 >>> binary_to_decimal(\\"0\\") 0 >>> binary_to_decimal(\\"-1101\\") -13","solution":"def binary_to_decimal(binary_str): Converts a binary string to its equivalent decimal number. Handles both positive and negative binary numbers. Args: binary_str (str): A string representing a binary number, starting with '0' or '1' for positive numbers, or '-' for negative numbers. Returns: int: The decimal equivalent of the binary number. if binary_str[0] == '-': return -int(binary_str[1:], 2) return int(binary_str, 2)"},{"question":"def flip_vertical_axis(grid: List[List[int]]) -> List[List[int]]: This function flips the image (grid) vertically. >>> flip_vertical_axis([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 8, 9], [4, 5, 6], [1, 2, 3] ] >>> flip_vertical_axis([ ... [1, 1, 1], ... [0, 0, 0] ... ]) [ [0, 0, 0], [1, 1, 1] ]","solution":"from typing import List def flip_vertical_axis(grid: List[List[int]]) -> List[List[int]]: This function flips the image (grid) vertically. m = len(grid) for i in range(m // 2): grid[i], grid[m - i - 1] = grid[m - i - 1], grid[i] return grid"},{"question":"def max_non_overlapping_events(test_cases): Determine the maximum number of non-overlapping events that can be attended. Args: test_cases: List of test cases, each containing a list of tuples (start, end) Returns: List of integers, where each integer is the maximum number of non-overlapping events for the corresponding test case. def parse_input(input_data): Parse the input data to extract test cases for the max_non_overlapping_events function. Args: input_data: String containing the input data. Returns: List of test cases, where each test case is a list of tuples (start, end) representing the events. import pytest from solution import max_non_overlapping_events, parse_input def test_example_case_1(): input_data = 2 3 1 2 2 3 3 4 4 1 3 3 4 4 6 2 5 test_cases = parse_input(input_data) result = max_non_overlapping_events(test_cases) assert result == [3, 3] def test_no_overlap(): input_data = 1 3 1 2 3 4 5 6 test_cases = parse_input(input_data) result = max_non_overlapping_events(test_cases) assert result == [3] def test_all_overlap(): input_data = 1 3 1 4 2 5 3 6 test_cases = parse_input(input_data) result = max_non_overlapping_events(test_cases) assert result == [1] def test_mixed_overlap(): input_data = 1 5 1 2 2 3 3 4 4 5 5 6 test_cases = parse_input(input_data) result = max_non_overlapping_events(test_cases) assert result == [5] def test_large_number_of_events(): input_data = 1 4 1 10 2 3 3 5 4 8 test_cases = parse_input(input_data) result = max_non_overlapping_events(test_cases) assert result == [2] def test_no_event(): input_data = 1 0 test_cases = parse_input(input_data) result = max_non_overlapping_events(test_cases) assert result == [0]","solution":"def max_non_overlapping_events(test_cases): results = [] for events in test_cases: events.sort(key=lambda x: x[1]) # Sort events based on their end times max_events = 0 last_end_time = 0 for start, end in events: if start >= last_end_time: max_events += 1 last_end_time = end results.append(max_events) return results def parse_input(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) index += 1 events = [] for _ in range(N): start, end = map(int, input_lines[index].split()) events.append((start, end)) index += 1 test_cases.append(events) return test_cases"},{"question":"from collections import deque def process_commands(commands): Process a list of commands to manage a deque. >>> process_commands([\\"append 1\\", \\"append 2\\", \\"appendleft 3\\", \\"pop\\", \\"popleft\\", \\"append 4\\"]) deque(['1', '4']) >>> process_commands([\\"append 10\\"]) deque(['10']) >>> process_commands([\\"appendleft 5\\"]) deque(['5']) >>> process_commands([\\"append 1\\", \\"pop\\", \\"append 2\\", \\"popleft\\"]) deque([]) >>> process_commands([]) deque([]) pass def print_line(d): Print the contents of the deque as a space-separated line. >>> d = deque([\\"10\\", \\"20\\", \\"30\\"]) >>> print_line(d) 10 20 30 >>> d = deque() >>> print_line(d) pass","solution":"from collections import deque def process_commands(commands): d = deque() for command in commands: if command.startswith(\\"append \\"): x = command.split()[1] d.append(x) elif command.startswith(\\"appendleft \\"): x = command.split()[1] d.appendleft(x) elif command == \\"pop\\": if d: d.pop() elif command == \\"popleft\\": if d: d.popleft() return d def print_line(d): if d: print(\\" \\".join(d)) else: print(\\"\\")"},{"question":"from typing import List def generateSymmetricMatrix(n: int) -> List[List[int]]: Generates an n x n symmetric matrix with specific properties. :param n: Size of the matrix :return: An n x n symmetric matrix The elements of the matrix satisfy the following conditions: 1. Each element on the main diagonal (i.e., where row index equals column index) is a unique integer starting from 1 up to n. 2. For elements not on the main diagonal (i.e., where row index does not equal column index), the value is the sum of the row and column indices. >>> generateSymmetricMatrix(3) [[1, 3, 4], [3, 2, 5], [4, 5, 3]] >>> generateSymmetricMatrix(4) [[1, 3, 4, 5], [3, 2, 5, 6], [4, 5, 3, 7], [5, 6, 7, 4]]","solution":"from typing import List def generateSymmetricMatrix(n: int) -> List[List[int]]: Generates an n x n symmetric matrix with specific properties. :param n: Size of the matrix :return: An n x n symmetric matrix matrix = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): if i == j: matrix[i][j] = i + 1 else: matrix[i][j] = i + 1 + j + 1 return matrix"},{"question":"from itertools import groupby def group_and_count(integers): Groups the integers by their value and prints a summary of each group, showing the value and the count of integers in that group. Parameters: integers (list of int): A list of integers to be grouped. >>> group_and_count([2, 3, 3, 2, 2, 1]) 1 1 2 3 3 2 >>> group_and_count([5]) 5 1 >>> group_and_count([4, 4, 4, 4, 4]) 4 5","solution":"from itertools import groupby def group_and_count(integers): Groups the integers by their value and prints a summary of each group, showing the value and the count of integers in that group. Parameters: integers (list of int): A list of integers to be grouped. sorted_integers = sorted(integers) groups = groupby(sorted_integers) for key, group in groups: print(key, len(list(group)))"},{"question":"from datetime import datetime, timedelta from typing import List, Tuple, Set def detect_brute_force(login_attempts: List[Tuple[str, str]], threshold: int) -> Set[str]: Detects IP addresses with potential brute-force attack attempts. Parameters: login_attempts (list of tuples): List of (timestamp, IP address) tuples. threshold (int): Number of attempts considered as brute-force in a 5-minute window. Returns: set: Set of IP addresses identified as potential brute-force attackers. pass def test_detect_brute_force_example_case(): login_attempts = [ (\\"2023-10-01 10:00:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:01:30\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:04:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:06:00\\", \\"10.0.0.1\\"), (\\"2023-10-01 10:07:30\\", \\"10.0.0.1\\"), (\\"2023-10-01 10:08:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:09:50\\", \\"192.168.1.1\\"), ] threshold = 3 assert detect_brute_force(login_attempts, threshold) == {\\"192.168.1.1\\"} def test_detect_brute_force_no_attacks(): login_attempts = [ (\\"2023-10-01 10:00:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:10:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:21:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:35:00\\", \\"10.0.0.1\\"), (\\"2023-10-01 10:45:00\\", \\"10.0.0.1\\"), ] threshold = 3 assert detect_brute_force(login_attempts, threshold) == set() def test_detect_brute_force_multiple_ips(): login_attempts = [ (\\"2023-10-01 10:00:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:01:30\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:03:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:00:00\\", \\"10.0.0.1\\"), (\\"2023-10-01 10:01:30\\", \\"10.0.0.1\\"), (\\"2023-10-01 10:03:00\\", \\"10.0.0.1\\"), ] threshold = 3 assert detect_brute_force(login_attempts, threshold) == {\\"192.168.1.1\\", \\"10.0.0.1\\"} def test_detect_brute_force_edge_case(): login_attempts = [ (\\"2023-10-01 10:00:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:04:59\\", \\"192.168.1.1\\"), (\\"2023-10-01 10:09:50\\", \\"192.168.1.1\\"), ] threshold = 3 assert detect_brute_force(login_attempts, threshold) == set() def test_detect_brute_force_large_window_lower_than_threshold(): login_attempts = [ (\\"2023-10-01 10:00:00\\", \\"192.168.1.1\\"), (\\"2023-10-01 11:00:00\\", \\"192.168.1.1\\"), ] threshold = 3 assert detect_brute_force(login_attempts, threshold) == set()","solution":"from datetime import datetime, timedelta def detect_brute_force(login_attempts, threshold): Detects IP addresses with potential brute-force attack attempts. Parameters: login_attempts (list of tuples): List of (timestamp, IP address) tuples. threshold (int): Number of attempts considered as brute-force in a 5-minute window. Returns: set: Set of IP addresses identified as potential brute-force attackers. from collections import defaultdict, deque # Convert timestamps to datetime objects and consolidate attempts by IP attempts_by_ip = defaultdict(deque) for timestamp, ip in login_attempts: time = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") attempts_by_ip[ip].append(time) brute_force_ips = set() for ip, times in attempts_by_ip.items(): times = deque(sorted(times)) window = deque() for time in times: window.append(time) while window and window[0] < time - timedelta(minutes=5): window.popleft() if len(window) >= threshold: brute_force_ips.add(ip) break return brute_force_ips"},{"question":"def find_max(nums: List[int]) -> int: Finds the greatest element in an array that first increases and then decreases. Args: nums: List[int] - A list of integers. Returns: int - The greatest element in the array. Examples: >>> find_max([1, 3, 7, 8, 6, 4, 2]) 8 >>> find_max([2, 4, 6, 9, 7, 5, 1]) 9","solution":"def find_max(nums): Finds the greatest element in an array that first increases and then decreases. Args: nums: List[int] - A list of integers. Returns: int - The greatest element in the array. return max(nums)"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. Each word in the sentence is separated by a single space and there should be no leading or trailing spaces in the output. Preserve the capitalization and punctuation of the original words. >>> reverse_words(\\"Hello World\\") 'World Hello' >>> reverse_words(\\"The quick brown fox\\") 'fox brown quick The' >>> reverse_words(\\"Python is great!\\") 'great! is Python' pass","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def is_palindrome(x: int) -> bool: Helper function that checks if a given number x is a palindrome. return str(x) == str(x)[::-1] def next_palindrome(n: int) -> int: Takes a positive integer n and returns the smallest palindrome number larger than n. >>> next_palindrome(123) -> 131 >>> next_palindrome(489) -> 494 >>> next_palindrome(99) -> 101","solution":"def is_palindrome(x): Helper function that checks if a given number x is a palindrome. return str(x) == str(x)[::-1] def next_palindrome(n): Takes a positive integer n and returns the smallest palindrome number larger than n. n += 1 while not is_palindrome(n): n += 1 return n"},{"question":"def reverse_string_using_reversed(s: str) -> str: Returns the reversed string using the reversed() function. >>> reverse_string_using_reversed(\\"hello\\") 'olleh' >>> reverse_string_using_reversed(\\"world\\") 'dlrow' pass def reverse_string_using_slicing(s: str) -> str: Returns the reversed string using slicing. >>> reverse_string_using_slicing(\\"hello\\") 'olleh' >>> reverse_string_using_slicing(\\"world\\") 'dlrow' pass","solution":"def reverse_string_using_reversed(s): Returns the reversed string using the reversed() function. return ''.join(reversed(s)) def reverse_string_using_slicing(s): Returns the reversed string using slicing. return s[::-1]"},{"question":"def get_strongest_warrior(T: int, test_cases: list) -> list: Determines the strongest warrior for each test case. Parameters: T (int): The number of test cases. test_cases (list): List of tuples, each containing the number of warriors and their respective strength levels. Returns: list: List of integers representing the strength level of the final winner for each test case. Examples: >>> get_strongest_warrior(2, [(5, [10, 30, 20, 50, 40]), (4, [1, 2, 3, 4])]) [50, 4] >>> get_strongest_warrior(1, [(1, [100])]) [100]","solution":"def get_strongest_warrior(T, test_cases): Determines the strongest warrior for each test case. Parameters: T (int): The number of test cases. test_cases (list): List of tuples, each containing the number of warriors and their respective strength levels. Returns: list: List of integers representing the strength level of the final winner for each test case. def fight(warriors): while len(warriors) > 1: next_round = [] for i in range(0, len(warriors), 2): if i + 1 < len(warriors): next_round.append(max(warriors[i], warriors[i + 1])) else: next_round.append(warriors[i]) warriors = next_round return warriors[0] results = [] for test_case in test_cases: N, warriors = test_case results.append(fight(warriors)) return results"},{"question":"def num_islands(grid: List[List[str]]) -> int: Count the number of distinct islands in a grid. >>> num_islands([ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '1', '1'], ... ['0', '0', '0', '1', '1'], ... ['0', '0', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'] ... ]) 3 >>> num_islands([ ... ['1', '1', '1', '1', '0'], ... ['1', '1', '0', '1', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '0', '0', '0'] ... ]) 1 >>> num_islands([ ... ['1', '0', '0', '0'], ... ['0', '1', '0', '0'], ... ['0', '0', '1', '0'], ... ['0', '0', '0', '1'] ... ]) 4 >>> num_islands([]) 0 >>> num_islands([['1']]) 1 >>> num_islands([['0']]) 0","solution":"def num_islands(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0': return grid[i][j] = '0' # mark as visited dfs(i-1, j) # up dfs(i+1, j) # down dfs(i, j-1) # left dfs(i, j+1) # right count = 0 for i in range(m): for j in range(n): if grid[i][j] == '1': dfs(i, j) count += 1 return count"},{"question":"def shortest_subarray_sum_gte_k(arr: List[int], k: int) -> int: Finds the length of the shortest subarray with a sum greater than or equal to k. If no such subarray exists, returns -1. >>> shortest_subarray_sum_gte_k([2, 1, 3, 4, 1, 1, 2, 3], 7) 2 >>> shortest_subarray_sum_gte_k([1, 2, 3], 6) 3 >>> shortest_subarray_sum_gte_k([1, 2], 5) -1 def test_example_1(): arr = [2, 1, 3, 4, 1, 1, 2, 3] k = 7 assert shortest_subarray_sum_gte_k(arr, k) == 2 def test_example_2(): arr = [1, 2, 3] k = 6 assert shortest_subarray_sum_gte_k(arr, k) == 3 def test_example_3(): arr = [1, 2] k = 5 assert shortest_subarray_sum_gte_k(arr, k) == -1 def test_large_k(): arr = [1, 2, 3, 4, 5] k = 15 assert shortest_subarray_sum_gte_k(arr, k) == 5 def test_single_element_pass(): arr = [10] k = 5 assert shortest_subarray_sum_gte_k(arr, k) == 1 def test_single_element_fail(): arr = [4] k = 5 assert shortest_subarray_sum_gte_k(arr, k) == -1 def test_subarray_at_start(): arr = [5, 1, 1, 1] k = 5 assert shortest_subarray_sum_gte_k(arr, k) == 1 def test_multiple_valid_subarrays(): arr = [1, 2, 2, 3, 4, 1] k = 7 assert shortest_subarray_sum_gte_k(arr, k) == 2 def test_no_positive_subarray(): arr = [1, -1, 2, -2, 3, -3] k = 4 assert shortest_subarray_sum_gte_k(arr, k) == -1","solution":"def shortest_subarray_sum_gte_k(arr, k): from collections import deque n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] deque_index = deque() min_length = n + 1 for i in range(n + 1): while deque_index and prefix_sum[i] - prefix_sum[deque_index[0]] >= k: min_length = min(min_length, i - deque_index.popleft()) while deque_index and prefix_sum[i] <= prefix_sum[deque_index[-1]]: deque_index.pop() deque_index.append(i) return min_length if min_length <= n else -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: Determine if the binary tree is balanced. A balanced binary tree is defined as one in which the depth of the two subtrees of every node never differ by more than one. >>> node1 = TreeNode(3) >>> node2 = TreeNode(9) >>> node3 = TreeNode(20) >>> node4 = TreeNode(15) >>> node5 = TreeNode(7) >>> node1.left = node2 >>> node1.right = node3 >>> node3.left = node4 >>> node3.right = node5 >>> is_balanced(node1) True >>> node1 = TreeNode(1) >>> node2 = TreeNode(2) >>> node3 = TreeNode(2) >>> node4 = TreeNode(3) >>> node5 = TreeNode(3) >>> node6 = TreeNode(4) >>> node7 = TreeNode(4) >>> node1.left = node2 >>> node1.right = node3 >>> node2.left = node4 >>> node2.right = node5 >>> node4.left = node6 >>> node4.right = node7 >>> is_balanced(node1) False >>> is_balanced(None) True >>> node = TreeNode(1) >>> is_balanced(node) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def height_and_balanced(node): if not node: return 0, True left_height, left_balanced = height_and_balanced(node.left) right_height, right_balanced = height_and_balanced(node.right) current_height = max(left_height, right_height) + 1 current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced _, balanced = height_and_balanced(root) return balanced"},{"question":"def can_reach_end(maze: List[List[str]]) -> bool: Determines if it is possible to reach the bottom-right corner of the maze starting from the top-left corner, only passing through walkable land ('.') and not water ('W'). Arguments: maze -- list of lists of characters representing the maze. Returns: True if there is a path from the start (0, 0) to the end (n-1, n-1), otherwise False. Examples: >>> maze = [ ... ['.', 'W', '.'], ... ['.', '.', 'W'], ... ['W', '.', '.'] ... ] >>> can_reach_end(maze) True >>> maze = [ ... ['.', 'W', 'W'], ... ['W', '.', 'W'], ... ['W', 'W', '.'] ... ] >>> can_reach_end(maze) False","solution":"def can_reach_end(maze): Determines if it is possible to reach the bottom-right corner of the maze starting from the top-left corner, only passing through walkable land ('.') and not water ('W'). Arguments: maze -- list of lists of characters representing the maze. Returns: True if there is a path from the start (0, 0) to the end (n-1, n-1), otherwise False. n = len(maze) if maze[0][0] == 'W' or maze[n-1][n-1] == 'W': return False def dfs(x, y, visited): if x == n-1 and y == n-1: return True visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and maze[nx][ny] == '.': if dfs(nx, ny, visited): return True return False visited = set() return dfs(0, 0, visited)"},{"question":"def largest_square_of_ones(grids): Find the size of the largest square containing only 1s in each grid. >>> largest_square_of_ones([(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]), (4, 5, [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]])]) [3, 2] >>> largest_square_of_ones([(2, 2, [[0, 0], [0, 0]])]) [0] >>> largest_square_of_ones([(2, 2, [[1, 1], [1, 1]])]) [2] def test_largest_square_of_ones(): input_data_1 = \\"2n3 3n1 1 1n1 1 1n1 1 1n4 5n1 0 1 0 0n1 0 1 1 1n1 1 1 1 1n1 0 0 1 0\\" expected_output_1 = \\"3n2\\" assert solve(input_data_1) == expected_output_1 input_data_2 = \\"1n2 2n0 0n0 0\\" expected_output_2 = \\"0\\" assert solve(input_data_2) == expected_output_2 input_data_3 = \\"1n2 2n1 1n1 1\\" expected_output_3 = \\"2\\" assert solve(input_data_3) == expected_output_3 input_data_4 = \\"1n4 4n1 1 1 0n1 1 1 0n1 1 1 1n0 0 1 1\\" expected_output_4 = \\"3\\" assert solve(input_data_4) == expected_output_4 input_data_5 = \\"3n2 2n1 0n0 1n3 3n1 0 1n0 1 0n1 1 1n4 4n1 1 1 1n1 1 0 1n1 1 0 0n1 1 1 1\\" expected_output_5 = \\"1n1n2\\" assert solve(input_data_5) == expected_output_5 if __name__ == \\"__main__\\": test_largest_square_of_ones() print(\\"All tests passed.\\")","solution":"def largest_square_of_ones(grids): def find_largest_square(grid, n, m): max_side = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side results = [] for grid in grids: n, m = grid[0] matrix = grid[1] results.append(find_largest_square(matrix, n, m)) return results # Reading the inputs and creating a list of grids to process def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) grids = [] index = 1 for _ in range(T): n, m = map(int, input_lines[index].strip().split()) grid = [] for i in range(n): grid.append(list(map(int, input_lines[index + 1 + i].strip().split()))) grids.append(((n, m), grid)) index += n + 1 return grids def solve(input_data): grids = process_input(input_data) results = largest_square_of_ones(grids) return \\"n\\".join(map(str, results))"},{"question":"from typing import List def rotateRight(arr: List[int], k: int) -> List[int]: Rotates an array to the right by k positions. >>> rotateRight([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotateRight([10, 20, 30, 40, 50], 3) == [30, 40, 50, 10, 20] >>> rotateRight([-1, -10, -100, -1000], 1) == [-1000, -1, -10, -100] pass","solution":"def rotateRight(arr, k): Rotates an array to the right by k positions. :param arr: List of integers :param k: Integer, number of positions to rotate :return: Rotated list if not arr or k <= 0: return arr n = len(arr) k = k % n # In case k is larger than array size return arr[-k:] + arr[:-k]"},{"question":"def filter_employees(hours: List[int], threshold: int) -> List[str]: Determines whether each employee works at least the threshold number of hours. Parameters: hours (list): A list of integers representing hours worked by each employee. threshold (int): The minimum required working hours per week. Returns: list: A list of \\"Yes\\" or \\"No\\" for each employee. >>> filter_employees([40, 50, 35, 45, 60], 40) [\\"Yes\\", \\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"] >>> filter_employees([20, 30, 35], 40) [\\"No\\", \\"No\\", \\"No\\"]","solution":"def filter_employees(hours, threshold): Determines whether each employee works at least the threshold number of hours. Parameters: hours (list): A list of integers representing hours worked by each employee. threshold (int): The minimum required working hours per week. Returns: list: A list of \\"Yes\\" or \\"No\\" for each employee. return [\\"Yes\\" if hour >= threshold else \\"No\\" for hour in hours]"},{"question":"def find_max_min_diff(arr): Returns the difference between the largest and smallest values in the array. Parameters: arr (list): A list of integers. Returns: int: The difference between the largest and smallest values. Examples: >>> find_max_min_diff([3, 1, 4, 1, 5, 9]) 8 >>> find_max_min_diff([10, -2, 33, 45, 23, 7]) 47 >>> find_max_min_diff([-10, -20, -30, -40]) 30 >>> find_max_min_diff([5]) 0 >>> find_max_min_diff([]) 0 >>> find_max_min_diff([7, 7, 7, 7]) 0","solution":"def find_max_min_diff(arr): Returns the difference between the largest and smallest values in the array. Parameters: arr (list): A list of integers. Returns: int: The difference between the largest and smallest values. if not arr: return 0 return max(arr) - min(arr)"},{"question":"from typing import List, Tuple, Union def find(parent, i): Function to find the parent of node i pass def union(parent, rank, x, y): Function to perform union of two sets x and y pass def kruskal(n, edges): Kruskal's algorithm to find the MST of a graph pass def minimum_spanning_tree(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> Union[int, str]: Find the total weight of the Minimum Spanning Tree (MST) of the graph using Kruskal's algorithm. Args: n: int: number of nodes. m: int: number of edges. edge_list: List[Tuple[int, int, int]]: List of edges where each edge is a tuple of (u, v, w). Returns: Union[int, str]: Total weight of the MST, or \\"IMPOSSIBLE\\" if no spanning tree is possible. Examples: >>> minimum_spanning_tree(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (4, 2, 5)]) 6 >>> minimum_spanning_tree(2, 0, []) \\"IMPOSSIBLE\\" pass # Unit tests def test_example_case(): assert minimum_spanning_tree(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (4, 2, 5)]) == 6 def test_no_edges(): assert minimum_spanning_tree(1, 0, []) == 0 assert minimum_spanning_tree(2, 0, []) == \\"IMPOSSIBLE\\" assert minimum_spanning_tree(3, 0, []) == \\"IMPOSSIBLE\\" def test_single_edge(): assert minimum_spanning_tree(2, 1, [(1, 2, 10)]) == 10 def test_disconnected_graph(): assert minimum_spanning_tree(3, 1, [(1, 2, 1)]) == \\"IMPOSSIBLE\\" def test_multiple_edges(): assert minimum_spanning_tree(4, 4, [(1, 2, 1), (2, 3, 4), (3, 4, 2), (4, 1, 3)]) == 6 assert minimum_spanning_tree(3, 3, [(1, 2, 3), (1, 3, 1), (2, 3, 1)]) == 2","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: if i >= len(edges): return \\"IMPOSSIBLE\\" u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result.append([u, v, w]) union(parent, rank, x, y) total_weight = sum([w for u, v, w in result]) return total_weight def minimum_spanning_tree(n, m, edge_list): edges = [] for edge in edge_list: u, v, w = edge edges.append((u, v, w)) return kruskal(n, edges)"},{"question":"import numpy as np def concatenate_and_flatten(n: int, m: int, array_a: List[List[int]], array_b: List[List[int]]) -> np.ndarray: Concatenates two NxM arrays along the horizontal axis and then flattens the result. Parameters: - n: int, the number of rows in the supplied arrays. - m: int, the number of columns in the supplied arrays. - array_a: list of lists, the first NxM array. - array_b: list of lists, the second NxM array. Returns: A one-dimensional array obtained by concatenating and flattening the input arrays. def test_concatenate_and_flatten(): # Test Case 1 n, m = 2, 3 array_a = [[1, 2, 3], [4, 5, 6]] array_b = [[7, 8, 9], [10, 11, 12]] result = concatenate_and_flatten(n, m, array_a, array_b) assert (result == np.array([1, 2, 3, 7, 8, 9, 4, 5, 6, 10, 11, 12])).all() # Test Case 2 n, m = 3, 2 array_a = [[1, 2], [3, 4], [5, 6]] array_b = [[7, 8], [9, 10], [11, 12]] result = concatenate_and_flatten(n, m, array_a, array_b) assert (result == np.array([1, 2, 7, 8, 3, 4, 9, 10, 5, 6, 11, 12])).all() # Test Case 3 (Edge Case: 1x1 arrays) n, m = 1, 1 array_a = [[1]] array_b = [[2]] result = concatenate_and_flatten(n, m, array_a, array_b) assert (result == np.array([1, 2])).all() # Test Case 4 (Identical arrays) n, m = 2, 2 array_a = [[1, 1], [1, 1]] array_b = [[1, 1], [1, 1]] result = concatenate_and_flatten(n, m, array_a, array_b) assert (result == np.array([1, 1, 1, 1, 1, 1, 1, 1])).all() def test_concatenate_and_flatten_non_square(): # Test Case 5 (Non-square arrays) n, m = 2, 4 array_a = [[1, 2, 3, 4], [5, 6, 7, 8]] array_b = [[9, 10, 11, 12], [13, 14, 15, 16]] result = concatenate_and_flatten(n, m, array_a, array_b) assert (result == np.array([1, 2, 3, 4, 9, 10, 11, 12, 5, 6, 7, 8, 13, 14, 15, 16])).all()","solution":"import numpy as np def concatenate_and_flatten(n, m, array_a, array_b): Concatenates two NxM arrays along the horizontal axis and then flattens the result. Parameters: - n: int, the number of rows in the supplied arrays. - m: int, the number of columns in the supplied arrays. - array_a: list of lists, the first NxM array. - array_b: list of lists, the second NxM array. Returns: A one-dimensional array obtained by concatenating and flattening the input arrays. array_a = np.array(array_a) array_b = np.array(array_b) concatenated = np.concatenate((array_a, array_b), axis=1) flattened = concatenated.flatten() return flattened"},{"question":"def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome, ignoring spaces and capitalization. Parameters: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"\\") True >>> is_palindrome(\\" \\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Racecar\\") True >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"Hello World\\") False","solution":"def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome, ignoring spaces and capitalization. Parameters: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Remove spaces and convert to lower case cleaned = ''.join(c.lower() for c in s if c.isalnum()) # Compare the cleaned string to its reverse return cleaned == cleaned[::-1]"},{"question":"def compressString(s: str) -> str: Compresses a string using the counts of repeated characters. If the compressed version is not shorter, returns the original string. >>> compressString(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" >>> compressString(\\"abcdef\\") == \\"abcdef\\" >>> compressString(\\"a\\") == \\"a\\" >>> compressString(\\"\\") == \\"\\" >>> compressString(\\"aabbcccc\\") == \\"a2b2c4\\" >>> compressString(\\"aaaaabbbbbccccccddddeeeee\\") == \\"a5b5c6d4e5\\"","solution":"def compressString(s): Compresses a string using the counts of repeated characters. If the compressed version is not shorter, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1]) compressed.append(str(count)) count = 1 # Append the last set of characters compressed.append(s[-1]) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def xor_lists(list1, list2, default=0): Returns a new list where each element is the result of the bitwise XOR operation between the corresponding elements of the input lists. If the lists are of different lengths, the unmatched elements from the longer list should be XORed with the default value. >>> xor_lists([1,2,3], [4,5,6]) [5, 7, 5] >>> xor_lists([1,2], [3,4,5]) [2, 6, 5] >>> xor_lists([7,8,9], [10,11]) [13, 3, 9] >>> xor_lists([2,4], [1,1,1], 2) [3, 5, 3] >>> xor_lists([3,5,7], [1,1,1]) [2, 4, 6]","solution":"def xor_lists(list1, list2, default=0): Returns a new list where each element is the result of the bitwise XOR operation between the corresponding elements of the input lists. If the lists are of different lengths, the unmatched elements from the longer list should be XORed with the default value. max_len = max(len(list1), len(list2)) result = [] for i in range(max_len): val1 = list1[i] if i < len(list1) else default val2 = list2[i] if i < len(list2) else default result.append(val1 ^ val2) return result"},{"question":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int, blocked_nodes: List[int]) -> int: Calculate the shortest travel time from the 'start' node to the 'end' node while avoiding 'blocked_nodes'. >>> graph = { ... 1: [(2, 5), (3, 10)], ... 2: [(4, 2)], ... 3: [(4, 1)], ... 4: [(5, 7)], ... 5: [] ... } >>> start = 1 >>> end = 5 >>> blocked_nodes = [3] >>> shortest_path(graph, start, end, blocked_nodes) 14","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int, blocked_nodes: List[int]) -> int: if start in blocked_nodes or end in blocked_nodes: return -1 blocked_set = set(blocked_nodes) # Priority queue to store (travel_time, current_node) pq = [(0, start)] visited = set() distances = {start: 0} while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) # If we reach the end node, return the travel time if current_node == end: return current_distance for neighbor, travel_time in graph.get(current_node, []): if neighbor in blocked_set or neighbor in visited: continue new_distance = current_distance + travel_time if new_distance < distances.get(neighbor, float('inf')): distances[neighbor] = new_distance heapq.heappush(pq, (new_distance, neighbor)) # If the end node is not reachable return -1"},{"question":"from typing import List def find_length_of_LCS(arr1: List[int], arr2: List[int]) -> int: Find the length of the longest common subarray between two arrays. Args: arr1: List[int] - The first array of integers. arr2: List[int] - The second array of integers. Returns: int - The length of the longest common subarray. Examples: >>> find_length_of_LCS([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]) 3 >>> find_length_of_LCS([0, 1, 1, 1, 1], [1, 1, 1, 1, 0]) 4 pass","solution":"from typing import List def find_length_of_LCS(arr1: List[int], arr2: List[int]) -> int: m, b_len = len(arr1), len(arr2) # Initialize a DP table with (m+1) x (b_len+1) dp = [[0] * (b_len + 1) for _ in range(m + 1)] max_len = 0 # Fill the dp table for i in range(1, m + 1): for j in range(1, b_len + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len"},{"question":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def find_maximum_path_sum(root): Find the maximum sum of nodes for any path in a binary tree. >>> node_values = [4, -10, 3, 5, 2] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> tree_root = build_tree_from_edges(node_values, edges) >>> find_maximum_path_sum(tree_root) 12 def build_tree_from_edges(node_values, edges): Construct a binary tree from node values and edges. >>> node_values = [4, -10, 3, 5, 2] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> build_tree_from_edges(node_values, edges) <__main__.TreeNode object at 0x...> def max_sum_for_all_cases(num_cases, cases): Determine the maximum sum of nodes for any path in given binary trees. >>> num_cases = 2 >>> cases = [ ... (5, [4, -10, 3, 5, 2], [(1, 2), (1, 3), (3, 4), (3, 5)]), ... (3, [1, 2, 3], [(1, 2), (1, 3)]) ... ] >>> max_sum_for_all_cases(num_cases, cases) [12, 6]","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def find_maximum_path_sum(root): def helper(node): nonlocal max_sum if not node: return 0 left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) current_sum = node.value + left_max + right_max max_sum = max(max_sum, current_sum) return node.value + max(left_max, right_max) max_sum = float('-inf') helper(root) return max_sum def build_tree_from_edges(node_values, edges): nodes = {i: TreeNode(value) for i, value in enumerate(node_values, 1)} for u, v in edges: if nodes[u].left is None: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return nodes[1] def max_sum_for_all_cases(num_cases, cases): results = [] for case in cases: N, nodes, edges = case tree_root = build_tree_from_edges(nodes, edges) results.append(find_maximum_path_sum(tree_root)) return results"},{"question":"def sum_of_digits_is_prime(number: int) -> bool: Determines if the sum of the digits of a positive integer \`number\` is a prime number. >>> sum_of_digits_is_prime(113) == True >>> sum_of_digits_is_prime(123) == False >>> sum_of_digits_is_prime(0) == False >>> sum_of_digits_is_prime(7) == True >>> sum_of_digits_is_prime(8) == False >>> sum_of_digits_is_prime(929292929) == True","solution":"def is_prime(n): Determines if a given number \`n\` is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_digits_is_prime(number): Determines if the sum of the digits of \`number\` is a prime number. digit_sum = sum(int(digit) for digit in str(number)) return is_prime(digit_sum)"},{"question":"class TicTacToe: Initialize the TicTacToe board of size n x n. def __init__(self, n: int): :param n: the size of the board, an n x n grid. pass def move(self, row: int, col: int, player: int) -> int: Player {player} places a mark at (row, col) on the board. :param row: row index of the move (0-indexed) :param col: column index of the move (0-indexed) :param player: the player making the move (1 or 2) :return: 0 if no player wins, 1 if Player 1 wins, 2 if Player 2 wins pass # Unit tests def test_tic_tac_toe_no_win(): toe = TicTacToe(3) assert toe.move(0, 0, 1) == 0 assert toe.move(0, 2, 2) == 0 assert toe.move(2, 2, 1) == 0 assert toe.move(1, 1, 2) == 0 assert toe.move(2, 0, 1) == 0 assert toe.move(1, 0, 2) == 0 def test_tic_tac_toe_player1_wins(): toe = TicTacToe(3) toe.move(0, 0, 1) toe.move(0, 2, 2) toe.move(2, 2, 1) toe.move(1, 1, 2) toe.move(2, 0, 1) toe.move(1, 0, 2) assert toe.move(2, 1, 1) == 1 # Player 1 wins def test_tic_tac_toe_player2_wins(): toe = TicTacToe(3) toe.move(0, 0, 1) toe.move(0, 2, 2) toe.move(1, 1, 1) toe.move(1, 2, 2) toe.move(0, 1, 1) assert toe.move(2, 2, 2) == 2 # Player 2 wins def test_tic_tac_toe_diagonal_win(): toe = TicTacToe(3) assert toe.move(0, 0, 1) == 0 assert toe.move(1, 0, 2) == 0 assert toe.move(1, 1, 1) == 0 assert toe.move(2, 0, 2) == 0 assert toe.move(2, 2, 1) == 1 # Player 1 wins diagonally def test_tic_tac_toe_anti_diagonal_win(): toe = TicTacToe(3) assert toe.move(0, 2, 1) == 0 assert toe.move(1, 1, 1) == 0 assert toe.move(1, 0, 2) == 0 assert toe.move(2, 0, 1) == 1 # Player 1 wins anti-diagonally","solution":"class TicTacToe: def __init__(self, n): Initialize the TicTacToe board of size n x n. self.n = n self.board = [[0] * n for _ in range(n)] self.rows = [0] * n self.cols = [0] * n self.diagonal = 0 self.anti_diagonal = 0 def move(self, row, col, player): Player {player} places a mark on the (row, col) cell of the board. Returns: - 0 if no player wins - 1 if Player 1 wins - 2 if Player 2 wins mark = 1 if player == 1 else -1 # update row, column, diagonal, and anti-diagonal self.rows[row] += mark self.cols[col] += mark if row == col: self.diagonal += mark if row + col == self.n - 1: self.anti_diagonal += mark # check for win condition if abs(self.rows[row]) == self.n or abs(self.cols[col]) == self.n or abs(self.diagonal) == self.n or abs(self.anti_diagonal) == self.n: return player return 0"},{"question":"def longest_unique_substring(s: str) -> int: Finds the length of the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"aaaaaa\\") 1 >>> longest_unique_substring(\\"z\\") 1 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> longest_unique_substring(\\"abccbaabcd\\") 4","solution":"def longest_unique_substring(s: str) -> int: Finds the length of the longest substring without repeating characters. char_map = {} start = 0 max_length = 0 for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def can_segment_string(s: str, dictionary: List[str]) -> bool: Determines if a string can be segmented into a space-separated sequence of one or more dictionary words. :param s: String to be segmented. :param dictionary: List of words to be used as dictionary. :return: Boolean value indicating whether the string can be segmented. >>> can_segment_string(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"pear\\", \\"lime\\"]) == True >>> can_segment_string(\\"applepeer\\", [\\"apple\\", \\"pie\\", \\"pear\\", \\"lime\\"]) == False >>> can_segment_string(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"pineapple\\"]) == True >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False >>> can_segment_string(\\"cat\\", [\\"cat\\", \\"dog\\", \\"sand\\", \\"and\\"]) == True >>> can_segment_string(\\"cat\\", [\\"dog\\", \\"sand\\", \\"and\\"]) == False >>> can_segment_string(\\"\\", [\\"apple\\", \\"pie\\", \\"pear\\", \\"lime\\"]) == True >>> can_segment_string(\\"applepie\\", []) == False","solution":"def can_segment_string(s, dictionary): Determines if a string can be segmented into a space-separated sequence of one or more dictionary words. :param s: String to be segmented. :param dictionary: List of words to be used as dictionary. :return: Boolean value indicating whether the string can be segmented. word_set = set(dictionary) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def max_allocated_area(grid: List[List[str]]) -> int: Determines the maximum area of a single rectangular section that can be allocated to a team without including any obstacles. Args: grid (List[List[str]]): A 2D grid representing the office floor layout with '.' as free areas and 'O' as obstacles. Returns: int: The maximum area of the largest rectangle without any obstacles. Examples: >>> grid = [ ... ['.', '.', '.', '.', 'O'], ... ['.', 'O', '.', '.', '.'], ... ['.', '.', '.', '.', '.'], ... ['.', '.', 'O', '.', 'O'] ... ] >>> max_allocated_area(grid) 6 >>> grid = [ ... ['O', 'O', 'O'], ... ['O', 'O', 'O'] ... ] >>> max_allocated_area(grid) 0","solution":"from typing import List def max_allocated_area(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize dp arrays height = [0] * (cols + 1) max_area = 0 for row in grid: for col in range(cols): height[col] = height[col] + 1 if row[col] == '.' else 0 stack = [-1] for col in range(cols + 1): while height[col] < height[stack[-1]]: h = height[stack.pop()] w = col - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(col) return max_area"},{"question":"from typing import List, Tuple def find_pairs(n: int) -> List[Tuple[int, int]]: Write a function that takes in an integer \`n\` and returns a list of all the unique pairs \`(a, b)\` such that \`a\` and \`b\` are positive integers, \`a < b\`, and the product \`a * b = n\`. The pairs should be returned as a list of tuples, and the list should be sorted in increasing order of \`a\`. For example: >>> find_pairs(12) [(1, 12), (2, 6), (3, 4)] >>> find_pairs(28) [(1, 28), (2, 14), (4, 7)] >>> find_pairs(16) [(1, 16), (2, 8), (4, 4)]","solution":"def find_pairs(n): Returns a list of tuples representing pairs (a, b) such that: - a and b are positive integers - a < b - a * b = n - The list is sorted by increasing order of \`a\`. if n <= 1: return [] pairs = [] for a in range(1, int(n**0.5) + 1): if n % a == 0: b = n // a if a < b: pairs.append((a, b)) elif a == b: pairs.append((a, a)) return pairs"},{"question":"def calculate_discount(spend: int, redeem_points: int) -> int: Calculate the final amount (after applying the discount) that the customer needs to pay. - For every 10 dollars spent in a single transaction, 1 loyalty point is earned. - If the transaction amount includes cents, the cents are ignored. - The points can be redeemed for a discount on future transactions, with each point worth a 5% discount up to a maximum of 50%. - If the number of points to redeem exceeds the maximum points necessary to get a 50% discount, then only redeem the points necessary to get the maximum discount. - The amount after applying the discount should be rounded to the nearest integer. >>> calculate_discount(47, 4) 38 >>> calculate_discount(120, 10) 60 >>> calculate_discount(75, 5) 56 >>> calculate_discount(100, 20) 50 >>> calculate_discount(100, 0) 100 >>> calculate_discount(200, 100) 100 >>> calculate_discount(47.99, 0) 48 >>> calculate_discount(100, 9) 55","solution":"def calculate_discount(spend, redeem_points): Calculate the final amount to pay after applying the discount based on redeem points. - For every 10 dollars spent in a single transaction, 1 loyalty point is earned. - If the transaction amount includes cents, the cents are ignored. - The points can be redeemed for a discount on future transactions, with each point worth a 5% discount up to a maximum of 50%. - If the number of points to redeem exceeds the maximum points necessary to get a 50% discount, then only redeem the points necessary to get the maximum discount. - The amount after applying the discount should be rounded to the nearest integer. :param spend: int, the amount of dollars spent in a transaction :param redeem_points: int, the number of loyalty points to redeem to get a discount for the current transaction :return: int, the final amount to pay after applying the discount max_discount_percentage = 50 discount_per_point = 5 max_redeemable_points = max_discount_percentage // discount_per_point actual_redeemable_points = min(redeem_points, max_redeemable_points) discount_percentage = actual_redeemable_points * discount_per_point discounted_amount = spend * (1 - discount_percentage / 100) return round(discounted_amount)"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Write a function that takes a list of integers and a target integer. The function should return a new list containing the indices of the two numbers in the input list that add up to the target integer. If no such pair exists, return an empty list. Ensure that the indices are returned in ascending order. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 2, 3], 7) [] >>> two_sum([5, 5], 10) [0, 1] >>> two_sum([1, 3, 3, 2], 6) [1, 2] >>> two_sum([10, 7, 11, 8], 15) [1, 3] >>> two_sum([1, 9, 2, 3, 8], 9) [0, 4] >>> two_sum([123456789, 987654321], 1111111110) [0, 1] >>> two_sum([2, 2, 3, 4], 4) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. If no such pair exists, return an empty list. Parameters: nums (list of int): List of integers. target (int): Target integer. Returns: list of int: List containing the indices of the two numbers that add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"def calculate_salary_increases(employee_data): This function takes in a list of tuples containing previous and current salaries of employees. It returns a list with the percentage increases for those employees whose salary has increased. :param employee_data: list of tuples (P, C) where P is previous salary and C is current salary. :return: list of percentage increases for employees with an increased salary. >>> calculate_salary_increases([(50000, 55000), (40000, 40000), (60000, 72000), (30000, 31000), (15000, 17000)]) [10.00, 20.00, 3.33, 13.33] >>> calculate_salary_increases([(50000, 50000), (40000, 40000), (60000, 60000)]) [] >>> calculate_salary_increases([(50000, 55000), (40000, 45000), (60000, 63000)]) [10.00, 12.50, 5.00] >>> calculate_salary_increases([(50000, 55000), (40000, 39000), (60000, 66000), (70000, 70000)]) [10.00, 10.00] >>> calculate_salary_increases([(100000, 110000), (90000, 95000), (120000, 130000)]) [10.00, 5.56, 8.33]","solution":"def calculate_salary_increases(employee_data): This function takes in a list of tuples containing previous and current salaries of employees. It returns a list with the percentage increases for those employees whose salary has increased. :param employee_data: list of tuples (P, C) where P is previous salary and C is current salary. :return: list of percentage increases for employees with an increased salary. result = [] for prev_salary, curr_salary in employee_data: if curr_salary > prev_salary: increase = ((curr_salary - prev_salary) / prev_salary) * 100 result.append(round(increase, 2)) return result"},{"question":"def longestCircularSubstring(circularString: str, subLength: int) -> str: Returns the longest substring of length subLength starting from the first character of the circularString in a circular manner. >>> longestCircularSubstring(\\"abcde\\", 3) 'abc' >>> longestCircularSubstring(\\"xyzabc\\", 4) 'xyza'","solution":"def longestCircularSubstring(circularString: str, subLength: int) -> str: Returns the longest substring of length subLength starting from the first character of the circularString in a circular manner. # Append the string to itself to handle the circular nature. circularStringExtended = circularString * 2 # Extract the substring starting from the first character with the given length. return circularStringExtended[:subLength]"},{"question":"def ordinal(num): Converts an integer to its ordinal representation. Args: num (int): The integer to convert. Returns: str: The ordinal representation of the integer. >>> ordinal(1), \\"1st\\" >>> ordinal(2), \\"2nd\\" >>> ordinal(3), \\"3rd\\" >>> ordinal(4), \\"4th\\" >>> ordinal(11), \\"11th\\" >>> ordinal(21), \\"21st\\" >>> ordinal(22), \\"22nd\\" >>> ordinal(23), \\"23rd\\" pass def nth_element(lst, n): Returns the nth element (1-based index) of a sorted list or raises an IndexError if the index is out of range. Args: lst (list): The list of non-negative integers to be sorted. n (int): The 1-based index of the desired element. Returns: int: The nth element in the sorted list. >>> nth_element([5, 2, 9, 1, 5, 6], 2), 2 >>> nth_element([5, 2, 9, 1, 5, 6], 5), 6 >>> nth_element([5, 2, 9, 1, 5, 6], 7) Traceback (most recent call last): IndexError: list index out of range pass def find_ordinal_at_index(lst, i): Converts each integer in the list to its ordinal representation and returns the ordinal representation of the i-th element. Args: lst (list): The list of non-negative integers. i (int): The 1-based index of the element to be converted to ordinal. Returns: str: The ordinal representation of the i-th element in the sorted list. >>> find_ordinal_at_index([5, 2, 9, 1, 5, 6], 3), \\"5th\\" >>> find_ordinal_at_index([11, 22, 33, 44, 55], 2), \\"22nd\\" >>> find_ordinal_at_index([3, 1, 2], 1), \\"1st\\" >>> find_ordinal_at_index([2, 2, 2, 2, 3], 5), \\"3rd\\" pass","solution":"def ordinal(num): Converts an integer to its ordinal representation. Args: num (int): The integer to convert. Returns: str: The ordinal representation of the integer. if 11 <= num % 100 <= 13: suffix = 'th' else: suffixes = {1: 'st', 2: 'nd', 3: 'rd'} suffix = suffixes.get(num % 10, 'th') return f\\"{num}{suffix}\\" def nth_element(lst, n): Returns the nth element (1-based index) of a sorted list or raises an IndexError if the index is out of range. Args: lst (list): The list of non-negative integers to be sorted. n (int): The 1-based index of the desired element. Returns: int: The nth element in the sorted list. sorted_list = sorted(lst) if 1 <= n <= len(sorted_list): return sorted_list[n-1] else: raise IndexError(\\"list index out of range\\") def find_ordinal_at_index(lst, i): Converts each integer in the list to its ordinal representation and returns the ordinal representation of the i-th element. Args: lst (list): The list of non-negative integers. i (int): The 1-based index of the element to be converted to ordinal. Returns: str: The ordinal representation of the i-th element in the sorted list. nth_element_value = nth_element(lst, i) return ordinal(nth_element_value)"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def max_shortest_distance(n: int, roads: List[Tuple[int, int]]) -> int: Determine the maximum possible shortest distance between any pair of cities after adding exactly one new road >>> max_shortest_distance(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 2 >>> max_shortest_distance(4, [(1, 2), (2, 3), (3, 4)]) 2 >>> max_shortest_distance(3, [(1, 2), (1, 3)]) 1 pass def test_max_shortest_distance(): assert max_shortest_distance(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) == 2 assert max_shortest_distance(4, [(1, 2), (2, 3), (3, 4)]) == 2 assert max_shortest_distance(3, [(1, 2), (1, 3)]) == 1 assert max_shortest_distance(2, [(1, 2)]) == 1 assert max_shortest_distance(6, [(1, 2), (1, 3), (1, 4), (4, 5), (4, 6)]) == 2 def test_single_edge(): assert max_shortest_distance(2, [(1, 2)]) == 1 def test_multiple_paths(): assert max_shortest_distance(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 2 def test_max_nodes(): n = 10**5 edges = [(i, i+1) for i in range(1, n)] assert max_shortest_distance(n, edges) == (n // 2)","solution":"from collections import deque, defaultdict def find_farthest_node(start, graph, n): visited = [False] * (n + 1) dist = [0] * (n + 1) queue = deque([start]) visited[start] = True farthest_node = start while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) dist[neighbor] = dist[node] + 1 if dist[neighbor] > dist[farthest_node]: farthest_node = neighbor return farthest_node, dist[farthest_node] def max_shortest_distance(n, roads): if n == 2: return 1 # Special case: If there's only one edge, adding another road will make distance 1 at most graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Find one of the farthest points (u) from an arbitrary start node (1) u, _ = find_farthest_node(1, graph, n) # Find the farthest point (v) from node u, which is one end of the longest path v, diameter = find_farthest_node(u, graph, n) # The result is the diameter of the tree divided by 2, rounded up. return (diameter + 1) // 2"},{"question":"def square_multiples_of_3(n: int, numbers: List[int]) -> List[int]: Returns a list containing the squares of numbers that are multiples of 3. Parameters: n (int): The number of elements in the list. numbers (list): List of integers. Returns: list: List containing the squares of numbers that are multiples of 3. >>> square_multiples_of_3(6, [1, 3, 4, 9, 10, 12]) [9, 81, 144] >>> square_multiples_of_3(5, [1, 2, 4, 5, 7]) []","solution":"def square_multiples_of_3(n, numbers): Returns a list containing the squares of numbers that are multiples of 3. Parameters: n (int): The number of elements in the list (not directly used in function). numbers (list): List of integers. Returns: list: List containing the squares of numbers that are multiples of 3. return [x**2 for x in numbers if x % 3 == 0]"},{"question":"def count_connected_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph, determine the number of connected components. Args: n (int): Number of nodes m (int): Number of edges edges (List[Tuple[int, int]]): List of edge tuples Returns: int: Number of connected components >>> count_connected_components(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) == 2 >>> count_connected_components(4, 0, []) == 4 >>> count_connected_components(5, 2, [(1, 2), (4, 5)]) == 3 >>> count_connected_components(1, 0, []) == 1 >>> count_connected_components(3, 0, []) == 3 >>> count_connected_components(4, 3, [(1, 2), (2, 3), (3, 4)]) == 1 >>> count_connected_components(6, 2, [(1, 2), (5, 6)]) == 4","solution":"def count_connected_components(n, m, edges): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited.add(node) while queue: u = queue.popleft() for v in graph[u]: if v not in visited: visited.add(v) queue.append(v) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() num_components = 0 for node in range(1, n+1): if node not in visited: bfs(node) num_components += 1 return num_components # To use the function, \`count_connected_components\` # Example usage: # n = 6 # m = 5 # edges = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)] # print(count_connected_components(n, m, edges)) # Output: 2"},{"question":"def largest_subarray_with_sum_k(arr: List[int], k: int) -> int: Determines the size of the largest contiguous subarray with sum equal to k. >>> largest_subarray_with_sum_k([1, -1, 5, -2, 3], 3) 4 >>> largest_subarray_with_sum_k([-2, -1, 2, 1], 1) 2 >>> largest_subarray_with_sum_k([1, 2, 3], 6) 3 >>> largest_subarray_with_sum_k([1, 2, 3], 7) 0 >>> largest_subarray_with_sum_k([1, 2, 3], 2) 1 >>> largest_subarray_with_sum_k([-1, -1, -1, -1, -1], -3) 3 >>> largest_subarray_with_sum_k([1, -1, 1, -1, 1, -1], 0) 6","solution":"def largest_subarray_with_sum_k(arr, k): Determines the size of the largest contiguous subarray with sum equal to k. :param arr: List of integers :param k: Integer target sum :return: Integer size of the largest subarray with sum equal to k sum_to_index = {} current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_length = i + 1 if current_sum - k in sum_to_index: max_length = max(max_length, i - sum_to_index[current_sum - k]) if current_sum not in sum_to_index: sum_to_index[current_sum] = i return max_length"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Given a list of integers, return the maximum sum of a non-empty subarray. >>> max_subarray_sum([34, -50, 42, 14, -5, 86]) 137 >>> max_subarray_sum([-5, -1, -8, -9]) -1","solution":"def max_subarray_sum(arr): Returns the maximum sum of a non-empty subarray. max_ending_here = max_so_far = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def minimal_spotlights_required(rectangles: List[Tuple[int, int, int, int]]) -> int: Given a list of rectangles, each represented by their coordinates (x1, y1, x2, y2), returns the minimal number of spotlights required to illuminate all given billboards. Parameters: rectangles (list of tuples): A list of tuples where each tuple contains: (x1, y1, x2, y2) coordinates of a rectangle. Returns: int: The minimum number of spotlights required. Examples: >>> minimal_spotlights_required([(1, 1, 2, 2)]) 1 >>> minimal_spotlights_required([(1, 1, 2, 2), (2, 2, 3, 3), (3, 3, 4, 4)]) 3 >>> minimal_spotlights_required([(1, 1, 4, 4), (2, 2, 3, 3)]) 2","solution":"def minimal_spotlights_required(rectangles): Given a list of rectangles, each represented by their coordinates (x1, y1, x2, y2), returns the minimal number of spotlights required to illuminate all given billboards. Parameters: rectangles (list of tuples): A list of tuples where each tuple contains: (x1, y1, x2, y2) coordinates of a rectangle. Returns: int: The minimum number of spotlights required. # Each rectangle requires its own spotlight since no further overlapping logic is needed. return len(rectangles)"},{"question":"def find_pairs_with_sum(nums, target): Finds all pairs of integers in the list that add up to the target sum. Args: nums: list of integers target: integer Returns: list of tuples (a, b) where a + b = target and a < b Examples: >>> find_pairs_with_sum([2, 4, 3, 5, 7, -1, 8, -2], 6) [(-2, 8), (-1, 7), (2, 4)] >>> find_pairs_with_sum([1, 2, 3, 9, 10], 8) [] >>> find_pairs_with_sum([1, 5, 3, 7, 9, 2, 4, 6], 10) [(1, 9), (3, 7), (4, 6)] >>> find_pairs_with_sum([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 110) [(10, 100), (20, 90), (30, 80), (40, 70), (50, 60)] >>> find_pairs_with_sum([], 5) [] >>> find_pairs_with_sum([5], 5) []","solution":"def find_pairs_with_sum(nums, target): Finds all pairs of integers in the list that add up to the target sum. Args: nums: list of integers target: integer Returns: list of tuples (a, b) where a + b = target and a < b nums.sort() # Sort the input list for ordered pairs pairs = [] seen = set() for num in nums: complement = target - num if complement in seen: if complement < num: pairs.append((complement, num)) else: pairs.append((num, complement)) seen.add(num) pairs.sort() return pairs"},{"question":"def isArithmeticProgression(nums: List[int]) -> bool: Determines if a given list of integers forms an arithmetic progression. >>> isArithmeticProgression([1, 3, 5, 7, 9]) True >>> isArithmeticProgression([2, 4, 6, 8, 11]) False >>> isArithmeticProgression([7, 7, 7, 7]) True","solution":"def isArithmeticProgression(nums): Determines if a given list of integers forms an arithmetic progression. if len(nums) < 2: return True # Trivially forms an arithmetic progression common_diff = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i - 1] != common_diff: return False return True"},{"question":"from typing import List, Tuple def common_contacts(test_cases: List[Tuple[List[int], List[int]]]) -> List[str]: Find common contacts who are in both friends and acquaintances list. Args: test_cases: A list of tuples, each containing two lists of integers representing friends and acquaintances. Returns: A list of strings, where each string contains space-separated IDs that are present in both lists for each test case, or \\"No common contacts\\" if there are no common IDs. pass def parse_input(input_string: str) -> List[Tuple[List[int], List[int]]]: Parse the input string into a list of test cases. Args: input_string: A string containing the input data Returns: A list of tuples, each containing two lists of integers. pass Test Cases: def test_common_contacts(): input_string = \\"2n5n1 2 3 4 5n4n3 4 5 6n3n100 200 300n4n150 250 350 450\\" test_cases = parse_input(input_string) result = common_contacts(test_cases) assert result == [\\"3 4 5\\", \\"No common contacts\\"] def test_no_common_contacts(): input_string = \\"1n4n101 102 103 104n5n105 106 107 108 109\\" test_cases = parse_input(input_string) result = common_contacts(test_cases) assert result == [\\"No common contacts\\"] def test_all_common_contacts(): input_string = \\"1n3n20 30 40n3n20 30 40\\" test_cases = parse_input(input_string) result = common_contacts(test_cases) assert result == [\\"20 30 40\\"] def test_partial_common_contacts(): input_string = \\"1n5n10 20 30 40 50n6n30 40 50 60 70 80\\" test_cases = parse_input(input_string) result = common_contacts(test_cases) assert result == [\\"30 40 50\\"] def test_large_input(): friends = list(range(1, 100001)) # ids 1 to 100000 acquaintances = list(range(50000, 150001)) # ids 50000 to 150000 input_string = f\\"1n100000n{' '.join(map(str, friends))}n100001n{' '.join(map(str, acquaintances))}\\" test_cases = parse_input(input_string) result = common_contacts(test_cases) assert result == [\\" \\".join(map(str, range(50000, 100001)))] def test_single_entry_no_common(): input_string = \\"1n1n12345n1n54321\\" test_cases = parse_input(input_string) result = common_contacts(test_cases) assert result == [\\"No common contacts\\"] def test_single_entry_common(): input_string = \\"1n1n12345n1n12345\\" test_cases = parse_input(input_string) result = common_contacts(test_cases) assert result == [\\"12345\\"]","solution":"def common_contacts(test_cases): results = [] for friends, acquaintances in test_cases: common = sorted(set(friends).intersection(acquaintances)) if common: results.append(\\" \\".join(map(str, common))) else: results.append(\\"No common contacts\\") return results # Input Parsing Function def parse_input(input_string): input_lines = input_string.strip().split(\\"n\\") t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) friends = list(map(int, input_lines[index + 1].split())) m = int(input_lines[index + 2]) acquaintances = list(map(int, input_lines[index + 3].split())) test_cases.append((friends, acquaintances)) index += 4 return test_cases"},{"question":"from typing import List def group_and_sort_orders(n: int, orders: List[str]) -> List[str]: You are given a list of package delivery orders that consist of a sender, a receiver, and a list of items. Each order specifies the sender and receiver as strings, and the list of items as a list of strings. Each item string is unique within an order, and items are also not shared between different orders. Your task is to group these orders by their sender, and within each sender group, sort the orders by the name of the receiver in ascending order. Then, for each group of orders from the same sender, output the sender, followed by each receiver and their corresponding items. >>> group_and_sort_orders(5, [ ... \\"anna:betty:apple\\", ... \\"anna:carol:banana,cat\\", ... \\"david:frank:dog\\", ... \\"anna:alice:elephant\\", ... \\"david:george:fish\\" ... ]) [\\"2\\", \\"anna\\", \\"alice:elephant\\", \\"betty:apple\\", \\"carol:banana,cat\\", \\"david\\", \\"frank:dog\\", \\"george:fish\\"] >>> group_and_sort_orders(1, [\\"anna:betty:apple\\"]) [\\"1\\", \\"anna\\", \\"betty:apple\\"] >>> group_and_sort_orders(3, [ ... \\"anna:betty:apple,mango\\", ... \\"bob:carol:banana,cat\\", ... \\"anna:carol:banana,cat\\" ... ]) [\\"2\\", \\"anna\\", \\"betty:apple,mango\\", \\"carol:banana,cat\\", \\"bob\\", \\"carol:banana,cat\\"] >>> group_and_sort_orders(3, [ ... \\"anna:carol:apple\\", ... \\"anna:carol:banana\\", ... \\"bob:carol:cat\\" ... ]) [\\"2\\", \\"anna\\", \\"carol:apple\\", \\"carol:banana\\", \\"bob\\", \\"carol:cat\\"] >>> group_and_sort_orders(0, []) [\\"0\\"]","solution":"def group_and_sort_orders(n, orders): from collections import defaultdict # Organize orders into a dictionary grouped by sender grouped_orders = defaultdict(list) for order in orders: sender, receiver, items = order.split(':', 2) items_list = items.split(',') grouped_orders[sender].append((receiver, items_list)) # Sort orders within each sender group by receiver's name for sender in grouped_orders: grouped_orders[sender].sort(key=lambda x: x[0]) # Get the sorted list of senders sorted_senders = sorted(grouped_orders.keys()) # Preparing the output result = [str(len(sorted_senders))] for sender in sorted_senders: result.append(sender) for receiver, items in grouped_orders[sender]: result.append(f\\"{receiver}:{','.join(items)}\\") return result"},{"question":"def sort_strings(strings: List[str]) -> List[str]: Sort strings first by their lengths in ascending order. If two strings have the same length, they should be sorted in lexicographical order. >>> sort_strings([\\"apple\\", \\"pie\\", \\"short\\", \\"bob\\"]) [\\"bob\\", \\"pie\\", \\"apple\\", \\"short\\"] >>> sort_strings([\\"banana\\", \\"kiwi\\", \\"grape\\", \\"papaya\\"]) [\\"kiwi\\", \\"grape\\", \\"banana\\", \\"papaya\\"] >>> sort_strings([\\"z\\", \\"abc\\", \\"def\\", \\"a\\", \\"b\\", \\"ab\\"]) [\\"a\\", \\"b\\", \\"z\\", \\"ab\\", \\"abc\\", \\"def\\"] >>> sort_strings([]) []","solution":"def sort_strings(strings): Sort strings first by their lengths in ascending order. If two strings have the same length, they should be sorted in lexicographical order. # return the sorted list using sorted and lambda function for key return sorted(strings, key=lambda x: (len(x), x))"},{"question":"def categorize_words(words: List[str]) -> Dict[str, List[str]]: Categorizes words into 'short', 'medium', and 'long' based on their lengths. Args: words (list of str): List of words to be categorized. Returns: dict: Dictionary with keys 'short', 'medium', and 'long' mapping to lists of categorized words. >>> categorize_words([\\"cat\\", \\"house\\", \\"elephant\\", \\"to\\", \\"run\\", \\"development\\"]) {'short': ['cat', 'to', 'run'], 'medium': ['house'], 'long': ['elephant', 'development']} >>> categorize_words([\\"a\\", \\"four\\", \\"dinosaur\\"]) {'short': ['a'], 'medium': ['four'], 'long': ['dinosaur']} >>> categorize_words([]) {'short': [], 'medium': [], 'long': []} >>> categorize_words([\\"house\\", \\"bingo\\", \\"apple\\"]) {'short': [], 'medium': ['house', 'bingo', 'apple'], 'long': []} >>> categorize_words([\\"elephant\\", \\"development\\", \\"amazing\\"]) {'short': [], 'medium': [], 'long': ['elephant', 'development', 'amazing']}","solution":"def categorize_words(words): Categorizes words into 'short', 'medium', and 'long' based on their lengths. Args: words (list of str): List of words to be categorized. Returns: dict: Dictionary with keys 'short', 'medium', and 'long' mapping to lists of categorized words. categorized = { 'short': [], 'medium': [], 'long': [] } for word in words: length = len(word) if 1 <= length <= 3: categorized['short'].append(word) elif 4 <= length <= 6: categorized['medium'].append(word) elif length >= 7: categorized['long'].append(word) return categorized"},{"question":"def reverse_words_order(sentence): Returns a new string where the order of the words is reversed, but the order of characters within each word is preserved. If the input is not a valid string, returns 'Invalid input!'. >>> reverse_words_order(\\"hello world\\") \\"world hello\\" >>> reverse_words_order(\\" a quick brown fox \\") \\"fox brown quick a\\" >>> reverse_words_order(12345) \\"Invalid input!\\" >>> reverse_words_order(\\"\\") \\"\\"","solution":"def reverse_words_order(sentence): Returns a new string with the order of the words reversed, while preserving the order of characters within each word. If input is not a valid string, returns 'Invalid input!'. if not isinstance(sentence, str): return 'Invalid input!' words = sentence.split() reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"from typing import List def longest_sorted_subsequence(arr: List[int]) -> int: Given a list of integers, find the length of the longest subsequence which appears in sorted order, but not necessarily consecutively. >>> longest_sorted_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_sorted_subsequence([3, 2]) 1 >>> longest_sorted_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_sorted_subsequence([10]) 1 >>> longest_sorted_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_sorted_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_sorted_subsequence([3, 4, 1, 5, 6, 2, 8, 3]) 5 >>> longest_sorted_subsequence([]) 0 pass","solution":"def longest_sorted_subsequence(arr): Returns the length of the longest subsequence in the list which appears in sorted order. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers up to n (inclusive) using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(13) [2, 3, 5, 7, 11, 13] >>> sieve_of_eratosthenes(15) [2, 3, 5, 7, 11, 13] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [2]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers up to n (inclusive) using the Sieve of Eratosthenes algorithm. if n < 2: return [] primes = [True] * (n + 1) p = 2 while (p * p <= n): if primes[p] == True: for i in range(p * p, n + 1, p): primes[i] = False p += 1 prime_numbers = [p for p in range(2, n + 1) if primes[p]] return prime_numbers"},{"question":"from collections import defaultdict from math import gcd from typing import List, Tuple def max_points_on_line(points: List[Tuple[int, int]]) -> int: Determine the maximum number of points that lie on the same straight line. Args: points: List of tuples representing the coordinates of each point (x, y). Returns: The maximum number of points that lie on the same straight line. def max_points_in_cases(test_cases: List[List[Tuple[int, int]]]) -> List[int]: Determine the maximum number of points on a line for multiple test cases. Args: test_cases: List of test cases, each containing a list of tuple coordinates (x, y). Returns: A list of integers where each integer is the maximum number of points on a single line for each test case. def test_max_points_on_line(): assert max_points_on_line([(1, 1), (2, 2), (3, 3), (4, 4)]) == 4 assert max_points_on_line([(1, 1), (1, 2), (2, 2), (2, 3), (3, 3), (4, 4)]) == 4 assert max_points_on_line([(0, 0), (0, 1), (1, 0), (1, 1)]) == 2 assert max_points_on_line([(1, 1), (1, 1), (2, 2), (3, 3)]) == 4 assert max_points_on_line([(2, 3)]) == 1 assert max_points_on_line([(1, 1), (1, 1), (1, 1)]) == 3 def test_max_points_in_cases(): test_cases = [ [(1, 1), (2, 2), (3, 3), (4, 4)], [(1, 1), (1, 2), (2, 2), (2, 3), (3, 3), (4, 4)] ] assert max_points_in_cases(test_cases) == [4, 4] test_max_points_on_line() test_max_points_in_cases()","solution":"from collections import defaultdict from math import gcd def max_points_on_line(points): if len(points) < 3: return len(points) def get_slope(point1, point2): x1, y1 = point1 x2, y2 = point2 dx = x2 - x1 dy = y2 - y1 if dx == 0: return 'inf' g = gcd(dx, dy) return (dy // g, dx // g) max_points = 1 for i in range(len(points)): slopes = defaultdict(int) duplicate = 1 for j in range(i+1, len(points)): if points[i] == points[j]: duplicate += 1 else: slope = get_slope(points[i], points[j]) slopes[slope] += 1 if slopes: max_points = max(max_points, max(slopes.values()) + duplicate) else: max_points = max(max_points, duplicate) return max_points def max_points_in_cases(test_cases): results = [] for case in test_cases: results.append(max_points_on_line(case)) return results"},{"question":"def factorial_array(x: int) -> List[int]: Develop a function that receives an integer \`x\` and returns the factorial of the first \`x\` positive integers as an array. >>> factorial_array(0) [1] >>> factorial_array(1) [1, 1] >>> factorial_array(5) [1, 1, 2, 6, 24, 120] >>> factorial_array(3) [1, 1, 2, 6] >>> factorial_array(10) [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]","solution":"def factorial_array(x): Returns an array containing the factorial of the first x positive integers (including 0). if x == 0: return [1] factorials = [1] for i in range(1, x + 1): factorials.append(factorials[-1] * i) return factorials"},{"question":"def compress_string(input_str: str) -> str: Compress the input string such that each word is represented by its first letter followed by the number of characters in the word, and the words are separated by commas. Parameters: input_str (str): A string of words separated by spaces. Returns: str: A compressed string representation. >>> compress_string(\\"hello world this is a test\\") == \\"h5,w5,t4,i2,a1,t4\\" >>> compress_string(\\"singleword\\") == \\"s10\\" >>> compress_string(\\"a sequence of words\\") == \\"a1,s8,o2,w5\\" # Your code here","solution":"def compress_string(input_str): Compress the input string such that each word is represented by its first letter followed by the number of characters in the word, and the words are separated by commas. Parameters: input_str (str): A string of words separated by spaces. Returns: str: A compressed string representation. words = input_str.split() compressed_words = [f\\"{word[0]}{len(word)}\\" for word in words] return \\",\\".join(compressed_words)"},{"question":"class ElevatorSystem: The ElevatorSystem class simulates the operation of a bank of elevators. The system consists of a configurable number of elevators and provides basic functionalities, such as moving the elevators to different floors, picking up passengers, and dropping them off. >>> system = ElevatorSystem(2, 10) >>> system.pickup(3, 'up') >>> system.step() >>> system.status() [(0, 'up', [3]), (0, 'idle', [])] >>> system.step() >>> system.status() [(1, 'up', [3]), (0, 'idle', [])] >>> system.pickup(5, 'down') >>> system.step() >>> system.status() [(2, 'up', [3]), (0, 'idle', [])] Methods: __init__(self, num_elevators: int, num_floors: int): Initializes the elevator system with the specified number of elevators and floors. pickup(self, floor: int, direction: str): Requests an elevator to pick up passengers at the specified floor. dropoff(self, elevator_id: int, floor: int): Requests a specific elevator to drop off passengers at the specified floor. step(self): Advances the system by one time unit. status(self): Returns the status of each elevator. def __init__(self, num_elevators: int, num_floors: int): pass def pickup(self, floor: int, direction: str): pass def dropoff(self, elevator_id: int, floor: int): pass def step(self): pass def status(self): pass","solution":"class ElevatorSystem: def __init__(self, num_elevators: int, num_floors: int): self.num_floors = num_floors self.elevators = [{'current_floor': 0, 'direction': 'idle', 'stops': []} for _ in range(num_elevators)] def pickup(self, floor: int, direction: str): # Find the idle elevator or the nearest moving in the correct direction best_elevator = None smallest_distance = float('inf') for elevator in self.elevators: current_floor = elevator['current_floor'] if elevator['direction'] == 'idle': distance = abs(current_floor - floor) if distance < smallest_distance: smallest_distance = distance best_elevator = elevator elif ((direction == 'up' and elevator['direction'] == 'up' and current_floor <= floor) or (direction == 'down' and elevator['direction'] == 'down' and current_floor >= floor)): distance = abs(current_floor - floor) if distance < smallest_distance: smallest_distance = distance best_elevator = elevator if best_elevator: best_elevator['stops'].append(floor) if best_elevator['direction'] == 'idle': best_elevator['direction'] = direction best_elevator['stops'].sort(reverse=(direction == 'down')) def dropoff(self, elevator_id: int, floor: int): if 0 <= elevator_id < len(self.elevators): self.elevators[elevator_id]['stops'].append(floor) if self.elevators[elevator_id]['direction'] == 'idle': self.elevators[elevator_id]['direction'] = ('up' if self.elevators[elevator_id]['current_floor'] < floor else 'down') self.elevators[elevator_id]['stops'].sort(reverse=(self.elevators[elevator_id]['direction'] == 'down')) def step(self): for elevator in self.elevators: if elevator['direction'] != 'idle': if elevator['stops']: next_stop = elevator['stops'][0] if elevator['current_floor'] < next_stop: elevator['current_floor'] += 1 elevator['direction'] = 'up' elif elevator['current_floor'] > next_stop: elevator['current_floor'] -= 1 elevator['direction'] = 'down' if elevator['current_floor'] == next_stop: elevator['stops'].pop(0) if not elevator['stops']: elevator['direction'] = 'idle' else: elevator['direction'] = 'idle' def status(self): return [(elevator['current_floor'], elevator['direction'], elevator['stops']) for elevator in self.elevators]"},{"question":"from typing import List def can_split_students(nums: List[int]) -> bool: Returns True if it is possible to split the students into groups that all have the same number of students, otherwise returns False. Example: >>> can_split_students([3, 3, 3, 3, 3, 3]) True >>> can_split_students([2, 3, 4]) False >>> can_split_students([1, 1, 1, 1, 2, 2, 2, 2]) True","solution":"from collections import Counter from math import gcd from functools import reduce def can_split_students(nums): Returns True if it is possible to split the students into groups that all have the same number of students, otherwise returns False. count = Counter(nums).values() return reduce(gcd, count) > 1"},{"question":"def common_elements(list1, list2): Returns a list containing all the common elements between list1 and list2, in the order they appear in list1. >>> common_elements([1, 2, 3, 4], [2, 4, 6, 8]) [2, 4] >>> common_elements(['a', 'b', 'c', 'd'], ['x', 'y', 'a', 'z']) ['a'] >>> common_elements([100, 200, 300], [400, 500, 600]) [] >>> common_elements([1, 2, 3, 4, 5], [3, 5, 7, 9]) [3, 5] >>> common_elements(['apple', 'banana', 'cherry'], ['apple', 'banana', 'cherry']) ['apple', 'banana', 'cherry'] >>> common_elements([], [1, 2, 3]) [] >>> common_elements([1, 2, 3], []) [] >>> common_elements([], []) [] >>> common_elements([1, 'a', 3.0, 'd'], [3.0, 'a', 6, 'x']) ['a', 3.0] >>> common_elements([1, 2, 2, 3, 3, 3], [2, 3, 3, 3, 4]) [2, 2, 3, 3, 3]","solution":"def common_elements(list1, list2): Returns a list containing all the common elements between list1 and list2, in the order they appear in list1. return [element for element in list1 if element in list2]"},{"question":"def sort_by_parity(lst: List[int]) -> List[int]: Sorts a list of integers such that all even numbers appear first, followed by all the odd numbers, while maintaining the relative order of even and odd numbers. >>> sort_by_parity([3, 1, 2, 4]) == [2, 4, 3, 1] >>> sort_by_parity([0, 1, 2]) == [0, 2, 1] >>> sort_by_parity([1, 3, 5, 7, 2, 4, 6, 8]) == [2, 4, 6, 8, 1, 3, 5, 7] >>> sort_by_parity([4, 2, 6, 8, 1, 3, 5, 7]) == [4, 2, 6, 8, 1, 3, 5, 7] from solution import sort_by_parity def test_sort_by_parity_mixed(): assert sort_by_parity([3, 1, 2, 4]) == [2, 4, 3, 1] assert sort_by_parity([1, 3, 5, 7, 2, 4, 6, 8]) == [2, 4, 6, 8, 1, 3, 5, 7] def test_sort_by_parity_already_sorted(): assert sort_by_parity([4, 2, 6, 8, 1, 3, 5, 7]) == [4, 2, 6, 8, 1, 3, 5, 7] def test_sort_by_parity_no_odds(): assert sort_by_parity([2, 4, 6, 8]) == [2, 4, 6, 8] def test_sort_by_parity_no_evens(): assert sort_by_parity([1, 3, 5, 7]) == [1, 3, 5, 7] def test_sort_by_parity_with_zero(): assert sort_by_parity([0, 1, 2]) == [0, 2, 1] def test_sort_by_parity_empty(): assert sort_by_parity([]) == [] def test_sort_by_parity_single_element(): assert sort_by_parity([1]) == [1] assert sort_by_parity([2]) == [2]","solution":"def sort_by_parity(lst): Sorts a list of integers such that all even numbers appear first, followed by all the odd numbers, while maintaining the relative order of even and odd numbers. even = [x for x in lst if x % 2 == 0] odd = [x for x in lst if x % 2 != 0] return even + odd"},{"question":"def min_bridges_to_rebuild(n: int, m: int, bridges: List[Tuple[int, int]]) -> int: Determine the minimum number of bridges required to be rebuilt so that all islands are connected. Args: - n (int): The number of islands. - m (int): The number of bridges. - bridges (List[Tuple[int, int]]): List of tuples where each tuple represents a bridge connecting two islands. Returns: - int: The minimum number of bridges that need to be rebuilt. >>> min_bridges_to_rebuild(6, 5, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 6)]) 0 >>> min_bridges_to_rebuild(6, 4, [(1, 2), (1, 3), (2, 4), (3, 5)]) 1 >>> min_bridges_to_rebuild(6, 3, [(1, 2), (1, 3), (2, 4)]) 2 >>> min_bridges_to_rebuild(6, 0, []) 5 >>> min_bridges_to_rebuild(1, 0, []) 0 >>> min_bridges_to_rebuild(2, 1, [(1, 2)]) 0","solution":"def min_bridges_to_rebuild(n, m, bridges): from collections import defaultdict, deque if n == 1: return 0 # Only one island, no bridge needed adj_list = defaultdict(list) for u, v in bridges: adj_list[u].append(v) adj_list[v].append(u) def bfs(start, visited): queue = deque([start]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (n + 1) component_count = 0 for island in range(1, n + 1): if not visited[island]: visited[island] = True bfs(island, visited) component_count += 1 return component_count - 1"},{"question":"def largest_rectangle_area(heights): Finds the largest rectangle area in a histogram represented by heights. Parameters: heights (list of int): A list of integers representing the histogram bar heights. Returns: int: The area of the largest rectangle that can be formed within the bounds of the histogram. pass from solution import largest_rectangle_area def test_largest_rectangle_area_case1(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_largest_rectangle_area_single_element(): assert largest_rectangle_area([5]) == 5 def test_largest_rectangle_area_same_height(): assert largest_rectangle_area([2, 2, 2, 2]) == 8 def test_largest_rectangle_area_increasing_heights(): assert largest_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_largest_rectangle_area_decreasing_heights(): assert largest_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_largest_rectangle_area_multiple_same_max_area(): assert largest_rectangle_area([5, 5, 1, 7, 7, 1]) == 14","solution":"def largest_rectangle_area(heights): Finds the largest rectangle area in a histogram represented by heights. Parameters: heights (list of int): A list of integers representing the histogram bar heights. Returns: int: The area of the largest rectangle that can be formed within the bounds of the histogram. stack = [] max_area = 0 heights.append(0) # Add a zero height to flush out remaining bars in stack at the end for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: h_idx = stack.pop() height = heights[h_idx] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area"},{"question":"def longest_prime_length_increasing_subsequence(signal_strengths: List[int]) -> int: Returns the length of the longest strictly increasing subsequence with a prime length. >>> longest_prime_length_increasing_subsequence([3, 2, 1, 2, 3, 5, 6, 4, 1, 2, 3]) 5 >>> longest_prime_length_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) 7 >>> longest_prime_length_increasing_subsequence([5, 4, 3, 2, 1]) 0 >>> longest_prime_length_increasing_subsequence([2, 3, 5, 7, 11, 13, 17]) 7 >>> longest_prime_length_increasing_subsequence([1, 3, 2, 4, 4, 5, 4, 6, 4, 7]) 5 >>> longest_prime_length_increasing_subsequence([]) 0 >>> longest_prime_length_increasing_subsequence([7]) 0 >>> longest_prime_length_increasing_subsequence([2, 2, 2, 2, 2]) 0 >>> longest_prime_length_increasing_subsequence([1, 2, 1, 2, 3, 1]) 3","solution":"def is_prime(n): Check if an integer n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def longest_prime_length_increasing_subsequence(signal_strengths): Returns the length of the longest strictly increasing subsequence with a prime length. if not signal_strengths: return 0 n = len(signal_strengths) dp = [1] * n max_len = 1 for i in range(1, n): for j in range(i): if signal_strengths[i] > signal_strengths[j]: dp[i] = max(dp[i], dp[j] + 1) max_len = max(max_len, dp[i]) max_prime_len = 0 for length in range(2, max_len + 1): if is_prime(length) and length in dp: max_prime_len = max(max_prime_len, length) return max_prime_len"},{"question":"def find_unique(nums: List[int]) -> int: Given an array of integers where each element can appear twice or once, and all duplicates appear exactly twice except for one unique element that appears only once. Write a function to find the single unique element. You must implement a solution with a linear runtime complexity and use only constant extra space. >>> find_unique([2, 2, 1, 4, 4]) 1 >>> find_unique([1, 3, 3, 5, 5, 9, 9]) 1 >>> find_unique([8, 7, 7, 8, 9, 9, 10]) 10 pass from solution import find_unique def test_find_unique_example1(): assert find_unique([2, 2, 1, 4, 4]) == 1 def test_find_unique_example2(): assert find_unique([1, 3, 3, 5, 5, 9, 9]) == 1 def test_find_unique_example3(): assert find_unique([8, 7, 7, 8, 9, 9, 10]) == 10 def test_find_unique_with_all_duplicates(): assert find_unique([4, 1, 2, 1, 2, 4, 5]) == 5 def test_find_unique_with_single_element(): assert find_unique([6]) == 6","solution":"def find_unique(nums): Returns the single unique element in the array where all other elements appear exactly twice. unique_element = 0 for num in nums: unique_element ^= num # XOR all elements together. Duplicates will cancel out. return unique_element"},{"question":"def is_palindrome(n: int) -> bool: Check if a given number n is a palindrome. return str(n) == str(n)[::-1] def smallest_palindrome_multiple(x: int) -> int: Find the smallest positive integer that is a multiple of x and a palindrome. i = 1 while True: if is_palindrome(i) and i % x == 0: return i i += 1 def solve(T: int, test_cases: List[int]) -> List[int]: For each test case, find the smallest positive palindrome number that is a multiple of the given number. Args: T (int): The number of test cases. test_cases (list): A list containing the integers for each test case. Returns: list: A list containing the smallest positive palindrome multiple for each test case. >>> solve(2, [1, 5]) [1, 5] >>> solve(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]","solution":"def is_palindrome(n): Check if a given number n is a palindrome. return str(n) == str(n)[::-1] def smallest_palindrome_multiple(x): Find the smallest positive integer that is a multiple of x and a palindrome. i = 1 while True: if is_palindrome(i) and i % x == 0: return i i += 1 def solve(T, test_cases): results = [] for x in test_cases: results.append(smallest_palindrome_multiple(x)) return results"},{"question":"from typing import List, Tuple def sort_invitations(n: int, invitations: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts invitations by priority level in descending order, and by name in alphabetical order for the same priority level. Parameters: - n: int, number of invitations - invitations: List of tuples [(name, priority), ...] Returns: - List of tuples [(name, priority), ...] sorted accordingly pass def process_invitations(input_data: str) -> str: Processes the input data, sorts the invitations, and outputs the sorted invitations. >>> process_invitations(\\"5nJane 2nDavid 3nAlice 2nBob 1nCharlie 3\\") \\"Charlie 3nDavid 3nAlice 2nJane 2nBob 1\\" >>> process_invitations(\\"4nEve 2nAlice 2nDavid 2nCharlie 2\\") \\"Alice 2nCharlie 2nDavid 2nEve 2\\" >>> process_invitations(\\"1nAlice 1\\") \\"Alice 1\\" >>> process_invitations(\\"6nAlice 3nBob 2nCharlie 1nDavid 3nEve 2nFrank 2\\") \\"Alice 3nDavid 3nBob 2nEve 2nFrank 2nCharlie 1\\" >>> process_invitations(\\"3nAlice 2nAlice 3nAlice 1\\") \\"Alice 3nAlice 2nAlice 1\\" pass","solution":"def sort_invitations(n, invitations): Sorts invitations by priority level in descending order, and by name in alphabetical order for the same priority level. Parameters: - n: int, number of invitations - invitations: List of tuples [(name, priority), ...] Returns: - List of tuples [(name, priority), ...] sorted accordingly # Sorting by priority (descending) and name (alphabetical) sorted_invites = sorted(invitations, key=lambda x: (-x[1], x[0])) return sorted_invites # Function to read input and process output def process_invitations(input_data): lines = input_data.strip().split('n') n = int(lines[0]) invitations = [(line.split()[0], int(line.split()[1])) for line in lines[1:]] sorted_invites = sort_invitations(n, invitations) output_lines = [f\\"{name} {priority}\\" for name, priority in sorted_invites] return \\"n\\".join(output_lines)"},{"question":"def crossword_helper(sentence: str) -> str: Write a function \`crossword_helper\` that takes in a string of words separated by a single space. The function should return a string where every even-indexed word in the input string appears reversed and every odd-indexed word appears unchanged. >>> crossword_helper(\\"practice makes perfect\\") \\"ecitcarp makes tcefrep\\" >>> crossword_helper(\\"hello world\\") \\"olleh world\\" >>> crossword_helper(\\"keep it simple\\") \\"peek it elpmis\\" >>> crossword_helper(\\"level up your skills\\") \\"level pu your slliks\\"","solution":"def crossword_helper(sentence: str) -> str: words = sentence.split() for i in range(len(words)): if i % 2 == 0: words[i] = words[i][::-1] return ' '.join(words)"},{"question":"class FileSystem: def __init__(self): Initializes the file system with a root directory '/'. Example: >>> fs = FileSystem() >>> fs.ls(\\"/\\") == [] True def ls(self, path): Returns a list of files and directories in the current directory given by path. Example: >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.ls(\\"/a/b\\") == [\\"c\\"] True def mkdir(self, path): Makes a new directory according to the given path. Example: >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.ls(\\"/a/b\\") == [\\"c\\"] True def addContentToFile(self, filePath, content): Adds content to the file at filePath. Example: >>> fs = FileSystem() >>> fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") >>> fs.readContentFromFile(\\"/a/b/c/d\\") == \\"hello\\" True def readContentFromFile(self, filePath): Returns the content in the file at filePath. Example: >>> fs = FileSystem() >>> fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") >>> fs.readContentFromFile(\\"/a/b/c/d\\") == \\"hello\\" True import pytest def test_file_system_operations(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") assert fs.ls(\\"/a/b\\") == [\\"c\\"] fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") assert fs.readContentFromFile(\\"/a/b/c/d\\") == \\"hello\\" fs.addContentToFile(\\"/a/b/c/d\\", \\" world\\") assert fs.readContentFromFile(\\"/a/b/c/d\\") == \\"hello world\\" assert fs.ls(\\"/a/b/c/d\\") == [\\"d\\"] def test_ls_root_directory(): fs = FileSystem() assert fs.ls(\\"/\\") == [] def test_mkdir_existing_directory(): fs = FileSystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a\\") assert fs.ls(\\"/\\") == [\\"a\\"] def test_add_content_to_new_file(): fs = FileSystem() fs.addContentToFile(\\"/newfile\\", \\"sample content\\") assert fs.readContentFromFile(\\"/newfile\\") == \\"sample content\\" assert fs.ls(\\"/\\") == [\\"newfile\\"] def test_non_existent_path_raises_error(): fs = FileSystem() fs.mkdir(\\"/a/b\\") with pytest.raises(FileNotFoundError): fs.ls(\\"/a/b/c\\")","solution":"class FileSystem: def __init__(self): self.root = {'isFile': False, 'content': {}, 'data': ''} def ls(self, path): node = self._traverse(path) if node['isFile']: return [path.split('/')[-1]] return sorted(node['content'].keys()) def mkdir(self, path): self._traverse(path, create=True) def addContentToFile(self, filePath, content): node = self._traverse(filePath, create=True) node['isFile'] = True node['data'] += content def readContentFromFile(self, filePath): node = self._traverse(filePath) return node['data'] def _traverse(self, path, create=False): node = self.root if path == '/': return node parts = path.split('/')[1:] for part in parts: if part not in node['content']: if create: node['content'][part] = {'isFile': False, 'content': {}, 'data': ''} else: raise FileNotFoundError(f'Path {path} does not exist.') node = node['content'][part] return node"},{"question":"from itertools import combinations from typing import List, Tuple def unique_gift_bags(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Determines the number of unique gift bags for each test case. Each test case consists of: - A list of distinct items. Returns a list of integers representing the number of unique gift bags for each test case. >>> unique_gift_bags(2, [(5, [\\"Apple\\", \\"Banana\\", \\"Chocolate\\", \\"Donut\\", \\"Eclair\\"]), (3, [\\"Apple\\", \\"Banana\\", \\"Chocolate\\"])]) [10, 1] >>> unique_gift_bags(1, [(3, [\\"Apple\\", \\"Banana\\", \\"Chocolate\\"])]) [1] >>> unique_gift_bags(1, [(4, [\\"A\\", \\"B\\", \\"C\\", \\"D\\"])]) [4] >>> unique_gift_bags(1, [(2, [\\"Apple\\", \\"Banana\\"])]) [0]","solution":"from itertools import combinations def unique_gift_bags(T, test_cases): Determines the number of unique gift bags for each test case. Each test case consists of: - A list of distinct items. Returns a list of integers representing the number of unique gift bags for each test case. results = [] for i in range(T): N = test_cases[i][0] items = test_cases[i][1] if N < 3: results.append(0) # Not enough items to form a gift bag else: results.append(len(list(combinations(items, 3)))) return results"},{"question":"def earliestBus(time, schedules): Determine the earliest bus you can catch based on the given time and bus schedules. Args: time (int): The current time in minutes past midnight. schedules (list): An array of bus schedules. Returns: dict: An object with 'busID' and 'departureTime' of the earliest bus you can catch, or None if there are no buses available after the given time. Example: >>> schedules = [ ... { ... \\"busID\\": \\"BusA\\", ... \\"route\\": 1, ... \\"departures\\": [60, 120, 180, 240], ... \\"duration\\": 45 ... }, ... { ... \\"busID\\": \\"BusB\\", ... \\"route\\": 2, ... \\"departures\\": [90, 150, 210, 270], ... \\"duration\\": 35 ... } ... ] >>> earliestBus(100, schedules) {'busID': 'BusA', 'departureTime': 120} >>> earliestBus(50, schedules) {'busID': 'BusA', 'departureTime': 60} >>> earliestBus(300, schedules) None","solution":"def earliestBus(time, schedules): Determine the earliest bus you can catch based on the given time and bus schedules. Args: time (int): The current time in minutes past midnight. schedules (list): An array of bus schedules. Returns: dict: An object with 'busID' and 'departureTime' of the earliest bus you can catch, or None if there are no buses available after the given time. earliest_departure = None for schedule in schedules: for departure in schedule['departures']: if departure >= time: if earliest_departure is None or departure < earliest_departure['departureTime']: earliest_departure = { 'busID': schedule['busID'], 'departureTime': departure } break # No need to check further departures for this bus as they are sorted return earliest_departure"},{"question":"def room_events(events): Determines the total number of different people that were in the room at some point while validating the given sequence of events. Args: events (list): List of event strings. Returns: int: Total number of different people that were in the room or -1 if the sequence is invalid. Examples: >>> room_events([\\"enter Alice\\", \\"enter Bob\\", \\"leave Alice\\", \\"enter Charlie\\", \\"leave Bob\\", \\"leave Charlie\\"]) 3 >>> room_events([\\"enter Alice\\", \\"enter Bob\\", \\"leave Alice\\", \\"leave Bob\\", \\"leave Charlie\\"]) -1 >>> room_events([\\"enter Alice\\", \\"enter Alice\\", \\"leave Alice\\"]) -1","solution":"def room_events(events): Determines the total number of different people that were in the room at some point while validating the given sequence of events. Args: events (list): List of event strings. Returns: int: Total number of different people that were in the room or -1 if the sequence is invalid. people_in_room = set() all_people = set() for event in events: action, person = event.split() if action == \\"enter\\": if person in people_in_room: return -1 people_in_room.add(person) all_people.add(person) elif action == \\"leave\\": if person not in people_in_room: return -1 people_in_room.remove(person) return len(all_people)"},{"question":"def get_longest_path(input_string: str) -> int: Returns the length of the longest absolute path to a file in a Unix-like file system represented by the input string. >>> get_longest_path(\\"dirntsubdir1ntsubdir2nttfile.ext\\") 20 >>> get_longest_path(\\"dirntsubdir1nttfile1.extntsubdir2nttsubsubdir1ntttfile2.ext\\") 32 >>> get_longest_path(\\"dirntsubdir1ntsubdir2ntsubsubdir1\\") 0 >>> get_longest_path(\\"dirntfile.ext\\") 12 >>> get_longest_path(\\"dirntsubdir1nttfile1.extntsubdir2nttfile2.ext\\") 21","solution":"def get_longest_path(input_string): Returns the length of the longest absolute path to a file in a Unix-like file system represented by the input string. max_length = 0 path_lengths = {0: 0} # Dict to store the current length at each directory level for line in input_string.split('n'): name = line.lstrip('t') # Get the folder/file name by stripping leading tabs level = len(line) - len(name) # The level of the current name is the count of leading tabs if '.' in name: # It's a file max_length = max(max_length, path_lengths[level] + len(name)) else: # It's a directory path_lengths[level + 1] = path_lengths[level] + len(name) + 1 # Include '/' in length return max_length"},{"question":"def distribute_candies(candies: int, friends: int) -> List[int]: Distribute candies among friends. Parameters: candies (int): The total number of candies to distribute. friends (int): The number of friends to distribute the candies to. Returns: List[int]: A list where each element represents the number of candies received by each friend. Throws: ValueError: If \`candies\` or \`friends\` is negative. Examples: >>> distribute_candies(10, 3) [4, 3, 3] >>> distribute_candies(7, 4) [2, 2, 2, 1] >>> distribute_candies(0, 5) [0, 0, 0, 0, 0] >>> distribute_candies(10, 0) [] >>> distribute_candies(-5, 2) Traceback (most recent call last): ... ValueError: The number of candies and friends cannot be negative.","solution":"def distribute_candies(candies, friends): Distribute candies among friends. Parameters: candies (int): The total number of candies to distribute. friends (int): The number of friends to distribute the candies to. Returns: List[int]: A list where each element represents the number of candies received by each friend. Throws: ValueError: If \`candies\` or \`friends\` is negative. if candies < 0 or friends < 0: raise ValueError(\\"The number of candies and friends cannot be negative.\\") if friends == 0: return [] base_candies = candies // friends remaining_candies = candies % friends distribution = [base_candies] * friends for i in range(remaining_candies): distribution[i] += 1 return distribution"},{"question":"def shortest_to_char(s: str, c: str) -> List[int]: Given a string \`s\` consisting of lowercase alphabets and a character \`c\`, construct a new string where each character in the new string is the shortest distance from that character in the input string to the character \`c\`. The distance between two indices \`i\` and \`j\` is \`|i - j|\`. Example: >>> shortest_to_char(\\"loveleetcode\\", 'e') [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_to_char(\\"a\\", 'a') [0] >>> shortest_to_char(\\"abacabd\\", 'a') [0, 1, 0, 1, 0, 1, 2] >>> shortest_to_char(\\"abc\\", 'c') [2, 1, 0] >>> shortest_to_char(\\"cab\\", 'c') [0, 1, 2]","solution":"def shortest_to_char(s, c): Returns a list of shortest distances from each character in string s to the character c. Parameters: s (str): the input string consisting of lowercase alphabets. c (str): the character whose distance is to be measured from each character in s. Returns: List[int]: a list where each index contains the shortest distance from that index to the character c. n = len(s) result = [0] * n prev_position = float('-inf') # First pass: check distance from left to right for i in range(n): if s[i] == c: prev_position = i result[i] = abs(i - prev_position) # Second pass: check distance from right to left prev_position = float('inf') for i in range(n-1, -1, -1): if s[i] == c: prev_position = i result[i] = min(result[i], abs(i - prev_position)) return result"},{"question":"def longestCommonPrefix(strs: List[str]) -> str: Returns the longest common prefix string amongst the list of strings. If there is no common prefix, returns an empty string. pass from typing import List def test_common_prefix_in_first_two_chars(): assert longestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_no_common_prefix(): assert longestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_common_prefix_in_first_six_chars(): assert longestCommonPrefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" def test_identical_strings(): assert longestCommonPrefix([\\"throne\\", \\"throne\\"]) == \\"throne\\" def test_no_common_prefix_with_different_first_char(): assert longestCommonPrefix([\\"throne\\", \\"dungeon\\"]) == \\"\\" def test_empty_list(): assert longestCommonPrefix([]) == \\"\\" def test_single_string_in_list(): assert longestCommonPrefix([\\"a\\"]) == \\"a\\" assert longestCommonPrefix([\\"test\\"]) == \\"test\\" def test_all_identical_prefixes_of_various_lengths(): assert longestCommonPrefix([\\"prefix\\", \\"prefixes\\", \\"prefixing\\"]) == \\"prefix\\" def test_case_with_no_common_even_in_first_char(): assert longestCommonPrefix([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"\\"","solution":"def longestCommonPrefix(strs): Returns the longest common prefix string amongst the list of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Start by assuming the whole first string is the common prefix prefix = strs[0] # Compare the prefix with each string for string in strs[1:]: while string[:len(prefix)] != prefix: prefix = prefix[:len(prefix)-1] if not prefix: return \\"\\" return prefix"},{"question":"def tallest_tower_in_range(heights, queries): Given an array of tower heights and a list of queries, return a list of the heights of the tallest tower within each specified range (1-based index). Args: heights (list): list of integers representing the heights of the towers. queries (list): list of tuples where each tuple contains two integers (l, r). representing the range (1-based index inclusive). Returns: list: heights of the tallest towers for each query range. >>> tallest_tower_in_range([3, 1, 4, 1, 5], [(1, 3)]) [4] >>> tallest_tower_in_range([3, 1, 4, 1, 5], [(1, 3), (2, 4), (3, 5)]) [4, 4, 5] >>> tallest_tower_in_range([3, 1, 4, 1, 5], [(1, 5)]) [5] >>> tallest_tower_in_range([3, 1, 4, 1, 5], [(3, 3)]) [4] >>> tallest_tower_in_range([3, 3, 3, 3, 3], [(1, 2), (2, 3), (1, 5)]) [3, 3, 3] >>> tallest_tower_in_range(list(range(1, 100001)), [(1, 100000)]) [100000] >>> tallest_tower_in_range([2, 3, 4, 5, 6], [(1, 2), (4, 5)]) [3, 6] >>> tallest_tower_in_range([1, 3, 2, 1, 4], [(1, 3), (2, 4), (1, 5)]) [3, 3, 4]","solution":"def tallest_tower_in_range(heights, queries): Given an array of tower heights and a list of queries, return a list of the heights of the tallest tower within each specified range (1-based index). Args: heights (list): list of integers representing the heights of the towers. queries (list): list of tuples where each tuple contains two integers (l, r). representing the range (1-based index inclusive). Returns: list: heights of the tallest towers for each query range. results = [] for l, r in queries: max_height = max(heights[l-1:r]) # converting 1-based index to 0-based results.append(max_height) return results"},{"question":"from typing import List def skyline_visible_heights(heights: List[int]) -> List[int]: Returns an array that denotes the visible height of the skyline from left to right, as viewed from the front. >>> skyline_visible_heights([1, 4, 2, 5, 3]) [1, 4, 4, 5, 5] >>> skyline_visible_heights([10, 1, 2, 3, 4]) [10, 10, 10, 10, 10] >>> skyline_visible_heights([1, 1, 1, 1, 1]) [1, 1, 1, 1, 1] >>> skyline_visible_heights([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]","solution":"from typing import List def skyline_visible_heights(heights: List[int]) -> List[int]: if not heights: # If the input list is empty, return an empty list. return [] max_height_so_far = heights[0] visible_heights = [max_height_so_far] for height in heights[1:]: max_height_so_far = max(max_height_so_far, height) visible_heights.append(max_height_so_far) return visible_heights"},{"question":"def replace_with_sum_excluding_self(lst: List[int]) -> List[int]: Given a list of integers, returns a new list where each integer is replaced with the sum of all the integers in the original list except itself. >>> replace_with_sum_excluding_self([1, 2, 3, 4]) [9, 8, 7, 6] >>> replace_with_sum_excluding_self([0, 1, 2, 3]) [6, 5, 4, 3]","solution":"def replace_with_sum_excluding_self(lst): Given a list of integers, returns a new list where each integer is replaced with the sum of all the integers in the original list except itself. total_sum = sum(lst) return [total_sum - num for num in lst]"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def linked_list_swap(head: ListNode, val1: int, val2: int) -> ListNode: Implement a function \`linked_list_swap\` that operates on a singly linked list. The function should take a singly linked list and two integer values, \`val1\` and \`val2\`, as arguments and swap the nodes that contain these values. If one or both values are not present in the list, the function should leave the list unchanged. The function should not modify the values of the nodes, only switch the nodes themselves. Example: Given the linked list: 1 -> 2 -> 3 -> 4 -> 5 If the function is called as linked_list_swap(head, 2, 4), the linked list should be modified to: 1 -> 4 -> 3 -> 2 -> 5 Properties: - The function must handle edge cases, such as when one or both values are not present in the list. - The function must not create new nodes or change the values inside the nodes, only their positions. - The function's time complexity should be as efficient as possible. return def list_to_array(head): array = [] while head: array.append(head.value) head = head.next return array def array_to_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head def test_linked_list_swap(): head = array_to_list([1, 2, 3, 4, 5]) swapped = linked_list_swap(head, 2, 4) assert list_to_array(swapped) == [1, 4, 3, 2, 5] def test_linked_list_swap_not_present(): head = array_to_list([1, 2, 3, 4, 5]) swapped = linked_list_swap(head, 2, 6) assert list_to_array(swapped) == [1, 2, 3, 4, 5] def test_linked_list_swap_adjacent(): head = array_to_list([1, 2, 3, 4, 5]) swapped = linked_list_swap(head, 3, 4) assert list_to_array(swapped) == [1, 2, 4, 3, 5] def test_linked_list_swap_same_node(): head = array_to_list([1, 2, 3, 4, 5]) swapped = linked_list_swap(head, 3, 3) assert list_to_array(swapped) == [1, 2, 3, 4, 5] def test_linked_list_swap_at_head(): head = array_to_list([1, 2, 3, 4, 5]) swapped = linked_list_swap(head, 1, 5) assert list_to_array(swapped) == [5, 2, 3, 4, 1] def test_empty_list(): head = array_to_list([]) swapped = linked_list_swap(head, 1, 2) assert list_to_array(swapped) == [] def test_single_element_list(): head = array_to_list([1]) swapped = linked_list_swap(head, 1, 2) assert list_to_array(swapped) == [1] def test_double_element_list(): head = array_to_list([1, 2]) swapped = linked_list_swap(head, 1, 2) assert list_to_array(swapped) == [2, 1]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def linked_list_swap(head: ListNode, val1: int, val2: int) -> ListNode: if val1 == val2: return head prev1 = prev2 = None curr1 = curr2 = head found1 = found2 = False while curr1 and curr1.value != val1: prev1 = curr1 curr1 = curr1.next while curr2 and curr2.value != val2: prev2 = curr2 curr2 = curr2.next if curr1 and curr1.value == val1: found1 = True if curr2 and curr2.value == val2: found2 = True if not found1 or not found2: return head if prev1: prev1.next = curr2 else: head = curr2 if prev2: prev2.next = curr1 else: head = curr1 curr1.next, curr2.next = curr2.next, curr1.next return head"},{"question":"def longest_common_substring(strings: List[str]) -> str: Returns the longest common substring among the provided list of strings. >>> longest_common_substring([\\"ababc\\", \\"babca\\", \\"abcba\\"]) \\"abc\\" >>> longest_common_substring([\\"abcd\\", \\"efgh\\"]) \\"\\" >>> longest_common_substring([]) \\"\\" >>> longest_common_substring([\\"hello\\"]) \\"hello\\" >>> longest_common_substring([\\"teststring\\", \\"teststring\\"]) \\"teststring\\" >>> longest_common_substring([\\"abcdefg\\", \\"bcdef\\", \\"cde\\"]) \\"cde\\" >>> longest_common_substring([\\"abc\\", \\"def\\", \\"ghi\\"]) \\"\\" >>> longest_common_substring([\\"a\\", \\"a\\", \\"a\\"]) \\"a\\" >>> longest_common_substring([\\"a\\", \\"b\\", \\"c\\"]) \\"\\" >>> longest_common_substring([\\"ab\\", \\"bc\\", \\"abc\\"]) \\"b\\" >>> longest_common_substring([\\"thisisatest\\", \\"testing123testing\\", \\"kittest\\"]) \\"test\\"","solution":"def longest_common_substring(strings): Returns the longest common substring among the provided list of strings. # If no strings were provided, return an empty string if not strings: return \\"\\" # Initialize the longest common substring as an empty string lcs = \\"\\" # Take the first string as the reference string reference = strings[0] ref_len = len(reference) # Iterate through every possible substring of the reference string for i in range(ref_len): for j in range(i + 1, ref_len + 1): # Extract the substring candidate = reference[i:j] # Check if this candidate substring is present in all other strings if all(candidate in string for string in strings): # If this candidate is longer than the current longest, update it if len(candidate) > len(lcs): lcs = candidate return lcs"},{"question":"def smallest_lexicographical_palindrome(s: str) -> str: Determine if it's possible to rearrange the characters of string s to form a palindrome, and return the smallest possible lexicographical palindrome if possible. Otherwise, return \\"IMPOSSIBLE\\". >>> smallest_lexicographical_palindrome('aabb') 'abba' >>> smallest_lexicographical_palindrome('abc') 'IMPOSSIBLE' >>> smallest_lexicographical_palindrome('aaabbbb') 'abbabba'","solution":"def smallest_lexicographical_palindrome(s): from collections import Counter # Count the frequency of each character char_count = Counter(s) # Check the number of characters with odd frequency odd_char_count = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one character have odd frequency, it is impossible to form a palindrome if odd_char_count > 1: return \\"IMPOSSIBLE\\" # Separate characters into two parts: the first half and the center character (if any) first_half = [] center = '' for char in sorted(char_count): count = char_count[char] if count % 2 != 0: center = char first_half.append(char * (count // 2)) # Join and form the smallest lexicographical palindrome first_half_str = ''.join(first_half) palindrome = first_half_str + center + first_half_str[::-1] return palindrome"},{"question":"def is_stable(l1: int, l2: int, l3: int, l4: int) -> bool: Determines if a table can be stable based on the lengths of its 4 legs. A table is considered stable if at least two pairs of legs have the same length. >>> is_stable(2, 2, 3, 3) True >>> is_stable(2, 3, 3, 3) True >>> is_stable(2, 2, 2, 3) True >>> is_stable(1, 2, 3, 4) False >>> is_stable(4, 4, 4, 4) True","solution":"def is_stable(l1, l2, l3, l4): Determines if a table can be stable based on the lengths of its 4 legs. A table is considered stable if at least two pairs of legs have the same length. from collections import Counter leg_lengths = [l1, l2, l3, l4] count = Counter(leg_lengths) # At least one length appears twice or more. return any(v >= 2 for v in count.values())"},{"question":"from typing import List, Tuple def find_first_activity_repeated_k_times(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: You have been hired by a software development company to help optimize their database's search functionality. The database stores logs of user activities, and each log entry consists of an integer representing the activity type. Your task is to find the first occurring activity (represented as an integer) that is repeated exactly K times within a session. If no such activity exists, return -1. :param T: Number of test cases. :param test_cases: List of test cases, each described by a tuple where the first element is a tuple of integers N and K, and the second element is a list of N integers representing activities in the session. :return: List of results for each test case. >>> find_first_activity_repeated_k_times(2, [([6, 2], [1, 2, 3, 1, 2, 3]), ([5, 3], [10, 20, 10, 10, 20])]) [1, 10] >>> find_first_activity_repeated_k_times(1, [([5, 3], [10, 20, 10, 20, 30])]) [-1] from solution import find_first_activity_repeated_k_times def test_single_test_case_found(): T = 1 test_cases = [ ([6, 2], [1, 2, 3, 1, 2, 3]), ] assert find_first_activity_repeated_k_times(T, test_cases) == [1] def test_single_test_case_not_found(): T = 1 test_cases = [ ([5, 3], [10, 20, 10, 20, 30]), ] assert find_first_activity_repeated_k_times(T, test_cases) == [-1] def test_multiple_test_case_found(): T = 2 test_cases = [ ([6, 2], [1, 2, 3, 1, 2, 3]), ([5, 3], [10, 20, 10, 10, 20]) ] assert find_first_activity_repeated_k_times(T, test_cases) == [1, 10] def test_multiple_test_case_mixed(): T = 3 test_cases = [ ([6, 2], [1, 2, 3, 1, 2, 3]), ([5, 3], [10, 20, 10, 20, 30]), ([7, 2], [4, 5, 6, 4, 5, 6, 4]) ] assert find_first_activity_repeated_k_times(T, test_cases) == [1, -1, 4] def test_no_repeating_activities(): T = 1 test_cases = [ ([5, 2], [1, 2, 3, 4, 5]), ] assert find_first_activity_repeated_k_times(T, test_cases) == [-1]","solution":"def find_first_activity_repeated_k_times(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] activities = test_cases[i][1] activity_count = {} for activity in activities: if activity in activity_count: activity_count[activity] += 1 else: activity_count[activity] = 1 if activity_count[activity] == K: results.append(activity) break else: results.append(-1) return results"},{"question":"def apply_operations(n: int, nums: List[int], q: int, operations: List[Tuple[int, int, int]]) -> List[int]: Performs a series of update operations on the array. Args: n (int): The number of elements in the array. nums (List[int]): The array of non-negative integers. q (int): The number of update operations. operations (List[Tuple[int, int, int]]): The list of update operations where each operation is described by three integers type, x, y. Returns: List[int]: The final state of the array after performing all operations. >>> apply_operations(5, [1, 2, 3, 4, 5], 3, [(1, 0, 10), (2, 2, 2), (1, 4, 1)]) [11, 2, 6, 4, 6] >>> apply_operations(4, [2, 3, 5, 7], 2, [(2, 0, 2), (2, 1, 3)]) [4, 9, 5, 7] >>> apply_operations(3, [10, 20, 30], 4, [(1, 0, 5), (2, 1, 2), (1, 2, 10), (2, 0, 2)]) [30, 40, 40] >>> apply_operations(3, [1, 2, 3], 0, []) [1, 2, 3] >>> apply_operations(2, [1000000000, 2000000000], 1, [(1, 0, 1000000000)]) [2000000000, 2000000000]","solution":"def apply_operations(n, nums, q, operations): for operation in operations: type, x, y = operation if type == 1: nums[x] += y elif type == 2: nums[x] *= y return nums"},{"question":"from collections import defaultdict, OrderedDict class LFUCache: Design a Cache system that supports the Least Frequently Used (LFU) eviction policy. LFUCache(int capacity) Initializes the cache with a given capacity. int get(int key) Returns the value of the key if present in the cache, otherwise returns -1. void put(int key, int value) Updates the value of the key if present, or inserts the key-value pair if not present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. Constraints: - 0 <= capacity <= 10000 - -10^5 <= key <= 10^5 - -10^5 <= value <= 10^5 - At most 2 * 10^5 calls will be made to put and get. Example: Input: [\\"LFUCache\\",\\"put\\",\\"put\\",\\"get\\",\\"put\\",\\"get\\",\\"put\\",\\"get\\",\\"get\\",\\"get\\"] [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]] Output: [null,null,null,1,null,-1,null,-1,3,4] Explanation: LFUCache cache = new LFUCache(2); cache.put(1, 1); // cache: {1=1} cache.put(2, 2); // cache: {1=1, 2=2} cache.get(1); // returns 1, cache: {2=2, 1=1} cache.put(3, 3); // evicts key 2, cache: {1=1, 3=3} cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1, cache: {4=4, 3=3} cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 def __init__(self, capacity: int): pass def _update_freq(self, key): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int): pass # Unit Tests def test_put_get_operations(): cache = LFUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 cache.put(3, 3) assert cache.get(2) == -1 assert cache.get(3) == 3 cache.put(4, 4) assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4 def test_cache_eviction(): cache = LFUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 cache.put(3, 3) assert cache.get(1) == 1 assert cache.get(2) == -1 assert cache.get(3) == 3 def test_update_existing_key(): cache = LFUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) assert cache.get(1) == 10 assert cache.get(2) == 2 def test_capacity_zero(): cache = LFUCache(0) cache.put(1, 1) assert cache.get(1) == -1 cache.put(2, 2) assert cache.get(2) == -1 def test_frequency_increase(): cache = LFUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == 1 # Now key 1 should be the most frequently used cache.put(4, 4) assert cache.get(1) == 1 assert cache.get(2) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4","solution":"from collections import defaultdict, OrderedDict class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.min_freq = 0 self.key_to_val_freq = {} self.freq_to_keys = defaultdict(OrderedDict) def _update_freq(self, key): val, freq = self.key_to_val_freq[key] del self.freq_to_keys[freq][key] # If the key was the only one with the current minimum frequency if not self.freq_to_keys[freq]: del self.freq_to_keys[freq] if self.min_freq == freq: self.min_freq += 1 # Update key's frequency new_freq = freq + 1 self.freq_to_keys[new_freq][key] = None self.key_to_val_freq[key] = (val, new_freq) def get(self, key: int) -> int: if key not in self.key_to_val_freq: return -1 self._update_freq(key) return self.key_to_val_freq[key][0] def put(self, key: int, value: int): if self.capacity == 0: return if key in self.key_to_val_freq: self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1]) self._update_freq(key) return if len(self.key_to_val_freq) >= self.capacity: lfu_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False) del self.key_to_val_freq[lfu_key] self.key_to_val_freq[key] = (value, 1) self.freq_to_keys[1][key] = None self.min_freq = 1"},{"question":"def odd_or_even(number: int) -> str: Determines if a given number is odd or even. Returns 'Even' if the number is even, otherwise returns 'Odd'. Parameters: number (int): The number to be checked. Returns: str: 'Even' if the number is even, otherwise 'Odd'. Examples: >>> odd_or_even(2) 'Even' >>> odd_or_even(1) 'Odd' >>> odd_or_even(0) 'Even' >>> odd_or_even(100) 'Even' >>> odd_or_even(-1) 'Odd'","solution":"def odd_or_even(number): Returns 'Even' if the number is even, otherwise returns 'Odd'. return 'Even' if number % 2 == 0 else 'Odd'"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Example usage: >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 from solution import longest_unique_substring def test_example_cases(): assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 def test_empty_string(): assert longest_unique_substring(\\"\\") == 0 def test_single_character_string(): assert longest_unique_substring(\\"a\\") == 1 assert longest_unique_substring(\\"b\\") == 1 def test_all_unique_characters(): assert longest_unique_substring(\\"abcdef\\") == 6 def test_end_of_string(): assert longest_unique_substring(\\"abrkaabcdefghijjxxx\\") == 10 def test_large_input(): assert longest_unique_substring(\\"a\\" * 100000) == 1","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def flatten_array(nested_array): Flatten a nested array structure by concatenating nested arrays into a single output array. Args: nested_array (list): The nested list to be flattened. Returns: list: A flat list containing all the elements of the nested array. >>> flatten_array([1, [2, 3], 4]) == [1, 2, 3, 4] >>> flatten_array([]) == [] >>> flatten_array([[], []]) == [] >>> flatten_array([1, [2, 3, [4, 5]], 6, [7, [8, [9, 10]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> flatten_array([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> flatten_array([1]) == [1] >>> flatten_array([[1]]) == [1] >>> flatten_array([[], 1, [2], [], [3, [], [4]]]) == [1, 2, 3, 4]","solution":"def flatten_array(nested_array): Flatten a nested array structure by concatenating nested arrays into a single output array. Args: nested_array (list): The nested list to be flattened. Returns: list: A flat list containing all the elements of the nested array. flat_array = [] def flatten_helper(arr): nonlocal flat_array for item in arr: if isinstance(item, list): flatten_helper(item) else: flat_array.append(item) flatten_helper(nested_array) return flat_array"},{"question":"def is_hex(s: str) -> bool: Determines if the given string is a valid hexadecimal number. A valid hexadecimal number starts with '0x' or '0X' followed by one or more characters from '0'-'9', 'a'-'f', and 'A'-'F'. Args: s (str): The string to check. Returns: bool: True if valid hexadecimal, False otherwise. Examples: >>> is_hex(\\"0x1A3F\\") True >>> is_hex(\\"0X4a5b\\") True >>> is_hex(\\"0h1234\\") False >>> is_hex(\\"123456\\") False","solution":"def is_hex(s): Determines if the given string is a valid hexadecimal number. Args: s (str): The string to check. Returns: bool: True if valid hexadecimal, False otherwise. if len(s) < 3: return False if s[:2] not in ('0x', '0X'): return False hex_digits = set('0123456789abcdefABCDEF') for char in s[2:]: if char not in hex_digits: return False return True"},{"question":"def find_min_max(input_array): Returns the minimum and maximum values found in the list of tuples. Args: input_array (List[Tuple[int, int]]): A list of tuples containing integer pairs. Returns: Tuple[int, int]: A tuple containing the minimum and maximum values. Examples: >>> find_min_max([(1, 3), (2, 4), (3, 5), (1, 6)]) (1, 6) >>> find_min_max([(3, 9)]) (3, 9) >>> find_min_max([(5, 5), (5, 5)]) (5, 5) >>> find_min_max([(1000, 2000), (3000, 4000)]) (1000, 4000) >>> find_min_max([]) (None, None) >>> find_min_max([(1, 100), (25, 50), (3, 75)]) (1, 100)","solution":"def find_min_max(input_array): Returns the minimum and maximum values found in the list of tuples. if not input_array: return (None, None) # Flatten the list of tuples and convert it into a single list of numbers all_numbers = [num for pair in input_array for num in pair] # Find the minimum and the maximum value in the list min_value = min(all_numbers) max_value = max(all_numbers) return (min_value, max_value)"},{"question":"def first_non_repeating_elem(arr: List[int]) -> int: Returns the first non-repeating element in an array of integers. If all elements are repeating, returns -1. >>> first_non_repeating_elem([4, 5, 1, 2, 0, 4]) 5 >>> first_non_repeating_elem([7, 8, 7, 8, 9, 10, 9]) 10 >>> first_non_repeating_elem([2, 2, 3, 3, 4, 4]) -1","solution":"def first_non_repeating_elem(arr): Returns the first non-repeating element in an array of integers. If all elements are repeating, returns -1. element_count = {} # Count occurrences of each element for elem in arr: if elem in element_count: element_count[elem] += 1 else: element_count[elem] = 1 # Find the first non-repeating element for elem in arr: if element_count[elem] == 1: return elem return -1"},{"question":"def array_transform(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Given an integer array A of length N, return a new array B where B[i] is the sum of all the elements of A except A[i]. You must solve it without using division and in O(N) time complexity. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case consists of an integer N and a list of N integers. Returns: List[List[int]]: A list of resulting arrays B for each test case. Example: >>> array_transform(2, [(4, [1, 2, 3, 4]), (3, [5, 6, 7])]) [[9, 8, 7, 6], [13, 12, 11]] >>> array_transform(1, [(2, [-1, -2])]) [[-2, -1]]","solution":"def array_transform(T, test_cases): result = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] total_sum = sum(A) B = [total_sum - x for x in A] result.append(B) return result"},{"question":"def is_prime(num: int) -> bool: Helper function to determine if a number is prime. >>> is_prime(-1) False >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(9) False >>> is_prime(37) True >>> is_prime(49) False pass def filter_primes(arr: List[int]) -> List[int]: Return a new array containing only the prime numbers from the original array. >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([10, 15, 20, 21, 22]) [] >>> filter_primes([29, 37, 41, 43]) [29, 37, 41, 43] >>> filter_primes([0, 1, 5, 10, 17]) [5, 17] >>> filter_primes([-1, -2, -3, -4]) [] >>> filter_primes([11, 13, 17, 19, 23, 29, 31]) [11, 13, 17, 19, 23, 29, 31] >>> filter_primes([4, 6, 8, 9, 10, 12]) [] >>> filter_primes([]) [] pass","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def filter_primes(arr): Return a new array containing only the prime numbers from the original array. return [num for num in arr if is_prime(num)]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[ListNode]) -> ListNode: Merge k sorted linked lists and return it as one sorted list. >>> lists = [ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6))] >>> result_head = merge_k_lists(lists) >>> linked_list_to_list(result_head) [1, 1, 2, 3, 4, 4, 5, 6] # Implementation here def linked_list_to_list(head): Helper function to convert linked list to Python list. result = [] while head: result.append(head.val) head = head.next return result def test_merge_k_lists_example(): lists = [ ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6)) ] merged_head = merge_k_lists(lists) assert linked_list_to_list(merged_head) == [1, 1, 2, 3, 4, 4, 5, 6] def test_merge_k_lists_empty(): lists = [] merged_head = merge_k_lists(lists) assert linked_list_to_list(merged_head) == [] def test_merge_k_lists_single_list(): lists = [ListNode(1, ListNode(3, ListNode(5)))] merged_head = merge_k_lists(lists) assert linked_list_to_list(merged_head) == [1, 3, 5] def test_merge_k_lists_all_empty_lists(): lists = [None, None, None] merged_head = merge_k_lists(lists) assert linked_list_to_list(merged_head) == [] def test_merge_k_lists_varied_lengths(): lists = [ ListNode(1, ListNode(4, ListNode(7))), None, ListNode(2, ListNode(5)), ListNode(3) ] merged_head = merge_k_lists(lists) assert linked_list_to_list(merged_head) == [1, 2, 3, 4, 5, 7]","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists): min_heap = [] # Initialize the heap for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Find the longest common prefix among a list of strings. Parameters: strs (List[str]): A list of strings Returns: str: The longest common prefix, or an empty string if there is none Examples: >>> longest_common_prefix([\\"flight\\", \\"flow\\", \\"flower\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"cat\\", \\"bird\\"]) '' >>> longest_common_prefix([\\"onlyone\\"]) 'onlyone' >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"apple\\", \\"ape\\", \\"april\\"]) 'ap' >>> longest_common_prefix([\\"abcd\\", \\"abc\\", \\"ab\\", \\"a\\"]) 'a'","solution":"def longest_common_prefix(strs): Finds the longest common prefix string among a list of strings. Parameters: strs (List[str]): A list of strings Returns: str: The longest common prefix if not strs: return \\"\\" # Sort the array, the common prefix of the array will be between the first and last string (after sorting) strs.sort() # Initializing first and last string first_str = strs[0] last_str = strs[-1] i = 0 # Compare the characters of the first and the last string while i < len(first_str) and first_str[i] == last_str[i]: i += 1 return first_str[:i]"},{"question":"def is_alphabetically_sorted(s: str) -> bool: Check if the given string \`s\` is alphabetically sorted (case insensitive). >>> is_alphabetically_sorted(\\"aBcdEfGh\\") == True >>> is_alphabetically_sorted(\\"bAcDeFgH\\") == False >>> is_alphabetically_sorted(\\"abcdefg\\") == True >>> is_alphabetically_sorted(\\"ABCdefGH\\") == True >>> is_alphabetically_sorted(\\"ZYX\\") == False >>> is_alphabetically_sorted(\\"A\\") == True >>> is_alphabetically_sorted(\\"\\") == True >>> is_alphabetically_sorted(\\"AaBbCc\\") == True >>> is_alphabetically_sorted(\\"AcbD\\") == False >>> is_alphabetically_sorted(\\"aaa\\") == True >>> is_alphabetically_sorted(\\"AAAaaa\\") == True >>> is_alphabetically_sorted(\\"aaAAaaAA\\") == True >>> is_alphabetically_sorted(\\"abBA\\") == False","solution":"def is_alphabetically_sorted(s): Check if the given string \`s\` is alphabetically sorted (case insensitive). :param s: str - The string representing the order of books in a shelf. :return: bool - True if the string is alphabetically sorted, False otherwise. # Convert string to lower case to perform case insensitive comparison s_lower = s.lower() # Compare each character with the next one for i in range(len(s_lower) - 1): if s_lower[i] > s_lower[i + 1]: return False return True"},{"question":"def longest_substring_with_two_distinct_chars(s: str) -> int: Given a string, determine the longest substring that contains no more than two distinct characters. >>> longest_substring_with_two_distinct_chars('eceba') 3 >>> longest_substring_with_two_distinct_chars('ccaabbb') 5","solution":"def longest_substring_with_two_distinct_chars(s): Returns the length of the longest substring that contains no more than two distinct characters. if len(s) == 0: return 0 left = 0 max_len = 0 char_count = {} for right in range(len(s)): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def remove_duplicates(users: List[Dict[str, str]]) -> List[Dict[str, str]]: Remove duplicates from the list of user records, keeping only the first instance of each duplicate set. Two records are considered duplicates if at least two out of 'name', 'email', and 'phone' match. >>> users = [ ... {'name': 'John Doe', 'email': 'john@example.com', 'phone': '555-1234'}, ... {'name': 'Jane Smith', 'email': 'jane@example.com', 'phone': '555-5678'}, ... {'name': 'John R. Doe', 'email': 'john@example.com', 'phone': '555-9101'}, ... {'name': 'Johnny Doe', 'email': 'john@example.com', 'phone': '555-9101'}, ... {'name': 'Jane Smith', 'email': 'jane@domain.com', 'phone': '555-5678'}, ... ] >>> remove_duplicates(users) [{'name': 'John Doe', 'email': 'john@example.com', 'phone': '555-1234'}, {'name': 'Jane Smith', 'email': 'jane@example.com', 'phone': '555-5678'}, {'name': 'John R. Doe', 'email': 'john@example.com', 'phone': '555-9101'}] >>> remove_duplicates([]) [] >>> users = [ ... {'name': 'John Doe', 'email': 'john@example.com', 'phone': '555-1234'}, ... {'name': 'John Doe', 'email': 'john@example.com', 'phone': '555-1234'}, ... {'name': 'John Doe', 'email': 'john@example.com', 'phone': '555-1234'}, ... ] >>> remove_duplicates(users) [{'name': 'John Doe', 'email': 'john@example.com', 'phone': '555-1234'}] pass","solution":"def remove_duplicates(users): Remove duplicates from the list of user records, keeping only the first instance of each duplicate set. seen = [] unique_users = [] for user in users: # For each user, check for duplicates is_duplicate = False for seen_user in seen: if sum(1 for k in ['name', 'email', 'phone'] if user[k] == seen_user[k]) >= 2: is_duplicate = True break # If it's not a duplicate, add to the list of seen users and unique_users if not is_duplicate: seen.append(user) unique_users.append(user) return unique_users"},{"question":"def max_difference(nums): Returns the maximum difference between any two elements such that the larger element comes after the smaller element in the array. If no such elements exist, returns -1. >>> max_difference([2, 3, 10, 6, 4, 8, 1]) 8 >>> max_difference([7, 1, 5, 4]) 4 >>> max_difference([9, 4, 3, 2]) -1 >>> max_difference([1, 5, 2, 10]) 9 pass def test_max_difference(): assert max_difference([2, 3, 10, 6, 4, 8, 1]) == 8 assert max_difference([7, 1, 5, 4]) == 4 assert max_difference([9, 4, 3, 2]) == -1 assert max_difference([1, 5, 2, 10]) == 9 assert max_difference([1, 1, 1, 1]) == -1 assert max_difference([]) == -1 assert max_difference([1]) == -1 assert max_difference([0, 10000]) == 10000 assert max_difference([10000, 0]) == -1 def test_max_difference_edge_cases(): assert max_difference([3, 3, 3, 3]) == -1 assert max_difference([1, 100, 1, 100]) == 99 assert max_difference([1, 2, 3, 4, 5]) == 4 assert max_difference([5, 4, 3, 2, 1]) == -1 assert max_difference([1, 2]) == 1 if __name__ == \\"__main__\\": test_max_difference() test_max_difference_edge_cases() print(\\"All tests passed!\\")","solution":"def max_difference(nums): Returns the maximum difference between any two elements such that the larger element comes after the smaller element in the array. If no such elements exist, returns -1. if len(nums) < 2: return -1 min_element = nums[0] max_diff = -1 for i in range(1, len(nums)): if nums[i] > min_element: max_diff = max(max_diff, nums[i] - min_element) min_element = min(min_element, nums[i]) return max_diff"},{"question":"def validate_ip(ip: str) -> str: Validates if the input string is a valid IPv4 address. An IPv4 address is valid if it consists of four octets, each between 0 and 255, inclusive, and separated by periods (\\".\\"). No extra leading zeros are allowed. :param ip: A string representing the IPv4 address. :return: \\"Valid IPv4 address\\" if the input string is a valid IPv4 address; otherwise, returns \\"Invalid IPv4 address\\". >>> validate_ip(\\"192.168.0.1\\") 'Valid IPv4 address' >>> validate_ip(\\"256.256.256.256\\") 'Invalid IPv4 address' >>> validate_ip(\\"192.168.01.1\\") 'Invalid IPv4 address' >>> validate_ip(\\"192.168.0.999\\") 'Invalid IPv4 address' >>> validate_ip(\\"192.168@0.1\\") 'Invalid IPv4 address' >>> validate_ip(\\"192.168.0\\") 'Invalid IPv4 address' >>> validate_ip(\\"19216801\\") 'Invalid IPv4 address' >>> validate_ip(\\"192.168\\") 'Invalid IPv4 address' >>> validate_ip(\\"192.168.0.1.1\\") 'Invalid IPv4 address' >>> validate_ip(\\"...\\") 'Invalid IPv4 address' >>> validate_ip(\\"01.01.01.01\\") 'Invalid IPv4 address' >>> validate_ip(\\"001.001.001.001\\") 'Invalid IPv4 address' >>> validate_ip(\\"\\") 'Invalid IPv4 address' >>> validate_ip(\\"1.1.1.256\\") 'Invalid IPv4 address' >>> validate_ip(\\"300.1.1.1\\") 'Invalid IPv4 address'","solution":"def validate_ip(ip: str) -> str: Validates if the input string is a valid IPv4 address. :param ip: A string representing the IPv4 address. :return: \\"Valid IPv4 address\\" if the input string is a valid IPv4 address; otherwise, returns \\"Invalid IPv4 address\\". octets = ip.split('.') # IPv4 address must be exactly 4 octets if len(octets) != 4: return \\"Invalid IPv4 address\\" for octet in octets: # Each octet must be a number, and in the range 0 to 255 if not octet.isdigit() or not (0 <= int(octet) <= 255): return \\"Invalid IPv4 address\\" # Each octet must not have leading zeros if len(octet) > 1 and octet[0] == '0': return \\"Invalid IPv4 address\\" return \\"Valid IPv4 address\\""},{"question":"def can_accommodate_reservations(test_cases): Determine if all reservations in the list can be accommodated without any time overlap for any of the tables. >>> can_accommodate_reservations([[(1, 3), (2, 5), (4, 6)], [(1, 2), (2, 3)]]) ['REJECTED', 'ACCEPTED'] # Implement your solution here def parse_input(input_text): Parse the input text into test cases. >>> parse_input(\\"2n3n1 3n2 5n4 6n2n1 2n2 3n\\") [[(1, 3), (2, 5), (4, 6)], [(1, 2), (2, 3)]] # Implement your solution here def restaurant_reservations(input_text): Read input, process reservations, and print results. >>> restaurant_reservations(\\"2n3n1 3n2 5n4 6n2n1 2n2 3n\\") REJECTED ACCEPTED # Implement your solution here # Unit tests def run_test_case(input_text): import sys from io import StringIO old_stdout = sys.stdout sys.stdout = StringIO() restaurant_reservations(input_text) result = sys.stdout.getvalue() sys.stdout = old_stdout return result def test_sample_input(): input_text = \\"2n3n1 3n2 5n4 6n2n1 2n2 3n\\" expected_output = \\"REJECTEDnACCEPTEDn\\" assert run_test_case(input_text) == expected_output def test_no_overlaps(): input_text = \\"1n4n1 2n3 4n5 6n7 8n\\" expected_output = \\"ACCEPTEDn\\" assert run_test_case(input_text) == expected_output def test_all_overlaps(): input_text = \\"1n3n1 4n2 3n3 5n\\" expected_output = \\"REJECTEDn\\" assert run_test_case(input_text) == expected_output def test_edge_case(): input_text = \\"1n2n0 1000n999 1000n\\" expected_output = \\"REJECTEDn\\" assert run_test_case(input_text) == expected_output def test_single_reservation(): input_text = \\"1n1n0 1n\\" expected_output = \\"ACCEPTEDn\\" assert run_test_case(input_text) == expected_output","solution":"def can_accommodate_reservations(test_cases): results = [] for reservations in test_cases: reservations.sort() # Sort by start time accepted = True for i in range(1, len(reservations)): if reservations[i][0] < reservations[i - 1][1]: accepted = False break results.append(\\"ACCEPTED\\" if accepted else \\"REJECTED\\") return results def parse_input(input_text): lines = input_text.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 reservations = [] for __ in range(N): Si, Ei = map(int, lines[index].split()) reservations.append((Si, Ei)) index += 1 test_cases.append(reservations) return test_cases def restaurant_reservations(input_text): test_cases = parse_input(input_text) results = can_accommodate_reservations(test_cases) for result in results: print(result)"},{"question":"def custom_fizzbuzz(n: int, fizz_num: int, buzz_num: int) -> List[str]: Simulates the FizzBuzz game with custom fizz and buzz values. Args: n (int): The number up to which the game should be played. fizz_num (int): The number which, if a number in range is divisible by, returns 'Fizz'. buzz_num (int): The number which, if a number in range is divisible by, returns 'Buzz'. Returns: List[str]: List of strings representing the results of the game. Examples: >>> custom_fizzbuzz(15, 3, 5) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"] >>> custom_fizzbuzz(10, 2, 3) [\\"1\\", \\"Fizz\\", \\"Buzz\\", \\"Fizz\\", \\"5\\", \\"FizzBuzz\\", \\"7\\", \\"Fizz\\", \\"Buzz\\", \\"Fizz\\"]","solution":"def custom_fizzbuzz(n, fizz_num, buzz_num): Simulates the FizzBuzz game with custom fizz and buzz values. Args: n (int): The number up to which the game should be played. fizz_num (int): The number which, if a number in range is divisible by, returns 'Fizz'. buzz_num (int): The number which, if a number in range is divisible by, returns 'Buzz'. Returns: List[str]: List of strings representing the results of the game. result = [] for i in range(1, n + 1): if i % fizz_num == 0 and i % buzz_num == 0: result.append(\\"FizzBuzz\\") elif i % fizz_num == 0: result.append(\\"Fizz\\") elif i % buzz_num == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"from typing import List def frequency_descending(arr: List[int]) -> List[int]: Create a function that takes a list of integers, \`arr\`, and returns a list of integers which contains only the first occurrence of each element from the original array, but orders the elements in descending order based on their frequency in \`arr\`. If multiple elements have the same frequency, they should appear in ascending order in the result list. >>> frequency_descending([3, 3, 2, 1, 4, 4, 4, 2]) [4, 2, 3, 1] >>> frequency_descending([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) [4, 3, 2, 1] >>> frequency_descending([5, 5, 4, 6, 6, 6, 7]) [6, 5, 4, 7]","solution":"def frequency_descending(arr): from collections import Counter # Count the frequency of each number in the array frequency = Counter(arr) # Create a list of (element, frequency) pairs frequency_pairs = list(frequency.items()) # Sort the pairs first by frequency (descending) and then by the element itself (ascending) sorted_frequency_pairs = sorted(frequency_pairs, key=lambda x: (-x[1], x[0])) # Extract only the elements from the sorted pairs result = [element for element, freq in sorted_frequency_pairs] return result"},{"question":"def longest_lexicographical_substring(s: str) -> int: Returns the length of the longest lexicographical substring in the given string. Args: s (str): A string consisting of lowercase English letters. Returns: int: The length of the longest lexicographical substring. >>> longest_lexicographical_substring(\\"abcabcdef\\") 6 >>> longest_lexicographical_substring(\\"acbd\\") 2 >>> longest_lexicographical_substring(\\"zyxw\\") 1","solution":"def longest_lexicographical_substring(s): Returns the length of the longest lexicographical substring in the given string. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] >= s[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Args: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: The merged sorted array. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([10, 20], [5, 15, 25]) [5, 10, 15, 20, 25] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Args: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: The merged sorted array. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements of arr1 or arr2 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def categorize_movies(N, movies): Categorize movies based on their genre and release year, then display them grouped by genre. >>> categorize_movies(4, [\\"Inception SciFi 2010\\", \\"Avatar SciFi 2009\\", \\"Titanic Romance 1997\\", \\"Interstellar SciFi 2014\\"]) [\\"Romance\\", \\"Titanic (1997)\\", \\"SciFi\\", \\"Avatar (2009)\\", \\"Inception (2010)\\", \\"Interstellar (2014)\\"] >>> categorize_movies(3, [\\"Avengers Action 2012\\", \\"IronMan Action 2008\\", \\"Thor Action 2011\\"]) [\\"Action\\", \\"IronMan (2008)\\", \\"Thor (2011)\\", \\"Avengers (2012)\\"] :param N: int - the number of movies :param movies: List[str] - list of strings where each string contains the movie title, genre, and release year separated by space :return: List[str] - sorted movie collection grouped by genre with each movie displayed as \\"Title (Year)\\"","solution":"def categorize_movies(N, movies): from collections import defaultdict # Create a dictionary where the key is the genre and the value is a list of tuples (title, year) movie_dict = defaultdict(list) for movie in movies: title, genre, year = movie.split() year = int(year) movie_dict[genre].append((title, year)) # Sort the genres alphabetically sorted_genres = sorted(movie_dict.keys()) result = [] for genre in sorted_genres: result.append(genre) # Sort the movies within the genre by year sorted_movies = sorted(movie_dict[genre], key=lambda x: x[1]) for title, year in sorted_movies: result.append(f\\"{title} ({year})\\") return result # Example of the function in action N = 4 movies = [ \\"Inception SciFi 2010\\", \\"Avatar SciFi 2009\\", \\"Titanic Romance 1997\\", \\"Interstellar SciFi 2014\\" ] print(\\"n\\".join(categorize_movies(N, movies)))"},{"question":"def count_unique_palindromic_substrings(arr: List[str]) -> int: Returns the total number of unique palindromic substrings found within all the strings in the array. >>> count_unique_palindromic_substrings([\\"abba\\"]) 4 >>> count_unique_palindromic_substrings([\\"racecar\\"]) 7 >>> count_unique_palindromic_substrings([\\"abba\\", \\"racecar\\"]) 10 >>> count_unique_palindromic_substrings([\\"abc\\", \\"def\\"]) 6 >>> count_unique_palindromic_substrings([\\"\\"]) 0 >>> count_unique_palindromic_substrings([\\"aaa\\"]) 3 >>> count_unique_palindromic_substrings([\\"aa\\", \\"aaa\\"]) 3 >>> count_unique_palindromic_substrings([\\"Aa\\", \\"bB\\"]) 4","solution":"def count_unique_palindromic_substrings(arr): Returns the total number of unique palindromic substrings found within all the strings in the array. :param arr: List of strings :return: Integer count of unique palindromic substrings unique_palindromes = set() def is_palindrome(s): return s == s[::-1] for string in arr: n = len(string) for length in range(1, n + 1): for start in range(n - length + 1): substring = string[start:start + length] if is_palindrome(substring): unique_palindromes.add(substring) return len(unique_palindromes)"},{"question":"def max_increasing_subsequence_sum(arr: List[int]) -> int: Returns the largest possible sum that can be obtained by summing a strictly increasing subsequence of the array. Parameters: arr (list): A list of positive integers. Returns: int: The largest possible sum of a strictly increasing subsequence. >>> max_increasing_subsequence_sum([10]) == 10 >>> max_increasing_subsequence_sum([7, 7, 7, 7]) == 7 >>> max_increasing_subsequence_sum([4, 6, 1, 3, 8, 4, 6]) == 18 >>> max_increasing_subsequence_sum([1, 2, 3, 4, 5]) == 15 >>> max_increasing_subsequence_sum([5, 4, 3, 2, 1]) == 5 >>> max_increasing_subsequence_sum([3, 7, 2, 8, 4, 10, 5, 12]) == 40 >>> max_increasing_subsequence_sum(list(range(1, 1001))) == sum(range(1, 1001)) # Your code here","solution":"def max_increasing_subsequence_sum(arr): Returns the largest possible sum that can be obtained by summing a strictly increasing subsequence of the array. Parameters: arr (list): A list of positive integers. Returns: int: The largest possible sum of a strictly increasing subsequence. n = len(arr) # Initialize dp array where each element is the sum of the subsequence ending at that index dp = arr[:] # Start with each element itself being the max sum at that point for i in range(1, n): for j in range(i): if arr[j] < arr[i]: dp[i] = max(dp[i], dp[j] + arr[i]) return max(dp) # The maximum value in dp array is the answer"},{"question":"def single_number(nums: List[int]) -> int: Returns the element that appears exactly once in the list where all other elements appears exactly twice. >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([2, 2, 3, 3, 7]) 7 >>> single_number([17, 17, 5, 7, 7, 11, 11, 9, 9]) 5","solution":"def single_number(nums): Returns the element that appears exactly once in the list where all other elements appear exactly twice. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def custom_sort(lst: List[int]) -> List[int]: Given a list of integers, return the list sorted in non-decreasing order without using the built-in sort function. Implement a custom sorting algorithm to achieve this task, and ensure the algorithm's complexity is appropriate for the input size. >>> custom_sort([4, 2, 7, 1, 9]) [1, 2, 4, 7, 9] >>> custom_sort([10, 5, 8, 3, 3, 2]) [2, 3, 3, 5, 8, 10]","solution":"def custom_sort(lst): Sorts a list of integers in non-decreasing order without using the built-in sort function. Uses the merge sort algorithm for sorting. if len(lst) <= 1: return lst mid = len(lst) // 2 left = custom_sort(lst[:mid]) right = custom_sort(lst[mid:]) return merge(left, right) def merge(left, right): Merges two sorted lists into one sorted list. sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"def calculate_prize(points): Returns the total prize money based on the points earned in each round. Parameters: points (list of int): A list where each integer represents the points earned in each round. Returns: int: The total prize money earned. >>> calculate_prize([5, 10, 15]) 300 >>> calculate_prize([20]) 200 >>> calculate_prize([]) 0 >>> calculate_prize([0, 0, 0]) 0 >>> calculate_prize([100, 200, 300]) 6000 >>> calculate_prize([0, 5, 0, 10, 0]) 150","solution":"def calculate_prize(points): Returns the total prize money based on the points earned in each round. Parameters: points (list of int): A list where each integer represents the points earned in each round. Returns: int: The total prize money earned. return sum(points) * 10"},{"question":"def process_list(lst: List[int]) -> List[int]: Given a list of integers, find the maximum difference between two elements in the list such that the larger element comes after the smaller element. Then remove all duplicates from the list and return the list in its reversed order. >>> process_list([2, 3, 10, 6, 4, 8, 1]) [1, 8, 4, 6, 10, 3, 2] >>> process_list([5]) [5] >>> process_list([1, 2, 2, 3, 3, 3, 4, 4]) [4, 3, 2, 1] >>> process_list([7, 7, 7, 7, 7]) [7] >>> process_list([]) [] >>> process_list([2, 10]) [10, 2]","solution":"def process_list(lst): if len(lst) < 2: max_diff = 0 else: max_diff, min_element = float('-inf'), float('inf') for num in lst: if num < min_element: min_element = num else: diff = num - min_element if diff > max_diff: max_diff = diff # Remove duplicates lst_unique = list(dict.fromkeys(lst)) # Reverse the list lst_unique.reverse() return lst_unique"},{"question":"def fibonacci_up_to(n: int) -> list: Generates a list of Fibonacci numbers up to a given number \`n\`. >>> fibonacci_up_to(10) [0, 1, 1, 2, 3, 5, 8] >>> fibonacci_up_to(1) [0, 1, 1] >>> fibonacci_up_to(0) [0] >>> fibonacci_up_to(-5) [] pass","solution":"def fibonacci_up_to(n: int) -> list: Returns a list of all Fibonacci numbers less than or equal to \`n\`. if n < 0: return [] fib_sequence = [0, 1] while True: next_fib = fib_sequence[-1] + fib_sequence[-2] if next_fib > n: break fib_sequence.append(next_fib) if n == 0: return [0] return fib_sequence"},{"question":"def max_submatrix_sum(matrix: List[List[int]]) -> int: Given a 2D matrix, finds the maximum sum of any contiguous submatrix. >>> max_submatrix_sum([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) == 29 >>> max_submatrix_sum([[-50]]) == -50 >>> max_submatrix_sum([[50]]) == 50 >>> max_submatrix_sum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> max_submatrix_sum([ ... [-1, -1, -1], ... [-1, -1, -1], ... [-1, -1, -1] ... ]) == -1 >>> max_submatrix_sum([ ... [1, -1, 1], ... [-1, 1, -1], ... [1, -1, 1] ... ]) == 1 >>> max_submatrix_sum([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6], ... [2, 3, -5, -6, 7] ... ]) == 29","solution":"def max_submatrix_sum(matrix): Given a 2D matrix, finds the maximum sum of any contiguous submatrix. n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') for left in range(m): tmp = [0] * n for right in range(left, m): for i in range(n): tmp[i] += matrix[i][right] current_sum = kadane(tmp) max_sum = max(max_sum, current_sum) return max_sum def kadane(array): Helper function to apply Kadane's algorithm on 1D array to find the maximum sum of a contiguous subarray. max_end_here = max_so_far = array[0] for x in array[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far"},{"question":"def can_sum_to_S(N: int, S: int, P: List[int]) -> str: Determines if there exists a non-empty subset of P that sums exactly to S. Parameters: N (int): Number of products. S (int): Target sum. P (List[int]): List of popularity scores of products. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\".","solution":"def can_sum_to_S(N, S, P): Determines if there exists a non-empty subset of P that sums exactly to S. Parameters: N (int): Number of products. S (int): Target sum. P (List[int]): List of popularity scores of products. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". # Use dynamic programming to solve the subset sum problem dp = [False] * (S + 1) dp[0] = True for num in P: for t in range(S, num - 1, -1): if dp[t - num]: dp[t] = True return \\"YES\\" if dp[S] else \\"NO\\""},{"question":"def capitalizeSentences(text: str) -> str: Write a function \`capitalizeSentences\` that accepts a string \`text\` as input, which contains multiple sentences. Each sentence is separated by a period followed by a space. The function should return a new string where the first letter of each sentence is capitalized. Args: text (str): The input string containing multiple sentences. Returns: str: The string with each sentence's first letter capitalized. >>> capitalizeSentences(\\"hello world. this is a test. how are you?\\") \\"Hello world. This is a test. How are you?\\" >>> capitalizeSentences(\\"the sky is blue. the sun is bright.\\") \\"The sky is blue. The sun is bright.\\" >>> capitalizeSentences(\\"this is a single sentence.\\") \\"This is a single sentence.\\" >>> capitalizeSentences(\\"\\") \\"\\" >>> capitalizeSentences(\\"Hello world. This is a test.\\") \\"Hello world. This is a test.\\" >>> capitalizeSentences(\\" hello world. this is a test.\\") \\" hello world. This is a test.\\" >>> capitalizeSentences(\\"no periods in this string\\") \\"No periods in this string\\"","solution":"def capitalizeSentences(text): Returns a new string where the first letter of each sentence is capitalized. Args: text (str): The input string containing multiple sentences. Returns: str: The string with each sentence's first letter capitalized. sentences = text.split('. ') capitalized_sentences = [sentence.capitalize() for sentence in sentences] return '. '.join(capitalized_sentences)"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Given an integer array nums and an integer k, returns true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k. >>> contains_nearby_duplicate([1,2,3,1], 3) True >>> contains_nearby_duplicate([1,0,1,1], 1) True >>> contains_nearby_duplicate([1,2,3,1,2,3], 2) False","solution":"def contains_nearby_duplicate(nums, k): Given an integer array nums and an integer k, returns true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k. num_dict = {} for i, num in enumerate(nums): if num in num_dict and i - num_dict[num] <= k: return True num_dict[num] = i return False"},{"question":"def process_order_total(order_items): Calculate the total price of an order. Args: order_items (list of tuples): A list where each tuple contains the price of an item and its quantity Returns: float: The total price of the order Examples: >>> process_order_total([(10.0, 2), (5.0, 3)]) 35.0 >>> process_order_total([]) 0.0 pass def apply_discount(total_price, discount_rate): Apply discount to the total price. Args: total_price (float): The total price of the order discount_rate (float): The discount rate to apply (0 <= discount rate < 1) Returns: float: The discounted total price Examples: >>> apply_discount(100.0, 0.1) 90.0 >>> apply_discount(50.0, 0.0) 50.0 pass","solution":"def process_order_total(order_items): Calculate the total price of an order. Args: order_items (list of tuples): A list where each tuple contains the price of an item and its quantity Returns: float: The total price of the order Examples: >>> process_order_total([(10.0, 2), (5.0, 3)]) 35.0 >>> process_order_total([]) 0.0 return sum(price * quantity for price, quantity in order_items) def apply_discount(total_price, discount_rate): Apply discount to the total price. Args: total_price (float): The total price of the order discount_rate (float): The discount rate to apply (0 <= discount rate < 1) Returns: float: The discounted total price Examples: >>> apply_discount(100.0, 0.1) 90.0 >>> apply_discount(50.0, 0.0) 50.0 return total_price - (total_price * discount_rate) if total_price > 0 and discount_rate > 0 else total_price"}]`),C={name:"App",components:{PoemCard:z},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},I={class:"card-container"},S={key:0,class:"empty-state"},j=["disabled"],E={key:0},D={key:1};function P(n,e,l,m,i,a){const f=p("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"ðŸ¤”prompts chatðŸ§ ")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"ðŸ”",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," âœ• ")):u("",!0)]),t("div",I,[(s(!0),r(x,null,v(a.displayedPoems,(o,h)=>(s(),y(f,{key:h,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",S,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",D,"Loading...")):(s(),r("span",E,"See more"))],8,j)):u("",!0)])}const B=c(C,[["render",P],["__scopeId","data-v-b4ae306f"]]),G=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/57.md","filePath":"grok/57.md"}'),M={name:"grok/57.md"},U=Object.assign(M,{setup(n){return(e,l)=>(s(),r("div",null,[w(B)]))}});export{G as __pageData,U as default};
