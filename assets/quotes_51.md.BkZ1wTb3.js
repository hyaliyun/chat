import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-bd00edfb"]]),S=JSON.parse('[{"question":"**Robot Cleaner Path** You are tasked with programming a robot vacuum cleaner that navigates and cleans a rectangular grid. The grid is represented as a 2D array where each cell can either be an open space, an obstacle, or the cleaner\'s starting position. The cleaner aims to visit all the open spaces, avoiding obstacles, and return to its starting position. The robot follows these rules: 1. It starts from a given position and moves up, down, left, or right. 2. It cannot move diagonally. 3. It must visit each open space at least once. 4. It must avoid the obstacles. 5. After visiting all open spaces, it must return to its starting position. # Requirements: 1. **Input and Output Formats**: * A 2D list representing the grid with: - `\'S\'` for the starting position. - `\'.\'` for open spaces. - `\'#\'` for obstacles. * The function should output a boolean indicating whether the robot can visit all open spaces and return to the start (`True` or `False`). 2. **Constraints**: * The grid dimension will not exceed 30x30. * There will be only one starting position. * The robot cannot move out of the grid bounds. # Example ```python grid = [ [\'S\', \'.\', \'.\', \'#\'], [\'.\', \'#\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'S\'] ] print(robot_cleaner_path(grid)) # Output: True grid = [ [\'S\', \'#\', \'.\'], [\'#\', \'.\', \'#\'], [\'#\', \'.\', \'S\'] ] print(robot_cleaner_path(grid)) # Output: False grid = [ [\'S\', \'#\', \'.\'], [\'#\', \'#\', \'#\'], [\'#\', \'.\', \'S\'] ] print(robot_cleaner_path(grid)) # Output: False ``` # Function Signature ```python def robot_cleaner_path(grid: List[List[str]]) -> bool: pass ``` In this problem, you must assess various paths the robot might take to ensure it visits all open spaces at least once and successfully returns to its starting point, managing obstacles along the way.","solution":"from typing import List, Tuple def robot_cleaner_path(grid: List[List[str]]) -> bool: def dfs(x: int, y: int, visited: set) -> bool: if not (0 <= x < len(grid) and 0 <= y < len(grid[0])): # out of bounds return False if grid[x][y] == \'#\' or (x, y) in visited: # obstacle or already visited return False visited.add((x, y)) # If we\'ve visited all open spaces, check if we can return to start. if len(visited) == open_spaces: return True # Explore surrounding cells for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if dfs(nx, ny, visited): return True # Backtrack visited.remove((x, y)) return False open_spaces = sum(row.count(\'.\') for row in grid) + 1 # Including the starting position start_pos = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == \'S\'][0] visited = set() if dfs(start_pos[0], start_pos[1], visited): # Check if after visiting all, we can return to start return (start_pos[0], start_pos[1]) in visited return False"},{"question":"# Coding Assessment Question You are a backend engineer tasked with developing new functionalities for a popular customer review platform. Your goal is to demonstrate your ability to handle data processing and aggregation by implementing a function that efficiently calculates aggregated review statistics for various products. Write a function `calculate_review_stats(reviews: list[dict]) -> dict` that performs the following operations: 1. **Average Rating**: Calculate the average rating for each product. 2. **Total Reviews**: Count the total number of reviews for each product. 3. **Max Rating**: Identify the highest rating received for each product. 4. **Min Rating**: Identify the lowest rating received for each product. 5. **Ratings Summary**: Provide a summary of rating counts (1 to 5 stars) for each product. Your function should handle the following input: * **reviews**: A list of dictionaries, where each dictionary represents a single review and contains the product ID (`product_id`), the rating given (`rating` between 1 and 5), and a review text (`review_text`). Function Signature ```python def calculate_review_stats(reviews: list[dict]) -> dict: pass ``` Input Conditions and Prechecks * The `reviews` list should be non-empty. * Each review dictionary must contain the keys `product_id`, `rating`, and `review_text`. * The `rating` value should be an integer between 1 and 5. Expected Output The function should return a dictionary where each key is a product ID, and the associated value is another dictionary containing: * `average_rating`: Float value representing the average rating. * `total_reviews`: Integer representing the total number of reviews. * `max_rating`: Integer representing the highest rating received. * `min_rating`: Integer representing the lowest rating received. * `ratings_summary`: Dictionary where keys are rating scores (1 to 5) and values are the counts of each rating. Example Usage ```python reviews = [ {\\"product_id\\": \\"A1\\", \\"rating\\": 4, \\"review_text\\": \\"Great product!\\"}, {\\"product_id\\": \\"A1\\", \\"rating\\": 5, \\"review_text\\": \\"Excellent!\\"}, {\\"product_id\\": \\"A2\\", \\"rating\\": 3, \\"review_text\\": \\"Average.\\"}, {\\"product_id\\": \\"A1\\", \\"rating\\": 2, \\"review_text\\": \\"Not as expected.\\"}, {\\"product_id\\": \\"A2\\", \\"rating\\": 4, \\"review_text\\": \\"Good value for money.\\"}, ] print(calculate_review_stats(reviews)) # Output: # { # \\"A1\\": { # \\"average_rating\\": 3.67, # \\"total_reviews\\": 3, # \\"max_rating\\": 5, # \\"min_rating\\": 2, # \\"ratings_summary\\": {1: 0, 2: 1, 3: 0, 4: 1, 5: 1} # }, # \\"A2\\": { # \\"average_rating\\": 3.5, # \\"total_reviews\\": 2, # \\"max_rating\\": 4, # \\"min_rating\\": 3, # \\"ratings_summary\\": {1: 0, 2: 0, 3: 1, 4: 1, 5: 0} # } # } ``` Ensure your implementation is optimized for large datasets and consider edge cases such as missing ratings or duplicate reviews.","solution":"from collections import defaultdict def calculate_review_stats(reviews): Calculate review statistics for each product from a list of reviews. Args: reviews (list[dict]): A list of dictionaries where each dictionary has keys: \'product_id\', \'rating\', and \'review_text\'. Returns: dict: A dictionary where each key is a product ID and the value is another dictionary containing average rating, total reviews, max rating, min rating, and ratings summary. # Initialize default dictionaries to store stats products = defaultdict(lambda: { \\"total_rating\\": 0, \\"total_reviews\\": 0, \\"max_rating\\": 0, \\"min_rating\\": 6, \\"ratings_summary\\": {1: 0, 2: 0, 3: 0, 4: 0, 5: 0} }) # Process each review for review in reviews: product_id = review[\'product_id\'] rating = review[\'rating\'] # Update stats products[product_id][\\"total_rating\\"] += rating products[product_id][\\"total_reviews\\"] += 1 products[product_id][\\"max_rating\\"] = max(products[product_id][\\"max_rating\\"], rating) products[product_id][\\"min_rating\\"] = min(products[product_id][\\"min_rating\\"], rating) products[product_id][\\"ratings_summary\\"][rating] += 1 # Calculate average and final statistics result = {} for product_id, stats in products.items(): result[product_id] = { \\"average_rating\\": round(stats[\\"total_rating\\"] / stats[\\"total_reviews\\"], 2), \\"total_reviews\\": stats[\\"total_reviews\\"], \\"max_rating\\": stats[\\"max_rating\\"], \\"min_rating\\": stats[\\"min_rating\\"], \\"ratings_summary\\": stats[\\"ratings_summary\\"] } return result"},{"question":"# Task Implement a function `sparse_string_matching` to optimize searching for a substring in a large sparse text using a binary search technique. # Scenarios Your function will be essential for processing and searching through large files of sparse text quickly, which is crucial for text analysis and data retrieval tasks. # Input - A list of strings `sparse_text` where empty strings represent gaps in the sparse text document. - A string `search_term` representing the substring you need to find in the `sparse_text`. # Output - An integer representing the index of the first occurrence of `search_term` in `sparse_text`. Return `-1` if `search_term` is not found. # Constraints 1. The `sparse_text` list contains up to `10^6` elements. 2. The length of `search_term` is between 1 and 100 characters. 3. The search should ignore the empty strings. # Requirements - Utilize an enhanced binary search to navigate through the sparse structure efficiently. - Ensure the solution has an optimal time complexity for large inputs. # Hints - Skip over the empty strings while performing the binary search. - Consider adapting the find-first-non-empty approach to locate valid text strings during the search. # Example ```python def sparse_string_matching(sparse_text: list[str], search_term: str) -> int: # Your implementation here pass # Example Test Cases: sparse_text = [\\"\\", \\"\\", \\"\\", \\"this\\", \\"\\", \\"is\\", \\"\\", \\"\\", \\"a\\", \\"simple\\", \\"\\", \\"example\\"] print(sparse_string_matching(sparse_text, \\"simple\\")) # Expected output: 9 (index in sparse_text) sparse_text = [\\"\\", \\"\\", \\"\\", \\"linear\\", \\"\\", \\"\\", \\"search\\", \\"\\"] print(sparse_string_matching(sparse_text, \\"search\\")) # Expected output: 6 (index in sparse_text) sparse_text = [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"] print(sparse_string_matching(sparse_text, \\"text\\")) # Expected output: -1 (search term not found) sparse_text = [\\"\\", \\"\\", \\"find\\", \\"\\", \\"me\\"] print(sparse_string_matching(sparse_text, \\"find\\")) # Expected output: 2 (index in sparse_text) sparse_text = [\\"search\\", \\"\\", \\"\\", \\"in\\", \\"\\", \\"\\", \\"sparse\\", \\"text\\", \\"\\"] print(sparse_string_matching(sparse_text, \\"text\\")) # Expected output: 7 (index in sparse_text) ```","solution":"def sparse_string_matching(sparse_text, search_term): Uses a modified binary search to find the first occurrence of search_term in sparse_text. Skips over empty strings in sparse_text. low, high = 0, len(sparse_text) - 1 while low <= high: mid = (low + high) // 2 # Find the nearest non-empty string to the right left, right = mid, mid while left >= low and sparse_text[left] == \\"\\": left -= 1 while right <= high and sparse_text[right] == \\"\\": right += 1 # Determine the closer non-empty midpoint if left < low and right > high: return -1 # no non-empty strings in range mid = right if left < low or (right <= high and mid - left > right - mid) else left # Perform the comparison to adjust binary search range if sparse_text[mid] == search_term: return mid elif sparse_text[mid] < search_term: low = mid + 1 else: high = mid - 1 return -1"},{"question":"# Task Create a k-Means Clustering model to identify clusters in a given dataset. Implement functionality to initialize centroids, assign clusters, update centroids, and evaluate the model with the Within-Cluster-Sum of Squared Errors (WCSS). # Problem Statement You need to implement the k-Means algorithm from scratch in a class `KMeansClustering`. The k-means algorithm can be summarized in the following steps: 1. Initialize k centroids randomly. 2. Assign each data point to the nearest centroid. 3. Update the centroids as the mean of the assigned points. 4. Repeat steps 2 and 3 until convergence. # Requirements: 1. Implement the `fit` method to perform the iterative clustering process. 2. Implement the `predict` method to assign clusters to new data points based on the fitted model. 3. Implement a `score` method to compute the WCSS. 4. Provide a method to plot the clustered data points and centroids. # Class Signature ```python class KMeansClustering: def __init__(self, n_clusters: int, max_iter: int = 300, tol: float = 1e-4) -> None: # Your code here def fit(self, x_train: np.ndarray) -> None: # Your code here def predict(self, x_test: np.ndarray) -> np.ndarray: # Your code here def score(self, x_test: np.ndarray) -> float: # Your code here def plot(self, x_data: np.ndarray) -> None: # Your code here ``` # Input and Output - `KMeansClustering(n_clusters: int, max_iter: int = 300, tol: float = 1e-4)`: - **n_clusters**: number of clusters (k). - **max_iter**: maximum number of iterations. - **tol**: tolerance for convergence. - Raises ValueError if n_clusters <= 0, max_iter <= 0, or tol <= 0. - `fit(x_train: np.ndarray)`: - **x_train**: data points for clustering. - Initializes centroids, assigns points to clusters, and updates centroids until convergence. - Raises ValueError if x_train is not a two-dimensional numpy array. - `predict(x_test: np.ndarray) -> np.ndarray`: - **x_test**: new unlabelled data points. - Returns an array of cluster labels for each data point in x_test. - Raises ValueError if x_test is not a two-dimensional numpy array. - `score(x_test: np.ndarray) -> float`: - **x_test**: data points to evaluate the clustering. - Returns the WCSS value. - Raises ValueError if x_test is not a two-dimensional numpy array. - `plot(x_data: np.ndarray) -> None`: - **x_data**: data points for plotting. - Plots the data points colored by their cluster along with the centroids. - Raises ValueError if x_data is not a two-dimensional numpy array. # Constraints - The number of clusters should be a positive integer. - Max iterations should be a positive integer. - Tolerance should be a positive float. - Input data for x should be a two-dimensional numpy array. # Performance Requirements - The `fit` method should handle typical dataset sizes efficiently (< 10⁶ data points). - The algorithm should provide reasonable results in terms of clustering quality and computational efficiency. Your job is to implement the classes and methods as described in the inputs and outputs for an effective assessment.","solution":"import numpy as np import matplotlib.pyplot as plt class KMeansClustering: def __init__(self, n_clusters: int, max_iter: int = 300, tol: float = 1e-4) -> None: if n_clusters <= 0 or max_iter <= 0 or tol <= 0: raise ValueError(\\"n_clusters, max_iter and tol should be positive values.\\") self.n_clusters = n_clusters self.max_iter = max_iter self.tol = tol self.centroids = None def fit(self, x_train: np.ndarray) -> None: if not isinstance(x_train, np.ndarray) or len(x_train.shape) != 2: raise ValueError(\\"x_train should be a two-dimensional numpy array.\\") n_samples, _ = x_train.shape random_indices = np.random.choice(n_samples, self.n_clusters, replace=False) self.centroids = x_train[random_indices] for _ in range(self.max_iter): # Assign clusters distances = np.linalg.norm(x_train[:, np.newaxis] - self.centroids, axis=2) labels = np.argmin(distances, axis=1) # Calculate new centroids new_centroids = np.array([x_train[labels == j].mean(axis=0) for j in range(self.n_clusters)]) # Check for convergence if np.all(np.linalg.norm(self.centroids - new_centroids, axis=1) < self.tol): break self.centroids = new_centroids def predict(self, x_test: np.ndarray) -> np.ndarray: if not isinstance(x_test, np.ndarray) or len(x_test.shape) != 2: raise ValueError(\\"x_test should be a two-dimensional numpy array.\\") distances = np.linalg.norm(x_test[:, np.newaxis] - self.centroids, axis=2) return np.argmin(distances, axis=1) def score(self, x_test: np.ndarray) -> float: if not isinstance(x_test, np.ndarray) or len(x_test.shape) != 2: raise ValueError(\\"x_test should be a two-dimensional numpy array.\\") labels = self.predict(x_test) distances = np.linalg.norm(x_test - self.centroids[labels], axis=1) return np.sum(distances ** 2) def plot(self, x_data: np.ndarray) -> None: if not isinstance(x_data, np.ndarray) or len(x_data.shape) != 2: raise ValueError(\\"x_data should be a two-dimensional numpy array.\\") labels = self.predict(x_data) for i in range(self.n_clusters): cluster_points = x_data[labels == i] plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f\\"Cluster {i+1}\\") plt.scatter(self.centroids[:, 0], self.centroids[:, 1], color=\'black\', marker=\'x\', s=100, label=\'Centroids\') plt.legend() plt.show()"},{"question":"# Problem Statement Write a function that parses a given log file containing multiple lines of log entries and extracts the IP addresses that accessed the system. The function should return a list of unique IP addresses in the order they first appeared in the log file. Consider all entries that contain an IP address and filter out any invalid IP addresses. # Function Signature ```python def extract_unique_ips(log: str) -> list[str]: ``` # Input * `log` (str): A string containing multiple lines of log entries. Each entry can include information like timestamps, IP addresses, messages, etc. # Output * Returns a list of unique IP addresses (as strings) in the order they first appeared in the log. # Constraints * Log file contains up to `10^6` lines. * Each log entry is at most `200` characters long. * Each IP address follows the standard IPv4 format: `xxx.xxx.xxx.xxx` where `xxx` is a number between 0 and 255, inclusive. # Example ```python log_data = 2023-03-15 10:15:42 INFO - Connection from 192.168.1.1 2023-03-15 10:15:43 WARNING - Failed login attempt from 10.0.0.1 2023-03-15 10:15:44 INFO - Connection from 192.168.1.1 2023-03-15 10:16:00 ERROR - Connection timeout from 10.0.0.2 2023-03-15 10:16:30 INFO - Connection from 8.8.8.8 print(extract_unique_ips(log_data)) # Output: [\'192.168.1.1\', \'10.0.0.1\', \'10.0.0.2\', \'8.8.8.8\'] ``` # Notes 1. Use regular expressions to identify and validate IP addresses within log entries. 2. The order of the output list should strictly follow the order of first occurrence of each unique IP address in the log. 3. Consider edge cases where log entries do not contain valid IP addresses or have malformed lines.","solution":"import re def extract_unique_ips(log: str) -> list[str]: Extracts unique IP addresses from the log and returns them in the order they first appeared. ip_pattern = re.compile(r\'b(?:[0-9]{1,3}.){3}[0-9]{1,3}b\') unique_ips = [] seen_ips = set() for line in log.splitlines(): for ip in ip_pattern.findall(line): if ip not in seen_ips and valid_ip(ip): seen_ips.add(ip) unique_ips.append(ip) return unique_ips def valid_ip(ip: str) -> bool: Validates if a given IP address is a valid IPv4 address. parts = ip.split(\'.\') for part in parts: if not 0 <= int(part) <= 255: return False return True"},{"question":"Graph Data Structure Traversal with Depth-Limiting **Objective**: Implement a depth-limited search algorithm for traversing a graph data structure. # Problem Statement You are given an undirected graph represented by adjacency lists. Your task is to modify the depth-first search (DFS) algorithm to include a depth limit, effectively making it a Depth-Limited Search (DLS). This means the search will only explore nodes up to a given depth. # Expected Input and Output * **Input**: - A list of vertices and edges representing the graph. - A starting vertex for the traversal. - A depth limit which restricts the depth to which the search can go. * **Output**: - A list of vertices visited during the depth-limited search ordered by the sequence in which they were visited. # Constraints 1. The number of vertices (V) will be such that (1 leq V leq 10^3). 2. The graph can contain up to (10^4) edges. 3. The starting vertex and depth limit will be within the bounds of the graph. 4. The graph does not contain any cycles. # Function Definition Implement the following function: ```python def depth_limited_search(graph: Dict[int, List[int]], start_vertex: int, depth_limit: int) -> List[int]: Conducts a Depth-Limited Search (DLS) on a graph from a start vertex up to the specified depth limit. :param graph: Dictionary where keys are vertices and values are lists of adjacent vertices. :param start_vertex: The vertex from which to start the search. :param depth_limit: Maximum depth to which the search can proceed. :return: List of vertices visited during the search. pass ``` # Example Usage Consider the graph represented by the following adjacency list: ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5, 6], 3: [1], 4: [1], 5: [2], 6: [2] } ``` If the starting vertex is `0` and the depth limit is `2`, the function should output: ```python depth_limited_search(graph, 0, 2) # expected output: [0, 1, 2, 3, 4, 5, 6] ``` This is because it explores nodes up to depth 2 from the starting vertex `0`. # Implementation Details * Initialize a stack to manage the current path and depth of each vertex. * Use a set to keep track of visited nodes to avoid processing the same node multiple times. * At each step, push adjacent vertices onto the stack if they have not been visited and the depth limit has not been reached. * Ensure that the search respects the depth limit by stopping the exploration from a node if the current path depth exceeds the limit.","solution":"def depth_limited_search(graph, start_vertex, depth_limit): Conducts a Depth-Limited Search (DLS) on a graph from a start vertex up to the specified depth limit. :param graph: Dictionary where keys are vertices and values are lists of adjacent vertices. :param start_vertex: The vertex from which to start the search. :param depth_limit: Maximum depth to which the search can proceed. :return: List of vertices visited during the search. visited = set() result = [] def dls(vertex, depth): if depth > depth_limit or vertex in visited: return visited.add(vertex) result.append(vertex) if depth < depth_limit: for neighbor in graph[vertex]: if neighbor not in visited: dls(neighbor, depth + 1) dls(start_vertex, 0) return result"},{"question":"# Shortest Path in Weighted Graph with Dijkstra\'s Algorithm Problem Statement You are given a weighted, directed graph represented as an adjacency list. Your task is to implement the Dijkstra\'s Algorithm to find the shortest path from a given source node to all other nodes in the graph. Requirements 1. **Class**: `Graph` - Implements the following method: 2. **Method**: - `shortest_paths_from_source(source: int) -> List[int]`: Returns a list of shortest path distances from the `source` node to all other nodes. If a node is unreachable, the distance should be represented as `float(\'inf\')`. Input Format - The `Graph` instance is initialized with an integer representing the number of nodes and a list of tuples representing the edges and weights in the graph. ```python Graph(num_nodes: int, edges: List[Tuple[int, int, int]]) ``` where each tuple is `(u, v, w)` meaning there\'s an edge from node `u` to node `v` with weight `w`. - Call to the method `shortest_paths_from_source(source)` with the source node index. Output Format - A list of shortest path distances from the `source` node to all other nodes. Constraints - Number of nodes (V) and the number of edges (E) will be at most (10^4). - Edge weights will be non-negative integers. Performance Requirements - The algorithm should have a time complexity of (O((V + E) log V)). Example ```python # Creating a graph with 5 nodes and edges with weights edges = [ (0, 1, 3), (0, 2, 1), (1, 2, 7), (1, 3, 5), (2, 3, 2), (3, 4, 7), ] graph = Graph(5, edges) # Finding shortest paths from node 0 print(graph.shortest_paths_from_source(0)) # Outputs: [0, 3, 1, 3, 10] # Finding shortest paths from node 2 print(graph.shortest_paths_from_source(2)) # Outputs: [float(\'inf\'), float(\'inf\'), 0, 2, 9] ``` Signature ```python def shortest_paths_from_source(self, source: int) -> List[int]: # Your code here ```","solution":"import heapq from typing import List, Tuple class Graph: def __init__(self, num_nodes: int, edges: List[Tuple[int, int, int]]): self.num_nodes = num_nodes # Initialize adjacency list self.adj_list = [[] for _ in range(num_nodes)] for u, v, w in edges: self.adj_list[u].append((v, w)) def shortest_paths_from_source(self, source: int) -> List[int]: # Distance from source to each node, initialized to infinity distances = [float(\'inf\')] * self.num_nodes distances[source] = 0 # Min-heap priority queue priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the distance to the current node is larger than the known distance, skip processing if current_distance > distances[current_node]: continue # Process each neighbor of the current node for neighbor, weight in self.adj_list[current_node]: distance = current_distance + weight # If a shorter path to the neighbor is found if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"You are required to enhance the class `DataProcessor` to allow it to handle additional functionality and improve performance. The original class processes a list of numbers, computes various statistics (sum, average, standard deviation), and has basic error handling. Objective Refactor the `DataProcessor` class to: 1. Extend its capabilities to process data efficiently with larger datasets. 2. Implement additional statistical methods like median, mode, and variance. 3. Include comprehensive error handling to manage invalid inputs and edge cases properly. Requirements - **Input**: - `data`: A list of numbers to be processed. - **Output**: - The various statistical calculations (sum, average, standard deviation, median, mode, and variance). - **Constraints**: - Ensure the class can handle lists with up to 10 million numbers efficiently. - Utilize optimal algorithms for computing statistics to minimize time complexity. - **Methods to Implement**: - `compute_sum`: Returns the sum of the data. - `compute_average`: Returns the average of the data. - `compute_std_dev`: Returns the standard deviation of the data. - `compute_median`: Returns the median of the data. - `compute_mode`: Returns the mode of the data. - `compute_variance`: Returns the variance of the data. Performance Requirements - Efficiently process large datasets without excessive memory utilization. - Ensure minimal computational overhead while performing statistical operations. Edge Cases & Error Handling - Handle empty lists and provide appropriate responses. - Manage lists with non-numeric values gracefully and throw meaningful exceptions. - Handle scenarios where multiple modes exist. # Scenario You are developing a data analysis module that should be robust and efficient for processing large datasets. The aim is to ensure accurate statistical analysis and reliable performance under high data volume conditions. Class Signature ```python class DataProcessor: def __init__(self, data: list): self.data = data def compute_sum(self) -> float: # Your improved implementation here def compute_average(self) -> float: # Your improved implementation here def compute_std_dev(self) -> float: # Your improved implementation here def compute_median(self) -> float: # Your improved implementation here def compute_mode(self) -> float: # Your improved implementation here def compute_variance(self) -> float: # Your improved implementation here ``` Example Given the input list: `[1, 2, 2, 3, 4]` ```python processor = DataProcessor([1, 2, 2, 3, 4]) sum_value = processor.compute_sum() # Output: 12 average_value = processor.compute_average() # Output: 2.4 std_dev_value = processor.compute_std_dev() # Output: 1.14 (approximately) median_value = processor.compute_median() # Output: 2 mode_value = processor.compute_mode() # Output: 2 variance_value = processor.compute_variance() # Output: 1.3 (approximately) ```","solution":"import math import statistics from collections import Counter class DataProcessor: def __init__(self, data: list): if not all(isinstance(x, (int, float)) for x in data): raise ValueError(\\"All elements must be numeric.\\") if not data: raise ValueError(\\"Data list cannot be empty.\\") self.data = data def compute_sum(self) -> float: return sum(self.data) def compute_average(self) -> float: return statistics.mean(self.data) def compute_std_dev(self) -> float: return statistics.stdev(self.data) def compute_median(self) -> float: return statistics.median(self.data) def compute_mode(self) -> float: mode_data = Counter(self.data) modes = [k for k, v in mode_data.items() if v == max(mode_data.values())] if len(modes) > 1: raise ValueError(\\"Multiple modes found.\\") return modes[0] def compute_variance(self) -> float: return statistics.variance(self.data)"},{"question":"# Problem Statement Write a function `next_largest_permutation(arr)` that takes a list of integers and rearranges them into the lexicographically next greater permutation. If such an arrangement is not possible, it must rearrange it as the lowest possible order (sorted in ascending order). The replacement must be done in-place and use only constant extra memory. # Function Signature ```python def next_largest_permutation(arr: List[int]) -> None: ``` # Input - `arr`: A list of integers with length between `1` and `1000`. # Output - This is an in-place function; it does not need to return anything. # Constraints - The elements of the array will be in the range `0 <= arr[i] <= 10000`. # Example ```python arr = [1, 2, 3] next_largest_permutation(arr) print(arr) # Outputs: [1, 3, 2] arr = [3, 2, 1] next_largest_permutation(arr) print(arr) # Outputs: [1, 2, 3] arr = [1, 1, 5] next_largest_permutation(arr) print(arr) # Outputs: [1, 5, 1] ``` # Execution Requirements - Ensure that the function operates correctly within the constraints. - The solution should be optimized for both time and space as described. # Scenario Imagine you are working on a software for generating unique product IDs by permuting digits of a given number. The challenge is to generate the next identifier in a sequence without any significant computation delays, ensuring that the operation is performed in-place to manage memory efficiently. # Notes - Handle edge cases gracefully, such as when the array is already in descending order or contains repeated numbers. - Consider scenarios where the length of the array is the smallest possible (one element), to ensure robust performance.","solution":"from typing import List def next_largest_permutation(arr: List[int]) -> None: Ruarranges the array into the lexicographically next greater permutation. If such an arrangement is not possible, it must rearrange it as the lowest possible order (sorted in ascending order). The replacement must be done in-place. # Find the first element that is smaller than the one next to it, from the end of the list i = len(arr) - 2 while i >= 0 and arr[i] >= arr[i + 1]: i -= 1 if i >= 0: # Find the first element that is greater than arr[i] from the end of the list j = len(arr) - 1 while arr[j] <= arr[i]: j -= 1 # Swap the elements at i and j arr[i], arr[j] = arr[j], arr[i] # Reverse the elements from i+1 to the end of the list arr[i + 1:] = reversed(arr[i + 1:])"},{"question":"# Coding Assessment Question Context Data caching is a common optimization technique where frequently accessed data is stored temporarily to reduce retrieval time. One popular caching mechanism is a Least Recently Used (LRU) cache. The LRU cache discards the least recently used items first when it reaches its capacity limit. Task You are required to implement a simple LRU cache by defining the `LRUCache` class with the following methods: 1. **Class Name**: `LRUCache` - **Attributes**: - `capacity` (int): The maximum number of items the cache can hold. - `cache` (OrderedDict): An ordered dictionary to store cache items in the order they were accessed. 2. **Method Name**: `__init__` - **Input**: An integer (`capacity`) representing the maximum capacity of the cache. - **Output**: No output. This is the initializer method that sets up the LRU cache. 3. **Method Name**: `get` - **Input**: An integer (`key`) representing the key of the cache item to retrieve. - **Output**: Returns the value associated with the key if it exists; otherwise, returns `-1`. - **Operation**: Move the accessed item to the end of the ordered dictionary to mark it as recently used. 4. **Method Name**: `put` - **Input**: An integer (`key`) and an associated integer (`value`) to add to the cache. - **Output**: No output. - **Operation**: Add the key-value pair to the cache. If the key already exists, update its value and mark it as recently used. If adding the new item exceeds the cache\'s capacity, remove the least recently used item. Constraints * The number of operations (`N`) will be in the range `[1, 10^4]`. * The capacity (`capacity`) will be in the range `[1, 10^4]`. * The values for `key` and `value` will be non-negative integers. Examples ```python # Example Usage cache = LRUCache(2) # Adding items to the cache cache.put(1, 1) cache.put(2, 2) # Retrieving items assert cache.get(1) == 1 # Returns 1 assert cache.get(3) == -1 # Returns -1 (not found) # Adding another item (exceeds capacity) cache.put(3, 3) # Removes key 2, as it was the least recently used assert cache.get(2) == -1 # Returns -1 (not found) # Recently used items updated cache.put(4, 4) # Removes key 1 assert cache.get(1) == -1 # Returns -1 (not found) assert cache.get(3) == 3 # Returns 3 assert cache.get(4) == 4 # Returns 4 ``` Ensure to implement the class and methods correctly taking into account the cache capacity, error handling, and efficiency.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 value = self.cache.pop(key) self.cache[key] = value # mark as recently used return value def put(self, key: int, value: int): if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # remove least recently used item self.cache[key] = value # add new item as most recently used"},{"question":"# Unique Elements in List You are given a class `UniqueElementsList` that operates on a list of integers. The class should support the following operations: 1. **add(item)**: Adds an `item` to the list. If the `item` already exists in the list, it should not add it again. 2. **remove(item)**: Removes the `item` from the list if it exists. If the `item` does not exist, it should raise an `IndexError` with the message \\"Item not found\\". 3. **get_unique_elements()**: Retrieves a list of all unique elements in the list. 4. **contains(item)**: Checks if the `item` exists in the list. # Specification Method Signature ```python def add(self, item: int) -> None def remove(self, item: int) -> None def get_unique_elements(self) -> list[int] def contains(self, item: int) -> bool ``` Input * `add(item)` takes an integer `item` to be added to the list. * `remove(item)` takes an integer `item` to be removed from the list. Output * `add()` returns None and adds the `item` to the list. * `remove()` returns None and removes the `item` from the list; raises `IndexError` if the `item` is not found. * `get_unique_elements()` returns a list of all unique elements currently in the list. * `contains()` returns a boolean indicating if the `item` exists in the list. Constraints * The list should not contain duplicate elements. * Your implementation should be efficient and should maintain unique elements only. * Attempting to remove an item that does not exist should raise an `IndexError` with an appropriate message. Example: ```python u = UniqueElementsList() u.add(1) u.add(2) u.add(2) assert u.get_unique_elements() == [1, 2] # [1, 2] u.remove(1) assert u.get_unique_elements() == [2] # [2] assert u.contains(2) == True # True assert u.contains(1) == False # False try: u.remove(1) except IndexError as e: assert str(e) == \\"Item not found\\" ```","solution":"class UniqueElementsList: def __init__(self): self.items = set() def add(self, item: int) -> None: Adds the item to the list if it is not already present. self.items.add(item) def remove(self, item: int) -> None: Removes the item from the list if it is present; otherwise, raises an IndexError. if item in self.items: self.items.remove(item) else: raise IndexError(\\"Item not found\\") def get_unique_elements(self) -> list[int]: Returns a list of all unique elements currently in the set. return list(self.items) def contains(self, item: int) -> bool: Checks if the item exists in the list. return item in self.items"},{"question":"# Prime Number Identifier **Problem Statement**: You need to create a function `is_prime(n)` that determines whether a given number n is a prime number. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. For example, 5 is prime because its only divisors are 1 and 5. **Requirements**: 1. Implement the `is_prime(n)` function with the following specifications: - The function should take one parameter `n`, an integer. - It should return `True` if `n` is a prime number. - It should return `False` otherwise. 2. Optimize the function to handle input values efficiently, considering the upper limit for `n`. **Input Format**: - A single integer, `n`. **Output Format**: - The output should be a boolean value: `True` if the number is prime, `False` otherwise. **Constraints**: - The input integer `n` will be between 1 and 1000000 inclusive. **Example**: ```python >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(100) False ``` **Notes**: - Consider edge cases, such as the smallest prime number and larger numbers near the upper limit. - Ensure that your implementation is efficient, particularly for larger values of `n`. # Solution Outline: 1. Check if `n` is less than or equal to 1, return `False` (since prime numbers are greater than 1). 2. Check if `n` is 2 or 3, return `True` (2 and 3 are prime numbers). 3. Check if `n` is divisible by 2 or 3, return ‘False’ (since they would be composite if divisible by these). 4. Use a loop to check for factors up to the square root of `n`, incrementing by 6 each iteration to skip even numbers and multiples of 3 for optimization.","solution":"def is_prime(n): Determines if the given number n is a prime number. :param n: int - The number to check for primality. :return: bool - True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Problem Statement You are tasked with implementing a simple text-based card game where a player tries to guess whether the next card in a deck will be higher or lower than the current card. # Requirements 1. **Deck Initialization**: Initialize a standard 52-card deck. 2. **Card Display**: Display the current card to the player. 3. **Player Guess**: Allow the player to guess whether the next card will be higher or lower. 4. **Card Comparison**: Draw the next card and compare it with the current card to determine if the player\'s guess was correct. 5. **Game Continuation**: The game continues until the deck is empty or until the player decides to stop playing. 6. **Score Tracking**: Keep track of the player\'s score based on correct guesses. # Input/Output - **Input**: Player\'s guess for higher or lower (\'h\' or \'l\') and whether to continue playing (\'y\' or \'n\'). - **Output**: Display the current card, the result of the guess, and the player\'s score. # Constraints 1. Each card is represented by its rank and suit (e.g., \\"7 of Hearts\\", \\"Ace of Spades\\"). 2. The rank order from lowest to highest is: 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace. 3. Enforce proper validation checks to ensure player inputs are valid. 4. Ensure randomness in card drawing from the deck. # Function Signature ```python def play_high_low_game() -> None: pass ``` # Example ```python Current card: 7 of Hearts Will the next card be higher or lower? (h/l): h Next card: Jack of Clubs Your guess was correct! Current score: 1 Would you like to continue playing? (y/n): y ``` In this example, the current card is \\"7 of Hearts\\". The player guesses that the next card will be higher (\'h\'). The drawn card is \\"Jack of Clubs\\", so the guess is correct, and the player\'s score increases by 1. # Implementation Details 1. Create a function to initialize and shuffle the deck. 2. Create a function to handle player input and validate guesses. 3. Create a function to draw a card from the deck. 4. Implement the main game loop to manage the game state, including displaying cards, handling player guesses, and updating the score. 5. Make sure to handle edge cases, such as when the deck is empty or invalid input from the player.","solution":"import random # Initialize rank and suits RANKS = [\'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\', \'10\', \'Jack\', \'Queen\', \'King\', \'Ace\'] SUITS = [\'Hearts\', \'Diamonds\', \'Clubs\', \'Spades\'] def initialize_deck(): Initialize and return a shuffled 52-card deck. deck = [{\'rank\': rank, \'suit\': suit} for suit in SUITS for rank in RANKS] random.shuffle(deck) return deck def card_value(card): Return the value of a card for comparison. return RANKS.index(card[\'rank\']) def display_card(card): Return a string representation of a card. return f\\"{card[\'rank\']} of {card[\'suit\']}\\" def play_high_low_game(): Main function to play the High-Low card game. deck = initialize_deck() score = 0 # Draw the first card current_card = deck.pop() while True: print(f\\"Current card: {display_card(current_card)}\\") # Get player guess guess = input(\\"Will the next card be higher or lower? (h/l): \\").strip().lower() while guess not in [\'h\', \'l\']: print(\\"Invalid input. Please enter \'h\' for higher or \'l\' for lower.\\") guess = input(\\"Will the next card be higher or lower? (h/l): \\").strip().lower() # Draw the next card if not deck: print(\\"The deck is empty. The game is over.\\") break next_card = deck.pop() print(f\\"Next card: {display_card(next_card)}\\") # Compare cards if (guess == \'h\' and card_value(next_card) > card_value(current_card)) or (guess == \'l\' and card_value(next_card) < card_value(current_card)): print(\\"Your guess was correct!\\") score += 1 else: print(\\"Your guess was incorrect.\\") print(f\\"Current score: {score}\\") # Check if player wants to continue continue_playing = input(\\"Would you like to continue playing? (y/n): \\").strip().lower() while continue_playing not in [\'y\', \'n\']: print(\\"Invalid input. Please enter \'y\' to continue or \'n\' to stop.\\") continue_playing = input(\\"Would you like to continue playing? (y/n): \\").strip().lower() if continue_playing == \'n\': break current_card = next_card print(f\\"Final score: {score}\\")"},{"question":"# Coding Assessment Question: Write a function `max_subarray_sum(arr: List[int]) -> int` that takes a list of integers `arr` and returns the maximum sum of any contiguous subarray within the list. **Function Signature** ```python def max_subarray_sum(arr: List[int]) -> int: pass ``` **Input** - `arr`: A list of integers `arr` (1 ≤ len(arr) ≤ 10^5, -10^4 ≤ arr[i] ≤ 10^4). **Output** - An integer representing the maximum sum of any contiguous subarray. **Example** ```python assert max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9 assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum([-1, -2, -3, -4]) == -1 ``` **Constraints and Conditions** - The function should be efficient enough to handle the upper limit of array lengths. - Make sure to handle edge cases such as an array consisting entirely of negative numbers. - Consider an optimized solution, such as using Kadane\'s algorithm, to achieve optimal performance. **Performance Considerations** - Aim for a solution with a time complexity of O(n), where n is the length of the array, to ensure it handles the maximum size efficiently. **Scenario** You are tasked with developing a key component for a financial application that needs to analyze profit and loss data quickly. Your function will be used to determine the most profitable period within a dataset of daily returns, thus requiring both speed and accuracy in handling potentially large inputs.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Function to calculate the maximum sum of any contiguous subarray. Uses Kadane\'s algorithm for optimal performance. Parameters: arr (List[int]): A list of integers. Returns: int: The maximum sum of any contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Assessment Question **Background**: String manipulation is a fundamental concept in programming that involves modifying, parsing, or editing string data. One common task is to reverse the words in a string while maintaining the relative order of the words. **Task**: Write a function `reverse_words` in Python that accepts a string and returns a new string with the words reversed. The words in the input string will be delimited by spaces, and the returned string should preserve the original spacing between words. # Requirements: 1. **Function Signature**: ```python def reverse_words(sentence: str) -> str: ``` 2. **Input**: - `sentence` (str): A sentence containing words separated by spaces. 3. **Output**: - `str`: A string with the words in reverse order. 4. **Constraints**: - The input string will contain only uppercase and lowercase English letters and spaces. - The input string will contain at least one word and no leading or trailing spaces. 5. **Performance**: - The solution should have a time complexity of O(n) and space complexity of O(n), where `n` is the length of the input string. # Example: ```python print(reverse_words(\\"Hello world\\")) # Expected output: \\"world Hello\\" print(reverse_words(\\"The quick brown fox\\")) # Expected output: \\"fox brown quick The\\" print(reverse_words(\\"A B C D\\")) # Expected output: \\"D C B A\\" ``` # Notes: - Ensure your function efficiently handles the reversal of words without reversing individual characters. - Write additional test cases to validate edge cases, such as strings with multiple spaces between words. --- The provided question adheres to the guidelines and matches the style, complexity, and scope of the initial set. It requires fundamental string manipulation skills in Python, involving operations that are both accessible yet demanding, ensuring it complements the existing questions in a cohesive manner.","solution":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence while maintaining the original spaces. Parameters: sentence (str): A string containing words separated by spaces. Returns: str: A string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Problem Statement Design a function `sort_squares` that receives a sorted list of integers (which may be both negative and positive), squares each number, and returns a sorted list of the squares. # Function Signature ```python def sort_squares(lst: list[int]) -> list[int]: pass ``` # Input * `lst`: A sorted list of integers where 1 <= len(lst) <= 10^5. # Output * Return a list of integers that are the squares of the input integers, sorted in non-decreasing order. # Constraints * The input list is sorted in non-decreasing order. * Your implementation should have O(n) time complexity. # Example ```python assert sort_squares([-4, -2, 0, 3, 5]) == [0, 4, 9, 16, 25] assert sort_squares([-9, -7, -5, -3, -1]) == [1, 9, 25, 49, 81] assert sort_squares([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25] assert sort_squares([-10, -3, 0, 2, 7]) == [0, 4, 9, 49, 100] assert sort_squares([0, 1, 2]) == [0, 1, 4] ``` # Notes * Think about efficient ways to handle both the negative and positive segments of the list. * Consider edge cases such as an empty list or a list with a single element. * The solution should utilize the properties of the input being a sorted list to achieve optimal performance. --- This problem assesses algorithmic skill in managing sorted data and leveraging its properties to perform operations efficiently, much like the QuickSelect algorithm in your other provided problem. The complexity and length are consistent with your current set, making it a seamless addition.","solution":"def sort_squares(lst: list[int]) -> list[int]: Returns a sorted list of the squares of the input sorted integers. n = len(lst) # Initialize pointers to both ends of the list left, right = 0, n - 1 result = [0] * n result_index = n - 1 while left <= right: left_square = lst[left] ** 2 right_square = lst[right] ** 2 if left_square > right_square: result[result_index] = left_square left += 1 else: result[result_index] = right_square right -= 1 result_index -= 1 return result"},{"question":"# Problem Statement You are tasked with implementing a function that parses, validates, and converts a given string representing a time in 12-hour format into a 24-hour format. The function should handle different components of the time string and ensure correct conversion. # Function Signature ```python def convert_to_24_hour_format(time_12hr: str) -> str: Convert the given 12-hour formatted time string to a 24-hour formatted time string. Parameters: time_12hr (str): A string representing the time in 12-hour format with an \'AM\' or \'PM\' suffix. Returns: str: The converted time in 24-hour format. pass ``` # Input - **time_12hr**: A string representing the time in 12-hour format (hh:mm:ssAM or hh:mm:ssPM). The input string will be well-formed and always include an \'AM\' or \'PM\' suffix. # Output - A string representing the converted time in 24-hour format (HH:MM:SS). # Example ```python # Example 1 time_12hr = \\"07:05:45PM\\" # Conversion to 24-hour format converted_time = convert_to_24_hour_format(time_12hr) print(converted_time) # Expected output: \\"19:05:45\\" # Example 2 time_12hr = \\"12:00:00AM\\" # Conversion to 24-hour format converted_time = convert_to_24_hour_format(time_12hr) print(converted_time) # Expected output: \\"00:00:00\\" ``` # Constraints - The input string will always be in a valid 12-hour time format, including leading zeros where needed. - Ensure that the function correctly handles edge cases, such as \\"12:00:00AM\\" which should convert to \\"00:00:00\\" and \\"12:00:00PM\\" to \\"12:00:00\\". - Be mindful of the conversion rules: - \\"12:xx:xxAM\\" should map to \\"00:xx:xx\\" - \\"12:xx:xxPM\\" remains as \\"12:xx:xx\\" - \\"hh:xx:xxAM\\" where hh ranges from 01 to 11 remains unchanged - \\"hh:xx:xxPM\\" where hh ranges from 01 to 11 should add 12 hours This question assesses your understanding of string manipulation and time format conversions.","solution":"def convert_to_24_hour_format(time_12hr: str) -> str: Convert the given 12-hour formatted time string to a 24-hour formatted time string. Parameters: time_12hr (str): A string representing the time in 12-hour format with an \'AM\' or \'PM\' suffix. Returns: str: The converted time in 24-hour format. period = time_12hr[-2:].upper() hour, minute, second = map(int, time_12hr[:-2].split(\':\')) if period == \'AM\': if hour == 12: hour = 0 # Midnight case (e.g., 12:00:00AM -> 00:00:00) else: # period == \'PM\' if hour != 12: hour += 12 # Add 12 to hour (e.g., 1PM -> 13) return f\\"{hour:02}:{minute:02}:{second:02}\\""},{"question":"# Question: Implement a Custom Sorting Algorithm with Stability Context You are tasked with implementing a custom sorting function that maintains the stability property (i.e., equal elements retain their relative order). The sort should be based on a primary and secondary condition, ensuring the output is a stable sorted list. Task 1. Implement a function `stable_custom_sort(arr: List[Tuple[int, str]]) -> List[Tuple[int, str]]` that: - Takes a list of tuples `arr` containing integer and string pairs. - Returns a list of tuples sorted primarily by the integer value in ascending order, and secondarily by the string value in ascending order for equal integer values. 2. Ensure the custom sorting function is stable. Implementation Constraints - Utilize efficient sorting algorithms (e.g., merge sort, Timsort) that guarantee stability. - Preserve the original order of elements where both primary and secondary conditions are equivalent. - Target a time complexity of O(n log n), where n is the number of tuples in the list. Input and Output - **Input**: A list of tuples `arr`, where each tuple consists of an integer and a string. - **Output**: A list of tuples sorted according to the specified conditions. Examples ```python assert stable_custom_sort([(3, \\"apple\\"), (1, \\"banana\\"), (2, \\"cherry\\"), (1, \\"apple\\")]) == [(1, \\"apple\\"), (1, \\"banana\\"), (2, \\"cherry\\"), (3, \\"apple\\")] assert stable_custom_sort([(1, \\"beta\\"), (2, \\"alpha\\"), (2, \\"beta\\"), (1, \\"alpha\\")]) == [(1, \\"alpha\\"), (1, \\"beta\\"), (2, \\"alpha\\"), (2, \\"beta\\")] assert stable_custom_sort([(5, \\"one\\"), (3, \\"three\\"), (3, \\"six\\"), (4, \\"two\\")]) == [(3, \\"six\\"), (3, \\"three\\"), (4, \\"two\\"), (5, \\"one\\")] assert stable_custom_sort([(4, \\"apple\\"), (4, \\"banana\\"), (4, \\"apple\\"), (3, \\"cherry\\")]) == [(3, \\"cherry\\"), (4, \\"apple\\"), (4, \\"apple\\"), (4, \\"banana\\")] # Edge case assert stable_custom_sort([]) == [] ``` Notes 1. Consider implementing a custom comparison function if required to ensure stability. 2. Test cases include both typical and edge scenarios to validate the correctness and stability of your implementation. 3. The solution should not use Python\'s built-in sorting functions initially but rather demonstrate the custom sorting logic explicitly.","solution":"from typing import List, Tuple def stable_custom_sort(arr: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sort the given list of tuples primarily by the integer value in ascending order, and secondarily by the string value in ascending order for equal integer values. This sorting is stable and maintains the original relative order for equal elements. # Implementing a stable sort using the built-in sort with key and lambda function # Note: Python\'s built-in sort is Timsort which is stable. return sorted(arr, key=lambda x: (x[0], x[1]))"},{"question":"# Problem Statement You need to design an algorithm to find the shortest path between two nodes in an unweighted graph. The graph is represented as an adjacency list, and you are given the starting node and the target node. Implement a function `shortest_path(graph, start, end)` that returns the shortest path as a list of nodes from the start node to the end node. If no path exists, return an empty list. # Function Signature ```python def shortest_path(graph: dict, start: str, end: str) -> list: pass ``` # Input * `graph` (dict): A dictionary representing the graph where the keys are node identifiers and the values are lists of adjacent nodes. * `start` (str): The starting node identifier. * `end` (str): The target node identifier. # Output * Returns a list of node identifiers representing the shortest path from `start` to `end`. If no path is found, returns an empty list. # Constraints * All node identifiers are strings. * The graph nodes and edges are provided such that there are no duplicate edges and no self-loops. * The graph can contain any number of nodes, and it is guaranteed that both `start` and `end` are present in the graph. # Example ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\", \\"E\\"], \\"C\\": [\\"A\\", \\"F\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"B\\", \\"F\\"], \\"F\\": [\\"C\\", \\"E\\"] } shortest_path(graph, \\"A\\", \\"F\\") == [\\"A\\", \\"C\\", \\"F\\"] shortest_path(graph, \\"A\\", \\"D\\") == [\\"A\\", \\"B\\", \\"D\\"] shortest_path(graph, \\"C\\", \\"D\\") == [] ``` # Additional Notes * You can assume that the input graph is always connected for the purposes of this task. * The algorithm should handle typical adjacency list graph representations and find the shortest path efficiently. # Algorithm 1. Use a Breadth-First Search (BFS) to explore the shortest path in an unweighted graph. 2. Use a queue to explore nodes level by level. 3. Keep track of visited nodes to avoid cycles. 4. Use a dictionary to record paths leading to each node. 5. Backtrack from the target node to construct the path if the target is reached. 6. If the target node is found, reconstruct the path from start to end. 7. If the BFS completes without finding the target, return an empty list. # Edge Cases * Ensure the algorithm returns correctly when the start and end nodes are the same. * Ensure the algorithm handles cases when no path exists gracefully.","solution":"from collections import deque def shortest_path(graph, start, end): if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return path + [end] queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Coding Question: String Manipulation and Palindromic Substrings Problem Statement You are given a string `s`, and your task is to implement a function that returns the number of palindromic substrings in the string. A substring is considered palindromic if it reads the same forwards and backwards. Requirements 1. **Count Palindromic Substrings**: - Implement the `count_palindromic_substrings` method which takes a single string `s` as input and returns an integer representing the number of palindromic substrings found in `s`. Method Signature - `def count_palindromic_substrings(s: str) -> int` Input and Output Formats - **Input**: A single string `s` consisting of lower-case English letters. - **Output**: An integer representing the number of palindromic substrings in the input string. Constraints - The length of the string `s` will be between 1 and 1,000. Example - For `count_palindromic_substrings(\\"abc\\")`, the output is `3` because the palindromic substrings are: \\"a\\", \\"b\\", \\"c\\". - For `count_palindromic_substrings(\\"aaa\\")`, the output is `6` because the palindromic substrings are: \\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aaa\\". - For `count_palindromic_substrings(\\"racecar\\")`, the output is `10` because the palindromic substrings are: \\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"c\\", \\"a\\", \\"r\\", \\"cec\\", \\"aceca\\", \\"racecar\\". Implementation ```python def count_palindromic_substrings(s: str) -> int: n = len(s) count = 0 def expand_around_center(left: int, right: int) -> None: nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd-length palindromes expand_around_center(i, i) # Even-length palindromes expand_around_center(i, i + 1) return count # Example of how to use: print(count_palindromic_substrings(\\"abc\\")) # Output: 3 print(count_palindromic_substrings(\\"aaa\\")) # Output: 6 print(count_palindromic_substrings(\\"racecar\\")) # Output: 10 ``` By examining the problem requirements, constraints, and the general structure of the existing question, this new problem seamlessly integrates with the given set in terms of style, complexity, scope, and technical requirements.","solution":"def count_palindromic_substrings(s: str) -> int: n = len(s) count = 0 def expand_around_center(left: int, right: int) -> None: nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd-length palindromes expand_around_center(i, i) # Even-length palindromes expand_around_center(i, i + 1) return count"},{"question":"# Coding Assessment Question Scenario You are developing a contact management application that needs to format phone numbers into a specific standardized format. The format required is `\\"(XXX) XXX-XXXX\\"`, where `X` is a digit from 0 to 9. Task Write a function `format_phone_number` that takes an array of 10 integers (0-9) representing a phone number and returns a string formatted as \\"(XXX) XXX-XXXX\\". Function Signature ```python def format_phone_number(numbers: list[int]) -> str: ``` Input * `numbers`: A list of 10 integers, each in the range 0 to 9, representing a phone number. Output * A string that represents the phone number formatted in the pattern \\"(XXX) XXX-XXXX\\". Constraints * The input list will always contain exactly 10 integers. * Each integer in the list will always be within the range 0 to 9. Examples ```python >>> format_phone_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) \\"(123) 456-7890\\" >>> format_phone_number([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) \\"(987) 654-3210\\" ``` Explanation of Examples * For `format_phone_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])`, the function arranges the digits into the format \\"(123) 456-7890\\". * For `format_phone_number([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])`, the function arranges the digits into the format \\"(987) 654-3210\\". Performance Requirements * The function should execute in linear time O(n), where n is the number of digits in the input list (in this case, n=10).","solution":"def format_phone_number(numbers): Formats a list of 10 integers into a phone number string in the format \\"(XXX) XXX-XXXX\\". if len(numbers) != 10: raise ValueError(\\"Input list must contain exactly 10 digits.\\") for num in numbers: if not isinstance(num, int) or not (0 <= num <= 9): raise ValueError(\\"All elements in input list must be integers in the range 0 to 9.\\") phone_number = f\\"({numbers[0]}{numbers[1]}{numbers[2]}) {numbers[3]}{numbers[4]}{numbers[5]}-{numbers[6]}{numbers[7]}{numbers[8]}{numbers[9]}\\" return phone_number"},{"question":"# Question Context In many programming scenarios, especially in frontend development and game development, you might need to transform 2D coordinates. A common transformation is rotating a point around another point by a certain angle. This can be particularly useful in animation, simulations, and geometric computations. Task Your task is to implement a function `rotate_point` that takes a point and rotates it around another point by a given angle. The function should return the new coordinates of the point after rotation. Function Signature ```python import math def rotate_point(px: float, py: float, ox: float, oy: float, angle: float) -> (float, float): Rotate point (px, py) around point (ox, oy) by the given angle in degrees. :param px: The x-coordinate of the point to rotate :param py: The y-coordinate of the point to rotate :param ox: The x-coordinate of the origin point :param oy: The y-coordinate of the origin point :param angle: The angle in degrees to rotate the point :return: A tuple (new_px, new_py) representing the new coordinates of the point after rotation Raises: TypeError: If any of the inputs are not float or int Examples: >>> rotate_point(1, 0, 0, 0, 90) (0.0, 1.0) >>> rotate_point(0, 1, 0, 0, 90) (-1.0, 0.0) >>> rotate_point(1, 2, 1, 1, 180) (1.0, 0.0) >>> rotate_point(2, 2, 1, 1, 45) (1.0, 2.414213562373095) ``` Constraints - The coordinates and angle are provided as floats or integers. - The function should handle both positive and negative angles, where positive angle indicates counter-clockwise rotation and negative angle indicates clockwise rotation. - Ensure floating-point precision in the result. Requirements - The function must raise a `TypeError` if any of the inputs are not float or int. - Utilize mathematical functions from the `math` module to perform the rotation. - Make sure to implement the function efficiently. Example ```python px, py = 3, 4 ox, oy = 1, 2 angle = 90 # Rotating point (3, 4) around point (1, 2) by 90 degrees print(rotate_point(px, py, ox, oy, angle)) # Output: (-1.0, 4.0) ``` Notes - Include proper docstrings and comments in your implementation. - Ensure to handle invalid inputs gracefully.","solution":"import math def rotate_point(px: float, py: float, ox: float, oy: float, angle: float) -> (float, float): Rotate point (px, py) around point (ox, oy) by the given angle in degrees. :param px: The x-coordinate of the point to rotate :param py: The y-coordinate of the point to rotate :param ox: The x-coordinate of the origin point :param oy: The y-coordinate of the origin point :param angle: The angle in degrees to rotate the point :return: A tuple (new_px, new_py) representing the new coordinates of the point after rotation Raises: TypeError: If any of the inputs are not float or int Examples: >>> rotate_point(1, 0, 0, 0, 90) (0.0, 1.0) >>> rotate_point(0, 1, 0, 0, 90) (-1.0, 0.0) >>> rotate_point(1, 2, 1, 1, 180) (1.0, 0.0) >>> rotate_point(2, 2, 1, 1, 45) (1.0, 2.414213562373095) # Validate input types if not all(isinstance(arg, (float, int)) for arg in [px, py, ox, oy, angle]): raise TypeError(\\"All input values must be of type float or int.\\") # Convert angle from degrees to radians angle_rad = math.radians(angle) # Translate point back to origin translated_px = px - ox translated_py = py - oy # Apply rotation cos_theta = math.cos(angle_rad) sin_theta = math.sin(angle_rad) rotated_px = translated_px * cos_theta - translated_py * sin_theta rotated_py = translated_px * sin_theta + translated_py * cos_theta # Translate point back to original position new_px = rotated_px + ox new_py = rotated_py + oy return new_px, new_py"},{"question":"# Coding Assessment Question As a backend developer, you are tasked with improving the data processing flow of a weather forecasting application. This application fetches recent weather data from an external API and processes it to provide valuable insights to end-users. The main issues to address include handling various edge cases and optimizing the data retrieval process to minimize API calls. Your task is to: 1. Refactor the existing functions to enhance error handling capabilities and optimize API usage. 2. Implement an additional caching mechanism to store frequently accessed weather data to reduce redundant API calls. 3. Include detailed documentation and comments for the new caching mechanism and update the existing function descriptions accordingly. Expected Input and Output **Function 1**: `def fetch_weather_data(location: str) -> dict[str, float | str]`: Fetch weather data for a given location. - **Input**: A location (string) for which to retrieve the weather data. - **Output**: A dictionary with weather parameters such as temperature, humidity, and description. **Function 2**: `def process_weather_data(weather_data: dict[str, float | str]) -> str`: Process the fetched weather data and provide a textual weather update. - **Input**: A dictionary containing weather data. - **Output**: A string with a human-readable weather summary. **Function 3**: `def get_cached_weather_data(location: str, cache: dict[str, dict[str, float | str]]) -> dict[str, float | str]`: Retrieve weather data from the cache or fetch it from the API if not present in the cache. - **Input**: - `location` (str): The location for which to get weather data. - `cache` (dict): A dictionary used for caching weather data. - **Output**: A dictionary with weather parameters from cache or freshly fetched. # Constraints - Ensure all API responses are properly handled, including timeouts and invalid data. - Implement efficient caching with an appropriate cache validity period to ensure fresh weather data. - Handle edge cases such as invalid location names and API rate limiting. # Example ```python cache = {} # Fetch data for New York and cache it weather_info_ny = get_cached_weather_data(\\"New York\\", cache) print(weather_info_ny) # { \\"temperature\\": 15.4, \\"humidity\\": 70, \\"description\\": \\"Cloudy\\" } # Process the weather data weather_summary = process_weather_data(weather_info_ny) print(weather_summary) # \\"The current temperature in New York is 15.4°C with a humidity level of 70%. The weather is cloudy.\\" # Attempt to fetch data for New York again, this time it should use the cache weather_info_ny_cached = get_cached_weather_data(\\"New York\\", cache) print(weather_info_ny_cached) # Output should be same as above, fetched from cache ``` Ensure the caching mechanism is effectively reducing redundant API calls and the processed weather information is accurate and well-formatted.","solution":"import time # Function to fetch weather data from an API def fetch_weather_data(location: str) -> dict[str, float | str]: Fetch weather data for a given location. This function simulates an API call to fetch weather data for the provided location. # This should be replaced with actual API call. # Here we simulate API data for demonstration purposes. api_data = { \\"New York\\": {\\"temperature\\": 15.4, \\"humidity\\": 70, \\"description\\": \\"Cloudy\\"}, \\"Los Angeles\\": {\\"temperature\\": 20.0, \\"humidity\\": 60, \\"description\\": \\"Sunny\\"}, # Add more locations as needed } if location not in api_data: raise ValueError(f\\"Weather data for location \'{location}\' not available\\") return api_data[location] # Function to process weather data and provide a textual weather update def process_weather_data(weather_data: dict[str, float | str]) -> str: Process the fetched weather data and provide a textual weather update. return ( f\\"The current temperature is {weather_data[\'temperature\']}°C \\" f\\"with a humidity level of {weather_data[\'humidity\']}%. \\" f\\"The weather is {weather_data[\'description\'].lower()}.\\" ) # Function to manage cache and fetch weather data def get_cached_weather_data(location: str, cache: dict[str, dict[str, float | str]]) -> dict[str, float | str]: Retrieve weather data from the cache or fetch it from the API if not present in the cache. cache_duration = 600 # 10 minutes as cache validity period current_time = time.time() # Check if the location is in cache and if the cache is still valid if location in cache: cached_data, timestamp = cache[location] if current_time - timestamp < cache_duration: return cached_data # Fetch new data and update the cache new_weather_data = fetch_weather_data(location) cache[location] = (new_weather_data, current_time) return new_weather_data"},{"question":"# Coding Assessment Question Scenario An e-commerce platform needs to automate the calculation of discount prices for products during a flash sale. The platform provides a list of original prices for the products and a corresponding list of discount percentages. The task is to determine the final price for each product after applying the respective discount. Task Write a Python function `calculate_discounted_prices(original_prices: list, discount_percentages: list) -> list` that calculates the discounted prices for each product. Function Signature ```python def calculate_discounted_prices(original_prices: list, discount_percentages: list) -> list: ``` Input - `original_prices`: a list of floating-point numbers where each number represents the original price of a product. - `discount_percentages`: a list of integers where each integer represents the discount percentage to be applied to the corresponding product in `original_prices`. Output - Return a list of floating-point numbers representing the discounted prices of the products. Constraints - The length of `original_prices` and `discount_percentages` lists will be equal. - All numbers in `original_prices` and `discount_percentages` will be non-negative. - The discount percentage for each product will not exceed 100. Examples ```python >>> calculate_discounted_prices([100.0, 200.0, 150.0], [10, 20, 25]) [90.0, 160.0, 112.5] >>> calculate_discounted_prices([50.0, 70.0], [5, 0]) [47.5, 70.0] >>> calculate_discounted_prices([30.0, 60.0, 90.0], [50, 50, 100]) [15.0, 30.0, 0.0] ``` Requirements - Your solution must ensure that all edge cases are handled properly. - Provide efficient performance adhering to the outlined complexities.","solution":"def calculate_discounted_prices(original_prices: list, discount_percentages: list) -> list: Calculates the discounted prices for each product. Parameters: original_prices (list of float): The original prices of the products. discount_percentages (list of int): The discount percentages for the corresponding products. Returns: list of float: The final prices of the products after applying the discounts. discounted_prices = [] for price, discount in zip(original_prices, discount_percentages): discounted_price = price * (1 - discount / 100.0) discounted_prices.append(discounted_price) return discounted_prices"},{"question":"Context You are a data analyst who needs to analyze annual sales data for a retail company. Your task is to implement functions that will aggregate sales data and calculate key statistics. Requirements Write two functions, `total_annual_sales` and `average_monthly_sales`, based on the following specifications: # Function 1: total_annual_sales **Input**: - `monthly_sales`: A list of 12 floats representing the sales figures for each month of the year. **Output**: - Returns a float representing the total annual sales. **Constraints**: - The `monthly_sales` list must contain exactly 12 elements. - Each monthly sales figure must be a non-negative float. - If these constraints are not met, raise a `ValueError` with the appropriate message: - `\\"monthly_sales must contain exactly 12 elements.\\"` - `\\"Monthly sales figures must be non-negative floats.\\"` # Function 2: average_monthly_sales **Input**: - `monthly_sales`: A list of 12 floats representing the sales figures for each month of the year. **Output**: - Returns a float representing the average monthly sales. **Constraints**: - The `monthly_sales` list must contain exactly 12 elements. - Each monthly sales figure must be a non-negative float. - If these constraints are not met, raise a `ValueError` with the appropriate message: - `\\"monthly_sales must contain exactly 12 elements.\\"` - `\\"Monthly sales figures must be non-negative floats.\\"` Example Usage ```python assert total_annual_sales([1000.0, 1100.5, 1200.0, 1300.3, 1400.2, 1500.6, 1600.1, 1700.4, 1800.9, 1900.8, 2000.0, 2100.7]) == 18604.5 assert total_annual_sales([0.0] * 12) == 0.0 assert average_monthly_sales([1000.0, 1100.5, 1200.0, 1300.3, 1400.2, 1500.6, 1600.1, 1700.4, 1800.9, 1900.8, 2000.0, 2100.7]) == 1550.375 assert average_monthly_sales([0.0] * 12) == 0.0 ``` Make sure to handle edge cases and validate inputs as specified.","solution":"def total_annual_sales(monthly_sales): Returns the total annual sales from a list of monthly sales figures. if len(monthly_sales) != 12: raise ValueError(\\"monthly_sales must contain exactly 12 elements.\\") if any(type(sale) is not float or sale < 0 for sale in monthly_sales): raise ValueError(\\"Monthly sales figures must be non-negative floats.\\") return sum(monthly_sales) def average_monthly_sales(monthly_sales): Returns the average monthly sales from a list of monthly sales figures. if len(monthly_sales) != 12: raise ValueError(\\"monthly_sales must contain exactly 12 elements.\\") if any(type(sale) is not float or sale < 0 for sale in monthly_sales): raise ValueError(\\"Monthly sales figures must be non-negative floats.\\") total_sales = sum(monthly_sales) return total_sales / 12"},{"question":"# Knapsack Problem Solver You are given a set of items, each with a weight and a value, and a knapsack with a weight capacity. Write a function `knapsack_solver` that implements the dynamic programming solution to the 0/1 knapsack problem. The goal is to determine the maximum value that can be obtained without exceeding the weight capacity of the knapsack. Function Signature ```python def knapsack_solver(weights: List[int], values: List[int], capacity: int) -> int: Solve the 0/1 knapsack problem using dynamic programming. Parameters: weights (List[int]): A list of integers representing the weights of the items. values (List[int]): A list of integers representing the values of the items. capacity (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value that can be obtained. pass ``` Requirements 1. **Input/Output**: - **Input**: - `weights` (List[int]): A list of integers where each integer represents the weight of an item. - `values` (List[int]): A list of integers where each integer represents the value of an item. - `capacity` (int): The maximum weight capacity of the knapsack. - **Output**: An integer that represents the maximum value that can be obtained without exceeding the weight capacity. 2. **Implementation Details**: - Use a 2D list (table) to store the maximum value that can be obtained for every possible weight up to the capacity. - Iterate through each item and update the table based on the inclusion or exclusion of the item. - Utilize bottom-up dynamic programming approach to build the solution. - Ensure the algorithm appropriately handles edge cases such as an empty list of items or a capacity of zero. 3. **Performance**: - Optimize for efficient performance and clarity. - Aim for a time complexity of O(n * W), where n is the number of items and W is the weight capacity of the knapsack. Example ```python weights = [2, 3, 4, 5] values = [3, 4, 5, 6] capacity = 5 max_value = knapsack_solver(weights, values, capacity) print(\\"Maximum Value:\\", max_value) # Output should be 7 ``` Your task is to implement the `knapsack_solver` function to achieve the expected functionality.","solution":"from typing import List def knapsack_solver(weights: List[int], values: List[int], capacity: int) -> int: Solve the 0/1 knapsack problem using dynamic programming. Parameters: weights (List[int]): A list of integers representing the weights of the items. values (List[int]): A list of integers representing the values of the items. capacity (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value that can be obtained. n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# JSON to Dictionary Conversion and Search Given a JSON formatted string representing a dictionary, and a list of keys, your task is to parse the JSON string into a dictionary, and then retrieve the values corresponding to the given keys. If a key does not exist in the dictionary, return `None` for that key in the output list. Function Signature ```python def json_to_dict_and_search(json_str: str, keys: list[str]) -> list[Optional[Union[str, int]]]: Parameters: json_str (str): A JSON formatted string representing the dictionary. keys (list[str]): A list of strings representing the keys to search in the dictionary. Returns: list[Optional[Union[str, int]]]: A list of values corresponding to the given keys. If a key does not exist, return `None` for that key. ``` Input - `json_str`: A JSON string representing the dictionary. - `keys`: A list of strings representing the keys to search for in the dictionary. Constraints - The JSON string will be a valid JSON format. - The dictionary values will be strings, integers, or nested dictionaries of similar structure. - The length of the keys list will be between 1 and 100. Output - A list of values corresponding to the given keys. If a key does not exist, return `None` for that key. Example ```python >>> json_to_dict_and_search(\'{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\"}\', [\\"name\\", \\"age\\", \\"occupation\\"]) [\'Alice\', 30, None] >>> json_to_dict_and_search(\'{\\"name\\": \\"Alice\\", \\"address\\": {\\"street\\": \\"Wonderland St.\\", \\"city\\": \\"Wonderland\\"}}\', [\\"name\\", \\"address\\", \\"address.city\\", \\"address.zip\\"]) [\'Alice\', {\'street\': \'Wonderland St.\', \'city\': \'Wonderland\'}, \'Wonderland\', None] ``` Note - Your solution should handle nested dictionaries. For nested keys, use dot notation (e.g., `address.city`). - Consider edge cases where the JSON string is empty or malformed.","solution":"import json from typing import Optional, Union, List, Dict def json_to_dict_and_search(json_str: str, keys: List[str]) -> List[Optional[Union[str, int, Dict[str, Union[str, int]]]]]: Parameters: json_str (str): A JSON formatted string representing the dictionary. keys (list[str]): A list of strings representing the keys to search in the dictionary. Returns: list[Optional[Union[str, int, Dict[str, Union[str, int]]]]]: A list of values corresponding to the given keys. If a key does not exist, return `None` for that key. def search_nested_key(d, key): parts = key.split(\'.\') for part in parts: if isinstance(d, dict) and part in d: d = d[part] else: return None return d dictionary = json.loads(json_str) result = [] for key in keys: result.append(search_nested_key(dictionary, key)) return result"},{"question":"# Coding Assessment Question You are to implement a real-time collaborative text synchronization system, where multiple users can edit a single shared document concurrently. The goal is to synchronize the text additions, deletions, and cursor movements in real-time using operational transformation or another suitable algorithm. Your implementation should ensure consistency of the shared document across all clients. Function Signature ```python class CollaborativeEditor: def __init__(self): pass def apply_operation(self, user_id, operation): pass def get_document(self): pass ``` Input/Output * **Input to `__init__`**: - No input is required to initialize the class. * **Input to `apply_operation`**: - `user_id`: An integer representing the unique identifier of the user making the change. - `operation`: A dictionary containing: - `type`: A string either \\"insert\\" or \\"delete\\" indicating the operation type. - `position`: An integer indicating the position in the document where the change is to be applied. - `character`: A single character (only for insert operations). * **Output from `get_document`**: - Returns the current state of the shared document as a string. Constraints * The document\'s initial state is empty (\\"\\"). * Users are assigned unique IDs from 1 to N, where N can be any positive integer. * The operations will be applied sequentially in the order they are received. Scenario Imagine you are part of a development team at a tech company building a real-time collaborative editing tool like Google Docs. Your task is to implement the core text synchronization logic that ensures all users see a consistent document state despite concurrent operations. Performance Requirements * Must efficiently handle concurrent operations from up to 10 users with 1000 operations each within a reasonable time frame (≤ 1 second total processing time). Example ```python # Example usage editor = CollaborativeEditor() editor.apply_operation(1, {\\"type\\": \\"insert\\", \\"position\\": 0, \\"character\\": \\"H\\"}) editor.apply_operation(2, {\\"type\\": \\"insert\\", \\"position\\": 1, \\"character\\": \\"i\\"}) editor.apply_operation(1, {\\"type\\": \\"delete\\", \\"position\\": 0}) print(editor.get_document()) # Output: i ``` Note You need to handle synchronization issues such as concurrent operations and ensure that the final document state is consistent across all clients. Ensure that the insertion and deletion operations are correctly ordered and applied to maintain the document\'s integrity.","solution":"class CollaborativeEditor: def __init__(self): self.document = \\"\\" def apply_operation(self, user_id, operation): Applies given operation to the document. Parameters: user_id (int): unique identifier of the user making the change. operation (dict): dictionary with keys: - \'type\' (str): either \\"insert\\" or \\"delete\\" - \'position\' (int): position where the change should be applied - \'character\' (str): character to insert (only for insert operations) op_type = operation.get(\'type\') position = operation.get(\'position\') if op_type == \\"insert\\": character = operation.get(\'character\') self.document = self.document[:position] + character + self.document[position:] elif op_type == \\"delete\\": self.document = self.document[:position] + self.document[position+1:] def get_document(self): Returns the current document state. Returns: str: the current state of the document return self.document"},{"question":"# Coding Question: Inventory Management System Scenario You are tasked with developing an inventory management system for a small store. The system keeps track of the items in stock, the quantity of each item, and allows for restocking and selling of items. Your task is to implement a function `manage_inventory` that processes a list of transactions and returns the current state of the inventory. Task Implement the function `manage_inventory` in Python that manages the inventory operations based on a series of transactions provided. Function Signature ```python def manage_inventory( transactions: list ) -> dict: ``` Parameters * `transactions` (list): A list of transactions, where each transaction is represented as a tuple of the form `(operation, item, quantity)`. The `operation` could either be \'restock\' or \'sell\'. Returns * `dict`: A dictionary representing the current state of the inventory. The keys are the item names, and the values are the number of items currently in stock. Constraints * Each `item` is a string consisting of alphabetic characters. * `quantity` (int) for each transaction is a non-negative integer ((0 leq quantity leq 10^3)). * The length of `transactions` list is at most (10^4). Example ```python # Example 1 transactions = [(\\"restock\\", \\"apple\\", 50), (\\"restock\\", \\"banana\\", 100), (\\"sell\\", \\"apple\\", 20), (\\"sell\\", \\"banana\\", 50)] result = manage_inventory(transactions) # Output: {\'apple\': 30, \'banana\': 50} # Example 2 transactions = [(\\"restock\\", \\"milk\\", 10), (\\"sell\\", \\"milk\\", 5), (\\"restock\\", \\"bread\\", 20), (\\"sell\\", \\"bread\\", 25)] result = manage_inventory(transactions) # Output: {\'milk\': 5, \'bread\': 0} ``` Remember to handle cases where selling an item that is not restocked yet should result in 0 quantity for that item in the inventory. Ensure your solution handles the restocking and selling operations accurately and efficiently.","solution":"def manage_inventory(transactions): inventory = {} for operation, item, quantity in transactions: if item not in inventory: inventory[item] = 0 if operation == \\"restock\\": inventory[item] += quantity elif operation == \\"sell\\": inventory[item] = max(0, inventory[item] - quantity) return inventory"},{"question":"# Movie Database Filtering Context: You are building a simple movie database that stores movies and their release years. Users should be able to query the database to find all movies released in a given range of years. Task: Implement a class `MovieDatabase` that allows adding movies to the database and querying movies by their release year. Requirements: 1. **Class Definition** - Implement the class `MovieDatabase` that represents the movie database. - The constructor initializes an empty database. 2. **Adding Movies** - Implement the method `add_movie(self, title: str, year: int) -> None` that adds a movie to the database with the given title and release year. 3. **Querying Movies** - Implement the method `query_movies(self, start_year: int, end_year: int) -> List[str]` that returns a list of movie titles released within the given range of years (inclusive). The list should be sorted alphabetically. 4. **Edge Cases Handling** - Ensure that all edge cases like non-overlapping ranges, no movies in the database, and movies with the same title are handled. Input/Output: - **Input**: ``` Add movie: (\\"The Shawshank Redemption\\", 1994) Add movie: (\\"The Godfather\\", 1972) Query movies: (1970, 1980) ``` - **Output**: ``` Movies released between 1970 and 1980: [\\"The Godfather\\"] ``` Constraints: - Movie titles are unique. - Years are valid integers within a realistic range (e.g., 1900 to 2100). - The input is guaranteed to be valid. Example Usage: ```python >>> db = MovieDatabase() >>> db.add_movie(\\"The Shawshank Redemption\\", 1994) >>> db.add_movie(\\"The Godfather\\", 1972) >>> db.add_movie(\\"The Dark Knight\\", 2008) >>> db.query_movies(1970, 1980) [\\"The Godfather\\"] >>> db.query_movies(1990, 2000) [\\"The Shawshank Redemption\\"] ```","solution":"from typing import List class MovieDatabase: def __init__(self): self.movies = [] def add_movie(self, title: str, year: int) -> None: Adds a movie to the database with the given title and release year. :param title: Title of the movie :param year: Release year of the movie self.movies.append((title, year)) def query_movies(self, start_year: int, end_year: int) -> List[str]: Returns a list of movie titles released within the given range of years (inclusive). :param start_year: The start year of the range :param end_year: The end year of the range :return: List of movie titles sorted alphabetically result = [title for title, year in self.movies if start_year <= year <= end_year] return sorted(result)"},{"question":"# Coding Assessment Task: Analyze Weather Patterns Context You work for a climate research organization that analyzes weather data to detect unusual weather patterns. You are tasked with creating a function that analyzes temperature data to find the hottest and coldest days in a given dataset. Task Write a Python function `analyze_temperatures(data: List[Tuple[str, float]]) -> Tuple[str, str]` that: 1. Takes a list of tuples as input, where each tuple contains a date (as a string in the format `YYYY-MM-DD`) and a temperature reading (as a float). 2. Finds the date with the highest temperature and the date with the lowest temperature. 3. Returns a tuple containing the date of the highest temperature and the date of the lowest temperature. Input Format - `data` (List[Tuple[str, float]]): A list of tuples, with each tuple containing: - `date` (str): A string representing the date in the format `YYYY-MM-DD`. - `temperature` (float): A float representing the temperature reading on that date. Output Format - A tuple containing two strings: - The date of the highest temperature. - The date of the lowest temperature. Constraints - The input list will have at least one entry. - Dates and temperatures will be valid and well-formed. Example ```python >>> analyze_temperatures([(\\"2023-01-01\\", 22.5), (\\"2023-01-02\\", 19.3), (\\"2023-01-03\\", 25.6), (\\"2023-01-04\\", 18.2)]) (\'2023-01-03\', \'2023-01-04\') ``` Performance Requirements - The function should compute the result efficiently, even for lists with hundreds of entries. Notes - You can assume that there are no tie temperatures for the highest or lowest values. - Utilize built-in Python functions such as `max` and `min` for optimal performance.","solution":"from typing import List, Tuple def analyze_temperatures(data: List[Tuple[str, float]]) -> Tuple[str, str]: Analyzes the temperature data to find the hottest and coldest days. Parameters: - data: List[Tuple[str, float]] : A list of tuples containing dates and their respective temperatures. Returns: - Tuple[str, str] : A tuple containing the date of the highest temperature and the date of the lowest temperature. max_temp = max(data, key=lambda x: x[1]) min_temp = min(data, key=lambda x: x[1]) return (max_temp[0], min_temp[0])"},{"question":"Coding Assessment Task Context: You are designing a feature for an online shopping platform to manage inventory levels effectively. To ensure that customers are always shown the correct availability of products, you must implement a system to handle inventory updates during simultaneous transactions. Task: Create a function that processes a batch of inventory updates from multiple transactions, ensuring that the final stock levels are accurate. Each transaction either adds or subtracts a certain quantity of items from the inventory. Requirements: 1. **Function Signature**: ```python def update_inventory(transactions: list, initial_stock: dict) -> dict: ``` 2. **Input**: * `transactions` (list): A list where each element is a dictionary representing a single transaction. Each dictionary has the format `{ \\"item\\": str, \\"quantity\\": int }`, where `quantity` can be positive (addition) or negative (subtraction). * `initial_stock` (dict): A dictionary representing the initial stock levels with item names as keys and quantities as values. 3. **Output**: * `dict`: A dictionary representing the updated stock levels after processing all transactions. 4. **Constraints**: * Ensure that stock levels do not go below zero. Transactions leading to negative stock should be ignored for that item. * Each transaction might operate on different items. * The function should handle up to 1000 transactions simultaneously. 5. **Performance Requirements**: * The function should efficiently handle a large number of transactions and update the inventory in a timely manner. * Aim to minimize computational overhead when applying transactions. Example Usage: ```python initial_stock = { \\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 7 } transactions = [ {\\"item\\": \\"apple\\", \\"quantity\\": -3}, {\\"item\\": \\"banana\\", \\"quantity\\": 5}, {\\"item\\": \\"orange\\", \\"quantity\\": -2}, {\\"item\\": \\"apple\\", \\"quantity\\": -8} # This transaction should be ignored since it would lead to a negative stock for apple ] result = update_inventory(transactions, initial_stock) # Expected Output Format # { # \\"apple\\": 7, # \\"banana\\": 10, # \\"orange\\": 5 # } ``` Hints: * Iterate through the transactions and update the stock dictionary accordingly. * Check for negative stock levels after applying each transaction and discard any transactions that would result in an invalid state. Good luck!","solution":"def update_inventory(transactions, initial_stock): Update the inventory based on a series of transactions. Arguments: transactions: List of dictionaries, each with \'item\' and \'quantity\' keys. initial_stock: Dictionary with initial stock levels. Returns: Dictionary of updated stock levels. # Create a copy of initial_stock to update updated_stock = initial_stock.copy() # Process each transaction for transaction in transactions: item = transaction[\'item\'] quantity = transaction[\'quantity\'] # Check if the item exists in the stock if item in updated_stock: # Calculate the new stock level new_quantity = updated_stock[item] + quantity # Only update if the new stock level is not negative if new_quantity >= 0: updated_stock[item] = new_quantity else: # If item does not exist and transaction is positive, add to inventory if quantity > 0: updated_stock[item] = quantity return updated_stock"},{"question":"# Question: Implement a Banking Transaction System Background In a banking system, users can hold multiple bank accounts, and each account can have different types of transactions like deposits and withdrawals. These transactions impact the account balance. Implement a set of functions to manage account balances and transactions. Task Your task is to implement a banking transaction system consisting of the following functionalities: 1. Initialize accounts with unique IDs and initial balances. 2. Perform deposit and withdrawal transactions on the accounts. 3. Retrieve the current balance of an account. 4. Retrieve the transaction history for an account. # Function Specifications `initialize_account(account_id: int, initial_balance: float) -> None` - **Input**: `account_id` (int), `initial_balance` (float) - **Output**: None - **Behavior**: Initialize an account with a unique `account_id` and an `initial_balance`. If the account already exists, raise an error. `deposit(account_id: int, amount: float) -> None` - **Input**: `account_id` (int), `amount` (float) - **Output**: None - **Behavior**: Add the `amount` to the balance of the account with the specified `account_id`. If the account does not exist, raise an error. `withdraw(account_id: int, amount: float) -> None` - **Input**: `account_id` (int), `amount` (float) - **Output**: None - **Behavior**: Deduct the `amount` from the balance of the account with the specified `account_id`. If the account does not have sufficient balance or does not exist, raise an error. `get_balance(account_id: int) -> float` - **Input**: `account_id` (int) - **Output**: Returns the current balance of the account as a float. - **Behavior**: Returns the balance of the account with the specified `account_id`. If the account does not exist, raise an error. `transaction_history(account_id: int) -> List[Tuple[str, float]]` - **Input**: `account_id` (int) - **Output**: A list of tuples with the transaction type (\\"deposit\\" or \\"withdraw\\") and the transaction amount (float). - **Behavior**: Returns the transaction history of the account with the specified `account_id`. If the account does not exist, raise an error. # Example Usage ```python initialize_account(101, 500.0) initialize_account(102, 1000.0) deposit(101, 200.0) withdraw(101, 100.0) deposit(102, 500.0) print(get_balance(101)) # 600.0 print(get_balance(102)) # 1500.0 print(transaction_history(101)) # [(\\"deposit\\", 200.0),(\\"withdraw\\", 100.0)] print(transaction_history(102)) # [(\\"deposit\\", 500.0)] ``` # Notes 1. Ensure account balances do not go negative during withdrawals. 2. Optimize for common operations, keeping track of balances and transactions efficiently. 3. Implement necessary error handling for non-existent accounts and insufficient funds during withdrawals.","solution":"class AccountError(Exception): Custom exception for account-related errors. pass accounts = {} def initialize_account(account_id: int, initial_balance: float) -> None: if account_id in accounts: raise AccountError(\'Account already exists\') accounts[account_id] = { \'balance\': initial_balance, \'transactions\': [] } def deposit(account_id: int, amount: float) -> None: if account_id not in accounts: raise AccountError(\'Account does not exist\') accounts[account_id][\'balance\'] += amount accounts[account_id][\'transactions\'].append((\'deposit\', amount)) def withdraw(account_id: int, amount: float) -> None: if account_id not in accounts: raise AccountError(\'Account does not exist\') if accounts[account_id][\'balance\'] < amount: raise AccountError(\'Insufficient balance\') accounts[account_id][\'balance\'] -= amount accounts[account_id][\'transactions\'].append((\'withdraw\', amount)) def get_balance(account_id: int) -> float: if account_id not in accounts: raise AccountError(\'Account does not exist\') return accounts[account_id][\'balance\'] def transaction_history(account_id: int) -> list: if account_id not in accounts: raise AccountError(\'Account does not exist\') return accounts[account_id][\'transactions\']"},{"question":"# Question: Largest Connected Component Given a graph represented as an adjacency list, implement an algorithm to find the size of the largest connected component. A connected component of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. Function Signature ```python def largest_connected_component(graph: dict) -> int: @input: graph (Graph stored as an adjacency list where each vertex is represented as an integer) @return: An integer, representing the size of the largest connected component in the graph. ``` # Input * `graph`: A dictionary where each key is a vertex, and each value is a list of adjacent vertices. Each vertex is represented as an integer. # Output * An integer representing the size of the largest connected component in the graph. # Example ```python >>> graph = {0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3]} >>> largest_connected_component(graph) 3 ``` # Constraints * You can assume the graph will have up to 1000 vertices. * The adjacency list representation guarantees there are no duplicate edges. * Self-loops are not present in the graph. # Notes * Your implementation should handle edge cases such as empty graphs, graphs with no edges, isolated vertices, and non-connected components appropriately. * Focus on performance and correctness of your solution. # Hints * Utilize Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the connected components of the graph. * Ensure your solution considers all vertices and accurately counts the size of each connected component.","solution":"def largest_connected_component(graph: dict) -> int: Returns the size of the largest connected component in the graph. :param graph: A dictionary representing the graph as an adjacency list. :return: An integer representing the size of the largest connected component. def dfs(node, visited): # Use a stack for the Depth-First Search stack = [node] size = 0 while stack: current = stack.pop() if current not in visited: visited.add(current) size += 1 # Add all unvisited neighbors to the stack stack.extend(neighbor for neighbor in graph[current] if neighbor not in visited) return size visited = set() largest_size = 0 for node in graph: if node not in visited: component_size = dfs(node, visited) largest_size = max(largest_size, component_size) return largest_size"},{"question":"# Question: Implement an Efficient Prime Factorization Algorithm Prime factorization is the process of determining the prime numbers that multiply together to give a certain number. Your task is to implement an efficient algorithm that computes the prime factors of a given integer and returns them in a sorted list. Requirements: * Your algorithm should be optimized to handle larger integers efficiently. * The function should return a sorted list of prime factors in ascending order. # Function Signature: ```python def prime_factors(n: int) -> list: Computes the prime factors of a given integer. :param n: An integer to factorize. :return: A list of prime factors in ascending order. ``` # Input: * A single integer `n` where 1 <= n <= 10^12. # Output: * A sorted list of integer prime factors of `n`. # Constraints: * You can assume the input integer is within the given range. * You should ensure the algorithm runs efficiently with a time complexity suitable for large inputs. # Example: ```python >>> prime_factors(60) [2, 2, 3, 5] >>> prime_factors(45) [3, 3, 5] >>> prime_factors(13) [13] >>> prime_factors(1) [] ``` # Instructions: 1. Implement a helper function `is_prime` to check if a number is prime. 2. Use an efficient method (such as trial division and checking up to the square root of `n`) to compute the prime factors. 3. Ensure the prime factors are returned in a sorted list. # Note: - Consider edge cases such as `n` being 1 or a prime number itself. - Think about optimizations to minimize the number of division operations, especially for larger integers.","solution":"def prime_factors(n: int) -> list: Computes the prime factors of a given integer. :param n: An integer to factorize. :return: A list of prime factors in ascending order. if n < 2: return [] factors = [] # Handle the smallest prime number (2) while n % 2 == 0: factors.append(2) n //= 2 # Handle odd numbers from 3 upwards factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If n is still larger than 2, then it\'s a prime number if n > 1: factors.append(n) return factors"},{"question":"# Coding Assessment Question **Context**: You are developing an application that processes text. One of the functionalities required is to analyze the frequency of letters in a given text, which can help in various text processing tasks such as cryptography, linguistic analysis, or data compression. To achieve this, you\'ll write a function that counts the occurrences of each letter, ignoring case and non-letter characters. **Task**: Write a function `letter_frequency` that computes the frequency of each letter in the given text and returns it as a dictionary. Function Signature: ```python def letter_frequency(text: str) -> dict: ``` Parameters: * `text` (str): The input string from which letter frequencies are calculated. Returns: * `dict`: A dictionary where keys are letters and values are their respective frequencies. Examples: ```python >>> letter_frequency(\\"Hello World!\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> letter_frequency(\\"Coding is fun!\\") {\'c\': 1, \'o\': 1, \'d\': 1, \'i\': 2, \'n\': 2, \'g\': 1, \'s\': 1, \'f\': 1, \'u\': 1} ``` # Constraints: * The input text may contain both uppercase and lowercase letters. * Ignore non-letter characters (such as spaces, punctuation, numbers, etc.). * The function should treat letters as case-insensitive (i.e., \'A\' and \'a\' are the same). * Ensure the solution handles large bodies of text efficiently.","solution":"def letter_frequency(text: str) -> dict: Computes the frequency of each letter in the given text, ignoring case and non-letter characters. Parameters: text (str): The input string from which letter frequencies are calculated. Returns: dict: A dictionary where keys are letters and values are their respective frequencies. from collections import defaultdict frequency = defaultdict(int) for char in text.lower(): if char.isalpha(): # Check if the character is a letter frequency[char] += 1 return dict(frequency)"},{"question":"# Coding Assessment Question: Maximum Consecutive Ones in Binary Array **Context**: Working with binary arrays (arrays composed of 0s and 1s) is a common task in many coding and technical assessments. One significant operation on such an array is determining the longest sequence of consecutive 1s, which has applications in signal processing, data compression, and more. **Objective**: Write a function `max_consecutive_ones(binary_array: list) -> int` that returns the length of the longest sequence of consecutive 1s in the given binary array. **Function Signature**: ```python def max_consecutive_ones(binary_array: list) -> int: pass ``` # Input: - A list `binary_array` of integers where each integer is either 0 or 1. The list is non-empty and has at most `10^6` elements. # Output: - An integer representing the length of the longest sequence of consecutive 1s in the array. # Constraints: - The function should handle large inputs efficiently. - The array will contain only 0s and 1s. # Examples: ```python >>> max_consecutive_ones([1, 1, 0, 1, 1, 1]) 3 >>> max_consecutive_ones([0, 0, 1, 0, 0, 1, 1, 0, 1]) 2 >>> max_consecutive_ones([1, 1, 1, 1, 1]) 5 >>> max_consecutive_ones([0, 0, 0]) 0 >>> max_consecutive_ones([1, 0, 1, 1, 0, 0, 1, 1, 1, 1]) 4 ``` # Additional Notes: 1. Consider how a simple iteration through the list can help in counting consecutive 1s. 2. Think about edge cases such as an array composed entirely of 0s or 1s, and ensure your function handles these gracefully.","solution":"def max_consecutive_ones(binary_array: list) -> int: Returns the length of the longest sequence of consecutive 1s in the given binary array. max_count = 0 current_count = 0 for num in binary_array: if num == 1: current_count += 1 else: max_count = max(max_count, current_count) current_count = 0 return max(max_count, current_count) # Handle the case where the array ends with a sequence of 1s."},{"question":"# String Rotation Checker **Problem Statement**: Given two strings, check if one string is a rotation of another string. A rotation means that the string can be rearranged in such a way that it becomes equivalent to the second string. **Function Signature**: ```python def is_rotation(str1: str, str2: str) -> bool: Approach: - Check if the two strings have the same length. If not, they can\'t be rotations. - Concatenate `str1` with itself, forming a new string. - Check if `str2` is a substring of this concatenated string. Params: - str1 (str): The first string. - str2 (str): The second string. Returns: - bool: True if `str2` is a rotation of `str1`, False otherwise. pass ``` **Input**: * `str1` - A string of length ( n ). * `str2` - A string of length ( n ). **Output**: * A boolean value indicating whether `str2` is a rotation of `str1`. **Constraints**: * `1 <= len(str1), len(str2) <= 1000` * Both strings contain only lowercase English letters. **Example**: ```python # Example use-cases print(is_rotation(\\"abcd\\", \\"cdab\\")) # Output: True print(is_rotation(\\"abcd\\", \\"acbd\\")) # Output: False print(is_rotation(\\"rotation\\", \\"tationro\\")) # Output: True print(is_rotation(\\"hello\\", \\"lohel\\")) # Output: True print(is_rotation(\\"hello\\", \\"world\\")) # Output: False ``` **Note**: - Ensure that your function handles edge cases such as strings of length 1 and two identical strings correctly. - Test the function with different rotations and non-rotations to verify its accuracy.","solution":"def is_rotation(str1: str, str2: str) -> bool: Check if `str2` is a rotation of `str1`. :param str1: The first string. :param str2: The second string. :return: True if `str2` is a rotation of `str1`, False otherwise. if len(str1) != len(str2): return False concatenated = str1 + str1 return str2 in concatenated"},{"question":"# Data Encryption and Decryption with RSA Algorithm Context You are working as a security engineer at a financial institution where protecting sensitive customer data is of paramount importance. Your current task involves implementing a secure data communication protocol using the RSA encryption scheme. The protocol needs to encrypt a given message with the receiver\'s public key and decrypt the received ciphertext with the corresponding private key. Task Your task is to implement the RSA encryption and decryption functions. You will be given public and private keys along with the message or ciphertext. Ensure the implementation can handle typical RSA key sizes and adheres to security best practices. Requirements 1. **Function Prototype**: Implement the functions `rsa_encrypt(message: int, e: int, n: int) -> int` and `rsa_decrypt(ciphertext: int, d: int, n: int) -> int`. 2. **Input and Output**: - For `rsa_encrypt`: - **Input**: - `message` (integer): The message to encrypt. - `e` (integer): The public exponent. - `n` (integer): The modulus. - **Output**: The encrypted message (integer). - For `rsa_decrypt`: - **Input**: - `ciphertext` (integer): The encrypted message to decrypt. - `d` (integer): The private exponent. - `n` (integer): The modulus. - **Output**: The decrypted message (integer). 3. **Constraints**: - Ensure that the message and ciphertext are both non-negative integers. - Handle cases where the inputs might not be within the valid range of the RSA scheme. - Implement the algorithm securely to prevent common vulnerabilities. Expectations - Proper error handling for invalid inputs. - Clear and concise documentation for the implemented code. - Use secure and efficient algorithms for modular exponentiation. Implementation Example Here is a template to get you started: ```python def rsa_encrypt(message: int, e: int, n: int) -> int: if message < 0 or message >= n: raise ValueError(\\"Message out of bounds.\\") return pow(message, e, n) def rsa_decrypt(ciphertext: int, d: int, n: int) -> int: if ciphertext < 0 or ciphertext >= n: raise ValueError(\\"Ciphertext out of bounds.\\") return pow(ciphertext, d, n) ``` Utilize appropriate mathematical functions to ensure secure and accurate encryption and decryption. Pay attention to potential edge cases and security considerations for handling large integers typically used in RSA.","solution":"def rsa_encrypt(message: int, e: int, n: int) -> int: Encrypts the given message using the RSA encryption algorithm. Args: message (int): The message to encrypt. e (int): The public exponent. n (int): The modulus. Returns: int: The encrypted message. Raises: ValueError: If the message is out of bounds. if message < 0 or message >= n: raise ValueError(\\"Message out of bounds.\\") return pow(message, e, n) def rsa_decrypt(ciphertext: int, d: int, n: int) -> int: Decrypts the given ciphertext using the RSA decryption algorithm. Args: ciphertext (int): The encrypted message to decrypt. d (int): The private exponent. n (int): The modulus. Returns: int: The decrypted message. Raises: ValueError: If the ciphertext is out of bounds. if ciphertext < 0 or ciphertext >= n: raise ValueError(\\"Ciphertext out of bounds.\\") return pow(ciphertext, d, n)"},{"question":"# Problem Statement You are tasked with implementing a function that simulates a simplified version of a spell checker. Given a list of correctly spelled words (the dictionary) and a single word (the query), the function should determine if the query is a valid word by checking if it is present in the dictionary. Additionally, the function should allow up to a given number of character mismatches. A character mismatch is defined as a difference between corresponding characters at the same position in two words. # Function Signature ```python def is_word_valid(dictionary: list[str], query: str, max_mismatches: int) -> bool: pass ``` # Input Format - `dictionary`: A list of strings representing the correctly spelled words (1 <= len(dictionary) <= 10^5, 1 <= len(dictionary[i]) <= 100). - `query`: A string representing the word to check (1 <= len(query) <= 100). - `max_mismatches`: An integer representing the maximum allowable character mismatches (0 <= max_mismatches <= 100). # Output Format - `True` if the query is a valid word, considering the maximum allowable mismatches, otherwise `False`. # Constraints 1. Words are case-sensitive (i.e., \\"Word\\" and \\"word\\" are considered different words). 2. The length of `query` will be the same as the lengths of words in `dictionary`. # Performance Requirements - The function should be implemented efficiently to handle large inputs. # Example ```python >>> dictionary = [\\"spell\\", \\"check\\", \\"correct\\", \\"words\\", \\"accurate\\"] >>> query = \\"shpll\\" >>> max_mismatches = 1 >>> is_word_valid(dictionary, query, max_mismatches) True >>> query = \\"apple\\" >>> max_mismatches = 2 >>> is_word_valid(dictionary, query, max_mismatches) False >>> query = \\"accumate\\" >>> max_mismatches = 3 >>> is_word_valid(dictionary, query, max_mismatches) True ``` # Explanation - In the first example, \\"shpll\\" matches \\"spell\\" with exactly one character mismatch (\'h\' instead of \'e\'). - In the second example, \\"apple\\" is not present in the dictionary, and no word in the dictionary allows for two character mismatches. - In the third example, \\"accumate\\" matches \\"accurate\\" with exactly two character mismatches (\'m\' instead of \'r\' and \'t\' instead of \'e\').","solution":"def is_word_valid(dictionary: list[str], query: str, max_mismatches: int) -> bool: def count_mismatches(word1, word2): return sum(1 for a, b in zip(word1, word2) if a != b) for word in dictionary: if count_mismatches(word, query) <= max_mismatches: return True return False"},{"question":"# Sum of Digits Problem Statement Write a function that takes a positive integer as input and returns the sum of its digits. The function should handle error cases as specified below. Function Signature ```python def sum_of_digits(n: int) -> int: ``` Input - `n` (int): a positive integer, where 0 <= n <= 10^6 Output - An integer representing the sum of the digits of the input number. Constraints - If the input is a negative number, raise a `ValueError` with the message \\"the input must be a non-negative integer\\". - If the input is not an integer, raise a `TypeError` with an appropriate message like \\"input must be a non-negative integer\\". Examples ```python >>> sum_of_digits(123) 6 >>> sum_of_digits(456) 15 >>> sum_of_digits(789) 24 >>> sum_of_digits(0) 0 >>> sum_of_digits(1001) 2 >>> sum_of_digits(-5) Traceback (most recent call last): ... ValueError: the input must be a non-negative integer >>> sum_of_digits(3.14) Traceback (most recent call last): ... TypeError: \'float\' object cannot be interpreted as an integer >>> sum_of_digits(\\"100\\") Traceback (most recent call last): ... TypeError: \'<\' not supported between instances of \'str\' and \'int\' ``` Additional Notes You are free to use Python\'s built-in functions for type checking and string manipulation.","solution":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the input integer n. Parameters: n (int): A non-negative integer. Returns: int: The sum of the digits of n. if not isinstance(n, int): raise TypeError(\\"input must be a non-negative integer\\") if n < 0: raise ValueError(\\"the input must be a non-negative integer\\") return sum(int(digit) for digit in str(n))"},{"question":"# Problem Overview You are given a non-empty string containing only digits. Your task is to find the number of ways you can decode it to a string using the mapping `A = 1, B = 2, ..., Z = 26`. For example, the string \\"123\\" can be decoded as \\"ABC\\" (1 2 3), \\"LC\\" (12 3), or \\"AW\\" (1 23). Each digit or pair of digits must map to a valid character. # Function Signature ```python def num_decodings(s: str) -> int: pass ``` # Input * `s`: A string consisting of digits (\'0\' - \'9\'). # Output An integer representing the number of ways to decode the string. # Constraints 1. 1 <= len(s) <= 100 2. The input string is guaranteed to be non-empty and contain only digits. # Examples ```python # Example 1 print(num_decodings(\\"12\\")) # Expected Output: 2 # Explanation: \\"12\\" could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). # Example 2 print(num_decodings(\\"226\\")) # Expected Output: 3 # Explanation: \\"226\\" could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). # Example 3 print(num_decodings(\\"06\\")) # Expected Output: 0 # Explanation: There is no valid way to decode \\"06\\" as leading zeros are not allowed. # Example 4 print(num_decodings(\\"10\\")) # Expected Output: 1 # Explanation: \\"10\\" could be decoded as \\"J\\" (10). # Example 5 print(num_decodings(\\"11106\\")) # Expected Output: 2 # Explanation: \\"11106\\" could be decoded as \\"AAJF\\" (1 1 10 6) or \\"KJF\\" (11 10 6). # Example 6 print(num_decodings(\\"2101\\")) # Expected Output: 1 # Explanation: \\"2101\\" could be decoded as \\"UJA\\" (21 1 0 1), but the only valid decoding is \\"U\\" (21 01 does not work so we have only one decoded version that starts with 21). ``` # Notes - Handle edge cases like strings with zeroes appropriately. For example, \\"100\\" should return `1` (only \\"J\\" (10) \\"J\\" (0) is valid). - Utilize dynamic programming to ensure the solution is efficient even for the upper limit of input size.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) # dp[i] represents the number of ways to decode s[:i] dp = [0] * (n + 1) dp[0] = 1 # Base case: An empty string has one way to be decoded for i in range(1, n + 1): # Check if the single digit is valid (1-9) if s[i - 1] != \'0\': dp[i] += dp[i - 1] # Check if the double digits are valid (10-26) if i > 1: double_digit = int(s[i - 2:i]) if 10 <= double_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Problem Statement You are working on a data analysis tool for a logistics company. The company wants to analyze the efficiency of their delivery routes based on various metrics of their trucks\' usage. One important metric is the \\"trip efficiency,\\" calculated as the ratio of the total distance traveled by a truck to the number of stops it made during the trip. # Function Definition You need to implement a function `trip_efficiency_report(trips: List[Dict[str, Union[int, float]]]) -> Dict[str, float]` that takes a list of dictionaries as input. Each dictionary represents a trip and contains the following keys: 1. `trip_id`: A unique integer identifier for the trip. 2. `total_distance`: The total distance traveled on the trip (in kilometers). 3. `stops`: The number of stops made during the trip. The function should return a dictionary where the keys are the `trip_id`s and the values are the calculated trip efficiencies. # Expected Output The function should return a dictionary mapping each trip ID to its efficiency, computed as the ratio of the total distance to the number of stops. # Constraints 1. `total_distance` will be a non-negative float. 2. `stops` will be a positive integer. 3. The input list will contain at least one trip. # Performance Requirements - Aim for an O(n) complexity, where `n` is the number of trips. # Example ```python from typing import List, Dict, Union def trip_efficiency_report(trips: List[Dict[str, Union[int, float]]]) -> Dict[str, float]: Calculate the trip efficiency for each trip provided in the input list. >>> trips = [ ... {\'trip_id\': 101, \'total_distance\': 150.0, \'stops\': 3}, ... {\'trip_id\': 102, \'total_distance\': 200.0, \'stops\': 4}, ... {\'trip_id\': 103, \'total_distance\': 300.0, \'stops\': 5} ... ] >>> trip_efficiency_report(trips) {101: 50.0, 102: 50.0, 103: 60.0} efficiency_report = {} for trip in trips: trip_id = trip[\'trip_id\'] total_distance = trip[\'total_distance\'] stops = trip[\'stops\'] efficiency = total_distance / stops if stops > 0 else 0 efficiency_report[trip_id] = efficiency return efficiency_report ```","solution":"from typing import List, Dict, Union def trip_efficiency_report(trips: List[Dict[str, Union[int, float]]]) -> Dict[str, float]: Calculate the trip efficiency for each trip provided in the input list. Parameters: trips (List[Dict[str, Union[int, float]]]): A list of dictionaries where each dictionary represents a trip. Each dictionary contains: - \'trip_id\' (int): A unique identifier for the trip - \'total_distance\' (float): The total distance traveled during the trip - \'stops\' (int): The number of stops made during the trip Returns: Dict[str, float]: A dictionary mapping each trip ID to its efficiency, calculated as the ratio of total distance to the number of stops. efficiency_report = {} for trip in trips: trip_id = trip[\'trip_id\'] total_distance = trip[\'total_distance\'] stops = trip[\'stops\'] # Calculate the trip efficiency efficiency = total_distance / stops if stops > 0 else 0 efficiency_report[trip_id] = efficiency return efficiency_report"},{"question":"**Decode the Alien Message** You are given an alien message in the form of a string consisting only of the characters \'A\', \'B\', and \'C\'. Each character \'A\' adds 2 to a decoded number, \'B\' adds 3, and \'C\' multiplies the current total by 2. Write a function to decode the message and return the final decoded number. # Function Signature ```python def decode_alien_message(message: str) -> int: pass ``` # Input - message (str): A string containing the alien message composed only of the characters \'A\', \'B\', and \'C\'. # Output - The integer representing the decoded number after processing the entire message. # Constraints - The input string will have at least one character and will not exceed 100 characters in length. - The operations should follow the given character rules strictly and be performed in the order they appear in the message. # Example - If the input message is `ABC`, the function should return `10`: - Start with a total of 0. - \'A\' adds 2 to total (total = 2). - \'B\' adds 3 to total (total = 5). - \'C\' multiplies total by 2 (total = 10). # Performance Requirements - The solution should efficiently process the entire message string in linear time relative to its length. - The function should handle the simple operations as defined without unnecessary computations. # Scenario/Context You have intercepted a message from an alien species and must decode it following their mathematical rules. Your program should process the received message string character by character and apply the corresponding operations to calculate the final decoded number.","solution":"def decode_alien_message(message: str) -> int: total = 0 for char in message: if char == \'A\': total += 2 elif char == \'B\': total += 3 elif char == \'C\': total *= 2 return total"},{"question":"# Problem Description You are tasked with creating a simple text editor with the ability to store text, append new text, undo recent operations, and retrieve a specific portion of the text. The text editor should support the following operations: - `append(string: str)`: Appends the given string to the end of the current text. - `undo()`: Reverts the most recent append operation. If no operations can be undone, nothing happens. - `substring(start: int, end: int) -> str`: Returns a substring of the current text from the start index to the end index (exclusive). If the indices are out of bounds, it should return an empty string. **Input Constraints** - Appended strings should have a length between 1 and 1000 characters. - The initial text is empty. - All string operations should be efficient with respect to their time complexity. - The indices for the `substring` method are zero-based. **Output Description** - Implement the specified functions. - Ensure that `append` and `undo` operations are efficiently handled, supporting up to 10^5 operations in total. **Example Input** ```python editor = SimpleTextEditor() editor.append(\\"hello\\") editor.append(\\" world\\") print(editor.substring(0, 5)) # Output: \\"hello\\" editor.undo() print(editor.substring(0, 11)) # Output: \\"hello\\" editor.append(\\"world\\") print(editor.substring(1, 9)) # Output: \\"elloworl\\" ``` **Detailed Instructions** 1. Implement the `SimpleTextEditor` class with: - An `__init__` method to initialize the editor with empty text. - An `append` method to add new text. - An `undo` method to revert the last append operation. - A `substring` method to extract text within the specified range.","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, string): self.history.append(self.text) self.text += string def undo(self): if self.history: self.text = self.history.pop() def substring(self, start, end): if 0 <= start <= end <= len(self.text): return self.text[start:end] return \\"\\""},{"question":"# Array Rotation Challenge You need to implement a function `rotate_array` to rotate the elements of an integer array `n` times to the right. In a single right rotation, each element of the array shifts one position to the right, and the last element of the array moves to the front. Your implementation must handle the following requirements: - If the array is empty, return an empty array. - If the number of rotations `n` is zero or an exact multiple of the array length, the array should remain unchanged. # Function Signature: ```python def rotate_array(arr: List[int], n: int) -> List[int]: pass ``` # Input: - `arr` - A list of integers. - `n` - A non-negative integer representing the number of times to rotate the array. # Output: - The function should return a list of integers which represent the array after `n` rotations. # Example: ```python arr = [1, 2, 3, 4, 5] n = 2 print(rotate_array(arr, n)) # Output: [4, 5, 1, 2, 3] arr = [1, 2, 3] n = 4 print(rotate_array(arr, n)) # Output: [3, 1, 2] ``` # Constraints: - The array may contain up to 10^5 elements. - The number of rotations `n` can be as large as 10^9. - The solution should be efficient, ideally with a time complexity of O(n), considering possible reductions in the number of rotations modulo the array length. # Testing: 1. Add multiple test cases to validate the correctness of the function. 2. Ensure to test edge cases like an empty array, single-element array, and when the number of rotations is zero or larger than the array length.","solution":"from typing import List def rotate_array(arr: List[int], n: int) -> List[int]: Rotate elements in the array `n` times to the right. :param arr: List of integers. :param n: Number of times to rotate. :return: The rotated array if not arr: return [] length = len(arr) n = n % length if n == 0: return arr return arr[-n:] + arr[:-n]"},{"question":"# Scenario: You are tasked with developing a small module for a personal finance application. One of the core features is to provide the user with a summary of their monthly transactions. Your task is to write a function that, given a list of individual transactions for a month, calculates the total income, total expenses, and the net balance. # Function Requirements: * Implement a function `monthly_summary` that takes a list of transactions and returns a summary as a dictionary. * Each transaction in the list is represented as a tuple `(amount, description)`, where `amount` is a float indicating the transaction amount (positive for incomes, negative for expenses), and `description` is a string detailing the transaction. * The summary should include total income (sum of all positive amounts), total expenses (sum of all negative amounts), and the net balance (total income - total expenses). # Constraints: * The input list will contain at least one transaction. * Transaction amounts can be zero. * Descriptions are non-empty strings. # Function Signature: ```python def monthly_summary(transactions: list) -> dict: pass ``` # Example: ```python transactions = [ (1500.00, \\"Salary\\"), (-50.75, \\"Groceries\\"), (-100.00, \\"Internet Bill\\"), (200.00, \\"Freelance Work\\"), (-20.00, \\"Lunch\\"), ] expected_output = { \\"total_income\\": 1700.00, \\"total_expenses\\": -170.75, \\"net_balance\\": 1529.25 } assert monthly_summary(transactions) == expected_output ``` # Input: - `transactions` (list): A list of tuples, with each tuple containing a float (transaction amount) and a string (description). # Output: - (dict): A dictionary with keys `total_income`, `total_expenses`, and `net_balance`. **Good luck!**","solution":"def monthly_summary(transactions): Calculate the total income, total expenses, and the net balance from a list of transactions. Args: transactions (list): A list of tuples, where each tuple contains a float (amount) and a string (description). Returns: dict: A dictionary with keys \'total_income\', \'total_expenses\', and \'net_balance\' containing the respective calculated values. total_income = sum(amount for amount, desc in transactions if amount > 0) total_expenses = sum(amount for amount, desc in transactions if amount < 0) net_balance = total_income + total_expenses return { \\"total_income\\": total_income, \\"total_expenses\\": total_expenses, \\"net_balance\\": net_balance }"},{"question":"# Coding Assessment Question: Sparse Matrix Multiplication Context Sparse matrices are matrices in which most of the elements are zero. These types of matrices are common in various applications, such as scientific computing and machine learning, where space and time efficiency are critical. To efficiently handle operations involving sparse matrices, special algorithms and data structures are often employed. Your task is to implement a method within the provided `SparseMatrix` class to perform matrix multiplication. The `SparseMatrix` class represents a sparse matrix using the coordinate list (COO) format, where only the non-zero elements are stored. Task Implement a method within the provided `SparseMatrix` class to multiply the sparse matrix with another sparse matrix. Function Signature ```python def multiply(self, other: \'SparseMatrix\') -> \'SparseMatrix\': Multiplies this sparse matrix with another sparse matrix. Args: other (SparseMatrix): The sparse matrix to be multiplied. Returns: SparseMatrix: The resulting sparse matrix from the multiplication. ``` Input - `self` - The current sparse matrix represented by the `SparseMatrix` class. - `other` - Another sparse matrix represented by the `SparseMatrix` class. Output - The function should return a new `SparseMatrix` representing the result of the multiplication. Constraints - Ensure to handle matrices of compatible dimensions for multiplication. - Consider an efficient approach that leverages the sparse nature of the matrices. - Edge cases such as matrices with no non-zero elements or incompatible dimensions should be handled gracefully. - Use the following simplified representation for sparse matrices: ```python class SparseMatrix: def __init__(self, num_rows: int, num_cols: int, elements: List[Tuple[int, int, float]]): Initializes a sparse matrix. Args: num_rows (int): Number of rows in the matrix. num_cols (int): Number of columns in the matrix. elements (List[Tuple[int, int, float]]): List of non-zero elements in the format (row, col, value). self.num_rows = num_rows self.num_cols = num_cols self.elements = elements ``` Example ```python # Example 1 matrix1 = SparseMatrix(2, 3, [ (0, 0, 1), (0, 2, 2), (1, 1, 3) ]) matrix2 = SparseMatrix(3, 2, [ (0, 1, 4), (1, 0, 5), (2, 1, 6) ]) result = matrix1.multiply(matrix2) # Expected output: SparseMatrix(2, 2, [(0, 1, 16), (1, 0, 15)]) # Example 2 matrix3 = SparseMatrix(2, 2, [ (0, 0, 0), (0, 1, 0), (1, 0, 0), (1, 1, 0) ]) matrix4 = SparseMatrix(2, 2, [ (0, 0, 1), (1, 1, 1) ]) result = matrix3.multiply(matrix4) # Expected output: SparseMatrix(2, 2, []) # No non-zero elements # Example 3 matrix5 = SparseMatrix(3, 3, [ (0, 0, 1), (1, 1, 1), (2, 2, 1) ]) matrix6 = SparseMatrix(3, 3, [ (0, 0, 1), (1, 1, 1), (2, 2, 1) ]) result = matrix5.multiply(matrix6) # Expected output: SparseMatrix(3, 3, [ # (0, 0, 1), # (1, 1, 1), # (2, 2, 1) # ]) ``` Additional Notes - You can assume the `SparseMatrix` class provided will have additional methods like `get_row` and `get_col` which may be useful for your implementation. - Ensure to minimize time and space complexity for handling large sparse matrices.","solution":"class SparseMatrix: def __init__(self, num_rows: int, num_cols: int, elements: list): Initializes a sparse matrix. Args: num_rows (int): Number of rows in the matrix. num_cols (int): Number of columns in the matrix. elements (list): List of non-zero elements in the format (row, col, value). self.num_rows = num_rows self.num_cols = num_cols self.elements = elements def multiply(self, other: \'SparseMatrix\') -> \'SparseMatrix\': if self.num_cols != other.num_rows: raise ValueError(\\"Incompatible dimensions for multiplication\\") # Create a dictionary to store elements of resulting matrix result_elements = {} # Convert sparse matrix to hashmap of rows self_rows = self._to_row_dict() other_cols = other._to_col_dict() # Perform multiplication for i in self_rows: for j in other_cols: sum_val = 0 for k, v1 in self_rows[i].items(): if k in other_cols[j]: sum_val += v1 * other_cols[j][k] if sum_val != 0: result_elements[(i, j)] = sum_val # Convert dictionary to list of (i, j, value) elements result_list = [(i, j, val) for (i, j), val in result_elements.items()] return SparseMatrix(self.num_rows, other.num_cols, result_list) def _to_row_dict(self): row_dict = {} for r, c, v in self.elements: if r not in row_dict: row_dict[r] = {} row_dict[r][c] = v return row_dict def _to_col_dict(self): col_dict = {} for r, c, v in self.elements: if c not in col_dict: col_dict[c] = {} col_dict[c][r] = v return col_dict"},{"question":"# Problem Statement You are provided with a list of integers where every element appears twice except for one. Implement a function to identify the single element that appears only once. Your function should have a linear runtime complexity and should not use extra space (i.e., a constant space solution). # Function Signature ```python def find_single_element(nums: List[int]) -> int: pass ``` # Input * `nums` (List[int]): A list of integers where every element appears twice except for one integer which appears only once. # Output * `int`: The single integer that appears only once in the list. # Constraints * The solution should have a linear runtime complexity. * The solution should not use additional space for data storage. # Example ```python >>> find_single_element([2, 2, 1]) 1 >>> find_single_element([4, 1, 2, 1, 2]) 4 ``` # Notes * Use of bitwise operations to achieve constant space is encouraged. * The function should efficiently handle the constraint of linear time complexity. * Pay attention to the edge cases where the list contains only one element.","solution":"def find_single_element(nums): Finds the single element that appears only once in the list. Uses bitwise XOR to achieve linear runtime complexity and constant space. single_element = 0 for num in nums: single_element ^= num return single_element"},{"question":"# Coding Assessment Question Question: Given an integer array `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. Assume each input would have exactly one solution, and you may not use the same element twice. Implement a function that solves this problem efficiently. Function Details: * **Function Name**: `two_sum` * **Input**: Two arguments: * `nums` which is a list of integers. * `target` which is an integer. * **Output**: A list of two integers representing the indices of the two numbers in `nums` that add up to `target`. * **Constraints**: * Each input will have exactly one solution. * Can assume that the solution will always be unique. * The input list `nums` will have a length of at least 2 and at most 10^4. * **Performance Requirement**: The function should run efficiently within O(n) time complexity where n is the length of the `nums` list. Example: ```python >>> print(two_sum([2, 7, 11, 15], 9)) [0, 1] >>> print(two_sum([3, 2, 4], 6)) [1, 2] >>> print(two_sum([3, 3], 6)) [0, 1] ``` Remember to handle edge cases such as having only two elements in the list, or multiple pairs with the same values but different indices. Document your code appropriately and include error handling for invalid inputs.","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. :param nums: List[int] - the list of integers to search. :param target: int - the target sum we are looking for. :return: List[int] - indices of the two numbers that add up to target. num_to_index = {} # Dictionary to store number and its index for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return [] # Should not reach here because the problem guarantees exactly one solution # Example usage of the function print(two_sum([2, 7, 11, 15], 9)) # [0, 1] print(two_sum([3, 2, 4], 6)) # [1, 2] print(two_sum([3, 3], 6)) # [0, 1]"},{"question":"# Question: Log Analyzer for Web Server Objective: As a part of maintaining a web server, you are tasked with implementing a log analyzer. This analyzer should parse a given log file, extract specific information, and compute statistical information. The log file is in a standardized format (Common Log Format). Part 1: Log Parsing 1. **Function: `parse_log_entry`** * Parse a single log entry and extract the IP address, timestamp, request type, URL, and status code. ```python def parse_log_entry(log_entry: str) -> dict: Parse a single log entry. Parameters: log_entry (str): A single line log entry in Common Log Format. Returns: dict: A dictionary with keys \'ip\', \'timestamp\', \'request_type\', \'url\', and \'status_code\' containing extracted data. pass # Your implementation ``` 2. **Function: `parse_log_file`** * Parse an entire log file and return a list of parsed log entries. ```python def parse_log_file(log_file_path: str) -> list: Parse a log file and extract details from each entry. Parameters: log_file_path (str): Path to the log file. Returns: list: List of dictionaries, each representing a parsed log entry. pass # Your implementation ``` Part 2: Analyzing Log Data 3. **Function: `most_frequent_ip`** * Determine the IP address that has made the most requests. ```python def most_frequent_ip(parsed_entries: list) -> str: Find the IP address with the most requests. Parameters: parsed_entries (list): List of parsed log entries. Returns: str: The IP address with the most requests. pass # Your implementation ``` 4. **Function: `error_rate`** * Compute the error rate, defined as the proportion of requests with status codes indicating an error (4xx or 5xx). ```python def error_rate(parsed_entries: list) -> float: Compute the error rate of log entries. Parameters: parsed_entries (list): List of parsed log entries. Returns: float: The error rate as a proportion of all requests. pass # Your implementation ``` Constraints & Requirements: * Ensure `parse_log_entry` handles various edge cases in log entry formats gracefully. * Each log entry can be assumed to follow the Common Log Format. * The log file can be large, so ensure efficient parsing and analysis. Example: ```python log_entry = \'127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326\' parsed_entry = parse_log_entry(log_entry) print(parsed_entry) # Output: { # \'ip\': \'127.0.0.1\', # \'timestamp\': \'10/Oct/2000:13:55:36 -0700\', # \'request_type\': \'GET\', # \'url\': \'/apache_pb.gif\', # \'status_code\': 200 # } parsed_entries = parse_log_file(\\"access_log\\") print(most_frequent_ip(parsed_entries)) # Example Output: \'192.168.1.1\' print(error_rate(parsed_entries)) # Example Output: 0.15 ``` Ensure your implementation handles all edge cases, performs efficiently with large log files, and meets the specified requirements.","solution":"import re def parse_log_entry(log_entry: str) -> dict: Parse a single log entry. Parameters: log_entry (str): A single line log entry in Common Log Format. Returns: dict: A dictionary with keys \'ip\', \'timestamp\', \'request_type\', \'url\', and \'status_code\' containing extracted data. log_pattern = r\'(?P<ip>d{1,3}(?:.d{1,3}){3}) - - [(?P<timestamp>[^]]+)] \\"(?P<request_type>w+) (?P<url>S+) [^\\"]+\\" (?P<status_code>d{3})\' match = re.match(log_pattern, log_entry) if match: return { \'ip\': match.group(\'ip\'), \'timestamp\': match.group(\'timestamp\'), \'request_type\': match.group(\'request_type\'), \'url\': match.group(\'url\'), \'status_code\': int(match.group(\'status_code\')) } return {} def parse_log_file(log_file_path: str) -> list: Parse a log file and extract details from each entry. Parameters: log_file_path (str): Path to the log file. Returns: list: List of dictionaries, each representing a parsed log entry. parsed_entries = [] with open(log_file_path, \'r\') as file: for line in file: parsed_entry = parse_log_entry(line.strip()) if parsed_entry: parsed_entries.append(parsed_entry) return parsed_entries def most_frequent_ip(parsed_entries: list) -> str: Find the IP address with the most requests. Parameters: parsed_entries (list): List of parsed log entries. Returns: str: The IP address with the most requests. ip_count = {} for entry in parsed_entries: ip = entry[\'ip\'] if ip in ip_count: ip_count[ip] += 1 else: ip_count[ip] = 1 return max(ip_count, key=ip_count.get) def error_rate(parsed_entries: list) -> float: Compute the error rate of log entries. Parameters: parsed_entries (list): List of parsed log entries. Returns: float: The error rate as a proportion of all requests. total_requests = len(parsed_entries) error_requests = sum(1 for entry in parsed_entries if 400 <= entry[\'status_code\'] < 600) return error_requests / total_requests if total_requests > 0 else 0.0"},{"question":"# Problem Statement A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Given a list of strings, implement a function to identify and return all the strings that are palindromes. Write a function `find_palindromes(strings: List[str]) -> List[str]` that takes as input a list of strings and returns a list of strings that are palindromes. # Input: - A list of strings where each string contains between 1 and 100 characters. # Output: - A list of strings. Each string is a palindrome. # Constraints: - Ensure the implementation handles mixed-case inputs by treating uppercase and lowercase letters as equivalent. - Optimize the solution to handle the maximum constraint efficiently. # Example: ```python >>> find_palindromes([\\"Anna\\", \\"Civic\\", \\"hello\\", \\"Level\\", \\"world\\", \\"racecar\\"]) [\'Anna\', \'Civic\', \'Level\', \'racecar\'] ``` # Performance Requirements - The algorithm should efficiently process each string in the list, ideally in ( O(n) ) time complexity per string, where ( n ) is the length of the string.","solution":"from typing import List def find_palindromes(strings: List[str]) -> List[str]: Returns all the palindromes from a list of strings. palindromes = [] for s in strings: normalized_string = \'\'.join(char.lower() for char in s if char.isalnum()) if normalized_string == normalized_string[::-1]: palindromes.append(s) return palindromes"},{"question":"# Queue Simulation You are required to simulate a basic queue system with additional features. Specifically, you need to implement functionality for enqueuing and dequeuing elements, as well as checking the size of the queue and retrieving the element at the front without removing it. Requirements 1. **`enqueue` method**: * **Input**: An element to add to the queue. * **Behavior**: Adds the element to the end of the queue. * **Function Signature**: ```python def enqueue(self, element: int) -> None: ``` 2. **`dequeue` method**: * **Output**: The element removed from the front of the queue. * **Behavior**: Removes and returns the element at the front of the queue. If the queue is empty, return `None`. * **Function Signature**: ```python def dequeue(self) -> int | None: ``` 3. **`size` method**: * **Output**: The number of elements currently in the queue. * **Function Signature**: ```python def size(self) -> int: ``` 4. **`front` method**: * **Output**: The element at the front of the queue without removing it. If the queue is empty, return `None`. * **Function Signature**: ```python def front(self) -> int | None: ``` Constraints * Input elements for the queue are limited to integers only. * The queue must handle at least 10,000 operations in under 1 second. Example ```python # Example usage of the Queue class queue = Queue() queue.enqueue(1) queue.enqueue(2) print(queue.size()) # Output: 2 print(queue.front()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.size()) # Output: 1 print(queue.front()) # Output: 2 print(queue.dequeue()) # Output: 2 print(queue.dequeue()) # Output: None ``` Notes * Ensure the class is implemented efficiently to handle a large number of operations. * The `enqueue` and `dequeue` operations should be performed in constant time O(1). Good luck, and happy coding!","solution":"class Queue: def __init__(self): Initializes an empty queue. self.queue = [] def enqueue(self, element: int) -> None: Adds the element to the end of the queue. :param element: Integer to be added to the queue. self.queue.append(element) def dequeue(self) -> int | None: Removes and returns the element at the front of the queue. :return: Integer at the front of the queue or None if the queue is empty. if not self.queue: return None return self.queue.pop(0) def size(self) -> int: Returns the number of elements in the queue. :return: The size of the queue. return len(self.queue) def front(self) -> int | None: Returns the element at the front of the queue without removing it. :return: Integer at the front of the queue or None if the queue is empty. if not self.queue: return None return self.queue[0]"},{"question":"# Data Segmentation Assessment Objective Design and implement a function to perform segmentation on a series of numeric data based on specified interval ranges. To test your understanding of the given requirements, you will create a solution that efficiently divides the data and provides summary statistics for each segment. Function Signature ```python def segment_data(data: List[float], intervals: List[Tuple[float, float]]) -> Dict[str, Dict[str, float]]: ... ``` Instructions 1. **Functionality**: - Create a function that takes two parameters: - `data`: A list of float values representing the numeric dataset. - `intervals`: A list of tuples, where each tuple contains two float values representing the lower and upper bounds of an interval range. - The function should return a dictionary where each key is a string representation of an interval (e.g., \\"0-10\\") and each value is another dictionary containing summary statistics (`count`, `sum`, `mean`) for the data points falling within that interval. 2. **Summary Statistics**: - **count**: The number of data points within the interval. - **sum**: The sum of the data points within the interval. - **mean**: The mean (average) of the data points within the interval. 3. **Considerations**: - A data point falls within an interval if it is greater than or equal to the lower bound and less than the upper bound. - Intervals may overlap, and each data point should be considered for every applicable interval. - The function should efficiently handle large datasets and multiple intervals. - Perform error handling for invalid data or intervals (e.g., non-numeric values, incorrect interval bounds). 4. **Examples**: - ```python segment_data([1.2, 2.5, 3.8, 5.0, 6.3], [(0, 3), (4, 7)]) # Output: {\\"0-3\\": {\\"count\\": 2, \\"sum\\": 3.7, \\"mean\\": 1.85}, \\"4-7\\": {\\"count\\": 2, \\"sum\\": 11.3, \\"mean\\": 5.65}} ``` - ```python segment_data([10.1, 15.5, 20.2, 25.6], [(10, 20), (15, 25)]) # Output: {\\"10-20\\": {\\"count\\": 2, \\"sum\\": 25.6, \\"mean\\": 12.8}, \\"15-25\\": {\\"count\\": 2, \\"sum\\": 35.7, \\"mean\\": 17.85}} ``` 5. **Constraints**: - The data list can contain up to 10^6 float values. - Intervals will be given in a properly formatted list of tuples with valid float bounds. - Handle extremely small and large float values efficiently. Notes - Assume proper input validation post-initial function checks. - Ensure the solution is optimized for performance, particularly for large datasets and multiple intervals. - Appropriately document your code to explain your logic and approach.","solution":"from typing import List, Tuple, Dict def segment_data(data: List[float], intervals: List[Tuple[float, float]]) -> Dict[str, Dict[str, float]]: Segments the data based on specified interval ranges and provides summary statistics for each segment. Parameters: data (List[float]): A list of float values representing the numeric dataset. intervals (List[Tuple[float, float]]): A list of tuples, where each tuple contains two float values representing the lower and upper bounds of an interval range. Returns: Dict[str, Dict[str, float]]: A dictionary where each key is a string representation of an interval and each value is another dictionary containing summary statistics (count, sum, mean). results = {} for lower, upper in intervals: key = f\\"{lower}-{upper}\\" filtered_data = [x for x in data if lower <= x < upper] count = len(filtered_data) total_sum = sum(filtered_data) mean = total_sum / count if count > 0 else 0 results[key] = { \\"count\\": count, \\"sum\\": total_sum, \\"mean\\": mean } return results"},{"question":"# Objective You need to implement a function that performs image rotation. The goal is to test your ability to manipulate multidimensional arrays and handle edge cases during rotation operations. # Problem Statement Write a Python function `rotate_image(image: np.ndarray, angle: int) -> np.ndarray` that rotates a given 2D grayscale image by the specified angle (90, 180, or 270 degrees). Input: 1. `image` (np.ndarray): a `M x N` array representing a grayscale image. 2. `angle` (int): the rotation angle, which can be one of the values {90, 180, 270}. Output: Returns a `numpy.ndarray` representing the rotated image. Constraints: 1. The input image will always be a non-empty `M x N` numpy array. 2. Ensure the rotation is performed clockwise. 3. Handle cases where the dimensions of the image change due to rotation. # Example ```python import numpy as np image = np.array([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) rotated_90 = rotate_image(image, 90) print(rotated_90) # Expected output: # array([ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ]) rotated_180 = rotate_image(image, 180) print(rotated_180) # Expected output: # array([ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ]) rotated_270 = rotate_image(image, 270) print(rotated_270) # Expected output: # array([ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ]) ``` Write the function `rotate_image` that implements the above problem statement.","solution":"import numpy as np def rotate_image(image: np.ndarray, angle: int) -> np.ndarray: Rotates a given 2D grayscale image by the specified angle (90, 180, or 270 degrees). Parameters: ----------- image : np.ndarray A M x N array representing a grayscale image. angle : int The rotation angle, which can be one of the values {90, 180, 270}. Returns: -------- np.ndarray The rotated image. if angle == 90: return np.rot90(image, k=3) # Rotate 90 degrees clockwise elif angle == 180: return np.rot90(image, k=2) # Rotate 180 degrees elif angle == 270: return np.rot90(image, k=1) # Rotate 270 degrees clockwise else: raise ValueError(\\"Angle must be one of the following values: 90, 180, 270\\")"},{"question":"# Fibonacci Sequence Coding Challenge Objective You are required to implement a function that returns the n-th number in the Fibonacci sequence efficiently using memoization and recursion. Problem Statement Implement the function `fib(n: int) -> int` that calculates the n-th Fibonacci number. Input and Output * **Input**: * `n`: A non-negative integer representing the position in the Fibonacci sequence. * **Output**: * Returns the computed n-th Fibonacci number. Constraints * The input `n` must be a non-negative integer. * The output is an integer displaying the n-th number in the Fibonacci sequence. Performance Requirement The function should run in (O(n)) time complexity. Example ```python >>> fib(0) 0 >>> fib(1) 1 >>> fib(6) 8 >>> fib(10) 55 >>> fib(20) 6765 ``` Note * Handle edge cases where `n` is 0 or 1 correctly, as these are the base cases of the Fibonacci sequence. Function Signature ```python def fib(n: int) -> int: # Your implementation here ``` Additional Information * `fib(0)` returns 0 as it is the 0-th number in the Fibonacci sequence. * `fib(1)` returns 1 as it is the 1st number in the Fibonacci sequence. * `fib(6)` returns 8 as the sequence would be [0, 1, 1, 2, 3, 5, 8] and the 6th number is 8. Implement the function `fib` to accomplish the task as described above.","solution":"def fib(n: int) -> int: Returns the n-th Fibonacci number using memoization memo = {0: 0, 1: 1} def helper(x): if x not in memo: memo[x] = helper(x - 1) + helper(x - 2) return memo[x] return helper(n)"},{"question":"# Sorting K-sorted Array Background: A **K-sorted array** is an array where each element is at most K positions away from its target position in a sorted array. This characteristic allows the use of more optimized sorting methods to sort the array efficiently. Task: Write a function that takes a K-sorted array and sorts it fully. You are required to implement a function that leverages a min-heap (priority queue) to achieve this. Requirements: 1. **Min-Heap Usage**: - Utilize a min-heap to ensure that the array is sorted efficiently. - Ensure that the min-heap contains at most K+1 elements at any time to leverage the properties of a K-sorted array. 2. **Heap Management**: - Use the heapq module in Python to manage the heap operations efficiently. - Properly handle cases where the array length is less than or equal to K. Function Implementation: Implement the following function: ```python def sort_k_sorted_array(arr: List[int], k: int) -> List[int]: pass ``` Input and Output **Input**: - `arr`: A list of integers representing the K-sorted array. - `k`: An integer representing the maximum number of positions any element is away from its target position in a sorted array. **Output**: - A fully sorted list of integers. **Example**: ```python # Example 1 arr = [3, 2, 6, 5, 4, 8] k = 2 # Output: [2, 3, 4, 5, 6, 8] # Example 2 arr = [10, 9, 8, 7, 4, 70, 50, 60] k = 4 # Output: [4, 7, 8, 9, 10, 50, 60, 70] ``` **Constraints**: - 1 <= len(arr) <= 100000 - 1 <= k < len(arr) - 0 <= arr[i] <= 10^9 **Performance Requirements**: - The function should run in O(N log K) time complexity, where N is the number of elements in the array. This ensures efficient sorting even for large arrays. Make sure to handle edge cases and provide clear documentation and comments within the code.","solution":"from typing import List import heapq def sort_k_sorted_array(arr: List[int], k: int) -> List[int]: Sort a K-sorted array. Parameters: arr (List[int]): The K-sorted array. k (int): The maximum number of positions an element is away from its target position. Returns: List[int]: The fully sorted array. # Initialize a min-heap min_heap = [] # Resultant sorted list sorted_arr = [] # Populate the min-heap with the first k+1 elements for i in range(min(k + 1, len(arr))): heapq.heappush(min_heap, arr[i]) # Process the remaining elements for i in range(k + 1, len(arr)): # Extract the minimum element from the heap and add it to the sorted array sorted_arr.append(heapq.heappop(min_heap)) # Add the current element to the heap heapq.heappush(min_heap, arr[i]) # Extract the remaining elements from the heap while min_heap: sorted_arr.append(heapq.heappop(min_heap)) return sorted_arr"},{"question":"# Sum of Unique Elements Write a function `sum_unique_elements` that takes a list of integers and returns the sum of elements that appear exactly once in the list. Function Signature ```python def sum_unique_elements(nums: List[int]) -> int: pass ``` Input: - `nums` (List[int]): A list of integers where each integer can be positive, negative, or zero. Output: - An integer representing the sum of elements that appear exactly once in the list. Example: ```python def sum_unique_elements(nums): pass # Example usage: print(sum_unique_elements([1, 2, 3, 2, 4, 5, 6, 4])) # Expected output: 15 # Explanation: The elements 1, 3, 5, and 6 appear exactly once, so their sum is 1+3+5+6=15 print(sum_unique_elements([10, 10, 10])) # Expected output: 0 # Explanation: No elements appear exactly once, so the sum is 0 print(sum_unique_elements([1, 2, 3])) # Expected output: 6 # Explanation: All elements appear exactly once, so the sum is 1+2+3=6 ``` **Hint**: Use a dictionary or collections.Counter to track the frequency of each element in the list.","solution":"from typing import List from collections import Counter def sum_unique_elements(nums: List[int]) -> int: Returns the sum of elements that appear exactly once in the list. counts = Counter(nums) sum_unique = sum(num for num, count in counts.items() if count == 1) return sum_unique"},{"question":"# Problem Statement A company wants to organize its files on the server, and each file can have multiple tags associated with it. You are tasked to implement a function that returns the files that contain all the specified tags. # Function Signature ```python def search_files_with_tags(files: dict[str, list[str]], tags: list[str]) -> list[str]: pass ``` # Input - `files`: A dictionary where keys are file names (strings) and values are lists of tags (strings) associated with that file. - `tags`: A list of tags to search for. # Output - Returns a list of file names that contain all the specified tags. # Constraints - All file names and tags consist of lowercase English letters and numbers only. - Each file can have zero or more tags, but no tag will appear more than once in a file. - The tags list might be empty, in which case all file names should be returned. # Example ```python f = { \\"file1\\": [\\"tag1\\", \\"tag2\\", \\"tag3\\"], \\"file2\\": [\\"tag1\\", \\"tag3\\"], \\"file3\\": [\\"tag2\\", \\"tag3\\"], \\"file4\\": [\\"tag1\\", \\"tag2\\", \\"tag4\\"] } tags = [\\"tag1\\", \\"tag2\\"] print(search_files_with_tags(f, tags)) # Output: [\\"file1\\", \\"file4\\"] ``` # Notes - Ensure the function can handle cases where no files match the specified tags. - Consider optimizing the solution for large sets of files and tags. This should seamlessly integrate with the original set of questions, maintaining consistency in style, complexity, and scope.","solution":"def search_files_with_tags(files, tags): Returns a list of file names that contain all the specified tags. :param files: dict where keys are file names and values are lists of tags :param tags: list of tags to search for :return: list of file names that have all the specified tags if not tags: return list(files.keys()) def has_all_tags(file_tags, required_tags): return all(tag in file_tags for tag in required_tags) result = [file_name for file_name, file_tags in files.items() if has_all_tags(file_tags, tags)] return result"},{"question":"# File System Operations You are given a class `SimpleFileSystem` that simulates basic file system operations using a dictionary where keys are file paths and values are the file contents. The file system supports the following operations: - `create_file(path, content)`: Creates a new file at the specified `path` with the given `content`. - `read_file(path)`: Reads the content of the file at the specified `path`. - `delete_file(path)`: Deletes the file at the specified `path`. Your task is to enhance the functionality of the `SimpleFileSystem` class by implementing additional utility functions: 1. **list_files()**: Lists all file paths in the file system. 2. **file_exists(path)**: Checks if a file exists at the given `path`. 3. **update_file(path, new_content)**: Updates the content of an existing file at the given `path` with `new_content`. # Specification Method Signature ```python def list_files(self) -> list[str] def file_exists(self, path: str) -> bool def update_file(self, path: str, new_content: str) -> None ``` Input * For `list_files()` and `file_exists(path)`, there are no inputs since they operate directly on the file system instance or the provided path. * For `update_file(path, new_content)`, `path` specifies the location of the file to update, and `new_content` is the new content to be written to the file. Output * `list_files()` returns a list of all file paths. * `file_exists(path)` returns a boolean indicating whether the file exists at the specified `path`. * `update_file(path, new_content)` updates the file\'s content and returns None. Constraints * The file paths are strings and follow typical Unix-style path conventions. * Attempting to update a non-existing file should raise a `FileNotFoundError` with the message \\"File not found\\". * Your implementation should be efficient and handle edge cases such as attempting to list files in an empty file system. Example: ```python fs = SimpleFileSystem() fs.create_file(\'/a.txt\', \'Hello\') fs.create_file(\'/b.txt\', \'World\') assert fs.list_files() == [\'/a.txt\', \'/b.txt\'] # [\'/a.txt\', \'/b.txt\'] assert fs.file_exists(\'/a.txt\') == True # True assert fs.file_exists(\'/c.txt\') == False # False assert fs.read_file(\'/a.txt\') == \'Hello\' # \'Hello\' fs.update_file(\'/a.txt\', \'Hello, FileSystem!\') assert fs.read_file(\'/a.txt\') == \'Hello, FileSystem!\' # \'Hello, FileSystem!\' try: fs.update_file(\'/c.txt\', \'New Content\') except FileNotFoundError as e: assert str(e) == \\"File not found\\" fs.delete_file(\'/a.txt\') assert fs.list_files() == [\'/b.txt\'] # [\'/b.txt\'] assert fs.file_exists(\'/a.txt\') == False # False ``` Use the existing `SimpleFileSystem` class framework to implement these additional functionalities.","solution":"class SimpleFileSystem: def __init__(self): self.files = {} def create_file(self, path, content): self.files[path] = content def read_file(self, path): if path in self.files: return self.files[path] else: raise FileNotFoundError(\\"File not found\\") def delete_file(self, path): if path in self.files: del self.files[path] else: raise FileNotFoundError(\\"File not found\\") def list_files(self): return list(self.files.keys()) def file_exists(self, path): return path in self.files def update_file(self, path, new_content): if path in self.files: self.files[path] = new_content else: raise FileNotFoundError(\\"File not found\\")"},{"question":"# Enhanced Word Frequency Counter Context You have been assigned to build a more sophisticated word frequency counter for analyzing textual data. The basic version that counts word frequency needs enhancements to handle varying requirements like ignoring case, filtering out common stop words, and considering word length. Requirements 1. Implement a function `word_frequency` that: * Accurately counts the frequency of each word in the given text, ignoring case. * Optionally excludes common stop words from the count. (Stop words are common words like \\"the\\", \\"and\\", etc. You may use a predefined list of common stop words.) * Optionally considers only words of a specified minimum length. 2. Ensure the function remains efficient (O(n) complexity, where n is the number of words). Implementation Create the `word_frequency` function to include the new features and handle input validation robustly. Allow the user to configure the behavior via optional parameters. # Function Signature ```python def word_frequency(text: str, ignore_stop_words: bool = False, min_length: int = 1) -> dict: pass ``` # Input/Output Specifications * **Input**: * `text` (str): The input text to analyze for word frequency. * `ignore_stop_words` (bool, optional): If set to `True`, the function should exclude common stop words. Defaults to `False`. * `min_length` (int, optional): Specifies the minimum length of words to be included in the count. Defaults to `1`. * **Output**: * (dict): A dictionary where the keys are words and values are the frequencies of those words. # Constraints * Text must be a non-empty string. * Minimum length must be a positive integer. # Examples ```python text = \\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\" stop_words = set([\\"the\\", \\"over\\", \\"was\\", \\"not\\", \\"and\\", \\"a\\", \\"an\\"]) # Example 1: Case insensitive counting assert word_frequency(text) == { \'the\': 2, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 2, \'was\': 1, \'not\': 1, \'amused\': 1 } # Example 2: Ignoring stop words assert word_frequency(text, ignore_stop_words=True) == { \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'lazy\': 1, \'dog\': 2, \'amused\': 1 } # Example 3: Filtering by minimum word length assert word_frequency(text, min_length=4) == { \'quick\': 1, \'brown\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'amused\': 1 } # Example 4: Combination of options assert word_frequency(text, ignore_stop_words=True, min_length=4) == { \'quick\': 1, \'brown\': 1, \'jumps\': 1, \'lazy\': 1, \'amused\': 1 } ```","solution":"from collections import defaultdict import re # Predefined list of common stop words: STOP_WORDS = set([\\"the\\", \\"over\\", \\"was\\", \\"not\\", \\"and\\", \\"a\\", \\"an\\", \\"is\\", \\"in\\", \\"it\\", \\"of\\"]) def word_frequency(text: str, ignore_stop_words: bool = False, min_length: int = 1) -> dict: Returns the frequency of each word in the given text. Args: text (str): Input text to analyze for word frequency. ignore_stop_words (bool, optional): If True, excludes common stop words. Defaults to False. min_length (int, optional): Minimum length of words to include in the count. Defaults to 1. Returns: dict: A dictionary where keys are words and values are frequencies. if not isinstance(text, str) or not text: raise ValueError(\\"Text must be a non-empty string.\\") if not isinstance(min_length, int) or min_length < 1: raise ValueError(\\"Minimum length must be a positive integer.\\") word_freq = defaultdict(int) words = re.findall(r\'bw+b\', text.lower()) for word in words: if len(word) >= min_length: if ignore_stop_words and word in STOP_WORDS: continue word_freq[word] += 1 return dict(word_freq)"},{"question":"Problem Statement You are given a list of cities and the distances between some pairs of these cities in a text file. Each line in the file represents a distance between two cities in the format `CityA,CityB,Distance`, where `CityA` and `CityB` are distinct city names, and `Distance` is a positive integer representing the distance between them. Your task is to write a function to determine the shortest distance required to visit all the cities starting from a given city and returning to the same city, using the distances listed in the file. This is a variant of the Traveling Salesman Problem (TSP). # Input - A single string `filepath` representing the path to the text file. - A single string `start_city` representing the city where the journey starts and ends. # Output - An integer representing the shortest distance required to visit all the cities and return to the starting city. # Constraints - The cities are represented by strings with a maximum length of 20 characters. - Distances between cities are positive integers and can be at most 10,000. - There are at most 10 cities listed in the file. - The distance between any two cities that isn\'t specified in the file should be considered infinite. # Example Consider the following distances in the file: ``` A,B,10 A,C,15 B,C,20 ``` The function `shortest_route(\'cities.txt\', \'A\')` should return `45`, which represents the tour A -> B -> C -> A. # Guidance To solve the problem, implement the following helper functions: 1. `parse_distances(filepath: str) -> Dict[str, Dict[str, int]]`: Parses the distance file and returns a dictionary of distances. 2. `tsp(distances: Dict[str, Dict[str, int]], start_city: str) -> int`: Computes the shortest route using a suitable algorithm like dynamic programming with bit masking or backtracking. # Sample Function Definition ```python def shortest_route(filepath: str, start_city: str) -> int: # Your code here ``` # Note Ensure your solution reads the input file correctly and handles any edge cases appropriately. Consider using the combinatorial nature of the problem efficiently to handle up to 10 cities.","solution":"import itertools import math def parse_distances(filepath: str): distances = {} with open(filepath, \'r\') as file: for line in file: cityA, cityB, dist = line.strip().split(\',\') dist = int(dist) if cityA not in distances: distances[cityA] = {} if cityB not in distances: distances[cityB] = {} distances[cityA][cityB] = dist distances[cityB][cityA] = dist return distances def tsp(distances, start_city): cities = list(distances.keys()) num_cities = len(cities) city_index = {city: idx for idx, city in enumerate(cities)} start_index = city_index[start_city] dp = [[math.inf] * num_cities for _ in range(1 << num_cities)] dp[1 << start_index][start_index] = 0 for mask in range(1 << num_cities): for u in range(num_cities): if mask & (1 << u): for v in range(num_cities): if not (mask & (1 << v)) and u != v and cities[v] in distances[cities[u]]: dp[mask | (1 << v)][v] = min(dp[mask | (1 << v)][v], dp[mask][u] + distances[cities[u]][cities[v]]) return min(dp[(1 << num_cities) - 1][i] + distances[cities[i]].get(start_city, math.inf) for i in range(num_cities)) def shortest_route(filepath: str, start_city: str) -> int: distances = parse_distances(filepath) return tsp(distances, start_city)"},{"question":"# Prime Number Checker with Cache Problem Description: You are to implement a function that checks if a given number is a prime number. To enhance performance, the function should utilize a cache to store previously determined prime numbers. The cache feature helps to avoid redundant calculations for the same number and improves efficiency when checking multiple numbers. Function Signature: ```python def is_prime_with_cache(num: int, cache: dict) -> bool: Checks if a number is prime and uses a cache for previously computed results. Args: - num (int): The number to check for primality. - cache (dict): A dictionary used to store the primality results of numbers. Returns: - bool: True if the number is prime, False otherwise. pass ``` Input: - `num`: An integer representing the number to be checked for primality. - `cache`: A dictionary where the keys are integers and the values are boolean representing whether the key is a prime number or not. Output: - Returns `True` if the number is prime, and `False` otherwise. Constraints: - The input number `num` will be a non-negative integer (0 ≤ num ≤ 10^6). - Update the cache with the primality result after checking if the number is not in the cache. Performance Requirements: - Optimize primality checking to handle large numbers efficiently. - Minimize redundant calculations by effectively using the cache. Example: ```python # Example usage of the function. cache = {} print(is_prime_with_cache(11, cache)) # Output: True print(is_prime_with_cache(4, cache)) # Output: False print(is_prime_with_cache(11, cache)) # Output: True (should utilize the cache) print(is_prime_with_cache(17, cache)) # Output: True ``` Note: You are not required to implement a prime number generation for the cache; the cache should build up with results as the function is called with new numbers.","solution":"def is_prime_with_cache(num: int, cache: dict) -> bool: Checks if a number is prime and uses a cache for previously computed results. Args: - num (int): The number to check for primality. - cache (dict): A dictionary used to store the primality results of numbers. Returns: - bool: True if the number is prime, False otherwise. if num in cache: return cache[num] if num < 2: cache[num] = False return False if num == 2: cache[num] = True return True if num % 2 == 0: cache[num] = False return False max_divisor = int(num**0.5) + 1 for i in range(3, max_divisor, 2): if num % i == 0: cache[num] = False return False cache[num] = True return True"},{"question":"# Question: Implement a Priority Queue Using Heap A priority queue is a data structure that allows for efficient retrieval and removal of the highest (or lowest) priority element. One common way to implement a priority queue is by using a heap, which is a specialized tree-based data structure. Your task is to implement a priority queue with two primary operations: `push`, which adds an element to the queue with a given priority, and `pop`, which removes and returns the element with the highest priority. # Class Definition ```python class PriorityQueue: def __init__(self): self._heap = [] def push(self, item: Any, priority: int) -> None: pass def pop(self) -> Any: pass ``` # Methods - `push(self, item: Any, priority: int) -> None`: Adds `item` to the queue with the specified `priority`. - `pop(self) -> Any`: Removes and returns the item with the highest priority. If the queue is empty, an `IndexError` should be raised. # Usage ```python pq = PriorityQueue() pq.push(\\"task1\\", 3) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 2) print(pq.pop()) # Output should be \\"task1\\" print(pq.pop()) # Output should be \\"task3\\" print(pq.pop()) # Output should be \\"task2\\" ``` # Constraints - Each `push` and `pop` operation should run in `O(log n)` time complexity. - The priority is an integer where a higher value means higher priority. # Implementation Details - Use Python\'s `heapq` library as the underlying heap data structure. - Store elements in the heap as tuples of the form `(priority, count, item)` to ensure the heap property is maintained and to handle items with the same priority. The `count` can be a counter to maintain the order of elements with the same priority. # Edge Cases - Ensure `pop` raises an `IndexError` when called on an empty queue. - Handle items with the same priority correctly. # Example ```python >>> pq = PriorityQueue() >>> pq.push(\\"task1\\", 3) >>> pq.push(\\"task2\\", 1) >>> pq.push(\\"task3\\", 2) >>> pq.pop() \'task1\' >>> pq.pop() \'task3\' >>> pq.pop() \'task2\' >>> pq.pop() IndexError: pop from an empty priority queue ``` # Note A high-level docstring along with `doctests` demonstrating the correctness of your implementation is highly encouraged.","solution":"import heapq from typing import Any class PriorityQueue: def __init__(self): self._heap = [] self._counter = 0 # Counter to handle items with the same priority def push(self, item: Any, priority: int) -> None: heapq.heappush(self._heap, (-priority, self._counter, item)) self._counter += 1 def pop(self) -> Any: if not self._heap: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self._heap)[2]"},{"question":"# Data Anonymizer You are tasked with creating a function that anonymizes sensitive information in a dataset. The function will ensure that personal identifiable information (PII) such as names, email addresses, and phone numbers are anonymized to maintain privacy. Objective: Develop the `anonymize_data` function to: * Replace names with a placeholder string \\"[NAME]\\". * Replace email addresses with a placeholder string \\"[EMAIL]\\". * Replace phone numbers with a placeholder string \\"[PHONE]\\". * Ensure that the input data format (e.g., JSON, dictionary, list) remains consistent in the output. Function Signature: ```python def anonymize_data(data: dict) -> dict: Anonymizes sensitive information in the provided dataset. Args: - data: dict: A dictionary representing the dataset with potential PII. Returns: - dict: The anonymized dataset with placeholder strings replacing sensitive information. ``` Input: * `data` (dict): A dictionary where keys can be strings and values can be nested dictionaries, lists, or strings containing sensitive information. Output: * A dictionary with the same structure as the input, but with PII replaced by placeholder strings. Constraints: * The function should be able to handle various levels of nesting within the dictionary. * Ensure that all instances of names, email addresses, and phone numbers are anonymized. * Typical patterns to be anonymized: - Names: Any string representing a name (e.g., \\"John Doe\\") - assume names have at least one space. - Email Addresses: Any string containing an \\"@\\" symbol (e.g., \\"username@example.com\\"). - Phone Numbers: Any string containing a sequence of digits with common delimiters (e.g., \\"123-456-7890\\", \\"(123) 456-7890\\", \\"1234567890\\"). Example Usage: ```python input_data = { \\"user\\": { \\"name\\": \\"John Doe\\", \\"contact\\": { \\"email\\": \\"john.doe@example.com\\", \\"phone\\": \\"(123) 456-7890\\" }, \\"friends\\": [ { \\"name\\": \\"Jane Smith\\", \\"contact\\": { \\"email\\": \\"jane.smith@example.com\\", \\"phone\\": \\"987-654-3210\\" } } ] } } anonymized_data = anonymize_data(input_data) print(anonymized_data) # Output: # { # \\"user\\": { # \\"name\\": \\"[NAME]\\", # \\"contact\\": { # \\"email\\": \\"[EMAIL]\\", # \\"phone\\": \\"[PHONE]\\" # }, # \\"friends\\": [ # { # \\"name\\": \\"[NAME]\\", # \\"contact\\": { # \\"email\\": \\"[EMAIL]\\", # \\"phone\\": \\"[PHONE]\\" # } # } # ] # } # } ``` # Additional Notes: - Use regular expressions to identify and replace sensitive information. - Ensure that phone numbers in various common formats are correctly anonymized. - Maintain the structure and integrity of the input data format in the output.","solution":"import re def anonymize_data(data): Anonymizes sensitive information in the provided dataset. Args: - data: dict: A dictionary representing the dataset with potential PII. Returns: - dict: The anonymized dataset with placeholder strings replacing sensitive information. # Regular expressions for matching email and phone number patterns email_regex = r\'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b\' phone_regex = r\'((?d{3})?[-.s]?)?d{3}[-.s]?d{4}\' name_regex = r\'b[A-Z][a-z]+s[A-Z][a-z]+b\' # Assuming names are in \\"First Last\\" format if isinstance(data, dict): return {k: anonymize_data(v) for k, v in data.items()} elif isinstance(data, list): return [anonymize_data(item) for item in data] elif isinstance(data, str): data = re.sub(name_regex, \'[NAME]\', data) data = re.sub(email_regex, \'[EMAIL]\', data) data = re.sub(phone_regex, \'[PHONE]\', data) return data else: return data"},{"question":"# Palindrome Subsequence Finder Your goal is to create a function `longest_palindrome_subsequence` that takes a string input and returns the longest subsequence within that string which is a palindrome. A palindrome is a sequence that reads the same backward as forward. Step-by-step Process: 1. **Input Validation**: - Check if the input string is empty. If so, return an empty string. 2. **Dynamic Programming Table**: - Use dynamic programming to build a table where each entry `dp[i][j]` represents the length of the longest palindromic subsequence within the substring from index `i` to `j`. 3. **Table Initialization**: - If a single character, the longest palindromic subsequence is of length 1. 4. **Table Filling**: - For substrings of length greater than 1, fill the table such that: - If `s[i] == s[j]`, then `dp[i][j] = dp[i+1][j-1] + 2` - If `s[i] != s[j]`, then `dp[i][j] = max(dp[i+1][j], dp[i][j-1])` 5. **Result Calculation**: - Use the filled table to backtrack and determine the longest palindromic subsequence. Input: - `s` (string): The input string for which the longest palindromic subsequence is to be found. Output: - `longest_palindrome_subseq` (string): The longest palindromic subsequence within the input string. Constraints: - The input string will contain only lowercase English letters. - The length of the input string will not exceed 1000 characters. Example: ```python def longest_palindrome_subsequence(s): pass # Example usage: print(longest_palindrome_subsequence(\\"bbbab\\")) # Expected Output: \\"bbbb\\" or \\"bbab\\" (both are valid longest palindromic subsequences) ``` **Hint**: Utilize a 2D list (matrix) to store the length of palindromic subsequences for various substrings to optimize the solution.","solution":"def longest_palindrome_subsequence(s): if not s: return \\"\\" n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) lps = [] i, j = 0, n - 1 while i <= j: if s[i] == s[j]: lps.append(s[i]) i += 1 j -= 1 elif dp[i + 1][j] > dp[i][j - 1]: i += 1 else: j -= 1 result = \'\'.join(lps) if len(result) * 2 - 1 == dp[0][n - 1]: return result + result[-2::-1] else: return result + result[::-1]"},{"question":"# Coding Assessment Question Context You are tasked to write a function that counts the number of unique elements in a given list while ignoring the case for string elements. The function should handle and preserve input types robustly, ensuring only valid inputs are processed. Task Write a Python function `count_unique_elements(elements: list) -> int` that takes a list which may contain elements of various types, and returns the count of unique elements, disregarding case for string elements. Raise a `TypeError` if any elements are not hashable. Function Signature ```python def count_unique_elements(elements: list) -> int: pass ``` Inputs - `elements` (list): A list that may contain elements of various types, including strings, numbers, and other hashable types. Output - Returns the count of unique elements, case-insensitive for strings. Constraints - Elements in `elements` can be of any hashable type. - The function should raise a `TypeError` if any element in `elements` is not hashable. Examples ```python >>> count_unique_elements([\\"Hello\\", \\"world\\", \\"hello\\", \\"WORLD\\"]) 2 >>> count_unique_elements([1, 2, 3, 2, 1, 4]) 4 >>> count_unique_elements([\\"Sunny\\", \\"sunny\\", \\"SUNNY\\"]) 1 >>> count_unique_elements([\\"apple\\", \\"banana\\", \\"cherry\\", \\"Apple\\", \\"CHERRY\\"]) 3 >>> count_unique_elements([\\"a\\", \\"A\\", 1, 2, \\"b\\", \\"B\\"]) 4 >>> count_unique_elements([\\"a\\", [1, 2, 3], \\"b\\"]) Traceback (most recent call last): ... TypeError: unhashable type: \'list\' ``` Notes - Consider the edge case of an empty list. - Test the function with lists that contain mixed-type elements. - Handle cases where elements are non-hashable, such as lists or dictionaries, by raising the appropriate error.","solution":"def count_unique_elements(elements: list) -> int: Returns the count of unique elements in a list, ignoring case sensitivity for strings. unique_elements = set() for element in elements: if isinstance(element, str): element = element.lower() try: unique_elements.add(element) except TypeError: raise TypeError(f\\"unhashable type: \'{type(element).__name__}\'\\") return len(unique_elements)"},{"question":"# Coding Assessment Question **Objective:** Implement a function to merge two sorted linked lists into a single sorted linked list. Problem Statement You are given two singly linked lists, each of which is already sorted in ascending order. Your task is to merge these two lists into one sorted doubly linked list. Write a function `merge_sorted_linked_lists` that takes the following inputs: - `list1`: (Node) The head node of the first sorted linked list. - `list2`: (Node) The head node of the second sorted linked list. The function should return the head node of the merged sorted doubly linked list. Constraints - The lists may be of different lengths. - Duplicates should be retained. - The linked list nodes are defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class DoublyListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next ``` Expected Input and Output ```python def merge_sorted_linked_lists( list1: ListNode, list2: ListNode ) -> DoublyListNode: # your implementation here # Example usage: list1 = ListNode(1, ListNode(2, ListNode(4))) list2 = ListNode(1, ListNode(3, ListNode(4))) merged_list_head = merge_sorted_linked_lists(list1, list2) ``` * `Input`: * `list1`: A linked list represented by its head node `ListNode(1, ListNode(2, ListNode(4)))` * `list2`: A linked list represented by its head node `ListNode(1, ListNode(3, ListNode(4)))` * `Output`: The head node of the merged sorted doubly linked list: * The resulting doubly linked list: `DoublyListNode(1) <-> DoublyListNode(1) <-> DoublyListNode(2) <-> DoublyListNode(3) <-> DoublyListNode(4) <-> DoublyListNode(4)` Notes 1. The resulting doubly linked list should be properly sorted. 2. Handle edge cases where one or both input lists may be empty. 3. Ensure proper memory management to avoid any potential leaks. 4. Provide meaningful comments and ensure the code is easily readable.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class DoublyListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next def merge_sorted_linked_lists(list1: ListNode, list2: ListNode) -> DoublyListNode: # Dummy head of the new sorted doubly linked list dummy = DoublyListNode(0) current = dummy current_prev = None while list1 is not None and list2 is not None: if list1.val < list2.val: new_node = DoublyListNode(list1.val) list1 = list1.next else: new_node = DoublyListNode(list2.val) list2 = list2.next # Set current node\'s pointers new_node.prev = current_prev current.next = new_node # Move current pointers forward current_prev = new_node current = new_node # At this point, one of the lists is exhausted remaining_list = list1 if list1 is not None else list2 while remaining_list is not None: new_node = DoublyListNode(remaining_list.val) new_node.prev = current_prev current.next = new_node current_prev = new_node current = new_node remaining_list = remaining_list.next # Return the head of the sorted doubly linked list (skipping the dummy) return dummy.next"},{"question":"# Problem Statement Implement a function `isomorphic(str1: str, str2: str) -> bool` that determines if two given strings `str1` and `str2` are isomorphic. Two strings are isomorphic if the characters in `str1` can be replaced to get `str2`. No two characters may map to the same character, but a character may map to itself. Input * `str1` (string): a string consisting of lower case English letters. * `str2` (string): another string consisting of lower case English letters. Output * Return `True` if `str1` and `str2` are isomorphic, `False` otherwise. Example ```python >>> isomorphic(\\"egg\\", \\"add\\") True >>> isomorphic(\\"foo\\", \\"bar\\") False >>> isomorphic(\\"paper\\", \\"title\\") True >>> isomorphic(\\"abca\\", \\"zbxz\\") True >>> isomorphic(\\"abc\\", \\"defg\\") False ``` # Constraints * Both strings `str1` and `str2` will have lengths between 1 and 100, both inclusive. * The function should execute in linear time, i.e., O(n). # Requirements * Make use of hashmaps to establish character mappings between the strings. * Ensure that the solution correctly handles edge cases such as different string lengths or the smallest size of strings (length 1).","solution":"def isomorphic(str1, str2): Determines if two given strings are isomorphic. if len(str1) != len(str2): return False char_map_str1 = {} char_map_str2 = {} for char1, char2 in zip(str1, str2): if char1 in char_map_str1: if char_map_str1[char1] != char2: return False else: char_map_str1[char1] = char2 if char2 in char_map_str2: if char_map_str2[char2] != char1: return False else: char_map_str2[char2] = char1 return True"},{"question":"# Coding Assessment Question **Context**: In the context of data manipulation and list processing, one often has to reorganize or transform lists to meet certain criteria. One common operation is rotating lists or arrays by a given number of positions. **Question**: Implement a function `rotate_list(nums: List[int], k: int) -> List[int]` that rotates a given list to the right by `k` positions. **Function Signature**: ```python def rotate_list(nums: List[int], k: int) -> List[int]: ``` **Input**: * `nums` (List[int]): A list of integers. * `k` (int): A non-negative integer representing the number of positions to rotate the list. **Output**: * A list of integers that is the result of rotating the input list to the right by `k` positions. **Constraints**: * `1 <= len(nums) <= 1000` * `-10^5 <= nums[i] <= 10^5` * All input parameters are assumed to be valid. * `k` can be greater than the length of `nums`. **Performance Requirements**: * The solution should run with time complexity O(n), where n is the length of the input list. * The solution should use O(1) additional space for rotation in place, excluding the space for the input and output. **Examples**: 1. `rotate_list([1, 2, 3, 4, 5, 6, 7], 3) -> [5, 6, 7, 1, 2, 3, 4]` 2. `rotate_list([1, 2, 3, 4], 4) -> [1, 2, 3, 4]` 3. `rotate_list([1], 0) -> [1]` 4. `rotate_list([1, 2], 3) -> [2, 1]` 5. `rotate_list([], 2) -> []` **Notes**: * Analyze edge cases such as when `k` is 0, when `nums` is empty, or when `k` is a multiple of the length of `nums`. * Consider efficient ways to handle cases where `k` is larger than the length of `nums`. * Ensure the function maintains the order of elements in the correct rotated manner.","solution":"def rotate_list(nums, k): Rotates the given list to the right by k positions and returns the resulting list. :param nums: List[int] - a list of integers :param k: int - number of positions to rotate the list to the right :return: List[int] - result of rotating the input list to the right by k positions if not nums: return [] n = len(nums) k = k % n # Normalize k to ensure k is within the bounds of the list length return nums[-k:] + nums[:-k]"},{"question":"# Problem Statement A robotics company is developing a software module to help their robots navigate through a multi-story building. The robot can move from one position to another, but it must follow a specific rule: it can only move to floors that are reachable via a strict incremental path. # Requirements * Implement a function `find_path_to_destination` that determines if a given list of floor positions represents a valid path the robot can take to reach its destination. * The path is considered valid if each subsequent floor in the list is reachable by moving up exactly one floor higher. * An empty list represents no movement, and should be considered valid. However, single-element lists should be valid if the element is non-negative. # Input and Output * **Input**: A list of integers, `path` representing the sequence of floors the robot will follow. For example: - `[0, 1, 2, 3]` - `[2, 3, 4, 5]` - `[0]` - `[]` - `[1, 2, 4, 5]` * **Output**: A boolean value indicating whether the given path is valid: - `True` if the path is valid. - `False` otherwise. # Constraints 1. An empty list should return `True`. 2. A list with only one floor must contain a non-negative integer. 3. Each subsequent floor must be exactly one floor higher than the previous one for the path to be valid. # Example Scenarios Example 1: * **Input**: `[0, 1, 2, 3]` * **Output**: `True` Example 2: * **Input**: `[2, 3, 4, 5]` * **Output**: `True` Example 3: * **Input**: `[0]` * **Output**: `True` Example 4: * **Input**: `[]` * **Output**: `True` Example 5: * **Input**: `[1, 2, 4, 5]` * **Output**: `False` Example 6: * **Input**: `[2, 5, 6]` * **Output**: `False` Write the function `find_path_to_destination(path: List[int]) -> bool` to perform the validation as described.","solution":"def find_path_to_destination(path): Determines if a given list of floor positions represents a valid path for the robot. Parameters: path (list of int): A list of integers representing floor positions. Returns: bool: True if the path is valid, False otherwise. if not path: return True if len(path) == 1: return path[0] >= 0 for i in range(1, len(path)): if path[i] != path[i - 1] + 1: return False return True"},{"question":"# Chessboard Checker You are tasked with implementing a function to check whether a given 8 x 8 chessboard configuration adheres to the rules of placing rooks. In chess, a rook can move horizontally or vertically any number of squares. The goal is to determine if any two rooks can attack each other directly. Implement a function `is_valid_rook_configuration` that checks if the given chessboard configuration is valid, meaning no two rooks are placed such that they can attack each other. ```python def is_valid_rook_configuration(chessboard: List[List[str]]) -> bool: Check if the given 8x8 chessboard configuration is valid for rooks placement. :param chessboard: 8x8 list of lists containing \'R\' for rook and \'.\' for empty squares :return: True if no two rooks can attack each other, otherwise False pass ``` Requirements: * The function should return `True` if no two rooks can attack each other directly, and `False` otherwise. * The input `chessboard` will always be a list of 8 lists, each containing exactly 8 characters, where \'R\' represents a rook and \'.\' represents an empty square. * Optimize the function to check the validity efficiently without unnecessary computations. Example Usage: ```python chessboard1 = [ [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'R\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'R\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'R\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'R\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'R\', \'.\', \'.\'] ] chessboard2 = [ [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'R\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'R\', \'.\', \'.\', \'R\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'R\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'R\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'R\', \'.\', \'.\'] ] print(is_valid_rook_configuration(chessboard1)) # Expected Output: True print(is_valid_rook_configuration(chessboard2)) # Expected Output: False ``` Additional Considerations: * Consider different optimization strategies to reduce the complexity of the validity check. * Discuss your approach to handling various edge cases, such as empty rows/columns or multiple rooks positioned to potentially attack each other. * Provide a brief explanation of your logic and any assumptions you made while developing your solution.","solution":"def is_valid_rook_configuration(chessboard): Check if the given 8x8 chessboard configuration is valid for rooks\' placement. :param chessboard: 8x8 list of lists containing \'R\' for rook and \'.\' for empty squares :return: True if no two rooks can attack each other, otherwise False # Check rows for rooks for row in chessboard: if row.count(\'R\') > 1: return False # Check columns for rooks for col in range(8): rook_count = 0 for row in range(8): if chessboard[row][col] == \'R\': rook_count += 1 if rook_count > 1: return False return True"},{"question":"# Maximum Subarray Sum **Scenario**: You are given an integer array representing daily stock prices over a period of time. You need to write a function to find the maximum profit you can achieve by buying and selling the stock exactly once within this period. If no profit is possible, you should return 0. **Requirements**: 1. **Function to Calculate Maximum Profit**: Write a function `max_profit(prices: list[int]) -> int`: - **Input**: A list of integers `prices` where each element represents the stock price on a specific day. - **Output**: An integer representing the maximum profit achievable. If no profit can be achieved, return 0. 2. **Algorithm Details**: - The algorithm should run in linear time complexity `O(n)`. - You are allowed to perform only one buy and one sell operation. You cannot sell a stock before buying. 3. **Edge Cases**: - Handle cases where the input list is empty or has only one element, where no transaction can be made. - Ensure that you return 0 if the prices are in a downward trend with no opportunity for a profit. 4. **Performance Constraints**: - Your function should efficiently handle input lists up to 100,000 elements. **Example**: Given the list of stock prices: ``` [7, 1, 5, 3, 6, 4] ``` Your function `max_profit([7, 1, 5, 3, 6, 4])` should return: ``` 5 ``` (Explanation: Buy on day 2 at price 1 and sell on day 5 at price 6, profit = 6 - 1 = 5) Given the list of stock prices: ``` [7, 6, 4, 3, 1] ``` Your function `max_profit([7, 6, 4, 3, 1])` should return: ``` 0 ``` (Explanation: In this case, no transactions can be made, so the maximum profit is 0)","solution":"def max_profit(prices): Returns the maximum profit achievable by buying and selling the stock exactly once. :param prices: A list of integers representing stock prices. :return: An integer representing the maximum profit or 0 if no profit is possible. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Problem Statement You are developing a scheduling system for a university\'s exam resource allocation. The system needs to allocate classrooms to exams in a way that maximizes room utilization. Each classroom has a fixed capacity and each exam has a required capacity. You need to write a function that assigns exams to the available classrooms using a greedy algorithm. Function Signature ```python def schedule_exams(classrooms: list, exams: list) -> list: # Your code here ``` Definitions - `classrooms`: A list of integers, where each integer represents the capacity of a classroom. - `exams`: A list of integers, where each integer represents the required capacity for an exam. Output The function should return a list of tuples, where each tuple contains: 1. An integer representing a classroom\'s capacity. 2. An integer representing the assigned exam\'s required capacity. Constraints - An exam can only be assigned to a classroom if the classroom has enough capacity. - Maximize the number of exams that are assigned to classrooms. - Utilize a greedy algorithm to make the assignments based on classroom and exam capacities. Example Usage ```python classrooms = [100, 50, 200, 150] exams = [80, 40, 120, 60, 180] print(schedule_exams(classrooms, exams)) # Output should reflect the optimal assignment of exams to classrooms, maximizing usage. ``` Notes - An exam cannot be split across multiple classrooms. - If there are multiple ways to assign exams to classrooms, any valid assignment that maximizes the number of exams assigned is acceptable. - Consider how to handle scenarios where not all exams can be allocated to classrooms due to capacity constraints.","solution":"def schedule_exams(classrooms: list, exams: list) -> list: This function assigns exams to classrooms using a greedy algorithm. :param classrooms: A list of integers representing the capacity of each classroom. :param exams: A list of integers representing the required capacity of each exam. :return: A list of tuples where each tuple represents an assignment of an exam to a classroom. # Sort classrooms and exams in ascending order classrooms.sort() exams.sort() assignments = [] j = 0 for exam in exams: while j < len(classrooms) and classrooms[j] < exam: j += 1 if j < len(classrooms): assignments.append((classrooms[j], exam)) j += 1 return assignments"},{"question":"# Coding Question You are given a string containing a digit sequence and a list of words, where each word is mapped to a digit from \'0\' to \'9\'. Your task is to write a function `decode_message(digits: str, word_map: dict) -> str` that takes the digit sequence and the dictionary mapping digits to words as input, and returns the decoded message by replacing each digit in the sequence with its corresponding word from the dictionary. Function Signature ```python def decode_message(digits: str, word_map: dict) -> str: pass ``` Input * `digits`: A string of digits (i.e., \\"0123456789\\"). * `word_map`: A dictionary where keys are single-character strings representing digits (\'0\'-\'9\'), and values are corresponding words. Output * `str`: The decoded message composed of words separated by spaces. Example ```python # Given word_map: # word_map = { # \'0\': \'zero\', # \'1\': \'one\', # \'2\': \'two\', # \'3\': \'three\', # \'4\': \'four\', # \'5\': \'five\', # \'6\': \'six\', # \'7\': \'seven\', # \'8\': \'eight\', # \'9\': \'nine\' # } decode_message(\\"123\\", word_map) # Output: \\"one two three\\" decode_message(\\"98765\\", word_map) # Output: \\"nine eight seven six five\\" ``` Performance Requirements * Your solution should efficiently handle the input size constraints. * It should process and generate the output string within reasonable time and space limits.","solution":"def decode_message(digits: str, word_map: dict) -> str: Returns the decoded message by replacing each digit in the sequence with its corresponding word from the dictionary. return \' \'.join(word_map[digit] for digit in digits)"},{"question":"# Scenario You are developing a simple task management application. This application manages individual tasks and provides the ability to add tasks, mark them as complete, and retrieve both completed and incomplete tasks. Each task is represented by a unique identifier and a description. # Task Implement a class called `TaskManager` that allows for the management of tasks. The class should provide methods to add new tasks, mark tasks as complete, and retrieve lists of completed and incomplete tasks. Function Implementations 1. **add_task(task_id: int, description: str) -> None** - Adds a new task with the given `task_id` and `description`. If a task with the same `task_id` already exists, it should be updated with the new description. 2. **complete_task(task_id: int) -> None** - Marks the task with the given `task_id` as complete. If the task does not exist, do nothing. 3. **get_incomplete_tasks() -> List[Tuple[int, str]]** - Returns a list of tuples where each tuple consists of `task_id` and `description` of incomplete tasks. The tasks should be sorted by their `task_id` in ascending order. 4. **get_completed_tasks() -> List[Tuple[int, str]]** - Returns a list of tuples where each tuple consists of `task_id` and `description` of completed tasks. The tasks should be sorted by their `task_id` in ascending order. Constraints - Task identifiers (`task_id`) are unique and non-negative integers. - Task descriptions are non-empty strings. - The system should handle up to `10^5` tasks. Performance Requirements - The `add_task` and `complete_task` operations should be optimized for insertion and update speed. - The retrieval operations should retrieve the sorted lists efficiently. Example ```python task_manager = TaskManager() # Adding tasks task_manager.add_task(1, \\"Implement login functionality\\") task_manager.add_task(2, \\"Design the user interface\\") task_manager.add_task(3, \\"Set up database schema\\") # Completing a task task_manager.complete_task(1) # Querying tasks print(task_manager.get_incomplete_tasks()) # Output: [(2, \\"Design the user interface\\"), (3, \\"Set up database schema\\")] print(task_manager.get_completed_tasks()) # Output: [(1, \\"Implement login functionality\\")] ``` Implement the `TaskManager` class with the required methods ensuring optimal performance and considering possible edge cases.","solution":"from typing import List, Tuple class TaskManager: def __init__(self): self.tasks = {} self.completed_tasks = set() def add_task(self, task_id: int, description: str) -> None: self.tasks[task_id] = description def complete_task(self, task_id: int) -> None: if task_id in self.tasks: self.completed_tasks.add(task_id) def get_incomplete_tasks(self) -> List[Tuple[int, str]]: return sorted([(task_id, desc) for task_id, desc in self.tasks.items() if task_id not in self.completed_tasks]) def get_completed_tasks(self) -> List[Tuple[int, str]]: return sorted([(task_id, self.tasks[task_id]) for task_id in self.completed_tasks])"},{"question":"# Problem Statement You are helping a library manage its book collection. Your task is to implement a system for checking out and returning books efficiently. Each book has a unique identifier, and the library can have up to 10,000 books. # Requirements Write a class `Library` with the following methods: - `__init__(self)`: Initializes an empty library collection. - `add_book(self, book_id: int) -> None`: Adds a book with the given `book_id` to the library collection. - `remove_book(self, book_id: int) -> bool`: Removes a book with the given `book_id` from the library. Returns `True` if the book was successfully removed, or `False` if the book was not found. - `checkout_book(self, book_id: int) -> bool`: Checks out a book with the given `book_id`. Returns `True` if the book was successfully checked out, or `False` if the book was not found or already checked out. - `return_book(self, book_id: int) -> bool`: Returns a book with the given `book_id` to the library. Returns `True` if the book was successfully returned, or `False` if the book was not found in the library\'s records. # Input Format - There will be multiple method invocations as per the requirements described. # Output Format - The methods will return values as specified: `add_book` returns `None`, `remove_book`, `checkout_book`, and `return_book` return booleans. # Constraints - Each `book_id` is a unique integer within the range ( 1 ) to ( 10^9 ). - The library can contain up to ( 10,000 ) books at a time. - Optimize for both time and space complexity as per the provided constraints. # Example ```python library = Library() library.add_book(1) library.add_book(2) assert library.checkout_book(1) == True assert library.checkout_book(1) == False assert library.return_book(1) == True assert library.return_book(1) == False assert library.remove_book(2) == True assert library.remove_book(2) == False assert library.checkout_book(3) == False assert library.return_book(3) == False ``` # Notes - Ensure that the library accurately tracks the status (available or checked out) of each book. - Edge cases such as attempting to checkout or return a non-existent book should be handled gracefully.","solution":"class Library: def __init__(self): self.books = set() self.checked_out = set() def add_book(self, book_id: int) -> None: self.books.add(book_id) def remove_book(self, book_id: int) -> bool: if book_id in self.books: self.books.remove(book_id) self.checked_out.discard(book_id) # Just to ensure it\'s not in checked_out when removed return True return False def checkout_book(self, book_id: int) -> bool: if book_id in self.books and book_id not in self.checked_out: self.checked_out.add(book_id) return True return False def return_book(self, book_id: int) -> bool: if book_id in self.checked_out: self.checked_out.remove(book_id) return True return False"},{"question":"# Coding Assessment Question Problem Context: In a grid-based city, there are several delivery points represented as 2D coordinates in the format (x, y). The starting point of the delivery truck is at the origin (0, 0). The delivery truck must visit each delivery point and return to the origin. You need to determine if there is a valid path that the delivery truck can take to visit all delivery points exactly once and return to the origin. Task: Write a function that determines if the above condition can be satisfied given a list of delivery points. If such a path exists, return `True`; otherwise, return `False`. Function Signature: ```python def valid_delivery_path(points: List[Tuple[int, int]]) -> bool: ``` Input: * A list of tuples `points`, where each tuple represents a delivery point\'s (x, y) coordinates. The length of the list is between 1 and 10 inclusive, and each coordinate is an integer between -1000 and 1000 inclusive. Output: * A boolean: `True` if there exists a valid path that visits each delivery point exactly once and returns to the origin, otherwise `False`. Constraints: * Consider the constraints and aim for an efficient solution. * Handle edge cases where points might be collinear or uniquely positioned. Example: ```python >>> valid_delivery_path([(1, 2), (3, 4), (5, 6)]) True >>> valid_delivery_path([(1, 2), (1, 2)]) False >>> valid_delivery_path([(-1, -2), (2, 3), (4, 5)]) True >>> valid_delivery_path([(0, 2)]) True ``` Notes: * The function must ensure that each delivery point is visited exactly once and the truck returns to the origin. * Think about pathfinding and graph traversal techniques that ensure optimal visits in reasonable computational time.","solution":"from itertools import permutations def valid_delivery_path(points): Determines if there exists a valid path that visits each delivery point exactly once and returns to the origin (0,0). def distance(p1, p2): Compute the Manhattan distance between two points p1 and p2. return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) origin = (0, 0) # Check all possible permutations of the points for perm in permutations(points): valid = True current = origin # Check the path from the origin to the first point to the last point back to the origin for point in perm: if distance(current, point) == 0: valid = False break current = point if valid and distance(current, origin) != 0: return True return False"},{"question":"# Question: Sum of Subset Differences Given an array of integers, you are to calculate the sum of absolute differences between every subset\'s elements and the overall sum of all these differences. The task is to help you understand subset generation and combinatorial calculations. # Your Task Implement the function `sum_of_subset_differences(arr: List[int]) -> int` that computes and returns the sum of the absolute differences between the elements of all possible subsets of the input array. **Requirements:** 1. You need to consider all possible subsets of the array. 2. For each subset, calculate the sum of absolute differences between every pair of elements. 3. Sum and return the values obtained from all subsets. # Input Format - **arr**: A list of integers. # Output Format The function should return an integer representing the total sum of absolute differences between elements of all subsets. # Constraints 1. (1 leq text{len(arr)} leq 15): The length of the array will be in the range 1 to 15. 2. (|arr[i]| leq 10^3): Each integer in the array will be between (-1000) and (1000) inclusive. # Example ```python def sum_of_subset_differences(arr: List[int]) -> int: >>> sum_of_subset_differences([1, 2, 3]) 8 >>> sum_of_subset_differences([4, 5, 6]) 8 pass ``` **Notes**: - Include the empty subset, which does not contribute to the sum. - Calculate the sum of absolute differences for subsets in an efficient manner. # Submission Complete the function `sum_of_subset_differences` as specified above to correctly sum the differences of all subsets.","solution":"from itertools import combinations from typing import List def sum_of_subset_differences(arr: List[int]) -> int: def subset_difference(subset): diff_sum = 0 for i in range(len(subset)): for j in range(i + 1, len(subset)): diff_sum += abs(subset[i] - subset[j]) return diff_sum total_sum = 0 for r in range(1, len(arr) + 1): for subset in combinations(arr, r): total_sum += subset_difference(subset) return total_sum"},{"question":"# Question: Implementation of Common Distance Metrics In this task, you will implement functions to compute various distance metrics, which are essential tools in machine learning and data analysis for comparing and understanding the similarity between data points. Objectives: 1. Implement the following distance metrics: 1. **Euclidean Distance** 2. **Manhattan Distance** 3. **Cosine Similarity** 4. **Hamming Distance** 2. Your implementations should handle edge cases and raise appropriate errors for invalid inputs. Function Specifications: **Euclidean Distance** ```python def euclidean_distance(v1: np.ndarray, v2: np.ndarray) -> float: Parameters: - v1: First vector of shape (n_dimensions,) - v2: Second vector of shape (n_dimensions,) Returns: - float: Euclidean distance between `v1` and `v2` ``` **Manhattan Distance** ```python def manhattan_distance(v1: np.ndarray, v2: np.ndarray) -> float: Parameters: - v1: First vector of shape (n_dimensions,) - v2: Second vector of shape (n_dimensions,) Returns: - float: Manhattan distance between `v1` and `v2` ``` **Cosine Similarity** ```python def cosine_similarity(v1: np.ndarray, v2: np.ndarray) -> float: Parameters: - v1: First vector of shape (n_dimensions,) - v2: Second vector of shape (n_dimensions,) Returns: - float: Cosine similarity between `v1` and `v2` ``` **Hamming Distance** ```python def hamming_distance(v1: np.ndarray, v2: np.ndarray) -> float: Parameters: - v1: First binary vector of shape (n_dimensions,) - v2: Second binary vector of shape (n_dimensions,) Returns: - float: Hamming distance between `v1` and `v2` ``` Constraints: 1. Ensure the input vectors (`v1` and `v2`) are numpy arrays. 2. Handle mismatched lengths of input arrays using appropriate error messages. 3. Ensure values in `v1` and `v2` are properly formatted as per function requirements. 4. Implement the distance computations efficiently, using numpy operations where applicable. Example Usage: ```python v1 = np.array([1, 2, 3]) v2 = np.array([4, 5, 6]) print(euclidean_distance(v1, v2)) # Output: 5.196152422706632 v1 = np.array([1, 0, 1, 0]) v2 = np.array([1, 1, 0, 0]) print(hamming_distance(v1, v2)) # Output: 0.5 v1 = np.array([1, 2, 3]) v2 = np.array([4, 5, 6]) print(manhattan_distance(v1, v2)) # Output: 9.0 v1 = np.array([1, 0, 1, 1]) v2 = np.array([1, 1, 0, 1]) print(cosine_similarity(v1, v2)) # Output: 0.7745966692414834 ``` You need to write these functions from scratch. You\'re encouraged to use vectorized numpy operations for efficient computation. Good luck!","solution":"import numpy as np def euclidean_distance(v1: np.ndarray, v2: np.ndarray) -> float: Returns the Euclidean distance between v1 and v2. if len(v1) != len(v2): raise ValueError(\\"Input vectors must have the same length.\\") return np.linalg.norm(v1 - v2) def manhattan_distance(v1: np.ndarray, v2: np.ndarray) -> float: Returns the Manhattan distance between v1 and v2. if len(v1) != len(v2): raise ValueError(\\"Input vectors must have the same length.\\") return np.sum(np.abs(v1 - v2)) def cosine_similarity(v1: np.ndarray, v2: np.ndarray) -> float: Returns the Cosine similarity between v1 and v2. if len(v1) != len(v2): raise ValueError(\\"Input vectors must have the same length.\\") dot_product = np.dot(v1, v2) norm_v1 = np.linalg.norm(v1) norm_v2 = np.linalg.norm(v2) if norm_v1 == 0 or norm_v2 == 0: raise ValueError(\\"Input vectors must not be zero vectors.\\") return dot_product / (norm_v1 * norm_v2) def hamming_distance(v1: np.ndarray, v2: np.ndarray) -> float: Returns the Hamming distance between v1 and v2. if len(v1) != len(v2): raise ValueError(\\"Input vectors must have the same length.\\") if not all(elem in [0, 1] for elem in np.concatenate((v1, v2))): raise ValueError(\\"Input vectors must be binary (contain only 0s and 1s).\\") return np.mean(v1 != v2)"},{"question":"# Scenario A database administrator needs to sanitize user-input data before storing it in the database to prevent SQL injection attacks. They decide to implement a simple escape mechanism that ensures any single quotes (`\'`) in the user input are properly escaped by doubling them up (`\'\'`). You need to write a function that performs this sanitization. # Task Write a Python function `sanitize_input(input_string: str) -> str` that takes a user input string and returns a sanitized version where every single quote is replaced by two single quotes. # Requirements - Replace every occurrence of a single quote with two single quotes - Do not use any third-party libraries, rely solely on Python\'s string methods - Handle edge cases such as empty strings and strings without single quotes # Input and Output - **Input**: A single string `input_string` that may contain any characters - **Output**: A sanitized string with single quotes properly escaped # Examples ```python >>> sanitize_input(\\"O\'Reilly\\") \\"O\'\'Reilly\\" >>> sanitize_input(\\"It\'s a test.\\") \\"It\'\'s a test.\\" >>> sanitize_input(\\"No quotes here\\") \\"No quotes here\\" >>> sanitize_input(\\"\\") \\"\\" ``` # Performance Requirements - The solution should handle inputs efficiently even if the input string is large. Create a Python function `sanitize_input` following the described specifications.","solution":"def sanitize_input(input_string: str) -> str: Takes a user input string and returns a sanitized version where every single quote is replaced by two single quotes. return input_string.replace(\\"\'\\", \\"\'\'\\")"},{"question":"# Context In competitive programming and algorithm design, one common challenge is efficient array manipulation. Let\'s consider the problem of subarray sums. A subarray is a contiguous part of an array. The sum of a subarray is the total of all its elements. Given an array of integers, you may need to answer queries to find the maximum sum of any subarray within a specified range of indices. # Problem Statement You need to implement a function `max_subarray_sum_in_range(arr, queries)` that takes an array of integers and a list of query ranges, where each query is a tuple (start_index, end_index). For each query, the function should return the maximum sum of all possible subarrays within the given range. # Function Signature ```python def max_subarray_sum_in_range(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: pass ``` # Input and Output * **Input**: - `arr` (List[int]): A list of integers representing the array. - `queries` (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers representing the start and end indices of the subarray range to consider. * **Output**: - `List[int]`: A list of integers where each integer is the maximum subarray sum for the corresponding query range. # Constraints * `1 <= len(arr) <= 10^5` * `1 <= len(queries) <= 10^4` * `-10^4 <= arr[i] <= 10^4` * `0 <= start_index <= end_index < len(arr)` # Performance Requirements The function should be optimized to handle large inputs efficiently. Consider using algorithms with complexity O(n) or O(n log n) where feasible. # Example ```python arr = [1, -2, 3, -1, 2] queries = [(0, 4), (1, 3), (2, 4)] result = max_subarray_sum_in_range(arr, queries) print(result) # Expected output: [4, 3, 4] ``` # Implementation Notes To solve this problem: 1. For each query range, extract the subarray defined by the start and end indices. 2. Use Kadane\'s Algorithm to find the maximum subarray sum within this range. By efficiently handling each range query and applying Kadane\'s Algorithm, you can ensure that the solution scales with larger inputs. --- This question assesses the candidate\'s ability to understand subarrays, perform range queries, and apply Kadane\'s Algorithm efficiently. Ensure your solution is optimal and can handle the largest possible inputs within the constraints.","solution":"def max_subarray_sum_in_range(arr, queries): Returns the maximum sum of subarrays within the specified ranges in queries. def kadanes_algorithm(subarray): Helper function to use Kadane\'s Algorithm for finding max subarray sum. max_current = max_global = subarray[0] for num in subarray[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global results = [] for start, end in queries: subarray = arr[start:end+1] results.append(kadanes_algorithm(subarray)) return results"},{"question":"# Problem Statement You are required to implement a spell-checking program using the concept of a Trie data structure. The Trie will store a dictionary of words, and the spell-checker will identify any misspelled words in the given input text by comparing it with the dictionary. # Objectives 1. **Trie Construction**: Implement the `Trie` class that allows inserting words and checking if a word exists. 2. **Spell-checking**: Implement a function that utilizes the Trie to check for any misspelled words in the provided text and return them. # Function Signatures - `__init__(self)` - `insert(self, word: str) -> None` - `search(self, word: str) -> bool` - `check_text(self, text: str) -> list[str]` # Example ```python T = Trie() T.insert(\\"apple\\") T.insert(\\"banana\\") T.insert(\\"grape\\") result = T.check_text(\\"I ate an apel and a banana.\\") print(result) # Output: [\'apel\'] ``` # Constraints - Dictionary words are non-empty strings, each up to 50 characters in length. - Text length can be up to 10^5 characters. - Total number of dictionary words will not exceed 10^4. # Hints 1. Use the Trie to store each word in the dictionary and mark the end of each word. 2. When checking the text, split it into words and verify each word against the Trie. # Performance Requirements - Your solution should efficiently handle up to the maximum constraints within acceptable time limits.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def check_text(self, text: str) -> list[str]: misspelled_words = [] words = text.split() for word in words: # Remove punctuation from word word = \'\'.join(char for char in word if char.isalpha()) if not self.search(word): misspelled_words.append(word) return misspelled_words"},{"question":"# Simple Text Compression using Run-Length Encoding Objective: **Write a function that compresses a given string using Run-Length Encoding (RLE), and another function that decompresses an RLE encoded string back to its original form.** Task: Implement two functions: **1. `compress_string(s)`** - Parameters: * `s` (str): The input string to be compressed. - Returns: * `str`: The run-length encoded string. **2. `decompress_string(rle)`** - Parameters: * `rle` (str): The run-length encoded string. - Returns: * `str`: The decompressed original string. Constraints: * The input string `s` will contain only uppercase alphabetic characters (A-Z). * The length of the string can be up to 1000 characters. * The compressed string should be in the format where each pair consists of an uppercase letter and a positive integer, representing the letter and its frequency. Example Input: ```python s = \\"AAABBBCCCAAA\\" ``` Example Output: ```python compressed = \\"A3B3C3A3\\" decompressed = \\"AAABBBCCCAAA\\" ``` Function Signature: ```python def compress_string(s: str) -> str: pass def decompress_string(rle: str) -> str: pass ``` Brief Scenario: Imagine you are dealing with a text containing repeated sequences of characters, and you need to compress the text to save space. Run-Length Encoding (RLE) is a simple compression algorithm where consecutive repeated characters are replaced by the character followed by the number of its repetitions. For instance, \\"AAABBB\\" becomes \\"A3B3\\", significantly reducing the length when there are many repetitions. Likewise, you need a function to revert the compressed representation back to the original string, ensuring that no data is lost in the process. ```python def compress_string(s: str) -> str: if not s: return \\"\\" result = [] count = 1 previous_char = s[0] for char in s[1:]: if char == previous_char: count += 1 else: result.append(previous_char + str(count)) previous_char = char count = 1 result.append(previous_char + str(count)) return \\"\\".join(result) def decompress_string(rle: str) -> str: if not rle: return \\"\\" result = [] i = 0 n = len(rle) while i < n: char = rle[i] j = i + 1 count = 0 while j < n and rle[j].isdigit(): count = count * 10 + int(rle[j]) j += 1 result.append(char * count) i = j return \\"\\".join(result) # Example usage: compressed = compress_string(\\"AAABBBCCCAAA\\") print(compressed) # Output: \\"A3B3C3A3\\" decompressed = decompress_string(compressed) print(decompressed) # Output: \\"AAABBBCCCAAA\\" ```","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" result = [] count = 1 previous_char = s[0] for char in s[1:]: if char == previous_char: count += 1 else: result.append(previous_char + str(count)) previous_char = char count = 1 result.append(previous_char + str(count)) return \\"\\".join(result) def decompress_string(rle: str) -> str: if not rle: return \\"\\" result = [] i = 0 n = len(rle) while i < n: char = rle[i] j = i + 1 count = 0 while j < n and rle[j].isdigit(): count = count * 10 + int(rle[j]) j += 1 result.append(char * count) i = j return \\"\\".join(result)"},{"question":"# Context You are tasked with implementing a function that finds all the possible ways to decode a given string of digits into alphabetical characters. The encoding rule is: \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26. You need to return the total number of ways to decode the string. # Task Implement a function `num_decodings(s: str) -> int` that returns the number of possible ways to decode the input string `s`. # Inputs - `s` - a string of digits, containing only characters from \'0\' to \'9\'. # Outputs - Return an integer representing the total number of ways to decode the string. # Constraints 1. 1 <= len(s) <= 100 2. Each character in the string `s` is a digit (\'0\'-\'9\'). # Performance Requirements - Your solution should have a time complexity of O(n) and a space complexity of O(n), where `n` is the length of the input string `s`. # Example ```python # Input s = \\"226\\" # Expected Output result = 3 # Explanation There are three ways to decode \\"226\\": \\"2 26\\" -> \\"BZ\\" \\"22 6\\" -> \\"VF\\" \\"2 2 6\\" -> \\"BBF\\" ``` # Edge Cases 1. If the string `s` is empty, the result should be 0. 2. If the string contains \'0\' without a preceding valid two-digit number (like \'10\' or \'20\'), the result should be 0 because \'0\' cannot be mapped to any character. Implement the function `num_decodings` to solve the problem efficiently.","solution":"def num_decodings(s): Returns the number of ways to decode the string s. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): if s[i - 1] != \'0\': dp[i] += dp[i - 1] if 10 <= int(s[i - 2:i]) <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Problem Statement Create a class `EventCounter` that efficiently tracks events and answers common queries on the recorded events. The `EventCounter` must support the following operations: 1. **Add Event**: Record an event that happened at a specific timestamp. 2. **Query Events Count**: Return the number of events that occurred within a given time range (inclusive). 3. **Delete Events Before**: Remove all events that occurred before a specific timestamp. # Function Signatures ```python class EventCounter: def __init__(self) -> None: Initializes the data structure. def add_event(self, timestamp: int) -> None: Records an event at the given timestamp. def query_events_count(self, start_time: int, end_time: int) -> int: Returns the number of events between the start_time and end_time (inclusive). def delete_events_before(self, timestamp: int) -> None: Deletes all events that occurred before the given timestamp. ``` # Input Constraints - Timestamps will be non-negative integers. - There may be up to `10^6` events recorded. - The timestamps for the events are not necessarily unique. - The `query_events_count` and `delete_events_before` operations can be called frequently. # Example Usage ```python # Initialize the EventCounter event_counter = EventCounter() # Add events at different timestamps event_counter.add_event(1) event_counter.add_event(2) event_counter.add_event(3) event_counter.add_event(3) # Query the count of events from timestamp 1 to 3 print(event_counter.query_events_count(1, 3)) # Output: 4 # Delete events that happened before timestamp 3 event_counter.delete_events_before(3) # Query again the count of events from timestamp 1 to 3 print(event_counter.query_events_count(1, 3)) # Output: 2 # Add more events event_counter.add_event(5) event_counter.add_event(5) event_counter.add_event(6) # Query the count of events from timestamp 4 to 6 print(event_counter.query_events_count(4, 6)) # Output: 3 ``` # Constraints - Edge cases such as no events in the counter, invalid range for querying, and high volume of events should be considered. - Aim to optimize the performance of the add, query, and delete operations to handle frequent operations efficiently.","solution":"import bisect class EventCounter: def __init__(self) -> None: Initializes the event counter with an empty list. self.events = [] def add_event(self, timestamp: int) -> None: Records an event at the given timestamp. bisect.insort(self.events, timestamp) def query_events_count(self, start_time: int, end_time: int) -> int: Returns the number of events between the start_time and end_time (inclusive). left = bisect.bisect_left(self.events, start_time) right = bisect.bisect_right(self.events, end_time) return right - left def delete_events_before(self, timestamp: int) -> None: Deletes all events that occurred before the given timestamp. index = bisect.bisect_left(self.events, timestamp) self.events = self.events[index:]"},{"question":"# Question: Implement a Morse Code Converter You are required to implement a class `MorseCodeConverter` with methods to encode and decode messages using Morse code. Your implementation should follow the standards below: Class: `MorseCodeConverter` Methods: 1. **`to_morse(self, message: str) -> str`**: * Input: A message (str) to be encoded. * Output: The encoded message in Morse code (str). Words should be separated by spaces and letters within a word should be separated by a single space. * Example: `MorseCodeConverter().to_morse(\'hello world\')` should return `.... . .-.. .-.. --- / .-- --- .-. .-.. -..`. 2. **`from_morse(self, message: str) -> str`**: * Input: An encoded message in Morse code (str). * Output: The decoded message (str). Assume Morse code letters are separated by single spaces and words by slashes (`/`). * Example: `MorseCodeConverter().from_morse(\'.... . .-.. .-.. --- / .-- --- .-. .-.. -..\')` should return `hello world`. Constraints: * The message will contain only lowercase and uppercase letters and spaces. * The Morse code dictionary should be implemented within the class for the necessary conversions. ```python class MorseCodeConverter: MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'0\': \'-----\', \', \': \'--..--\', \'.\': \'.-.-.-\', \'?\': \'..--..\', \'/\': \'-..-.\', \'-\': \'-....-\', \'(\': \'-.--.\', \')\': \'-.--.-\', \' \': \'/\' } def to_morse(self, message: str) -> str: # Implement this method pass def from_morse(self, message: str) -> str: # Implement this method pass # Example Usage: # converter = MorseCodeConverter() # encoded_message = converter.to_morse(\\"Hello World\\") # decoded_message = converter.from_morse(encoded_message) # print(f\\"Encoded: {encoded_message}, Decoded: {decoded_message}\\") ``` This question tests your understanding of string manipulation, dictionary usage, and basic encoding and decoding principles in Python.","solution":"class MorseCodeConverter: MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'0\': \'-----\', \', \': \'--..--\', \'.\': \'.-.-.-\', \'?\': \'..--..\', \'/\': \'-..-.\', \'-\': \'-....-\', \'(\': \'-.--.\', \')\': \'-.--.-\', \' \': \'/\' } @staticmethod def to_morse(message: str) -> str: message = message.upper() morse_message = \' \'.join(MorseCodeConverter.MORSE_CODE_DICT[char] for char in message) return morse_message @staticmethod def from_morse(message: str) -> str: morse_to_char = {v: k for k, v in MorseCodeConverter.MORSE_CODE_DICT.items()} decoded_message = \'\'.join(morse_to_char[code] for code in message.split(\' \')) return decoded_message.replace(\'/\', \' \')"},{"question":"# Matrix Column Mean You are given a matrix represented as a list of lists, where each sublist is a row of the matrix. Your task is to perform the following operations: 1. `column_means(matrix: List[List[float]]) -> List[float]`: This function computes the mean of each column in the matrix. 2. `scale_columns(matrix: List[List[float]], factors: List[float]) -> List[List[float]]`: This function scales each column in the matrix by the corresponding factor from the factors list. Task Write a function `compute_and_scale(matrix: List[List[float]]) -> Tuple[List[float], List[List[float]]]` which combines the functionality of the above two functions: - The function should first calculate the means of each column. - Then, it scales each column of the matrix by the mean of that column. - Return both the means of the columns and the scaled matrix. Input: - `matrix` (List[List[float]]): A non-empty list of lists containing floats, where each sublist is of the same length. Output: - A tuple with: - A list of floats representing the means of the columns. - A matrix (list of lists) where each column has been scaled by its mean. Constraints: - Each row in the matrix contains the same number of elements. - The matrix is non-empty. - The matrix can contain only non-zero floats to avoid division by zero during scaling. Examples: 1. **Input**: ``` matrix = [ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ] ``` **Output**: ``` ([ 4.0, 5.0, 6.0 ], [ [0.25, 0.4, 0.5], [1.0, 1.0, 1.0], [1.75, 1.6, 1.5] ]) ``` 2. **Input**: ``` matrix = [ [10.0, 20.0], [30.0, 40.0], [50.0, 60.0] ] ``` **Output**: ``` ([ 30.0, 40.0 ], [ [0.3333333333333333, 0.5], [1.0, 1.0], [1.6666666666666667, 1.5] ]) ``` 3. **Input**: ``` matrix = [ [2.0, 4.0, 6.0], [8.0, 10.0, 12.0] ] ``` **Output**: ``` ([ 5.0, 7.0, 9.0 ], [ [0.4, 0.5714285714285714, 0.6666666666666666], [1.6, 1.4285714285714286, 1.3333333333333333] ]) ``` Additional Requirements: - Ensure to handle edge cases such as matrices with only one row or one column. - Handle matrices with varying content values but ensure all values in the matrix are non-zero for valid scaling operations.","solution":"from typing import List, Tuple def column_means(matrix: List[List[float]]) -> List[float]: num_rows = len(matrix) num_cols = len(matrix[0]) means = [sum(matrix[row][col] for row in range(num_rows)) / num_rows for col in range(num_cols)] return means def scale_columns(matrix: List[List[float]], factors: List[float]) -> List[List[float]]: num_rows = len(matrix) num_cols = len(matrix[0]) scaled_matrix = [[matrix[row][col] / factors[col] for col in range(num_cols)] for row in range(num_rows)] return scaled_matrix def compute_and_scale(matrix: List[List[float]]) -> Tuple[List[float], List[List[float]]]: means = column_means(matrix) scaled_matrix = scale_columns(matrix, means) return means, scaled_matrix"},{"question":"# Coding Assessment Question You are required to design a function that analyzes temperature data from a JSON file and identifies the top three highest and lowest temperature readings along with their respective dates. The function should parse the input JSON file, process the data, and handle potential data inconsistencies. Function Specification **Function Name**: `analyze_temperatures` **Input Parameters**: 1. `file_path`: (str) Path to the JSON file containing the temperature data. **Output**: - Returns a dictionary with two keys: `highest` and `lowest`. - The `highest` key maps to a list of three dictionaries. - The `lowest` key maps to a list of three dictionaries. - Each dictionary within these lists contains: - `date`: (str) Date of the temperature reading in `YYYY-MM-DD` format. - `temperature`: (float) The temperature reading. **Constraints**: - The JSON file should contain an array of objects where each object has a `date` and `temperature` field. - Handle cases where the JSON file has less than three temperature readings by returning as many readings as available. - Manage and implement data parsing robustly to handle unexpected data types or missing fields. Example Usage ```python def analyze_temperatures(file_path: str) -> dict: # Your implementation here pass # Example call results = analyze_temperatures(\\"temperature_data.json\\") print(\\"Highest temperatures:\\", results[\'highest\']) print(\\"Lowest temperatures:\\", results[\'lowest\']) ``` # Requirements: 1. **Error Handling**: Implement proper error handling for file access issues, JSON parsing errors, and missing data fields. 2. **Sorting and Selection**: Efficiently sort and select the top three highest and lowest temperatures. 3. **Data Validation**: Ensure the function validates the presence and correctness of the `date` and `temperature` fields. 4. **Clear Documentation and Code**: Provide meaningful function and variable names, and ensure your code is well-documented. You have 2 hours to complete this task. Good luck!","solution":"import json def analyze_temperatures(file_path: str) -> dict: try: with open(file_path, \'r\') as file: data = json.load(file) except FileNotFoundError: raise FileNotFoundError(f\\"File not found: {file_path}\\") except json.JSONDecodeError: raise ValueError(f\\"Error decoding JSON from file: {file_path}\\") temperatures = [] for entry in data: if \'date\' in entry and \'temperature\' in entry: date = entry[\'date\'] try: temperature = float(entry[\'temperature\']) temperatures.append({\'date\': date, \'temperature\': temperature}) except ValueError: continue sorted_temperatures = sorted(temperatures, key=lambda x: x[\'temperature\']) return { \'highest\': sorted_temperatures[-3:][::-1], \'lowest\': sorted_temperatures[:3] }"},{"question":"Coding Challenge: Game of Numbers - Maximum Subarray Sum # Objective: Write a function that takes an integer array as input and finds the contiguous subarray (containing at least one element) which has the largest sum. The function should return the sum of this subarray. # Game Description: Given an integer array `nums`, you are required to find the subarray (contiguous elements) that has the maximum sum, and return this sum. The problem can be solved using the well-known Kadane\'s Algorithm for finding the maximum subarray sum in linear time. # Function Specification: Implement the following function: ```python def max_subarray_sum(nums: List[int]) -> int: Calculate the maximum sum of a contiguous subarray in the given list of integers. Parameters: nums (List[int]): A list of integers (both positive and negative). Returns: int: The maximum sum of a contiguous subarray. pass ``` # Input: * `nums`: A list of integers, where `1 ≤ len(nums) ≤ 10^5` and `-10^4 ≤ nums[i] ≤ 10^4`. # Output: * An integer representing the maximum sum of a contiguous subarray. # Example: ```python print(max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4])) # Expected output: 6 print(max_subarray_sum([1])) # Expected output: 1 print(max_subarray_sum([5,4,-1,7,8])) # Expected output: 23 ``` # Constraints: * The `nums` list contains at least one number and at most 100,000 numbers. * The numbers in the `nums` list are within the range of -10,000 to 10,000. # Additional Notes: * The function should efficiently handle large arrays. * Kadane\'s Algorithm is an efficient approach to solve this problem with a time complexity of O(n). # Guideline: * Initialize two variables: `current_sum` to keep track of the sum of the current subarray and `max_sum` to store the maximum sum found so far. * Iterate through the array to update the `current_sum` and `max_sum`. * Ensure to account for negative numbers and consider edge cases such as all negative numbers in the array. Good luck!","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Calculate the maximum sum of a contiguous subarray in the given list of integers. Parameters: nums (List[int]): A list of integers (both positive and negative). Returns: int: The maximum sum of a contiguous subarray. # Initialize the current sum and the maximum sum with the first element. current_sum = max_sum = nums[0] # Loop through the array starting from the second element. for num in nums[1:]: # Update current sum either by adding the current number or starting a new subarray from current number. current_sum = max(num, current_sum + num) # Update the max_sum if current_sum is greater than max_sum found so far. max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Scenario You are developing a feature for a social media application that allows users to create and interact with groups. Each group has a unique ID, a name, and a list of user IDs who are members of the group. Implement a function to find the largest group based on the number of members. # Task Write a Python function, `find_largest_group()`, that processes a list of groups and returns the details of the group with the highest number of members. # Requirements 1. **Function Signature**: ```python def find_largest_group(groups: list[dict[str, int | str | list[int]]]) -> dict[str, int | str | list[int]]: ``` 2. **Input**: A list of dictionaries, where each dictionary represents a group and contains the following keys: * `GroupID`: An integer that uniquely identifies the group. * `Name`: The name of the group as a string. * `Members`: A list of integers representing the user IDs of the group\'s members. 3. **Output**: A dictionary containing the following keys and their corresponding values for the group with the most members: * `GroupID`: The unique ID of the group. * `Name`: The name of the group. * `Members`: The list of user IDs who are members of the group. 4. **Constraints**: * If two or more groups have the same largest number of members, return the details of the first one that appears in the input list. * Handle edge cases such as an empty input list or groups with no members gracefully. # Example ```python groups = [ {\\"GroupID\\": 1, \\"Name\\": \\"Developers\\", \\"Members\\": [101, 102, 103]}, {\\"GroupID\\": 2, \\"Name\\": \\"Designers\\", \\"Members\\": [201, 202]}, {\\"GroupID\\": 3, \\"Name\\": \\"Managers\\", \\"Members\\": [301, 302, 303, 304]} ] print(find_largest_group(groups)) ``` Expected Output ```python { \\"GroupID\\": 3, \\"Name\\": \\"Managers\\", \\"Members\\": [301, 302, 303, 304] } ``` # Additional Guidelines * Ensure your function efficiently handles the input list and returns the correct result. * Write a few test cases to validate your implementation. * Remember to handle possible edge cases such as an empty groups list or a group with no members.","solution":"def find_largest_group(groups): Returns the largest group based on the number of members. Args: groups (list): A list of dictionaries, where each dictionary represents a group. Returns: dict: The group with the highest number of members. if not groups: return {} largest_group = groups[0] max_members_count = len(groups[0][\'Members\']) for group in groups[1:]: current_members_count = len(group[\'Members\']) if current_members_count > max_members_count: largest_group = group max_members_count = current_members_count return largest_group"},{"question":"# Question: Implement a k-Nearest Neighbors (k-NN) Classifier You are provided a dataset with features and corresponding class labels. Write code to implement a k-Nearest Neighbors (k-NN) classifier to classify new samples based on the given dataset. Requirements: 1. Implement the `train_knn()` function that stores the training data. 2. Implement the `predict_knn()` function that classifies new samples based on the k-nearest neighbors algorithm. 3. The `predict_knn()` function should take the feature matrix, class labels, new sample, and the number of neighbors `k` as input. Function Signature: ```python def train_knn(features: np.ndarray, labels: np.ndarray) -> None: def predict_knn(features: np.ndarray, labels: np.ndarray, new_sample: np.ndarray, k: int) -> int: ``` Input: - `features`: 2D NumPy array of shape `(n_samples, n_features)` - `labels`: 1D NumPy array of integers of shape `(n_samples,)` - `new_sample`: 1D NumPy array of shape `(n_features,)` representing the new sample to classify - `k`: Integer, specifying the number of nearest neighbors to consider Output: - Integer representing the predicted class label for the new sample Constraints: - `k` should be less than or equal to the number of samples in the training data. - Ensure your implementation handles edge cases such as ties in class labels among the k-nearest neighbors. Example: ```python features = np.array([[1, 2], [2, 3], [3, 4], [5, 6]]) labels = np.array([0, 1, 0, 1]) # Train k-NN train_knn(features, labels) # Predict class for a new sample new_sample = np.array([4, 5]) predicted_class = predict_knn(features, labels, new_sample, 3) print(predicted_class) # Output might be 0 or 1 depending on the majority class of the 3 nearest points ``` Note: Handle all possible edge cases and optimize your code for performance.","solution":"import numpy as np from collections import Counter def train_knn(features: np.ndarray, labels: np.ndarray) -> None: Stores the training data. # In a real implementation, this function might store the features and labels to some # global or class-level attributes, so that they can be accessed later. global training_features, training_labels training_features = features training_labels = labels def predict_knn(features: np.ndarray, labels: np.ndarray, new_sample: np.ndarray, k: int) -> int: Classifies the new sample based on the k-nearest neighbors algorithm. # Calculate the distances from the new sample to all training samples distances = np.sqrt(np.sum((features - new_sample) ** 2, axis=1)) # Get the indices of the k smallest distances nearest_indices = np.argsort(distances)[:k] # Get the labels corresponding to the K nearest neighbors nearest_labels = labels[nearest_indices] # Determine the most common class label among the nearest neighbors most_common = Counter(nearest_labels).most_common(1) return most_common[0][0]"},{"question":"# Coding Question Problem Statement Implement two functions that calculate the nth Fibonacci number and return the number of operations performed during the calculation. You are required to implement both a recursive and an iterative version of this algorithm. Requirements 1. **Recursive Version**: - Input: A single integer `n`. - Output: A tuple `(fib_n, call_count)` where `fib_n` is the nth Fibonacci number, and `call_count` is the number of recursive calls made. 2. **Iterative Version**: - Input: A single integer `n`. - Output: A tuple `(fib_n, iteration_count)` where `fib_n` is the nth Fibonacci number, and `iteration_count` is the number of iterations performed. 3. **Constraints**: - `0 <= n <= 30` - The recursive version should count each call separately even if it is a redundant call. 4. **Performance**: - Ensure the recursive function can handle the maximum input size within a reasonable time frame. - The iterative function should be efficient and handle the maximum input size comfortably. Example ```python # Recursive Version assert fib_recursive_count(5) == (5, 15) assert fib_recursive_count(10) == (55, 177) assert fib_recursive_count(0) == (0, 1) # Iterative Version assert fib_iterative_count(5) == (5, 5) assert fib_iterative_count(10) == (55, 10) assert fib_iterative_count(0) == (0, 0) ``` Implementation Details Please implement the following two functions: ```python def fib_recursive_count(n: int, count: int = 1) -> Tuple[int, int]: Calculate nth Fibonacci number using a recursive method. Returns: (fib_n, call_count): Tuple containing the nth Fibonacci number and the number of recursive calls. # Your code here def fib_iterative_count(n: int) -> Tuple[int, int]: Calculate nth Fibonacci number using an iterative method. Returns: (fib_n, iteration_count): Tuple containing the nth Fibonacci number and the number of iterations. # Your code here ```","solution":"from typing import Tuple def fib_recursive_count(n: int, call_count: int = 1) -> Tuple[int, int]: Calculate nth Fibonacci number using a recursive method. Returns: (fib_n, call_count): Tuple containing the nth Fibonacci number and the number of recursive calls. if n <= 1: return (n, call_count) left_fib, left_calls = fib_recursive_count(n - 1, call_count + 1) right_fib, right_calls = fib_recursive_count(n - 2, call_count + 1) total_calls = left_calls + right_calls - call_count return (left_fib + right_fib, total_calls) def fib_iterative_count(n: int) -> Tuple[int, int]: Calculate nth Fibonacci number using an iterative method. Returns: (fib_n, iteration_count): Tuple containing the nth Fibonacci number and the number of iterations. if n == 0: return (0, 0) if n == 1: return (1, 1) a, b = 0, 1 iter_count = 1 # since we start from 1 for i in range(2, n + 1): a, b = b, a + b iter_count += 1 return (b, iter_count)"},{"question":"# Question: Implementing Efficient Prime Number Finder You are tasked with developing a function that efficiently identifies all prime numbers within a given range `[start, end]`. The function should leverage optimal algorithms to ensure it operates efficiently for large ranges. # Input and Output Formats Function Signature ```python def find_primes_in_range(start: int, end: int) -> list[int]: pass ``` Inputs: - `start` (int): The beginning of the range (inclusive). - `end` (int): The end of the range (inclusive). Outputs: - A list of all prime numbers within the given range `[start, end]`, inclusive. Constraints: - `0 <= start <= end <= 10^6` Performance Requirements: - The function must handle large ranges up to `10^6` efficiently. Examples: ```python >>> find_primes_in_range(10, 30) [11, 13, 17, 19, 23, 29] >>> find_primes_in_range(50, 70) [53, 59, 61, 67] >>> find_primes_in_range(0, 10) [2, 3, 5, 7] >>> find_primes_in_range(100, 110) [101, 103, 107, 109] ``` # Scenario Finding prime numbers is a fundamental problem in number theory and has applications in cryptography, coding theory, and various fields of mathematics and computer science. Your task is to implement an efficient algorithm to find all primes within a given range, ensuring it handles large ranges effectively.","solution":"def find_primes_in_range(start: int, end: int) -> list[int]: Returns a list of all prime numbers within the range [start, end], inclusive. if start > end: return [] # Sieve of Eratosthenes to find all primes up to sqrt(end) def sieve(limit): is_prime = [True] * (limit + 1) p = 2 while p * p <= limit: if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, limit + 1) if is_prime[p]] import math sieve_limit = int(math.sqrt(end)) + 1 small_primes = sieve(sieve_limit) # Use the small primes to mark non-primes in the range [start, end] is_prime_range = [True] * (end - start + 1) for prime in small_primes: # Find the starting point of marking for this prime start_index = max(prime * prime, start + (prime - start % prime) % prime) for j in range(start_index, end + 1, prime): is_prime_range[j - start] = False # Special case: 1 is not a prime number if start == 1: is_prime_range[0] = False if start == 0: if end >= 1: is_prime_range[1] = False if end >= 0: is_prime_range[0] = False return [num for num, is_prime in enumerate(is_prime_range, start=start) if is_prime]"},{"question":"# Context In social networking sites, users often tag each other in posts, which can be represented as a graph where users are nodes, and tags are edges. Analyzing these graphs helps identify closely-knit communities. # Problem Statement You need to create a `SocialNetwork` class that models user interactions and allows for the addition of tags (edges) and the detection of communities (connected components). # Task Extend the given social network data structure to include the following functionalities: 1. **Add User**: * Implement a method `add_user(user_id: int) -> None` that adds a new user to the network. 2. **Add Tag**: * Implement a method `add_tag(user1: int, user2: int) -> None` that tags `user1` with `user2`, creating an undirected edge between them. 3. **Find Communities**: * Implement a method `find_communities() -> List[Set[int]]` that returns a list of sets, where each set contains the users in one community. # Function Signature ```python class SocialNetwork: def __init__(self): # Initialize your data structure here pass def add_user(self, user_id: int) -> None: pass def add_tag(self, user1: int, user2: int) -> None: pass def find_communities(self) -> List[Set[int]]: pass ``` # Input * `user_id` is an integer representing a unique user. * `user1` and `user2` are integers representing user IDs that need to be tagged with each other. # Output * **add_user**: Adds the user to the network. * **add_tag**: Creates a mutual tag between user1 and user2. * **find_communities**: Returns a list of sets, where each set contains the integers representing the users in one community. # Example Usage ```python # Example Usage sn = SocialNetwork() sn.add_user(1) sn.add_user(2) sn.add_user(3) sn.add_user(4) sn.add_user(5) sn.add_user(6) sn.add_tag(1, 2) sn.add_tag(2, 3) sn.add_tag(4, 5) sn.add_tag(4, 6) print(sn.find_communities()) # Should output [{1, 2, 3}, {4, 5, 6}] ``` # Constraints 1. Users have unique `user_id` values within the given problem. 2. The total number of users will be less than or equal to 1000. 3. The methods should efficiently handle the operations even when the network is near its capacity.","solution":"from typing import List, Set, Dict class SocialNetwork: def __init__(self): self.network = {} def add_user(self, user_id: int) -> None: if user_id not in self.network: self.network[user_id] = set() def add_tag(self, user1: int, user2: int) -> None: if user1 in self.network and user2 in self.network: self.network[user1].add(user2) self.network[user2].add(user1) def find_communities(self) -> List[Set[int]]: visited = set() communities = [] def dfs(node, community): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) community.add(current) stack.extend(self.network[current] - visited) for user in self.network: if user not in visited: community = set() dfs(user, community) communities.append(community) return communities"},{"question":"# Problem Statement: You are a software developer tasked with creating a utility function that helps an inventory management system keep track of product stock levels in different warehouses. The goal is to compute the total stock of a specific product across all given warehouses. # Task: Write a function `calculate_total_stock()` that takes two arguments: - `stock_levels` (dict): A dictionary where the keys are warehouse names (strings) and the values are dictionaries. Each of these nested dictionaries has product names (strings) as keys and their respective stock levels (integers) as values. - `product_name` (str): The name of the product for which the total stock needs to be calculated. The function should return an integer representing the total stock of the specified product across all warehouses. Constraints: - `stock_levels` dictionary contains at least one warehouse. - Each warehouse dictionary contains at least one product. - All stock levels are non-negative integers. - If a product is not found in any warehouse, its stock level should be considered as 0. Example: ```python def calculate_total_stock(stock_levels: dict, product_name: str) -> int: pass # Your implementation here # Example Test Cases: warehouses = { \'Warehouse_A\': {\'Product_1\': 100, \'Product_2\': 150}, \'Warehouse_B\': {\'Product_2\': 200, \'Product_3\': 250}, \'Warehouse_C\': {\'Product_1\': 300, \'Product_3\': 350}, } print(calculate_total_stock(warehouses, \'Product_1\')) # Output: 400 print(calculate_total_stock(warehouses, \'Product_2\')) # Output: 350 print(calculate_total_stock(warehouses, \'Product_3\')) # Output: 600 print(calculate_total_stock(warehouses, \'Product_4\')) # Output: 0 ``` # Requirements: - Traverse through all warehouse data to sum up the stock levels of the specified product. - Handle cases where the product may not be present in some warehouses but is still considered a valid query.","solution":"def calculate_total_stock(stock_levels: dict, product_name: str) -> int: Calculate the total stock of a specific product across all warehouses. Args: stock_levels (dict): A dictionary where the keys are warehouse names and the values are dictionaries containing product stock levels. product_name (str): The name of the product for which to calculate the total stock. Returns: int: Total stock of the specified product across all warehouses. total_stock = 0 for warehouse in stock_levels: total_stock += stock_levels[warehouse].get(product_name, 0) return total_stock"},{"question":"# Coding Assessment Question Context You have been requested to build a small utility that interacts with an external API to fetch some data. Specifically, the utility needs to fetch weather data from a weather API. Task Create a function `fetch_weather_data(city: str) -> dict` which: 1. Uses the OpenWeatherMap API to fetch weather data for the given city. 2. Parses the JSON response to extract and return specific weather details like temperature, humidity, and weather description. Requirements 1. Sign up on the OpenWeatherMap website to get an API key. 2. Implement the function `fetch_weather_data(city: str) -> dict`. 3. The function should return a dictionary containing the following keys: `temperature`, `humidity`, and `description`. 4. Handle any potential errors related to network issues or invalid API responses gracefully. 5. Ensure the function can handle cases where the input city is not found. Input and Output * **Input**: A string `city` representing the city name for which to fetch weather data. * **Output**: A dictionary with the keys `temperature`, `humidity`, and `description`, each containing relevant weather information. Constraints * The function should work with the free tier of the OpenWeatherMap API. * Assume the environment has internet access and necessary permissions. * Handle common network and API errors gracefully using appropriate exception handling. * The script must use the `requests` library for HTTP requests. API Usage Example ```python # Example response from OpenWeatherMap API { \\"main\\": { \\"temp\\": 288.55, \\"humidity\\": 82 }, \\"weather\\": [ { \\"description\\": \\"light rain\\" } ] } ``` Example usage: ```python >>> weather_data = fetch_weather_data(\\"London\\") >>> print(weather_data) { \\"temperature\\": 288.55, \\"humidity\\": 82, \\"description\\": \\"light rain\\" } ``` [Script ends here]","solution":"import requests def fetch_weather_data(city: str) -> dict: Fetches weather data for a given city using the OpenWeatherMap API. :param city: Name of the city to fetch weather data for. :type city: str :return: A dictionary containing temperature, humidity, and weather description. :rtype: dict api_key = \\"your_api_key_here\\" # Replace with your actual OpenWeatherMap API key url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\\" try: response = requests.get(url) response.raise_for_status() # Will raise HTTPError for bad responses (4XX and 5XX) data = response.json() weather_data = { \\"temperature\\": data[\\"main\\"][\\"temp\\"], \\"humidity\\": data[\\"main\\"][\\"humidity\\"], \\"description\\": data[\\"weather\\"][0][\\"description\\"] } return weather_data except requests.exceptions.RequestException as e: print(f\\"Error fetching data from the weather API: {e}\\") return {} except KeyError as e: print(f\\"Missing expected data in the API response: {e}\\") return {}"},{"question":"# Context You are developing a feature for an application that involves sorting large datasets. To ensure optimal performance, your task is to implement a sort that can efficiently handle large lists of integers. # Objective Implement the QuickSort algorithm to sort a list of integers in ascending order. Your function should be efficient and able to handle edge cases such as empty lists and lists with duplicate elements. # Function Signature ```python def quick_sort(nums: list[int]) -> list[int]: Sort a list of integers in ascending order using the QuickSort algorithm :param nums: List of integers to be sorted :return: Sorted list of integers Example: >>> quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quick_sort([1, 9, 8, 7, 6, 5, 4, 3, 2, 1]) [1, 1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Constraints and Requirements 1. The function must handle lists of integers, including negative numbers and duplicates. 2. If the input list is empty, return an empty list. 3. Ensure the algorithm has a best-case time complexity of (O(n log n)) and a worst-case time complexity of (O(n^2)), where (n) is the number of elements in the list. 4. Use an in-place sorting approach to minimize space complexity. # Performance 1. Aim for a space complexity of (O(log n)) due to the recursive nature of QuickSort. 2. Ensure the implementation can handle large lists efficiently and robustly. # Examples - Input: `[3, 6, 8, 10, 1, 2, 1]` Output: `[1, 1, 2, 3, 6, 8, 10]` - Input: `[1, 9, 8, 7, 6, 5, 4, 3, 2, 1]` Output: `[1, 1, 2, 3, 4, 5, 6, 7, 8, 9]` - Input: `[]` Output: `[]` # Bonus (optional) Discuss potential improvements for the QuickSort algorithm to handle nearly sorted lists or detect and mitigate the worst-case performance scenario. # Notes Ensure proper handling of edge cases and test your implementation with various datasets, including large and small lists, and lists with duplicate and negative values. Verify the sorted output against the expected results for accuracy.","solution":"def quick_sort(nums: list[int]) -> list[int]: Sort a list of integers in ascending order using the QuickSort algorithm :param nums: List of integers to be sorted :return: Sorted list of integers if len(nums) <= 1: return nums pivot = nums[len(nums) // 2] left = [x for x in nums if x < pivot] middle = [x for x in nums if x == pivot] right = [x for x in nums if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"Problem Statement A group of hikers is planning their route through a grid-like forest. Each cell in the grid either contains a tree or is open ground. The grid is represented by a list of strings where \'T\' represents a tree and \'O\' represents open ground. The hikers can only move vertically or horizontally from one cell to another and cannot pass through trees. Write a function to determine the minimum number of steps the hikers need to take to get from their start point to their destination point. If the destination cannot be reached, return -1. # Input - A 2D list of strings `forest` representing the forest grid. - A tuple `(start_x, start_y)` representing the starting position. - A tuple `(dest_x, dest_y)` representing the destination position. # Output - An integer representing the minimum number of steps required to reach the destination, or -1 if the destination is unreachable. # Constraints - 1 ≤ number of rows in `forest` ≤ 100 - 1 ≤ number of columns in `forest` ≤ 100 - Both the starting and destination positions will be on open ground. - There will be at least one open ground cell in the grid. # Example ```python forest = [ [\\"O\\", \\"O\\", \\"T\\", \\"O\\"], [\\"T\\", \\"O\\", \\"T\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\", \\"T\\"], [\\"T\\", \\"T\\", \\"O\\", \\"O\\"] ] start = (0, 0) dest = (3, 3) # The function should return 6, as the minimum path is: # (0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2) -> (3,2) -> (3,3) print(min_steps_to_destination(forest, start, dest)) # Output: 6 ``` # Guidance To solve this problem, use a Breadth-First Search (BFS) algorithm since it is most suitable for finding the shortest path in an unweighted grid. # Sample Function Definition ```python def min_steps_to_destination(forest: list[list[str]], start: tuple[int, int], dest: tuple[int, int]) -> int: # Your code here ```","solution":"from collections import deque def min_steps_to_destination(forest, start, dest): Given a forest represented as a grid of \'T\' (trees) and \'O\' (open ground), it finds the minimum number of steps needed to reach the destination from the start point using BFS. rows, cols = len(forest), len(forest[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if start == dest: return 0 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and forest[nx][ny] == \'O\': if (nx, ny) == dest: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Single Number Identifier Given an array `nums` containing n integers where each integer appears twice except for one integer that appears only once, find that single integer. Implement a function to return the single integer that occurs only once. Function Signature ```python def single_number(nums: List[int]) -> int: ``` Input - `nums`: A list of integers (1 ≤ n ≤ 3 * 10^4), where each integer appears exactly twice except for one integer which appears once. Output - Returns an integer which is the single number that appears only once. Example ```python >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1]) 1 ``` Constraints - The input list must have a length of at least 1 and at most 30,000. - Each element in the array appears twice except for one. Notes - Implement the solution with a linear runtime complexity of O(n) and constant space complexity. - You can achieve this by leveraging the properties of the XOR operation. Explanation The XOR operation provides a convenient way to achieve the desired result due to its properties: - XOR of two identical numbers is 0: `a ⊕ a = 0` - XOR with 0 leaves the number unchanged: `a ⊕ 0 = a` Hence, performing XOR across all elements in the array will result in the single number remaining.","solution":"def single_number(nums): Given a non-empty array of integers, every element appears twice except for one. Find that single one. Args: nums (List[int]): List of integers. Returns: int: The single integer that appears only once. single_num = 0 for num in nums: single_num ^= num return single_num"},{"question":"# Order Processing System **Background:** In many e-commerce platforms, an order processing system is critical for managing the fulfillment of customer orders. Orders include multiple products, each with a specified quantity. The total cost of the order is computed by multiplying the quantity of each product by its price and summing these values. Occasionally, discounts are applied either as a percentage of the total order cost or as a direct reduction. **Function Signature:** ```python def calculate_total(order: list[tuple[int, float, int]], discount: tuple[str, float] = (\\"none\\", 0.0)) -> float: Calculate the total cost of an order after applying any discounts. Parameters: order (list): A list of tuples representing the products in the order. Each tuple contains: (quantity as an int, price_per_unit as a float, product_id as an int). discount (tuple): An optional tuple indicating the type and amount of discount. The first element is a string (\\"none\\", \\"percentage\\", \\"fixed\\"). The second element is a float representing the discount value. Returns: float: The total cost after applying the discount, rounded to two decimal places. ``` # Input and Output: - **Input:** - A list of tuples, each containing three values: quantity (int), price per unit (float), and product ID (int). - An optional tuple indicating the discount type and value. - **Output:** - A float value representing the total cost of the order after applying the discount, rounded to two decimal places. # Constraints: - The input quantities will be non-negative integers. - The input prices will be non-negative floats. - The discount percentage will be a non-negative float representing a percentage (0-100). - The fixed discount will be a non-negative float. - Order list\'s length will be between 0 and 1,000. - Price per unit will be in the range of 0 to 10^4. # Function Implementation: Based on your understanding, complete the code to correctly calculate the total cost of an order after taking into consideration any discounts applied. **Examples:** 1. `calculate_total([(3, 20.0, 101), (5, 15.0, 102)], (\\"percentage\\", 10.0))` should return `135.00`. 2. `calculate_total([(2, 100.0, 201), (1, 200.0, 202)], (\\"fixed\\", 50.0))` should return `350.00`. 3. `calculate_total([], (\\"none\\", 0.0))` should return `0.00`. 4. `calculate_total([(1, 1000.0, 301)], (\\"percentage\\", 50.0))` should return `500.00`. Make sure to consider edge cases and handle rounding appropriately.","solution":"def calculate_total(order, discount=(\\"none\\", 0.0)) -> float: Calculate the total cost of an order after applying any discounts. Parameters: order (list): A list of tuples representing the products in the order. Each tuple contains: (quantity as an int, price_per_unit as a float, product_id as an int). discount (tuple): An optional tuple indicating the type and amount of discount. The first element is a string (\\"none\\", \\"percentage\\", \\"fixed\\"). The second element is a float representing the discount value. Returns: float: The total cost after applying the discount, rounded to two decimal places. total_cost = sum(quantity * price_per_unit for quantity, price_per_unit, _ in order) discount_type, discount_value = discount if discount_type == \\"percentage\\": total_cost *= (1 - discount_value / 100) elif discount_type == \\"fixed\\": total_cost -= discount_value # Ensure we don\'t have negative total cost total_cost = max(total_cost, 0.0) return round(total_cost, 2)"},{"question":"# Question: Balanced Parentheses Speech Analysis You are developing an application that transcribes and analyzes speeches. Once transcribed, you need to ensure that the parentheses used in the speeches are appropriately balanced, as unbalanced parentheses can distort meaning and lead to misinterpretations. **Objective:** Write a function `is_balanced(s: str) -> bool` that checks if the input string `s` has balanced parentheses. Parentheses include the following pairs: `()`, `{}`, and `[]`. Requirements: 1. The function should handle multiple types of parentheses and check for balance accordingly. 2. Parentheses pairs must open and close in the correct order. 3. Only the parentheses need to be considered for balancing, other characters in the string can be ignored. Input: - `s`: A string containing any combination of characters, including multiple types of parentheses. Output: - A boolean indicating whether the parentheses in the input string are balanced. Constraints: - (1 leq text{length of } s leq 10^4) Example: ```python >>> is_balanced(\\"This (is a [sample] {speech} with) balanced parentheses.\\") True >>> is_balanced(\\"Unbalanced (this [speech} has)\\") False >>> is_balanced(\\"Miscellaneous characters [do (not {affect})] the check.\\") True >>> is_balanced(\\"Missing closing (parentheses here.\\") False >>> is_balanced(\\"Extra {closing}) parentheses.\\") False ``` # Notes: - The implementation should be efficient, potentially using a stack-based approach to ensure that the parentheses are correctly balanced as the string is processed. - Edge cases such as nested parentheses and strings without any parentheses should be handled gracefully.","solution":"def is_balanced(s: str) -> bool: Checks whether the parentheses in the input string are balanced. stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_parentheses.values(): # If it\'s any of the opening parentheses, push to stack stack.append(char) elif char in matching_parentheses: # If it\'s a closing parenthesis, check if it matches the top of the stack if stack and stack[-1] == matching_parentheses[char]: stack.pop() else: return False # If stack is empty, all opened parentheses were properly closed return not stack"},{"question":"# Question: Implement a Python function `find_common_prefix` that takes a list of words and returns the longest common prefix shared among all the words in the list. If there is no common prefix, return an empty string. Function Signature ```python def find_common_prefix(words: list[str]) -> str: ``` # Input - `words`: A list of strings, where each string consists of lowercase English letters only. # Output - Returns the longest common prefix as a string. # Constraints - The length of each word will not exceed 200 characters. - The list `words` may contain up to 1000 words. - The words will not contain spaces or non-alphabetic characters. # Examples ```python assert find_common_prefix([\\"apple\\", \\"application\\", \\"apricot\\"]) == \\"ap\\" assert find_common_prefix([\\"dog\\", \\"cat\\", \\"fish\\"]) == \\"\\" assert find_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"internet\\"]) == \\"inter\\" assert find_common_prefix([]) == \\"\\" assert find_common_prefix([\\"alone\\"]) == \\"alone\\" ``` # Requirements 1. Ensure the function handles an empty list gracefully. 2. Handle the input validation to accept only lists of non-empty strings consisting of lowercase English letters; raise a `ValueError` for invalid inputs. 3. Ensure the function performs efficiently even for larger lists of words. # Scenario You are tasked with developing a search engine that relies heavily on identifying common prefixes among search terms to group and optimize related queries. Use this function to index and categorize searches based on their shared prefixes, improving the speed and accuracy of query retrieval.","solution":"def find_common_prefix(words: list[str]) -> str: Returns the longest common prefix shared among all the words in the list. If there is no common prefix, returns an empty string. if not words: return \\"\\" # Find the minimum length word in order to limit our prefix check min_length = min(len(word) for word in words) # Initialize prefix as an empty string prefix = \\"\\" for i in range(min_length): # Take the character from the first word as a reference char = words[0][i] # Check if this character is found in the same position in all other words if all(word[i] == char for word in words): prefix += char else: break return prefix"},{"question":"# Task You are tasked with implementing a function that calculates the Matrix Product efficiently. This function is a fundamental operation in various scientific computing and machine learning tasks. # Problem Statement **Function Signature**: ```python def matrix_product(matrix_a: np.ndarray, matrix_b: np.ndarray) -> np.ndarray: \'\'\' Parameters: matrix_a (np.ndarray): A 2D numpy array representing the first matrix. matrix_b (np.ndarray): A 2D numpy array representing the second matrix. Returns: np.ndarray: The resultant matrix of the product of matrix_a and matrix_b. \'\'\' ``` Your task is to implement the `matrix_product` function to compute the product of two matrices `matrix_a` and `matrix_b`. Ensure the function handles large matrices efficiently using optimized methods provided by numpy. # Constraints * Matrices `matrix_a` and `matrix_b` are of compatible dimensions for matrix multiplication. * Each element in the matrices is a real number. * The function should handle matrices up to size `1000 x 1000` effectively. # Examples Example 1: * Input: ```python matrix_a = np.array([[1, 2], [3, 4]]) matrix_b = np.array([[5, 6], [7, 8]]) ``` * Output: ```python array([[19, 22], [43, 50]]) ``` Example 2: * Input: ```python matrix_a = np.array([[1, 0], [0, 1]]) matrix_b = np.array([[9, 8], [7, 6]]) ``` * Output: ```python array([[9, 8], [7, 6]]) ``` # Notes * Use numpy\'s built-in functionalities to optimize the matrix multiplication process. * Make sure the function properly validates the input matrices for compatible dimensions before proceeding with the multiplication. * Validate your implementation with unit tests for correctness and efficiency.","solution":"import numpy as np def matrix_product(matrix_a: np.ndarray, matrix_b: np.ndarray) -> np.ndarray: Returns the product of two matrices. Uses numpy\'s dot function for efficient computation. Parameters: matrix_a (np.ndarray): A 2D numpy array representing the first matrix. matrix_b (np.ndarray): A 2D numpy array representing the second matrix. Returns: np.ndarray: The resultant matrix of the product of matrix_a and matrix_b. # Validate the input matrices dimensions if matrix_a.shape[1] != matrix_b.shape[0]: raise ValueError(\\"Matrices are not aligned. The number of columns in matrix_a must be equal to the number of rows in matrix_b.\\") return np.dot(matrix_a, matrix_b)"},{"question":"# Coding Assessment Question Scenario You are developing a trading system that keeps track of stock prices over time. For each stock, you want to maintain the highest price observed during the last `k` days. To streamline this process, you will use a sliding window mechanism. Task Write a function that processes a series of daily stock prices and calculates the maximum stock price for each sliding window of size `k`. Function Signature ```python def max_stock_prices(prices: List[int], k: int) -> List[int]: Calculates the maximum stock prices in sliding windows of size k. :param prices: A list of integers representing daily stock prices. :param k: An integer representing the size of the window. :return: A list of integers representing the maximum stock prices for each sliding window. ``` Constraints 1. `1 <= k <= len(prices) <= 10^5` 2. `prices[i]` are integers where `-10^4 <= prices[i] <= 10^4`. Example Given the following `prices` and `k`: ```python prices = [4, 3, 5, 2, 1, 6, 7] k = 3 ``` The function should return: `[5, 5, 5, 6, 7]` because: - The first sliding window `[4, 3, 5]` has a maximum of `5`. - The second sliding window `[3, 5, 2]` has a maximum of `5`. - The third sliding window `[5, 2, 1]` has a maximum of `5`. - The fourth sliding window `[2, 1, 6]` has a maximum of `6`. - The fifth sliding window `[1, 6, 7]` has a maximum of `7`. Ensure your function is optimized to handle the upper limits of input size efficiently.","solution":"from collections import deque from typing import List def max_stock_prices(prices: List[int], k: int) -> List[int]: Calculates the maximum stock prices in sliding windows of size k. :param prices: A list of integers representing daily stock prices. :param k: An integer representing the size of the window. :return: A list of integers representing the maximum stock prices for each sliding window. if not prices or k <= 0: return [] result = [] deque_window = deque() for i, price in enumerate(prices): # Remove elements outside of the current sliding window if deque_window and deque_window[0] <= i - k: deque_window.popleft() # Remove elements from the deque that are less than the current price while deque_window and prices[deque_window[-1]] <= price: deque_window.pop() # Add the current element index deque_window.append(i) # Append the current max to the result starting from the k-th element if i >= k - 1: result.append(prices[deque_window[0]]) return result"},{"question":"# Matrix Transposition You are required to implement a matrix transposition function that will transpose a given matrix of integers. Transposition involves flipping the matrix over its diagonal, switching the row and column indices of the matrix. Requirements 1. The function should accept a list of lists representing the matrix. 2. Each row in the matrix will have the same number of columns. 3. The function should return a new matrix that is the transpose of the input matrix. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose the input matrix. Parameters: - matrix (List[List[int]]): A 2D list of integers representing the matrix to be transposed. Returns: - List[List[int]]: A new 2D list of integers representing the transposed matrix. ``` Test Cases - `transpose_matrix([[1, 2, 3], [4, 5, 6]])` should return `[[1, 4], [2, 5], [3, 6]]`. - `transpose_matrix([[1, 2], [3, 4], [5, 6]])` should return `[[1, 3, 5], [2, 4, 6]]`. - `transpose_matrix([[1]])` should return `[[1]]`. - `transpose_matrix([])` should return `[]`. Ensure to handle edge cases and exceptions according to the requirements provided.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose the input matrix. Parameters: - matrix (List[List[int]]): A 2D list of integers representing the matrix to be transposed. Returns: - List[List[int]]: A new 2D list of integers representing the transposed matrix. if not matrix: return [] rows, cols = len(matrix), len(matrix[0]) transposed_matrix = [[matrix[row][col] for row in range(rows)] for col in range(cols)] return transposed_matrix"},{"question":"# Question: Sorting a List of Tuples by Specific Elements You are asked to implement a function that sorts a list of tuples. Each tuple contains three elements: a name (string), an age (integer), and a score (float). The list should be sorted first by the age in ascending order. If two ages are identical, sort these by the score in descending order. If both age and score are identical, then sort by name in ascending alphabetical order. Requirements: 1. **Functionality to Implement**: Write a function to sort a list of tuples based on the specified criteria. 2. **Input and Output Formats**: - **Input**: * `data (list[tuple[str, int, float]])`: A list of tuples where each tuple consists of (name, age, score). - **Output**: A list of tuples sorted according to the criteria described. 3. **Constraints**: - Each name is a non-empty string. - Each age is a non-negative integer. - Each score is a non-negative float. 4. **Performance**: - Ensure the implementation is efficient even for larger lists. ```python def sort_tuples(data: list[tuple[str, int, float]]) -> list[tuple[str, int, float]]: Sort a list of tuples by age in ascending order, score in descending order, and name in alphabetical order. :param data: List of tuples (name: str, age: int, score: float). :return: Sorted list of tuples according to the specified criteria. # Your code here pass ``` **Example**: ```python data = [(\\"John\\", 25, 98.5), (\\"Doe\\", 25, 95.7), (\\"Alice\\", 23, 89.0), (\\"Bob\\", 25, 98.5)] result = sort_tuples(data) # `result` should be: [(\'Alice\', 23, 89.0), (\'Bob\', 25, 98.5), (\'John\', 25, 98.5), (\'Doe\', 25, 95.7)] ``` **Scenarios to Consider**: * Same ages with different scores and names. * All elements having the same age and different scores or names. * Empty input list. * Large list inputs with mixed age, score, and name values. Write your solution and ensure to test the function against various edge cases.","solution":"def sort_tuples(data: list[tuple[str, int, float]]) -> list[tuple[str, int, float]]: Sort a list of tuples by age in ascending order, score in descending order, and name in alphabetical order. :param data: List of tuples (name: str, age: int, score: float). :return: Sorted list of tuples according to the specified criteria. # Sort by age ascending, score descending, and name ascending return sorted(data, key=lambda x: (x[1], -x[2], x[0]))"},{"question":"# Scenario As a software developer, you are building a feature to generate financial reports based on daily transaction data. Each day\'s transactions need to be aggregated to provide daily totals, and further, these daily totals should be summarized monthly. # Task Write a function `summarize_transactions` that takes a list of transactions and returns a dictionary summarizing the daily and monthly totals. Each transaction is a tuple containing a date string (`\'YYYY-MM-DD\'`) and an amount. The function should group transactions by date and compute daily totals, then aggregate these daily totals to compute monthly totals. # Function Signature ```python def summarize_transactions(transactions: list[tuple[str, float]]) -> dict: ``` # Input - `transactions`: A list of tuples where each tuple contains: - a `date` string in the format `\'YYYY-MM-DD\'` - an `amount` which is a float representing the transaction amount. # Output - Returns a dictionary with two keys: - `\'daily_totals\'`: A dictionary mapping each date (`\'YYYY-MM-DD\'`) to the total amount of transactions on that date. - `\'monthly_totals\'`: A dictionary mapping each month (`\'YYYY-MM\'`) to the total amount of transactions in that month. # Examples ```python transactions = [ (\'2023-01-01\', 100.0), (\'2023-01-01\', 200.0), (\'2023-01-02\', 300.0), (\'2023-02-01\', 400.0), (\'2023-02-01\', 100.0) ] print(summarize_transactions(transactions)) # Output: # { # \'daily_totals\': { # \'2023-01-01\': 300.0, # \'2023-01-02\': 300.0, # \'2023-02-01\': 500.0, # }, # \'monthly_totals\': { # \'2023-01\': 600.0, # \'2023-02\': 500.0 # } # } ``` # Notes - The input list of transactions is guaranteed not to be empty. - Ensure your solution handles different months and multiple transactions on the same day correctly. - Pay attention to the required date formats for keys in the resulting dictionary.","solution":"from collections import defaultdict def summarize_transactions(transactions): daily_totals = defaultdict(float) monthly_totals = defaultdict(float) for date, amount in transactions: daily_totals[date] += amount year_month = date[:7] monthly_totals[year_month] += amount return { \'daily_totals\': dict(daily_totals), \'monthly_totals\': dict(monthly_totals) }"},{"question":"# Word Ladder Transformation Scenario You are developing a feature for a language learning app that helps users transform one word into another. Each transformation consists of changing one letter at a time, and each intermediate word must also be a valid word from a given word list. Task Implement a function `word_ladder(begin_word, end_word, word_list)` that: - Takes a starting word (`begin_word`), an ending word (`end_word`), and a list of words (`word_list`) as input. - Returns the minimum number of transformations required to transform `begin_word` into `end_word` using the rules mentioned. If there is no possible transformation, return 0. Your solution should employ Breadth-First Search (BFS) to handle the transformation efficiently. Function Signature ```python def word_ladder(begin_word: str, end_word: str, word_list: list[str]) -> int: pass ``` Input Constraints * 1 <= len(begin_word), len(end_word) <= 100 * 1 <= len(word_list) <= 10^4 * Each word consists of lowercase alphabets (a-z). Example ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert word_ladder(begin_word, end_word, word_list) == 5 # hit -> hot -> dot -> dog -> cog begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] assert word_ladder(begin_word, end_word, word_list) == 0 # No possible transformation ``` Requirements 1. Ensure that the transformation path exists within the given word list. 2. Performance should be efficient enough to handle the maximum constraints. Hint You may use a queue to perform BFS and a set to store the words in the word list for quick lookups during the transformation process.","solution":"from collections import deque def word_ladder(begin_word: str, end_word: str, word_list: list[str]) -> int: word_set = set(word_list) if end_word not in word_set: return 0 queue = deque([(begin_word, 1)]) # Queue of tuples (current_word, current_depth) while queue: current_word, depth = queue.popleft() if current_word == end_word: return depth for i in range(len(current_word)): for c in \\"abcdefghijklmnopqrstuvwxyz\\": next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) # Mark word as visited queue.append((next_word, depth + 1)) return 0"},{"question":"# Context You are writing a part of a financial application that deals with stock prices. The application should be able to identify significant price drops to trigger alerts for investment opportunities. # Task Implement the function `largest_price_drop` that determines the largest drop in stock prices over a period of time. The largest drop is defined as the maximum difference between a peak price and any subsequent lower price. Note that the peak must occur before the low point. Function Signature ```python def largest_price_drop(prices: List[int]) -> int: pass ``` Input - `prices` (List[int]): A list of integers representing daily closing stock prices, where 1 ≤ len(prices) ≤ 10^5 and 1 ≤ prices[i] ≤ 10^6. Output - Returns the largest price drop as an integer. # Constraints - The list of prices will have at least one valid drop. - Ensure the function performs efficiently, ideally with a time complexity of O(n). # Example ```python # Example 1 print(largest_price_drop([100, 90, 80, 70, 60, 50])) # Output: 50 # Example 2 print(largest_price_drop([10, 20, 30, 5, 15, 25, 35])) # Output: 25 # Example 3 print(largest_price_drop([150, 180, 90, 60, 120, 40, 30])) # Output: 140 ``` # Hints - Traverse the list and keep track of the maximum price found so far and the largest drop. - Consider edge cases where prices may increase and decrease non-uniformly.","solution":"from typing import List def largest_price_drop(prices: List[int]) -> int: max_price = prices[0] largest_drop = 0 for price in prices: if price > max_price: max_price = price drop = max_price - price if drop > largest_drop: largest_drop = drop return largest_drop"},{"question":"# Problem Statement: A game involves moving a character on a 2D grid consisting of obstacles. The character can only move up, down, left, or right by one cell at a time, but it cannot move into cells marked as obstacles. Given the character\'s starting position, determine the length of the shortest path to reach a target position. If the target position is unreachable, return -1. # Function Signature: ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int ``` # Input: - `grid` (List[List[int]]): A 2D list representing the grid. Cells with value `1` are obstacles, and cells with value `0` are free to move into. The grid is at least 1x1 and at most 100x100. - `start` (Tuple[int, int]): A tuple representing the starting position (x, y) of the character. - `end` (Tuple[int, int]): A tuple representing the target position (x, y) the character needs to reach. # Output: - (int): The length of the shortest path from `start` to `end`. Return -1 if the path is unreachable. # Constraints: - The function should operate efficiently with a maximum time complexity of O(n * m), where `n` and `m` are the dimensions of the grid. - Ensure to handle edge cases such as the start position being the same as the end position, or either position being an obstacle. # Example: ```python # Example 1: grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) end = (2, 2) shortest_path(grid, start, end) # Returns: 4 # Example 2: grid = [ [0, 1], [1, 0] ] start = (0, 0) end = (1, 1) shortest_path(grid, start, end) # Returns: -1 ``` # Hints: - Use Breadth-First Search (BFS) to explore the shortest path efficiently. - Keep track of visited cells to avoid redundant work and infinite loops. - Edge cases include grids where the start or end is blocked by an obstacle or the start being the same as the end.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: if grid[start[1]][start[0]] == 1 or grid[end[1]][end[0]] == 1: return -1 if start == end: return 0 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # queue stores (x, y, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < cols and 0 <= ny < rows and (nx, ny) not in visited and grid[ny][nx] == 0: if (nx, ny) == end: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Coding Assessment Question: Implement Circular Buffer for Fixed-Size Queue You are tasked with implementing a circular buffer (ring buffer) for a fixed-size queue. This data structure efficiently handles adding and removing elements in a fixed-size buffer, wrapping around to the start when the end is reached. # Specifications 1. **Class Name**: `CircularBuffer` 2. **Methods**: - `__init__(self, size: int) -> None`: Initializes the buffer with a given size. - `enqueue(self, item: Any) -> bool`: Adds an item to the buffer. Returns `True` if successful, `False` if the buffer is full. - `dequeue(self) -> Optional[Any]`: Removes and returns the oldest item from the buffer. Returns `None` if the buffer is empty. - `is_empty(self) -> bool`: Returns `True` if the buffer is empty, `False` otherwise. - `is_full(self) -> bool`: Returns `True` if the buffer is full, `False` otherwise. # Instructions 1. Implement the `CircularBuffer` class using a fixed-size list. 2. Ensure that all methods perform their tasks in constant time (O(1)). 3. Carefully handle edge cases such as empty buffers (dequeue) and full buffers (enqueue). 4. Provide clear and concise comments explaining the logic of your implementation. # Example ```python from typing import Any, Optional class CircularBuffer: def __init__(self, size: int) -> None: self.buffer = [None] * size self.size = size self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, item: Any) -> bool: if self.is_full(): return False self.buffer[self.tail] = item self.tail = (self.tail + 1) % self.size self.count += 1 return True def dequeue(self) -> Optional[Any]: if self.is_empty(): return None item = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return item def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.size # Example usage cb = CircularBuffer(3) assert cb.enqueue(1) == True assert cb.enqueue(2) == True assert cb.enqueue(3) == True assert cb.enqueue(4) == False # Buffer is full assert cb.dequeue() == 1 assert cb.dequeue() == 2 assert cb.enqueue(4) == True # Space available now assert cb.dequeue() == 3 assert cb.dequeue() == 4 assert cb.dequeue() == None # Buffer is empty ``` # Evaluation Your `CircularBuffer` class should efficiently handle enqueue and dequeue operations while effectively managing the fixed-size constraints. Test your implementation with multiple scenarios to ensure robustness and correctness.","solution":"from typing import Any, Optional class CircularBuffer: def __init__(self, size: int) -> None: self.buffer = [None] * size self.size = size self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, item: Any) -> bool: if self.is_full(): return False self.buffer[self.tail] = item self.tail = (self.tail + 1) % self.size self.count += 1 return True def dequeue(self) -> Optional[Any]: if self.is_empty(): return None item = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return item def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.size"},{"question":"# Problem Statement: You are given a list of integers representing the heights of trees in a forest. Your task is to check if it\'s possible to cut a single tree in such a way that the heights of the trees would form a strictly increasing or strictly decreasing sequence. Write a function `can_form_strict_sequence` that determines whether this is possible. Function Signature: ```python def can_form_strict_sequence(heights: list) -> bool: # Your code here ``` Input: * A list of integers `heights` where (1 leq text{len(heights)} leq 1000) and each integer in the list is between 1 and (10^6). Output: * A boolean value - `True` if it\'s possible to cut down exactly one tree to form a strictly increasing or decreasing sequence, otherwise `False`. Constraints: * You can only cut one tree. # Example: *Example 1*: ```python heights = [1, 3, 2, 4] can_form_strict_sequence(heights) ``` *Output*: ``` True ``` *Example 2*: ```python heights = [3, 4, 2, 5, 1] can_form_strict_sequence(heights) ``` *Output*: ``` False ``` *Example 3*: ```python heights = [1, 2, 3, 4] can_form_strict_sequence(heights) ``` *Output*: ``` False ``` Explanation: In the first example, by cutting the second tree (height = 3), the sequence [1, 2, 4] becomes strictly increasing. In the second example, regardless of which tree is cut, you cannot form a strictly increasing or decreasing sequence from the remaining trees. In the third example, the sequence is already strictly increasing, so cutting any tree would disrupt this, making it impossible to then form a new strict sequence.","solution":"def can_form_strict_sequence(heights): Determines if it\'s possible to cut down exactly one tree to form a strictly increasing or strictly decreasing sequence. def is_strict_increasing(seq): return all(seq[i] < seq[i + 1] for i in range(len(seq) - 1)) def is_strict_decreasing(seq): return all(seq[i] > seq[i + 1] for i in range(len(seq) - 1)) n = len(heights) # Check if original sequence is already strict increasing or decreasing if is_strict_increasing(heights) or is_strict_decreasing(heights): return False for i in range(n): # Create a new list without the i-th element new_heights = heights[:i] + heights[i+1:] # Check if the new list is strictly increasing or decreasing if is_strict_increasing(new_heights) or is_strict_decreasing(new_heights): return True return False"},{"question":"# Question: Image Rotate Function Context In computer graphics and image processing, rotating an image by 90 degrees is a common operation. This can be done in an efficient manner by transforming the pixel positions. Task You are given a function `rotate_image(image: List[List[int]]) -> List[List[int]]` that rotates a given 2D image (represented as a matrix) 90 degrees clockwise. Constraints * The image is a square matrix (i.e., the number of rows is equal to the number of columns). * Each element in the matrix is an integer. Instructions 1. **Function definition**: Implement a function `rotate_image(image: List[List[int]]) -> List[List[int]]`. 2. **Input**: * `image`: A square 2D list of integers representing the image to be rotated. 3. **Output**: * A new 2D list of integers representing the image after being rotated 90 degrees clockwise. Example: ```python >>> rotate_image([[1,2,3],[4,5,6],[7,8,9]]) [[7,4,1], [8,5,2], [9,6,3]] >>> rotate_image([[1,2],[3,4]]) [[3,1], [4,2]] ``` Additional Scenarios: Test your function with the following inputs: 1. `rotate_image([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])` 2. `rotate_image([[1]])` 3. `rotate_image([[1,2,3],[4,5,6],[7,8,9]])`","solution":"def rotate_image(image): Rotates the given square matrix (2D list) 90 degrees clockwise. n = len(image) rotated_image = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_image[j][n - 1 - i] = image[i][j] return rotated_image"},{"question":"# Coding Assessment Question You are given a text consisting of sentences. Your task is to implement a function to identify and replace certain words based on a predefined dictionary of replacements. Each key in the replacements dictionary represents a word that needs to be replaced, and the corresponding value is the replacement word. Write a function `replace_words` that takes a string `text` representing the input text and a dictionary `replacements` where keys are words to be replaced and values are the corresponding replacement words. The function should return the modified text. Function Signature ```python def replace_words(text: str, replacements: dict[str, str]) -> str: pass ``` Input Format - `text`: A string containing the input text. The text consists of multiple sentences separated by periods, question marks, or exclamation marks. - `replacements`: A dictionary where each key is a string representing a word to be replaced, and the corresponding value is the string representing the replacement word. Output Format A string representing the modified text after performing all the replacements. Constraints - The text will contain only alphabetic characters and the punctuation marks `.`, `?`, and `!` as sentence separators. - Words in the text are case-sensitive and will only contain alphabetic characters. - The text will have at most 10,000 characters. - The replacements dictionary will contain at most 100 key-value pairs. - Each word in the text will not exceed 100 characters. Example ```python text = \\"Hello world. How are you world? World peace is important.\\" replacements = { \\"world\\": \\"Earth\\", \\"peace\\": \\"harmony\\" } modified_text = replace_words(text, replacements) print(modified_text) # Output: # \\"Hello Earth. How are you Earth? World harmony is important.\\" ``` Performance Requirements - Your solution should efficiently handle the given constraints. - The overall time complexity should be O(n) where n is the length of the text, assuming dictionary operations are O(1).","solution":"def replace_words(text: str, replacements: dict[str, str]) -> str: This function replaces words in the text based on the given replacements dictionary. Parameters: text (str): The input text containing sentences. replacements (dict): A dictionary with words to be replaced as keys and the replacement words as values. Returns: str: The modified text after performing the replacements. import re def replacement(match): word = match.group(0) return replacements.get(word, word) # Create a regex pattern for words that need to be replaced pattern = re.compile(r\'b(\' + \'|\'.join(re.escape(key) for key in replacements.keys()) + r\')b\') # Use the pattern to substitute words in the text modified_text = pattern.sub(replacement, text) return modified_text"},{"question":"# Question Context In competitive programming and system design, string manipulation and pattern recognition are often used to solve complex problems. One such problem involves determining the longest prefix of a given string that also appears as a suffix. Task Write a function `longest_prefix_suffix` that finds the longest prefix of a given string which is also a suffix. The prefix and suffix cannot overlap. Function Signature ```python def longest_prefix_suffix(s: str) -> str: ``` Input * `s` – A string with length ranging from `1` to `10^5` composed of lowercase English letters. Output * Return the longest prefix which is also a suffix. If there\'s no such prefix, return an empty string. Examples ```python assert longest_prefix_suffix(\\"level\\") == \\"l\\" assert longest_prefix_suffix(\\"ababab\\") == \\"abab\\" assert longest_prefix_suffix(\\"abcd\\") == \\"\\" assert longest_prefix_suffix(\\"aaaa\\") == \\"aaa\\" assert longest_prefix_suffix(\\"abcab\\") == \\"ab\\" ``` Explanation * In the string \\"level\\", \\"l\\" is both a prefix and a suffix. * In the string \\"ababab\\", \\"abab\\" is the longest prefix which is also a suffix. * In the string \\"abcd\\", there is no prefix which is also a suffix. * In the string \\"aaaa\\", \\"aaa\\" is the longest prefix which is also a suffix. * In the string \\"abcab\\", \\"ab\\" is the longest prefix which is also a suffix. Hints * Consider using the concept of prefix function (pi function) from the KMP (Knuth-Morris-Pratt) algorithm to find the longest prefix which is also a suffix. Utilize efficient string manipulation techniques to achieve the desired result within the constraints.","solution":"def longest_prefix_suffix(s): Returns the longest prefix which is also a suffix in the given string. Note: The prefix and suffix cannot overlap. n = len(s) lps = [0] * n # lps array to store the length of the longest prefix suffix values for the prefix ending at i j = 0 # length of previous longest prefix suffix i = 1 while i < n: if s[i] == s[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j-1] else: lps[i] = 0 i += 1 # lps[n-1] contains the length of the longest prefix which is also a suffix prefix_len = lps[-1] if prefix_len > 0 and prefix_len < n: return s[:prefix_len] else: return \\"\\""},{"question":"# **Coding Assessment Question** **Objective**: You are tasked with implementing a functionality to determine the order of courses one has to take given a list of course prerequisites. Your implementation should handle cyclical dependencies and provide an error message if a cycle is detected. **Problem Statement**: Given a list of courses and their prerequisites, implement a function to find a valid order in which the courses can be completed. If it is not possible to complete all the courses due to a cycle, return an empty list. **Function Signature**: ```python def find_course_order(num_courses: int, prerequisites: List[Tuple[int, int]]) -> List[int]: ``` **Input Format**: - `num_courses`: an integer representing the total number of courses, labeled from `0` to `num_courses - 1`. - `prerequisites`: a list of tuples where each tuple (a, b) indicates that course `a` depends on course `b` (i.e., `b` must be taken before `a`). **Output Format**: - Return a list of integers representing a valid order in which the courses can be completed. If no valid order exists, return an empty list. **Constraints**: - `1 <= num_courses <= 10^4` - `0 <= len(prerequisites) <= 5 * 10^4` - The prerequisites are given as direct acyclic dependencies. **Performance Requirements**: - Optimize the function for both time and space. Use appropriate algorithms such as topological sorting to handle dependencies efficiently. **Example Usage**: ```python # Example 1 num_courses = 4 prerequisites = [(1, 0), (2, 1), (3, 2)] result = find_course_order(num_courses, prerequisites) # The result could be [0, 1, 2, 3] or any other order that satisfies the prerequisites # Example 2 num_courses = 2 prerequisites = [(0, 1), (1, 0)] result = find_course_order(num_courses, prerequisites) # The result should be [] because there is a cycle ``` **Additional Notes**: - Carefully handle the detection of cycles within the course prerequisites. - Consider edge cases such as a graph with no edges, where any order is valid. This question assesses understanding of graph theory concepts, specifically topological sorting and cycle detection in directed graphs, and requires efficient handling of large inputs.","solution":"from typing import List, Tuple from collections import deque, defaultdict def find_course_order(num_courses: int, prerequisites: List[Tuple[int, int]]) -> List[int]: Determine the order of courses based on prerequisites. If a cycle is detected, return an empty list. in_degree = {i: 0 for i in range(num_courses)} graph = defaultdict(list) for course, prereq in prerequisites: in_degree[course] += 1 graph[prereq].append(course) queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == num_courses: return order else: return []"},{"question":"# Coding Assessment Question **Context:** Sorting algorithms are fundamental concepts in computer science and are widely used in numerous applications. Among the various sorting algorithms, quicksort is known for its effectiveness and efficiency in sorting large datasets. **Task:** Write a function named `quick_sort` in Python to sort an array of integers in ascending order using the quicksort algorithm. **Function Signature:** ```python def quick_sort(arr: list[int]) -> list[int]: ``` **Input:** - `arr`: A list of integers that needs to be sorted. **Output:** - A new list of integers sorted in ascending order. **Constraints:** - The input list can have up to 10^5 elements. - Each integer in the list will be between -10^9 and 10^9. **Example:** ```python >>> quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quick_sort([1, 4, -1, 2]) [-1, 1, 2, 4] >>> quick_sort([50, 23, 9, 18, 61, 32]) [9, 18, 23, 32, 50, 61] ``` **Note:** - You may not use Python\'s built-in sorting functions. - Ensure your function is efficient and handles large inputs within a reasonable time frame.","solution":"def quick_sort(arr: list[int]) -> list[int]: Sorts an array of integers in ascending order using the quicksort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Scenario You are tasked with developing a text processing library, and one of the requirements is to create a function that returns the longest word in a given sentence while ignoring punctuation. This function should be able to efficiently handle sentences with mixed character cases and various punctuation marks. # Task Implement a function `longest_word` that finds the longest word in a given sentence. # Function Signature ```python def longest_word(sentence: str) -> str: ``` # Input * `sentence`: A string containing a sentence with words separated by spaces. It may include punctuation such as commas, periods, question marks, etc. # Output * Returns a string representing the longest word in the sentence. If there are multiple words of the same longest length, return the first one encountered. # Constraints * The input string can have a maximum length of (10^4) characters. * The function should be case-insensitive but return the exact case of the original longest word. * Words are defined as sequences of alphanumeric characters. # Example ```python >>> longest_word(\\"Hello, World! It\'s a beautiful day.\\") \\"beautiful\\" >>> longest_word(\\"A quick brown-fox jumps over the lazy dog!\\") \\"quick\\" ``` # Performance Requirements * The solution should efficiently process the input string within a reasonable time. # Edge Cases * Ensure your function handles sentences with only one word correctly. * Ensure proper handling of punctuation and mixed case without altering the case of the original word.","solution":"import re def longest_word(sentence: str) -> str: Finds the longest word in a given sentence, ignoring punctuation. :param sentence: A string containing a sentence with words separated by spaces. May include punctuation. :return: A string representing the longest word in the sentence. # Use regex to find all words (alphanumeric sequences) words = re.findall(r\'bw+b\', sentence) # Return the longest word (of the first if multiple words have the same length) return max(words, key=len) if words else \\"\\""},{"question":"# JSON Data Validator & Cleaner You are required to write a Python script that reads a JSON file containing product data, validates its structure, applies cleaning rules, and outputs a cleaned JSON file. Your task focuses on implementing functions for data validation, data cleaning, and file operations. Task Requirements: 1. **Function Implementation** - Implement the following functions: * `load_json(file_path: str) -> list[dict]` * `validate_data(data: list[dict]) -> bool` * `clean_data(data: list[dict]) -> list[dict]` * `save_json(data: list[dict], file_path: str) -> None` * Write a test function using `pytest` to validate the functionality of `validate_data` and `clean_data`. 2. **JSON Data Structure**: * The JSON file contains a list of products with the following structure: ```json [ { \\"product_id\\": \\"12345\\", \\"name\\": \\"Product Name\\", \\"price\\": \\"19.99\\", \\"quantity\\": \\"100\\" }, ... ] ``` * All fields should be present and non-empty. `price` and `quantity` should be convertible to their respective types (float and int). 3. **Cleaning Rules**: * Normalize the `name` field by stripping leading/trailing whitespace and converting to title case. * Convert `price` to a float and round to two decimal places. * Convert `quantity` to an integer. 4. **Input/Output**: * Your script will read from an existing JSON file, validate and clean the data, then save the cleaned data to a new JSON file. * Assume the paths to input and output files are provided as arguments to your script. 5. **Constraints**: * Ensure that malformed data entries (e.g., non-numeric values in `price` or `quantity`) are logged and skipped during the cleaning process. * Only consider files with a `.json` extension for this task. 6. **Performance**: * Ensure your script efficiently handles large datasets, considering potential performance bottlenecks with I/O operations. # Example Usage: ```python input_file = \\"products.json\\" output_file = \\"cleaned_products.json\\" data = load_json(input_file) if validate_data(data): cleaned_data = clean_data(data) save_json(cleaned_data, output_file) else: print(\\"Input data validation failed.\\") ```","solution":"import json def load_json(file_path: str) -> list[dict]: with open(file_path, \'r\') as file: return json.load(file) def validate_data(data: list[dict]) -> bool: required_fields = {\\"product_id\\", \\"name\\", \\"price\\", \\"quantity\\"} for entry in data: if not all(field in entry and entry[field] for field in required_fields): return False if not is_float(entry[\\"price\\"]) or not is_int(entry[\\"quantity\\"]): return False return True def is_float(value: str) -> bool: try: float(value) return True except ValueError: return False def is_int(value: str) -> bool: try: int(value) return True except ValueError: return False def clean_data(data: list[dict]) -> list[dict]: cleaned_data = [] for entry in data: try: clean_entry = { \\"product_id\\": entry[\\"product_id\\"], \\"name\\": entry[\\"name\\"].strip().title(), \\"price\\": round(float(entry[\\"price\\"]), 2), \\"quantity\\": int(entry[\\"quantity\\"]) } cleaned_data.append(clean_entry) except (ValueError, KeyError): # Skip malformed entries continue return cleaned_data def save_json(data: list[dict], file_path: str) -> None: with open(file_path, \'w\') as file: json.dump(data, file, indent=4)"},{"question":"# Maze Path Finder with Conditional Movement A robot is situated in a grid maze represented by a 2D list of integers. Each cell of the grid can either be empty (represented by 0) or contain an obstacle (represented by 1). The robot can move only in four directions: up, down, left, and right. Your task is to determine if there is a path from the top-left corner of the maze (starting at (0, 0)) to the bottom-right corner (ending at (n-1, m-1)). The robot also has a constraint: it can only visit each cell once and cannot move to cells with obstacles. # Implementation: You need to implement a function: ```python def is_path_exists(maze: List[List[int]]) -> bool: pass ``` **Input**: - `maze` (List[List[int]]): A 2D list representing the n × m maze, where each element is either 0 (empty space) or 1 (obstacle). **Output**: - Return `True` if a path exists from the top-left corner to the bottom-right corner; otherwise, return `False`. **Constraints**: - The dimensions of the maze `n` and `m` are both between 1 and 100 inclusive. - The cell (0, 0) and the cell (n-1, m-1) are always empty (i.e., `maze[0][0] == 0` and `maze[n-1][m-1] == 0`). **Example**: ```python assert is_path_exists([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) == True assert is_path_exists([[0, 1, 1], [1, 0, 1], [1, 1, 0]]) == False ``` Your function must efficiently determine if there is a valid path from the top-left corner to the bottom-right corner by validating possible movements while respecting the constraints of the maze.","solution":"def is_path_exists(maze): from collections import deque n = len(maze) m = len(maze[0]) # Check if the starting or ending point is blocked if maze[0][0] == 1 or maze[n-1][m-1] == 1: return False # Directions for movement: right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == 0 # BFS to find if there is a path from (0, 0) to (n-1, m-1) queue = deque([(0, 0)]) maze[0][0] = -1 # Mark as visited while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): maze[nx][ny] = -1 # Mark as visited queue.append((nx, ny)) return False"},{"question":"# Question Write a Python function called `sum_of_k_smallest_elements` that computes the sum of the k smallest numbers in a given list. The function should handle cases where the input list contains duplicate values and should return the correct sum based on the smallest elements. Function Signature ```python def sum_of_k_smallest_elements(nums: list[int], k: int) -> int: pass ``` Input * `nums`: A list of integers. * `k`: A non-negative integer representing the number of smallest elements to sum. Output * Returns the sum of the k smallest elements in the list. Constraints * The length of `nums` will be in the range [0, 10^5]. * All values in `nums` will be integers within the range [-10^9, 10^9]. * `0 <= k <= len(nums)` Requirements * If there are fewer than `k` elements in the list, the function should raise a `ValueError` with the message \\"Not enough elements in the list\\". Example ```python >>> sum_of_k_smallest_elements([5, 3, 1, 7, 4], 2) 4 >>> sum_of_k_smallest_elements([7, 2, 3, 2, -1], 3) 4 >>> sum_of_k_smallest_elements([2, 1], 1) 1 >>> sum_of_k_smallest_elements([], 0) 0 >>> sum_of_k_smallest_elements([1, 2, 3], 5) Traceback (most recent call last): ... ValueError: Not enough elements in the list >>> sum_of_k_smallest_elements([3, 2, 0, -2], 0) 0 ``` Notes * Ensure the function handles edge cases appropriately, such as when `k` is 0 or when `nums` is an empty list. * Perform input validation to check for negative values of `k`, and raise a `ValueError` with the message \\"k must be non-negative\\" if `k` is negative. * Ensure that the function does not modify the input list.","solution":"def sum_of_k_smallest_elements(nums: list[int], k: int) -> int: Returns the sum of the k smallest elements in the given list of numbers. If k is greater than the length of the list, raises a ValueError. if k < 0: raise ValueError(\\"k must be non-negative\\") if k > len(nums): raise ValueError(\\"Not enough elements in the list\\") sorted_nums = sorted(nums) return sum(sorted_nums[:k])"},{"question":"# Question You are given a list of integers, where each integer occurs an even number of times, except for one integer that occurs an odd number of times. Your task is to find and return the integer that occurs an odd number of times. Write a function `find_odd_occurrence(numbers: List[int]) -> int` that takes in a list of integers and returns the integer that occurs an odd number of times. # Input - A list of integers `numbers` (1 ≤ len(numbers) ≤ 10^5), where every integer occurs an even number of times, except for one integer that occurs an odd number of times. # Output - Return the single integer that occurs an odd number of times. # Constraints - The integers may be positive or negative. - Optimize the solution to handle large lists efficiently. # Example ```python >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) 3 >>> find_odd_occurrence([10, 10, 20, 30, 30, 20, -5]) -5 ``` # Notes - You may assume that there is exactly one integer that occurs an odd number of times in the input list. - Consider using bitwise operators or other efficient methods to achieve optimal performance.","solution":"from typing import List def find_odd_occurrence(numbers: List[int]) -> int: Finds the integer that occurs an odd number of times in the list. :param numbers: List of integers where exactly one integer occurs an odd number of times. :return: The integer that occurs an odd number of times. result = 0 for number in numbers: result ^= number return result"},{"question":"# Problem Statement Design a function `has_duplicate_k_distance(arr, k)` that determines whether there are any duplicate integers in the array `arr` such that the distance between them is at most `k`. The function should return `True` if there exists at least one such pair, otherwise, it should return `False`. # Input Format: - A list `arr` of integers. - An integer `k` representing the maximum allowed distance between duplicate elements. # Output Format: - Return a boolean value, `True` or `False`. # Constraints: - 1 ≤ len(arr) ≤ 10^5 - 1 ≤ k ≤ 10^5 - -10^9 ≤ arr[i] ≤ 10^9 # Example: ```python has_duplicate_k_distance([1, 2, 3, 1], 3) # True (1 is repeated and the distance between the two 1\'s is 3) has_duplicate_k_distance([1, 2, 3, 1], 2) # False (1 is repeated but the distance is greater than 2) has_duplicate_k_distance([1, 2, 3, 4, 5], 3) # False (no duplicates) has_duplicate_k_distance([], 3) # False (empty array) has_duplicate_k_distance([1, 1, 1, 1, 1], 1) # True (1 is repeated and the distance between any two 1\'s is at most 1) ``` # Task Requirements: - Implement the function `has_duplicate_k_distance` that returns True or False based on the above criteria. - Your solution should efficiently handle large input sizes with a time complexity ideally around O(n). # Notes: - The function should account for edge cases such as: - Empty arrays - Arrays with only one element - Large values of `k` that exceed the length of the array ```python def has_duplicate_k_distance(arr, k): # Implement an efficient algorithm to detect duplicates within the given distance here pass ``` # Implementation Hints: - Consider using a sliding window or hash map approach to solve the problem efficiently.","solution":"def has_duplicate_k_distance(arr, k): Determines whether there are any duplicate integers in the array arr such that the distance between them is at most k. Returns True if there exists at least one such pair, otherwise returns False. if not arr: return False value_indices = {} for i, value in enumerate(arr): if value in value_indices and i - value_indices[value] <= k: return True value_indices[value] = i return False"},{"question":"# Problem Statement You are tasked with writing a function that generates all possible anagrams of a given word. An anagram of a word is a rearrangement of its letters into a new word or phrase, using all the original letters exactly once. Given a string `word`, write a function `generate_anagrams` that returns a list of all unique anagrams of the given word. Function Signature ```python def generate_anagrams(word: str) -> List[str]: pass ``` # Input * `word` (str): The word for which anagrams need to be generated. The word will consist only of lowercase alphabetic characters and will have a length between 1 and 8 inclusive. # Output * (List[str]): A list of all unique anagrams of the word in any order. # Constraints * The length of the `word` will be between 1 and 8 characters. * The `word` will consist only of lowercase alphabetic characters. # Example ```python print(generate_anagrams(\'abc\')) # Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] print(generate_anagrams(\'aab\')) # Output: [\'aab\', \'aba\', \'baa\'] print(generate_anagrams(\'z\')) # Output: [\'z\'] ``` # Note * The output list should contain all unique anagrams, regardless of their order. * The function should handle all edge cases efficiently within the given constraints. * Consider utilizing Python\'s `itertools.permutations` for generating combinations efficiently. **Performance Requirements**: The implemented function should handle all possible permutations of the input word with a length up to 8 characters efficiently.","solution":"from itertools import permutations def generate_anagrams(word: str): Generates all unique anagrams of a given word. Parameters: - word (str): The word for which anagrams need to be generated. Returns: - List[str]: A list of all unique anagrams of the word. anagrams = set([\'\'.join(p) for p in permutations(word)]) return list(anagrams)"},{"question":"# Binary Search Tree Traversal and Operations You are given a Binary Search Tree (BST) class with basic functionality. Your task is to enhance this BST class by implementing additional traversal methods and operations. You need to ensure that the enhancements are modular and maintain the integrity of the existing class. # Task Requirements: 1. **In-Order Traversal**: * Implement the in-order traversal method that returns the elements of the BST in sorted order. 2. **Pre-Order Traversal**: * Implement the pre-order traversal method that returns the elements of the BST in the order they are visited. 3. **Post-Order Traversal**: * Implement the post-order traversal method that returns the elements of the BST in the order they are visited. 4. **Height Calculation**: * Add a method to calculate the height of the tree, which is the number of edges on the longest path from the root to a leaf. 5. **Level-Order Traversal**: * Implement a level-order traversal (or breadth-first traversal) method that processes the nodes level by level from the root. # Input and Output Formats: - **Input**: - A sequence of integers to be inserted into the BST. - Specific operations to perform on the BST such as traversal or height calculation. - **Output**: - Results of the traversal methods (a list of integers). - The height of the tree as an integer. # Constraints: - Assume that the input sequence consists of distinct integers. - The BST class should handle any integer inputs within the range of typical 32-bit signed integers. # Scenario: Your company is developing a library management system where books are stored in a BST based on their unique ISBN numbers. To efficiently manage book inventory, different traversal methods and tree height calculation are required to provide various views of the book collection. # Code Skeleton: ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.value: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def inorder_traversal(self) -> list: result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node: self._inorder_recursive(node.left, result) result.append(node.value) self._inorder_recursive(node.right, result) def preorder_traversal(self) -> list: result = [] self._preorder_recursive(self.root, result) return result def _preorder_recursive(self, node, result): if node: result.append(node.value) self._preorder_recursive(node.left, result) self._preorder_recursive(node.right, result) def postorder_traversal(self) -> list: result = [] self._postorder_recursive(self.root, result) return result def _postorder_recursive(self, node, result): if node: self._postorder_recursive(node.left, result) self._postorder_recursive(node.right, result) result.append(node.value) def height(self) -> int: return self._height_recursive(self.root) def _height_recursive(self, node) -> int: if node is None: return 0 else: left_height = self._height_recursive(node.left) right_height = self._height_recursive(node.right) return max(left_height, right_height) + 1 def level_order_traversal(self) -> list: result = [] if self.root is None: return result queue = [self.root] while queue: node = queue.pop(0) result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def example_bst_operations(): bst = BinarySearchTree() elements = [50, 30, 20, 40, 70, 60, 80] for elem in elements: bst.insert(elem) print(\\"In-order Traversal:\\") print(bst.inorder_traversal()) print(\\"Pre-order Traversal:\\") print(bst.preorder_traversal()) print(\\"Post-order Traversal:\\") print(bst.postorder_traversal()) print(\\"Level-order Traversal:\\") print(bst.level_order_traversal()) print(\\"Height of the tree:\\") print(bst.height()) if __name__ == \'__main__\': example_bst_operations() ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.value: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def inorder_traversal(self) -> list: result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node: self._inorder_recursive(node.left, result) result.append(node.value) self._inorder_recursive(node.right, result) def preorder_traversal(self) -> list: result = [] self._preorder_recursive(self.root, result) return result def _preorder_recursive(self, node, result): if node: result.append(node.value) self._preorder_recursive(node.left, result) self._preorder_recursive(node.right, result) def postorder_traversal(self) -> list: result = [] self._postorder_recursive(self.root, result) return result def _postorder_recursive(self, node, result): if node: self._postorder_recursive(node.left, result) self._postorder_recursive(node.right, result) result.append(node.value) def height(self) -> int: return self._height_recursive(self.root) def _height_recursive(self, node) -> int: if node is None: return 0 else: left_height = self._height_recursive(node.left) right_height = self._height_recursive(node.right) return max(left_height, right_height) + 1 def level_order_traversal(self) -> list: result = [] if self.root is None: return result queue = [self.root] while queue: node = queue.pop(0) result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"# Coding Assessment Question: String Manipulation and Palindrome Check You are tasked with implementing two essential string manipulation functions related to palindrome checks: identifying if a string can be rearranged into a palindrome and finding the longest palindrome substring within a string. - **Function 1: `can_form_palindrome(s: str) -> bool`** - **Description**: Determine if the input string can be rearranged into a palindrome. - **Input**: A string consisting of lowercase alphabets. - **Output**: A boolean indicating if the string can be rearranged into a palindrome. - **Constraints**: - The input must be a non-empty string of lowercase alphabets. - **Edge Cases**: - Raise a `ValueError` for empty string inputs. - **Function 2: `longest_palindrome_substring(s: str) -> str`** - **Description**: Find the longest palindromic substring within the given string. - **Input**: A string of lowercase alphabets. - **Output**: A substring which is the longest palindrome within the given string. - **Constraints**: - The input must be a non-empty string of lowercase alphabets. - **Edge Cases**: - Raise a `ValueError` for empty string inputs. Example: ```python # Example Function Call: print(can_form_palindrome(\\"civic\\")) # Output: True print(can_form_palindrome(\\"ivicc\\")) # Output: True print(can_form_palindrome(\\"hello\\")) # Output: False print(longest_palindrome_substring(\\"babad\\")) # Output: \\"bab\\" or \\"aba\\" print(longest_palindrome_substring(\\"cbbd\\")) # Output: \\"bb\\" # Example Invalid Call: print(can_form_palindrome(\\"\\")) # Output: Raises ValueError # Empty string example: print(longest_palindrome_substring(\\"\\")) # Output: Raises ValueError ``` Performance Requirement: - The `can_form_palindrome` function should operate in linear time, O(n), where n is the length of the string. - The `longest_palindrome_substring` function should operate in quadratic time, O(n^2), where n is the length of the string. **Notes**: - You can assume the input strings will have a length of up to 10^4 characters. - Use proper exception handling to deal with invalid input scenarios. Implement the functions according to the given specifications.","solution":"def can_form_palindrome(s: str) -> bool: Determine if the input string can be rearranged into a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged into a palindrome, False otherwise. Raises: ValueError: If the input string is empty. if not s: raise ValueError(\\"Input string cannot be empty\\") from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def longest_palindrome_substring(s: str) -> str: Find the longest palindromic substring within the given string. Args: s (str): The input string. Returns: str: The longest palindromic substring. Raises: ValueError: If the input string is empty. if not s: raise ValueError(\\"Input string cannot be empty\\") n = len(s) start, max_length = 0, 1 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True start = i max_length = length return s[start:start + max_length]"},{"question":"# Median Finder Scenario You are tasked with developing a feature for a data analytics tool that computes the median of a dynamically changing list of numbers. The list will allow for the addition of new numbers and should provide the current median efficiently after each addition. Problem Statement Write a class `MedianFinder` that manages a list of numbers and provides the ability to add new numbers and find the median of the list at any given point. Input and Output * **Input**: Instances and method calls to the `MedianFinder` class: - `__init__()`: Initializes the MedianFinder object. - `add_num(num)`: Adds the integer `num` to the list. - `find_median()`: Returns the median of all numbers added so far as a float. Constraints: * The number of calls to `add_num` and `find_median` are both up to 10^5. * All inputs to the `add_num` method are valid integers in the range [-10^6, 10^6]. Example: ```python >>> mf = MedianFinder() >>> mf.add_num(1) >>> mf.add_num(2) >>> mf.find_median() 1.5 >>> mf.add_num(3) >>> mf.find_median() 2.0 ``` Requirements: * The `add_num` method should run efficiently to handle the case of large sequence inputs. * The `find_median` method should efficiently provide the median of the sequence so far. Notes: * Consider using two heaps (a max heap and a min heap) to maintain a balance of elements for efficient median finding. * Ensure the class handles edge cases, such as an empty list or large sequences, gracefully.","solution":"import heapq class MedianFinder: def __init__(self): Initialize two heaps: - A max heap for the lower half of the numbers. - A min heap for the upper half of the numbers. self.lower_half = [] # Max heap (inverted to use min heap) self.upper_half = [] # Min heap def add_num(self, num: int) -> None: Add a new number to the data structure. # Add to max heap heapq.heappush(self.lower_half, -num) # Balance the heaps if self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0]): heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Ensure the lower half has equal or one more element than the upper half if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def find_median(self) -> float: Find the median of the numbers added so far. if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] else: return (-self.lower_half[0] + self.upper_half[0]) / 2"},{"question":"# Question Context Sorting algorithms are fundamental tools in computer science for organizing data. Each algorithm comes with its own set of advantages and disadvantages depending on the nature of the data and the requirements for sort stability and performance. Problem Statement You are given a list of words and a dictionary order for the characters (which may differ from the usual alphabetical order). Implement the function `sort_words_custom_order` that sorts the words according to the provided custom order of characters. # Function Signature ```python def sort_words_custom_order(words: list[str], custom_order: str) -> list[str]: Sorts a list of words according to a custom character order. :param words: A list of strings where each string represents a word. :param custom_order: A string representing the custom order of characters. :return: A list of strings sorted according to the custom character order. Example: >>> sort_words_custom_order([\\"cat\\", \\"bat\\", \\"rat\\"], \\"cbrta\\") [\'cat\', \'bat\', \'rat\'] ``` # Constraints: * The list `words` is guaranteed to have between 1 and 1000 words. * Each word contains only characters present in `custom_order`. * The length of `custom_order` will be between 1 and 26 and will include unique characters only. * The dictionary order provided in `custom_order` will determine the precedence of characters in sorting the words. # Requirements: 1. **Definition of Custom Order:** Use the given `custom_order` to define precedence for sorting characters. 2. **Stable Sorting:** Ensure that the words are sorted stably. 3. **Edge Case Handling:** Proper handling of cases where words might have the same set of characters. 4. **Performance:** Efficient implementation to handle the sorting of up to 1000 words. # Example: ```python >>> sort_words_custom_order([\\"banana\\", \\"apple\\", \\"orange\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") [\'orange\', \'banana\', \'apple\'] ``` # Additional Notes: * You may use standard libraries for sorting but ensure that the custom order of characters is respected. * Consider the use of dictionaries for mapping characters to their custom order indices to create an effective sorting mechanism.","solution":"def sort_words_custom_order(words: list[str], custom_order: str) -> list[str]: Sorts a list of words according to a custom character order. :param words: A list of strings where each string represents a word. :param custom_order: A string representing the custom order of characters. :return: A list of strings sorted according to the custom character order. char_position = {char: idx for idx, char in enumerate(custom_order)} def custom_key(word): return [char_position[char] for char in word] return sorted(words, key=custom_key)"},{"question":"# Matrix Transpose and Multiplication Challenge **Objective**: Implement functions to compute the transpose of a matrix and to multiply two matrices, ensuring the operations are efficiently handled for large matrices. Function Signatures ```python def transpose(matrix: List[List[int]]) -> List[List[int]]: ``` ```python def multiply_matrices(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: ``` Input * `matrix` (List[List[int]]): A 2D list representing the input matrix to be transposed. * `matrix_a` (List[List[int]]): A 2D list representing the first matrix to be multiplied. * `matrix_b` (List[List[int]]): A 2D list representing the second matrix to be multiplied. Output * For transpose function: A 2D list representing the transposed matrix. * For multiply_matrices function: A 2D list representing the resulting matrix product. Constraints * The matrices will be non-empty and will have valid dimensions for matrix multiplication. * The matrix should be well-formed (i.e., all rows should be of the same length). * Raise `ValueError` if the matrices cannot be multiplied due to incompatible dimensions. Example Usage: ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> transpose(matrix) [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] >>> matrix_a = [ ... [1, 2], ... [3, 4] ... ] >>> matrix_b = [ ... [5, 6], ... [7, 8] ... ] >>> multiply_matrices(matrix_a, matrix_b) [ [19, 22], [43, 50] ] ``` # Additional Requirements * Ensure proper documentation with example cases for clarification. * Include input validation and handle edge cases such as empty matrices and non-uniform row lengths gracefully. # Context Matrix operations are fundamental in various fields of computer science and engineering, particularly in algorithms, data science, and machine learning. Efficient and accurate implementation of matrix transposition and multiplication is essential for performance-intensive applications and numerical computations.","solution":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given matrix. :param matrix: A 2D list representing the input matrix. :return: A 2D list representing the transposed matrix. if not matrix or not matrix[0]: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] def multiply_matrices(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Returns the product of two matrices. :param matrix_a: A 2D list representing the first matrix. :param matrix_b: A 2D list representing the second matrix. :return: A 2D list representing the resulting matrix product. :raises ValueError: If the matrices cannot be multiplied due to incompatible dimensions. if not matrix_a or not matrix_b or not matrix_a[0] or not matrix_b[0]: raise ValueError(\\"Input matrices cannot be empty.\\") rows_a, cols_a = len(matrix_a), len(matrix_a[0]) rows_b, cols_b = len(matrix_b), len(matrix_b[0]) if cols_a != rows_b: raise ValueError(\\"Incompatible dimensions for matrix multiplication.\\") result = [[0] * cols_b for _ in range(rows_a)] for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Question: Sum of Unique Numbers in a List Context: You need to write a function that computes the sum of all unique numbers in a given list. A number is considered unique if it appears exactly once in the list. Task: Write a function, `sum_of_unique`, that takes a list of integers `numbers` and returns the sum of all numbers that appear exactly once in the list. Function Signature: ```python def sum_of_unique(numbers: list) -> int: pass ``` Input: * `numbers` (0 ≤ len(numbers) ≤ 10^5): A list of integers where each integer `number` satisfies `-10^6 ≤ number ≤ 10^6`. Output: * Return an integer representing the sum of all unique numbers in the list. Examples: ```python >>> sum_of_unique([1, 2, 3, 2]) 4 >>> sum_of_unique([4, 4, 4, 4]) 0 >>> sum_of_unique([10, 20, 10, 30]) 50 >>> sum_of_unique([1]) 1 >>> sum_of_unique([-1, -1, -2, -3, -2, -4]) -7 >>> sum_of_unique([]) 0 ``` # Constraints: * Your solution should have an average time complexity of O(n) and space complexity of O(n). # Additional Notes: * Consider edge cases such as an empty list, a list with all duplicate numbers, or a list where all the numbers are unique. * Ensure that the solution handles both positive and negative numbers correctly.","solution":"def sum_of_unique(numbers): Returns the sum of all unique numbers in the given list. from collections import Counter # Count the frequency of each number in the list num_count = Counter(numbers) # Compute the sum of numbers that appear exactly once unique_sum = sum(num for num, count in num_count.items() if count == 1) return unique_sum"},{"question":"# Coding Assessment Question Scenario You are designing an application that allows users to manage their daily schedules. Part of this application requires determining the optimal times for completing a set of tasks where each task takes a specific amount of time. Some tasks depend on the completion of others before they can start. Problem Statement Write a function `calculate_completion_time(tasks: List[Tuple[int, int, List[int]]]) -> int` that calculates the minimum total time required to complete all tasks. Each task is represented by a tuple (task_id, duration, dependencies), where `task_id` is a unique integer identifier for the task, `duration` is the time in minutes it takes to complete the task, and `dependencies` is a list of task_ids that must be completed before this task can start. # Input: * A list `tasks` of tuples where each tuple contains: * `task_id` (int): Unique identifier of the task. * `duration` (int): Time in minutes required to complete the task. * `dependencies` (List[int]): List of task_ids that must be completed before this task can start. # Output: * An integer representing the minimum total time required to complete all tasks. If it is not possible due to cyclic dependencies, return `-1`. # Constraints: * (1 leq text{number of tasks} leq 10^4) * (1 leq text{duration} leq 10^3) * Dependencies form a Directed Acyclic Graph (DAG). # Example: ```python tasks_1 = [(0, 5, []), (1, 10, []), (2, 2, [0, 1]), (3, 3, [1]), (4, 7, [2, 3])] # Explanation: Task 0 takes 5 minutes and can start immediately. Task 1 takes 10 minutes and can start immediately. # Task 2 starts after both Task 0 and Task 1 are done, which is at minute 10. Task 3 starts after Task 1 completes at minute 10. # Task 4 starts after both Task 2 and Task 3 are done, which is at minute 13. assert calculate_completion_time(tasks_1) == 20 tasks_2 = [(0, 1, [1]), (1, 1, [0])] # Explanation: There is a cycle between tasks 0 and 1. assert calculate_completion_time(tasks_2) == -1 ``` Function Signature ```python from typing import List, Tuple def calculate_completion_time(tasks: List[Tuple[int, int, List[int]]]) -> int: pass ``` # Notes: * Ensure to use an efficient algorithm to handle the dependencies and calculate cumulative durations to avoid excessive computational overhead. * You may use topological sorting and dynamic programming to determine the optimal task completion times.","solution":"from typing import List, Tuple, Dict from collections import defaultdict, deque def calculate_completion_time(tasks: List[Tuple[int, int, List[int]]]) -> int: def topological_sort(num_tasks: int, graph: Dict[int, List[int]], in_degree: Dict[int, int]) -> List[int]: queue = deque([task for task in range(num_tasks) if in_degree[task] == 0]) topo_order = [] while queue: current = queue.popleft() topo_order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(topo_order) == num_tasks: return topo_order else: return [] # Indicates a cycle exists num_tasks = len(tasks) graph = defaultdict(list) in_degree = {task[0]: 0 for task in tasks} duration = {task[0]: task[1] for task in tasks} for task_id, dur, deps in tasks: for dep in deps: graph[dep].append(task_id) in_degree[task_id] += 1 topo_order = topological_sort(num_tasks, graph, in_degree) if not topo_order: return -1 completion_time = {task_id: 0 for task_id in in_degree} for task_id in topo_order: for neighbor in graph[task_id]: completion_time[neighbor] = max(completion_time[neighbor], completion_time[task_id] + duration[task_id]) return max(completion_time[task_id] + duration[task_id] for task_id in in_degree)"},{"question":"**Sum of Unique Elements** # Context Given a list of integers, you need to calculate the sum of elements that appear exactly once in the list. For instance, in the list [1, 2, 3, 2, 4], the numbers 1, 3, and 4 each appear exactly once, so their sum is 1 + 3 + 4 = 8. # Task Write a function `sum_of_unique_elements(data: List[int]) -> int` that takes a list of integers as input and returns the sum of elements which appear exactly once in the list. # Input Format A list `data` containing integers which can be: * positive, * negative, * or zero. # Output Format An integer value representing the sum of elements appearing exactly once in the list. # Constraints * The input list must contain integers. * The list can be empty. # Example ```python >>> sum_of_unique_elements([1, 2, 3, 2, 4]) 8 >>> sum_of_unique_elements([4, 5, 6, 7, 4, 4, 5]) 13 >>> sum_of_unique_elements([-1, -2, -3, -2]) -4 >>> sum_of_unique_elements([100, 200, 300, 400, 100, 200]) 700 >>> sum_of_unique_elements([]) 0 ``` # Constraints 1. Ensure the function correctly handles edge cases, such as empty lists or lists with only one element. 2. Aim for an efficient solution ideally with a time complexity of (O(n)), where (n) is the number of elements in the input list. # Note * Utilize Python\'s in-built data structures wisely to achieve the desired time complexity. * You are not allowed to use any third-party libraries. # Optional Extension Implement an additional function to: * Generate a dictionary that maps each element to the frequency of its occurrence in the list.","solution":"from typing import List def sum_of_unique_elements(data: List[int]) -> int: Return the sum of elements that appear exactly once in the list. from collections import Counter element_counts = Counter(data) unique_sum = sum(num for num, count in element_counts.items() if count == 1) return unique_sum"},{"question":"Problem Statement As part of a numerically intensive project, you need to implement an algorithm to determine the prime factors of a given positive integer. Write a Python class that efficiently calculates and stores the prime factors of numbers up to a specified maximum value. # Function Signature: ```python class PrimeFactors: def __init__(self, max_value: int) -> None: Initialize the class with the maximum value to consider. Args: max_value (int): The maximum value for which prime factors will be computed. def get_factors(self, number: int) -> list: Get the prime factors of a given number. Args: number (int): The number to factorize. Returns: list: A list of prime factors of the specified number. ``` # Input - Number (`number: int`): An integer value representing the number to be factorized. The number is guaranteed to be a positive integer and less than or equal to the `max_value` specified during initialization. # Output - A list of integers representing the prime factors of the given number. # Constraints - The input `number` for `get_factors` will always be a positive integer. - The input to `get_factors` will be less than or equal to `max_value`. # Example ```python # Creating an instance of the PrimeFactors class with a maximum value of 100 prime_factors = PrimeFactors(100) # Requesting the prime factors of the number 60 print(prime_factors.get_factors(60)) # Output: [2, 2, 3, 5] # Requesting the prime factors of the number 97 (a prime number) print(prime_factors.get_factors(97)) # Output: [97] # Requesting the prime factors of the number 100 print(prime_factors.get_factors(100)) # Output: [2, 2, 5, 5] ``` # Additional Notes - Ensure that the class efficiently handles multiple requests for prime factors by reusing previously computed data where possible. - If the initialized `max_value` is less than the requested number in `get_factors`, raise a `ValueError` with an appropriate message.","solution":"class PrimeFactors: def __init__(self, max_value: int) -> None: Initialize the class with the maximum value to consider. Args: max_value (int): The maximum value for which prime factors will be computed. self.max_value = max_value self.sieve = self._generate_sieve(max_value) def _generate_sieve(self, limit: int) -> list: Generate a list that marks composite numbers with their smallest prime factors. Args: limit (int): The upper bound for the sieve. Returns: list: A list where sieve[i] is the smallest prime factor of i. sieve = list(range(limit + 1)) sieve[0] = sieve[1] = 0 for start in range(2, int(limit**0.5) + 1): if sieve[start] == start: # start is a prime number for multiple in range(start * start, limit + 1, start): if sieve[multiple] == multiple: sieve[multiple] = start return sieve def get_factors(self, number: int) -> list: Get the prime factors of a given number. Args: number (int): The number to factorize. Returns: list: A list of prime factors of the specified number. if number > self.max_value: raise ValueError(f\\"The number {number} exceeds the maximum value {self.max_value}.\\") factors = [] while number > 1: prime_factor = self.sieve[number] factors.append(prime_factor) number //= prime_factor return factors"},{"question":"Problem Statement You are working on a simple banking system where each account has a unique account number and a balance. Your task is to implement a function `process_transactions()` that takes a list of transactions and an initial state of accounts, processes the transactions, and returns the final state of the accounts. Each transaction in the list is a dictionary with three keys: - `\'type\'`: The type of transaction, which can be either `\'deposit\'` or `\'withdraw\'`. - `\'account\'`: The account number as a string. - `\'amount\'`: The amount to deposit or withdraw as a float. The initial state of accounts is given as a dictionary where keys are account numbers (as strings) and values are initial balances (as floats). The function should correctly update the balances according to the transactions and handle the following cases: - If a withdrawal amount is greater than the balance available, the balance should not change. - If an account number does not exist in the initial state, it should be ignored. - The function should return the updated state of accounts as a dictionary. # Input * `transactions` (list): A list of dictionaries representing transactions. * `initial_state` (dictionary): A dictionary representing the initial state of accounts. # Output * A dictionary representing the final state of accounts. # Examples ```python initial_state = {\\"123\\": 100.0, \\"456\\": 150.0} transactions = [ {\\"type\\": \\"deposit\\", \\"account\\": \\"123\\", \\"amount\\": 50.0}, {\\"type\\": \\"withdraw\\", \\"account\\": \\"123\\", \\"amount\\": 25.0}, {\\"type\\": \\"withdraw\\", \\"account\\": \\"456\\", \\"amount\\": 160.0}, {\\"type\\": \\"deposit\\", \\"account\\": \\"789\\", \\"amount\\": 100.0} ] process_transactions(transactions, initial_state) # Expected output: {\'123\': 125.0, \'456\': 150.0} ``` # Constraints * Ensure the function handles invalid transactions appropriately by ignoring them. * The account numbers and balances in the initial state are guaranteed to be valid. * Round the balances to two decimal places where necessary.","solution":"def process_transactions(transactions, initial_state): Processes a list of transactions and updates the initial state of accounts accordingly. Parameters: transactions (list): A list of dictionaries representing transactions. initial_state (dict): A dictionary representing the initial state of accounts. Returns: dict: The updated state of accounts. accounts = initial_state.copy() for transaction in transactions: account = transaction.get(\'account\') amount = transaction.get(\'amount\') if account in accounts and isinstance(amount, (int, float)) and amount >= 0: if transaction.get(\'type\') == \'deposit\': accounts[account] += amount elif transaction.get(\'type\') == \'withdraw\' and accounts[account] >= amount: accounts[account] -= amount # Rounding all balances to two decimal places for account in accounts: accounts[account] = round(accounts[account], 2) return accounts"},{"question":"# Question: Count Sorted Vowel Strings Context In combinatorial mathematics, it is essential to understand how to count combinations and permutations. This problem requires counting the number of sorted vowel strings that can be formed. It will assess your knowledge of dynamic programming or combinatorial counting methods. Problem Statement Write a function `count_vowel_strings(n: int) -> int` that returns the number of strings of length `n` that consist only of vowels (a, e, i, o, u) and are lexicographically sorted. Input - `n` (int): The length of the strings. This value is an integer where `1 <= n <= 50`. Output - `int`: The total number of lexicographically sorted strings of length `n` that can be formed using the vowels. Constraints - You should consider efficient solutions as `n` can be as large as 50. - The vowels in the strings must appear in non-decreasing order. Hint - Consider the use of dynamic programming or combinatorial counting techniques to solve this problem. - Observe that for each vowel, the corresponding count of possible substrings can be derived from the counts of (n-1) for the same and later vowels. Example ```python def count_vowel_strings(n: int) -> int: # Your code here print(count_vowel_strings(1)) # Output: 5 print(count_vowel_strings(2)) # Output: 15 print(count_vowel_strings(3)) # Output: 35 print(count_vowel_strings(4)) # Output: 70 ```","solution":"def count_vowel_strings(n: int) -> int: Returns the number of lexicographically sorted strings of length n that can be formed using the vowels (a, e, i, o, u). # Initial base case: for strings of length 1 dp = [1] * 5 for _ in range(1, n): for j in range(3, -1, -1): dp[j] += dp[j + 1] return sum(dp)"},{"question":"# Problem Statement A linked list is a linear data structure where elements are not stored at contiguous memory locations. Instead, each element, or node, points to the next element by means of a pointer. Reverse traversing such a list can be challenging as there is no direct link to the previous element. Your task is to write a function that reverses a singly linked list. Given the head of a singly linked list, the function should return the head of the reversed linked list. # Input Format 1. A singly linked list. # Output Format - The head node of the reversed singly linked list. # Constraints - The number of nodes in the linked list is in the range ( text{0} leq text{n} leq text{10}^4 ). - The values of the nodes are in the range (-10^5 leq text{node value} leq 10^5). # Performance Requirements - Your solution should run efficiently for a linked list with size up to 10,000 nodes. - Aim for a time complexity of (O(n)) and a space complexity of (O(1)). # Examples 1. **Input**: ``` 1 -> 2 -> 3 -> 4 -> 5 -> None ``` **Output**: ``` 5 -> 4 -> 3 -> 2 -> 1 -> None ``` 2. **Input**: ``` None ``` **Output**: ``` None ``` 3. **Input**: ``` 7 -> 8 -> None ``` **Output**: ``` 8 -> 7 -> None ``` # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: # Your code here ``` # Notes - Ensure your implementation efficiently handles all edge cases, such as an empty list, a single node, and a typical multi-node list. - Avoid using built-in reversal or any additional data structures.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None curr = head while curr: next_temp = curr.next # store next node curr.next = prev # reverse the link prev = curr # move prev pointer up curr = next_temp # move curr pointer up return prev # prev will be the new head at the end of the loop"},{"question":"# Attendance Report for Employees Your task is to develop a function that calculates the total number of days each employee has attended work in a given month, based on the given attendance records. The attendance records are represented using a list of strings, where each string contains the date and the names of the employees who attended work that day. Each string follows the format \\"YYYY-MM-DD: Name1, Name2, ...\\". Your function should return a dictionary where the keys are the employee names and the values are the number of days they attended. Implementation: You need to implement a function: ```python def calculate_attendance(records: List[str]) -> dict: pass ``` **Input**: - `records` (List[str]): A list of strings containing the attendance records. **Output**: - Return a dictionary where the keys are employee names and the values are the number of days they attended. **Constraints**: - The dates in the records are always valid. - Employee names are case-sensitive. - Each date appears only once in the records. - The `records` list is not empty and contains at least one attendance record. **Example**: ```python records = [ \\"2023-01-01: Alice, Bob, Charlie\\", \\"2023-01-02: Alice, Charlie\\", \\"2023-01-03: Bob, Charlie\\" ] assert calculate_attendance(records) == {\\"Alice\\": 2, \\"Bob\\": 2, \\"Charlie\\": 3} ``` In this example, Alice attended work on two days, Bob attended on two days, and Charlie attended on three days. Make sure your function accurately parses the records and calculates the attendance count for each employee.","solution":"from typing import List, Dict def calculate_attendance(records: List[str]) -> Dict[str, int]: attendance_dict = {} for record in records: date, attendees = record.split(\\": \\") names = attendees.split(\\", \\") for name in names: if name in attendance_dict: attendance_dict[name] += 1 else: attendance_dict[name] = 1 return attendance_dict"},{"question":"You are given a set of functions for performing various operations on strings. Your task is to implement the function `longest_common_subsequence` with optimized performance and detailed testing for various edge cases. # Context The function `longest_common_subsequence` is used to find the longest subsequence common to two sequences. A subsequence is a sequence that appears in the same relative order but not necessarily consecutively. # Function Signature ```python def longest_common_subsequence(seq1: str, seq2: str) -> str: Computes the longest common subsequence between two given strings. :param seq1: First input string. :param seq2: Second input string. :return: The longest common subsequence as a string. ``` # Requirements 1. Your function should optimize the existing `longest_common_subsequence` function to handle longer strings efficiently. 2. Implement checks for edge cases like empty strings and ensure appropriate handling. 3. Optimize the longest common subsequence finding process with an appropriate algorithm. 4. Ensure your solution has detailed testing for various edge cases. # Input Constraints * The strings seq1 and seq2 will contain only lowercase English alphabets. * The lengths of both strings will be between 0 and 1000. # Example ```python # Testing the longest_common_subsequence function seq1 = \\"abcde\\" seq2 = \\"ace\\" print(longest_common_subsequence(seq1, seq2)) # Expected output: \\"ace\\" seq1 = \\"abc\\" seq2 = \\"def\\" print(longest_common_subsequence(seq1, seq2)) # Expected output: \\"\\" ``` # Guidelines * Your function must handle and return appropriate values for exceptional cases such as empty strings. * The optimization must consider reducing time complexity to handle longer input strings effectively. * Comment your code appropriately to explain your logic and any optimizations applied.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> str: Computes the longest common subsequence between two given strings. :param seq1: First input string. :param seq2: Second input string. :return: The longest common subsequence as a string. # Create a 2D array to store lengths of longest common subsequence # dp[i][j] will be storing the length of LCS of seq1[0..i-1] and seq2[0..j-1] dp = [[0] * (len(seq2) + 1) for _ in range(len(seq1) + 1)] # Fill dp array for i in range(1, len(seq1) + 1): for j in range(1, len(seq2) + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the longest common subsequence from the dp array i, j = len(seq1), len(seq2) lcs = [] while i > 0 and j > 0: if seq1[i - 1] == seq2[j - 1]: lcs.append(seq1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return \\"\\".join(reversed(lcs))"},{"question":"# Question You are given an integer array `nums` of length `n`, which consists of positive integers, and an integer target `k`. Your task is to determine if there is a subarray within `nums` whose length is exactly `k` and the sum of its elements is a prime number. If such a subarray exists, return `True`, otherwise, return `False`. Write a function `subarray_sum_is_prime(nums: List[int], k: int) -> bool` that accepts: - `nums`: A list of integers representing the input array. - `k`: An integer representing the length of the subarray. The function should return a boolean indicating whether there is a subarray of length `k` with a prime sum. Example ```python nums = [2, 3, 5, 1, 6, 4, 7] k = 3 assert subarray_sum_is_prime(nums, k) == True # Subarray [2, 3, 5] has sum 10, which is not prime. Subarray [3, 5, 1] has sum 9, which is not prime. Subarray [5, 1, 6] has sum 12, which is not prime. Subarray [1, 6, 4] has sum 11, which is prime. ``` Constraints - `1 <= n <= 1000` - `1 <= nums[i] <= 10^6` - `1 <= k <= n` Notes - A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. - Consider implementing an efficient algorithm to check for primality, such as the Sieve of Eratosthenes for generating prime numbers up to a certain limit. Hints - Use a sliding window approach to efficiently calculate the sum of each subarray of length `k`. - Optimize the primality check to ensure the function runs efficiently for larger values of `n` and `nums[i]`.","solution":"import math from typing import List def is_prime(number: int) -> bool: Checks if a number is a prime. if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def subarray_sum_is_prime(nums: List[int], k: int) -> bool: Determines if there is a subarray of length k with a prime sum. if k > len(nums): return False # Calculate the sum of the first k elements current_sum = sum(nums[:k]) # Check if the sum of the first subarray is prime if is_prime(current_sum): return True # Use sliding window to calculate the sum of other subarrays of length k for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] if is_prime(current_sum): return True return False"},{"question":"# Matrix Multiplication with Blocking Optimization You are tasked with optimizing a matrix multiplication program by implementing a blocking algorithm. Matrix multiplication can be optimized by dividing the matrices into smaller sub-blocks that fit into the cache, which reduces cache misses and improves performance. # Requirements: 1. Implement the blocked matrix multiplication algorithm using a specified block size. 2. Ensure that your implementation falls back to the naive algorithm if the block size is larger than the matrix dimensions. 3. Handle cases where the matrix dimensions are not perfectly divisible by the block size. 4. Provide appropriate documentation and tests for your implementation. # Constraints: * Assume the input matrices are square matrices of size (N times N). * Assume (N) is reasonably small (e.g., less than 5000) considering computational and memory limitations. * Do not use additional external libraries beyond NumPy. # Input Format: You will receive: * Two matrices `A` and `B`, both of shape (N times N). * An integer `block_size` specifying the size of the blocks for the blocking algorithm. # Output Format: The function should return: * A matrix `C` of shape (N times N) which is the result of multiplying `A` and `B` using the blocked algorithm. # Example Usage: ```python import numpy as np def blocked_matrix_multiplication(A, B, block_size): N = A.shape[0] C = np.zeros((N, N)) # Check if block_size is suitable if block_size > N: for i in range(N): for j in range(N): for k in range(N): C[i, j] += A[i, k] * B[k, j] return C # Implement the blocking algorithm for i in range(0, N, block_size): for j in range(0, N, block_size): for k in range(0, N, block_size): # Block multiplication for ii in range(i, min(i + block_size, N)): for jj in range(j, min(j + block_size, N)): sum = 0 for kk in range(k, min(k + block_size, N)): sum += A[ii, kk] * B[kk, jj] C[ii, jj] += sum return C A = np.array([[1, 2], [3, 4]]) B = np.array([[5, 6], [7, 8]]) block_size = 1 C = blocked_matrix_multiplication(A, B, block_size) print(C) # Output: [[19. 22.] # [43. 50.]] ``` Implement the blocked matrix multiplication algorithm as specified.","solution":"import numpy as np def blocked_matrix_multiplication(A, B, block_size): Multiplies two square matrices A and B using the blocked matrix multiplication algorithm. Parameters: A (numpy.ndarray): Input matrix A of shape (N, N) B (numpy.ndarray): Input matrix B of shape (N, N) block_size (int): Size of the blocks for the blocking algorithm Returns: numpy.ndarray: The result matrix C of shape (N, N) after multiplying A and B N = A.shape[0] C = np.zeros((N, N)) # Check if block_size is suitable if block_size > N: # Fall back to naive multiplication for i in range(N): for j in range(N): for k in range(N): C[i, j] += A[i, k] * B[k, j] return C # Implement the blocking algorithm for i in range(0, N, block_size): for j in range(0, N, block_size): for k in range(0, N, block_size): # Block multiplication for ii in range(i, min(i + block_size, N)): for jj in range(j, min(j + block_size, N)): sum = 0 for kk in range(k, min(k + block_size, N)): sum += A[ii, kk] * B[kk, jj] C[ii, jj] += sum return C"},{"question":"# Scenario You are tasked with designing a function to determine if an integer is a palindrome without converting the integer to a string. Implement the `is_palindrome` function to accomplish this requirement. # Requirements **Function Signature**: ```python def is_palindrome(x: int) -> bool: pass ``` # Input & Output Formats * `is_palindrome`: * **Input**: An integer `x` * **Output**: A boolean `True` if `x` is a palindrome, and `False` otherwise. # Constraints * The function must not convert the integer to a string. * The function must handle negative numbers: all negative numbers should return `False`. # Performance Requirements * Time Complexity: O(log10(n)) where n is the value of the integer. * Space Complexity: O(1) constant space. # Example ```python >>> is_palindrome(121) True >>> is_palindrome(-121) False >>> is_palindrome(10) False >>> is_palindrome(12321) True ```","solution":"def is_palindrome(x: int) -> bool: if x < 0: return False reversed_number = 0 original_number = x while x > 0: reversed_number = reversed_number * 10 + x % 10 x //= 10 return original_number == reversed_number"},{"question":"# Custom Data Structure for Efficient Access You are tasked with creating a custom data structure that allows efficient insertions, deletions, and access to elements. This data structure must support the following operations: - **Insertion**: Add an integer to the data structure in O(log n) time. - **Deletion**: Remove an integer from the data structure in O(log n) time. - **Access**: Retrieve the `k`-th smallest element in the data structure in O(log n) time. Task 1. **Class Name**: `EfficientDataStructure` 2. **Methods**: - `insert(self, value: int) -> None`: Inserts `value` into the data structure. - `delete(self, value: int) -> None`: Removes `value` from the data structure if it exists. - `get_kth_smallest(self, k: int) -> int`: Returns the `k`-th smallest element in the data structure (1-based index). 3. **Constraints**: - The data structure will contain at most 10^5 elements at any given time. - The elements can be any integer. - You can assume `k` will always be valid and within the range of the data structure\'s current size. Example ```python class EfficientDataStructure: def __init__(self): # Your implementation here pass def insert(self, value: int) -> None: # Your implementation here pass def delete(self, value: int) -> None: # Your implementation here pass def get_kth_smallest(self, k: int) -> int: # Your implementation here pass # Example usage ds = EfficientDataStructure() ds.insert(5) ds.insert(3) ds.insert(4) ds.insert(2) print(ds.get_kth_smallest(1)) # Expected output: 2 print(ds.get_kth_smallest(3)) # Expected output: 4 ds.delete(3) print(ds.get_kth_smallest(2)) # Expected output: 4 ``` You can include unit tests to verify the correctness of your methods, especially for various edge cases such as inserting duplicates, deleting non-existing elements, and handling large datasets efficiently.","solution":"import bisect class EfficientDataStructure: def __init__(self): self.data = [] def insert(self, value: int) -> None: bisect.insort(self.data, value) def delete(self, value: int) -> None: index = bisect.bisect_left(self.data, value) if index < len(self.data) and self.data[index] == value: self.data.pop(index) def get_kth_smallest(self, k: int) -> int: return self.data[k - 1]"},{"question":"# Sort List Based on Custom Comparator You are given a list of dictionary items, each with the same structure. Different fields in the dictionary have different levels of priority while sorting. Design a function that sorts this list based on the defined order of fields. Objective Create a function `custom_sorter(items: List[Dict[str, Any]]) -> List[Dict[str, Any]]` that: 1. Sorts the list based on a priority order of fields in the dictionaries. 2. Handles different types of field values, including integers, strings, and floating points. 3. Returns the sorted list. Your task is to: - Implement the `custom_sorter` function. - Define the priority order of the fields and handle corresponding data types appropriately. - Account for potential edge cases, such as dictionaries missing some fields or having `None` values. # Function Signature ```python def custom_sorter(items: List[Dict[str, Any]]) -> List[Dict[str, Any]]: pass ``` Input - `items`: A list of dictionaries with varying fields and types of values. Output - A list of dictionaries sorted according to the specified field priority. Example ```python items = [ {\'name\': \'Alice\', \'age\': 30, \'score\': 85.7}, {\'name\': \'Bob\', \'age\': 25, \'score\': None}, {\'name\': \'Charlie\', \'age\': 35, \'score\': 90.5} ] # Assuming the priority order is: \'score\', \'age\', \'name\' # The output should sort by \'score\' descending, then \'age\' ascending, # and finally by \'name\' ascending if others are equal. print(custom_sorter(items)) # Expected output: [{\'name\': \'Charlie\', \'age\': 35, \'score\': 90.5}, {\'name\': \'Alice\', \'age\': 30, \'score\': 85.7}, {\'name\': \'Bob\', \'age\': 25, \'score\': None}] ``` # Constraints - Ensure support for mixed value types and handle missing fields properly. - Sorting should be done in a stable and predictable manner based on the defined priority. - Edge cases involving `None` values should be properly handled, possibly by treating them as the lowest possible value for sorting purposes.","solution":"from typing import List, Dict, Any def custom_sorter(items: List[Dict[str, Any]]) -> List[Dict[str, Any]]: def sorter_key(item: Dict[str, Any]): # Ensure \\"None\\" values are placed at the end by assigning them a very low or high value depending on the field. score = item.get(\'score\', float(\'-inf\')) if item.get(\'score\') is not None else float(\'-inf\') age = item.get(\'age\', float(\'inf\')) if item.get(\'age\') is not None else float(\'inf\') name = item.get(\'name\', \'\') # Return a tuple that represents the sorting order: # - \'score\' descending (multiply by -1) # - \'age\' ascending # - \'name\' ascending return (-score, age, name) return sorted(items, key=sorter_key)"},{"question":"# Problem Statement Implement a file system simulation where you will manage directories and files, along with their sizes. The system should support standard operations such as creating directories, adding files, getting the size of a directory (including all nested contents), and deleting files. # Objectives 1. **Class `FileSystem`**: - **Methods**: - **`mkdir(path: str) -> None`:** - **Input**: `path` - A string representing the path where the new directory should be created. - **Output**: None - **Constraints**: The path must not conflict with an existing file or directory, and the parent directories must exist. - **Requirements**: - If the path conflicts with existing files, raise a `ValueError`. - **`add_file(path: str, size: int) -> None`:** - **Input**: - `path` - A string representing the full path where the file should be added. - `size` - An integer representing the size of the file in bytes. - **Output**: None - **Constraints**: The path must not specify an existing directory or file, and the parent directories must exist. - **Requirements**: - If the path conflicts with existing directories, raise a `ValueError`. - **`get_size(path: str) -> int`:** - **Input**: `path` - A string representing the path of the directory. - **Output**: The size of the directory and its contents in bytes. - **Constraints**: The path must refer to an existing directory. - **Requirements**: - If the path does not exist, raise a `ValueError`. - **`delete(path: str) -> None`:** - **Input**: `path` - A string representing the path of the file to be deleted. - **Output**: None - **Constraints**: The path must refer to an existing file. - **Requirements**: - If the path refers to a directory or does not exist, raise a `ValueError`. # Examples ```python # Creating an instance of the FileSystem fs = FileSystem() # Creating directories fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") fs.mkdir(\\"/a/b/c\\") # Adding files fs.add_file(\\"/a/file1.txt\\", 100) fs.add_file(\\"/a/b/file2.txt\\", 200) fs.add_file(\\"/a/b/c/file3.txt\\", 300) # Getting size of directories assert fs.get_size(\\"/a\\") == 600 assert fs.get_size(\\"/a/b\\") == 500 assert fs.get_size(\\"/a/b/c\\") == 300 # Deleting a file fs.delete(\\"/a/b/file2.txt\\") assert fs.get_size(\\"/a\\") == 400 # Handling errors try: fs.mkdir(\\"/d\\") # This should raise a ValueError because /d does not exist except ValueError as e: print(e) try: fs.add_file(\\"/a/b/d/file4.txt\\", 100) # This should raise a ValueError because /a/b/d does not exist except ValueError as e: print(e) try: fs.get_size(\\"/a/b/nonexistent\\") # This should raise a ValueError because the path does not exist except ValueError as e: print(e) try: fs.delete(\\"/a/b\\") # This should raise a ValueError because /a/b is a directory except ValueError as e: print(e) ``` You are expected to implement the `FileSystem` class and test all possible scenarios and edge cases to ensure the correct functionality of the directory and file operations.","solution":"class FileSystem: def __init__(self): self.files = {} self.directories = {\'/\'} def mkdir(self, path: str) -> None: if path in self.files: raise ValueError(f\\"Path {path} conflicts with an existing file.\\") parent = \'/\'.join(path.split(\'/\')[:-1]) or \'/\' if parent not in self.directories: raise ValueError(f\\"Parent directory {parent} does not exist.\\") self.directories.add(path) def add_file(self, path: str, size: int) -> None: if path in self.directories: raise ValueError(f\\"Path {path} conflicts with an existing directory.\\") parent = \'/\'.join(path.split(\'/\')[:-1]) or \'/\' if parent not in self.directories: raise ValueError(f\\"Parent directory {parent} does not exist.\\") self.files[path] = size def get_size(self, path: str) -> int: if path not in self.directories: raise ValueError(f\\"Path {path} does not exist.\\") total_size = 0 for file_path in self.files: if file_path.startswith(path): total_size += self.files[file_path] return total_size def delete(self, path: str) -> None: if path not in self.files: raise ValueError(f\\"Path {path} does not exist or is not a file.\\") del self.files[path]"},{"question":"# Coding Assessment Question Binary Search Tree Modification You need to enhance the existing `BinarySearchTree` class for a more robust performance. Specifically, you are required to add a mechanism to self-balance the tree after each insertion to maintain optimal search time. Task 1. Implement a method `balance` that rebalances the tree every time a new node is inserted. This method should automatically keep the tree balanced by ensuring the heights of the left and right subtrees of any node differ by at most one. 2. Modify the `insert` function to incorporate the balancing step after adding a new node. Additional Guidelines - Balancing Strategy: - Use AVL tree rotations (single and double rotations) to ensure the tree remains balanced. Function Signatures and Expected Behavioral Outline ```python class SelfBalancingBST(BinarySearchTree): def insert(self, value): # Enhanced insert that adds the value and balances the tree pass def balance(self, node): # Implement the balancing logic based on height difference pass ``` Input Examples and Output Expectations ```python # Sample insertions bst = SelfBalancingBST() bst.insert(10) bst.insert(20) bst.insert(30) bst.insert(5) bst.insert(25) # After inserts with balancing print(bst.in_order_traversal()) # Should print the elements in sorted order # Height of the tree should be balanced print(bst.height()) # Should print the height of the tree, ideally log(n) where n is # of nodes ``` - **Constraints**: - Nodes\' values must be integers. - Insertions can be performed in any order. - The tree should automatically balance itself after each insertion. - **Performance Requirements**: - Ensure that the tree maintains balance and avoids becoming a skewed tree. - Search operations should maintain a time complexity of O(log n) due to the balancing mechanism. Evaluate the height of the tree and order of elements to confirm successful balancing. Perform multiple insertions and ensure that the tree maintains a balanced structure.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class SelfBalancingBST: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = TreeNode(value) else: self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: return TreeNode(value) elif value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance_factor = self._get_balance(node) # Balancing the tree if balance_factor > 1: if value < node.left.value: # Left-Left case return self._right_rotate(node) else: # Left-Right case node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance_factor < -1: if value > node.right.value: # Right-Right case return self._left_rotate(node) else: # Right-Left case node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traversal(self): return self._in_order_traversal(self.root) def _in_order_traversal(self, node): res = [] if node: res = self._in_order_traversal(node.left) res.append(node.value) res = res + self._in_order_traversal(node.right) return res def height(self): return self._get_height(self.root)"},{"question":"# Scenario: You are working on a project that involves processing and analyzing large log files generated from web servers. One specific task that you need to implement is a function that will help identify sections of the log file where unusual spikes in activity occur. This involves scanning through timestamps and counting the number of logged events in distinct time windows. # Problem Description: Implement a function `detect_spike` that takes two parameters: a list of timestamps and a window size (in seconds). The function should return the start time of the window where the maximum spike in the number of log entries is observed. If there are multiple windows with the same maximum number of entries, return the earliest start time among them. # Function Signature: `def detect_spike(timestamps: List[int], window_size: int) -> int:` # Input: - `timestamps`: A list of integers representing the timestamps of log entries in seconds. - `window_size`: An integer representing the size of the window in seconds within which to count the entries. # Output: - Returns an integer representing the start time of the window with the highest number of log entries. # Constraints: - Each timestamp in the list is a non-negative integer. - The list of timestamps is sorted in ascending order. - The window size is a positive integer. # Example: ```python print(detect_spike([1, 2, 3, 6, 6, 6, 9, 9, 12], 5)) # Output: 1 print(detect_spike([10, 20, 30, 40, 50, 60, 70], 10)) # Output: 10 ``` # Notes: - The function should efficiently handle large lists of timestamps. - Consider using a sliding window approach to determine the spike efficiently.","solution":"from typing import List def detect_spike(timestamps: List[int], window_size: int) -> int: n = len(timestamps) if n == 0: return -1 max_count = 0 max_start_time = timestamps[0] left = 0 for right in range(n): while timestamps[right] - timestamps[left] >= window_size: left += 1 current_count = right - left + 1 if current_count > max_count: max_count = current_count max_start_time = timestamps[left] return max_start_time"},{"question":"# Problem Statement: **Word Ladder Transformation Path** You are given two words `begin_word` and `end_word` of the same length, and a list of `word_list` containing a set of allowed words. Write a function to find the shortest transformation path from `begin_word` to `end_word`, such that: 1. You can only change one letter at a time. 2. Each transformed word must exist in the `word_list`. Additionally, you should return the path as a list of words, including the `begin_word` and `end_word`. If there is no valid transformation sequence, return an empty list. # Function Signature: ```python def word_ladder(begin_word: str, end_word: str, word_list: list) -> list: ``` # Input: - `begin_word`: A string representing the start word. - `end_word`: A string representing the end word. - `word_list`: A list of strings representing the allowed words. # Output: - A list of strings that represent the shortest transformation path from `begin_word` to `end_word`. If no such path exists, return an empty list. # Constraints: - The length of `begin_word` and `end_word` and each word in `word_list` will be equal and not exceed 100. - There will be no duplicate words in `word_list`. - All strings will consist of lowercase letters only. # Example: ```python assert word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) == [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] assert word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) == [] assert word_ladder(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"c\\"] assert word_ladder(\\"hit\\", \\"hit\\", [\\"hit\\"]) == [\\"hit\\"] assert word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"tog\\", \\"cog\\"]) == [] ``` # Implementation Requirements: 1. The function must find the shortest path in terms of the number of transformations (BFS algorithm may be useful). 2. The function should handle cases where no path exists appropriately and return an empty list. 3. You may assume that there are no more than 5000 words in the `word_list`. # Scenario: You are given the task to transform one word into another by changing only one letter at a time, where each intermediate word must follow a given set of allowed transformations. This problem examines your ability to implement graph traversal algorithms in finding the shortest path under specific constraints.","solution":"from collections import deque def word_ladder(begin_word: str, end_word: str, word_list: list) -> list: Find the shortest transformation path from begin_word to end_word using the given word_list. If there is no valid transformation sequence, return an empty list. :param begin_word: str :param end_word: str :param word_list: list of str :return: list of str if end_word not in word_list: return [] word_list = set(word_list) # Convert to set for O(1) lookups queue = deque([(begin_word, [begin_word])]) while queue: current_word, path = queue.popleft() if current_word == end_word: return path for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_list: queue.append((next_word, path + [next_word])) word_list.remove(next_word) # Remove to avoid revisiting return []"},{"question":"# Description: You are given a sentence composed exclusively of words and spaces. Your task is to find and return the longest palindrome (a word that reads the same backward as forward) within the sentence. In case of ties (multiple words of the same maximum length), return the one which appears first in the sentence. # Task: Implement a function, `find_longest_palindromic_word(sentence: str) -> str`, which returns the longest palindromic word in the given sentence. If no palindromic word is found, return an empty string. # Input: - A string `sentence` containing only lowercase letters and spaces. # Output: - The longest palindromic word in the sentence. If no palindromic word exists, return an empty string. # Constraints: - The input sentence length will be between 1 and 1000 characters inclusive. # Performance Requirements: - The solution should efficiently handle word segmentation and palindrome checking within the given constraints. # Example: ```python def is_palindrome(word: str) -> bool: return word == word[::-1] def find_longest_palindromic_word(sentence: str) -> str: words = sentence.split() longest_palindrome = \\"\\" for word in words: if is_palindrome(word) and len(word) > len(longest_palindrome): longest_palindrome = word elif is_palindrome(word) and len(word) == len(longest_palindrome): # If another palindrome of the same length appears first, we keep the first continue return longest_palindrome print(find_longest_palindromic_word(\\"racecar level civic\\")) # Output: \\"racecar\\" print(find_longest_palindromic_word(\\"a quick brown fox jumps over\\")) # Output: \\"\\" ``` # Instructions: 1. Define a helper function, `is_palindrome(word: str) -> bool`, to check whether a given word is a palindrome. 2. Split the sentence into words using spaces. 3. Iterate through each word to determine if it is a palindrome. 4. Track the longest palindrome found. In case of ties, the first one encountered should be returned. 5. Return the longest palindromic word or an empty string if no palindromic word is found.","solution":"def is_palindrome(word: str) -> bool: Helper function to check if a given word is a palindrome. return word == word[::-1] def find_longest_palindromic_word(sentence: str) -> str: Returns the longest palindromic word in the given sentence. If no palindromic word is found, returns an empty string. words = sentence.split() longest_palindrome = \\"\\" for word in words: if is_palindrome(word): if len(word) > len(longest_palindrome): longest_palindrome = word return longest_palindrome"},{"question":"Scenario You are developing a simple file system simulation for an educational application. One of the features required is the implementation of a function to manage file and directory paths. Specifically, the function should simplify a given absolute file path by resolving relative path components such as `.` (current directory) and `..` (parent directory), and removing any redundant slashes. Problem Statement Write a function `simplify_path` that, given an absolute path, returns the simplified canonical path. The canonical path should have the following properties: 1. No redundant slashes (/). 2. No `.` references in the path. 3. No `..` references in the path that go above the root directory. 4. The path should always begin with a single slash (/). # Function Signature ```python def simplify_path(path: str) -> str: ``` # Input * A string `path` representing an absolute path (with or without redundant components). # Output * A string representing the simplified canonical path. # Constraints * The path string will contain only printable ASCII characters. * The path string can have a length from 1 up to 1000 characters. * The given path will always begin with a slash `/`. # Example ```python path = \\"/a/./b/../../c/\\" result = simplify_path(path) # This should return \\"/c\\" path = \\"/home//foo/\\" result = simplify_path(path) # This should return \\"/home/foo\\" ``` # Additional Information * The simplified path should not end with a slash unless it is the root `/`. * Ensure your function handles edge cases such as multiple consecutive slashes and the presence of only slashes correctly. * Perform necessary checks to manage paths with multiple levels of `..` without going above the root directory.","solution":"def simplify_path(path: str) -> str: Simplifies the given absolute file path and returns the canonical path. # Split the path by slashes parts = path.split(\'/\') # Use a stack to handle the path components stack = [] for part in parts: if part == \'\' or part == \'.\': # Ignore empty and current directory references continue elif part == \'..\': if stack: # Go up one directory unless at the root stack.pop() else: # Add valid directory names to the stack stack.append(part) # Construct the simplified canonical path result = \'/\' + \'/\'.join(stack) return result"},{"question":"# Context In computer science, sorting algorithms are fundamental techniques that are used to arrange data in a specified order. One commonly studied sorting algorithm is merge sort, which is a divide-and-conquer algorithm that recursively divides the array into halves, sorts each half, and then merges the sorted halves back together. # Task You need to write a function that sorts an array of integers using the merge sort algorithm. Your function should return the sorted array. # Function Signature: ```python def merge_sort(arr: list[int]) -> list[int]: pass ``` # Input - `arr`: A list of integers, where the list may include negative numbers and duplicates. # Output - A list of integers, which is the sorted version of the input list. # Constraints 1. The input list can contain between 0 and 10^5 integers. 2. The integers in the list range from -10^9 to 10^9. # Performance Requirements - Time Complexity: O(n log n), where n is the number of elements in the list. - Space Complexity: O(n), for the additional space used by merging subarrays. # Example ```python print(merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] print(merge_sort([10, -1, 2, 5, 0, 6, 4, -5])) # Output: [-5, -1, 0, 2, 4, 5, 6, 10] print(merge_sort([-3, -1, -2, -5, -4])) # Output: [-5, -4, -3, -2, -1] print(merge_sort([])) # Output: [] # Sorting a single element list print(merge_sort([42])) # Output: [42] ``` # Notes - You can assume that the input list may be empty, in which case the output should also be an empty list. - Refrain from using built-in sorting functions like `sort()` or `sorted()` in Python. - Implement the merge sort recursively as specified in the context.","solution":"def merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"**Problem Statement**: Given a sentence written in camelCase format, convert it into a sentence written in snake_case format. In camelCase format, words are written without spaces, and each word except the first is capitalized. In snake_case format, words are written in lowercase and separated by underscores (\\"_\\"). **Function Signature**: ```python def camel_to_snake(camel_case_sentence: str) -> str: pass ``` **Parameters**: - `camel_case_sentence` (str): A sentence written in camelCase format. **Returns**: - (str): The sentence converted to snake_case format. **Constraints**: - The input string `camel_case_sentence` will only contain letters. - The input string will contain at least one character and at most 100 characters. **Examples**: ```python assert camel_to_snake(\\"thisIsCamelCase\\") == \\"this_is_camel_case\\" assert camel_to_snake(\\"convertMeToSnakeCase\\") == \\"convert_me_to_snake_case\\" assert camel_to_snake(\\"simpletest\\") == \\"simpletest\\" ``` **Notes**: - Ensure that all words in the resulting snake_case format are in lowercase. - Optimize for efficiency. - Consider edge cases such as very short strings or strings with no capital letters.","solution":"def camel_to_snake(camel_case_sentence: str) -> str: Converts a camelCase sentence into snake_case format. :param camel_case_sentence: A sentence in camelCase format. :return: The sentence converted to snake_case format. snake_case_sentence = \\"\\" for index, char in enumerate(camel_case_sentence): if char.isupper(): if index != 0: snake_case_sentence += \\"_\\" snake_case_sentence += char.lower() else: snake_case_sentence += char return snake_case_sentence"},{"question":"# Coding Assessment Question: Problem Statement: Given a non-negative integer `num`, repeatedly add its digits until the result has only one digit. This is known as the digital root of the number. Your task is to write a function that computes the digital root of a given number using an iterative process. Function Signature: ```python def digital_root(num: int) -> int: Computes the digital root of a given non-negative integer by repeatedly adding its digits until the result has only one digit. Parameters: num (int): The input non-negative integer. Returns: int: The digital root of the given number. pass ``` Input: - `num`: A non-negative integer (0 <= num <= 10^9). Output: - Return an integer, the digital root of the given number. Example: ```python >>> digital_root(38) 2 >>> digital_root(0) 0 >>> digital_root(98765) 8 ``` Explanation: - For the first example: - 38 => 3 + 8 = 11 => 1 + 1 = 2, so the digital root of 38 is 2. - For the second example: - The digital root of 0 is simply 0. - For the third example: - 98765 => 9 + 8 + 7 + 6 + 5 = 35 => 3 + 5 = 8, so the digital root of 98765 is 8. _**Hint**_: Consider a loop to add the digits of the number and continue until a single-digit result is obtained.","solution":"def digital_root(num: int) -> int: Computes the digital root of a given non-negative integer by repeatedly adding its digits until the result has only one digit. Parameters: num (int): The input non-negative integer. Returns: int: The digital root of the given number. while num >= 10: sum_digits = 0 while num > 0: sum_digits += num % 10 num //= 10 num = sum_digits return num"},{"question":"# Problem Statement: Develop a function that will anonymize a dataset consisting of user information. The function will replace sensitive details (like email and phone number) with anonymized placeholders to protect user privacy. The dataset will be provided in the form of a list of dictionaries. # Function Requirements: 1. **`anonymize_data(data: List[Dict[str, Any]]) -> List[Dict[str, Any]]`**: - **Input**: - `data` (list of dictionaries): Each dictionary represents user information with keys such as \'name\', \'email\', \'phone\', and other relevant details. - **Output**: - Return a new list of dictionaries with anonymized \'email\' and \'phone\' values. # Anonymization Guidelines: - Replace email addresses with the string “hidden_email”. - Replace phone numbers with the string “hidden_phone”. - Other fields should remain unchanged. - Handle edge cases such as missing or empty \'email\' and \'phone\' fields by leaving them as is. # Constraints: - The input list `data` may contain up to 1000 user records. - Each record is a dictionary with a variable number of fields. - Emails will contain valid email formats. - Phone numbers will contain digits and may include country codes and separators. # Example: ```python user_data = [ {\\"name\\": \\"Alice\\", \\"email\\": \\"alice@example.com\\", \\"phone\\": \\"123-456-7890\\"}, {\\"name\\": \\"Bob\\", \\"email\\": \\"bob@anotherdomain.com\\", \\"phone\\": \\"+1-800-555-1212\\"}, {\\"name\\": \\"Charlie\\", \\"email\\": \\"\\", \\"phone\\": \\"987654321\\"}, {\\"name\\": \\"Diana\\", \\"phone\\": \\"555-1234\\"}, ] # Example Anonymization anonymized_data = anonymize_data(user_data) expected_output = [ {\\"name\\": \\"Alice\\", \\"email\\": \\"hidden_email\\", \\"phone\\": \\"hidden_phone\\"}, {\\"name\\": \\"Bob\\", \\"email\\": \\"hidden_email\\", \\"phone\\": \\"hidden_phone\\"}, {\\"name\\": \\"Charlie\\", \\"email\\": \\"\\", \\"phone\\": \\"hidden_phone\\"}, {\\"name\\": \\"Diana\\", \\"phone\\": \\"hidden_phone\\"}, ] assert anonymized_data == expected_output ``` # Additional Requirements: - Ensure the function is efficient and can handle large datasets within reasonable time limits. - Clearly comment the code to explain the logic and transformations applied. - Include comprehensive error handling and validation to manage incomplete user records and other anomalies gracefully.","solution":"from typing import List, Dict, Any def anonymize_data(data: List[Dict[str, Any]]) -> List[Dict[str, Any]]: Anonymizes a given dataset by replacing sensitive information like email and phone number with placeholders to protect user privacy. Parameters: data (list of dicts): List of dictionaries containing user information. Returns: list of dicts: Anonymized list of dictionaries. # Placeholder values for anonymization hidden_email = \\"hidden_email\\" hidden_phone = \\"hidden_phone\\" anonymized_data = [] for record in data: anonymized_record = record.copy() if \'email\' in anonymized_record and anonymized_record[\'email\']: anonymized_record[\'email\'] = hidden_email if \'phone\' in anonymized_record and anonymized_record[\'phone\']: anonymized_record[\'phone\'] = hidden_phone anonymized_data.append(anonymized_record) return anonymized_data"},{"question":"# Question: Stock Profit Calculation You are asked to write two functions to calculate the maximum profit from buying and selling stocks under two scenarios: single transaction and multiple transactions. Each function needs to handle various input validations and return the appropriate profit amount, following stock trading principles. Function 1: `max_single_transaction_profit(prices: List[float]) -> float` **Calculate the maximum profit from a single buy and sell transaction.** - **Input**: - `prices` (List[float]): List of stock prices where `prices[i]` is the price of the stock on the ith day. - **Output**: - `float`: Maximum profit achievable from a single transaction. - **Constraints**: - The length of `prices` list must be greater than 1. - All prices must be non-negative. Function 2: `max_multiple_transactions_profit(prices: List[float]) -> float` **Calculate the maximum profit from multiple buy and sell transactions, where you cannot hold more than one stock at a time.** - **Input**: - `prices` (List[float]): List of stock prices where `prices[i]` is the price of the stock on the ith day. - **Output**: - `float`: Maximum profit achievable from any number of transactions. - **Constraints**: - The length of `prices` list must be greater than 1. - All prices must be non-negative. # Testing & Validation - Include checks for invalid inputs like lists of length less than 2 or containing negative prices. - Use various test cases to validate the correctness of your implementation. Consider edge cases such as consistently increasing or decreasing prices, and fluctuating prices.","solution":"from typing import List def max_single_transaction_profit(prices: List[float]) -> float: if len(prices) < 2: raise ValueError(\\"The prices list must contain at least two prices.\\") if any(p < 0 for p in prices): raise ValueError(\\"All prices must be non-negative.\\") min_price = float(\'inf\') max_profit = 0.0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def max_multiple_transactions_profit(prices: List[float]) -> float: if len(prices) < 2: raise ValueError(\\"The prices list must contain at least two prices.\\") if any(p < 0 for p in prices): raise ValueError(\\"All prices must be non-negative.\\") max_profit = 0.0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"# Prime Factorization Problem Statement: You are given an integer `n`. Your task is to write a function that returns a list of all prime factors of `n`. Function Signature: ```python def prime_factors(n: int) -> List[int]: ``` Input: * **n**: An integer where (2 leq n leq 10^6). Output: * Returns a list of integers representing the prime factors of `n` in non-decreasing order. Constraints: * ( n ) will always be greater than 1. Example: ```python n = 28 expected_output = [2, 2, 7] assert prime_factors(n) == expected_output ``` ```python n = 97 expected_output = [97] assert prime_factors(n) == expected_output ``` Instructions: 1. **Find Prime Factors**: Create an empty list to store the prime factors. Start with the smallest prime number, 2, and divide `n` by it repeatedly until `n` can no longer be divided by 2. Repeat this process for the next prime number, and so on. 2. **Collect Factors**: Each time `n` is evenly divisible by a prime number `i`, store `i` in the list and divide `n` by `i`. Continue this process until `n` becomes 1. 3. **Return the result**: Return the list containing all prime factors of `n` in non-decreasing order. Hints: * Use the sieve of Eratosthenes to generate a list of prime numbers up to the square root of `n` to reduce the number of division operations. * Remember to include `n` itself in the list of factors if `n` is a prime number greater than 2 after the division process.","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of all prime factors of the given integer n. factors = [] # Check for number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point so we can skip one element (i.e., we check only odd numbers) for i in range(3, int(n**0.5) + 1, 2): # While i divides n, add i to the list and divide n while n % i == 0: factors.append(i) n = n // i # This condition is to check if n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# Question: Implement an Efficient Fibonacci Number Validator You are working on a software system that performs various mathematical validations. One of the tasks is to check if a given large integer is a Fibonacci number. Implement a function that efficiently checks if a number belongs to the Fibonacci sequence. Task Create the function `is_fibonacci(num: int) -> bool` to determine if `num` is a Fibonacci number. Utilize mathematical properties of Fibonacci numbers for optimally validating the number. Function Signature ```python def is_fibonacci(num: int) -> bool: pass ``` Input * `num`: an integer that needs to be checked. - Constraints: (0 leq num leq 10^{18}) Output * Returns `True` if `num` is a Fibonacci number, `False` otherwise. Constraints 1. Your solution should handle very large numbers efficiently, focusing on performance. 2. Consider relevant edge cases and ensure algorithm correctness. Example ```python print(is_fibonacci(21)) # Expected output: True print(is_fibonacci(22)) # Expected output: False print(is_fibonacci(144)) # Expected output: True ``` Additional Requirements 1. **Performance**: Ensure the function can quickly determine the result for input values ranging up to (10^{18}). 2. **Correctness**: Consider edge cases such as first few Fibonacci numbers and large integers that are not in the Fibonacci sequence. # Hint A number `n` is a Fibonacci number if and only if one (or both) of `(5*n^2 + 4)` or `(5*n^2 - 4)` is a perfect square. Use this property for efficient validation. ```python def is_fibonacci(num: int) -> bool: def is_perfect_square(x): s = int(x**0.5) return s*s == x # Check for the conditions mentioned in the hint return is_perfect_square(5*num*num + 4) or is_perfect_square(5*num*num - 4) ```","solution":"import math def is_fibonacci(num: int) -> bool: def is_perfect_square(x): s = int(math.isqrt(x)) return s * s == x # Check for the conditions mentioned in the hint return is_perfect_square(5 * num * num + 4) or is_perfect_square(5 * num * num - 4)"},{"question":"# Scenario Geometric shapes are fundamental entities in mathematics and computer graphics. Each shape has distinct properties and can be represented using a set of parameters. For instance, a rectangle can be described with its length and width, while a circle can be represented using its radius. Calculating the perimeter and area of these shapes is a common task in various applications. # Task Write a Python class hierarchy to represent geometric shapes `Shape`, `Rectangle`, and `Circle`. Implement methods to compute the area and perimeter of these shapes. Utilize inheritance to avoid code duplication where possible. # Class Definitions 1. `Shape`: This is an abstract base class that serves as a blueprint for other shapes. It should declare two methods: - `area()`: Abstract method to compute the area of the shape. - `perimeter()`: Abstract method to compute the perimeter of the shape. 2. `Rectangle`: Inherits from `Shape`. Represents a rectangle with a given length and width. 3. `Circle`: Inherits from `Shape`. Represents a circle with a given radius. # Input Specifications * `Rectangle` class takes two parameters: `length` and `width`. * `Circle` class takes one parameter: `radius`. # Output Specifications * The `area()` method returns the area of the shape. * The `perimeter()` method returns the perimeter of the shape. # Constraints * All dimensions are positive floats greater than zero. # Example ```python >>> rect = Rectangle(5, 3) >>> rect.area() 15.0 >>> rect.perimeter() 16.0 >>> circ = Circle(4) >>> circ.area() 50.24 >>> circ.perimeter() 25.12 ``` # Requirements * Ensure to use the `Shape` abstract base class for code organization and clarity. * Include proper docstrings and type annotations for all methods. * Use appropriate constants (e.g., π for `Circle` calculations, use 3.14 for simplicity). Below is a potential implementation structure: ```python from abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def area(self) -> float: pass @abstractmethod def perimeter(self) -> float: pass class Rectangle(Shape): def __init__(self, length: float, width: float): self.length = length self.width = width def area(self) -> float: return self.length * self.width def perimeter(self) -> float: return 2 * (self.length + self.width) class Circle(Shape): def __init__(self, radius: float): self.radius = radius def area(self) -> float: return 3.14 * self.radius ** 2 def perimeter(self) -> float: return 2 * 3.14 * self.radius ``` Ensure to provide meaningful docstrings and complete the implementation details required to handle the given constraints.","solution":"from abc import ABC, abstractmethod from math import pi class Shape(ABC): An abstract base class for geometric shapes. @abstractmethod def area(self) -> float: Returns the area of the shape. pass @abstractmethod def perimeter(self) -> float: Returns the perimeter of the shape. pass class Rectangle(Shape): A class representing a rectangle with a given length and width. def __init__(self, length: float, width: float): self.length = length self.width = width def area(self) -> float: return self.length * self.width def perimeter(self) -> float: return 2 * (self.length + self.width) class Circle(Shape): A class representing a circle with a given radius. def __init__(self, radius: float): self.radius = radius def area(self) -> float: return pi * self.radius ** 2 def perimeter(self) -> float: return 2 * pi * self.radius"},{"question":"# Coding Assessment Question: Write a function that will help keep track of the stock level of products in a warehouse. The function should allow adding new inventory, updating stock levels, and removing inventory when it is sold. **Function Details**: * Implement a class `Warehouse` with the following methods: - `add_inventory(product_id: str, quantity: int) -> None`: Adds a product with specified quantity to the inventory. - `update_stock(product_id: str, quantity: int) -> None`: Updates the stock level of an existing product. If the product does not exist, it should raise an exception. - `remove_inventory(product_id: str, quantity: int) -> None`: Removes the specified quantity of a product. If the product does not exist or there is insufficient stock, it should raise an exception. - `get_stock_level(product_id: str) -> int`: Returns the current stock level of a specified product. If the product does not exist, it should return 0. **Constraints**: * `product_id` is a non-empty string. * `quantity` is a non-negative integer. **Performance Requirements**: * All operations (adding, updating, removing, and querying) should be done in constant time, ( O(1) ). **Example Use Cases**: ```python warehouse = Warehouse() warehouse.add_inventory(\\"product_1\\", 50) warehouse.add_inventory(\\"product_2\\", 30) warehouse.update_stock(\\"product_1\\", 80) warehouse.remove_inventory(\\"product_2\\", 20) stock_level_p1 = warehouse.get_stock_level(\\"product_1\\") # should return 80 stock_level_p2 = warehouse.get_stock_level(\\"product_2\\") # should return 10 ``` **Edge Cases**: * Adding a new inventory with quantity 0 should be valid. * Updating stock level with a non-existent product id should raise an exception: `\\"Product does not exist\\"`. * Removing more inventory than available should raise an exception: `\\"Insufficient stock\\"`.","solution":"class Warehouse: def __init__(self): self.inventory = {} def add_inventory(self, product_id: str, quantity: int) -> None: if product_id in self.inventory: self.inventory[product_id] += quantity else: self.inventory[product_id] = quantity def update_stock(self, product_id: str, quantity: int) -> None: if product_id not in self.inventory: raise ValueError(\\"Product does not exist\\") self.inventory[product_id] = quantity def remove_inventory(self, product_id: str, quantity: int) -> None: if product_id not in self.inventory: raise ValueError(\\"Product does not exist\\") if self.inventory[product_id] < quantity: raise ValueError(\\"Insufficient stock\\") self.inventory[product_id] -= quantity def get_stock_level(self, product_id: str) -> int: return self.inventory.get(product_id, 0)"},{"question":"# Question Context You are developing a file management utility for a local system. This utility enables users to find and display files within a directory based on specific criteria. The utility should be efficient and handle typical edge cases robustly. # Problem Statement Implement a function called `find_files` in Python, which searches for files within a given directory that match a specific filename pattern and lists their paths. Additionally, write unit tests to ensure the function performs correctly using the `unittest.mock` library to mock filesystem interactions. # Requirements 1. **Function Definition**: ```python def find_files(directory: str, pattern: str) -> List[str]: pass ``` 2. **Behavior**: - The function should search recursively through `directory` for files whose names match the `pattern`. - The `pattern` can be a simple filename, a wildcard pattern (e.g., `*.txt`), or regex. 3. **Testing Requirements**: - Use `unittest.mock` to mock the file system functions, such as `os.walk` and `fnmatch.fnmatch`. - Verify that the function correctly identifies and returns the file paths that match the pattern. - Write at least one test for an edge case where no files match the pattern. # Expected Input and Output Formats - **Input**: - `directory`: A string representing the path to the directory to be searched. - `pattern`: A string representing the filename pattern to match within the directory. - **Output**: A list of strings, each representing the path to a file that matches the pattern. # Constraints - Assume the directory structure fits within typical system memory constraints. - Assume standard filesystem permissions and structures. - Patterns should support typical filename matching characters (e.g., `*`, `?`, or corresponding regex). # Performance Requirements - The function should effectively handle searches within a reasonable time frame, even for nested directory structures. # Implementation You are required to implement the `find_files` function and comprehensive unit tests following the outlined specifications.","solution":"import os import fnmatch from typing import List def find_files(directory: str, pattern: str) -> List[str]: Recursively searches for files in the given directory that match the filename pattern. Args: directory (str): The directory path to search within. pattern (str): The filename pattern to match. Returns: List[str]: A list of paths to files that match the pattern. matched_files = [] for root, _, files in os.walk(directory): for filename in files: if fnmatch.fnmatch(filename, pattern): matched_files.append(os.path.join(root, filename)) return matched_files"},{"question":"# Problem Statement You are required to write a function that detects if a given string is a valid arithmetic expression and if so, evaluates its result. This task tests your ability to handle string parsing, evaluate expressions, and manage errors gracefully. # Function Signature ```python def evaluate_expression(expression: str) -> float: ``` # Input - `expression` (str): A string representing an arithmetic expression. The string may contain numbers, \'+\', \'-\', \'*\', \'/\', and spaces. # Output - Returns a float which is the result of the evaluated expression. # Constraints - The input string will contain only the characters \'0\'-\'9\', \'+\', \'-\', \'*\', \'/\', and spaces. - The function should raise a `ValueError` with the message \\"Invalid expression\\" if the input contains any invalid characters or if the expression cannot be evaluated properly (such as division by zero or mismatched operators). # Example ```python >>> evaluate_expression(\\"3 + 5\\") 8.0 >>> evaluate_expression(\\"10 / 2\\") 5.0 >>> evaluate_expression(\\"10 / 0\\") Traceback (most recent call last): ... ValueError: Invalid expression >>> evaluate_expression(\\"12.5 * 2\\") 25.0 >>> evaluate_expression(\\"7 + a\\") Traceback (most recent call last): ... ValueError: Invalid expression ``` # Performance Requirements - The function should run in O(n) time complexity, where n is the length of the input string. - The function should use at most O(n) additional space for parsing and evaluating the expression. # Guidelines 1. First, handle the edge cases of invalid characters and division by zero. 2. Validate that the expression is syntactically correct. 3. Evaluate the arithmetic expression using Python\'s built-in functionalities. 4. Ensure that the result maintains floating-point precision by converting intermediate results to floats.","solution":"def evaluate_expression(expression: str) -> float: Evaluates if a given string is a valid arithmetic expression and returns its result. Raises ValueError if the expression is invalid. # Remove spaces expression = expression.replace(\' \', \'\') # Define valid characters valid_chars = set(\'0123456789+-*/.\') # Check for invalid characters if any(char not in valid_chars for char in expression): raise ValueError(\\"Invalid expression\\") try: # Evaluate the expression result = eval(expression) except ZeroDivisionError: raise ValueError(\\"Invalid expression\\") except (SyntaxError, NameError): raise ValueError(\\"Invalid expression\\") # Ensure the result is a float return float(result)"},{"question":"# Problem Description Implement a function that determines whether a given string is a \\"happy\\" string. A string is considered \\"happy\\" if each character that occurs more than once in the string has the same number of occurrences as any other character in the string. # Constraints * The function should correctly handle input strings up to 1000 characters long. * The string consists of only lowercase English letters (`a` to `z`). # Input * A string `s` (1 ≤ len(s) ≤ 1000). # Output * A boolean value: `True` if the string is happy, `False` otherwise. # Function Signature ```python def is_happy_string(s: str) -> bool: ``` # Example ```python >>> is_happy_string(\\"abcabc\\") True >>> is_happy_string(\\"aabbcc\\") True >>> is_happy_string(\\"aabbccc\\") False >>> is_happy_string(\\"abcdef\\") True >>> is_happy_string(\\"aabbc\\") False ``` # Approach 1. Create a frequency dictionary to count the occurrences of each character in the string. 2. Identify if any character occurs more than once. 3. Compare the frequency of these characters to ensure they are equal. 4. Return `True` if the criteria are met, else `False`. # Note - Consider edge cases such as single-character strings and strings with no repeating characters. - The function should be efficient to handle the upper limit of the input size.","solution":"def is_happy_string(s: str) -> bool: from collections import Counter # Step 1: Create a frequency dictionary frequency = Counter(s) # Step 2: Filter characters that occur more than once repeated_chars = {char: count for char, count in frequency.items() if count > 1} # Step 3: If no character occurs more than once, it\'s automatically happy if not repeated_chars: return True # Step 4: Get the list of frequencies of the repeated characters frequencies = list(repeated_chars.values()) # Step 5: Check if all frequencies are the same return all(frequency == frequencies[0] for frequency in frequencies)"},{"question":"# Network Packet Transmission You are given a directed acyclic graph (DAG) representing a network of nodes, where each edge has an integer weight representing the time it takes to send a packet along that edge. Your task is to find the shortest time (minimum weight path) to send a packet from a given source node to a destination node. Write a function `shortest_transmission_time(n: int, edges: List[Tuple[int, int, int]], src: int, dest: int) -> int` that takes in: 1. An integer `n` representing the number of nodes in the network. 2. A list of edges where each edge is represented as a tuple `(u, v, w)` indicating there is a directed edge from node `u` to node `v` with weight `w`. 3. Two integers `src` and `dest` representing the source and destination nodes, respectively. Your function should return the shortest time required to transmit a packet from `src` to `dest`. If there is no path from `src` to `dest`, return `-1`. Input Format - `n` (1 ≤ n ≤ 10^4): an integer denoting the number of nodes. - `edges` (0 ≤ len(edges) ≤ 10^4): a list of tuples where each tuple contains three integers `(u, v, w)`. - `src` and `dest` (0 ≤ src, dest < n): integers representing the source and destination nodes. Output Format - An integer representing the shortest transmission time from `src` to `dest`. If there is no such path, return `-1`. Example ```python 1. Example Input: n = 5 edges = [(0, 1, 2), (1, 2, 3), (2, 3, 1), (3, 4, 4), (0, 4, 10)] src = 0 dest = 4 Output: 10 Explanation: The shortest path from node 0 to node 4 has a total weight of 10 (direct edge). 2. Example Input: n = 4 edges = [(0, 1, 1), (1, 2, 1), (2, 3, 1), (1, 3, 2), (0, 2, 2)] src = 0 dest = 3 Output: 3 Explanation: The shortest path from node 0 to node 3 is through nodes 0 -> 1 -> 3 with a total weight of 3. 3. Example Input: n = 3 edges = [(0, 1, 4), (1, 2, 3)] src = 0 dest = 2 Output: 7 Explanation: The shortest path from node 0 to node 2 is through nodes 0 -> 1 -> 2 with a total weight of 7. ``` Performance Requirements - Aim for O(n + m) time complexity, where `m` is the number of edges. - Use appropriate data structures to ensure efficient traversal and pathfinding in the graph.","solution":"from typing import List, Tuple import heapq def shortest_transmission_time(n: int, edges: List[Tuple[int, int, int]], src: int, dest: int) -> int: Returns the shortest time required to transmit a packet from source to destination node in a directed acyclic graph. If there is no path, returns -1. # Create adjacency list graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) # Dijkstra\'s algorithm to find the shortest path min_heap = [(0, src)] # (time, node) dist = [float(\'inf\')] * n dist[src] = 0 while min_heap: current_time, u = heapq.heappop(min_heap) # If we reach the destination, return the current time if u == dest: return current_time # If this path is already longer than the known shortest path, skip it if current_time > dist[u]: continue # Explore neighbours for v, weight in graph[u]: time = current_time + weight if time < dist[v]: dist[v] = time heapq.heappush(min_heap, (time, v)) # If destination is unreachable return -1 if dist[dest] == float(\'inf\') else dist[dest]"},{"question":"# Problem Statement: In this task, you are required to create a function to determine if the given strings are *rotations* of each other using only one call to an inbuilt string method. A rotation means that you can shift the characters of a string around in a circular manner. For example, \\"abcdef\\" rotated right by 2 would be \\"efabcd\\". # Function Requirements: 1. **`are_rotations(str1: str, str2: str) -> bool`**: - **Input**: - `str1` (string): The first string to be compared. - `str2` (string): The second string to be compared. - **Output**: - Return `True` if `str1` and `str2` are rotations of each other, `False` otherwise. # Constraints: - Both `str1` and `str2` will contain only lowercase alphabetic characters. - The length of `str1` and `str2` will be between 1 and 100, inclusive. - The function should handle edge cases like empty strings. # Example: ```python # Example 1 str1 = \\"waterbottle\\" str2 = \\"erbottlewat\\" assert are_rotations(str1, str2) == True # Example 2 str1 = \\"hello\\" str2 = \\"ohell\\" assert are_rotations(str1, str2) == True # Example 3 str1 = \\"abc\\" str2 = \\"acb\\" assert are_rotations(str1, str2) == False # Example 4 str1 = \\"\\" str2 = \\"\\" assert are_rotations(str1, str2) == True ``` # Additional Requirements: - Focus on time and space efficiency. - Comment your code to ensure the logic is clear. - Provide proper verification using assert statements for edge cases.","solution":"def are_rotations(str1, str2): Determines if str1 and str2 are rotations of each other. # If lengths of both strings are not equal, they cannot be rotations of each other if len(str1) != len(str2): return False # Concatenate str1 with itself and check if str2 is a substring of this new string return str2 in str1 + str1"},{"question":"# Problem Statement You are given a string containing digits, \'(\' and \')\', representing a simple mathematical expression containing addition and subtraction only. Your task is to evaluate this expression and return the result as an integer. Function Signature ```python def evaluate_expression(expression: str) -> int: ``` Input - A string `expression` (1 ≤ len(expression) ≤ 100) Output - An integer representing the evaluated result of the mathematical expression. # Performance Requirements - Your solution should handle edge cases efficiently as per the constraints. # Example **Input**: `\\"1 + (2 - (2 + 3) + 4) + 6\\"` **Output**: `8` # Constraints 1. The length of the string will be between 1 and 100 (both inclusive). 2. The string will contain only digits, spaces, \'+\', \'-\', \'(\' and \')\'. 3. The input is guaranteed to be a valid expression. # Implementation Notes - You need to consider the operator precedence and the parentheses to correctly evaluate the expression. - Utilize a stack to handle the parentheses and operations evaluation. - Ensure proper handling of unary operators and whitespace. Implement the `evaluate_expression` function based on the above problem statement.","solution":"def evaluate_expression(expression: str) -> int: def calculate(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) operators = [] values = [] i = 0 while i < len(expression): char = expression[i] if char == \' \': i += 1 continue if char.isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 values.append(num) continue if char == \'(\': operators.append(char) elif char == \')\': while operators and operators[-1] != \'(\': calculate(operators, values) operators.pop() # Pop the \'(\' from the stack elif char in \'+-\': while (operators and operators[-1] in \\"+-\\" and (char in \'+-\' or operators[-1] in \'+-\')): calculate(operators, values) operators.append(char) i += 1 while operators: calculate(operators, values) return values[0]"},{"question":"# Context Data compression is a crucial aspect of data storage and transmission. Huffman coding is a popular algorithm used to minimize the size of data. # Problem Statement You are provided with a series of characters and their frequencies. Use Huffman coding to create an optimal prefix code for the given characters. Implement a class `HuffmanCoding` to construct the Huffman Tree and encode/decode the given data. # Task 1. **Build Huffman Tree**: * Implement a method `build_tree(char_freq: List[Tuple[str, int]]) -> None` that takes a list of tuples where each tuple contains a character and its frequency, and builds the Huffman Tree. 2. **Generate Codes**: * Implement a method `generate_codes() -> Dict[str, str]` that generates the Huffman codes for each character based on the Huffman Tree and returns a dictionary with characters as keys and their corresponding Huffman codes as values. 3. **Encode Data**: * Implement a method `encode(data: str) -> str` that takes a string of data and returns the encoded string using the generated Huffman codes. 4. **Decode Data**: * Implement a method `decode(encoded_data: str) -> str` that takes an encoded string and returns the decoded original string using the Huffman Tree. # Function Signature ```python from typing import List, Tuple, Dict class HuffmanCoding: def __init__(self): # Initialize your data structure here pass def build_tree(self, char_freq: List[Tuple[str, int]]) -> None: pass def generate_codes(self) -> Dict[str, str]: pass def encode(self, data: str) -> str: pass def decode(self, encoded_data: str) -> str: pass ``` # Input * A list of tuples where each tuple contains a character and its frequency. * A string of data to encode. * An encoded string to decode. # Output * **build_tree**: None. * **generate_codes**: A dictionary where keys are characters and values are their Huffman codes. * **encode**: A string representing encoded data. * **decode**: A string representing the original decoded data. # Example Usage ```python # Example Usage huffman = HuffmanCoding() char_freq = [(\'a\', 5), (\'b\', 9), (\'c\', 12), (\'d\', 13), (\'e\', 16), (\'f\', 45)] huffman.build_tree(char_freq) codes = huffman.generate_codes() print(codes) # Should output the Huffman codes for each character data = \\"abcde\\" encoded_data = huffman.encode(data) print(encoded_data) # Should output the encoded string decoded_data = huffman.decode(encoded_data) print(decoded_data) # Should output the original string \'abcde\' ``` # Constraints 1. Assume all characters provided are within the ASCII range. 2. The length of the input data string will be between 1 and 1000. 3. Each character frequency will be positive and the sum of all frequencies will be less than or equal to 10000. 4. The methods should handle the operations efficiently.","solution":"from typing import List, Tuple, Dict import heapq class HuffmanCoding: class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def __init__(self): self.root = None self.codes = {} self.reverse_codes = {} def build_tree(self, char_freq: List[Tuple[str, int]]) -> None: heap = [self.Node(char, freq) for char, freq in char_freq] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = self.Node(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) self.root = heap[0] self._generate_codes_helper(self.root, \'\') def _generate_codes_helper(self, node, current_code): if node is None: return if node.char is not None: self.codes[node.char] = current_code self.reverse_codes[current_code] = node.char self._generate_codes_helper(node.left, current_code + \'0\') self._generate_codes_helper(node.right, current_code + \'1\') def generate_codes(self) -> Dict[str, str]: return self.codes def encode(self, data: str) -> str: encoded_data = \'\'.join([self.codes[char] for char in data]) return encoded_data def decode(self, encoded_data: str) -> str: current_code = \'\' decoded_data = \'\' for bit in encoded_data: current_code += bit if current_code in self.reverse_codes: decoded_data += self.reverse_codes[current_code] current_code = \'\' return decoded_data"},{"question":"# Scenario: You are responsible for developing an analytics tool that constantly computes various statistics from a stream of numbers. One such metric is the average of the k most recent numbers from the stream. Your task is to implement a function that efficiently maintains and returns the moving average. # Function Requirements: * Implement a class `MovingAverage` that initializes with an integer `k` representing the window size. * The class should have a method `next(val: float) -> float` which takes a new value from the stream and returns the current moving average of the last k values. * If less than k values have been processed, return the average of all values received so far. # Constraints: * The window size k will be a positive integer. * The stream of numbers will be continuous and non-empty. # Class Signature: ```python class MovingAverage: def __init__(self, k: int): pass def next(self, val: float) -> float: pass ``` # Example: ```python m_avg = MovingAverage(3) assert round(m_avg.next(1), 2) == 1.00 # output is 1.0 since there is only one value assert round(m_avg.next(10), 2) == 5.50 # output is (1 + 10) / 2 assert round(m_avg.next(3), 2) == 4.67 # output is (1 + 10 + 3) / 3 assert round(m_avg.next(5), 2) == 6.00 # output is (10 + 3 + 5) / 3 since window size is 3 ``` # Input: - `k` (integer): The window size for the moving average. - `val` (float): A new value from the stream. # Output: - (float): The moving average of the last k values rounded to two decimal places. **Good luck!**","solution":"from collections import deque class MovingAverage: def __init__(self, k: int): Initialize the MovingAverage with a window size k. self.k = k self.queue = deque() self.sum = 0.0 def next(self, val: float) -> float: Takes a new value from the stream and returns the current moving average of the last k values. self.queue.append(val) self.sum += val if len(self.queue) > self.k: self.sum -= self.queue.popleft() return self.sum / len(self.queue)"},{"question":"# Scenario An analytics company operates a service where they track user interactions with an online platform. They store these interactions as events in a server log file, which contain various pieces of information such as the event type, timestamp, and user ID. The company needs a utility function to analyze the log file and determine the most active user, i.e., the user who has the highest number of events recorded. # Task Write a Python function `most_active_user(log: str) -> str` that takes a single string as input, representing the server log file. Each line in the log file contains a user ID. The function should return the user ID of the most active user. # Requirements - You are given the server log as a newline-separated string where each line is a user ID - You need to parse the log and count the occurrences of each user ID - The function should return the user ID with the highest number of occurrences - If there is a tie, return any of the tied user IDs # Input and Output - **Input**: A single string `log` which is a newline-separated log of user IDs - **Output**: A single string representing the user ID of the most active user # Constraints - The input string log can have up to 1,000,000 lines - Each user ID is an alphanumeric string with a maximum length of 30 characters # Examples ```python >>> log = \\"user_1nuser_2nuser_1nuser_3nuser_1nuser_2n\\" >>> most_active_user(log) \'user_1\' >>> log = \\"user_2nuser_2nuser_2nuser_1nuser_3nuser_1n\\" >>> most_active_user(log) \'user_2\' ``` **Notes** - Consider using a dictionary or `Counter` from the `collections` module to count user IDs efficiently. - The function should handle large logs efficiently, both in terms of time and space complexity. Create a Python function `most_active_user` following the described specifications.","solution":"def most_active_user(log: str) -> str: Given a string representing a server log where each line contains a user ID, this function returns the user ID of the most active user (i.e. the user with the highest number of events recorded). from collections import Counter # Split the log string into individual lines (user IDs) user_ids = log.strip().split(\'n\') # Count the occurrences of each user ID user_count = Counter(user_ids) # Find the user ID with the maximum count most_active = max(user_count, key=user_count.get) return most_active"},{"question":"# Coding Assessment Question **Problem Context**: You are developing an application that requires frequent conversion between different numeral systems. Your task is to implement functions that convert integers from decimal (base-10) to binary (base-2) and hexadecimal (base-16), and vice versa. This is essential for seamless data representation and manipulation in various systems. **Task**: Implement two pairs of functions, `decimal_to_binary(n: int) -> str` and `binary_to_decimal(b: str) -> int`, as well as `decimal_to_hexadecimal(n: int) -> str` and `hexadecimal_to_decimal(h: str) -> int`, that convert integers between decimal, binary, and hexadecimal numeral systems. Ensure that your implementations handle both positive and negative integers correctly. **Function Signature**: ```python def decimal_to_binary(n: int) -> str: pass def binary_to_decimal(b: str) -> int: pass def decimal_to_hexadecimal(n: int) -> str: pass def hexadecimal_to_decimal(h: str) -> int: pass ``` **Constraints**: 1. All functions should handle both positive and negative integers. 2. The binary strings will begin with `-` if the number is negative. 3. The hexadecimal strings will begin with `-` if the number is negative. 4. Validate and handle invalid input scenarios. 5. Ensure correctness and efficiency in both conversion directions. **Input Format**: - For binary and hexadecimal conversion functions, input will be a string representing the binary or hexadecimal number. - For decimal conversion functions, input will be an integer. **Output Format**: - For binary and hexadecimal conversion functions, output will be a string representing the binary or hexadecimal number. - For decimal conversion functions, output will be an integer. **Example**: ```python >>> decimal_to_binary(10) \'1010\' >>> binary_to_decimal(\'1010\') 10 >>> decimal_to_hexadecimal(255) \'FF\' >>> hexadecimal_to_decimal(\'FF\') 255 >>> decimal_to_binary(-10) \'-1010\' >>> binary_to_decimal(\'-1010\') -10 >>> decimal_to_hexadecimal(-255) \'-FF\' >>> hexadecimal_to_decimal(\'-FF\') -255 >>> binary_to_decimal(\'2\') ValueError: Invalid binary string >>> hexadecimal_to_decimal(\'G1\') ValueError: Invalid hexadecimal string ``` **Additional Task**: - Validate and handle incorrect input formats in a separate `main` function that prompts user input and calls all conversion functions, ensuring outputs are consistent and correct. **Performance Requirements**: - Implement conversion functions ensuring efficient time complexity. - Handle conversions without using Python\'s built-in conversion functions.","solution":"def decimal_to_binary(n: int) -> str: Converts a decimal (base-10) integer to a binary (base-2) string. if n == 0: return \'0\' is_negative = n < 0 n = abs(n) binary_str = \'\' while n > 0: binary_str = str(n % 2) + binary_str n //= 2 return \'-\' + binary_str if is_negative else binary_str def binary_to_decimal(b: str) -> int: Converts a binary (base-2) string to a decimal (base-10) integer. if b.strip()[0] == \'-\': return -binary_to_decimal(b[1:]) try: decimal_val = 0 for digit in b: if digit not in \'01\': raise ValueError(\\"Invalid binary string\\") decimal_val = decimal_val * 2 + int(digit) return decimal_val except ValueError: raise ValueError(\\"Invalid binary string\\") def decimal_to_hexadecimal(n: int) -> str: Converts a decimal (base-10) integer to a hexadecimal (base-16) string. if n == 0: return \'0\' hexadecimal_digits = \'0123456789ABCDEF\' is_negative = n < 0 n = abs(n) hex_str = \'\' while n > 0: hex_str = hexadecimal_digits[n % 16] + hex_str n //= 16 return \'-\' + hex_str if is_negative else hex_str def hexadecimal_to_decimal(h: str) -> int: Converts a hexadecimal (base-16) string to a decimal (base-10) integer. if h.strip()[0] == \'-\': return -hexadecimal_to_decimal(h[1:]) hexadecimal_digits = \'0123456789ABCDEF\' try: decimal_val = 0 for digit in h: if digit.upper() not in hexadecimal_digits: raise ValueError(\\"Invalid hexadecimal string\\") decimal_val = decimal_val * 16 + hexadecimal_digits.index(digit.upper()) return decimal_val except ValueError: raise ValueError(\\"Invalid hexadecimal string\\")"},{"question":"# Domino Arrangement Challenge You are given an empty rectangular grid of size `M x N`. Your task is to determine the maximum number of 2x1 dominoes that can be placed on the grid such that no dominoes overlap and every domino covers exactly two cells. # Input Format: * Integers `M` and `N`: The dimensions of the grid (1 <= M, N <= 100). # Output Format: * Integer: The maximum number of 2x1 dominoes that can be placed on the grid. # Constraints: * The grid dimensions are such that it is always possible to perfectly cover with 2x1 dominoes when possible. # Example: Input: ``` 3 3 ``` Output: ``` 4 ``` Explanation: The grid can accommodate a maximum of 4 dominoes. For example: ``` D D _ _ D D D D _ ``` where `D` marks the cells covered by dominoes. # Function Signature: ```python def max_dominoes(M: int, N: int) -> int: # Your implementation here pass ```","solution":"def max_dominoes(M: int, N: int) -> int: Returns the maximum number of 2x1 dominoes that can be placed on the MxN grid. # Each domino covers 2 cells, so the maximum number of dominoes # is simply the total number of cells divided by 2. total_cells = M * N return total_cells // 2"},{"question":"# Multi-stage Processing Pipeline You are given a set of independent processing stages that need to be applied sequentially to transform a collection of input data. Each stage performs a specific operation on the data items and passes the transformed data to the next stage. Your task is to write a function that simulates the processing of data through several stages. Each stage is represented by a function, and the stages must be applied in the given order to each item in the input list. Requirements: 1. The function should accept a list of data and a list of stage functions. 2. Each function in the stages list takes a single argument (a data item) and returns a transformed data item. 3. Apply each stage in sequence to all data items in the input list. Input: * `data` (list): a list of data items to be processed. * `stages` (list): a list of functions that represent the processing stages. Output: * A transformed list of data items after all stages have been applied. Function Signature: ```python def process_pipeline(data: list, stages: list) -> list: pass ``` Example: ```python # Sample stage functions def increment(x): return x + 1 def multiply_by_two(x): return x * 2 # Example usage: data = [1, 2, 3, 4, 5] stages = [increment, multiply_by_two] assert process_pipeline(data, stages) == [4, 6, 8, 10, 12] ``` Constraints: * `1 <= len(data) <= 10^4` * `1 <= len(stages) <= 10` * The input data list contains integers `1 <= data[i] <= 10^6` Implement the function `process_pipeline` adhering to the above specifications.","solution":"def process_pipeline(data: list, stages: list) -> list: for stage in stages: data = [stage(item) for item in data] return data # Sample stage functions def increment(x): return x + 1 def multiply_by_two(x): return x * 2 def square(x): return x * x"},{"question":"# Coding Assessment Question **Context**: You are developing a system for a library to manage its book inventory. The library keeps a record of books, their authors, publication years, and their availability status. You need to implement a function that can retrieve information about books based on the specified author\'s name and sort them by publication year in ascending order. # Task Write a function `get_books_by_author` that takes an author\'s name and a list of books and returns a list of book titles by that author, sorted by the publication year in ascending order. # Function Signature ```python def get_books_by_author(author_name: str, books: List[Dict[str, Any]]) -> List[str]: ``` # Input - `author_name` (str): A string representing the author\'s name. - `books` (List[Dict[str, Any]]): A list of dictionaries where each dictionary contains: - `title` (str): Title of the book. - `author` (str): Name of the author. - `publication_year` (int): Year the book was published. - `available` (bool): Availability status of the book. # Output - Returns a list of book titles by the specified author, sorted by the publication year in ascending order. # Constraints - The `author_name` will be a non-empty string. - The `books` list will have at least one book. # Performance Requirements - The function should handle cases where the specified author has no books in the list efficiently. - The sorting should be performed in a time-efficient manner. # Example ```python books = [ {\'title\': \'Book A\', \'author\': \'Author X\', \'publication_year\': 2000, \'available\': True}, {\'title\': \'Book B\', \'author\': \'Author Y\', \'publication_year\': 1999, \'available\': False}, {\'title\': \'Book C\', \'author\': \'Author X\', \'publication_year\': 2003, \'available\': True}, {\'title\': \'Book D\', \'author\': \'Author Z\', \'publication_year\': 2001, \'available\': True} ] print(get_books_by_author(\'Author X\', books)) ``` Expected Output: ``` [\'Book A\', \'Book C\'] ``` **Note**: - If there are no books by the specified author, the function should return an empty list. - Only the book titles should be returned, sorted by publication year in ascending order. # Additional Information 1. The function should handle any potential edge cases, such as an empty list of books or missing keys in the book dictionaries, gracefully. 2. Ensure appropriate documentation and error handling mechanisms are in place for robustness.","solution":"from typing import List, Dict, Any def get_books_by_author(author_name: str, books: List[Dict[str, Any]]) -> List[str]: Retrieve books by the specified author, sorted by publication year in ascending order. Args: author_name (str): The name of the author. books (List[Dict[str, Any]]): A list of dictionaries representing books. Each dictionary contains: - \'title\' (str): Title of the book, - \'author\' (str): Name of the author, - \'publication_year\' (int): Year the book was published, - \'available\' (bool): Availability status of the book. Returns: List[str]: A list of titles of books by the specified author, sorted by the publication year. # Filter books by the specified author filtered_books = [book for book in books if book[\'author\'] == author_name] # Sort the filtered books by publication year in ascending order sorted_books = sorted(filtered_books, key=lambda x: x[\'publication_year\']) # Extract and return the titles of the sorted books return [book[\'title\'] for book in sorted_books]"},{"question":"**Question 2**: **Task**: Implement a function `find_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]` that finds and returns a path through a given maze from the start position to the end position. The maze is represented as a 2D list where `0` means an open cell, and `1` means a blocked cell. **Requirements**: - Implement **Breadth-First Search (BFS)** to find the shortest path in an unweighted grid. - Handle different maze configurations, ensuring your algorithm efficiently explores the shortest route. - Return the path as a list of coordinate tuples representing the cells visited from start to end. **Input/Output Specification**: - **Input**: - `maze` - A 2D list of integers where 0 represents an open cell and 1 represents a blocked cell. - `start` - A tuple (x, y) indicating the start position in the maze. - `end` - A tuple (x, y) indicating the end position in the maze. - **Output**: A list of tuples representing the path from start to end, including both start and end positions. If no path exists, return an empty list. - **Constraints**: - The maze will always have at least one open cell. - Start and end positions will always be open cells. - Maze dimensions can vary but will fit within typical memory constraints. **Performance**: Your implementation should strive to be efficient, ideally maintaining O(m*n) time complexity, where m is the number of rows and n is the number of columns in the maze. **Scenario**: Given a maze with open and blocked cells, you need to: - Start from the `start` position. - Find the shortest path to the `end` position using BFS. - Construct the path as a sequence of coordinate tuples. - Return this path as a list. **Edge Cases**: - No possible path from start to end. - The start and end positions are the same. - Small mazes with minimal cells. Implement and thoroughly test the `find_path` function to handle various scenarios and edge cases.","solution":"from typing import List, Tuple from collections import deque def find_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: if start == end: return [start] rows, cols = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(start, [start])]) visited.add(start) while queue: (current_x, current_y), path = queue.popleft() for dx, dy in directions: next_x, next_y = current_x + dx, current_y + dy if (0 <= next_x < rows) and (0 <= next_y < cols) and maze[next_x][next_y] == 0 and (next_x, next_y) not in visited: if (next_x, next_y) == end: return path + [(next_x, next_y)] queue.append(((next_x, next_y), path + [(next_x, next_y)])) visited.add((next_x, next_y)) return []"},{"question":"# Coding Assessment Question Scenario: You are a software developer working on a project management tool. One of the features involves analyzing the work schedule to identify the longest path of tasks that must be completed in sequence without overlap, essentially finding the critical path in a Directed Acyclic Graph (DAG) representing tasks and their dependencies. Goals: Using a topological sorting algorithm, write a Python function `find_critical_path` that takes the number of tasks and their dependencies, and returns the longest path of task completion times as a list of task indices. Function Signature: ```python def find_critical_path(n: int, dependencies: list[tuple[int, int, int]]) -> list[int]: pass ``` Input: - `n (int)`: The number of tasks, represented as nodes in the graph. - `dependencies (list[tuple[int, int, int]])`: A list of tuples where each tuple (u, v, w) signifies that task u must be completed before task v and the time taken to complete task u is w units. Output: - `list[int]`: A list of task indices representing the longest path in terms of completion times. Example: ```python n = 6 dependencies = [(0, 1, 2), (1, 2, 2), (1, 3, 4), (3, 4, 1), (4, 5, 2)] print(find_critical_path(n, dependencies)) # Output: [0, 1, 3, 4, 5] ``` Constraints: - The number of tasks will not exceed 1000. - Each task can depend on multiple other tasks but the total number of dependencies will not exceed 10,000. Performance Requirements: - The solution must efficiently handle the constraints on the number of tasks (vertices) and dependencies (edges) as specified.","solution":"from collections import deque, defaultdict def find_critical_path(n, dependencies): # Step 1: Create the graph structure graph = defaultdict(list) in_degree = [0] * n weights = {} for u, v, w in dependencies: graph[u].append((v, w)) in_degree[v] += 1 weights[(u, v)] = w # Step 2: Topological Sort using Kahn\'s Algorithm topo_sort = [] zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topo_sort.append(node) for neighbor, _ in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Step 3: Find the longest path dist = [-float(\'inf\')] * n parent = [-1] * n # Initialize distances of nodes with no incoming edges to 0 for node in topo_sort: if in_degree[node] == 0: dist[node] = 0 for u in topo_sort: for v, w in graph[u]: if dist[v] < dist[u] + w: dist[v] = dist[u] + w parent[v] = u # Step 4: Reconstruct the longest path max_dist = max(dist) end_node = dist.index(max_dist) path = [] while end_node != -1: path.append(end_node) end_node = parent[end_node] return path[::-1]"},{"question":"# SQL Query Optimization You are given a SQL table named `employees` with the following structure: | Column Name | Data Type | |-------------|------------| | id | INT | | name | VARCHAR | | department | VARCHAR | | salary | INT | The table contains details of employees such as their id, name, department, and salary. Write a function `optimize_query(conn) -> str` that takes a database connection and optimizes the given SQL query for performance. The query retrieves the top 5 highest salaried employees from each department. The original query is as follows: ```sql SELECT e1.id, e1.name, e1.department, e1.salary FROM employees e1 WHERE e1.salary >= ( SELECT MIN(e2.salary) FROM employees e2 WHERE e2.department = e1.department ORDER BY e2.salary DESC LIMIT 5 ) ORDER BY e1.department, e1.salary DESC; ``` The function `optimize_query` should return an optimized version of the above SQL query as a string which enhances its performance, ensuring the correct results are still returned. Input: - `conn`: A database connection object. Output: - A string representing the optimized SQL query. # Example ```python conn = sqlite3.connect(\'employee.db\') print(optimize_query(conn)) # Output # # WITH ranked_employees AS ( # SELECT id, name, department, salary, # ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rnk # FROM employees # ) # SELECT id, name, department, salary # FROM ranked_employees # WHERE rnk <= 5 # ORDER BY department, salary DESC; # ``` # Constraints 1. Assume the `employees` table contains a large volume of data, so the query must be optimized for performance. 2. Use analytic functions such as `ROW_NUMBER()` for optimization. 3. The database connection and table structure will always be valid for the purpose of this task. 4. The solution must handle SQL syntax according to the rules of either SQLite, PostgreSQL, or MySQL.","solution":"def optimize_query(conn) -> str: Returns an optimized SQL query to retrieve the top 5 highest salaried employees from each department. query = WITH ranked_employees AS ( SELECT id, name, department, salary, ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rnk FROM employees ) SELECT id, name, department, salary FROM ranked_employees WHERE rnk <= 5 ORDER BY department, salary DESC; return query"},{"question":"Given an array of integers, implement a function `find_missing_number(nums: list) -> int` that finds the single missing number in the series from `0` to `n`. # Input - **List** of integers `nums` containing `n` distinct numbers taken from the range `[0, n]` where exactly one number is missing. # Output - **Integer**: The missing number in the series. # Constraints 1. The given list has length between (1) and (10^5) (inclusive). 2. The elements in the array are between (0) and (n). # Example ```python nums_1 = [3, 0, 1] print(find_missing_number(nums_1)) # Output: 2 nums_2 = [9,6,4,2,3,5,7,0,1] print(find_missing_number(nums_2)) # Output: 8 ``` Implement the function `find_missing_number(nums: list) -> int` by completing this task. Notes - Consider leveraging mathematical properties of summation or using bit manipulation to find the missing number efficiently. - Ensure the function handles large input sizes effectively within the given constraints.","solution":"def find_missing_number(nums): Returns the single missing number in the series from 0 to n. n = len(nums) total_sum = n * (n + 1) / 2 actual_sum = sum(nums) missing_number = int(total_sum - actual_sum) return missing_number"},{"question":"# Question: **Context**: Array manipulation techniques are essential for various computational problems, and understanding how to implement operations such as rotations efficiently can significantly impact the performance of an algorithm dealing with large datasets. In this task, you will demonstrate your ability to perform array rotations to achieve specific outcomes. Task Write a function `rotate_array(arr: List[int], k: int) -> List[int]` that rotates an array of integers `arr` by `k` positions to the right. The rotation should be done in-place, meaning you should not use extra space for another array. Input - `arr` (List[int]): A list of integers representing the array to be rotated. - `k` (int): The number of positions to rotate the array. If `k` is greater than the length of the array, use `k % len(arr)`. Output - A list of integers representing the rotated array. Constraints - The length of `arr` is between `0` and `10^5`. - Each integer in `arr` fits within the range of a 32-bit signed integer. - `k` is a non-negative integer and fits within the range of a 32-bit signed integer. Examples ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3], 3) == [1, 2, 3] assert rotate_array([], 1) == [] assert rotate_array([1], 5) == [1] ``` Additional Notes - You are allowed to use extra helper functions as long as the array is rotated in-place. - Consider edge cases such as empty arrays and rotations greater than the array length.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array arr by k positions to the right. n = len(arr) if n == 0: return arr # Ensure k is within the bounds of the array length k = k % n if k == 0: return arr # Rotating the array in-place using reverse technique # Step 1: Reverse the whole array arr.reverse() # Step 2: Reverse the first k elements arr[:k] = reversed(arr[:k]) # Step 3: Reverse the last n - k elements arr[k:] = reversed(arr[k:]) return arr"},{"question":"# Find the Missing Number in a Sequence As a software developer, you are often faced with the challenge of manipulating and analyzing data sequences. One common task is determining a missing element in a complete integer sequence. Given an array consisting of `n` distinct integers in the range `0` to `n` (inclusive) and exactly one integer is missing from this range, your task is to find and return the missing number. Write a Python function `find_missing_number` that accepts one parameter: 1. `numbers` (list[int]): A list of distinct integers with a single missing number in the range from `0` to `n`. The function should return the missing number as an integer. # Example Usage ```python # Example 1 numbers = [3, 0, 1] find_missing_number(numbers) => 2 # Example 2 numbers = [0, 1] find_missing_number(numbers) => 2 # Example 3 numbers = [9, 6, 4, 2, 3, 5, 7, 0, 1] find_missing_number(numbers) => 8 # Example 4 numbers = [0] find_missing_number(numbers) => 1 ``` # Constraints - The length of the input list `numbers` will be `n`, where `1 ≤ n ≤ 10^4`. - The elements in `numbers` are unique and will be in the range from `0` to `n` (inclusive, with one missing). # Implementation ```python def find_missing_number(numbers: list[int]) -> int: # Your implementation here. pass ``` Your task is to complete the `find_missing_number` function ensuring it efficiently finds the missing number from the sequence of integers.","solution":"def find_missing_number(numbers): Returns the missing number in the given list of integers from 0 to n. n = len(numbers) total_sum = n * (n + 1) / 2 actual_sum = sum(numbers) return int(total_sum - actual_sum)"},{"question":"Image Cropping Utility You are developing an image processing utility that includes a feature for cropping images. Given the coordinates of the top-left and bottom-right corners of the cropping rectangle, you need to extract this rectangular region from the image. # Task: Implement the function `crop_image(image: list[list[int]], top_left: tuple[int, int], bottom_right: tuple[int, int]) -> list[list[int]]` following the specifications provided below: 1. **Function `crop_image(image: list[list[int]], top_left: tuple[int, int], bottom_right: tuple[int, int]) -> list[list[int]]`:** * **Input**: * `image`: A 2D list of integers where each integer represents a pixel value, assuming a grayscale image where pixel values range from 0 to 255. * `top_left`: A tuple of two integers `(x1, y1)` representing the coordinates of the top-left corner of the cropping rectangle. * `bottom_right`: A tuple of two integers `(x2, y2)` representing the coordinates of the bottom-right corner of the cropping rectangle. * **Output**: * A 2D list of integers representing the cropped region of the image. * **Constraints**: * The coordinates `(x1, y1)` and `(x2, y2)` are within the bounds of the image dimensions. * `(x1, y1)` is less than or equal to `(x2, y2)`. # Examples: ```python # Example 1 image1 = [ [255, 255, 255, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 255, 255, 255] ] top_left1 = (1, 1) bottom_right1 = (2, 2) print(crop_image(image1, top_left1, bottom_right1)) # Output: [[0, 0], [0, 0]] # Example 2 image2 = [ [0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15] ] top_left2 = (1, 0) bottom_right2 = (3, 2) print(crop_image(image2, top_left2, bottom_right2)) # Output: [[4, 5, 6], [8, 9, 10], [12, 13, 14]] # Example 3 image3 = [ [10, 20, 30, 40, 50], [60, 70, 80, 90, 100], [110, 120, 130, 140, 150], [160, 170, 180, 190, 200] ] top_left3 = (0, 2) bottom_right3 = (3, 4) print(crop_image(image3, top_left3, bottom_right3)) # Output: [[30, 40, 50], [80, 90, 100], [130, 140, 150], [180, 190, 200]] ``` # Additional Information: Ensure your function handles edge cases where the cropping rectangle might touch the borders of the image. Also, the dimensions of the resulting cropped image should be correctly calculated based on the input coordinates.","solution":"def crop_image(image, top_left, bottom_right): Crops a rectangular region from the image defined by the top-left and bottom-right coordinates. Parameters: image (list of list of int): The 2D image to crop, represented as a list of lists of integers. top_left (tuple of int): Coordinates of the top-left corner of the cropping rectangle. bottom_right (tuple of int): Coordinates of the bottom-right corner of the cropping rectangle. Returns: list of list of int: The cropped region of the image. x1, y1 = top_left x2, y2 = bottom_right cropped_image = [row[y1:y2+1] for row in image[x1:x2+1]] return cropped_image"},{"question":"# Matrix Transposition and Rotation **Context**: Transposition and rotation are fundamental operations that can be efficiently performed on matrices. These operations are commonly used in graphics, cryptography, and various data transformation tasks. **Task**: Write a function that takes a square matrix, first transposes it, and then rotates it 90 degrees clockwise. The function should perform these operations in place, utilizing the properties of the matrix to avoid unnecessary memory usage. **Function Signature**: ```python def transpose_and_rotate(matrix: List[List[int]]) -> None: pass ``` **Input and Output**: * **Input**: * `matrix` - A 2D list of integers representing an NxN matrix. * **Output**: * None. The matrix is modified in-place. **Constraints**: * The input matrix is always a valid square matrix. * The function should perform efficiently for matrices up to size 1000x1000 pixels. **Performance Requirements**: * Time Complexity: O(N^2) * Space Complexity: O(1)[excluding input space] **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transpose_and_rotate(matrix) print(matrix) ``` **Output**: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"from typing import List def transpose_and_rotate(matrix: List[List[int]]) -> None: This function takes a square matrix, first transposes it, and then rotates it 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i+1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Rotate the matrix 90 degrees clockwise by reversing each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Question: Expression Evaluator with Variable Substitution You are tasked with creating an expression evaluator that can handle basic arithmetic expressions and substitute variables with specified values before evaluating. The arithmetic expressions can contain addition (+), subtraction (-), multiplication (*), division (/), parentheses, and variables. Write a function `evaluate_expression` that evaluates a given arithmetic expression after substituting the variables with their corresponding values. Function Signature ```python def evaluate_expression(expression: str, variables: Dict[str, Union[int, float]]) -> Union[int, float]: ``` Parameters - **expression**: (string) The arithmetic expression to be evaluated. It may contain variables represented by alphabetic characters. - **variables**: (dictionary) A dictionary where keys are variable names (strings) and values are their corresponding numeric values (integer or float). Returns - (integer or float) The result of evaluating the arithmetic expression after substituting the variables with their values. Constraints - The expression given will be valid and will not contain any division by zero. - Variable names will be single alphabetic characters and guaranteed to be provided in the `variables` dictionary. - Expressions may contain nested parentheses. Example Usage ```python variables = {\'a\': 5, \'b\': 2, \'c\': 3.5} print(evaluate_expression(\\"a + b * c\\", variables)) # Evaluates the expression `5 + 2 * 3.5` and should return `12.0`. print(evaluate_expression(\\"(a + b) * c\\", variables)) # Evaluates the expression `(5 + 2) * 3.5` and should return `24.5`. print(evaluate_expression(\\"a * (b + (c - a))\\", variables)) # Evaluates the expression `5 * (2 + (3.5 - 5))` and should return `2.5`. ``` # Implementation Notes - Ensure to handle nested parentheses correctly. - The implementation should parse the expression, replace the variables with their values, and then evaluate the expression accurately. - Use appropriate exception handling to manage potential errors in expression parsing and evaluation.","solution":"from typing import Dict, Union def evaluate_expression(expression: str, variables: Dict[str, Union[int, float]]) -> Union[int, float]: # Replace variables in the expression with their values for var, value in variables.items(): expression = expression.replace(var, str(value)) # Evaluate the expression safely try: result = eval(expression) except Exception as e: raise ValueError(f\\"Error evaluating expression: {e}\\") return result"},{"question":"# Context: You are given a 2D grid representing a map where a \'1\' represents land and a \'0\' represents water. You need to write a function to find the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. # Problem: 1. Write a method `numIslands(self, grid)` that returns the number of islands. 2. Write a method `dfs(self, grid, i, j)` that is used internally by `numIslands(self, grid)` to perform a Depth-First Search to mark the visited land cells. # Implementation Details: - Class definition: `class IslandCounter:` - Methods to implement: * `def numIslands(self, grid):` * `def dfs(self, grid, i, j):` # Input: - `numIslands(self, grid)` takes a single parameter: * `grid` (List[List[str]]): A 2D list representing the map, where \'1\' represents land and \'0\' represents water. - `dfs(self, grid, i, j)` takes three parameters: * `grid` (List[List[str]]): The map grid. * `i` (int): The row index of the current land cell. * `j` (int): The column index of the current land cell. # Output: - `numIslands(self, grid)` returns an integer representing the number of islands. - `dfs(self, grid, i, j)` does not return anything but modifies the grid in place. # Constraints: - The grid dimensions (rows x columns) will not exceed 300 x 300. - You may assume that all edges of the grid are surrounded by water. # Performance Requirements: - The `numIslands(self, grid)` method should have a time complexity of O(m * n), where m is the number of rows and n is the number of columns in the grid. - The `dfs(self, grid, i, j)` method should visit each land cell at most once. # Example Usage: ```python island_counter = IslandCounter() grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] # Counting the number of islands num_islands = island_counter.numIslands(grid) print(num_islands) # Output: 3 ```","solution":"class IslandCounter: def numIslands(self, grid): if not grid: return 0 self.num_rows = len(grid) self.num_cols = len(grid[0]) self.grid = grid self.visited = [[False for _ in range(self.num_cols)] for _ in range(self.num_rows)] num_islands = 0 for i in range(self.num_rows): for j in range(self.num_cols): if self.grid[i][j] == \'1\' and not self.visited[i][j]: self.dfs(i, j) num_islands += 1 return num_islands def dfs(self, i, j): if i < 0 or i >= self.num_rows or j < 0 or j >= self.num_cols or self.grid[i][j] == \'0\' or self.visited[i][j]: return self.visited[i][j] = True self.dfs(i - 1, j) self.dfs(i + 1, j) self.dfs(i, j - 1) self.dfs(i, j + 1)"},{"question":"# Context You are provided with a list of integers and tasked with calculating the \\"running sum\\" for each element in the list. The running sum at a given index is defined as the sum of the elements from the start of the list up to that index. # Task Implement the `running_sum` function such that it returns a list where each element is the running sum of the corresponding element in the input list. # Function Signature ```python def running_sum(data: list) -> list: pass ``` # Input * `data` (list): A list of integers, where the size can range from 0 to 1000 elements. # Output * A list of integers where each element is the running sum up to that index in the input list. # Constraints * The input list is assumed to be properly formatted with integers only. * Handle edge cases like empty lists and lists with one element. # Examples ```python print(running_sum([1, 2, 3, 4])) # Output: [1, 3, 6, 10] print(running_sum([1])) # Output: [1] print(running_sum([])) # Output: [] print(running_sum([5, -1, 3, 2])) # Output: [5, 4, 7, 9] ``` # Additional Instructions * Ensure your implementation is purely in Python and does not rely on any external libraries. * Include inline comments to document the main steps of your algorithm. * Validate that the input list contains integer elements before processing.","solution":"def running_sum(data: list) -> list: Calculate the running sum of a list of integers. Parameters: data (list): List of integers. Returns: list: List where each element is the running sum up to that index. # Check if the list is empty if not data: return [] # Initialize the running sum list with the first element running_sum_list = [data[0]] # Iterate through the input list starting from the second element for i in range(1, len(data)): # Append the sum of the current element and the last element in the running sum list running_sum_list.append(running_sum_list[-1] + data[i]) return running_sum_list"},{"question":"# Coding Assessment Question Problem Statement You are working on a project that involves processing large datasets. You need to implement two functions to remove duplicate elements from a list while maintaining the original order of first occurrences. **Function Signatures** ```python def remove_duplicates(input_list: List[int]) -> List[int]: pass def remove_duplicates_alternative(input_list: List[int], key_function: Callable[[int], Any]) -> List[int]: pass ``` **Input/Output Description** 1. `input_list` (List[int]): A list of integers, each element can range from -10^6 to 10^6. 2. `key_function` (Callable[[int], Any]): A function that takes an integer and returns a value. You can use this key function to define how duplicates are identified. The first function (`remove_duplicates`) should return a list with duplicates removed, maintaining only the first occurrence of each element. The second function (`remove_duplicates_alternative`) should use the `key_function` to determine uniqueness and return the list with duplicates removed based on the output of the `key_function`. **Constraints** - The length of `input_list` will be between 0 and 10^5. - The `key_function` will map an integer to a unique identifier which is used to determine duplicates. Example ```python # Example of remove_duplicates input_list1 = [3, 5, 3, 7, 5, 3, 8] print(remove_duplicates(input_list1)) # Output: [3, 5, 7, 8] # Example of remove_duplicates_alternative input_list2 = [2, -2, 4, 4, -2, 2, 6, -6] key_func = lambda x: abs(x) print(remove_duplicates_alternative(input_list2, key_func)) # Output: [2, 4, 6] ``` Notes 1. Ensure the list maintains the original order of first occurrences. 2. Handle edge cases such as an empty list. 3. Consider performance and optimize for time complexity. 4. Write comprehensive tests to ensure the functions work correctly for various edge cases and scenarios.","solution":"from typing import List, Callable, Any def remove_duplicates(input_list: List[int]) -> List[int]: Removes duplicates from the input_list while maintaining the original order of first occurrences. seen = set() result = [] for item in input_list: if item not in seen: seen.add(item) result.append(item) return result def remove_duplicates_alternative(input_list: List[int], key_function: Callable[[int], Any]) -> List[int]: Removes duplicates from the input_list based on the output of key_function while maintaining the original order of first occurrences. seen = set() result = [] for item in input_list: key = key_function(item) if key not in seen: seen.add(key) result.append(item) return result"},{"question":"# Question Background Binary search is an efficient algorithm for finding an item from a sorted list of items. It halves the search space at each step, reducing the time complexity to O(log n). However, traditional binary search only works on lists sorted in non-decreasing order. Sometimes, we may encounter lists sorted in non-increasing order and need to adapt the algorithm appropriately. Problem Implement a function `binary_search_desc` that performs binary search on a list sorted in non-increasing order and returns the index of the target value. If the target value is not found, return -1. Function Signature ```python def binary_search_desc(arr: list, target: int) -> int: :param arr: A list of integers sorted in non-increasing order. :param target: The integer value to search for in the list. :return: The index of the target value if found, otherwise -1. pass ``` Requirements - Implement binary search tailored for lists sorted in non-increasing order. - Ensure the function has a time complexity of O(log n). - Return the index of the target value if present; otherwise, return -1. Constraints - The list `arr` can contain up to 10^5 elements. - The elements in the list can be any integer within the range of -10^9 to 10^9. - Ensure your implementation handles edge cases properly, such as an empty list. Example ```python # Example 1 arr = [9, 7, 5, 3, 1] target = 5 print(binary_search_desc(arr, target)) # Output: 2 # Example 2 arr = [100, 80, 60, 40, 20] target = 25 print(binary_search_desc(arr, target)) # Output: -1 # Example 3 arr = [10] target = 10 print(binary_search_desc(arr, target)) # Output: 0 # Example 4 arr = [] target = -5 print(binary_search_desc(arr, target)) # Output: -1 ``` In these examples, the `binary_search_desc` function should locate the target value in the descendingly sorted list and return its index or -1 if the target is not found.","solution":"def binary_search_desc(arr, target): Performs binary search on a list sorted in non-increasing order. :param arr: A list of integers sorted in non-increasing order. :param target: The integer value to search for in the list. :return: The index of the target value if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: right = mid - 1 else: left = mid + 1 return -1"},{"question":"# Problem Statement In the study of matrix operations, rotation matrices are used to rotate vectors in Cartesian coordinates. The 2D rotation matrix for an angle (theta) radians is given by: [ R(theta) = begin{bmatrix} cos(theta) & -sin(theta) sin(theta) & cos(theta) end{bmatrix} ] # Your Task 1. **Rotate a Vector**: Implement a function that takes a 2D vector and an angle (in radians), applies the rotation matrix for that angle, and returns the new rotated vector. 2. **Verify Orthogonality of Rotation Matrix**: Implement a function that checks if a given 2x2 matrix is a valid rotation matrix. A valid rotation matrix ( R ) should satisfy the following properties: - ( R^T * R = I ) where ( R^T ) is the transpose of ( R ) and ( I ) is the identity matrix. - The absolute determinant of ( R ) is 1. # Instructions 1. **rotate_vector**: * **Input**: `vector` (list of two floats), `angle` (float) - the 2D vector and the angle of rotation in radians. * **Output**: `list` - the rotated vector. * **Constraints**: The vector elements will be real numbers. 2. **check_rotation_matrix**: * **Input**: `matrix` (list of lists) - a 2x2 matrix represented as a list of lists. * **Output**: `bool` - True if the matrix is a valid rotation matrix, and False otherwise. * **Constraints**: The matrix should be of size 2x2. # Example ```python >>> rotate_vector([1, 0], 1.5707963267948966) # rotate by π/2 radians (90 degrees) [0.0, 1.0] >>> rotate_vector([0, 1], -1.5707963267948966) # rotate by -π/2 radians (-90 degrees) [1.0, 0.0] >>> check_rotation_matrix([[0, -1], [1, 0]]) True >>> check_rotation_matrix([[0, -1.1], [1, 0]]) False ``` # Requirements - The solutions should handle edge cases involving invalid inputs. - Performance should be O(1) for both functions. - Adhere to the provided constraints for correctness.","solution":"import math def rotate_vector(vector, angle): Rotates a 2D vector by the given angle in radians. Parameters: vector (list): A list of two floats representing the vector to rotate. angle (float): The angle in radians to rotate the vector. Returns: list: The rotated vector. cos_theta = math.cos(angle) sin_theta = math.sin(angle) x, y = vector x_new = cos_theta * x - sin_theta * y y_new = sin_theta * x + cos_theta * y return [x_new, y_new] def check_rotation_matrix(matrix): Checks if the given 2x2 matrix is a valid rotation matrix. Parameters: matrix (list): A 2D list containing the 2x2 matrix. Returns: bool: True if the matrix is a valid rotation matrix, False otherwise. if len(matrix) != 2 or not all(len(row) == 2 for row in matrix): return False # Calculate the transpose of the matrix transpose = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]] # Calculate the product of matrix and its transpose product = [ [matrix[0][0] * transpose[0][0] + matrix[0][1] * transpose[1][0], matrix[0][0] * transpose[0][1] + matrix[0][1] * transpose[1][1]], [matrix[1][0] * transpose[0][0] + matrix[1][1] * transpose[1][0], matrix[1][0] * transpose[0][1] + matrix[1][1] * transpose[1][1]] ] # Identity matrix identity = [[1, 0], [0, 1]] # Check if product equals the identity matrix is_orthogonal = all(math.isclose(product[row][col], identity[row][col]) for row in range(2) for col in range(2)) # Calculate determinant determinant = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] # Valid rotation matrix if orthogonal and determinant equal to ±1 return is_orthogonal and math.isclose(abs(determinant), 1)"},{"question":"# Question: Inventory Management System You have been tasked with implementing a function that manages inventory for a small store. The store keeps track of items in the inventory by their names and quantities. Your function will receive a list of inventory operations and should return the final state of the inventory after applying all operations. # Function Signature ```python def manage_inventory(operations: List[Tuple[str, str, int]]) -> Dict[str, int]: pass ``` # Input * `operations`: A list of tuples, where each tuple consists of three elements: - The first element is a string indicating the operation, either \'ADD\' or \'REMOVE\'. - The second element is a string representing the item name. - The third element is an integer representing the quantity to add or remove. # Output * Return a dictionary with the final quantities of each item in the inventory after all operations have been applied. # Constraints * The length of `operations` will not exceed 1000. * Quantities will be positive integers. * If a \'REMOVE\' operation would result in the quantity of an item dropping below zero, set the quantity to zero instead. * Assume no two operations for the same item happen at the same time. # Example Example 1 ```python operations = [(\'ADD\', \'apple\', 10), (\'REMOVE\', \'apple\', 3), (\'ADD\', \'banana\', 5)] assert manage_inventory(operations) == {\'apple\': 7, \'banana\': 5} ``` Example 2 ```python operations = [(\'ADD\', \'milk\', 2), (\'REMOVE\', \'milk\', 5), (\'ADD\', \'bread\', 3)] assert manage_inventory(operations) == {\'milk\': 0, \'bread\': 3} ``` # Additional Information You do not need to handle invalid inputs. Assume all operations are valid and operations lists are well-formed.","solution":"from typing import List, Tuple, Dict def manage_inventory(operations: List[Tuple[str, str, int]]) -> Dict[str, int]: inventory = {} for operation, item, quantity in operations: if operation == \'ADD\': if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif operation == \'REMOVE\': if item in inventory: inventory[item] = max(0, inventory[item] - quantity) else: inventory[item] = 0 return inventory"},{"question":"# Programming Question **Scenario** You are tasked with developing a library for handling various currency conversions for an online marketplace. The system should be able to convert between different currencies using predefined exchange rates. **Problem Statement** Implement a function `convert_currency` that converts a known amount from one currency to another using given exchange rates. **Function Signature** ```python def convert_currency(known_amount: float, known_currency: str, target_currency: str, exchange_rates: dict) -> float: pass ``` **Input** - `known_amount` (float): The amount of money in the known currency. - `known_currency` (str): The currency code (e.g., \\"USD\\", \\"EUR\\") of the known amount. - `target_currency` (str): The currency code to convert the known amount into. - `exchange_rates` (dict): A dictionary where keys are tuples representing conversion pairs and values are the corresponding exchange rates. For example, `{(\'USD\', \'EUR\'): 0.85, (\'EUR\', \'USD\'): 1.18}`. **Output** - (float): The converted amount in the target currency. **Constraints** - The `known_currency` and `target_currency` will always be present in the `exchange_rates` dictionary. - The function should handle mixed-case currency inputs (e.g., \\"usd\\" should be treated the same as \\"USD\\"). **Examples** ```python # Example 1 # Convert 100 USD to EUR with given exchange rate exchange_rates = {(\'USD\', \'EUR\'): 0.85, (\'EUR\', \'USD\'): 1.18} print(convert_currency(100, \'usd\', \'eur\', exchange_rates)) # Output: 85.0 # Example 2 # Convert 50 EUR to USD with given exchange rate exchange_rates = {(\'USD\', \'EUR\'): 0.85, (\'EUR\', \'USD\'): 1.18} print(convert_currency(50, \'eur\', \'usd\', exchange_rates)) # Output: 59.0 # Example 3 # Convert 200 GBP to USD with given exchange rate exchange_rates = {(\'GBP\', \'USD\'): 1.39, (\'USD\', \'GBP\'): 0.72} print(convert_currency(200, \'gbp\', \'usd\', exchange_rates)) # Output: 278.0 # Example 4 # Convert 300 JPY to EUR with given exchange rate exchange_rates = {(\'JPY\', \'USD\'): 0.0091, (\'USD\', \'EUR\'): 0.85} print(convert_currency(300, \'jpy\', \'eur\', exchange_rates)) # Output: 2.3175 ``` **Notes** - You may use lowercase for currency codes input, and your function should convert them to uppercase. - Ensure your solution handles cases where the input currency codes are not in the expected case format. For instance, \\"usd\\" should be interpreted as \\"USD\\".","solution":"def convert_currency(known_amount: float, known_currency: str, target_currency: str, exchange_rates: dict) -> float: Converts a known amount from one currency to another using given exchange rates. Parameters: known_amount (float): The amount in the known currency. known_currency (str): The currency code of the known amount. target_currency (str): The currency code to convert the known amount into. exchange_rates (dict): Dictionary with conversion rates. Returns: float: The converted amount in the target currency. known_currency = known_currency.upper() target_currency = target_currency.upper() rate = exchange_rates.get((known_currency, target_currency)) if rate is None: raise ValueError(\\"Conversion rate from {} to {} not found.\\".format(known_currency, target_currency)) return known_amount * rate"},{"question":"# Coding Assessment Question Context You are working with sequences of numbers and have come across a series called ``Triangular Numbers``. A number is said to be triangular if it can form an equilateral triangle. The nth triangular number is given by the formula `T(n) = n*(n+1)/2`. Your task is to determine if a given number is a triangular number and to find the index `n` such that `T(n) = number`, if it exists. Problem Statement Implement the function `is_triangular(n: int) -> Tuple[bool, int]` that determines whether a given number `n` is a triangular number and returns the index `k` such that `T(k) = n`, if it exists. Input * `n`: an integer representing the number to be checked. (1 ≤ `n` ≤ 10^12) Output * Return a tuple `(bool, int)`. The first element is `True` if `n` is a triangular number, otherwise `False`. The second element is the index `k` such that `T(k) = n` if `n` is a triangular number, otherwise it should be `-1`. Example ```python assert is_triangular(10) == (True, 4) assert is_triangular(15) == (True, 5) assert is_triangular(16) == (False, -1) ``` Constraints 1. The number `n` must be an integer. Performance Requirements Your function should efficiently determine whether `n` is a triangular number and find the index `k` within a reasonable time limit for large inputs (up to the order of 10^12). Hints * Utilize the inverse of the triangular number formula to find potential `k`. * Check if the calculated `k` results in an integer to confirm if `n` is a triangular number.","solution":"import math from typing import Tuple def is_triangular(n: int) -> Tuple[bool, int]: Determines if the given number n is a triangular number. Parameters: - n: int, the number to check Returns: - A tuple (bool, int) where the first element is True if n is a triangular number, otherwise False. The second element is the index k such that T(k) = n if it exists, otherwise it is -1. if n <= 0: return (False, -1) # Calculate the potential k using the inverse of the triangular number formula # T(n) = n * (n + 1) // 2 implies n = k * (k + 1) // 2 # Solving the quadratic equation k^2 + k - 2n = 0 gives: # k = (-1 + sqrt(1 + 8n)) / 2 k = (-1 + math.sqrt(1 + 8 * n)) / 2 # Check if k is an integer if k.is_integer(): return (True, int(k)) else: return (False, -1)"},{"question":"# Coding Assessment Question You have been provided with the implementation of the Levenshtein distance, which measures the minimum number of single-character edits required to convert one string into another. To test your understanding of string manipulation and dynamic programming, you are tasked with implementing a custom function that computes the Damerau-Levenshtein distance. # Scenario Your task is to implement an algorithm to compute the Damerau-Levenshtein distance between two strings. This distance metric is like the Levenshtein distance but also considers adjacent transpositions of characters (swaps) as a single edit operation. # Function Definition Implement the function `damerau_levenshtein_distance` that computes this distance between two strings. # Mathematical Definition The Damerau-Levenshtein distance between strings `s` and `t` is defined as the minimum number of operations needed to transform `s` into `t`, where an operation is one of: - Deletion of a character. - Insertion of a character. - Substitution of a character. - Transposition of two adjacent characters. # Function Signature ```python def damerau_levenshtein_distance(s: str, t: str) -> int: pass ``` # Input * `s` (str): The source string. * `t` (str): The target string. # Output * Returns (int): The Damerau-Levenshtein distance between the input strings. # Constraints * Both `s` and `t` will have lengths between 0 and 1000. * The strings will consist of uppercase and lowercase English letters. # Performance Requirements Your implementation must perform efficiently, aiming for a time complexity close to O(N*M), where N is the length of string `s` and M is the length of string `t`. # Examples ```python >>> damerau_levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> damerau_levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> damerau_levenshtein_distance(\\"example\\", \\"samples\\") 3 >>> damerau_levenshtein_distance(\\"book\\", \\"back\\") 2 ```","solution":"def damerau_levenshtein_distance(s: str, t: str) -> int: len_s, len_t = len(s), len(t) dp = [[0] * (len_t + 1) for _ in range(len_s + 1)] for i in range(len_s + 1): for j in range(len_t + 1): if i == 0: dp[i][j] = j # base case: insertions elif j == 0: dp[i][j] = i # base case: deletions else: cost = 0 if s[i - 1] == t[j - 1] else 1 dp[i][j] = min(dp[i - 1][j] + 1, # deletion dp[i][j - 1] + 1, # insertion dp[i - 1][j - 1] + cost) # substitution if i > 1 and j > 1 and s[i - 1] == t[j - 2] and s[i - 2] == t[j - 1]: dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + 1) # transposition return dp[len_s][len_t]"},{"question":"# Duplicate Detection Challenge **Context**: You are building a system to detect duplicate entries in datasets that are dynamically updated. The system needs to identify and report any duplicate records based on specific criteria. **Problem Statement**: Implement a function `has_duplicates` that receives a sequence of records (each record is represented as a tuple) and a key function. The function should return `True` if there are any duplicate records based on the provided key function, and `False` otherwise. **Function Signature**: ```python from collections.abc import Sequence, Callable def has_duplicates(records: Sequence[tuple], key_func: Callable[[tuple], tuple] = lambda x: x) -> bool: Detects duplicates in the given sequence of records based on the provided key function. :param records: the given sequence of records (each record is a tuple). :param key_func: a function that extracts the comparison key from each record. Defaults to identity function. :return: True if there are duplicates based on the key function, otherwise False. ``` **Input**: - `records`: A sequence (list) of tuples where each tuple represents a record. - `key_func`: A function that extracts the comparison key from a record. Defaults to the identity function (tuple itself). **Output**: - A boolean value `True` if there are duplicate records based on the comparison keys, otherwise `False`. **Constraints**: - The sequence `records` can have up to 10^6 records. - Each record is a tuple of elements including strings, integers, or floats. - The key function can extract any subset of the fields from each record. **Examples**: ```python print(has_duplicates([(1, \'a\'), (2, \'b\'), (1, \'a\')])) # Output: True print(has_duplicates([(1, \'a\'), (2, \'b\'), (3, \'c\')])) # Output: False print(has_duplicates([(1, \'a\', 100), (2, \'b\', 200), (3, \'a\', 100)], key_func=lambda x: (x[1], x[2]))) # Output: True print(has_duplicates([(1, \'a\'), (2, \'A\')])) # Output: False print(has_duplicates([(1, 2, 3), (4, 5, 6), (1, 2, 3)], key_func=lambda x: x[:2])) # Output: True print(has_duplicates([])) # Output: False ``` **Key Considerations**: - Ensure the function performs efficiently even for large datasets. - Handle edge cases such as empty records and various types of elements within each record. - The key function allows flexibility in defining what constitutes a duplicate.","solution":"from collections.abc import Sequence, Callable def has_duplicates(records: Sequence[tuple], key_func: Callable[[tuple], tuple] = lambda x: x) -> bool: Detects duplicates in the given sequence of records based on the provided key function. :param records: the given sequence of records (each record is a tuple). :param key_func: a function that extracts the comparison key from each record. Defaults to identity function. :return: True if there are duplicates based on the key function, otherwise False. seen_keys = set() for record in records: key = key_func(record) if key in seen_keys: return True seen_keys.add(key) return False"},{"question":"# Coding Challenge # Problem Statement Given a list of integers, your task is to find the length of the longest subsequence that can be derived from the list such that the subsequence is strictly increasing. # Input - A list of integers `arr`, where 1 ≤ len(arr) ≤ 1000 # Output - An integer representing the length of the longest increasing subsequence. # Example Input ``` arr = [10, 9, 2, 5, 3, 7, 101, 18] ``` Output ``` 4 ``` # Explanation For the given example, the longest increasing subsequence is [2, 3, 7, 101], which has a length of 4. # Function Signature ```python def longest_increasing_subsequence(arr: list) -> int: pass ``` # Constraints - 1 ≤ len(arr) ≤ 1000 - All list values are integers between -10^4 and 10^4. # Scenario You are asked to examine an integer array and derive a method that efficiently finds the length of the longest subsequence with strictly increasing values. This problem assesses your ability to implement dynamic programming or other efficient algorithms to handle moderately large datasets within acceptable performance limits.","solution":"def longest_increasing_subsequence(arr: list) -> int: if not arr: return 0 # Create an array to store the longest increasing subsequence length at each index lis = [1] * len(arr) # Iterate over each element of the array for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest increasing subsequence is the maximum value in the lis array return max(lis)"},{"question":"# Problem Statement You need to implement a function that identifies all the unique anagrams of a given string within a list of words. # Requirements Function Signature ```python def find_anagrams(source: str, words: List[str]) -> List[str]: ``` Functionality Description - The function should accept two parameters: * `source` (str): A string for which anagrams need to be identified. * `words` (List[str]): A list of words to be checked for anagrams of `source`. - The function should return a list of all unique anagrams of the `source` string found in the `words` list. # Constraints 1. The `source` must be a non-empty string composed of lowercase letters only. 2. The `words` list must contain strings composed of lowercase letters only. 3. Each word in the `words` list must be of the same length as the `source` string. 4. If no anagrams are found, the function should return an empty list. # Error Handling 1. Raise a `ValueError` if `source` is not a string. 2. Raise a `ValueError` if `words` is not a list of strings or contains non-string elements. 3. The lengths of `source` and the words in `words` must match; otherwise, these words should be ignored. # Performance Requirements - Implement the function such that it operates efficiently, prioritizing clarity and performance. It should ideally operate within O(n * m log m) time complexity, where n is the number of words and m is the length of each word. # Example Usage ```python >>> find_anagrams(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"]) [\'enlist\', \'inlets\'] >>> find_anagrams(\\"abc\\", [\\"bca\\", \\"acb\\", \\"bac\\", \\"cab\\", \\"abc\\"]) [\'bca\', \'acb\', \'bac\', \'cab\', \'abc\'] >>> find_anagrams(\\"abc\\", [\\"def\\", \\"ghi\\", \\"jkl\\"]) [] ``` In addition, ensure that the function properly raises exceptions on incorrect argument types: ```python >>> find_anagrams(123, [\\"bca\\", \\"acb\\"]) Traceback (most recent call last): ... ValueError: Expected string as source, found <class \'int\'> >>> find_anagrams(\\"abc\\", \\"bca\\") Traceback (most recent call last): ... ValueError: Expected list as words parameter, found <class \'str\'> >>> find_anagrams(\\"abc\\", [\\"bca\\", 123]) Traceback (most recent call last): ... ValueError: Expected list of strings, found non-string element in list ``` Make sure all these aspects are handled and the code functions correctly under the specified constraints.","solution":"from typing import List def find_anagrams(source: str, words: List[str]) -> List[str]: Identifies all the unique anagrams of a given string within a list of words. Parameters: source (str): A string for which anagrams need to be identified. words (List[str]): A list of words to be checked for anagrams of source. Returns: List[str]: A list of unique anagrams of the source found in the words list. if not isinstance(source, str): raise ValueError(f\\"Expected string as source, found {type(source).__name__}\\") if not isinstance(words, list): raise ValueError(f\\"Expected list as words parameter, found {type(words).__name__}\\") for word in words: if not isinstance(word, str): raise ValueError(f\\"Expected list of strings, found non-string element in list\\") source_sorted = sorted(source) anagrams = [word for word in words if sorted(word) == source_sorted] return anagrams"},{"question":"# Problem: Implement Secure Password Validation You need to create a function that validates a password based on several security rules. The function will check if the password adheres to the specified constraints and return an appropriate response. Function Specification: - **Function Name**: `validate_password` - **Input**: - `password`: A string representing the password to be validated. - **Output**: - A dictionary with two keys: `is_valid` and `errors`. - `is_valid`: A boolean value. `True` if the password is valid, `False` otherwise. - `errors`: A list of strings, each describing a rule that the password violated. If the password is valid, this list should be empty. Constraints: 1. The password must be at least 8 characters long. 2. The password must contain at least one uppercase letter (A-Z). 3. The password must contain at least one lowercase letter (a-z). 4. The password must contain at least one digit (0-9). 5. The password must contain at least one special character (e.g., @, #, , &, *, etc.). 6. The password must not contain any whitespace characters. # Task Description: Implement the function `validate_password` to enforce the listed security rules and return the validation results accordingly. Example: ```python def validate_password(password: str) -> dict: # Implementation here ``` Examples of how the function should behave: ```python assert validate_password(\\"Password123!\\") == {\'is_valid\': True, \'errors\': []} assert validate_password(\\"password\\") == {\'is_valid\': False, \'errors\': [ \'Password must contain at least one uppercase letter.\', \'Password must contain at least one digit.\', \'Password must contain at least one special character.\' ]} assert validate_password(\\" \\") == {\'is_valid\': False, \'errors\': [ \'Password must be at least 8 characters long.\', \'Password must contain at least one uppercase letter.\', \'Password must contain at least one lowercase letter.\', \'Password must contain at least one digit.\', \'Password must contain at least one special character.\', \'Password must not contain whitespace characters.\' ]} assert validate_password(\\"P@ssw0rd!\\") == {\'is_valid\': True, \'errors\': []} ``` # Requirements - Implement the function following the specifications and constraints. - Ensure you thoroughly test the function with various cases, covering all rules and constraints. - Optimize the function to properly handle both valid and invalid passwords efficiently. Good luck and happy coding!","solution":"import re def validate_password(password: str) -> dict: errors = [] # Validate length if len(password) < 8: errors.append(\'Password must be at least 8 characters long.\') # Validate uppercase letter if not re.search(r\'[A-Z]\', password): errors.append(\'Password must contain at least one uppercase letter.\') # Validate lowercase letter if not re.search(r\'[a-z]\', password): errors.append(\'Password must contain at least one lowercase letter.\') # Validate digit if not re.search(r\'d\', password): errors.append(\'Password must contain at least one digit.\') # Validate special character if not re.search(r\'[!@#%^&*(),.?\\":{}|<>]\', password): errors.append(\'Password must contain at least one special character.\') # Validate whitespace if re.search(r\'s\', password): errors.append(\'Password must not contain whitespace characters.\') is_valid = len(errors) == 0 return {\'is_valid\': is_valid, \'errors\': errors}"},{"question":"**Task**: Implement a function `convert_to_rpn(expression: str) -> str` that takes a mathematical expression in infix notation (what we traditionally use) and converts it to postfix notation (Reverse Polish Notation). Reverse Polish Notation has the advantage of eliminating the need for parentheses to signify operation precedence. **Requirements**: - Implement **Dijkstra\'s Shunting Yard algorithm** to perform the conversion. - Handle standard arithmetic operators: `+`, `-`, `*`, `/`, and parentheses `(`, `)`. - Ensure the final output expression is correctly formatted with space-separated tokens. **Input/Output Specification**: - **Input**: `expression` - A string containing the infix expression (e.g., \\"3 + 4 * 2 / ( 1 - 5 )\\") - **Output**: String containing the expression in postfix notation (e.g., \\"3 4 2 * 1 5 - / +\\"). - **Constraints**: - The input expression is a valid arithmetic expression. - The operators and operands are space-separated. - Handle both unary and binary operators appropriately, assuming unary operators are represented as `-3` or `+7`. **Performance**: Ensure the algorithm processes the input in O(n) time complexity, where n is the length of the input expression string. **Scenario**: Given an infix expression, you need to: - Parse and determine the precedence of operators. - Utilize a stack data structure to hold operators and ensure correct order. - Output the expression in postfix notation with the appropriate order of operations respected. **Edge Cases**: - Expressions with nested parentheses. - Handling of operations involving negative numbers and unary operators. Implement and thoroughly test the `convert_to_rpn` function to handle various scenarios and edge cases.","solution":"def convert_to_rpn(expression: str) -> str: Convert an infix expression to postfix (Reverse Polish Notation) using Dijkstra\'s Shunting Yard algorithm. # Precedence and associativity rules precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} left_associative = {\'+\': True, \'-\': True, \'*\': True, \'/\': True} output = [] operators = [] def is_operator(token): return token in precedence def is_operand(token): return token.isdigit() or (token.startswith(\'-\') and token[1:].isdigit()) tokens = expression.split() for token in tokens: if is_operand(token): output.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': output.append(operators.pop()) operators.pop() # Remove the \'(\' from stack elif is_operator(token): while (operators and operators[-1] != \'(\' and (precedence[operators[-1]] > precedence[token] or (precedence[operators[-1]] == precedence[token] and left_associative[token]))): output.append(operators.pop()) operators.append(token) while operators: output.append(operators.pop()) return \' \'.join(output)"},{"question":"# Question You are given the task of determining the longest sequence of zeros contained in a binary string. The sequence must be made up entirely of zeroes and can be interrupted by ones. Task Write a function named `longest_zero_sequence(binary_str: str) -> int` that finds the length of the longest contiguous sequence of zeros in the given binary string. Input - `binary_str` (str): A string consisting of only \'0\' and \'1\' characters. Output - (int): The length of the longest contiguous sequence of zeros. Constraints - The input string will be at least one character long. # Example Here is a sample input and the expected result: ``` longest_zero_sequence(\'110001000010011000\') => 4 ```","solution":"def longest_zero_sequence(binary_str: str) -> int: Returns the length of the longest contiguous sequence of zeros in the given binary string. # Split the string by \'1\' and calculate the length of each part zero_sequences = binary_str.split(\'1\') # Find the longest sequence by taking the max length longest_sequence = max(len(seq) for seq in zero_sequences) return longest_sequence"},{"question":"# Problem Statement You are tasked with implementing a utility function that calculates the day of the week for a given date. This problem has a historical significance, as it aids in calendar-related computations in various applications like scheduling, finance, and astronomy. # Function Definition 1. **day_of_the_week** ```python def day_of_the_week(year: int, month: int, day: int) -> str | ValueError: Input Parameters: ----------------- year: 4-digit year (1000 <= year <= 9999) month: Month of the year (1 <= month <= 12) day: Day of the month (1 <= day <= 31) Returns: -------- The day of the week for the given date as a string. The value should be one of the following: [\\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\"] Raises a ValueError if the date is invalid. ``` # Constraints * The input date must be valid according to the Gregorian calendar. * The year should be a 4-digit year between 1000 and 9999 inclusive. * The month should be between 1 and 12 inclusive. * The day should be between 1 and 31 inclusive, and should be valid as per the month and year (e.g., February should handle leap years correctly). # Example Scenarios: **Example 1**: ```python # Day of the week for the date 2022-10-22 day_of_the_week(2022, 10, 22) # Expected: \\"Saturday\\" ``` **Example 2**: ```python # Day of the week for the date 2000-02-29 (leap year) day_of_the_week(2000, 2, 29) # Expected: \\"Tuesday\\" ``` **Example 3**: ```python # Invalid date will result in ValueError day_of_the_week(2021, 2, 29) # Expected: ValueError(\'Input Error: Invalid date.\') ``` # Hints * Consider using a known algorithm such as Zeller\'s Congruence or similar to calculate the day of the week. * Validate the input date before attempting to compute the day of the week.","solution":"import datetime def day_of_the_week(year: int, month: int, day: int) -> str: Input Parameters: ----------------- year: 4-digit year (1000 <= year <= 9999) month: Month of the year (1 <= month <= 12) day: Day of the month (1 <= day <= 31) Returns: -------- The day of the week for the given date as a string. The value should be one of the following: [\\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\"] Raises a ValueError if the date is invalid. try: date = datetime.date(year, month, day) except ValueError: raise ValueError(\\"Input Error: Invalid date.\\") days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] return days_of_week[date.weekday()]"},{"question":"# Problem Statement Create a class to represent a sparse vector, which is a vector that contains mostly zero values. The class should provide methods for efficiently adding, subtracting, and calculating the dot product of two sparse vectors. # Requirements 1. **Class Definition**: Create a class called `SparseVector`. 2. **Methods**: - `__init__(self, nums: list[int])`: Initializes the sparse vector from a list of integers. - `add(self, vec: SparseVector) -> SparseVector`: Returns a new sparse vector that is the sum of two sparse vectors. - `subtract(self, vec: SparseVector) -> SparseVector`: Returns a new sparse vector that is the difference of two sparse vectors. - `dot_product(self, vec: SparseVector) -> int`: Returns the dot product of two sparse vectors. - `__repr__(self) -> str`: Represents the sparse vector as a string. 3. **Representation**: Store only the non-zero elements of the vector to optimize space. 4. **Error Handling**: Ensure that operations are only performed on vectors of the same length. 5. **Performance Requirements**: * Ensure that addition, subtraction, and dot product operations are efficient and leverage the sparse nature of the vectors. * Ensure the vector length is not excessively large, specifically the maximum length is 10^5. # Constraints - The vectors will only contain integer values. - The input list `nums` can have lengths up to 10^5 with most of the values being zero. - The input vector for operations will be properly formatted and have the same length as the original vector. # Input/Output Structure * **Input**: N/A (The input parameters will be method parameters) * **Output**: The methods will return new instances of `SparseVector` for `add` and `subtract`, an integer for `dot_product`, and a string for `__repr__`. # Example ```python # Example Usage vec1 = SparseVector([1, 0, 0, 2, 3]) vec2 = SparseVector([0, 3, 0, 4, 0]) print(vec1) # Output: {0: 1, 3: 2, 4: 3} print(vec2) # Output: {1: 3, 3: 4} sum_vec = vec1.add(vec2) print(sum_vec) # Output: {0: 1, 1: 3, 3: 6, 4: 3} diff_vec = vec1.subtract(vec2) print(diff_vec) # Output: {0: 1, 1: -3, 3: -2, 4: 3} dot_prod = vec1.dot_product(vec2) print(dot_prod) # Output: 8 ``` This question tests the candidate\'s ability to design a class and data structure to efficiently handle operations specific to sparse data, focusing on optimization and correctness.","solution":"class SparseVector: def __init__(self, nums: list[int]): self.sparse_representation = {i: num for i, num in enumerate(nums) if num != 0} self.length = len(nums) def add(self, vec: \'SparseVector\') -> \'SparseVector\': if self.length != vec.length: raise ValueError(\\"Vectors must be of the same length\\") new_nums = [0] * self.length for key, value in self.sparse_representation.items(): new_nums[key] = value for key, value in vec.sparse_representation.items(): new_nums[key] += value return SparseVector(new_nums) def subtract(self, vec: \'SparseVector\') -> \'SparseVector\': if self.length != vec.length: raise ValueError(\\"Vectors must be of the same length\\") new_nums = [0] * self.length for key, value in self.sparse_representation.items(): new_nums[key] = value for key, value in vec.sparse_representation.items(): new_nums[key] -= value return SparseVector(new_nums) def dot_product(self, vec: \'SparseVector\') -> int: if self.length != vec.length: raise ValueError(\\"Vectors must be of the same length\\") result = 0 for key, value in self.sparse_representation.items(): if key in vec.sparse_representation: result += value * vec.sparse_representation[key] return result def __repr__(self) -> str: return str(self.sparse_representation)"},{"question":"# Rotate Matrix You are given a square matrix \'mat\' representing a 2D grid of integers. The task is to rotate the matrix by 90 degrees in a clockwise direction and return the resulting matrix. # Input 1. **mat**: A 2D list representing the square matrix where each element is an integer. # Output * Return a 2D list representing the rotated matrix. # Constraints * The dimensions of the matrix will be such that both width and height are between 1 and 1000. # Performance Requirements * Aim for an efficient implementation with minimal computational overhead. # Example ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # After rotating the matrix by 90 degrees clockwise, the output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Implementation Hints * Consider the mathematical relationship between the original and the rotated indices. * Make use of list comprehensions for concise code. * Ensure your function handles various matrix sizes efficiently. Write a function `rotate_matrix(mat)` that takes a 2D list `mat` and returns the matrix rotated by 90 degrees clockwise.","solution":"def rotate_matrix(mat): Rotates the input square matrix by 90 degrees clockwise. Args: mat (list of list of int): The 2D square matrix to be rotated. Returns: list of list of int: The rotated matrix. n = len(mat) rotated_mat = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_mat[j][n - 1 - i] = mat[i][j] return rotated_mat"},{"question":"# Question: Implement a library book borrowing system interface that keeps track of borrowed and available books. Your task is to create a `Library` class that manages the borrowing and returning of books based on user request. **Class Signature**: ```python class Library: def __init__(self, books: List[str]): # implement the constructor def borrow_book(self, book_name: str) -> bool: # implement the method def return_book(self, book_name: str) -> bool: # implement the method def available_books(self) -> List[str]: # implement the method ``` # Requirements: 1. **Class Initialization**: - The class is initialized with a list of book names available in the library. 2. **Methods**: - `borrow_book(book_name: str) -> bool`: - Borrows a book by its name. - Returns `True` if the book is successfully borrowed (i.e., exists in the available list and is not already borrowed), otherwise returns `False`. - `return_book(book_name: str) -> bool`: - Returns a borrowed book to the library. - Returns `True` if the book is successfully returned (i.e., was borrowed), otherwise returns `False`. - `available_books() -> List[str]`: - Returns a list of available books that can be borrowed. # Constraints: - The list of initial books will contain `1` to `10^3` books. - Each book name is a non-empty string of at most `100` characters. - The borrow and return operations should be optimized for quick lookups and updates. # Example Usage: ```python library = Library([\\"The Hobbit\\", \\"1984\\", \\"Harry Potter\\", \\"War and Peace\\"]) # Borrowing a book print(library.borrow_book(\\"1984\\")) # Output: True print(library.borrow_book(\\"The Hobbit\\")) # Output: True print(library.borrow_book(\\"The Hobbit\\")) # Output: False (already borrowed) # Returning a book print(library.return_book(\\"1984\\")) # Output: True print(library.return_book(\\"1984\\")) # Output: False (was not borrowed currently) # Checking available books print(library.available_books()) # Output: [\'Harry Potter\', \'War and Peace\'] ``` # Function Behavior: 1. On initialization, the given books are marked as available. 2. Borrowing a book marks it as borrowed if it is available and removes it from the available list. 3. Returning a book adds it back to the available list if it was borrowed. 4. You should maintain an efficient way to keep track of borrowed and available books for fast operations. # Additional Notes: - Ensure to handle edge cases like borrowing a book not in the initially available list gracefully. - Consider maintaining data structures that provide efficient lookup, addition, and removal for the available and borrowed books. # Hints: * You may use a set for tracking borrowed books for optimal performance in membership check operations. * Ensure the list of available books is kept up-to-date after each operation to reflect the state of the library.","solution":"from typing import List, Set class Library: def __init__(self, books: List[str]): self.all_books: Set[str] = set(books) self.available: Set[str] = set(books) self.borrowed: Set[str] = set() def borrow_book(self, book_name: str) -> bool: if book_name in self.available: self.available.remove(book_name) self.borrowed.add(book_name) return True return False def return_book(self, book_name: str) -> bool: if book_name in self.borrowed: self.borrowed.remove(book_name) self.available.add(book_name) return True return False def available_books(self) -> List[str]: return list(self.available)"},{"question":"# Problem: First Missing Positive Integer **Objective**: Write a function `first_missing_positive` that takes a list of integers and returns the smallest positive integer that is missing from the list. The solution should have a linear runtime complexity. **Constraints**: - The input list will contain at most (10^6) elements. - Each element of the list will be an integer within the range ([-10^6, 10^6]). **Function Signature**: ```python def first_missing_positive(nums: List[int]) -> int: pass ``` **Input**: - A list of integers `nums` (can be empty). **Output**: - An integer representing the smallest positive integer missing from the list. **Examples**: 1. Given the list [3, 4, -1, 1], the function should return 2. 2. Given the list [1, 2, 0], the function should return 3. 3. Given the list [7, 8, 9, 11, 12], the function should return 1. # Hints: - Try placing each positive integer `x` from the list in the position `x-1` if it is within the range `[1, len(nums)]`. - After rearranging the list, iterate over the list to find the first missing positive integer. - Handle edge cases such as empty lists efficiently to ensure correct results.","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the list. n = len(nums) # Place each number in its right place, e.g., 5 in position 4 (0-based index) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # The first place where its number is not right, return the place + 1 for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Scenario You are given a stream of incoming integers. Your task is to continuously maintain and output the median of the numbers seen so far, efficiently updating with each new number added to the stream. # Task Description Implement a `MedianFinder` class that uses two heaps to keep track of the current median. The `MedianFinder` class should support the following operations: 1. Add a number to the data stream. 2. Get the current median of the numbers seen so far. # Input and Output Formats `MedianFinder` class should have the following methods: - `add_num(num: int)`: Adds the integer `num` to the data stream. - `find_median() -> float`: Returns the median of the current numbers in the data stream. If the number of elements is even, it should return the average of the two middle elements. # Constraints - The integers in the data stream range from (-10^6) to (10^6). - The number of integers (`n`) will not exceed (10^5). - The detailed ordering and constraints are such that the solution must handle potentially large numbers efficiently and in real-time. # Example ```python finder = MedianFinder() finder.add_num(1) assert finder.find_median() == 1.0 finder.add_num(2) assert finder.find_median() == 1.5 finder.add_num(3) assert finder.find_median() == 2.0 finder.add_num(4) assert finder.find_median() == 2.5 finder.add_num(5) assert finder.find_median() == 3.0 finder.add_num(6) assert finder.find_median() == 3.5 ``` # Requirements Ensure that your implementation is efficient under the constraint of continuous input.","solution":"import heapq class MedianFinder: def __init__(self): self.min_heap = [] # will contain the larger half of the numbers self.max_heap = [] # will contain the smaller half of the numbers def add_num(self, num: int): if len(self.max_heap) == 0 or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) # Balance the heaps such that the difference in length is not more than 1 if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Question You are given a string that contains a sentence with words separated by spaces. Some words might be misspelled, but you have access to a dictionary of correctly spelled words to validate against. Your task is to implement the `spell_correct` function that suggests corrections for each misspelled word by finding the closest correctly spelled word from the dictionary based on the minimum edit distance. # Function Signature ```python def spell_correct(sentence: str, dictionary: list) -> str: ``` # Input * A string `sentence` where `1 <= len(sentence) <= 10^4`. The sentence is a single line containing multiple words separated by spaces. * A list of strings `dictionary` containing correctly spelled words. Each word in the dictionary will have `1 <= len(word) <= 100`. # Output * The function should return the corrected sentence with every misspelled word replaced by the closest word from the dictionary. # Constraints * The text contains only lowercase letters and spaces. * The dictionary is a list of unique words with only lowercase letters. # Requirements * Use dynamic programming to compute the minimum edit distance (Levenshtein distance) between words. * Ensure that the function handles large input efficiently. # Examples ```python # Example 1 sentence = \\"helo theer word\\" dictionary = [\\"hello\\", \\"there\\", \\"world\\"] print(spell_correct(sentence, dictionary)) # Output: \\"hello there world\\" # Example 2 sentence = \\"hapy coding\\" dictionary = [\\"happy\\", \\"coding\\", \\"happy coding\\", \\"enjoy\\"] print(spell_correct(sentence, dictionary)) # Output: \\"happy coding\\" # Example 3 sentence = \\"teh quikc borwn foz\\" dictionary = [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\"] print(spell_correct(sentence, dictionary)) # Output: \\"the quick brown fox\\" ``` # Explanation * In **Example 1**, \\"helo\\" is closest to \\"hello\\", \\"theer\\" is closest to \\"there\\", and \\"word\\" is closest to \\"world\\". Hence, the corrected sentence is \\"hello there world\\". * In **Example 2**, \\"hapy\\" is corrected to \\"happy\\" and \\"coding\\" is already correctly spelled. Therefore, the sentence remains \\"happy coding\\". * In **Example 3**, a similar logic follows to correct the misspelled words to form the sentence \\"the quick brown fox\\". # Additional Information * Consider edge cases such as sentences with all correctly spelled words, sentences with all words misspelled, and sentences with mixed cases. * Aim for efficiency, especially for longer sentences and larger dictionaries.","solution":"def spell_correct(sentence: str, dictionary: list) -> str: def edit_distance(word1, word2): m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n] words = sentence.split() corrected_words = [] for word in words: min_distance = float(\'inf\') closest_word = word for dict_word in dictionary: distance = edit_distance(word, dict_word) if distance < min_distance: min_distance = distance closest_word = dict_word corrected_words.append(closest_word) return \' \'.join(corrected_words)"},{"question":"String Permutations and Unique Substrings Objective Write a Python function to find the count of unique substrings of a given input string\'s permutations of length `n`. # Detailed Description **Task**: Create a function `unique_substrings_count` that generates all permutations of length `n` from the given input string, identifies all possible substrings of these permutations, and counts how many of these substrings are unique. Constraints: * The input string will consist of lowercase English letters only. * The length `n` will always be less than or equal to the length of the input string. * Consider all possible substrings of length `n` derived from any permutation of the input string. * Aim for an efficient solution that handles the factorial complexity of permutations. Function Signature: ```python def unique_substrings_count(s: str, n: int) -> int: pass ``` # Input: * `s` - A string of lowercase English letters. (1 <= len(s) <= 10) * `n` - An integer representing the length of the substrings to be considered. (1 <= n <= len(s)) # Output: * Integer representing the count of unique substrings of length `n` from all permutations of the input string. # Example Usage: ```python print(unique_substrings_count(\\"abc\\", 2)) # Expected output: 6 # Explanation: The permutations of \\"abc\\" are [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]. # Unique substrings of length 2 are: [\\"ab\\", \\"bc\\", \\"ca\\", \\"ac\\", \\"cb\\", \\"ba\\"]. # Total unique substrings = 6 print(unique_substrings_count(\\"aab\\", 2)) # Expected output: 3 # Explanation: The permutations of \\"aab\\" are [\\"aab\\", \\"aba\\", \\"baa\\"]. # Unique substrings of length 2 are: [\\"aa\\", \\"ab\\", \\"ba\\"]. # Total unique substrings = 3 ``` # Hints: * Utilize itertools.permutations to generate all permutations of the input string. * Use set data structure to efficiently track and count unique substrings. * Consider optimizing the solution for performance, handling the combinatorial explosion gracefully while utilizing efficient string manipulation and set operations.","solution":"from itertools import permutations def unique_substrings_count(s: str, n: int) -> int: Given a string s and an integer n, return the count of unique substrings of length n from the permutations of the string s. perm_set = set(\'\'.join(p) for p in permutations(s)) unique_substrings = set() for perm in perm_set: for i in range(len(perm) - n + 1): unique_substrings.add(perm[i:i+n]) return len(unique_substrings)"},{"question":"# Question: Implement Advanced Trie with Prefix Count You are tasked with implementing an advanced trie (prefix tree) that supports the following features: 1. **Insertion**: Add a word to the trie. 2. **Search**: Check if a word exists in the trie. 3. **Prefix Count**: Retrieve the number of words in the trie that start with a given prefix. 4. **Word Deletion**: Remove a word from the trie. Function Specifications: 1. **Insert**: * Function Name: `insert` * Input: A string `word` to be added to the trie. * Output: None. 2. **Search**: * Function Name: `search` * Input: A string `word` to be searched in the trie. * Output: Boolean value indicating whether the word exists in the trie. 3. **Prefix Count**: * Function Name: `count_words_starting_with` * Input: A string `prefix`. * Output: An integer representing the number of words that start with the given prefix. 4. **Word Deletion**: * Function Name: `delete` * Input: A string `word` to be deleted from the trie. * Output: None. You are required to implement these methods in a `Trie` class. The provided class should efficiently support all operations maintaining a compact and clear structure. Constraints: - All input words will contain only lowercase English letters. - Words are case-insensitive. - Ensure that all methods are optimized for performance and pass the provided test cases. Example Usage: ```python # Initialize trie trie = Trie() # Insert elements trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") # Search word print(trie.search(\\"apple\\")) # Expected Output: True print(trie.search(\\"app\\")) # Expected Output: True print(trie.search(\\"banana\\")) # Expected Output: True print(trie.search(\\"ban\\")) # Expected Output: False # Prefix Count print(trie.count_words_starting_with(\\"ap\\")) # Expected Output: 3 (apple, app, apricot) print(trie.count_words_starting_with(\\"ban\\")) # Expected Output: 1 (banana) # Delete word trie.delete(\\"app\\") print(trie.search(\\"app\\")) # Expected Output: False print(trie.count_words_starting_with(\\"ap\\")) # Expected Output: 2 (apple, apricot) ``` Implement the advanced trie structure and ensure that all operations are efficient and conform to the provided specifications.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.prefix_count = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.prefix_count += 1 current.is_end_of_word = True def search(self, word): current = self.root for char in word: if char not in current.children: return False current = current.children[char] return current.is_end_of_word def count_words_starting_with(self, prefix): current = self.root for char in prefix: if char not in current.children: return 0 current = current.children[char] return current.prefix_count def delete(self, word): def _delete(current, word, depth): if depth == len(word): if not current.is_end_of_word: return False current.is_end_of_word = False return len(current.children) == 0 char = word[depth] if char not in current.children: return False can_delete_child = _delete(current.children[char], word, depth + 1) if can_delete_child: del current.children[char] else: current.children[char].prefix_count -= 1 return not current.is_end_of_word and len(current.children) == 0 _delete(self.root, word, 0)"},{"question":"# Problem Statement You need to develop a solution for scheduling tasks based on their dependencies. This task assesses your understanding of graph traversal, topological sorting, and handling constraints within a directed acyclic graph (DAG). Function Specification Implement a function `schedule_tasks` with the following signature: ```python from typing import List, Tuple def schedule_tasks(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: Schedules tasks based on their dependencies using topological sorting. Args: num_tasks: Number of tasks to schedule. dependencies: A list of tuples where each tuple (a, b) represents that task `a` must be completed before task `b`. Returns: A list of task indices in the order they should be completed. ``` Parameters - **num_tasks**: An integer `t` where `0 <= t <= 10^5` representing the number of tasks to be scheduled. - **dependencies**: A list of tuples where each tuple `(a, b)` represents a dependency indicating task `a` must be completed before task `b`. Each task is represented by an integer `0 <= a, b < t`. Returns - A list of integers representing the order in which tasks can be completed respecting the given dependencies. If there are multiple valid answers, return any. If the tasks cannot be scheduled due to a circular dependency, return an empty list. Constraints - Ensure the solution handles cases where `num_tasks` is `0`. - Detect and handle circular dependencies appropriately. # Example ```python tasks = 4 deps = [(1, 0), (2, 0), (3, 1), (3, 2)] result = schedule_tasks(tasks, deps) print(result) ``` This could output: ``` [3, 1, 2, 0] ``` Or any other valid topological sort such as: ``` [3, 2, 1, 0] ``` In case of a circular dependency: ```python tasks = 4 deps = [(1, 0), (0, 1)] result = schedule_tasks(tasks, deps) print(result) ``` This would output: ``` [] ```","solution":"from typing import List, Tuple from collections import defaultdict, deque def schedule_tasks(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: # If no tasks, return an empty list if num_tasks == 0: return [] # Create a graph representation graph = defaultdict(list) in_degree = [0] * num_tasks # Build the graph and track in-degrees for prereq, task in dependencies: graph[prereq].append(task) in_degree[task] += 1 # Find all starting points (tasks with no prerequisites) queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) sorted_order = [] while queue: current = queue.popleft() sorted_order.append(current) # Process and reduce in-degrees of the neighboring tasks for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we were able to process all tasks, if not, it\'s a circular dependency if len(sorted_order) == num_tasks: return sorted_order else: return []"},{"question":"# Transaction History Summarizer You are given the implementation of a `Transaction` class representing individual financial transactions. Your task is to implement a function that summarizes the transaction history for a given list of transactions. The summary should include the total number of transactions, the total amount, and the number of transactions grouped by type. # Requirements 1. **Function**: `summarize_transactions(transactions: List[Transaction]) -> Dict[str, Any]` 2. **Inputs**: - `transactions` - A list of `Transaction` objects. Each `Transaction` object has the following attributes: - `id` (int): A unique identifier for the transaction. - `amount` (float): The amount of money involved in the transaction. - `type` (str): The type of the transaction (e.g., \'deposit\', \'withdrawal\'). 3. **Output**: - A dictionary summarizing the transactions with the following keys: - `total_transactions` (int): The total number of transactions. - `total_amount` (float): The sum of all transaction amounts. - `transaction_types` (Dict[str, int]): A dictionary where each key is a transaction type, and its value is the number of transactions of that type. 4. **Constraints**: - The `amount` for any transaction is a non-negative float. - The transaction `type` is a non-empty string. # Examples ```python class Transaction: def __init__(self, tid, amt, ttype): self.id = tid self.amount = amt self.type = ttype # Example transaction list trans_list = [ Transaction(1, 100.0, \'deposit\'), Transaction(2, 50.0, \'withdrawal\'), Transaction(3, 200.0, \'deposit\'), ] assert summarize_transactions(trans_list) == { \'total_transactions\': 3, \'total_amount\': 350.0, \'transaction_types\': {\'deposit\': 2, \'withdrawal\': 1} } # Empty transaction list assert summarize_transactions([]) == { \'total_transactions\': 0, \'total_amount\': 0.0, \'transaction_types\': {} } ``` # Notes - You should handle edge cases such as an empty list of transactions. - Ensure that the returned dictionary includes all keys even if some values are zero or empty. - The `Transaction` class is given and does not need to be implemented by you. The focus is on `summarize_transactions` function.","solution":"from typing import List, Dict, Any class Transaction: def __init__(self, tid, amt, ttype): self.id = tid self.amount = amt self.type = ttype def summarize_transactions(transactions: List[Transaction]) -> Dict[str, Any]: summary = { \'total_transactions\': 0, \'total_amount\': 0.0, \'transaction_types\': {} } for transaction in transactions: summary[\'total_transactions\'] += 1 summary[\'total_amount\'] += transaction.amount if transaction.type in summary[\'transaction_types\']: summary[\'transaction_types\'][transaction.type] += 1 else: summary[\'transaction_types\'][transaction.type] = 1 return summary"},{"question":"# Task: You are tasked with creating a class `IntervalTree` that supports efficient querying for finding all intervals that overlap with a given interval. This class should utilize an interval tree data structure, a fundamentally important structure in computational geometry and various real-time systems. # Requirements: - Implement the necessary methods to support inserting intervals, deleting intervals, and querying for overlapping intervals. - Ensure the interval tree maintains efficiency in both time and space complexity. # Detailed Function Requirements: 1. **`insert(interval: tuple) -> None`**: Inserts an interval into the interval tree. * **Input**: `interval` - a tuple of two integers representing the start and end points of the interval. * **Output**: None. * **Constraints**: The start point must be less than the end point. 2. **`delete(interval: tuple) -> None`**: Deletes an interval from the interval tree. * **Input**: `interval` - a tuple of two integers representing the start and end points of the interval. * **Output**: None. * **Constraints**: If the interval does not exist in the tree, no changes should be made. 3. **`query(interval: tuple) -> list`**: Returns a list of all intervals in the tree that overlap with the given interval. * **Input**: `interval` - a tuple of two integers representing the start and end points of the interval. * **Output**: A list of tuples, each representing an interval that overlaps with the given interval. * **Constraints**: The start point must be less than the end point. # Constraints: - Intervals are represented as tuples, where the first element is the start point and the second is the end point. - Efficient insertion, deletion, and querying operations are required, typically in logarithmic time complexity. - Consider edge cases such as intervals that overlap at boundary points or intervals that do not overlap at all. # Example Usage: ```python tree = IntervalTree() tree.insert((5, 10)) tree.insert((15, 20)) print(tree.query((14, 16))) # Output: [(15, 20)] print(tree.query((5, 10))) # Output: [(5, 10)] tree.insert((8, 18)) print(tree.query((6, 9))) # Output: [(5, 10), (8, 18)] tree.delete((8, 18)) print(tree.query((6, 9))) # Output: [(5, 10)] ``` # Note: Your implementation should use an interval tree to ensure efficient querying of overlapping intervals, adhering to principles of data structures and algorithms.","solution":"class IntervalTree: def __init__(self): self.intervals = [] def insert(self, interval): self.intervals.append(interval) self.intervals.sort() def delete(self, interval): if interval in self.intervals: self.intervals.remove(interval) def query(self, interval): result = [] for intv in self.intervals: if self._is_overlapping(intv, interval): result.append(intv) return result def _is_overlapping(self, interval1, interval2): return interval1[0] < interval2[1] and interval2[0] < interval1[1]"},{"question":"# Bipartite Graph Check You are given a graph with `M` nodes and `T` edges. Your task is to determine if the graph is bipartite. A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets such that no two graph vertices within the same set are adjacent. # Input Format: * Integer `M`: The number of nodes in the graph (2 <= M <= 100). * Integer `T`: The number of edges in the graph. * List of `T` edges: Each edge is represented by a tuple `(u, v)` where `u` and `v` are the nodes connected by that edge (1 <= u, v <= M). # Output Format: * Boolean: `True` if the graph is bipartite, `False` otherwise. # Constraints: * Each edge connects two different nodes. * No multiple edges between the same pair of nodes. # Example: Input: ``` 5 5 [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] ``` Output: ``` False ``` Explanation: The given graph forms an odd-length cycle, which cannot be bipartite. Input: ``` 4 4 [(1, 2), (1, 3), (2, 4), (3, 4)] ``` Output: ``` True ``` Explanation: The given graph can be divided into two sets: {1, 4} and {2, 3}. # Function Signature: ```python def is_bipartite(M: int, T: int, edges: list[tuple[int, int]]) -> bool: # Your implementation here pass ``` **Hint**: Use BFS or DFS to try coloring the graph using two colors (representing the two sets). If you can traverse the entire graph without any two adjacent nodes having the same color, the graph is bipartite. If you encounter two adjacent nodes with the same color, it is not bipartite.","solution":"def is_bipartite(M: int, T: int, edges: list[tuple[int, int]]) -> bool: from collections import deque, defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = {} for node in range(1, M + 1): if node not in color: color[node] = 0 queue = deque([node]) while queue: current_node = queue.popleft() for neighbor in graph[current_node]: if neighbor not in color: color[neighbor] = 1 - color[current_node] queue.append(neighbor) elif color[neighbor] == color[current_node]: return False return True"},{"question":"# Coding Question You are asked to develop a simple online voting system for a university election. The provided script must include functionalities for adding candidates, casting votes, and displaying the results. Implement error checks and ensure that the voting process is robust and user-friendly. Objective Implement and enhance the functionality of the voting system focusing on candidate management and vote processing, as well as ensuring the integrity of the results. 1. **Implement Initialization Functions**: - Implement the `register_candidate` function to add a candidate to the list. - Implement the `cast_vote` function to record a vote for a candidate. 2. **Add New Functionalities**: - Implement a new function `validate_candidate` to ensure the uniqueness of candidate names. - Implement a new function `display_results` to show the tally of votes for each candidate. Function Implementations - **register_candidate(candidate: str, candidates: list[str]) -> list[str]**: - Input: A string (candidate name) and a list of current candidates. - Output: Updated list of candidates with error raised if the candidate already exists. - **cast_vote(candidate: str, votes: dict[str, int]) -> dict[str, int]**: - Input: A string (candidate name) and a dictionary mapping candidates to vote counts. - Output: Updated vote count dictionary or an error if a candidate is invalid. - **validate_candidate(candidate: str, candidates: list[str]) -> bool**: - Input: A string (candidate name) and a list of current candidates. - Output: Returns `True` if candidate is unique, otherwise raises a `ValueError`. - **display_results(votes: dict[str, int]) -> None**: - Input: A dictionary mapping candidates to vote counts. - Output: Prints each candidate and their vote count. Example ```python >>> candidates = [] >>> votes = {} >>> candidates = register_candidate(\\"Alice\\", candidates) >>> candidates = register_candidate(\\"Bob\\", candidates) >>> votes = cast_vote(\\"Alice\\", votes) >>> votes = cast_vote(\\"Bob\\", votes) >>> votes = cast_vote(\\"Bob\\", votes) >>> display_results(votes) Alice: 1 vote(s) Bob: 2 vote(s) ``` Implement these functionalities and ensure they integrate seamlessly for a robust and user-friendly online voting system.","solution":"def register_candidate(candidate, candidates): Registers a candidate if they are not already in the list of candidates. if candidate in candidates: raise ValueError(f\\"Candidate {candidate} is already registered.\\") candidates.append(candidate) return candidates def cast_vote(candidate, votes): Records a vote for a candidate if the candidate exists in the current candidates\' list. if candidate not in votes: raise ValueError(f\\"Candidate {candidate} is not valid.\\") votes[candidate] += 1 return votes def validate_candidate(candidate, candidates): Validates that a candidate is unique in the list of candidates. if candidate in candidates: raise ValueError(f\\"Candidate {candidate} already exists.\\") return True def display_results(votes): Prints the tally of votes for each candidate. for candidate, vote_count in votes.items(): print(f\\"{candidate}: {vote_count} vote(s)\\")"},{"question":"# Sorting a List of Dictionaries by Multiple Keys **Problem Statement:** You are given a list of dictionaries where each dictionary contains information about a person, including their name, age, and height. Your task is to write a function to sort this list based on the following criteria: 1. Sort primarily by the `age` key in ascending order. 2. If two people have the same age, then sort by the `height` key in descending order. **Function Signature:** ```python def sort_people(people: list) -> list: pass ``` **Input:** - `people` (list): A list of dictionaries, where each dictionary has three keys - \'name\' (str), \'age\' (int), and \'height\' (int). **Output:** - A list of dictionaries sorted by the given criteria. **Constraints:** - Each dictionary in the input list will have the exact keys \'name\', \'age\', and \'height\'. - The list will contain at least one dictionary and at most 10^4 dictionaries. - Age will be a non-negative integer, and height will be a positive integer. **Example:** ```python # Example input people = [ {\'name\': \'Alice\', \'age\': 30, \'height\': 165}, {\'name\': \'Bob\', \'age\': 25, \'height\': 175}, {\'name\': \'Charlie\', \'age\': 30, \'height\': 170}, {\'name\': \'David\', \'age\': 25, \'height\': 180} ] # Expected output # [ # {\'name\': \'David\', \'age\': 25, \'height\': 180}, # {\'name\': \'Bob\', \'age\': 25, \'height\': 175}, # {\'name\': \'Charlie\', \'age\': 30, \'height\': 170}, # {\'name\': \'Alice\', \'age\': 30, \'height\': 165} # ] output = sort_people(people) print(output) ``` **Explanation:** In the example provided: - David and Bob both have the age of 25, but David has a greater height than Bob, hence David comes first. - Charlie and Alice both have the age of 30, but Charlie has a greater height than Alice, hence Charlie comes first. **Note:** Ensure to test your function with various lists to check its robustness and correctness.","solution":"def sort_people(people: list) -> list: Sort a list of dictionaries by \'age\' in ascending order, and by \'height\' in descending order for people with the same age. return sorted(people, key=lambda x: (x[\'age\'], -x[\'height\']))"},{"question":"# Problem Statement Implement a Python function, `flatten_and_sort`, which takes a list of lists of integers as input and returns a single sorted list of all the integers contained in the input list of lists. The function should handle edge cases like empty lists and lists with one or more empty sublists correctly. # Function Signature ```python def flatten_and_sort(lst: list) -> list: Flattens a list of lists of integers into a single sorted list. Args: lst (list): A list of lists of integers. Returns: list: A sorted list containing all the integers from the input list of lists. Raises: TypeError: If the input is not a list of lists of integers. ``` # Example ```python >>> flatten_and_sort([[3, 2, 1], [4, 6, 5], [], [9, 7, 8]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_and_sort([[], [1, 3, 5], [2, 4, 6], []]) [1, 2, 3, 4, 5, 6] >>> flatten_and_sort([[], [], []]) [] >>> flatten_and_sort([[1, 3, 5], [7, 9], [2, 4, 6]]) [1, 2, 3, 4, 5, 6, 7, 9] >>> flatten_and_sort([[1, 2, 3], [4], [1, 2, 3]]) [1, 1, 2, 2, 3, 3, 4] >>> flatten_and_sort(\\"not a list\\") Traceback (most recent call last): ... TypeError: Input should be a list of lists of integers >>> flatten_and_sort([[1, 2, \\"a\\"], [3, 4]]) Traceback (most recent call last): ... TypeError: Input should be a list of lists of integers ``` Constraints - The function should handle empty lists and sublists properly. - Avoid using built-in flatting functions like `itertools.chain`. - Aim for a solution with a time complexity of O(n log n), where \'n\' is the number of elements across all sublists.","solution":"def flatten_and_sort(lst): Flattens a list of lists of integers into a single sorted list. Args: lst (list): A list of lists of integers. Returns: list: A sorted list containing all the integers from the input list of lists. Raises: TypeError: If the input is not a list of lists of integers. if not isinstance(lst, list): raise TypeError(\'Input should be a list of lists of integers\') for sublist in lst: if not isinstance(sublist, list): raise TypeError(\'Input should be a list of lists of integers\') for item in sublist: if not isinstance(item, int): raise TypeError(\'Input should be a list of lists of integers\') # Flatten the list of lists flat_list = [item for sublist in lst for item in sublist] # Sort the flattened list sorted_list = sorted(flat_list) return sorted_list"},{"question":"# Find Peak Element Context You are given an array of integers that represents the elevation of various points on a hiking trail. Your task is to identify a \\"peak\\" element. A peak element is an element that is not smaller than its neighbors. For corner elements, we need to consider only one neighbor. Efficiently finding a peak in the trail will help determine the best vantage points. Task Write a Python function `find_peak_element(nums: list) -> int` that takes a list of integers representing elevations and returns the index of any one peak element. Your implementation should aim to find the peak element in O(log n) time complexity. Function Signature ```python def find_peak_element(nums: list) -> int: pass ``` Input and Output * **Input**: A list of integers `nums` where each integer represents the elevation at that point on the trail. * **Output**: An integer representing the index of one of the peak elements. Constraints * Each element in the list will be in the range -10^6 to 10^6. * The length of the list will not exceed 10^4. * The given list will contain at least one element. Examples ```python assert find_peak_element([1, 2, 3, 1]) in [2] assert find_peak_element([1, 2, 1, 3, 5, 6, 4]) in [1, 5] assert find_peak_element([5, 10, 20, 15]) in [2] assert find_peak_element([10]) == 0 ``` Performance Requirements Your implementation should have a time complexity of O(log n) by considering the binary search approach. Additional Notes * If the list contains multiple peaks, returning the index of any one of them is acceptable. * Pay attention to edge cases such as a list with only one element or a completely flat list where all elements are the same. # Hint * Consider using a binary search approach, as this will help achieve the desired time complexity. * In a binary search, decide whether to move left or right based on the comparison with neighboring elements.","solution":"def find_peak_element(nums: list) -> int: Finds a peak element in the list and returns its index. A peak element is greater than or equal to its neighbors. For corner elements, only one neighbor is checked. The solution uses binary search to achieve O(log n) time complexity. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"# Question: Implement an Efficient Sliding Window Maximum Given an array of integers and a number `k`, find the maximum element in every sub-array of length `k` using an efficient approach. Your function should return a list containing the maximum elements of each sub-array. # Function Signature ```python def sliding_window_maximum(arr: List[int], k: int) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers. * `k` (int): The length of the sub-arrays to consider for maximum value. Assume valid 1 <= k <= len(arr). # Output * A list of integers representing the maximum value in every sub-array of length `k`. # Constraints * The solution should run in linear time O(n), where n is the length of the array. # Example ```python # Example 1 arr = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 print(sliding_window_maximum(arr, k)) # Output: [3, 3, 5, 5, 6, 7] # Example 2 arr = [4, 1, 2, 7, 5, 3] k = 2 print(sliding_window_maximum(arr, k)) # Output: [4, 2, 7, 7, 5] ``` # Additional Information * The function should utilize a deque or similar data structure to maintain the maximum in constant time as the window slides. * Handle edge cases such as when `arr` has only one element or `k` is equal to 1 gracefully.","solution":"from collections import deque from typing import List def sliding_window_maximum(arr: List[int], k: int) -> List[int]: Find the maximum element in every sub-array of length k. # Base case if not arr: return [] n = len(arr) if k > n: return [] result = [] deq = deque() for i in range(n): # Remove elements not within the sliding window if deq and deq[0] == i - k: deq.popleft() # Remove all elements smaller than the current element while deq and arr[deq[-1]] < arr[i]: deq.pop() # Add the current element at the end of the deque deq.append(i) # Start adding results to the array once the first window is complete if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"# Coding Assessment Question Scenario You are designing a text processing application that needs to determine the frequency of words in a given text but with a twist. The application should be able to ignore certain \\"stop words\\" and be case-insensitive. Given this constraint, you need to implement an efficient algorithm to return the top N most frequent words, excluding the stop words. Task Implement a function `top_n_words` that, given a string of text and a list of stop words, returns the top N most frequent words in descending order of frequency, excluding the stop words. The words should be compared in a case-insensitive manner. Function Signature ```python def top_n_words(text: str, stop_words: List[str], n: int) -> List[str]: ``` Input * `text (str)`: A string containing the text to be processed. * `stop_words (List[str])`: A list of words to be ignored during the frequency count. * `n (int)`: The number of top frequent words to return. Output * Returns a list of the top N most frequent words (List[str]) in descending order of frequency, excluding the stop words. If there are fewer than N distinct words remaining after removing stop words, return all of them. Constraints * Assume the text contains only alphanumeric characters and spaces. * The text string can be of length between 1 and 10,000 characters. * Stop words list can contain up to 100 words. * If `n` is greater than the number of distinct words (excluding stop words), return all available words. * Words are delimited by spaces. Example ```python You have the text as follows: \\"The quick brown fox jumps over the lazy dog. The dog barks loudly.\\" And the stop words: [\\"the\\", \\"over\\", \\"jumps\\"] With n=3, the function should return: [\'dog\', \'brown\', \'fox\'] text = \\"The quick brown fox jumps over the lazy dog. The dog barks loudly.\\" stop_words = [\\"the\\", \\"over\\", \\"jumps\\"] n = 3 result = top_n_words(text, stop_words, n) print(result) # Output should be [\'dog\', \'brown\', \'fox\'] ``` Notes * Ensure the function is case-insensitive (e.g., \\"The\\" and \\"the\\" should be considered the same word). * Consider the efficiency of the solution, especially for longer texts and larger values of `n`. [Output]:","solution":"from typing import List from collections import Counter import re def top_n_words(text: str, stop_words: List[str], n: int) -> List[str]: # Normalize text to lower case and split into words words = re.findall(r\'bw+b\', text.lower()) # Create a set of stop words for quick lookup stop_words_set = set(stop_words) # Filter out stop words filtered_words = [word for word in words if word not in stop_words_set] # Count word frequencies word_counts = Counter(filtered_words) # Get the most common words most_common = word_counts.most_common(n) # Return the words only, in descending order of frequency return [word for word, count in most_common]"},{"question":"# Coding Assessment Question: Develop a mini blog platform where users can create, edit, and delete blog posts. The focus of this task is to implement the core functionalities of the blog post management while ensuring efficient data handling and error management. Objectives: 1. **Create Blog Post**: Implement the functionality to create a new blog post with a title and content. Each post should have a unique identifier, creation timestamp, and optionally tags. 2. **Edit Blog Post**: Allow editing of an existing blog post using its unique identifier. Users should be able to update the title, content, or tags. 3. **Delete Blog Post**: Provide a method to delete an existing blog post by its unique identifier. 4. **Retrieve Blog Posts**: Implement a method to retrieve all blog posts, or filter posts by specific tags. Function Specification: * **Expected Input and Output Formats**: - **Input**: Blog post details such as title, content, and tags as strings or list of strings. - **Output**: Blog post data as dictionaries. * **Constraints and Limitations**: - Ensure the title and content are non-empty strings. - Handle cases where editing or deleting a non-existent post is attempted. - Ensure unique identifiers for all blog posts. * **Performance Requirements**: Ensure efficient handling of data for multiple blog posts, and implement necessary error handling. Implementation Requirements: 1. Create a `BlogPost` class with methods to handle: - Creation, editing, and deletion of blog posts. - Retrieval of all blog posts or filtered by specific tags. 2. Ensure each blog post has a unique identifier, creation timestamp, and can optionally have tags. 3. Implement error handling for cases like trying to edit or delete non-existent posts. 4. Add appropriate methods to retrieve blog posts, either all or filtered by tags. 5. Optimize data handling to ensure performance even with a larger number of posts. Function Signature: ```python from typing import List, Dict, Optional import datetime class BlogPost: def __init__(self): self.posts = {} self.current_id = 0 def create_post(self, title: str, content: str, tags: Optional[List[str]] = None) -> int: Create a new blog post and return its unique identifier. # Implementation goes here. def edit_post(self, post_id: int, title: Optional[str] = None, content: Optional[str] = None, tags: Optional[List[str]] = None) -> bool: Edit an existing blog post identified by post_id. Return True if successful, else False. # Implementation goes here. def delete_post(self, post_id: int) -> bool: Delete a blog post identified by post_id. Return True if successful, else False. # Implementation goes here. def get_posts(self, tag: Optional[str] = None) -> List[Dict]: Retrieve all blog posts or filter by specific tag if provided. # Implementation goes here. ``` # Example Usage: ```python # Initialize the BlogPost class blog = BlogPost() # Create a new post post_id = blog.create_post(\\"My First Post\\", \\"This is the content of my first post.\\", [\\"intro\\", \\"first\\"]) # Edit the post blog.edit_post(post_id, content=\\"Updated content of my first post.\\") # Retrieve all posts all_posts = blog.get_posts() # Delete the post blog.delete_post(post_id) # Retrieve posts with a specific tag filtered_posts = blog.get_posts(tag=\\"intro\\") ``` Ensure your implementation is robust, handles various edge cases, and includes proper documentation and comments for clarity.","solution":"from typing import List, Dict, Optional import datetime class BlogPost: def __init__(self): self.posts = {} self.current_id = 1 def create_post(self, title: str, content: str, tags: Optional[List[str]] = None) -> int: if not title or not content: raise ValueError(\\"Title and content cannot be empty.\\") post = { \\"id\\": self.current_id, \\"title\\": title, \\"content\\": content, \\"tags\\": tags if tags else [], \\"timestamp\\": datetime.datetime.now() } self.posts[self.current_id] = post self.current_id += 1 return post[\\"id\\"] def edit_post(self, post_id: int, title: Optional[str] = None, content: Optional[str] = None, tags: Optional[List[str]] = None) -> bool: if post_id not in self.posts: return False if title is not None: self.posts[post_id][\\"title\\"] = title if content is not None: self.posts[post_id][\\"content\\"] = content if tags is not None: self.posts[post_id][\\"tags\\"] = tags self.posts[post_id][\\"timestamp\\"] = datetime.datetime.now() return True def delete_post(self, post_id: int) -> bool: if post_id not in self.posts: return False del self.posts[post_id] return True def get_posts(self, tag: Optional[str] = None) -> List[Dict]: if tag: return [post for post in self.posts.values() if tag in post[\\"tags\\"]] return list(self.posts.values())"},{"question":"# Scenario In a social media application, users often express their opinions through short messages, known as tweets. Sometimes, these tweets contain hashtags to categorize the content or make it searchable. Imagine you are required to create a utility that collects hashtags from a given list of tweet texts. # Task Implement a Python function `extract_hashtags(tweets: List[str]) -> Dict[str, int]` that performs the following: 1. Takes a list of strings, where each string is a tweet. 2. Extracts all unique hashtags from each tweet. 3. Counts the occurrences of each hashtag across all tweets. 4. Returns a dictionary where the keys are the hashtags and the values are the number of times each hashtag appears. # Constraints * Input `tweets` is a non-empty list of non-empty strings. * Hashtags start with the `#` symbol and can include letters, numbers, and underscores. * Ensure the function is case-insensitive (i.e., `#Python` and `#python` should be considered the same). * The expected output is a dictionary of hashtags with their corresponding frequency count. # Function Signature ```python from typing import List, Dict def extract_hashtags(tweets: List[str]) -> Dict[str, int]: pass ``` # Example ```python tweets = [ \\"Loving the #Python and #DataScience community!\\", \\"Getting started with #python. Any resources? #100DaysOfCode\\", \\"#DataScience is amazing. #Python rocks!\\", \\"Exploring #MachineLearning with #Python.\\" ] result = extract_hashtags(tweets) print(result) # Output: {\'#python\': 4, \'#datascience\': 2, \'#100daysofcode\': 1, \'#machinelearning\': 1} ``` # Requirements * Properly handle scenarios where a tweet has no hashtags. * Ensure hashtags are case-insensitive and stored in lowercase. * Avoid counting any string that does not match the hashtag pattern as a hashtag.","solution":"from typing import List, Dict import re from collections import defaultdict def extract_hashtags(tweets: List[str]) -> Dict[str, int]: hashtag_counts = defaultdict(int) hashtag_pattern = re.compile(r\'#w+\') for tweet in tweets: hashtags = hashtag_pattern.findall(tweet) for hashtag in hashtags: normalized_hashtag = hashtag.lower() hashtag_counts[normalized_hashtag] += 1 return dict(hashtag_counts)"},{"question":"**Context**: You are requested to create a function that simulates a basic calculator with support for undo and redo operations. The calculator should handle addition and subtraction, and it should be able to revert recent operations or reapply undone operations. For example, if you add 10, then subtract 3, and then undo the last operation, the result should be as if only 10 was added. **Task**: Create a class `Calculator` that supports the following methods: - `add(num: int) -> None`: Adds the given number to the current total. - `subtract(num: int) -> None`: Subtracts the given number from the current total. - `undo() -> None`: Reverts the most recent operation (addition or subtraction). - `redo() -> None`: Reapplies the most recently undone operation. - `get_total() -> int`: Returns the current total after performing all operations. The class should handle undo and redo operations efficiently and ensure that multiple undo or redo operations beyond the history of operations are managed gracefully. **Class Definition**: ```python class Calculator: def __init__(self): # Implement your constructor here def add(self, num: int) -> None: # Implement addition here def subtract(self, num: int) -> None: # Implement subtraction here def undo(self) -> None: # Implement undo here def redo(self) -> None: # Implement redo here def get_total(self) -> int: # Return the current total here ``` **Examples**: ```python calc = Calculator() calc.add(10) calc.subtract(3) print(calc.get_total()) # Should print 7 calc.undo() print(calc.get_total()) # Should print 10 calc.redo() print(calc.get_total()) # Should print 7 calc.subtract(5) calc.undo() calc.undo() print(calc.get_total()) # Should print 10 calc.redo() print(calc.get_total()) # Should print 7 ``` **Expected Output**: - 7 - 10 - 7 - 10 - 7 **Constraints**: - All numbers are integers between -1000 and 1000. - Ensure that the operations are executed in constant time.","solution":"class Calculator: def __init__(self): self._total = 0 self._history = [] self._redo_stack = [] def add(self, num: int) -> None: self._history.append((self._total, num, \'add\')) self._total += num self._redo_stack.clear() def subtract(self, num: int) -> None: self._history.append((self._total, num, \'subtract\')) self._total -= num self._redo_stack.clear() def undo(self) -> None: if self._history: last_total, num, operation = self._history.pop() self._redo_stack.append((self._total, num, operation)) self._total = last_total def redo(self) -> None: if self._redo_stack: last_total, num, operation = self._redo_stack.pop() self._history.append((self._total, num, operation)) if operation == \'add\': self._total += num elif operation == \'subtract\': self._total -= num def get_total(self) -> int: return self._total"},{"question":"# Sublist Sum Check You are given a function `has_sublist_sum` that determines whether there exists a contiguous sublist within a given list of integers that adds up to a specified target sum. The function must return `True` if such a sublist exists and `False` otherwise. # Requirements: 1. **Input**: A list of integers and an integer representing the target sum. 2. **Output**: A boolean value indicating whether there exists a contiguous sublist that sums up to the target. 3. **Constraints**: - The input list can have a length up to `10^5`. - The input list can contain both positive and negative integers. - The target sum can be any integer, positive, negative, or zero. # Performance: - Optimize the function to run efficiently even with the maximum input size. - Design your solution to have a linear time complexity `O(n)`, where `n` is the length of the input list. Additional Requirements: - Handle edge cases where the list is empty or contains very large integers. Example usage: ```python >>> has_sublist_sum([1, 2, 3, 4, 5], 9) True # (2 + 3 + 4 = 9) >>> has_sublist_sum([-1, 2, 3, -2, 5], 6) True # (2 + 3 + -2 + 3 = 6) >>> has_sublist_sum([1, 2, 3], 7) False >>> has_sublist_sum([1, -1, 1, -1, 1], 0) True # (1 + -1 + 1 + -1 = 0) >>> has_sublist_sum([], 1) False ```","solution":"def has_sublist_sum(nums, target): Determines whether there exists a contiguous sublist within a given list of integers that adds up to a specified target sum. Returns True if such a sublist exists, False otherwise. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: bool: True if a contiguous sublist with sum equal to target exists, else False. current_sum = 0 sums_seen = set() sums_seen.add(0) for num in nums: current_sum += num if current_sum - target in sums_seen: return True sums_seen.add(current_sum) return False"},{"question":"# Scenario: You are working on a database migration task and need to convert times stored in different time zones to a single standard time zone (UTC). Your goal is to implement a function that parses timestamps, identifies their time zones, and converts them to UTC. # Task: Implement a Python function `convert_to_utc(timestamps: List[str]) -> List[str]` that: 1. Accepts a list of timestamps in ISO 8601 format. 2. Identifies the time zone from each timestamp. 3. Converts each timestamp to UTC. 4. Returns a list of the converted timestamps in UTC, formatted as ISO 8601 strings. # Input: - `timestamps` (List[str]): A list of timestamp strings in ISO 8601 format. # Output: - (List[str]): A list of timestamp strings converted to UTC, formatted as ISO 8601 strings. # Constraints: - The timestamps will be valid ISO 8601 strings. - Timestamps can have different time zone offsets or \'Z\' indicating UTC. - Assume each timestamp contains both date and time parts. # Example: ```python timestamps = [ \\"2023-10-07T13:45:00-04:00\\", \\"2023-10-07T17:30:00+02:00\\", \\"2023-10-07T14:00:00Z\\", \\"2023-10-07T07:30:00-07:00\\" ] result = convert_to_utc(timestamps) # Expected result: # [ # \\"2023-10-07T17:45:00Z\\", # \\"2023-10-07T15:30:00Z\\", # \\"2023-10-07T14:00:00Z\\", # \\"2023-10-07T14:30:00Z\\" # ] ``` # Notes: - Ensure your function can handle different time zone offsets correctly. - Use a reliable library for parsing and converting time zones (e.g., `datetime`, `pytz` or `dateutil`). - Test your function with a variety of timestamps to ensure accuracy.","solution":"from dateutil import parser from datetime import datetime, timezone from typing import List def convert_to_utc(timestamps: List[str]) -> List[str]: Converts a list of timestamps in different time zones to UTC. Args: timestamps (List[str]): A list of timestamp strings in ISO 8601 format. Returns: List[str]: A list of timestamp strings converted to UTC, formatted as ISO 8601 strings. utc_timestamps = [] for ts in timestamps: dt = parser.isoparse(ts) # Parse the timestamp using dateutil utc_dt = dt.astimezone(timezone.utc) # Convert to UTC utc_timestamps.append(utc_dt.isoformat().replace(\\"+00:00\\", \\"Z\\")) # Convert back to ISO 8601 string return utc_timestamps"},{"question":"# Coding Question: Crop the Centered Square from an Image Given the provided code snippets for image processing tasks, let\'s extend the functionality to support cropping a centered square from any given image. The function should take an image (2D numpy array) and the target side length for the square, then return the centered square crop of the image. Core Requirements: - **Function Signature**: ```python def centered_square_crop(image: np.ndarray, side_length: int) -> np.ndarray: ``` - **Input**: - `image` (np.ndarray): A 2D numpy array representing a grayscale image. - `side_length` (int): The side length of the square to be cropped. - **Output**: - A 2D numpy array representing the cropped centered square of the given side length. - **Constraints**: - The input `image` will have dimensions within the range (1 ≤ width, height ≤ 1000). - The `side_length` will be a positive integer within the dimensions of the image. Instructions: 1. **Centering**: Ensure the cropped square is centered in the input image. 2. **Boundary Handling**: Take care to handle boundary cases where the side length results in an odd number of rows/columns around the center. 3. **Performance**: Implement the cropping efficiently to minimize computational overhead for large images. Example ```python >>> image = np.array([[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]) >>> side_length = 2 >>> centered_square_crop(image, side_length) array([[1, 1], [1, 1]]) >>> image = np.array([[0, 0, 0, 0, 0], [0, 1, 2, 3, 0], [0, 4, 5, 6, 0], [0, 7, 8, 9, 0], [0, 0, 0, 0, 0]]) >>> side_length = 3 >>> centered_square_crop(image, side_length) array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ``` This task will test your understanding of image processing fundamentals, handling array operations and efficiency in manipulating image data.","solution":"import numpy as np def centered_square_crop(image: np.ndarray, side_length: int) -> np.ndarray: Crops a centered square from the given image. Parameters: image (np.ndarray): A 2D numpy array representing a grayscale image. side_length (int): The side length of the square to be cropped. Returns: np.ndarray: A 2D numpy array representing the cropped centered square. height, width = image.shape if side_length > height or side_length > width: raise ValueError(\\"side_length must be within the dimensions of the image\\") start_row = (height - side_length) // 2 start_col = (width - side_length) // 2 return image[start_row:start_row + side_length, start_col:start_col + side_length]"},{"question":"# Coding Assessment Question Context You are tasked with implementing an interval tree to manage a collection of intervals. This data structure allows for efficient insertion, deletion, and querying of intervals, such as finding all intervals that overlap a given interval. The interval tree maintains a balanced structure to ensure efficient performance of these operations. Task Implement the `IntervalTree` class with the following functionalities: 1. **Insert** an interval into the tree. 2. **Delete** a given interval from the tree. 3. **Search**: Find all intervals that overlap with a given interval. 4. **Clear**: Remove all intervals from the tree. 5. **InOrderTraversal**: Return a list of all intervals in the tree, sorted by their start values. Requirements - Implement the `IntervalTree` class with all the specified methods. - Ensure that all operations adhere to their expected time complexity of O(log N) for insert and delete operations. - Handle edge cases such as inserting into an empty tree, deleting from an empty tree, and searching intervals when the tree is empty. Example Usage ```python it = IntervalTree() it.insert((5, 10)) it.insert((15, 20)) it.insert((10, 12)) overlapping_intervals = it.search((8, 16)) print(overlapping_intervals) # Output: [(5, 10), (10, 12), (15, 20)] sorted_intervals = it.in_order_traversal() print(sorted_intervals) # Output: [(5, 10), (10, 12), (15, 20)] it.delete((10, 12)) sorted_intervals = it.in_order_traversal() print(sorted_intervals) # Output: [(5, 10), (15, 20)] it.clear() try: it.delete((5, 10)) # Should raise ValueError as the tree is now empty except ValueError: print(\\"Tree is empty\\") ``` Input/Output Format - **Insert**: Accepts a tuple `(start, end)` where `start` and `end` are integers representing the interval. `start` is inclusive, and `end` is exclusive. - **Delete**: Receives a tuple (start, end) and removes it from the tree. - **Search**: Accepts a tuple `(start, end)` and returns a list of all intervals in the tree that overlap with this interval. - **Clear**: Removes all intervals from the tree. - **InOrderTraversal**: Returns a list of all intervals in the tree, sorted by their start values. Constraints - Intervals are represented by integers where `start` < `end`. - The values in the intervals will be within the range of standard integer bounds. Performance - Ensure that the insert, delete, and search operations have an average time complexity within the specified limits.","solution":"class IntervalTree: def __init__(self): self.intervals = [] def insert(self, interval): Insert an interval into the tree. if not self.intervals: self.intervals.append(interval) else: self.intervals.append(interval) self.intervals.sort(key=lambda x: x[0]) def delete(self, interval): Delete a given interval from the tree. if interval in self.intervals: self.intervals.remove(interval) else: raise ValueError(f\\"Interval {interval} not found in the tree.\\") def search(self, interval): Find all intervals that overlap with a given interval. return [i for i in self.intervals if i[0] < interval[1] and i[1] > interval[0]] def clear(self): Remove all intervals from the tree. self.intervals = [] def in_order_traversal(self): Return a list of all intervals in the tree, sorted by their start values. return self.intervals[:]"},{"question":"# Subarray Product Less Than K Given an array of positive integers, write a function `num_of_subarrays(arr: List[int], k: int) -> int` that returns the number of contiguous subarrays where the product of all the elements in the subarray is less than a given target `k`. Input and Output Formats * **Input**: * `arr`: A list of positive integers. * `k`: A positive integer, the target threshold for the product. * **Output**: * Return an integer representing the number of contiguous subarrays where the product of all the elements is less than `k`. Constraints * `1 <= len(arr) <= 10^5` * `1 <= arr[i] <= 1000` * `1 <= k <= 10^6` Performance Requirements * Aim for a solution that runs in less than O(n^2) time complexity. Utilizing a sliding window approach can help achieve better performance. # Example ```python arr = [10, 5, 2, 6] k = 100 print(num_of_subarrays(arr, k)) # Output: 8, subarrays: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6] arr = [1, 2, 3] k = 0 print(num_of_subarrays(arr, k)) # Output: 0, no subarray has a product less than 0 ``` # Implementation Implement the `num_of_subarrays` function which calculates the number of subarrays where the product of the elements is less than `k` using an efficient approach, such as sliding window.","solution":"def num_of_subarrays(arr, k): Returns the number of contiguous subarrays where the product of all the elements in the subarray is less than k. if k <= 1: return 0 left = 0 product = 1 count = 0 for right in range(len(arr)): product *= arr[right] while product >= k and left <= right: product /= arr[left] left += 1 count += right - left + 1 return count"},{"question":"# Question: Data Analysis on Website Traffic **Context**: You are given a dataset of website traffic logs, where each log entry contains the timestamp of a visit and the user ID of the visitor. You need to analyze this data to find the peak period of activity -- specifically, the 1-hour period that has the highest number of unique visitors. **Task**: You need to write a function `peak_hour_traffic` that identifies the 1-hour period with the highest number of unique visitors, starting from any given visit timestamp in the logs. **Function Signature and Inputs**: ```python from typing import List, Tuple, Dict from collections import namedtuple LogEntry = namedtuple(\'LogEntry\', [\'timestamp\', \'user_id\']) def peak_hour_traffic(logs: List[LogEntry]) -> Tuple[str, int]: ... ``` **Input Description**: - `logs`: A list of `LogEntry` namedtuples where: - `timestamp` is a string in the format \'YYYY-MM-DD HH:MM:SS\', - `user_id` is an integer representing the unique ID of a user. **Output Description**: - Return a tuple containing: - The timestamp (string) representing the start of the 1-hour period with the highest unique visitor count, - The count of unique visitors during that period. **Constraints**: - The given logs are guaranteed to be in chronological order. **Additional Notes**: - The timestamp should be formatted as \'YYYY-MM-DD HH:MM:SS\'. - Ensure your solution is efficient; consider the time complexity of comparing each possible 1-hour period. - If there are multiple periods with the same highest unique visitor count, return the earliest period. **Example**: ```python logs = [ LogEntry(\'2023-01-01 00:00:01\', 1), LogEntry(\'2023-01-01 00:10:00\', 2), LogEntry(\'2023-01-01 00:20:00\', 3), LogEntry(\'2023-01-01 01:30:00\', 3), LogEntry(\'2023-01-01 01:40:00\', 2), LogEntry(\'2023-01-01 01:50:00\', 1), ] print(peak_hour_traffic(logs)) # Expected Output: (\'2023-01-01 00:00:01\', 3) ``` Implement the `peak_hour_traffic` function to solve the problem.","solution":"from typing import List, Tuple, Dict from collections import namedtuple, defaultdict from datetime import datetime, timedelta LogEntry = namedtuple(\'LogEntry\', [\'timestamp\', \'user_id\']) def peak_hour_traffic(logs: List[LogEntry]) -> Tuple[str, int]: # Convert all timestamps to datetime objects logs = [(datetime.strptime(log.timestamp, \'%Y-%m-%d %H:%M:%S\'), log.user_id) for log in logs] # Variables to track the result max_count = 0 max_start_timestamp = \'\' n = len(logs) for i in range(n): start_time = logs[i][0] end_time = start_time + timedelta(hours=1) unique_users = set() for j in range(i, n): if logs[j][0] < end_time: unique_users.add(logs[j][1]) else: break if len(unique_users) > max_count: max_count = len(unique_users) max_start_timestamp = logs[i][0].strftime(\'%Y-%m-%d %H:%M:%S\') return (max_start_timestamp, max_count)"},{"question":"# Scenario You are working on an e-commerce platform and responsible for implementing a feature that allows customers to search for products. To enhance the search functionality, you need to implement a query processing system that ranks the search results based on their relevance. # Task Implement a function `rank_search_results` that takes two arguments: a string `query` and a list of strings `documents`, representing the search query and the list of product descriptions, respectively. The function should return the list of product descriptions sorted by their relevance to the search query. Relevance is determined by the number of words in the query that match the words in the document. # Input - A string `query`: search query containing one or more words. - A list of strings `documents`: each string in the list represents a product description. # Output - A list of strings: the input `documents` list sorted based on relevance to the `query`. # Constraints - The query and each document will contain only alphanumeric characters and spaces. - Words are separated by a single space in the query and documents. - The length of `query` will be between 1 and 200. - Each document in `documents` will have a length between 1 and 1000. - The number of documents will not exceed 1000. # Example Given the query \\"fast laptop\\", and documents [\\"A fast laptop with SSD\\", \\"Laptop with long battery life\\", \\"Fast and reliable laptop\\"], the function should return: ```python [\\"A fast laptop with SSD\\", \\"Fast and reliable laptop\\", \\"Laptop with long battery life\\"] ``` # Note - Ensure the function handles edge cases such as an empty `documents` list or a query with words not present in any document. - If two documents have the same relevance score, their original order should be preserved. ```python def rank_search_results(query, documents): Rank search results by relevance based on the query. Args: query (str): The search query. documents (List[str]): List of product descriptions. Returns: List[str]: List of product descriptions sorted by their relevance to the query. query_words = set(query.lower().split()) def relevance(document): doc_words = set(document.lower().split()) return len(query_words & doc_words) return sorted(documents, key=relevance, reverse=True) # Example usage: query = \\"fast laptop\\" documents = [\\"A fast laptop with SSD\\", \\"Laptop with long battery life\\", \\"Fast and reliable laptop\\"] print(rank_search_results(query, documents)) # Output: [\\"A fast laptop with SSD\\", \\"Fast and reliable laptop\\", \\"Laptop with long battery life\\"] ```","solution":"def rank_search_results(query, documents): Rank search results by relevance based on the query. Args: query (str): The search query. documents (List[str]): List of product descriptions. Returns: List[str]: List of product descriptions sorted by their relevance to the query. query_words = set(query.lower().split()) def relevance(document): doc_words = set(document.lower().split()) return len(query_words & doc_words) return sorted(documents, key=relevance, reverse=True) # Example usage: query = \\"fast laptop\\" documents = [\\"A fast laptop with SSD\\", \\"Laptop with long battery life\\", \\"Fast and reliable laptop\\"] print(rank_search_results(query, documents)) # Output: [\\"A fast laptop with SSD\\", \\"Fast and reliable laptop\\", \\"Laptop with long battery life\\"]"},{"question":"# Problem Statement A common task in string processing is to identify and manipulate palindromes - sequences that read the same backward as forward. In this problem, you are required to implement several functions to handle palindromic substrings within a given string. Specifically, your task involves the following steps: 1. **Longest Palindromic Substring**: Implement a function to find the longest palindromic substring in a given string. 2. **Count All Palindromic Substrings**: Implement a function to count all unique palindromic substrings within the given string. 3. **Palindromic Substring Replacement**: Implement a function to replace all occurrences of a given palindromic substring with another substring. # Function Signatures ```python def longest_palindrome(s: str) -> str: pass def count_palindromic_substrings(s: str) -> int: pass def replace_palindromic_substring(s: str, old: str, new: str) -> str: pass ``` # Input/Output Formats * **longest_palindrome**: - **Input**: A string `s`. - **Output**: The longest palindromic substring within `s`. * **count_palindromic_substrings**: - **Input**: A string `s`. - **Output**: An integer representing the count of all unique palindromic substrings within `s`. * **replace_palindromic_substring**: - **Input**: Three strings `s`, `old`, and `new`. - **Output**: A new string resulting from replacing all occurrences of the palindromic substring `old` with `new` in `s`. # Constraints * `1 <= len(s) <= 10^5` * The input strings will contain only lowercase English letters. * You can assume that `old` is a palindromic substring of `s`. # Example ```python assert longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_palindrome(\\"cbbd\\") == \\"bb\\" assert count_palindromic_substrings(\\"aaa\\") == 6 # \\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aaa\\" assert count_palindromic_substrings(\\"abc\\") == 3 # \\"a\\", \\"b\\", \\"c\\" assert replace_palindromic_substring(\\"ababab\\", \\"aba\\", \\"xyz\\") == \\"xyzbab\\" assert replace_palindromic_substring(\\"abcde\\", \\"cdc\\", \\"xyz\\") == \\"abcde\\" # \\"cdc\\" is not found in \\"abcde\\", so no replacement ``` # Implementation Notes 1. **Longest Palindrome**: Use dynamic programming or expand around center approach to implement this efficiently. 2. **Count Palindromic Substrings**: Use a two-pointer approach to count unique palindromic substrings. 3. **Replace Palindromic Substring**: Perform string replacement operations ensuring all occurrences of the specified palindromic substring are replaced.","solution":"def longest_palindrome(s: str) -> str: if len(s) == 0: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes substr1 = expand_around_center(s, i, i) if len(substr1) > len(longest): longest = substr1 # Even length palindromes substr2 = expand_around_center(s, i, i + 1) if len(substr2) > len(longest): longest = substr2 return longest def count_palindromic_substrings(s: str) -> int: def expand_around_center(s, left, right): count = 0 while left >= 0 and right < len(s) and s[left] == s[right]: count += 1 left -= 1 right += 1 return count count = 0 for i in range(len(s)): # Odd length palindromes count += expand_around_center(s, i, i) # Even length palindromes count += expand_around_center(s, i, i + 1) return count def replace_palindromic_substring(s: str, old: str, new: str) -> str: return s.replace(old, new)"},{"question":"# Question: Find Duplicates in a List You are asked to implement a function that finds all the duplicate elements in a list of integers and returns them as a new list. The order of the duplicates in the output list should match the order of their first occurrences in the input list. Function Signature ```python def find_duplicates(nums: List[int]) -> List[int]: Returns a list containing all the duplicates from the input list `nums` in the order of their first occurrence. ``` Input * A single list of integers `nums` where `1 <= len(nums) <= 10^6`. Output * A list of integers containing all duplicate elements from `nums` in the order of their first occurrence. Constraints * The integers in `nums` can range from `-10^9` to `10^9`. * The result list should contain each duplicate number only once, irrespective of how many times it appears in the input list. * The function should be efficient in terms of time and space complexity. # Example ```python # Example 1 nums = [4, 3, 2, 7, 8, 2, 3, 1] print(find_duplicates(nums)) # Output: [2, 3] # Example 2 nums = [1, 1, 2] print(find_duplicates(nums)) # Output: [1] # Example 3 nums = [1, 2, 3, 4, 5] print(find_duplicates(nums)) # Output: [] ``` # Performance Requirements * The function should be able to handle lists with up to `10^6` elements efficiently. * The implementation should utilize appropriate data structures to ensure that the solution is both time and space optimized.","solution":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: Returns a list containing all the duplicates from the input list `nums` in the order of their first occurrence. seen = set() duplicates = set() result = [] for num in nums: if num in seen: if num not in duplicates: duplicates.add(num) result.append(num) else: seen.add(num) return result"},{"question":"# Binary Search Implementation **Objective**: Implement a function to perform binary search on a sorted list of integers. **Function Signature**: ```python def binary_search(arr: list[int], target: int) -> int: ``` # Instructions: Write a function `binary_search` that: 1. Takes two parameters: * `arr`: a list of integers sorted in ascending order. * `target`: an integer value to search for in the list. 2. Returns the index of the `target` in `arr` if it exists, or `-1` if the `target` is not found. # Approach: Use the binary search algorithm, which divides the search interval in half repeatedly until the target value is found or the interval is empty. # Input constraints: * The length of `arr` will be between 1 and 10,000 inclusive. * The elements of `arr` will be between -10^5 and 10^5 inclusive. * The `target` will be between -10^5 and 10^5 inclusive. # Output: The function should return an integer representing the index of the `target` in `arr`, or `-1` if the `target` is not found. # Examples: ```python >>> binary_search([1, 2, 3, 4, 5], 3) 2 >>> binary_search([1, 2, 3, 4, 5], 6) -1 >>> binary_search([1], 1) 0 >>> binary_search([-10, -5, 0, 5, 10], -5) 1 >>> binary_search([-10, -5, 0, 5, 10], 15) -1 ``` # Performance requirements: The function should perform efficiently with a time complexity of O(log n) and space complexity of O(1). # Additional Notes: * Ensure to handle edge cases such as an empty array or a single-element array. * You can assume the function will not receive non-numeric input values.","solution":"def binary_search(arr: list[int], target: int) -> int: Perform binary search on a sorted list of integers and return the index of the target if found, or -1 if not found. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Program Description In digital signal processing, signals are often represented as arrays of integers. One of the fundamental operations performed on signals is determining the length of consecutive identical values, also known as \\"runs\\". Your task is to implement a function that finds the longest run of identical consecutive elements in an array of integers. # Function Signature ```python def longest_consecutive_run(arr: List[int]) -> Tuple[int, int]: ``` # Input - **arr**: A list of integers representing the signal values. The list may be empty. # Output - A tuple containing two integers: 1. The integer value of the longest run. 2. The length of that run. - If there are multiple runs of the same length, return the first one encountered. - If the array is empty, return `(None, 0)`. # Constraints - You may assume the length of the input list does not exceed (10^6). # Example ```python >>> longest_consecutive_run([1, 1, 2, 2, 2, 3, 3]) (2, 3) >>> longest_consecutive_run([5, 5, 5, 1, 1, 5]) (5, 3) >>> longest_consecutive_run([1]) (1, 1) >>> longest_consecutive_run([]) (None, 0) >>> longest_consecutive_run([7, 7, 7, 7, 7, 1, 1, 1, 1, 2, 2, 2]) (7, 5) ``` # Implementation Notes - Ensure the function efficiently processes the input list up to the constraint limits. - Consider edge cases like an empty list or a list where all elements are the same. - Avoid using additional libraries or built-in functions for finding runs; implement the logic manually.","solution":"from typing import List, Tuple def longest_consecutive_run(arr: List[int]) -> Tuple[int, int]: if not arr: return (None, 0) max_value = arr[0] max_length = 1 current_value = arr[0] current_length = 1 for i in range(1, len(arr)): if arr[i] == current_value: current_length += 1 else: if current_length > max_length: max_length = current_length max_value = current_value current_value = arr[i] current_length = 1 if current_length > max_length: max_length = current_length max_value = current_value return (max_value, max_length)"},{"question":"# Array Product Puzzle Imagine you are given an array of integers. You need to write a function that returns an array of the products of all the other elements at each index without using division. For example, given the array `[1, 2, 3, 4, 5]`, the function should return `[120, 60, 40, 30, 24]`. This is because at each index, the product of the other numbers is being calculated. Specifically: - For 1 at index 0, the product of `[2, 3, 4, 5]` is `120` - For 2 at index 1, the product of `[1, 3, 4, 5]` is `60` - And so forth. **Your function** `array_product_puzzle(nums: List[int]) -> List[int]` should calculate and return the desired output array. Function Signature: ```python def array_product_puzzle(nums: List[int]) -> List[int]: pass ``` # Input * A list of integers `nums`. # Output * A list of integers representing the product of the elements at each index considering all other elements in the array. # Constraints * Assume `1 <= len(nums) <= 10^5` * The elements in the given list can be positive or negative integers, including zero. * The solution should not use division. # Example Scenarios 1. `array_product_puzzle([1, 2, 3, 4, 5])` should return `[120, 60, 40, 30, 24]`. 2. `array_product_puzzle([3, 2, 1])` should return `[2, 3, 6]`. # Edge Cases 1. For a single-element array like `[7]`, return `[1]`. 2. For an array with zeros like `[0, 1, 2, 3]`, account for proper zero placement: `[6, 0, 0, 0]`. Requirements: - **Performance**: Efficiently handle input arrays with up to 10^5 elements. - **Edge Handling**: Properly handle the presence of zeroes and single-element arrays. Implement the function and ensure it passes the provided tests.","solution":"from typing import List def array_product_puzzle(nums: List[int]) -> List[int]: n = len(nums) if n == 0: return [] left = [1] * n right = [1] * n result = [1] * n for i in range(1, n): left[i] = left[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right[i] = right[i + 1] * nums[i + 1] for i in range(n): result[i] = left[i] * right[i] return result"},{"question":"# Scenario A company offers a service to convert PDF documents into editable text files. As a part of the quality assurance process, there’s a need to write a function to detect whether the extracted text from the PDF contains any malformed sentences. A well-formed sentence should start with an uppercase letter and end with a period. If a sentence does not meet this criterion, it is considered malformed. # Task Implement a Python function `check_sentences(text: str) -> bool` that will determine if all sentences in the input text are well-formed according to the specified rules. The function should ignore empty strings and whitespace-only sentences. Input * A single string `text` representing the extracted text from a PDF document. Output * Return `True` if all non-empty, non-whitespace-only sentences are well-formed. * Return `False` if there is at least one malformed sentence. Example Inputs and their corresponding correct/incorrect outputs: ```python check_sentences(\\"This is a well-formed sentence. This is another one.\\") # Returns: True check_sentences(\\"this is not well-formed. This is.\\") # Returns: False check_sentences(\\" \\") # Returns: True check_sentences(\\"Correctly formatted. Unformatted\\") # Returns: False check_sentences(\\"Well-formed. Another well-formed.\\") # Returns: True ``` **Note**: Ensure that the function properly handles various edge cases such as multiple spaces, empty sentences, and different sentence lengths.","solution":"def check_sentences(text: str) -> bool: Determines if all sentences in the input text are well-formed. A well-formed sentence starts with an uppercase letter and ends with a period. import re # Split text using regex to capture sentences sentences = re.split(r\'(?<=[.])s+\', text) for sentence in sentences: sentence = sentence.strip() if sentence: # Ignore empty or whitespace-only sentences if not (sentence[0].isupper() and sentence[-1] == \'.\'): return False return True"},{"question":"# Problem Statement: You are given a matrix of characters representing an N x M grid where some cells are empty spaces (\' \') and others are obstacles (\'#\'). The goal is to find the shortest path from the top-left corner (0, 0) to the bottom-right corner (N-1, M-1) while avoiding obstacles. If it\'s impossible to reach the destination, return -1. Implement a function `shortest_path(grid: List[List[str]]) -> int` that finds the length of the shortest path from the top-left to the bottom-right corner of the grid. # Input: - A 2D list of characters `grid` where: * `grid[i][j]` is either \' \' (empty space) or \'#\' (obstacle). * 1 ≤ N, M ≤ 1000. # Output: - An integer representing the length of the shortest path, or -1 if no path exists. # Constraints: * You can move up, down, left, or right, but cannot move diagonally. * The top-left and bottom-right corners are always empty spaces (\' \'). # Example: ```python assert shortest_path([ [\' \', \'#\', \' \', \' \'], [\' \', \'#\', \' \', \'#\'], [\' \', \' \', \' \', \'#\'], [\'#\', \' \', \' \', \' \'] ]) == 6 assert shortest_path([ [\' \', \'#\'], [\'#\', \' \'] ]) == -1 assert shortest_path([ [\' \', \' \'], [\' \', \' \'] ]) == 2 ``` # Notes: * Use a breadth-first search (BFS) approach to efficiently find the shortest path. * Handle edge cases such as small grids and grids filled mostly with obstacles.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[str]]) -> int: def in_bounds(x, y): return 0 <= x < n and 0 <= y < m def is_empty(x, y): return grid[x][y] == \' \' n, m = len(grid), len(grid[0]) if grid[0][0] == \'#\' or grid[n-1][m-1] == \'#\': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and is_empty(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Question: Forbidden Path in a Grid Background You are given a grid of size ( m times n ) consisting of non-negative integers representing the cost to enter each cell. You are starting at the top-left corner of the grid (i.e., cell ( (0,0) )) and you must reach the bottom-right corner (i.e., cell ( (m-1,n-1) )). You can only move either down or right at any point in time. However, there are certain forbidden cells in the grid where entry is not allowed. If there is no valid path due to these forbidden cells, return -1. Task Write a function `min_path_sum_with_forbidden_cells(grid: list[list[int]], forbidden_cells: set[tuple[int, int]]) -> int` that calculates the minimum cost to travel from the top-left to the bottom-right corner of the grid without entering any forbidden cells. If no such path exists, return -1. Function Signature ```python def min_path_sum_with_forbidden_cells(grid: list[list[int]], forbidden_cells: set[tuple[int, int]]) -> int: pass ``` Input * `grid`: A list of lists where each inner list represents a row of the grid filled with non-negative integers representing the cost. * `forbidden_cells`: A set containing tuples, where each tuple represents the coordinates (row, col) of forbidden cells. Output * Returns an integer, the minimum cost to travel from the top-left to the bottom-right corner of the grid without entering any forbidden cells, or -1 if no such path exists. Example ```python Input: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ], forbidden_cells = {(1, 1)} Output: 7 Input: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ], forbidden_cells = {(1, 1), (1, 0), (1, 2)} Output: -1 ``` Constraints * ( 1 leq m, n leq 100 ) * ( 0 leq text{grid}[i][j] leq 100 ) * The set of forbidden cell coordinates will not include the starting cell (0,0) and the ending cell (m-1,n-1). Notes * Make sure to handle edge cases where either the initial or the final cell are directly adjacent to any forbidden cell.","solution":"def min_path_sum_with_forbidden_cells(grid, forbidden_cells): if not grid or (len(grid) - 1, len(grid[0]) - 1) in forbidden_cells: return -1 m, n = len(grid), len(grid[0]) dp = [[float(\'inf\')] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(m): for j in range(n): if (i, j) in forbidden_cells: continue if i > 0 and (i - 1, j) not in forbidden_cells: dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]) if j > 0 and (i, j - 1) not in forbidden_cells: dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]) return dp[m - 1][n - 1] if dp[m - 1][n - 1] != float(\'inf\') else -1"},{"question":"# Coding Assessment Question: Implement a Simplified Virtual File System You are tasked to implement a simplified virtual file system for performing basic file and directory operations: creating instances of files and directories, adding files to directories, retrieving files, and listing directory contents. # Function Definitions: 1. `File` class: * `__init__(self, name: str, content: str) -> None`: * **Input**: * `name`: A string representing the name of the file. * `content`: A string containing the file\'s content. * **Output**: * Initializes the file instance. * `get_name(self) -> str`: * **Output**: * Returns the name of the file. * `get_content(self) -> str`: * **Output**: * Returns the content of the file. 2. `Directory` class: * `__init__(self, name: str) -> None`: * **Input**: * `name`: A string representing the name of the directory. * **Output**: * Initializes the directory instance. *`add_file(self, file: File) -> None`: * **Input**: * `file`: An instance of the `File` class to be added to the directory. * **Output**: * Adds the file to the directory. * `get_file(self, name: str) -> File`: * **Input**: * `name`: A string representing the name of the file to retrieve. * **Output**: * Returns the `File` instance with the specified name, or `None` if the file does not exist in the directory. * `list_files(self) -> List[str]`: * **Output**: * Returns a list of strings representing the names of all files in the directory. # Instructions: 1. Implement the `File` class. 2. Implement the `Directory` class. # Example: ```python # Create files file1 = File(\\"file1.txt\\", \\"This is the content of file 1\\") file2 = File(\\"file2.txt\\", \\"This is the content of file 2\\") # Create directory and add files directory = Directory(\\"my_directory\\") directory.add_file(file1) directory.add_file(file2) # List files in the directory print(directory.list_files()) # Expected Output: [\'file1.txt\', \'file2.txt\'] # Retrieve a specific file and print its content retrieved_file = directory.get_file(\\"file1.txt\\") if retrieved_file: print(retrieved_file.get_content()) # Expected Output: \'This is the content of file 1\' # Try to retrieve a non-existing file non_existent_file = directory.get_file(\\"non_existent.txt\\") print(non_existent_file) # Expected Output: None ``` # Constraints: * The `File` and `Directory` classes should appropriately encapsulate their data, only allowing manipulation through their defined methods. * There will be no duplicate file names within a directory. Good luck and demonstrate your ability to manage a simplified object-oriented file system!","solution":"from typing import List class File: def __init__(self, name: str, content: str) -> None: self.name = name self.content = content def get_name(self) -> str: return self.name def get_content(self) -> str: return self.content class Directory: def __init__(self, name: str) -> None: self.name = name self.files = {} def add_file(self, file: File) -> None: self.files[file.get_name()] = file def get_file(self, name: str) -> File: return self.files.get(name, None) def list_files(self) -> List[str]: return list(self.files.keys())"},{"question":"# Question Scenario: As a junior software engineer at a data analytics company, you are responsible for writing a function to analyze a list of numerical data representing daily temperatures in a month. Your team requires you to implement a function that finds the length of the longest subsequence of consecutive days where each day\'s temperature is increased by exactly one degree compared to the previous day. Task: Write a Python function `longest_consecutive_growth` that finds the length of the longest subsequence of consecutive days with exactly one degree increase. Function Signature: ```python def longest_consecutive_growth(temperatures: list[int]) -> int: ``` Input: - A list of integers, `temperatures` (0 <= len(temperatures) <= 10^3), representing daily temperatures. Output: - An integer representing the length of the longest subsequence of consecutive days with exactly one degree increase. Constraints: - The function should handle edge cases efficiently (e.g., empty list, single element list, no growth period). - No built-in sequence manipulation functions (e.g., itertools) should be used to solve the problem. Example Usage: ```python >>> longest_consecutive_growth([10, 11, 12, 10, 11, 13, 14]) 3 # The subsequence [10, 11, 12] is the longest with exactly one degree increase. >>> longest_consecutive_growth([5, 6, 7, 1, 2, 3, 4, 8]) 4 # The subsequence [1, 2, 3, 4] is the longest with exactly one degree increase. >>> longest_consecutive_growth([10, 10, 10]) 1 # No growth, but each day itself counts as the longest sequence. >>> longest_consecutive_growth([1]) 1 # Only one day, the sequence is of length 1. >>> longest_consecutive_growth([]) 0 # No temperatures, hence no growth. ``` Performance Requirements: - Target a time complexity of (O(n)) and space complexity of (O(1)), where (n) is the length of the list.","solution":"def longest_consecutive_growth(temperatures: list[int]) -> int: if not temperatures: return 0 max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] == temperatures[i-1] + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"File Parsing and Summarization with Exception Handling You have been asked to implement a function that processes a text file containing details of transactions. Each line in the file represents a transaction with the format `transaction_id,transaction_date,amount` where: - `transaction_id` is a unique identifier (integer) - `transaction_date` is the date of the transaction (YYYY-MM-DD) - `amount` is the transaction amount (a float) The function will read the file, validate the transaction data, and return a summary report. # Task Implement the function `summarize_transaction_file(file_path: str) -> dict | None`. This function should handle various edge cases, perform data validation, and summarize the total amount of valid transactions. # Requirements: 1. **Function Signature**: ```python def summarize_transaction_file(file_path: str) -> dict | None: ``` 2. **Input**: - `file_path (str)`: The path to the transaction file. 3. **Output**: - A dictionary containing the `total_amount` of valid transactions and `transaction_count`. If the file is invalid or empty, return `None`. ```python example_output = { \'total_amount\': 1500.75, \'transaction_count\': 10, } ``` 4. **Constraints and Validations**: - Validate the format of each transaction line (3 comma-separated fields). - Validate that `transaction_id` is a positive integer. - Validate that `transaction_date` follows the format YYYY-MM-DD. - Validate that `amount` is a positive float. - Handle potential file read errors gracefully. - Handle empty file scenario gracefully. # Additional Points to Consider: - Each line in the file should be processed individually to avoid memory issues with large files. - Implement exception handling for file operations and invalid data formats. - Write meaningful error messages that could aid in debugging. # Example Usage: ```python report = summarize_transaction_file(\\"transactions.txt\\") if report: print(f\'Total Amount: {report[\\"total_amount\\"]}, Transaction Count: {report[\\"transaction_count\\"]}\') else: print(\\"Invalid file or data\\") ``` # Evaluation Criteria: - Correctness: Ensuring all provided constraints and edge cases are properly handled. - Robustness: Ability to handle file read errors, data format inconsistencies, and empty files. - Efficiency: Efficient file handling and processing. - Code Quality: Maintainable, readable code with appropriate comments and documentation.","solution":"import os from datetime import datetime def summarize_transaction_file(file_path: str) -> dict | None: if not os.path.isfile(file_path): return None total_amount = 0.0 transaction_count = 0 try: with open(file_path, \'r\') as file: for line in file: parts = line.strip().split(\',\') if len(parts) != 3: continue transaction_id, transaction_date, amount = parts # Validate transaction_id if not transaction_id.isdigit() or int(transaction_id) <= 0: continue # Validate transaction_date try: datetime.strptime(transaction_date, \'%Y-%m-%d\') except ValueError: continue # Validate amount try: amount = float(amount) if amount <= 0: continue except ValueError: continue # All validations passed total_amount += amount transaction_count += 1 if transaction_count == 0: return None return { \'total_amount\': total_amount, \'transaction_count\': transaction_count } except IOError: return None"},{"question":"Coding Assessment Question You are tasked with designing a function that monitors the state of a web service and sends an alert through email when the service becomes unavailable. You will build a function based on the provided code snippet. # Function Signature ```python def monitor_service(url: str, email: str, check_interval: int) -> None: ``` # Objective Modify the provided `monitor_web_service` function to create `monitor_service` that: 1. Takes `url`, `email`, and `check_interval` as parameters. 2. Continuously checks the availability of the web service at the specified `url` every `check_interval` seconds. 3. Sends an email alert if the service becomes unavailable. # Input/Output Format * **Input**: * `url` (str): The URL of the web service to be monitored. * `email` (str): The email address where alerts should be sent. * `check_interval` (int): The interval in seconds between each check. * **Output**: None (the function monitors the service and handles sending alerts internally). # Constraints * Use the Python `requests` library for making HTTP requests. * Use the Python `smtplib` library for sending email alerts. * A service is considered unavailable if an HTTP request to the `url` results in a status code of 500 or higher, or if a request raises an exception. * Ensure appropriate exception handling for network-related issues both for checking the service and for sending emails. * Throttle the alert emails such that a maximum of one email is sent every 10 minutes to avoid spamming. # Context This function will be part of a larger monitoring system that ensures web services run smoothly. Proper error detection and notification are crucial for system reliability and timely issue resolution. # Implementation Notes * Use the `time.sleep` function to implement the service check intervals and to throttle email alerts. * Ensure proper and detailed logging of service check failures and alert email deliveries. Design and implement the `monitor_service` function based on the above requirements.","solution":"import time import requests import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart def send_email_alert(to_email, subject, body): from_email = \\"alert@example.com\\" password = \\"password\\" # Placeholder: this should be securely managed msg = MIMEMultipart() msg[\\"From\\"] = from_email msg[\\"To\\"] = to_email msg[\\"Subject\\"] = subject msg.attach(MIMEText(body, \\"plain\\")) text = msg.as_string() try: with smtplib.SMTP(\\"smtp.example.com\\", 587) as server: server.starttls() server.login(from_email, password) server.sendmail(from_email, to_email, text) except Exception as e: print(f\\"Failed to send email alert: {e}\\") def monitor_service(url: str, email: str, check_interval: int) -> None: last_alert_time = 0 alert_throttle_interval = 10 * 60 # 10 minutes while True: try: response = requests.get(url) if response.status_code >= 500: raise Exception(f\\"Service unavailable: {response.status_code}\\") except Exception as e: current_time = time.time() if current_time - last_alert_time > alert_throttle_interval: send_email_alert(email, \\"Service Alert\\", f\\"The service at {url} is down: {e}\\") last_alert_time = current_time time.sleep(check_interval)"},{"question":"**Scenario**: You are a software engineer working for an e-commerce platform. One of your tasks is to process customer transactions represented as a list of integers, where each integer represents the amount of a separate transaction. Due to a system glitch, some transactions have been recorded multiple times. Your job is to find and return the duplicated transaction amounts in the order they first appear in the list. **Task**: Write a Python function to determine which transaction amounts have duplicates and return them in the sequence they first appeared as duplicates. **Function Signature**: ```python def find_duplicates(transactions: list[int]) -> list[int]: pass ``` **Input**: - `transactions` (list[int]): A list of integers representing transaction amounts. **Constraints**: - Each integer in the transactions list is between `1` and `10^6`. - The length of the transactions list is at most `10^5`. **Output**: - A list of integers representing the transaction amounts that are duplicated, in the sequence they first appear as duplicates. **Examples**: ```python >>> find_duplicates([10, 15, 10, 20, 15, 30, 10]) [10, 15] >>> find_duplicates([5, 25, 15, 25, 5, 15, 5]) [25, 5, 15] ``` **Hints**: - Utilize a set or dictionary to track duplicates efficiently. - Consider the order of first appearance when collecting duplicate entries.","solution":"def find_duplicates(transactions: list[int]) -> list[int]: seen = set() duplicates = set() result = [] for transaction in transactions: if transaction in seen: if transaction not in duplicates: duplicates.add(transaction) result.append(transaction) else: seen.add(transaction) return result"},{"question":"# Coding Assessment Question You are developing a string manipulation library for text processing. One of the tasks is to implement a function that checks if a string can be segmented into a sequence of one or more dictionary words. **Task**: Create a function that determines if a given string can be segmented into a space-separated sequence of one or more dictionary words. Assume you are given a dictionary (list) of words. # Requirements and Constraints: 1. **Input Format**: * A string `s` which consists of lowercase letters. * A list of lowercase dictionary words `word_dict`. 2. **Output Format**: * A boolean value indicating whether the string can be segmented into dictionary words. 3. **Constraints**: * The string length should not exceed 1000 characters. * The dictionary list will not contain more than 1000 words. 4. **Performance Requirements**: * Ensure an efficient approach to avoid excessive computation time. * Aim for a solution with a reasonable time complexity for the given constraints. # Example: ```python def can_segment_string(s: str, word_dict: list) -> bool: # Your implementation here # Examples # Test case 1: s1 = \\"leetcode\\" dict1 = [\\"leet\\", \\"code\\"] assert can_segment_string(s1, dict1) == True # Test case 2: s2 = \\"applepenapple\\" dict2 = [\\"apple\\", \\"pen\\"] assert can_segment_string(s2, dict2) == True # Test case 3: s3 = \\"catsandog\\" dict3 = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] assert can_segment_string(s3, dict3) == False # Test case 4: s4 = \\"pineapplepenapple\\" dict4 = [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"] assert can_segment_string(s4, dict4) == True # Test case 5: s5 = \\"abcd\\" dict5 = [\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"] assert can_segment_string(s5, dict5) == True ``` **Additional Task**: Document and explain the various approaches to solving this problem, focusing on the trade-offs between them. Discuss any dynamic programming strategies applied, if any.","solution":"def can_segment_string(s, word_dict): Returns True if the string s can be segmented into one or more dictionary words from word_dict. word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"# Coding Assessment Question A company is managing a warehouse of products and wants to implement a system to automatically restock items that fall below a certain threshold. Your task is to design a function `restock_warehouse` that takes a list of tuples, where each tuple contains the product name, current stock quantity, and restock threshold. The function should return a list of product names that need to be restocked. **Function Signature**: ```python def restock_warehouse(products: list) -> list: pass ``` # Input * `products` - A list of tuples where each tuple is in the format `(str, int, int)` representing: * `product_name` - A string with the name of the product `(1 <= len(product_name) <= 100)`. * `current_stock` - An integer representing the current stock of the product `(0 <= current_stock <= 100000)`. * `threshold` - An integer representing the stock level that triggers restocking `(0 <= threshold <= 100000)`. # Output * A list of strings representing the names of products that need to be restocked. The list should be in the same order as the input. # Example ```python assert restock_warehouse([(\\"laptop\\", 50, 100), (\\"phone\\", 10, 5), (\\"desk\\", 20, 20)]) == [\\"laptop\\"] assert restock_warehouse([(\\"pen\\", 12, 15), (\\"notebook\\", 5, 5), (\\"eraser\\", 0, 1)]) == [\\"pen\\", \\"eraser\\"] assert restock_warehouse([(\\"chair\\", 30, 30), (\\"table\\", 25, 20)]) == [] ``` # Constraints * The function should raise a `ValueError` if any of the input values violate the constraints. * The input list can contain up to 100,000 products. # Performance Requirements * Your solution must run efficiently within the time constraints, especially considering large datasets. * Think carefully about sorting or filtering operations to ensure the solution\'s performance. # Explanation Consider providing comments within your code explaining the steps or approaches taken, especially around: * Validation of input data. * Logic to determine which products need restocking. * Handling of edge cases, such as zero stock and exact threshold values.","solution":"def restock_warehouse(products: list) -> list: Returns a list of product names that need to be restocked based on their current stock and restock threshold. # Validate input for product in products: if not isinstance(product[0], str) or not (1 <= len(product[0]) <= 100): raise ValueError(\\"Invalid product name\\") if not (0 <= product[1] <= 100000): raise ValueError(\\"Invalid current stock value\\") if not (0 <= product[2] <= 100000): raise ValueError(\\"Invalid restock threshold value\\") # Determine products that need to be restocked products_to_restock = [] for product_name, current_stock, threshold in products: if current_stock < threshold: products_to_restock.append(product_name) return products_to_restock"},{"question":"# Array Rotation and Minimum Finder You are developing a module that requires manipulating and analyzing arrays. Your task is to implement two functions: 1. `rotate_array(arr: List[int], k: int) -> List[int]`: This function should rotate the elements of the input list, `arr`, to the right by `k` steps. For example, given `arr = [1, 2, 3, 4, 5]` and `k = 2`, the result should be `[4, 5, 1, 2, 3]`. 2. `find_minimum(arr: List[int]) -> int`: This function should return the minimum value in the list `arr` after it has been rotated. Input - `arr` is a list of integers with length (1 leq text{len(arr)} leq 10^5). - `k` is a non-negative integer (0 ≤ k ≤ 10^6). Output - `rotate_array(arr, k)` should return a list of integers representing the rotated array. - `find_minimum(arr)` should return an integer which is the minimum value in the array. Constraints - The array rotation should be done efficiently without creating a new array of the same size. - Ensure optimal time complexity for the `find_minimum` function given the constraints. Example ```python # Example usage: arr = [3, 8, 9, 7, 6] k = 3 rotated_arr = rotate_array(arr, k) # Expected: [9, 7, 6, 3, 8] minimum_value = find_minimum(rotated_arr) # Expected: 3 print(rotated_arr) print(minimum_value) ``` Implement these functions in Python, ensuring they perform efficiently with large input sizes.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of the input list `arr` to the right by `k` steps. n = len(arr) k = k % n # To handle cases where k is larger than the array length. return arr[-k:] + arr[:-k] def find_minimum(arr: List[int]) -> int: Returns the minimum value in the list `arr`. if not arr: # Guard clause for empty list raise ValueError(\\"Empty array has no minimum value\\") return min(arr)"},{"question":"# Question You are developing a feature for a productivity application that allows users to track their activities across different categories. Your task is to write a function that summarizes the total time spent on each category, given a list of activity records. Write a function `summarize_activities(records: List[Tuple[str, str]]) -> Dict[str, int]` that takes a list of activity records and returns a dictionary summarizing the total time spent on each category. Each activity record is a tuple containing the category name and the time spent in minutes. Example Usage: ```python >>> summarize_activities([(\\"work\\", 120), (\\"exercise\\", 30), (\\"work\\", 180), (\\"leisure\\", 45), (\\"exercise\\", 15)]) {\'work\': 300, \'exercise\': 45, \'leisure\': 45} >>> summarize_activities([(\\"reading\\", 60), (\\"work\\", 90), (\\"exercise\\", 60), (\\"work\\", 60)]) {\'reading\': 60, \'work\': 150, \'exercise\': 60} ``` # Constraints: - Each `record` tuple will contain a non-empty string representing the category name and a positive integer representing the time spent in minutes. - The list of records may be empty, in which case the function should return an empty dictionary. # Instructions: 1. Iterate over the list of activity records. 2. Maintain a dictionary to accumulate the total time spent on each category. 3. If a category appears multiple times, sum up all the time spent on that category. 4. Return the dictionary with total times for each category.","solution":"from typing import List, Tuple, Dict def summarize_activities(records: List[Tuple[str, int]]) -> Dict[str, int]: Summarizes the total time spent on each category. :param records: A list of tuples, where each tuple contains a category name and time spent in minutes :return: A dictionary with the total time spent on each category summary = {} for category, time_spent in records: if category in summary: summary[category] += time_spent else: summary[category] = time_spent return summary"},{"question":"# Question: Implement a Version Control Functionality in Git You have been asked to implement a basic version control simulation that mimics some functionality of Git. This simulation must support basic commands to commit new versions, rollback to previous versions, and retrieve the state of a certain version. Task: Implement the class `VersionControl` that supports the following functionalities: 1. **`commit(state: dict) -> None`**: Saves a new version of the provided state. 2. **`rollback(version: int) -> bool`**: Reverts to the specified version. Returns `True` if successful, otherwise `False` if the version does not exist. 3. **`get_state(version: int) -> dict`**: Retrieves the state of the specified version. Returns an empty dictionary if the version does not exist. # Constraints: - States are represented as dictionaries where keys are strings and values are integers. - Version numbers are zero-indexed. - Rolling back to a previous version means setting the state to exactly how it was during that version. # Class Definition: ```python class VersionControl: def __init__(self): # Initialize version control system pass def commit(self, state: dict) -> None: # Save a new version of the state pass def rollback(self, version: int) -> bool: # Reverts to the specified version pass def get_state(self, version: int) -> dict: # Retrieve the state of the specified version pass ``` # Example: ```python vc = VersionControl() vc.commit({\'file1\': 100, \'file2\': 200}) vc.commit({\'file1\': 110, \'file2\': 210}) vc.commit({\'file1\': 120, \'file2\': 205}) assert vc.get_state(0) == {\'file1\': 100, \'file2\': 200} assert vc.get_state(1) == {\'file1\': 110, \'file2\': 210} assert vc.get_state(2) == {\'file1\': 120, \'file2\': 205} assert vc.rollback(1) == True assert vc.get_state(2) == {} # After rollback, state for version 2 does not exist assert vc.rollback(5) == False # Version 5 does not exist ``` # Performance Note: The optimal implementation should handle the basic operations in constant or near-constant time for most cases.","solution":"class VersionControl: def __init__(self): # Initialize version control system self.versions = [] def commit(self, state: dict) -> None: # Save a new version of the state self.versions.append(state.copy()) def rollback(self, version: int) -> bool: # Reverts to the specified version if 0 <= version < len(self.versions): self.versions = self.versions[:version + 1] return True else: return False def get_state(self, version: int) -> dict: # Retrieve the state of the specified version if 0 <= version < len(self.versions): return self.versions[version].copy() else: return {}"},{"question":"# Question: Find Duplicate Subtrees in a Binary Tree Given the root of a binary tree, your task is to find all duplicate subtrees in the tree. For each duplicate subtree, only return the root node of any one of them. Two trees are considered duplicate if they have the same structure with the same node values. # Function Signature ```python def find_duplicate_subtrees(root: TreeNode) -> List[TreeNode]: ``` # Input * `root`: The root node of the binary tree (TreeNode object). # Output * Return a list of TreeNode, representing the root nodes of all duplicate subtrees. # Constraints * The number of nodes in the tree is in the range [1, 5000]. * -200 <= TreeNode.value <= 200 # TreeNode Definition A TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, value: int = 0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Example ```python tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.right.left = TreeNode(2) tree.right.left.left = TreeNode(4) tree.right.right = TreeNode(4) # Example duplicates = find_duplicate_subtrees(tree) # Visualize the result: [TreeNode(2), TreeNode(4)] sample_output = [node.value for node in duplicates] print(sample_output) # Output: [2, 4] ``` # Note * In the example above, there are two duplicate subtrees: - The subtree rooted at node 2 with structure `2 -> 4`. - The subtree rooted at node 4 with structure `4`. * The function should be implemented to find these duplicate subtrees and return the root nodes of only one instance of each duplicate subtree. This requires an efficient implementation that compares the structure and values of subtrees to identify duplicates.","solution":"class TreeNode: def __init__(self, value: int = 0, left=None, right=None): self.value = value self.left = left self.right = right def find_duplicate_subtrees(root: TreeNode): from collections import defaultdict duplicates = [] subtree_map = defaultdict(int) subtree_roots = [] def serialize(node): if not node: return \'#\' serial = f\\"{node.value},{serialize(node.left)},{serialize(node.right)}\\" if subtree_map[serial] == 1: duplicates.append(node) subtree_map[serial] += 1 return serial serialize(root) return duplicates"},{"question":"# Coding Assessment Question Problem Statement You are given a string containing only lowercase alphabets. Your task is to write a function that permutes the given string and generates all possible distinct permutations of the string using a recursive approach. Function Definition You need to implement the following function: ```python def generate_distinct_permutations(s: str) -> list[str]: Generates all distinct permutations of the given string. :param s: A string containing only lowercase alphabets. :return: A list containing all distinct permutations, each represented as a string. pass ``` Input - A string `s` containing only lowercase alphabets. Output - A list of strings, where each string is a distinct permutation of the input string. Example ```python # Example 1 s = \\"abc\\" print(generate_distinct_permutations(s)) # Output: [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] # Example 2 s = \\"aab\\" print(generate_distinct_permutations(s)) # Output: [\\"aab\\", \\"aba\\", \\"baa\\"] # Example 3 s = \\"a\\" print(generate_distinct_permutations(s)) # Output: [\\"a\\"] ``` Constraints - The string length will not exceed 10. Notes - Ensure that the permutations are unique and returned in lexicographical order. - Handle the case where the string might contain duplicate characters. Edge Cases - Handle the case of a string with repeated characters correctly by ensuring permutations are unique. - Consider scenarios where the string is a single character or an empty string. Performance Requirements - The time complexity of your solution should consider generating all permutations, which is O(n!). - The space complexity should be managed within acceptable limits given the constraints.","solution":"def generate_distinct_permutations(s: str) -> list[str]: Generates all distinct permutations of the given string. :param s: A string containing only lowercase alphabets. :return: A list containing all distinct permutations, each represented as a string. def permute(current, remaining): if not remaining: results.add(current) return for i in range(len(remaining)): permute(current + remaining[i], remaining[:i] + remaining[i+1:]) results = set() permute(\\"\\", s) return sorted(list(results))"},{"question":"# Problem Statement You are required to compute the number of substrings of a given string that contain all unique characters. To achieve this, you must implement an efficient sliding window technique to find all such substrings and count them. # Function Signature ```python def count_unique_substrings(s: str) -> int: ``` # Input - A string `s` consisting of lowercase English letters, where (1 leq text{len}(s) leq 1000). # Output - Return an integer representing the number of substrings with unique characters. # Constraints - (1 leq text{len}(s) leq 1000) - `s` consists of only lowercase English letters. # Example 1. Example 1: - Input: `s = \\"abc\\"` - Output: `6` - Explanation: The substrings are \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\", all containing unique characters. 2. Example 2: - Input: `s = \\"aaa\\"` - Output: `3` - Explanation: The substrings are \\"a\\", \\"a\\", \\"a\\", all containing unique characters. 3. Example 3: - Input: `s = \\"abca\\"` - Output: `9` - Explanation: The substrings are \\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"ab\\", \\"bc\\", \\"ca\\", \\"abc\\", \\"bca\\", containing unique characters. # Additional Notes - Utilize a sliding window technique to handle large input sizes efficiently. - Ensure that the function gracefully handles the edge cases such as empty or very short strings. - Avoid nested loops if possible to keep time complexity optimal. # Testing Include relevant test cases and edge cases to ensure correctness of your implementation. ```python def count_unique_substrings(s: str) -> int: def is_unique(sub: str) -> bool: return len(sub) == len(set(sub)) n = len(s) unique_count = 0 for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) unique_count += 1 return unique_count if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def count_unique_substrings(s: str) -> int: Given a string s, returns the number of substrings with all unique characters. n = len(s) unique_count = 0 for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) unique_count += 1 return unique_count"},{"question":"# Majority Element Finder You are given a list of integers `nums`. Your task is to write a function to find the majority element. The majority element is the element that appears more than `n // 2` times (where `n` is the length of the list). You may assume that the majority element always exists in the list. Function Signature ```python def majority_element(nums: list[int]) -> int: pass ``` Input - `nums`: A list of integers. Output - An integer representing the majority element. Constraints - 1 <= len(nums) <= 10^5 - -10^9 <= nums[i] <= 10^9 Example ```python >>> majority_element([3, 2, 3]) 3 >>> majority_element([2, 2, 1, 1, 1, 2, 2]) 2 ``` Explanation 1. In the first example, the number `3` appears twice in the list `[3, 2, 3]`, which is more than `3 // 2 = 1` times. 2. In the second example, the number `2` appears 4 times in the list `[2, 2, 1, 1, 1, 2, 2]`, which is more than `7 // 2 = 3.5` times. Implement the `majority_element` function to solve this problem. Ensure the solution is efficient and scales well with larger lists.","solution":"def majority_element(nums: list[int]) -> int: Returns the majority element from the list `nums`. The majority element is the element that appears more than n / 2 times where n is the length of the list. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"# Problem Statement You are tasked with implementing a text editor feature that supports a basic undo/redo functionality. The editor needs to keep track of the text content and allow the user to perform operations like inserting text, deleting text, undoing the last operation, and redoing an undone operation. # Requirements 1. **Class Implementation**: Implement the class `TextEditor`: - **Methods**: - `insert_text(position: int, text: str) -> None`: Inserts the given `text` starting at the given `position`. - `delete_text(position: int, length: int) -> None`: Deletes a substring starting at the given `position` with the given `length`. - `undo() -> None`: Undoes the last performed operation. - `redo() -> None`: Redoes the last undone operation. - `get_content() -> str`: Returns the current content of the text editor. 2. **Constraints**: - The `position` passed to the insert and delete methods will always be within the bounds of the current text. - Length of the text to be deleted will always be non-negative and will not exceed the text bounds. - The operations to be tracked for undo/redo include insert and delete operations only. - Calling `undo` should reverse the effect of the last insert or delete operation, and calling `redo` should reapply the last undone operation. 3. **Example**: ```python editor = TextEditor() editor.insert_text(0, \\"Hello\\") editor.insert_text(5, \\" World\\") print(editor.get_content()) # Output: \\"Hello World\\" editor.delete_text(5, 6) print(editor.get_content()) # Output: \\"Hello\\" editor.undo() print(editor.get_content()) # Output: \\"Hello World\\" editor.redo() print(editor.get_content()) # Output: \\"Hello\\" ``` 4. **Edge Cases**: - Multiple undos followed by multiple redos. - Insertions and deletions at the start or end of string. - Operations resulting in empty content. # Hints - Use a stack to keep track of operations for undo/redo functionality. - Consider robust string manipulation techniques when performing insert and delete operations. - Ensure the redo stack is cleared when a new operation is performed after an undo.","solution":"class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] self.redo_stack = [] def insert_text(self, position: int, text: str) -> None: Inserts the given text starting at the specified position. # Record the operation self.history.append((\\"insert\\", position, text)) # Clear the redo stack self.redo_stack.clear() # Perform the insertion self.content = self.content[:position] + text + self.content[position:] def delete_text(self, position: int, length: int) -> None: Deletes a substring of specified length starting at the given position. # Record the operation along with the deleted text deleted_text = self.content[position:position + length] self.history.append((\\"delete\\", position, deleted_text)) # Clear the redo stack self.redo_stack.clear() # Perform the deletion self.content = self.content[:position] + self.content[position + length:] def undo(self) -> None: Undoes the last performed operation. if self.history: last_operation = self.history.pop() op_type, position, text = last_operation if op_type == \\"insert\\": # Undo the insert by deleting the inserted text self.content = self.content[:position] + self.content[position + len(text):] elif op_type == \\"delete\\": # Undo the delete by re-inserting the deleted text self.content = self.content[:position] + text + self.content[position:] # Add the undone operation to the redo stack self.redo_stack.append(last_operation) def redo(self) -> None: Redoes the last undone operation. if self.redo_stack: last_operation = self.redo_stack.pop() op_type, position, text = last_operation if op_type == \\"insert\\": # Redo insert self.content = self.content[:position] + text + self.content[position:] elif op_type == \\"delete\\": # Redo delete self.content = self.content[:position] + self.content[position + len(text):] # Add the redone operation back to the history stack self.history.append(last_operation) def get_content(self) -> str: Returns the current content of the text editor. return self.content"},{"question":"# Coding Question Context You are developing a real-time chat application that continuously receives and sends messages to and from users. The current implementation lacks the capability to handle multiple users efficiently and the message processing is not optimized. Task Write a class `ChatServer` with methods to manage user connections, receive messages, and broadcast them to other users in the chat. Your implementation should include robust error handling and efficient message processing. Class Definition ```python class ChatServer: def __init__(self): pass def add_user(self, username: str) -> None: pass def remove_user(self, username: str) -> None: pass def broadcast_message(self, message: str, from_user: str) -> None: pass def receive_message(self, message: str, from_user: str) -> None: pass ``` Requirements 1. **Methods**: * `__init__`: Initialize the server with necessary data structures to keep track of users and messages. * `add_user`: Adds a new user to the server. * `remove_user`: Removes a user from the server if they exist. * `broadcast_message`: Sends a message from one user to all other connected users. * `receive_message`: Handles the receipt of a message from a user and processes it accordingly. 2. **Constraints**: * Handle user addition and removal dynamically. * Ensure messages are broadcasted to all users except the sender efficiently. * Implement proper error handling for cases such as user not found or message processing errors. * Ensure the solution can handle a high volume of messages and users without degradation in performance. Example: ```python if __name__ == \\"__main__\\": server = ChatServer() server.add_user(\\"alice\\") server.add_user(\\"bob\\") server.receive_message(\\"Hello, everyone!\\", \\"alice\\") ``` Notes: * Implement logging for error conditions and user connection status. * Write clean and readable code with adequate comments to explain your logic. * Use appropriate data structures for efficient user management and message broadcasting.","solution":"class ChatServer: def __init__(self): self.users = {} # Dictionary to keep track of users self.messages = [] # List to keep track of messages for broadcasting/logging def add_user(self, username: str) -> None: if username in self.users: raise ValueError(f\\"User \'{username}\' already exists.\\") self.users[username] = [] def remove_user(self, username: str) -> None: if username not in self.users: raise ValueError(f\\"User \'{username}\' not found.\\") del self.users[username] def broadcast_message(self, message: str, from_user: str) -> None: if from_user not in self.users: raise ValueError(f\\"User \'{from_user}\' not found.\\") for user in self.users: if user != from_user: self.users[user].append(f\\"{from_user}: {message}\\") self.messages.append(f\\"{from_user}: {message}\\") def receive_message(self, message: str, from_user: str) -> None: try: self.broadcast_message(message, from_user) except ValueError as e: print(e)"},{"question":"# String Compression with RLE (Run Length Encoding) Context Run-Length Encoding (RLE) is a simple form of data compression in which consecutive occurrences of the same data value are stored as a single data value and count. This is especially useful for data that contains many such sequences. Problem Statement You need to write a function that performs Run-Length Encoding on a given string. The function should compress the string by replacing consecutive occurrences of the same character with the character followed by the count of its repetitions. Function Signature ```python def run_length_encode(input_string: str) -> str: pass ``` Input - `input_string` (str): A non-empty string consisting of alphanumeric characters. Output - A string representing the Run-Length Encoded version of the input string. Constraints - The input string will have at least one character. - Length of the input string: 1 ≤ |input_string| ≤ 10^6. Example ```python input_string1 = \\"aaabbccccdd\\" input_string2 = \\"aabccbaa\\" input_string3 = \\"zzzzzzzzzzzz\\" assert run_length_encode(input_string1) == \\"a3b2c4d2\\" assert run_length_encode(input_string2) == \\"a2b1c2b1a2\\" assert run_length_encode(input_string3) == \\"z12\\" ``` Notes - Ensure your solution is efficient and can handle long input strings up to a length of 10^6. - The input string will not contain spaces or special characters. - If a character appears only once, it should still be followed by \'1\' in the output. # Solution Here is an implementation of the `run_length_encode` function: ```python def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 encoded_string.append(current_char + str(count)) return \'\'.join(encoded_string) ```","solution":"def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 encoded_string.append(current_char + str(count)) return \'\'.join(encoded_string)"},{"question":"# Coding Question: Roman to Integer Conversion Optimized Background The Roman numeral system uses combinations of letters from the Latin alphabet (I, V, X, L, C, D, M) to represent numbers. A Roman numeral is converted to an integer by summing the individual values, while accounting for specific subtraction cases such as IV (4) and IX (9). Task Optimize the conversion of a Roman numeral to an integer by using a lookup table to convert from Roman characters to their integer values and efficiently handling the subtraction cases. Implement a function `roman_to_integer` that converts a given Roman numeral string into its corresponding integer value. Function Signature ```python def roman_to_integer(s: str) -> int: Convert a Roman numeral string to an integer. :param s: A string representing a Roman numeral. :return: The integer value of the Roman numeral. pass ``` Constraints 1. `1 <= len(s) <= 15` 2. The input string is guaranteed to be a valid Roman numeral representing a number between 1 and 3999. Example ```python >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994 ``` Write a solution that converts the Roman numeral string into the correct integer value, efficiently handling all valid cases.","solution":"def roman_to_integer(s: str) -> int: Convert a Roman numeral string to an integer. :param s: A string representing a Roman numeral. :return: The integer value of the Roman numeral. roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"# Problem: Maximum Sum Subsequence with No Two Adjacent Elements You are given an array of integers. Your task is to find the maximum sum you can obtain by selecting a subsequence of non-adjacent elements from this array. Function Signature ```python def max_sum_non_adjacent(arr: List[int]) -> int: pass ``` # Constraints * The array can have between 1 and 10,000 elements. * Each element in the array is an integer between -10,000 and 10,000. # Input * `arr`: A list of integers. # Output * An integer representing the maximum sum of a subsequence with no two selected elements being adjacent. # Example ```python # Example 1 arr = [3, 2, 5, 10, 7] print(max_sum_non_adjacent(arr)) # Output should be 15 (3 + 10 + 2) # Example 2 arr = [3, 2, 7, 10] print(max_sum_non_adjacent(arr)) # Output should be 13 (3 + 10) # Example 3 arr = [5, 5, 10, 100, 10, 5] print(max_sum_non_adjacent(arr)) # Output should be 110 (5 + 100 + 5) ``` # Explanation - In Example 1, the maximum sum we can achieve by choosing non-adjacent elements is 15, which can be obtained by selecting the numbers 3, 10, and 2. - In Example 2, by selecting the first and last elements (3 and 10), we achieve the maximum sum of 13. - In Example 3, selecting 5, 100, and 5 results in the highest sum of 110. # Performance Expectation * The solution should aim for linear time complexity O(n) considering the constraints and ensure a space complexity of O(1) if possible.","solution":"from typing import List def max_sum_non_adjacent(arr: List[int]) -> int: Returns the maximum sum of non-adjacent elements from the array. if not arr: return 0 if len(arr) == 1: return arr[0] # Initialize two variables to store the max sum including the previous element and excluding the previous element include_prev = arr[0] exclude_prev = 0 for i in range(1, len(arr)): # Current max excluding i (either keeping previous excluding or the one that includes i-1) new_exclude = max(include_prev, exclude_prev) # Current max including i include_prev = exclude_prev + arr[i] # Update exclude_prev to the new value exclude_prev = new_exclude # The answer will be the maximum of include_prev and exclude_prev return max(include_prev, exclude_prev)"},{"question":"# Scenario: A software company wants to implement a text editor\'s \\"word wrap\\" feature. The goal is to format a given string so that no line in the string exceeds a specified maximum width, and words are not broken across lines if there is room to fit them on the same line. If a word itself is longer than the maximum width, it should be placed on a new line as is. # Task: Write a Python function that takes a string and a maximum width, and returns a list of strings where each string represents a line in the word-wrapped format. # Function Signature: ```python def word_wrap(text: str, max_width: int) -> List[str]: pass ``` # Input: - `text` (str): The input string to be word-wrapped. - `max_width` (int): The maximum number of characters allowed per line. # Output: - Returns a list of strings, where each string is a line that does not exceed `max_width` characters. # Constraints: - The input string `text` contains only printable ASCII characters and spaces. - Words in the input string are separated by single spaces. - Words in the input may contain punctuation but will not include double spaces or other whitespace characters. # Example: ```python >>> word_wrap(\\"The quick brown fox jumps over the lazy dog\\", 10) [\'The quick\', \'brown fox\', \'jumps over\', \'the lazy\', \'dog\'] >>> word_wrap(\\"A quick movement of the enemy will jeopardize five gunboats\\", 15) [\'A quick\', \'movement of the\', \'enemy will\', \'jeopardize\', \'five gunboats\'] >>> word_wrap(\\"Supercalifragilisticexpialidocious is a long word\\", 20) [\'Supercalifragilisticexpialidocious\', \'is a long word\'] ``` # Requirements: - Implement the solution to traverse through the string and build lines without exceeding the `max_width`. - Ensure that words are not broken across lines unless a word itself is longer than `max_width`. - Use efficient string manipulation techniques to handle potential edge cases like long words.","solution":"from typing import List def word_wrap(text: str, max_width: int) -> List[str]: if not text: return [] words = text.split() lines = [] current_line = \\"\\" for word in words: # If the word can fit in the current line without exceeding max_width if len(current_line) + len(word) + 1 <= max_width: if current_line: current_line += \\" \\" + word else: current_line = word else: # If the line was not empty, append it to lines if current_line: lines.append(current_line) # Place the long word in the new line if it\'s longer than max_width if len(word) > max_width: lines.append(word) current_line = \\"\\" else: current_line = word # Append the last line if it\'s not empty if current_line: lines.append(current_line) return lines"},{"question":"# Binary Search Tree Implementation - Height Calculation **Context**: You are tasked with implementing a Binary Search Tree (BST) class. A BST is a node-based binary tree data structure where each node has at most two children, referred to as the left child and the right child. For every node, the left subtree\'s keys are less than the node\'s key, and the right subtree\'s keys are greater. # Task: Implement the following methods in a BST class: 1. **Insertion** 2. **Height Calculation** 3. **In-order Traversal** # Requirements: 1. **Insertion**: - Insert a new element into the BST. - **Input**: Integer data. - **Output**: None. 2. **Height Calculation**: - Calculate the height of the BST. - **Output**: Integer representing the height of the tree. 3. **In-order traversal**: - Perform in-order traversal of the BST and return the list of elements. - **Output**: List of integers. # Constraints: 1. Elements inserted will be unique. 2. Operations will be performed in a sequence. 3. Your implementation should handle all edge cases efficiently. # Example: * Insert: 30, 20, 40, 10, 25 * Height: 3 * In-order Traversal: [10, 20, 25, 30, 40] # Guidelines: 1. Ensure your BST adheres to the property where the left subtree has keys less than the parent node, and the right subtree has keys greater. 2. The height of the BST is the number of edges in the longest path from the root to a leaf node. 3. Do not use built-in tree data structures. # Implementation: ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def height(self): return self._height(self.root) def _height(self, node): if not node: return 0 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if not node: return self._in_order_traversal(node.left, result) result.append(node.key) self._in_order_traversal(node.right, result) # Example Usage bst = BinarySearchTree() inputs = [30, 20, 40, 10, 25] for inp in inputs: bst.insert(inp) print(\\"Height of BST:\\", bst.height()) # Output: 3 print(\\"In-order Traversal of BST:\\", bst.in_order_traversal()) # Output: [10, 20, 25, 30, 40] ``` In the provided example code, upon performing insertion operations, the height of the tree and the in-order traversal should match the example scenario provided. Ensure your code passes this test scenario and handles all edge cases mentioned in the guidelines.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def height(self): return self._height(self.root) def _height(self, node): if not node: return 0 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if not node: return self._in_order_traversal(node.left, result) result.append(node.key) self._in_order_traversal(node.right, result) # Example Usage bst = BinarySearchTree() inputs = [30, 20, 40, 10, 25] for inp in inputs: bst.insert(inp) print(\\"Height of BST:\\", bst.height()) # Output: 3 print(\\"In-order Traversal of BST:\\", bst.in_order_traversal()) # Output: [10, 20, 25, 30, 40]"},{"question":"# Question: Implement and Optimize LRU Cache Context You are working on a caching system to optimize data retrieval performance in a web server. The task is to design and implement a Least Recently Used (LRU) Cache that efficiently manages cache hits and evictions. Task 1. Implement a class `LRUCache` that: - Initializes with a positive size capacity. - Contains a `get` method that fetches the value of the key if it exists in the cache, otherwise returns -1. - Contains a `put` method that inserts or updates a value. If the cache exceeds its capacity, it must evict the least frequently used item before inserting the new item. 2. Optimize your solution to perform both `get` and `put` operations in O(1) time complexity. Implementation Constraints - You must use a combination of a hash map and a doubly linked list to achieve the desired time complexity. - Handle edge cases such as inserting into a full cache, and updating existing keys. Input and Output - **Input**: The `LRUCache` class will be initialized with an integer representing the size capacity. - The `get` method takes an integer key and returns the value or -1. - The `put` method takes two integers: a key and a value. Examples ```python # Initialize the cache with a capacity of 2 cache = LRUCache(2) # Cache is: {} cache.put(1, 1) # Cache: {1: 1} cache.put(2, 2) # Cache: {1: 1, 2: 2} assert cache.get(1) == 1 # Returns 1, Cache: {2: 2, 1: 1} cache.put(3, 3) # Evicts key 2, Cache: {1: 1, 3: 3} assert cache.get(2) == -1 # Returns -1 (not found) cache.put(4, 4) # Evicts key 1, Cache: {3: 3, 4: 4} assert cache.get(1) == -1 # Returns -1 (not found) assert cache.get(3) == 3 # Returns 3, Cache: {4: 4, 3: 3} assert cache.get(4) == 4 # Returns 4, Cache: {3: 3, 4: 4} ``` Notes 1. Use a doubly linked list to maintain the order of usage and a hash map to achieve O(1) access and insertion. 2. Make sure to update the order of nodes in the doubly linked list upon each `get` and `put` operation. 3. Ensure proper handling of capacity constraints to evict the least recently used item.","solution":"class Node: def __init__(self, key:int, value:int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) # Using sentinel nodes for simplicity self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key] def _remove(self, node: Node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node): prev_tail = self.tail.prev prev_tail.next = node self.tail.prev = node node.prev = prev_tail node.next = self.tail"},{"question":"**Longest Subarray with Given Sum** You are given an array of integers and a target sum. Modify the existing algorithm to find the longest subarray (contiguous sequence of elements) in the array that sums up to the target sum. Given: - `nums`: A list of integers. - `target_sum`: An integer representing the target sum. # Function Signature ```python def longest_subarray_with_sum(nums: list[int], target_sum: int) -> int: pass ``` # Input - `nums`: A list of integers. `1 <= len(nums) <= 10^4`, and each integer in `nums` is `-10^4 <= nums[i] <= 10^4`. - `target_sum`: An integer that can be positive, negative, or zero. `-10^4 <= target_sum <= 10^4`. # Output - An integer representing the length of the longest subarray that sums to `target_sum`. If no such subarray exists, return 0. # Constraints You must consider the edge cases where: - The `nums` list may be empty, in which case the function should return 0. - The target sum could be zero, which means you need to handle subarrays that sum exactly to zero. - Evaluate the efficiency of your algorithm to ensure it performs well within the input size constraints. # Example ```python >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_with_sum([1, 2, 3], 6) 3 >>> longest_subarray_with_sum([1, 2, 3], 7) 0 ``` # Explanation - In the first example, the subarray `[1, -1, 5, -2]` sums to 3 and has a length of 4, which is the longest. - In the second example, the subarray `[-1, 2]` sums to 1 and has a length of 2. - In the third example, the entire array sums to 6, and thus the length is 3. - In the fourth example, no subarray sums to 7, so the function returns 0. Your task is to implement the `longest_subarray_with_sum` function.","solution":"def longest_subarray_with_sum(nums, target_sum): sum_indices = {0: -1} # Dictionary to store cumulative sums and their earliest index max_length = 0 cumulative_sum = 0 for i in range(len(nums)): cumulative_sum += nums[i] if cumulative_sum - target_sum in sum_indices: max_length = max(max_length, i - sum_indices[cumulative_sum - target_sum]) if cumulative_sum not in sum_indices: sum_indices[cumulative_sum] = i return max_length"},{"question":"Question # Problem: You are provided with two lists of integers representing weights and values of items, and a target integer representing the maximum weight capacity of a knapsack. Your task is to implement a function that determines the maximum total value that can be achieved within the given weight capacity by selecting items optimally (the 0/1 Knapsack Problem). # Function Signature: ```python def max_knapsack_value(weights: list, values: list, max_weight: int) -> int: pass ``` # Input: - `weights`: A list of integers where each integer represents the weight of an item. - `values`: A list of integers where each integer represents the value of the corresponding item in `weights`. - `max_weight`: An integer representing the maximum weight capacity of the knapsack. # Output: - An integer representing the maximum total value that can be achieved without exceeding the weight capacity. # Constraints: - All values in `weights` and `values` will be non-negative integers. - Both `weights` and `values` lists will have equal length (at least one element). - `max_weight` will be a non-negative integer. # Example: ```python weights = [1, 3, 4, 5] values = [1, 4, 5, 7] max_weight = 7 result = max_knapsack_value(weights, values, max_weight) # Expected output: # 9 (selecting items with weights 3 and 4 which gives value 4 + 5 = 9) ``` # Notes: - You should implement a dynamic programming approach to solve this problem efficiently. - Ensure that your function handles edge cases, such as when the maximum weight is 0 or when weights are significantly larger than the maximum weight. - Consider time and space complexity when designing your solution. # Hints: - You can use a 2D array to keep track of the maximum value at each weight capacity up to `max_weight`. - Optimize space usage by using a 1D array if possible.","solution":"def max_knapsack_value(weights: list, values: list, max_weight: int) -> int: n = len(weights) dp = [0] * (max_weight + 1) for i in range(n): for w in range(max_weight, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[max_weight]"},{"question":"# Coding Assessment Question You are developing a simplified Payroll system for a small company. In this system, each employee has a name and a list of work hours logged for a specific week. The payment rate is the same for all employees, which changes over time. The calculation for the weekly payment follows these rules: 1. Each employee earns a fixed hourly wage rate of 20. 2. For every hour worked over 40 hours in a week, they earn 1.5 times the hourly rate. Your task is to write a function to calculate the total weekly payment for each employee, given their name and hours worked. Function Signature ```python def calculate_weekly_payment(employee_name: str, hours_worked: List[int]) -> Dict[str, float]: ``` Input - `employee_name`: A string representing the name of the employee. - `hours_worked`: A list of integers representing the hours worked each day in a specific week. The list will always contain exactly 7 elements (one for each day of the week). Output - Return a dictionary with a single key-value pair where: * The key is the string representing the employee\'s name. * The value is a float representing the total weekly payment calculated based on the rules mentioned. Constraints - Ensure the inputs are valid, i.e., `hours_worked` should always contain exactly 7 non-negative integers. - The total weekly hours will never exceed 100. Example Example 1: ```python calculate_weekly_payment(\\"John Doe\\", [8, 9, 8, 9, 8, 0, 0]) ``` Output: ```python {\\"John Doe\\": 1040.0} ``` Example 2: ```python calculate_weekly_payment(\\"Jane Smith\\", [10, 10, 10, 10, 10, 10, 10]) ``` Output: ```python {\\"Jane Smith\\": 1700.0} ``` In the first example, John worked 8 + 9 + 8 + 9 + 8 + 0 + 0 = 42 hours in the week. Since John worked 2 hours over 40, he gets paid at 1.5 times the hourly rate for those extra 2 hours. Thus, his payment calculation is: ``` (40 * 20) + (2 * 20 * 1.5) = 800 + 60 = 860.0 ``` In the second example, Jane worked 70 hours in the week. For the first 40 hours, she gets paid at the normal rate, and for the remaining 30 hours, she gets paid at 1.5 times the hourly rate. Thus, her payment calculation is: ``` (40 * 20) + (30 * 20 * 1.5) = 800 + 900 = 1700.0 ```","solution":"from typing import List, Dict def calculate_weekly_payment(employee_name: str, hours_worked: List[int]) -> Dict[str, float]: # Validate that hours_worked contains exactly 7 elements if len(hours_worked) != 7: raise ValueError(\\"hours_worked must contain exactly 7 elements\\") # Validate that each element in hours_worked is a non-negative integer if not all(isinstance(hour, int) and hour >= 0 for hour in hours_worked): raise ValueError(\\"hours_worked must contain non-negative integers\\") HOURLY_RATE = 20 OVERTIME_MULTIPLIER = 1.5 REGULAR_HOURS = 40 total_hours = sum(hours_worked) if total_hours <= REGULAR_HOURS: total_payment = total_hours * HOURLY_RATE else: overtime_hours = total_hours - REGULAR_HOURS total_payment = (REGULAR_HOURS * HOURLY_RATE) + (overtime_hours * HOURLY_RATE * OVERTIME_MULTIPLIER) return {employee_name: total_payment}"},{"question":"# Fibonacci Sum Checking Context In numerology and mathematical analysis, the Fibonacci sequence holds significant interest. One of its intriguing properties is the relationship between the sum of its elements and the sequence\'s incremental nature. Testing a number against this characteristic can be a useful exercise in understanding recursion and iterative computation. Problem Statement You are required to implement a function `is_fibonacci_sum` that determines whether a given number can be represented as a sum of any contiguous subsequence of Fibonacci numbers. Your implementation should efficiently compute Fibonacci numbers up to the given number and check if any sum of a contiguous subsequence matches the input number. Function Signature ```python def is_fibonacci_sum(number: int) -> bool: pass ``` Parameters - `number` (int): The non-negative integer to check. Returns - bool: Return `True` if the number can be expressed as a sum of a contiguous subsequence of Fibonacci numbers, otherwise `False`. Constraints - Raise a `ValueError` if `number` is not a non-negative integer. Examples ```python >>> is_fibonacci_sum(10) True # (2 + 3 + 5) >>> is_fibonacci_sum(7) True # (2 + 3 + 2) >>> is_fibonacci_sum(17) False >>> is_fibonacci_sum(13) True # (13 is a Fibonacci number itself) >>> is_fibonacci_sum(0) False ``` Notes - Use an iterative approach to generate Fibonacci numbers up to the given number. - Implement a sliding window technique or a similar method to check for contiguous subsequences efficiently. - Consider edge cases such as very small numbers, numbers that are themselves Fibonacci numbers, and sequences that span the full range of calculated Fibonacci numbers. - Ensure your implementation is optimized for both space and time complexity.","solution":"def is_fibonacci_sum(number: int) -> bool: if not isinstance(number, int) or number < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if number == 0: return False # Generate fibonacci numbers until the largest one less than or equal to `number` fibs = [1, 1] while True: next_fib = fibs[-1] + fibs[-2] if next_fib > number: break fibs.append(next_fib) # Use sliding window technique to find a contiguous subsequence for start in range(len(fibs)): current_sum = 0 for end in range(start, len(fibs)): current_sum += fibs[end] if current_sum == number: return True if current_sum > number: break return False"},{"question":"# Heap Sort Implementation Challenge In this task, you are required to implement the Heap Sort algorithm using a custom min-heap. There are two parts to this task: Part A: CustomMinHeap Implement a custom min-heap class with the following methods: 1. `__init__(self)`: Initializes an empty list to store heap elements. 2. `insert(self, value: int)`: Adds an element to the heap, maintaining the heap property. Raise `OverFlowError` if the heap exceeds 100 elements. 3. `extract_min(self) -> int`: Removes and returns the minimum element from the heap, maintaining the heap property. Raise `UnderFlowError` if the heap is empty. 4. `__str__(self) -> str`: Returns a string representation of the heap. Part B: HeapSort Implement the Heap Sort algorithm using the `CustomMinHeap` class. Implement the following function: 1. `heap_sort(data: List[int]) -> List[int]`: Takes a list of integers and returns a new list with the integers sorted in ascending order using the heap sort algorithm. # Input and Output * Insert and extract operations should ensure the heap properties are maintained. * `heap_sort(data)` accepts a list of integers and returns a sorted list of integers. * Instances of the `CustomMinHeap` should handle standard exceptions for overflow and underflow conditions. # Performance Requirements Ensure that your implementation meets the specified time complexities: * `insert`: O(log n) * `extract_min`: O(log n) * `heap_sort`: O(n log n) # Example ```python # Part A: CustomMinHeap heap = CustomMinHeap() heap.insert(10) heap.insert(20) heap.insert(5) print(heap) # [5, 20, 10] min_elem = heap.extract_min() # 5 print(heap) # [10, 20] # Part B: HeapSort unsorted = [4, 10, 3, 5, 1] sorted_list = heap_sort(unsorted) print(sorted_list) # [1, 3, 4, 5, 10] ``` Implement the class `CustomMinHeap` and the function `heap_sort` with the specified methods and ensure your code passes the above examples.","solution":"class OverFlowError(Exception): pass class UnderFlowError(Exception): pass class CustomMinHeap: def __init__(self): self.heap = [] self.capacity = 100 def __str__(self): return str(self.heap) def insert(self, value: int): if len(self.heap) >= self.capacity: raise OverFlowError(\\"Heap has exceeded the capacity of 100 elements\\") self.heap.append(value) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: if not self.heap: raise UnderFlowError(\\"Heap is empty\\") min_elem = self.heap[0] last_elem = self.heap.pop() if self.heap: self.heap[0] = last_elem self._heapify_down(0) return min_elem def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def heap_sort(data): heap = CustomMinHeap() for value in data: heap.insert(value) sorted_list = [] while heap.heap: sorted_list.append(heap.extract_min()) return sorted_list"},{"question":"# Scenario You are a developer for a logistics company that uses drones to deliver packages. Each drone has a maximum payload capacity, and you need to optimize the number of trips to deliver all packages. # Task Write a function to determine the minimum number of trips needed for a drone to deliver all packages, given the weight limit of the drone and the weights of the packages. # Function Signature ```python def min_drone_trips(weights, max_weight): ``` # Inputs - `weights` (List[int]): A list of integers representing the weights of the packages. - `max_weight` (int): An integer representing the maximum weight capacity of the drone. # Outputs - An integer representing the minimum number of trips required to deliver all packages. # Constraints - `1 <= len(weights) <= 1000` (The number of packages) - `1 <= weights[i] <= max_weight <= 1000` (The weight of individual packages and the drone capacity) # Example Given the packages and drone weight limit: ``` weights = [5, 3, 7, 2, 6] max_weight = 10 ``` The function should output: ``` 3 ``` # Remarks - Ensure to optimize the solution for minimum trips. - Consider different combinations and packing strategies (e.g., greedy strategies) to find the most efficient way to group packages within the drone\'s weight limit. (For the example above, the trips could be: [5, 3, 2], [7], [6])","solution":"def min_drone_trips(weights, max_weight): Given the weights of the packages and the maximum weight that a drone can carry, this function determines the minimum number of trips required for the drone to deliver all the packages. Parameters: weights (List[int]): A list of integers representing the weights of the packages. max_weight (int): An integer representing the maximum weight capacity of the drone. Returns: int: The minimum number of trips required to deliver all the packages. # Sort the package weights in descending order for a more efficient packing weights.sort(reverse=True) trips = 0 while weights: trip_weight = 0 i = 0 while i < len(weights): if trip_weight + weights[i] <= max_weight: trip_weight += weights.pop(i) else: i += 1 trips += 1 return trips"},{"question":"# Question: You are provided with a list of strings and a target substring. Your task is to implement a search function to find all strings in the list that contain the exact target substring at least once, but the search should ignore case (i.e., be case-insensitive). Additionally, the search should offer an option to match whole words only or allow partial matches. **Function Signature**: ```python def search_substring( strings: List[str], target: str, whole_word: bool = False ) -> List[str]: pass ``` **Input**: - `strings`: A list of strings to be searched. - `target`: A string representing the substring to search for. - `whole_word`: A boolean flag indicating whether to match whole words only. Default is `False`. **Output**: - A list of strings containing the target substring according to the search criteria. **Constraints**: - If `whole_word` is `True`, the target substring must match an entire word in the string (words are delimited by whitespace or punctuation). - The function should perform a case-insensitive search. **Example**: ```python >>> search_substring([\'Hello World\', \'worldly matters\', \'The World is Big\'], \'World\', whole_word=True) [\'Hello World\', \'The World is Big\'] >>> search_substring([\'Hello there\', \'There is a world\', \'thEre she goes\', \'here\'], \'there\', whole_word=False) [\'Hello there\', \'There is a world\', \'thEre she goes\'] >>> search_substring([\'Hello\', \'Bye\', \'World\'], \'o\', whole_word=True) [] ``` *Your task is to implement the `search_substring` function according to the described requirements.*","solution":"import re from typing import List def search_substring( strings: List[str], target: str, whole_word: bool = False ) -> List[str]: Searches for strings containing the target substring in a given list of strings. Args: - strings: List of strings to be searched. - target: Substring to search for. - whole_word: Boolean flag indicating whether to match whole words only. Default is False. Returns: - List of strings that contain the target substring according to the search criteria. result = [] target_pattern = re.escape(target) if whole_word: target_pattern = fr\'b{target_pattern}b\' for string in strings: if re.search(target_pattern, string, re.IGNORECASE): result.append(string) return result"},{"question":"# Coding Assessment Question Context As a junior developer, you are required to work with sorted lists of integers. An important functionality that’s frequently required in your tasks is merging multiple sorted lists into a single sorted list efficiently. You need to develop a function that merges these sorted lists. Task You are asked to implement a function called **merge_sorted_lists** that takes in multiple sorted lists and returns a single sorted list containing all the elements from the input lists. # Input and Output Specifications * **Function Signature:** ```python def merge_sorted_lists(*lists: List[int]) -> List[int]: ``` * **Input:** - `lists`: Variable number of sorted lists (each of type List[int]). * **Output:** - The function must return a single sorted list containing all elements from the input lists. # Example *Given the following sorted lists as inputs:* ```python list1 = [1, 3, 5] list2 = [2, 4, 6] list3 = [0, 7, 8] merged_list = merge_sorted_lists(list1, list2, list3) print(merged_list) ``` *Expected Output:* ``` [0, 1, 2, 3, 4, 5, 6, 7, 8] ``` # Constraints 1. All input lists are already sorted in non-decreasing order. 2. The total number of elements across all lists does not exceed 10^6. 3. The function should handle variable number of input lists gracefully. Notes - Aim to implement the function in O(N log k) time complexity where N is the total number of elements across all lists, and k is the number of input lists. - Consider using a min-heap to efficiently merge the lists.","solution":"from heapq import heappop, heappush from typing import List def merge_sorted_lists(*lists: List[int]) -> List[int]: Merges multiple sorted lists into a single sorted list. Args: *lists: Variable number of sorted lists (each of type List[int]). Returns: A single sorted list containing all elements from the input lists. min_heap = [] result = [] # Push the first element of each list along with the index of the list and the index of the element for i, lst in enumerate(lists): if lst: heappush(min_heap, (lst[0], i, 0)) while min_heap: val, list_idx, element_idx = heappop(min_heap) result.append(val) # If there is a next element in the same list, push it to the heap if element_idx + 1 < len(lists[list_idx]): heappush(min_heap, (lists[list_idx][element_idx + 1], list_idx, element_idx + 1)) return result"},{"question":"Matrix Diagonal Traversal Traversing a matrix diagonally provides an interesting way to access its elements. The traversal goes from the top-left corner to the bottom-right corner, moving along each diagonal in the order of their sums (row index + column index). # Objective Implement the function `diagonalTraversal(matrix: List[List[int]]) -> List[int]` to print the elements of a 2D matrix in diagonal order. # Function Definition 1. **diagonalTraversal(matrix: List[List[int]]) -> List[int]:** * **Input:** * `matrix` (List of List of int): A 2D matrix to traverse. * **Output:** (List of int) A list of elements in the order they are traversed diagonally. * **Constraints:** * Each element of the matrix is an integer between -10^5 and 10^5. * The matrix size is `m x n` where `1 <= m, n <= 1000`. # Example Traversals Given the matrix: [ begin{matrix} 1 & 2 & 3 4 & 5 & 6 7 & 8 & 9 end{matrix} ] The diagonal traversal sequence should be: `[1, 2, 4, 7, 5, 3, 6, 8, 9]` Here is a breakdown of the traversal: - Diagonal 0 (1 element): `[1]` - Diagonal 1 (2 elements): `[2, 4]` - Diagonal 2 (2 elements): `[3, 5, 7]` - Diagonal 3 (2 elements): `[6, 8]` - Diagonal 4 (1 element): `[9]` # Example Usage ```python assert diagonalTraversal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [1, 2, 4, 7, 5, 3, 6, 8, 9] assert diagonalTraversal([ [1, 2], [3, 4], [5, 6] ]) == [1, 2, 3, 5, 4, 6] ``` # Implementation Details * Ensure your function handles cases where the matrix has different numbers of rows and columns appropriately. * Maintain the order of traversal as per the diagonal rules. * Use meaningful variable names and clear code structure to enhance readability. # Constraints * Ensure your functions pass all the example tests. * Handle inputs that fit within the given constraints but can be of varying dimensions. * The function should perform efficiently on larger matrices within the given size limits. By adhering to given requirements and handling all edge cases, the `diagonalTraversal` function can provide diagonal traversal sequence effectively, helping in matrix manipulation tasks.","solution":"from typing import List def diagonalTraversal(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] diags = {} for i in range(m): for j in range(n): if i + j not in diags: diags[i + j] = [] diags[i + j].append(matrix[i][j]) for k in sorted(diags.keys()): if k % 2 == 0: result.extend(diags[k][::-1]) else: result.extend(diags[k]) return result # Example Usage: # assert diagonalTraversal([ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ]) == [1, 2, 4, 7, 5, 3, 6, 8, 9]"},{"question":"# Problem Statement You are building a simplified digital book library system that allows users to manage book inventories. Each book can have multiple properties like title, author, genre, and the number of copies available in the library. Users should be able to add new books, update existing books\' properties, remove books, and search for books based on various properties. Implement a class `Library` with the following methods: # Methods: 1. `add_book(self, title: str, author: str, genre: str, copies: int) -> None`: - Adds a new book with the specified properties to the library inventory. - If a book with the same title and author already exists, update the number of copies for that book. 2. `update_book(self, title: str, author: str, **kwargs) -> None`: - Updates the properties (`genre`, `copies`) of an existing book identified by its title and author. - Raises a `ValueError` if the book does not exist in the library. 3. `remove_book(self, title: str, author: str) -> None`: - Removes a book identified by its title and author from the library. - Raises a `ValueError` if the book does not exist in the library. 4. `search_books(self, **kwargs) -> List[Dict[str, Any]]`: - Searches for books based on the provided properties (`title`, `author`, `genre`). - Returns a list of dictionaries representing the books that match the search criteria. - If no books match the criteria, return an empty list. # Example Usage: ```python library = Library() # Adding books to the library library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Fiction\\", 5) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 2) library.add_book(\\"A Brief History of Time\\", \\"Stephen Hawking\\", \\"Science\\", 3) # Updating a book\'s properties library.update_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", genre=\\"Classic Literature\\", copies=4) # Removing a book from the library library.remove_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") # Searching for books books = library.search_books(genre=\\"Fiction\\") print(books) # Output: [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'genre\': \'Classic Literature\', \'copies\': 4}] ``` # Notes: - Book titles and authors are case-sensitive. - Ensure that each method performs the appropriate validation, such as checking whether a book exists before updating or removing it. - The `search_books` method should be flexible enough to handle partial searches (e.g., searching by genre only, title only, etc.).","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title, author, genre, copies): for book in self.books: if book[\'title\'] == title and book[\'author\'] == author: book[\'copies\'] = copies return new_book = { \'title\': title, \'author\': author, \'genre\': genre, \'copies\': copies } self.books.append(new_book) def update_book(self, title, author, **kwargs): for book in self.books: if book[\'title\'] == title and book[\'author\'] == author: for key, value in kwargs.items(): if key in book: book[key] = value return raise ValueError(\\"Book not found\\") def remove_book(self, title, author): for book in self.books: if book[\'title\'] == title and book[\'author\'] == author: self.books.remove(book) return raise ValueError(\\"Book not found\\") def search_books(self, **kwargs): result = [] for book in self.books: match = True for key, value in kwargs.items(): if book.get(key) != value: match = False break if match: result.append(book) return result"},{"question":"# Question: You are to implement a function that calculates a modified version of the atbash cipher algorithm with additional features and constraints. **Objective:** Write two functions, `custom_atbash_encode` and `custom_atbash_decode`. 1. `custom_atbash_encode(plain: str) -> str`: - Converts a given string using the atbash cipher, which shifts each letter to its opposite in the alphabet (i.e., \'a\' becomes \'z\', \'b\' becomes \'y\', etc.). - Ignore non-alphabetic characters while preserving their position in the string. - Spaces should be preserved as is in the output string. 2. `custom_atbash_decode(encoded: str) -> str`: - Reverses the modified atbash cipher transformation to retrieve the original string. - Preserves non-alphabetic characters and spaces in their original positions. **Constraints:** - The input string will contain lowercase alphabetic characters, spaces, and any other characters. - The input for decoding will follow the transformation rules and constraints used in encoding. **Input and Output:** - For `custom_atbash_encode`: - **Input**: A string with lowercase alphabetic characters, spaces, and other non-alphabetic characters. - **Output**: A string where each letter is substituted according to the atbash cipher with non-alphabetic characters left unchanged. - For `custom_atbash_decode`: - **Input**: A string encoded with the modified atbash cipher method. - **Output**: The original string before encoding. **Examples:** 1. **Encoding Example:** ```python >>> custom_atbash_encode(\\"hello world!\\") \'svool dliow!\' ``` 2. **Decoding Example:** ```python >>> custom_atbash_decode(\\"svool dliow!\\") \'hello world!\' ``` **Function Signatures:** ```python def custom_atbash_encode(plain: str) -> str: pass def custom_atbash_decode(encoded: str) -> str: pass ``` **Performance Requirements:** - The solution should handle strings up to 10^6 characters efficiently.","solution":"def custom_atbash_encode(plain: str) -> str: def atbash(char): if \'a\' <= char <= \'z\': return chr(ord(\'z\') - (ord(char) - ord(\'a\'))) return char return \'\'.join(atbash(char) for char in plain) def custom_atbash_decode(encoded: str) -> str: return custom_atbash_encode(encoded)"},{"question":"# Question You have been provided with a **nested dictionary** that represents a hierarchical structure of departments within a company. Each department can have sub-departments and employees. Your task is to implement a function called `find_employee_hierarchy` that, given an employee\'s name, returns the hierarchy of departments the employee belongs to. **Function Signature**: ```python def find_employee_hierarchy(company: Dict[str, Any], employee_name: str) -> List[str]: pass ``` # Instructions 1. **Function Details**: - **Input**: - `company`: A nested dictionary representing the hierarchical structure of the company. - `employee_name`: A string representing the name of the employee to find. - **Output**: Returns a list of strings containing the names of the departments from the top level down to the employee\'s department. If the employee is not found, returns an empty list. - **Constraints**: You may assume that all department names and employee names are unique. 2. **Examples**: ```python # Example 1 company = { \\"Sales\\": { \\"North Region\\": { \\"employees\\": [\\"Alice\\", \\"Bob\\"] }, \\"South Region\\": { \\"employees\\": [\\"Charlie\\"] }, }, \\"Engineering\\": { \\"Backend Team\\": { \\"employees\\": [\\"David\\"], \\"API Team\\": { \\"employees\\": [\\"Eve\\"] } }, \\"Frontend Team\\": { \\"employees\\": [\\"Frank\\"] } } } assert find_employee_hierarchy(company, \\"Alice\\") == [\\"Sales\\", \\"North Region\\"] assert find_employee_hierarchy(company, \\"Eve\\") == [\\"Engineering\\", \\"Backend Team\\", \\"API Team\\"] assert find_employee_hierarchy(company, \\"Frank\\") == [\\"Engineering\\", \\"Frontend Team\\"] assert find_employee_hierarchy(company, \\"John\\") == [] # Example 2 company = { \\"HR\\": { \\"Recruitment\\": { \\"employees\\": [\\"Grace\\"] }, \\"Payroll\\": { \\"employees\\": [\\"Hank\\"] } }, \\"Marketing\\": { \\"Online Marketing\\": { \\"employees\\": [] }, \\"Offline Marketing\\": { \\"employees\\": [\\"Ivy\\"] } } } assert find_employee_hierarchy(company, \\"Grace\\") == [\\"HR\\", \\"Recruitment\\"] assert find_employee_hierarchy(company, \\"Hank\\") == [\\"HR\\", \\"Payroll\\"] assert find_employee_hierarchy(company, \\"Ivy\\") == [\\"Marketing\\", \\"Offline Marketing\\"] assert find_employee_hierarchy(company, \\"Zack\\") == [] ``` 3. **Guidelines**: - Ensure that your implementation can handle deeply nested dictionaries. - Consider using a recursive approach to traverse the hierarchical structure. Implement the `find_employee_hierarchy` function: # Code to Implement ```python def find_employee_hierarchy(company: Dict[str, Any], employee_name: str) -> List[str]: # Your code here pass ```","solution":"def find_employee_hierarchy(company, employee_name): Given an employee\'s name, returns the hierarchy of departments the employee belongs to. :param company: A dictionary representing the company\'s hierarchical structure. :param employee_name: A string representing the name of the employee to find. :return: A list of strings containing the names of the departments from the top level down to the employee\'s department. If the employee is not found, returns an empty list. for department, structure in company.items(): if \'employees\' in structure and employee_name in structure[\'employees\']: return [department] if isinstance(structure, dict): sub_hierarchy = find_employee_hierarchy(structure, employee_name) if sub_hierarchy: return [department] + sub_hierarchy return []"},{"question":"# Fibonacci Sequence - Recursive vs Iterative In this task, you are required to implement functions to calculate the nth Fibonacci number using both recursive and iterative approaches. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, starting from 0 and 1. That is: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n geq 2 ) Your task is to write the following functions: 1. `fibonacci_recursive(n: int) -> int`: This function calculates the nth Fibonacci number using recursion. - **Input**: - `n` (int): The position in the Fibonacci sequence (where ( n ) is a non-negative integer). - **Output**: - Returns the nth Fibonacci number as an integer. - **Constraint**: - The function should raise a `ValueError` if `n` is negative. 2. `fibonacci_iterative(n: int) -> int`: This function calculates the nth Fibonacci number using an iterative approach. - **Input**: - `n` (int): The position in the Fibonacci sequence (where ( n ) is a non-negative integer). - **Output**: - Returns the nth Fibonacci number as an integer. - **Constraint**: - The function should raise a `ValueError` if `n` is negative. # Example ```python >>> fibonacci_recursive(10) 55 >>> fibonacci_recursive(0) 0 >>> fibonacci_recursive(-5) Traceback (most recent call last): ... ValueError: Position in the Fibonacci sequence can\'t be negative. >>> fibonacci_iterative(10) 55 >>> fibonacci_iterative(0) 0 >>> fibonacci_iterative(-5) Traceback (most recent call last): ... ValueError: Position in the Fibonacci sequence can\'t be negative. ``` # Constraints - Ensure your code handles larger values of `n` efficiently in the case of the iterative approach. - For `fibonacci_recursive`, consider memoization to handle larger values of `n` more efficiently. # Performance - For `fibonacci_iterative`, the time complexity should be (O(n)) and space complexity should be (O(1)). - For `fibonacci_recursive`, the time complexity without memoization is (O(2^n)), but with memoization, it should be (O(n)), and space complexity should be (O(n)) due to the call stack. Good luck, and ensure to test edge cases such as zero and negative values!","solution":"def fibonacci_recursive(n, memo = None): Calculates the nth Fibonacci number using recursion with memoization. Params: n (int): Position in the Fibonacci sequence (non-negative integer). Returns: int: The nth Fibonacci number. Raises: ValueError: If the input n is negative. if n < 0: raise ValueError(\\"Position in the Fibonacci sequence can\'t be negative.\\") if memo is None: memo = {} if n in memo: return memo[n] if n in {0, 1}: memo[n] = n else: memo[n] = fibonacci_recursive(n-1, memo) + fibonacci_recursive(n-2, memo) return memo[n] def fibonacci_iterative(n): Calculates the nth Fibonacci number using iterative approach. Params: n (int): Position in the Fibonacci sequence (non-negative integer). Returns: int: The nth Fibonacci number. Raises: ValueError: If the input n is negative. if n < 0: raise ValueError(\\"Position in the Fibonacci sequence can\'t be negative.\\") if n in {0, 1}: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Scenario A data analyst needs to frequently find the median of a dynamically changing list of numbers. They want to implement a dynamic list structure that can efficiently support adding new numbers and retrieving the median at any point in time. The analyst considers using two heaps to balance the numbers and streamline the process. # Task Write a Python class `DynamicMedian` that supports the following operations: - `add_number(num: int) -> None`: Adds a number to the data structure. - `get_median() -> float`: Returns the median of the current number set. # Requirements - Use two heaps (a max-heap for the lower half and a min-heap for the upper half) to maintain balance. - Maintain efficient operations for both adding a new number and retrieving the median. - The median is the middle number if the list has an odd number of elements, or the average of the two middle numbers if the list has an even number of elements. # Input and Output - **Input**: For `add_number`, a single integer `num` where -10^6 <= num <= 10^6. For `get_median`, no input. - **Output**: For `get_median`, the median of the current list of numbers as a float. # Constraints - The methods `add_number` and `get_median` should each run in O(log n) time where n is the number of elements added so far. # Examples ```python >>> dm = DynamicMedian() >>> dm.add_number(1) >>> dm.add_number(2) >>> dm.get_median() 1.5 >>> dm.add_number(3) >>> dm.get_median() 2 >>> dm.add_number(4) >>> dm.get_median() 2.5 ``` **Notes** - You may use the `heapq` module for implementing the min-heap. The max-heap can be simulated using a min-heap by inverting the values inserted into it. Create a Python class `DynamicMedian` following the described specifications.","solution":"import heapq class DynamicMedian: def __init__(self): self.min_heap = [] # min heap for the larger half self.max_heap = [] # max heap for the smaller half def add_number(self, num: int): if not self.max_heap or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) # Rebalance heaps if necessary if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def get_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Problem Statement For this coding assessment, write a function `find_busiest_period` that determines the busiest time period in terms of visitor numbers at a venue. You are given a list of logs where each log is a tuple containing three elements: a Unix timestamp, an integer count, and a string type (\\"enter\\" or \\"exit\\"). The incoming logs are sorted in ascending order of timestamps. The function must return the timestamp at which the venue was at its busiest (i.e., had the most visitors present). # Requirements * The function should raise a ValueError with the message \\"Invalid log entry\\" if a log entry contains an unsupported type. * The function must retain the order of the input list elements. * The function should not mutate the input list. * The function must execute with a time complexity of O(n). # Input * A list of tuples `[ (timestamp: int, count: int, type: str) ]` representing the entry or exit logs of the venue. # Output * An integer representing the timestamp at which the venue had the most visitors present. # Function Signature ```python def find_busiest_period(logs: list[tuple[int, int, str]]) -> int: pass ``` # Example ```python >>> find_busiest_period([(1578326400, 10, \'enter\'), (1578327300, 5, \'exit\'), (1578328200, 15, \'enter\'), (1578329100, 10, \'exit\')]) 1578328200 >>> find_busiest_period([(1578326400, 50, \'enter\'), (1578327300, 30, \'exit\'), (1578328200, 25, \'enter\'), (1578329100, 20, \'enter\'), (1578329400, 30, \'exit\')]) 1578329100 >>> find_busiest_period([(1620000000, 5, \'invalid\')]) Traceback (most recent call last): ... ValueError: Invalid log entry ``` # Constraints * The list can contain at most 10^5 elements. * The timestamp is a positive integer representing seconds since the Unix epoch. * The count is a positive integer.","solution":"def find_busiest_period(logs): Finds the timestamp at which the venue was at its busiest. Parameters: logs (list): A list of tuples where each tuple contains (timestamp, count, type) indicating visitors entering or exiting. Returns: int: The Unix timestamp at which the venue had the most visitors present. if not logs: raise ValueError(\\"Logs list is empty\\") current_visitors = 0 max_visitors = 0 busiest_timestamp = None last_timestamp = None for timestamp, count, log_type in logs: if log_type == \'enter\': current_visitors += count elif log_type == \'exit\': current_visitors -= count else: raise ValueError(\\"Invalid log entry\\") if current_visitors > max_visitors: max_visitors = current_visitors busiest_timestamp = timestamp return busiest_timestamp"},{"question":"# Knapsack Problem (Dynamic Programming) Context: You are given a list of items, each with a weight and a value, along with a maximum weight capacity of a knapsack. Your task is to determine the maximum value that can be achieved by selecting a subset of the items such that the total weight does not exceed the given capacity. Input: The input consists of: 1. An integer `W`, representing the maximum weight capacity of the knapsack. 2. A list of tuples, where each tuple consists of two integers: the weight and value of an item. Output: Return a single integer, representing the maximum value that can be achieved within the given weight capacity. Requirements: * Implement the solution using dynamic programming. * The function should be efficient in terms of both time and space complexity constraints typical for the problem. Constraints: * The number of items can be up to 100. * The maximum weight capacity can be up to 1000. * All weights and values are guaranteed to be positive integers. Example: Given the inputs: ``` W = 10 items = [(2, 3), (3, 4), (4, 5), (5, 8)] ``` The output should be: ``` 11 ``` Explanation: The optimal subset of items is the ones with weights 2 and 3, and 5 (total weight = 2 + 3 + 5 = 10), yielding the maximum value of 3 + 4 + 8 = 15. # Task: Implement the function `knapsack(W: int, items: List[Tuple[int, int]]) -> int` which takes the maximum capacity and the list of items, and returns the maximum value achievable. ```python from typing import List, Tuple def knapsack(W: int, items: List[Tuple[int, int]]) -> int: # Your implementation goes here pass # Example Usage: # assert knapsack(10, [(2, 3), (3, 4), (4, 5), (5, 8)]) == 11 ```","solution":"from typing import List, Tuple def knapsack(W: int, items: List[Tuple[int, int]]) -> int: # Create a 1D DP array to save space dp = [0] * (W + 1) for weight, value in items: # Traverse backwards from W to weight for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[W]"},{"question":"# Coding Question: Implement a Hybrid Sorting Algorithm with Dynamic Strategy **Context**: Hybrid sorting algorithms combine multiple sorting techniques to leverage the strengths of each. One such hybrid algorithm is Timsort, which combines merge sort and insertion sort. It is designed to perform well on many kinds of real-world data. **Challenge**: Your task is to implement a custom hybrid sorting algorithm named `DynamicSort` that dynamically chooses between quicksort, mergesort, and insertion sort based on the size and characteristics of the data. **Function Signature**: ```python class DynamicSort: def __init__(self, threshold: int) -> None: pass def sort(self, data: list) -> list: pass ``` **Detailed Requirements**: 1. **Initialization**: The constructor should accept one parameter: - `threshold`: An integer that determines when the algorithm should switch from quicksort to insertion sort for small subarrays. For subarrays larger than this threshold, mergesort should be used for combining the sorted results. 2. **Sort Function**: - You should implement the `sort` method to sort the input list `data` which contains integers. - The method needs to dynamically choose between the different sorting algorithms: - Use quicksort as the primary sorting technique. - Switch to insertion sort when dealing with subarrays smaller than the threshold. - Implement mergesort logic to merge sorted subarrays. 3. **Efficiency**: - The hybrid sort algorithm should offer O(n log n) complexity for large input sizes, leveraging the speed of quicksort for partitioning and the efficiency of insertion sort for small arrays. - Ensure that the memory usage for mergesort is adequately managed to handle large datasets. **Constraints**: - The input list `data` can be empty, and it can have up to 1,000,000 elements. - All the elements in `data` are integers. **Performance Requirements**: - The `sort` method should complete in a reasonable time for input sizes up to 1,000,000 elements. - The hybrid approach should be efficiently balanced to ensure the overhead of switching algorithms does not degrade performance. **Example**: ```python >>> sorter = DynamicSort(threshold=10) >>> unsorted_data = [34, 7, 23, 32, 5, 62, 32, 7, 9] >>> sorted_data = sorter.sort(unsorted_data) >>> print(sorted_data) [5, 7, 7, 9, 23, 32, 32, 34, 62] ``` Note: - Ensure to appropriately handle edge cases such as empty input lists. - The switching logic should be clearly defined to maintain the sorting efficiency.","solution":"class DynamicSort: def __init__(self, threshold: int) -> None: self.threshold = threshold def sort(self, data: list) -> list: if len(data) <= 1: return data self._quicksort(data, 0, len(data) - 1) return data def _quicksort(self, data, low, high): if low < high: if high - low < self.threshold: self._insertion_sort(data, low, high) else: pivot_index = self._partition(data, low, high) self._quicksort(data, low, pivot_index - 1) self._quicksort(data, pivot_index + 1, high) def _partition(self, data, low, high): pivot = data[high] i = low - 1 for j in range(low, high): if data[j] <= pivot: i += 1 data[i], data[j] = data[j], data[i] data[i + 1], data[high] = data[high], data[i + 1] return i + 1 def _insertion_sort(self, data, low, high): for i in range(low + 1, high + 1): key = data[i] j = i - 1 while j >= low and key < data[j]: data[j + 1] = data[j] j -= 1 data[j + 1] = key"},{"question":"# Coding Assessment: Genetic Algorithm for Traveling Salesperson Problem (TSP) Problem Statement You are provided with an implementation of a Genetic Algorithm for solving a simple optimization problem. Your task is to adapt and extend this implementation to solve the Traveling Salesperson Problem (TSP). Objectives 1. Implement a `genetic_algorithm_tsp` function that finds an approximate solution to the TSP. 2. Develop a `TSPProblem` class with appropriate methods to represent the problem. 3. Your implementation should use genetic algorithm techniques such as selection, crossover, and mutation to evolve potential solutions. Input - **Cities**: A list of coordinates representing the cities to visit. - **Population Size**: The number of solutions in the population. - **Generations**: The number of generations to evolve the population. - **Mutation Rate**: The probability of mutating a solution during reproduction. - **Tournament Size**: The number of solutions used in each selection tournament. Output - The best solution found, represented as an ordered list of city indices and the total distance of the tour. # Constraints 1. **Class Implementation**: Your `TSPProblem` class must have the following methods: - `__init__(self, cities: List[Tuple[float, float]])` - `initial_population(self, population_size: int) -> List[List[int]]` - `fitness(self, solution: List[int]) -> float` - `selection(self, population, fitnesses, tournament_size: int) -> List[int]` - `crossover(self, parent1: List[int], parent2: List[int]) -> List[int]` - `mutate(self, solution: List[int], mutation_rate: float) -> List[int]` 2. **Genetic Algorithm Implementation**: Your `genetic_algorithm_tsp` function must have the following signature: ```python def genetic_algorithm_tsp( tsp_prob, population_size: int, generations: int, mutation_rate: float, tournament_size: int ) -> Tuple[List[int], float]: ``` 3. **Performance Requirement**: Your implementation should efficiently find an approximate solution within a reasonable time frame for typical inputs. # Example Usage ```python # Define cities cities = [(0, 0), (1, 3), (4, 3), (6, 1)] # Create TSP problem instance tsp_problem = TSPProblem(cities=cities) # Perform genetic algorithm best_solution, best_distance = genetic_algorithm_tsp( tsp_prob=tsp_problem, population_size=50, generations=100, mutation_rate=0.01, tournament_size=5 ) print(f\\"Optimal tour: {best_solution}, Total distance: {best_distance}\\") ``` Ensure your function is well-tested with various sets of cities to validate its correctness and performance.","solution":"import random import math from typing import List, Tuple class TSPProblem: def __init__(self, cities: List[Tuple[float, float]]): self.cities = cities def initial_population(self, population_size: int) -> List[List[int]]: population = [] for _ in range(population_size): individual = list(range(len(self.cities))) random.shuffle(individual) population.append(individual) return population def fitness(self, solution: List[int]) -> float: distance = 0.0 for i in range(len(solution)): city1 = self.cities[solution[i]] city2 = self.cities[solution[(i + 1) % len(solution)]] distance += math.dist(city1, city2) return distance def selection(self, population, fitnesses, tournament_size: int) -> List[int]: selected = random.choices( population, weights=[1.0 / fitness for fitness in fitnesses], k=tournament_size ) return min(selected, key=lambda ind: self.fitness(ind)) def crossover(self, parent1: List[int], parent2: List[int]) -> List[int]: start, end = sorted(random.sample(range(len(parent1)), 2)) child_p1 = parent1[start:end + 1] child_p2 = [city for city in parent2 if city not in child_p1] return child_p2[:start] + child_p1 + child_p2[start:] def mutate(self, solution: List[int], mutation_rate: float) -> List[int]: for i in range(len(solution)): if random.random() < mutation_rate: j = random.randint(0, len(solution) - 1) solution[i], solution[j] = solution[j], solution[i] return solution def genetic_algorithm_tsp( tsp_prob: TSPProblem, population_size: int, generations: int, mutation_rate: float, tournament_size: int ) -> Tuple[List[int], float]: population = tsp_prob.initial_population(population_size) for generation in range(generations): fitnesses = [tsp_prob.fitness(individual) for individual in population] new_population = [] for _ in range(population_size): parent1 = tsp_prob.selection(population, fitnesses, tournament_size) parent2 = tsp_prob.selection(population, fitnesses, tournament_size) child = tsp_prob.crossover(parent1, parent2) child = tsp_prob.mutate(child, mutation_rate) new_population.append(child) population = new_population best_solution = min(population, key=lambda ind: tsp_prob.fitness(ind)) best_distance = tsp_prob.fitness(best_solution) return best_solution, best_distance"},{"question":"# Question: Graph Pathfinding Using Depth-First Search (DFS) Context You are required to implement a graph traversal algorithm to find a path between two nodes in an unweighted, directed graph. This problem will focus on building a `Graph` class that supports adding edges and uses Depth-First Search (DFS) to determine if a path exists between two given nodes. Task Implement the following methods within a Python class `Graph`: 1. `__init__(self)`: - Initialize an empty adjacency list to represent the graph. 2. `add_edge(self, start_node, end_node)`: - Add a directed edge from `start_node` to `end_node` in the graph. - Input: - `start_node`: Integer, the starting node of the directed edge. - `end_node`: Integer, the ending node of the directed edge. - Output: None. 3. `has_path_dfs(self, source, target)`: - Determine if a path exists from the `source` node to the `target` node using Depth-First Search (DFS). - Input: - `source`: Integer, the source node. - `target`: Integer, the target node. - Output: Boolean, `True` if a path exists from `source` to `target`, otherwise `False`. Constraints - The graph contains `n` nodes, numbered from `0` to `n-1`. - Assume nodes are added implicitly when edges are added. - The graph can have up to 1000 nodes with any number of edges. - Handle edge cases like when the source or target node does not exist in the graph. # Solution Outline ```python class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, start_node, end_node): if start_node not in self.adjacency_list: self.adjacency_list[start_node] = [] self.adjacency_list[start_node].append(end_node) def has_path_dfs(self, source, target): if source not in self.adjacency_list or target not in self.adjacency_list: return False visited = set() def dfs(current): if current == target: return True visited.add(current) for neighbor in self.adjacency_list.get(current, []): if neighbor not in visited: if dfs(neighbor): return True return False return dfs(source) # Sample usage: graph = Graph() graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) print(graph.has_path_dfs(1, 3)) # True print(graph.has_path_dfs(3, 1)) # False ```","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, start_node, end_node): if start_node not in self.adjacency_list: self.adjacency_list[start_node] = [] self.adjacency_list[start_node].append(end_node) def has_path_dfs(self, source, target): if source not in self.adjacency_list: return False visited = set() def dfs(current): if current == target: return True visited.add(current) for neighbor in self.adjacency_list.get(current, []): if neighbor not in visited: if dfs(neighbor): return True return False return dfs(source) # Sample usage: graph = Graph() graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) print(graph.has_path_dfs(1, 3)) # True print(graph.has_path_dfs(3, 1)) # False"},{"question":"# Coding Assessment Question You are provided with a function that calculates the factorial of a given non-negative integer using both iterative and recursive methods. Your task is to enhance the provided functions by adding input validation and optimizing the recursive implementation to avoid stack overflow for large input values. Your Task Write enhanced versions of the provided functions (`factorial_iterative`, `factorial_recursive`) that incorporate input validation and improve the recursive version to use memoization for handling large inputs efficiently. Raise appropriate exceptions for invalid input cases. # Function Specifications `factorial_iterative` - **Input**: `n` (an integer) - **Output**: `int` (factorial of `n`) - **Exceptions**: - Raise `ValueError` if the input is a negative integer. `factorial_recursive` - **Input**: `n` (an integer) - **Output**: `int` (factorial of `n`) - **Exceptions**: - Raise `ValueError` if the input is a negative integer. # Implementation Details 1. **Iterative Approach**: - Enhance the function by adding a check for negative input values, raising a `ValueError` if the input is negative. 2. **Recursive Approach with Memoization**: - Use a dictionary to store previously calculated results to avoid redundant calculations and reduce the likelihood of stack overflow errors. - Ensure the function includes validation to raise a `ValueError` for negative inputs. # Example Usage ```python try: result_iterative = factorial_iterative(5) print(result_iterative) # Expected Output: 120 result_recursive = factorial_recursive(5) print(result_recursive) # Expected Output: 120 result_iterative_large = factorial_iterative(20) print(result_iterative_large) # Expected Output: 2432902008176640000 result_recursive_large = factorial_recursive(20) print(result_recursive_large) # Expected Output: 2432902008176640000 result_iterative_negative = factorial_iterative(-5) # Expected to raise ValueError except ValueError as e: print(e) ``` # Constraints - Input values are integers. - Ensure to handle and validate both small and large input values, as well as negative inputs. Good luck, and ensure your functions are thoroughly tested with both correct and incorrect inputs!","solution":"def factorial_iterative(n): Calculate the factorial of n using an iterative approach. Raise ValueError for negative input. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = 1 for i in range(2, n + 1): result *= i return result def factorial_recursive(n, memo={}): Calculate the factorial of n using a recursive approach with memoization. Raise ValueError for negative input. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n in memo: return memo[n] if n == 0 or n == 1: return 1 memo[n] = n * factorial_recursive(n - 1, memo) return memo[n]"},{"question":"# DNA Sequence Alignment Using Dynamic Programming Background Scenario In computational biology, one of the common problems is aligning DNA sequences to identify regions of similarity. The Needleman-Wunsch algorithm is a well-known dynamic programming method for aligning sequences optimally. You are tasked with implementing this algorithm to find the optimal alignment score between two DNA sequences. Function Description Implement the function: 1. `needleman_wunsch(seq1: str, seq2: str) -> int`: This function takes two DNA sequences and returns the optimal alignment score. Expected Input and Output: 1. `needleman_wunsch(seq1: str, seq2: str) -> int` * **Input**: Two strings `seq1` and `seq2` each of length `n` and `m`, respectively. * **Output**: An integer representing the optimal alignment score between the two sequences. Constraints: 1. Lengths of `seq1` and `seq2` are between 1 and 1000. 2. Sequences consist of the characters \'A\', \'C\', \'G\', and \'T\' only. 3. Use the following scoring scheme: * Match: +1 * Mismatch: -1 * Gap: -1 Specification: ```python def needleman_wunsch(seq1: str, seq2: str) -> int: Computes the optimal alignment score between two DNA sequences using the Needleman-Wunsch algorithm. Parameters: seq1 (str): The first DNA sequence. seq2 (str): The second DNA sequence. Returns: int: The optimal alignment score between the two sequences. n = len(seq1) m = len(seq2) # Initialize the scoring matrix with zeros score_matrix = [[0 for _ in range(m+1)] for _ in range(n+1)] # Fill the first row and first column with gap penalties for i in range(1, n+1): score_matrix[i][0] = score_matrix[i-1][0] - 1 for j in range(1, m+1): score_matrix[0][j] = score_matrix[0][j-1] - 1 # Fill in the rest of the score matrix for i in range(1, n+1): for j in range(1, m+1): match = score_matrix[i-1][j-1] + (1 if seq1[i-1] == seq2[j-1] else -1) delete = score_matrix[i-1][j] - 1 insert = score_matrix[i][j-1] - 1 score_matrix[i][j] = max(match, delete, insert) # The optimal alignment score is in the bottom-right cell of the matrix return score_matrix[n][m] ``` Example: ```python seq1 = \\"GATTACA\\" seq2 = \\"GCATGCU\\" print(needleman_wunsch(seq1, seq2)) # Output: 0 seq1 = \\"TTAGGG\\" seq2 = \\"TAGG\\" print(needleman_wunsch(seq1, seq2)) # Output: 2 ```","solution":"def needleman_wunsch(seq1: str, seq2: str) -> int: Computes the optimal alignment score between two DNA sequences using the Needleman-Wunsch algorithm. Parameters: seq1 (str): The first DNA sequence. seq2 (str): The second DNA sequence. Returns: int: The optimal alignment score between the two sequences. n = len(seq1) m = len(seq2) # Initialize the scoring matrix with zeros score_matrix = [[0 for _ in range(m+1)] for _ in range(n+1)] # Fill the first row and first column with gap penalties for i in range(1, n+1): score_matrix[i][0] = score_matrix[i-1][0] - 1 for j in range(1, m+1): score_matrix[0][j] = score_matrix[0][j-1] - 1 # Fill in the rest of the score matrix for i in range(1, n+1): for j in range(1, m+1): match = score_matrix[i-1][j-1] + (1 if seq1[i-1] == seq2[j-1] else -1) delete = score_matrix[i-1][j] - 1 insert = score_matrix[i][j-1] - 1 score_matrix[i][j] = max(match, delete, insert) # The optimal alignment score is in the bottom-right cell of the matrix return score_matrix[n][m]"},{"question":"**Scenario**: You are tasked with developing a simple contacts manager for a phonebook application. The application must handle adding, removing, updating, and searching for contacts by their phone numbers or names. We will utilize classes and dictionaries to manage the contacts. # Task 1. **Contact Class**: - Implement a `Contact` class with the following attributes: - `name` (string): The name of the contact. - `phone` (string): The phone number of the contact. - The `__init__` method should initialize both attributes. 2. **Phonebook Class**: - Implement a `Phonebook` class with the following methods: - `add_contact(contact)`: - Adds a `Contact` object to the phonebook. - If a contact with the same phone number already exists, raise a `ValueError` with an appropriate message. - `remove_contact(phone)`: - Removes the contact with the given phone number. - If no contact with the specified phone number exists, raise a `ValueError`. - `update_contact(phone, new_name)`: - Updates the contact\'s name with the given phone number. - If no contact with the specified phone number exists, raise a `ValueError`. - `search_by_name(name)`: - Searches for contacts by their name. - Returns a list of all contacts\' phone numbers (strings) that match the name. - `search_by_phone(phone)`: - Searches for contacts by their phone number. - Returns the name (string) of the contact with the given phone number. - If no contact with the specified phone number exists, raise a `ValueError`. # Input and Output Format - **Input**: * For `add_contact`: param `contact` (Contact object) * For `remove_contact`: param `phone` (string) * For `update_contact`: params `phone` (string), `new_name` (string) * For `search_by_name`: param `name` (string) * For `search_by_phone`: param `phone` (string) - **Output**: * For `add_contact`, `remove_contact`, and `update_contact`: None * For `search_by_name`: return a list of phone numbers (list of strings). * For `search_by_phone`: return a contact name (string). # Constraints - The phone number will always be a non-empty string with digits. - The name will always be a non-empty string. - Operations will be performed in any order. # Example ```python class Contact: def __init__(self, name, phone): self.name = name self.phone = phone class Phonebook: def __init__(self): self.contacts = {} def add_contact(self, contact): if contact.phone in self.contacts: raise ValueError(\\"Contact with this phone number already exists.\\") self.contacts[contact.phone] = contact.name def remove_contact(self, phone): if phone not in self.contacts: raise ValueError(\\"Contact with this phone number does not exist.\\") del self.contacts[phone] def update_contact(self, phone, new_name): if phone not in self.contacts: raise ValueError(\\"Contact with this phone number does not exist.\\") self.contacts[phone] = new_name def search_by_name(self, name): return [phone for phone, cname in self.contacts.items() if cname == name] def search_by_phone(self, phone): if phone not in self.contacts: raise ValueError(\\"Contact with this phone number does not exist.\\") return self.contacts[phone] # Usage Example phonebook = Phonebook() c1 = Contact(\\"Alice\\", \\"12345\\") c2 = Contact(\\"Bob\\", \\"67890\\") phonebook.add_contact(c1) phonebook.add_contact(c2) print(phonebook.search_by_phone(\\"12345\\")) # Output: \\"Alice\\" print(phonebook.search_by_name(\\"Bob\\")) # Output: [\\"67890\\"] try: phonebook.add_contact(c1) except ValueError as e: print(e) # Outputs: \\"Contact with this phone number already exists.\\" phonebook.update_contact(\\"12345\\", \\"Alicia\\") print(phonebook.search_by_phone(\\"12345\\")) # Output: \\"Alicia\\" phonebook.remove_contact(\\"67890\\") try: phonebook.search_by_phone(\\"67890\\") except ValueError as e: print(e) # Outputs: \\"Contact with this phone number does not exist.\\" ```","solution":"class Contact: def __init__(self, name, phone): self.name = name self.phone = phone class Phonebook: def __init__(self): self.contacts = {} def add_contact(self, contact): if contact.phone in self.contacts: raise ValueError(\\"Contact with this phone number already exists.\\") self.contacts[contact.phone] = contact.name def remove_contact(self, phone): if phone not in self.contacts: raise ValueError(\\"Contact with this phone number does not exist.\\") del self.contacts[phone] def update_contact(self, phone, new_name): if phone not in self.contacts: raise ValueError(\\"Contact with this phone number does not exist.\\") self.contacts[phone] = new_name def search_by_name(self, name): return [phone for phone, cname in self.contacts.items() if cname == name] def search_by_phone(self, phone): if phone not in self.contacts: raise ValueError(\\"Contact with this phone number does not exist.\\") return self.contacts[phone]"},{"question":"Task You need to complete the implementation of a class that simulates a basic Stack data structure using a dynamic array. # Stack Implementation You are given a partially implemented class `Stack` that uses a dynamic array (list in Python) to simulate a stack\'s behavior. The class should provide typical stack operations. Task Implement the following methods in the `Stack` class: 1. `push(value: int) -> None`: Adds an element to the top of the stack. 2. `pop() -> int`: Removes and returns the top element of the stack. If the stack is empty, it should raise an `IndexError` with the message \\"pop from empty stack\\". 3. `peek() -> int`: Returns the top element of the stack without removing it. If the stack is empty, it should raise an `IndexError` with the message \\"peek from empty stack\\". 4. `is_empty() -> bool`: Returns `True` if the stack is empty, otherwise `False`. 5. `size() -> int`: Returns the number of elements in the stack. Implementation ```python class Stack: def __init__(self): self._stack = [] def push(self, value: int) -> None: Adds an element to the top of the stack. # TODO: Implement this method pass def pop(self) -> int: Removes and returns the top element of the stack. Raises IndexError if the stack is empty. # TODO: Implement this method pass def peek(self) -> int: Returns the top element of the stack without removing it. Raises IndexError if the stack is empty. # TODO: Implement this method pass def is_empty(self) -> bool: Returns True if the stack is empty, otherwise False. # TODO: Implement this method pass def size(self) -> int: Returns the number of elements in the stack. # TODO: Implement this method pass ``` Constraints * The value pushed onto the stack will always be an integer. Example ```python s = Stack() s.push(1) s.push(2) print(s.peek()) # Output: 2 print(s.pop()) # Output: 2 print(s.size()) # Output: 1 print(s.is_empty()) # Output: False print(s.pop()) # Output: 1 print(s.is_empty()) # Output: True try: print(s.pop()) # Should raise IndexError: \\"pop from empty stack\\" except IndexError as e: print(e) try: print(s.peek()) # Should raise IndexError: \\"peek from empty stack\\" except IndexError as e: print(e) ``` Your task is to complete the implementation of the `Stack` class by filling in the bodies of the provided methods based on the described behavior.","solution":"class Stack: def __init__(self): self._stack = [] def push(self, value: int) -> None: Adds an element to the top of the stack. self._stack.append(value) def pop(self) -> int: Removes and returns the top element of the stack. Raises IndexError if the stack is empty. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self._stack.pop() def peek(self) -> int: Returns the top element of the stack without removing it. Raises IndexError if the stack is empty. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self._stack[-1] def is_empty(self) -> bool: Returns True if the stack is empty, otherwise False. return len(self._stack) == 0 def size(self) -> int: Returns the number of elements in the stack. return len(self._stack)"},{"question":"# Problem Statement You are given an integer array `nums` of length `n`, where `n` is even. Your task is to implement a Python function that partitions the array into two groups of equal size such that the difference between the sums of the elements in the two groups is minimized. # Function Signature ```python def min_difference_partition(nums: List[int]) -> Tuple[List[int], List[int]]: Partitions the input list `nums` into two sublists such that the difference between their sums is minimized. Parameters: nums (List[int]): The list of integers to be partitioned. Returns: Tuple[List[int], List[int]]: A tuple containing the two sublists resulting from the partition. Raises: ValueError: If the input list does not have an even number of elements. ``` # Requirements - You should return a tuple containing the two partitions, each represented as a list. - The length of `nums` is guaranteed to be an even number. - If `nums` has no elements (i.e., it is an empty list), both sublists should also be empty. - Your solution should aim to find the closest possible sums for the two sublists, although an exact split may not always be possible. # Example ```python print(min_difference_partition([1, 6, 11, 5])) # Example output: ([1, 11], [6, 5]) print(min_difference_partition([3, 1, 4, 2])) # Example output: ([3, 1], [4, 2]) print(min_difference_partition([1, 2, 3, 4, 5, 6])) # Example output: ([1, 4, 6], [2, 3, 5]) ``` # Constraints - The length of `nums` will satisfy 0 <= n <= 20. - All elements of `nums` are integers in the range -10^6 to 10^6. - The length of `nums` is always even. # Hints - Consider using dynamic programming or a recursive approach with memoization to generate the partitions. - The problem shares similarities with the subset-sum problem, which can be approached using backtracking or dynamic programming techniques.","solution":"from typing import List, Tuple from itertools import combinations def min_difference_partition(nums: List[int]) -> Tuple[List[int], List[int]]: Partitions the input list `nums` into two sublists such that the difference between their sums is minimized. Parameters: nums (List[int]): The list of integers to be partitioned. Returns: Tuple[List[int], List[int]]: A tuple containing the two sublists resulting from the partition. Raises: ValueError: If the input list does not have an even number of elements. if len(nums) % 2 != 0: raise ValueError(\\"The input list must have an even number of elements.\\") n = len(nums) half_n = n // 2 # Generating all possible combinations of half_n elements min_diff = float(\'inf\') best_partition = ([], []) for comb in combinations(nums, half_n): group1 = list(comb) group2 = [num for num in nums if num not in group1] diff = abs(sum(group1) - sum(group2)) if diff < min_diff: min_diff = diff best_partition = (group1, group2) return best_partition"},{"question":"# Inverted Index Search You are provided with an `InvertedIndex` class that stores a mapping of words to the list of document IDs (integers) where each word appears. Your task is to implement a function `search_inverted_index` that performs a boolean search query on the inverted index. The search should find all document IDs that contain all the specified words. Function Signature ```python def search_inverted_index(inverted_index: dict, query: list[str]) -> list[int]: Perform a boolean search query on the inverted index and return all document IDs containing all words in the query. Args: inverted_index (dict): A dictionary where keys are words (str) and values are lists of integers representing document IDs. query (list[str]): A list of words (str) representing the search query. Returns: list[int]: A list of document IDs that contain all the words in the query. ``` Input 1. `inverted_index`: A dictionary where each key is a word (str) and each value is a list of integers representing the IDs of documents where the word appears. 2. `query`: A list of strings where each string is a word to be searched in the inverted index. Output - A list of integers where each integer is a document ID that contains all the words in the query. Constraints 1. The number of documents will not exceed 10,000. 2. Each word in the index will appear in at most 1,000 documents. 3. The query will be a list of up to 10 words. # Example ```python # Example Inverted Index inverted_index = { \'python\': [1, 2, 3, 5, 6], \'programming\': [2, 5, 6], \'language\': [1, 3, 5] } # Query query = [\'python\', \'language\'] # Expected output result = search_inverted_index(inverted_index, query) # Output should contain document IDs: [1, 3, 5] ``` # Hints 1. Use set operations to compute the intersection of lists of document IDs for each word in the query. 2. Efficiently handle cases where a word in the query is not found in the inverted index by returning an empty list immediately.","solution":"def search_inverted_index(inverted_index, query): Perform a boolean search query on the inverted index and return all document IDs containing all words in the query. Args: inverted_index (dict): A dictionary where keys are words (str) and values are lists of integers representing document IDs. query (list[str]): A list of words (str) representing the search query. Returns: list[int]: A list of document IDs that contain all the words in the query. if not query: return [] # Initialize with the document ids of the first word in the query result_set = set(inverted_index.get(query[0], [])) for word in query[1:]: if word not in inverted_index: return [] result_set.intersection_update(inverted_index[word]) return list(result_set)"},{"question":"# **Generating Unique Usernames** Scenario: You are developing a system to generate unique usernames for a large-scale application. Usernames must be easily readable and must not contain any special characters or spaces. To ensure uniqueness, a username should be checked against a list of existing usernames. Task: Implement the function `generate_unique_username` in a class `UsernameGenerator`. The method should generate a new, unique username based on the following rules: 1. Generate a username using the full name provided by the user (concatenate first name and last name without spaces). 2. If the username is already taken, append a numerical suffix starting from 1 until a unique username is found. Method Specification: 1. **generate_unique_username(existing_usernames: list[str], first_name: str, last_name: str) -> str** - **Input**: - `existing_usernames`: A list of strings containing usernames that have already been taken. - `first_name`: The first name of the user. - `last_name`: The last name of the user. - **Output**: A unique username string. Constraints: - All strings (usernames, first name, last name) are alphanumeric and non-empty. - The method should handle both uppercase and lowercase inputs and ensure that the generated username is positioned consistently (e.g., all lowercase). - The method should be case-insensitive when checking for existing usernames. Example: ```python from username_generator import UsernameGenerator # assume the code is in a file named \'username_generator.py\' existing_usernames = [\\"johnsmith\\", \\"johnsmith1\\", \\"annesmith\\", \\"michaeljohnson\\"] # Generating a unique username for a new user username = UsernameGenerator.generate_unique_username(existing_usernames, \\"John\\", \\"Smith\\") # The new username should be \'johnsmith2\' assert username == \\"johnsmith2\\" ``` Your task is to implement this method according to the given specifications.","solution":"class UsernameGenerator: @staticmethod def generate_unique_username(existing_usernames, first_name, last_name): # Normalize the existing usernames to lowercase existing_usernames_lower = {username.lower() for username in existing_usernames} # Generate the base username by concatenating first and last name in lowercase base_username = (first_name + last_name).lower() # If the base username is already taken if base_username in existing_usernames_lower: suffix = 1 # Append numerical suffix until a unique username is found while (base_username + str(suffix)) in existing_usernames_lower: suffix += 1 return base_username + str(suffix) else: return base_username"},{"question":"# Smallest Missing Positive Integer You are given an unsorted array of integers. Your task is to implement a function `smallest_missing_positive` that finds and returns the smallest missing positive integer from the array. Function Signature: ```python def smallest_missing_positive(nums: List[int]) -> int: # Your code goes here ``` Input Format: - The input function receives a parameter `nums`, which is a list of integers. Output Format: - Return an integer representing the smallest missing positive integer. Constraints: - The number of elements in the array is within the range `[0, 10^5]`. - Each element in the array falls within the range `[-10^6, 10^6]`. Example: **Example 1**: ```python nums1 = [1, 2, 0] print(smallest_missing_positive(nums1)) # Output: 3 ``` **Example 2**: ```python nums2 = [3, 4, -1, 1] print(smallest_missing_positive(nums2)) # Output: 2 ``` **Example 3**: ```python nums3 = [7, 8, 9, 11, 12] print(smallest_missing_positive(nums3)) # Output: 1 ``` In the first example, the positive integers 1 and 2 are present, so the smallest missing positive integer is 3. In the second example, the positive integers 1 and 3 are present, so the smallest missing positive integer is 2. In the third example, none of the first few positive integers are present, so the smallest missing positive integer is 1. **Note**: 1. Ensure that your solution handles edge cases such as arrays with all negative values. 2. Optimize your approach to achieve the best performance for large input sizes. Hints: - Consider using an algorithm that operates in linear time and constant space to meet the constraints effectively.","solution":"from typing import List def smallest_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Coding Assessment Question Question: You are developing a system to manage bookings for a conference. Each booking request includes a start time and an end time, and bookings cannot overlap. You are required to write a function that checks if a new booking can be accommodated without causing any overlaps with the existing bookings. Write a function `can_accommodate(new_booking: Tuple[int, int], existing_bookings: List[Tuple[int, int]]) -> bool` that takes a new booking request and a list of existing bookings, and returns `True` if the new booking can be accommodated, otherwise returns `False`. Function Signature: ```python def can_accommodate(new_booking: Tuple[int, int], existing_bookings: List[Tuple[int, int]]) -> bool: pass ``` Input: - `new_booking` (Tuple[int, int]): A tuple representing the start and end times of the new booking. - `existing_bookings` (List[Tuple[int, int]]): A list of tuples where each tuple represents the start and end times of an existing booking. Output: - `bool`: `True` if the new booking can be accommodated without overlap, `False` otherwise. Constraints: - All times are represented as integers. - 0 <= start time < end time <= 10000 for all bookings. - The length of the existing_bookings list does not exceed 10^5. - Ensure a booking\'s end time is greater than its start time. Example: ```python >>> can_accommodate((10, 20), [(0, 5), (22, 30)]) True >>> can_accommodate((10, 20), [(0, 15)]) False >>> can_accommodate((5, 10), [(0, 5), (10, 15)]) True >>> can_accommodate((5, 10), [(0, 7)]) False ``` # Additional Information: 1. The function should efficiently handle checking overlaps considering the number of bookings can be large (up to 10^5). 2. Ensure to handle edge cases like bookings at the boundaries properly, e.g., a booking that ends exactly when another booking starts is valid. # Hints: - Consider sorting the bookings by start time to simplify the check for overlaps. - You may assume that the existing bookings list does not contain overlapping intervals.","solution":"from typing import List, Tuple def can_accommodate(new_booking: Tuple[int, int], existing_bookings: List[Tuple[int, int]]) -> bool: new_start, new_end = new_booking for start, end in existing_bookings: # Check if the new booking overlaps with the existing one if not (new_end <= start or new_start >= end): return False return True"},{"question":"# Scenario You are developing a software that processes a large dataset of customer transactions to detect potentially fraudulent activities. For this task, you need to analyze sequences of transactions and identify patterns that are indicative of fraud. A known indicator of fraud is when a user makes two transactions with the same amount within a very short period of time. # Question Implement a function to detect pairs of transactions for a given user where the transaction amounts are the same and the transactions are made within a specified time window. # Requirements 1. Implement the `find_fraudulent_transactions(transactions: List[Tuple[int, float]], window: int) -> List[Tuple[int, int]]` function to find pairs of fraudulent transactions. 2. The input list `transactions` contains tuples where each tuple represents a transaction with an integer timestamp and a float amount `[(timestamp1, amount1), (timestamp2, amount2), ...]`. 3. The `window` parameter is an integer representing the maximum allowed time difference (in seconds) between two transactions for them to be considered potentially fraudulent. 4. Return a list of tuples, each representing a pair of indices of fraudulent transactions `[(index1, index2), ...]`. Example ```python transactions = [ (1609459200, 100.0), # Timestamp: 2021-01-01 00:00:00, Amount: 100.0 (1609459260, 150.0), # Timestamp: 2021-01-01 00:01:00, Amount: 150.0 (1609459320, 100.0), # Timestamp: 2021-01-01 00:02:00, Amount: 100.0 (1609459380, 100.0) # Timestamp: 2021-01-01 00:03:00, Amount: 100.0 ] window = 120 # 2 minutes # Perform fraud detection fraudulent_pairs = find_fraudulent_transactions(transactions, window) # Outputs print(f\\"Fraudulent transaction pairs: {fraudulent_pairs}\\") # Expected output: [(0, 2), (2, 3)] ``` # Constraints and Performance - `1 <= len(transactions) <= 10^5` - Each timestamp is a positive integer ranging from `1` to `10^9`. - Each amount is a float within the range `[0.0, 10^6.0]`. - The solution should aim to minimize the time complexity for processing large datasets within the given constraints.","solution":"from typing import List, Tuple from collections import defaultdict def find_fraudulent_transactions(transactions: List[Tuple[int, float]], window: int) -> List[Tuple[int, int]]: Finds pairs of transactions with the same amount made within a specified time window. :param transactions: List of tuples with each tuple containing an integer timestamp and a float amount. :param window: Integer representing the maximum allowed time difference (in seconds) between two transactions. :return: List of tuples, each containing indices of fraudulent transactions. # Mapping from amounts to a list of (index, timestamp) tuples amount_to_transactions = defaultdict(list) # Collect transactions by amount for index, (timestamp, amount) in enumerate(transactions): amount_to_transactions[amount].append((index, timestamp)) fraudulent_pairs = [] # Check each amount group for fraudulent pairs for amount, transaction_list in amount_to_transactions.items(): # Sort transactions by timestamp for this amount transaction_list.sort(key=lambda x: x[1]) for i in range(len(transaction_list)): for j in range(i + 1, len(transaction_list)): time_diff = transaction_list[j][1] - transaction_list[i][1] if time_diff <= window: fraudulent_pairs.append((transaction_list[i][0], transaction_list[j][0])) else: # Since the list is sorted by timestamp, no need to check further break return fraudulent_pairs"},{"question":"# Calculate the Median of a List Write a function in Python called `calculate_median` that accepts a single parameter: 1. `numbers` (list): A list of integers. The function should return the median value of the list. If the list is empty, it should return `\\"List is empty\\"`. If there are an even number of elements, the median should be the average of the two middle numbers. # Constraints: * The input list can contain up to 10^6 integers. * Each integer in the list can range from -10^6 to 10^6. * The function should handle cases where the input list is unsorted. # Inputs: * `numbers`: a list of integers. # Outputs: * A float representing the median value of the list, or a string `\\"List is empty\\"` if the list has no elements. # Example: ```python print(calculate_median([1, 3, 2])) # Output: 2 print(calculate_median([1, 2, 3, 4])) # Output: 2.5 print(calculate_median([])) # Output: \\"List is empty\\" print(calculate_median([7])) # Output: 7 ``` # Hints: * You might find the `sort()` method useful for sorting the list. * To calculate the median: - For an odd-length list, pick the middle element. - For an even-length list, take the average of the two middle elements.","solution":"def calculate_median(numbers): Returns the median of the list of numbers. If the list is empty, returns \\"List is empty\\". if not numbers: return \\"List is empty\\" numbers.sort() n = len(numbers) # If the number of elements is odd, return the middle element if n % 2 != 0: median = numbers[n // 2] # If the number of elements is even, return the average of the two middle elements else: mid1 = numbers[n // 2 - 1] mid2 = numbers[n // 2] median = (mid1 + mid2) / 2 return median"},{"question":"# Coding Challenge: Validate Arithmetic Expression You have been assigned the task of validating a mathematical expression to ensure it adheres to the correct syntax and balanced parentheses. Your function should parse the given expression and return a boolean indicating whether the expression is valid. **Function Signature**: ```python def validate_expression(expression: str) -> bool: ``` **Input**: - A string `expression` representing the mathematical expression to be validated. The expression can include digits (0-9), operators (`+`, `-`, `*`, `/`), and parentheses (`(`, `)`). **Output**: - A boolean value. `True` if the expression is valid, `False` otherwise. **Constraints**: - The function must handle the string length up to `10^5`. - Operators must be surrounded by valid operands (e.g., `1+2`, not `1+` or `+2`). - Parentheses must be balanced and properly nested. **Example**: ```python >>> validate_expression(\\"(1+2)*3\\") True >>> validate_expression(\\"((1+2)*3\\") False >>> validate_expression(\\"(1+2)*3)\\") False >>> validate_expression(\\"3+5*(2+1\\") False >>> validate_expression(\\"\\") True >>> validate_expression(\\"((10 + 2) - (3 * 7)) / (7 / 2)\\") True ``` **Instructions**: 1. Implement the function `validate_expression` to handle the validation logic as outlined. 2. Ensure the function efficiently checks for balanced and properly nested parentheses. 3. Verify that operators are correctly placed between operands. 4. Consider edge cases such as an empty string or unbalanced parentheses. --- Create your function to validate the arithmetic expressions, making sure to follow the constraints and deliver a solution that efficiently checks for syntax correctness and balanced parentheses.","solution":"def validate_expression(expression: str) -> bool: Validates a mathematical expression for correct syntax and balanced parentheses. stack = [] operators = set(\'+-*/\') prev_char = None for char in expression: if char in \'0123456789\': prev_char = \'num\' continue elif char in operators: if prev_char != \'num\' and prev_char != \')\': return False prev_char = \'op\' elif char == \'(\': stack.append(char) prev_char = \'(\' elif char == \')\': if not stack or stack[-1] != \'(\': return False stack.pop() if prev_char == \'op\': return False prev_char = \')\' elif char == \' \': continue else: return False if prev_char == \'op\': return False return len(stack) == 0"},{"question":"# Coding Assessment Question Scenario You are working on an optimization problem where you need to rearrange the elements of an array to achieve a particular order. Specifically, you have an array of integers and your task is to move all the zeros to the end of the array while maintaining the relative order of the non-zero elements. Task Write a function `move_zeros_to_end(arr)` that takes an array of integers `arr` and rearranges the array so that all zeros are moved to the end. The function should modify the array in place and also return it. Input - An array `arr` of integers with a length of up to 100,000. Output - The function should return the modified array with all zeros moved to the end. Constraints - The array should be modified in place. - The order of the non-zero elements should remain unchanged. Performance Requirements - The function must execute efficiently in linear time. Function Signature ```python def move_zeros_to_end(arr: List[int]) -> List[int]: ``` Example ```python assert move_zeros_to_end([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0] assert move_zeros_to_end([1, 2, 0, 0, 3, 4]) == [1, 2, 3, 4, 0, 0] assert move_zeros_to_end([0, 0, 0, 1]) == [1, 0, 0, 0] ```","solution":"def move_zeros_to_end(arr): Moves all zeros in the array to the end while maintaining the order of non-zero elements. if not arr: return arr non_zero_index = 0 # First pass to move non-zero elements to the front for i in range(len(arr)): if arr[i] != 0: arr[non_zero_index] = arr[i] non_zero_index += 1 # Second pass to fill the rest of the array with zeros for i in range(non_zero_index, len(arr)): arr[i] = 0 return arr"},{"question":"**Question**: Implement a **Function to Check Tree Isomorphism** to determine if two binary trees are isomorphic. # Context Given two binary trees, we need to determine whether they are isomorphic. Two binary trees are isomorphic if one of them can be transformed into the other by flipping some of their subtrees. This means that both trees have the same structure or can have the same structure by swapping left and right children of some nodes. # Task - Write a function `is_isomorphic(tree1: Optional[TreeNode], tree2: Optional[TreeNode]) -> bool` that takes two binary trees as input and returns `True` if they are isomorphic, otherwise returns `False`. # Requirements - **Input**: Two binary trees `tree1` and `tree2`, represented by their root nodes. The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - **Output**: A boolean value `True` if the two trees are isomorphic, otherwise `False`. # Constraints - A tree node value can be any integer. - Trees can be empty (i.e., `tree1` or `tree2` can be `None`). - Efficient runtime is expected, but there are no strict constraints on the size of the trees. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) tree2 = TreeNode(1, TreeNode(3), TreeNode(2)) assert is_isomorphic(tree1, tree2) == True # Example 2 tree1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) tree2 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) assert is_isomorphic(tree1, tree2) == True # Example 3 tree1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), None)) tree2 = TreeNode(1, TreeNode(3), TreeNode(2, TreeNode(4), TreeNode(5, TreeNode(6), None))) assert is_isomorphic(tree1, tree2) == False # Example 4 assert is_isomorphic(None, None) == True assert is_isomorphic(TreeNode(1), None) == False assert is_isomorphic(None, TreeNode(1)) == False ``` Write the `is_isomorphic` function to meet the above requirements and ensure it passes the examples provided.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_isomorphic(tree1: TreeNode, tree2: TreeNode) -> bool: # Both roots are None, trees are isomorphic if tree1 is None and tree2 is None: return True # Only one of the trees is empty, trees are not isomorphic if tree1 is None or tree2 is None: return False # Both trees have different values, trees are not isomorphic if tree1.val != tree2.val: return False # There are two cases: # 1. The subtrees are not swapped # 2. The subtrees are swapped return ((is_isomorphic(tree1.left, tree2.left) and is_isomorphic(tree1.right, tree2.right)) or (is_isomorphic(tree1.left, tree2.right) and is_isomorphic(tree1.right, tree2.left)))"},{"question":"# Coding Assessment Question **Objective**: To evaluate your understanding of basic graph algorithms, specifically Depth-First Search (DFS), along with your ability to implement and optimize algorithms while handling edge cases effectively. **Problem Statement**: Given an undirected graph represented as an adjacency list, implement a function to determine the number of connected components in the graph using Depth-First Search. **Function Signature**: ```python def count_connected_components(graph: dict[int, list[int]]) -> int: pass ``` **Input**: * `graph`: A dictionary where keys are integers representing nodes, and values are lists of integers representing the adjacent nodes (i.e., the edges). **Output**: * Returns an integer representing the number of connected components in the graph. **Constraints**: 1. `1 <= len(graph) <= 100` 2. Each node is an integer between `0` and `len(graph) - 1`. 3. No self-loops or multiple edges between the same pair of nodes. **Example**: ```python graph = { 0: [1, 2], 1: [0], 2: [0, 3], 3: [2], 4: [5], 5: [4] } print(count_connected_components(graph)) # Output: 2 graph = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } print(count_connected_components(graph)) # Output: 1 ``` **Requirements**: 1. Write your implementation inside the `count_connected_components` function. 2. Ensure your solution handles edge cases, such as disconnected nodes or graphs with only one node, correctly. 3. Optimize the function to efficiently handle the upper constraint. **Notes**: - You are required to implement DFS manually and not use any built-in Python libraries for graph traversal. - Use the provided sample inputs to debug and verify your function. [End of Question]","solution":"def count_connected_components(graph: dict[int, list[int]]) -> int: This function returns the number of connected components in an undirected graph using DFS. def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() count = 0 for node in graph: if node not in visited: count += 1 visited.add(node) dfs(node, visited) return count"},{"question":"# Movie Rating Aggregator You are developing a movie rating aggregation system. This system collects ratings from several different sources and computes an average rating for a given movie. Function Signature ```python def average_movie_rating(movie_ratings: dict) -> float: pass ``` # Instructions 1. **Functionality**: Develop a function `average_movie_rating` that, given a dictionary of movie ratings, calculates the average rating of the movie. 2. **Handling Ratings**: The input dictionary contains ratings from various sources, and each rating is given as a float between 0 and 10. 3. **Invalid Ratings**: If any rating is outside the valid range (0-10), the function should ignore that rating but continue processing other ratings. 4. **No Valid Ratings**: If there are no valid ratings or if all ratings are invalid, the function should return 0. 5. **Precision**: The average rating should be rounded to 2 decimal places. # Expected Input and Output * **Input**: - `movie_ratings`: a dictionary where the keys are the source names (strings) and the values are the ratings (floats). * **Output**: - A float representing the average rating, rounded to 2 decimal places. # Constraints 1. The provided ratings must be valid numbers between 0 and 10. 2. The function should ignore any invalid ratings and not consider them in the average calculation. 3. If no valid ratings are present, the function should return 0.0. # Example ```python >>> average_movie_rating({\\"Source A\\": 8.5, \\"Source B\\": 9.0, \\"Source C\\": 7.5}) 8.33 >>> average_movie_rating({\\"Source A\\": 12.0, \\"Source B\\": -1.0, \\"Source C\\": 7.5}) 7.5 >>> average_movie_rating({\\"Source A\\": 12.0, \\"Source B\\": -1.0}) 0.0 ``` # Note Ensure the function accurately calculates the average rating while properly handling any invalid ratings and returning the correct result in such cases.","solution":"def average_movie_rating(movie_ratings: dict) -> float: valid_ratings = [rating for rating in movie_ratings.values() if 0 <= rating <= 10] if not valid_ratings: return 0.0 average = sum(valid_ratings) / len(valid_ratings) return round(average, 2)"},{"question":"# Scenario You are tasked with implementing a simplified version of a message service that can record messages, retrieve messages by user, and delete messages efficiently. # Task Description Implement a `MessageService` class to manage messages. The `MessageService` class should provide the following functionalities: 1. Record a new message. 2. Retrieve all messages sent by a specific user. 3. Delete all messages sent by a specific user. # Input and Output Formats `MessageService` class should have the following methods: - `record_message(sender: str, message: str)`: Records a new message sent by the specified sender. - `get_messages(sender: str) -> List[str]`: Returns a list of all messages sent by the specified sender. If no messages exist, returns an empty list. - `delete_messages(sender: str)`: Deletes all messages sent by the specified sender. # Constraints - Senders are identified by a unique string (username). - Messages are strings of arbitrary length. - The number of total messages (`m`) will not exceed (10^5). - The number of unique users (`u`) will not exceed (10^4). # Example ```python service = MessageService() service.record_message(\\"Alice\\", \\"Hello, Bob!\\") service.record_message(\\"Bob\\", \\"Hi, Alice!\\") service.record_message(\\"Alice\\", \\"How are you?\\") assert service.get_messages(\\"Alice\\") == [\\"Hello, Bob!\\", \\"How are you?\\"] assert service.get_messages(\\"Bob\\") == [\\"Hi, Alice!\\"] service.delete_messages(\\"Alice\\") assert service.get_messages(\\"Alice\\") == [] assert service.get_messages(\\"Bob\\") == [\\"Hi, Alice!\\"] ``` # Requirements Ensure that your implementation can handle a large number of messages and users efficiently.","solution":"class MessageService: def __init__(self): self.messages = {} def record_message(self, sender: str, message: str): if sender not in self.messages: self.messages[sender] = [] self.messages[sender].append(message) def get_messages(self, sender: str) -> list: return self.messages.get(sender, []) def delete_messages(self, sender: str): if sender in self.messages: del self.messages[sender]"},{"question":"# Problem Statement You are given a list of integers. You need to find the `k`-th smallest element in the list using the Quickselect algorithm. # Function Signature ```python def kth_smallest_element(nums: List[int], k: int) -> int: pass ``` # Input * A list of integers `nums` (1 <= len(nums) <= 10^5, -10^9 <= nums[i] <= 10^9): The list of integers. * An integer `k` (1 <= k <= len(nums)): The position of the smallest element you need to find. # Output * An integer: The `k`-th smallest element in the list. # Example ```python >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 ``` # Constraints * The input list `nums` will have at least one element. * The value of `k` will always be a valid index in the list.","solution":"from typing import List def kth_smallest_element(nums: List[int], k: int) -> int: def partition(low, high): pivot = nums[high] i = low for j in range(low, high): if nums[j] <= pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[high] = nums[high], nums[i] return i def quickselect(low, high, k): if low == high: return nums[low] pivot_index = partition(low, high) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(low, pivot_index - 1, k) else: return quickselect(pivot_index + 1, high, k) if not 1 <= k <= len(nums): raise ValueError(\\"k is out of bounds\\") return quickselect(0, len(nums) - 1, k - 1)"},{"question":"# Efficient Log File Reordering You are required to write a function `reorder_log_files` that reorders a list of log file entries. Each log is a space-delimited string of words. The first word in each log is an alphanumeric identifier. There are two types of logs: 1. **Letter-logs**: All words except the identifier consist of lowercase English letters. 2. **Digit-logs**: All words except the identifier consist of digits. Reordering Rules: 1. Letter-logs come before all digit-logs. 2. Letter-logs are sorted lexicographically by their contents (excluding the identifier), and in case of ties, lexicographically by their identifiers. 3. Digit-logs maintain their relative order. Requirements: 1. Implement the function `reorder_log_files(logs)` that processes the list of logs and returns the reordered list. 2. The function should handle a list of strings and return a list of strings. Expected Input and Output: - Input: List of strings called `logs`, where each string is a log file. - Output: List of strings representing the reordered logs. Constraints: - The list of logs will have at most (10^4) entries. - Each log string will be at most 100 bytes. # Function Signature: ```python def reorder_log_files(logs: List[str]) -> List[str]: ``` # Example: ```python logs = [ \\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\", ] print(reorder_log_files(logs)) # Output: [ # \\"g1 act car\\", # \\"a8 act zoo\\", # \\"ab1 off key dog\\", # \\"a1 9 2 3 1\\", # \\"zo4 4 7\\", # ] ``` Ensure to implement the function `reorder_log_files` following the described requirements and constraints. # Notes: - The complexity of this function should reflect efficient string manipulations and sorting. - Consider edge cases where logs have similar content or identifiers.","solution":"from typing import List def reorder_log_files(logs: List[str]) -> List[str]: def get_key(log: str): identifier, rest = log.split(\\" \\", 1) is_digit = rest[0].isdigit() return (1, ) if is_digit else (0, rest, identifier) return sorted(logs, key=get_key)"},{"question":"# Linked List Reversal and Detection Your task is to enhance the provided `LinkedList` class with the following functionalities: 1. **Reverse the List**: Implement a method `reverse` that reverses the linked list in place. 2. **Cycle Detection**: Implement a method `has_cycle` that detects whether the linked list contains a cycle. If a cycle is detected, return `True`; otherwise, return `False`. # Linked List Structure You are provided with a basic structure of a `Node` class and a `LinkedList` class. You need to add the required methods to the `LinkedList` class. Node Class ```python class Node: def __init__(self, value=0, next=None): self.value = value self.next = next ``` Linked List Class ```python class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self): # Implement the reversal of the linked list pass def has_cycle(self): # Implement the cycle detection algorithm pass ``` # Detailed Requirements 1. **Reverse Method**: - Reverse the linked list such that the last node becomes the head and the head becomes the last node. - This method should modify the linked list in place and should not return anything. 2. **Cycle Detection Method**: - Implement Floyd\'s Tortoise and Hare algorithm to check for cycles. - Return `True` if a cycle is detected, otherwise return `False`. # Example Usage ```python # Create a linked list: 1 -> 2 -> 3 -> 4 ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) # Reverse the linked list: 4 -> 3 -> 2 -> 1 ll.reverse() # Detect cycles in a linked list: should return False print(ll.has_cycle()) # Output: False # Create a cycle for testing: 1 -> 2 -> 3 -> 4 -> 2 (cycle) ll.head.next.next.next.next = ll.head.next print(ll.has_cycle()) # Output: True ``` # Constraints: - The linked list may contain any number of nodes, including zero. - The values in the linked list nodes are integers. - You may assume there are no duplicate values in the linked list. # Function Signature ```python def reverse(self) -> None: pass def has_cycle(self) -> bool: pass ```","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def has_cycle(self): slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Scenario You are working on a library management system that includes a feature to help librarians quickly identify books that are overdue. Books can be borrowed for a specific duration, and if they are not returned within the stipulated period, they are considered overdue. Your task is to implement a function that calculates the number of days a book has been overdue based on the current date. # Function Implementation Implement a function `calculate_overdue_days(borrow_date: datetime, return_date: datetime, borrow_period: int) -> int` in Python, which calculates the number of days a book is overdue. The borrowing period is provided in days, and the return date is the actual date the book was or will be returned. Both dates will be given as `datetime` objects with `UTC` timezone information. # Input and Output Formats * **Input**: - `borrow_date`: A `datetime` object representing the date and time when the book was borrowed. - `return_date`: A `datetime` object representing the date and time when the book was or will be returned. - `borrow_period`: An integer representing the number of days for which the book can be borrowed. Constraints: `1 <= borrow_period <= 365`. * **Output**: An integer representing the number of days the book is overdue. If the book is returned on time or is yet to be returned, the result should be `0`. # Constraints * Both `borrow_date` and `return_date` will be valid `datetime` objects in UTC time zone. * The `borrow_period` will be a positive integer. # Requirements 1. Calculate the due date based on the `borrow_date` and `borrow_period`. 2. Compare the `return_date` with the due date to determine if the book is overdue. 3. If the book is overdue, return the number of days overdue; otherwise, return `0`. 4. Ensure the function returns `0` for any books returned on time or that have not yet reached the due date. # Example ```python from datetime import datetime, timezone # Example usage borrow_date = datetime(2023, 7, 1, 15, 0, 0, tzinfo=timezone.utc) return_date = datetime(2023, 7, 20, 15, 0, 0, tzinfo=timezone.utc) borrow_period = 14 print(calculate_overdue_days(borrow_date, return_date, borrow_period)) # Output: 5 borrow_date = datetime(2023, 7, 1, 15, 0, 0, tzinfo=timezone.utc) return_date = datetime(2023, 7, 10, 15, 0, 0, tzinfo=timezone.utc) borrow_period = 14 print(calculate_overdue_days(borrow_date, return_date, borrow_period)) # Output: 0 ``` # Detailed Steps 1. Calculate the due date by adding the borrow period to the borrow date. 2. Compare the return date with the calculated due date. 3. If the return date is after the due date, calculate the number of days overdue. 4. Return the number of days overdue, ensuring a minimum value of `0` in cases where the book is not overdue or returned on time.","solution":"from datetime import datetime, timedelta, timezone def calculate_overdue_days(borrow_date: datetime, return_date: datetime, borrow_period: int) -> int: Calculate the number of days a book is overdue. :param borrow_date: datetime object representing the date the book was borrowed. :param return_date: datetime object representing the date the book was or will be returned. :param borrow_period: The number of days the book can be borrowed. :return: Integer representing the number of days the book is overdue. # Calculate the due date due_date = borrow_date + timedelta(days=borrow_period) # Calculate the difference in days between return date and due date overdue_days = (return_date - due_date).days # Return the number of overdue days, ensuring a minimum value of 0 return max(overdue_days, 0)"},{"question":"# Objective Write a function to find the k-th smallest element in an unsorted list using the Quickselect algorithm. # Description The function `kth_smallest(arr: List[int], k: int) -> int` should: 1. Use the Quickselect algorithm to find the k-th smallest element in the list. # Input * `arr`: A list of integers. * `k`: An integer representing the position (1-based) of the smallest element you are looking for. # Output * An integer representing the k-th smallest element in the list. # Constraints * 1 <= len(arr) <= 10^5 * -10^9 <= arr[i] <= 10^9, where 0 <= i < len(arr) * 1 <= k <= len(arr) # Requirements - Implement the Quickselect algorithm to solve the problem efficiently. - Ensure that your solution handles edge cases, such as duplicate elements. # Example ```python from typing import List def kth_smallest(arr: List[int], k: int) -> int: def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] # Move pivot to end store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] # Move pivot to its final place return store_index def quickselect(left, right, k_smallest): if left == right: return arr[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(arr) - 1, k - 1) # Example usage: arr = [3, 2, 1, 5, 4] k = 3 output = kth_smallest(arr, k) print(output) # Output: 3 ```","solution":"from typing import List def kth_smallest(arr: List[int], k: int) -> int: def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] # Move pivot to end store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] # Move pivot to its final place return store_index def quickselect(left, right, k_smallest): if left == right: return arr[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"# Coding Assessment Question: Genetic Sequence Similarity Context: In bioinformatics, one common task is to compare genetic sequences to identify similarities and differences. This process is essential for tasks such as identifying evolutionary relationships, diagnosing genetic disorders, and more. Problem Statement: You are required to implement the following functions that work with pairs of sequences: 1. **hamming_distance**: - **Input**: Two strings `seq1` and `seq2` representing genetic sequences. - **Output**: The Hamming distance between the two sequences. - **Constraints**: The lengths of `seq1` and `seq2` must be equal. 2. **longest_common_subsequence**: - **Input**: Two strings `seq1` and `seq2` representing genetic sequences. - **Output**: The length of the longest common subsequence (LCS) between `seq1` and `seq2`. 3. **similarity_percentage**: - **Input**: Two strings `seq1` and `seq2` representing genetic sequences. - **Output**: The similarity percentage between the two sequences based on their Hamming distance. - **Constraints**: The lengths of `seq1` and `seq2` must be equal. 4. **complement_sequence**: - **Input**: A string `sequence` representing a genetic sequence. - **Output**: The complementary sequence where each \'A\' is replaced with \'T\', \'T\' with \'A\', \'C\' with \'G\', and \'G\' with \'C\'. Requirements: - All functions should handle input validity checks, including ensuring equal lengths for `seq1` and `seq2` where necessary. - Optimize for readability and performance. - Consider edge cases such as empty sequences, null inputs, and non-standard characters in the sequences. - Provide clear and concise documentation within the code. Example Usage: ```python seq1 = \\"AGCT\\" seq2 = \\"TCGA\\" # Hamming Distance hamming_dist = hamming_distance(seq1, seq2) print(hamming_dist) # Output: 4 # Longest Common Subsequence lcs_length = longest_common_subsequence(seq1, seq2) print(lcs_length) # Output: 1 # Similarity Percentage similarity = similarity_percentage(seq1, seq2) print(similarity) # Output: 0.0 # Complement Sequence complement = complement_sequence(seq1) print(complement) # Output: \\"TCGA\\" ``` Function Definitions: ```python def hamming_distance(seq1, seq2): if len(seq1) != len(seq2): raise ValueError(\\"Sequences must be of equal length.\\") return sum(char1 != char2 for char1, char2 in zip(seq1, seq2)) def longest_common_subsequence(seq1, seq2): m, n = len(seq1), len(seq2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def similarity_percentage(seq1, seq2): hamming_dist = hamming_distance(seq1, seq2) return (1 - hamming_dist / len(seq1)) * 100 def complement_sequence(sequence): complement = {\'A\': \'T\', \'T\': \'A\', \'C\': \'G\', \'G\': \'C\'} return \'\'.join(complement[base] for base in sequence) ``` This question assesses your understanding of string processing, dynamic programming, and basic bioinformatics algorithms.","solution":"def hamming_distance(seq1, seq2): Calculates the Hamming distance between two sequences. Sequences must be of equal length. Parameters: seq1 (str): First genetic sequence. seq2 (str): Second genetic sequence. Returns: int: Hamming distance between seq1 and seq2. Raises: ValueError: If the sequences are not of equal length. if len(seq1) != len(seq2): raise ValueError(\\"Sequences must be of equal length.\\") return sum(char1 != char2 for char1, char2 in zip(seq1, seq2)) def longest_common_subsequence(seq1, seq2): Calculates the length of the longest common subsequence (LCS) between two sequences. Parameters: seq1 (str): First genetic sequence. seq2 (str): Second genetic sequence. Returns: int: Length of the longest common subsequence. m, n = len(seq1), len(seq2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def similarity_percentage(seq1, seq2): Calculates the similarity percentage between two sequences based on their Hamming distance. Sequences must be of equal length. Parameters: seq1 (str): First genetic sequence. seq2 (str): Second genetic sequence. Returns: float: Similarity percentage between seq1 and seq2. Raises: ValueError: If the sequences are not of equal length. hamming_dist = hamming_distance(seq1, seq2) return (1 - hamming_dist / len(seq1)) * 100 def complement_sequence(sequence): Returns the complementary sequence where each \'A\' is replaced with \'T\', \'T\' with \'A\', \'C\' with \'G\', and \'G\' with \'C\'. Parameters: sequence (str): A genetic sequence. Returns: str: The complementary sequence. complement = {\'A\': \'T\', \'T\': \'A\', \'C\': \'G\', \'G\': \'C\'} return \'\'.join(complement[base] for base in sequence)"},{"question":"# Coding Task: Design a function that solves a Sudoku puzzle using a backtracking algorithm. The function should accept a 2D list representing the Sudoku board and fill in the missing digits. The empty cells are represented by zeros. # Function Specification - **Function Name**: `solve_sudoku` - **Input**: A 9x9 2D list `board` representing the Sudoku grid, with numbers from 1-9 and zeros indicating empty spaces. - **Output**: The function should modify the board in place to complete the Sudoku puzzle. It should not return any value. # Example ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solve_sudoku(board) print(board) Output: [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] ``` # Constraints 1. The starting `board` will always be a valid 9x9 grid. 2. The puzzle will have at least one solution. 3. Your function should modify the board in place. 4. Use a backtracking approach to solve the puzzle. # Points to Consider - Carefully choose where to place digits to avoid breaking Sudoku rules (i.e., no duplicates allowed in rows, columns, and 3x3 subgrids). - Implement a helper function to check the validity of placing a digit in a cell. - Efficiently backtrack by undoing previous steps when encountering conflicts.","solution":"def is_valid(board, row, col, num): # Check if the number is not repeated in the current row, column, or 3x3 grid for i in range(9): if board[row][i] == num or board[i][col] == num: return False start_row, start_col = (row // 3) * 3, (col // 3) * 3 for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve_sudoku(board): for row in range(9): for col in range(9): if board[row][col] == 0: # Empty cell found for num in range(1, 10): # Try all numbers from 1 to 9 if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return True board[row][col] = 0 # Undo assignment and backtrack return False # Trigger backtracking return True # Puzzle solved"},{"question":"# String Compression **Context**: String compression algorithms are commonly used to save space in data storage and transmission. One simple scheme for compressing a string is to abbreviate sequences of repeated characters to the first character followed by a count of repetitions. In this exercise, you will implement a basic string compression algorithm and compare its efficiency with the original string. **Task**: 1. Implement a function to compress a string using the described scheme. 2. Implement a function to decompress a string encoded with the described scheme. 3. Write a function to compare the length of the compressed string with the original string and determine if compression saves space. **Requirements**: 1. **Function 1**: `compress_string(s: str) -> str` - Compress the string by replacing sequences of repeated characters with a single character followed by the number of repetitions. - For instance, \\"aaabccdddd\\" would be compressed to \\"a3bc2d4\\". - If a character is not repeated, it should just appear as is. 2. **Function 2**: `decompress_string(s: str) -> str` - Decompress the string back to its original form. - For example, \\"a3bc2d4\\" should be decompressed to \\"aaabccdddd\\". 3. **Function 3**: `compare_compression(original: str) -> None` - Compare the length of the original string with the compressed string. - Print a summary showing whether the compression resulted in a shorter string and what the respective lengths are. ```python def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + (str(count) if count > 1 else \\"\\")) count = 1 compressed.append(s[-1] + (str(count) if count > 1 else \\"\\")) return \\"\\".join(compressed) def decompress_string(s: str) -> str: decompressed = [] i = 0 while i < len(s): char = s[i] count = 1 # Default count is 1 if i + 1 < len(s) and s[i + 1].isdigit(): count_str = [] i += 1 while i < len(s) and s[i].isdigit(): count_str.append(s[i]) i += 1 count = int(\\"\\".join(count_str)) else: i += 1 decompressed.append(char * count) return \\"\\".join(decompressed) def compare_compression(original: str) -> None: compressed = compress_string(original) print(f\\"Original length: {len(original)}\\") print(f\\"Compressed length: {len(compressed)}\\") if len(compressed) < len(original): print(\\"Compression saved space.\\") else: print(\\"Compression did not save space or resulted in a larger string.\\") # For demonstration purposes, decompress and compare decompressed = decompress_string(compressed) print(f\\"Decompressed string equals original: {decompressed == original}\\") # Example Usage: # compare_compression(\\"aaabccdddd\\") ``` This question maintains consistency with the original coding assessment set in terms of question length, complexity, and style. The core programming concepts involved, such as string manipulation, pattern recognition, and comparison operations, align well with those in the original set.","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + (str(count) if count > 1 else \\"\\")) count = 1 compressed.append(s[-1] + (str(count) if count > 1 else \\"\\")) return \\"\\".join(compressed) def decompress_string(s: str) -> str: decompressed = [] i = 0 while i < len(s): char = s[i] count = 1 # Default count is 1 if i + 1 < len(s) and s[i + 1].isdigit(): count_str = [] i += 1 while i < len(s) and s[i].isdigit(): count_str.append(s[i]) i += 1 count = int(\\"\\".join(count_str)) else: i += 1 decompressed.append(char * count) return \\"\\".join(decompressed) def compare_compression(original: str) -> None: compressed = compress_string(original) print(f\\"Original length: {len(original)}\\") print(f\\"Compressed length: {len(compressed)}\\") if len(compressed) < len(original): print(\\"Compression saved space.\\") else: print(\\"Compression did not save space or resulted in a larger string.\\") # For demonstration purposes, decompress and compare decompressed = decompress_string(compressed) print(f\\"Decompressed string equals original: {decompressed == original}\\")"},{"question":"# Question: Implement Dijkstra\'s Algorithm with Priority Queue Optimization You are tasked with implementing Dijkstra\'s algorithm using a priority queue to find the shortest path from a source vertex to all other vertices in a weighted directed graph. Problem Statement Implement a function `dijkstra(graph: List[Vertex], source: Vertex) -> Dict[int, int]` that returns the shortest path distances from the source vertex to all other vertices in the input graph. Input * `graph`: A list of `Vertex` objects representing the graph. * `source`: A `Vertex` object from which Dijkstra’s algorithm should start. Each `Vertex` object has the following properties: * `id`: Unique identifier for the vertex. * `neighbors`: List of connected vertices. * `edges`: Dictionary mapping neighbor vertex\'s ID to the edge weight. Output A dictionary mapping each vertex\'s ID to the shortest path distance from the source vertex. If a vertex is unreachable, its distance should be `float(\'inf\')`. Constraints * All weights are non-negative integers. * The given graph is directed. * The input vertices\' ids are 0-based integers. Example ```python # Assuming the definition of the Vertex class and connect function are available # Create vertices vertices = [Vertex(i) for i in range(6)] # Connect vertices with edges connect(vertices, 0, 1, 2) connect(vertices, 0, 2, 4) connect(vertices, 1, 2, 1) connect(vertices, 1, 3, 7) connect(vertices, 2, 4, 3) connect(vertices, 3, 4, 1) connect(vertices, 3, 5, 2) connect(vertices, 4, 5, 5) # Call Dijkstra\'s Algorithm distances = dijkstra(vertices, vertices[0]) # Expected output (shortest path distances from vertex 0) # {0: 0, 1: 2, 2: 3, 3: 9, 4: 6, 5: 11} print(distances) ``` Notes 1. Initialize all vertices with a distance of `float(\'inf\')` except the source vertex which should have a distance of 0. 2. Use a priority queue (min-heap) to efficiently fetch the vertex with the smallest known distance during iterations. 3. Update distances based on the current smallest known distances and edge weights. 4. Performance of the solution should align with ( O((m + n) log n) ) complexity, where ( m ) is the number of edges and ( n ) is the number of vertices. Implement the `dijkstra` function and test your solution with different graph configurations to ensure correctness and efficiency.","solution":"import heapq from typing import List, Dict class Vertex: def __init__(self, id: int): self.id = id self.neighbors = [] self.edges = {} def connect(graph: List[Vertex], from_id: int, to_id: int, weight: int): graph[from_id].neighbors.append(graph[to_id]) graph[from_id].edges[to_id] = weight def dijkstra(graph: List[Vertex], source: Vertex) -> Dict[int, int]: dist = {vertex.id: float(\'inf\') for vertex in graph} dist[source.id] = 0 priority_queue = [(0, source.id)] # (distance, vertex_id) while priority_queue: current_dist, current_id = heapq.heappop(priority_queue) current_vertex = graph[current_id] if current_dist > dist[current_id]: continue for neighbor in current_vertex.neighbors: distance = current_dist + current_vertex.edges[neighbor.id] if distance < dist[neighbor.id]: dist[neighbor.id] = distance heapq.heappush(priority_queue, (distance, neighbor.id)) return dist"},{"question":"# Problem Statement You are required to implement a function that generates unique codes for user registrations based on a given pattern. The pattern is defined using a format schema with placeholders for letters (`L`), digits (`D`), and special characters (`S`). Your task is to substitute the placeholders with appropriate characters and ensure the uniqueness of each generated code. # Function Signature ```python def generate_unique_code(pattern: str, num_codes: int) -> List[str]: pass ``` # Input and Output The function should take: * `pattern`: a string representing the format pattern. * `num_codes`: an integer representing the number of unique codes to generate. The function should return a list of unique code strings. # Constraints * The pattern consists of placeholders: \'L\' for letters (both uppercase and lowercase), \'D\' for digits (0-9), and \'S\' for special characters (`!@#%^&*`). * All generated codes must be unique. * `num_codes` will always be between 1 and 100, inclusive. # Explanation and Example The function should replace each placeholder in the pattern with a corresponding character: - \'L\' -> uppercase and lowercase letters (`A-Z` and `a-z`) - \'D\' -> digits (`0-9`) - \'S\' -> special characters (`!@#%^&*`) Example ```python generate_unique_code(\\"L-DD-SS\\", 5) ``` Should produce a list of 5 unique codes like: ``` [\'B-45-@\', \'H-78-%&\', \'r-23-!*\', \'x-19-)\', \'K-04-^\'] ``` # Note - If insufficient characters are available to meet the requirement (e.g., requesting 1000 unique codes from a very restrictive pattern), you should raise a `ValueError`. - Ensure that the codes are unique and the distribution of characters is randomized. - Preserve the order of placeholder types within the generated codes. # Implementation - Utilize Python\'s `random` module for character substitution. - Track the generated codes to ensure uniqueness. - Handle potential errors gracefully, providing meaningful feedback when the constraints cannot be satisfied.","solution":"import random import string from typing import List def generate_unique_code(pattern: str, num_codes: int) -> List[str]: if num_codes < 1 or num_codes > 100: raise ValueError(\\"num_codes must be between 1 and 100, inclusive\\") letters = string.ascii_letters # A-Z and a-z digits = string.digits # 0-9 special_chars = \\"!@#%^&*\\" # To generate unique codes, we\'ll use a set to track them unique_codes = set() # Function to generate a single code based on the given pattern def generate_code(): code = [] for char in pattern: if char == \'L\': code.append(random.choice(letters)) elif char == \'D\': code.append(random.choice(digits)) elif char == \'S\': code.append(random.choice(special_chars)) else: code.append(char) return \'\'.join(code) # Generate unique codes until we reach the desired amount while len(unique_codes) < num_codes: new_code = generate_code() unique_codes.add(new_code) return list(unique_codes)"},{"question":"# Question You are required to implement a function that parses log entries from a web server and returns a summary report. Each log entry follows a standard format and includes the HTTP method, URL path, response status code, and response time in milliseconds. Function Signature ```python def parse_log_entries(logs: list[str]) -> dict[str, Any]: ``` Input * `logs` (list[str]): A list of log entry strings, where each string contains the following space-separated fields: - HTTP method (str): The request method (e.g., \\"GET\\", \\"POST\\"). - URL path (str): The path requested (e.g., \\"/home\\", \\"/api/data\\"). - Response status code (str): The response status code (e.g., \\"200\\", \\"404\\"). - Response time (str): The time taken to respond in milliseconds (e.g., \\"123\\"). Output * Returns a dictionary containing the following: - `total_requests` (int): The total number of log entries. - `methods` (dict): A nested dictionary with HTTP methods as keys and their counts as values. - `average_response_time` (float): The average response time across all log entries. - `status_codes` (dict): A nested dictionary with status codes as keys and their counts as values. Constraints * All log entries adhere to the specified format. * The response time is always a non-negative integer. Example ```python logs = [ \\"GET /home 200 150\\", \\"POST /api/data 404 250\\", \\"GET /home 200 100\\", \\"GET /about 200 200\\" ] result = parse_log_entries(logs) # Expected output: # { # \'total_requests\': 4, # \'methods\': { # \'GET\': 3, # \'POST\': 1 # }, # \'average_response_time\': 175.0, # \'status_codes\': { # \'200\': 3, # \'404\': 1 # } # } ``` Ensure you: 1. Correctly parse each log entry. 2. Aggregate the counts for HTTP methods and status codes. 3. Calculate the average response time. 4. Return the summary as a dictionary adhering to the specified structure. Notes: * Ensure your function is efficient and handles typical edge cases. * Aim to write clean, maintainable, and well-documented code.","solution":"def parse_log_entries(logs): Parses log entries and returns a summary report. Args: logs (list[str]): A list of log entry strings. Returns: dict: A dictionary containing summary details. total_requests = len(logs) methods = {} status_codes = {} total_response_time = 0 for log in logs: parts = log.split() http_method = parts[0] status_code = parts[2] response_time = int(parts[3]) # Count method occurrences if http_method not in methods: methods[http_method] = 0 methods[http_method] += 1 # Count status code occurrences if status_code not in status_codes: status_codes[status_code] = 0 status_codes[status_code] += 1 # Sum response time total_response_time += response_time # Calculate average response time average_response_time = total_response_time / total_requests if total_requests > 0 else 0 return { \'total_requests\': total_requests, \'methods\': methods, \'average_response_time\': average_response_time, \'status_codes\': status_codes }"},{"question":"# Assessment Question: Context: You are designing a software application to manage a library. Part of this task involves implementing a system for checking out books. To efficiently keep track of borrowed books, you need to maintain a list of currently loaned books and ensure that no book is loaned out more than once. Task: Write a function to manage the check-out process for a library. Your function will take in the current list of loaned books and a list of books to be checked out. The function should attempt to check out each book in the input list, adding it to the list of loaned books, and return the updated list of loaned books. # Function Signature: ```python def checkout_books(current_loaned: list, checkout_list: list) -> list: ``` # Input: - `current_loaned`: a list of strings where each string is the title of a currently loaned book. - `checkout_list`: a list of strings where each string is the title of a book to check out. # Output: - Return a list of strings representing the updated list of currently loaned books after attempting to check out the books from `checkout_list`. # Constraints: - Neither input list will contain duplicate book titles within itself. - The titles in both lists are case-insensitive and may contain spaces, digits, and punctuation. - Both `current_loaned` and `checkout_list` can range from 0 to 10^6 in length. - If a book from `checkout_list` is already in `current_loaned`, it should not be added again. # Example: ```python >>> current_loaned = [\\"The Hobbit\\", \\"1984\\"] >>> checkout_list = [\\"The Catcher in the Rye\\", \\"1984\\"] >>> checkout_books(current_loaned, checkout_list) [\'The Hobbit\', \'1984\', \'The Catcher in the Rye\'] >>> current_loaned = [] >>> checkout_list = [\\"The Great Gatsby\\", \\"Moby Dick\\"] >>> checkout_books(current_loaned, checkout_list) [\'The Great Gatsby\', \'Moby Dick\'] ``` # Requirements: - Ensure that book titles are handled in a case-insensitive manner during the check-out process. - Return the updated list sorted alphabetically, disregarding case. Notes: - The input and output formats should match the examples. - Ensure that the function works efficiently with the maximum input size.","solution":"def checkout_books(current_loaned: list, checkout_list: list) -> list: Processes the checkout of books and returns an updated list of currently loaned books. - Titles are managed in a case-insensitive manner. - The final list is sorted alphabetically, disregarding case. :param current_loaned: List of currently loaned books. :param checkout_list: List of books to check out. :return: Updated list of currently loaned books. # Create a set for case-insensitive matching loaned_lower_set = set(title.lower() for title in current_loaned) # Process checkout books for book in checkout_list: if book.lower() not in loaned_lower_set: current_loaned.append(book) loaned_lower_set.add(book.lower()) # Return sorted list of loaned books, sorted case-insensitively return sorted(current_loaned, key=lambda title: title.lower())"},{"question":"# Problem Statement: You are required to design a function that computes the sum of all possible products formed by picking one element from each of the given integer arrays. This function will be important in scenarios involving probabilistic product selection such as multi-variate statistical modeling. # Function Signature: ```python def sum_of_products(arrays: List[List[int]]) -> int: pass ``` # Input: * `arrays` (List[List[int]]): A list of lists, where each inner list contains integers. There will be at least two inner lists, and each inner list will have at least one integer. # Output: * Returns an integer which is the sum of all the possible products obtained by picking one element from each of the arrays. # Constraints: * The number of inner lists (`len(arrays)`) and the number of elements in each inner list can range from 2 to 10. * The integers in the inner lists can range from -10^3 to 10^3. * The resulting product calculations should handle values up to `10^18` safely. # Example: ```python from typing import List def sum_of_products(arrays: List[List[int]]) -> int: from itertools import product total_sum = 0 for combination in product(*arrays): current_product = 1 for num in combination: current_product *= num total_sum += current_product return total_sum # Example Usage print(sum_of_products([[1, 2], [3, 4]])) # Output: 21 (1*3 + 1*4 + 2*3 + 2*4) print(sum_of_products([[1], [2], [3]])) # Output: 6 (1*2*3) print(sum_of_products([[-1, 1], [-2, 2]])) # Output: 0 (-1*-2 + -1*2 + 1*-2 + 1*2) ``` # Requirements: 1. Implement the function `sum_of_products` that efficiently computes the sum of all possible products. 2. Ensure the function handles edge cases such as arrays containing negative numbers or zeros. 3. Validate through the provided example cases and additional custom test cases to ensure accuracy. # Hints: 1. Utilize `itertools.product` to generate all possible combinations of picking one element from each array. 2. Perform intermediate checks on the product calculations to ensure they do not exceed practical limits for the given constraints.","solution":"from typing import List def sum_of_products(arrays: List[List[int]]) -> int: from itertools import product total_sum = 0 for combination in product(*arrays): current_product = 1 for num in combination: current_product *= num total_sum += current_product return total_sum"},{"question":"# Persistent Palindrome Checker You are tasked with creating a function that checks whether a number is a \\"persistent palindrome.\\" A number is considered a persistent palindrome if it becomes a palindrome through repeated reversal and addition. The function should return the number of iterations required to reach a palindrome. If a palindrome is not reached within 1000 iterations, return -1. Function Signature ```python def persistent_palindrome(num: int) -> int: pass ``` Input - `num` (int): A positive integer. Output - Return an integer representing the number of iterations required to reach a palindrome. - Return -1 if the number does not become a palindrome within 1000 iterations. Constraints 1. The given number will be a positive integer. 2. Return the number of iterations needed or -1 if a palindrome is not reached within 1000 iterations. Context In number theory, the process of forming a palindrome by repeatedly reversing the digits and adding the result to the original number is an interesting challenge. Some numbers become palindromes quickly, while others take longer or may never become palindromes within a reasonable number of steps. # Examples Example 1 **Input**: ```python 26 ``` **Output**: ```python 1 ``` **Explanation**: ``` 26 + 62 = 88 (which is a palindrome) ``` Example 2 **Input**: ```python 89 ``` **Output**: ```python 24 ``` **Explanation**: ``` It takes 24 iterations to reach a palindrome starting from 89. ``` Example 3 **Input**: ```python 196 ``` **Output**: ```python -1 ``` **Explanation**: ``` 196 is known to never reach a palindrome within 1000 iterations. ``` # Instructions - Implement the function `persistent_palindrome` as described. - Ensure you handle edge cases such as very large numbers and the maximum number of iterations. - Validate using given examples and additional test cases. *Note*: This problem tests your understanding of loops, conditionals, and palindrome detection within the constraints of algorithmic performance.","solution":"def is_palindrome(num: int) -> bool: Helper function to determine if a number is a palindrome. return str(num) == str(num)[::-1] def persistent_palindrome(num: int) -> int: Returns the number of iterations required for a number to become a palindrome through repeated reversal and addition. If it does not become a palindrome within 1000 iterations, return -1. iterations = 0 while iterations < 1000: if is_palindrome(num): return iterations reversed_num = int(str(num)[::-1]) num += reversed_num iterations += 1 return -1"},{"question":"# Question **The Hamming Distance for DNA Sequences** As a bioinformatics software developer, you\'re tasked with calculating the Hamming distance between two DNA sequences. The Hamming distance is a measure of the difference between two sequences of equal length, defined as the number of positions at which the corresponding symbols are different. Write a function to compute the Hamming distance for given DNA sequences. Requirements 1. Implement the `compute_hamming_distance` function. 2. The function should take the following parameters: - `seq1` (str): The first DNA sequence. - `seq2` (str): The second DNA sequence. 3. The function should return an integer representing the Hamming distance between `seq1` and `seq2`. **Constraints:** - Both `seq1` and `seq2` will have the same length and can only contain the characters \'A\', \'C\', \'G\', and \'T\'. **Example:** ```python seq1 = \\"GAGCCTACTAACGGGAT\\" seq2 = \\"CATCGTAATGACGGCCT\\" distance = compute_hamming_distance(seq1, seq2) # Expected output: 7, as there are 7 positions where the sequences differ. print(distance) ``` **Expected Output:** ```plaintext 7 ``` **Additional Tests:** ```python def test_case_1(): assert compute_hamming_distance(\\"AAAA\\", \\"AAAT\\") == 1 def test_case_2(): assert compute_hamming_distance(\\"GGGG\\", \\"GGGA\\") == 1 def test_case_3(): assert compute_hamming_distance(\\"ACTG\\", \\"TGCA\\") == 4 def test_case_4(): assert compute_hamming_distance(\\"ACGTTGCA\\", \\"ACGTTGCA\\") == 0 ``` Write your implementation to fulfill these requirements and pass the provided test cases.","solution":"def compute_hamming_distance(seq1, seq2): Computes the Hamming distance between two DNA sequences. Parameters: seq1 (str): The first DNA sequence. seq2 (str): The second DNA sequence. Returns: int: The Hamming distance between seq1 and seq2. # Ensure both sequences are of the same length if len(seq1) != len(seq2): raise ValueError(\\"Sequences must be of the same length\\") # Calculate the Hamming distance distance = sum(1 for a, b in zip(seq1, seq2) if a != b) return distance"},{"question":"# Coding Assessment Question Scenario You are part of a development team working on a large-scale e-commerce platform. One of your tasks is to develop a system to help customers find products quickly by searching keywords. To improve search performance, you need to implement an autocomplete system that suggests the top k products based on the prefix typed by the user. The suggestions should be sorted by the frequency of the keywords\' appearance in user searches. Task Write a function `autocomplete` that takes in a list of product suggestions and a prefix, then returns the top k most frequent suggestions that start with the given prefix. # Function Signature ```python def autocomplete(suggestions: list[str], prefix: str, k: int) -> list[str]: pass ``` # Input - `suggestions`: A list of strings, where each string is a product suggestion (1 ≤ len(suggestions) ≤ 10^5). - `prefix`: A string representing the prefix typed by a user (0 ≤ len(prefix) ≤ 100). - `k`: An integer representing the number of top suggestions to return (1 ≤ k ≤ 100). # Output - A list of strings containing the top k product suggestions that start with the given prefix, sorted by frequency of appearance. If less than k suggestions are available, return all matching suggestions. # Constraints - The function should run efficiently even with the maximum input size. - The order of suggestions with the same frequency should be maintained as they appear in the input list. # Example ```python assert autocomplete([\\"apple\\", \\"apricot\\", \\"banana\\", \\"apple\\", \\"appeal\\", \\"apartment\\", \\"apricot\\", \\"banana\\"], \\"ap\\", 3) == [\\"apple\\", \\"apricot\\", \\"appeal\\"] assert autocomplete([\\"apple\\", \\"apricot\\", \\"banana\\", \\"apple\\", \\"appeal\\", \\"apartment\\", \\"apricot\\", \\"banana\\"], \\"ba\\", 2) == [\\"banana\\"] assert autocomplete([\\"apple\\", \\"apricot\\", \\"banana\\", \\"apple\\", \\"appeal\\", \\"apartment\\", \\"apricot\\", \\"banana\\"], \\"apple\\", 2) == [\\"apple\\"] assert autocomplete([\\"apple\\", \\"apricot\\", \\"banana\\", \\"apple\\", \\"appeal\\", \\"apartment\\", \\"apricot\\", \\"banana\\"], \\"z\\", 3) == [] ``` # Notes - Ensure that your code handles different cases and edge cases, such as an empty prefix or no matching suggestions. - Maintain the complexity of your solution to handle large datasets efficiently.","solution":"from collections import Counter def autocomplete(suggestions: list[str], prefix: str, k: int) -> list[str]: Returns the top k most frequent product suggestions that start with the given prefix. # Filtering the suggestions that start with the given prefix filtered_suggestions = [s for s in suggestions if s.startswith(prefix)] # Counting the frequency of each suggestion suggestion_counts = Counter(filtered_suggestions) # Sorting the filtered suggestions by their frequency in decreasing order, # and maintaining the original order for suggestions with the same frequency sorted_suggestions = sorted(suggestion_counts, key=lambda x: (-suggestion_counts[x], suggestions.index(x))) # Return the top k suggestions return sorted_suggestions[:k]"},{"question":"# Problem Statement A popular logistics company is optimizing the routing of their delivery trucks. Given that each truck has a limited maximum carrying capacity, they need to pack the trucks such that the total weight of the packages in any truck does not exceed its capacity, while minimizing the number of trucks used. # Implementation Details Implement the `pack_trucks` function in Python using the given signature: ```python def pack_trucks(weights: List[int], capacity: int) -> int: pass ``` * **Input**: - `weights` (List[int]): A list of integers where each integer represents the weight of a package. - `capacity` (int): An integer representing the maximum capacity of a single truck. * **Output**: - Returns an integer representing the minimum number of trucks required to transport all packages. # Example ```python >>> pack_trucks([10, 20, 30, 40, 50], 60) 3 >>> pack_trucks([5, 5, 5, 5, 5, 5, 5, 5], 10) 4 ``` # Requirements Ensure your function adheres to the following: 1. Attempt to group the packages in such a way that maximizes the use of the truck capacity. 2. Use a greedy algorithm to feasibly solve this problem considering that an optimal solution is often computationally complex. 3. Handle edge cases gracefully, such as when an individual package weight exceeds truck capacity. 4. The function should be efficient and able to handle larger lists of packages within reasonable time constraints. # Notes - Packages must be grouped such that the sum of weights in each group does not exceed the given capacity. - You may assume that the weight list and capacities are positive integers. - The goal is to minimize the number of trucks used while respecting the maximum capacity limit of each truck. - Carefully consider the trade-offs of different algorithmic approaches to achieve an efficient solution.","solution":"from typing import List def pack_trucks(weights: List[int], capacity: int) -> int: Returns the minimum number of trucks required to transport all packages. :param weights: A list of integers where each integer represents the weight of a package. :param capacity: An integer representing the maximum capacity of a single truck. :return: Minimum number of trucks required. # Sort weights in descending order to place larger weights first weights.sort(reverse=True) trucks = [] for weight in weights: placed = False for i in range(len(trucks)): if trucks[i] + weight <= capacity: trucks[i] += weight placed = True break if not placed: trucks.append(weight) return len(trucks)"},{"question":"# Question: Sum of Digits Until Single Digit Statement: Write a function that repeatedly sums the digits of a given non-negative integer until the result is a single digit. Return the final single digit. Function Signature: ```python def single_digit_sum(num: int) -> int: ``` Input: - ( num ) (int): A non-negative integer. Output: - An integer representing the final single digit obtained by repeatedly summing the digits of ( num ). Constraints: - ( 0 leq num leq 10^9 ) Example: ```python >>> single_digit_sum(38) 2 # (3 + 8 = 11, 1 + 1 = 2) >>> single_digit_sum(0) 0 # (0 is already a single digit) >>> single_digit_sum(99999) 9 # (9+9+9+9+9 = 45, 4+5 = 9) >>> single_digit_sum(123456789) 9 # (1+2+3+4+5+6+7+8+9 = 45, 4+5 = 9) >>> single_digit_sum(1) 1 # (1 is already a single digit) ``` Notes: - Handle cases where the input number is already a single digit. - Ensure optimized handling for very large numbers within the given constraint.","solution":"def single_digit_sum(num: int) -> int: Repeatedly sums the digits of a given non-negative integer until the result is a single digit. Returns the final single digit. if num == 0: return 0 while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"# Problem Statement You are given an array of integers where each integer appears three times except for one unique integer which appears exactly once. Write a function `find_unique_number(nums: list) -> int` that finds and returns the unique integer that appears only once. Input - `nums`: A list of integers where each integer appears three times except for one unique integer. The length of the list will be in the range `3 <= len(nums) <= 10^4`. Output - An integer representing the unique integer that appears only once in the list. Constraints - The integers in the list will be in the range `-3 * 10^4 <= nums[i] <= 3 * 10^4`. Example ```python nums = [2, 2, 3, 2] print(find_unique_number(nums)) # Output: 3 nums = [0, 1, 0, 1, 0, 1, 99] print(find_unique_number(nums)) # Output: 99 ``` Requirements - Your implementation should use bit manipulation to achieve a time complexity of O(n) and a space complexity of O(1). - Avoid using extra space such as hashmaps or lists to achieve the desired result.","solution":"def find_unique_number(nums): Given an array where every element appears three times except for one, find that single one. ones, twos = 0, 0 for num in nums: # `twos` holds the bits that appear twice twos |= ones & num # `ones` holds the bits that appear once ones ^= num # `threes` holds the bits that appear three times threes = ones & twos # If a bit can be seen in `threes`, it should be erased from `ones` and `twos` ones &= ~threes twos &= ~threes return ones"},{"question":"# Problem Statement Write a function `uncommon_words` that takes two strings and returns a list of words that appear in exactly one of the input strings. Words are considered as sequences of characters separated by spaces. # Input * Two strings containing words separated by spaces. For example: `\\"apple banana apple grape\\"` and `\\"banana orange apple\\"` # Output * A list of words that are present in exactly one of the input strings, maintaining the order in which they appear in the input strings. For example: `[\\"grape\\", \\"orange\\"]` # Constraints 1. The input strings will each have at most `10^4` characters. 2. The words in the strings are case-sensitive. # Examples ```python >>> uncommon_words(\\"apple banana apple grape\\", \\"banana orange apple\\") [\\"grape\\", \\"orange\\"] >>> uncommon_words(\\"hello world\\", \\"world hello\\") [] >>> uncommon_words(\\"one two three\\", \\"four five six\\") [\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\"] ``` # Notes - If the word appears in both strings, it is not included in the output list. - Ensure that the words in the output list maintain their original order from the input strings. # Instructions Implement the function `uncommon_words` to solve the specified problem: ```python def uncommon_words(str1: str, str2: str) -> list: Given two strings, return a list of words that are present in exactly one of the input strings. # Your code here ```","solution":"def uncommon_words(str1: str, str2: str) -> list: Given two strings, return a list of words that are present in exactly one of the input strings. from collections import Counter # Split the strings into words and count their occurrences words1 = str1.split() words2 = str2.split() counter1 = Counter(words1) counter2 = Counter(words2) # Collect the words that appear in exactly one of the strings uncommon = [] # Check words in the first string for word in words1: if counter1[word] == 1 and word not in counter2: uncommon.append(word) # Check words in the second string for word in words2: if counter2[word] == 1 and word not in counter1: uncommon.append(word) return uncommon"},{"question":"You are given an array of integers `nums` and a positive integer `k`. You need to write a function `find_pairs(nums: List[int], k: int) -> int` that returns the number of unique pairs `(i, j)` such that `nums[i] + nums[j] == k` and `i < j`. # Example ```python >>> find_pairs([1, 2, 3, 4, 3], 6) 2 >>> find_pairs([1, 1, 1, 2, 3], 4) 1 >>> find_pairs([1], 2) 0 ``` # Constraints * `nums` will always be a list of integers with a length between 1 and 10^5. * `k` will always be a positive integer less than or equal to 10^9. # Requirements 1. Implement the function ensuring it runs efficiently for large inputs. 2. Consider edge cases such as: - Very small or very large values within the array. - Arrays with duplicate values. - Arrays where no pairs meet the criteria. 3. Raise a ValueError if `nums` contains any non-integer elements. # Performance Expectations * The solution should have a time complexity of O(n). * The space complexity should be kept within reasonable limits, preferably O(n). # Additional Notes * Consider using a hash set or dictionary to optimize the search for complement values in the array. * Ensure that each pair `(i, j)` is counted only once as a unique pair.","solution":"def find_pairs(nums, k): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] == k and i < j. if not all(isinstance(x, int) for x in nums): raise ValueError(\\"All elements in nums must be integers.\\") seen = set() pairs = set() for num in nums: complement = k - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"# Problem Statement: **Rotate Array** You are given an array `nums` and an integer `k`. Your task is to implement a function that rotates the array to the right by `k` steps. The function should modify the array in-place, meaning you cannot use extra space proportional to the input size. # Function Signature: ```python def rotate_array(nums: list, k: int) -> None: ``` # Input: - `nums`: A list of integers. - `k`: A non-negative integer representing the number of steps to rotate the array. # Output: - The function should modify the list `nums` in-place and should not return anything. # Constraints: - The length of the list (`len(nums)`) will be between 1 and 10^5. - The integer `k` will be between 0 and 10^5. # Example: ```python arr = [1, 2, 3, 4, 5, 6, 7] rotate_array(arr, 3) assert arr == [5, 6, 7, 1, 2, 3, 4] arr = [-1, -100, 3, 99] rotate_array(arr, 2) assert arr == [3, 99, -1, -100] arr = [1, 2, 3] rotate_array(arr, 4) # 4 steps to the right is the same as 1 step assert arr == [3, 1, 2] ``` # Implementation Requirements: 1. The function must perform the rotation in linear time O(n). 2. The function must work in-place and use O(1) additional space. # Scenario: Imagine you are working on a data streaming framework, where lists of data need to be processed in a rotating manner based on specific intervals. Implementing this in an efficient way ensures that the data processing pipeline remains performant even for large datasets. This problem tests your ability to manipulate lists in-place and optimize for time and space complexity. # Constraints to Consider: - Ensure that the function handles edge cases such as `k` greater than the length of the array. - Consider the scenario where no rotation is needed (i.e., `k` is 0).","solution":"def rotate_array(nums: list, k: int) -> None: Rotates the array nums to the right by k steps. This function modifies the nums list in-place. n = len(nums) k = k % n # Reducing k to the effective number of rotations. def reverse(start: int, end: int) -> None: Helper function to reverse the elements of the array from index start to end. while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # Step 1: Reverse the entire array reverse(0, n-1) # Step 2: Reverse the first k elements reverse(0, k-1) # Step 3: Reverse the remaining n-k elements reverse(k, n-1)"},{"question":"# Sorting with Custom Comparator Objective: Implement a function that sorts a list of strings based on a custom comparator. The strings should be sorted in such a way that concating any two strings `X` and `Y` should have `X + Y` > `Y + X` in lexicographical order. Instructions: 1. Implement the function `custom_sort(strings: List[str]) -> List[str]` to sort the list of strings based on the specified custom comparator. 2. Use of any built-in sorting functions is allowed, but you must define the custom comparator to guide the sorting process. 3. Handle edge cases where strings can be empty. Input: * `strings` - A list of strings to be sorted. - Constraints: * `1 <= len(strings) <= 10^4` * `0 <= len(strings[i]) <= 100` Output: * A list of strings sorted based on the custom comparator. Example: ```python assert custom_sort([\\"abc\\", \\"ab\\", \\"abcd\\", \\"b\\"]) == [\\"b\\", \\"abcd\\", \\"abc\\", \\"ab\\"] assert custom_sort([\\"20\\", \\"1\\", \\"3\\", \\"90\\", \\"21\\"]) == [\\"90\\", \\"3\\", \\"21\\", \\"20\\", \\"1\\"] assert custom_sort([\\"\\", \\"ab\\", \\"a\\"]) == [\\"ab\\", \\"a\\", \\"\\"] ``` Additional Notes: 1. The function should be efficient with a time complexity of O(n log n). 2. Pay attention to edge cases such as: * Empty strings within the input list. * Very large lists with up to 10^4 elements. * Strings of maximum length as specified in constraints. Good luck and happy coding!","solution":"from typing import List def custom_sort(strings: List[str]) -> List[str]: def custom_comparator(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort using the custom comparator sorted_strings = sorted(strings, key=lambda x: x, reverse=True) # Define a custom key for sorting from functools import cmp_to_key sorted_strings.sort(key=cmp_to_key(custom_comparator)) return sorted_strings"},{"question":"# Question: E-Commerce Inventory Management System You are developing an inventory management system for an e-commerce platform. Your task is to implement a Python class to manage the inventory of products. The class should allow adding new products, removing products, updating the quantity of existing products, and checking the inventory status. Class Signature ```python class InventoryManager: Manages the inventory for an e-commerce platform. def __init__(self): Initialize an empty inventory. pass def add_product(self, product_id: str, name: str, quantity: int) -> None: Adds a new product to the inventory. :param product_id: A unique identifier for the product. :param name: The name of the product. :param quantity: The quantity of the product to add. :raises ValueError: If product_id already exists or quantity is not positive. pass def remove_product(self, product_id: str) -> None: Removes a product from the inventory. :param product_id: The unique identifier of the product to remove. :raises ValueError: If product_id does not exist. pass def update_quantity(self, product_id: str, quantity: int) -> None: Updates the quantity of an existing product in the inventory. :param product_id: The unique identifier of the product. :param quantity: The new quantity of the product. :raises ValueError: If product_id does not exist or quantity is negative. pass def get_inventory_status(self) -> dict: Returns the current inventory status. :return: A dictionary where keys are product IDs and values are another dictionary containing the product name and quantity. pass ``` # Requirements 1. **Initialization**: The inventory should be initialized as empty. 2. **Adding Products**: Adding a product should ensure the product ID is unique and the quantity is positive. 3. **Removing Products**: Removing a product should ensure the product ID exists in the inventory. 4. **Updating Quantity**: Updating the quantity should ensure the product ID exists and the new quantity is not negative. 5. **Getting Inventory Status**: The inventory status should be a dictionary with product IDs as keys and another dictionary as values containing the product name and current quantity. # Constraints - Ensure thread safety for concurrent access (if applicable). - You may not assume product IDs follow a specific format. # Example ```python # Create an instance of the InventoryManager inventory = InventoryManager() # Add products inventory.add_product(\'P001\', \'Laptop\', 10) inventory.add_product(\'P002\', \'Smartphone\', 20) # Update quantity inventory.update_quantity(\'P001\', 15) # Remove product inventory.remove_product(\'P002\') # Get inventory status status = inventory.get_inventory_status() print(status) # Output: {\'P001\': {\'name\': \'Laptop\', \'quantity\': 15}} ```","solution":"class InventoryManager: Manages the inventory for an e-commerce platform. def __init__(self): Initialize an empty inventory. self.inventory = {} def add_product(self, product_id: str, name: str, quantity: int) -> None: Adds a new product to the inventory. :param product_id: A unique identifier for the product. :param name: The name of the product. :param quantity: The quantity of the product to add. :raises ValueError: If product_id already exists or quantity is not positive. if product_id in self.inventory: raise ValueError(f\\"Product ID {product_id} already exists.\\") if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") self.inventory[product_id] = {\'name\': name, \'quantity\': quantity} def remove_product(self, product_id: str) -> None: Removes a product from the inventory. :param product_id: The unique identifier of the product to remove. :raises ValueError: If product_id does not exist. if product_id not in self.inventory: raise ValueError(f\\"Product ID {product_id} does not exist.\\") del self.inventory[product_id] def update_quantity(self, product_id: str, quantity: int) -> None: Updates the quantity of an existing product in the inventory. :param product_id: The unique identifier of the product. :param quantity: The new quantity of the product. :raises ValueError: If product_id does not exist or quantity is negative. if product_id not in self.inventory: raise ValueError(f\\"Product ID {product_id} does not exist.\\") if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") self.inventory[product_id][\'quantity\'] = quantity def get_inventory_status(self) -> dict: Returns the current inventory status. :return: A dictionary where keys are product IDs and values are another dictionary containing the product name and quantity. return self.inventory"},{"question":"# Problem Statement You\'ve been consulted to enhance a text processing module that identifies specific patterns in text segments. Your task is to write a function that counts the number of vowels in a given string. This exercise is designed to test your proficiency with string manipulation and efficient iteration. # Function Signature ```python def count_vowels(input_string: str) -> int: pass ``` # Input - A string (input_string) (1 ≤ length of (input_string) ≤ 10^5). # Output - Return an integer representing the count of vowels in (input_string). Vowels include \'a\', \'e\', \'i\', \'o\', \'u\' (both lowercase and uppercase). # Constraints - Ensure your solution has a time complexity of (O(n)), where (n) is the length of the input string. - Be careful with case sensitivity; \'A\' and \'a\' should both be counted as vowels. # Examples 1. **Example 1:** - Input: `input_string = \\"hello\\"` - Output: `2` - Explanation: The vowels are `e` and `o`. 2. **Example 2:** - Input: `input_string = \\"Beautiful\\"` - Output: `5` - Explanation: The vowels are `e`, `a`, `u`, `i`, and `u`. 3. **Example 3:** - Input: `input_string = \\"xyz\\"` - Output: `0` - Explanation: There are no vowels in the string \\"xyz\\". # Performance Requirements Your solution should maintain a linear time complexity, (O(n)), and avoid using additional space beyond what is necessary for the function execution.","solution":"def count_vowels(input_string: str) -> int: Returns the count of vowels in the input string. Vowels are \'a\', \'e\', \'i\', \'o\', \'u\' and their uppercase counterparts. vowels = set(\\"aeiouAEIOU\\") return sum(1 for char in input_string if char in vowels)"},{"question":"# Context Searching for the k-th smallest element in an unordered list is a common problem that has multiple solutions, including deterministic and randomized algorithms. However, certain special lists, such as those with duplicate elements or specific patterns, can benefit from tailored approaches. # Question Write a function `kth_smallest_with_duplicates` that finds the k-th smallest element in a list that may contain duplicate values. Your function should ensure that it handles duplicates correctly and returns the k-th smallest unique element. If k is larger than the number of unique elements, raise a ValueError. # Function Signature ```python def kth_smallest_with_duplicates(array: List[int], k: int) -> int: Finds the k-th smallest unique element in the given list. :param array: The list of integers, which may contain duplicates. :param k: The k-th position (1-indexed) to find the smallest unique element. :return: The k-th smallest unique element in the list. :raises ValueError: If k is larger than the number of unique elements. ``` # Input * `array`: List of integers, e.g., `[10, 20, 20, 7, 1, -5, 8, -5]` * `k`: The k-th position (1-indexed) to find the smallest unique element, e.g., `3` # Output * The k-th smallest unique element in the list, e.g., `10` # Constraints * The input list `array` may contain duplicate values. * `k` is a positive integer. * If `k` is larger than the number of unique elements, the function should raise a ValueError. # Examples ```python assert kth_smallest_with_duplicates([10, 20, 20, 7, 1, -5, 8, -5], 3) == 10 assert kth_smallest_with_duplicates([5, 3, 8, 7, 7, 3], 2) == 5 assert kth_smallest_with_duplicates([2, 2, 2, 3, 3, 3], 1) == 2 # Raises ValueError because k is larger than the number of unique elements try: kth_smallest_with_duplicates([2, 2, 2, 3, 3, 3], 3) except ValueError as e: assert str(e) == \\"k is larger than the number of unique elements\\" ```","solution":"from typing import List def kth_smallest_with_duplicates(array: List[int], k: int) -> int: Finds the k-th smallest unique element in the given list. :param array: The list of integers, which may contain duplicates. :param k: The k-th position (1-indexed) to find the smallest unique element. :return: The k-th smallest unique element in the list. :raises ValueError: If k is larger than the number of unique elements. unique_elements = sorted(set(array)) if k > len(unique_elements): raise ValueError(\\"k is larger than the number of unique elements\\") return unique_elements[k - 1]"},{"question":"# Problem: You have been given a list of integers representing the elevation of a 2D landscape at a particular point. After heavy rainfall, water may be trapped in valleys formed by the elevations. Your task is to calculate the total amount of water that can be trapped in the landscape. # Objective: Implement the function `trapRainWater(heights: List[int]) -> int` that takes a list of integers representing the elevation at each index and returns the total amount of water that can be trapped. # Function Signature: ```python def trapRainWater(heights: List[int]) -> int: ``` # Input: - `heights`: A list of integers where each integer represents the elevation height at that index. (0 <= len(heights) <= 1000, 0 <= heights[i] <= 1000) # Output: - An integer representing the total units of water trapped. # Example: ```python heights = [0, 1, 2, 1, 0, 1, 3, 2, 1, 2, 1] output = trapRainWater(heights) # Expected output: 5 heights = [4, 2, 0, 3, 2, 5] output = trapRainWater(heights) # Expected output: 9 ``` # Explanation: For the first example, the trapped water occupies the indices that form valleys, such as between elevations 2 and 3. # Guidance: In your function: 1. Initialize two pointers, one starting from the beginning of the list and the other from the end. 2. Keep track of the maximum elevation encountered from both ends. 3. Use the two-pointer approach to calculate the water level at each index, considering the smaller of the current maximums from either end. 4. Accumulate the trapped water by subtracting the current elevation from the water level. 5. Return the total trapped water.","solution":"from typing import List def trapRainWater(heights: List[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += right_max - heights[right] return water_trapped"},{"question":"# Problem Statement Optimize a Path-Finding Function with A* Algorithm Overview You are given a grid that represents a maze. Each cell in the grid can either be free (0) or blocked (1). Your task is to find the shortest path from the top-left corner to the bottom-right corner using the A* search algorithm. The A* algorithm combines the benefits of Dijkstra\'s algorithm and a Greedy Best-First Search, using a heuristic to estimate the shortest path. Task Implement the A* search algorithm to find the shortest path in the given grid. You need to design a function `astar` that returns the path from the start to the end if one exists, or `None` if no path exists. Requirements 1. **Heuristic Function**: Implement the A* algorithm using the Manhattan distance as the heuristic. 2. **Grid Navigation**: The path can only move up, down, left, or right. 3. **Edge Cases**: Handle cases where the start or end positions are blocked. Input - **Grid**: A 2D list of integers representing the maze. ```text grid: List[List[int]] ``` where `0` represents a free cell and `1` represents a blocked cell. - **Start and End Points**: The starting point is always at the top-left corner `(0, 0)` and the ending point is at the bottom-right corner `(n-1, m-1)`. Output - Return a list of tuples representing the path from start to end, including both endpoints. - If no path is found, return `None`. Constraints - The grid will always be rectangular and non-empty. - The grid size will not exceed 1000x1000. Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0] ] # Sample function call path = astar(grid) print(path) # Expected output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 1), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)] ``` **Note**: Your solution should implement the A* algorithm efficiently, ensuring it can handle grids up to the maximum size constraint.","solution":"import heapq def astar(grid): n, m = len(grid), len(grid[0]) def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(node): neighbors = [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for d in directions: nx, ny = node[0] + d[0], node[1] + d[1] if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0: neighbors.append((nx, ny)) return neighbors start = (0, 0) goal = (n - 1, m - 1) if grid[start[0]][start[1]] == 1 or grid[goal[0]][goal[1]] == 1: return None open_set = [] heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start)) came_from = {} g_score = {node: float(\'inf\') for row in grid for node in [(i, j) for i, row in enumerate(grid) for j, col in enumerate(row)]} g_score[start] = 0 while open_set: _, current_g, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = current_g + 1 if tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score, tentative_g_score, neighbor)) return None"},{"question":"# Context Your task is to showcase your proficiency in data manipulation and functional programming by implementing a series of transformations on a sequence of numbers. Specifically, you are required to implement functions to filter, map, and reduce a list based on provided criteria. # Question Implement three functions `filter_even(numbers: list) -> list`, `square(numbers: list) -> list`, and `product(numbers: list) -> int` in Python. The `filter_even` function should filter out even numbers from the provided list. The `square` function should return a list of the squares of the numbers. The `product` function should return the product of all numbers in the list. Ensure to handle edge cases and write efficient code. Input Format - A list of integers for each function. Output Format - A list of integers representing the even numbers for the `filter_even` function. - A list of integers representing the squares of the numbers for the `square` function. - An integer representing the product of the numbers for the `product` function. Example ```python >>> filter_even([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> square([1, 2, 3, 4]) [1, 4, 9, 16] >>> product([1, 2, 3, 4]) 24 >>> filter_even([]) [] >>> square([]) [] >>> product([]) 1 ``` Constraints - The input list may contain zero or more integers. - If the input list is empty, appropriate empty outputs should be returned for `filter_even` and `square`. The `product` function should return 1 for an empty list. - Functions should manage large input sizes efficiently. # Performance Requirements - The `filter_even` function should have O(n) time complexity. - The `square` function should have O(n) time complexity. - The `product` function should have O(n) time complexity. - All functions should aim for optimized space usage, ideally O(n) for list transformations and O(1) for product calculations.","solution":"def filter_even(numbers: list) -> list: Returns a list of even numbers from the provided list. return [num for num in numbers if num % 2 == 0] def square(numbers: list) -> list: Returns a list of the squares of the numbers in the provided list. return [num ** 2 for num in numbers] def product(numbers: list) -> int: Returns the product of all numbers in the provided list. if not numbers: return 1 prod = 1 for num in numbers: prod *= num return prod"},{"question":"You are tasked with implementing a function to compute the greatest common divisor (GCD) of a list of integers. The GCD of a list of integers is the largest positive integer that divides all of the integers in the list without leaving a remainder. # Requirements: Implement a function `compute_gcd_list(nums: List[int]) -> int` with the following parameter: * `nums` (List[int]): A list of integers. (1 ≤ len(nums) ≤ 10^6, -10^6 ≤ nums[i] ≤ 10^6) # Expected Output: The function should return an integer representing the GCD of the given list of integers. # Constraints: * If the list is empty, return 0. * If the list contains a mix of positive and negative integers, the GCD should consider the absolute values of these integers. * Handle edge cases where the list contains only one element. # Examples: ```python >>> compute_gcd_list([24, 36, 48]) 12 >>> compute_gcd_list([10, 20, 30, 40]) 10 >>> compute_gcd_list([-12, -15, -9]) 3 >>> compute_gcd_list([5]) 5 >>> compute_gcd_list([]) 0 ``` # Performance Considerations: Ensure the implementation can handle the upper limits of input size efficiently, utilizing appropriate algorithms such as the Euclidean algorithm for finding GCD.","solution":"from typing import List import math from functools import reduce def compute_gcd_list(nums: List[int]) -> int: Computes the GCD of a list of integers. Parameters: nums (List[int]): A list of integers. Returns: int: The GCD of the integers in the list. if not nums: return 0 # Using reduce and math.gcd to compute the GCD of the list return reduce(lambda x, y: math.gcd(x, abs(y)), nums, abs(nums[0]))"},{"question":"# Coding Assessment Question In the realm of data processing, you are tasked with implementing a function that removes duplicate integers from an unsorted linked list. The goal is to create a function `remove_duplicates` that will take the `head` of a singly linked list and return the head of the modified list with all duplicate nodes removed. # Inputs * `head`: The head node of a singly linked list where each node contains an integer value. # Outputs * The head node of the linked list after all duplicates have been removed. # Constraints * The linked list will have at least one node. * Node values are within the range of ([-10^4, 10^4]). # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example usage: # Linked list: 1 -> 3 -> 5 -> 3 -> 7 -> 1 # After removing duplicates: 1 -> 3 -> 5 -> 7 head = ListNode(1, ListNode(3, ListNode(5, ListNode(3, ListNode(7, ListNode(1)))))) result = remove_duplicates(head) # Convert result to list for easy verification: def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result print(linked_list_to_list(result)) # Output: [1, 3, 5, 7] ``` # Implementation You need to complete the implementation of the `remove_duplicates` function: ```python def remove_duplicates(head): if not head: return None current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): if not head: return None current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"Question # Problem Statement You are working on a reservation system for a small conference room. The room can be reserved for a set period of time, given that there are no overlapping reservations. You need to design a class that helps manage room reservations by allowing the creation, checking, and cancellation of reservations. # Instructions Complete the implementation of the `ReservationSystem` class with the following methods: 1. **Creating a Reservation**: - Method: `reserve(self, start_time: str, end_time: str) -> bool` - Description: Attempts to create a reservation for the room. The reservation can only be created if it doesn\'t overlap with any existing reservations. - Input: `start_time` and `end_time` (strings in the format \\"HH:MM\\", using a 24-hour clock) - Output: Returns `True` if the reservation was successful, `False` otherwise. 2. **Checking a Reservation**: - Method: `is_available(self, start_time: str, end_time: str) -> bool` - Description: Checks if the room is available for the given time period. - Input: `start_time` and `end_time` (strings in the format \\"HH:MM\\", using a 24-hour clock) - Output: Returns `True` if the room is available, `False` otherwise. 3. **Cancelling a Reservation**: - Method: `cancel(self, start_time: str) -> bool` - Description: Cancels an existing reservation that starts at the specified start time. - Input: `start_time` (a string in the format \\"HH:MM\\", using a 24-hour clock) - Output: Returns `True` if the cancellation was successful, `False` otherwise. # Example Usage ```python class ReservationSystem: def __init__(self): self.reservations = [] # Holds tuples of (start_time, end_time) def reserve(self, start_time: str, end_time: str) -> bool: Attempts to make a reservation. if not self.is_available(start_time, end_time): return False self.reservations.append((start_time, end_time)) self.reservations.sort() # Keep reservations sorted by start_time return True def is_available(self, start_time: str, end_time: str) -> bool: Checks if the room is available for the requested time slot. start = self._time_to_minutes(start_time) end = self._time_to_minutes(end_time) for (res_start, res_end) in self.reservations: res_start = self._time_to_minutes(res_start) res_end = self._time_to_minutes(res_end) if start < res_end and end > res_start: return False return True def cancel(self, start_time: str) -> bool: Cancels an existing reservation. for i, (res_start, res_end) in enumerate(self.reservations): if res_start == start_time: del self.reservations[i] return True return False def _time_to_minutes(self, time_str: str) -> int: Converts a time string \\"HH:MM\\" into the number of minutes since midnight. hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes # Example usage reservation_system = ReservationSystem() # Creating a reservation from 09:00 to 11:00 assert reservation_system.reserve(\\"09:00\\", \\"11:00\\") == True # Trying to create an overlapping reservation from 10:00 to 12:00 assert reservation_system.reserve(\\"10:00\\", \\"12:00\\") == False # Checking if the room is available from 11:00 to 12:00 assert reservation_system.is_available(\\"11:00\\", \\"12:00\\") == True # Cancelling the reservation starting at 09:00 assert reservation_system.cancel(\\"09:00\\") == True # Checking if the room is available from 10:00 to 12:00 after cancellation assert reservation_system.is_available(\\"10:00\\", \\"12:00\\") == True ``` Write tests for the following scenarios: 1. Creating non-overlapping reservations. 2. Checking availability when the room is fully booked. 3. Cancelling a reservation and verifying availability afterward. 4. Edge cases such as cancelling a non-existent reservation.","solution":"class ReservationSystem: def __init__(self): self.reservations = [] # Holds tuples of (start_time, end_time) def reserve(self, start_time: str, end_time: str) -> bool: Attempts to make a reservation. if not self.is_available(start_time, end_time): return False self.reservations.append((start_time, end_time)) self.reservations.sort() # Keep reservations sorted by start_time return True def is_available(self, start_time: str, end_time: str) -> bool: Checks if the room is available for the requested time slot. start = self._time_to_minutes(start_time) end = self._time_to_minutes(end_time) for (res_start, res_end) in self.reservations: res_start = self._time_to_minutes(res_start) res_end = self._time_to_minutes(res_end) if start < res_end and end > res_start: return False return True def cancel(self, start_time: str) -> bool: Cancels an existing reservation. for i, (res_start, res_end) in enumerate(self.reservations): if res_start == start_time: del self.reservations[i] return True return False def _time_to_minutes(self, time_str: str) -> int: Converts a time string \\"HH:MM\\" into the number of minutes since midnight. hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes"},{"question":"# Coding Question Context In the realm of data handling, it\'s common to manage sets of integers and perform various operations on them. One such important operation is to verify if two sets are disjoint. Two sets are disjoint if they have no elements in common. Problem Statement Write a function `are_disjoint_sets` that takes two lists of integers, representing two sets, and returns a boolean value indicating whether the two sets are disjoint. Function Signature ```python def are_disjoint_sets(set1: list[int], set2: list[int]) -> bool: pass ``` Input * `set1`: A list of integers representing the first set. (0 <= len(set1) <= 10^5) * `set2`: A list of integers representing the second set. (0 <= len(set2) <= 10^5) Output * The function should return `True` if the two sets are disjoint (i.e., no elements in common), and `False` otherwise. Constraints * Each integer will be in the range of -10^9 to 10^9. * The input lists may be empty. Example ```python assert are_disjoint_sets([1, 2, 3, 4], [5, 6, 7, 8]) == True assert are_disjoint_sets([1, 2, 3], [3, 4, 5]) == False assert are_disjoint_sets([], []) == True assert are_disjoint_sets([1, 1, 1, 1], [2, 2, 2, 2]) == True ``` By matching the key aspects as outlined—coding complexity, style, scope, and topic alignment with integer manipulation—the above question should fit seamlessly into the existing set of programming assessments.","solution":"def are_disjoint_sets(set1: list[int], set2: list[int]) -> bool: Function to determine if two sets of integers are disjoint. Parameters: set1 (list[int]): The first set of integers. set2 (list[int]): The second set of integers. Returns: bool: True if the sets are disjoint, False otherwise. # Convert both lists to sets set1_as_set = set(set1) set2_as_set = set(set2) # Check if the intersection of both sets is empty return set1_as_set.isdisjoint(set2_as_set)"},{"question":"# Question: Matrix Transpose and Dot Product Calculation In data analysis, matrix operations are essential. You are tasked with implementing two functions to calculate the transpose of a matrix and the dot product of two matrices. Function 1: `matrix_transpose` ```python def matrix_transpose(matrix: List[List[int]]) -> List[List[int]]: Calculate the transpose of a given matrix. Parameters: matrix (List[List[int]]) : A 2D list (list of lists) where each list represents a row in the matrix. Returns: List[List[int]] : The transpose of the input matrix. ``` Function 2: `matrix_dot_product` ```python def matrix_dot_product(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Calculate the dot product of two matrices. Parameters: matrix_a (List[List[int]]) : The first matrix in the dot product operation. matrix_b (List[List[int]]) : The second matrix in the dot product operation. Returns: List[List[int]] : The resulting matrix from the dot product operation. ``` # Constraints: 1. The input matrices for `matrix_transpose` and `matrix_dot_product` will be non-empty 2D lists. 2. For `matrix_dot_product`, the number of columns in `matrix_a` must be equal to the number of rows in `matrix_b`. 3. Raise a `ValueError` in `matrix_dot_product` if the number of columns in `matrix_a` does not match the number of rows in `matrix_b` with the message: \\"Incompatible matrices for dot product.\\" # Example: ```python >>> matrix_transpose([[1, 2], [3, 4], [5, 6]]) # Expected output: [[1, 3, 5], [2, 4, 6]] >>> matrix_transpose([[1]]) # Expected output: [[1]] >>> matrix_dot_product([[1, 2], [3, 4]], [[2, 0], [1, 2]]) # Expected output: [[4, 4], [10, 8]] >>> matrix_dot_product([[2]], [[3]]) # Expected output: [[6]] ``` # Additional Requirements: 1. Ensure the functions handle edge cases effectively, such as when the matrices are 1x1. 2. Adhere to appropriate time and space complexity constraints based on the operations.","solution":"from typing import List def matrix_transpose(matrix: List[List[int]]) -> List[List[int]]: Calculate the transpose of a given matrix. Args: matrix (List[List[int]]): A 2D list (list of lists) where each list represents a row in the matrix. Returns: List[List[int]]: The transpose of the input matrix. return [list(row) for row in zip(*matrix)] def matrix_dot_product(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Calculate the dot product of two matrices. Args: matrix_a (List[List[int]]): The first matrix in the dot product operation. matrix_b (List[List[int]]): The second matrix in the dot product operation. Returns: List[List[int]]: The resulting matrix from the dot product operation. Raises: ValueError: If the number of columns in matrix_a does not match the number of rows in matrix_b. if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Incompatible matrices for dot product.\\") # Transpose matrix_b for easier handling. matrix_b_transposed = matrix_transpose(matrix_b) # Calculate dot product dot_product = [ [ sum(a * b for a, b in zip(row_a, col_b)) for col_b in matrix_b_transposed ] for row_a in matrix_a ] return dot_product"},{"question":"# Recursive Coin Change Problem You have a set of coins, and your goal is to determine the number of ways you can make change for a given amount using these coins. Implement a recursive solution to solve the coin change problem. **Function Signature**: ```python def coin_change_ways(coins: List[int], amount: int) -> int: ``` **Input**: * `coins`: (List of Integers) A list of distinct integers representing the coin denominations available. * `amount`: (Integer) The total amount of money you need to make change for. **Output**: * An integer representing the number of ways to make change for the given `amount` using any number of coins from the `coins` list. If no combination can make the exact amount, return 0. **Constraints**: * 1 ≤ len(coins) ≤ 50 * 1 ≤ coins[i] ≤ 100 * 0 ≤ amount ≤ 10^4 **Example**: ```python >>> coins = [1, 2, 5] >>> amount = 5 >>> coin_change_ways(coins, amount) 4 ``` Explanation: There are four ways to make change for 5 units: 1. 1+1+1+1+1 2. 1+1+1+2 3. 1+2+2 4. 5 **Important Considerations**: * Think recursively to break the problem into smaller subproblems. * Ensure to handle the base case where the amount is 0 (only one way to form 0, by using no coins). Implement the `coin_change_ways` function: Good luck!","solution":"from typing import List def coin_change_ways(coins: List[int], amount: int) -> int: Returns the number of ways to make change for the given amount using the provided coin denominations. def helper(coins, m, amount): if amount == 0: return 1 if amount < 0: return 0 if m <= 0 and amount > 0: return 0 return helper(coins, m - 1, amount) + helper(coins, m, amount - coins[m - 1]) return helper(coins, len(coins), amount)"},{"question":"Task Write a Python function that reads in a CSV (Comma Separated Values) file containing student names and their respective scores across various subjects, then calculates and returns the average score for each student. Input * A string representing the file path to a CSV file. * The CSV file contains multiple rows, each representing a student. The first column is the student\'s name, and the subsequent columns contain scores in different subjects. Output * A dictionary where the keys are student names and the values are their average scores. Constraints * The function should handle potential file read errors gracefully by displaying a meaningful error message. * The CSV file is assumed to be well-formed with student names and scores only. Performance * Aim to minimize file I/O operations. * Ensure the solution scales efficiently with a large number of students and subjects. Function Signature ```python def calculate_average_scores(file_path: str) -> dict: ``` Example Given a CSV file `students_scores.csv` with the following content: ``` Name,Math,Physics,Chemistry Alice,80,90,85 Bob,70,85,80 Charlie,75,95,85 ``` Calling the function as shown below: ```python result = calculate_average_scores(\\"students_scores.csv\\") print(result) ``` Expected output: ```python { \\"Alice\\": 85.0, \\"Bob\\": 78.33, \\"Charlie\\": 85.0 } ``` Hint Use the `csv` module from the Python Standard Library to handle reading the CSV file.","solution":"import csv def calculate_average_scores(file_path: str) -> dict: Calculates the average score for each student from a CSV file. :param file_path: The path to the CSV file. :return: A dictionary where the keys are student names and the values are their average scores. average_scores = {} try: with open(file_path, \'r\') as file: reader = csv.reader(file) headers = next(reader) # Skip the header row for row in reader: name = row[0] scores = list(map(float, row[1:])) average_score = sum(scores) / len(scores) average_scores[name] = round(average_score, 2) except FileNotFoundError: print(f\\"Error: The file {file_path} was not found.\\") except Exception as e: print(f\\"Error: An unexpected error occurred. {str(e)}\\") return average_scores"},{"question":"# Problem Statement Imagine you are a logistics coordinator responsible for planning the shipment of goods. You\'re working with a number of different containers, and each container has a weight limit. You need to determine the minimum and the maximum weight of goods that can be shipped using these containers, provided the total weight of goods has to be an exact multiple of the smallest container\'s weight limit. Your task is to write a function `find_min_max_weights(container_weights, goods_weight)` that calculates the minimum and maximum weights of goods that can be shipped using the given containers. The solution should account for the fact that the total goods weight must be a multiple of the smallest container\'s weight. # Input and Output * **Input**: * `container_weights` - a list of integers representing the weight limits of different containers. * `goods_weight` - an integer representing the weight of goods to be shipped. * **Output**: * A tuple of two integers representing: 1. The minimum weight possible (in the smallest container\'s multiples). 2. The maximum weight possible (in the smallest container\'s multiples). # Constraints * The container weights and goods weight are positive integers. * The list of container weights will have at least one container. # Example ```python container_weights = [5, 10, 15] goods_weight = 40 Output: (40, 45) ``` In this example, the smallest container weight is 5. Therefore, the total weight of goods should be a multiple of 5. - The minimum weight: 40 (as it’s already a multiple of 5). - The maximum weight: 45 (as the next possible weight over 40 that is multiple of smallest container weight is 45). # Task Write a function with the following signature: ```python def find_min_max_weights(container_weights: List[int], goods_weight: int) -> Tuple[int, int]: # Your code here pass ``` Implement this function to meet the requirements outlined above.","solution":"def find_min_max_weights(container_weights, goods_weight): Returns the minimum and maximum weights of goods that can be shipped using the given containers\' weights, such that the total weight is an exact multiple of the smallest container\'s weight limit. min_container_weight = min(container_weights) # Find the minimum weight possible if goods_weight % min_container_weight == 0: min_weight = goods_weight else: min_weight = (goods_weight // min_container_weight) * min_container_weight # Find the maximum weight possible max_weight = min_weight if goods_weight % min_container_weight != 0: max_weight += min_container_weight return (min_weight, max_weight)"},{"question":"# Array Rotation Check **Objective**: Assess the student\'s understanding of array manipulation, specifically rotating (shifting) and comparing arrays. **Task**: Write a Python function `is_rotation` that checks if one array is a rotation of another array. A rotation means that the elements can be shifted circularly. **Function Signature**: ```python def is_rotation(array1: list[int], array2: list[int]) -> bool: Parameters: - array1 (list[int]): The original array. - array2 (list[int]): The array to check if it is a rotation of the original array. Returns: - bool: True if array2 is a rotation of array1, False otherwise. ``` **Input**: - Two lists of integers `array1` and `array2`. **Output**: - A boolean value indicating if `array2` is a rotation of `array1`. **Example**: ```python array1 = [1, 2, 3, 4, 5] array2 = [3, 4, 5, 1, 2] is_rotation(array1, array2) # Expected output: True array1 = [1, 2, 3, 4, 5] array2 = [3, 4, 5, 6, 2] is_rotation(array1, array2) # Expected output: False ``` **Constraints**: - Do not use brute force methods (e.g., nested loops checking all possible rotations). - Ensure the function runs in linear time. - Handle the case where arrays of different lengths should immediately return False. **Notes**: - Use appropriate data structures to achieve the check efficiently. - Consider edge cases such as empty arrays or arrays with duplicate elements. **Testing**: - Use unit tests to validate your solution with various input cases for correctness and performance.","solution":"def is_rotation(array1: list[int], array2: list[int]) -> bool: Checks if array2 is a rotation of array1. if len(array1) != len(array2): return False # Concatenate array1 to itself concatenated = array1 + array1 # Convert lists to strings to use substring check str_concat = \'-\'.join(map(str, concatenated)) str_array2 = \'-\'.join(map(str, array2)) return str_array2 in str_concat"},{"question":"# Question: Convert Dates Between Different Formats You are tasked with writing three functions to handle date conversions between various formats. Each function has distinct input and output formats for parsing and formatting dates, ensuring correct handling of valid dates and appropriate error handling for invalid inputs. Function 1: `convert_ddmmyyyy_to_mmddyyyy(date_str: str) -> str` **Convert a date from `DD-MM-YYYY` format to `MM-DD-YYYY` format.** - **Input**: - `date_str` (str): Date string in `DD-MM-YYYY` format. - **Output**: - `str`: Date in `MM-DD-YYYY` format. - **Constraints**: - The input date must be a valid date in `DD-MM-YYYY` format. - The function should raise a `ValueError` if the date format is incorrect or if the date is invalid (e.g., `31-02-2020`). Function 2: `days_between_dates(start_date: str, end_date: str) -> int` **Calculate the number of days between two dates.** - **Input**: - `start_date` (str): Start date in `YYYY-MM-DD` format. - `end_date` (str): End date in `YYYY-MM-DD` format. - **Output**: - `int`: The number of days between `start_date` and `end_date`. - **Constraints**: - Both dates must be valid dates in `YYYY-MM-DD` format. - The function should raise a `ValueError` if any date format is incorrect or if a date is invalid. - The end date must be on or after the start date. Function 3: `add_days_to_date(date_str: str, days: int) -> str` **Add a specified number of days to a date and return the resulting date.** - **Input**: - `date_str` (str): Initial date in `YYYY-MM-DD` format. - `days` (int): Number of days to add (can be positive or negative). - **Output**: - `str`: The resulting date after adding/subtracting days, in `YYYY-MM-DD` format. - **Constraints**: - The input date must be a valid date in `YYYY-MM-DD` format. - The function should raise a `ValueError` if the date format is incorrect or if the date is invalid. # Testing & Validation - Include checks for invalid date inputs such as non-existent dates (e.g., `31-02-2020`). - Ensure correct exception handling for invalid formats and out-of-bounds dates. - Use various test cases to validate the correctness of your implementation.","solution":"from datetime import datetime, timedelta def convert_ddmmyyyy_to_mmddyyyy(date_str): try: date = datetime.strptime(date_str, \'%d-%m-%Y\') return date.strftime(\'%m-%d-%Y\') except ValueError: raise ValueError(\\"Invalid date format or date\\") def days_between_dates(start_date, end_date): try: start = datetime.strptime(start_date, \'%Y-%m-%d\') end = datetime.strptime(end_date, \'%Y-%m-%d\') if end < start: raise ValueError(\\"End date must be on or after the start date\\") delta = end - start return delta.days except ValueError: raise ValueError(\\"Invalid date format or date\\") def add_days_to_date(date_str, days): try: date = datetime.strptime(date_str, \'%Y-%m-%d\') new_date = date + timedelta(days=days) return new_date.strftime(\'%Y-%m-%d\') except ValueError: raise ValueError(\\"Invalid date format or date\\")"},{"question":"# Coding Assessment Question **Title**: Validate and Serialize Nested JSON Objects **Objective**: To assess the student\'s skills in working with JSON data, including validation, normalization, and serialization in Python. Problem Statement: You are given a JSON object that may contain nested structures (dictionaries within dictionaries). Your task is to implement a function that validates the given JSON structure according to specified rules, normalizes any nested structures, and then serializes the JSON object into a string. Here are the steps to complete the task: 1. **Validation**: Ensure each key in the JSON object and its nested dictionaries has: - Keys that are non-empty strings. - Values that are either strings, numbers, lists, or dictionaries. - Lists that only contain strings, numbers, or dictionaries. 2. **Normalization**: Flatten any lists or nested dictionaries such that: - Lists should be converted into dictionaries with keys being the index values as strings. - Nested dictionaries should be flattened using dot notation for composite keys. 3. **Serialization**: Convert the normalized JSON object into a properly formatted JSON string. Function Signature ```python import json from typing import Any, Dict def validate_and_serialize(json_obj: Dict[str, Any]) -> str: ... ``` Input - A `json_obj` dictionary representing the JSON object. Output - A `str` representing the JSON object with normalized structure and valid data. Constraints - Keys and values must adhere to the validation rules. - Nested structures must be correctly flattened. - Invalid JSON should raise appropriate exceptions. Examples ```python # Example 1: Simple valid JSON json_obj = { \\"name\\": \\"John\\", \\"age\\": 30, \\"address\\": { \\"city\\": \\"New York\\", \\"zip\\": 10001 } } expected_output = \'{\\"name\\": \\"John\\", \\"age\\": 30, \\"address.city\\": \\"New York\\", \\"address.zip\\": 10001}\' assert json.loads(validate_and_serialize(json_obj)) == json.loads(expected_output) # Example 2: JSON with nested lists and dictionaries json_obj = { \\"user\\": { \\"id\\": 123, \\"name\\": \\"Alice\\", \\"roles\\": [\\"admin\\", \\"editor\\"], \\"settings\\": { \\"theme\\": \\"dark\\", \\"notifications\\": { \\"email\\": True, \\"sms\\": False } } } } expected_output = \'{\\"user.id\\": 123, \\"user.name\\": \\"Alice\\", \\"user.roles.0\\": \\"admin\\", \\"user.roles.1\\": \\"editor\\", \\"user.settings.theme\\": \\"dark\\", \\"user.settings.notifications.email\\": true, \\"user.settings.notifications.sms\\": false}\' assert json.loads(validate_and_serialize(json_obj)) == json.loads(expected_output) # Example 3: Invalid JSON (e.g., non-string key) json_obj = { 123: \\"invalid\\" } try: validate_and_serialize(json_obj) except ValueError as e: assert str(e) == \\"All keys must be non-empty strings.\\" ``` **Notes** - Use proper exception handling to raise meaningful errors when validation fails. - Ensure the serialized JSON string is formatted correctly and handles typical edge cases. - Follow clean coding practices and maintain readability and maintainability in your implementation.","solution":"import json from typing import Any, Dict def validate_and_serialize(json_obj: Dict[str, Any]) -> str: def is_valid_key(key): if not isinstance(key, str) or not key: raise ValueError(\\"All keys must be non-empty strings.\\") def is_valid_value(value): if not isinstance(value, (str, int, float, list, dict, bool)): raise ValueError(\\"Values must be strings, numbers, lists, dictionaries, or booleans.\\") if isinstance(value, list): for item in value: is_valid_value(item) elif isinstance(value, dict): for k, v in value.items(): is_valid_key(k) is_valid_value(v) def flatten_dict(d, parent_key=\'\'): items = [] for k, v in d.items(): new_key = parent_key + \'.\' + k if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key).items()) elif isinstance(v, list): list_dict = {f\\"{new_key}.{i}\\": item for i, item in enumerate(v)} items.extend(flatten_dict(list_dict).items()) else: items.append((new_key, v)) return dict(items) for key, value in json_obj.items(): is_valid_key(key) is_valid_value(value) flattened_json = flatten_dict(json_obj) return json.dumps(flattened_json)"},{"question":"# Coding Question **Scenario:** An e-commerce platform tracks user ratings for different products. One important feature is to summarize and analyze the ratings to offer better recommendations and insights. For this challenge, you need to write a function to determine the median rating of a given set of ratings. # Problem Statement: You are given a list of integers representing ratings for a particular product. Each integer rating is between 1 and 5. Write a function `median_rating(ratings: list[int]) -> float` that returns the median rating of the product. If there is an even number of ratings, the median is the average of the two middle ratings. # Input: - A list of integers `ratings` where each integer represents a rating (0 <= len(ratings) <= 10^6, 1 <= ratings[i] <= 5). # Output: - A float representing the median rating. If the list is empty, return `0.0`. # Constraints: - Each input element is a valid integer rating between 1 and 5. - The list can be very large but will fit into memory. # Example: ```python >>> median_rating([5, 3, 4, 2, 1]) 3.0 >>> median_rating([5, 3, 4, 4, 2, 1]) 3.5 >>> median_rating([4, 4, 4, 4]) 4.0 >>> median_rating([1]) 1.0 >>> median_rating([]) 0.0 ``` # Detailed Steps: 1. Sort the list of ratings. 2. Determine the length of the sorted list. 3. If the length is odd, return the middle element. 4. If the length is even, return the average of the two middle elements. 5. Handle the case where the list is empty by returning `0.0`. # Notes: - Ensure code efficiently handles sorting and finding the median for large lists. - Consider edge cases like empty lists and lists with a single element.","solution":"def median_rating(ratings: list[int]) -> float: Returns the median rating of the given list of ratings. Parameters: ratings (list[int]): List of integers where each integer is a rating between 1 and 5. Returns: float: The median rating of the product. if len(ratings) == 0: return 0.0 # Sort the ratings sorted_ratings = sorted(ratings) n = len(sorted_ratings) # Calculate the median if n % 2 == 1: return float(sorted_ratings[n // 2]) else: mid1 = n // 2 mid2 = mid1 - 1 return (sorted_ratings[mid1] + sorted_ratings[mid2]) / 2.0"},{"question":"# Coding Assessment Question Problem Statement: You are tasked with implementing a function in Python to simulate the behavior of a basic 4-digit lock system. The lock can be set to any 4-digit code (0000 to 9999) and can be unlocked only by entering the correct code. Create two functions: one to set the lock code and another to attempt to unlock it. Functional Requirements: - Implement a function `set_lock_code` that sets the 4-digit lock code. - Implement a function `unlock_attempt` that tries to unlock the lock with a provided code. - The `set_lock_code` function should set the code based on a provided 4-digit integer. - The `unlock_attempt` function should return `True` if the provided code matches the set lock code, otherwise return `False`. Input: - The `set_lock_code` function takes a single integer input `code` which is a 4-digit integer (from 0000 to 9999): `set_lock_code(code: int) -> None` - The `unlock_attempt` function takes a single integer input `attempt` which is a 4-digit integer (from 0000 to 9999): `unlock_attempt(attempt: int) -> bool` Example: ```python >>> set_lock_code(1234) >>> unlock_attempt(1234) True >>> unlock_attempt(4321) False ``` Constraints: - The code must be a 4-digit integer within the range 0000 to 9999. - If an input is outside the 4-digit range, your functions should raise a `ValueError`. Notes: - Ensure the `set_lock_code` function validates the input and raises an appropriate error if the value is outside the expected range. - Ensure the `unlock_attempt` function validates the input and also raises a `ValueError` if the value is outside the expected range. ```python lock_code = None def set_lock_code(code: int) -> None: global lock_code if not (0 <= code <= 9999): raise ValueError(\\"Lock code must be a 4-digit integer between 0000 and 9999\\") lock_code = code def unlock_attempt(attempt: int) -> bool: if not (0 <= attempt <= 9999): raise ValueError(\\"Attempt code must be a 4-digit integer between 0000 and 9999\\") return lock_code == attempt ``` Explanation: - `set_lock_code` function validates and sets the lock code if the input is within the 4-digit range. - `unlock_attempt` function validates the input and compares it to the set lock code, returning `True` if they match and `False` otherwise.","solution":"lock_code = None def set_lock_code(code: int) -> None: Sets the lock code. Parameters: code (int): A 4-digit integer code Raises: ValueError: If the code is not a 4-digit integer global lock_code if not (0 <= code <= 9999): raise ValueError(\\"Lock code must be a 4-digit integer between 0000 and 9999\\") lock_code = code def unlock_attempt(attempt: int) -> bool: Attempts to unlock the lock with the provided code. Parameters: attempt (int): A 4-digit integer attempt code Raises: ValueError: If the attempt code is not a 4-digit integer Returns: bool: True if the attempt matches the lock code, otherwise False if not (0 <= attempt <= 9999): raise ValueError(\\"Attempt code must be a 4-digit integer between 0000 and 9999\\") return lock_code == attempt"},{"question":"# Optimizing a Function for Matrix Diagonal Sum Calculation You are tasked with creating a function to calculate the sum of the diagonals in a given square matrix. Ensure to account for both the primary and secondary diagonals and avoid double-counting the center element in matrices with an odd dimension. Function Signature: ```python def diagonal_sum(matrix: List[List[int]]) -> int: pass ``` Requirements: 1. **Input Matrix**: The function should take a single argument, which is a square matrix (list of lists) with integer elements. 2. **Primary Diagonal**: Sum the elements on the primary diagonal, which spans from the top-left to the bottom-right. 3. **Secondary Diagonal**: Sum the elements on the secondary diagonal, which spans from the top-right to the bottom-left. 4. **Exclude Center for Odd Dimension**: In matrices with odd dimensions, ensure the center element, which is part of both diagonals, is included only once in the final sum. Constraints: - The input matrix will always be a square matrix (N x N), where 1 ≤ N ≤ 1000. - Each element in the matrix will be an integer in the range [-1000, 1000]. Input and Output Format: - **Input**: A list of lists where each sublist represents a row of the matrix. - **Output**: An integer representing the sum of the elements on both diagonals. Example: ```python matrix = [ [2, 3, 7], [6, 5, 8], [1, 4, 9] ] result = diagonal_sum(matrix) print(result) # Output: 2 + 5 + 9 (primary diagonal) + 7 + 5 + 1 (secondary diagonal) - 5 (center element) = 24 ``` Additional Notes: - Ensure optimal performance given the potential size of the matrix. - Consider edge cases, such as a 1x1 matrix, where the only element is both primary and secondary. # Solution ```python from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) primary_diagonal_sum = sum(matrix[i][i] for i in range(n)) secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n)) center_element = matrix[n // 2][n // 2] if n % 2 == 1 else 0 return primary_diagonal_sum + secondary_diagonal_sum - center_element # Example usage: matrix = [ [2, 3, 7], [6, 5, 8], [1, 4, 9] ] print(diagonal_sum(matrix)) # Output: 24 ``` This problem tests the candidate\'s ability to correctly identify and sum matrix elements based on specific indices, ensuring efficient computation and consideration of edge cases.","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) primary_diagonal_sum = sum(matrix[i][i] for i in range(n)) secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n)) # Subtract the center element only if the matrix has an odd dimension center_element = matrix[n // 2][n // 2] if n % 2 == 1 else 0 return primary_diagonal_sum + secondary_diagonal_sum - center_element"},{"question":"# Problem Statement A software engineering company is developing an inventory management system that tracks various items in a warehouse. Each item has a unique identifier and a count representing the available stock. Write a Python function `merge_inventories` that takes two dictionaries representing inventories from two different warehouses and combines them into a single dictionary. Each dictionary contains item IDs (strings) as keys and the corresponding counts (integers) as values. The function should return a new dictionary where each item ID appears only once, and the counts from the two input dictionaries are summed. # Input Format - Two dictionaries, `inventory1` and `inventory2`, representing the inventories of two warehouses. # Output Format - A single dictionary representing the merged inventory, with item counts summed. # Constraints - All item IDs will be strings. - All counts will be non-negative integers. - The number of items in each dictionary will not exceed 1000. # Example ```python # Example 1 inventory1 = {\'apple\': 10, \'banana\': 5, \'orange\': 7} inventory2 = {\'banana\': 3, \'orange\': 2, \'grape\': 4} print(merge_inventories(inventory1, inventory2)) # Output: {\'apple\': 10, \'banana\': 8, \'orange\': 9, \'grape\': 4} # Example 2 inventory1 = {\'widget\': 3, \'gadget\': 12} inventory2 = {\'widget\': 5, \'gear\': 7} print(merge_inventories(inventory1, inventory2)) # Output: {\'widget\': 8, \'gadget\': 12, \'gear\': 7} # Example 3 inventory1 = {\'item1\': 2, \'item2\': 4} inventory2 = {\'item3\': 6} print(merge_inventories(inventory1, inventory2)) # Output: {\'item1\': 2, \'item2\': 4, \'item3\': 6} ``` # Implementation ```python def merge_inventories(inventory1, inventory2): Merge two dictionaries representing inventories into a single dictionary. The resulting dictionary should sum the counts of items with the same ID. result = {} # Add items from the first inventory for item, count in inventory1.items(): if item in result: result[item] += count else: result[item] = count # Add items from the second inventory and sum counts if necessary for item, count in inventory2.items(): if item in result: result[item] += count else: result[item] = count return result ```","solution":"def merge_inventories(inventory1, inventory2): Merge two dictionaries representing inventories into a single dictionary. The resulting dictionary should sum the counts of items with the same ID. result = {} # Add items from the first inventory for item, count in inventory1.items(): result[item] = count # Add items from the second inventory and sum counts if necessary for item, count in inventory2.items(): if item in result: result[item] += count else: result[item] = count return result"},{"question":"# Problem Statement: Design a class `SparseVector` for a sparse vector data structure and implement two methods: `dot_product` and `to_dense`. Class Definition: ```python class SparseVector: def __init__(self, nums: List[int]): # Initializes a sparse vector with the given list of numbers def dot_product(self, vec: \'SparseVector\') -> int: # Returns the dot product of this vector with another sparse vector def to_dense(self) -> List[int]: # Returns the dense representation of the sparse vector ``` Input Format: * The initializer `__init__` receives a list `nums` of integers representing the vector. Most of the elements in the list are zeros. * The `dot_product` method receives an instance of `SparseVector`. * The `to_dense` method takes no arguments. Output Format: * The `dot_product` method returns an integer which is the dot product of two vectors. * The `to_dense` method returns a list of integers representing the dense form of the vector. Constraints: * Both input vectors have the same length, with at most 100,000 elements. * The elements of the vectors are between -1000 and 1000 (inclusive). Examples: ```python nums1 = [0, 1, 0, 0, 2, 0, 0] nums2 = [0, 0, 0, 1, 2, 0, 0] vec1 = SparseVector(nums1) vec2 = SparseVector(nums2) # Dot product of vec1 and vec2 result1 = vec1.dot_product(vec2) print(result1) # Output: 4 (since 2*2 = 4) # Dense representation of vec1 result2 = vec1.to_dense() print(result2) # Output: [0, 1, 0, 0, 2, 0, 0] ``` Additional notes: Ensure efficient handling of extremely sparse vectors by leveraging the sparsity property, especially when computing the dot product. Avoid creating dense vectors internally unless explicitly requested via `to_dense`.","solution":"class SparseVector: def __init__(self, nums): Initializes a sparse vector with the given list of numbers. self.vector_repr = {i: num for i, num in enumerate(nums) if num != 0} self.length = len(nums) def dot_product(self, vec): Returns the dot product of this vector with another sparse vector. result = 0 for i in self.vector_repr: if i in vec.vector_repr: result += self.vector_repr[i] * vec.vector_repr[i] return result def to_dense(self): Returns the dense representation of the sparse vector. result = [0] * self.length for i, value in self.vector_repr.items(): result[i] = value return result"},{"question":"# Subarray Sum Finder **Context:** Given an array of integers, finding a subarray with the maximum sum is a classic problem known as the Maximum Subarray Problem. In this variation, instead of finding the maximum sum, we are interested in finding whether there exists a subarray with a specific sum. **Task:** Write a function that checks if there exists a subarray within the given array that sums up to a specified target value. The subarray can be of any length, including zero length. **Function Signature:** ```python def has_subarray_with_sum(arr: List[int], target: int) -> bool: ``` **Input:** - `arr` (List[int]): A list of integers, which can be either positive, negative, or zero. - `target` (int): The target sum to find in the subarray. **Output:** - `bool` : Return `True` if there is a subarray with sum equal to the target, otherwise `False`. **Constraints:** - 1 <= len(arr) <= 10^5 (This ensures the input size is large enough to require an efficient solution) - -10^5 <= arr[i] <= 10^5 (Allows a wide range of integer values, including negatives) - -10^9 <= target <= 10^9 (Target can be large, requiring careful handling of sums) **Example:** ```python >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_with_sum([-1, 3, -2, 5, -4], 1) True >>> has_subarray_with_sum([1, 2, 3], 7) False ``` **Performance Requirements:** - The function should run in O(n) time complexity, leveraging hashing to store intermediate sums efficiently without using nested loops. **Explanation:** The function `has_subarray_with_sum` should scan through the array while keeping track of the cumulative sum and using a hash set to quickly check if the target subarray sum condition is met, ensuring an efficient computation.","solution":"def has_subarray_with_sum(arr, target): Checks if there exists a subarray within the array that sums up to the target value. :param arr: List[int] - List of integers which might contain positive, negative, or zero values :param target: int - The target sum to find in the subarray :return: bool - True if there is a subarray with sum equal to the target, otherwise False current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == target: return True if (current_sum - target) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"# Understanding Tree Data Structures through Implementation Objective Design and implement additional functionalities for the `BinarySearchTree` class to deepen your understanding of tree operations and data structure management. Task Extend the given `BinarySearchTree` class by implementing the following functionalities: 1. **Tree Traversal Methods**: Implement In-order, Pre-order, and Post-order traversal methods. Each method should return a list of nodes in the order they were visited. 2. **Height Calculation**: Implement a method to calculate the height of the tree. 3. **Balance Check**: Implement a method to check if the tree is balanced. A balanced tree is defined as a tree where the difference in heights between the left and right subtrees of any node is no more than one. Requirements - Ensure proper checks and raise appropriate exceptions for invalid operations. - Your methods should follow these signatures: ```python def in_order_traversal(self) -> list[T]: pass def pre_order_traversal(self) -> list[T]: pass def post_order_traversal(self) -> list[T]: pass def height(self) -> int: pass def is_balanced(self) -> bool: pass ``` Input and Output Formats - **Tree Traversal Methods**: - **Input**: None - **Output**: List of nodes in the order they were visited. - **Height Calculation** (`height`): - **Input**: None - **Output**: Integer representing the height of the tree. - **Balance Check** (`is_balanced`): - **Input**: None - **Output**: Boolean indicating whether the tree is balanced. Constraints - The tree can have up to 1000 nodes. - Ensure your solutions handle edge cases and are optimized for performance with large trees. Example ```python # Sample binary search tree initialization bst = BinarySearchTree() nodes = [10, 5, 20, 3, 7, 15, 30] for node in nodes: bst.insert(node) # Perform tree traversals print(bst.in_order_traversal()) # Example output: [3, 5, 7, 10, 15, 20, 30] print(bst.pre_order_traversal()) # Example output: [10, 5, 3, 7, 20, 15, 30] print(bst.post_order_traversal()) # Example output: [3, 7, 5, 15, 30, 20, 10] # Check height of the tree print(bst.height()) # Output: 3 # Check if the tree is balanced print(bst.is_balanced()) # Output: True ``` Implement and test the functionalities with various tree inputs to ensure correctness and efficiency.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node is not None: self._in_order_traversal(node.left, result) result.append(node.val) self._in_order_traversal(node.right, result) def pre_order_traversal(self): result = [] self._pre_order_traversal(self.root, result) return result def _pre_order_traversal(self, node, result): if node is not None: result.append(node.val) self._pre_order_traversal(node.left, result) self._pre_order_traversal(node.right, result) def post_order_traversal(self): result = [] self._post_order_traversal(self.root, result) return result def _post_order_traversal(self, node, result): if node is not None: self._post_order_traversal(node.left, result) self._post_order_traversal(node.right, result) result.append(node.val) def height(self): return self._height(self.root) def _height(self, node): if node is None: return 0 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def is_balanced(self): return self._is_balanced(self.root) def _is_balanced(self, node): if node is None: return True left_height = self._height(node.left) right_height = self._height(node.right) if abs(left_height - right_height) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right)"},{"question":"# Scenario You are given a list of non-negative integers where each integer represents the number of flowers planted in a line at the respective positions. You have a fixed number of additional flowers to plant, but you must ensure that no two flowers are planted adjacent to one another. Your task is to determine if you can plant all the additional flowers in the list while adhering to the no-adjacent-flowers rule. # Task Implement a function `def can_plant_flowers(flowerbed: List[int], new_flowers: int) -> bool:` that, given a list of non-negative integers representing the flowerbed and an integer indicating the number of new flowers to plant, returns a boolean value indicating whether it is possible to plant all the new flowers without violating the no-adjacent-flowers rule. # Input and Output Formats 1. **Input**: - A list of non-negative integers (`flowerbed`) and an integer (`new_flowers`). 2. **Output**: - A boolean (`True` if it is possible to plant all new flowers, `False` otherwise). # Constraints 1. The `flowerbed` list can have a length of up to 10^4. 2. Each value in the `flowerbed` list is a non-negative integer. 3. `new_flowers` is a non-negative integer. # Examples ```python def can_plant_flowers(flowerbed: List[int], new_flowers: int) -> bool: # Your implementation here # Example 1 flowerbed1 = [1, 0, 0, 0, 1] new_flowers1 = 1 assert can_plant_flowers(flowerbed1, new_flowers1) == True # Example 2 flowerbed2 = [1, 0, 0, 0, 1] new_flowers2 = 2 assert can_plant_flowers(flowerbed2, new_flowers2) == False # Example 3 flowerbed3 = [0, 0, 1, 0, 0] new_flowers3 = 1 assert can_plant_flowers(flowerbed3, new_flowers3) == True # Example 4 flowerbed4 = [1, 0, 0, 0, 0, 0, 1] new_flowers4 = 2 assert can_plant_flowers(flowerbed4, new_flowers4) == True # Example 5 flowerbed5 = [0, 0, 0, 0, 0] new_flowers5 = 3 assert can_plant_flowers(flowerbed5, new_flowers5) == True ``` Remember to handle edge cases like a completely empty flowerbed or a flowerbed that is already fully occupied by flowers.","solution":"from typing import List def can_plant_flowers(flowerbed: List[int], new_flowers: int) -> bool: Determines if it\'s possible to plant the given number of new flowers in the flowerbed without having any two flowers adjacent. Parameters: flowerbed (List[int]): A list of non-negative integers representing existing flower positions. new_flowers (int): The number of new flowers to plant. Returns: bool: True if it\'s possible to plant all new flowers, False otherwise. count = 0 i = 0 while i < len(flowerbed): # Check if the current spot and its neighbors are empty if (flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0)): # Plant a flower here flowerbed[i] = 1 count += 1 if count >= new_flowers: return True # Skip the next spot to ensure no adjacency i += 1 i += 1 return count >= new_flowers"},{"question":"# Coding Assessment Question Context You are given a dataset that consists of temperature readings (`X`) and corresponding ice cream sales (`y`) over several days. The goal is to understand the relationship between temperature and ice cream sales by implementing and evaluating a linear regression model from scratch. Task Write a function that fits and evaluates a linear regression model to predict ice cream sales based on temperature readings. Your function needs to: 1. **Implement Linear Regression**: Create a linear regression model from scratch without using any third-party machine learning libraries. 2. **Gradient Descent Optimizer**: Implement the gradient descent algorithm to find the optimal parameters of the linear regression model. 3. **Plotting the Regression Line**: Generate a plot to visualize the fitted regression line along with the scattered data points. 4. **Evaluation Metrics**: Calculate and print the Mean Squared Error (MSE) to evaluate the model\'s performance on the provided data. Function Signature ```python def fit_linear_regression(X: List[float], y: List[float], learning_rate: float, num_iterations: int): Fit and evaluate a linear regression model using gradient descent. Parameters: X (List[float]): List of temperature readings. y (List[float]): List of corresponding ice cream sales. learning_rate (float): The learning rate for gradient descent. num_iterations (int): Number of iterations for the gradient descent algorithm. Note: The function should also generate and display a plot showing the temperature readings, actual sales, and the regression line. ``` Input - **X (List[float])**: Temperature readings for several days. - **y (List[float])**: Ice cream sales corresponding to the temperature readings. - **learning_rate (float)**: A positive decimal value determining the step size in the gradient descent algorithm. - **num_iterations (int)**: A positive integer representing the number of iterations for the gradient descent optimization. Output - The function should print the following: * Optimal parameters (slope and intercept) of the fitted linear model. * Mean Squared Error (MSE) of the model on the given data. - The function should also generate and display a plot with the scattered temperature readings, actual sales, and the fitted regression line. Constraints - Ensure the function handles potential edge cases, such as: * Empty input lists `X` and `y`. * Lists `X` and `y` having different lengths. Example ```python X = [30.0, 35.0, 40.0, 45.0, 50.0] y = [200.0, 220.0, 250.0, 270.0, 290.0] learning_rate = 0.01 num_iterations = 1000 fit_linear_regression(X, y, learning_rate, num_iterations) ``` **Expected Outcome**: The function should print the optimal parameters (slope and intercept), the Mean Squared Error (MSE), and display a plot showing the temperature readings with their corresponding sales points and the fitted regression line. Good luck!","solution":"import matplotlib.pyplot as plt def fit_linear_regression(X, y, learning_rate, num_iterations): # Check for edge cases if not X or not y: return \\"Input lists cannot be empty\\" if len(X) != len(y): return \\"Input lists must have the same length\\" # Initialize parameters m = 0 b = 0 n = len(X) # Gradient Descent for _ in range(num_iterations): y_predicted = [m * x + b for x in X] # Compute gradients dm = (-2/n) * sum(x * (y_i - y_p) for x, y_i, y_p in zip(X, y, y_predicted)) db = (-2/n) * sum(y_i - y_p for y_i, y_p in zip(y, y_predicted)) # Update parameters m -= learning_rate * dm b -= learning_rate * db # Calculate Mean Squared Error y_predicted = [m * x + b for x in X] mse = sum((y_i - y_p) ** 2 for y_i, y_p in zip(y, y_predicted)) / n # Print Optimal Parameters and MSE print(f\\"Optimal parameters: Slope (m) = {m}, Intercept (b) = {b}\\") print(f\\"Mean Squared Error (MSE) = {mse}\\") # Plot the results plt.scatter(X, y, color=\'blue\', label=\'Actual data\') plt.plot(X, y_predicted, color=\'red\', label=\'Fitted line\') plt.xlabel(\'Temperature (X)\') plt.ylabel(\'Ice Cream Sales (y)\') plt.title(\'Temperature vs Ice Cream Sales\') plt.legend() plt.show() # Example usage students_X = [30.0, 35.0, 40.0, 45.0, 50.0] students_y = [200.0, 220.0, 250.0, 270.0, 290.0] students_learning_rate = 0.01 students_num_iterations = 1000 fit_linear_regression(students_X, students_y, students_learning_rate, students_num_iterations)"},{"question":"# Circular Array Rotation Problem **Background**: Implementing array manipulation and understanding circular data structures is pivotal in many algorithms. One such operation is rotating elements within an array to the right or left. This forms the basis for numerous applications, including but not limited to, scheduling algorithms, buffer management, and cryptography. **Objective**: Write a function that rotates an array to the right by a given number of positions and then returns the updated array. If the number of rotations is larger than the length of the array, the rotations should wrap around the array’s length. **Task**: 1. Implement the function `rotate_array`. 2. Ensure that the function correctly handles arrays of varying lengths and rotation values. 3. Consider the edge cases where the array might be empty or rotations to be zero. **Function Signature**: ```python def rotate_array(arr: list[int], rotations: int) -> list[int]: ``` **Input**: - `arr`: A list of integers representing the array to be rotated. Example: `[1, 2, 3, 4, 5]` - `rotations`: An integer representing the number of positions to rotate the array to the right. Example: `2` **Output**: - A list of integers representing the rotated array. Example: `[4, 5, 1, 2, 3]` **Constraints**: - The length of the array `n` is such that `0 <= n <= 10^5`. - The number of rotations `k` is such that `0 <= k <= 10^9`. - The elements of the array are integers within the range `-10^6` to `10^6`. **Example**: ```python arr = [1, 2, 3, 4, 5] rotations = 2 result = rotate_array(arr, rotations) print(result) # Output: [4, 5, 1, 2, 3] ``` **Explanation**: - Rotating the array `[1, 2, 3, 4, 5]` two positions to the right results in `[4, 5, 1, 2, 3]`. **Edge Cases**: - An empty array should return an empty array regardless of rotation values. - If the number of rotations is a multiple of the length of the array, the resultant array should be the same as the input array. Ensure that the solution efficiently handles arrays with large sizes and large values for the number of rotations.","solution":"def rotate_array(arr, rotations): Rotates the elements of an array to the right by the specified number of positions. Parameters: arr (list[int]): The array to rotate. rotations (int): The number of positions to rotate the array. Returns: list[int]: The rotated array. if not arr: return arr n = len(arr) rotations = rotations % n # Reduce the number of rotations to within the length of the array return arr[-rotations:] + arr[:-rotations]"},{"question":"# Question: Implement a Factorial Trailing Zeros Counter Description Implement a function that calculates the number of trailing zeros in the factorial of a given integer `n`. Ensure the function has error handling for non-positive integers and non-integer types. Input - An integer `n` (1 ≤ n ≤ 100) Output - The number of trailing zeros in the factorial of `n` as an integer Constraints 1. If `n` is not an integer, the function should raise a `TypeError` with the message: `Input value of [number={n}] must be an integer` 2. If `n` is less than 1, the function should raise a `ValueError` with the message: `Input value of [number={n}] must be >= 1` Example ```plaintext Input: 5 Output: 1 Input: 10 Output: 2 Input: 25 Output: 6 Input: 100 Output: 24 ``` Additional Notes - The number of trailing zeros in the factorial of `n` is determined by the number of pairs of factors 2 and 5 in its prime factorization. - Since there are more factors of 2 than 5, the number of trailing zeros is equal to the number of factors of 5. Template ```python def factorial_trailing_zeros(n: int) -> int: if not isinstance(n, int): msg = f\\"Input value of [number={n}] must be an integer\\" raise TypeError(msg) if n < 1: msg = f\\"Input value of [number={n}] must be >= 1\\" raise ValueError(msg) count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count # Example Usage print(factorial_trailing_zeros(5)) # Output: 1 print(factorial_trailing_zeros(10)) # Output: 2 print(factorial_trailing_zeros(25)) # Output: 6 print(factorial_trailing_zeros(100)) # Output: 24 ```","solution":"def factorial_trailing_zeros(n: int) -> int: if not isinstance(n, int): msg = f\\"Input value of [number={n}] must be an integer\\" raise TypeError(msg) if n < 1: msg = f\\"Input value of [number={n}] must be >= 1\\" raise ValueError(msg) count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"# Problem Statement You are required to write a program that simulates a library book tracking system. The system needs to manage a collection of books where each book has a title, an author, and an available status indicating whether the book is currently available to borrow or not. Implement a class `Library` that provides the following methods: 1. `add_book(title: str, author: str) -> None`: Adds a new book to the library with the given title and author. The book should be marked as available when added. 2. `borrow_book(title: str) -> str`: If the book with the given title is available, mark it as not available and return the string `\'borrowed\'`. If the book is not available or does not exist, return the string `\'unavailable\'`. 3. `return_book(title: str) -> str`: If the book with the given title is not available, mark it as available and return the string `\'returned\'`. If the book is already available or does not exist, return the string `\'not found\'`. 4. `get_available_books() -> List[Dict[str, str]]`: Returns a list of dictionaries representing the available books. Each dictionary should have the keys `\'title\'` and `\'author\'`. # Constraints - Book titles are case-insensitive, i.e., borrowing a book with the title `\'Book One\'` should be treated the same as borrowing a book with the title `\'book one\'`. - The library must handle at least 1000 books efficiently. # Example ```python from typing import List, Dict class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str) -> None: # Write your implementation here def borrow_book(self, title: str) -> str: # Write your implementation here def return_book(self, title: str) -> str: # Write your implementation here def get_available_books(self) -> List[Dict[str, str]]: # Write your implementation here # Example Usage library = Library() library.add_book(\\"Book One\\", \\"Author A\\") library.add_book(\\"Book Two\\", \\"Author B\\") print(library.borrow_book(\\"book one\\")) # Expected Output: \'borrowed\' print(library.borrow_book(\\"book one\\")) # Expected Output: \'unavailable\' print(library.return_book(\\"BOOK ONE\\")) # Expected Output: \'returned\' print(library.return_book(\\"BOOK ONE\\")) # Expected Output: \'not found\' print(library.get_available_books()) # Expected Output: [{\'title\': \'Book Two\', \'author\': \'Author B\'}] ``` Implement the class and methods according to the specified behavior and constraints.","solution":"from typing import List, Dict class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str) -> None: self.books.append({\'title\': title.lower(), \'author\': author, \'available\': True}) def borrow_book(self, title: str) -> str: for book in self.books: if book[\'title\'] == title.lower(): if book[\'available\']: book[\'available\'] = False return \'borrowed\' else: return \'unavailable\' return \'unavailable\' def return_book(self, title: str) -> str: for book in self.books: if book[\'title\'] == title.lower(): if not book[\'available\']: book[\'available\'] = True return \'returned\' else: return \'not found\' return \'not found\' def get_available_books(self) -> List[Dict[str, str]]: return [{\'title\': book[\'title\'].title(), \'author\': book[\'author\']} for book in self.books if book[\'available\']]"},{"question":"# Prime Factorization Analysis Prime factorization is an essential concept in number theory which involves breaking down a composite number into its prime factors. In this problem, you will implement a function to determine the prime factorization of a given integer and analyze some properties of its factors. # Objective Implement a function `prime_factorization_analysis` which performs the following steps: 1. **Calculate the prime factorization** of a given integer. 2. **Count the number of distinct prime factors**. 3. **Return the sum and product of these distinct prime factors**. # Function Signature ```python def prime_factorization_analysis(n: int) -> (list, int, int, int): pass ``` # Input - `n` (int): The integer to be factorized. Must be greater than 1. # Output - A tuple with four elements: - A **list of tuples** where each tuple contains a prime factor and its exponent in the factorization, sorted in ascending order by the prime factor. - The **number of distinct prime factors** (int). - The **sum of the distinct prime factors** (int). - The **product of the distinct prime factors** (int). # Constraints - The integer `n` must be greater than 1. - The calculations should handle reasonably large values of `n` efficiently. # Example ```python n = 60 prime_factors, count_distinct_primes, sum_distinct_primes, product_distinct_primes = prime_factorization_analysis(n) print(prime_factors) # Expected: [(2, 2), (3, 1), (5, 1)] print(count_distinct_primes) # Expected: 3 print(sum_distinct_primes) # Expected: 10 print(product_distinct_primes) # Expected: 30 ``` # Note - Ensure that the algorithm used to determine the prime factors is efficient, particularly for larger values of `n`. - Handle edge cases, including when `n` is a prime number itself, ensuring the function properly identifies and processes such input. # Hints - A common approach to factorization involves iterating through possible divisors up to the square root of `n`. - Using a list or dictionary to keep track of prime factors and their exponents can simplify the implementation of the function. - Consider precomputing a list of primes up to a certain limit to enhance the factorization process for larger numbers.","solution":"def prime_factorization_analysis(n: int) -> (list, int, int, int): def prime_factors(n): i = 2 factors = {} while i * i <= n: while (n % i) == 0: if i in factors: factors[i] += 1 else: factors[i] = 1 n //= i i += 1 if n > 1: factors[n] = 1 return factors factors = prime_factors(n) factors_list = sorted(factors.items()) count_distinct_primes = len(factors) sum_distinct_primes = sum(factors.keys()) product_distinct_primes = 1 for prime in factors.keys(): product_distinct_primes *= prime return factors_list, count_distinct_primes, sum_distinct_primes, product_distinct_primes"},{"question":"Longest Arithmetic Subsequence of Given Difference Context: An arithmetic subsequence of an array is a subsequence chosen from the array such that the difference between consecutive elements is constant. For example, in the array [3, 6, 9, 12], the entire array is an arithmetic sequence with a difference of 3. Given an integer array and a specific difference, you are tasked with finding the length of the longest arithmetic subsequence in the array with that difference. Specification: * Function Name: `longest_arith_seq_length` * Input: List of integers `arr`, integer `difference`. * Output: Integer representing the length of the longest arithmetic subsequence. Examples: ```python def longest_arith_seq_length(arr: List[int], difference: int) -> int: pass # Examples print(longest_arith_seq_length([1, 2, 3, 4], 1)) # should return 4 (1, 2, 3, 4) print(longest_arith_seq_length([1, 3, 5, 7], 1)) # should return 1 (no subsequence with difference 1) print(longest_arith_seq_length([1, 5, 7, 8, 5, 3, 4, 2, 1], -2)) # should return 4 (7, 5, 3, 1) ``` Constraints: * The subsequence does not need to be contiguous. * Length of `arr` is between 1 and 10^5. * -10^4 ≤ arr[i], difference ≤ 10^4 Requirements: Implement the function `longest_arith_seq_length` such that it finds and returns the length of the longest arithmetic subsequence with the specified difference. Optimize the function to handle large input sizes efficiently. Additional Information: * Use dynamic programming or a dictionary to keep track of the lengths of arithmetic subsequences encountered so far. * Ensure that the solution handles negative differences correctly. * Consider edge cases such as when the input array is very short.","solution":"def longest_arith_seq_length(arr, difference): Returns the length of the longest arithmetic subsequence with the given difference. Args: arr (List[int]): The list of integers. difference (int): The difference of the arithmetic subsequence. Returns: int: The length of the longest arithmetic subsequence. dp = {} max_length = 0 for num in arr: if num - difference in dp: dp[num] = dp[num - difference] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"# Implementing a Priority Queue Using a Min-Heap Scenario You are managing a system that requires efficient priority scheduling of tasks. To handle this, you need to implement a priority queue that operates based on a min-heap, enabling quick retrieval of the task with the highest priority. Objective * **Implement**: Write a `PriorityQueue` class that uses a min-heap to manage task priorities. * **Test**: Develop test cases to verify the functionality of your priority queue. # Requirements `PriorityQueue` Class 1. **Init method**: Initialize an empty min-heap. ```python def __init__(self): pass ``` 2. **Insert method**: Implement a method to insert a task with a given priority into the min-heap. ```python def insert(self, task: str, priority: int): pass ``` 3. **Extract-min method**: Implement a method to remove and return the task with the highest priority (i.e., the smallest priority number). ```python def extract_min(self) -> str: pass ``` 4. **Peek method**: Implement a method to return the task with the highest priority without removing it from the queue. ```python def peek(self) -> str: pass ``` # Example Usage ```python # Initialize the priority queue pq = PriorityQueue() # Insert tasks with different priorities pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 1) pq.insert(\\"task3\\", 2) # Extract tasks based on priority assert pq.extract_min() == \\"task2\\" assert pq.peek() == \\"task3\\" assert pq.extract_min() == \\"task3\\" assert pq.extract_min() == \\"task1\\" # Inserting more tasks pq.insert(\\"task4\\", 4) pq.insert(\\"task5\\", 0) # Checking the top priority task without removing it assert pq.peek() == \\"task5\\" assert pq.extract_min() == \\"task5\\" assert pq.extract_min() == \\"task4\\" ``` # Constraints * Task names are non-empty strings consisting of lowercase English letters. * `1 ≤ priority ≤ 10^9` * At most `10^5` insert operations will be performed. # Performance Requirements Your implementation must: * Insert tasks in logarithmic time, (O(log n)). * Extract tasks in logarithmic time, (O(log n)). * Peek tasks in constant time, (O(1)). # Instructions 1. Implement the class and its methods as described. 2. Develop and run a suite of test cases to validate the functionality of your implementation. 3. Ensure your implementation is efficient and handles edge cases effectively.","solution":"import heapq class PriorityQueue: def __init__(self): self.min_heap = [] def insert(self, task: str, priority: int): # Insert the task with given priority into the min-heap heapq.heappush(self.min_heap, (priority, task)) def extract_min(self) -> str: # Extract and return the task with the highest priority if not self.min_heap: return None priority, task = heapq.heappop(self.min_heap) return task def peek(self) -> str: # Return the task with the highest priority without removing it if not self.min_heap: return None priority, task = self.min_heap[0] return task"},{"question":"Problem Statement Your task is to work on a text processing project that involves identifying all unique words in a given text and counting the number of occurrences of each word. The words should be reported in alphabetical order. # Problem Statement Write a function `count_unique_words` that takes a string representing the text and returns a dictionary where the keys are unique words in alphabetical order and the values are the number of times each word appears in the text. # Function Signature ```python def count_unique_words(text: str) -> dict: ``` # Input - `text`: A string containing the text in which words are to be counted. The string will only contain lowercase letters and spaces. # Output - A dictionary with words as keys (in alphabetical order) and their corresponding counts as values. # Constraints - `1 ≤ len(text) ≤ 10000` - All words in the text are separated by spaces. - The text contains only lowercase letters and spaces. # Examples 1. `count_unique_words(\\"hello world hello\\")` should return `{\\"hello\\": 2, \\"world\\": 1}`. 2. `count_unique_words(\\"the quick brown fox jumps over the lazy dog\\")` should return `{\\"brown\\": 1, \\"dog\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"lazy\\": 1, \\"over\\": 1, \\"quick\\": 1, \\"the\\": 2}`. 3. `count_unique_words(\\"a a a b b c\\")` should return `{\\"a\\": 3, \\"b\\": 2, \\"c\\": 1}`. # Notes - A word is defined as a sequence of characters separated by spaces. - You may assume the input text does not have consecutive spaces or leading/trailing spaces. # Hints 1. Split the text into words based on spaces. 2. Use a dictionary to count the occurrences of each word. 3. Return the dictionary sorted by keys.","solution":"def count_unique_words(text: str) -> dict: Takes a string \'text\' and returns a dictionary where the keys are unique words in alphabetical order and the values are the number of times each word appears in the text. words = text.split() word_counts = {} for word in words: if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 sorted_word_counts = dict(sorted(word_counts.items())) return sorted_word_counts"},{"question":"**Title**: Implement a Simple File System Simulator **Context**: You are tasked with creating a basic file system simulator that can track and manage directories, files, and their contents. This simulator is aimed at testing your ability to handle data structures, recursion, and command pattern implementation. **Task**: Implement three classes with specific methods: `FileSystem`, `Directory`, and `File`. # 1. File **Class**: `File` **Description**: This class represents a file with a name and content. **Attributes**: - `name` : The name of the file, a string. - `content`: The content inside the file, a string. **Methods**: - `__init__(self, name: str, content: str = \\"\\")`: - Initializes a new file with a given name and optional content. - `write(self, content: str)`: - Writes/updates the content of the file. # 2. Directory **Class**: `Directory` **Description**: This class represents a directory which can contain subdirectories and files. **Attributes**: - `name` : The name of the directory. - `subdirectories`: A dictionary to store subdirectories with directory names as keys and Directory objects as values. - `files`: A dictionary to store files with file names as keys and File objects as values. **Methods**: - `__init__(self, name: str)`: - Initializes a new directory with a given name. - `create_file(self, file_name: str, content: str = \\"\\")`: - Creates a new file in this directory. - `create_subdirectory(self, directory_name: str)`: - Creates a new subdirectory in this directory. - `get_file(self, file_name: str) -> File`: - Retrieves a file object from this directory by its name. - `get_subdirectory(self, directory_name: str) -> \'Directory\'`: - Retrieves a subdirectory object from this directory by its name. # 3. FileSystem **Class**: `FileSystem` **Description**: This class represents the overall file system managing directories and files. **Attributes**: - `root`: The root directory object. **Methods**: - `__init__(self)`: - Initializes the file system with a root directory. - `execute_command(self, command: str)`: - Parses and executes a command string to interact with the file system. # Requirements and Constraints: 1. Commands must be parsed correctly and meaningful outputs if any. 2. The file system must support nested directories. 3. Handle edge cases such as creating files or directories with the same name. **Example Cases**: **Initialization**: ```python fs = FileSystem() ``` **Case 1**: ```python fs.execute_command(\\"mkdir /subdir1\\") subdir1 = fs.root.get_subdirectory(\\"subdir1\\") assert subdir1.name == \\"subdir1\\" ``` **Case 2**: ```python fs.execute_command(\\"touch /subdir1/file1.txt\\") file1 = subdir1.get_file(\\"file1.txt\\") assert file1.name == \\"file1.txt\\" assert file1.content == \\"\\" ``` **Case 3**: ```python fs.execute_command(\\"write /subdir1/file1.txt Hello World\\") assert file1.content == \\"Hello World\\" ``` By implementing these classes and methods, you will create a simple yet functional file system simulator, addressing the core concepts of file and directory management in a nested structure.","solution":"class File: def __init__(self, name: str, content: str = \\"\\"): self.name = name self.content = content def write(self, content: str): self.content = content class Directory: def __init__(self, name: str): self.name = name self.subdirectories = {} self.files = {} def create_file(self, file_name: str, content: str = \\"\\"): if file_name not in self.files: self.files[file_name] = File(file_name, content) def create_subdirectory(self, directory_name: str): if directory_name not in self.subdirectories: self.subdirectories[directory_name] = Directory(directory_name) def get_file(self, file_name: str) -> \'File\': return self.files.get(file_name) def get_subdirectory(self, directory_name: str) -> \'Directory\': return self.subdirectories.get(directory_name) class FileSystem: def __init__(self): self.root = Directory(\\"root\\") def execute_command(self, command: str): parts = command.split() action = parts[0] path = parts[1].split(\'/\') if action == \\"mkdir\\": self._create_directory(path) elif action == \\"touch\\": self._create_file(path) elif action == \\"write\\": content = \' \'.join(parts[2:]) self._write_to_file(path, content) def _create_directory(self, path: list): current_directory = self.root for dirname in path[1:]: if dirname not in current_directory.subdirectories: current_directory.create_subdirectory(dirname) current_directory = current_directory.get_subdirectory(dirname) def _create_file(self, path: list): current_directory = self.root for dirname in path[1:-1]: current_directory = current_directory.get_subdirectory(dirname) file_name = path[-1] current_directory.create_file(file_name) def _write_to_file(self, path: list, content: str): current_directory = self.root for dirname in path[1:-1]: current_directory = current_directory.get_subdirectory(dirname) file_name = path[-1] file = current_directory.get_file(file_name) if file: file.write(content)"},{"question":"# Merge Dictionaries - Programming Question You are provided with two dictionaries. Your task is to implement a function that merges these two dictionaries, such that for any common keys, their values are summed. If a key exists in only one dictionary, it should appear in the merged dictionary with its original value. **Function Signature**: ```python def merge_dictionaries(dict_a: dict, dict_b: dict) -> dict: :param dict_a: dictionary with integer keys and values :param dict_b: dictionary with integer keys and values :return: A dictionary containing merged keys with summed values for common keys >>> merge_dictionaries({1: 5, 2: 3}, {2: 2, 3: 4}) {1: 5, 2: 5, 3: 4} >>> merge_dictionaries({1: 5, 2: 3}, {3: 2, 4: 6}) {1: 5, 2: 3, 3: 2, 4: 6} >>> merge_dictionaries({}, {1: 2, 2: 3}) {1: 2, 2: 3} >>> merge_dictionaries({1: 5, 2: 3}, {1: \\"a\\", 2: \\"b\\"}) Traceback (most recent call last): ... AssertionError: The input dictionaries must have integer values only pass ``` # Constraints: 1. Both inputs must be dictionaries with integer keys and integer values. 2. If input dictionaries do not have integer values, the function should raise an assertion error with a specific message. # Edge Cases to Consider: - One or both dictionaries are empty. - Large dictionaries with considerable number of elements. - Non-integer values within the dictionaries. # Inputs: - `dict_a` and `dict_b`: Two dictionaries with integer keys and values. # Outputs: - A merged dictionary where common keys have their values summed. Implement the function `merge_dictionaries` to compute the result based on the provided template and constraints.","solution":"def merge_dictionaries(dict_a, dict_b): Merges two dictionaries, summing values for common keys and keeping original values for unique keys. :param dict_a: dictionary with integer keys and values :param dict_b: dictionary with integer keys and values :return: A dictionary containing merged keys with summed values for common keys Raises an AssertionError if any value in the dictionaries is not an integer. # Assertion to ensure values are integers for d in [dict_a, dict_b]: assert all(isinstance(v, int) for v in d.values()), \\"The input dictionaries must have integer values only\\" # Merging dictionaries merged_dict = dict(dict_a) for key, value in dict_b.items(): if key in merged_dict: merged_dict[key] += value else: merged_dict[key] = value return merged_dict"},{"question":"# Scenario A library management system is being developed to manage book inventories, user information, and book borrowings. The system needs to consistently track the status of books and users and report on overdue books. # Task 1. **Function Requirement: `add_new_user`** - **Purpose**: Create a function to add a new user to the system. The function should validate user data and ensure no duplicate users are created. - **Input**: - `user_data: dict`: A dictionary containing user data with keys \'user_id\', \'name\', and \'email\'. - **Output**: - Returns a string confirming the successful addition of the user or raises an exception for duplicate users or invalid data. 2. **Function Requirement: `borrow_book`** - **Purpose**: Create a function to allow a user to borrow a book. The function should update the book and user status accordingly and set the due date for the book return. - **Input**: - `user_id: str`: The ID of the user borrowing the book. - `book_id: str`: The ID of the book being borrowed. - `due_date: str`: The due date for returning the book in \'YYYY-MM-DD\' format. - **Output**: - Returns a string confirming the successful borrowing or raises an exception if the book is already borrowed, user does not exist, or invalid data supplied. # Constraints: - The `user_data` dictionary should have the structure `{\'user_id\': str, \'name\': str, \'email\': str}`. - Ensure each user ID and email are unique. - Ensure a user cannot borrow a book already borrowed by another user. - The `due_date` should be a valid date, and the function should raise an exception for overdue borrow attempts. - Handle errors such as invalid user IDs, book IDs, and invalid data formats by raising custom exceptions with meaningful messages. # Example ```python # Example Usage # 1. Add new user try: user_data = {\'user_id\': \'1\', \'name\': \'Alice\', \'email\': \'alice@example.com\'} print(add_new_user(user_data)) # Expected output: \\"User Alice added successfully\\" except Exception as e: print(e) # 2. Borrow a book try: user_id = \'1\' book_id = \'101\' due_date = \'2023-11-30\' print(borrow_book(user_id, book_id, due_date)) # Expected output: \\"Book 101 borrowed by user 1, due on 2023-11-30\\" except Exception as e: print(e) ```","solution":"import datetime # Data storage users_db = {} books_db = {} class LibraryError(Exception): Custom exception for library-related errors. pass def validate_user_data(user_data): if not isinstance(user_data, dict): raise LibraryError(\\"Invalid user data format\\") required_keys = {\'user_id\', \'name\', \'email\'} if not required_keys.issubset(user_data.keys()): raise LibraryError(\\"Missing required user data fields\\") def add_new_user(user_data): Adds a new user to the system. :param user_data: dict, A dictionary containing \'user_id\', \'name\', and \'email\'. :return: str, Confirmation message. validate_user_data(user_data) user_id = user_data[\'user_id\'] email = user_data[\'email\'] if user_id in users_db: raise LibraryError(f\\"User ID {user_id} already exists.\\") if any(user[\'email\'] == email for user in users_db.values()): raise LibraryError(f\\"Email {email} already exists.\\") users_db[user_id] = { \'name\': user_data[\'name\'], \'email\': user_data[\'email\'], \'borrowed_books\': [] } return f\\"User {user_data[\'name\']} added successfully\\" def validate_date(date_str): Validates the date format and returns a datetime object try: return datetime.datetime.strptime(date_str, \'%Y-%m-%d\') except ValueError: raise LibraryError(\\"Invalid date format, should be YYYY-MM-DD\\") def borrow_book(user_id, book_id, due_date): Allows a user to borrow a book. :param user_id: str, The ID of the user borrowing the book. :param book_id: str, The ID of the book being borrowed. :param due_date: str, The due date for returning the book in \'YYYY-MM-DD\'. :return: str, Confirmation message. if user_id not in users_db: raise LibraryError(f\\"User ID {user_id} does not exist.\\") if book_id in books_db and books_db[book_id][\'borrowed_by\'] is not None: raise LibraryError(f\\"Book ID {book_id} is already borrowed.\\") due_date_obj = validate_date(due_date) if due_date_obj < datetime.datetime.now(): raise LibraryError(\\"Due date cannot be in the past.\\") books_db[book_id] = { \'borrowed_by\': user_id, \'due_date\': due_date_obj } users_db[user_id][\'borrowed_books\'].append(book_id) return f\\"Book {book_id} borrowed by user {user_id}, due on {due_date}\\""},{"question":"# String Manipulation and Palindrome Check Scenario: You are developing a utility tool that processes user-input strings to remove punctuation, spaces, and converts to lowercase to check if the cleaned string forms a palindrome. A palindrome is a string that reads the same forward and backward when ignoring spaces, punctuation, and case. Task: Write a Python function `is_palindrome(input_string: str) -> bool` to determine if the cleaned version of the given string is a palindrome. Requirements: 1. Remove all spaces and punctuation from the input string. 2. Convert the cleaned string to lowercase. 3. Check if the cleaned string reads the same forward and backward. 4. Return `True` if the string is a palindrome, and `False` otherwise. # Function Signature ```python def is_palindrome(input_string: str) -> bool: pass ``` Input * `input_string`: A string containing alphanumeric characters, spaces, and punctuation (e.g., \\"A man, a plan, a canal: Panama\\"). Constraints * The input string length will be between 1 and 1000 characters. Output * A boolean value indicating whether the cleaned string is a palindrome. Notes * Utilize Python\'s string methods to clean the input. * Consider edge cases, such as empty strings and strings with only non-alphanumeric characters. * Ensure the solution executes efficiently given typical input sizes. --- Example: ```python assert is_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome(\\"race a car\\") == False ```","solution":"import string def is_palindrome(input_string: str) -> bool: Checks if the cleaned version of the input_string is a palindrome. # Remove punctuation translator = str.maketrans(\'\', \'\', string.punctuation) cleaned_string = input_string.translate(translator) # Remove spaces and convert to lowercase cleaned_string = cleaned_string.replace(\\" \\", \\"\\").lower() # Check if the cleaned string is a palindrome return cleaned_string == cleaned_string[::-1]"},{"question":"# Consecutive Character Counter As part of a pattern recognition application, you are required to write a function that counts the occurrence of each character consecutively in a given string and returns a list of tuples, with each tuple representing a character and the number of consecutive occurrences in the input string. # Function Specification **Function Name**: `count_consecutive_chars` **Input**: 1. `input_string` (str): The string in which to count consecutive characters. **Output**: - Returns a list of tuples, where each tuple contains a character and the count of its consecutive occurrences. # Constraints: - The input string will contain at most 10^5 characters. - The string will contain only alphanumeric characters and spaces. - If the input string is empty, return an empty list. # Examples: ```python count_consecutive_chars(\\"aaabbcaaa\\") # Output: [(\'a\', 3), (\'b\', 2), (\'c\', 1), (\'a\', 3)] count_consecutive_chars(\\"Hello\\") # Output: [(\'H\', 1), (\'e\', 1), (\'l\', 2), (\'o\', 1)] count_consecutive_chars(\\"112233\\") # Output: [(\'1\', 2), (\'2\', 2), (\'3\', 2)] count_consecutive_chars(\\"\\") # Output: [] ``` # Additional Notes: Ensure that your implementation handles different characters and counts them accurately. # Testing: * Handle empty input strings. * Handle strings with single characters repeated. * Handle strings with varied characters and non-consecutive duplicates. Write the function `count_consecutive_chars` such that it efficiently counts consecutive characters in the given string.","solution":"def count_consecutive_chars(input_string): Counts the occurrence of each character consecutively in a given string and returns a list of tuples with each tuple representing a character and the number of consecutive occurrences. Parameters: - input_string (str): The string in which to count consecutive characters. Returns: - List[Tuple[str, int]]: A list of tuples, where each tuple contains a character and the count of its consecutive occurrences. if not input_string: return [] result = [] count = 1 current_char = input_string[0] for char in input_string[1:]: if char == current_char: count += 1 else: result.append((current_char, count)) current_char = char count = 1 result.append((current_char, count)) return result"},{"question":"**String Analysis and Transformation** You are required to implement a set of string analysis and transformation operations, including reversing a string, checking for palindromes, counting vowels and consonants, converting to uppercase and lowercase, and finding the longest repeating substring. You should adhere to the following function signatures and specifications: ```python def reverse_string(s: str) -> str: Reverses a given string. :param s: Input string. :return: The reversed string. def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome. :param s: Input string. :return: True if the string is a palindrome, False otherwise. def count_vowels_and_consonants(s: str) -> Tuple[int, int]: Counts the number of vowels and consonants in the given string. :param s: Input string. :return: A tuple containing the count of vowels and consonants respectively. def to_uppercase(s: str) -> str: Converts the given string to uppercase. :param s: Input string. :return: The uppercase version of the string. def to_lowercase(s: str) -> str: Converts the given string to lowercase. :param s: Input string. :return: The lowercase version of the string. def longest_repeating_substring(s: str) -> str: Finds the longest repeating substring within the given string. :param s: Input string. :return: The longest repeating substring. ``` # Constraints: 1. Strings will only contain alphabetical characters. 2. The length of the input string will not exceed 1000 characters. 3. Cases should be considered for reversing, palindrome checking, and conversions. # Testing: You should ensure your implementations pass the following test cases: - Reversing a string: Test with various lengths and check the reverse. - Palindrome checking: Include both palindromic and non-palindromic strings. - Counting vowels and consonants: Ensure accuracy across different strings. - Uppercase and lowercase conversions: Validate these transformations properly. - Longest repeating substring: Test with different patterns to identify the correct substring.","solution":"from typing import Tuple def reverse_string(s: str) -> str: Reverses a given string. :param s: Input string. :return: The reversed string. return s[::-1] def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome. :param s: Input string. :return: True if the string is a palindrome, False otherwise. s_reversed = s[::-1] return s == s_reversed def count_vowels_and_consonants(s: str) -> Tuple[int, int]: Counts the number of vowels and consonants in the given string. :param s: Input string. :return: A tuple containing the count of vowels and consonants respectively. vowels = set(\'aeiouAEIOU\') num_vowels = sum(1 for char in s if char in vowels) num_consonants = sum(1 for char in s if char.isalpha() and char not in vowels) return num_vowels, num_consonants def to_uppercase(s: str) -> str: Converts the given string to uppercase. :param s: Input string. :return: The uppercase version of the string. return s.upper() def to_lowercase(s: str) -> str: Converts the given string to lowercase. :param s: Input string. :return: The lowercase version of the string. return s.lower() def longest_repeating_substring(s: str) -> str: Finds the longest repeating substring within the given string. :param s: Input string. :return: The longest repeating substring. n = len(s) lrs = \\"\\" for i in range(n): for j in range(i + 1, n): # Find the longest common prefix of s[i:] and s[j:] lcp_length = 0 while (j + lcp_length < n) and (s[i + lcp_length] == s[j + lcp_length]): lcp_length += 1 # Update result if the current LCP is found to be longer if lcp_length > len(lrs): lrs = s[i:i+lcp_length] return lrs"},{"question":"# Matrix Multiplication of Sparse Matrices You are tasked with implementing a function to perform matrix multiplication on sparse matrices. Sparse matrices are matrices in which most of the elements are zero. For this task, you will represent the sparse matrices using a dictionary of keys (DOK) format, where the keys are tuple indices (i, j) representing the non-zero elements and the values are the corresponding matrix elements. # Requirements: 1. Implement a function `sparse_matrix_multiply(A, B)` that takes two sparse matrices `A` and `B` and returns their matrix product. 2. Validate that the matrices have compatible dimensions for multiplication. 3. Optimize the function to handle large sparse matrices efficiently. 4. Ensure the result matrix is also in DOK format. # Constraints: * Assume both matrices have dimensions of up to ( 1000 times 1000 ). * Sparse matrices will have at most 1% of their elements as non-zero. * You are not allowed to use additional external libraries beyond Python\'s built-in capabilities and the `collections` module. * Your solution should handle edge cases like empty matrices, mismatched dimensions, etc. # Input Format: You will receive: * Two dictionaries `A` and `B`, representing the sparse matrices in DOK format. # Output Format: The function should return: * A dictionary representing the product of matrices `A` and `B` in DOK format. # Example Usage: ```python A = { (0, 0): 1, (0, 1): 2, (1, 0): 3, (1, 1): 4 } B = { (0, 0): 5, (0, 1): 6, (1, 0): 7, (1, 1): 8 } result = sparse_matrix_multiply(A, B) print(result) # Output: {(0, 0): 19, (0, 1): 22, (1, 0): 43, (1, 1): 50} ``` Implement the matrix multiplication function for sparse matrices.","solution":"def sparse_matrix_multiply(A, B): Multiplies two sparse matrices A and B using the dictionary of keys (DOK) format. :param A: Dictionary representing sparse matrix A with keys as (i, j) and values as matrix elements. :param B: Dictionary representing sparse matrix B with keys as (i, j) and values as matrix elements. :return: Dictionary representing the product of matrix A and B in DOK format. # Required imports from collections import defaultdict # Initialize result matrix C in defaultdict to handle default values C = defaultdict(int) # Find dimensions of matrix A and B A_rows = max(i for i, j in A.keys()) + 1 if A else 0 A_cols = max(j for i, j in A.keys()) + 1 if A else 0 B_rows = max(i for i, j in B.keys()) + 1 if B else 0 B_cols = max(j for i, j in B.keys()) + 1 if B else 0 # Validate matrix dimensions for multiplication if A_cols != B_rows: raise ValueError(\\"Matrix dimensions mismatch for multiplication\\") # Multiply A and B for (i, k) in A: if k in [x for x, y in B.keys()]: for j in range(B_cols): if (k, j) in B: C[(i, j)] += A[(i, k)] * B[(k, j)] # Convert defaultdict to normal dictionary return dict(C)"},{"question":"# Problem Statement: You\'re developing a task scheduling app, SnapTasker, that allows users to set deadlines for tasks and get notifications if they approach the deadline. To support this, you need to create a feature that determines whether a list of tasks has deadlines within a specific time frame. # Requirements: 1. **Input List**: Your function should accept a list of dictionaries, where each dictionary represents a task with: * `task_name`: A string denoting the name of the task. * `deadline`: A string representing the deadline of the task in the format \\"YYYY-MM-DD HH:MM\\". 2. **Time Frame**: Accept a time frame input in minutes specifying the duration from the current time to check for upcoming deadlines. 3. **Output List**: Return a list of task names sorted lexicographically (alphabetical order) that have deadlines within the specified time frame. If no tasks meet the criteria, return an empty list. 4. **Current Time Handling**: Use the `datetime` module to handle the current time accurately. # Constraints: * A task deadline will always be in the future relative to its creation time. * The input list can have up to 10^4 tasks. # Function Signature: ```python def upcoming_tasks(tasks: list[dict], time_frame: int) -> list[str]: pass ``` # Example: ```python tasks_list = [ {\\"task_name\\": \\"Complete Project\\", \\"deadline\\": \\"2023-05-20 14:00\\"}, {\\"task_name\\": \\"Doctor Appointment\\", \\"deadline\\": \\"2023-05-20 16:30\\"}, {\\"task_name\\": \\"Grocery Shopping\\", \\"deadline\\": \\"2023-05-21 09:00\\"}, {\\"task_name\\": \\"Call Mom\\", \\"deadline\\": \\"2023-05-19 18:00\\"}, ] current_time = \\"2023-05-20 12:00\\" time_frame = 180 # 180 minutes (3 hours) # The function call should return: # [\\"Complete Project\\", \\"Doctor Appointment\\"] ``` # Task: Implement the `upcoming_tasks` function which determines the tasks whose deadlines fall within the given time frame from the current time. # Hint: Use the `datetime` module for the current time and to calculate the difference between the current time and the deadlines.","solution":"from datetime import datetime, timedelta def upcoming_tasks(tasks: list[dict], time_frame: int) -> list[str]: Determines the tasks whose deadlines fall within the given time frame from the current time. Args: tasks (list[dict]): List of dictionaries representing tasks with \'task_name\' and \'deadline\' fields. time_frame (int): Time frame in minutes to check for upcoming deadlines. Returns: list[str]: A list of task names sorted lexicographically that have deadlines within the specified time frame. current_time = datetime.now() time_limit = current_time + timedelta(minutes=time_frame) upcoming_task_names = [] for task in tasks: deadline = datetime.strptime(task[\'deadline\'], \\"%Y-%m-%d %H:%M\\") if current_time <= deadline <= time_limit: upcoming_task_names.append(task[\'task_name\']) return sorted(upcoming_task_names)"},{"question":"# Number to Words Conversion You are tasked with implementing a function that converts a non-negative integer into its English words representation. Ensure the solution handles the range from 0 to up to 1 billion. Function Specifications 1. **Convert Function**: Define a function `convert_to_words(n)` that accepts a single integer `n` and returns a string representing the number in English words. You can assume `n` is a non-negative integer less than or equal to 1 billion. Input and Output Specifications **Input**: - `convert_to_words(n)`, where `n` is a non-negative integer (0 ≤ n ≤ 1,000,000,000). **Output**: - The function should return a string that represents the English words of the input number. # Example Test Cases ```python assert convert_to_words(0) == \\"zero\\" assert convert_to_words(5) == \\"five\\" assert convert_to_words(13) == \\"thirteen\\" assert convert_to_words(123) == \\"one hundred twenty-three\\" assert convert_to_words(10503) == \\"ten thousand five hundred three\\" assert convert_to_words(1000000) == \\"one million\\" assert convert_to_words(1000000000) == \\"one billion\\" assert convert_to_words(123456789) == \\"one hundred twenty-three million four hundred fifty-six thousand seven hundred eighty-nine\\" ``` Implement the `convert_to_words` function according to these specifications and ensure your implementation passes all the given example test cases.","solution":"def convert_to_words(n): if n == 0: return \\"zero\\" ones = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\"] teens = [\\"\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"ten\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] thousands = [\\"\\", \\"thousand\\", \\"million\\", \\"billion\\"] def words_hundred(n): hundred = n // 100 remainder = n % 100 result = \\"\\" if hundred > 0: result += ones[hundred] + \\" hundred\\" if remainder > 0: if hundred > 0: result += \\" \\" if remainder < 10: result += ones[remainder] elif 10 < remainder < 20: result += teens[remainder - 10] else: ten = remainder // 10 one = remainder % 10 if ten > 0: result += tens[ten] if one > 0: if ten > 0: result += \\"-\\" result += ones[one] return result def words_thousand(n): result = \\"\\" if n >= 1000: result += words_hundred(n // 1000) result += \\" thousand\\" if n % 1000 > 0: result += \\" \\" return result + words_hundred(n % 1000) result = \\"\\" if n == 1000000000: return \\"one billion\\" if n >= 1000000: result += words_hundred(n // 1000000) result += \\" million\\" if n % 1000000 > 0: result += \\" \\" if n % 1000000 and (result != \\"\\" and n >= 1000): result += words_thousand(n % 1000000) elif n < 1000000: result += words_thousand(n) return result.strip()"},{"question":"**Longest Common Subsequence: Implementing Optimal Subsequence Length Calculation** # Background You are given two sequences of characters, and your task is to determine the length of the longest subsequence that is common to both sequences. A subsequence is a sequence derived from another sequence by deleting some or none of the characters without changing the order of the remaining characters. # Problem You are to implement a function `longest_common_subsequence(seq1: str, seq2: str) -> int` that calculates the length of the longest subsequence present in both `seq1` and `seq2`. # Function Signature ```python def longest_common_subsequence(seq1: str, seq2: str) -> int: # Implement your solution here ``` # Input * `seq1` (str): The first sequence of characters. * `seq2` (str): The second sequence of characters. # Output * Returns the length of the longest common subsequence as an integer. # Constraints * `0 <= len(seq1), len(seq2) <= 1000` * `seq1` and `seq2` will consist of uppercase and lowercase English letters. # Examples 1. `longest_common_subsequence(\\"ABCD\\", \\"AEBD\\")` should return `3` 2. `longest_common_subsequence(\\"XMJYAUZ\\", \\"MZJAWXU\\")` should return `4` 3. `longest_common_subsequence(\\"ABC\\", \\"DEF\\")` should return `0` # Instructions * Make sure your function handles edge cases such as: - One or both sequences being empty. - Sequences with no common subsequence. * Your implementation should use dynamic programming to achieve optimal performance. # Evaluation Criteria * Correctness: The function returns correct results for all test cases. * Efficiency: The solution is optimized for performance within given constraints. * Edge Case Handling: Proper handling of edge cases and error scenarios. * Code Quality: Clear and readable code with appropriate comments.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> int: Returns the length of the longest subsequence common to both seq1 and seq2. Utilizes dynamic programming to achieve optimal performance. m, n = len(seq1), len(seq2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Unique Webpage View Counter Objective: You need to implement a function that takes a list of user-page visit records and returns the count of unique pages viewed by each user. Each record in the list represents a user visiting a page. Function Signature: ```python def count_unique_views(visitor_records: List[Tuple[str, str]]) -> Dict[str, int]: Counts the unique pages viewed by each user. Args: visitor_records (List[Tuple[str, str]]): List of tuples where each tuple consists of a user ID and a page URL. Returns: Dict[str, int]: A dictionary where the keys are user IDs and the values are the counts of unique pages viewed by that user. ``` Input: * `visitor_records`: A list of tuples where each tuple contains two strings: * The first string represents the user ID. * The second string represents the page URL. Output: * A dictionary where each key is a user ID and the value is the number of unique pages that user visited. Constraints: * The list `visitor_records` can have at most 10^5 records. * User IDs and page URLs consist of alphanumeric characters and might include some special characters like `\'.\'`, `\'_\'`, `\'-\'`. Example: ```python visitor_records = [ (\\"user1\\", \\"page1\\"), (\\"user2\\", \\"page2\\"), (\\"user1\\", \\"page3\\"), (\\"user1\\", \\"page1\\"), (\\"user2\\", \\"page2\\"), (\\"user2\\", \\"page4\\"), (\\"user3\\", \\"page5\\"), (\\"user3\\", \\"page5\\"), (\\"user1\\", \\"page4\\") ] result = count_unique_views(visitor_records) # Expected result: {\\"user1\\": 3, \\"user2\\": 2, \\"user3\\": 1} ``` Notes: * The function should be efficient in handling large inputs up to the constraints. * Consider edge cases such as: * An empty list of records, which should result in an empty dictionary being returned. * A user visiting the same page multiple times should count as a single unique view for that page.","solution":"from typing import List, Tuple, Dict def count_unique_views(visitor_records: List[Tuple[str, str]]) -> Dict[str, int]: Counts the unique pages viewed by each user. Args: visitor_records (List[Tuple[str, str]]): List of tuples where each tuple consists of a user ID and a page URL. Returns: Dict[str, int]: A dictionary where the keys are user IDs and the values are the counts of unique pages viewed by that user. user_page_views = {} for user, page in visitor_records: if user not in user_page_views: user_page_views[user] = set() user_page_views[user].add(page) unique_views_count = {user: len(pages) for user, pages in user_page_views.items()} return unique_views_count"},{"question":"# Problem Statement You are tasked with implementing a regular expression engine that supports a subset of typical regex operations. The engine should be able to match strings against patterns containing the special characters `.` (which matches any single character) and `*` (which matches zero or more of the preceding character). # Function Signature ```python def regex_match(pattern: str, text: str) -> bool: Matches a given pattern against a given text using basic regex rules. Parameters: - pattern (str): The regex pattern, which can include `.` and `*`. - text (str): The text to match against the pattern. Returns: (bool): True if the text matches the pattern, else False. pass ``` # Input - `pattern` - The regex pattern which includes characters and the special characters dot (`.`) and asterisk (`*`). (1 <= len(pattern) <= 50) - `text` - The text string to be checked against the pattern. (1 <= len(text) <= 50) # Output - A boolean value indicating whether the text matches the pattern (`True`) or not (`False`). # Constraints - The pattern supports `.` which matches any single character. - The pattern supports `*` which matches zero or more of the preceding character. - The regex engine should handle all typical edge cases. # Example Usage ```python pattern = \\"a*b.c\\" text = \\"aaabbc\\" print(regex_match(pattern, text)) # Expected: True pattern = \\"a*b.c\\" text = \\"aabc\\" print(regex_match(pattern, text)) # Expected: False pattern = \\"a.*c\\" text = \\"abcdefc\\" print(regex_match(pattern, text)) # Expected: True pattern = \\".*\\" text = \\"anything\\" print(regex_match(pattern, text)) # Expected: True pattern = \\"a*\\" text = \\"\\" print(regex_match(pattern, text)) # Expected: True ``` # Requirements - Implement the function without relying on built-in Python regular expressions. - Consider edge cases such as empty strings, only `*` or `.` in patterns. - Ensure optimized performance within the constraints. - Write clear, readable, and maintainable code. # Testing - Test your implementation with a variety of patterns and texts including edge cases. - Include cases that test the performance within the given constraints.","solution":"def regex_match(pattern: str, text: str) -> bool: Matches a given pattern against a given text using basic regex rules. Parameters: - pattern (str): The regex pattern, which can include `.` and `*`. - text (str): The text to match against the pattern. Returns: (bool): True if the text matches the pattern, else False. def match_helper(p, t, p_idx, t_idx): if p_idx == len(p): # End of pattern return t_idx == len(t) # True if end of text, else False first_match = t_idx < len(t) and (p[p_idx] == t[t_idx] or p[p_idx] == \'.\') if p_idx + 1 < len(p) and p[p_idx + 1] == \'*\': return (match_helper(p, t, p_idx + 2, t_idx) or (first_match and match_helper(p, t, p_idx, t_idx + 1))) else: return first_match and match_helper(p, t, p_idx + 1, t_idx + 1) return match_helper(pattern, text, 0, 0)"},{"question":"# Coding Assessment Question Scenario You are developing an application that efficiently manages book rentals at a library. Each book can be rented out or returned, and you need to keep track of which books are currently rented and which are available. Additionally, you need to provide functionality to list all available books sorted by their title. Task Write a class `Library` that supports the following operations: - Renting out a specific book (if available). - Returning a rented book. - Providing a list of all available books sorted alphabetically by their title. Class Definition ```python class Library: def __init__(self): self.available_books = set() # Use a set to store available book titles self.rented_books = set() # Use a set to store rented book titles def add_book(self, title: str) -> None: Adds a book to the library inventory. :param title: The title of the book to add. if title not in self.rented_books: self.available_books.add(title) def rent_book(self, title: str) -> bool: Rents out a book from the library if it is available. :param title: The title of the book to rent. :return: True if the book was successfully rented out, False if it was not available. if title in self.available_books: self.available_books.remove(title) self.rented_books.add(title) return True return False def return_book(self, title: str) -> bool: Returns a rented book to the library. :param title: The title of the book to return. :return: True if the book was successfully returned, False if the book was not rented. if title in self.rented_books: self.rented_books.remove(title) self.available_books.add(title) return True return False def list_available_books(self) -> List[str]: Returns a list of all available book titles sorted alphabetically. :return: A sorted list of available book titles. return sorted(self.available_books) ``` Constraints 1. Each book title is unique. 2. The library can handle up to (10^5) books. 3. Book titles are strings and have a maximum length of 100 characters. Example ```python library = Library() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"1984\\") library.add_book(\\"To Kill A Mockingbird\\") assert library.rent_book(\\"1984\\") == True assert library.rent_book(\\"1984\\") == False assert library.return_book(\\"1984\\") == True assert library.return_book(\\"1984\\") == False assert library.list_available_books() == [\\"The Great Gatsby\\", \\"1984\\", \\"To Kill A Mockingbird\\"] ```","solution":"from typing import List class Library: def __init__(self): self.available_books = set() # Use a set to store available book titles self.rented_books = set() # Use a set to store rented book titles def add_book(self, title: str) -> None: Adds a book to the library inventory. :param title: The title of the book to add. if title not in self.rented_books: self.available_books.add(title) def rent_book(self, title: str) -> bool: Rents out a book from the library if it is available. :param title: The title of the book to rent. :return: True if the book was successfully rented out, False if it was not available. if title in self.available_books: self.available_books.remove(title) self.rented_books.add(title) return True return False def return_book(self, title: str) -> bool: Returns a rented book to the library. :param title: The title of the book to return. :return: True if the book was successfully returned, False if the book was not rented. if title in self.rented_books: self.rented_books.remove(title) self.available_books.add(title) return True return False def list_available_books(self) -> List[str]: Returns a list of all available book titles sorted alphabetically. :return: A sorted list of available book titles. return sorted(self.available_books)"},{"question":"# Problem Statement You are given a sorted list of unique integers and a target integer. Your task is to determine whether there are any two distinct integers in the list whose sum equals the target integer. Implement a function `pair_with_target_sum(nums: List[int], target: int) -> bool` that returns a boolean value: `True` if there are two distinct integers in the list whose sum equals the target integer, and `False` otherwise. # Input - A list of unique integers `nums` which is sorted in non-decreasing order. - An integer `target` which is the sum we are trying to find. # Output - A boolean value `True` if there exist two distinct integers in the list whose sum equals the target integer, and `False` otherwise. # Example ```python >>> pair_with_target_sum([1, 2, 3, 4, 5], 7) True >>> pair_with_target_sum([1, 2, 3, 4, 5], 10) False >>> pair_with_target_sum([0, -1, 2, 3, 5], 4) True >>> pair_with_target_sum([0, -1, 2, 3, 5], -2) False ``` # Constraints - The length of the list `nums` is between 2 and 10^5. - The integers in the list `nums` range between `-10^9` and `10^9`. - The algorithm should run in linear time `O(n)` where `n` is the length of the list. # Notes - Use two pointers approach to efficiently find if such a pair exists within the provided list. - Since the list is already sorted, you can start with the first element and the last element, adjusting pointers based on the sum comparison to the target. This ensures optimal performance without unnecessary iterations.","solution":"from typing import List def pair_with_target_sum(nums: List[int], target: int) -> bool: Determine if there are two distinct integers in the sorted list `nums` whose sum equals the target integer. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"# Context: Graphs are crucial structures in computer science used for modeling pairwise relations between objects. A common problem involving graphs is finding a path between two nodes. In this task, you\'ll work with an undirected graph and determine if there\'s a path between two given nodes using Depth-First Search (DFS). # Task: Write a function `find_path(graph: Dict[int, List[int]], start: int, end: int) -> bool` that determines whether there is a path between the `start` node and the `end` node in a given undirected graph. # Input: * `graph` - A dictionary representing an undirected graph where the keys are node identifiers and the values are lists of neighboring nodes. * `start` - An integer representing the starting node. * `end` - An integer representing the destination node. # Output: * A boolean value: * `True` if a path exists between the `start` node and the `end` node. * `False` otherwise. # Constraints: * The graph will contain between 1 and 1000 nodes. * The graph may not be connected. * Node identifiers are unique integers. * The function should handle graphs efficiently both in terms of time and space complexity. * You may assume the graph is non-empty and nodes `start` and `end` exist in the graph. # Requirements: * The function must use Depth-First Search (DFS) for path detection. * Handle input validation to ensure the graph is properly structured. * The function should be performance-efficient and handle typical edge cases such as isolated nodes gracefully. Example Usage: ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2] } print(find_path(graph, 1, 4)) # Expected output: True print(find_path(graph, 3, 4)) # Expected output: True print(find_path(graph, 1, 5)) # Expected output: False (node 5 does not exist in the graph) ```","solution":"def find_path(graph, start, end): Determines if there\'s a path between start and end node using DFS. def dfs(node, visited): if node == end: return True visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited): return True return False if start not in graph or end not in graph: return False return dfs(start, set())"},{"question":"**Context**: Given a large data set of user logs, each log entry contains a timestamp, user ID, and some action taken by the user. The logs need to be analyzed to determine user engagement. Specifically, we need to know how many distinct users engaged with the system within a given timeframe. **Task**: Implement the function `distinct_users_in_timeframe(logs: List[Tuple[str, int, str]], start: str, end: str) -> int` to count the distinct number of users who have engaged with the system between the given `start` and `end` timestamps, inclusive. **Function Signature**: ```python def distinct_users_in_timeframe(logs: List[Tuple[str, int, str]], start: str, end: str) -> int: pass ``` **Input**: * `logs` (List[Tuple[str, int, str]]): A list of log entries where each entry is a tuple of three values `(timestamp, user_id, action)`. The `timestamp` is a string in the format `\\"YYYY-MM-DD HH:MM:SS\\"`, `user_id` is an integer, and `action` is a string describing the action. * `start` (str): The start timestamp as a string in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. * `end` (str): The end timestamp as a string in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. **Output**: * (int): The number of distinct users who engaged with the system between `start` and `end`, inclusive. **Constraints**: * The log entries are sorted by timestamp in ascending order. * The `logs` list can contain up to 10^6 entries. * Timestamps in `start` and `end` are guaranteed to align with the format and will fall within the range of timestamps in the `logs`. **Requirements**: * The solution should be efficient in terms of time complexity, making use of the sorted nature of the logs. **Examples**: ```python logs = [ (\\"2023-01-01 10:00:00\\", 1, \\"login\\"), (\\"2023-01-01 10:05:00\\", 2, \\"view\\"), (\\"2023-01-01 10:10:00\\", 1, \\"click\\"), (\\"2023-01-01 10:20:00\\", 3, \\"login\\"), (\\"2023-01-01 10:30:00\\", 2, \\"logout\\"), (\\"2023-01-01 10:35:00\\", 4, \\"view\\"), (\\"2023-01-01 10:45:00\\", 1, \\"logout\\"), ] assert distinct_users_in_timeframe(logs, \\"2023-01-01 10:00:00\\", \\"2023-01-01 10:30:00\\") == 3 assert distinct_users_in_timeframe(logs, \\"2023-01-01 10:20:00\\", \\"2023-01-01 10:40:00\\") == 2 assert distinct_users_in_timeframe(logs, \\"2023-01-01 10:35:00\\", \\"2023-01-01 10:45:00\\") == 2 assert distinct_users_in_timeframe(logs, \\"2023-01-01 09:00:00\\", \\"2023-01-01 09:59:59\\") == 0 assert distinct_users_in_timeframe(logs, \\"2023-01-01 10:00:00\\", \\"2023-01-01 10:45:00\\") == 4 ```","solution":"from typing import List, Tuple def distinct_users_in_timeframe(logs: List[Tuple[str, int, str]], start: str, end: str) -> int: Returns the number of distinct users who engaged with the system between the given start and end timestamps (inclusive). user_set = set() for timestamp, user_id, action in logs: if start <= timestamp <= end: user_set.add(user_id) return len(user_set)"},{"question":"# Sentence Capitalizer Function Enhancement Problem Statement You are tasked with creating an enhanced sentence capitalizer function. This function should take a string representing a sentence and return the string with the first letter of each word capitalized. Words are sequences of characters separated by spaces. The function should handle the following enhancements: 1. The function should correctly handle extra spaces between words and remove any leading or trailing spaces. 2. It should also properly manage words with punctuation marks, ensuring any leading or trailing punctuation marks are ignored when capitalizing words. 3. Provide robust exception handling for non-string inputs. Functional Specification 1. **Function Name**: `enhanced_capitalize_sentence` 2. **Input**: A string `sentence`. 3. **Output**: A string where the first letter of each word is capitalized. 4. **Exceptions**: - Raise a `TypeError` if the input is not a string. Constraints 1. The function must handle empty strings and strings with only spaces correctly. 2. Each word should be capitalized without modifying internal punctuation. 3. All leading and trailing spaces should be removed in the output. Examples ```python >>> enhanced_capitalize_sentence(\\" hello world \\") \\"Hello World\\" >>> enhanced_capitalize_sentence(\\"Python\'s syntax is easy-to-read\\") \\"Python\'s Syntax Is Easy-To-Read\\" >>> enhanced_capitalize_sentence(\\"multiple spaces\\") \\"Multiple Spaces\\" >>> enhanced_capitalize_sentence(123) Traceback (most recent call last): ... TypeError: sentence must be a string >>> enhanced_capitalize_sentence(\\"\\") \\"\\" ``` Implementation Enhance the existing code with the above specifications and ensure it passes all test cases. ```python def enhanced_capitalize_sentence(sentence): Returns the capitalized version of the input string, capitalizing the first letter of each word and removing any extra spaces around and between words. Args: sentence (str): A string sentence. Returns: str: A string with the first letter of each word capitalized. Raises: TypeError: If sentence is not a string. if not isinstance(sentence, str): raise TypeError(\\"sentence must be a string\\") # Remove leading/trailing spaces and split by spaces words = sentence.strip().split() # Capitalize each word and join them back with a single space capitalized_words = [word.capitalize() for word in words] return \' \'.join(capitalized_words) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def enhanced_capitalize_sentence(sentence): Returns the capitalized version of the input string, capitalizing the first letter of each word and removing any extra spaces around and between words. Args: sentence (str): A string sentence. Returns: str: A string with the first letter of each word capitalized. Raises: TypeError: If sentence is not a string. if not isinstance(sentence, str): raise TypeError(\\"sentence must be a string\\") # Remove leading/trailing spaces and split by spaces words = sentence.strip().split() # Capitalize each word and join them back with a single space capitalized_words = [word.capitalize() for word in words] return \' \'.join(capitalized_words)"},{"question":"# Problem Statement As part of maintaining a large collection of nested data structures, you need to implement a utility function that extracts all the unique keys from a deeply nested dictionary. Each dictionary may contain other dictionaries, lists of dictionaries, or lists of lists, etc. The objective is to flatten the structure and list all unique keys present at any level of the nesting. # Requirements 1. **Function Signature**: ```python def extract_keys(nested_dict: dict) -> set: ``` - **Input**: * `nested_dict`: A dictionary that may contain other dictionaries, lists, and other complex nested structures. - **Output**: * Returns a set containing all unique keys found within the nested dictionary. # Example ```python def test_extract_keys(): nested_dict_1 = { \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3, \\"f\\": 4 } }, \\"g\\": [ { \\"h\\": 5, \\"i\\": 6 }, { \\"j\\": 7, \\"k\\": { \\"l\\": 8 } } ] } nested_dict_2 = { \\"x\\": { \\"y\\": [ { \\"z\\": 0 } ] }, \\"m\\": \\"n\\", \\"o\\": { \\"p\\": { \\"q\\": \\"r\\" } } } assert extract_keys(nested_dict_1) == {\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\", \\"h\\", \\"i\\", \\"j\\", \\"k\\", \\"l\\"} assert extract_keys(nested_dict_2) == {\\"x\\", \\"y\\", \\"z\\", \\"m\\", \\"o\\", \\"p\\", \\"q\\"} if __name__ == \\"__main__\\": test_extract_keys() ``` # Constraints and Performance Requirements 1. Assume the depth of the nested dictionary/structure won\'t exceed 100 levels. 2. Assume dictionaries may contain lists, and lists may contain dictionaries, repeatedly. 3. Your function should not modify the input dictionary. 4. Ensure your implementation efficiently handles varying degrees of nesting and allows for any Python nested data structure.","solution":"def extract_keys(nested_dict): Extract all unique keys from a deeply nested dictionary. Args: nested_dict (dict): The nested dictionary from which to extract keys. Returns: set: A set of unique keys found within the nested dictionary. unique_keys = set() def _extract(obj): if isinstance(obj, dict): for key, value in obj.items(): unique_keys.add(key) _extract(value) elif isinstance(obj, list): for item in obj: _extract(item) _extract(nested_dict) return unique_keys"},{"question":"# Coding Assessment Question Scenario: You are working as a developer for a company that provides keyword suggestions for search engine optimization. The company wants to implement a new feature where given a set of keywords, the system should return all unique combinations of these keywords that can be formed by concatenation. Task: Write a Python function `keyword_combinations(keywords)` that returns a list of all unique concatenated combinations of the given keywords. The order of keywords in each combination does not matter, and the function should avoid duplicates. **Function Signature**: ```python def keyword_combinations(keywords: list) -> list: ``` **Input**: - `keywords`: A list of strings where each string represents a keyword. **Output**: - A list of strings representing all unique concatenated combinations of the given keywords. The output list should not contain duplicates and should be sorted lexicographically. **Constraints**: - All keywords in the `keywords` list are unique. - Keywords can be concatenated in any order to form combinations. - The length of the `keywords` list will not exceed 10. - Each keyword within the list will not exceed 100 characters. **Edge Cases to Handle**: - If the `keywords` list is empty, return an empty list. - If the `keywords` list contains only one keyword, return a list with that single keyword. **Examples**: ```python print(keyword_combinations([\'apple\', \'banana\'])) # Expected Output: [\'applebanana\', \'bananaapple\'] print(keyword_combinations([\'cat\', \'dog\', \'fish\'])) # Expected Output: [\'catdog\', \'catdogfish\', \'catfish\', \'catfishdog\', \'dogcat\', \'dogcatfish\', \'dogfish\', \'dogfishcat\', \'fishcat\', \'fishcatdog\', \'fishdog\', \'fishdogcat\'] print(keyword_combinations([])) # Expected Output: [] print(keyword_combinations([\'keyword\'])) # Expected Output: [\'keyword\'] ``` Ensure your implementation is efficient and capable of handling the given constraints appropriately.","solution":"from itertools import permutations def keyword_combinations(keywords): Given a list of unique keywords, this function returns all unique concatenated combinations of the given keywords. Parameters: keywords (list): A list of strings where each string represents a keyword. Returns: list: A list of unique concatenated combinations of the given keywords sorted lexicographically. if not keywords: return [] result = set() length = len(keywords) # Generate all possible permutations of all lengths for i in range(1, length + 1): for combination in permutations(keywords, i): result.add(\'\'.join(combination)) # Convert the result set to a sorted list return sorted(result)"},{"question":"# Coding Challenge: Implement K-Dimensional Tree (KD-Tree) Range Search Context You have been provided with a basic implementation of a K-Dimensional Tree (KD-Tree), a useful data structure for organizing points in a k-dimensional space. However, one commonly required feature is missing: the ability to perform range searches. Task You need to extend the `KDTree` class with a function to perform range searches. Specifications **Operation: Range Search** - **Function Signature**: `def range_search(self, query_range):` - **Input**: `query_range` - A list of tuples where each tuple defines the min and max range for each dimension. For example, `[(xmin, xmax), (ymin, ymax), (zmin, zmax)]` for a 3D tree. - **Output**: A list of points that lie within the defined range for all dimensions. Additional Requirements - Ensure that the points returned by the range search are accurately bounded within the provided range. - Optimize the search by leveraging the properties of the KD-Tree. # Example Usage ```python # Define a KDTree class and insert points class KDTree: def __init__(self, points): # Initialize the KD-Tree with a list of k-dimensional points pass def insert(self, point): # Insert a point into the KD-Tree pass def range_search(self, query_range): # Implement range search pass # Example Initialization points = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)] kdtree = KDTree(points) # Range search within specified ranges for each dimension query_range = [(4, 9), (1, 6)] # Example range [x in 4 to 9, y in 1 to 6] # Perform range search and print results result = kdtree.range_search(query_range) print(result) # This should print the points within the specified range ``` # Constraints - The KD-Tree should be properly balanced to ensure efficient search operations. - Handle empty trees and invalid ranges gracefully. - The algorithm’s performance level must adhere to the standard complexities expected of KD-Tree operations, specifically O(log n) for balanced trees in average case scenarios. - Assume k-dimensional points, where k ≥ 2. **Nota Bene**: Modify the `KDTree` and any supporting classes as necessary to implement the new functionalities. Ensure the main structure and properties of the KD-Tree are maintained.","solution":"class KDTree: def __init__(self, points=None, depth=0): Initialize the KD-Tree with a list of k-dimensional points. self.axis = depth % len(points[0]) if points else 0 self.location = None self.left = None self.right = None if points: points.sort(key=lambda x: x[self.axis]) median = len(points) // 2 self.location = points[median] self.left = KDTree(points[:median], depth + 1) if median > 0 else None self.right = KDTree(points[median + 1:], depth + 1) if median < len(points) - 1 else None def range_search(self, query_range): Perform range search to find all points within the given range. def search(node, depth=0): if not node: return [] axis = depth % len(query_range) results = [] # Check if the current node is within the range. if all(query_range[d][0] <= node.location[d] <= query_range[d][1] for d in range(len(query_range))): results.append(node.location) # Search left subtree if needed. if node.left and query_range[axis][0] <= node.location[axis]: results.extend(search(node.left, depth + 1)) # Search right subtree if needed. if node.right and query_range[axis][1] >= node.location[axis]: results.extend(search(node.right, depth + 1)) return results return search(self)"},{"question":"# Problem Statement: You are required to create a library management system that can handle book information and user transactions. The library application should allow adding, removing, and searching for books, as well as managing user book borrowings and returns. # Requirements: 1. **Book Management Functions**: Implement functions to add, remove, and search for books in the library. 2. **User Transaction Functions**: Implement user functions to borrow and return books, along with tracking borrowed books. 3. **Edge Cases**: Ensure all functions handle edge cases, such as attempting to borrow a book that is not available or return a book that wasn\'t borrowed. # Input & Output: Book Management Functions: 1. **add_book(book_id: int, title: str, author: str) -> None** - **Input**: - `book_id`: a unique identifier for each book. - `title`: the title of the book. - `author`: the author of the book. - **Output**: None 2. **remove_book(book_id: int) -> None** - **Input**: `book_id`: the unique identifier for the book to be removed. - **Output**: None 3. **search_book(title: str) -> List[Dict[str, Union[int, str]]]:** - **Input**: `title`: the title or partial title of the book to search for. - **Output**: A list of dictionaries, where each dictionary contains information about the book (`book_id`, `title`, `author`). User Transaction Functions: 1. **borrow_book(user_id: int, book_id: int) -> None** - **Input**: - `user_id`: the unique identifier of the user. - `book_id`: the unique identifier of the book to be borrowed. - **Output**: None 2. **return_book(user_id: int, book_id: int) -> None** - **Input**: - `user_id`: the unique identifier of the user. - `book_id`: the unique identifier of the book to be returned. - **Output**: None 3. **get_borrowed_books(user_id: int) -> List[int]:** - **Input**: `user_id`: the unique identifier of the user. - **Output**: A list of `book_id`s representing the books currently borrowed by the user. # Example Usage: ```python library = LibraryManagementSystem() # Book Management library.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.add_book(2, \\"1984\\", \\"George Orwell\\") library.add_book(3, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") print(library.search_book(\\"1984\\")) # Output: [{\'book_id\': 2, \'title\': \'1984\', \'author\': \'George Orwell\'}] library.remove_book(2) print(library.search_book(\\"1984\\")) # Output: [] # User Transactions library.borrow_book(1001, 1) library.borrow_book(1001, 3) print(library.get_borrowed_books(1001)) # Output: [1, 3] library.return_book(1001, 1) print(library.get_borrowed_books(1001)) # Output: [3] ``` # Notes: * Make sure to use appropriate data structures to store book and user information efficiently. * Implement error handling for scenarios like attempting to borrow an unavailable book, returning a book not borrowed by the user, etc. * Ensure your system can handle multiple users and books without performance degradation.","solution":"class LibraryManagementSystem: def __init__(self): self.books = {} self.user_borrowed_books = {} def add_book(self, book_id: int, title: str, author: str) -> None: if book_id not in self.books: self.books[book_id] = {\'title\': title, \'author\': author} def remove_book(self, book_id: int) -> None: if book_id in self.books: del self.books[book_id] def search_book(self, title: str): result = [] for book_id, info in self.books.items(): if title.lower() in info[\'title\'].lower(): result.append({\'book_id\': book_id, \'title\': info[\'title\'], \'author\': info[\'author\']}) return result def borrow_book(self, user_id: int, book_id: int) -> None: if book_id in self.books: if user_id not in self.user_borrowed_books: self.user_borrowed_books[user_id] = [] if book_id not in self.user_borrowed_books[user_id]: self.user_borrowed_books[user_id].append(book_id) def return_book(self, user_id: int, book_id: int) -> None: if user_id in self.user_borrowed_books and book_id in self.user_borrowed_books[user_id]: self.user_borrowed_books[user_id].remove(book_id) def get_borrowed_books(self, user_id: int): if user_id in self.user_borrowed_books: return self.user_borrowed_books[user_id] return []"},{"question":"# Flight Route Calculation with Time Constraints A travel agency needs to find the shortest travel route between two cities, given various possible connections with specific travel times and delays. Each connection between two cities may have different travel times due to factors such as delays, layovers, and transit times at airports. Write a function that calculates the minimum travel time from a start city to a destination city based on given connections and time constraints. Function Signature ```python def shortest_travel_time(connections: list, start: str, destination: str) -> int: Calculates the shortest travel time between two cities. Parameters: connections (list): A list of connections where each connection is represented as a tuple. - Each tuple consists of (origin: str, destination: str, travel_time: int). start (str): The starting city. destination (str): The destination city. Returns: int: The shortest travel time from start to destination. ``` Input and Output Formats * **Input**: A list of connections and two city names. * Each connection is represented as a tuple: * The origin city name as a string. * The destination city name as a string. * The travel time in minutes as an integer. * The start city name as a string. * The destination city name as a string. * **Output**: A single integer representing the shortest travel time in minutes. Constraints * The connections list will have a maximum length of 10,000. * Travel time values are positive integers. * There may be multiple connections between the same origin and destination with different travel times. * If the destination is unreachable from the start, return -1. Examples ```python >>> shortest_travel_time([(\\"A\\", \\"B\\", 50), (\\"A\\", \\"C\\", 40), (\\"B\\", \\"D\\", 30), (\\"C\\", \\"D\\", 20), (\\"A\\", \\"D\\", 100)], \\"A\\", \\"D\\") 60 >>> shortest_travel_time([(\\"A\\", \\"B\\", 10), (\\"A\\", \\"C\\", 60), (\\"B\\", \\"D\\", 20), (\\"C\\", \\"D\\", 10), (\\"B\\", \\"C\\", 50)], \\"A\\", \\"D\\") 30 >>> shortest_travel_time([(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 5), (\\"C\\", \\"D\\", 5), (\\"A\\", \\"E\\", 100), (\\"E\\", \\"D\\", 5)], \\"A\\", \\"D\\") 15 >>> shortest_travel_time([(\\"A\\", \\"B\\", 15), (\\"B\\", \\"C\\", 20), (\\"C\\", \\"D\\", 30)], \\"A\\", \\"E\\") -1 ``` Hint Use Dijkstra\'s algorithm or a priority queue to efficiently calculate the shortest path from start to destination. Track visited cities to avoid cycles.","solution":"import heapq def shortest_travel_time(connections, start, destination): Calculates the shortest travel time between two cities. Parameters: connections (list): A list of connections where each connection is represented as a tuple. - Each tuple consists of (origin: str, destination: str, travel_time: int). start (str): The starting city. destination (str): The destination city. Returns: int: The shortest travel time from start to destination. graph = {} for origin, dest, time in connections: if origin not in graph: graph[origin] = [] graph[origin].append((dest, time)) pq = [(0, start)] shortest_times = {start: 0} while pq: curr_time, curr_city = heapq.heappop(pq) if curr_city == destination: return curr_time if curr_city in graph: for neighbor, travel_time in graph[curr_city]: new_time = curr_time + travel_time if neighbor not in shortest_times or new_time < shortest_times[neighbor]: shortest_times[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return -1"},{"question":"# Matrix Diagonal Sum **Context:** In a given square matrix, the sum of the elements on the main diagonal and the anti-diagonal are of interest. The main diagonal of a matrix consists of elements from the top-left to bottom-right, while the anti-diagonal consists of elements from the top-right to bottom-left. **Task:** Write a function to compute and return the sum of the main diagonal and the anti-diagonal of a given n x n integer matrix. If there is an overlap (when n is odd), the central element should only be counted once in the overall sum. **Function Signature:** ```python def diagonal_sum(matrix: List[List[int]]) -> int: ``` **Input:** - `matrix` (List[List[int]]): A square matrix of integers with dimensions n x n. **Output:** - `int` : The sum of the main diagonal and anti-diagonal elements. **Constraints:** - 1 <= n <= 1000 (matrix size) - -10^6 <= matrix[i][j] <= 10^6 **Example:** ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> diagonal_sum(matrix) 25 >>> matrix = [ ... [3, 5, 7, 9], ... [1, 2, 4, 8], ... [6, 10, 11, 15], ... [14, 13, 12, 16] ... ] >>> diagonal_sum(matrix) 59 ``` **Explanation:** For the first example, the matrix `matrix` is: ``` 1 2 3 4 5 6 7 8 9 ``` The main diagonal elements are 1, 5, 9, and the anti-diagonal elements are 3, 5, 7. Sum them up: 1 + 5 + 9 + 3 + 7 = 25 (5 is counted only once). For the second example, the matrix `matrix` is: ``` 3 5 7 9 1 2 4 8 6 10 11 15 14 13 12 16 ``` The main diagonal elements are 3, 2, 11, 16, and the anti-diagonal elements are 9, 4, 10, 14. Sum them up: 3 + 2 + 11 + 16 + 9 + 4 + 10 + 14 = 69.","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) main_diag_sum = 0 anti_diag_sum = 0 for i in range(n): main_diag_sum += matrix[i][i] anti_diag_sum += matrix[i][n - 1 - i] if n % 2 == 1: # Subtract the center element which was counted twice (once in each diagonal) center = matrix[n // 2][n // 2] return main_diag_sum + anti_diag_sum - center else: return main_diag_sum + anti_diag_sum"},{"question":"# Coding Assessment Question Problem Statement: Given a binary tree, find the largest subtree that is a Binary Search Tree (BST) and also return its size. A subtree must include all of its descendants. You need to implement the function: ```python def largest_bst_subtree(root: Optional[TreeNode]) -> Tuple[Optional[TreeNode], int]: Find the largest subtree that is a BST in a given binary tree and return the root of that subtree and its size. Args: - root (Optional[TreeNode]): The root node of the binary tree. Returns: - Tuple[Optional[TreeNode], int]: A tuple containing the root of the largest BST subtree and the size of that subtree. ``` Constraints: * The number of nodes in the tree will be in the range [1, 10^4]. * Each node\'s value is an integer and can be both positive and negative. Examples: ```python >>> class TreeNode: >>> def __init__(self, val=0, left=None, right=None): >>> self.val = val >>> self.left = left >>> self.right = right >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(8) >>> root.right.right = TreeNode(7) >>> largest_bst_subtree(root) (TreeNode(5), 3) >>> root2 = TreeNode(4) >>> root2.left = TreeNode(2) >>> root2.right = TreeNode(6) >>> root2.left.left = TreeNode(1) >>> root2.left.right = TreeNode(3) >>> root2.right.left = TreeNode(5) >>> root2.right.right = TreeNode(7) >>> largest_bst_subtree(root2) (TreeNode(4), 7) ``` Requirements: * Your function should efficiently determine the largest BST subtree. * You may use helper functions to keep the main function clean and readable. * Make sure to handle edge cases where multiple subtrees have the same size. * The `TreeNode` class defined above should be used to create nodes for the binary tree. Good luck, and focus on both accuracy and performance in your solution!","solution":"from typing import Optional, Tuple class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_bst_subtree(root: Optional[TreeNode]) -> Tuple[Optional[TreeNode], int]: def helper(node): # Base case: if node is None, consider it as a BST with size 0 if not node: return (True, 0, float(\'inf\'), float(\'-inf\'), None) left_is_bst, left_size, left_min, left_max, left_subtree = helper(node.left) right_is_bst, right_size, right_min, right_max, right_subtree = helper(node.right) # Check if current node is a valid BST root if left_is_bst and right_is_bst and left_max < node.val < right_min: size = left_size + right_size + 1 return (True, size, min(left_min, node.val), max(right_max, node.val), node) # Not a BST, take the max size from left or right subtree if left_size > right_size: return (False, left_size, 0, 0, left_subtree) else: return (False, right_size, 0, 0, right_subtree) _, size, _, _, subtree_root = helper(root) return (subtree_root, size)"},{"question":"# Frog Jump Puzzle Solution A frog is sitting at the bottom of a staircase with `n` steps. The frog can jump either 1 step or 2 steps at a time. Your task is to determine the number of distinct ways the frog can reach the top of the staircase. Specifications: 1. **Function Definition**: * You should implement a function `frog_jump_ways(n: int) -> int` that calculates the number of distinct ways the frog can hop to the top. 2. **Dynamic Programming**: * Use a dynamic programming approach to solve this problem. * Store the number of ways to reach each step in an array to avoid redundant computations. * The number of ways to reach step `i` is the sum of ways to reach step `i-1` and step `i-2`. 3. **Input**: * `n`: An integer representing the number of steps in the staircase (1 <= n <= 30). 4. **Output**: * Return the number of distinct ways to reach the top of the staircase. Function Signature: ```python def frog_jump_ways(n: int) -> int: pass ``` Examples: ```python assert frog_jump_ways(1) == 1 assert frog_jump_ways(2) == 2 assert frog_jump_ways(3) == 3 assert frog_jump_ways(4) == 5 assert frog_jump_ways(5) == 8 ``` Explanation of Examples: 1. For `n=1`: The frog can only jump 1 step to reach the top, so there is 1 way. 2. For `n=2`: The frog can either jump two 1-steps or one 2-step, so there are 2 ways. 3. For `n=3`: The frog can jump (1,1,1), (1,2), or (2,1), so there are 3 ways. 4. For `n=4`: The frog can jump (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), or (2,2), so there are 5 ways. 5. For `n=5`: The frog can jump (1,1,1,1,1), (1,1,1,2), (1,1,2,1), (1,2,1,1), (2,1,1,1), (1,2,2), (2,1,2), or (2,2,1), so there are 8 ways. Implement this function and write the appropriate assertions to validate your results. Analyze any potential edge cases.","solution":"def frog_jump_ways(n: int) -> int: Calculate the number of distinct ways the frog can reach the top of a staircase with n steps. :param n: Number of steps in the staircase :return: Number of distinct ways to reach the top if n == 1: return 1 if n == 2: return 2 # Create a list to store the number of ways to reach each step dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"# Problem Statement In an amusement park, there is a popular tickets booth that offers a collection of tickets with different values. A customer wants to buy a combination of tickets that maximize the total value, but they are constrained by a budget limit. Write a function that determines the maximum possible sum of ticket values that do not exceed the given budget. # Input - A list of integers `tickets` where each integer represents the value of a ticket. (1 ≤ len(tickets) ≤ 1000, 1 ≤ ticket value ≤ 1000) - An integer `budget` representing the maximum amount the customer can spend. (1 ≤ budget ≤ 10000) # Output - An integer representing the maximum possible sum of ticket values that do not exceed the budget. # Constraints - 1 ≤ len(tickets) ≤ 1000 - 1 ≤ ticket value ≤ 1000 - 1 ≤ budget ≤ 10000 # Example ```python def test_maximize_tickets(): assert maximize_tickets([100, 200, 300, 400, 500], 1000) == 1000 # e.g., [100, 200, 300, 400] assert maximize_tickets([200, 300, 700], 500) == 500 # e.g., [200, 300] assert maximize_tickets([1000, 2000, 3000], 1000) == 1000 # e.g., [1000] assert maximize_tickets([100, 250, 300, 200, 150], 700) == 700 # e.g., [100, 250, 300] ``` Implement the function `maximize_tickets` such that it passes the above test cases. # Additional Notes - You may assume that the customer can choose to buy no tickets if it is not possible to stay within the budget. - Consider a dynamic programming approach similar to the Knapsack problem to solve this efficiently.","solution":"def maximize_tickets(tickets, budget): Determines the maximum possible sum of ticket values that do not exceed the budget. Uses a dynamic programming approach similar to the knapsack problem. :param tickets: List of integers where each integer is a ticket value. :param budget: Integer representing the maximum amount the customer can spend. :return: Integer representing the maximum possible sum of ticket values that do not exceed the budget. n = len(tickets) dp = [0] * (budget + 1) for ticket in tickets: for j in range(budget, ticket - 1, -1): dp[j] = max(dp[j], dp[j - ticket] + ticket) return dp[budget]"},{"question":"# Palindrome Formation Check with Character Frequencies You are given a string consisting of lowercase letters. Your task is to determine if the characters of the string can be rearranged to form a palindrome. --- # Function Specification **Function Name**: `can_form_palindrome` **Input**: - One string, `s`, consisting of lowercase letters only. **Output**: - Boolean: Returns `True` if the characters of the string can be rearranged to form a palindrome; returns `False` otherwise. # Example ```python assert can_form_palindrome(\\"civic\\") == True assert can_form_palindrome(\\"ivicc\\") == True assert can_form_palindrome(\\"hello\\") == False assert can_form_palindrome(\\"aabb\\") == True assert can_form_palindrome(\\"abc\\") == False ``` # Constraints - 1 <= len(s) <= 10^5 # Additional Information - A string can form a palindrome if, at most, one character occurs an odd number of times. - Aim for a linear time complexity solution with respect to the length of the string. - Space complexity should be optimized to handle large input sizes efficiently. # Performance Requirements - The solution must be efficient in both time and space, capable of processing large strings within the constraint. --- # Implementation Task Write a function `can_form_palindrome(s: str) -> bool` that adheres to the specifications and passes all the given test cases. Do not use any additional libraries or helper functions that break the self-containment of this task.","solution":"def can_form_palindrome(s): Determines if the characters of the string can be rearranged to form a palindrome. :param s: String of lowercase letters :return: Boolean, True if characters can form a palindrome, False otherwise from collections import Counter # Count the frequency of each character in the string freq_counter = Counter(s) # Count the number of characters that have an odd frequency odd_count = sum(1 for count in freq_counter.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"# Problem Statement: Given a text file containing a list of email addresses, your task is to extract the unique domains and count their occurrences. Implement a function `count_email_domains(file_path: str) -> Dict[str, int]` that reads the file and returns a dictionary where the keys are domain names and the values are their respective counts. # Input: - `file_path`: A string representing the path to the text file containing the email addresses. # Output: - A dictionary with domain names as keys and the count of each domain as values. # Constraints: 1. The text file contains one email address per line. 2. Each email address is guaranteed to be valid as per the standard email format. 3. The email addresses may contain mixed case characters, and domain comparison should be case-insensitive. # Example: Consider the following content of a text file named `emails.txt`: ``` alice@example.com bob@example.com charlie@sub.example.com dana@example.NET eve@example.org ``` The result of running the function on this file should be: ```python { \'example.com\': 2, \'sub.example.com\': 1, \'example.net\': 1, \'example.org\': 1 } ``` # Function Signature: ```python from typing import Dict def count_email_domains(file_path: str) -> Dict[str, int]: pass ``` # Notes: - Ensure domain names are treated in a case-insensitive manner by converting them to lowercase. - Handle potential file reading errors gracefully. - Consider edge cases such as empty files or files with only one or very few addresses. # Example Test Case: ```python def test_count_email_domains(): file_path = \'emails.txt\' with open(file_path, \'w\') as f: f.write(\\"alice@example.comn\\") f.write(\\"bob@example.comn\\") f.write(\\"charlie@sub.example.comn\\") f.write(\\"dana@example.NETn\\") f.write(\\"eve@example.orgn\\") result = count_email_domains(file_path) expected = { \'example.com\': 2, \'sub.example.com\': 1, \'example.net\': 1, \'example.org\': 1 } assert result == expected # Additional tests needed for complete verification ```","solution":"from typing import Dict import os def count_email_domains(file_path: str) -> Dict[str, int]: domain_count = {} if not os.path.exists(file_path): raise FileNotFoundError(f\\"The file {file_path} does not exist.\\") with open(file_path, \'r\') as file: for line in file: email = line.strip() if email: domain = email.split(\'@\')[1].lower() if domain in domain_count: domain_count[domain] += 1 else: domain_count[domain] = 1 return domain_count"},{"question":"# Longest Common Subsequence Problem Statement: You are tasked with finding the length of the longest common subsequence (LCS) between two given strings using dynamic programming. Detailed Description: A subsequence is a sequence that appears in the same relative order, but not necessarily contiguously. A common subsequence of two strings is a subsequence that is common to both strings. The problem is to find the length of the longest subsequence present in both of the given strings. The recursive formula to compute LCS is: [ LCS(X[1...m], Y[1...n]) = begin{cases} 0 & text{if } m = 0 text{ or } n = 0 LCS(X[1...m-1], Y[1...n-1]) + 1 & text{if } X[m-1] = Y[n-1] max(LCS(X[1...m-1], Y[1...n]), LCS(X[1...m], Y[1...n-1]) & text{if } X[m-1] neq Y[n-1] end{cases} ] You need to implement a function that computes this using dynamic programming. Function Signature: ```python def longest_common_subsequence(str1: str, str2: str) -> int: # Your code here ``` Input/Output: * **Input**: * `str1` (str): The first input string. * `str2` (str): The second input string. * **Output**: * An integer representing the length of the longest common subsequence between the two input strings. Constraints: * The input strings will only contain lowercase English letters. * The maximum length of the string will be reasonably within the computational limits (up to about 1000 characters). Example: ```python print(longest_common_subsequence(\\"abcde\\", \\"ace\\")) # Output: 3 print(longest_common_subsequence(\\"abc\\", \\"abc\\")) # Output: 3 print(longest_common_subsequence(\\"abc\\", \\"def\\")) # Output: 0 ``` Implementation Notes: * Ensure your solution handles edge cases such as empty strings and very small strings. * Your solution should be efficient enough to handle larger input sizes effectively due to the constraints given. * The use of a 2D array for dynamic programming is expected to store intermediate results and avoid recomputation.","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: m, n = len(str1), len(str2) # Create a 2D array to store the lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from the bottom up. for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence will be in dp[m][n] return dp[m][n]"},{"question":"# Coding Assessment Question Context: In many applications, managing datasets involves filtering based on various criteria. One common operation is filtering even or odd numbers from a list. To facilitate processing such operations efficiently, you are tasked with writing functions that can perform this filtering and provide statistical summaries of the lists. Problem Statement: Your task is to implement two functions: `filter_evens` and `summary_statistics`. **Function 1: Filtering Evens** Implement a function `filter_evens(numbers: list[int]) -> list[int]` that filters and returns the even numbers from a given list of integers. **Function 2: Summary Statistics** Implement a function `summary_statistics(numbers: list[int]) -> dict[str, float]` that computes and returns a dictionary containing the mean, median, and standard deviation of the given list of integers. **Constraints and Requirements:** 1. **Filtering Evens**: - The input list can be of any length, including zero. - Any non-even numbers (i.e., odd numbers) should be excluded from the result. 2. **Summary Statistics**: - The input list can be of any length but must have at least one element to compute meaningful statistics. - For the purposes of this problem, avoid using any built-in statistical libraries; instead, implement the calculations manually. - Mean is the sum of all elements divided by the number of elements. - Median is the middle value when the numbers are sorted. If the list has an even number of elements, the median is the average of the two middle numbers. - Standard deviation is a measure of the amount of variation or dispersion of the numbers. Use the formula: ( text{std_dev} = sqrt{frac{1}{N} sum (x_i - mu)^2} ), where ( mu ) is the mean. **Expected Input and Output:** 1. `filter_evens(numbers: list[int]) -> list[int]`: - **Input**: A list of integers. - **Output**: A list of integers containing only the even numbers from the input list. 2. `summary_statistics(numbers: list[int]) -> dict[str, float]`: - **Input**: A list of integers. - **Output**: A dictionary with keys \'mean\', \'median\', and \'std_dev\' and their corresponding float values. **Performance Requirements:** - Ensure that the functions perform efficiently even with large lists (up to 10,000 elements). - Consider edge cases, such as empty input list for filter or unsorted input list for statistics calculation. **Example Usage:** ```python # Example usage: # Filtering evens print(filter_evens([1, 2, 3, 4, 5, 6])) # Output: [2, 4, 6] # Summary statistics numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] stats = summary_statistics(numbers) print(stats) # Output: {\'mean\': 5.0, \'median\': 5.0, \'std_dev\': 2.581988897471611} ``` By implementing these functions, you will have created utility features commonly used in data processing and analysis.","solution":"import math def filter_evens(numbers: list[int]) -> list[int]: Filters and returns the even numbers from a given list of integers. return [num for num in numbers if num % 2 == 0] def summary_statistics(numbers: list[int]) -> dict[str, float]: Computes and returns a dictionary containing the mean, median, and standard deviation of the given list of integers. # Calculate mean mean = sum(numbers) / len(numbers) # Sort the numbers to determine median sorted_numbers = sorted(numbers) n = len(numbers) # Calculate median if n % 2 == 0: median = (sorted_numbers[n//2 - 1] + sorted_numbers[n//2]) / 2 else: median = sorted_numbers[n//2] # Calculate standard deviation variance = sum((x - mean) ** 2 for x in numbers) / n std_dev = math.sqrt(variance) return { \'mean\': mean, \'median\': median, \'std_dev\': std_dev }"},{"question":"# Coding Assessment Question Scenario In various applications, it is often necessary to validate input data to ensure it meets specific criteria. A common task is to verify if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. Developing such a function without relying on external libraries helps in understanding fundamental string manipulation techniques and logic building. Problem Statement Write a function `is_valid_palindrome(s: str) -> bool` that takes a string `s` and returns `True` if it is a palindrome, and `False` otherwise. An empty string and strings consisting of non-alphanumeric characters alone should be considered as valid palindromes. Ensure the function ignores cases and non-alphanumeric characters while performing the validation. Input and Output - **Input**: A single string `s` containing ASCII characters. (0 ≤ len(s) ≤ 1000) - **Output**: A boolean value `True` if the given string is a palindrome, `False` otherwise. Constraints - Ignore cases (i.e., treat \'A\' and \'a\' as the same). - Ignore non-alphanumeric characters. - An empty string is considered a valid palindrome. - You must handle edge cases such as strings with only non-alphanumeric characters. Examples ```python >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_valid_palindrome(\\"race a car\\") False >>> is_valid_palindrome(\\"\\") True >>> is_valid_palindrome(\\"!!\\") True >>> is_valid_palindrome(\\"aA\\") True ``` Provide the implementation for the `is_valid_palindrome` function. Ensure your code passes the given examples and consider any edge cases.","solution":"def is_valid_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome considering only alphanumeric characters and ignoring cases. # Filter out non-alphanumeric characters and convert to lowercase. filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters is the same forwards and backwards. return filtered_chars == filtered_chars[::-1]"},{"question":"# Problem: Route Optimizer for Delivery Drones You are given a fleet of delivery drones that need to deliver packages to various locations. Each drone has a limited battery capacity, and you must find the optimal route to ensure all packages are delivered with the least amount of energy consumption. Instructions: 1. **Implement the Optimal Path Algorithm**: Write a function `find_optimal_route` that calculates the most energy-efficient path for each drone to deliver packages. 2. **Handle Edge Cases**: Ensure that your implementation can handle scenarios where the starting and ending points are the same, where there are multiple packages at the same location, and where some locations are unreachable. Input: - A list of delivery locations as tuples `(x, y)` representing coordinates on a 2D plane. - A starting location `(sx, sy)` of the drone. - The battery capacity `B` of the drone. - An optional list of non-accessible locations (no-fly zones) on the 2D plane. Output: - A list of tuples representing the optimal delivery route in order of visitation. - A boolean value indicating whether all deliveries were completed within the battery capacity. Constraints: - The coordinates are integers. - The plane is bound by (-10^4 le x, y le 10^4). - The battery capacity (B) is an integer. - There will be at least one delivery location. - Non-accessible locations will not overlap with the starting location or delivery locations. Example Usage: ```python locations = [(2, 3), (5, 7), (8, 2)] start_location = (0, 0) battery_capacity = 20 no_fly_zones = [(4, 4), (6, 6)] route, status = find_optimal_route(locations, start_location, battery_capacity, no_fly_zones) print(route) # [(0, 0), (2, 3), (5, 7), (8, 2)] print(status) # True ``` Constraints: - The number of delivery locations (1 le N le 50). - The number of no-fly zones (0 le Z le 100). You will be graded on: - Correctness: Ensure the implementation delivers all packages within the battery capacity if possible. - Efficiency: Use efficient algorithms to handle the routing and optimize the energy consumption. - Clarity: Maintain readable code with appropriate documentation. Make sure to test your implementation thoroughly against all provided test cases.","solution":"def find_optimal_route(locations, start_location, battery_capacity, no_fly_zones=[]): Calculate the most energy-efficient path for the drone to deliver packages. Args: locations (list of tuple): List of delivery locations as (x, y) coordinates. start_location (tuple): Starting location of the drone as (sx, sy) coordinates. battery_capacity (int): The battery capacity of the drone. no_fly_zones (list of tuple, optional): List of non-accessible locations as (x, y) coordinates. Returns: (list of tuple, bool): The optimal delivery route and a boolean indicating if the deliveries were completed within battery capacity. from itertools import permutations import math def distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def is_accessible(path, no_fly_zones): for point in path: if point in no_fly_zones: return False return True locations_permutations = permutations(locations) optimal_route = None min_distance = float(\'inf\') for perm in locations_permutations: route = [start_location] + list(perm) total_distance = sum(distance(route[i], route[i+1]) for i in range(len(route)-1)) + distance(route[-1], start_location) if total_distance <= battery_capacity and is_accessible(route, no_fly_zones): if total_distance < min_distance: min_distance = total_distance optimal_route = route if optimal_route: optimal_route.append(start_location) return optimal_route, True else: return [], False"},{"question":"# Word Frequency Counter in Large File Develop a function that reads a large text file and outputs the frequency of each word encountered in the file. Due to the potentially large size of the file, the function should be optimized to handle memory efficiently by processing the file in chunks. Function Signature ```python def word_frequency(input_filename: str, output_filename: str, chunk_size: int) -> None: Count word frequencies in a large text file and write the frequencies to an output file. Args: input_filename (str): The name of the input file to be processed. output_filename (str): The name of the file where word frequencies should be written. chunk_size (int): The size of each chunk to be read into memory (in bytes). Returns: None ``` Constraints 1. The input file contains an arbitrary amount of text with words separated by spaces and punctuations. 2. The function should efficiently manage memory by reading the file in chunks of the specified size. 3. The output file should list each word and its frequency in the format: `word: frequency`, one per line. Requirements 1. Implement the `word_frequency` function to read the file chunk by chunk. 2. Split the text into words, handle punctuation, and count frequencies. 3. Write the word frequencies to the output file in a sorted order, alphabetically by word. 4. Ensure proper handling of chunks to account for words that might be split between chunks. Example Assuming `input.txt` contains: ``` apple banana apple orange banana apple kiwi fruit orange ``` Calling the function as follows: ```python word_frequency(\'input.txt\', \'output.txt\', 1024) # chunk_size = 1KB ``` The `output.txt` should contain: ``` apple: 3 banana: 2 fruit: 1 kiwi: 1 orange: 2 ``` Notes - The function must handle reading large files and avoid holding the entire file in memory. - Properly manage edge cases where words might be split across two chunks. - Ensure that the output is sorted by the word in alphabetical order and the frequencies are correctly counted.","solution":"import re from collections import defaultdict def word_frequency(input_filename: str, output_filename: str, chunk_size: int) -> None: # Use a default dictionary to count word frequencies word_count = defaultdict(int) # Function to process a block of text to count word frequencies def process_block(block): words = re.findall(r\'bw+b\', block.lower()) for word in words: word_count[word] += 1 with open(input_filename, \'r\') as file: remainder = \'\' while True: chunk = file.read(chunk_size) if not chunk: break # Adding remainder from the previous chunk to the beginning of the current chunk chunk = remainder + chunk # Find the last complete word from the chunk last_space = chunk.rfind(\' \') if last_space != -1: # Process the text up to the last space process_block(chunk[:last_space]) # Save the remainder for the next chunk remainder = chunk[last_space:] else: # If no space was found in the chunk, hold it for the next read remainder = chunk # Process the final remainder if any if remainder: process_block(remainder) # Writing word frequencies to output file with open(output_filename, \'w\') as out_file: for word in sorted(word_count.keys()): out_file.write(f\\"{word}: {word_count[word]}n\\")"},{"question":"# **Circular Buffer Implementation** You are tasked with implementing a circular buffer (ring buffer) data structure in Python. The circular buffer is a fixed-size data structure that efficiently supports `enqueue` and `dequeue` operations with a constant time complexity, and is often used in scenarios where a fixed amount of space is needed for buffering data. Problem Statement Design and implement a class `CircularBuffer` with the following methods: 1. `__init__(self, capacity)`: Initializes the buffer with a specified fixed capacity. 2. `enqueue(self, item)`: Adds an item to the buffer. If the buffer is full, the oldest data will be overwritten. 3. `dequeue(self)`: Removes and returns the oldest item from the buffer. 4. `is_empty(self)`: Returns `True` if the buffer is empty, `False` otherwise. 5. `is_full(self)`: Returns `True` if the buffer is full, `False` otherwise. 6. `size(self)`: Returns the number of elements currently in the buffer. # Class Definition: 1. **`__init__(self, capacity)`**: - **Input**: An integer `capacity` that denotes the maximum number of items the buffer can hold. - **Output**: None. - **Constraints**: Assume `capacity` is a positive integer. 2. **`enqueue(self, item)`**: - **Input**: `item` can be of any data type. - **Output**: None. 3. **`dequeue(self)`**: - **Input**: None. - **Output**: The oldest item in the buffer. If the buffer is empty, return `None`. 4. **`is_empty(self)`**: - **Input**: None. - **Output**: A boolean indicating if the buffer is empty. 5. **`is_full(self)`**: - **Input**: None. - **Output**: A boolean indicating if the buffer is full. 6. **`size(self)`**: - **Input**: None. - **Output**: An integer representing the number of elements currently in the buffer. Example: ```python buffer = CircularBuffer(3) buffer.enqueue(1) buffer.enqueue(2) buffer.enqueue(3) print(buffer.is_full()) # Output: True buffer.enqueue(4) print(buffer.size()) # Output: 3 print(buffer.dequeue()) # Output: 2 print(buffer.dequeue()) # Output: 3 print(buffer.dequeue()) # Output: 4 print(buffer.is_empty()) # Output: True ``` # Additional Requirements: - Handle edge cases like dequeueing from an empty buffer and enqueueing with no initial capacity. - Ensure that the operations maintain constant time complexity.","solution":"class CircularBuffer: def __init__(self, capacity): self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.end = 0 self.count = 0 def enqueue(self, item): self.buffer[self.end] = item self.end = (self.end + 1) % self.capacity if self.count == self.capacity: self.start = (self.start + 1) % self.capacity else: self.count += 1 def dequeue(self): if self.is_empty(): return None item = self.buffer[self.start] self.start = (self.start + 1) % self.capacity self.count -= 1 return item def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.capacity def size(self): return self.count"},{"question":"# Coding Assessment Question: Implement a Custom Exception Handler Context You are given a basic retail store inventory system that manages products and their quantities. The system currently lacks robust error handling, and your task is to implement custom exception handling to make the system more reliable. You need to create and integrate custom exceptions to handle specific scenarios gracefully. Task 1. **Define Custom Exceptions**: - `ProductNotFoundError`: Raised when attempting to access or modify a product that does not exist. - `InsufficientQuantityError`: Raised when attempting to reduce the quantity of a product below zero. 2. **Modify Inventory Methods**: - Update methods `add_product`, `remove_product`, and `reduce_quantity` to handle the new exceptions. 3. **Testing Exception Handling**: - Incorporate a method `test_exceptions` that demonstrates handling each of the new exceptions. Implementation ```python class ProductNotFoundError(Exception): Exception raised when a product is not found in the inventory. pass class InsufficientQuantityError(Exception): Exception raised when there is an attempt to reduce quantity below zero. pass class Inventory: def __init__(self): self.products = {} def add_product(self, product_name, quantity): if product_name in self.products: self.products[product_name] += quantity else: self.products[product_name] = quantity def remove_product(self, product_name): if product_name not in self.products: raise ProductNotFoundError(f\\"Product \'{product_name}\' not found.\\") del self.products[product_name] def reduce_quantity(self, product_name, quantity): if product_name not in self.products: raise ProductNotFoundError(f\\"Product \'{product_name}\' not found.\\") if self.products[product_name] < quantity: raise InsufficientQuantityError(f\\"Not enough quantity of \'{product_name}\'.\\") self.products[product_name] -= quantity def test_exceptions(self): try: self.reduce_quantity(\\"non_existing_product\\", 1) except ProductNotFoundError as e: print(f\\"Caught an exception - {e}\\") try: self.add_product(\\"apple\\", 5) self.reduce_quantity(\\"apple\\", 10) except InsufficientQuantityError as e: print(f\\"Caught an exception - {e}\\") try: self.remove_product(\\"non_existing_product\\") except ProductNotFoundError as e: print(f\\"Caught an exception - {e}\\") Input Format - `add_product` takes a string `product_name` and an integer `quantity`. - `remove_product` takes a string `product_name`. - `reduce_quantity` takes a string `product_name` and an integer `quantity`. Output Format - All methods operate on the inventory and return appropriate values. - Custom exception messages should provide clear and descriptive error information. Constraints - Product names are case-sensitive strings. - Quantities are non-negative integers. You should write your implementation within the given `Inventory` class template.","solution":"class ProductNotFoundError(Exception): Exception raised when a product is not found in the inventory. pass class InsufficientQuantityError(Exception): Exception raised when there is an attempt to reduce quantity below zero. pass class Inventory: def __init__(self): self.products = {} def add_product(self, product_name, quantity): if product_name in self.products: self.products[product_name] += quantity else: self.products[product_name] = quantity def remove_product(self, product_name): if product_name not in self.products: raise ProductNotFoundError(f\\"Product \'{product_name}\' not found.\\") del self.products[product_name] def reduce_quantity(self, product_name, quantity): if product_name not in self.products: raise ProductNotFoundError(f\\"Product \'{product_name}\' not found.\\") if self.products[product_name] < quantity: raise InsufficientQuantityError(f\\"Not enough quantity of \'{product_name}\'.\\") self.products[product_name] -= quantity def test_exceptions(self): try: self.reduce_quantity(\\"non_existing_product\\", 1) except ProductNotFoundError as e: print(f\\"Caught an exception - {e}\\") try: self.add_product(\\"apple\\", 5) self.reduce_quantity(\\"apple\\", 10) except InsufficientQuantityError as e: print(f\\"Caught an exception - {e}\\") try: self.remove_product(\\"non_existing_product\\") except ProductNotFoundError as e: print(f\\"Caught an exception - {e}\\")"},{"question":"# Coding Question: Binary Search Tree Maximum Width In this task, you will implement a function to determine the maximum width of a given binary search tree. The width of a tree at a particular level is defined as the number of nodes present at that level. Function Signature: ```python def max_width_of_bst(root: Optional[TreeNode]) -> int: pass ``` # Input: - `root`: The root of the binary search tree (BST), represented as an instance of the `TreeNode` class. # Output: - An integer representing the maximum width of any level in the BST. # Constraints: - The number of nodes in the BST is between `1` and `1000`. # Example: 1. **Input**: ```python # The TreeNode class is defined as follows: # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right # # root = TreeNode(1) # root.left = TreeNode(2) # root.right = TreeNode(3) # root.left.left = TreeNode(4) # root.left.right = TreeNode(5) # root.right.right = TreeNode(8) # root.right.right.left = TreeNode(6) # root.right.right.right = TreeNode(7) max_width_of_bst(root) ``` **Output**: ```python 4 ``` 2. **Input**: ```python # root2 = TreeNode(1) # root2.left = TreeNode(2) # root2.left.left = TreeNode(4) # root2.left.left.left = TreeNode(8) max_width_of_bst(root2) ``` **Output**: ```python 1 ``` # Explanation: In the first example: - The level order traversal of the tree is: - Level 1: 1 - Level 2: 2, 3 - Level 3: 4, 5, None, 8 - Level 4: None, None, 6, 7 - The maximum width of any level in this tree is `4` (which is the width at the 4th level). In the second example: - The level order traversal of the tree is: - Level 1: 1 - Level 2: 2 - Level 3: 4 - Level 4: 8 - The maximum width of any level in this tree is `1`. # Notes: 1. Ensure that your implementation handles edge cases such as: - A tree with only the root node. - Imbalanced trees with all nodes skewed to one side.","solution":"from typing import Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_width_of_bst(root: Optional[TreeNode]) -> int: if not root: return 0 max_width = 0 queue = deque([(root, 0)]) while queue: level_length = len(queue) _, first_index = queue[0] last_index = queue[-1][1] max_width = max(max_width, last_index - first_index + 1) for _ in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) return max_width"},{"question":"# Dynamic Programming Array Manipulation You are tasked with developing an efficient solution for manipulating an array through a series of operations, leveraging dynamic programming principles. The operations involve incrementing subarrays by fixed values and querying the sum of subarray elements. Task: Implement a class `ArrayManipulator` that supports two primary operations on an integer array: 1. **Increment:** Increment each element of a subarray by a given integer value. 2. **Sum Query:** Return the sum of elements in a specified subarray. Class Structure: ```python class ArrayManipulator: def __init__(self, size: int): Initialize the ArrayManipulator with an array of zeros of given size. :param size: Size of the array pass def increment(self, left: int, right: int, value: int) -> None: Increment each element in the array from index left to index right (inclusive) by value. :param left: Left index of the subarray (0-based) :param right: Right index of the subarray (0-based) :param value: Value to increment each element by pass def sum_query(self, left: int, right: int) -> int: Return the sum of the elements in the array from index left to index right (inclusive). :param left: Left index of the subarray (0-based) :param right: Right index of the subarray (0-based) :return: Sum of elements within the specified range pass ``` Requirements: 1. **Constructor (`__init__`):** * Input: `size` (integer) - the size of the array to initialize. * Initializes an array of zeros with the specified size. 2. **Increment Method (`increment`):** * Input: `left`, `right` (integers) - the range of indices to increment (inclusive). * Input: `value` (integer) - the value to increment each element by. * Update the elements in the specified subarray efficiently. 3. **Sum Query Method (`sum_query`):** * Input: `left`, `right` (integers) - the range of indices to query (inclusive). * Output: (integer) - the sum of elements within the specified subarray. * The sum query must be handled efficiently. 4. **Edge Cases:** * Invalid or out-of-bound indices for `increment` and `sum_query` should be handled gracefully. 5. **Performance Considerations:** * Optimize the solution to handle multiple `increment` and `sum_query` operations efficiently, even for large arrays. Example Usage: ```python array_manipulator = ArrayManipulator(10) array_manipulator.increment(2, 5, 3) array_manipulator.increment(0, 3, 1) print(array_manipulator.sum_query(0, 5)) # Expected output: 10 print(array_manipulator.sum_query(4, 5)) # Expected output: 6 print(array_manipulator.sum_query(6, 9)) # Expected output: 0 ``` In this example: * The initial array is `[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`. * After `increment(2, 5, 3)`, the array becomes `[0, 0, 3, 3, 3, 3, 0, 0, 0, 0]`. * After `increment(0, 3, 1)`, the array becomes `[1, 1, 4, 4, 3, 3, 0, 0, 0, 0]`. The `sum_query` operations provide the expected sums based on the modified array. Focus on implementing the `ArrayManipulator` class efficiently, using techniques such as prefix sums or difference arrays where applicable to optimize performance. Ensure you handle edge cases gracefully and optimize for large input sizes.","solution":"class ArrayManipulator: def __init__(self, size: int): Initialize the ArrayManipulator with an array of zeros of given size. :param size: Size of the array self.size = size self.array = [0] * size self.lazy = [0] * (size + 1) def increment(self, left: int, right: int, value: int) -> None: Increment each element in the array from index left to index right (inclusive) by value. :param left: Left index of the subarray (0-based) :param right: Right index of the subarray (0-based) :param value: Value to increment each element by if left < 0 or right >= self.size or left > right: return self.lazy[left] += value if right + 1 < self.size: self.lazy[right + 1] -= value def sum_query(self, left: int, right: int) -> int: Return the sum of the elements in the array from index left to index right (inclusive). :param left: Left index of the subarray (0-based) :param right: Right index of the subarray (0-based) :return: Sum of elements within the specified range if left < 0 or right >= self.size or left > right: return 0 # Apply the lazy increment current_increment = 0 for i in range(self.size): current_increment += self.lazy[i] self.array[i] += current_increment self.lazy[i] = 0 # Reset lazy # Compute prefix sums prefix_sum = [0] * (self.size + 1) for i in range(1, self.size + 1): prefix_sum[i] = prefix_sum[i-1] + self.array[i-1] return prefix_sum[right + 1] - prefix_sum[left]"},{"question":"**Context**: Data compression is a critical aspect in various computer science applications, including file storage, data transmission, and real-time streaming. Huffman coding is an efficient method for lossless data compression, which constructs an optimal binary tree-based encoding for symbols based on their frequencies. **Objective**: Your task is to implement the Huffman Coding algorithm. Given a set of characters and their corresponding frequencies, you need to construct the Huffman Tree and generate the Huffman codes for each character. Understanding this algorithm will enhance your grasp of greedy algorithms and their practical applications in data compression. # Task Description: Implement the function `huffman_encoding(char_freq: List[Tuple[str, int]]) -> Dict[str, str]` that takes in a list of tuples where each tuple represents a character and its frequency, and returns a dictionary where the keys are the characters and the values are the Huffman codes. # Input Format: *A single argument: `char_freq` (type: `List[Tuple[str, int]]`). The input list containing tuples with characters and their respective frequencies. # Output Format: * Returns a `Dict[str, str]` where each character is mapped to its Huffman code. # Constraints: 1. The input list will contain at least 1 and at most 1000 tuples. 2. All characters in the input list are unique and consist of printable ASCII characters. 3. All frequencies are positive integers and the sum of frequencies does not exceed (10^6). # Examples: ```python # Example 1 char_freq = [(\'a\', 5), (\'b\', 9), (\'c\', 12), (\'d\', 13), (\'e\', 16), (\'f\', 45)] print(huffman_encoding(char_freq)) # Possible Output: {\'f\': \'0\', \'c\': \'100\', \'d\': \'101\', \'a\': \'1100\', \'b\': \'1101\', \'e\': \'111\'} # Example 2 char_freq = [(\'x\', 2), (\'y\', 3), (\'z\', 6)] print(huffman_encoding(char_freq)) # Possible Output: {\'z\': \'0\', \'x\': \'10\', \'y\': \'11\'} ``` # Note: 1. The specific binary Huffman codes generated can vary as long as the described properties hold true, i.e., the code is optimal and uniquely decodable. 2. For simplicity, you can assume the provided frequencies ensure a unique Huffman coding tree construction without ties in frequencies that might introduce ambiguity in the structure of the tree.","solution":"import heapq from typing import List, Tuple, Dict class Node: def __init__(self, freq, char=None, left=None, right=None): self.freq = freq self.char = char self.left = left self.right = right def __lt__(self, other): return self.freq < other.freq def build_huffman_tree(char_freq: List[Tuple[str, int]]) -> Node: heap = [Node(freq, char) for char, freq in char_freq] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = Node(left.freq + right.freq, None, left, right) heapq.heappush(heap, merged) return heap[0] def generate_huffman_codes(root: Node, prefix: str, huffman_code: Dict[str, str]): if root.char is not None: huffman_code[root.char] = prefix else: generate_huffman_codes(root.left, prefix + \'0\', huffman_code) generate_huffman_codes(root.right, prefix + \'1\', huffman_code) def huffman_encoding(char_freq: List[Tuple[str, int]]) -> Dict[str, str]: if not char_freq: return {} root = build_huffman_tree(char_freq) huffman_code = {} generate_huffman_codes(root, \'\', huffman_code) return huffman_code"},{"question":"**Scenario**: You are working on a financial application that requires verification of credit card numbers to ensure they are valid as per the Luhn algorithm. **Task**: Implement a function `validate_credit_card(card_number: str) -> bool` that checks whether a given credit card number is valid. The credit card number may contain spaces or dashes which need to be ignored during the validation. Use the Luhn algorithm to perform this verification. The Luhn algorithm works as follows: 1. Starting from the rightmost digit, double the value of every second digit (i.e., the last digit is unchanged, the second last digit is doubled, etc.). If doubling a digit results in a number greater than 9, subtract 9 from the result. 2. Sum up all the digits of the resulting numbers. 3. If the total sum is divisible by 10, the credit card number is valid; otherwise, it is not. * Expected input and output formats: * `validate_credit_card(\\"1234-5678-9012-3456\\")` -> `bool` * `validate_credit_card(\\"1234 5678 9012 3456\\")` -> `bool` * Constraints: * The credit card number must be between 13 and 19 digits long (excluding spaces and dashes). * The function should ignore any non-digit characters (spaces, dashes) within the input string. Below is the starting code for the function: ```python def validate_credit_card(card_number: str) -> bool: # Implement the logic to validate the credit card number using the Luhn algorithm. pass ```","solution":"def validate_credit_card(card_number: str) -> bool: # Remove spaces and dashes from the card number card_number = card_number.replace(\\" \\", \\"\\").replace(\\"-\\", \\"\\") # Check if the card number length is within the valid range if not 13 <= len(card_number) <= 19: return False # Check if all characters are digits if not card_number.isdigit(): return False total = 0 reverse_digits = card_number[::-1] for i, digit in enumerate(reverse_digits): n = int(digit) if (i % 2 == 1): # Index is odd in 0-based index (even when 1-based) n *= 2 if n > 9: n -= 9 total += n return total % 10 == 0"},{"question":"# Coding Exercise: Implementing a Matrix Rotation Function Context In image processing and computer graphics, rotating a matrix is a common operation. This is often required in applications involving transformations and manipulations of images or two-dimensional data. Rotating a matrix by 90 degrees clockwise can be particularly useful. Task Write a Python function `rotate_matrix` that rotates a given square matrix by 90 degrees clockwise. The matrix will be represented as a list of lists, with each inner list representing a row. Requirements 1. **Function Name**: `rotate_matrix` 2. **Expected Input and Output**: - Input: A square matrix (list of lists) of size ( n times n ), where ( 1 leq n leq 100 ). - Output: A new list of lists representing the rotated matrix. 3. **Constraints**: - Can handle matrices of varying sizes within the specified range. 4. **Performance Requirements**: The function should be efficient and handle the maximum input size smoothly. Example Scenarios ```python >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] ``` Instructions - Implement the function with minimal auxiliary space. - Avoid modifying the input matrix directly; return a new matrix representing the rotated version. - Ensure your function correctly handles edge cases such as the smallest matrix sizes.","solution":"def rotate_matrix(matrix): Rotates the given square matrix by 90 degrees clockwise. Args: matrix (list of lists): The input square matrix. Returns: list of lists: A new matrix rotated by 90 degrees clockwise. n = len(matrix) # Initialize the new matrix rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Reversing Subarrays Scenario You are tasked with manipulating an array by reversing all subarrays of a given size. The objective is to create a function that takes an array of integers and an integer k (subarray size) and reverses every k-sized subarray within the array. If the array cannot be divided evenly by k, the remaining elements should be left as is. Function Signature ```python def reverse_subarrays(arr: list, k: int) -> list: pass ``` Input 1. A list of integers `arr` where (1 ≤ len(arr) ≤ 10^5) 2. An integer `k` (1 ≤ k ≤ len(arr)) Output A list of integers representing the modified array with all possible k-sized subarrays reversed. Example ```python assert reverse_subarrays([1, 2, 3, 4, 5], 2) == [2, 1, 4, 3, 5] # Subarrays: [1, 2], [3, 4], [5] assert reverse_subarrays([1, 2, 3, 4, 5, 6, 7], 3) == [3, 2, 1, 6, 5, 4, 7] # Subarrays: [1, 2, 3], [4, 5, 6], [7] assert reverse_subarrays([10, 20, 30, 40, 50, 60], 4) == [40, 30, 20, 10, 50, 60] # Subarrays: [10, 20, 30, 40], [50, 60] ``` Constraints * Iterate through the array in chunks of size k and reverse each chunk. * If the chunk size is less than k at the end, leave it unchanged. Guidelines * Utilize efficient slicing and reversing techniques to handle large arrays. * Ensure that the function processes the array within reasonable time limits for the given constraints. * Simulate k-subarray processing and provide appropriate test examples to validate your approach.","solution":"def reverse_subarrays(arr: list, k: int) -> list: Reverse subarrays of size k within the array. # result array to store the modified elements result = [] # iterate through the array in chunks of size k for i in range(0, len(arr), k): # get the current chunk and reverse it if its size is k chunk = arr[i:i + k] if len(chunk) == k: chunk.reverse() # add the chunk to the result array result.extend(chunk) return result"},{"question":"# Coding Assessment Question **Context**: You are tasked with designing a feature for a Graph Database system that performs various graph traversal algorithms. Graph traversal is a fundamental requirement in graph databases for querying and analyzing data. # Task Your task is to implement a function that finds the shortest path in an unweighted graph from a starting node to a target node using the Breadth-First Search (BFS) algorithm. **Specifications**: 1. Implement the function `shortest_path(graph, start_node, target_node)` that finds the shortest path from the `start_node` to the `target_node`. - Parameters: * `graph`: A dictionary where keys are node identifiers and values are lists of nodes representing the adjacency list of each node. * `start_node`: The identifier of the starting node. * `target_node`: The identifier of the target node. - Returns: A list of nodes representing the shortest path from `start_node` to `target_node`. If no path exists, return an empty list. - Constraints: * The graph is connected, and each node appears as a key in the dictionary. * The nodes are represented as integers or strings. * There may be multiple shortest paths; returning any one valid path is acceptable. **Steps**: 1. Initialize a queue with the `start_node` and an empty path. 2. Use BFS to explore the graph level by level. 3. Track visited nodes to avoid cycles. 4. When the `target_node` is reached, return the path taken to get there. 5. If the queue is exhausted without finding the target, return an empty list. **Example**: ```python graph = { 1: [2, 3], 2: [4], 3: [4], 4: [5], 5: [] } start_node = 1 target_node = 5 shortest_path(graph, start_node, target_node) # Expected output: [1, 2, 4, 5] or [1, 3, 4, 5] ``` **Note**: - Consider edge cases such as when the `start_node` is the same as the `target_node`, or when the `target_node` is not reachable from the `start_node`. - Ensure the function handles large graphs efficiently within reasonable limits for BFS.","solution":"from collections import deque def shortest_path(graph, start_node, target_node): Finds the shortest path in an unweighted graph from start_node to target_node using BFS. :param graph: A dictionary where keys are node identifiers and values are lists of adjacent nodes. :param start_node: The identifier of the starting node. :param target_node: The identifier of the target node. :return: A list of nodes representing the shortest path from start_node to target_node. if start_node == target_node: return [start_node] visited = set() queue = deque([(start_node, [start_node])]) while queue: current_node, path = queue.popleft() if current_node not in visited: visited.add(current_node) for neighbor in graph[current_node]: if neighbor == target_node: return path + [target_node] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Palindrome Checker Objective Write a function that checks whether a given string is a palindrome. Function Signature ```python def is_palindrome(s: str) -> bool: pass ``` Input - A single string `s` of length (1 <= len(s) <= 10^5) consisting of lowercase and uppercase alphabets. Output - Return `True` if the string `s` is a palindrome. Otherwise, return `False`. Examples ```python assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"hello\\") == False assert is_palindrome(\\"Aba\\") == True assert is_palindrome(\\"Noon\\") == True assert is_palindrome(\\"Palindrome\\") == False ``` Constraints * Your solution should account for case insensitivity (i.e., \'A\' and \'a\' should be considered the same). * Consider edge cases like empty strings or single character strings. # Explanation A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring case). Performance Requirements To handle the maximum string length efficiently, consider: - Using two pointers technique to compare characters from both ends towards the center. - Normalizing the string to a common case (e.g., all lowercase) before comparison.","solution":"def is_palindrome(s: str) -> bool: Checks if the input string is a palindrome. A palindrome reads the same forwards and backwards, case insensitive. :param s: The input string to check. :return: True if \'s\' is a palindrome, False otherwise. normalized_s = s.lower() left, right = 0, len(normalized_s) - 1 while left < right: if normalized_s[left] != normalized_s[right]: return False left += 1 right -= 1 return True"},{"question":"**Context**: You are working as a software engineer tasked with optimizing the performance of a music streaming service. One of the challenges is efficiently finding subsequences in playlists. Specifically, you need to determine if a given playlist can be decomposed into multiple non-overlapping increasing subsequences. **Task**: Write a function `is_partitionable` that determines if the given playlist can be partitioned into one or more non-overlapping strictly increasing subsequences. # Function Signature ```python def is_partitionable(arr: List[int]) -> bool: pass ``` # Input * `arr`: A list of integers representing the playlist. # Output * Returns a boolean indicating whether the playlist can be partitioned into one or more strictly increasing subsequences. # Constraints * 0 ≤ len(arr) ≤ 10^4 * The integers in the list can be any signed 32-bit integers. # Example ```python assert is_partitionable([1, 2, 3, 4, 5]) == True assert is_partitionable([5, 1, 2, 3, 4]) == True assert is_partitionable([1, 3, 2, 4]) == False assert is_partitionable([1, 2, 2, 3]) == False assert is_partitionable([]) == True assert is_partitionable([1]) == True ``` # Explanation 1. The playlist `[1, 2, 3, 4, 5]` is already a single strictly increasing subsequence. 2. The playlist `[5, 1, 2, 3, 4]` can be partitioned into two subsequences: `[5]` and `[1, 2, 3, 4]`. 3. The playlist `[1, 3, 2, 4]` cannot be partitioned as required. 4. The playlist `[1, 2, 2, 3]` contains a repetition, which prevents partitioning into strictly increasing subsequences.","solution":"from typing import List def is_partitionable(arr: List[int]) -> bool: Determine if the given list can be partitioned into one or more non-overlapping strictly increasing subsequences. if not arr: return True prev = float(\'-inf\') count = 0 n = len(arr) for i in range(n): if arr[i] > prev: prev = arr[i] count += 1 return count == n"},{"question":"# Question: A company is planning a networking event and needs to schedule presentations. You are given two lists, `start_times` and `end_times`, representing the start and end times of each presentation, respectively. The goal is to fit as many non-overlapping presentations as possible in the schedule. **Function Signature**: ```python def max_presentations(start_times: List[int], end_times: List[int]) -> int: Determines the maximum number of non-overlapping presentations that can be scheduled. :param start_times: A list of integers representing the start times of the presentations. :param end_times: A list of integers representing the end times of the presentations. :return: An integer representing the maximum number of non-overlapping presentations. Example: >>> start_times = [1, 3, 0, 5, 8, 5] >>> end_times = [2, 4, 6, 7, 9, 9] >>> max_presentations(start_times, end_times) 4 Constraints: - start_times and end_times list will be of the same length. - 1 <= len(start_times), len(end_times) <= 10^3 - 1 <= start_times[i] < end_times[i] <= 10^5 for any valid index i. ``` **Requirements**: 1. Utilize a greedy approach by considering the earliest end times first. 2. Ensure the function handles edge cases (e.g., no presentations). 3. The function should exhibit a time complexity of O(n log n) due to sorting. **Example**: ```python >>> start_times = [1, 3, 2, 4] >>> end_times = [2, 5, 4, 6] >>> print(max_presentations(start_times, end_times)) 2 ```","solution":"from typing import List def max_presentations(start_times: List[int], end_times: List[int]) -> int: Determines the maximum number of non-overlapping presentations that can be scheduled. # Combine and sort the presentations by their end times presentations = sorted(zip(start_times, end_times), key=lambda x: x[1]) # Initialize the count of presentations and the end time of the last selected presentation count = 0 last_end_time = 0 for start, end in presentations: # If the start time of the current presentation is after # the end time of the last selected presentation, select this one if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"# Coding Assessment Question You are tasked with implementing a function that reads and processes a CSV file containing user data and extracts specific information to generate a report. This will test your understanding of file handling, data parsing, and generating structured output. # Question **Problem Statement:** Write a function `generate_user_report(csv_file_path: str) -> str` that reads a CSV file containing user data and generates a report summarizing the users from each country. The report should list each country followed by the count of users from that country, sorted in descending order by user count. **Input:** - `csv_file_path` (str): The path to the input CSV file. **Output:** - A string report where each line contains a country and the count of users from that country, in the format `Country: Count`. **CSV Format:** - The CSV file will have the following columns: `id`, `name`, `email`, `country`. - The file may contain headers. **Constraints:** - You must handle file reading errors gracefully. - If the CSV file is empty or contains no valid data, return an appropriate message such as \\"No user data available.\\" - Ensure the function is efficient with memory and processing. # Example Suppose the CSV file `users.csv` has the following content: ``` id,name,email,country 1,John Doe,john@example.com,USA 2,Jane Smith,jane@example.com,Canada 3,Bob Brown,bob@example.com,USA 4,Alice Green,alice@example.com,UK 5,Mary White,mary@example.com,Canada ``` ```python def generate_user_report(csv_file_path: str) -> str: pass # Your implementation here # Example usage: print(generate_user_report(\\"users.csv\\")) ``` # Expected Output ``` USA: 2 Canada: 2 UK: 1 ``` Make sure your code is well-documented, handles errors appropriately, and is efficient. Use any necessary libraries to accomplish the task.","solution":"import csv from collections import defaultdict def generate_user_report(csv_file_path: str) -> str: Reads a CSV file containing user data and generates a report summarizing the users from each country. Parameters: csv_file_path (str): The path to the input CSV file. Returns: str: A report where each line contains a country and the count of users from that country, in the format \\"Country: Count\\", sorted in descending order by user count. try: country_counts = defaultdict(int) with open(csv_file_path, newline=\'\', encoding=\'utf-8\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: if \'country\' in row: country_counts[row[\'country\']] += 1 if not country_counts: return \\"No user data available.\\" sorted_countries = sorted(country_counts.items(), key=lambda item: item[1], reverse=True) report_lines = [f\\"{country}: {count}\\" for country, count in sorted_countries] return \'n\'.join(report_lines) except FileNotFoundError: return \\"File not found.\\" except Exception as e: return f\\"An error occurred: {e}\\""},{"question":"# Problem Statement You are tasked with developing a function that calculates the least common multiple (LCM) of an array of integers. Your function should be capable of handling both positive and negative integers. # Function Signature ```python def array_lcm(numbers: list[int]) -> int: pass ``` # Input - `numbers`: A list of integers wherein the list can have both positive and negative numbers. # Output - An integer representing the least common multiple of the provided integers. # Constraints - The list `numbers` will contain at least two integers and not more than 1000 integers. - Each integer in the list will have an absolute value not exceeding (10^6). # Example ```python print(array_lcm([4, 6])) # Output: 12 print(array_lcm([15, 20, 30])) # Output: 60 print(array_lcm([-3, 9, 12])) # Output: 36 print(array_lcm([5, -5])) # Output: 5 print(array_lcm([40, 1, 2, 5])) # Output: 40 ``` # Additional Requirements - Do not use built-in libraries that perform this task directly. Implement the LCM calculation logic yourself. - Ensure that the function can handle negative numbers, where the sign of the LCM should always be positive. - Include input validation to ensure the list is not empty and contains only integers. Raise a `ValueError` with the message \\"Invalid input: numbers must be a list of integers\\" for invalid inputs. # Test Cases To validate your solution, include the following test cases in addition to any you create: ```python print(array_lcm([17, 31])) # Output: 527 print(array_lcm([2, 5, 7, 11])) # Output: 770 print(array_lcm([-4, 10, 20])) # Output: 20 print(array_lcm([3, 6, 9, 12])) # Output: 36 print(array_lcm(\\"abc\\")) # Raises ValueError: \\"Invalid input: numbers must be a list of integers\\" ```","solution":"def gcd(a, b): Helper function to compute the greatest common divisor of a and b. while b: a, b = b, a % b return a def lcm(a, b): Helper function to compute the least common multiple of a and b. return abs(a * b) // gcd(a, b) def array_lcm(numbers: list[int]) -> int: Returns the least common multiple (LCM) of a list of integers. Handles both positive and negative integers by considering their absolute values. if not isinstance(numbers, list) or not all(isinstance(x, int) for x in numbers): raise ValueError(\\"Invalid input: numbers must be a list of integers\\") if len(numbers) < 2: raise ValueError(\\"Invalid input: the list must contain at least two integers\\") current_lcm = abs(numbers[0]) for number in numbers[1:]: current_lcm = lcm(current_lcm, abs(number)) return current_lcm"},{"question":"# Coding Assessment Question Context You\'re developing an application that needs to compress and decompress sequences of integers using Run-Length Encoding (RLE). RLE is a simple form of lossless data compression in which runs of data are stored as a single data value and count. Task Implement two functions: `compress_rle(data: list) -> list` and `decompress_rle(rle: list) -> list` that perform the Run-Length Encoding compression and decompression respectively. - `compress_rle(data: list)`: Takes a list of integers and returns an RLE compressed list. - `decompress_rle(rle: list)`: Takes an RLE compressed list and returns the decompressed list of integers. Implementation * Your functions should: - Ensure the input list `data` contains integers. - For the `compress_rle` function: - Produce an RLE list where consecutive repeated values are stored as pairs (value and count). - For the `decompress_rle` function: - Reconstruct the original list from its RLE representation. Constraints - The input list can contain between 1 and 10^5 integers. - All integers are between -10^6 and 10^6. Input/Output Format - Input: - `compress_rle(data)` takes a list of integers. - `decompress_rle(rle)` takes a list of integers in the format [value1, count1, value2, count2, ..., valueN, countN]. - Output: - `compress_rle(data)` returns a list of integers in RLE format. - `decompress_rle(rle)` returns the decompressed list of integers. Example ```python def compress_rle(data: list) -> list: # Your implementation here def decompress_rle(rle: list) -> list: # Your implementation here # Example usage: print(compress_rle([1, 1, 1, 2, 2, 3, 3, 3, 3])) # Output: [1, 3, 2, 2, 3, 4] print(decompress_rle([1, 3, 2, 2, 3, 4])) # Output: [1, 1, 1, 2, 2, 3, 3, 3, 3] print(compress_rle([10, 10, -5, -5, -5, -5, 7, 7])) # Output: [10, 2, -5, 4, 7, 2] print(decompress_rle([10, 2, -5, 4, 7, 2])) # Output: [10, 10, -5, -5, -5, -5, 7, 7] ``` The submitted code will be evaluated for correctness, efficiency, and adherence to problem constraints.","solution":"def compress_rle(data: list) -> list: if not data: return [] compressed = [] count = 1 current = data[0] for i in range(1, len(data)): if data[i] == current: count += 1 else: compressed.append(current) compressed.append(count) current = data[i] count = 1 compressed.append(current) compressed.append(count) return compressed def decompress_rle(rle: list) -> list: if not rle or len(rle) % 2 != 0: return [] decompressed = [] for i in range(0, len(rle), 2): value = rle[i] count = rle[i+1] decompressed.extend([value] * count) return decompressed"},{"question":"# Scenario You are a software engineer tasked with processing log files generated by a web server. These log files contain timestamps indicating when a specific event happened, such as a user request. You need to write a function that calculates the total duration of time that server activity took place within a 24-hour period. Overlapping time intervals should only be counted once. # Coding Task Implement the function `server_activity_duration` as described below. The function will take a list of tuples where each tuple represents an interval of activity with two timestamps indicating the start and end of the interval. Function Signature ```python def server_activity_duration(intervals: List[Tuple[str, str]]) -> int: ``` Input Parameters * `intervals` (List[Tuple[str, str]]): A list of tuples, each containing two strings representing the start and end timestamps of server activity in \'HH:MM:SS\' format. Output * Returns an integer, the total duration of server activity in seconds within the 24-hour period. # Constraints * The interval timestamps are guaranteed to be within the same day and in proper \'HH:MM:SS\' format. * There are no invalid or overlapping intervals. * If two or more intervals overlap, the overlapping time should be counted only once. # Example Usage ```python >>> server_activity_duration([(\\"00:00:00\\", \\"01:00:00\\"), (\\"02:00:00\\", \\"03:00:00\\")]) 3600 + 3600 = 7200 >>> server_activity_duration([(\\"01:00:00\\", \\"02:00:00\\"), (\\"01:30:00\\", \\"02:30:00\\")]) 3600 + 1800 (overlap) = 5400 >>> server_activity_duration([(\\"23:00:00\\", \\"23:59:59\\"), (\\"00:00:00\\", \\"00:30:00\\")]) 3599 + 1800 = 5399 ``` # Performance Requirements * The function should handle lists with up to 1000 intervals efficiently. * Ensure that the function properly handles edge cases like intervals that start or end at exactly midnight.","solution":"from typing import List, Tuple from datetime import datetime def server_activity_duration(intervals: List[Tuple[str, str]]) -> int: def time_to_seconds(t: str) -> int: h, m, s = map(int, t.split(\':\')) return h * 3600 + m * 60 + s events = [] for start, end in intervals: events.append((time_to_seconds(start), \'start\')) events.append((time_to_seconds(end), \'end\')) events.sort() total_duration = 0 current_start = None active_intervals = 0 for time, event_type in events: if event_type == \'start\': if active_intervals == 0: current_start = time active_intervals += 1 else: active_intervals -= 1 if active_intervals == 0: total_duration += time - current_start return total_duration"},{"question":"# Question: Implement the A* Algorithm for Pathfinding Context You are developing a navigation system that needs to find the shortest path between two points on a grid. The grid has obstacles that cannot be crossed, and movement is allowed in four directions (up, down, left, right). The A* algorithm should be used due to its efficient handling of pathfinding in such scenarios. Task Write a function `a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]` that finds and returns the shortest path from the `start` position to the `goal` position using the A* algorithm. Grid Representation - `0` represents an empty cell that can be traversed. - `1` represents an obstacle that cannot be crossed. - `start` and `goal` are tuples representing the coordinates (row, column) of the respective positions on the grid. Function Signature ```python def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` # Implementation Instructions: 1. Use a heuristic function `h(node, goal)` that returns the Manhattan distance between a `node` and the `goal`. 2. Utilize the four possible movements: up, down, left, and right. 3. If no path exists from start to goal, return an empty list. Input - `grid`: A 2D list where each element is either 0 or 1. - `start`: A tuple (row, column) representing the starting position. - `goal`: A tuple (row, column) representing the target position. Output - Return a list of tuples where each tuple represents a cell (row, column) in the shortest path from `start` to `goal`, inclusive. - If no path exists, return an empty list. Constraints - The grid can be as large as `100x100`. - The `start` and `goal` will always be within the grid bounds and will not be obstacles. - There may be no valid path between `start` and `goal`. Example ```python grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (5, 4) print(a_star_search(grid, start, goal)) # Output: [(0, 0), (0, 1), (0, 2), (0, 3), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4)] ``` Note The provided function should implement the A* algorithm, accurately calculating the shortest path that navigates around obstacles to reach the goal efficiently. If there is no path, an empty list should be returned.","solution":"from typing import List, Tuple, Optional import heapq def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(node: Tuple[int, int]) -> List[Tuple[int, int]]: neighbors = [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for direction in directions: neighbor = (node[0] + direction[0], node[1] + direction[1]) if 0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0: neighbors.append(neighbor) return neighbors open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: _, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = g_score[current] + 1 if tentative_g_score < g_score.get(neighbor, float(\'inf\')): came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) if neighbor not in [i[1] for i in open_set]: heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Coding Task: Simulate a Virtual File System You are tasked to implement a Virtual File System (VFS) that allows users to carry out basic file and directory operations. Your VFS should support creating, reading, updating, and deleting files, as well as creating and deleting directories. # Objective Implement a class `VirtualFileSystem` to simulate file system operations. This class should maintain a directory structure and support various file operations. # Details Input * A sequence of commands to interact with the file system. Each command may include parameters like file paths or content. Output * The output varies based on the command: - For read operations, return the file\'s content. - For other operations, provide appropriate success or error messages. Commands and Their Functionalities 1. **Create File**: `create_file(path, content)` Creates a new file at the specified path with the given content. 2. **Read File**: `read_file(path)` Returns the content of the file at the specified path. 3. **Update File**: `update_file(path, content)` Updates the content of the file at the specified path. 4. **Delete File**: `delete_file(path)` Deletes the file at the specified path. 5. **Create Directory**: `create_directory(path)` Creates a new directory at the specified path. 6. **Delete Directory**: `delete_directory(path)` Deletes the directory at the specified path. # Example ```python vfs = VirtualFileSystem() vfs.create_directory(\'/documents\') vfs.create_file(\'/documents/notes.txt\', \'These are my notes.\') print(vfs.read_file(\'/documents/notes.txt\')) # Expected Output: \'These are my notes.\' vfs.update_file(\'/documents/notes.txt\', \'Updated notes.\') print(vfs.read_file(\'/documents/notes.txt\')) # Expected Output: \'Updated notes.\' vfs.delete_file(\'/documents/notes.txt\') print(vfs.read_file(\'/documents/notes.txt\')) # Expected Output: \'File not found\' ``` # Constraints * Directory and file paths should follow Unix-like structure (e.g., `/documents/notes.txt`). * Assume a maximum of 1,000 files and 1,000 directories can be created. * Each file\'s content will be a string with a maximum length of 10,000 characters. * Directory paths cannot contain files directly; a file must be created within a directory. # Notes * Your implementation should handle edge cases like reading a non-existent file or creating a file in a non-existent directory. * Use appropriate data structures to represent the file and directory hierarchy and ensure efficient operation handling. ```python class VirtualFileSystem: def __init__(self): # Initialize the root directory pass def create_file(self, path, content): # Implement file creation logic pass def read_file(self, path): # Implement file reading logic pass def update_file(self, path, content): # Implement file update logic pass def delete_file(self, path): # Implement file deletion logic pass def create_directory(self, path): # Implement directory creation logic pass def delete_directory(self, path): # Implement directory deletion logic pass # Additional methods as required to support the above functionality # Test cases to verify correctness of the implementation def test_virtual_file_system(): vfs = VirtualFileSystem() vfs.create_directory(\'/documents\') vfs.create_file(\'/documents/notes.txt\', \'These are my notes.\') assert vfs.read_file(\'/documents/notes.txt\') == \'These are my notes.\' vfs.update_file(\'/documents/notes.txt\', \'Updated notes.\') assert vfs.read_file(\'/documents/notes.txt\') == \'Updated notes.\' vfs.delete_file(\'/documents/notes.txt\') assert vfs.read_file(\'/documents/notes.txt\') == \'File not found\' # Ensure more comprehensive testing with additional edge cases # Challenge # Extend your implementation to support large depth directory operations efficiently. ```","solution":"class VirtualFileSystem: def __init__(self): self.root = {} def _traverse(self, path, create=False): parts = path.strip(\'/\').split(\'/\') current = self.root for part in parts[:-1]: if part not in current: if create: current[part] = {} else: return None, None current = current[part] return current, parts[-1] def create_file(self, path, content): directory, file_name = self._traverse(path, create=True) if directory is not None: directory[file_name] = content def read_file(self, path): directory, file_name = self._traverse(path) if directory is not None and file_name in directory: return directory[file_name] return \'File not found\' def update_file(self, path, content): directory, file_name = self._traverse(path) if directory is not None and file_name in directory: directory[file_name] = content def delete_file(self, path): directory, file_name = self._traverse(path) if directory is not None and file_name in directory: del directory[file_name] def create_directory(self, path): directory, dir_name = self._traverse(path, create=True) if directory is not None: if dir_name not in directory: directory[dir_name] = {} def delete_directory(self, path): directory, dir_name = self._traverse(path) if directory is not None and dir_name in directory: del directory[dir_name]"},{"question":"# Coding Assessment Question Context In the following task, you are required to implement a solution to encode and decode strings using a simple Caesar Cipher. A Caesar Cipher is one of the simplest known encryption techniques whereby each letter in the plaintext is shifted by a fixed number of positions down the alphabet. For example, with a shift of 3, `A` would be encoded as `D`, `B` as `E`, and so on. This technique is a basic exercise in understanding encoding and encryption mechanisms. Task You are required to implement the functions `caesar_encode` and `caesar_decode` as specified below: 1. **Function Name**: `caesar_encode` - **Input**: A `str` object (`text`) containing the plaintext to be encoded, and an `int` (`shift`) indicating the number of positions to shift each letter. - **Output**: A `str` object containing the encoded text using the Caesar Cipher. 2. **Function Name**: `caesar_decode` - **Input**: A `str` object (`text`) containing the encoded text to be decoded, and an `int` (`shift`) indicating the number of positions each letter was shifted during encoding. - **Output**: A `str` object containing the original plaintext. Constraints * Both functions should preserve the case of alphabetic characters. * Non-alphabetic characters should remain unchanged. * You are not allowed to use any external libraries for encoding or decoding. Examples ```python # Example for caesar_encode assert caesar_encode(\'Hello, World!\', 3) == \'Khoor, Zruog!\' assert caesar_encode(\'abcXYZ\', 2) == \'cdeZAB\' assert caesar_encode(\'Python 3.9\', 1) == \'Qzuipo 3.9\' # Example for caesar_decode assert caesar_decode(\'Khoor, Zruog!\', 3) == \'Hello, World!\' assert caesar_decode(\'cdeZAB\', 2) == \'abcXYZ\' assert caesar_decode(\'Qzuipo 3.9\', 1) == \'Python 3.9\' ``` Be sure to handle edge cases and validate the input appropriately. --- Implement the `caesar_encode` and `caesar_decode` functions to handle the requirements above.","solution":"def caesar_encode(text, shift): def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) else: return c return \'\'.join(shift_char(c, shift) for c in text) def caesar_decode(text, shift): return caesar_encode(text, -shift)"},{"question":"# Problem Statement Write a Python function `generate_multiples(n: int, m: int) -> List[int]` that generates a list of the first `n` multiples of a positive integer `m` in descending order. # Input * `n` (1 ≤ n ≤ 10^6): The number of multiples to generate. * `m` (1 ≤ m ≤ 10^6): The number whose multiples are to be generated. # Output * A list of integers containing the first `n` multiples of `m` in descending order. # Constraints * The function should be efficient in both time and space to handle the upper limits of `n` and `m`. # Example ```python >>> generate_multiples(5, 3) [15, 12, 9, 6, 3] >>> generate_multiples(3, 7) [21, 14, 7] >>> generate_multiples(4, 10) [40, 30, 20, 10] ``` # Notes * Ensure that your solution is optimized for large values of `n` and `m`. * Consider the descending order requirement while generating the multiples.","solution":"from typing import List def generate_multiples(n: int, m: int) -> List[int]: Generates a list of the first n multiples of m in descending order. :param n: The number of multiples to generate. :param m: The number whose multiples are to be generated. :return: A list of the first n multiples of m in descending order. return [m * i for i in range(n, 0, -1)]"},{"question":"# Predictive Text System using Trie and Autocomplete **Background**: A messaging app wants to implement a predictive text feature to enhance user experience. By using a trie data structure, the app can efficiently manage a dictionary of words and provide auto-completion suggestions as users type. **Objective**: Implement a trie data structure and build a function that suggests possible completions for a given query prefix. **Task**: 1. Implement the `insert_word` and `find_words_with_prefix` methods in the `Trie` class. 2. Write a function `autocomplete(dictionary: list[str], prefix: str) -> list[str]` that: - Accepts a list of words (dictionary) and a prefix string. - Returns a list of words from the dictionary that start with the given prefix. **Function Signature**: ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert_word(self, word: str) -> None: # Implement this method def find_words_with_prefix(self, prefix: str) -> list[str]: # Implement this method def autocomplete(dictionary: list[str], prefix: str) -> list[str]: ``` **Input**: - `dictionary`: A list of words representing the dictionary of the app. Example: `[\'hello\', \'help\', \'hero\', \'herald\', \'heat\', \'heavy\', \'height\']` - `prefix`: A string representing the current prefix being typed by the user. Example: `\'he\'` **Output**: - A list of words from the dictionary that start with the given prefix. Example: `[\'hello\', \'help\', \'hero\', \'herald\', \'heat\', \'heavy\', \'height\']` **Constraints**: - The number of words in the dictionary `n` is such that `1 <= n <= 10000`. - Each word in the dictionary and the prefix will only contain lowercase English letters. - The length of the prefix `p` is such that `0 <= p <= 100`. - The length of each word in the dictionary is such that `1 <= len(word) <= 100`. **Example**: ```python dictionary = [\'hello\', \'help\', \'hero\', \'herald\', \'heat\', \'heavy\', \'height\'] prefix = \'he\' result = autocomplete(dictionary, prefix) print(result) # Output: [\'hello\', \'help\', \'hero\', \'herald\', \'heat\', \'heavy\', \'height\'] ``` The `Trie` class with `insert_word` and `find_words_with_prefix` methods will facilitate the auto-completion suggestions based on the prefix provided by the user.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert_word(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def find_words_with_prefix(self, prefix: str) -> list[str]: def dfs(node, path): if node.is_end_of_word: words.append(\'\'.join(path)) for char, next_node in node.children.items(): dfs(next_node, path + [char]) current = self.root for char in prefix: if char not in current.children: return [] current = current.children[char] words = [] dfs(current, list(prefix)) return words def autocomplete(dictionary: list[str], prefix: str) -> list[str]: trie = Trie() for word in dictionary: trie.insert_word(word) return trie.find_words_with_prefix(prefix)"},{"question":"# BST Range Sum **Context**: You are tasked with upgrading a service that involves performing various range queries on large sets of data stored in a Binary Search Tree (BST). One common operation is calculating the sum of all nodes\' values within a given range `[low, high]`. **Task**: Implement the range sum query method for a BST. The method should calculate the sum of all nodes with values in the inclusive range `[low, high]`. **Instructions**: 1. Complete the `range_sum` method for the `BST` class. 2. Your method should efficiently traverse the BST to compute the sum. 3. Consider edge cases where the BST might be empty or where no nodes fall within the given range. **Input Format**: - An integer representing the lower bound of the range (low). - An integer representing the upper bound of the range (high). **Output Format**: - An integer representing the sum of all nodes\' values within the given range. **Constraints**: - The values of the nodes in the BST are distinct and non-negative. - `low` and `high` are non-negative integers with `low <= high`. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def range_sum(self, low, high): Calculate the sum of all nodes with values in the inclusive range [low, high]. :param low: Integer representing the lower bound of the range. :param high: Integer representing the upper bound of the range. :return: Integer sum of all nodes\' values within the range. # Write your code here ``` **Example**: ```python bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(18) print(bst.range_sum(7, 15)) # Output: 32 (7 + 10 + 15) print(bst.range_sum(6, 10)) # Output: 17 (7 + 10) print(bst.range_sum(1, 5)) # Output: 8 (3 + 5) ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def range_sum(self, low, high): Calculate the sum of all nodes with values in the inclusive range [low, high]. :param low: Integer representing the lower bound of the range. :param high: Integer representing the upper bound of the range. :return: Integer sum of all nodes\' values within the range. return self._range_sum_helper(self.root, low, high) def _range_sum_helper(self, node, low, high): if not node: return 0 # If current node\'s value is greater than high, we only need to consider the left subtree if node.val > high: return self._range_sum_helper(node.left, low, high) # If current node\'s value is less than low, we only need to consider the right subtree if node.val < low: return self._range_sum_helper(node.right, low, high) # If current node\'s value is within the range, consider both subtrees and include current node\'s value return (node.val + self._range_sum_helper(node.left, low, high) + self._range_sum_helper(node.right, low, high))"},{"question":"# Problem Statement You are tasked with implementing a function that efficiently determines the longest subsequence of unique items within a given string. This problem involves understanding and utilizing data structures effectively to track and manage subsequences. Function Description Implement the function `longest_unique_subsequence` which has the following signature: ```python def longest_unique_subsequence(s: str) -> str: :param s: a string containing alphanumeric characters :return: the longest subsequence of unique characters ``` Input - `s`: A string containing alphanumeric characters (`1 <= len(s) <= 10^5`). Output - Return the longest subsequence of unique characters found within the input string `s`. Constraints - The function should handle input strings efficiently even for the maximum length. - If there are multiple subsequences of the same maximum length, return the first one found. - The function should run within acceptable time limits. # Example ```python print(longest_unique_subsequence(\\"abcabcbb\\")) # Expected Output: \\"abc\\" print(longest_unique_subsequence(\\"bbbbb\\")) # Expected Output: \\"b\\" print(longest_unique_subsequence(\\"pwwkew\\")) # Expected Output: \\"wke\\" print(longest_unique_subsequence(\\"abcdef\\")) # Expected Output: \\"abcdef\\" ``` # Notes - A subsequence refers to any sequence of characters that appear consecutively in the string in the same order as they appear in the original string. - The solution should utilize appropriate data structures such as sets or maps for tracking unique characters efficiently. - Consider the optimal use of sliding window techniques or other algorithmic optimizations to meet performance requirements.","solution":"def longest_unique_subsequence(s: str) -> str: Returns the longest subsequence of unique characters found within the input string. start = 0 max_len = 0 max_subseq_start = 0 max_subseq_end = 0 char_map = {} for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end if end - start + 1 > max_len: max_len = end - start + 1 max_subseq_start = start max_subseq_end = end return s[max_subseq_start:max_subseq_end+1]"},{"question":"# Question: Implement a Simple Text Editor Class You are tasked with creating a simple text editor that can perform basic operations on a string. **Class Definition**: `TextEditor` **Methods**: 1. `append(text: str) -> None`: Appends a given string to the end of the current text. 2. `delete(k: int) -> None`: Deletes the last k characters of the current text. 3. `print_k(k: int) -> str`: Returns the k-th character of the current text (1-indexed). 4. `undo() -> None`: Undoes the last operation (either append or delete). **Input**: - Original text is an empty string upon instantiation. - The methods `append` and `delete` can be called multiple times. - The method `print_k` will be called with `k` being a valid position within the text. - `undo` will only be called when there has been a previous operation executed. **Output**: - The `print_k` method returns a single character string representing the k-th character in the current text. **Constraints**: - `1 <= len(text) <= 10^6` for append. - `0 <= k <= current length of text` for delete. - For print_k, `1 <= k <= current length of text`. # Example ```python editor = TextEditor() editor.append(\\"hello\\") editor.append(\\" world\\") print(editor.print_k(6)) # Output: \' \' editor.delete(6) print(editor.print_k(5)) # Output: \'o\' editor.undo() print(editor.print_k(6)) # Output: \' \' editor.undo() print(editor.print_k(5)) # Output: \'o\' ``` # Performance Requirements: - Each method should operate within an appropriate time complexity for efficient editing and retrieval given the input size constraints. Implement the `TextEditor` class ensuring to handle edge cases and maintain the correct sequence of operations with `undo`.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, text: str) -> None: self.history.append(self.text) self.text += text def delete(self, k: int) -> None: self.history.append(self.text) self.text = self.text[:-k] def print_k(self, k: int) -> str: if 1 <= k <= len(self.text): return self.text[k-1] else: raise ValueError(\\"Index out of bounds\\") def undo(self) -> None: if self.history: self.text = self.history.pop() else: raise RuntimeError(\\"No operations to undo\\")"},{"question":"# Coding Challenge # Problem Statement Given a list of integers, write a Python function called `duplicate_count` that returns the number of duplicate elements in the list. An element is considered a duplicate if it appears more than once in the list. # Input * A list of integers `nums`. # Output * An integer representing the number of unique integers that appear more than once in the list. # Constraints * The input list `nums` will have at least one integer. * The length of `nums` will be between 1 and 10^5. # Example ```python def duplicate_count(nums: List[int]) -> int: pass # Example usage: assert duplicate_count([1, 2, 3, 4, 5]) == 0 assert duplicate_count([1, 1, 2, 2, 3, 3, 4, 4, 5]) == 4 assert duplicate_count([10, 20, 10, 30, 30, 30]) == 2 ``` # Instructions * Implement the `duplicate_count` function. * Ensure the solution is efficient. * Consider edge cases such as lists with no duplicates and lists where all elements are duplicates. * Avoid using unnecessary space. # Performance considerations * Large inputs must be handled within a reasonable time frame. * Ensure the algorithm processes the input optimally. # Note * You can assume a suitable context for the problem, such as counting repeated inventory items or duplicated records for clarity.","solution":"from typing import List def duplicate_count(nums: List[int]) -> int: Returns the number of unique integers that appear more than once in the list. element_count = {} for num in nums: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 duplicate_count = 0 for count in element_count.values(): if count > 1: duplicate_count += 1 return duplicate_count"},{"question":"# Problem Statement You are tasked with writing a function that checks for prime numbers in a given range and returns them in descending order. A number is considered prime if it has exactly two distinct positive divisors: 1 and itself. Function Signature ```python def primes_in_range(lower_bound: int, upper_bound: int) -> list[int]: ``` Input 1. `lower_bound (int)`: The inclusive lower bound of the range to check for prime numbers. 2. `upper_bound (int)`: The inclusive upper bound of the range to check for prime numbers. Output * Returns a `list[int]` containing all the prime numbers within the specified range in descending order. If no primes are found, return an empty list. Constraints * Both `lower_bound` and `upper_bound` should be positive integers. * Ensure that `lower_bound` is less than or equal to `upper_bound`. Examples ```python >>> primes_in_range(10, 50) [47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11] >>> primes_in_range(50, 10) [] >>> primes_in_range(1, 10) [7, 5, 3, 2] >>> primes_in_range(20, 22) [] >>> primes_in_range(17, 17) [17] ``` Additional Requirements 1. Implement a helper function to determine the primality of a number. 2. Ensure efficient computations by optimizing the prime-checking logic. 3. Handle edge cases where the bounds might be the same, or there are no primes in the given range. # Solution ```python def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_in_range(lower_bound: int, upper_bound: int) -> list[int]: if lower_bound > upper_bound: return [] primes = [] for num in range(lower_bound, upper_bound + 1): if is_prime(num): primes.append(num) return primes[::-1] ```","solution":"def is_prime(n: int) -> bool: Determines if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_in_range(lower_bound: int, upper_bound: int) -> list[int]: Returns all prime numbers within the specified range in descending order. if lower_bound > upper_bound: return [] primes = [] for num in range(lower_bound, upper_bound + 1): if is_prime(num): primes.append(num) return primes[::-1]"},{"question":"# Working with CSV Data A researcher is analyzing environmental data that is stored in CSV files. Each CSV file has columns that include \\"Date\\", \\"Temperature\\", \\"Humidity\\", and \\"Wind Speed\\". The researcher requires a function that can read a CSV file, process the data, and output summary statistics. Task: Implement a function `summarize_weather_data(file_path: str) -> dict` that reads the weather data from the given CSV file and returns summary statistics for Temperature, Humidity, and Wind Speed. Requirements: 1. **Input:** `file_path` (string) - the path to the CSV file containing the weather data. 2. **Output:** A dictionary containing summary statistics: * \\"Temperature\\" (dict) - Contains \\"mean\\", \\"min\\", and \\"max\\" values for Temperature. * \\"Humidity\\" (dict) - Contains \\"mean\\", \\"min\\", and \\"max\\" values for Humidity. * \\"Wind Speed\\" (dict) - Contains \\"mean\\", \\"min\\", and \\"max\\" values for Wind Speed. 3. The function should handle the following edge cases: * The CSV file might be missing some columns. * There could be missing or non-numeric values in the columns. 4. Ensure the function reads and processes the CSV efficiently and accurately. Constraints: * The CSV file will have headers and the structure will be consistent, but some data may be missing or corrupted. * The summary statistics should be calculated only from the available data. Example: Assuming `weather_data.csv` contains the following: ``` \\"Date\\", \\"Temperature\\", \\"Humidity\\", \\"Wind Speed\\" \\"2021-01-01\\", \\"20.5\\", \\"65\\", \\"15\\" \\"2021-01-02\\", \\"22.0\\", \\"68\\", \\"20\\" \\"2021-01-03\\", \\"\\", \\"70\\", \\"18\\" ``` The function call `summarize_weather_data(\'weather_data.csv\')` should return: ```python { \\"Temperature\\": {\\"mean\\": 21.25, \\"min\\": 20.5, \\"max\\": 22.0}, \\"Humidity\\": {\\"mean\\": 67.67, \\"min\\": 65, \\"max\\": 70}, \\"Wind Speed\\": {\\"mean\\": 17.67, \\"min\\": 15, \\"max\\": 20} } ``` Note: Make sure to handle the missing and non-numeric values properly while calculating the summary statistics. Utilize libraries like `pandas` for data manipulation and ensuring efficient processing.","solution":"import pandas as pd def summarize_weather_data(file_path: str) -> dict: Reads the weather data from the given CSV file and returns summary statistics for Temperature, Humidity, and Wind Speed. # Read the CSV file try: data = pd.read_csv(file_path) except FileNotFoundError: raise FileNotFoundError(f\\"The file at path {file_path} does not exist.\\") # Function to compute summary statistics if values are present def compute_summary(column_name): if column_name in data: valid_data = pd.to_numeric(data[column_name], errors=\'coerce\').dropna() if not valid_data.empty: return { \\"mean\\": round(valid_data.mean(), 2), \\"min\\": round(valid_data.min(), 2), \\"max\\": round(valid_data.max(), 2) } return {\\"mean\\": None, \\"min\\": None, \\"max\\": None} # Compute the summaries summary_stats = { \\"Temperature\\": compute_summary(\\"Temperature\\"), \\"Humidity\\": compute_summary(\\"Humidity\\"), \\"Wind Speed\\": compute_summary(\\"Wind Speed\\") } return summary_stats"},{"question":"# Coding Assessment Question **Context**: A \\"run-length encoding\\" (RLE) is a very simple form of data compression in which runs of data (sequences in which an element appears consecutively) are stored as a single data value and the count of how many times it appears consecutively. For example, the input string \\"aaabbbccaaa\\" would be encoded as \\"a3b3c2a3\\". **Problem**: Implement the `run_length_encoding` function that compresses a given string using run-length encoding technique. **Function Signature**: ```python def run_length_encoding(s: str) -> str: ``` **Input**: * s: A string of characters where each character is an ASCII character and the length of the string is between 1 and 10^5. **Output**: * The function should return a new string representing the run-length encoded version of the input string. **Constraints**: * The input string will only contain printable ASCII characters. **Performance Requirements**: * The algorithm should execute with a linear time complexity of O(n). **Examples**: 1. `run_length_encoding(\\"aaabbbccaaa\\")` should return `\\"a3b3c2a3\\"` 2. `run_length_encoding(\\"abcd\\")` should return `\\"a1b1c1d1\\"` 3. `run_length_encoding(\\"wwwwaaadexxxxxx\\")` should return `\\"w4a3d1e1x6\\"` **Edge Cases**: 1. Handle a string with one character: `run_length_encoding(\\"a\\")` should return `\\"a1\\"`. 2. Handle a string where no characters are repeated: `run_length_encoding(\\"xyz\\")` should return `\\"x1y1z1\\"`. 3. Handle a string where all characters are the same: `run_length_encoding(\\"ttttt\\")` should return `\\"t5\\"`. 4. Handle a string with mixed characters: `run_length_encoding(\\"aabbc\\")` should return `\\"a2b2c1\\"`.","solution":"def run_length_encoding(s: str) -> str: Compresses the given string using run-length encoding. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 # Append the last run encoded_string.append(f\\"{current_char}{count}\\") return \'\'.join(encoded_string)"},{"question":"# Removing Minimum Digits You are given a numeric string representing a non-negative integer. Your task is to generate the smallest possible integer by removing a specific number of digits from the string. Function Specification: **Function Name**: `min_integer_by_removing_digits` **Parameters**: * `num_str` (str): A string of numeric characters representing a non-negative integer. * `k` (int): The number of digits to remove. **Returns**: * `str`: The smallest possible integer as a string after removing exactly `k` digits. Constraints: * `1 <= len(num_str) <= 100` * `0 <= k <= len(num_str)` * The input string may contain leading zeros. Examples: 1. **Input**: ```python num_str = \\"1432219\\" k = 3 ``` **Output**: `\\"1219\\"` **Explanation**: The smallest integer is achieved by removing 4, 3, and 2. 2. **Input**: ```python num_str = \\"10200\\" k = 1 ``` **Output**: `\\"200\\"` **Explanation**: The smallest integer is achieved by removing 1. 3. **Input**: ```python num_str = \\"10\\" k = 2 ``` **Output**: `\\"0\\"` **Explanation**: The smallest integer is achieved by removing both digits. Implement the function above to generate the smallest possible integer by removing the specified number of digits from the input string.","solution":"def min_integer_by_removing_digits(num_str, k): Returns the smallest possible integer by removing exactly k digits from num_str. stack = [] for digit in num_str: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If we still have k more digits to remove, remove them from the end stack = stack[:-k] if k else stack # Convert to string and remove leading zeros result = \'\'.join(stack).lstrip(\'0\') return result if result else \'0\'"},{"question":"# Objective Write a Python function `find_missing_number` that takes a list of unique integers from 1 to `n` inclusive, with one missing number, and returns the missing number. # Input - A list of unique integers `nums` of length `n-1`, where each integer is in the range `[1, n]`. # Output Format - An integer representing the missing number in the list. # Function Signature ```python def find_missing_number(nums: list[int]) -> int: pass ``` # Example ```python assert find_missing_number([1, 2, 4, 5, 6]) == 3 assert find_missing_number([2, 3, 4, 6, 1, 7, 8]) == 5 assert find_missing_number([1, 3]) == 2 assert find_missing_number([2, 1]) == 3 assert find_missing_number([1, 2, 3, 5]) == 4 ``` # Constraints - The list `nums` will have a length of `n-1` where `1 ≤ n ≤ 100,000`. - All integers in the range `[1, n]` are unique. - The integers `nums` will be in no particular order. # Notes - Aim for an efficient time and space complexity. - Consider mathematical or algorithmic methods to solve the problem efficiently. - Handle edge cases like smallest (`n = 2`) and largest inputs (`n = 100,000`).","solution":"def find_missing_number(nums): Given a list of unique integers from 1 to n inclusive with one missing number, returns the missing number. n = len(nums) + 1 total_sum = n * (n + 1) // 2 array_sum = sum(nums) return total_sum - array_sum"},{"question":"Credit Card Validator You are tasked with implementing a credit card number validator based on the Luhn algorithm. The Luhn algorithm is used to validate a variety of identification numbers, primarily credit card numbers. # Task: Part 1: Validation Function Implement a function `is_valid_credit_card(card_number)` that takes one argument: - `card_number` (string): A string of digits representing the credit card number to be validated. **Requirements**: - Return a boolean value indicating whether the credit card number is valid according to the Luhn algorithm. **Example**: ```python is_valid_credit_card(\\"4539578763621486\\") # Output: True is_valid_credit_card(\\"8273123273520569\\") # Output: False ``` Part 2: Formatting Function Implement a function `format_credit_card(card_number)` that takes one argument: - `card_number` (string): A string of digits representing the credit card number. **Requirements**: - Return the credit card number formatted in groups of four digits separated by spaces. If the number of digits is not a multiple of four, the last group will have fewer digits. **Example**: ```python format_credit_card(\\"4539578763621486\\") # Output: \\"4539 5787 6362 1486\\" format_credit_card(\\"827312327352056\\") # Output: \\"8273 1232 7352 056\\" ``` **Constraints**: - You may assume that the input string is non-empty and contains only digits. - Consider edge cases such as minimum or maximum length input. # Additional Information: - You may use additional helper functions if needed. - Ensure that your implementation is efficient in terms of both time and space complexity.","solution":"def is_valid_credit_card(card_number): Validate credit card number using the Luhn algorithm. Parameters: card_number (str): The credit card number as a string of digits. Returns: bool: True if the card number is valid, False otherwise. def digits_of(n): return [int(d) for d in str(n)] digits = digits_of(card_number) odd_digits = digits[-1::-2] even_digits = digits[-2::-2] checksum = sum(odd_digits) for d in even_digits: checksum += sum(digits_of(d*2)) return checksum % 10 == 0 def format_credit_card(card_number): Format credit card number into groups of four digits separated by spaces. Parameters: card_number (str): The credit card number as a string of digits. Returns: str: Formatted credit card number. return \' \'.join(card_number[i:i+4] for i in range(0, len(card_number), 4))"},{"question":"# Problem Statement You are tasked with implementing a matrix multiplication function that efficiently handles large, sparse matrices. Sparse matrices are those in which most of the elements are zero, and they are commonly represented in a compact form to save space. Your function should handle both dense and sparse matrices as input and produce a dense matrix as output. # Requirements Write a function `matrix_multiplication(matrix_a, matrix_b)` that multiplies two matrices and returns the result. The function should consider the efficiency gains when multiplying sparse input matrices. Function Signature ```python def matrix_multiplication(matrix_a, matrix_b): pass ``` Expected Input and Output - **Input**: - `matrix_a`: A list of lists representing matrix ( A ) where each inner list is a row of the matrix. - `matrix_b`: A list of lists representing matrix ( B ) where each inner list is a row of the matrix. - **Output**: - Returns the resulting matrix after multiplying ( A ) and ( B ) as a list of lists. Example ```python matrix_a = [ [1, 0, 0], [0, 2, 0], [0, 0, 3] ] matrix_b = [ [4, 5, 6], [7, 8, 9], [1, 2, 3] ] result = matrix_multiplication(matrix_a, matrix_b) print(result) # Output should be [ # [4, 5, 6], # [14, 16, 18], # [3, 6, 9] # ] ``` Constraints 1. Dimensions of `matrix_a` and `matrix_b` must be compatible for multiplication. If `matrix_a` is of size ( m times n ), then `matrix_b` must be of size ( n times p ). 2. `matrix_a` and `matrix_b` can be sparse or dense matrices. 3. Optimize for scenarios where the input matrices are very large and sparse. 4. ( 1 leq m, n, p leq 500 ). # Notes - Handle edge cases where matrices have a large number of zero elements to optimize the multiplication process. - Ensure your function correctly handles both sparse and dense matrices without significant performance degradation for large dense matrices. - Validate the input matrices to ensure they are of the correct dimensions for multiplication. - Utilize any data structures or algorithms that enhance the performance for sparse matrices.","solution":"def matrix_multiplication(matrix_a, matrix_b): Multiplies two matrices and returns the resulting matrix. if not matrix_a or not matrix_b: raise ValueError(\\"Input matrices cannot be empty.\\") m, n = len(matrix_a), len(matrix_a[0]) n_b, p = len(matrix_b), len(matrix_b[0]) if n != n_b: raise ValueError(\\"Number of columns of matrix_a must be equal to number of rows of matrix_b.\\") # Prepare the result matrix with zeros result = [[0] * p for _ in range(m)] # Sparse representation of matrix_a and matrix_b sparse_a = {} sparse_b = {} for i in range(m): for j in range(n): if matrix_a[i][j] != 0: if i not in sparse_a: sparse_a[i] = {} sparse_a[i][j] = matrix_a[i][j] for i in range(n): for j in range(p): if matrix_b[i][j] != 0: if i not in sparse_b: sparse_b[i] = {} sparse_b[i][j] = matrix_b[i][j] # Perform multiplication for i in sparse_a: for k in sparse_a[i]: if k in sparse_b: for j in sparse_b[k]: result[i][j] += sparse_a[i][k] * sparse_b[k][j] return result"},{"question":"# Problem Statement You are tasked with implementing a basic recommendation system for a streaming platform. The platform needs to recommend a list of shows to users based on their viewing history. Each user has a profile that contains the titles of the shows they have watched. # Task Write a Python function called `recommend_shows` that takes in the viewing history of multiple users and the list of all available shows. The function should recommend shows to a specified user based on what other users with similar tastes have watched. You can apply a simple collaborative filtering approach by finding users with overlapping viewing histories and recommending shows that the specific user has not watched yet. # Function Signature ```python def recommend_shows( user_history: dict, target_user: str, all_shows: list, num_recommendations: int = 5 ) -> list: pass ``` # Input * `user_history` (dict): A dictionary where the keys are user IDs (strings) and the values are lists of show titles (strings) watched by that user. * `target_user` (str): The ID of the user to whom you want to recommend shows. * `all_shows` (list): A list of all available shows (strings) on the streaming platform. * `num_recommendations` (int): The number of recommended shows to return. Default is 5. # Output * Returns a list of show titles recommended to the target user, based on their viewing history and similar users\' interests. If the target user has watched all available shows, return an empty list or fewer recommendations as available. # Constraints * The user IDs and show titles are strings. * There are multiple users with varying lengths of viewing histories. * `num_recommendations` is a positive integer. * If there are insufficient shows to recommend, return as many as possible. # Example ```python >>> user_history = { ... \'user1\': [\'showA\', \'showB\', \'showC\'], ... \'user2\': [\'showB\', \'showC\', \'showD\'], ... \'user3\': [\'showA\', \'showD\', \'showE\'], ... \'user4\': [\'showC\', \'showE\', \'showF\'] ... } >>> target_user = \'user1\' >>> all_shows = [\'showA\', \'showB\', \'showC\', \'showD\', \'showE\', \'showF\', \'showG\'] >>> recommend_shows(user_history, target_user, all_shows) [\'showD\', \'showE\', \'showF\', \'showG\'] ``` In this example, \'user1\' has already watched \'showA\', \'showB\', and \'showC\'. Based on other users\' histories, the system should recommend shows \'showD\', \'showE\', and \'showF\' that \'user1\' has not watched yet. \'showG\' is also included as it is an available show not watched by \'user1\'. You can assume that the function\'s results are not required to be in any specific order, but make sure to recommend the most relevant shows based on overlaps in viewing history first.","solution":"def recommend_shows( user_history: dict, target_user: str, all_shows: list, num_recommendations: int = 5 ) -> list: target_watched = set(user_history.get(target_user, [])) # Collect all shows watched by other users and calculate the similarity recommendations = set() for user, watched_shows in user_history.items(): if user != target_user: common_shows = target_watched & set(watched_shows) if common_shows: recommendations.update(watched_shows) # Remove shows that the target user has already watched recommendations.difference_update(target_watched) # Convert recommendations to list and limit to num_recommendations recommendations_list = list(recommendations) # If there are not enough unique show recommendations, add shows from all_shows additional_shows = [show for show in all_shows if show not in recommendations and show not in target_watched] recommendations_list += additional_shows recommendations_list = recommendations_list[:num_recommendations] return recommendations_list"},{"question":"# Problem Statement You are given two tables, `employees` and `departments`, in a SQL database. The `employees` table contains information about employees including their names, department ids, and salaries. The `departments` table contains department names and ids. Write a SQL query that returns the names of employees who have salaries higher than the average salary of their respective departments. # Input Schema - The `employees` table has the following columns: - `id`: integer, the unique identifier for each employee. - `name`: varchar, the name of the employee. - `department_id`: integer, the foreign key referencing `departments.id`. - `salary`: integer, the salary of the employee. - The `departments` table has the following columns: - `id`: integer, the unique identifier for each department. - `name`: varchar, the name of the department. # Output - The resulting query should return a list of employee names (with no duplicates) who earn more than the average salary of their department. # Example Consider the following data in the `employees` table: | id | name | department_id | salary | |----|----------|---------------|--------| | 1 | John Doe | 1 | 5000 | | 2 | Jane Roe | 1 | 7000 | | 3 | Alice | 2 | 6000 | | 4 | Bob | 2 | 3000 | | 5 | Charlie | 1 | 8000 | And the following data in the `departments` table: | id | name | |----|-----------------| | 1 | Engineering | | 2 | Human Resources | The resulting query should return: | name | |----------| | Jane Roe | | Charlie | # Note - Ensure that the employee names are unique in your results. - Assume that the data in the `salary` column is never null. ```sql SELECT e.name FROM employees e JOIN ( SELECT department_id, AVG(salary) as avg_salary FROM employees GROUP BY department_id ) AS avg_salaries ON e.department_id = avg_salaries.department_id WHERE e.salary > avg_salaries.avg_salary; ```","solution":"def get_high_earning_employees(): Returns a SQL query that retrieves the names of employees who have salaries higher than the average salary in their respective departments. query = SELECT e.name FROM employees e JOIN ( SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id ) AS avg_salaries ON e.department_id = avg_salaries.department_id WHERE e.salary > avg_salaries.avg_salary; return query"},{"question":"# String Rotation Check Scenario: Imagine you are working on a program that needs to determine if two strings are rotations of each other. String rotation is a concept where the characters of the string are cyclically shifted by any number of positions. For instance, `\\"waterbottle\\"` can be rotated to become `\\"erbottlewat\\"` or `\\"tlewaterbot\\"`, but not `\\"bottlerwater\\"` or `\\"erottlewtab\\"`. Task: Write a function `is_rotation(s1: str, s2: str) -> bool` that: 1. Checks if the second string (`s2`) is a rotation of the first string (`s1`). 2. Uses only one call to a method that checks for substrings (such as the `in` operator or the `str.find` method). Requirements: * The function must handle cases where the strings have different lengths effectively. * Avoid unnecessary checks and aim for optimal performance. Input: * `s1` (str): The original string. * `s2` (str): The string to check as a rotation of `s1`. Output: * A boolean value `True` if `s2` is a rotation of `s1`, otherwise `False`. Constraints: * Both `s1` and `s2` contain only lowercase Latin letters and have lengths up to 1000 characters. Example: ```python print(is_rotation(\\"waterbottle\\", \\"erbottlewat\\")) # Output: True print(is_rotation(\\"waterbottle\\", \\"bottlewater\\")) # Output: True print(is_rotation(\\"hello\\", \\"llohe\\")) # Output: True print(is_rotation(\\"hello\\", \\"lhelo\\")) # Output: False ``` The function `is_rotation(\\"waterbottle\\", \\"erbottlewat\\")` will return `True` because `\\"erbottlewat\\"` is a rotation of `\\"waterbottle\\"`. Similarly, `is_rotation(\\"hello\\", \\"lhelo\\")` will return `False`.","solution":"def is_rotation(s1: str, s2: str) -> bool: Checks if s2 is a rotation of s1. Args: s1 (str): The original string. s2 (str): The string to check as a rotation of s1. Returns: bool: True if s2 is a rotation of s1, False otherwise. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"# Scenario You are developing functionality for an e-commerce web application that offers dynamic pricing based on product demand. The application backend makes decisions on price adjustments following a specific algorithm. # Task Write a Python function, `update_product_prices()`, that adjusts the prices of products based on their demand scores. Products with high demand will have their prices increased, while those with lower demand will have their prices decreased. # Requirements 1. **Function Signature**: ```python def update_product_prices(products: list[dict[str, int | float]]) -> list[dict[str, int | float]]: ``` 2. **Input**: * `products`: A list of dictionaries where each dictionary represents a product with the following keys: - `id`: Unique identifier for the product (int) - `name`: The name of the product (str) - `price`: The current price of the product (float) - `demand`: The demand score for the product (int) 3. **Output**: * A list of dictionaries with the updated prices. Each dictionary should contain: - `id`: Unique identifier for the product (int) - `name`: The name of the product (str) - `price`: The updated price of the product (float) - `demand`: The demand score for the product (int) 4. **Constraints**: * Products with a demand score higher than 50 should have their prices increased by 10%. * Products with a demand score between 20 and 50 (inclusive) should have their prices remain unchanged. * Products with a demand score lower than 20 should have their prices decreased by 5%. * Ensure the price is rounded to two decimal places. # Example Given the following list of products: ```python products = [ {\'id\': 1, \'name\': \'Laptop\', \'price\': 1500.00, \'demand\': 55}, {\'id\': 2, \'name\': \'Smartphone\', \'price\': 800.00, \'demand\': 45}, {\'id\': 3, \'name\': \'Headphones\', \'price\': 200.00, \'demand\': 15} ] ``` The function should return: ```python [ {\'id\': 1, \'name\': \'Laptop\', \'price\': 1650.00, \'demand\': 55}, {\'id\': 2, \'name\': \'Smartphone\', \'price\': 800.00, \'demand\': 45}, {\'id\': 3, \'name\': \'Headphones\', \'price\': 190.00, \'demand\': 15} ] ``` # Additional Guidelines * Write a few test cases to validate your implementation. * Ensure your function is efficient and accounts for edge cases, such as empty product lists or products with the same demand scores. fuscation for robustness.","solution":"def update_product_prices(products: list[dict[str, int | float]]) -> list[dict[str, int | float]]: updated_products = [] for product in products: new_price = product[\'price\'] if product[\'demand\'] > 50: new_price *= 1.10 elif product[\'demand\'] < 20: new_price *= 0.95 new_price = round(new_price, 2) updated_product = { \'id\': product[\'id\'], \'name\': product[\'name\'], \'price\': new_price, \'demand\': product[\'demand\'] } updated_products.append(updated_product) return updated_products"},{"question":"**Context**: You are part of a team developing automated trading algorithms. Your task is to implement a trading bot that can predict the next day\'s price of a stock based on a series of historical prices using a simple moving average model. This will help the bot make buying or selling decisions. **Task**: Write the function `predict_next_price(prices, window_size)` which calculates the next day\'s predicted price using a simple moving average (SMA). **Input**: - `prices` (list[float]): A list of historical stock prices. - `window_size` (int): The number of days over which to calculate the moving average. **Output**: - The function should return a float representing the predicted next day\'s price. **Constraints**: - The length of the `prices` list is greater than or equal to the `window_size`. - The `window_size` is a positive integer. - The prices are non-negative floating-point numbers. **Performance Requirements**: - The function should perform efficiently even with a larger number of prices. ```python def predict_next_price(prices: list[float], window_size: int) -> float: # Implementation here ``` **Example**: ```python # Example usage: historical_prices = [100.5, 102.0, 99.5, 101.0, 98.5, 100.0] window_size = 3 predicted_price = predict_next_price(historical_prices, window_size) print(\\"Predicted next day\'s price:\\", predicted_price) # Output should be: # Predicted next day\'s price: 99.83333333333333 ``` # Function Explanation The `predict_next_price` function calculates the next day\'s price prediction using the average of the last `window_size` prices in the `prices` list. This is a common method in financial analysis to estimate future trends based on past data.","solution":"def predict_next_price(prices: list[float], window_size: int) -> float: Predicts the next day\'s price based on the simple moving average (SMA) of the last \'window_size\' prices. parameters: prices (list[float]): A list of historical stock prices. window_size (int): The number of days over which to calculate the moving average. Returns: float: The predicted next day\'s price. if window_size <= 0 or len(prices) < window_size: raise ValueError(\\"Window size must be positive and less than or equal to the length of the prices list.\\") sma = sum(prices[-window_size:]) / window_size return sma"},{"question":"# Percentage Increase Calculator You are tasked with developing a function to calculate the percentage increase or decrease between two numbers, given an old value and a new value. Function Signature ```python def calculate_percentage_change(old_value: float, new_value: float) -> float: ``` Input * `old_value` (float): The initial value before the change. Must be a non-negative number. * `new_value` (float): The value after the change. Must be a non-negative number. Output * The percentage change from the old value to the new value, rounded to two decimal places. Errors The function should raise a `ValueError` if: * Either `old_value` or `new_value` is not a non-negative number. Example Usage ```python >>> calculate_percentage_change(100, 150) 50.0 >>> calculate_percentage_change(80, 100) 25.0 >>> calculate_percentage_change(50, 25) -50.0 >>> calculate_percentage_change(200, 200) 0.0 >>> calculate_percentage_change(0, 50) ValueError: old_value cannot be zero for percentage calculation ``` Constraints * Ensure that `old_value` is not zero; if it is, the function should raise a ValueError, as percentage change with respect to zero is undefined. Notes * The percentage change is calculated using the formula: ```python ((new_value - old_value) / old_value) * 100 ``` * The result can be positive (indicating an increase) or negative (indicating a decrease). Make sure the function handles floating-point arithmetic correctly and returns a result rounded to two decimal places.","solution":"def calculate_percentage_change(old_value: float, new_value: float) -> float: Calculate the percentage increase or decrease from old_value to new_value. Parameters: old_value (float): The initial value before the change. Must be a non-negative number. new_value (float): The value after the change. Must be a non-negative number. Returns: float: The percentage change from the old value to the new value, rounded to two decimal places. Raises: ValueError: If either old_value or new_value is not a non-negative number or if old_value is zero. if old_value < 0 or new_value < 0: raise ValueError(\\"Values must be non-negative numbers.\\") if old_value == 0: raise ValueError(\\"old_value cannot be zero for percentage calculation\\") percentage_change = ((new_value - old_value) / old_value) * 100 return round(percentage_change, 2)"},{"question":"# Coding Assessment Question Context Sorting algorithms are fundamental to computer science, forming the backbone for various optimizations and efficiency improvements in coding tasks. Understanding and implementing these algorithms is essential for any developer. Task Implement a function `find_kth_largest(nums: List[int], k: int) -> int` that returns the k-th largest element in an unsorted array. Your solution must optimize the process to handle large arrays efficiently. Input and Output Formats: ```python def find_kth_largest(nums: List[int], k: int) -> int: pass # Example usage: print(find_kth_largest([3,2,1,5,6,4], 2)) # Output: 5 print(find_kth_largest([3,2,3,1,2,4,5,5,6], 4)) # Output: 4 ``` Constraints: * `1 <= k <= len(nums) <= 10^4` * `-10^4 <= nums[i] <= 10^4` Requirements: 1. **Efficient Selection:** Your implementation should leverage efficient selection algorithms such as Quickselect, to find the k-th largest element without fully sorting the array. 2. **Handling Duplicates:** Ensure the algorithm correctly accounts for duplicate elements in the array. 3. **Consider Edge Cases:** Manage edge cases, such as when the list length is 1 or when k equals the list length. Performance Goals: * Aim for an average-case O(n) time complexity for the selection algorithm, using partitioning techniques similar to Quickselect. * Minimize auxiliary space usage to ensure that the solution is space-efficient. Implement the `find_kth_largest` function, ensuring it adheres to the above specifications and performs optimally within the given constraints.","solution":"from typing import List import random def partition(nums, left, right, pivot_index): pivot_value = nums[pivot_index] # Move pivot to end nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left # Move all larger elements to the left for i in range(left, right): if nums[i] > nums[right]: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 # Move pivot to its final place nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def quickselect(nums, left, right, k): Returns the k-th largest element of list within left..right if left == right: # If the list contains only one element, return nums[left] # return that element # Select a random pivot_index pivot_index = random.randint(left, right) # Find the pivot position in a sorted list pivot_index = partition(nums, left, right, pivot_index) # The pivot is in its final sorted position if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(nums, left, pivot_index - 1, k) else: return quickselect(nums, pivot_index + 1, right, k) def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in an unsorted array. # Adjust k to be the index in zero-indexed format return quickselect(nums, 0, len(nums) - 1, k - 1)"},{"question":"# Question: Implementing a Fast Exponentiation Algorithm In computational problems, exponentiation operations can be expensive when dealing with large numbers. A well-known efficient method for exponentiation is known as **Exponentiation by Squaring**. It reduces the time complexity to O(log n) as opposed to the naive approach which is O(n). Task Write a function `fast_exponentiation(base, exp, mod)` that computes `(base ^ exp) % mod` using the Exponentiation by Squaring method. This method is particularly useful for large exponents and systems with limited computational resources. Function Signature ```python def fast_exponentiation(base: int, exp: int, mod: int) -> int: ``` Input - `base` (int): The base integer (1 <= base <= 10^9) - `exp` (int): The exponent (0 <= exp <= 10^9) - `mod` (int): The modulus (1 <= mod <= 10^9) Output - An integer representing `(base ^ exp) % mod`. Example ```python fast_exponentiation(2, 10, 1000) # Output: 24 fast_exponentiation(5, 3, 13) # Output: 8 ``` Performance Requirements Your implementation should efficiently handle the upper limits of `base`, `exp`, and `mod` within reasonable time and space constraints. Hint Consider using recursion or iteration to apply the Exponentiation by Squaring technique for optimizing the calculation. Note - Be mindful of edge cases such as `exp` being 0 or other potential pitfalls related to very large numbers.","solution":"def fast_exponentiation(base: int, exp: int, mod: int) -> int: def exp_by_squaring(x, y): if y == 0: return 1 elif y % 2 == 0: return exp_by_squaring((x * x) % mod, y // 2) else: return (x * exp_by_squaring((x * x) % mod, (y - 1) // 2)) % mod return exp_by_squaring(base, exp)"},{"question":"# Coding Assessment Question: Longest Common Subsequence in Strings Problem Statement You are given two strings `text1` and `text2`. Write a function `longest_common_subsequence` that computes the length of the longest common subsequence between the given two strings. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. Write a class `LongestCommonSubsequenceOptimizer` that includes the following methods: 1. `__init__()`: Initialization method. 2. `longest_common_subsequence(self, text1: str, text2: str) -> int`: This method calculates the length of the longest common subsequence between the given two strings. Requirements: - **Input Format**: - `text1`: The first input string (`str`). - `text2`: The second input string (`str`). - **Output Format**: - An integer representing the length of the longest common subsequence between the two strings (`int`). Constraints: - The lengths of `text1` and `text2` should be between `1` and `1000`. - The strings consist of only lower case English characters. # Scenario Consider the following scenario to ensure clarity of the problem: You are given the following two strings as examples: - `text1 = \\"abcde\\"` - `text2 = \\"ace\\"` Your function should return `3` for these inputs because the longest common subsequence is `\\"ace\\"`. You can use the following class definition to complete your solution: ```python class LongestCommonSubsequenceOptimizer: A LongestCommonSubsequenceOptimizer has methods to calculate the length of the longest common subsequence between two strings. def __init__(self) -> None: pass def longest_common_subsequence(self, text1: str, text2: str) -> int: # Your implementation here pass ``` Implementing this solution efficiently would involve careful consideration of dynamic programming techniques to manage the computational complexity. Additional helper methods may be used if necessary.","solution":"class LongestCommonSubsequenceOptimizer: A LongestCommonSubsequenceOptimizer has methods to calculate the length of the longest common subsequence between two strings. def __init__(self) -> None: pass def longest_common_subsequence(self, text1: str, text2: str) -> int: Calculates the length of the longest common subsequence between two strings. :param text1: The first input string. :param text2: The second input string. :return: The length of the longest common subsequence. m, n = len(text1), len(text2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence is in the bottom-right cell of the dp array. return dp[m][n]"},{"question":"# Scenario You are tasked with developing a simple recommendation system for an online bookstore. Your system will suggest books to users based on their past purchases using a collaborative filtering approach. The idea is to recommend books that other users with similar tastes have bought. # Task Implement a function that takes in the purchase data of users and returns a list of book recommendations for a specific user. You need to: 1. Parse the purchase data and identify users with similar purchase patterns. 2. Generate recommendations based on the books bought by similar users but not yet bought by the target user. 3. Sort and return the recommendations by the frequency of purchase within the similar users\' group. # Function Signature ```python def recommend_books(purchase_data: dict, target_user: str, num_recommendations: int) -> list: # Your implementation here ``` # Explanation 1. **purchase_data**: A dictionary where keys are usernames and values are lists of books that the user has purchased. 2. **target_user**: The username of the user for whom the recommendations are being generated. 3. **num_recommendations**: The number of book recommendations to return. # Constraints - Users who have not purchased any books should receive a default list of top-n trending books. - Books already purchased by the target user should not be recommended again. - If the target user has no similar users based on their purchase history, return the top-n most popular books overall in the store. # Example ```python # Purchase data purchase_data = { \\"Alice\\": [\\"Book1\\", \\"Book2\\", \\"Book3\\"], \\"Bob\\": [\\"Book2\\", \\"Book4\\"], \\"Charlie\\": [\\"Book1\\", \\"Book4\\", \\"Book5\\"], \\"Diana\\": [\\"Book1\\", \\"Book2\\", \\"Book4\\"] } # Recommendations for Alice, requesting 2 recommendations recommend_books(purchase_data, \\"Alice\\", 2) # Output: [\\"Book4\\", \\"Book5\\"] ``` # Notes - Consider implementing a similarity measure such as cosine similarity or Jaccard index to identify similar users. - Ensure that the recommendations are efficient and can handle large datasets. - Provide meaningful log messages for different stages of the recommendation process, including errors.","solution":"from collections import Counter from typing import List, Dict import numpy as np def jaccard_similarity(user_books1: List[str], user_books2: List[str]) -> float: set1, set2 = set(user_books1), set(user_books2) intersection = set1.intersection(set2) union = set1.union(set2) if not union: return 0.0 return len(intersection) / len(union) def recommend_books(purchase_data: Dict[str, List[str]], target_user: str, num_recommendations: int) -> List[str]: if target_user not in purchase_data or not purchase_data[target_user]: # Returning top-n overall books if target user has not purchased any books. all_purchased_books = [book for books in purchase_data.values() for book in books] most_common_books = [book for book, _ in Counter(all_purchased_books).most_common(num_recommendations)] return most_common_books target_books = set(purchase_data[target_user]) similarity_scores = [] for user, books in purchase_data.items(): if user != target_user: similarity = jaccard_similarity(target_books, books) similarity_scores.append((similarity, books)) # Sort users by similarity scores in descending order similarity_scores.sort(reverse=True, key=lambda x: x[0]) book_recommendations = Counter() for similarity, books in similarity_scores: for book in books: if book not in target_books: book_recommendations[book] += 1 # Get top-n recommendations based on frequency recommended_books = [book for book, _ in book_recommendations.most_common(num_recommendations)] if len(recommended_books) < num_recommendations: # Fill in with most common books if not enough recommendations all_purchased_books = [book for books in purchase_data.values() for book in books] most_common_books = [book for book, _ in Counter(all_purchased_books).most_common(num_recommendations)] recommended_books += [book for book in most_common_books if book not in recommended_books and book not in target_books] return recommended_books[:num_recommendations]"},{"question":"Dynamic Programming for Longest Common Subsequence Given two sequences `A` and `B`, you are to implement a function to find the longest common subsequence (LCS). LCS of two sequences is the longest subsequence that is found in both sequences in the same order. You need to implement: 1. **`longest_common_subsequence` method** which calculates the length of the longest common subsequence between two sequences `A` and `B`. 2. **`get_lcs_sequence` method** which returns the actual longest common subsequence. # Implementation Details: 1. **`longest_common_subsequence` method** should: - Accept two sequences `A` and `B`. - Use dynamic programming to compute the length of the LCS. 2. **`get_lcs_sequence` method** should: - Accept two sequences `A` and `B`. - Use the dynamic programming table constructed by `longest_common_subsequence` method to trace back and find the actual LCS. # Input/Output: - **Input**: - For `longest_common_subsequence` method: ```python def longest_common_subsequence(A, B): # A: First sequence (string or list of characters) # B: Second sequence (string or list of characters) ``` - For `get_lcs_sequence` method: ```python def get_lcs_sequence(A, B): # A: First sequence (string or list of characters) # B: Second sequence (string or list of characters) ``` - **Output**: - For `longest_common_subsequence` method: Return the length of the longest common subsequence. - For `get_lcs_sequence` method: Return the longest common subsequence as a string or list of characters. # Constraints: 1. Sequences `A` and `B` will have at most 1000 elements each. 2. Sequences should be non-empty. # Example Scenario: ```python A = \\"ABCBDAB\\" B = \\"BDCAB\\" # Compute LCS length lcs_length = longest_common_subsequence(A, B) print(f\\"LCS length: {lcs_length}\\") # Compute actual LCS lcs_sequence = get_lcs_sequence(A, B) print(f\\"LCS sequence: {lcs_sequence}\\") ``` # Expected Output: ``` LCS length: 4 LCS sequence: \\"BDAB\\" ``` # Notes: - Focus on the efficiency of the dynamic programming solution. - Ensure that the `get_lcs_sequence` method correctly traces back through the dynamic programming table to construct the LCS. - Pay attention to edge cases such as sequences with no common subsequence or completely identical sequences.","solution":"def longest_common_subsequence(A, B): m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def get_lcs_sequence(A, B): m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs = [] i, j = m, n while i > 0 and j > 0: if A[i - 1] == B[j - 1]: lcs.append(A[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 lcs.reverse() return \'\'.join(lcs)"},{"question":"# Binary Search Tree (BST) Range Query You are given a base implementation of a Binary Search Tree (BST), where each node contains an integer value and pointers to its left and right children. The BST maintains the property that for any given node, all values in its left subtree are less than the node\'s value, and all values in its right subtree are greater than the node\'s value. You must extend the functionality of the provided BST by implementing the following feature: 1. **Range Query**: Implement a function that finds and returns the sum of all values within a given range [low, high] (inclusive) in the BST. The function should take the root of the BST and the range boundaries as arguments. # Function Signature ```python def range_query(root: Node | None, low: int, high: int) -> int: pass ``` # Input/Output * `range_query(root: Node | None, low: int, high: int) -> int`: Returns the sum of all values within the range [low, high] in the BST. If the BST is empty, return `0`. # Constraints * Each node in the BST contains integer values only. * `low` and `high` are integer values where `low <= high`. # Examples ```python # Example BST creation root = None root = insert(root, 10) root = insert(root, 20) root = insert(root, 5) root = insert(root, 7) root = insert(root, 25) # Running range_query function assert range_query(root, 5, 20) == 42 # 5 + 7 + 10 + 20 assert range_query(root, 15, 25) == 45 # 20 + 25 assert range_query(root, 1, 5) == 5 # 5 assert range_query(root, 30, 40) == 0 # No values in the range ``` # Implementation Notes 1. **range_query**: Use an in-order traversal to visit each node and check if the node\'s value falls within the specified range [low, high]. If it does, add it to the running sum. 2. Optimize the function to skip entire subtrees that are out of the specified range to maintain efficiency. # Example BST Structure ``` 10 / 5 20 / 7 15 25 ``` - `range_query(root, 5, 20)` traverses nodes with values 5, 7, 10, 15, 20 and sums them to 42. - `range_query(root, 15, 25)` traverses nodes with values 20, 25 and sums them to 45. This question tests your understanding of tree traversal techniques and your ability to implement efficient range queries on a BST.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def insert(root, key): if root is None: return Node(key) if key < root.value: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def range_query(root: Node | None, low: int, high: int) -> int: if root is None: return 0 if root.value < low: return range_query(root.right, low, high) if root.value > high: return range_query(root.left, low, high) return (root.value + range_query(root.left, low, high) + range_query(root.right, low, high))"},{"question":"# **Question: Implement a Custom String Split Function** You are tasked with creating a function that splits a string into a list of substrings based on a given delimiter. Additionally, you need to implement an iterator class that iterates through these substrings. 1. **Custom Split Function**: Implement a function `custom_split(string, delimiter)` that splits the string using the provided delimiter and returns a list of substrings. 2. **Substring Iterator**: Implement an iterator class called `SubstringIterator` that takes the list of substrings from the `custom_split` function and iterates over them one by one. Constraints 1. `string` will not be an empty string. 2. `delimiter` will be a non-empty string and will be present in `string`. 3. The `substring` will not be an empty string. Input 1. For the function: - `string`: A string of characters. - `delimiter`: A string used as a delimiter to split the `string`. 2. For the iterator class: - `substrings`: A list of substrings obtained from splitting the original `string`. Output 1. For the function: - A list of substrings obtained by splitting the original `string` using the `delimiter`. 2. For the iterator class: - An iterator yielding substrings one by one. # Example 1. **Using the custom split function:** ```python string = \\"apple;banana;cherry;date\\" delimiter = \\";\\" output = custom_split(string, delimiter) print(output) # Output: [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] string = \\"dog:cat:mouse\\" delimiter = \\":\\" output = custom_split(string, delimiter) print(output) # Output: [\\"dog\\", \\"cat\\", \\"mouse\\"] ``` 2. **Using the iterator:** ```python substrings = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] iterator = SubstringIterator(substrings) print(list(iterator)) # Output: [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] substrings = [\\"dog\\", \\"cat\\", \\"mouse\\"] iterator = SubstringIterator(substrings) print(list(iterator)) # Output: [\\"dog\\", \\"cat\\", \\"mouse\\"] ``` # Requirements * Implement the `custom_split` function. * Implement the `SubstringIterator` class. * Ensure proper handling of edge cases. * Maintain efficient time and space complexity. --- This question requires you to: - Develop a custom string manipulation function. - Implement an iterator using the outcome of the above function. - Handle common edge cases (e.g., different delimiters). The difficulty and scope are consistent with the provided example, involving string manipulation and custom iterator implementation.","solution":"def custom_split(string, delimiter): Splits the input string based on the given delimiter and returns a list of substrings. return string.split(delimiter) class SubstringIterator: def __init__(self, substrings): self.substrings = substrings self.index = 0 def __iter__(self): return self def __next__(self): if self.index < len(self.substrings): result = self.substrings[self.index] self.index += 1 return result else: raise StopIteration"},{"question":"# Problem Description You are given a non-negative integer represented as a non-empty list of digits. Increment the integer by one and return the resulting list of digits. You may assume the integer does not contain any leading zero, except the number 0 itself. # Function Signature ```python def plus_one(digits: list[int]) -> list[int]: pass ``` # Input * `digits: list[int]` - A list of non-negative integers representing the digits of a number. (`1 <= len(digits) <= 1000`) # Output * Return a list of integers representing the digits of the number after adding one to it. # Constraints * All elements in `digits` are in the range `[0, 9]`. * The input list will not have leading zeroes except for the number `0` itself. # Example 1. `digits = [1, 2, 3]` returns `[1, 2, 4]`: * The number represented is `123`. Incrementing gives `124`. 2. `digits = [4, 3, 2, 1]` returns `[4, 3, 2, 2]`: * The number represented is `4321`. Incrementing gives `4322`. 3. `digits = [9, 9, 9]` returns `[1, 0, 0, 0]`: * The number represented is `999`. Incrementing gives `1000`. # Note You should handle cases where carrying over occurs, such as transitioning from `[9, 9, 9]` to `[1, 0, 0, 0]`.","solution":"def plus_one(digits: list[int]) -> list[int]: Function to add one to the number represented as a list of digits. n = len(digits) # Traverse the list starting from the last digit for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we\'re here, it means all the digits were 9 # Hence, we need an extra 1 at the beginning return [1] + [0] * n"},{"question":"# Question: Implement a Simple Chatbot You are tasked with creating the backend for a simple rule-based chatbot that can respond to a limited set of user inputs and carry a conversation. The chatbot should be able to handle three main types of queries: greetings, farewells, and a predefined set of questions. Function Specifications: * **Function Name**: `chatbot_response` * **Input**: - `message: str` - The user message to which the bot should respond. * **Output**: `str` - The chatbot\'s response. The chatbot should respond as follows: - For greetings such as \\"hi\\", \\"hello\\", and \\"hey\\", respond with \\"Hello! How can I help you today?\\" - For farewells like \\"bye\\", \\"goodbye\\", and \\"see you\\", respond with \\"Goodbye! Have a great day!\\" - For predefined questions such as \\"what is your name?\\" and \\"how are you?\\", respond with fixed answers like \\"I am a chatbot created by [Your Name].\\" and \\"I am just a bunch of code, but I\'m doing great!\\" - For any other query, respond with \\"I am sorry, I do not understand your question.\\" Make sure to handle edge cases like variations in letter casing (e.g., \\"Hi\\", \\"hELLo\\"). Constraints: - Use Python string methods to normalize user input (e.g., converting to lowercase) before matching it to predefined responses. - Ensure your function is efficient and cleanly handle input strings. ```python def chatbot_response(message): Generate a response from a simple rule-based chatbot. Args: message (str): The user message to which the bot should respond. Returns: str: The chatbot\'s response. # Normalize the user message norm_message = message.lower().strip() # Define possible responses greeting_responses = [\\"hello! how can i help you today?\\"] farewell_responses = [\\"goodbye! have a great day!\\"] known_responses = { \\"what is your name?\\": \\"I am a chatbot created by [Your Name].\\", \\"how are you?\\": \\"I am just a bunch of code, but I\'m doing great!\\" } # Determine response if norm_message in [\\"hi\\", \\"hello\\", \\"hey\\"]: return greeting_responses[0] elif norm_message in [\\"bye\\", \\"goodbye\\", \\"see you\\"]: return farewell_responses[0] elif norm_message in known_responses: return known_responses[norm_message] else: return \\"I am sorry, I do not understand your question.\\" # Example usage: # print(chatbot_response(\\"Hello\\")) # print(chatbot_response(\\"What is your name?\\")) # print(chatbot_response(\\"See you\\")) # print(chatbot_response(\\"How much do you charge?\\")) ```","solution":"def chatbot_response(message): Generate a response from a simple rule-based chatbot. Args: message (str): The user message to which the bot should respond. Returns: str: The chatbot\'s response. # Normalize the user message norm_message = message.lower().strip() # Define possible responses greeting_responses = {\\"hi\\", \\"hello\\", \\"hey\\"} farewell_responses = {\\"bye\\", \\"goodbye\\", \\"see you\\"} known_responses = { \\"what is your name?\\": \\"I am a chatbot created by [Your Name].\\", \\"how are you?\\": \\"I am just a bunch of code, but I\'m doing great!\\" } # Determine response if norm_message in greeting_responses: return \\"Hello! How can I help you today?\\" elif norm_message in farewell_responses: return \\"Goodbye! Have a great day!\\" elif norm_message in known_responses: return known_responses[norm_message] else: return \\"I am sorry, I do not understand your question.\\" # Example usage: # print(chatbot_response(\\"Hello\\")) # print(chatbot_response(\\"What is your name?\\")) # print(chatbot_response(\\"See you\\")) # print(chatbot_response(\\"How much do you charge?\\"))"},{"question":"# Task: Implement a Binary Search Tree Deletion Function Scenario You are given a basic implementation of a Binary Search Tree (BST) that supports insertion and in-order traversal. However, the tree lacks a function to delete a node. Your task is to extend this implementation by adding a delete function that correctly handles three cases: deleting a leaf node, deleting a node with one child, and deleting a node with two children. Requirements 1. **TreeNode Class**: Implement necessary methods in the `TreeNode` class to handle node deletions. ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key ``` 2. **Function Implementation**: Implement the function `delete_node(root, key)` that achieves the following: * Takes as input: - `root`: the root node of the Binary Search Tree (BST). - `key`: the value of the node to be deleted. * Returns: - The root node of the BST after the deletion. 3. **Deletion Logic**: * Find the node to be deleted. * Handle the following cases: - If the node is a leaf, remove it directly. - If the node has one child, replace the node with its child. - If the node has two children, find the in-order successor (smallest node in the right subtree), replace the node\'s value with the successor\'s value, and delete the in-order successor. Input and Output Format * **Input**: * `root`: TreeNode object, the root of a BST. * `key`: integer, value to be deleted from the BST. * **Output**: * TreeNode object, the root of the BST after the deletion operation. Constraints * The Binary Search Tree will not contain duplicate values. * TreeNode values and key are integers. * The node to be deleted will always be present in the tree. Example ```python # Example Tree # 50 # / # 30 70 # / / # 20 40 60 80 # Deleting a node with one child root = TreeNode(50) root.left = TreeNode(30) root.right = TreeNode(70) root.left.left = TreeNode(20) root.left.right = TreeNode(40) root.right.left = TreeNode(60) root.right.right = TreeNode(80) # delete 20 new_root = delete_node(root, 20) # Resulting Tree after deleting 20: # 50 # / # 30 70 # / # 40 60 80 ``` Ensure to implement the delete_node function and complete tree traversal to test your implementation.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def delete_node(root, key): if root is None: return root if key < root.val: root.left = delete_node(root.left, key) elif key > root.val: root.right = delete_node(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = min_value_node(root.right) root.val = temp.val root.right = delete_node(root.right, temp.val) return root def min_value_node(node): current = node while current.left is not None: current = current.left return current def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else []"},{"question":"# Problem Statement You have been asked to develop software for managing parking lot occupancy. Your task is to implement a system that tracks and identifies the available parking slots in a parking lot. Each slot is represented by a unique identifier (a string). The program should allow adding vehicles to parking slots, removing them, and checking for available slots. # Function Signatures ```python class ParkingLot: def __init__(self, slots: list): Args: slots: List of slot identifiers which are initially all available. pass def park_vehicle(self, slot: str) -> bool: Parks a vehicle in the given slot if it is available. Args: slot: Identifier of the slot to park the vehicle in. Returns: True if parking was successful, False if the slot is already occupied. pass def remove_vehicle(self, slot: str) -> bool: Removes a vehicle from the given slot. Args: slot: Identifier of the slot to remove the vehicle from. Returns: True if removal was successful, False if the slot was already empty. pass def get_available_slots(self) -> list: Returns a list of available slots. Returns: List of available slot identifiers. pass ``` # Input Format * `slots` (List of str): Initial identifiers of all parking slots. * `slot` (str): A specific slot identifier in `park_vehicle` and `remove_vehicle` methods. # Output Format * The `park_vehicle` method returns a boolean: `True` if the slot was successfully occupied, `False` if it was already occupied. * The `remove_vehicle` method returns a boolean: `True` if the slot was successfully freed, `False` if it was already empty. * The `get_available_slots` method returns a list of strings representing the identifiers of available slots. # Constraints * Slot identifiers are unique strings. * The `ParkingLot` will not have more than 1000 slots. * Valid actions for `park_vehicle` and `remove_vehicle` methods only include existing slot identifiers. # Examples ```python >>> parking_lot = ParkingLot(slots=[\\"A1\\", \\"A2\\", \\"B1\\", \\"B2\\", \\"C1\\"]) >>> parking_lot.park_vehicle(\\"A1\\") True >>> parking_lot.park_vehicle(\\"A1\\") False >>> parking_lot.remove_vehicle(\\"A1\\") True >>> parking_lot.remove_vehicle(\\"A1\\") False >>> parking_lot.get_available_slots() [\\"A1\\", \\"A2\\", \\"B1\\", \\"B2\\", \\"C1\\"] >>> parking_lot.park_vehicle(\\"B2\\") True >>> parking_lot.get_available_slots() [\\"A1\\", \\"A2\\", \\"B1\\", \\"C1\\"] ```","solution":"class ParkingLot: def __init__(self, slots: list): Initializes the parking lot with given slots, initially marking all as available. self.slots = {slot: None for slot in slots} def park_vehicle(self, slot: str) -> bool: Parks a vehicle in the given slot if it is available. Args: slot: Identifier of the slot to park the vehicle in. Returns: True if parking was successful, False if the slot is already occupied. if self.slots.get(slot) is None: self.slots[slot] = \'Occupied\' return True return False def remove_vehicle(self, slot: str) -> bool: Removes a vehicle from the given slot. Args: slot: Identifier of the slot to remove the vehicle from. Returns: True if removal was successful, False if the slot was already empty. if self.slots.get(slot) == \'Occupied\': self.slots[slot] = None return True return False def get_available_slots(self) -> list: Returns a list of available slots. Returns: List of available slot identifiers. return [slot for slot, status in self.slots.items() if status is None]"},{"question":"**Problem Statement:** A company is working on a project to optimize their internet routing algorithms. One part of the project involves determining the shortest path between different network nodes. However, before proceeding, they need to identify any pairs of nodes that are directly connected. You are given a task to check if a pair of nodes in a network is directly connected. The network is represented as an undirected graph using an adjacency list. **Write a function:** ```python def is_directly_connected(graph: dict, node1: int, node2: int) -> bool: Given an adjacency list representing an undirected graph and two nodes, determine whether the two nodes are directly connected. :param graph: A dictionary representing the adjacency list of the graph where keys are node labels and values are lists of directly connected nodes. :param node1: An integer representing the first node. :param node2: An integer representing the second node. :return: True if node1 and node2 are directly connected, False otherwise. Example: >>> graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2] } >>> is_directly_connected(graph, 1, 2) True >>> is_directly_connected(graph, 2, 3) False >>> is_directly_connected(graph, 3, 1) True >>> is_directly_connected(graph, 4, 1) False pass ``` # Input - A dictionary `graph` representing the adjacency list of an undirected graph where keys are integers representing nodes and values are lists of integers representing the nodes directly connected to the key node. - Two integers `node1` and `node2` representing the nodes to check for direct connection. # Output - A boolean value. Return `True` if the two nodes are directly connected, `False` otherwise. # Constraints - The graph will have no more than 1000 nodes. - The nodes will be labeled with integers from 1 to 1000. - The graph might be sparse, meaning not all nodes will have a direct connection. # Scenario This problem is designed to test your understanding of graph representations and fundamental graph traversal strategies. It challenges you to efficiently check for direct connections in potentially large but sparse graphs. Your solution should handle edge cases, including disconnected nodes and non-existing nodes gracefully. **Testing:** Ensure that your solution passes the given examples and consider additional edge cases, for instance: - A node connected to itself: `is_directly_connected({1: [1]}, 1, 1) -> True` - Checking non-existing nodes in the graph: `is_directly_connected({1: [2]}, 1, 3) -> False`","solution":"def is_directly_connected(graph: dict, node1: int, node2: int) -> bool: Given an adjacency list representing an undirected graph and two nodes, determine whether the two nodes are directly connected. :param graph: A dictionary representing the adjacency list of the graph where keys are node labels and values are lists of directly connected nodes. :param node1: An integer representing the first node. :param node2: An integer representing the second node. :return: True if node1 and node2 are directly connected, False otherwise. if node1 not in graph or node2 not in graph: return False return node2 in graph[node1]"},{"question":"# Programming Assessment Question Context Different sorting algorithms provide different levels of efficiency based on the input data characteristics. Merge Sort is a popular sorting algorithm due to its efficiency and predictable performance. In this task, you will implement the Merge Sort algorithm and analyze its performance on various arrays. Task **Objective:** Write a function to perform the Merge Sort algorithm on a given list of integers. # Requirements * **Function Signature**: ```python def merge_sort(arr: list) -> list: ``` * **Inputs**: - `arr`: A list of integers that needs to be sorted. * **Output**: - Returns a new list of integers sorted in ascending order. # Constraints * The list can be of any length, including 0. * You cannot use built-in sort functions. * The algorithm should have a time complexity of O(n log n). # Example Scenarios 1. **Example 1**: ```python merge_sort([4, 3, 1, 5, 2]) # Returns: [1, 2, 3, 4, 5] ``` (Explanation: The array is sorted in ascending order using the Merge Sort algorithm.) 2. **Example 2**: ```python merge_sort([10, -1, 0, 5, 3, 8]) # Returns: [-1, 0, 3, 5, 8, 10] ``` (Explanation: Both positive and negative integers are sorted correctly.) 3. **Example 3**: ```python merge_sort([]) # Returns: [] ``` (Explanation: An empty list remains empty as there are no elements to sort.) # Additional Requirements * The implementation should split the array into halves recursively until each sub-array has one element, and then merge the sorted sub-arrays to produce the sorted list. * Ensure that the implementation correctly handles base cases such as an empty list and already sorted lists. * To demonstrate your understanding of the algorithm, include comments within your code explaining each significant step, especially the recursive division and the merging process. # Solution Template Here\'s a template to help you get started: ```python def merge_sort(arr): if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) ``` # Explanation - **Base Case:** If the array length is 1 or less, return the array (it is already sorted). - **Merge Function:** This function takes two sorted sub-arrays (`left` and `right`) and merges them into a single sorted array. - **Recursive Steps:** Split the array into `left` and `right` half, recursively sort each half, and then merge them back together. Please verify your solution against the provided example scenarios to ensure correctness.","solution":"def merge_sort(arr): # Function to perform merge sort on the input list if len(arr) <= 1: return arr def merge(left, right): # Helper function that merges two sorted lists into a single sorted list result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) # Append the remaining elements of left, if any result.extend(right[j:]) # Append the remaining elements of right, if any return result mid = len(arr) // 2 left = merge_sort(arr[:mid]) # Recursively sort the first half right = merge_sort(arr[mid:]) # Recursively sort the second half return merge(left, right) # Merge the two sorted halves"},{"question":"# Problem Statement You are tasked with creating a program to manage a small bookstore inventory. The program will maintain and update a catalog of books, facilitating searches and displaying book information based on user queries. # Requirements 1. Implement a class `BookCatalog` with the following methods: - `add_book(isbn: str, title: str, author: str, year: int, price: float) -> None`: Adds a new book to the catalog. - `remove_book(isbn: str) -> bool`: Removes a book with the given ISBN from the catalog. Returns `True` if the book was successfully removed, or `False` if the book does not exist. - `search_by_title(title: str) -> list`: Returns a list of books that contain the given title (case-insensitive) as a substring. - `search_by_author(author: str) -> list`: Returns a list of books written by the given author (case-insensitive). - `get_book_details(isbn: str) -> dict`: Returns a dictionary with details of the book identified by the given ISBN. # Input/Output - Methods `add_book` and `remove_book` do not return any output. - Method `search_by_title` returns a list of book dictionaries. - Method `search_by_author` returns a list of book dictionaries. - Method `get_book_details` returns a dictionary with book details: ```python { \\"isbn\\": \\"value\\", \\"title\\": \\"value\\", \\"author\\": \\"value\\", \\"year\\": int, \\"price\\": float } ``` # Constraints - ISBNs will be unique for each book. - Books can be searched and removed even if the title, author, and ISBN have mixed cases. - The year should be a positive integer, and the price should be a positive float. - Ensure proper error handling for invalid ISBNs (e.g., when removing or fetching details of a book that doesn\'t exist). # Example ```python catalog = BookCatalog() catalog.add_book(\\"978-3-16-148410-0\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925, 10.99) catalog.add_book(\\"978-1-45-162665-0\\", \\"Steve Jobs\\", \\"Walter Isaacson\\", 2011, 15.95) details = catalog.get_book_details(\\"978-3-16-148410-0\\") print(details) # Expected Output # { # \\"isbn\\": \\"978-3-16-148410-0\\", # \\"title\\": \\"The Great Gatsby\\", # \\"author\\": \\"F. Scott Fitzgerald\\", # \\"year\\": 1925, # \\"price\\": 10.99 # } search_results = catalog.search_by_author(\\"walter isaacson\\") print(search_results) # Expected Output # [ # { # \\"isbn\\": \\"978-1-45-162665-0\\", # \\"title\\": \\"Steve Jobs\\", # \\"author\\": \\"Walter Isaacson\\", # \\"year\\": 2011, # \\"price\\": 15.95 # } # ] ``` # Class Definition ```python class BookCatalog: def __init__(self): # Initialize the book catalog pass def add_book(self, isbn: str, title: str, author: str, year: int, price: float) -> None: # Your implementation here pass def remove_book(self, isbn: str) -> bool: # Your implementation here pass def search_by_title(self, title: str) -> list: # Your implementation here pass def search_by_author(self, author: str) -> list: # Your implementation here pass def get_book_details(self, isbn: str) -> dict: # Your implementation here pass ```","solution":"class BookCatalog: def __init__(self): self.catalog = {} def add_book(self, isbn: str, title: str, author: str, year: int, price: float) -> None: book_details = { \\"isbn\\": isbn, \\"title\\": title, \\"author\\": author, \\"year\\": year, \\"price\\": price } self.catalog[isbn] = book_details def remove_book(self, isbn: str) -> bool: if isbn in self.catalog: del self.catalog[isbn] return True return False def search_by_title(self, title: str) -> list: title_lower = title.lower() return [book for book in self.catalog.values() if title_lower in book[\\"title\\"].lower()] def search_by_author(self, author: str) -> list: author_lower = author.lower() return [book for book in self.catalog.values() if author_lower in book[\\"author\\"].lower()] def get_book_details(self, isbn: str) -> dict: return self.catalog.get(isbn, {})"},{"question":"# Sum of Subarray Minimums As a software engineer, you have been tasked with analyzing chunks of data across various intervals. Specifically, you need to calculate the sum of minimum values of all subarrays for a given array. This is a common problem in data processing and optimization algorithms. Function Signature ```python def sum_subarray_mins(arr: List[int]) -> int: pass ``` Input * A list of integers `arr` where `1 <= len(arr) <= 30000` and `1 <= arr[i] <= 30000`. Output * Returns an integer representing the sum of the minimum values of all subarrays of the input list. Example ```python assert sum_subarray_mins([3, 1, 2, 4]) == 17 assert sum_subarray_mins([11, 81, 94, 43, 3]) == 444 ``` # Constraints * The solution should be optimized to handle large inputs efficiently. * Consider using stack-based approaches or other efficient algorithms to achieve optimal performance. # Notes 1. A subarray is a contiguous part of an array. 2. Use modular arithmetic to prevent overflow, if necessary. 3. Consider performance trade-offs and ensure the function can handle the maximum constraints in a reasonable time. 4. This problem involves understanding data structures such as arrays and stacks, and concepts like subarrays and modular arithmetic.","solution":"from typing import List def sum_subarray_mins(arr: List[int]) -> int: MOD = 10**9 + 7 n = len(arr) left = [0] * n right = [0] * n stack = [] # Previous Less Element for i in range(n): count = 1 while stack and stack[-1][0] > arr[i]: count += stack.pop()[1] left[i] = count stack.append((arr[i], count)) stack = [] # Next Less Element for i in range(n-1, -1, -1): count = 1 while stack and stack[-1][0] >= arr[i]: count += stack.pop()[1] right[i] = count stack.append((arr[i], count)) # Calculating the result result = 0 for i in range(n): result = (result + arr[i] * left[i] * right[i]) % MOD return result"},{"question":"# Binary Tree Level Order Traversal Problem Statement: You are required to write a program that performs a level order traversal on a binary tree. The level order traversal involves visiting each node of the tree level by level from left to right. Your task includes implementing this traversal both with and without a queue data structure to understand the different methods of traversal. Requirements: 1. Implement a basic function `level_order_traversal_queue(root: TreeNode) -> List[List[int]]` that performs level order traversal using a queue. 2. Implement an alternate function `level_order_traversal_dfs(root: TreeNode) -> List[List[int]]` that performs level order traversal using depth-first search (DFS) by maintaining depth levels. Function Signatures: ```python from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal_queue(root: Optional[TreeNode]) -> List[List[int]]: pass def level_order_traversal_dfs(root: Optional[TreeNode]) -> List[List[int]]: pass ``` Constraints: * The binary tree node values will be in the range of -1000 ≤ Node.val ≤ 1000. * The number of nodes in the tree will be in the range 0 ≤ Number of Nodes ≤ 10^4. * If the tree is empty, return an empty list. Example: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) # Using Queue based implementation assert level_order_traversal_queue(root) == [[1], [2, 3], [4, 5, 6, 7]] # Using DFS based implementation assert level_order_traversal_dfs(root) == [[1], [2, 3], [4, 5, 6, 7]] ``` Performance Requirements: * Both functions should complete in a time complexity of O(n), where n is the number of nodes in the binary tree. * Space complexity for `level_order_traversal_queue` should be O(n) due to the usage of a queue. * Space complexity for `level_order_traversal_dfs` should be O(h) where h is the height of the tree due to recursion stack space.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal_queue(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for i in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result def level_order_traversal_dfs(root: Optional[TreeNode]) -> List[List[int]]: result = [] def dfs(node, depth): if node: if len(result) <= depth: result.append([]) result[depth].append(node.val) dfs(node.left, depth + 1) dfs(node.right, depth + 1) dfs(root, 0) return result"},{"question":"# Weighted Graph Shortest Path Challenge # Background: In graph theory, the shortest path problem is the problem of finding a path between two vertices (or nodes) such that the sum of the weights of its constituent edges is minimized. This problem has numerous practical applications, such as in network routing and urban planning. # Your Task: Implement the `dijkstra_shortest_path` function to find the shortest path between two nodes in a weighted graph using Dijkstra\'s algorithm. # Function Signature: ```python def dijkstra_shortest_path( graph: dict[int, list[tuple[int, int]]], start_node: int, end_node: int ) -> tuple[int, list[int]]: ``` # Input: 1. **graph (dict[int, list[tuple[int, int]]])**: A weighted graph represented as an adjacency list where the key is the node, and the value is a list of tuples, each containing a neighboring node and the edge\'s weight. Example: `{0: [(1, 4), (2, 1)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: []}` 2. **start_node (int)**: The start node for the path. 3. **end_node (int)**: The target node for the path. # Output: - **shortest_path_weight (int)**: The total weight of the shortest path from `start_node` to `end_node`. - **shortest_path (list[int])**: The nodes in the shortest path from `start_node` to `end_node` in sequential order. # Constraints: - The graph will contain at most 1000 nodes and 5000 edges. - All edge weights are non-negative integers. - The start and end nodes will always be valid and present in the graph. - There will always be at least one path from `start_node` to `end_node`. # Requirements: 1. Ensure that the algorithm efficiently finds the shortest path using Dijkstra\'s algorithm. 2. Handle cases where multiple shortest paths exist by returning any one of them. 3. Consider edge cases such as disconnected graphs, cycles, and large graphs. 4. Optimize the algorithm to handle the constraints effectively. # Example: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: [] } start_node = 0 end_node = 3 shortest_path_weight, shortest_path = dijkstra_shortest_path(graph, start_node, end_node) print(\\"Shortest Path Weight:\\", shortest_path_weight) print(\\"Shortest Path:\\", shortest_path) ``` ```python # Shortest Path Weight: 2 # Shortest Path: [0, 2, 3] ``` # Additional Task: Write automated tests to validate your `dijkstra_shortest_path` implementation against known shortest paths using different graph configurations.","solution":"import heapq def dijkstra_shortest_path(graph, start_node, end_node): Finds the shortest path between start_node and end_node in a weighted graph using Dijkstra\'s algorithm. Parameters: graph (dict[int, list[tuple[int, int]]]): A weighted graph represented as an adjacency list. start_node (int): The start node for the path. end_node (int): The target node for the path. Returns: tuple[int, list[int]]: The total weight of the shortest path and the nodes in the shortest path from start_node to end_node. # Initialize distance to all nodes as infinity and distance to start_node as 0 distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Priority queue for maintaining nodes to explore priority_queue = [(0, start_node)] # Dictionary to keep track of the shortest path previous_nodes = {node: None for node in graph} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reach the end_node, reconstruct and return the path if current_node == end_node: path = [] while previous_nodes[current_node] is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] path.insert(0, start_node) return current_distance, path if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # If there is no path from start_node to end_node return float(\'inf\'), [] # Example usage graph_example = { 0: [(1, 4), (2, 1)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: [] } start_node_example = 0 end_node_example = 3 shortest_path_weight, shortest_path = dijkstra_shortest_path(graph_example, start_node_example, end_node_example) print(\\"Shortest Path Weight:\\", shortest_path_weight) print(\\"Shortest Path:\\", shortest_path)"},{"question":"# Simulated Annealing for N-Queens Problem The N-Queens problem is a classic computer science problem where the objective is to place `N` queens on an `N x N` chessboard such that no two queens attack each other. Queens can attack each other if they are on the same row, column, or diagonal. Write a Python class that uses the Simulated Annealing algorithm to solve the N-Queens problem. Simulated Annealing is a probabilistic technique for approximating the global optimum of a given function. It aims to find a good solution by probabilistically allowing less optimal moves initially and then gradually reducing the likelihood of accepting those moves as the search continues. # Class Specifications **Class `NQueensSolver`** **Method 1: `__init__`** ```python def __init__(self, N: int, initial_temp: float, cooling_rate: float) -> None: pass ``` * **Parameters**: * `N` - An integer representing the size of the board (and the number of queens). * `initial_temp` - A float indicating the starting temperature of the algorithm. * `cooling_rate` - A float representing the rate at which the temperature decreases. * **Description**: Initializes the board with `N` queens placed randomly. **Method 2: `solve`** ```python def solve(self) -> List[int]: pass ``` * **Output**: A list representing the row positions of queens in each column if a solution is found. * **Description**: Uses the Simulated Annealing algorithm to find a valid solution for the N-Queens problem. * **Constraints**: The algorithm should run until a valid solution is found or the temperature reaches near zero. **Method 3: `is_valid`** ```python def is_valid(self, board: List[int]) -> bool: pass ``` * **Parameters**: * `board` - A list of integers where the index represents the column and the value at each index represents the row of the queen. * **Output**: A boolean indicating whether the board configuration is valid (i.e., no two queens attack each other). * **Description**: Checks the board for validity according to N-Queens rules. # Example Usage ```python solver = NQueensSolver(N=8, initial_temp=100, cooling_rate=0.99) solution = solver.solve() if solution: print(\\"Solution found:\\", solution) else: print(\\"No solution found.\\") ``` # Additional Constraints 1. The algorithm should be efficient in terms of time and space complexity. 2. The solution should handle cases where N is a large value, up to at least 1000. Implement the `NQueensSolver` class, ensuring that the `solve` method effectively finds a solution using the Simulated Annealing approach while maintaining the simplicity and efficiency of the algorithm.","solution":"import random import math from typing import List class NQueensSolver: def __init__(self, N: int, initial_temp: float, cooling_rate: float) -> None: self.N = N self.temperature = initial_temp self.cooling_rate = cooling_rate self.board = list(range(N)) random.shuffle(self.board) def is_valid(self, board: List[int]) -> bool: for col1 in range(len(board)): for col2 in range(col1 + 1, len(board)): row1, row2 = board[col1], board[col2] if row1 == row2 or abs(row1 - row2) == abs(col1 - col2): return False return True def _calculate_cost(self, board: List[int]) -> int: attacks = 0 for col1 in range(self.N): for col2 in range(col1 + 1, self.N): row1, row2 = board[col1], board[col2] if row1 == row2 or abs(row1 - row2) == abs(col1 - col2): attacks += 1 return attacks def solve(self) -> List[int]: current_board = self.board[:] current_cost = self._calculate_cost(current_board) while self.temperature > 1e-8 and current_cost > 0: next_board = current_board[:] col1, col2 = random.sample(range(self.N), 2) next_board[col1], next_board[col2] = next_board[col2], next_board[col1] next_cost = self._calculate_cost(next_board) delta_cost = next_cost - current_cost if delta_cost < 0 or random.uniform(0, 1) < math.exp(-delta_cost / self.temperature): current_board = next_board current_cost = next_cost self.temperature *= self.cooling_rate return current_board if current_cost == 0 else [] # Example usage: if __name__ == \\"__main__\\": solver = NQueensSolver(N=8, initial_temp=100, cooling_rate=0.99) solution = solver.solve() if solution: print(\\"Solution found:\\", solution) else: print(\\"No solution found.\\")"},{"question":"# Quickselect Algorithm Implementation **Context**: The Quickselect algorithm is a selection algorithm to find the ( k )th smallest element in an unordered list. It is related to the QuickSort sorting algorithm. The main advantage of Quickselect is its average-case linear time complexity, making it efficient for selecting elements in large datasets. # Task Write a Python function `quickselect(arr: list[int], k: int) -> int` that implements the Quickselect algorithm to find the ( k )th smallest element in the array. # Input * A list of integers `arr` with ( 1 leq text{len(arr)} leq 10^5 ). * An integer `k` where ( 1 leq k leq text{len(arr)} ). # Output * An integer which is the ( k )th smallest element in the array. # Example ```python >>> quickselect([3, 2, 1, 5, 4], 1) 1 >>> quickselect([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 3 >>> quickselect([8, 16, 10, 2, 20, 7, 25, 4], 6) 16 ``` # Constraints * Ensure that the algorithm handles duplicate elements correctly. * Consider edge cases such as the smallest and largest values of ( k ). # Solution Template ```python def quickselect(arr: list[int], k: int) -> int: def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): if left == right: return arr[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1) # Example usage print(quickselect([3, 2, 1, 5, 4], 1)) # Should output 1 ``` **Note**: Ensure that your implementation efficiently handles large inputs and maintains an average-case time complexity of O(n).","solution":"def quickselect(arr: list[int], k: int) -> int: Quickselect algorithm to find the k-th smallest element in an unordered list. Args: arr (list[int]): List of integers. k (int): 1-based index of the k-th smallest element. Returns: int: The k-th smallest element in the list. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): if left == right: return arr[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"# Coding Assessment Question: Dynamic Circular Buffer **Context**: A circular buffer, also known as a ring buffer, is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure is useful for buffering data streams. **Objective**: Create a dynamic circular buffer that can expand its capacity when it becomes full. When the buffer is full and an attempt is made to write new data, the buffer should double its current capacity and correctly adjust the pointers for the next write operation. **Function Signature**: ```python class DynamicCircularBuffer: def __init__(self, initial_capacity: int) -> None: Initializes the circular buffer with a given initial capacity. pass def read(self) -> int: Reads and removes the oldest data from the buffer. Returns the data item that was read. If the buffer is empty, raises an exception. pass def write(self, data: int) -> None: Writes data to the buffer. Expands the buffer if it becomes full. pass def size(self) -> int: Returns the number of elements currently in the buffer. pass def capacity(self) -> int: Returns the current capacity of the buffer. pass ``` **Expected Input/Output**: * Initialization: `initial_capacity` specifies the initial capacity of the circular buffer. * `read()`: Returns the oldest element in the buffer and removes it. * `write(data)`: Adds a new element to the buffer, doubling the capacity if necessary. * `size()`: Returns the current number of elements in the buffer. * `capacity()`: Returns the current capacity of the buffer. **Constraints**: 1. The initial capacity (`initial_capacity`) will be a positive integer within the range [1, 10^4]. 2. The data to be written will be integers. 3. The buffer should be able to expand its capacity multiple times if needed. **Requirements**: - **Edge Cases**: Handle reading from an empty buffer by raising an appropriate exception. - **Dynamic Expansion**: Ensure the buffer can expand its capacity while maintaining the order of the elements. **Challenge**: Optimize the buffer operations to ensure that resizing and data management are handled efficiently. Use proper data structures to achieve dynamic resizing with minimal performance impact.","solution":"class DynamicCircularBuffer: def __init__(self, initial_capacity: int) -> None: self.buffer = [None] * initial_capacity self.head = 0 self.tail = 0 self.count = 0 self.capacity_value = initial_capacity def read(self) -> int: if self.count == 0: raise Exception(\\"Buffer is empty\\") data = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.capacity_value self.count -= 1 return data def write(self, data: int) -> None: if self.count == self.capacity_value: self._expand_capacity() self.buffer[self.tail] = data self.tail = (self.tail + 1) % self.capacity_value self.count += 1 def size(self) -> int: return self.count def capacity(self) -> int: return self.capacity_value def _expand_capacity(self): new_capacity = self.capacity_value * 2 new_buffer = [None] * new_capacity for i in range(self.count): new_buffer[i] = self.buffer[(self.head + i) % self.capacity_value] self.buffer = new_buffer self.head = 0 self.tail = self.count self.capacity_value = new_capacity"},{"question":"# ASCII Value Summation of a String In many computer systems, ASCII (American Standard Code for Information Interchange) values are used to represent characters. Each character has a corresponding integer ASCII value. For instance, the ASCII value of \'A\' is 65 and that of \'a\' is 97. Task You are required to implement a function `sum_ascii_values` that takes a string input and returns the sum of the ASCII values of its characters. Function Signature ```python def sum_ascii_values(s: str) -> int: pass ``` Input * `s` (str): A non-empty string containing only alphabetical characters (both uppercase and lowercase). Output * Returns an integer representing the sum of the ASCII values of the characters in the string. Constraints * `1 <= len(s) <= 1000` Examples * Example 1: - Input: `\'ABC\'` - Output: `198` * Example 2: - Input: `\'abc\'` - Output: `294` * Example 3: - Input: `\'Hello\'` - Output: `500` * Example 4: - Input: `\'Python\'` - Output: `642` * Example 5: - Input: `\'Z\'` - Output: `90` Requirements * Ensure the solution efficiently handles the summation of ASCII values. * Python\'s in-built `ord()` function can be utilized to find the ASCII value of a character.","solution":"def sum_ascii_values(s: str) -> int: Computes the sum of the ASCII values of the characters in the given string. Parameters: s (str): The input string containing alphabetical characters. Returns: int: The sum of the ASCII values of the characters in the string. return sum(ord(char) for char in s)"},{"question":"# Objective: Create a function that simulates the operations of a banking system, specifically focusing on handling transactions on multiple accounts. Your function should be able to add transactions and compute the balance for each account by maintaining a transaction history. # Task: Write a Python class `BankingSystem` that allows for recording transactions (deposits and withdrawals) for multiple accounts and calculating the balance for any given account. # Class Signature: ```python class BankingSystem: def __init__(self): pass def add_transaction(self, account_id: str, amount: float) -> None: pass def get_balance(self, account_id: str) -> float: pass ``` # Input: - The `add_transaction` method takes: * `account_id`: A string representing the account identifier. * `amount`: A float representing the transaction amount (positive for deposits, negative for withdrawals). - The `get_balance` method takes: * `account_id`: A string representing the account identifier. # Output: - The `get_balance` method returns a float representing the current balance of the specified account. # Constraints: - Transactions will be in the range `[-10^6, 10^6]`. - Each account will have at most 10^4 transactions. - Account IDs will be unique strings up to 10 characters long. # Example: ```python # Initializing the banking system banking_system = BankingSystem() # Adding transactions banking_system.add_transaction(\\"acc1\\", 1000.0) banking_system.add_transaction(\\"acc1\\", -500.0) banking_system.add_transaction(\\"acc2\\", 1500.0) banking_system.add_transaction(\\"acc1\\", 300.0) # Getting balances print(banking_system.get_balance(\\"acc1\\")) # Output: 800.0 print(banking_system.get_balance(\\"acc2\\")) # Output: 1500.0 ``` # Details: - Maintain an internal record of transactions for each account. - Use a data structure such as a dictionary to store transactions keyed by the account ID. - Ensure that the `get_balance` function accurately computes the current balance by summing the transactions. # Edge Cases: - Handle cases where an account has no transactions (should return a balance of 0.0). - Ensure proper handling of large transaction values within the specified range.","solution":"class BankingSystem: def __init__(self): # Using a dictionary to store transactions for each account_id self.accounts = {} def add_transaction(self, account_id: str, amount: float) -> None: # If the account_id doesn\'t exist, initialize it with an empty list if account_id not in self.accounts: self.accounts[account_id] = [] # Append the transaction amount to the account_id\'s transaction history self.accounts[account_id].append(amount) def get_balance(self, account_id: str) -> float: # Return the account balance by summing up the transactions if account_id in self.accounts: return sum(self.accounts[account_id]) else: return 0.0 # Return 0.0 if the account_id has no transactions or does not exist"},{"question":"# Question You are given three different methods for determining if a number is a prime number: - An iterative approach using a basic loop (`is_prime_iterative`). - A more optimized approach using the square root technique (`is_prime_sqrt`). - A compact approach using generator expressions (`is_prime_compact`). Your task is to write a function `prime_check_factory` that returns the appropriate prime-checking function based on the size of the input number and a provided threshold. Specifically: - If the number is less than or equal to the threshold, use the basic loop approach. - If the number is greater than the threshold but less than twice the threshold, use the square root technique. - If the number is greater than twice the threshold, use the generator expression approach. - If the number is negative or zero, it is not prime by definition. # Function Signature ```python def prime_check_factory(n: int, threshold: int) -> bool: pass ``` # Input - `n` (int): The integer number to be checked for primality. - `threshold` (int): The threshold value for selecting between the prime-checking methods. # Output - `bool`: `True` if `n` is a prime number, `False` otherwise. # Constraints - You must use the provided `is_prime_iterative`, `is_prime_sqrt`, and `is_prime_compact` functions. - The input `n` will be a non-negative integer. - The threshold will be a positive integer. # Examples ```python >>> prime_check_factory(17, 10) True >>> prime_check_factory(1, 10) False >>> prime_check_factory(-5, 10) False >>> prime_check_factory(101, 50) True >>> prime_check_factory(50, 25) False ``` # Requirements - Optimize for both performance and readability. - Handle edge cases effectively. # Testing Ensure your function passes the provided examples as well as edge cases like the smallest prime numbers, large composite numbers, and numbers with various magnitudes.","solution":"def is_prime_iterative(n: int) -> bool: Return True if n is a prime number using iterative approach. if n < 2: return False for i in range(2, n): if n % i == 0: return False return True def is_prime_sqrt(n: int) -> bool: Return True if n is a prime number using square root optimization. if n < 2: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def is_prime_compact(n: int) -> bool: Return True if n is a prime number using generator expressions. if n < 2: return False return all(n % i for i in range(2, int(n**0.5) + 1)) def prime_check_factory(n: int, threshold: int) -> bool: Return the appropriate prime-checking function based on the size of n and the threshold. if n <= 0: return False elif n <= threshold: return is_prime_iterative(n) elif n <= 2 * threshold: return is_prime_sqrt(n) else: return is_prime_compact(n)"},{"question":"# Array Manipulation Question You are tasked with writing a function that rotates a given array to the right by a specified number of steps. This operation shifts each element of the array to the right by one position, with the last element wrapping around to the beginning of the array. # Problem Statement Write a Python function `rotate_array(nums: list, k: int) -> list` that takes an array of integers and an integer `k`, and returns a new array that is the result of rotating the input array to the right by `k` steps. Implement: ```python def rotate_array(nums: list, k: int) -> list: pass ``` # Constraints: * The input `nums` must be a list of integers; otherwise, raise a `TypeError`. * The input list `nums` should not be modified; the function should return a new list. * You are not allowed to use any built-in list slicing methods for this task. # Example: ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3], 4) [3, 1, 2] >>> rotate_array([1], 0) [1] >>> rotate_array([], 10) [] >>> rotate_array(\\"12345\\", 2) Traceback (most recent call last): ... TypeError: Expected a list of integers as input >>> rotate_array([1, 2, \'3\', 4, 5], 2) Traceback (most recent call last): ... TypeError: List must contain only integers ``` # Notes: 1. If `k` is greater than the length of the list, rotate only by `k % len(nums)` steps. 2. Ensure that the function handles the case where `k` is zero gracefully. 3. Maintain the order of original elements apart from their rotated positions. 4. Consider edge cases for empty lists and single-element lists. # Performance Requirements: * The rotation operation must be efficient, with a time complexity of O(n), where n is the length of the list. * The space complexity should also aim for O(n) due to the creation of the new list.","solution":"def rotate_array(nums: list, k: int) -> list: # Check if input is a list if not isinstance(nums, list): raise TypeError(\\"Expected a list of integers as input\\") # Check if list contains only integers if not all(isinstance(x, int) for x in nums): raise TypeError(\\"List must contain only integers\\") # Handle edge cases n = len(nums) if n == 0: return [] k = k % n if k == 0: return nums[:] # Rotate the array rotated_array = [0] * n for i in range(n): rotated_array[(i + k) % n] = nums[i] return rotated_array"},{"question":"# Binary Tree Maximum Width The maximum width of a binary tree is the maximum number of nodes present at any level of the tree. The width of a binary search tree is defined as the number of nodes that can be found at each level of the tree. The maximum width is the width of the level with the maximum number of nodes. Given a binary tree, implement a function `max_width_of_binary_tree(root: TreeNode) -> int` to find the maximum width of the binary tree. # Function Signature ```python def max_width_of_binary_tree(root: TreeNode) -> int: ``` # Input - `root`: A `TreeNode` object that represents the root of a binary tree. Each `TreeNode` object has the following attributes: - `val` (int): the value of the node. - `left` (TreeNode): the left child of the node. - `right` (TreeNode): the right child of the node. # Output - An integer representing the maximum width of the binary tree. # Constraints - The binary tree will have at most 10,000 nodes. # Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(8) root.right.right.left = TreeNode(6) root.right.right.right = TreeNode(7) print(max_width_of_binary_tree(root)) # Output: 4 ``` # Notes - You may assume that the width of the input binary tree is always less than or equal to the number of nodes in the tree. - Make sure to handle the edge cases such as an empty tree (where the maximum width would be `0`).","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_width_of_binary_tree(root: TreeNode) -> int: if not root: return 0 # Initialize a queue for level order traversal queue = [(root, 0)] max_width = 0 # Perform level order traversal while queue: level_length = len(queue) _, first_index = queue[0] _, last_index = queue[-1] max_width = max(max_width, last_index - first_index + 1) for _ in range(level_length): node, index = queue.pop(0) # Append children to the queue with appropriate indices if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) return max_width"},{"question":"# Problem Statement: You are tasked with developing a feature extraction function for text data as part of a natural language processing (NLP) pipeline. Specifically, you need to implement a function that computes the Term Frequency-Inverse Document Frequency (TF-IDF) for a list of documents. Each document is represented as a string of words separated by spaces, and you should treat words as case-insensitive. # Function Signature: ```python def compute_tfidf(documents: List[str]) -> List[Dict[str, float]]: # Your code here ``` # Input: - A list of strings `documents`, where each string represents a document containing words separated by spaces. The list can contain up to `10000` documents, and each document can have up to `1000` words. Words consist only of alphabetic characters and are case-insensitive (e.g., \\"Word\\" and \\"word\\" should be treated the same). # Output: - A list of dictionaries where each dictionary represents the TF-IDF scores of the words in a corresponding document from the input list. Each dictionary should map words to their TF-IDF scores. # Constraints: - The length of each document does not exceed `1000` words. - The total number of documents does not exceed `10000`. - Words consist only of lowercase English letters (a-z). # Performance requirements: - Your solution should efficiently compute the TF-IDF scores within the given constraints. # Example: ```python - Input: [\\"this is a sample\\", \\"this is another example example\\"] - Output: [ {\\"this\\": 0.0, \\"is\\": 0.0, \\"a\\": 0.405465, \\"sample\\": 0.405465}, {\\"this\\": 0.0, \\"is\\": 0.0, \\"another\\": 0.405465, \\"example\\": 0.81093} ] ``` # Notes: - The Term Frequency (TF) of a word in a document is computed as: `TF = (Number of times the word appears in the document) / (Total number of words in the document)` - The Inverse Document Frequency (IDF) of a word is computed as: `IDF = log((Total number of documents) / (Number of documents containing the word))` - The TF-IDF score of a word in a document is the product of its TF and IDF scores. - Floating-point precision errors are acceptable within reason. # Task: Implement the function as described and ensure it handles various edge cases efficiently and correctly.","solution":"from math import log from collections import defaultdict from typing import List, Dict def compute_tfidf(documents: List[str]) -> List[Dict[str, float]]: Computes the TF-IDF scores for each word in each document in the list of documents. # Convert documents to lowercase and split into words lower_documents = [doc.lower().split() for doc in documents] # Calculate the document frequency for each word doc_count = defaultdict(int) total_docs = len(documents) for doc in lower_documents: unique_words = set(doc) for word in unique_words: doc_count[word] += 1 # Compute IDF for each word idf = {word: log(total_docs / count) for word, count in doc_count.items()} # Compute TF and TF-IDF for each document tfidf_docs = [] for doc in lower_documents: tf = defaultdict(float) word_count = len(doc) for word in doc: tf[word] += 1 tfidf = {word: (tf[word] / word_count) * idf[word] for word in tf} tfidf_docs.append(tfidf) return tfidf_docs"},{"question":"# Problem Statement You are given a 2D grid where each cell contains an integer representing different types of terrain. Your task is to determine the size of the largest contiguous region (connected component) with the same terrain type. Two cells are considered contiguous if they share a common edge (left, right, top, or bottom). Implement a function `largest_contiguous_region(grid)` to solve this problem. # Input: - A 2D list of integers `grid`, where `0 <= len(grid), len(grid[0]) <= 500`. # Output: - An integer representing the size (number of cells) of the largest contiguous region of the same terrain type. # Constraints: - The values in the 2D grid are integers which can be positive or negative. # Example: ```python # Example 1 grid = [ [1, 1, 2, 2], [1, 1, 2, 2], [3, 3, 3, 3], [3, 3, 1, 1] ] print(largest_contiguous_region(grid)) # Output: 6 (Region of terrain type 3) # Example 2 grid = [ [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2] ] print(largest_contiguous_region(grid)) # Output: 1 (No larger regions than individual cells) # Example 3 grid = [ [2, 2, 2], [2, 1, 1], [1, 1, 1] ] print(largest_contiguous_region(grid)) # Output: 5 (Region of terrain type 1 - bottom right) ``` # Requirements: - Implement the solution using depth-first search (DFS) or breadth-first search (BFS). - Ensure that your implementation has an appropriate depth limit to avoid stack overflow with large grids. - Optimize for time complexity relative to the size of the input grid. # Notes: - Consider edge cases such as empty grids or grids with only one cell. - Be mindful of the time complexity, given the upper bounds of the input sizes.","solution":"def largest_contiguous_region(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) def dfs(r, c, terrain): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != terrain: return 0 # Mark the cell as visited by setting it to None grid[r][c] = None size = 1 # Explore all four directions size += dfs(r+1, c, terrain) size += dfs(r-1, c, terrain) size += dfs(r, c+1, terrain) size += dfs(r, c-1, terrain) return size largest_region_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] is not None: terrain_type = grid[r][c] region_size = dfs(r, c, terrain_type) largest_region_size = max(largest_region_size, region_size) return largest_region_size"},{"question":"# Problem Statement You are given a binary tree. Your task is to implement a function that performs a **Zigzag Level Order Traversal** of the tree. This traversal is also known as \\"spiral order traversal\\" where the nodes at each level are printed in alternating left-to-right and right-to-left order. # Input Format 1. A list of integers representing the values of nodes when the tree is serialized in a level-order manner (breadth-first) where `None` represents a missing node. # Output Format - A list of lists of integers where each inner list contains the nodes\' values at that level in zigzag order. # Constraints * The number of nodes in the tree can be up to (10^4). * Node values are integers in the range (-10^5 leq text{node value} leq 10^5). # Performance Requirements * Aim for an efficient traversal that correctly handles trees with a large number of nodes. # Examples 1. **Input**: ``` tree = [3, 9, 20, None, None, 15, 7] ``` **Output**: ``` [[3], [20, 9], [15, 7]] ``` 2. **Input**: ``` tree = [1, 2, 3, 4, 5, 6, 7] ``` **Output**: ``` [[1], [3, 2], [4, 5, 6, 7]] ``` 3. **Input**: ``` tree = [1, None, 2, None, 3, None, 4, None, 5] ``` **Output**: ``` [[1], [2], [3], [4], [5]] ``` # Notes - You may assume that the input list represents a valid binary tree. - Implement your solution with appropriate traversal and queue structures to maintain the zigzag order. # Function Signature ```python from typing import List, Optional def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: # Your code here class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result, current_level, left_to_right = [], [root], True while current_level: level_values = [] next_level = [] for node in current_level: level_values.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_values.reverse() result.append(level_values) current_level = next_level left_to_right = not left_to_right return result"},{"question":"# Problem Statement Build an application that processes a list of events and identifies overlapping intervals. This task evaluates your understanding of interval management, sorting, and merging techniques. Function Specification Implement a function `merge_intervals` with the following signature: ```python from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals from a list of intervals. Args: intervals: A list of tuples, where each tuple consists of two integers representing the start and end of an interval. Returns: A list of tuples with merged intervals. ``` Parameters - **intervals**: A list containing `n` tuples, each with two integers `(start, end)` where - `0 <= n <= 10^6` - `0 <= start < end <= 10^9` Returns - A list of tuples with the merged intervals. The resulting intervals should be sorted based on the start time. Constraints - Ensure the function handles cases with zero intervals. - Each interval start and end are distinct integers. - The intervals provided may not be sorted and may overlap. # Example ```python intervals = [(1, 3), (2, 4), (5, 7), (6, 8)] result = merge_intervals(intervals) print(result) ``` This should output: ``` [(1, 4), (5, 8)] ``` # Explanation In the given example: - The first two intervals `(1, 3)` and `(2, 4)` are overlapping and should be merged into `(1, 4)`. - The last two intervals `(5, 7)` and `(6, 8)` are also overlapping and should be merged into `(5, 8)`. # Performance Requirements - The function must efficiently handle up to `10^6` intervals. - Ensure the intervals are processed with minimal computational overhead.","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals from a list of intervals. Args: intervals: A list of tuples, where each tuple consists of two integers representing the start and end of an interval. Returns: A list of tuples with merged intervals. # If no intervals, return empty list if not intervals: return [] # Sort the intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] # Iterate over the intervals starting from the second one for start, end in intervals[1:]: if start <= current_end: # There is an overlap, merge the intervals current_end = max(current_end, end) else: # No overlap, add the previous interval to the list merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"# Question: Custom Merge Sort for Even and Odd Separation The classic Merge Sort algorithm is a comparison-based sorting algorithm known for its efficiency and stability. However, sometimes sorting requirements can be peculiar. Let\'s customize Merge Sort to first separate even and odd numbers, and then within each group, sort the numbers in descending order. **Task**: Modify the Merge Sort algorithm such that it sorts the integers in the following manner: - All even numbers are sorted in descending order and come first. - All odd numbers are sorted in descending order and come after the even numbers. Write a function `custom_merge_sort` which takes a list of integers and returns a sorted list based on the aforementioned criteria. **Function Signature**: ```python def custom_merge_sort(array: list[int]) -> list[int]: ``` **Input**: * `array`: A list of integers. **Output**: * A list of integers sorted such that even numbers in descending order come before odd numbers in descending order. **Constraints**: * The input list can contain positive or negative integers. * Handle the case where the input list is empty. * The algorithm should maintain efficiency similar to the classic Merge Sort (O(n log n)). **Examples**: ```python >>> custom_merge_sort([9, 4, 2, 5, 3]) [4, 2, 9, 5, 3] >>> custom_merge_sort([7, 3, 5, 1]) [7, 5, 3, 1] >>> custom_merge_sort([8, -6, 12, 0, 7]) [12, 8, 0, -6, 7] >>> custom_merge_sort([]) [] ``` **Notes**: * Consider edge cases such as an empty list or a list containing all even or all odd numbers. * Ensure the performance is optimal by leveraging the Merge Sort technique. * Maintain stability for numbers between even and odd separation (relative ordering shouldn\'t change). # Solution Outline To solve the problem, you can follow these steps: 1. Separate the list into even and odd numbers. 2. Sort each list in descending order. 3. Merge the sorted even and odd lists with even numbers preceding odd numbers. 4. Implement the sorting logic using a modified version of the Merge Sort algorithm to ensure efficiency. You can also provide the corresponding implementation of the `custom_merge_sort` function.","solution":"def custom_merge_sort(array: list[int]) -> list[int]: Sorts the list such that even numbers in descending order come before odd numbers in descending order. :param array: List of integers to be sorted :return: List of integers sorted based on the criteria if len(array) <= 1: return array mid = len(array) // 2 left_half = custom_merge_sort(array[:mid]) right_half = custom_merge_sort(array[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: Merge function for custom merge sort. Merges two halves while maintaining separate and sorted evens and odds. :param left: Left half sorted list :param right: Right half sorted list :return: Merged list based on custom criteria result = [] # Extract even and odd numbers left_evens = [x for x in left if x % 2 == 0] left_odds = [x for x in left if x % 2 != 0] right_evens = [x for x in right if x % 2 == 0] right_odds = [x for x in right if x % 2 != 0] evens = sorted(left_evens + right_evens, reverse=True) odds = sorted(left_odds + right_odds, reverse=True) return evens + odds"},{"question":"# Coding Assessment Question Scenario You\'re developing an application to help teachers keep track of students\' grades. One feature requires calculating the median grade from a dynamically changing list of grades. This means that you need to efficiently support updates to the list as well as quick median queries. Task Write a Python class `MedianTracker` that supports adding a new grade and finding the median of the current grades efficiently. The class should provide the following methods: - `add_grade(grade: int) -> None`: Adds a new grade to the list of grades. - `find_median() -> float`: Returns the median of the current grades. If the number of grades is even, return the average of the two middle elements. Class Signature ```python class MedianTracker: def __init__(self): pass def add_grade(self, grade: int) -> None: pass def find_median(self) -> float: pass ``` Input * The method `add_grade(grade: int)` takes an integer grade, where 0 <= grade <= 100. * The method `find_median()` does not take any input. Output * The `find_median()` method returns a float representing the median of the grades. Constraints * The solution should efficiently handle dynamic updates and quick median queries. * The grade list can consist of up to 10^5 grades. * All methods should have a time complexity appropriate for handling the upper limit of constraints. Example ```python tracker = MedianTracker() tracker.add_grade(85) tracker.add_grade(92) tracker.add_grade(75) tracker.add_grade(88) print(tracker.find_median()) # Output: 86.5 tracker.add_grade(95) print(tracker.find_median()) # Output: 88.0 tracker.add_grade(100) print(tracker.find_median()) # Output: 92.0 ``` Performance Requirements Ensure that your implementation efficiently supports both adding grades and computing the median, even as the list grows to its maximum size.","solution":"import heapq class MedianTracker: def __init__(self): self.min_heap = [] # Min heap for the larger half self.max_heap = [] # Max heap for the smaller half def add_grade(self, grade: int) -> None: if len(self.max_heap) == 0 or grade <= -self.max_heap[0]: heapq.heappush(self.max_heap, -grade) else: heapq.heappush(self.min_heap, grade) # Balance the heaps if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"Matrix Path Finder # Description: Implement a function that finds the number of unique paths in an `m x n` grid from the top-left corner to the bottom-right corner. You can only move either down or to the right at any point in time. Additionally, there may be obstacles in the grid that you need to navigate around. # Input: * An integer `m` indicating the number of rows. * An integer `n` indicating the number of columns. * A 2D list `obstacleGrid` of size `m x n` where `1` indicates the presence of an obstacle and `0` indicates no obstacle. # Output: * An integer representing the total number of unique paths from the top-left corner to the bottom-right corner. # Constraints: * `1 <= m, n <= 100` * `obstacleGrid[i][j]` is either `0` or `1`. # Functions: * `unique_paths_with_obstacles(m: int, n: int, obstacleGrid: List[List[int]]) -> int` # Example: ```python def unique_paths_with_obstacles(m: int, n: int, obstacleGrid: List[List[int]]) -> int: # Your implementation here # Example Usage: obstacle_grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] print(unique_paths_with_obstacles(3, 3, obstacle_grid)) # Output: 2 ``` **Example Execution:** Given: ```plaintext m = 3 n = 3 obstacleGrid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] ``` Expected output: ```plaintext 2 ``` # Note: * In this example, (3, 3) is the end-point in a grid, and there are a total of 2 unique paths avoiding the obstacle located at (2, 2). * Your function should handle edge cases such as a completely blocked path correctly. * Ensure that the function efficiently computes the number of unique paths for grid sizes up to 100x100.","solution":"from typing import List def unique_paths_with_obstacles(m: int, n: int, obstacleGrid: List[List[int]]) -> int: if obstacleGrid[0][0] == 1 or obstacleGrid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Anagram Finder **Context**: You are tasked with developing a function for a text analysis software to identify anagrams from a list of words. An anagram is a word formed by rearranging the letters of a different word, typically using all the original letters exactly once. **Task**: Implement the function `find_anagrams(words_list: List[str]) -> Dict[str, List[str]]` that takes a list of strings and groups the anagrams together. **Input**: - `words_list`: A list of strings representing words. **Output**: - Return a dictionary where the keys are the sorted version of the anagrams and the values are lists of words that are anagrams of each other. **Constraints**: - Each word will consist of lowercase alphabets only. - The length of the `words_list` will not exceed 10^4. - All words within the list will have a maximum length of 100 characters. **Examples**: ```python >>> find_anagrams([\\"cat\\", \\"dog\\", \\"tac\\", \\"god\\", \\"act\\"]) {\'act\': [\'cat\', \'tac\', \'act\'], \'dgo\': [\'dog\', \'god\']} >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\"]) {\'eilnst\': [\'listen\', \'silent\', \'enlist\', \'inlets\'], \'eggloo\': [\'google\']} >>> find_anagrams([\\"abc\\", \\"bac\\", \\"cab\\", \\"xyz\\", \\"zyx\\"]) {\'abc\': [\'abc\', \'bac\', \'cab\'], \'xyz\': [\'xyz\', \'zyx\']} >>> find_anagrams([\\"hello\\", \\"olleh\\", \\"world\\", \\"dlrow\\", \\"abc\\", \\"bca\\", \\"cab\\"]) {\'ehllo\': [\'hello\', \'olleh\'], \'dlorw\': [\'world\', \'dlrow\'], \'abc\': [\'abc\', \'bca\', \'cab\']} ``` **Hints**: - Consider using a defaultdict to simplify the process of grouping anagrams. - Sorting the characters of the words can help in identifying and grouping anagrams.","solution":"from typing import List, Dict from collections import defaultdict def find_anagrams(words_list: List[str]) -> Dict[str, List[str]]: Groups anagrams together from the input list of words. Parameters: words_list (List[str]): A list of words. Returns: Dict[str, List[str]]: A dictionary where each key is the sorted form of anagrams and the value is a list of words that are anagrams of each other. anagrams = defaultdict(list) for word in words_list: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return dict(anagrams)"},{"question":"# Coding Assessment Question **Context**: You are required to design a function that identifies the most frequent character in a given string and returns it along with its frequency count. This can be useful in text analysis tasks where understanding character distribution is critical. Write a Python function `most_frequent_char(s: str) -> Tuple[str, int]` that takes a string and identifies the most frequently occurring character (case insensitive). If there are multiple characters with the same highest frequency, return the one that appears first in alphabetical order. **Function Signature**: ```python from typing import Tuple def most_frequent_char(s: str) -> Tuple[str, int]: ``` **Input**: 1. `s`: string, representing the text to analyze. **Output**: - Return a tuple containing the most frequent character as a string and its frequency as an integer. **Constraints**: - The string will contain only printable ASCII characters (no newline characters). - The string will contain at least one character. **Example**: Given the input string ` \\"Hello World!\\"`, Example usage: ```python result = most_frequent_char(\\"Hello World!\\") print(result) # Should return (\'l\', 3) as \'l\' appears the most frequently. ``` **Additional Instructions**: 1. Ignore case when counting character frequencies (i.e., \'A\' and \'a\' should be considered the same character). 2. Non-alphabetic characters should be included in the frequency count. 3. Ensure that the function performs efficiently even with large input sizes.","solution":"from typing import Tuple from collections import Counter def most_frequent_char(s: str) -> Tuple[str, int]: s = s.lower() # Convert the string to lowercase for case insensitivity char_counter = Counter(s) # Count frequency of each character most_common_char = min(char_counter.items(), key=lambda item: (-item[1], item[0])) return most_common_char"},{"question":"# Stock Price Averages Context: You are working on a financial analytics software that needs to compute the average stock price for each company over a specified range of days, efficiently handling multiple queries. Objective: Improve the provided `StockPrices` class which uses a simple list, by implementing a more efficient solution to handle frequent range queries involving stock price averages. Specifications: - **Class Name**: `StockPrices` - **Methods**: - `add_price(day: int, price: float) -> None`: Adds the stock price for a given day. - `average_price(start_day: int, end_day: int) -> float`: Returns the average stock price between `start_day` and `end_day`, inclusive. - **Input Format**: - `day` is an integer representing the specific day (starting from 0). - `price` is a float representing the stock price on that day. - `start_day` and `end_day` are integers representing the range of days for the average calculation. - **Output Format**: - `add_price` returns `None`. - `average_price` returns a float representing the average price, rounded to two decimal places. Tasks: - Implement the `StockPrices` class using a more efficient data structure (such as a cumulative sum array) to optimize the range queries. - Ensure that adding prices and querying the average price are efficient, even for large inputs. - Handle edge cases where queries go beyond the added price days. ```python class StockPrices: def __init__(self): self.prices = [] self.cumulative_sums = [] def add_price(self, day: int, price: float) -> None: if day < len(self.prices): self.prices[day] = price else: self.prices.extend([0] * (day - len(self.prices) + 1)) self.prices[day] = price self.cumulative_sums = [0] * (len(self.prices) + 1) for i in range(len(self.prices)): self.cumulative_sums[i + 1] = self.cumulative_sums[i] + self.prices[i] def average_price(self, start_day: int, end_day: int) -> float: if start_day < 0 or end_day >= len(self.prices) or end_day < start_day: raise ValueError(\\"Invalid day range\\") total_sum = self.cumulative_sums[end_day + 1] - self.cumulative_sums[start_day] average = total_sum / (end_day - start_day + 1) return round(average, 2) if __name__ == \\"__main__\\": sp = StockPrices() sp.add_price(0, 100.0) sp.add_price(1, 200.0) sp.add_price(2, 300.0) sp.add_price(3, 400.0) sp.add_price(4, 500.0) print(sp.average_price(0, 4)) # Output: 300.0 print(sp.average_price(1, 3)) # Output: 300.0 print(sp.average_price(2, 2)) # Output: 300.0 ``` Test your implementation thoroughly to ensure it meets the requirements mentioned above.","solution":"class StockPrices: def __init__(self): self.prices = [] self.cumulative_sums = [] def add_price(self, day: int, price: float) -> None: if day < len(self.prices): self.prices[day] = price else: self.prices.extend([0] * (day - len(self.prices) + 1)) self.prices[day] = price # Update the cumulative sum array from scratch self.cumulative_sums = [0] * (len(self.prices) + 1) for i in range(len(self.prices)): self.cumulative_sums[i + 1] = self.cumulative_sums[i] + self.prices[i] def average_price(self, start_day: int, end_day: int) -> float: if start_day < 0 or end_day >= len(self.prices) or end_day < start_day: raise ValueError(\\"Invalid day range\\") total_sum = self.cumulative_sums[end_day + 1] - self.cumulative_sums[start_day] average = total_sum / (end_day - start_day + 1) return round(average, 2)"},{"question":"# Coding Challenge: Matrix Diagonal Sum Problem Statement Given a square matrix `mat` with integers, your task is to compute the sum of elements on both the primary diagonal and the secondary diagonal. However, if any element is found on both diagonals (which only happens if the matrix has an odd dimension), that element should only be counted once. You need to write a function `diagonal_sum(mat: List[List[int]]) -> int` that performs such a calculation. Specifications - **Input**: A list of lists `mat`, representing a square matrix of integers. - **Output**: An integer representing the sum of the primary and secondary diagonal elements, with overlapping elements counted only once. Constraints - 1 <= len(mat) <= 100 (i.e., the matrix will be at most 100 x 100 in size). - -1000 <= mat[i][j] <= 1000 (the integer values in the matrix). Example Consider the following input matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Calling `diagonal_sum` on this matrix should return `25`, since: - Primary diagonal sum: 1 + 5 + 9 = 15 - Secondary diagonal sum: 3 + 5 + 7 = 15 - The element 5 is counted only once. Thus, the total sum is 15 + 15 - 5 = 25. Function Signature ```python def diagonal_sum(mat: List[List[int]]) -> int: pass ``` **Note**: Ensure your solution handles all edge cases and optimizes for performance where possible.","solution":"from typing import List def diagonal_sum(mat: List[List[int]]) -> int: n = len(mat) total_sum = 0 for i in range(n): total_sum += mat[i][i] # Primary diagonal total_sum += mat[i][n - 1 - i] # Secondary diagonal if n % 2 == 1: # Subtract the middle element which is added twice for odd n total_sum -= mat[n // 2][n // 2] return total_sum"},{"question":"# Directed Graph Cycle Detection Detecting cycles in a directed graph is a fundamental problem in computer science, particularly in the analysis of graph structures used in various real-world applications such as dependency resolution. Task You are required to implement a function that checks for the presence of cycles in a directed graph. The graph is represented as an adjacency list. Input * A dictionary `graph` where keys are nodes (integers) and values are lists of integers representing directed edges from the key node to the nodes in the list. * The nodes are labeled from 0 to n-1, where `1 ≤ n ≤ 10^4`. Output * Return `True` if there is at least one cycle in the graph. * Return `False` if there are no cycles. Function Signature ```python def has_cycle(graph: dict[int, list[int]]) -> bool: pass ``` Example ```python >>> has_cycle({0: [1], 1: [2], 2: [0]}) True >>> has_cycle({0: [1], 1: [2], 2: []}) False >>> has_cycle({0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}) True >>> has_cycle({0: [], 1: []}) False ``` Constraints * The implementation should handle various edge cases such as graphs with isolated nodes and graphs with self-loops. * Time Complexity: (O(V + E)), where (V) is the number of vertices and (E) is the number of edges. * Space Complexity: (O(V)) for storing visited states of nodes. Tips * Use Depth First Search (DFS) to explore the graph. * Maintain recursion stack and visited arrays to detect back edges indicating cycles. * Handle disconnected components by iterating over all nodes in the graph.","solution":"def has_cycle(graph: dict[int, list[int]]) -> bool: Detect cycles in a directed graph using Depth First Search (DFS). Parameters: graph (dict): The graph represented as an adjacency list. Returns: bool: True if there\'s at least one cycle in the graph, False otherwise. V = len(graph) visited = [False] * V recursion_stack = [False] * V def dfs(node): visited[node] = True recursion_stack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor): return True elif recursion_stack[neighbor]: return True recursion_stack[node] = False return False for node in range(V): if not visited[node]: if dfs(node): return True return False"},{"question":"# Coding Task: Implement a Custom Sort Algorithm Often sorting is necessary to arrange data, but sometimes you may need more control over how your data is ordered. In this task, you will create a custom sort function that allows sorting based on multiple criteria. # Objective Implement a custom sort function `multi_criteria_sort` that sorts a list of dictionaries based on multiple keys and their respective sort orders. # Details Input * The input will be a list of dictionaries and a list of sort criteria. Output * The output will be a sorted list of dictionaries based on the provided criteria. Example ```python data = [ {\\"name\\": \\"John\\", \\"age\\": 30, \\"salary\\": 40000}, {\\"name\\": \\"Alice\\", \\"age\\": 25, \\"salary\\": 50000}, {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"salary\\": 30000} ] criteria = [(\\"age\\", \\"asc\\"), (\\"salary\\", \\"desc\\")] sorted_data = multi_criteria_sort(data, criteria) print(sorted_data) # Expected Output: [ # {\\"name\\": \\"Alice\\", \\"age\\": 25, \\"salary\\": 50000}, # {\\"name\\": \\"John\\", \\"age\\": 30, \\"salary\\": 40000}, # {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"salary\\": 30000} # ] ``` # Constraints * Each dictionary in the list will have the same keys. * The criteria list will contain tuples where the first element is the key to sort by and the second is either \\"asc\\" for ascending or \\"desc\\" for descending order. * The list will contain at least one dictionary and the criteria list will have at least one criterion. * The solution should handle large datasets efficiently. # Implementation Guide - Write a helper function to perform sorting based on a single criterion. - Use the helper function iteratively for each criterion in reverse order (to maintain multiple sort criteria correctly). ```python def multi_criteria_sort(data, criteria): data_sorted = data[:] for key, order in reversed(criteria): reverse = order == \\"desc\\" data_sorted.sort(key=lambda x: x[key], reverse=reverse) return data_sorted # Test cases to verify correctness of the implementation def test_multi_criteria_sort(): data = [ {\\"name\\": \\"John\\", \\"age\\": 30, \\"salary\\": 40000}, {\\"name\\": \\"Alice\\", \\"age\\": 25, \\"salary\\": 50000}, {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"salary\\": 30000} ] criteria = [(\\"age\\", \\"asc\\"), (\\"salary\\", \\"desc\\")] sorted_data = multi_criteria_sort(data, criteria) assert sorted_data == [ {\\"name\\": \\"Alice\\", \\"age\\": 25, \\"salary\\": 50000}, {\\"name\\": \\"John\\", \\"age\\": 30, \\"salary\\": 40000}, {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"salary\\": 30000} ] ``` # Challenge * Ensure that the function efficiently handles sorting with multiple layers of criteria for large datasets. * Validate the solution to guarantee it meets performance expectations with a time complexity of O(n log n) where n is the number of items to sort.","solution":"def multi_criteria_sort(data, criteria): Sorts a list of dictionaries based on multiple criteria. Parameters: - data: List[Dict[str, Any]], the list of dictionaries to be sorted. - criteria: List[Tuple[str, str]], the list of sorting criteria, where each tuple contains the key to sort by and the order (\\"asc\\" or \\"desc\\"). Returns: - List[Dict[str, Any]], the sorted list of dictionaries. data_sorted = data[:] for key, order in reversed(criteria): reverse = order == \\"desc\\" data_sorted.sort(key=lambda x: x[key], reverse=reverse) return data_sorted"},{"question":"# Sorting Strings by Custom Alphabet Context: You are given an alien language\'s alphabet (a permutation of the English alphabet) and a list of words translated to this language. Your task is to sort these words based on the given alien alphabet. Function Signature: ```python def alien_language_sort(words: list[str], alphabet: str) -> list[str]: pass ``` Input: - `words`: A list of strings, where each string is a word in the alien language. - `alphabet`: A string of length 26 representing the custom alphabet, which is a permutation of the English alphabet. Output: - A list of strings, sorted according to the order defined by `alphabet`. Constraints: - The list `words` can contain between 1 to 1000 words. - Each word in `words` contains only lowercase English letters. - The `alphabet` is a single string of 26 unique lowercase English letters. Example: ```python words = [\\"hello\\", \\"world\\", \\"hi\\"] alphabet = \\"hlabcdefgijkmnopqrstuvwxyz\\" print(alien_language_sort(words, alphabet)) # Output: [\\"hello\\", \\"hi\\", \\"world\\"] ``` # Description: In the above example: - The custom alphabet is used to determine the order in which the words should appear. - \\"hello\\" comes before \\"hi\\" because \'e\' comes before \'i\' in the custom alphabet. - \\"hi\\" comes before \\"world\\" because \'h\' (the first letter of \\"hi\\") comes before \'w\' in the custom alphabet. Requirements: - Implement the function `alien_language_sort` to sort the list of words according to the custom alphabet. - Your function must efficiently handle up to 1000 words and appropriately validate inputs. Note: - Avoid using any print statements in your function. - Consider edge cases, such as when two words are identical or when the list contains only one word.","solution":"def alien_language_sort(words, alphabet): Sorts the words based on the provided alien language alphabet. Parameters: - words: List of strings, each a word in the alien language. - alphabet: A string of length 26 representing the custom alphabet. Returns: - A list of strings sorted according to the order defined by the custom alphabet. # Create a dictionary to map each letter in the custom alphabet to its index order_map = {char: index for index, char in enumerate(alphabet)} # A helper function to convert a word to its custom order representation def custom_order(word): return [order_map[char] for char in word] # Sort the words using the custom order representation return sorted(words, key=custom_order)"},{"question":"# Scenario You are working on implementing a book catalog system that needs the ability to find books by a specific keyword found in their title. Write the `find_books_by_keyword` function to provide this search capability. # Requirements **Function Signature**: ```python def find_books_by_keyword(catalog: list[dict], keyword: str) -> list[str]: pass ``` # Input * A list of dictionaries `catalog`, where each dictionary represents a book with keys \\"title\\" and \\"author\\". The \\"title\\" value is the book title (a string) and the \\"author\\" value is the author\'s name (a string). * A string `keyword` representing the word to search for within the titles of the books in the catalog. # Output * A list of strings, where each string is the title of a book that contains the keyword (case insensitive). The titles should be returned in their original form and maintain the order they appeared in the catalog. # Constraints * The `keyword` input will be a non-empty string consisting of alphabetic characters only. # Performance Requirements * Time Complexity: O(n * k) where n is the number of books and k is the length of the longest title. * Space Complexity: O(n) where n is the number of books that match the keyword. # Example ```python catalog = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\"}, {\\"title\\": \\"Great Expectations\\", \\"author\\": \\"Charles Dickens\\"}, {\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\"} ] >>> find_books_by_keyword(catalog, \\"great\\") [\\"The Great Gatsby\\", \\"Great Expectations\\"] >>> find_books_by_keyword(catalog, \\"the\\") [\\"The Great Gatsby\\", \\"The Catcher in the Rye\\"] ```","solution":"def find_books_by_keyword(catalog: list[dict], keyword: str) -> list[str]: Finds books by a specific keyword found in their title. Parameters: catalog (list of dict): A list of dictionaries representing the books. Each dictionary has \\"title\\" and \\"author\\" keys. keyword (str): The keyword to search for within the titles of the books. Returns: list of str: A list of book titles that contain the keyword (case insensitive). keyword = keyword.lower() matching_books = [book[\'title\'] for book in catalog if keyword in book[\'title\'].lower()] return matching_books"},{"question":"**Objective**: Develop a class that performs basic operations on a collection of numbers and allows for dynamic data manipulation. **Scenario**: You are tasked with creating a class `NumberCollection`, which manages a list of numbers and provides methods to add a number, remove a number, and compute the average of the numbers currently in the collection. The class should also provide a method to retrieve all numbers sorted in ascending order. **Guidelines**: - Define methods to add a number, remove a number (by value), compute the average, and get the sorted list. - Ensure the class handles duplicates appropriately. - The methods should validate inputs and handle possible exceptions gracefully. - Implement unit tests for each method to ensure they perform as expected. **Class Signature**: ```python class NumberCollection: def __init__(self): # Initializes an empty list to store numbers self.numbers = [] def add_number(self, number: float): # Adds a number to the collection pass def remove_number(self, number: float): # Removes a number from the collection, if it exists pass def compute_average(self) -> float: # Computes and returns the average of the numbers in the collection pass def get_sorted_numbers(self) -> List[float]: # Returns a sorted list of numbers in ascending order pass ``` **Method Descriptions**: 1. `add_number(self, number: float)`: Adds the given number to the list of numbers. 2. `remove_number(self, number: float)`: Removes the first occurrence of the given number from the list. If the number is not found, it does nothing. 3. `compute_average(self) -> float`: Computes and returns the average of the numbers in the list. If the list is empty, it returns 0. 4. `get_sorted_numbers(self) -> List[float]`: Returns a sorted list of the numbers in ascending order. **Input Format**: - Numbers can be integers or floats. **Output Format**: - The `add_number` and `remove_number` methods do not return any value. - The `compute_average` method returns a float. - The `get_sorted_numbers` method returns a list of floats sorted in ascending order. **Constraints**: - Inputs to methods should be valid numbers (integers or floats). - The `remove_number` method should remove only the first occurrence of the number if multiple instances exist. **Examples**: ```python >>> nc = NumberCollection() >>> nc.add_number(5) >>> nc.add_number(10) >>> nc.add_number(5) >>> nc.remove_number(5) >>> nc.compute_average() 7.5 >>> nc.get_sorted_numbers() [5, 10] ``` **Important Considerations**: - Ensure your implementation is efficient for managing and manipulating large collections of numbers. - Validate and test each method thoroughly to handle edge cases and unexpected input formats. - Maintain clear and concise documentation within the code for ease of understanding and maintenance.","solution":"from typing import List class NumberCollection: def __init__(self): self.numbers = [] def add_number(self, number: float): if not isinstance(number, (int, float)): raise ValueError(\\"Only integers and floats are allowed\\") self.numbers.append(number) def remove_number(self, number: float): if not isinstance(number, (int, float)): raise ValueError(\\"Only integers and floats are allowed\\") try: self.numbers.remove(number) except ValueError: pass # If the number is not found, do nothing def compute_average(self) -> float: if not self.numbers: return 0 return sum(self.numbers) / len(self.numbers) def get_sorted_numbers(self) -> List[float]: return sorted(self.numbers)"},{"question":"# Scenario In many financial applications, it is crucial to ensure that transactions are correctly recorded and balances are accurately maintained. Engineers often need to verify that a series of financial transactions are valid according to certain rules, such as no transaction can cause the balance to go negative. # Task Write a Python function `validate_transactions(transactions: List[float], initial_balance: float) -> bool` that takes a list of monetary transactions and an initial account balance. The function should return `True` if all transactions can be completed without the balance ever dropping below zero, and `False` otherwise. # Input Specifications * `transactions`: A list of float numbers representing the transactions to be processed. Positive numbers represent deposits, and negative numbers represent withdrawals. * `initial_balance`: A float representing the starting balance of the account. # Output Specifications * Returns a boolean value: `True` if all transactions are valid, and `False` otherwise. # Constraints * Each transaction and the initial balance will be between `-1e6` and `1e6`. * There can be up to `1e4` transactions in the list. # Example ```python >>> validate_transactions([200.0, -500.0, 100.0], 500.0) True >>> validate_transactions([100.0, -200.0, -300.0], 50.0) False >>> validate_transactions([-50.0, 200.0, -100.0], 150.0) True >>> validate_transactions([-1000.0, -500.0, 2000.0], 500.0) False ``` # Requirements * Ensure the function correctly handles deposits and withdrawals. * The function should iterate through the list of transactions once and maintain the balance accordingly. * If at any point during the processing of transactions the balance becomes negative, return `False` immediately.","solution":"def validate_transactions(transactions, initial_balance): Validates that a series of transactions do not cause the balance to drop below zero. :param transactions: List of float numbers representing the transactions to be processed. :param initial_balance: Float representing the starting balance of the account. :return: Boolean value `True` if all transactions can be completed without the balance ever dropping below zero, `False` otherwise. balance = initial_balance for transaction in transactions: balance += transaction if balance < 0: return False return True"},{"question":"# Problem: You are given a list of integers and a target value. Your task is to determine if there are two distinct indices in the list such that the numbers at these indices sum up to the target value. # Objective: Implement the function `find_indices(nums: List[int], target: int) -> Tuple[int, int]` that takes the list of integers and the target value as input and returns a tuple containing the two indices of the numbers that sum up to the target value. If no such indices exist, return `(-1, -1)`. # Function Signature: ```python def find_indices(nums: List[int], target: int) -> Tuple[int, int]: ``` # Input: - `nums`: A list of integers. (2 <= len(nums) <= 1000) - `target`: An integer representing the target sum. (-10^6 <= target <= 10^6) # Output: - A tuple containing two integers representing the indices of the numbers that sum up to the target value. If no such indices exist, return `(-1, -1)`. # Example: ```python nums = [2, 7, 11, 15] target = 9 output = find_indices(nums, target) # Expected output: (0, 1) nums = [3, 2, 4] target = 6 output = find_indices(nums, target) # Expected output: (1, 2) nums = [3, 3] target = 6 output = find_indices(nums, target) # Expected output: (0, 1) nums = [3, 3] target = 10 output = find_indices(nums, target) # Expected output: (-1, -1) ``` # Constraints: - Each input list will have at least two elements. - A valid result consists of two distinct indices (i, j) where 0 <= i, j < len(nums) and i != j. - If there are multiple valid results, you can return any one of them. - The input list can contain negative, zero and positive integers. # Guidance: In your function: 1. You can use a dictionary to store the indices of the numbers while iterating through the list. 2. For each number in the list, check if the complement (target - current number) exists in the dictionary. 3. If the complement exists, return the current index and the index of the complement from the dictionary. 4. If no such pair is found after iterating through the list, return `(-1, -1)`.","solution":"from typing import List, Tuple def find_indices(nums: List[int], target: int) -> Tuple[int, int]: Returns two distinct indices of the numbers in the list that sum up to the target value. If no such indices exist, returns (-1, -1). num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return (num_dict[complement], i) num_dict[num] = i return (-1, -1)"},{"question":"# Scenario: You are tasked with developing a software system for an online book store. The store maintains an inventory of books, each with a variety of relevant information such as title, author, ISBN, price, and stock quantity. The goal is to create a function that can search the inventory based on different criteria and update inventory records efficiently. # Task: Implement a class named `BookInventory` with the following requirements: 1. A method `add_book` to add a new book to the inventory. The book will be represented as a dictionary with keys: `title`, `author`, `isbn`, `price`, and `stock`. 2. A method `search_books` to search for books based on a specific attribute and value. The method should be flexible enough to search by `title`, `author`, or `isbn`. 3. A method `update_stock` to update the stock quantity of a book identified by its `isbn`. If the `isbn` does not exist in the inventory, the method should raise a `ValueError`. # Requirements: 1. The `add_book` method should check for the presence of all required keys in the book dictionary and raise a `ValueError` if any are missing. 2. The `search_books` method should return a list of books that match the search criteria. If no books match, it should return an empty list. 3. The `update_stock` method should take the `isbn` of the book and the new stock quantity as parameters and update the stock quantity accordingly. # Expected Input and Output: * **Input:** - `add_book`: Accepts a dictionary representing the book. - `search_books`: Accepts a string for the attribute and a string for the value to search. - `update_stock`: Accepts a string for the `isbn` and an integer for the new stock quantity. * **Output:** - `add_book`: Adds the book to the inventory and returns `None`. - `search_books`: Returns a list of dictionaries representing the books that match the search criteria. - `update_stock`: Updates the stock quantity for the specified book and returns `None`. # Constraints: * The `isbn` field is unique for each book in the inventory. * The `price` and `stock` fields are non-negative. # Example: ```python inventory = BookInventory() inventory.add_book({\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"isbn\\": \\"9780743273565\\", \\"price\\": 10.99, \\"stock\\": 5}) inventory.add_book({\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"isbn\\": \\"9780451524935\\", \\"price\\": 8.99, \\"stock\\": 3}) inventory.search_books(\\"author\\", \\"F. Scott Fitzgerald\\") # Returns: [{\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'isbn\': \'9780743273565\', \'price\': 10.99, \'stock\': 5}] inventory.update_stock(\\"9780451524935\\", 10) # The stock for \\"1984\\" is now 10. inventory.update_stock(\\"9780451524999\\", 5) # Raises ValueError: \'ISBN not found in inventory\' ``` # Hint: Ensure your class internally manages the inventory using a suitable data structure, such as a list or dictionary, to allow efficient searching and updating of book records.","solution":"class BookInventory: def __init__(self): self.inventory = [] def add_book(self, book): required_keys = {\'title\', \'author\', \'isbn\', \'price\', \'stock\'} if not required_keys.issubset(book.keys()): raise ValueError(\\"Missing required book information\\") self.inventory.append(book) def search_books(self, attribute, value): return [book for book in self.inventory if book.get(attribute) == value] def update_stock(self, isbn, new_stock): for book in self.inventory: if book.get(\\"isbn\\") == isbn: book[\'stock\'] = new_stock return raise ValueError(\\"ISBN not found in inventory\\")"},{"question":"# Question: Longest Increasing Subsequence **Context**: You are developing a recommendation system that sorts products based on their increasing popularity over time. To achieve this, you need to find the longest increasing sequence of product popularity scores. **Task**: Implement a function `longestIncreasingSubsequence` that determines the length of the longest increasing subsequence in a given list of integers representing product popularity scores. **Function signature**: ```python def longestIncreasingSubsequence(nums: List[int]) -> int: pass ``` **Input**: - `nums` (List[int]): A list of integers representing the popularity scores of products. **Output**: - Returns the length of the longest increasing subsequence of popularity scores. **Constraints**: - All input integers are non-negative. - The size of `nums` will be between 1 and 1000 inclusive. **Sample Input**: ```python nums = [10, 9, 2, 5, 3, 7, 101, 18] ``` **Sample Output**: ```python 4 ``` **Explanation**: The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4. There are other increasing subsequences such as [2, 5, 7, 18], but [2, 3, 7, 101] is the longest. This problem tests your ability to implement an algorithm for finding the longest increasing subsequence, leveraging dynamic programming or other suitable techniques.","solution":"from typing import List def longestIncreasingSubsequence(nums: List[int]) -> int: if not nums: return 0 # DP array initialized to 1 as the longest subsequence minimum length is 1 (the element itself) dp = [1] * len(nums) # Populate the dp array for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence return max(dp)"},{"question":"# Problem Statement You are tasked with developing a custom string processing module for a software application. This module requires a set of three functions for processing text in various ways. Your goal is to implement the following functions with specified behavior: 1. `reverse_words(sentence: str) -> str` 2. `camel_to_snake_case(text: str) -> str` 3. `count_vowels_consonants(text: str) -> tuple` # Function Specifications 1. reverse_words(sentence: str) -> str * Given a sentence, this function should reverse the order of the words in the sentence. * **Input**: A string representing a sentence. * **Output**: A string with the words in reverse order. Example: ```python >>> reverse_words(\\"Hello world this is a test\\") \'test a is this world Hello\' ``` 2. camel_to_snake_case(text: str) -> str * Converts a given camel case string into a snake case string. * **Input**: A camel case string. * **Output**: A snake case string. Example: ```python >>> camel_to_snake_case(\\"thisIsCamelCase\\") \'this_is_camel_case\' ``` 3. count_vowels_consonants(text: str) -> tuple * Counts the number of vowels and consonants in the given text. * **Input**: A string of text. * **Output**: A tuple containing two integers: number of vowels and number of consonants. Example: ```python >>> count_vowels_consonants(\\"Hello world\\") (3, 7) ``` # Constraints * The input sentence for `reverse_words` will contain only alphabetic characters and spaces with exactly one space between words. * The input text for `camel_to_snake_case` will only contain alphabetic characters in camel case format. * The input text for `count_vowels_consonants` can contain any printable characters, but only alphabetic characters should be considered for counting vowels and consonants. * Ensure all functions handle both lowercase and uppercase letters appropriately. * Aim for efficient implementation with clear and concise code. # Requirements 1. Implement each function adhering to the above specifications. 2. Handle edge cases such as empty strings effectively. 3. Add any necessary comments to describe the code functionality.","solution":"def reverse_words(sentence): Reverse the order of words in a given sentence. :param sentence: str :return: str return \' \'.join(sentence.split()[::-1]) def camel_to_snake_case(text): Convert camel case string to snake case string. :param text: str :return: str snake_text = \\"\\" for char in text: if char.isupper(): snake_text += \\"_\\" + char.lower() else: snake_text += char if snake_text.startswith(\\"_\\"): snake_text = snake_text[1:] return snake_text def count_vowels_consonants(text): Count the number of vowels and consonants in a given text. :param text: str :return: tuple (vowels count, consonants count) vowels = \\"aeiouAEIOU\\" count_vowels = 0 count_consonants = 0 for char in text: if char.isalpha(): # Consider only alphabetic characters if char in vowels: count_vowels += 1 else: count_consonants += 1 return count_vowels, count_consonants"},{"question":"# Context: You are developing a system for managing a school library\'s book inventory. Each book is identified by its ISBN number, and the library staff needs a utility function to convert ISBN-13 numbers to ISBN-10 numbers. This conversion is necessary for compatibility with legacy database systems. # Problem Statement: Write a function `convert_isbn13_to_isbn10(isbn13: str) -> str` that takes an ISBN-13 number as a string and returns the corresponding ISBN-10 number as a string. If the input is not a valid ISBN-13 number, the function should raise a `ValueError`. The function should follow these rules: 1. Remove the `978-` prefix from the ISBN-13 number. 2. Calculate the ISBN-10 checksum using the first 9 digits that follow the `978-` prefix. 3. Append the checksum to these 9 digits to form the ISBN-10 number. 4. The checksum is calculated as follows: - Multiply the 1st digit by 10, the 2nd digit by 9, ..., the 9th digit by 2. - Sum these products. - Compute the modulo 11 of this sum. - Subtract the result from 11 to get the checksum digit. - If the checksum is 10, use \'X\' as the checksum digit; otherwise, use the computed digit. Input and Output Formats: * **Input**: A single argument `isbn13` which is a string representing the ISBN-13 number. * **Output**: A string representing the ISBN-10 number. Constraints and Limitations: * The ISBN-13 must start with the prefix \'978-\'. * The input string should be exactly 17 characters long, excluding white spaces and hyphens. * Validate the input to ensure it is a proper ISBN-13 number. Example: ```python >>> convert_isbn13_to_isbn10(\'978-3-16-148410-0\') \'316148410X\' >>> convert_isbn13_to_isbn10(\'978-0-306-40615-7\') \'0306406152\' >>> convert_isbn13_to_isbn10(\'978-0-12-345678-9\') \'0123456789\' >>> convert_isbn13_to_isbn10(\'press-any-key-to-continue\') Traceback (most recent call last): ... ValueError: Input must be a valid ISBN-13 number >>> convert_isbn13_to_isbn10(\'123-4-567-89012-3\') Traceback (most recent call last): ... ValueError: Input must be a valid ISBN-13 number >>> convert_isbn13_to_isbn10(\'978-0-12-3456789\') Traceback (most recent call last): ... ValueError: Input must be a valid ISBN-13 number ``` # Performance Requirements: * The solution should ideally run in O(n) time complexity, where n is the length of the input string.","solution":"def convert_isbn13_to_isbn10(isbn13): Converts an ISBN-13 number to an ISBN-10 number. Parameters: isbn13 (str): The ISBN-13 number. Returns: str: The ISBN-10 number. Raises: ValueError: If the input is not a valid ISBN-13 number. if not isinstance(isbn13, str): raise ValueError(\\"Input must be a string\\") isbn13 = isbn13.replace(\\"-\\", \\"\\").replace(\\" \\", \\"\\") if len(isbn13) != 13 or not isbn13.startswith(\\"978\\"): raise ValueError(\\"Input must be a valid ISBN-13 number\\") isbn_base = isbn13[3:12] if not isbn_base.isdigit(): raise ValueError(\\"Input must be a valid ISBN-13 number\\") checksum = 0 for i, digit in enumerate(isbn_base): checksum += int(digit) * (10 - i) checksum = 11 - (checksum % 11) if checksum == 10: check_digit = \'X\' elif checksum == 11: check_digit = \'0\' else: check_digit = str(checksum) isbn10 = f\\"{isbn_base}{check_digit}\\" return isbn10"},{"question":"# Problem Statement In a distributed database system, an important task involves merging multiple sorted segments of a database that are stored on different servers into a single, globally sorted segment. Your goal is to develop an efficient function to merge these sorted segments using the **K-way merge algorithm**. Each server hosts a sorted segment represented by a list of integers. The system ensures that there is no overlap of integer values across these segments. You need to merge these segments into a single sorted list. # Function Details: **Function Name**: `k_way_merge` **Input**: - `segments`: A list of lists where each inner list contains a sorted segment of integers. **Output**: - A list of integers representing the globally sorted segment. **Constraints**: - The number of segments `k` will not exceed 10^5. - The total number of integers across all segments combined will not exceed 10^6. - Each inner list within `segments` is sorted in ascending order. - Each integer value in any inner list is unique across all segments. # Example: ```python def k_way_merge(segments: list) -> list: # Your implementation here pass # Example Test Cases print(k_way_merge([[1, 4, 6], [2, 5, 7], [3, 8, 9]])) # Expected: [1, 2, 3, 4, 5, 6, 7, 8, 9] print(k_way_merge([[10, 20], [15, 25], [30]])) # Expected: [10, 15, 20, 25, 30] print(k_way_merge([[-5, 0], [1, 2, 3]])) # Expected: [-5, 0, 1, 2, 3] print(k_way_merge([[10], [5], [3]])) # Expected: [3, 5, 10] print(k_way_merge([[1], [2], [], [3]])) # Expected: [1, 2, 3] ``` # Notes: - The function should be optimized to minimize the time complexity, making use of efficient data structures for merging. - Consider edge cases such as empty segments or when some segments are significantly larger than others.","solution":"import heapq def k_way_merge(segments: list) -> list: Merges multiple sorted segments into a single globally sorted segment. Args: segments (list): A list of lists where each inner list contains a sorted segment of integers. Returns: list: A list of integers representing the globally sorted segment. min_heap = [] result = [] # Initialize the heap with the first element of each segment along with the segment index and element index for i, segment in enumerate(segments): if segment: heapq.heappush(min_heap, (segment[0], i, 0)) while min_heap: val, seg_idx, elem_idx = heapq.heappop(min_heap) result.append(val) # If the current segment has more elements, push the next element to heap if elem_idx + 1 < len(segments[seg_idx]): next_val = segments[seg_idx][elem_idx + 1] heapq.heappush(min_heap, (next_val, seg_idx, elem_idx + 1)) return result"},{"question":"# Fibonacci Sequence Optimization Problem Statement: In this assessment, the objective is to implement an optimized version of the Fibonacci sequence generator. The classic recursive approach can be highly inefficient for larger indices due to its exponential time complexity. Your task involves improving the Fibonacci sequence computation for more substantial indices. 1. Modify the provided **fibonacci** function to use dynamic programming techniques. 2. Implement both memorization and tabulation approaches to optimize the sequence generation. Input: * A non-negative integer `n` representing the index in the Fibonacci sequence. Output: * An integer representing the Fibonacci number at the given index `n`. Constraints: * The value of `n` will not exceed 10,000. Requirements: * Your solution should not have a time complexity greater than O(n). * Use dynamic programming techniques to avoid redundant calculations. * Ensure your implementation handles large values of `n` efficiently. Example: ```python Input: 10 Output: 55 Input: 20 Output: 6765 ``` Hints: 1. Use an array or a dictionary to store previously computed Fibonacci numbers to save time on repeated calculations. 2. Consider both space and time efficiency when choosing between memorization and tabulation methods.","solution":"def fibonacci_memorization(n, memo=None): if memo is None: memo = {} if n in memo: return memo[n] if n <= 1: return n memo[n] = fibonacci_memorization(n-1, memo) + fibonacci_memorization(n-2, memo) return memo[n] def fibonacci_tabulation(n): if n <= 1: return n table = [0] * (n + 1) table[1] = 1 for i in range(2, n + 1): table[i] = table[i-1] + table[i-2] return table[n]"},{"question":"# Task: Implement an Integer Array Sorting Function You are tasked with implementing a function that sorts a given list of integers using the QuickSort algorithm. The function should return the sorted list. Function Signature ```python def quicksort(arr: list) -> list: ``` # Input * `arr`: A list of integers which may contain both positive and negative numbers. # Output * A sorted list of integers in ascending order. # Constraints * The input list will have a length between 1 and 10^5. * Each integer in the list will be between -10^6 and 10^6. # Performance Requirements * Your solution should run in O(n log n) on average time complexity, where n is the length of the list. # Example ```python >>> quicksort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quicksort([-3, -9, 0, -2, 5]) [-9, -3, -2, 0, 5] >>> quicksort([1, 4, 3, 9, 8, 7, 5, 6, 2]) [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Notes * You may use helper functions if needed. * Do not use any built-in sorting functions. * Assume that the input list is given and not `None`. * Focus on the recursion and partitioning aspects to implement the QuickSort algorithm effectively.","solution":"def quicksort(arr): Implements the QuickSort algorithm to sort a list of integers. Args: - arr: List of integers to be sorted. Returns: - List of integers sorted in ascending order. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"# Problem Statement Given a sorted array `arr` containing `n` unique integers, write a function `find_missing_element(arr: List[int], start: int, end: int) -> int:` that finds the missing number within the range `[start, end]`. # Inputs - A sorted list of integers `arr` of length ( n-1 ) where ( 1 leq n leq 10^5 ). - Two integers `start` and `end` where ( 1 leq start < end leq 10^6 ). # Outputs - Returns the missing integer within the range `[start, end]`. - If there is no missing number in the range, return -1. # Constraints & Performance - ( 1 leq n-1 leq 100000 ) - Time Complexity: Ideally O(log n) due to the sorted nature of the array. - Space Complexity: O(1) # Scenario for Context You are given a list representing a sequence of numbers within a specific range except for one missing number. Your task is to identify that missing number efficiently. # Sample Tests **Input:** ```python assert find_missing_element([1, 2, 3, 4, 6], 1, 6) == 5 assert find_missing_element([10, 11, 13, 14, 15], 10, 15) == 12 assert find_missing_element([21, 22, 23, 24, 25], 21, 25) == -1 assert find_missing_element([101, 102, 104, 105], 101, 105) == 103 ``` **Explanation:** - For the range 1 to 6, the number 5 is missing from the array `[1, 2, 3, 4, 6]`. - For the range 10 to 15, the number 12 is missing from the array `[10, 11, 13, 14, 15]`. - For the range 21 to 25, there is no missing number in the complete array `[21, 22, 23, 24, 25]`, so the function returns -1. - For the range 101 to 105, the number 103 is missing from the array `[101, 102, 104, 105]`.","solution":"def find_missing_element(arr, start, end): Given a sorted array `arr` containing `n-1` unique integers within the range `[start, end]`, find the missing integer. Return the missing integer or -1 if no integer is missing. # Calculate the expected sum of the numbers from start to end expected_sum = (end * (end + 1)) // 2 - ((start - 1) * start) // 2 # Calculate the actual sum of numbers in the array actual_sum = sum(arr) # The missing number is the difference between the expected sum and the actual sum missing_number = expected_sum - actual_sum # If the missing number is within the range, return it if start <= missing_number <= end: return missing_number # If no number is missing in the range return -1"},{"question":"# Coding Assessment Question Problem Statement You need to implement a function that simulates the dining philosophers problem using multithreading. Your task is to ensure that the solution avoids deadlock and starvation. Your solution should allow multiple philosophers to dine but ensure that only one philosopher can access each fork at a time. Function Signature ```python import threading class DiningPhilosophers: def __init__(self): # initialization pass def wants_to_eat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork): This function will be called by the philosopher thread to simulate the action. Parameters: philosopher (int): The philosopher number from 0 to 4. pickLeftFork (function): An action to pick the left fork. pickRightFork (function): An action to pick the right fork. eat (function): An action to eat. putLeftFork (function): An action to put the left fork down. putRightFork (function): An action to put the right fork down. # your code here ``` Input Format Your function should handle no direct input, all the required initialization and calling of `wants_to_eat` should be managed by the threads. Output Format Your function will not return any output but should correctly simulate the dining philosophers\' actions. Constraints - There are 5 philosophers numbered from 0 to 4. - Each philosopher can only pick up their left and right forks. - A philosopher cannot pick up a fork that is already in use by another philosopher. - The forks are arranged in a circular manner where the fork of philosopher (i)\'s left side is fork (i) and the fork on the right side is fork ((i+1) % 5). Example Simulate the dining philosophers problem using the provided function signature: ```python def pickLeftFork(): print(\\"picked left fork\\") def pickRightFork(): print(\\"picked right fork\\") def eat(): print(\\"eating\\") def putLeftFork(): print(\\"put left fork\\") def putRightFork(): print(\\"put right fork\\") philosophers = DiningPhilosophers() def philosopher_thread(id): philosophers.wants_to_eat(id, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) for i in range(5): threading.Thread(target=philosopher_thread, args=(i,)).start() ``` This example should ensure correctness by demonstrating each philosopher\'s actions without creating a deadlock and properly sharing the forks between them. # NOTES: 1. You need to ensure that the implementation of the solution using multiple threads works correctly. 2. Remember to manage synchronization to avoid potential race conditions and to prevent deadlocks.","solution":"import threading class DiningPhilosophers: def __init__(self): self.forks = [threading.Lock() for _ in range(5)] self.lock = threading.Lock() def wants_to_eat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork): leftFork = philosopher rightFork = (philosopher + 1) % 5 with self.lock: self.forks[leftFork].acquire() self.forks[rightFork].acquire() pickLeftFork() pickRightFork() eat() putLeftFork() putRightFork() self.forks[rightFork].release() self.forks[leftFork].release()"},{"question":"# Matrix Operations You are responsible for extending the functionality of a `Matrix` class. In particular, you need to implement the following methods: 1. **Matrix Determinant**: * Implement a method `determinant` that calculates the determinant of a given n x n matrix. * The determinant for a 2x2 matrix `[[a, b], [c, d]]` is `ad - bc`. For larger matrices, use the Laplace expansion (recursive definition). * **Input**: A `Matrix` object. * **Output**: A float representing the determinant of the matrix. 2. **Matrix Transpose**: * Implement a method `transpose` that returns the transpose of a matrix. * **Input**: A `Matrix` object. * **Output**: A new `Matrix` object representing the transposed matrix. **Function Signatures**: ```python def determinant(self) -> float: ... def transpose(self) -> Matrix: ... ``` **Constraints**: 1. For determinant: - The input matrix must be square (number of rows equals number of columns). - Raise an exception if the matrix is not square. 2. For transpose: - No special constraints beyond a standard matrix. **Example Usage**: ```python matrix1 = Matrix([[1, 2], [3, 4]]) # Determinant result_determinant = matrix1.determinant() print(result_determinant) # Output: -2.0 # Transpose result_transpose = matrix1.transpose() print(result_transpose) # Output: Matrix([[1, 3], [2, 4]]) ``` **Edge Cases**: Ensure your solution handles edge cases such as: - Very small or very large matrices. - Matrices with zero rows or zero columns. - Matrices with identical rows or columns which may lead to a zero determinant. --- Ensure you test your implementation thoroughly to cover various edge cases and input scenarios.","solution":"class Matrix: def __init__(self, elements): self.elements = elements self.rows = len(elements) self.cols = len(elements[0]) if elements else 0 def determinant(self) -> float: if self.rows != self.cols: raise ValueError(\\"Matrix must be square to calculate determinant.\\") if self.rows == 2: return self.elements[0][0] * self.elements[1][1] - self.elements[0][1] * self.elements[1][0] det = 0 for c in range(self.cols): det += ((-1) ** c) * self.elements[0][c] * self._minor(0, c).determinant() return det def _minor(self, row, col): minor = [r[:col] + r[col + 1:] for r in (self.elements[:row] + self.elements[row + 1:])] return Matrix(minor) def transpose(self): transposed_elements = [[self.elements[j][i] for j in range(self.rows)] for i in range(self.cols)] return Matrix(transposed_elements) def __eq__(self, other): return self.elements == other.elements def __repr__(self): return f\\"Matrix({self.elements})\\""},{"question":"# Problem Context In many statically-typed programming languages, working with strings often involves manipulating sequences of characters, such as reversing them, changing their case, or removing certain characters. Your task involves creating a function that transforms a given string by rearranging its words and adjusting their cases according to specified rules. # Problem Statement You need to write a function `transform_string(s: str) -> str` that takes a single string `s`, reverses the order of words in the string, and changes each word\'s case (uppercase to lowercase and vice versa). # Function Signature ```python def transform_string(s: str) -> str: # your code here ``` # Input - A single string `s` containing only alphabetic characters and spaces. The string will not contain leading or trailing spaces, and words will be separated by a single space. (`1 <= len(s) <= 10^4`) # Output - A string with the words in reversed order and each character\'s case transformed. # Constraints - The input string `s` will only contain alphabetic characters (a-z, A-Z) and spaces. - The input string will have at least one word. # Examples ```python assert transform_string(\\"Hello World\\") == \\"wORLD hELLO\\" assert transform_string(\\"Python coding IS FUN\\") == \\"fun is CODING pYTHON\\" assert transform_string(\\"Example String\\") == \\"sTRING eXAMPLE\\" assert transform_string(\\"a\\") == \\"A\\" assert transform_string(\\"a B cD\\") == \\"Cd b A\\" ``` # Edge Cases to Consider 1. When the input string contains only one word, reversing it should have no effect, but the case of each character should still be changed. 2. When all characters in the string are already in uppercase or lowercase, ensure that the case transformation is applied consistently. 3. Very short and very long strings should be handled efficiently. The provided function should adhere to the rules, identifying the transformations accurately while maintaining clarity and consistency in the output.","solution":"def transform_string(s: str) -> str: Transforms the input string by reversing the order of words and changing each character\'s case. :param s: A string containing only alphabetic characters and spaces. :return: A transformed string with words in reversed order and case of each character changed. # Split the string into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Function to change the case of each character in a word def change_case(word): return \'\'.join([char.lower() if char.isupper() else char.upper() for char in word]) # Apply the case change to each word in the reversed list transformed_words = [change_case(word) for word in reversed_words] # Join the transformed words into a single string with spaces return \' \'.join(transformed_words)"},{"question":"# Film Database Search Implementation You are given a dataset containing information about a collection of films. Each film is represented as a dictionary with keys \\"title\\", \\"year\\", and \\"rating\\". Your task is to implement a search function that can retrieve films based on specified criteria. Instructions 1. **Define a `FilmDatabase` class:** - The class should store a list of films, where each film is represented as a dictionary. - Implement methods: - `add_film`: to add a new film to the database. - `find_by_title`: to find films by title (exact match). - `find_by_year`: to find films released in a specific year. - `find_by_rating`: to find films with a rating equal to or higher than a specified value. 2. **Define the `search_films` function:** - Takes the list of films and criteria in the form of a dictionary as input. - Constructs a `FilmDatabase` by adding all films. - Depending on the criteria provided, perform the appropriate search and return the list of matched films. Function Signature ```python def search_films(films: list[dict], criteria: dict) -> list[dict]: pass ``` Examples ```python films = [ {\\"title\\": \\"Inception\\", \\"year\\": 2010, \\"rating\\": 8.8}, {\\"title\\": \\"The Matrix\\", \\"year\\": 1999, \\"rating\\": 8.7}, {\\"title\\": \\"Interstellar\\", \\"year\\": 2014, \\"rating\\": 8.6}, {\\"title\\": \\"Shutter Island\\", \\"year\\": 2010, \\"rating\\": 8.1} ] criteria = {\\"title\\": \\"Inception\\"} search_films(films, criteria) -> [{\'title\': \'Inception\', \'year\': 2010, \'rating\': 8.8}] criteria = {\\"year\\": 2010} search_films(films, criteria) -> [{\'title\': \'Inception\', \'year\': 2010, \'rating\': 8.8}, {\'title\': \'Shutter Island\', \'year\': 2010, \'rating\': 8.1}] criteria = {\\"rating\\": 8.7} search_films(films, criteria) -> [{\'title\': \'Inception\', \'year\': 2010, \'rating\': 8.8}, {\'title\': \'The Matrix\', \'year\': 1999, \'rating\': 8.7}] ``` Constraints - The input list may contain up to 10^4 films. - Each film dictionary will contain the keys \\"title\\", \\"year\\", and \\"rating\\". - The \\"title\\" is a non-empty string. - The \\"year\\" is an integer between 1900 and 2100. - The \\"rating\\" is a floating-point number between 0.0 and 10.0. Performance Expectations - The search operations should be optimized for quick retrieval. - Aim for efficient handling of 10^4 search queries. **Edge Cases**: - Handle cases where no films match the given criteria. - Ensure proper handling of different types of search criteria (title, year, rating). - Consider scenarios where the criteria are not provided (an empty dictionary).","solution":"class FilmDatabase: def __init__(self): self.films = [] def add_film(self, film): self.films.append(film) def find_by_title(self, title): return [film for film in self.films if film[\'title\'] == title] def find_by_year(self, year): return [film for film in self.films if film[\'year\'] == year] def find_by_rating(self, rating): return [film for film in self.films if film[\'rating\'] >= rating] def search_films(films, criteria): db = FilmDatabase() for film in films: db.add_film(film) if \'title\' in criteria: return db.find_by_title(criteria[\'title\']) elif \'year\' in criteria: return db.find_by_year(criteria[\'year\']) elif \'rating\' in criteria: return db.find_by_rating(criteria[\'rating\']) else: return db.films"},{"question":"# Problem Statement You are given a string containing a mix of characters and spaces, representing a sentence. Your task is to write a function `reverse_words_and_uppercase` that reverses each word in the sentence individually and converts each word to uppercase. # Input * A string, `sentence`, where (1 leq text{len(sentence)} leq 10^5). The string only contains spaces and alphanumeric characters, and words are separated by a single space. # Output * Return a string where each word in the input string is reversed and converted to uppercase. # Function Signature ```python def reverse_words_and_uppercase(sentence: str) -> str: pass ``` # Constraints * You must preserve the original spacing between words. * Each word should be reversed before being converted to uppercase. # Example ```python >>> reverse_words_and_uppercase(\\"Hello world\\") \\"OLLEH DLROW\\" >>> reverse_words_and_uppercase(\\"coding is fun\\") \\"GNIDOC SI NUF\\" >>> reverse_words_and_uppercase(\\"a b cdef\\") \\"A B FEDC\\" ``` # Detailed Explanation * Split the input string into words based on the spaces. * Reverse each word and convert it to uppercase. * Join the transformed words with a single space to form the final result. * The function should handle large inputs efficiently and maintain linear time complexity relative to the length of the input string.","solution":"def reverse_words_and_uppercase(sentence: str) -> str: Given a string containing a mix of characters and spaces, this function reverses each word in the sentence individually and converts each word to uppercase. :param sentence: A string containing words separated by a single space. :return: A string with each word reversed and converted to uppercase. words = sentence.split() reversed_uppercase_words = [word[::-1].upper() for word in words] return \' \'.join(reversed_uppercase_words)"},{"question":"# Scenario You are developing a data processing application that involves managing user data in a relational database. To improve the performance and consistency of database operations, you decide to create a caching strategy. The strategy uses a Least Recently Used (LRU) cache to store results of frequent queries and user records. # Task Implement the `LRUCache` class to manage the cache. The cache should have a fixed capacity and operate on a Least Recently Used eviction policy. # Details 1. **Class `LRUCache` Implementation**: * Initialize the cache with a specified capacity. * Provide methods: - `get(key: int) -> int`: Retrieve the value associated with the `key` if it exists in the cache, otherwise return `-1`. - `put(key: int, value: int)`: Insert or update the `key-value` pair in the cache. If the cache exceeds its capacity, evict the least recently used item before inserting the new item. 2. **Capacity Management**: * Ensure that insertion or update actions keep the total number of items within the set capacity. * Efficiently manage the accessed and insertion order to implement the LRU policy. # Input * `key`: Integer representing the unique identifier of the cache entry. * `value`: Integer representing the data to be cached. # Output * For the `get` method, return the value associated with the `key` if it exists, otherwise return `-1`. * For the `put` method, there is no return value. Ensure the cache is updated according to the LRU policy. # Constraints * Cache size should be a positive integer and at most 10^4. * `key` and `value` should be non-negative integers up to 10^5. # Example ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Returns 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Returns -1 (not found) cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4 ``` # Notes 1. Implement error handling for invalid cache size during initialization. 2. Ensure the cache operations are optimized for time complexity, ideally O(1) for both `get` and `put` operations.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): if capacity <= 0: raise ValueError(\\"Cache capacity must be positive\\") self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: value = self.cache.pop(key) self.cache[key] = value # re-insert the item to mark it as recently used return value def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # remove the first item (least recently used) self.cache[key] = value"},{"question":"# Coding Assessment Question Scenario You are developing a financial application that requires tracking and managing user transactions. Each user can perform deposit, withdrawal, and balance inquiry operations. The system should handle these operations efficiently while maintaining the consistency of each user\'s account balance. Task You are required to write a function that processes a sequence of operations on a collection of user accounts. Each operation will be one of the following: - Creating a new user account with an initial balance. - Depositing a certain amount to an existing user\'s account. - Withdrawing a certain amount from an existing user\'s account. - Querying the current balance of an existing user\'s account. Function Signature ```python def process_financial_operations(operations: List[Tuple[str, Union[int, Tuple[int, int]]]]) -> List[int]: Processes a sequence of financial operations and returns results of balance inquiries. :param operations: A list of tuples where each tuple represents an operation. - \\"create\\", (user_id, initial_balance): Creates a user account with the specified initial balance. - \\"deposit\\", (user_id, amount): Deposits the specified amount to the user\'s account. - \\"withdraw\\", (user_id, amount): Withdraws the specified amount from the user\'s account. - \\"balance\\", user_id: Returns the current balance of the user\'s account. :return: A list of balances corresponding to \\"balance\\" operations in the order they were requested. ``` Constraints 1. The `user_id` is guaranteed to be unique for each user account creation. 2. The `operations` list will contain up to (10^5) operations. 3. Amounts for deposits and withdrawals are positive integer values. 4. Withdrawals will not result in a negative balance. Example Given the following operations: ```python operations = [ (\\"create\\", (1, 100)), (\\"create\\", (2, 200)), (\\"deposit\\", (1, 50)), (\\"withdraw\\", (2, 100)), (\\"balance\\", 1), (\\"balance\\", 2) ] ``` The function should return: `[150, 100]` because user 1\'s balance after depositing 50 is 150, and user 2\'s balance after withdrawing 100 from 200 is 100.","solution":"def process_financial_operations(operations): Processes a sequence of financial operations and returns results of balance inquiries. :param operations: A list of tuples where each tuple represents an operation. - \\"create\\", (user_id, initial_balance): Creates a user account with the specified initial balance. - \\"deposit\\", (user_id, amount): Deposits the specified amount to the user\'s account. - \\"withdraw\\", (user_id, amount): Withdraws the specified amount from the user\'s account. - \\"balance\\", user_id: Returns the current balance of the user\'s account. :return: A list of balances corresponding to \\"balance\\" operations in the order they were requested. accounts = {} results = [] for op in operations: if op[0] == \\"create\\": user_id, initial_balance = op[1] accounts[user_id] = initial_balance elif op[0] == \\"deposit\\": user_id, amount = op[1] if user_id in accounts: accounts[user_id] += amount elif op[0] == \\"withdraw\\": user_id, amount = op[1] if user_id in accounts and accounts[user_id] >= amount: accounts[user_id] -= amount elif op[0] == \\"balance\\": user_id = op[1] if user_id in accounts: results.append(accounts[user_id]) return results"},{"question":"# Question: Optimize Product Listings # Context: E-commerce platforms often need to showcase products in a way that maximizes user engagement and sales. One such strategy is to sort products based on a specific criterion, such as price, customer rating, or relevance. Given a list of products, each with a name and a numerical score (higher values are better), the task is to sort the products in descending order of their scores. # Task: Implement a function `sort_products` that sorts a list of products by their scores in descending order. # Function Signature: ```python def sort_products(products: list[tuple[str, float]]) -> list[tuple[str, float]]: pass ``` # Input: * `products` (list of tuples): A list of tuples where each tuple contains: * A product name (string, 1 <= len <= 100). * A numeric score (float, -1000 <= score <= 1000). # Output: * A list of tuples sorted in descending order by score. * If two products have the same score, they should be returned in the order they appeared in the input list. # Constraints: * The number of products will be between 1 and 10^5. * Product names will contain only alphanumeric characters and spaces. # Example: ```python >>> sort_products([(\\"ProductA\\", 4.5), (\\"ProductB\\", 3.6), (\\"ProductC\\", 4.5), (\\"ProductD\\", 5.0)]) [(\'ProductD\', 5.0), (\'ProductA\', 4.5), (\'ProductC\', 4.5), (\'ProductB\', 3.6)] >>> sort_products([(\\"ProductA\\", -1.2), (\\"ProductB\\", -1.3), (\\"ProductC\\", 0.0), (\\"ProductD\\", 3.3)]) [(\'ProductD\', 3.3), (\'ProductC\', 0.0), (\'ProductA\', -1.2), (\'ProductB\', -1.3)] ``` # Notes: * Ensure your implementation is efficient enough to handle large input sizes. * Maintain the relative ordering of products with the same score as in the input list.","solution":"def sort_products(products: list[tuple[str, float]]) -> list[tuple[str, float]]: Sort a list of products by their scores in descending order. If two products have the same score, they remain in the order they appeared in the input list. Parameters: products (list): A list of tuples where each tuple contains: a product name (string) and a numeric score (float). Returns: list: A list of tuples sorted in descending order by score. return sorted(products, key=lambda x: x[1], reverse=True)"},{"question":"# Question: Basic In-Memory Cache Implementation Context: You are required to implement a basic in-memory cache system that supports a fixed size with a least recently used (LRU) eviction policy. The cache should store key-value pairs and provide quick access to the values based on their keys. When the cache exceeds its fixed size, it should remove the least recently used (LRU) item to make space for new entries. Requirements: 1. **Class Definition**: - Implement a class `LRUCache` with the following method signatures: ```python def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` 2. **Input and Output Formats**: - `__init__` method initializes the cache with the specified capacity. - `get` method returns the value associated with the key if present in the cache, otherwise returns -1. - `put` method inserts or updates the key-value pair in the cache. If the cache reaches its capacity, it should evict the LRU item. 3. **Constraints**: - The cache should operate close to O(1) time complexity for both `get` and `put` operations. - Keys and values are non-negative integers. - Capacity is a positive integer. - If a `put` operation includes a key that already exists in the cache, update its value and mark it as recently used. 4. **Performance Requirements**: - Ensure your cache handles operations efficiently to simulate a real-time cache. Example Usage: ```python # Initialize the cache with capacity 2. cache = LRUCache(2) # Cache is {1=1} cache.put(1, 1) # Cache is {1=1, 2=2} cache.put(2, 2) # Returns 1 as key 1 is present in cache assert cache.get(1)==1 # Cache is ordered as {2=2, 1=1} since 1 was recently accessed # Add key-value pair and evict LRU, which is now 2 # Cache is {1=1, 3=3} cache.put(3, 3) # Returns -1 as key 2 was evicted assert cache.get(2)==-1 # Returns 3 assert cache.get(3)==3 # Updates value and order as 3 is accessed, ordered as {1=1, 3=3} # Add key and evict LRU which is now 1 # Cache is {3=3, 4=4} cache.put(4, 4) # Returns -1 as key 1 was evicted assert cache.get(1)==-1 # Returns 3 assert cache.get(3)==3 # Returns 4 assert cache.get(4)==4 ``` Instructions: 1. Implement the `LRUCache` class with the specified methods. 2. Ensure that `get` and `put` operations maintain the correct ordering for eviction. 3. Verify your implementation through the provided assertions. 4. Handle invalid operations appropriately, ensuring the evictions follow LRU policy accurately. Output your implementation in the cell provided below: ```python class LRUCache: def __init__(self, capacity: int): self.cache = {} # dictionary to hold key-value pairs self.capacity = capacity self.order = [] # list to maintain access order def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) # remove and append to mark as recently used self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) == self.capacity: lru = self.order.pop(0) # remove the least recently used del self.cache[lru] self.cache[key] = value self.order.append(key) ```","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} # dictionary to hold key-value pairs self.capacity = capacity self.order = [] # list to maintain access order def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) # remove and append to mark as recently used self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) == self.capacity: lru = self.order.pop(0) # remove the least recently used del self.cache[lru] self.cache[key] = value self.order.append(key)"},{"question":"# Coding Assessment Question Scenario Your team is tasked with developing a budgeting and expense tracking system that helps users categorize their daily expenses efficiently. Each user can add expenses, categorized as either \'food\', \'transport\', or \'entertainment\'. The system needs to generate a summary of expenses over a period of time, ensuring that each category\'s total expenses are accounted for accurately. Your task is to implement a function that takes a list of expenses and a specific category, then returns the total expenditure for that category. Each expense entry contains a category and an amount spent. Function Definition Write a function `calculate_total(expenses: List[Dict[str, Union[str, float]]], category: str) -> float` that takes a list of expense dictionaries and a category string, then returns the total expenditure for that category. Input * `expenses` (List[Dict[str, Union[str, float]]]): A list of dictionaries where each dictionary represents an expense with two keys: - `category` (str): The category of the expense (\'food\', \'transport\', \'entertainment\'). - `amount` (float): The amount spent on the expense. * `category` (str): The category for which to calculate the total expenditure (\'food\', \'transport\', or \'entertainment\'). Output * (float): The total expenditure for the specified category. Example ```python >>> expenses = [ ... {\\"category\\": \\"food\\", \\"amount\\": 15.50}, ... {\\"category\\": \\"transport\\", \\"amount\\": 8.00}, ... {\\"category\\": \\"food\\", \\"amount\\": 25.00}, ... {\\"category\\": \\"entertainment\\", \\"amount\\": 20.00}, ... {\\"category\\": \\"transport\\", \\"amount\\": 5.50} ... ] >>> calculate_total(expenses, \\"food\\") 40.50 >>> calculate_total(expenses, \\"transport\\") 13.50 >>> calculate_total(expenses, \\"entertainment\\") 20.00 ``` Constraints * The list of expenses can contain up to 10000 expense entries. * Each category string is guaranteed to be either \'food\', \'transport\', or \'entertainment\'. * The amount spent is guaranteed to be a non-negative float. Performance Requirements Your solution should efficiently handle the upper limit of the expense entries (up to 10000 entries). Edge Cases to Consider * If no expenses for the given category exist, the result should be 0.","solution":"from typing import List, Dict, Union def calculate_total(expenses: List[Dict[str, Union[str, float]]], category: str) -> float: Calculate the total expenditure for a given category. :param expenses: List of dictionaries representing individual expenses. :param category: The category for which to calculate the total expenditure. :return: Total expenditure for the specified category. total = 0.0 for expense in expenses: if expense[\'category\'] == category: total += expense[\'amount\'] return total"},{"question":"# Custom N-gram Language Model **Objective**: Develop a function to build an n-gram model for text prediction and use it to generate a sequence of words based on given input. # Background An n-gram model is a type of probabilistic language model that predicts the next item in a sequence based on the previous n-1 items. It can be used for various NLP tasks such as text generation, speech recognition, and more. # Problem Statement You need to implement a function `generate_text` that builds an n-gram model from the given text data and generates new text based on a provided seed sequence. # Function Signature ```python def generate_text(text_data: str, n: int, seed: str, num_words: int) -> str: Generate text using an n-gram model. Args: text_data (str): The input text data used to build the n-gram model. n (int): The number of grams (n) to consider. seed (str): The seed sequence from which text generation will start. num_words (int): The number of words to generate. Returns: str: The generated text. pass ``` # Input 1. `text_data` (str): A string containing the text data used to build the n-gram model. 2. `n` (int): The number of grams (n) to use in the model (e.g., 2 for bigrams, 3 for trigrams). 3. `seed` (str): The initial sequence of words to start the generation (must contain n-1 words). 4. `num_words` (int): The number of words to generate. # Output A string containing the generated sequence of words. # Example ```python text_data = \\"the quick brown fox jumps over the lazy dog the quick brown fox jumps over the quick brown dog\\" n = 3 seed = \\"the quick\\" num_words = 5 output = generate_text(text_data, n, seed, num_words) print(output) # Output: \\"the quick brown fox jumps over\\" ``` # Constraints 1. The text data must contain at least `n` words. 2. The seed sequence must contain `n-1` words and must be found in the text data. 3. Ensure the function can handle large text data efficiently. # Performance Requirements Your implementation should be efficient enough to handle large text corpora. Use appropriate data structures to store and retrieve n-grams quickly to ensure performance and scalability. Consider handling edge cases such as very small text data or absent seed sequences. **Hint**: Use a dictionary to map n-gram prefixes to possible suffixes and count their occurrences to decide the next word in the generated text.","solution":"import random from collections import defaultdict, Counter def generate_text(text_data: str, n: int, seed: str, num_words: int) -> str: Generate text using an n-gram model. Args: text_data (str): The input text data used to build the n-gram model. n (int): The number of grams (n) to consider. seed (str): The seed sequence from which text generation will start. num_words (int): The number of words to generate. Returns: str: The generated text. if n <= 1: raise ValueError(\\"n must be greater than 1.\\") words = text_data.split() if len(words) < n: raise ValueError(\\"Text data must contain at least n words.\\") seed_words = seed.split() if len(seed_words) != n - 1: raise ValueError(\\"Seed sequence must contain exactly n-1 words.\\") # Build the n-gram model ngrams = defaultdict(Counter) for i in range(len(words) - n + 1): gram = tuple(words[i:i + n - 1]) next_word = words[i + n - 1] ngrams[gram][next_word] += 1 # Generate text using the seed current_gram = tuple(seed_words) generated_words = list(current_gram) for _ in range(num_words): possible_next_words = ngrams[current_gram] if not possible_next_words: break next_word = random.choices(list(possible_next_words.keys()), list(possible_next_words.values()))[0] generated_words.append(next_word) current_gram = tuple(generated_words[-(n - 1):]) return \' \'.join(generated_words)"},{"question":"# Coding Assessment Question Task Write a function that, given a positive integer `n`, generates a list of all possible variations of binary strings of length `n` such that no two consecutive `1`s appear in any string. Your function should return the list of these binary strings in lexicographical order. Function Signature ```python def generate_binary_strings(n: int) -> List[str]: ``` # Input - `n` (int): The length of the binary strings. # Output - `List[str]`: A list containing all binary strings of length `n` with no two consecutive `1`s, sorted in lexicographical order. # Constraints - 1 ≤ n ≤ 20 # Requirements * Each string in the result must be exactly `n` characters long. * No string should contain the substring \\"11\\". # Example Here are examples of how your function might be called and the expected outputs: ```python assert generate_binary_strings(1) == [\'0\', \'1\'] assert generate_binary_strings(2) == [\'00\', \'01\', \'10\'] assert generate_binary_strings(3) == [\'000\', \'001\', \'010\', \'100\', \'101\'] ``` # Notes * Ensure that the output list is in lexicographical order. * Consider edge cases where `n` is very small or very large within the given constraints. * You may not use built-in functions that would trivialize generating all legal combinations directly.","solution":"from typing import List def generate_binary_strings(n: int) -> List[str]: Generates a list of all possible variations of binary strings of length n such that no two consecutive 1\'s appear in any string. The list is sorted in lexicographical order. def backtrack(so_far: str): # Base case: if the current string is of length n, add it to the results if len(so_far) == n: result.append(so_far) return # Recursive case: add \'0\' or \'1\' to the current string if valid backtrack(so_far + \'0\') if not so_far or so_far[-1] != \'1\': # Ensure no two consecutive \'1\'s backtrack(so_far + \'1\') result = [] backtrack(\\"\\") return sorted(result) # sort results lexicographically before returning"},{"question":"# Coding Assessment Task: Context: You are a software developer working on a project that involves processing large sets of scientific data. To ensure that the data is stored efficiently, you need to implement a custom compression algorithm. Your task is to create a function that compresses a given input string using a basic run-length encoding (RLE) algorithm. Problem Statement: Implement a function `run_length_encode` that compresses a given string using run-length encoding. The function should return the encoded string. Run-length encoding works by representing consecutive repeated characters as a single character followed by the number of repetitions. For example, the string \\"aaabbc\\" would be encoded as \\"a3b2c1\\". Function Signature: ```python def run_length_encode(input_string: str) -> str: pass ``` Input/Output: * **Input**: A string `input_string` containing only uppercase and lowercase alphabetic characters. * **Output**: A string representing the run-length encoded version of the input. Constraints: - The input string will have a length between 1 and 10^4. - The input string will contain only uppercase (A-Z) and lowercase (a-z) letters. Examples: ```python >>> run_length_encode(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> run_length_encode(\\"abcdef\\") \\"a1b1c1d1e1f1\\" >>> run_length_encode(\\"WWWWWWBBBBBWWWW\\") \\"W6B5W4\\" ``` Notes: 1. Ensure that your solution is efficient and handles the maximum input length constraint within acceptable runtime limits. 2. Consider edge cases such as an input string with only one type of character.","solution":"def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: encoded_string.append(previous_char + str(count)) previous_char = char count = 1 # Append the last accumulated character and its count encoded_string.append(previous_char + str(count)) return \'\'.join(encoded_string)"},{"question":"# Problem You are tasked with implementing a function to simulate a simple traffic light system at an intersection consisting of four directions. Each traffic light can be either RED or GREEN, and the system changes the lights according to predefined rules for a given number of cycles. # Function Signature ```python def traffic_light_simulation( initial_lights: dict, green_duration: int, red_duration: int, cycles: int ) -> dict: pass ``` # Parameters - **initial_lights** `(dict)` : A dictionary representing the initial direction of the traffic lights and their states at the start of the simulation. The dictionary has four keys: `\'north\'`, `\'south\'`, `\'east\'`, `\'west\'`, each mapping to either `\'GREEN\'` or `\'RED\'`. - **green_duration** `(int)` : Duration (in cycles) that a traffic light remains green before switching to red (1 ≤ green_duration ≤ 100). - **red_duration** `(int)` : Duration (in cycles) that a traffic light remains red before switching to green (1 ≤ red_duration ≤ 100). - **cycles** `(int)` : Number of cycles the simulation should run (1 ≤ cycles ≤ 1000). # Returns - **result** `(dict)` : A dictionary representing the final state of the traffic lights, with keys `\'north\'`, `\'south\'`, `\'east\'`, `\'west\'` mapping to their final states (`\'GREEN\'` or `\'RED\'`). # Detailed Requirements 1. **Initialization**: - The traffic light system starts with the states provided in the `initial_lights` dictionary. 2. **Simulation Loop**: - For each cycle, update the state of each traffic light according to the durations provided: - A light that is currently GREEN will switch to RED after `green_duration` cycles. - A light that is currently RED will switch to GREEN after `red_duration` cycles. - The changes are simultaneous for all directions. 3. **Return Final States**: - After all cycles have been processed, return the states of the traffic lights. # Example ```python initial_lights = { \\"north\\": \\"GREEN\\", \\"south\\": \\"RED\\", \\"east\\": \\"GREEN\\", \\"west\\": \\"RED\\" } green_duration = 5 red_duration = 7 cycles = 10 result = traffic_light_simulation( initial_lights, green_duration, red_duration, cycles ) print(result) # Output: {\'north\': \'RED\', \'south\': \'GREEN\', \'east\': \'RED\', \'west\': \'GREEN\'} ``` In this example, the system alternates the traffic lights every `green_duration` cycles if they are green, and every `red_duration` cycles if they are red. The final states of the traffic lights are represented in the resulting dictionary after the simulation runs for `cycles` cycles.","solution":"def traffic_light_simulation(initial_lights: dict, green_duration: int, red_duration: int, cycles: int) -> dict: Simulates a traffic light system for a given number of cycles. Args: initial_lights (dict): Initial states of the traffic lights. green_duration (int): Duration that a traffic light remains green. red_duration (int): Duration that a traffic light remains red. cycles (int): Number of cycles the simulation should run. Returns: dict: Final states of the traffic lights. lights = initial_lights.copy() last_switched = {direction: 0 for direction in lights} for cycle in range(1, cycles + 1): for direction, state in lights.items(): if state == \\"GREEN\\" and (cycle - last_switched[direction]) >= green_duration: lights[direction] = \\"RED\\" last_switched[direction] = cycle elif state == \\"RED\\" and (cycle - last_switched[direction]) >= red_duration: lights[direction] = \\"GREEN\\" last_switched[direction] = cycle return lights"},{"question":"# Find Missing Number in Arithmetic Progression Problem Statement Given a list of `n` integers that form an arithmetic progression but are missing exactly one element, write a function `find_missing_number(arr: List[int]) -> int` that identifies and returns the missing number. The arithmetic progression is defined by its first element and a common difference `d`. Function Signature ```python def find_missing_number(arr: List[int]) -> int: ``` Input - `arr`: A list of `n` integers representing an incomplete arithmetic progression where exactly one number is missing. Output - An integer representing the missing number in the arithmetic progression. Constraints - The list `arr` will have at least 3 elements and no more than (10^5) elements. - All elements in `arr` are distinct. - The common difference `d` is a non-zero integer. Example ```python assert find_missing_number([1, 4, 7, 10, 13, 19, 22]) == 16 assert find_missing_number([5, 10, 20, 25]) == 15 assert find_missing_number([2, 8, 14, 26]) == 20 ``` Implementation Provide a complete implementation of the function that efficiently identifies the missing number in the arithmetic progression. The solution should have a time complexity of O(n).","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the missing number in an arithmetic progression. n = len(arr) total_sum = (n + 1) * (arr[0] + arr[-1]) // 2 # Sum of the full AP sequence including the missing element actual_sum = sum(arr) # Sum of the given elements return total_sum - actual_sum # Example usage if __name__ == \\"__main__\\": print(find_missing_number([1, 4, 7, 10, 13, 19, 22])) # Should print 16 print(find_missing_number([5, 10, 20, 25])) # Should print 15 print(find_missing_number([2, 8, 14, 26])) # Should print 20"},{"question":"# Concatenate Elimination **Objective**: Implement a function that concatenates the elements of two lists into a single string with conditions for elimination. # Scenario You are working on a text-processing tool that takes two input lists containing single-character strings and concatenates them into a single string. The twist is that you need to exclude any character that appears in both lists from the final concatenated string. # Problem Specification Write a function `concatenate_elimination(list1: List[str], list2: List[str]) -> str` which takes two lists of single-character strings and concatenates them into a single string, eliminating any character that appears in both lists. Constraints 1. All characters in the lists are lowercase English letters (\'a\'-\'z\'). 2. The length of each list will be in the range 1 to 100. 3. The function should preserve the order of appearance of the characters from both lists in the final string. Input - `list1`: List containing the first set of single-character strings. - `list2`: List containing the second set of single-character strings. Output - A string that is the result of concatenating the two lists after eliminating any character that is present in both lists. # Example ```python def concatenate_elimination(list1: List[str], list2: List[str]) -> str: Concatenate the elements of two lists into a single string, excluding common characters. Example: >>> concatenate_elimination([\'a\', \'b\', \'c\'], [\'b\', \'d\', \'e\']) \'acde\' >>> concatenate_elimination([\'m\', \'n\'], [\'n\', \'o\']) \'mo\' pass if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Note**: Your function should handle the lists as input and produce the appropriate concatenated string per the elimination logic defined.","solution":"from typing import List def concatenate_elimination(list1: List[str], list2: List[str]) -> str: Concatenate the elements of two lists into a single string, excluding common characters. Args: list1: List containing the first set of single-character strings. list2: List containing the second set of single-character strings. Returns: A string that is the result of concatenating the two lists after eliminating any character that is present in both lists. Examples: >>> concatenate_elimination([\'a\', \'b\', \'c\'], [\'b\', \'d\', \'e\']) \'acde\' >>> concatenate_elimination([\'m\', \'n\'], [\'n\', \'o\']) \'mo\' # Create a set of common characters common_chars = set(list1).intersection(set(list2)) # Filter out common characters from list1 and list2 filtered_list1 = [char for char in list1 if char not in common_chars] filtered_list2 = [char for char in list2 if char not in common_chars] # Concatenate the filtered lists and return as a string return \'\'.join(filtered_list1 + filtered_list2)"},{"question":"**Problem Statement**: You need to create a class that represents an **m x n integer matrix**, and then implement several operations that can be performed on it. This matrix should be mutable, meaning its elements can be changed after matrix creation. # Features to Implement: 1. **Constructor**: - Method: `__init__(self, m: int, n: int, initial_value: int) -> None` - Description: Initializes an `m x n` matrix where each element is set to `initial_value`. 2. **Set Element**: - Method: `set_element(self, row: int, col: int, value: int) -> None` - Description: Sets the element at the specified row and column to `value`. Raise an `IndexError` if the row or column is out of bounds. 3. **Get Element**: - Method: `get_element(self, row: int, col: int) -> int` - Description: Returns the element at the specified row and column. Raise an `IndexError` if the row or column is out of bounds. 4. **Transpose**: - Method: `transpose(self) -> \'Matrix\'` - Description: Returns a new `Matrix` object that is the transpose of the current matrix. 5. **Clear Matrix**: - Method: `clear_matrix(self) -> None` - Description: Sets all elements of the matrix to zero, effectively clearing the matrix. 6. **Print Matrix**: - Method: `print_matrix(self) -> None` - Description: Prints the matrix elements in a readable format, with each row on a new line. # Constraints: - The matrix dimensions (m and n) will be positive integers. - The methods should handle edge cases like empty matrices, and invalid row/column indices gracefully. # Example: ```python # Example Usage matrix = Matrix(3, 3, initial_value=1) matrix.set_element(0, 0, 5) matrix.set_element(2, 2, 9) print(matrix.get_element(0, 0)) # Output: 5 print(matrix.get_element(2, 2)) # Output: 9 transposed = matrix.transpose() transposed.print_matrix() # Transposed Output: # 5 1 1 # 1 1 1 # 1 1 9 matrix.clear_matrix() matrix.print_matrix() # Cleared Matrix Output: # 0 0 0 # 0 0 0 # 0 0 0 ``` Implement the `Matrix` class following the above description and ensuring your implementation passes all necessary edge cases.","solution":"class Matrix: def __init__(self, m: int, n: int, initial_value: int): self.rows = m self.cols = n self.matrix = [[initial_value for _ in range(n)] for _ in range(m)] def set_element(self, row: int, col: int, value: int): if row < 0 or row >= self.rows or col < 0 or col >= self.cols: raise IndexError(\\"Row or column index out of bounds.\\") self.matrix[row][col] = value def get_element(self, row: int, col: int) -> int: if row < 0 or row >= self.rows or col < 0 or col >= self.cols: raise IndexError(\\"Row or column index out of bounds.\\") return self.matrix[row][col] def transpose(self) -> \'Matrix\': transposed_matrix = Matrix(self.cols, self.rows, 0) for i in range(self.rows): for j in range(self.cols): transposed_matrix.set_element(j, i, self.matrix[i][j]) return transposed_matrix def clear_matrix(self): for i in range(self.rows): for j in range(self.cols): self.matrix[i][j] = 0 def print_matrix(self): for row in self.matrix: print(\\" \\".join(map(str, row)))"},{"question":"# Coding Assessment Question **Context**: You are given a dataset containing historical stock prices of a company over a period of time. Your task is to implement a function to predict the stock\'s closing price on the next day using a linear regression model. You need to determine which features provide the most accurate predictions. **Objective**: Implement a function `predict_stock_price` that trains a linear regression model on the given dataset, evaluates its performance using cross-validation, and returns the feature importances based on their contribution to the prediction accuracy. **Function Signature**: ```python def predict_stock_price(data: pd.DataFrame, target_column: str, feature_columns: List[str], cv: int = 5) -> dict: Parameters: - data: pd.DataFrame, The dataset containing stock price information. - target_column: str, The name of the target column (closing price) in the dataset. - feature_columns: List[str], List of feature column names to be used for prediction. - cv: int, Number of cross-validation folds. Default is 5. Returns: - dict: Dictionary containing feature importances ``` **Input**: * `data`: A pandas DataFrame with historical stock price data. Example: ```python data = pd.DataFrame({ \'Date\': [\'2021-01-01\', \'2021-01-02\', ...], \'Open\': [100, 101, ...], \'High\': [105, 106, ...], \'Low\': [99, 100, ...], \'Close\': [104, 103, ...], \'Volume\': [1500, 1600, ...] }) ``` * `target_column`: Column name in the DataFrame representing the closing price. * `feature_columns`: List of columns to be used as features for training the model. * `cv`: Number of cross-validation splits to perform, default is 5. **Output**: * Returns a dictionary containing the feature importances based on their coefficients\' absolute values in the linear regression model. **Constraints**: * Use scikit-learn\'s `LinearRegression` for model training. * Use cross-validation to evaluate model performance. * Use standardized feature values for training the model. **Additional Information**: Assume the dataset has already been cleaned and prepared for modeling. The main task is to implement the `predict_stock_price` function and validate its prediction accuracy using cross-validated mean squared error. **Example**: ```python import pandas as pd import numpy as np from sklearn.linear_model import LinearRegression from sklearn.model_selection import cross_val_score from sklearn.preprocessing import StandardScaler def predict_stock_price(data: pd.DataFrame, target_column: str, feature_columns: List[str], cv: int = 5) -> dict: X = data[feature_columns] y = data[target_column] scaler = StandardScaler() X_scaled = scaler.fit_transform(X) model = LinearRegression() feature_importances = {} cross_val_scores = cross_val_score(model, X_scaled, y, cv=cv, scoring=\'neg_mean_squared_error\') model.fit(X_scaled, y) for feature, coef in zip(feature_columns, model.coef_): feature_importances[feature] = abs(coef) return feature_importances, -cross_val_scores.mean() # Sample data preparation (mock data example) data = pd.DataFrame({ \'Date\': pd.date_range(start=\'1/1/2021\', periods=100), \'Open\': np.random.rand(100) * 100, \'High\': np.random.rand(100) * 100, \'Low\': np.random.rand(100) * 100, \'Close\': np.random.rand(100) * 100, \'Volume\': np.random.randint(1000, 5000, size=100) }) features = [\'Open\', \'High\', \'Low\', \'Volume\'] target = \'Close\' # Running the function feature_importances, avg_mse = predict_stock_price(data, target, features) print(\\"Feature Importances:\\", feature_importances) print(\\"Average MSE:\\", avg_mse) ``` **Note**: Ensure the function is tested with a real dataset for reliable feature importance evaluation and prediction accuracy.","solution":"import pandas as pd import numpy as np from sklearn.linear_model import LinearRegression from sklearn.model_selection import cross_val_score from sklearn.preprocessing import StandardScaler from typing import List, Tuple def predict_stock_price(data: pd.DataFrame, target_column: str, feature_columns: List[str], cv: int = 5) -> Tuple[dict, float]: Trains a linear regression model on the given dataset, evaluates its performance using cross-validation, and returns the feature importances and average mean squared error. Parameters: - data: pd.DataFrame, The dataset containing stock price information. - target_column: str, The name of the target column (closing price) in the dataset. - feature_columns: List[str], List of feature column names to be used for prediction. - cv: int, Number of cross-validation folds. Default is 5. Returns: - dict: Dictionary containing feature importances - float: Average mean squared error from cross-validation X = data[feature_columns] y = data[target_column] scaler = StandardScaler() X_scaled = scaler.fit_transform(X) model = LinearRegression() cross_val_scores = cross_val_score(model, X_scaled, y, cv=cv, scoring=\'neg_mean_squared_error\') avg_mse = -cross_val_scores.mean() model.fit(X_scaled, y) feature_importances = {feature: abs(coef) for feature, coef in zip(feature_columns, model.coef_)} return feature_importances, avg_mse"},{"question":"# Task: Implement Algorithm to Sort Custom Matrix with Row-wise and Column-wise Constraints Scenario You are required to sort a given matrix based on custom sorting rules. The matrix should be sorted in ascending order such that: 1. Each row of the matrix is sorted in ascending order. 2. Each column of the matrix is sorted in ascending order. Core Requirements Implement a function that takes a (m times n) matrix and sorts its elements to meet the above constraints. You should achieve this in an efficient manner in terms of time complexity. Function Specifications You are to implement the function: 1. `sort_custom_matrix(matrix: List[List[int]]) -> List[List[int]]` Input - `matrix` (List[List[int]]): A 2D list representing an (m times n) matrix with integer values. Output - Returns a 2D list which is the sorted matrix, with all rows and all columns in ascending order. Constraints - The given matrix dimensions, (m) and (n), can range from 1 to 1000. - The values within the matrix will be between (-10^9) and (10^9). Performance Requirements - The code should run efficiently for larger matrices within reasonable time constraints. - Utilize appropriate sorting algorithms or techniques to minimize the computational complexity. Example ```python # example usage matrix = [ [5, 4, 7], [1, 3, 8], [2, 9, 6] ] print(sort_custom_matrix(matrix)) # Expected Output: [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] ```","solution":"def sort_custom_matrix(matrix): Takes a matrix and sorts it such that each row and column is in ascending order. # Flatten the matrix flattened = [elem for row in matrix for elem in row] # Sort the flattened list flattened.sort() # Calculate the dimensions of the matrix m = len(matrix) n = len(matrix[0]) # Construct the sorted matrix sorted_matrix = [] for i in range(m): sorted_matrix.append(flattened[i*n:(i+1)*n]) return sorted_matrix"},{"question":"# Problem Scenario You are developing a unique word counting utility for a text editor. The application should be able to determine the number of unique words in a given text document. Implement a system that processes the text and identifies how many unique words are present, considering that words are case-insensitive and punctuations should be ignored. # Function Implementations Implement the following function: 1. **count_unique_words(text: str) -> int** - Input: A string representing the text from the document. - Output: An integer representing the count of unique words. # Constraints - The length of the text (n) can range from 1 to (10^6) characters. - The text will contain only printable ASCII characters. # Example ```python # Example Usage: text = \\"Hello, world!! HELLO... World??\\" unique_word_count = count_unique_words(text) assert unique_word_count == 2 print(\\"Unique word counting was successful!\\") ``` # Notes - Words are assumed to be sequences of alphabetic characters (a-zA-Z). - Ignore case and punctuations, thus \\"Hello\\", \\"hello\\", and \\"HELLO\\" should be considered the same word. - Ensure to handle edge cases, such as an empty string.","solution":"import re def count_unique_words(text: str) -> int: Returns the number of unique words in the given text. Words are considered case-insensitive and punctuations are ignored. # Normalize case to lowercase text = text.lower() # Remove punctuation and split into words words = re.findall(r\'b[a-z]+b\', text) # Use a set to track unique words unique_words = set(words) return len(unique_words)"},{"question":"# Minimum Move Transformations You are given a string `s` and a list of transformations. Each transformation is represented as a tuple `(a, b)` meaning that you can replace any occurrence of `a` in the string `s` with `b`. You need to determine the minimum number of transformations required to convert the string `s` into the string `t`. Requirements: 1. **Transformation Function**: Implement a function `min_transformations` that calculates the minimum number of transformations needed to convert `s` into `t`. 2. **Handling Inputs and Outputs**: The function should return the minimum number of transformations required. If it is not possible to transform `s` into `t` using the given transformations, return `-1`. Input/Output Specification: * **Input**: * `s`: (String) The initial string. * `t`: (String) The target string. * `transformations`: (List of Tuples) Each tuple contains two characters, representing the allowed transformation rules. * **Output**: * `min_moves`: (Integer) The minimum number of transformations needed to convert `s` to `t`. If it\'s not possible, return `-1`. Example: ```python # Example 1 s = \\"abc\\" t = \\"cde\\" transformations = [(\'a\', \'d\'), (\'b\', \'e\'), (\'c\', \'f\'), (\'f\', \'c\')] print(min_transformations(s, t)) # Expected: -1 # Example 2 s = \\"abc\\" t = \\"ded\\" transformations = [(\'a\', \'d\'), (\'b\', \'e\'), (\'e\', \'d\'), (\'c\', \'d\')] print(min_transformations(s, t)) # Expected: 3 ``` Code: ```python def min_transformations(s: str, t: str, transformations: list) -> int: if len(s) != len(t): return -1 trans_dict = {} for a, b in transformations: trans_dict[a] = b moves = 0 for i in range(len(s)): current_char = s[i] target_char = t[i] if current_char == target_char: continue if current_char in trans_dict: while current_char != target_char: if current_char not in trans_dict: return -1 current_char = trans_dict[current_char] moves += 1 if current_char == target_char: break else: return -1 return moves # Example usage if __name__ == \\"__main__\\": # Example 1 Test Case s = \\"abc\\" t = \\"cde\\" transformations = [(\'a\', \'d\'), (\'b\', \'e\'), (\'c\', \'f\'), (\'f\', \'c\')] print(min_transformations(s, t)) # Expected: -1 # Example 2 Test Case s = \\"abc\\" t = \\"ded\\" transformations = [(\'a\', \'d\'), (\'b\', \'e\'), (\'e\', \'d\'), (\'c\', \'d\')] print(min_transformations(s, t)) # Expected: 3 ``` Please ensure to handle correct input validation and raise appropriate errors when input constraints are violated.","solution":"def min_transformations(s: str, t: str, transformations: list) -> int: if len(s) != len(t): return -1 # Create mapping from each character in transformations transformation_map = {} for a, b in transformations: if a in transformation_map and transformation_map[a] != b: return -1 # Conflicting transformations make the task impossible transformation_map[a] = b moves = 0 for char_s, char_t in zip(s, t): if char_s == char_t: continue # No transformation needed current_char = char_s transformations = 0 visited = set() while current_char != char_t: if current_char in visited: return -1 # Loop detected, transformation is impossible visited.add(current_char) if current_char not in transformation_map: return -1 # No way to transform char_s into char_t current_char = transformation_map[current_char] transformations += 1 moves += transformations return moves"},{"question":"# Coding Assessment Question # Finding the Minimum Element in a Rotated Sorted Array You are required to implement an efficient algorithm to find the minimum element in a rotated sorted array. A rotated sorted array is an array that has been sorted in ascending order but then rotated at an unknown pivot. # Objective Implement a function `findMin(nums: List[int]) -> int` that finds and returns the minimum element in the rotated sorted array. # Input * A list of integers `nums`, where 1 ≤ len(nums) ≤ 10^5 and each element in the array is unique. # Output * The minimum element in the rotated sorted array. # Constraints * Your solution should have O(log(n)) time complexity. * The array does not contain any duplicate elements. # Example ```python def findMin(nums: List[int]) -> int: pass # Test cases print(findMin([3, 4, 5, 1, 2])) # Output: 1 print(findMin([4, 5, 6, 7, 0, 1, 2])) # Output: 0 print(findMin([11, 13, 15, 17])) # Output: 11 print(findMin([2, 1])) # Output: 1 print(findMin([1])) # Output: 1 ``` # Guidelines 1. Use a binary search approach to locate the minimum element. 2. Handle edge cases such as arrays with only one element or arrays that are not rotated. 3. Ensure your function is efficient and correctly handles various possible rotations of the sorted array. In your implementation, the goal is to leverage the properties of the rotated sorted array to minimize the number of comparisons and efficiently find the pivot point where the minimum element is located.","solution":"from typing import List def findMin(nums: List[int]) -> int: left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"# Coding Assessment Question Context You\'re developing a module for data analysis. One of the tasks involves calculating specific statistical measures from a given dataset. The dataset provided is a list of numeric values. Your task is to write a Python function that calculates the median, mode, and range of the dataset. Task Write a function `calculate_stats(data)` that: - Computes the median of the dataset. - Determines the mode of the dataset (if there are multiple modes, return any one of them). - Calculates the range of the dataset. Input - `data` (List[int or float]): A list of numeric values. Output - Returns a tuple `(median, mode, range_val)` where: - `median` (float): The median value of the dataset. - `mode` (int or float): The mode of the dataset. - `range_val` (float): The range of the dataset. Constraints - The list will always contain at least one element. Example ```python data = [1, 2, 2, 3, 4] stats = calculate_stats(data) print(stats) # Output: (2, 2, 3) data = [5, 7, 3, 9, 3, 8] stats = calculate_stats(data) print(stats) # Output: (6.0, 3, 6) ``` Requirements - Implement the median calculation correctly (handling both even and odd number of elements). - Accurately determine the mode (return any if multiple modes exist). - Calculate the range as the difference between the maximum and minimum values.","solution":"from collections import Counter from typing import List def calculate_stats(data: List[int or float]): Returns the median, mode and range of the dataset. data.sort() # Calculate the median n = len(data) mid = n // 2 if n % 2 == 0: median = (data[mid - 1] + data[mid]) / 2.0 else: median = data[mid] # Calculate the mode count = Counter(data) mode = max(count.keys(), key=lambda x: count[x]) # Calculate the range range_val = data[-1] - data[0] return (median, mode, range_val)"},{"question":"# Permutation of Array You are given an array of unique integers. Your task is to generate all possible permutations of the array. Implement the function `permutations` which takes in the following parameters: - `arr`: A list of unique integers representing the array. The function should return a list of lists, where each inner list is a unique permutation of the given array. Example ```python arr = [1, 2, 3] print(permutations(arr)) # Output: [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] ``` Constraints 1. The length of the array will be between 1 and 10. 2. The array will contain unique integers. Requirements - Implement the function efficiently to handle the permutations\' generation. - Minimize space complexity as much as possible while ensuring readability and correctness.","solution":"from itertools import permutations as it_permutations def permutations(arr): Generates all possible permutations of a list of unique integers. Parameters: - arr: List[int], a list of unique integers. Returns: - List[List[int]], a list of lists where each inner list is a unique permutation of arr. return [list(p) for p in it_permutations(arr)]"},{"question":"# Coding Assessment Question In this assessment, you need to design and implement a caching mechanism for a web application that efficiently handles requests for frequently accessed resources. This exercise is designed to test your understanding of data structures, algorithms, and optimization strategies within the context of server-side application development. Your Task 1. **Implement Least Recently Used (LRU) Cache**: - Design and implement an LRU cache that supports the following operations: `get(key)`, `set(key, value)`, and `delete(key)`. The cache should store up to a specified maximum number of items and evict the least recently used item when the limit is reached. 2. **Concurrency Support**: - Ensure the cache implementation is thread-safe, allowing multiple threads to access and modify the cache concurrently without causing data inconsistencies. 3. **Expiration Policy**: - Extend the cache to support an expiration policy where entries can expire after a given duration. The cache should automatically evict expired entries. # Implementation Details Required Classes and Methods: 1. **`class LRUCache:`** - **`__init__(self, capacity: int, expiration: int)`**: Initialize the cache with a specified capacity (maximum number of items) and expiration time (in seconds). - **`get(self, key: str) -> Any`**: Retrieve the value associated with the key if present in the cache and not expired. Update the key\'s usage timestamp. Return None if the key is not found or expired. - **`set(self, key: str, value: Any)`**: Insert or update the key-value pair in the cache. If the cache is at capacity, evict the least recently used item before adding the new key-value pair. - **`delete(self, key: str)`**: Remove the key-value pair from the cache if it exists. - **`_evict_expired(self)`**: Internal method to remove expired entries from the cache. Constraints: - The keys are strings, and the values can be any type (strings, numbers, objects). - The cache must handle up to 10,000 get/set/delete operations per second while ensuring thread-safety. Input/Output: - **Input**: - Cache operations in the form of method calls (`get`, `set`, `delete`). - Capacity and expiration time during cache initialization. - **Output**: - Values retrieved from the cache for `get` operations. - Updated cache state after `set` and `delete` operations. # Performance Requirements - The cache must handle up to 10,000 operations per second without significant delays. - It should provide O(1) time complexity for get and set operations through the use of appropriate data structures. # Scenario As part of a web application development team, you are tasked with implementing a caching mechanism to optimize data retrieval for frequently accessed resources. By implementing an efficient LRU cache with concurrency support and expiration policies, you aim to improve application performance and scalability. --- Ensure your solution is thoroughly tested using various scenarios, including concurrent access and high operation volumes. Consider edge cases such as accessing or deleting keys that do not exist, updating existing entries, and the behavior under maximum capacity constraints.","solution":"import threading from collections import OrderedDict import time class LRUCache: def __init__(self, capacity: int, expiration: int): self.capacity = capacity self.expiration = expiration self.cache = OrderedDict() self.lock = threading.Lock() def _is_expired(self, entry): return time.time() - entry[1] > self.expiration def _evict_expired(self): keys_to_delete = [] for key, entry in self.cache.items(): if self._is_expired(entry): keys_to_delete.append(key) for key in keys_to_delete: del self.cache[key] def get(self, key: str): with self.lock: self._evict_expired() if key not in self.cache: return None value, timestamp = self.cache.pop(key) self.cache[key] = (value, time.time()) # update timestamp return value def set(self, key: str, value: any): with self.lock: self._evict_expired() if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # pop the first item (LRU) self.cache[key] = (value, time.time()) def delete(self, key: str): with self.lock: if key in self.cache: del self.cache[key]"},{"question":"# File Directory Tree You are tasked with designing a `FileDirectory` system that efficiently represents the hierarchical structure of folders and files within a directory. Each folder can contain files and subfolders, and each subfolder can itself contain further files and subfolders. Function Specifications 1. **Initialization (`__init__(self, name, is_folder=True)`)**: Create a new folder or file with the given `name`. The parameter `is_folder` determines whether the instance is a folder or a file. 2. **Add Child (`add_child(self, child)`)**: Add a new file or folder as a child to the current folder. Raise an exception if you attempt to add a child to a file. 3. **Remove Child (`remove_child(self, name)`)**: Remove a file or folder by `name` from the current folder. Raise an exception if you try to remove a child from a file or if the specified child does not exist. 4. **List Contents (`list_contents(self)`)**: List the names of all files and folders within the current folder. If called on a file, return an empty list. 5. **Find Path (`find_path(self, path)`)**: Given a `path` string, return the FileDirectory object at that path. Paths are defined with a \'/\' separator similar to filesystem paths (e.g., `folder1/folder2/file.txt`). Raise an exception if the path does not exist. Input and Output Specifications **Input**: - `FileDirectory(name, is_folder=True)` constructor where `name` is the name of the file or folder, and `is_folder` is a boolean specifying whether it is a folder (defaults to `True`). - `add_child(child)` where `child` is an instance of `FileDirectory`. - `remove_child(name)` where `name` is the name of the file or folder to be removed. - `list_contents()` and `find_path(path)` are methods that do not have additional input besides `self`. **Output**: - `add_child(child)` does not return anything. - `remove_child(name)` does not return anything. - `list_contents()` returns a list of strings of the names of all child files and folders. - `find_path(path)` returns the `FileDirectory` object at the specified path. # Example Test Cases ```python root = FileDirectory(\\"root\\") # Add folders and files folder1 = FileDirectory(\\"folder1\\") root.add_child(folder1) file1 = FileDirectory(\\"file1.txt\\", is_folder=False) folder1.add_child(file1) # List contents of root and folder1 assert root.list_contents() == [\\"folder1\\"] assert folder1.list_contents() == [\\"file1.txt\\"] # Find path assert root.find_path(\\"folder1\\") == folder1 assert root.find_path(\\"folder1/file1.txt\\") == file1 # Remove file folder1.remove_child(\\"file1.txt\\") assert folder1.list_contents() == [] # Add more hierarchy folder2 = FileDirectory(\\"folder2\\") folder1.add_child(folder2) file2 = FileDirectory(\\"file2.txt\\", is_folder=False) folder2.add_child(file2) assert folder1.list_contents() == [\\"folder2\\"] assert root.find_path(\\"folder1/folder2/file2.txt\\") == file2 # Exception handling try: root.add_child(file1) except Exception as e: assert str(e) == \\"Cannot add a child to a file\\" try: folder1.remove_child(\\"file3.txt\\") except Exception as e: assert str(e) == \\"Child does not exist\\" try: file1.list_contents() except Exception as e: assert str(e) == \\"Cannot list contents of a file\\" try: root.find_path(\\"folder3\\") except Exception as e: assert str(e) == \\"Path does not exist\\" ``` Implement the `FileDirectory` class according to these specifications and ensure your implementation passes all the given example test cases.","solution":"class FileDirectory: def __init__(self, name, is_folder=True): Initialize a new file or folder. :param name: str, name of the file or folder. :param is_folder: bool, indicates whether it is a folder or file. self.name = name self.is_folder = is_folder self.children = {} def add_child(self, child): Add a new file or folder as a child to the current folder. :param child: FileDirectory object to be added as a child. if not self.is_folder: raise Exception(\\"Cannot add a child to a file\\") self.children[child.name] = child def remove_child(self, name): Remove a file or folder by name from the current folder. :param name: str, name of the file or folder to be removed. if not self.is_folder: raise Exception(\\"Cannot remove a child from a file\\") if name not in self.children: raise Exception(\\"Child does not exist\\") del self.children[name] def list_contents(self): List the names of all files and folders within the current folder. :return: list of str, names of all child files and folders. if not self.is_folder: return [] return list(self.children.keys()) def find_path(self, path): Given a path string, return the FileDirectory object at that path. :param path: str, path string with \'/\' separator. :return: FileDirectory object at the specified path. if not path: return self parts = path.split(\'/\') node = self for part in parts: if part in node.children: node = node.children[part] else: raise Exception(\\"Path does not exist\\") return node"},{"question":"# Unique Characters Subsequence Given a string `s`, write a function `unique_chars_subsequence` to return the length of the longest subsequence of `s` such that all characters in the subsequence are unique. Function Signature ```python def unique_chars_subsequence(s: str) -> int: pass ``` Input - A single string `s` where ( 1 leq |s| leq 100 ). Output - An integer representing the length of the longest subsequence with all unique characters. Constraints - The string will consist of lowercase alphabetic characters only. Example ```python unique_chars_subsequence(\\"abcabcbb\\") ``` Output: ```python 3 ``` Explanation: The answer is \\"abc\\", with the length of 3. ```python unique_chars_subsequence(\\"bbbbb\\") ``` Output: ```python 1 ``` Explanation: The answer is \\"b\\", with the length of 1. Instructions 1. Utilize a sliding window or a set to track unique characters. 2. Iterate through the string to find the longest subsequence with unique characters.","solution":"def unique_chars_subsequence(s: str) -> int: Returns the length of the longest subsequence of s such that all characters in the subsequence are unique. char_set = set() max_length = 0 left = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Coding Assessment Question Objective: Implement a function to rotate an NxN matrix representing an image by 90 degrees clockwise. The function should perform the rotation in place, modifying the original matrix. Scenario You are given a square NxN matrix where each cell contains a pixel value representing an image. Your task is to rotate the image by 90 degrees clockwise without using any additional matrices (i.e., perform the rotation in place). Function Signature ```python def rotate_image(matrix: List[List[int]]) -> None: pass ``` Input - `matrix` (List[List[int]]): A list of lists of integers representing an NxN matrix where ( 1 leq N leq 1000 ). Output - The function should modify the original matrix in place and must not return any value. Constraints - The matrix is guaranteed to be NxN. - Each cell of the matrix contains an integer value. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(matrix) print(matrix) # Expected Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Notes - In-place means you cannot use any extra space to store another matrix. Modify the existing matrix itself. - Think about the pattern or formula required to map the values from the original positions to their new positions after rotation. - Ensure the solution is optimized for efficiency given the constraints of the problem.","solution":"def rotate_image(matrix: list) -> None: Rotates the given NxN matrix by 90 degrees clockwise in place. :param matrix: List[List[int]]: A 2D list representing the matrix N = len(matrix) # Step 1: Transpose the matrix for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(N): matrix[i].reverse()"},{"question":"# Stock Price Prediction with Moving Average **Problem Statement**: Develop a function to predict future stock prices using a simple moving average (SMA). The function should calculate the SMA for a given window size and use the latest available SMA value to predict the next day\'s stock price. **Inputs**: 1. **prices**: List of floats representing the historical stock prices. 2. **window_size**: Integer representing the window size for the moving average. **Outputs**: 1. **predicted_price**: Float representing the predicted stock price for the next day based on the latest SMA value. **Constraints**: - 1 <= len(prices) <= 10000 (number of historical prices) - 1 <= window_size <= len(prices) (size of the moving average window) **Performance Requirements**: - Ensure the function runs efficiently, focusing on the time complexity related to the SMA calculation. **Function Signature**: ```python def predict_stock_price(prices: List[float], window_size: int) -> float: pass ``` # Example: ```python # Example input data prices = [100.0, 101.5, 102.0, 105.5, 107.0, 110.0, 111.5] window_size = 3 # Example run predicted_price = predict_stock_price(prices, window_size) # Expected output: 109.5 (explained below) # SMA for the last 3 prices [107.0, 110.0, 111.5] = (107.0 + 110.0 + 111.5) / 3 = 109.5 # Hence, the predicted price for the next day is 109.5 ``` **Notes**: - The function should handle edge cases, such as when the window_size is equal to 1, ensuring the algorithm defaults correctly. - The initial predicted price should use the average of the first available window. - Clearly document any assumptions and decisions in the code comments.","solution":"from typing import List def predict_stock_price(prices: List[float], window_size: int) -> float: Predicts the next day\'s stock price using the Simple Moving Average (SMA). Parameters: prices (List[float]): The historical stock prices. window_size (int): The window size for calculating the SMA. Returns: float: The predicted stock price for the next day. # Calculate the sum of the last `window_size` prices window_sum = sum(prices[-window_size:]) # Compute the SMA sma = window_sum / window_size # Return the calculated SMA as the prediction for the next day\'s price return sma"},{"question":"# Coding Assessment Question You are tasked with implementing a function to sort an array using an in-place quicksort algorithm. The function should sort the array in ascending order and output the array after each partitioning operation. # Function Signature: ```python def quicksort(arr: List[int]) -> None: ``` # Parameters: - `arr` (List[int]): A list of integers to be sorted. # Returns: - This function should not return any value. The input list should be sorted in place. - During the execution, the function should print the array after each partitioning operation. # Constraints: 1. 1 <= len(arr) <= 1000 2. Elements of the array are integers in the range [-10^5, 10^5]. # Performance Requirement: - Time Complexity: O(n log n) on average, O(n^2) in the worst case. - Space Complexity: O(log n) due to recursion stack. # Example: ```python arr = [10, 4, 6, 3, 8, 2, 5] quicksort(arr) # Output: # [2, 4, 6, 3, 8, 10, 5] # [2, 4, 5, 3, 6, 8, 10] # [2, 3, 4, 5, 6, 8, 10] print(arr) # Output: [2, 3, 4, 5, 6, 8, 10] ``` # Instructions: 1. Choose the last element as the pivot for partitioning the array. 2. Implement the partitioning within the quicksort function such that it sorts the array in place. 3. Print the array after each partitioning step before any recursive calls. 4. Ensure your implementation handles edge cases such as empty arrays or arrays with one element.","solution":"from typing import List def quicksort(arr: List[int]) -> None: Sorts the array in place using the quicksort algorithm and prints the array after each partitioning operation. def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] print(arr) return i + 1 def quicksort_recursive(low, high): if low < high: pi = partition(low, high) quicksort_recursive(low, pi - 1) quicksort_recursive(pi + 1, high) quicksort_recursive(0, len(arr) - 1)"},{"question":"# Question: You are given a binary tree where each node contains a value. You need to implement a function that returns the sum of values of all nodes at the deepest level in the binary tree. If the tree has multiple deepest levels (i.e., the leaf nodes are all at the same depth), sum the values of the nodes at that deepest level. Requirements: 1. Implement the function `deepest_level_sum` to find and return the sum of values at the deepest level of the binary tree. Input: - `root`: TreeNode (the root node of the binary tree) Output: - int (the sum of values at the deepest level in the binary tree) # Constraints: - The number of nodes in the binary tree is in the range [1, 10^4]. - -1000 <= node.val <= 1000 # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.left.left.left = TreeNode(7) assert deepest_level_sum(root) == 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.right = TreeNode(5) root.right.right.left = TreeNode(6) assert deepest_level_sum(root) == 6 ``` # Notes: - You may assume the existence of a TreeNode class. - The deepest level sum should be computed efficiently to handle larger trees within the constraints. - If the tree consists of only one node, the function should return the value of that node. # Implementation: Implement the `deepest_level_sum` function in Python, ensuring it correctly handles the provided binary tree structure. ```python def deepest_level_sum(root): from collections import deque if not root: return 0 queue = deque([root]) level_sum = 0 while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_level_sum(root): from collections import deque if not root: return 0 queue = deque([root]) level_sum = 0 while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"# Problem Statement Implement the operations of a Circular Queue using the provided `CircularQueue` class template: 1. **Enqueue**: The method, `enqueue`, should insert an element at the rear of the queue. 2. **Dequeue**: The method, `dequeue`, should remove and return the element from the front of the queue. 3. **Front**: The method, `front`, should return the front element without removing it. 4. **isEmpty**: The method, `is_empty`, should return `True` if the queue is empty; otherwise, it returns `False`. Input Format - You will be provided a series of commands to manipulate the circular queue. Output Format - For each operation that returns a value (i.e., `dequeue`, `front`, `is_empty`), output the result of the operation. Constraints - The capacity of the circular queue will be at most 10^4. - The input elements for enqueue will be integers in the range -10^9 to 10^9. Functions to Implement ```python def __init__(self, k: int): pass def enqueue(self, value: int) -> bool: pass def dequeue(self) -> int: pass def front(self) -> int: pass def is_empty(self) -> bool: pass ``` Example ```python # Initialize the circular queue with capacity 5 cq = CircularQueue(5) # Enqueue operation cq.enqueue(10) cq.enqueue(20) cq.enqueue(30) print(cq) # Output: [10, 20, 30, -1, -1] # Dequeue operation value = cq.dequeue() print(value) # Output: 10 print(cq) # Output: [-1, 20, 30, -1, -1] # Front operation front_value = cq.front() print(front_value) # Output: 20 # isEmpty operation empty_check = cq.is_empty() print(empty_check) # Output: False # Adding more elements to fill the queue cq.enqueue(40) cq.enqueue(50) cq.enqueue(60) print(cq) # Output: [60, 20, 30, 40, 50] # Check after dequeue cq.dequeue() print(cq.front()) # Output: 30 print(cq.is_empty()) # Output: False ``` Note: The queue implementation will handle the wrap-around cases internally, and the actual output may vary slightly depending on the underlying circular array\'s management.","solution":"class CircularQueue: def __init__(self, k: int): Initialize the queue with a fixed size of k. self.queue = [-1] * k self.max_size = k self.front_index = 0 self.rear_index = 0 self.size = 0 def enqueue(self, value: int) -> bool: Enqueue (insert) an element at the rear of the queue. Returns True if the operation is successful (queue not full), False otherwise. if self.size == self.max_size: return False self.queue[self.rear_index] = value self.rear_index = (self.rear_index + 1) % self.max_size self.size += 1 return True def dequeue(self) -> int: Dequeue (remove) and return the element from the front of the queue. Returns -1 if the queue is empty. if self.size == 0: return -1 value = self.queue[self.front_index] self.queue[self.front_index] = -1 self.front_index = (self.front_index + 1) % self.max_size self.size -= 1 return value def front(self) -> int: Return the front element without removing it from the queue. Returns -1 if the queue is empty. if self.size == 0: return -1 return self.queue[self.front_index] def is_empty(self) -> bool: Returns True if the queue is empty, otherwise False. return self.size == 0"},{"question":"# Problem Description You are given a `Node` class representing nodes in a binary tree and a `BinaryTree` class to manage the tree operations. Your task is to extend the functionality of this `BinaryTree` by implementing a method that performs a level-order traversal (also known as Breadth-First Search, BFS) and returns the values of the nodes in level order, grouped by each level. # Objective Write a method called `level_order_traversal` for the `BinaryTree` class that returns the values of the nodes level by level. # Function Specification **Method Signature:** ```python class Node: def __init__(self, value: int, left: \'Node\' = None, right: \'Node\' = None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root: Node = None): self.root = root def level_order_traversal(self) -> List[List[int]]: pass ``` **Output:** * Returns a list of lists, where each inner list contains the node values at the corresponding level. # Constraints: * The tree may be empty. * Node values are integers. # Requirements: 1. The method should handle edge cases, such as an empty tree. 2. The method should efficiently traverse the tree using BFS. # Examples: 1. **Example 1:** ```python root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) tree = BinaryTree(root) print(tree.level_order_traversal()) ``` *Output:* `[[1], [2, 3], [4, 5]]` 2. **Example 2:** ```python tree = BinaryTree() print(tree.level_order_traversal()) ``` *Output:* `[]` 3. **Example 3:** ```python root = Node(1) root.left = Node(2) tree = BinaryTree(root) print(tree.level_order_traversal()) ``` *Output:* `[[1], [2]]` # Notes: 1. Ensure that the method correctly handles an empty tree case and trees with multiple levels. 2. Provide adequate testing for trees with various shapes and sizes to ensure proper level order traversal.","solution":"from typing import List, Optional from collections import deque class Node: def __init__(self, value: int, left: \'Node\' = None, right: \'Node\' = None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root: Optional[Node] = None): self.root = root def level_order_traversal(self) -> List[List[int]]: if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Coding Challenge # Problem Statement Given a 2D grid of characters and a word, determine if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. # Input - A 2D list of characters representing the grid. - A string representing the word to search for in the grid. - Guarantee: The grid and the word will be non-empty, with the grid containing between 1x1 and 100x100 elements and the word containing between 1 and 100 characters. # Output - A boolean indicating whether the word exists in the grid. # Example Input ``` [[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']] \'ABCCED\' ``` Output ``` True ``` Input ``` [[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']] \'SEE\' ``` Output ``` True ``` Input ``` [[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']] \'ABCB\' ``` Output ``` False ``` # Explanation For the first example, the word \\"ABCCED\\" can be found following the path A -> B -> C -> C -> E -> D. For the second example, the word \\"SEE\\" can be found following the path S -> E -> E. For the third example, there is no valid path in the grid that forms the word \\"ABCB\\". # Function Signature ```python def exist(board: List[List[str]], word: str) -> bool: pass ``` # Constraints - 1 ≤ grid dimensions ≤ 100 - 1 ≤ word length ≤ 100 - All grid values and word characters are uppercase alphabets (\'A\' - \'Z\'). # Scenario This problem tests the ability to implement depth-first search (DFS) and backtracking within a grid structure, ensuring efficiency in navigating and handling potentially large datasets. Robust handling of edge cases with grid boundaries and word permutations will be critical.","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: def dfs(board, word, i, j, k): if k == len(word): # all characters are checked return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False tmp = board[i][j] # store the cell character board[i][j] = \\"#\\" # mark the cell as visited # Check in all four directions found = (dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1)) board[i][j] = tmp # unmark the cell return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"# Quadratic Equation Solver You have been given a task to create a utility that solves quadratic equations of the form `ax^2 + bx + c = 0`. Your job is to implement a function: 1. `solve_quadratic(a: int, b: int, c: int) -> Union[str, Tuple[float, float]]`: This function should return either a string indicating no real roots if the discriminant is negative, or a tuple containing two real roots (sorted in non-decreasing order) of the quadratic equation. Input - `a`, `b`, and `c` are integers where -1000 ≤ a, b, c ≤ 1000. - It is guaranteed that `a` is not zero. Output - If the equation has no real roots, return the string `\\"No real roots\\"`. - If the equation has real roots, return a tuple containing the roots sorted in non-decreasing order. Constraints - Handle edge cases such as large coefficients and small coefficients. - Ensure numerical stability in calculations especially for discriminant calculations and rounding errors. Example ```python # Example usage: print(solve_quadratic(1, -3, 2)) # Expected: (1.0, 2.0) print(solve_quadratic(1, 2, 5)) # Expected: \\"No real roots\\" print(solve_quadratic(2, -4, 2)) # Expected: (1.0, 1.0) ``` Implement this function in Python and ensure it correctly handles a variety of input scenarios, including edge cases.","solution":"from typing import Union, Tuple import math def solve_quadratic(a: int, b: int, c: int) -> Union[str, Tuple[float, float]]: Solves the quadratic equation ax^2 + bx + c = 0. - If there are no real roots, returns \\"No real roots\\". - If there are real roots, returns a tuple containing the roots sorted in non-decreasing order. :param a: Coefficient of x^2 :param b: Coefficient of x :param c: Constant term :return: A string if no real roots, or a tuple of two floats if real roots exist. # Calculate the discriminant discriminant = b ** 2 - 4 * a * c if discriminant < 0: return \\"No real roots\\" # Calculate the roots sqrt_discriminant = math.sqrt(discriminant) root1 = (-b - sqrt_discriminant) / (2 * a) root2 = (-b + sqrt_discriminant) / (2 * a) # Sort the roots in non-decreasing order return (min(root1, root2), max(root1, root2))"},{"question":"# Scenario You are tasked with implementing a simple book repository system. The goal is to create a class that manages the collection of books in the repository. Each book is represented as a dictionary with the keys \'title\', \'author\', and \'year\'. # Task Write a Python class `BookRepository` with the following methods: 1. `__init__(self)`: Initializes an empty list of books. 2. `add_book(self, title: str, author: str, year: int)`: Adds a book with the given title, author, and year to the repository. 3. `remove_book(self, title: str)`: Removes the book with the given title from the repository. 4. `get_books_by_author(self, author: str) -> List[Dict[str, Union[str, int]]]`: Returns a list of books by the given author. 5. `get_books(self) -> List[Dict[str, Union[str, int]]]`: Returns the list of all books in the repository. # Constraints * The repository should not contain duplicate books (books with the same title and author are considered duplicates). * The `year` parameter is a four-digit integer representing the year of publication. # Input * Parameters for `add_book` and `remove_book` methods to add or remove books from the repository. * The `author` parameter for the `get_books_by_author` method to filter books by author. # Output * The `get_books_by_author` and `get_books` methods should return lists of book dictionaries. # Example ```python repo = BookRepository() repo.add_book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) repo.add_book(\\"Nine Stories\\", \\"J.D. Salinger\\", 1953) repo.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) print(repo.get_books_by_author(\\"J.D. Salinger\\")) # Output: [{\'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\', \'year\': 1951}, {\'title\': \'Nine Stories\', \'author\': \'J.D. Salinger\', \'year\': 1953}] repo.remove_book(\\"Nine Stories\\") print(repo.get_books()) # Output: [{\'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\', \'year\': 1951}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960}] ``` The class should manage the collection of books and provide functionality to add, remove, and retrieve books based on the specified criteria.","solution":"from typing import List, Dict, Union class BookRepository: def __init__(self): Initializes an empty list of books. self.books = [] def add_book(self, title: str, author: str, year: int): Adds a book with the given title, author, and year to the repository. for book in self.books: if book[\'title\'] == title and book[\'author\'] == author: return # Do not add duplicate books self.books.append({\'title\': title, \'author\': author, \'year\': year}) def remove_book(self, title: str): Removes the book with the given title from the repository. self.books = [book for book in self.books if book[\'title\'] != title] def get_books_by_author(self, author: str) -> List[Dict[str, Union[str, int]]]: Returns a list of books by the given author. return [book for book in self.books if book[\'author\'] == author] def get_books(self) -> List[Dict[str, Union[str, int]]]: Returns the list of all books in the repository. return self.books"},{"question":"# Problem Statement You are working as a software engineer tasked with designing an efficient system for managing user session data. The system needs to ensure that session data can be quickly accessed, modified, and cleaned up after a period of inactivity. To achieve this, you need to use a combination of data structures to facilitate rapid access and efficient memory management. # Goal Create a `SessionManager` class that implements the following features: 1. Storage of session data using a dictionary for fast access. 2. Tracking of session expiry using a priority queue to efficiently manage and remove expired sessions. # Implementation SessionManager Class 1. **Session Storage:** * Use a dictionary named `sessions` to store session data with session IDs as keys. 2. **Session Expiry:** * Use a priority queue (min-heap) named `expiry_queue` to keep track of session expiry times, where each entry is a tuple `(expiry_time, session_id)`. 3. **Key Methods:** * `create_session(session_id, data, duration)`: Adds a session with the given `session_id`, `data`, and `duration` (in seconds). The session should be scheduled to expire after `duration` seconds. * `get_session_data(session_id)`: Returns the session data if the session is active or `None` if it has expired or doesn\'t exist. * `cleanup_sessions(current_time)`: Removes all expired sessions based on the `current_time` (in seconds since epoch). # Input and Output Format ```python class SessionManager: def __init__(self): self.sessions = {} self.expiry_queue = [] def create_session(self, session_id, data, duration): # Implementation of creating and storing session with expiration logic def get_session_data(self, session_id): # Implementation of retrieving session data def cleanup_sessions(self, current_time): # Implementation of cleaning up expired sessions ``` # Example Usage ```python import time # Create a SessionManager instance sm = SessionManager() # Add sessions sm.create_session(\\"session1\\", {\\"user\\": \\"Alice\\"}, 10) sm.create_session(\\"session2\\", {\\"user\\": \\"Bob\\"}, 20) # Simulate time passing time.sleep(5) # Retrieve session data print(sm.get_session_data(\\"session1\\")) # Expected Output: {\\"user\\": \\"Alice\\"} # Cleanup expired sessions sm.cleanup_sessions(time.time()) # Simulate more time passing time.sleep(10) # Retrieve session data after expiry print(sm.get_session_data(\\"session1\\")) # Expected Output: None print(sm.get_session_data(\\"session2\\")) # Expected Output: {\\"user\\": \\"Bob\\"} ``` # Constraints and Performance Requirements 1. The system should handle at least 1,000 active user sessions efficiently. 2. The `cleanup_sessions` method should have a time complexity of O(log n) where n is the number of active sessions. # Write your SessionManager class below: ```python # Write your solution here ```","solution":"import time import heapq class SessionManager: def __init__(self): self.sessions = {} self.expiry_queue = [] def create_session(self, session_id, data, duration): expiry_time = time.time() + duration self.sessions[session_id] = {\'data\': data, \'expiry_time\': expiry_time} heapq.heappush(self.expiry_queue, (expiry_time, session_id)) def get_session_data(self, session_id): current_time = time.time() self.cleanup_sessions(current_time) if session_id in self.sessions: return self.sessions[session_id][\'data\'] return None def cleanup_sessions(self, current_time): while self.expiry_queue and self.expiry_queue[0][0] <= current_time: expiry_time, session_id = heapq.heappop(self.expiry_queue) if session_id in self.sessions and self.sessions[session_id][\'expiry_time\'] <= current_time: del self.sessions[session_id]"},{"question":"# Merge Sort Implementation and Adaptation # Objective Your task is to implement the Merge Sort algorithm for sorting a list of integers, as well as adapt the algorithm to sort a list of dictionaries based on a specified key. # Problem Description Part 1: Merge Sort for Integers Implement the `merge_sort` function that takes a list of integers and returns it sorted in ascending order using the Merge Sort algorithm. Part 2: Merge Sort for List of Dictionaries Using your `merge_sort` implementation, create a function `merge_sort_dict` that sorts a list of dictionaries based on a specified key and returns the sorted list. # Function Signatures ```python def merge_sort(collection: List[int]) -> List[int]: pass def merge_sort_dict(collection: List[Dict[str, Union[int, str]]], key: str) -> List[Dict[str, Union[int, str]]]: pass ``` # Input/Output Specifications Part 1: Merge Sort for Integers * **Input**: A list of integers which can include negative values. * Example: `[12, 11, 13, 5, 6, 7]` * **Output**: A list of integers sorted in ascending order. * Example: `[5, 6, 7, 11, 12, 13]` Part 2: Merge Sort for List of Dictionaries * **Input**: A list of dictionaries where each dictionary contains at least the specified key, with values as either integers or strings. * Example: `[{ \\"name\\": \\"John\\", \\"age\\": 23 },{ \\"name\\": \\"Jane\\", \\"age\\": 31 },{ \\"name\\": \\"Dave\\", \\"age\\": 20 }]` and the key `\'age\'` * **Output**: A list of dictionaries sorted based on the specified key. * Example: `[{ \\"name\\": \\"Dave\\", \\"age\\": 20 }, { \\"name\\": \\"John\\", \\"age\\": 23 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 }]` # Constraints * For Part 1, the list can have up to 10^6 elements, and the integers range from -10^6 to 10^6. * For Part 2, the input list can contain up to 10^6 dictionaries, and the value of the sorting key will be either integers or strings with length up to 100 characters. # Examples Part 1: Merge Sort for Integers ```python >>> merge_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] >>> merge_sort([-3, 10, 0, -19, 2]) [-19, -3, 0, 2, 10] >>> merge_sort([1, 2, 3, 2, 1]) [1, 1, 2, 2, 3] ``` Part 2: Merge Sort for List of Dictionaries ```python >>> merge_sort_dict([{ \\"name\\": \\"John\\", \\"age\\": 23 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 },{ \\"name\\": \\"Dave\\", \\"age\\": 20 }], \'age\') [{ \\"name\\": \\"Dave\\", \\"age\\": 20 }, { \\"name\\": \\"John\\", \\"age\\": 23 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 }] >>> merge_sort_dict([{ \\"name\\": \\"John\\", \\"age\\": 23 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 },{ \\"name\\": \\"Dave\\", \\"age\\": 20 }], \'name\') [{ \\"name\\": \\"Dave\\", \\"age\\": 20 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 }, { \\"name\\": \\"John\\", \\"age\\": 23 }] >>> merge_sort_dict([], \'name\') [] ``` # Implementation Details * Ensure that your solutions handle empty inputs gracefully. * For `merge_sort_dict`, assume that all dictionaries in the list contain the specified key.","solution":"from typing import List, Dict, Union def merge_sort(collection: List[int]) -> List[int]: if len(collection) <= 1: return collection middle = len(collection) // 2 left_half = merge_sort(collection[:middle]) right_half = merge_sort(collection[middle:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index = right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list def merge_sort_dict(collection: List[Dict[str, Union[int, str]]], key: str) -> List[Dict[str, Union[int, str]]]: if len(collection) <= 1: return collection middle = len(collection) // 2 left_half = merge_sort_dict(collection[:middle], key) right_half = merge_sort_dict(collection[middle:], key) return merge_dict(left_half, right_half, key) def merge_dict(left: List[Dict[str, Union[int, str]]], right: List[Dict[str, Union[int, str]]], key: str) -> List[Dict[str, Union[int, str]]]: sorted_list = [] left_index = right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index][key] <= right[right_index][key]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Question Create a function that reads a JSON file containing weather data for a given city and converts it into a more user-friendly format. The resulting structure should be a dictionary containing specific keys, with their respective values. Function Signature ```python def process_weather_data(file_path: str) -> dict[str, Any]: ``` Input * `file_path` (str): The path to the JSON file containing weather data. Output * Returns a dictionary containing processed weather information with the following keys: * `city` (str): Name of the city. * `temperature` (float): Current temperature in Celsius. * `humidity` (int): Percentage of humidity. * `weather` (str): Description of the current weather (e.g., \\"Clear sky\\", \\"Rain\\"). * `coordinates` (dict): Dictionary containing `lat` (latitude) and `lon` (longitude). Constraints * The JSON file will follow a common weather API structure. * Handle file reading errors gracefully and return an empty dictionary in case of errors. * If the required data is missing or malformed, handle it appropriately by returning an empty dictionary. Example Given a JSON file `weather.json` with the content: ```json { \\"name\\": \\"London\\", \\"main\\": { \\"temp\\": 288.55, \\"humidity\\": 87 }, \\"weather\\": [ { \\"description\\": \\"light rain\\" } ], \\"coord\\": { \\"lat\\": 51.51, \\"lon\\": -0.13 } } ``` `process_weather_data(\\"weather.json\\")` should return: ```python { \\"city\\": \\"London\\", \\"temperature\\": 15.4, \\"humidity\\": 87, \\"weather\\": \\"light rain\\", \\"coordinates\\": { \\"lat\\": 51.51, \\"lon\\": -0.13 } } ``` Notes: * The temperature in the JSON file is given in Kelvin. Convert it to Celsius using `C = K - 273.15`. * Use the `json` module in Python to handle JSON parsing. * Aim to write clean, maintainable, and well-documented code.","solution":"import json from typing import Any, Dict def process_weather_data(file_path: str) -> Dict[str, Any]: Processes a JSON file containing weather data and converts it into a more user-friendly format. Parameters: - file_path (str): The path to the JSON file containing weather data. Returns: - dict[str, Any]: A dictionary containing processed weather information or an empty dictionary in case of error. try: with open(file_path, \'r\') as file: data = json.load(file) city = data.get(\'name\', \'\') temperature = data.get(\'main\', {}).get(\'temp\') - 273.15 if \'main\' in data and \'temp\' in data[\'main\'] else None humidity = data.get(\'main\', {}).get(\'humidity\', None) weather_description = data.get(\'weather\', [{}])[0].get(\'description\', \'\') coordinates = data.get(\'coord\', {\'lat\': None, \'lon\': None}) if not city or temperature is None or humidity is None or not weather_description or \'lat\' not in coordinates or \'lon\' not in coordinates: return {} result = { \'city\': city, \'temperature\': round(temperature, 2), \'humidity\': humidity, \'weather\': weather_description, \'coordinates\': { \'lat\': coordinates.get(\'lat\'), \'lon\': coordinates.get(\'lon\') } } return result except (json.JSONDecodeError, FileNotFoundError): return {}"},{"question":"# Question **Heap Sort Implementation** As a developer, you are required to implement the Heap Sort algorithm, a comparison-based sorting algorithm that uses a binary heap data structure. Your task is to write a function that sorts an array of integers in non-decreasing order using Heap Sort. Requirements 1. Implement the `heap_sort` function. 2. The function should take a single parameter: - `arr` (List[int]): A list of integers that needs to be sorted. 3. The function should return the sorted list. **Example:** ```python output = heap_sort([4, 6, 3, 2, 8, 5, 7, 1]) # Expected output is the array sorted in non-decreasing order. print(output) ``` **Expected Output:** ```plaintext [1, 2, 3, 4, 5, 6, 7, 8] ``` **Additional Tests:** ```python def test_case_1(): assert heap_sort([0, 3, 2, 1, -1, 7, 4]) == [-1, 0, 1, 2, 3, 4, 7] def test_case_2(): assert heap_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_case_3(): assert heap_sort([]) == [] def test_case_4(): assert heap_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] ``` **Implementation Notes:** 1. Implement a helper function to maintain the max heap property used in Heap Sort. 2. Heap Sort consists of two main phases: building a max heap and repeatedly extracting the maximum element to build the sorted array. 3. Be mindful of edge cases such as an empty array or an array with identical elements. Write your implementation to fulfill these requirements and pass the provided test cases.","solution":"def heapify(arr, n, i): Converts a subtree rooted with node i into a max heap. largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] > arr[largest]: largest = l if r < n and arr[r] > arr[largest]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) def heap_sort(arr): n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr"},{"question":"# Problem Statement You are given an array of integers where all elements appear twice except for one element which appears only once. Your task is to find and return the unique element that appears only once. # Input - An array of integers, `nums`, which contains 2n + 1 elements where n is a non-negative integer. # Output - The function should return the integer that appears only once in the array. # Constraints 1. The length of the array is odd. 2. Each element in the array appears exactly twice except for one element which appears only once. # Requirements 1. Implement the function `find_unique_element(nums: List[int]) -> int` that adheres to the above constraints and solves the problem. 2. The function should have a linear runtime complexity. 3. You may not use extra memory for a hash set or similar; optimize for space where possible. # Example - Example 1: ```python nums = [2, 3, 2, 4, 4, 5, 5] print(find_unique_element(nums)) # Output: 3 ``` - Example 2: ```python nums = [1, 1, 7, 2, 2] print(find_unique_element(nums)) # Output: 7 ``` # Hint Think about using bitwise operations to solve this problem efficiently. # Function Signature ```python from typing import List def find_unique_element(nums: List[int]) -> int: # Your code here pass ``` # Evaluation Your solution will be evaluated based on: 1. **Correctness**: Accurate identification of the unique element. 2. **Efficiency**: The time complexity should be linear, and the space complexity should be optimal. 3. **Code Quality**: Clear, readable, and well-commented code.","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Find the element that appears only once in the array where all other elements appear twice. Args: nums (List[int]): The input array containing integers. Returns: int: The integer that appears only once. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Coding Assessment Question You are assigned to implement a function that processes a given list of integers by applying a specific operation to its elements. Further, you need to write unit tests using `unittest` framework to ensure the function works correctly with various edge cases. Scenario Your task is to write a function `process_numbers` which takes a list of integers and a string representing the operation to be applied to each element. The possible operations are \\"square\\", \\"cube\\", and \\"double\\". Additionally, you need to write test cases to ensure the function handles different scenarios appropriately. Implementation Details **Function: process_numbers(numbers: List[int], operation: str) -> List[int]** * **Inputs**: - `numbers` (List[int]): A list of integers to be processed. - `operation` (str): A string specifying the operation, can be \\"square\\", \\"cube\\", or \\"double\\". * **Outputs**: - A list of integers where the specified operation has been applied to each element. **Unit Testing Function** * Write a function `test_process_numbers` that uses the `unittest` framework to verify the correctness of `process_numbers`. * Include tests for each operation type, an empty list, and invalid operations. Example: ```python from typing import List import unittest def process_numbers(numbers: List[int], operation: str) -> List[int]: if operation == \\"square\\": return [x ** 2 for x in numbers] elif operation == \\"cube\\": return [x ** 3 for x in numbers] elif operation == \\"double\\": return [x * 2 for x in numbers] else: raise ValueError(\\"Invalid operation\\") class TestProcessNumbers(unittest.TestCase): def test_square(self): self.assertEqual(process_numbers([1, 2, 3], \\"square\\"), [1, 4, 9]) def test_cube(self): self.assertEqual(process_numbers([1, 2, 3], \\"cube\\"), [1, 8, 27]) def test_double(self): self.assertEqual(process_numbers([1, 2, 3], \\"double\\"), [2, 4, 6]) def test_empty_list(self): self.assertEqual(process_numbers([], \\"square\\"), []) def test_invalid_operation(self): with self.assertRaises(ValueError): process_numbers([1, 2, 3], \\"quadruple\\") if __name__ == \\"__main__\\": unittest.main() ``` In the above example, you need to ensure the correctness of `process_numbers` by developing appropriate test cases using `unittest`. **Constraints**: * Inputs are guaranteed to be a list of integers and a string representing the operation. * Handle edge cases such as an empty list or invalid operation. * Use Python\'s `unittest` framework for testing. Complete the implementation and ensure it adheres to the requirements.","solution":"from typing import List def process_numbers(numbers: List[int], operation: str) -> List[int]: if operation == \\"square\\": return [x ** 2 for x in numbers] elif operation == \\"cube\\": return [x ** 3 for x in numbers] elif operation == \\"double\\": return [x * 2 for x in numbers] else: raise ValueError(\\"Invalid operation\\")"},{"question":"# Question You are tasked with analyzing a bioinformatics dataset, where you need to calculate the GC content of a given DNA sequence. The GC content represents the percentage of nucleotides in a DNA sequence that are either Guanine (G) or Cytosine (C). Implement a function `gc_content` that takes a DNA sequence as input and returns the GC content as a percentage, rounded to two decimal places. The function should handle invalid characters by raising a specific error. Function Signature ```python def gc_content(dna_sequence: str) -> float: ``` Input * `dna_sequence (str)`: A string representing a DNA sequence, consisting only of the characters A, T, G, and C (case insensitive). Output * Return the GC content as a float, rounded to two decimal places. Errors * If the DNA sequence contains any characters other than A, T, G, and C (case insensitive), the function should raise a `ValueError` with the message \\"Invalid character in DNA sequence\\". Example ```python >>> gc_content(\\"ATGCCGTAAGT\\") 45.45 >>> gc_content(\\"ATGCATGCAAA\\") 40.00 >>> gc_content(\\"GGGGCCCC\\") 100.00 ``` Errors ```python >>> gc_content(\\"ATGCCGTXAGT\\") Traceback (most recent call last): ... ValueError: Invalid character in DNA sequence >>> gc_content(\\"ATGC123\\") Traceback (most recent call last): ... ValueError: Invalid character in DNA sequence ``` Notes * The DNA sequence may be in either lowercase or uppercase. The function should handle both uniformly. * Valid characters for a DNA sequence are A, T, G, and C only. Any deviation should result in an error.","solution":"def gc_content(dna_sequence: str) -> float: Calculate the GC content of a given DNA sequence. Parameters: dna_sequence (str): A string representing a DNA sequence, consisting only of the characters A, T, G, and C (case insensitive). Returns: float: GC content as a percentage, rounded to two decimal places. Raises: ValueError: If the DNA sequence contains invalid characters. dna_sequence = dna_sequence.upper() valid_bases = {\'A\', \'T\', \'G\', \'C\'} if not set(dna_sequence).issubset(valid_bases): raise ValueError(\\"Invalid character in DNA sequence\\") gc_count = dna_sequence.count(\'G\') + dna_sequence.count(\'C\') gc_content_percentage = (gc_count / len(dna_sequence)) * 100 return round(gc_content_percentage, 2)"}]'),O={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},R={class:"card-container"},N={key:0,class:"empty-state"},L=["disabled"],z={key:0},D={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",R,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",N,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",z,"See more"))],8,L)):u("",!0)])}const Y=h(O,[["render",P],["__scopeId","data-v-d1002872"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/51.md","filePath":"quotes/51.md"}'),j={name:"quotes/51.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,U as default};
