import{_,o as r,c as n,a as t,m,t as d,C as g,M as p,U as b,f as u,F as x,p as y,e as w,q as v}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(s,e,l,h,i,a){return r(),n("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(l.poem.solution),1)])])])}const j=_(k,[["render",R],["__scopeId","data-v-15a68af6"]]),A=JSON.parse(`[{"question":"def longest_chain(words: List[str]) -> int: Returns the length of the longest chain of characters from the given list of strings. All characters in the longest chain must appear in non-decreasing order. :param words: List of strings :return: Integer length of the longest chain >>> longest_chain([\\"a\\", \\"b\\", \\"c\\"]) == 3 >>> longest_chain([\\"edc\\", \\"gfb\\", \\"a\\"]) == 7 >>> longest_chain([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) == 9 >>> longest_chain([\\"abc\\", \\"def\\", \\"ghi\\"]) == 9 >>> longest_chain([]) == 0 >>> longest_chain([\\"zxcvbnm\\"]) == 7 >>> longest_chain([\\"abcd\\", \\"abcd\\"]) == 8","solution":"def longest_chain(words): Returns the length of the longest chain of characters from the given list of strings. All characters in the longest chain must appear in non-decreasing order. :param words: List of strings :return: Integer length of the longest chain # Concatenate all words into one chain and sort it all_chars = ''.join(words) sorted_chars = sorted(all_chars) # The length of the sorted characters list is the length of the longest chain return len(sorted_chars)"},{"question":"from typing import List def minSteps(grid: List[List[int]]) -> int: Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner of the grid. If it is impossible to reach the bottom-right corner, returns -1. >>> minSteps([[1, 1, 0], [0, 1, 0], [0, 1, 1]]) 4 >>> minSteps([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) -1 >>> minSteps([[1, 1], [1, 1]]) 2 >>> minSteps([[1]]) 0 >>> minSteps([[0, 1], [1, 1]]) -1 >>> minSteps([[1, 1], [1, 0]]) -1 >>> minSteps([[1, 1, 1, 1], [0, 0, 1, 0], [1, 1, 1, 1], [1, 0, 0, 1]]) 6","solution":"from typing import List from collections import deque def minSteps(grid: List[List[int]]) -> int: Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner of the grid. If it is impossible to reach the bottom-right corner, returns -1. if not grid or not grid[0] or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 n, m = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (n-1, m-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: queue.append((nx, ny)) grid[nx][ny] = 0 # Mark as visited steps += 1 return -1"},{"question":"def rearrange_to_divisible_by_3(s: str) -> int: Given a string s containing only digits, determine if it can be rearranged into a number that is divisible by 3. Return the largest possible such number or -1 if it's not possible. >>> rearrange_to_divisible_by_3(\\"123\\") '321' >>> rearrange_to_divisible_by_3(\\"9876543210\\") '9876543210' >>> rearrange_to_divisible_by_3(\\"124\\") -1 >>> rearrange_to_divisible_by_3(\\"30\\") '30' >>> rearrange_to_divisible_by_3(\\"999\\") '999' >>> rearrange_to_divisible_by_3(\\"3\\") '3' >>> rearrange_to_divisible_by_3(\\"1\\") -1","solution":"def rearrange_to_divisible_by_3(s): Given a string s containing only digits, determine if it can be rearranged into a number that is divisible by 3. Return the largest possible such number or -1 if it's not possible. # Convert the string into a list of digits digits = [int(char) for char in s] # Sum of the digits digit_sum = sum(digits) # Check if sum of the digits is divisible by 3 if digit_sum % 3 != 0: return -1 # Sort digits in descending order to form the largest number possible digits.sort(reverse=True) # Join sorted digits and form the largest number largest_number = ''.join(map(str, digits)) return largest_number"},{"question":"from typing import List class SubmatrixSumFinder: def __init__(self, matrix: List[List[int]]): Initializes the SubmatrixSumFinder object with the matrix. Args: matrix (List[List[int]]): The 2D list of integers representing the matrix. Raises: ValueError: If the matrix is empty. pass def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int: Returns the sum of all elements in the submatrix defined by its upper-left corner (row1, col1) and lower-right corner (row2, col2). Args: row1 (int): Row number of the upper-left corner. col1 (int): Column number of the upper-left corner. row2 (int): Row number of the lower-right corner. col2 (int): Column number of the lower-right corner. Returns: int: The sum of all elements in the specified submatrix. pass # Unit tests def test_sumRegion_single_element(): matrix = [ [1, 2], [3, 4] ] finder = SubmatrixSumFinder(matrix) assert finder.sumRegion(0, 0, 0, 0) == 1 assert finder.sumRegion(1, 1, 1, 1) == 4 def test_sumRegion_full_matrix(): matrix = [ [1, 2], [3, 4] ] finder = SubmatrixSumFinder(matrix) assert finder.sumRegion(0, 0, 1, 1) == 10 def test_sumRegion_partial_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] finder = SubmatrixSumFinder(matrix) assert finder.sumRegion(1, 1, 2, 2) == 28 assert finder.sumRegion(0, 0, 1, 1) == 12 def test_sumRegion_edge_cases(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] finder = SubmatrixSumFinder(matrix) assert finder.sumRegion(0, 1, 1, 2) == 16 # Sum elements [2, 3, 5, 6] assert finder.sumRegion(1, 0, 2, 1) == 24 # Sum elements [4, 5, 7, 8] def test_empty_matrix(): empty_matrix = [] try: finder = SubmatrixSumFinder(empty_matrix) except ValueError as e: assert str(e) == \\"Matrix cannot be empty\\"","solution":"from typing import List class SubmatrixSumFinder: def __init__(self, matrix: List[List[int]]): if not matrix or not matrix[0]: raise ValueError(\\"Matrix cannot be empty\\") self.matrix = matrix self.m = len(matrix) self.n = len(matrix[0]) # Initialize the prefix sum matrix. self.prefix_sum = [[0] * (self.n + 1) for _ in range(self.m + 1)] # Calculate the prefix sum for each cell. for i in range(1, self.m + 1): for j in range(1, self.n + 1): self.prefix_sum[i][j] = (self.matrix[i - 1][j - 1] + self.prefix_sum[i - 1][j] + self.prefix_sum[i][j - 1] - self.prefix_sum[i - 1][j - 1]) def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int: return (self.prefix_sum[row2 + 1][col2 + 1] - self.prefix_sum[row1][col2 + 1] - self.prefix_sum[row2 + 1][col1] + self.prefix_sum[row1][col1])"},{"question":"def move_zeroes(nums: List[int]) -> None: Moves all zeros in the list to the end while maintaining the order of non-zero elements. Modifies the list in-place and returns nothing. >>> nums = [0, 1, 0, 3, 12] >>> move_zeroes(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [1, 2, 3, 4] >>> move_zeroes(nums) >>> nums [1, 2, 3, 4] >>> nums = [0, 0, 0, 0] >>> move_zeroes(nums) >>> nums [0, 0, 0, 0] >>> nums = [1, 0, 2, 0, 3, 0, 4] >>> move_zeroes(nums) >>> nums [1, 2, 3, 4, 0, 0, 0] >>> nums = [0] >>> move_zeroes(nums) >>> nums [0] >>> nums = [1] >>> move_zeroes(nums) >>> nums [1] >>> nums = [] >>> move_zeroes(nums) >>> nums []","solution":"def move_zeroes(nums): Moves all zeros in the list to the end while maintaining the order of non-zero elements. Modifies the list in-place and returns nothing. non_zero_index = 0 # pointer for non-zero elements # Iterate over the nums array for i in range(len(nums)): if nums[i] != 0: # Swap the elements nums[non_zero_index], nums[i] = nums[i], nums[non_zero_index] non_zero_index += 1"},{"question":"def maximalSquare(matrix: List[List[str]]) -> int: Given a rows x cols binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. >>> maximalSquare([]) == 0 >>> maximalSquare([[]]) == 0 >>> maximalSquare([['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0']]) == 0 >>> maximalSquare([['1', '1'], ['1', '1']]) == 4 >>> maximalSquare([['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0']]) == 4 >>> maximalSquare([['1', '1', '1', '1']]) == 1 >>> maximalSquare([['1', '1', '1', '0', '0', '0'], ['1', '1', '1', '0', '0', '0'], ['1', '1', '1', '0', '0', '0'], ['0', '0', '0', '1', '1', '1'], ['0', '0', '0', '1', '1', '1']]) == 9","solution":"def maximalSquare(matrix): Returns the area of the largest square containing only 1's in the binary matrix. if not matrix or not matrix[0]: return 0 max_side = 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i - 1][j - 1] == '1': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def largest_island(grid: List[List[int]]) -> int: Returns the size of the largest island in the given grid. >>> largest_island([ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0] ]) 5 >>> largest_island([ [1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 1], [0, 1, 0, 0] ]) 3 >>> largest_island([ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]) 0 >>> largest_island([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 9 >>> largest_island([ [1, 0, 1], [0, 1, 0], [1, 0, 1] ]) 1 >>> largest_island([]) 0 >>> largest_island([[1]]) 1 >>> largest_island([[0]]) 0","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or visited[i][j]: return 0 visited[i][j] = True return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1) max_island_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"from typing import List, Dict def shortest_path(graph: Dict[str, List[str]], start: str, target: str) -> List[str]: Write a function to find the shortest path between two nodes in an unweighted graph. The graph is represented as an adjacency list. Your function should take in the graph as a dictionary, the starting node, and the target node. Return a list of nodes representing the shortest path from the starting node to the target node. If no path exists, return an empty list. >>> graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } >>> shortest_path(graph, 'A', 'C') ['A', 'C'] >>> shortest_path(graph, 'A', 'F') ['A', 'C', 'F'] >>> shortest_path(graph, 'A', 'E') [] >>> shortest_path(graph, 'A', 'A') ['A'] >>> graph = { 'A': [] } >>> shortest_path(graph, 'A', 'A') ['A'] >>> shortest_path(graph, 'A', 'B') []","solution":"from collections import deque def shortest_path(graph, start, target): Finds the shortest path in an unweighted graph using BFS. Parameters: graph (dict): The graph represented as an adjacency list. start (node): The starting node. target (node): The target node. Returns: list: A list of nodes representing the shortest path from start to target, if no path exists, returns an empty list. if start not in graph or target not in graph: return [] queue = deque([[start]]) visited = set([start]) while queue: path = queue.popleft() node = path[-1] if node == target: return path for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) new_path = list(path) new_path.append(neighbor) queue.append(new_path) return []"},{"question":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays into one sorted array with unique elements. Parameters: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: A merged and sorted array with unique elements. >>> mergeSortedArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([1, 2, 3], [2, 3, 4]) [1, 2, 3, 4] >>> mergeSortedArrays([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> mergeSortedArrays([1, 2, 3], []) [1, 2, 3] >>> mergeSortedArrays([], [1, 2, 3]) [1, 2, 3] >>> mergeSortedArrays([], []) [] >>> mergeSortedArrays([1000, 2000], [1500, 2500]) [1000, 1500, 2000, 2500]","solution":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays into one sorted array with unique elements. Parameters: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: A merged and sorted array with unique elements. merged_set = set(arr1).union(set(arr2)) merged_list = sorted(merged_set) return merged_list"},{"question":"def minStudentsToMove(arr): Returns the minimum number of students to move to get a strictly increasing sequence. >>> minStudentsToMove([4, 3, 2, 6, 5, 7]) == 3 >>> minStudentsToMove([1, 2, 3, 4, 5]) == 0 >>> minStudentsToMove([5, 4, 3, 2, 1]) == 4 >>> minStudentsToMove([5, 1, 3, 2, 4]) == 2 >>> minStudentsToMove([10]) == 0 >>> minStudentsToMove([]) == 0 >>> minStudentsToMove([1, 2, 2, 3]) == 1 >>> minStudentsToMove([1, 3, 2, 4, 3, 5]) == 2","solution":"def minStudentsToMove(arr): Returns the minimum number of students to move to get a strictly increasing sequence. The approach uses the length of the Longest Increasing Subsequence (LIS) since the minimum number of students to move is \`len(arr) - length of LIS\`. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return n - max(lis)"},{"question":"def is_valid_bst(arr): Determines if the given binary tree represented as an array is a valid BST. :param arr: List[int], a list of integers where arr represents a binary tree. :return: bool, True if the tree is a valid BST, False otherwise. # Your code goes here from solution import is_valid_bst def test_valid_bst(): assert is_valid_bst([2, 1, 3]) == True def test_invalid_bst_with_incorrect_left_child(): assert is_valid_bst([5, 1, 4, None, None, 3, 6]) == False def test_invalid_bst_with_incorrect_right_child(): assert is_valid_bst([10, 5, 15, None, None, 6, 20]) == False def test_single_node_tree(): assert is_valid_bst([10]) == True def test_empty_tree(): assert is_valid_bst([]) == True def test_null_node_in_tree(): assert is_valid_bst([10, None, 15, None, None, 13, 16]) == True def test_valid_bst_large(): assert is_valid_bst([10, 5, 15, 2, 7, 12, 18, 1, 3, 6, 8, 11, 13, 17, 19]) == True def test_invalid_bst_large(): assert is_valid_bst([10, 5, 15, 2, 7, 12, 18, 1, 3, 6, 8, 16, 13, 17, 19]) == False","solution":"def is_valid_bst(arr): Determines if the given binary tree represented as an array is a valid BST. :param arr: List[int], a list of integers where arr represents a binary tree. :return: bool, True if the tree is a valid BST, False otherwise. def is_bst_util(index, left, right): if index >= len(arr) or arr[index] == None: return True if arr[index] <= left or arr[index] >= right: return False left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 return (is_bst_util(left_child_index, left, arr[index]) and is_bst_util(right_child_index, arr[index], right)) return is_bst_util(0, float('-inf'), float('inf'))"},{"question":"def num_distinct_islands(grid: List[List[str]]) -> int: Given a grid of size \`m x n\`, consisting of 'X' and 'O' characters, where 'X' represents land and 'O' represents water, return the number of distinct islands. An island is a group of connected 'X's (land), connected horizontally, vertically, or diagonally. You may assume all four edges of the grid are surrounded by water. >>> num_distinct_islands([ [\\"X\\",\\"O\\",\\"O\\",\\"X\\",\\"X\\"], [\\"X\\",\\"X\\",\\"O\\",\\"O\\",\\"X\\"], [\\"O\\",\\"X\\",\\"X\\",\\"O\\",\\"O\\"], [\\"O\\",\\"O\\",\\"O\\",\\"O\\",\\"X\\"] ]) 3 >>> num_distinct_islands([ [\\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\"] ]) 0 >>> num_distinct_islands([ [\\"X\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"O\\", \\"X\\"] ]) 1 >>> num_distinct_islands([ [\\"X\\",\\"X\\"], [\\"X\\",\\"X\\"] ]) 1 >>> num_distinct_islands([ [\\"O\\"] ]) 0 pass","solution":"def num_distinct_islands(grid): Returns the number of distinct islands in the given grid. def dfs(i, j): stack = [(i, j)] while stack: x, y = stack.pop() if 0 <= x < m and 0 <= y < n and grid[x][y] == 'X': grid[x][y] = 'O' # Mark the cell as visited # Explore all 8 possible directions (horizontally, vertically, and diagonally) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for dx, dy in directions: stack.append((x + dx, y + dy)) if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 'X': island_count += 1 dfs(i, j) return island_count"},{"question":"def can_distribute_candies(candies: List[int], k: int) -> List[bool]: Determines if each type of candy can be evenly distributed among k friends. Parameters: candies (list of int): List where candies[i] represents the number of candies of type i. k (int): Number of friends to distribute the candies to. Returns: list of bool: List where answer[i] is true if candies[i] can be evenly distributed among k friends, false otherwise. >>> can_distribute_candies([8, 12, 16], 4) [True, True, True] >>> can_distribute_candies([7, 5, 11], 3) [False, False, False] >>> can_distribute_candies([10, 15, 20], 5) [True, True, True] >>> can_distribute_candies([10, 16, 20], 5) [True, False, True] >>> can_distribute_candies([10], 5) [True] >>> can_distribute_candies([7], 2) [False] >>> can_distribute_candies([3, 4, 5], 10) [False, False, False] >>> can_distribute_candies([], 3) []","solution":"def can_distribute_candies(candies, k): Determines if each type of candy can be evenly distributed among k friends. Parameters: candies (list of int): List where candies[i] represents the number of candies of type i. k (int): Number of friends to distribute the candies to. Returns: list of bool: List where answer[i] is true if candies[i] can be evenly distributed among k friends, false otherwise. return [candy % k == 0 for candy in candies]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root): Return the number of \\"good\\" nodes in the binary tree rooted at \`root\`. A node X in the binary tree is named \\"good\\" if in the path from root to X there are no nodes with a value greater than X. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(3) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(5) >>> good_nodes(root) 4 >>> root = TreeNode(1) >>> good_nodes(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.left = TreeNode(5) >>> root.right.right = TreeNode(6) >>> good_nodes(root) 6 >>> root = TreeNode(5) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(1) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(1) >>> good_nodes(root) 1 >>> root = TreeNode(3) >>> root.left = TreeNode(3) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(4) >>> root.right.left = TreeNode(2) >>> root.right.right = TreeNode(6) >>> good_nodes(root) 5","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root): def dfs(node, max_val): if not node: return 0 # Determine if the current node is \\"good\\" is_good = node.val >= max_val total_good = 1 if is_good else 0 # Update the max value on this path new_max_val = max(max_val, node.val) # Continue the search on the left and right subtrees total_good += dfs(node.left, new_max_val) total_good += dfs(node.right, new_max_val) return total_good return dfs(root, root.val)"},{"question":"def maximal_square(matrix: List[List[int]]) -> int: You are given a matrix \`mat\` of dimensions \`m x n\` where each cell contains either a \`0\` or a \`1\`. You need to find the largest square that contains only \`1\`s and return its area. >>> maximal_square([[0]]) == 0 >>> maximal_square([[1]]) == 1 >>> maximal_square([]) == 0 >>> maximal_square([[]]) == 0 >>> maximal_square([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) == 4 >>> maximal_square([ ... [0, 1, 1, 0, 0], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [0, 1, 1, 1, 1], ... [0, 0, 1, 1, 1] ... ]) == 9 >>> maximal_square([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> maximal_square([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 pass","solution":"def maximal_square(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"class MaxSumPath: def __init__(self, grid: List[List[int]]): Initializes the object with the integer matrix grid. pass def getMaxSumPath(self) -> int: Returns the maximum sum of a path from the top-left to the bottom-right cell in the grid. pass # Unit Tests def test_max_sum_path_single_element(): grid = [[5]] path = MaxSumPath(grid) assert path.getMaxSumPath() == 5 def test_max_sum_path_row(): grid = [ [1, 2, 3, 4] ] path = MaxSumPath(grid) assert path.getMaxSumPath() == 10 def test_max_sum_path_column(): grid = [ [1], [2], [3], [4] ] path = MaxSumPath(grid) assert path.getMaxSumPath() == 10 def test_max_sum_path_rectangle(): grid = [ [1, 2, 3], [4, 5, 6] ] path = MaxSumPath(grid) assert path.getMaxSumPath() == 16 def test_max_sum_path_example(): grid = [ [5, 3, 2, 1], [1, 2, 10, 3], [4, 3, 2, 1] ] path = MaxSumPath(grid) assert path.getMaxSumPath() == 24","solution":"class MaxSumPath: def __init__(self, grid): self.grid = grid self.m = len(grid) self.n = len(grid[0]) def getMaxSumPath(self): dp = [[0] * self.n for _ in range(self.m)] dp[0][0] = self.grid[0][0] for i in range(1, self.m): dp[i][0] = dp[i-1][0] + self.grid[i][0] for j in range(1, self.n): dp[0][j] = dp[0][j-1] + self.grid[0][j] for i in range(1, self.m): for j in range(1, self.n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + self.grid[i][j] return dp[self.m - 1][self.n - 1]"},{"question":"def min_coins(nums, target): Determine the minimum number of coins required to make the target amount. Args: nums (List[int]): List of non-negative integers representing coin values. target (int): Target amount. Returns: int: Minimum number of coins needed to make the target amount or -1 if it's not possible. >>> min_coins([1, 2, 5], 11) # 11 can be made with 5+5+1 3 >>> min_coins([2], 3) # Not possible to make 3 with only coins of 2 -1 >>> min_coins([1, 2, 5], 0) # No coins needed to make 0 amount 0 >>> min_coins([1], 5) # 1 can be used 5 times to make 5 5 >>> min_coins([5], 5) # One coin of 5 1 >>> min_coins([2, 4], 7) # It's not possible, not by the fact that it's infeasible. After all, the latter is still A reason to fail Solution: def solution(nums, target): Determine the minimum number of coins required to make the target amount. Args: nums (List[int]): List of non-negative integers representing coin values. target (int): Target amount. Returns: int: Minimum number of coins needed to make the target amount or -1 if it's not possible. if target == 0: return 0 # Initialize DP array with a large value (target + 1 is used here as a form of \\"infinity\\") dp = [target + 1] * (target + 1) dp[0] = 0 # Populate the dp array for coin in nums: for x in range(coin, target + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[target] if dp[target] != target + 1 else -1","solution":"def min_coins(nums, target): Determine the minimum number of coins required to make the target amount. Args: nums (List[int]): List of non-negative integers representing coin values. target (int): Target amount. Returns: int: Minimum number of coins needed to make the target amount or -1 if it's not possible. if target == 0: return 0 # Initialize DP array with a large value (target + 1 is used here as a form of \\"infinity\\") dp = [target + 1] * (target + 1) dp[0] = 0 # Populate the dp array for coin in nums: for x in range(coin, target + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[target] if dp[target] != target + 1 else -1"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the maximum amount of rainwater that can be trapped between the buildings. :param heights: List[int] - The heights of the buildings. :return: int - The maximum amount of rainwater that can be trapped. >>> trap_rain_water([]) == 0 >>> trap_rain_water([1]) == 0 >>> trap_rain_water([1, 2]) == 0 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([3, 3, 3, 3, 3]) == 0 >>> trap_rain_water([5, 4, 3, 2, 1]) == 0 >>> trap_rain_water([0, 3, 0, 2, 0, 4]) == 7 pass","solution":"def trap_rain_water(heights): Calculate the maximum amount of rainwater that can be trapped between the buildings. :param heights: List[int] - The heights of the buildings. :return: int - The maximum amount of rainwater that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from collections import deque def min_operations(start, end): Return the minimum number of operations required to transform \`start\` to \`end\`. The operations allowed are: - Add 1 to the current integer. - Subtract 1 from the current integer. - Multiply the current integer by 2. - Divide the current integer by 2 (only if the current integer is even). >>> min_operations(5, 5) 0 >>> min_operations(1, 2) 1 >>> min_operations(2, 1) 1 >>> min_operations(2, 4) 1 >>> min_operations(4, 2) 1 >>> min_operations(3, 10) 3 >>> min_operations(1, 1024) 10 >>> min_operations(1024, 1) 10","solution":"from collections import deque def min_operations(start, end): Return the minimum number of operations required to transform \`start\` to \`end\`. The operations allowed are: - Add 1 to the current integer. - Subtract 1 from the current integer. - Multiply the current integer by 2. - Divide the current integer by 2 (only if the current integer is even). if start == end: return 0 queue = deque([(start, 0)]) # (current value, number of steps) visited = set([start]) # To avoid revisiting nodes while queue: current, steps = queue.popleft() for next_value in (current + 1, current - 1, current * 2, current // 2 if current % 2 == 0 else current): if next_value == end: return steps + 1 if next_value not in visited: visited.add(next_value) queue.append((next_value, steps + 1)) return -1"},{"question":"def find_cheapest_flight(n, flights, src, dst): Returns the minimum cost to travel from src to dst. If there is no way to reach dst from src, returns -1. :param n: int - number of cities :param flights: List[List[int]] - list of flights [city1, city2, cost] :param src: int - starting city :param dst: int - destination city :return: int - minimum cost to reach dst from src, or -1 if unreachable # Implementation goes here # Test cases def test_no_flights(): assert find_cheapest_flight(3, [], 0, 2) == -1 def test_direct_flight(): assert find_cheapest_flight(3, [[0, 2, 100]], 0, 2) == 100 def test_indirect_flight(): assert find_cheapest_flight(3, [[0, 1, 50], [1, 2, 50]], 0, 2) == 100 def test_multiple_path_choice(): assert find_cheapest_flight(4, [[0, 1, 100], [1, 2, 100], [0, 2, 500], [2, 3, 100]], 0, 3) == 300 def test_no_path_available(): assert find_cheapest_flight(3, [[0, 1, 100]], 0, 2) == -1 def test_self_to_self(): assert find_cheapest_flight(3, [[0, 1, 100]], 1, 1) == 0 def test_complex_graph(): flights = [ [0, 1, 100], [1, 2, 100], [0, 2, 500], [2, 3, 200], [1, 3, 400], [0, 3, 800] ] assert find_cheapest_flight(4, flights, 0, 3) == 400","solution":"import heapq def find_cheapest_flight(n, flights, src, dst): Returns the minimum cost to travel from src to dst. If there is no way to reach dst from src, returns -1. :param n: int - number of cities :param flights: List[List[int]] - list of flights [city1, city2, cost] :param src: int - starting city :param dst: int - destination city :return: int - minimum cost to reach dst from src, or -1 if unreachable graph = {i: [] for i in range(n)} for flight in flights: graph[flight[0]].append((flight[1], flight[2])) # Priority queue to store (cost, node) pq = [(0, src)] min_cost = {i: float('inf') for i in range(n)} min_cost[src] = 0 while pq: current_cost, current_city = heapq.heappop(pq) if current_city == dst: return current_cost for neighbor, cost in graph[current_city]: next_cost = current_cost + cost if next_cost < min_cost[neighbor]: min_cost[neighbor] = next_cost heapq.heappush(pq, (next_cost, neighbor)) return -1 if min_cost[dst] == float('inf') else min_cost[dst]"},{"question":"def min_operations_to_remove_all(arr: List[int], k: int) -> int: Determine the minimum number of operations required to remove all elements from the array. >>> min_operations_to_remove_all([1, 2, 3, 4], 2) 2 >>> min_operations_to_remove_all([1, 2, 3, 4, 5, 6], 3) 2 >>> min_operations_to_remove_all([1, 2, 3, 4, 5], 1) 5 >>> min_operations_to_remove_all([1, 2], 3) -1 >>> min_operations_to_remove_all([1], 2) -1 >>> min_operations_to_remove_all([1], 1) 1 >>> min_operations_to_remove_all([1, 1, 1, 1], 4) 1 >>> min_operations_to_remove_all([2, 4, 6, 8], 5) -1","solution":"def min_operations_to_remove_all(arr, k): length = len(arr) # If k is larger than length, it's impossible to remove all elements if k > length: return -1 # Number of operations is the ceiling of length divided by k # This is equivalent to (length + k - 1) // k # which ensures that any remainder still requires an additional operation operations = (length + k - 1) // k return operations"},{"question":"def search_in_rotated_array(numbers, target): Performs a search in a rotated sorted array to find the target value. :param numbers: List[int] - A rotated sorted array :param target: int - The target value to be searched :return: int - The index of the target if found, otherwise -1 >>> search_in_rotated_array([4,5,6,7,0,1,2], 0) 4 >>> search_in_rotated_array([4,5,6,7,0,1,2], 3) -1 >>> search_in_rotated_array([1], 0) -1 >>> search_in_rotated_array([1], 1) 0 >>> search_in_rotated_array([1, 3], 3) 1 >>> search_in_rotated_array([1, 3], 1) 0 >>> search_in_rotated_array([4,5,6,7,0,1,2], 8) -1 >>> search_in_rotated_array([], 0) -1 >>> search_in_rotated_array([1, 2, 3, 4, 5, 6, 7], 10) -1 >>> search_in_rotated_array([7, 8, 1, 2, 3, 4, 5, 6], 7) 0 >>> search_in_rotated_array([7, 8, 1, 2, 3, 4, 5, 6], 8) 1 >>> search_in_rotated_array([7, 8, 1, 2, 3, 4, 5, 6], 1) 2 >>> search_in_rotated_array([7, 8, 1, 2, 3, 4, 5, 6], 6) 7","solution":"def search_in_rotated_array(numbers, target): Performs a search in a rotated sorted array to find the target value. :param numbers: List[int] - A rotated sorted array :param target: int - The target value to be searched :return: int - The index of the target if found, otherwise -1 if not numbers: return -1 left, right = 0, len(numbers) - 1 while left <= right: mid = left + (right - left) // 2 if numbers[mid] == target: return mid # Determine the sorted half of the array if numbers[left] <= numbers[mid]: # Left half is sorted if numbers[left] <= target < numbers[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if numbers[mid] < target <= numbers[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def rob(houses: List[int]) -> int: Computes the maximum amount of money that can be robbed without alerting the police. Args: houses (list): List of non-negative integers representing the amount of money in each house. Returns: int: Maximum amount of money that can be robbed. >>> rob([]) == 0 >>> rob([10]) == 10 >>> rob([10, 15]) == 15 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 1, 1, 2]) == 4 >>> rob([100, 200, 300, 400, 500]) == 900 >>> rob([0, 0, 0, 0, 0]) == 0","solution":"def rob(houses): Computes the maximum amount of money that can be robbed without alerting the police. Args: houses (list): List of non-negative integers representing the amount of money in each house. Returns: int: Maximum amount of money that can be robbed. if not houses: return 0 n = len(houses) if n == 1: return houses[0] # Initialize the dp array dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of swaps required to sort the array in non-decreasing order. >>> min_swaps_to_sort([4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_swaps_to_sort([5, 4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 5, 4, 2, 3]) 3 >>> min_swaps_to_sort([1]) 0 >>> min_swaps_to_sort([2, 1]) 1","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in non-decreasing order. # Create a list of tuples where each tuple is (index, element) indexed_arr = list(enumerate(arr)) # Sort the array based on the elements indexed_arr.sort(key=lambda x: x[1]) visited = [False] * len(arr) swaps = 0 for i in range(len(arr)): # If already visited or already in the right place if visited[i] or indexed_arr[i][0] == i: continue # Find number of nodes in this cycle cycle_size = 0 j = i while not visited[j]: visited[j] = True j = indexed_arr[j][0] cycle_size += 1 # If there is cycle of size n, it will take (n-1) swaps to fix it if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLargestPathSum(root: TreeNode) -> int: Given the root of a binary tree, return the maximum sum of values from any path in the tree. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. >>> findLargestPathSum(TreeNode(1, TreeNode(2), TreeNode(3))) 6 >>> findLargestPathSum(TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) 42 # Add your implementation here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLargestPathSum(root): def max_gain(node): nonlocal max_sum if not node: return 0 # Max sum on the left and right sub-trees of node left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # Price to start a new path where \`node\` is the highest node new_path_sum = node.val + left_gain + right_gain # Update max_sum if it's better to start a new path max_sum = max(max_sum, new_path_sum) # For recursion, return the max gain if continue the same path return node.val + max(left_gain, right_gain) max_sum = float('-inf') max_gain(root) return max_sum"},{"question":"def trap(height): Compute how much water can be trapped between the buildings after it rains. :param height: List[int] - List of integers representing height of buildings :return: int - Total units of water trapped >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([4,2,0,3,2,5]) == 9 >>> trap([]) == 0 >>> trap([1,2,3,4,5]) == 0 >>> trap([5,4,3,2,1]) == 0 >>> trap([3,3,3,3,3]) == 0 >>> trap([5]) == 0 >>> trap([5,2]) == 0","solution":"def trap(height): Compute how much water can be trapped between the buildings after it rains. :param height: List[int] - List of integers representing height of buildings :return: int - Total units of water trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def num_of_subsequences(s: str, word: str) -> int: Returns the number of times \`word\` appears as a subsequence within \`s\`. :param s: String consisting of lowercase English letters. :param word: String word to find as a subsequence within \`s\`. :return: Number of times \`word\` appears as a subsequence within \`s\`. >>> num_of_subsequences(\\"babgbag\\", \\"bag\\") 5 >>> num_of_subsequences(\\"rabbbit\\", \\"rabbit\\") 3 >>> num_of_subsequences(\\"abc\\", \\"d\\") 0 >>> num_of_subsequences(\\"abcdef\\", \\"gh\\") 0 >>> num_of_subsequences(\\"abcbc\\", \\"abc\\") 3 >>> num_of_subsequences(\\"aaaa\\", \\"aa\\") 6 >>> num_of_subsequences(\\"abcdef\\", \\"\\") 1 >>> num_of_subsequences(\\"\\", \\"\\") 1 >>> num_of_subsequences(\\"\\", \\"a\\") 0 >>> num_of_subsequences(\\"\\", \\"abc\\") 0 # Your code here","solution":"def num_of_subsequences(s, word): Returns the number of times \`word\` appears as a subsequence within \`s\`. :param s: String consisting of lowercase English letters. :param word: String word to find as a subsequence within \`s\`. :return: Number of times \`word\` appears as a subsequence within \`s\`. m, n = len(s), len(word) if n == 0: return 1 dp = [0] * (n + 1) dp[0] = 1 for i in range(m): for j in range(n - 1, -1, -1): if s[i] == word[j]: dp[j + 1] += dp[j] return dp[n]"},{"question":"from typing import List, Tuple def max_login_span(logs: List[Tuple[int, int]]) -> int: Returns the maximum span of login times on a single day. Args: logs (List[Tuple[int, int]]): A list of tuples where each tuple represents (day, time) of login. Returns: int: The maximum span of login times in a day. Examples: >>> max_login_span([(1, 5), (1, 2), (1, 3), (1, 10)]) 8 >>> max_login_span([(1, 8), (1, 5), (2, 15), (2, 10), (2, 20)]) 10 >>> max_login_span([(1, 1), (2, 2), (3, 3)]) 0 >>> max_login_span([(1, 1)]) 0 >>> max_login_span([]) 0 >>> max_login_span([(1, 10), (1, 1), (1, 100), (2, 5), (2, 15), (2, 25)]) 99 >>> max_login_span([(1, 5), (1, 5), (2, 10), (2, 10)]) 0","solution":"from collections import defaultdict def max_login_span(logs): Returns the maximum span of login times on a single day. Args: logs (List[(int, int)]): A list of tuples where each tuple represents (day, time) of login. Returns: int: The maximum span of login times in a day. day_logs = defaultdict(list) for day, time in logs: day_logs[day].append(time) max_span = 0 for times in day_logs.values(): if len(times) > 1: times.sort() span = times[-1] - times[0] if span > max_span: max_span = span return max_span"},{"question":"def search_sorted_matrix(matrix, target): Searches for the target in a 2D sorted matrix (rows and columns sorted). Returns the position (row_index, column_index) if found, else (-1, -1). >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> search_sorted_matrix(matrix, 5) (1, 1) >>> search_sorted_matrix(matrix, 10) (-1, -1) >>> matrix = [] >>> search_sorted_matrix(matrix, 1) (-1, -1) >>> matrix = [[]] >>> search_sorted_matrix(matrix, 1) (-1, -1) >>> matrix = [[1]] >>> search_sorted_matrix(matrix, 1) (0, 0) >>> search_sorted_matrix(matrix, 2) (-1, -1) >>> matrix = [ ... [1, 2, 2], ... [3, 4, 5], ... [6, 6, 6] ... ] >>> search_sorted_matrix(matrix, 2) (0, 1) >>> matrix = [ ... [1, 3, 5], ... [7, 9, 11], ... [13, 15, 17] ... ] >>> search_sorted_matrix(matrix, 1) (0, 0) >>> search_sorted_matrix(matrix, 17) (2, 2) >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_sorted_matrix(matrix, 5) (1, 1) >>> search_sorted_matrix(matrix, 20) (-1, -1)","solution":"def search_sorted_matrix(matrix, target): Searches for the target in a 2D sorted matrix (rows and columns sorted). Returns the position (row_index, column_index) if found, else (-1, -1). if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) for i in range(rows): for j in range(cols): if matrix[i][j] == target: return (i, j) return (-1, -1)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string by replacing occurrences of \\"ab\\" with \\"ba\\". >>> lexicographically_smallest_string(\\"ab\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"ba\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"cba\\") == \\"abc\\" >>> lexicographically_smallest_string(\\"bbaac\\") == \\"aabbc\\" >>> lexicographically_smallest_string(\\"ccba\\") == \\"abcc\\" >>> lexicographically_smallest_string(\\"a\\") == \\"a\\" >>> lexicographically_smallest_string(\\"abc\\") == \\"abc\\" >>> lexicographically_smallest_string(\\"bacab\\") == \\"aabbc\\" >>> lexicographically_smallest_string(\\"cbbbaaacc\\") == \\"aaabbbccc\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string by replacing occurrences of \\"ab\\" with \\"ba\\". # Continuously move 'a' characters to the left in the presence of 'b'. # This can be done by sorting part here to get the effect in O(nlogn) time. sorted_segments = ''.join(sorted(s)) return sorted_segments"},{"question":"def digits_greater_than_average(s: str) -> int: Returns the number of digits in the string s that are greater than the average of all digits present in the string. >>> digits_greater_than_average(\\"abcdef\\") == 0 >>> digits_greater_than_average(\\"11111\\") == 0 >>> digits_greater_than_average(\\"abc123def456\\") == 3 >>> digits_greater_than_average(\\"123456789\\") == 4 >>> digits_greater_than_average(\\"a1b2c\\") == 1 >>> digits_greater_than_average(\\"\\") == 0","solution":"def digits_greater_than_average(s): Returns the number of digits in the string s that are greater than the average of all digits present in the string. digits = [int(ch) for ch in s if ch.isdigit()] if not digits: return 0 average = sum(digits) / len(digits) count = sum(1 for digit in digits if digit > average) return count"},{"question":"def min_subset_sum_difference(arr, n, x): You are given a list of \`n\` integers, \`arr\`, and an integer \`x\`. Your task is to partition the list into two subsets such that the absolute difference between their sums is minimized. Return the minimum possible absolute difference. >>> min_subset_sum_difference([1, 6, 11, 5], 4, 4) # 1 >>> min_subset_sum_difference([1, 2, 3, 8], 4, 3) # 2 >>> min_subset_sum_difference([1, 2, 7], 3, 2) # 4 >>> min_subset_sum_difference([3, 1, 4, 2, 2], 5, 1) # 0 >>> min_subset_sum_difference([10, 20, 15, 5, 25], 5, 5) # 5","solution":"def min_subset_sum_difference(arr, n, x): # Calculate total sum of elements total_sum = sum(arr) # Initialize DP table dp = [[False for _ in range(total_sum + 1)] for _ in range(n + 1)] # Populate the partition table dp[][] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum + 1): dp[i][j] = dp[i-1][j] if arr[i-1] <= j: dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]] # Find the maximum j such that dp[n][j] is true where j loops from 0 to total_sum/2 diff = float('inf') for j in range(total_sum // 2, -1, -1): if dp[n][j] == True: diff = total_sum - 2 * j break return diff"},{"question":"def max_length_subarray(numbers, threshold): Returns the maximum length of a contiguous subarray where the sum of the elements in the subarray is less than or equal to the given threshold. >>> max_length_subarray([1, 2, 3, 4, 5], 10) 4 >>> max_length_subarray([1, 1, 1, 1, 1], 3) 3","solution":"def max_length_subarray(numbers, threshold): Returns the maximum length of a contiguous subarray where the sum of the elements in the subarray is less than or equal to the given threshold. n = len(numbers) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += numbers[end] while current_sum > threshold: current_sum -= numbers[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def combinationSum4(nums: List[int], target: int) -> int: Returns the number of combinations that add up to target using the numbers in nums. You may use each number in nums as many times as needed. >>> combinationSum4([1, 2, 3], 4) 7 >>> combinationSum4([2], 3) 0 >>> combinationSum4([1, 2, 3], 0) 1 >>> combinationSum4([5], 5) 1 >>> combinationSum4([1, 2, 3], 32) 181997601","solution":"def combinationSum4(nums, target): Returns the number of combinations that add up to target using the numbers in nums. You may use each number in nums as many times as needed. dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i >= num: dp[i] += dp[i - num] return dp[target]"},{"question":"def min_operations_to_group_chars(s: str) -> int: Determine the minimum number of operations required to move all characters of the same type together. >>> min_operations_to_group_chars(\\"a\\") == 0 >>> min_operations_to_group_chars(\\"aa\\") == 0 >>> min_operations_to_group_chars(\\"ab\\") == 1 >>> min_operations_to_group_chars(\\"abb\\") == 1 >>> min_operations_to_group_chars(\\"abc\\") == 2 >>> min_operations_to_group_chars(\\"aabbcc\\") == 4 >>> min_operations_to_group_chars(\\"baabbac\\") == 4","solution":"def min_operations_to_group_chars(s): from collections import Counter if len(s) < 2: return 0 char_freq = Counter(s) max_freq = max(char_freq.values()) return len(s) - max_freq"},{"question":"def max_area(height: List[int]) -> int: Returns the maximum amount of water that can be contained by any two lines from the height array. >>> max_area([1,8,6,2,5,4,8,3,7]) == 49 >>> max_area([1,1]) == 1 >>> max_area([4]) == 0 >>> max_area([1, 8]) == 1 >>> max_area([4, 3]) == 3 >>> max_area([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 25 >>> max_area([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 25 >>> max_area([1, 3, 2, 5, 25, 24, 5]) == 24","solution":"def max_area(height): Returns the maximum amount of water that can be contained by any two lines from the height array. left, right = 0, len(height) - 1 max_water = 0 while left < right: # Calculate the width and height of the container width = right - left min_height = min(height[left], height[right]) # Calculate the area of the container current_water = width * min_height # Update the maximum water contained if current water is greater if current_water > max_water: max_water = current_water # Move the pointer which is at the shorter line inward if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"def min_partitions(s: str, k: int) -> int: Given a string s and an integer k, partitions the string into contiguous substrings such that each substring contains at most k distinct characters. Returns the minimum number of substrings needed to achieve this. :param s: str, input string :param k: int, maximum distinct characters allowed in each substring :return: int, minimum number of substrings >>> min_partitions(\\"aabbcc\\", 3) 1 >>> min_partitions(\\"abac\\", 2) 2 >>> min_partitions(\\"abc\\", 3) 1 >>> min_partitions(\\"abcdef\\", 1) 6 >>> min_partitions(\\"abc\\", 0) 0 >>> min_partitions(\\"\\", 2) 0 >>> min_partitions(\\"aaaaa\\", 1) 1 >>> min_partitions(\\"aaaaa\\", 2) 1 >>> min_partitions(\\"abcdefgh\\", 10) 1 pass","solution":"def min_partitions(s, k): Given a string s and an integer k, partitions the string into contiguous substrings such that each substring contains at most k distinct characters. Returns the minimum number of substrings needed to achieve this. :param s: str, input string :param k: int, maximum distinct characters allowed in each substring :return: int, minimum number of substrings if k == 0: return 0 substr_count = 0 start = 0 while start < len(s): end = start distinct_chars = set() while end < len(s) and (len(distinct_chars) < k or (len(distinct_chars) == k and s[end] in distinct_chars)): distinct_chars.add(s[end]) end += 1 substr_count += 1 start = end return substr_count"},{"question":"def longestSubsequence(s: str, t: str) -> int: Given a string \`s\` and a string \`t\`, determines the length of the longest subsequence of \`t\` that can be formed by selecting any characters from \`s\` and rearranging them. >>> longestSubsequence(\\"abc\\", \\"def\\") 0 >>> longestSubsequence(\\"abc\\", \\"abc\\") 3 >>> longestSubsequence(\\"abc\\", \\"aabbcc\\") 3 >>> longestSubsequence(\\"aabbcc\\", \\"abc\\") 3 >>> longestSubsequence(\\"aab\\", \\"abacaba\\") 3 >>> longestSubsequence(\\"aaabbbccc\\", \\"abcabcabc\\") 9 >>> longestSubsequence(\\"abc\\", \\"\\") 0 >>> longestSubsequence(\\"\\", \\"abc\\") 0 >>> longestSubsequence(\\"\\", \\"\\") 0","solution":"def longestSubsequence(s, t): Returns the length of the longest subsequence of \`t\` that can be formed by re-arranging characters of \`s\`. from collections import Counter # Count occurrences of each character in s and t s_count = Counter(s) t_count = Counter(t) # Determine the maximum length subsequence possible len_subsequence = 0 for char in t_count: if char in s_count: len_subsequence += min(s_count[char], t_count[char]) return len_subsequence"},{"question":"def rank_participants(times: List[int]) -> List[int]: Return the ranks of participants based on their execution times. Parameters: times (List[int]): List of execution times where times[i] is the execution time of participant i. Returns: List[int]: List of ranks where the i-th element is the rank of the participant i. Example: >>> rank_participants([500]) [1] >>> rank_participants([300, 200]) [2, 1] >>> rank_participants([500, 400, 400, 300, 300]) [5, 3, 3, 1, 1] >>> rank_participants([200, 200, 200, 200]) [1, 1, 1, 1] >>> rank_participants([400, 300, 600, 200, 500]) [3, 2, 5, 1, 4] >>> rank_participants([1000, 200, 900, 300, 600, 600, 500]) [7, 1, 6, 2, 4, 4, 3]","solution":"def rank_participants(times): Return the ranks of participants based on their execution times. Parameters: times (List[int]): List of execution times where times[i] is the execution time of participant i. Returns: List[int]: List of ranks where the i-th element is the rank of the participant i. sorted_times = sorted((time, idx) for idx, time in enumerate(times)) ranks = [0] * len(times) current_rank = 1 for i in range(len(times)): if i == 0 or sorted_times[i][0] != sorted_times[i - 1][0]: current_rank = i + 1 ranks[sorted_times[i][1]] = current_rank return ranks"},{"question":"def surfaceArea(grid: List[List[int]]) -> int: Calculate the total surface area of the 3D shape represented by the grid. :param grid: List[List[int]]: A 2D list representing the height of the stacks of cubes :return: int: The total surface area of the 3D shape >>> surfaceArea([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) 32 >>> surfaceArea([[2, 2, 2], [2, 1, 2], [2, 2, 2]]) 46 >>> surfaceArea([[1, 2], [3, 4]]) 34 >>> surfaceArea([[1]]) 6 >>> surfaceArea([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def surfaceArea(grid): Calculate the total surface area of the 3D shape represented by the grid. :param grid: List[List[int]]: A 2D list representing the height of the stacks of cubes :return: int: The total surface area of the 3D shape m, n = len(grid), len(grid[0]) total_surface_area = 0 for i in range(m): for j in range(n): if grid[i][j] > 0: # Add the top and bottom faces total_surface_area += 2 # Add the sides # Check the current cell height and compare it to the neighboring cells # Front (i-1) total_surface_area += grid[i][j] if i == 0 else max(grid[i][j] - grid[i-1][j], 0) # Back (i+1) total_surface_area += grid[i][j] if i == m-1 else max(grid[i][j] - grid[i+1][j], 0) # Left (j-1) total_surface_area += grid[i][j] if j == 0 else max(grid[i][j] - grid[i][j-1], 0) # Right (j+1) total_surface_area += grid[i][j] if j == n-1 else max(grid[i][j] - grid[i][j+1], 0) return total_surface_area"},{"question":"from typing import List def min_bonus(ratings: List[int]) -> int: Return the minimum number of bonus points required to distribute among the employees following the given rules. >>> min_bonus([1, 2, 2]) 4 >>> min_bonus([1, 0, 2]) 5 >>> min_bonus([1, 2, 3, 2, 1]) 9 >>> min_bonus([1, 3, 2, 2, 1]) 7 >>> min_bonus([5, 4, 3, 2, 1]) 15 >>> min_bonus([]) 0","solution":"def min_bonus(ratings): n = len(ratings) if n == 0: return 0 bonus = [1] * n # First pass from left to right for i in range(1, n): if ratings[i] > ratings[i - 1]: bonus[i] = bonus[i - 1] + 1 # Second pass from right to left for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonus[i] = max(bonus[i], bonus[i + 1] + 1) return sum(bonus)"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSumQueries(root: TreeNode, queries: List[int]) -> List[bool]: Determines whether there exists a root-to-leaf path in the tree such that the sum of the path equals the query values. Args: root (TreeNode): The root of the binary tree. queries (List[int]): A list of query values. Returns: List[bool]: A list of booleans indicating the presence of each sum in the tree paths. Example: >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.right.right = TreeNode(1) >>> pathSumQueries(root, [22, 26, 18, 5]) [True, True, True, False]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSumQueries(root: TreeNode, queries: List[int]) -> List[bool]: def has_path_sum(node: TreeNode, target_sum: int) -> bool: if not node: return False if not node.left and not node.right: return node.val == target_sum new_sum = target_sum - node.val return has_path_sum(node.left, new_sum) or has_path_sum(node.right, new_sum) results = [] for query in queries: results.append(has_path_sum(root, query)) return results"},{"question":"def sorted_squares(arr: List[int]) -> List[int]: Given an array of integers \`arr\` sorted in non-decreasing order, return an array of the squares of each number, also sorted in non-decreasing order. >>> sorted_squares([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> sorted_squares([-5, -4, -3, -2, -1]) [1, 4, 9, 16, 25] >>> sorted_squares([-3, -1, 0, 2, 4]) [0, 1, 4, 9, 16] >>> sorted_squares([0]) [0] >>> sorted_squares([2]) [4] >>> sorted_squares([-2]) [4] >>> sorted_squares([]) []","solution":"def sorted_squares(arr): Given a list of integers sorted in non-decreasing order, returns a list of the squares of each number, also sorted in non-decreasing order. result = [x ** 2 for x in arr] result.sort() return result"},{"question":"def longest_subarray_with_duplicates(arr: List[int]) -> int: Given an array of integers arr, return the length of the longest contiguous subarray such that every number in this subarray appears at least twice within this subarray. If no such subarray exists, return 0. >>> longest_subarray_with_duplicates([1, 2, 3, 4, 5]) == 0 >>> longest_subarray_with_duplicates([2, 2, 2, 2, 2]) == 5 >>> longest_subarray_with_duplicates([1, 2, 2, 3, 3, 4]) == 4 >>> longest_subarray_with_duplicates([1, 2, 2, 3, 3, 2, 2]) == 6 >>> longest_subarray_with_duplicates([]) == 0 >>> longest_subarray_with_duplicates([1, 2, 3, 4]) == 0 >>> longest_subarray_with_duplicates([1, 1, 2, 2, 3, 3, 1, 1]) == 8","solution":"def longest_subarray_with_duplicates(arr): Returns the length of the longest contiguous subarray such that every number in this subarray appears at least twice within the subarray. n = len(arr) max_len = 0 left = 0 while left < n: freq = {} right = left while right < n: freq[arr[right]] = freq.get(arr[right], 0) + 1 # Check if all elements in the current window appear at least twice if all(val >= 2 for val in freq.values()): max_len = max(max_len, right - left + 1) right += 1 left += 1 return max_len"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid, or -1 if no such path exists. >>> shortest_path([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) == -1 >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) == -1 >>> shortest_path([[0]]) == 1 >>> shortest_path([[1]]) == -1 >>> shortest_path([[0, 0], [0, 0]]) == 3 >>> shortest_path([[0, 1], [1, 0]]) == -1 >>> shortest_path([[0, 0, 0], [1, 1, 0], [1, 1, 0]]) == 5 >>> shortest_path([[0, 0, 1, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0]]) == 9","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid, or -1 if no such path exists. # Helper function to check if a cell is within bounds and is not blocked def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 m, n = len(grid), len(grid[0]) # If the start or end point is blocked, return -1 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 # Directions array for moving in all 4 directions (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue to perform BFS, and a set to track visited cells queue = deque([(0, 0, 1)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reached the bottom-right corner if x == m-1 and y == n-1: return dist # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # If no path is found"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root: TreeNode) -> int: Given the \`root\` of a binary tree, return the maximum level sum among all levels of the tree. >>> root = TreeNode(1) >>> maxLevelSum(root) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> maxLevelSum(root) 5 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> maxLevelSum(root) 22 >>> root = TreeNode(-1, TreeNode(-2), TreeNode(-3)) >>> maxLevelSum(root) -1 >>> root = TreeNode(0, TreeNode(0), TreeNode(0)) >>> maxLevelSum(root) 0 >>> root = TreeNode(1, TreeNode(7), TreeNode(0, TreeNode(7), TreeNode(-8))) >>> maxLevelSum(root) 7","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root): Returns the maximum level sum of the binary tree. if not root: return 0 max_sum = float('-inf') queue = deque([(root, 1)]) current_level = 1 current_sum = 0 while queue: node, level = queue.popleft() if level > current_level: max_sum = max(max_sum, current_sum) current_sum = 0 current_level = level current_sum += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(edges): Build a binary tree from given edges. Args: edges (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing an edge in the tree. Returns: TreeNode: The root of the binary tree. # Your code here def find_shortest_paths(root, queries): Find the shortest path lengths between pairs of nodes in a binary tree. Args: root (TreeNode): The root of the binary tree. queries (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing two nodes in the tree. Returns: List[int]: A list of integers representing the shortest path lengths for each query. >>> edges = [(1, 2), (1, 3)] >>> queries = [(2, 3)] >>> root = build_tree(edges) >>> find_shortest_paths(root, queries) == [2] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> queries = [(4, 5), (4, 3)] >>> root = build_tree(edges) >>> find_shortest_paths(root, queries) == [2, 3] >>> edges = [(1, 2), (1, 3), (3, 4), (4, 5)] >>> queries = [(2, 5), (3, 5)] >>> root = build_tree(edges) >>> find_shortest_paths(root, queries) == [4, 2] >>> edges = [] >>> queries = [(1, 1)] >>> root = TreeNode(1) >>> find_shortest_paths(root, queries) == [0] >>> edges = [(1, 2)] >>> queries = [(1, 1), (2, 2)] >>> root = build_tree(edges) >>> find_shortest_paths(root, queries) == [0, 0] # Your code here","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(edges): from collections import defaultdict nodes = {} for u, v in edges: if u not in nodes: nodes[u] = TreeNode(u) if v not in nodes: nodes[v] = TreeNode(v) # Assuming the tree doesn't specify left/right directly in edges. if not nodes[u].left: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] # returning the root (assuming it's node 1) return nodes[1] def find_shortest_paths(root, queries): from collections import deque def bfs(root): queue = deque([(root, None)]) parent = {root.val: None} depth = {root.val: 0} while queue: node, par = queue.popleft() if node: if par is not None: parent[node.val] = par depth[node.val] = depth[par] + 1 if node.left: queue.append((node.left, node.val)) if node.right: queue.append((node.right, node.val)) return parent, depth parent, depth = bfs(root) def get_lca(a, b): while a != b: if depth[a] > depth[b]: a = parent[a] else: b = parent[b] return a def get_path_length(a, b): lca = get_lca(a, b) return depth[a] + depth[b] - 2 * depth[lca] results = [] for a, b in queries: results.append(get_path_length(a, b)) return results"},{"question":"def greed_score(dice): Evaluates the score for the dice game Greed. Parameters: dice: List[int] - A list of five integers representing dice rolls. Returns: int - The total score based on the rules of the game. >>> greed_score([1, 1, 1, 5, 1]) 1150 >>> greed_score([2, 3, 4, 6, 2]) 0 >>> greed_score([3, 4, 5, 3, 3]) 350","solution":"def greed_score(dice): Evaluates the score for the dice game Greed. Parameters: dice: List[int] - A list of five integers representing dice rolls. Returns: int - The total score based on the rules of the game. from collections import Counter # Count the occurrences of each die roll roll_counts = Counter(dice) score = 0 # Check for three of a kind for num in range(1, 7): if roll_counts[num] >= 3: if num == 1: score += 1000 else: score += num * 100 roll_counts[num] -= 3 # Score remaining rolls score += roll_counts[1] * 100 score += roll_counts[5] * 50 return score"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups strings into anagrams. Args: words (List[str]): List of strings to be grouped. Returns: List[List[str]]: A list of lists, where each sublist contains anagrams of each other in the order of their first appearance. >>> group_anagrams(['hello']) [['hello']] >>> group_anagrams(['hello', 'world']) [['hello'], ['world']] >>> group_anagrams(['bat', 'tab', 'cat']) [['bat', 'tab'], ['cat']] >>> group_anagrams(['act', 'cat', 'tac', 'bat', 'tab', 'tap']) [['act', 'cat', 'tac'], ['bat', 'tab'], ['tap']] >>> group_anagrams(['eat', 'tea', 'ate', 'ate']) [['eat', 'tea', 'ate', 'ate']]","solution":"from collections import defaultdict def group_anagrams(words): Groups strings into anagrams. anagram_groups = defaultdict(list) for word in words: sorted_word = tuple(sorted(word)) anagram_groups[sorted_word].append(word) result = [] for group in anagram_groups.values(): result.append(group) return result"},{"question":"def find_closest_visible_buildings(heights: List[int]) -> List[int]: You are given a \`0-indexed\` integer array \`heights\` representing the height of buildings on a street. A building \`i\` can see another building \`j\` if both the following conditions are true: * \`i < j\` * For every \`k\` between \`i\` and \`j\` (\`i < k < j\`), the height of building \`k\` is less than the height of building \`j\`. Return an integer array \`answer\` where \`answer[i]\` is the index of the closest building that building \`i\` can see. If no such building exists, set \`answer[i] = -1\`. >>> find_closest_visible_buildings([]) [] >>> find_closest_visible_buildings([5]) [-1] >>> find_closest_visible_buildings([1, 2]) [1, -1] >>> find_closest_visible_buildings([2, 1]) [-1, -1] >>> find_closest_visible_buildings([3, 1, 4, 2]) [2, 2, -1, -1] >>> find_closest_visible_buildings([2, 3, 1, 4]) [1, 3, 3, -1] >>> find_closest_visible_buildings([1, 3, 2, 4, 2, 5]) [1, 3, 3, 5, 5, -1]","solution":"def find_closest_visible_buildings(heights): For each building in the heights array, find the index of the closest building that it can see. If no such building exists, return -1 for that index. n = len(heights) answer = [-1] * n for i in range(n): for j in range(i + 1, n): if heights[j] > heights[i]: can_see = True for k in range(i + 1, j): if heights[k] >= heights[j]: can_see = False break if can_see: answer[i] = j break return answer"},{"question":"from typing import List def k_most_frequent_products(products: List[str], k: int) -> List[str]: Find the k most frequent products mentioned in customer reviews. Parameters: products (List[str]): List of product names. k (int): The number of top frequent products to return. Returns: List[str]: The k most frequent products sorted in alphabetical order. >>> k_most_frequent_products([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 2) [\\"apple\\", \\"banana\\"] >>> k_most_frequent_products([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"orange\\"], 2) [\\"apple\\", \\"banana\\"] >>> k_most_frequent_products([\\"apple\\", \\"banana\\", \\"orange\\"], 2) [\\"apple\\", \\"banana\\"] >>> k_most_frequent_products([\\"apple\\"], 1) [\\"apple\\"] >>> k_most_frequent_products([\\"apple\\", \\"banana\\", \\"apple\\"], 5) [\\"apple\\", \\"banana\\"] >>> k_most_frequent_products([], 3) []","solution":"from collections import Counter def k_most_frequent_products(products, k): Returns the k most frequent products sorted in alphabetical order. Parameters: products (List[str]): A list of product names. k (int): The number of top frequent products to return. Returns: List[str]: A list of the k most frequent products sorted in alphabetical order. product_count = Counter(products) # sort products first by frequency (in descending order), then alphabetically sorted_products = sorted(product_count.keys(), key=lambda x: (-product_count[x], x)) return sorted_products[:k]"},{"question":"def longest_common_subsequence_length(s: str, t: str) -> int: Find the length of the longest substring of s that can be written as a substring of t after removing some characters from t without changing the order of the remaining characters. Args: s (str): The first string consisting of lowercase English letters. t (str): The second string consisting of lowercase English letters. Returns: int: The length of the longest common substring. >>> longest_common_subsequence_length(\\"abc\\", \\"ahbgdc\\") 3 >>> longest_common_subsequence_length(\\"axc\\", \\"ahbgdc\\") 2 >>> longest_common_subsequence_length(\\"abcd\\", \\"abc\\") 3 >>> longest_common_subsequence_length(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence_length(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence_length(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence_length(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence_length(\\"\\", \\"\\") 0 pass","solution":"def longest_common_subsequence_length(s, t): Find the length of the longest subsequence in s that appears in t Args: s (str): The first string. t (str): The second string. Returns: int: The length of the longest common subsequence that can be derived from s and appears in t. m, n = len(s), len(t) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"def max_subarray_sum(arr: List[int], k: int) -> int: Returns the maximum sum of any non-empty subarray of arr with length <= k. :param arr: List of integers :param k: Maximum length of the subarray :return: Maximum sum of any subarray with length <= k pass # Unit tests def test_single_element(): assert max_subarray_sum([1], 1) == 1 assert max_subarray_sum([-1], 1) == -1 def test_all_negative_elements(): assert max_subarray_sum([-1, -2, -3], 2) == -1 assert max_subarray_sum([-5, -3, -2], 3) == -2 def test_mixed_elements(): assert max_subarray_sum([1, -2, 3, 4], 2) == 7 assert max_subarray_sum([2, 1, -3, 4, -1, 2, 1, -5, 4], 4) == 6 def test_large_k(): assert max_subarray_sum([1, 2, 3, 4, 5], 10) == 15 assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4], 9) == 6 def test_edge_cases(): assert max_subarray_sum([], 5) == 0 assert max_subarray_sum([2, 4, 6, 8], 1) == 8","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of any non-empty subarray of arr with length <= k. :param arr: List of integers :param k: Maximum length of the subarray :return: Maximum sum of any subarray with length <= k n = len(arr) if n == 0: return 0 max_sum = float('-inf') for i in range(n): current_sum = 0 for j in range(i, min(i + k, n)): current_sum += arr[j] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def trap(height: List[int]) -> int: Calculate the total units of water trapped between the columns after the rain. :param height: List[int] - List of non-negative integers representing the height of columns. :return: int - Total units of water trapped. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([0,0,0,0,0]) == 0 >>> trap([3,3,3,3,3]) == 0 >>> trap([2, 0, 2]) == 2 >>> trap([1,2,3,4,5]) == 0 >>> trap([5,4,3,2,1]) == 0 >>> trap([4,2,0,3,2,5]) == 9 >>> trap([]) == 0 >>> trap([1]) == 0 >>> trap([0]) == 0","solution":"def trap(height): Calculate the total units of water trapped between the columns after the rain. :param height: List[int] - List of non-negative integers representing the height of columns. :return: int - Total units of water trapped. n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def findRange(arr: List[int], target: int) -> List[int]: Returns the first and last position of target in a sorted integer array arr. If target is not present, returns [-1, -1]. Parameters: arr: List[int] A sorted list of integers. target: int The target integer to find in the list. Returns: List[int] A list containing the first and last positions of the target in the array, or [-1, -1] if the target is not present. Examples: >>> findRange([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> findRange([5, 7, 7, 8, 8, 10], 6) [-1, -1]","solution":"def findRange(arr, target): Returns the first and last position of target in arr. If target is not present, returns [-1, -1]. def binary_search_left(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] < target: left = mid + 1 else: right = mid - 1 return left def binary_search_right(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_idx = binary_search_left(arr, target) right_idx = binary_search_right(arr, target) if left_idx <= right_idx < len(arr) and arr[left_idx] == target and arr[right_idx] == target: return [left_idx, right_idx] return [-1, -1]"},{"question":"from typing import List, Optional def max_element_after_k_rotations(nums: List[int], k: int) -> Optional[int]: Returns the maximum element in the array after rotating it to the right by k steps. :param nums: List of integers representing the array. :param k: Integer representing the number of steps to rotate. :return: The maximum element in the array after rotation. >>> max_element_after_k_rotations([1], 0) == 1 >>> max_element_after_k_rotations([1], 1) == 1 >>> max_element_after_k_rotations([1, 2, 3, 4, 5], 0) == 5 >>> max_element_after_k_rotations([3, 8, 9, 7, 6], 3) == 9 >>> max_element_after_k_rotations([2, 5, 1, 3, 4], 2) == 5 >>> max_element_after_k_rotations([2, 4, 7, 8, 1, 3], 8) == 8 >>> max_element_after_k_rotations([], 3) == None >>> max_element_after_k_rotations([1, 3, 5, 7], 13) == 7","solution":"def max_element_after_k_rotations(nums, k): Returns the maximum element in the array after rotating it to the right by k steps. :param nums: List of integers representing the array. :param k: Integer representing the number of steps to rotate. :return: The maximum element in the array after rotation. n = len(nums) if n == 0: return None k = k % n # Normalize k to be within the bounds of the array length if k > 0: nums[:] = nums[-k:] + nums[:-k] # Rotate the array return max(nums)"},{"question":"def find_disappeared_numbers(nums): Finds all the integers from 1 to n that do not appear in nums. Args: nums (list): List of integers where each integer appears once or twice. Returns: list: List of integers that do not appear in nums, sorted in ascending order. Examples: >>> find_disappeared_numbers([4,3,2,7,8,2,3,1]) [5,6] >>> find_disappeared_numbers([1,2,3,4,5]) [] >>> find_disappeared_numbers([2,2,2,2,2]) [1,3,4,5] >>> find_disappeared_numbers([1]) [] >>> find_disappeared_numbers([2,2,3,3,3]) [1,4,5]","solution":"def find_disappeared_numbers(nums): Finds all the integers from 1 to n that do not appear in nums. Args: nums (list): List of integers where each integer appears once or twice. Returns: list: List of integers that do not appear in nums, sorted in ascending order. n = len(nums) for i in range(n): index = abs(nums[i]) - 1 if nums[index] > 0: nums[index] = -nums[index] result = [i + 1 for i in range(n) if nums[i] > 0] return result"},{"question":"def h_index(citations: List[int]) -> int: Returns the h-index for the given list of citations. The h-index is defined as the maximum value h such that the given researcher has published h papers that have each been cited at least h times. Parameters: citations (List[int]): A list of citation counts. Returns: int: The h-index. >>> h_index([3, 0, 6, 1, 5]) 3 >>> h_index([4, 4, 4, 4, 4]) 4 >>> h_index([0, 0, 0, 0]) 0 >>> h_index([10]) 1 >>> h_index([10, 8, 5, 4, 3]) 4 >>> h_index([0, 1, 4, 2]) 2","solution":"def h_index(citations): Returns the h-index for the given list of citations. Parameters: citations (List[int]): A list of citation counts. Returns: int: The h-index. citations.sort(reverse=True) h = 0 for i, citation in enumerate(citations): if citation >= i + 1: h = i + 1 else: break return h"},{"question":"from typing import List def ideal_permutations(arr: List[int]) -> int: Returns the number of ideal permutations of the array where the absolute difference between any two consecutive elements is at most 1 and returns the result modulo 10^9 + 7. Args: arr: List[int] - The given array of distinct integers. Returns: int - The number of ideal permutations modulo 10^9 + 7. pass def test_ideal_permutations_min_case(): assert ideal_permutations([1]) == 2 % (10**9 + 7) def test_ideal_permutations_case_1(): assert ideal_permutations([1, 2, 3]) == 2 % (10**9 + 7) def test_ideal_permutations_case_2(): assert ideal_permutations([3, 2, 1]) == 2 % (10**9 + 7) def test_ideal_permutations_large_case(): arr = list(range(1, 101)) assert ideal_permutations(arr) == 2 % (10**9 + 7) def test_ideal_permutations_random_case(): arr = [10, 9, 8, 7, 6, 5, 4] assert ideal_permutations(arr) == 2 % (10**9 + 7)","solution":"def ideal_permutations(arr): Returns the number of ideal permutations of the array where the absolute difference between any two consecutive elements is at most 1. Args: arr: List[int] - The given array of distinct integers. Returns: int - The number of ideal permutations modulo 10^9 + 7. MOD = 10**9 + 7 n = len(arr) # Only two permutations are ideal: # 1. arr sorted in ascending order # 2. arr sorted in descending order return 2 % MOD"},{"question":"def sum_ranges(arr, queries): Given an array of integers \`arr\`, find the sum of the elements between indices \`i\` and \`j\` (inclusive) for a range of queries. Each query is given as a pair of indices \`[i, j]\`. Return an array of sums where each element is the result of the corresponding query. You should aim to answer the queries efficiently, particularly if the number of queries is large. >>> sum_ranges([1, 2, 3, 4, 5], [(1, 3)]) [9] >>> sum_ranges([1, 2, 3, 4, 5], [(0, 1), (1, 3), (2, 4)]) [3, 9, 12] >>> sum_ranges([1, 2, 3, 4, 5], [(2, 2)]) [3] >>> sum_ranges([1, 2, 3, 4, 5], [(0, 4)]) [15] >>> sum_ranges([1, 2, 3, 4, 5], [(0, 1), (0, 1), (0, 1)]) [3, 3, 3] >>> sum_ranges([1, -2, 3, -4, 5], [(0, 1), (1, 3), (0, 4)]) [-1, -3, 3]","solution":"def sum_ranges(arr, queries): Given an array of integers \`arr\`, this function returns the sum of elements between indices \`i\` and \`j\` (inclusive) for a range of queries. The queries are given as a list of pairs of indices \`[i, j]\`. To efficiently answer the queries, we precompute prefix sums. # Precompute prefix sums n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] # Answer each query using the prefix sums result = [] for i, j in queries: result.append(prefix_sums[j + 1] - prefix_sums[i]) return result"},{"question":"class TreeNode: def __init__(self, val, left=None, right=None): Initialize a tree node. :param val: The value of the node, which can be an operator or an operand. :param left: The left child node. :param right: The right child node. self.val = val self.left = left self.right = right def evaluate_expression_tree(node): Evaluates the expression represented by the given binary tree. :param node: The root node of the expression tree. :return: The result of the expression. >>> tree = TreeNode('+', TreeNode('3'), TreeNode('2')) >>> evaluate_expression_tree(tree) 5 >>> tree = TreeNode('*', TreeNode('+', TreeNode('3'), TreeNode('2')), TreeNode('5')) >>> evaluate_expression_tree(tree) 25 >>> tree = TreeNode('-', TreeNode('10'), TreeNode('2')) >>> evaluate_expression_tree(tree) 8 >>> tree = TreeNode('/', TreeNode('20'), TreeNode('4')) >>> evaluate_expression_tree(tree) 5.0 >>> tree = TreeNode('+', TreeNode('*', TreeNode('6'), TreeNode('3')), TreeNode('/', TreeNode('9'), TreeNode('3'))) >>> evaluate_expression_tree(tree) 21 >>> tree = TreeNode('*', TreeNode('+', TreeNode('5'), TreeNode('4')), TreeNode('-', TreeNode('20'), TreeNode('10'))) >>> evaluate_expression_tree(tree) 90 >>> tree = TreeNode('7') >>> evaluate_expression_tree(tree) 7 >>> tree = None >>> evaluate_expression_tree(tree) 0","solution":"class TreeNode: def __init__(self, val, left=None, right=None): Initialize a tree node. :param val: The value of the node, which can be an operator or an operand. :param left: The left child node. :param right: The right child node. self.val = val self.left = left self.right = right def evaluate_expression_tree(node): Evaluates the expression represented by the given binary tree. :param node: The root node of the expression tree. :return: The result of the expression. if node is None: return 0 # If it's a leaf node (operand), return its value as an integer if node.left is None and node.right is None: return int(node.val) # Recursively evaluate the left and right subtrees left_value = evaluate_expression_tree(node.left) right_value = evaluate_expression_tree(node.right) # Apply the operator at the current node to the values obtained from the subtrees if node.val == '+': return left_value + right_value elif node.val == '-': return left_value - right_value elif node.val == '*': return left_value * right_value elif node.val == '/': return left_value / right_value"},{"question":"def combine_availability(arr1, arr2, m): Combine the availability of products from two warehouses with a threshold. Parameters: arr1 (list of int): Availability array of the first warehouse. arr2 (list of int): Availability array of the second warehouse. m (int): Threshold value. Returns: list of int: Combined availability array. Example: >>> combine_availability([1, 2, 3], [4, 5, 6], 10) [5, 7, 9] >>> combine_availability([1, 2, 3], [4, 5, 6], 5) [5, 5, 5] >>> combine_availability([1, 1, 1], [2, 2, 2], 10) [3, 3, 3] >>> combine_availability([5, 6, 7], [5, 4, 3], 10) [10, 10, 10] >>> combine_availability([3], [4], 5) [5] >>> combine_availability([3], [1], 5) [4]","solution":"def combine_availability(arr1, arr2, m): Combine the availability of products from two warehouses with a threshold. Parameters: arr1 (list of int): Availability array of the first warehouse. arr2 (list of int): Availability array of the second warehouse. m (int): Threshold value. Returns: list of int: Combined availability array. n = len(arr1) result = [min(arr1[i] + arr2[i], m) for i in range(n)] return result"},{"question":"def minimum_cost_with_coupon(costs: List[int]) -> int: Calculate the minimum possible cost to buy all items using a coupon that allows you to buy one item for free. Parameters: costs (list): A list of positive integers representing the cost of each item. Returns: int: The minimum cost to buy all items using the coupon. >>> minimum_cost_with_coupon([1, 2, 3, 4]) 6 >>> minimum_cost_with_coupon([10, 20, 30, 40, 50]) 100 >>> minimum_cost_with_coupon([5]) 0 >>> minimum_cost_with_coupon([5, 10]) 5 >>> minimum_cost_with_coupon([10, 10, 10]) 20 >>> minimum_cost_with_coupon([1000, 2000, 3000]) 3000","solution":"def minimum_cost_with_coupon(costs): Returns the minimum cost to buy all items considering the coupon which allows you to buy one item for free. Parameters: costs (list): A list of positive integers representing the cost of each item. Returns: int: The minimum cost to buy all items using the coupon. if len(costs) == 1: return 0 total_cost = sum(costs) max_cost_item = max(costs) return total_cost - max_cost_item"},{"question":"from collections import defaultdict import bisect class TimeMap: TimeMap class to store timestamped key-value pairs, and to retrieve the value associated with a key at the latest timestamp before or equal to a given timestamp. Methods: - set(String key, String value, int timestamp) - get(String key, int timestamp) def __init__(self): Initializes the object of the data structure. def set(self, key, value, timestamp): Stores the key \`key\` with the value \`value\` at the given \`timestamp\`. :param key: str :param value: str :param timestamp: int def get(self, key, timestamp): Returns a value such that \`set\` was called previously with \`key\` and a timestamp \`prevTimestamp\` such that \`prevTimestamp\` <= \`timestamp\`. If there are multiple such values, it returns the value associated with the largest \`prevTimestamp\`. If there are no values, it returns an empty string \`\\"\\"\`. :param key: str :param timestamp: int :return: str import pytest def test_set_and_get_with_exact_timestamp(): time_map = TimeMap() time_map.set(\\"foo\\", \\"bar\\", 1) assert time_map.get(\\"foo\\", 1) == \\"bar\\" def test_get_with_time_after_set(): time_map = TimeMap() time_map.set(\\"foo\\", \\"bar\\", 1) assert time_map.get(\\"foo\\", 5) == \\"bar\\" def test_get_with_no_value(): time_map = TimeMap() assert time_map.get(\\"foo\\", 1) == \\"\\" def test_overwrite_value_same_key(): time_map = TimeMap() time_map.set(\\"foo\\", \\"bar1\\", 1) time_map.set(\\"foo\\", \\"bar2\\", 2) assert time_map.get(\\"foo\\", 1) == \\"bar1\\" assert time_map.get(\\"foo\\", 2) == \\"bar2\\" assert time_map.get(\\"foo\\", 3) == \\"bar2\\" def test_multiple_keys(): time_map = TimeMap() time_map.set(\\"foo\\", \\"bar1\\", 1) time_map.set(\\"foo2\\", \\"bar2\\", 2) assert time_map.get(\\"foo\\", 1) == \\"bar1\\" assert time_map.get(\\"foo2\\", 2) == \\"bar2\\" assert time_map.get(\\"foo\\", 2) == \\"bar1\\" assert time_map.get(\\"foo2\\", 1) == \\"\\" def test_large_scale_operations(): time_map = TimeMap() time_map.set(\\"foo\\", \\"bar1\\", 1) time_map.set(\\"foo\\", \\"bar2\\", 2) for i in range(3, 1001): time_map.set(\\"foo\\", f\\"bar{i}\\", i) assert time_map.get(\\"foo\\", 1000) == \\"bar1000\\" assert time_map.get(\\"foo\\", 1001) == \\"bar1000\\" assert time_map.get(\\"foo\\", 500) == \\"bar500\\" assert time_map.get(\\"foo\\", 750) == \\"bar750\\" assert time_map.get(\\"foo\\", 2) == \\"bar2\\" assert time_map.get(\\"foo\\", 1) == \\"bar1\\" if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import defaultdict import bisect class TimeMap: def __init__(self): Initializes the object of the data structure. self.store = defaultdict(list) def set(self, key, value, timestamp): Stores the key \`key\` with the value \`value\` at the given \`timestamp\`. :param key: str :param value: str :param timestamp: int self.store[key].append((timestamp, value)) def get(self, key, timestamp): Returns a value such that \`set\` was called previously with \`key\` and a timestamp \`prevTimestamp\` such that \`prevTimestamp\` <= \`timestamp\`. If there are multiple such values, it returns the value associated with the largest \`prevTimestamp\`. If there are no values, it returns an empty string \`\\"\\"\`. :param key: str :param timestamp: int :return: str if key not in self.store or not self.store[key]: return \\"\\" timestamps = [ts for ts, _ in self.store[key]] pos = bisect.bisect_right(timestamps, timestamp) if pos == 0: return \\"\\" return self.store[key][pos - 1][1]"},{"question":"def find_smallest_missing_positive(nums: List[int]) -> int: Finds the smallest positive integer that is missing from the list. :param nums: List of integers :return: Smallest missing positive integer >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_smallest_missing_positive([1, 2, 3, 4, 5]) 6","solution":"def find_smallest_missing_positive(nums): Finds the smallest positive integer that is missing from the list. :param nums: List of integers :return: Smallest missing positive integer nums = [num for num in nums if num > 0] # Remove negative numbers and zero nums_set = set(nums) # Create a set for O(1) look-ups i = 1 # Start from the smallest positive integer while i in nums_set: i += 1 return i"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseBetween(head: ListNode, m: int, n: int) -> ListNode: Reverse the linked list from position m to n in one-pass. >>> list_to_array(reverseBetween(array_to_list([1, 2, 3, 4, 5]), 2, 4)) == [1, 4, 3, 2, 5] >>> list_to_array(reverseBetween(array_to_list([5, 6, 7, 8, 9]), 1, 5)) == [9, 8, 7, 6, 5] pass def list_to_array(head): array = [] while head: array.append(head.val) head = head.next return array def array_to_list(array): dummy = ListNode(0) current = dummy for val in array: current.next = ListNode(val) current = current.next return dummy.next def test_reverse_between(): list1 = array_to_list([1, 2, 3, 4, 5]) m, n = 2, 4 new_head = reverseBetween(list1, m, n) assert list_to_array(new_head) == [1, 4, 3, 2, 5] list2 = array_to_list([5, 6, 7, 8, 9]) m, n = 1, 5 new_head = reverseBetween(list2, m, n) assert list_to_array(new_head) == [9, 8, 7, 6, 5] list3 = array_to_list([1, 2, 3, 4, 5, 6, 7, 8, 9]) m, n = 3, 7 new_head = reverseBetween(list3, m, n) assert list_to_array(new_head) == [1, 2, 7, 6, 5, 4, 3, 8, 9] list4 = array_to_list([1]) m, n = 1, 1 new_head = reverseBetween(list4, m, n) assert list_to_array(new_head) == [1] list5 = array_to_list([1, 2]) m, n = 1, 2 new_head = reverseBetween(list5, m, n) assert list_to_array(new_head) == [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseBetween(head, m, n): Reverse the linked list from position m to n in one-pass. if not head or m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move prev to the node just before the start of the reverse segment for _ in range(m - 1): prev = prev.next start = prev.next # The first node of the reverse segment then = start.next # The second node of the reverse segment # Reverse the segment between m and n for _ in range(n - m): start.next = then.next then.next = prev.next prev.next = then then = start.next return dummy.next"},{"question":"def max_subarray_sum_circular(nums): Returns the maximum sum of a subarray in a circular array. pass def test_case_1(): assert max_subarray_sum_circular([1, -2, 3, -2]) == 3 def test_case_2(): assert max_subarray_sum_circular([5, -3, 5]) == 10 def test_case_3(): assert max_subarray_sum_circular([3, -1, 2, -1]) == 4 def test_case_4(): assert max_subarray_sum_circular([3, -2, 2, -3]) == 3 def test_case_5(): assert max_subarray_sum_circular([-2, -3, -1]) == -1 def test_case_6(): assert max_subarray_sum_circular([8, -1, 3, 4]) == 15 def test_case_7(): assert max_subarray_sum_circular([0, 5, 8, -9, 9, -7, 3, -2]) == 16 def test_case_8(): assert max_subarray_sum_circular([-5, 3, 5]) == 8 def test_case_9(): assert max_subarray_sum_circular([10]) == 10","solution":"def max_subarray_sum_circular(nums): Returns the maximum sum of a subarray in a circular array. def kadane(arr): Helper function to find the maximum subarray sum using Kadane's algorithm. max_sum = cur_sum = arr[0] for num in arr[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum # Case 1: get the maximum sum using standard Kadane's algorithm max_kadane = kadane(nums) # Case 2: Now find the maximum possible sum that includes corner elements. total_sum = sum(nums) # Invert the sign of the numbers for Kadane's on inverted numbers to find the minimum subarray sum in original numbers nums = [-num for num in nums] max_wrap = total_sum + kadane(nums) # If max_wrap is 0, it means all numbers are negative. Thus, we should not consider max_wrap as it means to take no elements. if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"def max_subarray_sum(nums: List[int], k: int, t: int) -> int: Returns the maximum sum of a subarray with length less than or equal to k and sum less than or equal to t. Args: nums (List[int]): List of integers. k (int): Maximum length of the subarray. t (int): Maximum allowable sum of the subarray. Returns: int: Maximum sum of the subarray that meets the criteria. >>> max_subarray_sum([1, 2, 3, -1, -2, 3, 5], 3, 6) == 6 >>> max_subarray_sum([10, 20, 30], 2, 5) == 0 >>> max_subarray_sum([1], 1, 1) == 1 >>> max_subarray_sum([-1, -2, -3, -4], 2, -1) == -1 >>> max_subarray_sum([4, -1, 2, 1], 2, 4) == 4","solution":"def max_subarray_sum(nums, k, t): Returns the maximum sum of a subarray with length less than or equal to k and sum less than or equal to t. Args: nums (List[int]): List of integers. k (int): Maximum length of the subarray. t (int): Maximum allowable sum of the subarray. Returns: int: Maximum sum of the subarray that meets the criteria. max_sum = float('-inf') for i in range(len(nums)): current_sum = 0 for j in range(i, min(i + k, len(nums))): current_sum += nums[j] if current_sum <= t: max_sum = max(max_sum, current_sum) return max_sum if max_sum != float('-inf') else 0"},{"question":"from typing import List def shortestPath(grid: List[List[int]], k: int) -> int: Given a matrix grid of size m x n consisting of positive integers and an integer k, find the length of the shortest path from the top-left to the bottom-right corner of the matrix while eliminating at most k obstacles. You can move up, down, left, or right from and to any cell in the matrix. If it is impossible to reach the bottom-right corner, return -1. >>> grid = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0], ... [0, 1, 1], ... [0, 0, 0] ... ] >>> k = 1 >>> shortestPath(grid, k) 6 >>> grid = [ ... [0, 1, 1], ... [1, 1, 1], ... [1, 0, 0] ... ] >>> k = 1 >>> shortestPath(grid, k) -1 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> k = 0 >>> shortestPath(grid, k) 4 >>> grid = [ [0] ] >>> k = 0 >>> shortestPath(grid, k) 0 >>> grid = [ ... [0, 1], ... [0, 1] ... ] >>> k = 10 >>> shortestPath(grid, k) 2 pass","solution":"from collections import deque def shortestPath(grid, k): m, n = len(grid), len(grid[0]) if m == 1 and n == 1: return 0 queue = deque([(0, 0, 0, k)]) visited = {(0, 0): k} directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y, steps, remaining_k = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_k = remaining_k - grid[nx][ny] if nx == m-1 and ny == n-1: return steps + 1 if new_k >= 0: if (nx, ny) not in visited or visited[(nx, ny)] < new_k: visited[(nx, ny)] = new_k queue.append((nx, ny, steps + 1, new_k)) return -1"},{"question":"def minimum_weight_difference(weights: List[int]) -> int: Return the minimum possible weight difference between the two groups of boxes. >>> minimum_weight_difference([1, 6, 11, 5]) 1 >>> minimum_weight_difference([2, 2, 2, 2]) 0 >>> minimum_weight_difference([10]) 10 >>> minimum_weight_difference([8, 12]) 4 >>> minimum_weight_difference([1, 2, 3, 9]) 3","solution":"def minimum_weight_difference(weights): total_weight = sum(weights) n = len(weights) dp = [False] * (total_weight // 2 + 1) dp[0] = True for weight in weights: for j in range(total_weight // 2, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] for i in range(total_weight // 2, -1, -1): if dp[i]: sum1 = i break sum2 = total_weight - sum1 return abs(sum2 - sum1)"},{"question":"def max_length_of_subarray(nums: List[int]) -> int: Returns the maximum length of a contiguous subarray that contains at most two distinct integers. >>> max_length_of_subarray([]) == 0 >>> max_length_of_subarray([1]) == 1 >>> max_length_of_subarray([1, 2]) == 2 >>> max_length_of_subarray([1, 1, 2, 2]) == 4 >>> max_length_of_subarray([1, 2, 1, 3, 4]) == 3 >>> max_length_of_subarray([1, 2, 3, 2, 2]) == 4 >>> max_length_of_subarray([1, 1, 1, 1]) == 4 >>> max_length_of_subarray([1, 2, 1]) == 3 >>> max_length_of_subarray([0, 1, 2, 2]) == 3 >>> max_length_of_subarray([1, 2, 3, 2, 2]) == 4 >>> max_length_of_subarray([1, 2, 3, 4, 5, 6]) == 2","solution":"def max_length_of_subarray(nums): Returns the maximum length of a contiguous subarray that contains at most two distinct integers. :param nums: List[int] - list of integers. :return: int - maximum length of the subarray. if not nums: return 0 start, max_length = 0, 0 count = {} for end in range(len(nums)): if nums[end] in count: count[nums[end]] += 1 else: count[nums[end]] = 1 while len(count) > 2: count[nums[start]] -= 1 if count[nums[start]] == 0: del count[nums[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List, Tuple def filter_logs(logs: List[Tuple[int, str]], start_timestamp: int, end_timestamp: int) -> List[Tuple[int, str]]: Returns the list of actions that were performed within the given time range (inclusive). Parameters: logs (list of tuple): A list of tuples containing (timestamp, action description). start_timestamp (int): The start of the timestamp range. end_timestamp (int): The end of the timestamp range. Returns: list of tuple: A list of actions performed within the given time range (inclusive). Example: >>> logs = [(1624291200, \\"Login\\"), (1624291260, \\"View Dashboard\\"), (1624291320, \\"Logout\\"), (1624291380, \\"Login\\"), (1624291440, \\"Download Report\\")] >>> filter_logs(logs, 1624291200, 1624291320) [(1624291200, \\"Login\\"), (1624291260, \\"View Dashboard\\"), (1624291320, \\"Logout\\")] >>> filter_logs(logs, 1624291500, 1624291600) [] >>> filter_logs(logs, 1624291260, 1624291260) [(1624291260, \\"View Dashboard\\")] >>> logs = [(1624291440, \\"Download Report\\"), (1624291200, \\"Login\\"), (1624291260, \\"View Dashboard\\"), (1624291380, \\"Login\\"), (1624291320, \\"Logout\\")] >>> filter_logs(logs, 1624291200, 1624291320) [(1624291200, \\"Login\\"), (1624291260, \\"View Dashboard\\"), (1624291320, \\"Logout\\")]","solution":"def filter_logs(logs, start_timestamp, end_timestamp): Returns a list of actions that were performed within the given time range inclusive. Parameters: logs (list of tuple): A list of tuples containing (timestamp, action description). start_timestamp (int): The start of the timestamp range. end_timestamp (int): The end of the timestamp range. Returns: list of tuple: A list of actions performed within the given time range inclusive. return sorted([log for log in logs if start_timestamp <= log[0] <= end_timestamp])"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: TreeNode) -> int: Return the sum of the values of the deepest leaves in a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.left.left = TreeNode(7) >>> root.right.right.right = TreeNode(8) >>> deepestLeavesSum(root) 15 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> deepestLeavesSum(root) 22 >>> deepestLeavesSum(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): from collections import deque if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"class MyQueue: def __init__(self): Initialize your data structure here. def push(self, x: int): Push element x to the back of queue. def pop(self) -> int: Removes the element from in front of queue and returns that element. def peek(self) -> int: Get the front element. def empty(self) -> bool: Returns whether the queue is empty. # Unit Tests def test_queue_operations(): queue = MyQueue() assert queue.empty() == True # Queue should be empty initially queue.push(1) queue.push(2) assert queue.peek() == 1 # The front element should be 1 assert queue.pop() == 1 # Removing the front element, which should be 1 assert queue.peek() == 2 # The front element should now be 2 queue.push(3) assert queue.pop() == 2 # Removing the front element, which should be 2 assert queue.peek() == 3 # The front element should now be 3 assert queue.empty() == False # Queue is not empty, should be False assert queue.pop() == 3 # Removing the front element, which should be 3 assert queue.empty() == True # Queue should be empty again def test_queue_single_element(): queue = MyQueue() queue.push(10) assert queue.peek() == 10 assert queue.pop() == 10 assert queue.empty() == True def test_queue_multiple_push_pop(): queue = MyQueue() for i in range(5): queue.push(i) assert queue.peek() == 0 # The front element should be 0 for i in range(5): assert queue.pop() == i # Elements should come out in the order they were put in assert queue.empty() == True def test_queue_interleaved_operations(): queue = MyQueue() queue.push(5) assert queue.peek() == 5 queue.push(10) assert queue.pop() == 5 assert queue.peek() == 10 queue.push(20) assert queue.pop() == 10 assert queue.pop() == 20 assert queue.empty() == True","solution":"class MyQueue: def __init__(self): # Two stacks to implement queue self.stack_in = [] self.stack_out = [] def push(self, x: int): self.stack_in.append(x) def pop(self) -> int: self._move_elements() return self.stack_out.pop() def peek(self) -> int: self._move_elements() return self.stack_out[-1] def empty(self) -> bool: return not self.stack_in and not self.stack_out # Helper function to transfer elements from stack_in to stack_out def _move_elements(self): if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop())"},{"question":"def longest_unique_substring(text: str) -> str: Returns the longest substring without repeating characters. If there are multiple substrings with the same maximum length, returns the first one. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> longest_unique_substring(\\"\\") \\"\\" >>> longest_unique_substring(\\"dvdf\\") \\"vdf\\" >>> longest_unique_substring(\\"anviaj\\") \\"nviaj\\" >>> longest_unique_substring(\\"abca\\") \\"abc\\"","solution":"def longest_unique_substring(text): Returns the longest substring without repeating characters. If there are multiple substrings with the same maximum length, returns the first one. if not text: return \\"\\" start = max_length = 0 used_char = {} longest_substr = '' for i, char in enumerate(text): if char in used_char and start <= used_char[char]: start = used_char[char] + 1 else: cur_length = i - start + 1 if cur_length > max_length: max_length = cur_length longest_substr = text[start:i+1] used_char[char] = i return longest_substr"},{"question":"from typing import List def get_activities(logs: List[str], user_type: str) -> List[str]: Returns a list of activities performed by the specified user type in chronological order. Parameters: logs (List[str]): List of log entries in the format \\"user_type;activity_type;timestamp\\". user_type (str): The user type to filter by (either \\"guest\\" or \\"registered\\"). Returns: List[str]: List of activities performed by the specified user type in chronological order. Examples: >>> logs = [ >>> \\"guest;login;2023-01-01 10:00:00\\", >>> \\"registered;purchase;2023-01-01 09:00:00\\", >>> \\"guest;logout;2023-01-01 10:30:00\\", >>> \\"registered;login;2023-01-01 09:30:00\\" >>> ] >>> user_type = \\"registered\\" >>> get_activities(logs, user_type) [\\"purchase\\", \\"login\\"] >>> user_type = \\"guest\\" >>> get_activities(logs, user_type) [\\"login\\", \\"logout\\"]","solution":"from typing import List def get_activities(logs: List[str], user_type: str) -> List[str]: Returns a list of activities performed by the specified user type in chronological order. Parameters: logs (List[str]): List of log entries in the format \\"user_type;activity_type;timestamp\\". user_type (str): The user type to filter by (either \\"guest\\" or \\"registered\\"). Returns: List[str]: List of activities performed by the specified user type in chronological order. # Filter logs based on the specified user type filtered_logs = [log for log in logs if log.split(';')[0] == user_type] # Extract the activity type and timestamp activities = [(log.split(';')[1], log.split(';')[2]) for log in filtered_logs] # Sort the activities based on the timestamp activities.sort(key=lambda x: x[1]) # Return the sorted activity types return [activity[0] for activity in activities]"},{"question":"def min_total_greeting_time(arrival: List[int], k: int) -> int: Returns the minimum total time required to greet all the guests. Parameters: arrival (List[int]): A list of integers representing the arrival times of the guests. k (int): The time in minutes required to meet one guest. Returns: int: The minimum total time required to greet all the guests. >>> min_total_greeting_time([10], 5) 5 >>> min_total_greeting_time([], 5) 0 >>> min_total_greeting_time([0, 5, 10], 5) 15 >>> min_total_greeting_time([10, 10, 10], 5) 15 >>> min_total_greeting_time([0, 2, 4, 6], 5) 20 >>> min_total_greeting_time([0, 3, 7], 5) 15 >>> min_total_greeting_time([1, 2, 3, 100], 5) 20 # Your code here","solution":"def min_total_greeting_time(arrival, k): Returns the minimum total time required to greet all the guests. Parameters: arrival (List[int]): A list of integers representing the arrival times of the guests. k (int): The time in minutes required to meet one guest. Returns: int: The minimum total time required to greet all the guests. if not arrival: return 0 arrival.sort() total_time = 0 end_time = 0 for time in arrival: if time >= end_time: total_time += k end_time = time + k else: total_time += k return total_time"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Shuffle the string s according to indices. Parameters: s (str): The input string. indices (list): The new indices for the characters in s. Returns: str: The shuffled string. >>> restore_string(\\"abc\\", [2, 1, 0]) == \\"cba\\" >>> restore_string(\\"a\\", [0]) == \\"a\\" >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) == \\"nihao\\" >>> restore_string(\\"abcdefgh\\", [7, 6, 5, 4, 3, 2, 1, 0]) == \\"hgfedcba\\" >>> restore_string(\\"art\\", [1, 0, 2]) == \\"rat\\"","solution":"def restore_string(s, indices): Shuffle the string s according to indices. Parameters: s (str): The input string. indices (list): The new indices for the characters in s. Returns: str: The shuffled string. # Initialize a list of the same length as s with empty strings shuffled = [''] * len(s) # Assign characters to their new positions for i, idx in enumerate(indices): shuffled[idx] = s[i] # Join the list into a single string and return return ''.join(shuffled)"},{"question":"import functools def compare_digits(x, y): if x + y < y + x: return -1 else: return 1 def smallest_number(arr: List[int]) -> str: Given an integer array \`arr\`, arranges the digits to form the smallest possible number. >>> smallest_number([50, 2, 1, 9]) \\"12509\\" >>> smallest_number([5, 3, 2, 1, 9, 7, 8, 6, 4, 0]) \\"0123456789\\" >>> smallest_number([13, 32, 321]) \\"1332132\\" >>> smallest_number([20, 200, 2]) \\"200202\\" >>> smallest_number([111, 11, 1]) \\"111111\\" >>> smallest_number([3, 30, 34, 5, 9]) \\"3033459\\" >>> smallest_number([]) \\"\\" >>> smallest_number([10]) \\"10\\"","solution":"import functools def compare_digits(x, y): if x + y < y + x: return -1 else: return 1 def smallest_number(arr): Given an integer array \`arr\`, arranges the digits to form the smallest possible number. str_arr = list(map(str, arr)) str_arr.sort(key=functools.cmp_to_key(compare_digits)) return ''.join(str_arr)"},{"question":"def min_window(s: str, p: str) -> str: Find the smallest window in \`s\` that contains all the characters of \`p\`. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"a\\", \\"a\\") \\"a\\" >>> min_window(\\"a\\", \\"aa\\") \\"\\" >>> min_window(\\"bba\\", \\"ab\\") \\"ba\\" >>> min_window(\\"acbbaca\\", \\"aba\\") \\"baca\\"","solution":"from collections import Counter, defaultdict def min_window(s, p): if not s or not p: return \\"\\" dict_p = Counter(p) required = len(dict_p) left, right = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None while right < len(s): character = s[right] window_counts[character] += 1 if character in dict_p and window_counts[character] == dict_p[character]: formed += 1 while left <= right and formed == required: character = s[left] end = right - left + 1 if end < ans[0]: ans = (end, left, right) window_counts[character] -= 1 if character in dict_p and window_counts[character] < dict_p[character]: formed -= 1 left += 1 right += 1 if ans[0] == float(\\"inf\\"): return \\"\\" else: return s[ans[1]: ans[2] + 1]"},{"question":"def simulate_stack(n: int, commands: List[str]) -> List[int]: Simulate stack operations based on incoming commands and return the results of the pops. Arguments: n -- an integer representing the number of commands commands -- a list of strings representing the commands where each command is either 'PUSH x' or 'POP' >>> simulate_stack(5, [\\"PUSH 3\\", \\"PUSH 5\\", \\"POP\\", \\"POP\\", \\"POP\\"]) [5, 3, -1] >>> simulate_stack(3, [\\"POP\\", \\"POP\\", \\"POP\\"]) [-1, -1, -1] >>> simulate_stack(6, [\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"POP\\", \\"POP\\", \\"POP\\"]) [3, 2, 1] >>> simulate_stack(6, [\\"PUSH 1\\", \\"POP\\", \\"PUSH 2\\", \\"POP\\", \\"PUSH 3\\", \\"POP\\"]) [1, 2, 3] >>> simulate_stack(10, [\\"PUSH 10\\", \\"PUSH 20\\", \\"POP\\", \\"POP\\", \\"POP\\", \\"PUSH 30\\", \\"PUSH 40\\", \\"POP\\", \\"PUSH 50\\", \\"POP\\"]) [20, 10, -1, 40, 50]","solution":"def simulate_stack(n, commands): stack = [] result = [] for command in commands: if \\"PUSH\\" in command: _, value = command.split() stack.append(int(value)) elif command == \\"POP\\": if stack: result.append(stack.pop()) else: result.append(-1) return result"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit from buying and selling the stock once. If no profit is possible, returns 0. :param prices: List[int] - list of stock prices in chronological order :return: int - the maximum profit >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([3, 2, 6, 5, 0, 3]) 4 >>> max_profit([]) 0 >>> max_profit([5]) 0","solution":"def max_profit(prices): Returns the maximum profit from buying and selling the stock once. If no profit is possible, returns 0. :param prices: List[int] - list of stock prices in chronological order :return: int - the maximum profit if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"def count_elements_in_range(nums: List[int], low: int, high: int) -> int: Counts how many elements in the list fall within the inclusive range [low, high]. Args: - nums (list of int): The list of integers to check. - low (int): The lower bound of the range. - high (int): The upper bound of the range. Returns: - int: The count of elements within the range. >>> count_elements_in_range([1, 2, 3, 4, 5], 1, 5) 5 >>> count_elements_in_range([1, 2, 3, 4, 5], 6, 10) 0 >>> count_elements_in_range([1, 2, 3, 6, 7], 2, 6) 3 >>> count_elements_in_range([-5, -1, 0, 1, 3], -2, 2) 3 >>> count_elements_in_range([7], 5, 10) 1 >>> count_elements_in_range([3], 4, 10) 0 >>> count_elements_in_range([], 1, 10) 0","solution":"def count_elements_in_range(nums, low, high): Counts how many elements in the list fall within the inclusive range [low, high]. Args: - nums (list of int): The list of integers to check. - low (int): The lower bound of the range. - high (int): The upper bound of the range. Returns: - int: The count of elements within the range. count = 0 for num in nums: if low <= num <= high: count += 1 return count"},{"question":"from typing import List def can_rearrange(s: str, p: int) -> bool: Determines if the input string s can be rearranged to ensure that no two adjacent characters are the same and all characters appear exactly p times consecutively before reappearing. :param s: Input string. :param p: Minimum spacing between the same characters. :return: True if rearrangement is possible, False otherwise. >>> can_rearrange(\\"aaabbc\\", 2) == True >>> can_rearrange(\\"aaab\\", 2) == False >>> can_rearrange(\\"aaabbb\\", 1) == True >>> can_rearrange(\\"abcdefg\\", 3) == True >>> can_rearrange(\\"aaaaaaa\\", 2) == False >>> can_rearrange(\\"\\", 1) == True >>> can_rearrange(\\"AaBbCc\\", 2) == True","solution":"from collections import Counter import heapq def can_rearrange(s, p): Determines if the input string s can be rearranged to ensure that no two adjacent characters are the same and all characters appear exactly p times consecutively before reappearing. :param s: Input string. :param p: Minimum spacing between the same characters. :return: True if rearrangement is possible, False otherwise. if p <= 1: return True # Count frequency of characters freq = Counter(s) # Create a max heap based on character frequency max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Queue to keep track of the element in waiting to be pushed back into the heap queue = [] output = [] while max_heap: count, char = heapq.heappop(max_heap) output.append(char) queue.append((char, count + 1)) # decrement the count since we use the char once if len(queue) < p: continue # After p elements, push the oldest one back to the heap if it still has a count remaining front_char, front_count = queue.pop(0) if front_count < 0: heapq.heappush(max_heap, (front_count, front_char)) return len(output) == len(s)"},{"question":"from typing import List def minMeetingRooms(tasks: List[List[int]]) -> int: Returns the minimum number of meeting rooms needed to hold all the tasks. >>> minMeetingRooms([]) == 0 >>> minMeetingRooms([[0, 10]]) == 1 >>> minMeetingRooms([[1, 5], [6, 10], [11, 15]]) == 1 >>> minMeetingRooms([[1, 10], [1, 10], [1, 10]]) == 3 >>> minMeetingRooms([[0, 30], [5, 10], [15, 20]]) == 2 >>> minMeetingRooms([[0, 5], [5, 10], [10, 15]]) == 1 >>> minMeetingRooms([[0, 10], [10, 20], [5, 15], [20, 30], [25, 35]]) == 2","solution":"def minMeetingRooms(tasks): Returns the minimum number of meeting rooms needed to hold all the tasks. if not tasks: return 0 # Separate out the start and end times start_times = sorted([task[0] for task in tasks]) end_times = sorted([task[1] for task in tasks]) start_pointer = end_pointer = 0 used_rooms = 0 while start_pointer < len(tasks): # If there is a meeting that has ended if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 # Allocate a room used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"def is_scramble(s1: str, s2: str) -> bool: Determines if s2 is a scrambled string of s1. >>> is_scramble(\\"great\\", \\"rgeat\\") True >>> is_scramble(\\"abcde\\", \\"caebd\\") False >>> is_scramble(\\"a\\", \\"a\\") True >>> is_scramble(\\"abcd\\", \\"bdac\\") False >>> is_scramble(\\"aabbcc\\", \\"ccbbaa\\") True >>> is_scramble(\\"abc\\", \\"bca\\") True >>> is_scramble(\\"abb\\", \\"bba\\") True >>> is_scramble(\\"ab\\", \\"ba\\") True >>> is_scramble(\\"\\", \\"\\") True >>> is_scramble(\\"a\\", \\"\\") False >>> is_scramble(\\"aaaa\\", \\"aaaa\\") True","solution":"def is_scramble(s1, s2): Determines if s2 is a scrambled string of s1. if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"from collections import defaultdict, deque from typing import List def findOrder(numCourses: int, prerequisites: List[List[int]]) -> List[int]: Determines if it is possible to finish all courses and returns the order of courses to take. :param numCourses: int - Total number of courses :param prerequisites: List[List[int]] - List of course prerequisites :return: List[int] - Order of courses to take, else an empty list if not possible >>> findOrder(2, []) in [[0, 1], [1, 0]] True >>> findOrder(2, [[1, 0]]) == [0, 1] True >>> findOrder(4, [[1, 0], [2, 1], [3, 2]]) == [0, 1, 2, 3] True >>> findOrder(2, [[0, 1], [1, 0]]) == [] True >>> findOrder(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) in [[0, 1, 2, 3], [0, 2, 1, 3]] True","solution":"from collections import defaultdict, deque def findOrder(numCourses, prerequisites): Determines if it is possible to finish all courses and returns the order of courses to take. :param numCourses: int - Total number of courses :param prerequisites: List[List[int]] - List of course prerequisites :return: List[int] - Order of courses to take, else an empty list if not possible # Create a graph and a list to count in-degrees of nodes graph = defaultdict(list) indegree = [0] * numCourses # Populate the graph and in-degree array for course, prereq in prerequisites: graph[prereq].append(course) indegree[course] += 1 # Queue for nodes with no incoming edges zero_indegree_queue = deque([i for i in range(numCourses) if indegree[i] == 0]) course_order = [] while zero_indegree_queue: current_course = zero_indegree_queue.popleft() course_order.append(current_course) # Decrease the in-degree of neighbouring nodes by 1 for neighbor in graph[current_course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If the course_order's length is equal to numCourses, we have a valid order if len(course_order) == numCourses: return course_order else: return []"},{"question":"from typing import List def leastInterval(tasks: List[str], k: int) -> int: Returns the least number of intervals the CPU will take to finish all tasks with cooldown period k. >>> leastInterval(['A', 'A', 'A', 'B', 'B', 'B'], 0) 6 >>> leastInterval(['A', 'A', 'A', 'B', 'B', 'B'], 2) 8 >>> leastInterval(['A'], 2) 1 >>> leastInterval(['A', 'B', 'C', 'D', 'E', 'F'], 2) 6 >>> leastInterval(['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C', 'D', 'D', 'E', 'F'], 2) 13","solution":"from collections import Counter def leastInterval(tasks, k): Returns the least number of intervals the CPU will take to finish all tasks with cooldown period k. task_counts = Counter(tasks) # Count the frequencies of each task max_count = max(task_counts.values()) # Get the maximum frequency of any task max_count_tasks = list(task_counts.values()).count(max_count) # Count the number of tasks with the maximum frequency # Calculate the number of intervals based on the formula intervals = (max_count - 1) * (k + 1) + max_count_tasks # The result is the max of the calculated intervals and the number of tasks return max(intervals, len(tasks))"},{"question":"def max_sum_subarray(nums: List[int], target: int) -> int: Finds the maximum sum of a continuous subarray within nums which does not exceed the target value. Returns 0 if no such subarray exists. >>> max_sum_subarray([1, 2, 3, 4, 5], 10) == 10 >>> max_sum_subarray([1, 2, 3, 4, 5], 15) == 15 >>> max_sum_subarray([1, 2, 3, 4, 10], 10) == 10 >>> max_sum_subarray([1, 2, 3, 4, 10], 8) == 7 >>> max_sum_subarray([5, 4, 3, 2, 1], 6) == 6 >>> max_sum_subarray([5, 4, 3, 2, 1], 1) == 1 >>> max_sum_subarray([-1, -2, -3, -4], 0) == 0 >>> max_sum_subarray([0, 0, 0], 0) == 0 >>> max_sum_subarray([5, 1, -3, -2, 4, 0], 6) == 6 >>> max_sum_subarray([9, 1, 2, 3, -2, -4, -1, 6], 10) == 10","solution":"def max_sum_subarray(nums, target): Finds the maximum sum of a continuous subarray within nums which does not exceed the target value. Returns 0 if no such subarray exists. max_sum = 0 # Variable to store the maximum sum current_sum = 0 # Variable to store the current sum of the subarray start = 0 # Start index of the subarray for end in range(len(nums)): current_sum += nums[end] # Shrink the window until the current sum is less than or equal to target while current_sum > target and start <= end: current_sum -= nums[start] start += 1 # Update the maximum sum if the current subarray's sum is less than or equal to target if current_sum <= target: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from collections import defaultdict, deque from typing import List def min_traversal_time(n: int, passageways: List[List[int]], chk_Time: int) -> int: Returns the minimum time required to get from room 1 to room n, including security checkpoint times. Arguments: n : int : The number of rooms passageways : List[List[int]] : The bi-directional passageways between rooms chk_Time : int : The security check time for each passageway Returns: int : The minimum time to travel from room 1 to room n pass def test_min_traversal_time(): assert min_traversal_time(2, [[1, 2]], 3) == 3 assert min_traversal_time(5, [[1, 2], [2, 3], [3, 4], [4, 5], [1, 3], [3, 5]], 2) == 4 assert min_traversal_time(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [1, 6]], 5) == 5 assert min_traversal_time(3, [[1, 2]], 1) == -1 assert min_traversal_time(5, [[1, 2], [2, 3], [1, 4], [4, 5]], 4) == 8","solution":"from collections import deque, defaultdict def min_traversal_time(n, passageways, chk_Time): Returns the minimum time required to get from room 1 to room n, including security checkpoint times. Arguments: n : int : The number of rooms passageways : List[List[int]] : The bi-directional passageways between rooms chk_Time : int : The security check time for each passageway Returns: int : The minimum time to travel from room 1 to room n # Create an adjacency list for the graph graph = defaultdict(list) for u, v in passageways: graph[u].append(v) graph[v].append(u) # BFS initialization queue = deque([(1, 0)]) # (current room, accumulated time) visited = {1} while queue: current_room, current_time = queue.popleft() # If we've reached room \`n\`, return the accumulated time if current_room == n: return current_time # Explore all neighbors for neighbor in graph[current_room]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_time + chk_Time)) # If there's no path from room 1 to room n return -1 # though, as per problem constraints, the museum is always connected # Example usage: # n = 5 # passageways = [[1, 2], [1, 3], [3, 4], [4, 5]] # chk_Time = 2 # print(min_traversal_time(n, passageways, chk_Time)) # Output should be 6"},{"question":"def max_profit_with_two_transactions(prices: List[int]) -> int: Given an array of integers \`arr\`, representing the prices of different items, determine the maximum profit you can achieve using at most two transactions. Note: * You cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). * You may assume that you cannot sell an item before you buy it. * If no profit can be made, return \`0\`. >>> max_profit_with_two_transactions([]) 0 >>> max_profit_with_two_transactions([5]) 0 >>> max_profit_with_two_transactions([5, 3]) 0 >>> max_profit_with_two_transactions([3, 5]) 2 >>> max_profit_with_two_transactions([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit_with_two_transactions([1, 2, 3, 4, 5]) 4 >>> max_profit_with_two_transactions([7, 1, 5, 3, 6, 4]) 7 >>> max_profit_with_two_transactions([7, 6, 4, 3, 1]) 0","solution":"def max_profit_with_two_transactions(prices): if len(prices) == 0: return 0 # Initialize variables for the maximum profit after the first and the second transaction max_profit_1 = 0 max_profit_2 = 0 # Initialize variables for the lowest price we have seen so far min_price_1 = float('inf') min_price_2 = float('inf') for price in prices: # Update for the first transaction min_price_1 = min(min_price_1, price) max_profit_1 = max(max_profit_1, price - min_price_1) # Update for the second transaction min_price_2 = min(min_price_2, price - max_profit_1) max_profit_2 = max(max_profit_2, price - min_price_2) return max_profit_2"},{"question":"def count_matching_patterns(patterns: List[str], word: str) -> int: Returns the number of patterns that match the word. A pattern matches the word if it can be transformed into the word by replacing '*' with any sequence of characters (including the empty sequence). >>> count_matching_patterns([\\"a*\\", \\"b*\\", \\"*c\\", \\"a*c\\"], \\"abc\\") == 3 >>> count_matching_patterns([\\"abc\\", \\"def\\", \\"ghi\\"], \\"abc\\") == 1 >>> count_matching_patterns([\\"a*c*\\", \\"a*b*c\\", \\"*b*\\", \\"*\\"], \\"abc\\") == 4 >>> count_matching_patterns([\\"*\\", \\"a*\\", \\"b*\\", \\"*c\\"], \\"\\") == 1 >>> count_matching_patterns([], \\"abc\\") == 0 >>> count_matching_patterns([\\"d*\\", \\"e*\\", \\"f*\\"], \\"abc\\") == 0","solution":"def count_matching_patterns(patterns, word): Returns the number of patterns that match the word. A pattern matches the word if it can be transformed into the word by replacing '*' with any sequence of characters (including the empty sequence). def matches(pattern, word): parts = pattern.split('*') if len(parts) == 1: return pattern == word if not word.startswith(parts[0]): return False word = word[len(parts[0]):] for part in parts[1:-1]: if part not in word: return False word = word[word.index(part) + len(part):] return word.endswith(parts[-1]) return sum(1 for pattern in patterns if matches(pattern, word))"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Given a m x n matrix of letters and a string \`word\`, determine if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Return true if the word exists in the grid, otherwise return false. >>> board1 = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> word1 = \\"ABCCED\\" >>> exist(board1, word1) True >>> board2 = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> word2 = \\"SEE\\" >>> exist(board2, word2) True >>> board3 = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> word3 = \\"ABCB\\" >>> exist(board3, word3) False >>> board4 = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> word4 = \\"E\\" >>> exist(board4, word4) True >>> board5 = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> word5 = \\"Z\\" >>> exist(board5, word5) False","solution":"def exist(board, word): def dfs(board, word, i, j, k): if not (0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == word[k]): return False if k == len(word) - 1: return True tmp, board[i][j] = board[i][j], '/' res = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1) board[i][j] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"from typing import List def find_cheapest_price(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: Returns the lowest price of a flight from src to dst with at most k stops. If there is no such route, returns -1. >>> find_cheapest_price(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 0) == 500 >>> find_cheapest_price(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1) == 200 >>> find_cheapest_price(4, [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 3, 700]], 0, 3, 2) == 300 >>> find_cheapest_price(4, [[0, 1, 100], [1, 2, 100], [2, 3, 100]], 0, 3, 0) == -1 >>> find_cheapest_price(4, [[0, 1, 100], [0, 2, 500], [1, 2, 100], [2, 3, 100], [1, 3, 600]], 0, 3, 2) == 300","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, src, dst, k): Returns the lowest price of a flight from src to dst with at most k stops. If there is no such route, returns -1. graph = defaultdict(list) for u, v, price in flights: graph[u].append((v, price)) pq = [(0, src, 0)] costs = defaultdict(lambda: float('inf')) costs[(src, 0)] = 0 while pq: total_cost, current_city, stops = heapq.heappop(pq) if current_city == dst: return total_cost if stops <= k: for neighbor, price in graph[current_city]: next_cost = total_cost + price if next_cost < costs[(neighbor, stops + 1)]: costs[(neighbor, stops + 1)] = next_cost heapq.heappush(pq, (next_cost, neighbor, stops + 1)) return -1"},{"question":"from typing import List import random def tournament_winner(skills: List[int]) -> int: Determine the winner of the tournament based on skills. In each round, the higher skill team wins. If skill levels are the same, a random one wins. :param skills: List[int] representing skill levels of teams :return: int representing the skill level of the winning team >>> tournament_winner([1, 2]) == 2 >>> tournament_winner([3, 5, 2, 1]) == 5 >>> tournament_winner([10, 10, 10, 10, 10, 10, 10, 10]) == 10 >>> tournament_winner([7, 7, 7, 7]) in [7] >>> tournament_winner([8, 4, 8, 4]) == 8 >>> tournament_winner([1, 2, 3, 4, 5, 6, 7, 8]) == 8 >>> tournament_winner([4, 6, 4, 6, 7, 1, 2, 3]) == 7 >>> tournament_winner([1, 9, 3, 5, 7, 10, 2, 11]) == 11","solution":"import random def tournament_winner(skills): Determine the winner of the tournament based on skills. In each round, the higher skill team wins. If skill levels are the same, a random one wins. :param skills: List[int] representing skill levels of teams :return: int representing the skill level of the winning team if not skills or len(skills) == 1: return skills[0] if skills else None while len(skills) > 1: next_round = [] for i in range(0, len(skills), 2): if skills[i] > skills[i+1]: next_round.append(skills[i]) elif skills[i] < skills[i+1]: next_round.append(skills[i+1]) else: next_round.append(random.choice([skills[i], skills[i+1]])) skills = next_round return skills[0]"},{"question":"from collections import Counter from typing import List def longest_valid_string_length(s: str, k: int) -> int: Returns the length of the longest possible string where each character appears at least k times. Args: s (str): The input string containing only lowercase English letters. k (int): The minimum number of times each character must appear in the final string. Returns: int: The length of the longest valid string. Examples: >>> longest_valid_string_length(\\"aabbcc\\", 2) 6 >>> longest_valid_string_length(\\"aabbcc\\", 3) 0 >>> longest_valid_string_length(\\"aaabbbccc\\", 3) 9 >>> longest_valid_string_length(\\"aaaaa\\", 1) 5 >>> longest_valid_string_length(\\"aaaaa\\", 5) 5 >>> longest_valid_string_length(\\"aaaaa\\", 6) 0 >>> longest_valid_string_length(\\"\\", 2) 0","solution":"from collections import Counter def longest_valid_string_length(s, k): Returns the length of the longest possible string where each character appears at least k times. # Count frequency of each character in the input string char_count = Counter(s) # Find the sum of counts for characters that appear at least k times valid_length = sum(count for count in char_count.values() if count >= k) return valid_length"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Removes adjacent duplicate characters from the string s and returns the final string. >>> remove_adjacent_duplicates(\\"abbaca\\") \\"ca\\" >>> remove_adjacent_duplicates(\\"a\\") \\"a\\" >>> remove_adjacent_duplicates(\\"aa\\") \\"\\" >>> remove_adjacent_duplicates(\\"abc\\") \\"abc\\" >>> remove_adjacent_duplicates(\\"abccba\\") \\"\\" >>> remove_adjacent_duplicates(\\"aaa\\") \\"a\\" >>> remove_adjacent_duplicates(\\"\\") \\"\\" >>> remove_adjacent_duplicates(\\"aabbaa\\") \\"\\" >>> remove_adjacent_duplicates(\\"aabbccddeeff\\") \\"\\" >>> remove_adjacent_duplicates(\\"azxxzy\\") \\"ay\\"","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicate characters from the string s. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"from typing import List def min_water_cells_to_add(grid: List[List[int]]) -> int: Returns the minimum number of water cells needed to be added to ensure every land cell is adjacent to at least one water cell. >>> min_water_cells_to_add([ ... [0, 2, 0], ... [2, 1, 2], ... [0, 2, 0] ... ]) == 0 >>> min_water_cells_to_add([ ... [1, 2, 1], ... [2, 0, 2], ... [1, 2, 1] ... ]) == 0 >>> min_water_cells_to_add([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 2] ... ]) == 1 >>> min_water_cells_to_add([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 3 >>> min_water_cells_to_add([ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ]) == 0 >>> min_water_cells_to_add([ ... [2, 2, 2], ... [2, 0, 2], ... [2, 2, 2] ... ]) == 0","solution":"def min_water_cells_to_add(grid): Returns the minimum number of water cells needed to be added to ensure every land cell is adjacent to at least one water cell. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(r, c): return 0 <= r < rows and 0 <= c < cols def is_adjacent_to_water(r, c): for dr, dc in directions: nr, nc = r + dr, c + dc if in_bounds(nr, nc) and grid[nr][nc] == 2: return True return False # Find all land cells that are not adjacent to any water cell land_cells = [(r, c) for r in range(rows) for c in range(cols) if grid[r][c] == 1 and not is_adjacent_to_water(r, c)] return len(land_cells)"},{"question":"def find_view_points(heights: List[int]) -> List[int]: Returns the indices of all view points in ascending order. A location \`i\` in the array is considered a \\"view point\\" if the height of the skyscraper at that location is greater than or equal to the height of all skyscrapers to its right, inclusive. >>> find_view_points([]) == [] >>> find_view_points([5]) == [0] >>> find_view_points([1, 2, 3, 4, 5]) == [4] >>> find_view_points([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4] >>> find_view_points([4, 2, 3, 1]) == [0, 2, 3] >>> find_view_points([2, 2, 2, 2]) == [0, 1, 2, 3] >>> find_view_points([1, 3, 2, 3, 1]) == [1, 3, 4]","solution":"def find_view_points(heights): Returns the indices of all view points in ascending order. A location \`i\` in the array is considered a \\"view point\\" if the height of the skyscraper at that location. is greater than or equal to the height of all skyscrapers to its right, inclusive. n = len(heights) if n == 0: return [] max_height_from_right = heights[-1] view_points = [n - 1] for i in range(n - 2, -1, -1): if heights[i] >= max_height_from_right: view_points.append(i) max_height_from_right = heights[i] return view_points[::-1]"},{"question":"def valid_events_count(timestamps, w): Returns the number of valid events in the timestamps array. An event is valid if there exists another event that occurred at most w minutes before it. Parameters: timestamps (List[int]): The timestamps of events. w (int): The maximum allowable difference in minutes between two events for them to be considered valid. Returns: int: The number of valid events. >>> valid_events_count([], 5) == 0 >>> valid_events_count([10], 5) == 0 >>> valid_events_count([5, 10], 5) == 1 >>> valid_events_count([1, 10], 5) == 0 >>> valid_events_count([1, 2, 8, 3, 12], 5) == 3 >>> valid_events_count([0, 10, 20, 30], 5) == 0 >>> valid_events_count([1, 2, 3, 4, 5], 5) == 4 >>> valid_events_count([5, 5, 5, 5, 5], 5) == 4","solution":"def valid_events_count(timestamps, w): Returns the number of valid events in the timestamps array. An event is valid if there exists another event that occurred at most w minutes before it. Parameters: timestamps (List[int]): The timestamps of events. w (int): The maximum allowable difference in minutes between two events for them to be considered valid. Returns: int: The number of valid events. valid_events = 0 for i in range(1, len(timestamps)): for j in range(i): if abs(timestamps[i] - timestamps[j]) <= w: valid_events += 1 break return valid_events"},{"question":"def findSpiralOrder(matrix): Returns the elements of the matrix in spiral order. >>> findSpiralOrder([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> findSpiralOrder([[1]]) [1] >>> findSpiralOrder([[1, 2, 3]]) [1, 2, 3] >>> findSpiralOrder([[1], [2], [3]]) [1, 2, 3] >>> findSpiralOrder([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> findSpiralOrder([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... [10, 11, 12] ... ]) [1, 2, 3, 6, 9, 12, 11, 10, 7, 4, 5, 8] >>> findSpiralOrder([]) []","solution":"def findSpiralOrder(matrix): Returns the elements of the matrix in spiral order. if not matrix: return [] spiral_order = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: for i in range(left, right + 1): spiral_order.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): spiral_order.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): spiral_order.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): spiral_order.append(matrix[i][left]) left += 1 return spiral_order"},{"question":"def find_cheapest_price(n: int, flights: List[Tuple[int, int, int]], source: int, destination: int, k: int) -> int: Find the minimum travel cost to reach the destination city from the source city with at most k stops. Args: n: Total number of cities flights: List of (source, destination, cost) tuples source: Starting city destination: Target city k: Maximum number of allowed stops Returns: Minimum travel cost from source to destination with at most k stops, or -1 if no such path exists. >>> find_cheapest_price(3, [(0, 1, 100), (1, 2, 100), (0, 2, 500)], 0, 2, 1) 200 >>> find_cheapest_price(3, [(0, 1, 100), (1, 2, 100), (0, 2, 500)], 0, 2, 0) 500 >>> find_cheapest_price(3, [(0, 1, 100), (1, 2, 100)], 0, 2, 0) -1 >>> find_cheapest_price(4, [(0, 1, 100), (1, 3, 100), (3, 2, 100), (0, 2, 500)], 0, 2, 2) 300 >>> find_cheapest_price(4, [(0, 1, 50), (0, 2, 100), (1, 2, 50), (2, 3, 50), (1, 3, 100)], 0, 3, 1) 150 >>> find_cheapest_price(5, [], 0, 3, 2) -1","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, source, destination, k): # Create an adjacency list for the graph representation graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) # Priority queue to hold (cost, current city, stops) pq = [(0, source, 0)] # Dictionary to record the minimum cost to reach each node with at most a certain number of stops costs = {(source, 0): 0} while pq: cost, node, stops = heapq.heappop(pq) # If we reach the destination within the allowed stops, return the cost if node == destination and stops <= k + 1: return cost # If we can still make a stop if stops <= k: for nei, price in graph[node]: next_cost = cost + price if (nei, stops + 1) not in costs or next_cost < costs[(nei, stops + 1)]: costs[(nei, stops + 1)] = next_cost heapq.heappush(pq, (next_cost, nei, stops + 1)) return -1"},{"question":"def min_operations_to_equal_arrays(arr1, arr2, k): Returns the minimum number of operations needed to make arr1 and arr2 equal, or -1 if it is not possible within k operations. >>> min_operations_to_equal_arrays([1, 0], [1, 0], 0) == 0 >>> min_operations_to_equal_arrays([1, 0], [0, 1], 1) == 1 >>> min_operations_to_equal_arrays([1, 1, 0, 0], [0, 0, 1, 1], 2) == 2 >>> min_operations_to_equal_arrays([1, 0, 1, 1], [0, 1, 0, 0], 1) == -1 >>> min_operations_to_equal_arrays([1, 1, 0], [0, 0, 1], 2) == -1 >>> min_operations_to_equal_arrays([0, 1, 0, 1], [1, 0, 1, 0], 5) == 2 >>> min_operations_to_equal_arrays([0, 1], [1, 0], 0) == -1","solution":"def min_operations_to_equal_arrays(arr1, arr2, k): Returns the minimum number of operations needed to make arr1 and arr2 equal or -1 if it is not possible within k operations. if len(arr1) != len(arr2): return -1 n = len(arr1) diff_count = sum(1 for i in range(n) if arr1[i] != arr2[i]) if diff_count % 2 != 0 or diff_count > 2 * k: return -1 return diff_count // 2"},{"question":"def is_palindrome(s: str) -> bool: Helper function to check if a string is a palindrome. return s == s[::-1] def palindrome_pair(words: List[str]) -> bool: Determine if there exists a pair of words in the input list such that their concatenation is a palindrome. >>> palindrome_pair([\\"bat\\", \\"tab\\", \\"cat\\"]) == True >>> palindrome_pair([\\"abc\\", \\"def\\", \\"ghi\\"]) == False >>> palindrome_pair([]) == False >>> palindrome_pair([\\"racecar\\"]) == False >>> palindrome_pair([\\"a\\", \\"b\\", \\"c\\", \\"bb\\"]) == True >>> palindrome_pair([\\"bc\\", \\"cb\\", \\"xyz\\", \\"zyx\\"]) == True","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def palindrome_pair(words): Function to determine if there exists a pair of words in the input list such that their concatenation is a palindrome. word_set = set(words) for word in words: for i in range(len(word) + 1): prefix = word[:i] suffix = word[i:] # Check if the suffix + prefix is a palindrome if is_palindrome(prefix) and suffix[::-1] in word_set and suffix[::-1] != word: return True # Check if the prefix + suffix is a palindrome if is_palindrome(suffix) and prefix[::-1] in word_set and prefix[::-1] != word: return True return False"},{"question":"def max_tasks(skills: List[int], threshold: int) -> int: Returns the maximum number of tasks that can be assigned where each task has exactly two employees with a skill difference that does not exceed the threshold. >>> max_tasks([4, 8, 5, 3, 1], 2) 2 >>> max_tasks([1, 2, 3, 4, 5], 1) 2 >>> max_tasks([10, 20, 30], 5) 0 >>> max_tasks([5, 5, 5, 5, 5], 0) 2 >>> max_tasks([4, 9, 1, 5, 7], 10) 2 >>> max_tasks([], 3) 0 >>> max_tasks([10], 2) 0","solution":"def max_tasks(skills, threshold): Returns the maximum number of tasks that can be assigned where each task has exactly two employees with a skill difference that does not exceed the threshold. skills.sort() i, j = 0, 1 num_tasks = 0 n = len(skills) while i < n and j < n: if (skills[j] - skills[i]) <= threshold: num_tasks += 1 i += 2 j = i + 1 else: j += 1 if j == n and i + 1 < n: i += 1 j = i + 1 return num_tasks"},{"question":"def shortest_path_labyrinth(grid: List[List[int]]) -> int: Calculate the shortest path from top-left to bottom-right in a labyrinth grid. Args: grid: List[List[int]]: A 2D list where 1 represents open paths and 0 represents blocked cells. Returns: int: The length of the shortest path from the top-left to the bottom-right cell. -1 if no path exists. >>> grid = [ ... [1, 1, 0, 1], ... [1, 0, 1, 0], ... [1, 1, 1, 1], ... [0, 1, 0, 1] ... ] >>> shortest_path_labyrinth(grid) 7 >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> shortest_path_labyrinth(grid) -1 >>> grid = [ ... [1, 1], ... [1, 1] ... ] >>> shortest_path_labyrinth(grid) 3 >>> grid = [[1]] >>> shortest_path_labyrinth(grid) 1 >>> grid = [ ... [1, 1, 1, 1, 1], ... [0, 0, 1, 0, 1], ... [1, 1, 1, 0, 1], ... [1, 0, 0, 1, 1], ... [1, 1, 1, 1, 1] ... ] >>> shortest_path_labyrinth(grid) 9 >>> grid = [ ... [1, 1], ... [1, 0] ... ] >>> shortest_path_labyrinth(grid) -1","solution":"from collections import deque def shortest_path_labyrinth(grid): Calculate the shortest path from top-left to bottom-right in a labyrinth grid. Args: grid: List[List[int]]: A 2D list where 1 represents open paths and 0 represents blocked cells. Returns: int: The length of the shortest path from the top-left to the bottom-right cell. -1 if no path exists. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 0 or grid[m-1][n-1] == 0: return -1 # Directions for moving in the grid: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() # If we reached the bottom-right corner if x == m-1 and y == n-1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1"},{"question":"def max_students_can_see_board(heights): Returns the maximum number of students who can see the board. >>> max_students_can_see_board([5, 5, 5, 5]) == 1 >>> max_students_can_see_board([1, 2, 3, 4, 5]) == 5 >>> max_students_can_see_board([5, 4, 3, 2, 1]) == 5 >>> max_students_can_see_board([4, 2, 5, 3, 1]) == 5 >>> max_students_can_see_board([5]) == 1","solution":"def max_students_can_see_board(heights): Returns the maximum number of students who can see the board. heights.sort(reverse=True) tallest_so_far = heights[0] count = 1 for i in range(1, len(heights)): if heights[i] < tallest_so_far: count += 1 tallest_so_far = heights[i] return count"},{"question":"def can_partition(nums: List[int]) -> bool: You are given a list of \`n\` integers. You need to partition the list into two subsets such that the sum of the elements in both subsets is equal. Return \`true\` if you can achieve this partition, or \`false\` otherwise. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1]) False >>> can_partition([4, 4]) True >>> can_partition([1, 2, 5, 10]) False >>> can_partition([1, 2, 3, 6, 7, 3, 2, 4]) True","solution":"def can_partition(nums): total_sum = sum(nums) # If the total sum is odd, it's impossible to partition it into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a 1D DP array dp = [False] * (target + 1) dp[0] = True # Iterate through the numbers for num in nums: # Update the dp array from right to left for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def islandPerimeter(grid: List[List[int]]) -> int: Returns the perimeter of the island in the given grid. >>> islandPerimeter([[1]]) 4 >>> islandPerimeter([[1, 1]]) 6 >>> islandPerimeter([[1, 1], [1, 1]]) 8 >>> islandPerimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]) 16 >>> islandPerimeter([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> islandPerimeter([[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]) 8","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the given grid. if not grid or not grid[0]: return 0 perimeter = 0 rows = len(grid) cols = len(grid[0]) for i in range(rows): for j in range(cols): if grid[i][j] == 1: # Check top if i == 0 or grid[i-1][j] == 0: perimeter += 1 # Check bottom if i == rows-1 or grid[i+1][j] == 0: perimeter += 1 # Check left if j == 0 or grid[i][j-1] == 0: perimeter += 1 # Check right if j == cols-1 or grid[i][j+1] == 0: perimeter += 1 return perimeter"},{"question":"def longest_substring_with_at_least_p_repeats(s: str, p: int) -> int: Given a string s and an integer p, return the length of the longest substring such that every character in this substring appears at least p times. >>> longest_substring_with_at_least_p_repeats(\\"aaabb\\", 3) 3 >>> longest_substring_with_at_least_p_repeats(\\"ababbc\\", 2) 5 >>> longest_substring_with_at_least_p_repeats(\\"a\\", 2) 0 >>> longest_substring_with_at_least_p_repeats(\\"aaabbb\\", 3) 6 >>> longest_substring_with_at_least_p_repeats(\\"ababacb\\", 3) 0 >>> longest_substring_with_at_least_p_repeats(\\"abcabcabcabc\\", 3) 12","solution":"def longest_substring_with_at_least_p_repeats(s, p): Given a string s and an integer p, returns the length of the longest substring such that every character in this substring appears at least p times. def helper(s, p): if len(s) < p: return 0 frequency = {} for char in s: frequency[char] = frequency.get(char, 0) + 1 for char in frequency: if frequency[char] < p: # Split the string by this character and recursively check each part return max(helper(t, p) for t in s.split(char)) # If all characters meet the frequency requirement, return the length of the string return len(s) return helper(s, p)"},{"question":"def longest_common_subarray_length(arr1, arr2): Returns the length of the longest common subarray with elements in same order in both arrays. >>> longest_common_subarray_length([1, 2, 3], [4, 5, 6]) 0 >>> longest_common_subarray_length([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) 3 >>> longest_common_subarray_length([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 5 >>> longest_common_subarray_length([1], [1]) 1 >>> longest_common_subarray_length([1, 2, 1, 2, 3], [2, 1, 2, 3]) 4 >>> longest_common_subarray_length([], []) 0 >>> longest_common_subarray_length([], [1, 2, 3]) 0","solution":"def longest_common_subarray_length(arr1, arr2): Returns the length of the longest common subarray with elements in same order in both arrays. n = len(arr1) m = len(arr2) dp = [[0] * (m + 1) for _ in range(n + 1)] max_len = 0 for i in range(1, n + 1): for j in range(1, m + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len"},{"question":"class WordDictionary: def __init__(self): Initializes the object. pass def addWord(self, word): Adds a word into the data structure. Args: word (str): The word to add. pass def search(self, word): Returns true if the word is in the data structure (with support for '.' wildcards), otherwise returns false. Args: word (str): The word to search. Returns: bool: True if the word is found, False otherwise. Examples: >>> word_dict = WordDictionary() >>> word_dict.addWord(\\"bad\\") >>> word_dict.addWord(\\"dad\\") >>> word_dict.addWord(\\"mad\\") >>> word_dict.search(\\"pad\\") False >>> word_dict.search(\\"bad\\") True >>> word_dict.search(\\".ad\\") True >>> word_dict.search(\\"b..\\") True >>> word_dict.search(\\"b.d\\") True >>> word_dict.search(\\"..d\\") True >>> word_dict.search(\\"...\\") True >>> word_dict.search(\\"....\\") False >>> word_dict.search(\\"..e\\") False pass","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word): self.words.append(word) def search(self, word): for w in self.words: if len(w) != len(word): continue for i in range(len(w)): if word[i] != '.' and word[i] != w[i]: break else: return True return False"},{"question":"def find_repeated_dna_sequences(s: str) -> List[str]: Returns a list of 10-letter-long sequences (substrings) that occur more than once in the given DNA string \`s\`. >>> find_repeated_dna_sequences(\\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\\") == [\\"AAAAACCCCC\\", \\"CCCCCAAAAA\\"] >>> find_repeated_dna_sequences(\\"ACGTACGTACGT\\") == [] >>> find_repeated_dna_sequences(\\"AAAAAAAAAAA\\") == [\\"AAAAAAAAAA\\"] >>> find_repeated_dna_sequences(\\"AAAAAAAAAAAA\\") == [\\"AAAAAAAAAA\\"] >>> find_repeated_dna_sequences(\\"AAAACCCCCTTTTAAAACCCCCT\\") == [\\"AAAACCCCCT\\"]","solution":"from collections import defaultdict def find_repeated_dna_sequences(s): Returns a list of 10-letter-long sequences (substrings) that occur more than once in the given DNA string \`s\`. sequence_length = 10 sequence_count = defaultdict(int) result = [] for i in range(len(s) - sequence_length + 1): sequence = s[i:i + sequence_length] sequence_count[sequence] += 1 for sequence, count in sequence_count.items(): if count > 1: result.append(sequence) return result"},{"question":"def min_largest_after_operations(arr: List[int]) -> int: Given an array of integers, this function returns the minimum possible value of the largest element in the array after performing the operation of removing the smaller of two adjacent elements any number of times. >>> min_largest_after_operations([10]) 10 >>> min_largest_after_operations([5, 5, 5, 5]) 5 >>> min_largest_after_operations([7, 2, 5, 8, 3]) 2 >>> min_largest_after_operations([1, 2, 3, 4]) 1 >>> min_largest_after_operations([4, 3, 2, 1]) 1","solution":"def min_largest_after_operations(arr): Returns the minimum possible value of the largest element in the array by repeatedly removing the smaller of two adjacent elements. return min(arr)"},{"question":"from typing import List def min_trees_to_cut(heights: List[int]) -> int: Calculate the minimum number of trees to cut down to form a strictly increasing sequence. Args: heights (List[int]): A list of integers representing the heights of trees. Returns: int: The minimum number of trees to cut down. Examples: >>> min_trees_to_cut([3, 7, 5, 6, 9]) 1 >>> min_trees_to_cut([1, 2, 3, 4, 5]) 0 >>> min_trees_to_cut([5, 4, 3, 2, 1]) 4 >>> min_trees_to_cut([10, 1, 2, 3]) 1 pass","solution":"def min_trees_to_cut(heights): from bisect import bisect_left def longest_increasing_subsequence(seq): lis = [] for x in seq: idx = bisect_left(lis, x) if idx == len(lis): lis.append(x) else: lis[idx] = x return len(lis) n = len(heights) lis_length = longest_increasing_subsequence(heights) return n - lis_length"},{"question":"def min_length_subarray(arr, target): Finds the smallest continuous subarray whose sum equals the target. If there are multiple subarrays with the same smallest length that sum to the target, returns any one of them. If no such subarray exists, returns an empty array. >>> min_length_subarray([5], 5) [5] >>> min_length_subarray([1, 2, 3, 4, 5], 3) [3] >>> min_length_subarray([1, 2, 3, 4, 5], 9) [4, 5] >>> min_length_subarray([1, 2, 3, 4, 5], 7) [3, 4] >>> min_length_subarray([1, 2, 3, 4, 5], 20) [] >>> min_length_subarray([1, 2, 3, 2, 5], 5) in [[5], [3, 2]] >>> min_length_subarray([2, 2, 2, 2, 2], 4) [2, 2] >>> min_length_subarray(list(range(1, 101)), 5050) == list(range(1, 101))","solution":"def min_length_subarray(arr, target): Finds the smallest continuous subarray whose sum equals the target. If there are multiple subarrays with the same smallest length that sum to the target, returns any one of them. If no such subarray exists, returns an empty array. n = len(arr) min_len = float('inf') start = 0 current_sum = 0 result = [] for end in range(n): current_sum += arr[end] while current_sum >= target: if current_sum == target: if end - start + 1 < min_len: min_len = end - start + 1 result = arr[start:end + 1] current_sum -= arr[start] start += 1 return result"},{"question":"def longest_even_subarray(arr): Returns the length of the longest subarray that contains only even numbers. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest subarray containing only even numbers. from solution import longest_even_subarray def test_all_even_numbers(): arr = [2, 4, 6, 8, 10] assert longest_even_subarray(arr) == 5 def test_no_even_numbers(): arr = [1, 3, 5, 7, 9] assert longest_even_subarray(arr) == 0 def test_mixed_numbers(): arr = [1, 2, 4, 5, 6, 8, 10, 1, 12, 14] assert longest_even_subarray(arr) == 3 def test_single_even_number(): arr = [1, 3, 5, 2, 7, 11] assert longest_even_subarray(arr) == 1 def test_empty_array(): arr = [] assert longest_even_subarray(arr) == 0 def test_consecutive_even_sections(): arr = [2, 4, 1, 6, 8, 10, 1, 2, 4, 6] assert longest_even_subarray(arr) == 3","solution":"def longest_even_subarray(arr): Returns the length of the longest subarray that contains only even numbers. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest subarray containing only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def knapsack_with_constraints(n: int, weights: List[int], values: List[int], W: int, forbidden_pairs: List[Tuple[int, int]]) -> int: Determine the maximum value you can obtain in a knapsack of capacity W considering a set of forbidden item pairs. >>> knapsack_with_constraints(3, [1, 2, 3], [6, 10, 12], 5, []) == 22 >>> knapsack_with_constraints(3, [1, 2, 3], [6, 10, 12], 5, [(1, 2)]) == 18 >>> knapsack_with_constraints(3, [1, 2, 3], [6, 10, 12], 0, []) == 0 >>> knapsack_with_constraints(1, [10], [100], 10, []) == 100 >>> knapsack_with_constraints(0, [], [], 10, []) == 0 >>> knapsack_with_constraints(3, [1, 2, 3], [6, 10, 12], 5, [(0, 1), (1, 2), (0, 2)]) == 12 >>> knapsack_with_constraints(4, [2, 2, 3, 4], [4, 3, 8, 8], 5, [(0, 1), (2, 3)]) == 12","solution":"def knapsack_with_constraints(n, weights, values, W, forbidden_pairs): from itertools import combinations def is_valid_set(selected_indices, forbidden_pairs): selected_set = set(selected_indices) for (i, j) in forbidden_pairs: if i in selected_set and j in selected_set: return False return True max_value = 0 for r in range(n + 1): for item_set in combinations(range(n), r): total_weight = sum(weights[i] for i in item_set) total_value = sum(values[i] for i in item_set) if total_weight <= W and is_valid_set(item_set, forbidden_pairs): max_value = max(max_value, total_value) return max_value"},{"question":"import heapq from typing import List def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merge k sorted arrays into a single sorted array. Parameters: arrays (list of list of int): a list of k sorted integer arrays Returns: list of int: a single sorted array pass # complete the function implementation def test_single_array(): assert merge_sorted_arrays([[1, 3, 5]]) == [1, 3, 5] def test_two_arrays(): assert merge_sorted_arrays([[1, 4, 6], [2, 3, 5]]) == [1, 2, 3, 4, 5, 6] def test_multiple_arrays(): assert merge_sorted_arrays([ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_empty_arrays(): assert merge_sorted_arrays([[], [], []]) == [] def test_mixed_length_arrays(): assert merge_sorted_arrays([ [1, 4], [2, 3, 5, 8], [0, 6, 7] ]) == [0, 1, 2, 3, 4, 5, 6, 7, 8] def test_some_empty_arrays(): assert merge_sorted_arrays([ [], [1, 2, 3], [], [4, 5], [] ]) == [1, 2, 3, 4, 5]","solution":"import heapq def merge_sorted_arrays(arrays): Merge k sorted arrays into a single sorted array. Parameters: arrays (list of list of int): a list of k sorted integer arrays Returns: list of int: a single sorted array # Create a min-heap to store the first element of each array along with the array index and element index min_heap = [] for array_index, array in enumerate(arrays): if array: # check if the array is not empty heapq.heappush(min_heap, (array[0], array_index, 0)) result = [] while min_heap: # Get the smallest element from the heap value, array_index, element_index = heapq.heappop(min_heap) result.append(value) # If there is another element in the same array, add it to the heap if element_index + 1 < len(arrays[array_index]): next_tuple = (arrays[array_index][element_index + 1], array_index, element_index + 1) heapq.heappush(min_heap, next_tuple) return result"},{"question":"def kth_distinct_element(nums: List[int], k: int) -> Union[int, str]: Returns the k-th distinct element of the array \`nums\`. If there are fewer than k distinct elements, returns an empty string. Parameters: nums (list of int): List of integers. k (int): The k-th position to find the distinct element. Returns: int or str : The k-th distinct element or \\"\\" if fewer than k distinct elements exist. >>> kth_distinct_element([1, 2, 2, 3, 4], 1) == 1 >>> kth_distinct_element([1, 2, 2, 3, 4], 2) == 2 >>> kth_distinct_element([1, 2, 2, 3, 4], 3) == 3 >>> kth_distinct_element([1, 2, 2, 3, 4], 4) == 4 >>> kth_distinct_element([1, 2, 2, 3, 4], 5) == \\"\\" >>> kth_distinct_element([3, 3, 3, 5], 1) == 3 >>> kth_distinct_element([3, 3, 1, 1, 4], 2) == 1 >>> kth_distinct_element([3, 3, 1, 4, 5], 3) == 4 >>> kth_distinct_element([1, 1, 1, 1], 1) == 1 >>> kth_distinct_element([1, 1, 1, 1], 2) == \\"\\" >>> kth_distinct_element([1, 1, 1, 1], 100) == \\"\\" >>> kth_distinct_element([], 1) == \\"\\" >>> kth_distinct_element([5], 1) == 5 >>> kth_distinct_element([5], 2) == \\"\\"","solution":"def kth_distinct_element(nums, k): Returns the k-th distinct element of the array \`nums\`. If there are fewer than k distinct elements, returns an empty string. Parameters: nums (list of int): List of integers. k (int): The k-th position to find the distinct element. Returns: int or str : The k-th distinct element or \\"\\" if fewer than k distinct elements exist. distinct_elements = [] seen = set() for num in nums: if num not in seen: distinct_elements.append(num) seen.add(num) if k <= len(distinct_elements): return distinct_elements[k-1] else: return \\"\\""},{"question":"def can_see_sunset(heights: List[int]) -> List[int]: Determines which buildings can see the sunset. Args: heights (list of int): Heights of the buildings. Returns: list of int: A binary list where 1 indicates the building can see the sunset and 0 indicates it cannot. >>> can_see_sunset([4, 3, 2, 1]) [1, 1, 1, 1] >>> can_see_sunset([1, 2, 3, 4]) [0, 0, 0, 1] >>> can_see_sunset([1, 3, 2, 4]) [0, 0, 0, 1] >>> can_see_sunset([10, 4, 2, 3, 4, 1, 7]) [1, 0, 0, 0, 0, 0, 1] >>> can_see_sunset([]) [] >>> can_see_sunset([5]) [1]","solution":"def can_see_sunset(heights): Determines which buildings can see the sunset. Args: heights (list of int): Heights of the buildings. Returns: list of int: A binary list where 1 indicates the building can see the sunset and 0 indicates it cannot. n = len(heights) result = [0] * n max_height = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height: result[i] = 1 max_height = heights[i] return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n): Generates all structurally unique BST's (binary search trees) that store values 1 to \`n\`. >>> len(generateTrees(0)) == 0 True >>> len(generateTrees(1)) == 1 True >>> len(generateTrees(2)) == 2 True >>> len(generateTrees(3)) == 5 True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n): Generates all structurally unique BST's (binary search trees) that store values 1 to \`n\`. Parameters: n (int): The number of nodes in the BST. Returns: List[TreeNode]: A list of root nodes of all unique BSTs. if n == 0: return [] def generate_tree(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_tree(start, i - 1) right_trees = generate_tree(i + 1, end) for left in left_trees: for right in right_trees: current_tree = TreeNode(i) current_tree.left = left current_tree.right = right all_trees.append(current_tree) return all_trees return generate_tree(1, n)"},{"question":"def min_ladders_required(heights: List[int], N: int) -> int: Returns the minimum number of ladders required to allow all N people to visit all the buildings in the given order. :param heights: List[int] - List where heights[i] is the height of the ith building. :param N: int - Number of people :return: int - Minimum number of ladders required >>> min_ladders_required([], 5) == 0 >>> min_ladders_required([], 0) == 0 >>> min_ladders_required([5], 1) == 0 >>> min_ladders_required([5], 3) == 0 >>> min_ladders_required([1, 2, 3, 4], 2) == 3 >>> min_ladders_required([4, 3, 2, 1], 2) == 0 >>> min_ladders_required([3, 1, 2, 4], 3) == 2 >>> min_ladders_required([2, 3, 3, 2], 4) == 1 >>> min_ladders_required([5, 5, 5, 5], 1) == 0 >>> min_ladders_required([1, 1, 1], 2) == 0","solution":"def min_ladders_required(heights, N): Returns the minimum number of ladders required to allow all N people to visit all the buildings in the given order. :param heights: List[int] - List where heights[i] is the height of the ith building. :param N: int - Number of people :return: int - Minimum number of ladders required if not heights or N <= 0: return 0 # If there's only one building, no ladder is needed if len(heights) == 1: return 0 ladders_needed = 0 for i in range(1, len(heights)): if heights[i] > heights[i - 1]: ladders_needed += 1 return ladders_needed"},{"question":"def count_visible_buildings(heights: List[int]) -> int: Given a list of heights representing the heights of buildings, return the number of buildings that are visible from the left side. A building is visible if there are no taller buildings to its left. Args: heights (list): A list of integers representing heights of buildings. Returns: int: The number of visible buildings from the left side. >>> count_visible_buildings([10]) 1 >>> count_visible_buildings([]) 0 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([5, 4, 3, 2, 1]) 1 >>> count_visible_buildings([3, 1, 4, 2, 5]) 3 >>> count_visible_buildings([3, 3, 3, 3, 3]) 1","solution":"def count_visible_buildings(heights): Given a list of heights representing the heights of buildings, return the number of buildings that are visible from the left side. A building is visible if there are no taller buildings to its left. Args: heights (list): A list of integers representing heights of buildings. Returns: int: The number of visible buildings from the left side. if not heights: return 0 max_height = heights[0] visible_count = 1 for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string possible after performing any number of allowed operations i.e., swapping or removing adjacent similar characters. >>> lexicographically_smallest_string(\\"abba\\") == \\"\\" >>> lexicographically_smallest_string(\\"acacb\\") == \\"acacb\\" >>> lexicographically_smallest_string(\\"abccba\\") == \\"\\" >>> lexicographically_smallest_string(\\"aabbcc\\") == \\"\\" >>> lexicographically_smallest_string(\\"abc\\") == \\"abc\\" >>> lexicographically_smallest_string(\\"\\") == \\"\\" >>> lexicographically_smallest_string(\\"azxxzy\\") == \\"ay\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string possible after performing any number of allowed operations i.e., swapping or removing adjacent similar characters. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \\"\\".join(stack)"},{"question":"from typing import List def check_subarray_sum(arr: List[int], k: int) -> bool: Determine if there exists a continuous subarray (of at least two numbers) that sums up to a multiple of k. >>> check_subarray_sum([23, 2, 4, 6, 7], 6) == True >>> check_subarray_sum([23, 2, 6, 4, 7], 6) == True >>> check_subarray_sum([23, 2, 6, 4, 7], 13) == False >>> check_subarray_sum([1, 2, 3, 4, 5], 0) == False >>> check_subarray_sum([0, 0], 0) == True >>> check_subarray_sum([0, 1, 0], 0) == False >>> check_subarray_sum([23, 2, 4, 6, 7, 30], 6) == True >>> check_subarray_sum([5, 0, 0], 5) == True","solution":"def check_subarray_sum(arr, k): Returns True if there exists a continuous subarray of at least two numbers that sums up to a multiple of k, otherwise returns False. if k == 0: return any(arr[i] == 0 and arr[i + 1] == 0 for i in range(len(arr) - 1)) mod_dict = {0: -1} current_sum = 0 for idx, num in enumerate(arr): current_sum += num mod = current_sum % k if mod in mod_dict: if idx - mod_dict[mod] > 1: return True else: mod_dict[mod] = idx return False"},{"question":"def islandPerimeter(grid: List[List[int]]) -> int: Returns the perimeter of the island in the grid. >>> islandPerimeter([[1]]) 4 >>> islandPerimeter([[1, 1, 1, 1]]) 10 >>> islandPerimeter([ [1], [1], [1], [1] ]) 10 >>> islandPerimeter([ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0] ]) 12 >>> islandPerimeter([ [0,0,0,0], [0,1,1,0], [0,1,0,0], [0,0,0,0] ]) 8 >>> islandPerimeter([ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) 12 >>> islandPerimeter([ [0, 1], [0, 0] ]) 4","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Start with 4 sides of the cell perimeter += 4 # Subtract sides for neighboring land cells if r > 0 and grid[r-1][c] == 1: # upper cell perimeter -= 1 if r < rows - 1 and grid[r+1][c] == 1: # lower cell perimeter -= 1 if c > 0 and grid[r][c-1] == 1: # left cell perimeter -= 1 if c < cols - 1 and grid[r][c+1] == 1: # right cell perimeter -= 1 return perimeter"},{"question":"def find_duplicate_and_missing(nums): Finds and returns the duplicate and missing number in the given list of nums. Args: nums: list, list of integers where each integer is between 1 and n. Returns: tuple, (duplicate, missing) where 'duplicate' is the number which appears more than once and 'missing' is the number that is missing in the list. >>> find_duplicate_and_missing([1, 2, 2, 4]) == (2, 3) >>> find_duplicate_and_missing([1, 3, 3, 4, 5]) == (3, 2) >>> find_duplicate_and_missing([3, 1, 3]) == (3, 2) >>> find_duplicate_and_missing([1, 2, 4, 5, 6, 6]) == (6, 3) >>> find_duplicate_and_missing([2, 2]) == (2, 1)","solution":"def find_duplicate_and_missing(nums): Finds and returns the duplicate and missing number in the given list of nums. Args: nums: list, list of integers where each integer is between 1 and n. Returns: tuple, (duplicate, missing) where 'duplicate' is the number which appears more than once and 'missing' is the number that is missing in the list. n = len(nums) actual_sum = n * (n + 1) // 2 actual_sum_square = n * (n + 1) * (2 * n + 1) // 6 sum_nums = sum(nums) sum_square_nums = sum(x * x for x in nums) # x - y = sum_nums - actual_sum # x^2 - y^2 = sum_square_nums - actual_sum_square diff = sum_nums - actual_sum sum_sq_diff = sum_square_nums - actual_sum_square # x^2 - y^2 = (x - y)(x + y) # sum_sq_diff = diff * (x + y) total = sum_sq_diff // diff x = (diff + total) // 2 y = total - x return x, y"},{"question":"def can_transform(s: str, t: str) -> bool: Determines if string \`s\` can be transformed into string \`t\` by reversing any of its substrings any number of times. >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abc\\", \\"cba\\") True >>> can_transform(\\"aabbcc\\", \\"bbaacc\\") True >>> can_transform(\\"abcdef\\", \\"ghijkl\\") False >>> can_transform(\\"aabbcc\\", \\"aabbccc\\") False >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"a\\", \\"\\") False >>> can_transform(\\"\\", \\"a\\") False >>> can_transform(\\"a\\", \\"a\\") True >>> can_transform(\\"a\\", \\"b\\") False","solution":"def can_transform(s, t): Determines if string \`s\` can be transformed into string \`t\` by reversing any of its substrings any number of times. # The strings s and t can be transformed into each other iff they have the same sorted list of characters return sorted(s) == sorted(t)"},{"question":"def are_connected(personData: List[Dict[str, Any]], personA: str, personB: str) -> bool: Determines if there is a chain of friends connecting two given people, personA and personB. Two people are considered connected if you can start from personA and reach personB by following the \\"friends\\" links. >>> personData = [ >>> {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"friends\\": [\\"Bob\\"]}, >>> {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"friends\\": [\\"Alice\\", \\"Charlie\\"]}, >>> {\\"name\\": \\"Charlie\\", \\"age\\": 20, \\"friends\\": [\\"Bob\\"]} >>> ] >>> are_connected(personData, \\"Alice\\", \\"Bob\\") True >>> are_connected(personData, \\"Alice\\", \\"Charlie\\") True >>> personData = [ >>> {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"friends\\": [\\"Bob\\"]}, >>> {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"friends\\": [\\"Alice\\"]}, >>> {\\"name\\": \\"Charlie\\", \\"age\\": 20, \\"friends\\": []} >>> ] >>> are_connected(personData, \\"Alice\\", \\"Charlie\\") False >>> are_connected(personData, \\"Alice\\", \\"Alice\\") True >>> personData = [ >>> {\\"name\\": \\"A\\", \\"age\\": 30, \\"friends\\": [\\"B\\"]}, >>> {\\"name\\": \\"B\\", \\"age\\": 25, \\"friends\\": [\\"C\\"]}, >>> {\\"name\\": \\"C\\", \\"age\\": 20, \\"friends\\": [\\"D\\"]}, >>> {\\"name\\": \\"D\\", \\"age\\": 30, \\"friends\\": [\\"E\\"]}, >>> {\\"name\\": \\"E\\", \\"age\\": 25, \\"friends\\": [\\"F\\"]}, >>> {\\"name\\": \\"F\\", \\"age\\": 20, \\"friends\\": [\\"G\\"]}, >>> {\\"name\\": \\"G\\", \\"age\\": 30, \\"friends\\": [\\"H\\"]}, >>> {\\"name\\": \\"H\\", \\"age\\": 25, \\"friends\\": [\\"I\\"]}, >>> {\\"name\\": \\"I\\", \\"age\\": 20, \\"friends\\": [\\"J\\"]}, >>> {\\"name\\": \\"J\\", \\"age\\": 30, \\"friends\\": []} >>> ] >>> are_connected(personData, \\"A\\", \\"J\\") True >>> are_connected(personData, \\"J\\", \\"A\\") False","solution":"def are_connected(personData, personA, personB): Returns True if there is a chain of friends connecting personA and personB, else False. # Create a dictionary to map people's names to their friends lists data = {person['name']: person['friends'] for person in personData} # BFS to find if personB can be reached starting from personA from collections import deque visited = set() queue = deque([personA]) while queue: current_person = queue.popleft() if current_person == personB: return True if current_person not in visited: visited.add(current_person) if current_person in data: queue.extend(data[current_person]) return False"},{"question":"def max_consecutive_sum(numbers: List[int], k: int) -> int: Returns the maximum possible sum of k consecutive elements in the array. If the array has fewer than k elements, return 0. :param numbers: List[int] - List of integers representing scores. :param k: int - Number of consecutive elements to sum. :return: int - Maximum sum of k consecutive elements.","solution":"def max_consecutive_sum(numbers, k): Returns the maximum possible sum of k consecutive elements in the array. If the array has fewer than k elements, return 0. :param numbers: List[int] - List of integers representing scores. :param k: int - Number of consecutive elements to sum. :return: int - Maximum sum of k consecutive elements. n = len(numbers) if n < k: return 0 # Compute the sum of the first k elements. max_sum = current_sum = sum(numbers[:k]) # Iterate through the array starting from the k-th element. for i in range(k, n): # Sliding the window right, subtract the leftmost element and add the incoming element. current_sum += numbers[i] - numbers[i - k] # Update max_sum if the current_sum is greater. max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def canFormPalindrome(s: str) -> bool: Determines if string \`s\` can be rearranged to form a palindrome. >>> canFormPalindrome(\\"aabb\\") True >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"aabbccdde\\") True >>> canFormPalindrome(\\"abcde\\") False >>> canFormPalindrome(\\"abc\\") False >>> canFormPalindrome(\\"a\\") True >>> canFormPalindrome(\\"\\") True >>> canFormPalindrome(\\"aabbc\\") True >>> canFormPalindrome(\\"aaabbbb\\") True >>> canFormPalindrome(\\"abcdef\\") False >>> canFormPalindrome(\\"ab\\") False","solution":"def canFormPalindrome(s: str) -> bool: Returns True if the string \`s\` can be rearranged to form a palindrome, False otherwise. from collections import Counter count = Counter(s) odd_count = 0 for freq in count.values(): if freq % 2 != 0: odd_count += 1 # For a string to be rearranged into a palindrome: # At most one character count can be odd. return odd_count <= 1"},{"question":"def longest_palindrome(word: str) -> int: Given a string \`word\`, return the length of the longest palindrome that can be built with those characters. The characters are case-sensitive. >>> longest_palindrome(\\"aabbcc\\") == 6 >>> longest_palindrome(\\"aabbccc\\") == 7 >>> longest_palindrome(\\"AaBbCc\\") == 1 >>> longest_palindrome(\\"aaaaa\\") == 5 >>> longest_palindrome(\\"abcde\\") == 1 >>> longest_palindrome(\\"\\") == 0 >>> longest_palindrome(\\"abccccdd\\") == 7","solution":"def longest_palindrome(word): Given a string \`word\`, return the length of the longest palindrome that can be built with those characters. from collections import Counter char_count = Counter(word) length_of_palindrome = 0 odd_count_found = False for count in char_count.values(): if count % 2 == 0: length_of_palindrome += count else: length_of_palindrome += count - 1 odd_count_found = True if odd_count_found: length_of_palindrome += 1 return length_of_palindrome"},{"question":"def findLargestSquare(matrix): Write a function to find the area of the largest square containing only '1's in a binary matrix. Args: matrix: List[List[str]] -- A binary matrix containing '0's and '1's. Returns: int -- The area of the largest square containing only '1's. >>> matrix1 = [ ... ['1', '0', '1', '0', '0'], ... ['1', '0', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '0', '0', '1', '0'] ... ] >>> findLargestSquare(matrix1) 4 >>> matrix2 = [ ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'] ... ] >>> findLargestSquare(matrix2) 16 >>> matrix3 = [ ... ['0', '0', '0', '0'], ... ['0', '1', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ] >>> findLargestSquare(matrix3) 1 >>> matrix4 = [ ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ] >>> findLargestSquare(matrix4) 0 >>> matrix5 = [ ... ['1', '1', '1', '1', '0'], ... ['1', '1', '1', '1', '0'], ... ['1', '1', '1', '1', '0'], ... ['1', '1', '1', '1', '0'] ... ] >>> findLargestSquare(matrix5) 16 >>> matrix6 = [] >>> findLargestSquare(matrix6) 0 >>> matrix7 = [['1']] >>> findLargestSquare(matrix7) 1 >>> matrix8 = [['0']] >>> findLargestSquare(matrix8) 0","solution":"def findLargestSquare(matrix): if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_side = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i - 1][j - 1] == '1': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string \`s\` representing a DNA sequence, return the length of the longest substring that contains at most 2 distinct nucleotides. >>> length_of_longest_substring_two_distinct(\\"ACCA\\") == 4 >>> length_of_longest_substring_two_distinct(\\"\\") == 0 >>> length_of_longest_substring_two_distinct(\\"A\\") == 1 >>> length_of_longest_substring_two_distinct(\\"AAC\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ACGT\\") == 2 >>> length_of_longest_substring_two_distinct(\\"ACACCCGTGTTAAC\\") == 6","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: from collections import defaultdict left = 0 max_length = 0 char_count = defaultdict(int) for right, char in enumerate(s): char_count[char] += 1 while len(char_count) > 2: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def min_difference(arr: List[int]) -> int: Returns the minimum difference between the total times spent on two machines. >>> min_difference([1, 2, 3, 4, 5]) == 1 >>> min_difference([1, 2, 3, 9]) == 3 >>> min_difference([10]) == 10 >>> min_difference([3, 3, 3, 3]) == 0 >>> min_difference([1, 10, 15, 20, 5]) == 1 >>> min_difference([]) == 0 >>> min_difference([2, 3]) == 1","solution":"def min_difference(arr): Returns the minimum difference between the total times spent on two machines. total_sum = sum(arr) n = len(arr) # Use dynamic programming to solve the subset sum problem dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] # Initialize dp matrix for i in range(n + 1): dp[i][0] = True # Fill dp matrix for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find the maximum value of j such that dp[n][j] is True for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j"},{"question":"def reverseWords(s: str) -> str: Given a string of words separated by spaces, reverse the order of characters in each word while preserving the order of words and the spaces between them. For example, given the input \\"hello world\\", the output should be \\"olleh dlrow\\". Parameters: s (str): The input string Returns: str: The string with word characters reversed >>> reverseWords(\\"hello\\") == \\"olleh\\" >>> reverseWords(\\"hello world\\") == \\"olleh dlrow\\" >>> reverseWords(\\"a b c d\\") == \\"a b c d\\" >>> reverseWords(\\" hello world \\") == \\" olleh dlrow \\" >>> reverseWords(\\"hello!\\") == \\"!olleh\\" >>> reverseWords(\\"hello world!\\") == \\"olleh !dlrow\\" >>> reverseWords(\\"\\") == \\"\\" >>> reverseWords(\\"123 456\\") == \\"321 654\\"","solution":"def reverseWords(s): Reverses the order of characters in each word of the string while preserving the order of words and spaces. Parameters: s (str): The input string Returns: str: The string with word characters reversed # Split the input string by spaces words = s.split(' ') # Reverse the characters in each word reversed_words = [word[::-1] for word in words] # Join them back with spaces and return return ' '.join(reversed_words)"},{"question":"from typing import List def numDistinctIslands(grid: List[List[int]]) -> int: Determine the number of distinct islands in the given 2D grid. An island is defined as a group of connected cells where each cell in the group has at least one horizontally or vertically adjacent cell in the group. Two islands are considered to be the same if they can be translated to match each other. >>> numDistinctIslands([[1, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]]) 2 >>> numDistinctIslands([[1, 1, 0, 1, 1], [1, 0, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 0, 1], [1, 0, 0, 0, 1]]) 2 >>> numDistinctIslands([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> numDistinctIslands([[1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]]) 1","solution":"def numDistinctIslands(grid): def dfs(r, c, direction, shape): if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 1: grid[r][c] = 0 shape.append(direction) dfs(r + 1, c, 'd', shape) # move down dfs(r - 1, c, 'u', shape) # move up dfs(r, c + 1, 'r', shape) # move right dfs(r, c - 1, 'l', shape) # move left shape.append('b') # mark backtracking shapes = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: shape = [] dfs(r, c, 'o', shape) # origin shapes.add(tuple(shape)) return len(shapes)"},{"question":"def min_sessions(tasks: List[int], k: int) -> int: Determines the minimum number of sessions required to complete all tasks. >>> min_sessions([1, 2, 3], 3) 2 >>> min_sessions([3, 1, 3, 1, 1], 8) 2 >>> min_sessions([1, 2, 2, 3, 3], 5) 3 >>> min_sessions([5, 5, 5], 10) 2 >>> min_sessions([2, 4, 8, 2], 8) 2","solution":"def min_sessions(tasks, k): Determines the minimum number of sessions required to complete all tasks. n = len(tasks) # dp[mask] will be the min number of sessions required to finish the tasks denoted by mask dp = [float('inf')] * (1 << n) dp[0] = 0 # work[mask] keeps track of total work for tasks denoted by mask work = [0] * (1 << n) for mask in range(1 << n): for i in range(n): if mask & (1 << i): work[mask] += tasks[i] for mask in range(1 << n): submask = mask while submask: if work[submask] <= k: dp[mask] = min(dp[mask], dp[mask ^ submask] + 1) submask = (submask - 1) & mask return dp[(1 << n) - 1]"},{"question":"def has_special_subset(nums, k): Returns True if there exists a non-empty subset in nums whose sum is divisible by k, otherwise False. >>> has_special_subset([1, 2, 3], 7) == False >>> has_special_subset([4, 5, 6], 5) == True >>> has_special_subset([3, 1, 4, 2], 5) == True >>> has_special_subset([], 3) == False >>> has_special_subset([10, 20, 30], 10) == True >>> has_special_subset([1, 1, 1, 1], 100) == False >>> has_special_subset([5, 10, 15, 20], 5) == True","solution":"def has_special_subset(nums, k): Returns True if there exists a non-empty subset in nums whose sum is divisible by k, otherwise False. n = len(nums) # Use a set to keep track of all possible subset sums encountered possible_sums = set([0]) for num in nums: # Generate new possible sums by adding the current num to each existing sum in possible_sums new_sums = {num + s for s in possible_sums} possible_sums.update(new_sums) # Check if any of the new sums are divisible by k if any(s % k == 0 and s != 0 for s in new_sums): return True return False"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Returns True if there exists a pair of integers in the array whose sum is equal to the target value. Uses a set to achieve O(n) time complexity. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([1, 2, 2, 3, 4, 5], 4) True >>> has_pair_with_sum([-3, -2, -1, 0, 1, 2, 3], 0) True >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([], 1) False >>> has_pair_with_sum([1000000, 2000000, 3000000, 4000000, 5000000], 7000000) True # Implementation here","solution":"def has_pair_with_sum(arr, target): Returns True if there exists a pair of integers in the array whose sum is equal to the target value. Uses a set to achieve O(n) time complexity. seen_numbers = set() for num in arr: required_num = target - num if required_num in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"def count_palindromic_substrings(s: str) -> int: Given a string \`s\`, return the number of palindromic substrings in it. The substrings with different start indices or end indices are counted as different substrings even if they consist of the same characters. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the string \`s\`. n = len(s) count = 0 # A helper function to count palindromes centered at \`left\` and \`right\` def count_from_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for center in range(n): # Count odd-length palindromes (single character center) count_from_center(center, center) # Count even-length palindromes (two characters center) count_from_center(center, center + 1) return count"},{"question":"def find_max_temperature(temperatures: List[List[int]]) -> int: Returns the highest temperature recorded within the given grid of temperatures. :param temperatures: List of lists where temperatures[i][j] represents the temperature on the i-th day at the j-th time slot. :return: The highest temperature recorded. >>> find_max_temperature([ ... [30, 32, 34], ... [33, 35, 36], ... [31, 30, 32] ... ]) == 36 >>> find_max_temperature([ ... [25, 28, 29, 22, 30] ... ]) == 30 >>> find_max_temperature([ ... [25], ... [27], ... [29], ... [30] ... ]) == 30 >>> find_max_temperature([ ... [-10, -20, -30], ... [0, -5, -2], ... [-1, -3, -4] ... ]) == 0 >>> find_max_temperature([]) == None >>> find_max_temperature([ ... [], ... [], ... [] ... ]) == None","solution":"def find_max_temperature(temperatures): Returns the highest temperature recorded within the given grid of temperatures. :param temperatures: List of lists where temperatures[i][j] represents the temperature on the i-th day at the j-th time slot. :return: The highest temperature recorded. if not temperatures or not temperatures[0]: return None max_temp = float('-inf') for day in temperatures: for temp in day: if temp > max_temp: max_temp = temp return max_temp"},{"question":"from typing import List, Tuple def min_time_to_finish_tasks(tasks: List[int], dependencies: List[Tuple[int, int]]) -> int: Determine the minimum time required to finish all tasks given their dependencies. Args: tasks: List of integers where tasks[i] represents the duration of the task. dependencies: List of tuple pairs where dependencies[i] = [a, b] indicates that task \`a\` must be completed before task \`b\` can be started. Returns: The minimum time required to finish all tasks. Test Cases: >>> min_time_to_finish_tasks([3, 2, 5], [(0, 1), (1, 2)]) == 10 >>> min_time_to_finish_tasks([1, 2, 3], []) == 3 >>> min_time_to_finish_tasks([5], []) == 5 >>> min_time_to_finish_tasks([1, 2, 1, 4], [(0, 1), (1, 2), (0, 2), (2, 3)]) == 8 >>> min_time_to_finish_tasks([3, 1], [(0, 1)]) == 4 >>> min_time_to_finish_tasks([3, 5, 7], [(0, 1), (0, 2)]) == 10 pass","solution":"def min_time_to_finish_tasks(tasks, dependencies): from collections import defaultdict, deque # Build the graph and calculate in-degree graph = defaultdict(list) in_degree = defaultdict(int) for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Find tasks with no dependencies zero_in_degree_queue = deque() for task in range(len(tasks)): if in_degree[task] == 0: zero_in_degree_queue.append(task) # Initialize minimum time required for each task task_time = [0] * len(tasks) while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() # Calculate completion time for tasks dependent on current_task for neighbor in graph[current_task]: task_time[neighbor] = max(task_time[neighbor], task_time[current_task] + tasks[current_task]) in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # The final completion time for each task for i in range(len(tasks)): task_time[i] += tasks[i] return max(task_time)"},{"question":"def min_distance(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s to string t. The allowed operations are insert, delete, and replace a character. >>> min_distance(\\"abc\\", \\"abc\\") 0 >>> min_distance(\\"abc\\", \\"def\\") 3 >>> min_distance(\\"abc\\", \\"abcd\\") 1 >>> min_distance(\\"abcdef\\", \\"abc\\") 3 >>> min_distance(\\"abcdef\\", \\"abcfgh\\") 3 >>> min_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5 >>> min_distance(\\"\\", \\"test\\") 4 >>> min_distance(\\"test\\", \\"\\") 4","solution":"def min_distance(s, t): Returns the minimum number of operations required to convert string s to string t. The allowed operations are insert, delete, and replace a character. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Need to insert all characters of t elif j == 0: dp[i][j] = i # Need to delete all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"def min_length_of_binary_string(s: str) -> int: Returns the length of the smallest possible string that can be obtained by repeatedly deleting \\"01\\" or \\"10\\" from the given binary string. >>> min_length_of_binary_string(\\"110100\\") == 0 >>> min_length_of_binary_string(\\"111\\") == 3 >>> min_length_of_binary_string(\\"000\\") == 3 >>> min_length_of_binary_string(\\"\\") == 0 >>> min_length_of_binary_string(\\"000111\\") == 0 >>> min_length_of_binary_string(\\"0101\\") == 0 >>> min_length_of_binary_string(\\"1001\\") == 0 >>> min_length_of_binary_string(\\"1110001\\") == 1 >>> min_length_of_binary_string(\\"1\\") == 1 >>> min_length_of_binary_string(\\"0\\") == 1","solution":"def min_length_of_binary_string(s): Returns the length of the smallest possible string that can be obtained by repeatedly deleting \\"01\\" or \\"10\\". return abs(s.count('0') - s.count('1'))"},{"question":"def max_sum_subarray_with_one_removal(arr: List[int]) -> int: Given an array of integers, find the maximum possible sum of a non-empty subarray, with at most one element being removed. A subarray is a contiguous part of an array. Note that you may not remove more than one element, and you may choose not to remove any elements at all. >>> max_sum_subarray_with_one_removal([1, 2, 3, 4]) == 10 >>> max_sum_subarray_with_one_removal([-1, -2, -3, -4]) == -1 >>> max_sum_subarray_with_one_removal([1, -2, 3, -4, 5]) == 8 >>> max_sum_subarray_with_one_removal([1, 2, -5, 4, 3]) == 10 >>> max_sum_subarray_with_one_removal([5]) == 5 >>> max_sum_subarray_with_one_removal([-1, 2]) == 2 >>> max_sum_subarray_with_one_removal([2, -1]) == 2 >>> max_sum_subarray_with_one_removal([1, 2, 3, -6, 4, 5, 6]) == 21","solution":"def max_sum_subarray_with_one_removal(arr): Finds the maximum possible sum of a non-empty subarray, with at most one element being removed. :param arr: List of integers :return: Integer representing the maximum sum achievable n = len(arr) if n == 0: return 0 # Arrays to store max sum subarray ending at each index max_ending_here = [0] * n max_starting_here = [0] * n # Forward pass: calculate max subarray sum ending at each index max_ending_here[0] = arr[0] for i in range(1, n): max_ending_here[i] = max(arr[i], max_ending_here[i-1] + arr[i]) # Backward pass: calculate max subarray sum starting at each index max_starting_here[-1] = arr[-1] for i in range(n-2, -1, -1): max_starting_here[i] = max(arr[i], max_starting_here[i+1] + arr[i]) # Calculate max sum of subarray with at most one element removed max_sum = max(max_ending_here) # This considers the case where no element is removed for i in range(1, n-1): max_sum = max(max_sum, max_ending_here[i-1] + max_starting_here[i+1]) return max_sum"},{"question":"def min_work_sessions(jobs: List[int], T: int) -> int: This function calculates the minimum number of work sessions required to complete all jobs given that each session can't exceed T hours and the worker needs at least one hour of rest after each session. :param jobs: List of integers, where jobs[i] is the time to complete the i-th job. :param T: Maximum continuous work session time. :return: Minimum number of work sessions required. >>> min_work_sessions([2], 2) 1 >>> min_work_sessions([1], 2) 1 >>> min_work_sessions([1, 2, 3], 6) 1 >>> min_work_sessions([3, 3, 2], 8) 1 >>> min_work_sessions([3, 3, 2], 5) 2 >>> min_work_sessions([6, 2, 3, 2], 7) 2 >>> min_work_sessions([2, 2, 2, 2], 4) 2 >>> min_work_sessions([3, 3, 3], 3) 3 >>> min_work_sessions([4, 4, 6, 2], 6) 3 >>> min_work_sessions([5, 5, 1, 1, 1], 5) 3 >>> min_work_sessions([1] * 100, 10) 10 >>> min_work_sessions([10] * 10, 10) 10 pass","solution":"def min_work_sessions(jobs, T): This function calculates the minimum number of work sessions required to complete all jobs given that each session can't exceed T hours and the worker needs at least one hour of rest after each session. :param jobs: List of integers, where jobs[i] is the time to complete the i-th job. :param T: Maximum continuous work session time. :return: Minimum number of work sessions required. # Sorting jobs in descending order to schedule longest jobs first jobs.sort(reverse=True) sessions = 0 while jobs: current_time = 0 temp_jobs = [] for job in jobs: if current_time + job <= T: current_time += job else: temp_jobs.append(job) jobs = temp_jobs sessions += 1 return sessions"},{"question":"def valid_path(n: int, edges: List[List[int]], start: int, end: int) -> bool: Determines if there is a valid path from start to end in an undirected graph. :param n: Integer, number of nodes :param edges: List of edges in the graph :param start: Starting node :param end: Target node :return: Boolean, True if a valid path exists, False otherwise >>> valid_path(3, [[0, 1], [1, 2], [2, 0]], 0, 2) True >>> valid_path(6, [[0, 1], [0, 2], [3, 5], [5, 4], [4, 3]], 0, 5) False >>> valid_path(5, [[0, 1], [1, 2], [2, 3], [3, 4]], 0, 4) True >>> valid_path(3, [[0, 1]], 0, 2) False >>> valid_path(1, [], 0, 0) True >>> edges = [[i, i + 1] for i in range(9999)] >>> valid_path(10000, edges, 0, 9999) True","solution":"def valid_path(n, edges, start, end): Determines if there is a valid path from start to end in an undirected graph. :param n: Integer, number of nodes :param edges: List of edges in the graph :param start: Starting node :param end: Target node :return: Boolean, True if a valid path exists, False otherwise from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) # Perform BFS queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Calculate the number of unique paths in a grid with obstacles from the top-left corner to the bottom-right corner. >>> uniquePathsWithObstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> uniquePathsWithObstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> uniquePathsWithObstacles([[0, 1], [1, 0]]) 0 >>> uniquePathsWithObstacles([[0], [0], [1], [0]]) 0 >>> uniquePathsWithObstacles([[0], [0], [0], [0]]) 1 >>> uniquePathsWithObstacles([[0]]) 1 >>> uniquePathsWithObstacles([[1]]) 0","solution":"from typing import List def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = 1 # Start position # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if obstacleGrid[i][0] == 0 else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if obstacleGrid[0][j] == 0 else 0 # Fill the rest of the grid for i in range(1, m): for j in range(1, n): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"def max_subarray_sum(nums): Given an array of integers \`nums\`, returns the maximum sum of a contiguous subarray within the array (\`nums\`) that contains at least one element. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([3, -2, 5, -1]) == 6 >>> max_subarray_sum([-1, -2, 10, -1, 10, -1, 10, -1, -2]) == 28 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(nums): This function returns the maximum sum of a contiguous subarray within the input array \`nums\`. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def countVisibleStudents(heights: List[int]) -> int: Returns the number of students who can see the stage. A student can see the stage if there are no taller students directly in front of them in the line. >>> countVisibleStudents([150, 160, 170, 180]) == 4 >>> countVisibleStudents([180, 170, 160, 150]) == 1 >>> countVisibleStudents([150, 180, 150, 200, 170]) == 3 >>> countVisibleStudents([170]) == 1 >>> countVisibleStudents([]) == 0 pass","solution":"def countVisibleStudents(heights): Returns the number of students who can see the stage. A student can see the stage if there are no taller students directly in front of them in the line. max_height = 0 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def find_peak_2d(matrix): You are given a **0-indexed** 2D integer array \`matrix\` of dimensions \`m x n\`. Each element in the matrix represents a height at that position. A peak element is an element that is strictly greater than its neighbors. Return the coordinates \`[x, y]\` of any peak element found in the matrix. Neighbors of an element at position \`[i, j]\` are the elements \`[i-1, j]\`, \`[i+1, j]\`, \`[i, j-1]\`, and \`[i, j+1]\` if they exist within the boundaries of the matrix. The result should be returned as a list of two integers \`[x, y]\`. If there are multiple peak elements, you may return any of them. >>> find_peak_2d([ [1, 4, 3], [6, 5, 2], [7, 8, 9] ]) in [[0, 1], [2, 2]] >>> find_peak_2d([ [1, 3, 5, 4, 2] ]) in [[0, 2]] >>> find_peak_2d([ [1], [3], [5], [4], [2] ]) in [[2, 0]] >>> find_peak_2d([ [10, 20, 15], [21, 30, 14], [7, 16, 32] ]) in [[1, 1], [2, 2]] >>> find_peak_2d([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) is None # This is a theoretical case as per problem constraints there should be at least one peak","solution":"def find_peak_2d(matrix): def is_peak(x, y): curr = matrix[x][y] if x > 0 and matrix[x-1][y] >= curr: return False if x < len(matrix) - 1 and matrix[x+1][y] >= curr: return False if y > 0 and matrix[x][y-1] >= curr: return False if y < len(matrix[0]) - 1 and matrix[x][y+1] >= curr: return False return True for i in range(len(matrix)): for j in range(len(matrix[0])): if is_peak(i, j): return [i, j] return None # In case there are no peaks which should not be possible with given problem constraints."},{"question":"from typing import List def shortest_path_binary_matrix(grid: List[List[int]]) -> int: Finds the length of the shortest clear path in a binary matrix grid. :param grid: List[List[int]] - binary matrix :return: int - length of the shortest clear path or -1 if no clear path exists You can move up, down, left, or right from an empty cell to another empty cell. Examples: >>> shortest_path_binary_matrix([[1, 0, 0], [1, 1, 0], [1, 0, 0]]) -1 >>> shortest_path_binary_matrix([[0, 0, 0], [1, 1, 0], [1, 1, 0]]) 5 >>> shortest_path_binary_matrix([[0]]) 1 >>> shortest_path_binary_matrix([[0, 0, 0, 0]]) 4 >>> shortest_path_binary_matrix([[0], [0], [0], [0]]) 4 >>> shortest_path_binary_matrix([[0, 1], [1, 0]]) -1 >>> shortest_path_binary_matrix([[1, 0], [0, 0]]) -1 >>> shortest_path_binary_matrix([[0, 0], [0, 1]]) -1","solution":"from collections import deque def shortest_path_binary_matrix(grid): Finds the length of the shortest clear path in a binary matrix grid. :param grid: List[List[int]] - binary matrix :return: int - length of the shortest clear path or -1 if no clear path exists if not grid or grid[0][0] != 0 or grid[-1][-1] != 0: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # four possible movements queue = deque([(0, 0, 1)]) # (row, col, path_length) visited = set((0, 0)) while queue: row, col, path_length = queue.popleft() if row == m - 1 and col == n - 1: return path_length for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and grid[r][c] == 0 and (r, c) not in visited: queue.append((r, c, path_length + 1)) visited.add((r, c)) return -1"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers \`nums\` sorted in non-decreasing order and an integer \`target\`, returns the indices of the two numbers such that they add up to \`target\`. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 7) [2, 3] >>> two_sum([-4, 1, 3, 5, 6], 1) [0, 3] >>> two_sum([3, 3, 4, 5], 6) [0, 1] >>> two_sum([1, 3, 6, 8, 10], 16) [2, 4]","solution":"def two_sum(nums, target): Given an array of integers \`nums\` sorted in non-decreasing order and an integer \`target\`, returns the indices of the two numbers such that they add up to \`target\`. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return None # As per the problem statement, there is always exactly one solution."},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Find the minimum sum path from the top-left to the bottom-right of the matrix. Args: grid (List[List[int]]): n x n grid of integers representing the obstacles. Returns: int: The minimum sum of obstacles along the path. Examples: >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [5] ... ]) 5 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) 3 >>> min_path_sum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 >>> min_path_sum([ ... [1, 99, 99], ... [1, 99, 1], ... [1, 1, 1] ... ]) 5 >>> min_path_sum([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 pass","solution":"def min_path_sum(grid): Find the minimum sum path from the top-left to the bottom-right of the matrix. n = len(grid) if n == 0: return 0 # Initialize the dp table dp = [[0] * n for _ in range(n)] # Set the value for the starting cell (0, 0) dp[0][0] = grid[0][0] # Initialize first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"def has_two_sum(nums: List[int], target: int) -> bool: Determine if there exists a pair of elements in a sorted array whose sum is equal to target. >>> has_two_sum([1, 2, 3, 4, 5], 9) True >>> has_two_sum([1, 2, 3, 4, 5], 10) False >>> has_two_sum([2, 2, 2, 2], 4) True","solution":"def has_two_sum(nums, target): Returns True if there exists two elements in a sorted array nums that sum to the target. Otherwise, returns False. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"class Vector2D: Class to represent a 2D vector iterator. >>> iterator = Vector2D([[1, 2], [3], [4]]) >>> iterator.next() 1 >>> iterator.next() 2 >>> iterator.hasNext() True >>> iterator.next() 3 >>> iterator.hasNext() True >>> iterator.next() 4 >>> iterator.hasNext() False >>> iterator2 = Vector2D([[], [1], [2, 3], []]) >>> iterator2.next() 1 >>> iterator2.hasNext() True >>> iterator2.next() 2 >>> iterator2.next() 3 >>> iterator2.hasNext() False >>> iterator3 = Vector2D([[]]) >>> iterator3.hasNext() False >>> iterator4 = Vector2D([[1]]) >>> iterator4.next() 1 >>> iterator4.hasNext() False def __init__(self, vec: List[List[int]]): Initialize your data structure here. def next(self) -> int: Return the next element in the 2D vector. def hasNext(self) -> bool: Return true if there are more elements in the 2D vector.","solution":"class Vector2D: def __init__(self, vec): self.vec = vec self.row = 0 self.col = 0 self.advance_to_next() def advance_to_next(self): while self.row < len(self.vec) and self.col >= len(self.vec[self.row]): self.row += 1 self.col = 0 def next(self): if not self.hasNext(): raise Exception(\\"No more elements\\") result = self.vec[self.row][self.col] self.col += 1 self.advance_to_next() return result def hasNext(self): self.advance_to_next() return self.row < len(self.vec)"},{"question":"from typing import List def least_interval(tasks: List[int], n: int) -> int: Returns the least number of units times that the CPU will take to finish all the given tasks with a cooling period of \`n\` between the same tasks. >>> least_interval([1, 1, 2, 1], 2) 7 >>> least_interval([1, 1, 2, 1], 0) 4 >>> least_interval([1], 2) 1 >>> least_interval([1, 2, 3], 2) 3 >>> least_interval([1, 1, 1, 1], 2) 10 >>> least_interval([1, 2, 3, 1, 2, 3], 3) 7","solution":"from collections import Counter def least_interval(tasks, n): Returns the least number of units times that the CPU will take to finish all the given tasks with a cooling period of \`n\` between the same tasks. task_counts = Counter(tasks) max_count = max(task_counts.values()) # Find the number of tasks that have the maximum count max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) # The part without the remainder tasks part_length = max_count - 1 empty_slots = part_length * (n - (max_count_tasks - 1)) available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"def distribute_weights(weights, k): Distribute the items into k containers such that the weight of items in each container is as balanced as possible. Args: weights (List[int]): The list of weights for the items. k (int): The number of containers. Returns: int: The maximum weight of the heaviest container after distribution. Example: >>> distribute_weights([1, 2, 3, 4, 5], 2) 9 >>> distribute_weights([7, 2, 5, 10, 8], 1) 32 pass from solution import distribute_weights def test_example_case(): weights = [1, 2, 3, 4, 5] k = 2 assert distribute_weights(weights, k) == 9 def test_single_container(): weights = [7, 2, 5, 10, 8] k = 1 assert distribute_weights(weights, k) == 32 def test_equal_distribution(): weights = [1, 2, 3, 4, 5] k = 5 assert distribute_weights(weights, k) == 5 def test_more_containers_than_items(): weights = [1, 2, 3, 4, 5] k = 10 assert distribute_weights(weights, k) == 5 # Since we can't have more containers than items effectively def test_small_weights_more_containers(): weights = [1, 1, 1, 1, 1] k = 2 assert distribute_weights(weights, k) == 3 def test_large_k_small_array(): weights = [10, 10, 10] k = 2 assert distribute_weights(weights, k) == 20","solution":"def distribute_weights(weights, k): def can_distribute(max_weight): current_weight = 0 containers_used = 1 for weight in weights: if current_weight + weight > max_weight: containers_used += 1 current_weight = weight if containers_used > k: return False else: current_weight += weight return True left, right = max(weights), sum(weights) while left < right: mid = (left + right) // 2 if can_distribute(mid): right = mid else: left = mid + 1 return left"},{"question":"def max_absolute_subarray_sum(nums: List[int]) -> int: Returns the maximum absolute sum of any subarray of nums. >>> max_absolute_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_absolute_subarray_sum([-1, -2, -3, -4, -5]) == 15 >>> max_absolute_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_absolute_subarray_sum([5]) == 5 >>> max_absolute_subarray_sum([-5]) == 5 >>> max_absolute_subarray_sum([0, 0, -1, -2, -3]) == 6 >>> max_absolute_subarray_sum([0, 0, 1, 2, 3]) == 6","solution":"def max_absolute_subarray_sum(nums): Returns the maximum absolute sum of any subarray of nums. max_ending_here, max_so_far = 0, 0 min_ending_here, min_so_far = 0, 0 for num in nums: max_ending_here = max(0, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) min_ending_here = min(0, min_ending_here + num) min_so_far = min(min_so_far, min_ending_here) return max(max_so_far, abs(min_so_far))"},{"question":"def hasCycle(graph: List[List[int]]) -> bool: Determines if the graph contains a cycle. Parameters: graph (List[List[int]]): The adjacency list of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. >>> hasCycle([[1, 2], [0, 3], [0], [1]]) False >>> hasCycle([[1], [0, 2], [1, 3], [2, 1]]) True >>> hasCycle([[], [2], [1, 3], [2], [5], [4]]) False >>> hasCycle([[], [2], [1, 3], [2, 1], [5], [4]]) True >>> hasCycle([[1, 2], [0, 2], [0, 1], [4, 5], [3, 5], [3, 4], [], [8], [7, 9], [8], [11], [10, 12], [11, 13], [12, 10]]) True >>> hasCycle([[]]) False >>> hasCycle([[1], [0]]) False >>> hasCycle([[1], [0, 2], [1, 0]]) True","solution":"def hasCycle(graph): Determines if the graph contains a cycle. Parameters: graph (List[List[int]]): The adjacency list of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(node, parent): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: # If the neighbor has not been visited, recur on it if dfs(neighbor, node): return True elif neighbor != parent: # If an adjacent is visited and not the parent of the current vertex, then there is a cycle return True return False visited = [False] * len(graph) # Call the recursive helper function to detect cycle in different DFS trees for node in range(len(graph)): if not visited[node]: # Don't recur for \`node\` if it is already visited if dfs(node, -1): # If a cycle is found return True return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root, p, q): Returns the value of the lowest common ancestor of nodes p and q. :param root: TreeNode, the root of the binary search tree :param p: int, value of the first node :param q: int, value of the second node :return: int, value of the lowest common ancestor from solution import TreeNode, lowestCommonAncestor def test_lowestCommonAncestor(): # Tree structure: # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) root.right.left = TreeNode(7) root.right.right = TreeNode(9) assert lowestCommonAncestor(root, 2, 8) == 6 assert lowestCommonAncestor(root, 2, 4) == 2 assert lowestCommonAncestor(root, 3, 5) == 4 assert lowestCommonAncestor(root, 0, 5) == 2 assert lowestCommonAncestor(root, 7, 9) == 8 assert lowestCommonAncestor(root, 6, 9) == 6 def test_lowestCommonAncestor_with_same_node(): # Tree structure: # 6 # / # 2 8 root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) assert lowestCommonAncestor(root, 6, 6) == 6 assert lowestCommonAncestor(root, 2, 2) == 2 assert lowestCommonAncestor(root, 8, 8) == 8 def test_lowestCommonAncestor_with_root_as_lca(): # Tree structure: # 6 # / # 2 8 root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) assert lowestCommonAncestor(root, 2, 8) == 6 assert lowestCommonAncestor(root, 2, 6) == 6 assert lowestCommonAncestor(root, 8, 6) == 6","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root, p, q): Returns the value of the lowest common ancestor of nodes p and q. :param root: TreeNode, the root of the binary search tree :param p: int, value of the first node :param q: int, value of the second node :return: int, value of the lowest common ancestor while root: if p < root.val and q < root.val: root = root.left elif p > root.val and q > root.val: root = root.right else: return root.val"},{"question":"def max_histogram_area(heights: List[int]) -> int: Returns the maximum rectangular area in a histogram represented by heights array. >>> max_histogram_area([4]) == 4 >>> max_histogram_area([2, 2, 2, 2]) == 8 >>> max_histogram_area([1, 2, 3, 4, 5]) == 9 >>> max_histogram_area([5, 4, 3, 2, 1]) == 9 >>> max_histogram_area([2, 1, 5, 6, 2, 3]) == 10 >>> max_histogram_area([2, 4, 2, 4, 2, 4]) == 12 pass","solution":"def max_histogram_area(heights): Returns the maximum rectangular area in a histogram represented by heights array. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def min_words_to_form_target(words: List[str], target: str) -> int: Returns the minimum number of words required to form the target string, or -1 if it is not possible. >>> min_words_to_form_target(['a', 'b', 'ab'], 'abab') == 2 >>> min_words_to_form_target(['ab', 'bab'], 'ababab') == 3 >>> min_words_to_form_target(['a', 'b', 'ab'], 'abc') == -1 >>> min_words_to_form_target(['abc'], 'abc') == 1 >>> min_words_to_form_target(['a', 'aa', 'aaa'], 'aaaaa') == 2 >>> min_words_to_form_target(['a', 'b', 'ab'], '') == -1 >>> min_words_to_form_target(['a', 'b', 'c'], 'abcd') == -1","solution":"def min_words_to_form_target(words, target): Returns the minimum number of words required to form the target string, or -1 if it is not possible. from collections import deque, defaultdict # Initialize queue for BFS and a dictionary to store the minimum operations queue = deque([(target, 0)]) visited = set([target]) while queue: current, steps = queue.popleft() for word in words: if current.startswith(word): new_target = current[len(word):] if new_target == '': # Whole target can be constructed return steps + 1 if new_target not in visited: visited.add(new_target) queue.append((new_target, steps + 1)) return -1"},{"question":"from typing import List def count_visible_buildings(buildings: List[int]) -> int: Returns the number of visible buildings from left to right in the array. >>> count_visible_buildings([5, 5, 5, 5, 5]) 1 >>> count_visible_buildings([1, 2, 3, 4, 5]) 1 >>> count_visible_buildings([5, 4, 3, 2, 1]) 5 >>> count_visible_buildings([1, 3, 2, 5, 4, 6]) 1 >>> count_visible_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_visible_buildings([10]) 1 >>> count_visible_buildings([]) 0","solution":"def count_visible_buildings(buildings): Returns the number of visible buildings from left to right in the array. if not buildings: return 0 max_height = buildings[-1] count_visible = 1 # The last building is always visible for i in range(len(buildings) - 2, -1, -1): if buildings[i] > max_height: count_visible += 1 max_height = buildings[i] return count_visible"},{"question":"def tallest_tower_height(arr: List[int]) -> int: Given an array of integers representing the heights of blocks, returns the height of the tallest tower that can be formed by stacking blocks of the same height. >>> tallest_tower_height([1, 1, 1, 1, 1]) == 5 >>> tallest_tower_height([1, 2, 2, 3, 3, 3]) == 3 >>> tallest_tower_height([]) == 0 >>> tallest_tower_height([1, 2, 3, 4, 5]) == 1 >>> tallest_tower_height([3, 27 Oct 19 13:46 Disk2 -rw-rw-r-- 1 1000 1000 4096 Mar 2 2024 File1 # Command: ls -lt # The output of the command is given above. Extract the filenames from this output and return them in a list. def extract_filenames_from_ls(output: str) -> List[str]: Extract filenames from the output of the \`ls -lt\` command. Args: output (str): A string containing the output of the \`ls -lt\` command. Returns: List[str]: A list of filenames extracted from the output. Example: >>> output = ''' ... -rw-rw-r-- 1 1000 1000 4096 Mar 2 2024 File1 ... drwxrwxr-x 2 1000 1000 4096 Feb 27 13:46 Disk2 ... drwxrwxr-x 11 1000 1000 4096 Feb 27 13:45 Disk1 ... drwxrwxr-x 4 1000 1000 4096 Feb 27 13:44 Disk0 ... ''' >>> extract_filenames_from_ls(output) ['File1', 'Disk2', 'Disk1', 'Disk0']","solution":"def tallest_tower_height(arr): Given an array of integers representing the heights of blocks, returns the height of the tallest tower that can be formed by stacking blocks of the same height. if not arr: return 0 height_counts = {} for height in arr: if height in height_counts: height_counts[height] += 1 else: height_counts[height] = 1 return max(height_counts.values())"},{"question":"def find_the_difference(s: str, t: str) -> str: Finds the additional character in t that is not in s. >>> find_the_difference(\\"abcd\\", \\"abcde\\") \\"e\\" >>> find_the_difference(\\"abc\\", \\"abxc\\") \\"x\\" >>> find_the_difference(\\"aabb\\", \\"aabbc\\") \\"c\\" >>> find_the_difference(\\"aabb\\", \\"ababb\\") \\"b\\" >>> find_the_difference(\\"xyz\\", \\"xyzt\\") \\"t\\"","solution":"def find_the_difference(s, t): Finds the additional character in t that is not in s. count_s = {} count_t = {} # Count characters in s for char in s: if char in count_s: count_s[char] += 1 else: count_s[char] = 1 # Count characters in t for char in t: if char in count_t: count_t[char] += 1 else: count_t[char] = 1 # Find the different character for char in count_t: if char not in count_s or count_t[char] > count_s[char]: return char"},{"question":"def isAlienSorted(words: List[str], order: str) -> bool: Determine if the given list of words is sorted lexicographically in an alien language. >>> isAlienSorted([\\"hello\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") True >>> isAlienSorted([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") False >>> isAlienSorted([\\"apple\\", \\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") False >>> isAlienSorted([\\"hello\\", \\"hello\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> isAlienSorted([\\"apple\\", \\"apricot\\", \\"banana\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> isAlienSorted([\\"apple\\", \\"apple\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> isAlienSorted([\\"apple\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> isAlienSorted([\\"abcd\\", \\"abce\\", \\"abcf\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") False","solution":"def isAlienSorted(words, order): Returns True if words are sorted lexicographically according to the alien language order, otherwise False. order_index = {char: index for index, char in enumerate(order)} def is_sorted(word1, word2): for char1, char2 in zip(word1, word2): if order_index[char1] < order_index[char2]: return True elif order_index[char1] > order_index[char2]: return False return len(word1) <= len(word2) for i in range(len(words) - 1): if not is_sorted(words[i], words[i + 1]): return False return True"},{"question":"def max_consecutive_free_slots(calendar: str) -> int: Determine the maximum number of consecutive free time slots in a calendar. Args: calendar (str): A string where 'X' represents busy and other characters represent free slots. Returns: int: The length of the longest span of consecutive free time slots. >>> max_consecutive_free_slots(\\"XOXOXOXOXO\\") == 1 >>> max_consecutive_free_slots(\\"OOOOOOOOOO\\") == 10 >>> max_consecutive_free_slots(\\"XXXXXXXXXX\\") == 0 >>> max_consecutive_free_slots(\\"XXOOXXXOOXXOOOOXX\\") == 4 >>> max_consecutive_free_slots(\\"XXXXXXXOOOOOO\\") == 6 >>> max_consecutive_free_slots(\\"OOOOOOXXXXXXX\\") == 6","solution":"def max_consecutive_free_slots(calendar): Determine the maximum number of consecutive free time slots in a calendar. Args: calendar (str): A string where 'X' represents busy and other characters represent free slots. Returns: int: The length of the longest span of consecutive free time slots. max_free_slots = 0 current_free_slots = 0 for slot in calendar: if slot == 'X': current_free_slots = 0 else: current_free_slots += 1 max_free_slots = max(max_free_slots, current_free_slots) return max_free_slots"},{"question":"def can_form_subsequence(s: str, t: str) -> bool: Checks if it is possible to form string t using characters from string s. >>> can_form_subsequence(\\"abccba\\", \\"abc\\") True >>> can_form_subsequence(\\"abccba\\", \\"abb\\") True >>> can_form_subsequence(\\"abccba\\", \\"abcd\\") False","solution":"from collections import Counter def can_form_subsequence(s, t): Checks if it is possible to form string t using characters from string s. s_counter = Counter(s) t_counter = Counter(t) for char, count in t_counter.items(): if s_counter[char] < count: return False return True"},{"question":"def sort_students_by_score(names, scores): Sorts the students' names by their scores in descending order. If two students have the same score, their names are sorted alphabetically. :param names: List of student names. :param scores: List of corresponding scores. :return: List of names sorted by scores in descending order. from solution import sort_students_by_score def test_sort_students_by_score(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] scores = [85, 92, 85] assert sort_students_by_score(names, scores) == [\\"Bob\\", \\"Alice\\", \\"Charlie\\"] def test_sort_students_by_score_with_same_names(): names = [\\"Alice\\", \\"Bob\\", \\"Athena\\"] scores = [85, 92, 85] assert sort_students_by_score(names, scores) == [\\"Bob\\", \\"Alice\\", \\"Athena\\"] def test_sort_students_by_score_with_all_same_scores(): names = [\\"Charlie\\", \\"Alice\\", \\"Bob\\"] scores = [85, 85, 85] assert sort_students_by_score(names, scores) == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_sort_students_by_score_with_single_entry(): names = [\\"Alice\\"] scores = [85] assert sort_students_by_score(names, scores) == [\\"Alice\\"] def test_sort_students_by_score_with_empty_lists(): names = [] scores = [] assert sort_students_by_score(names, scores) == []","solution":"def sort_students_by_score(names, scores): Sorts the students' names by their scores in descending order. If two students have the same score, their names are sorted alphabetically. :param names: List of student names. :param scores: List of corresponding scores. :return: List of names sorted by scores in descending order. # Combining names and scores into a list of tuples combined = list(zip(names, scores)) # Sorting primarily by score descending, and secondarily by name ascending combined_sorted = sorted(combined, key=lambda x: (-x[1], x[0])) # Extracting the sorted names sorted_names = [name for name, score in combined_sorted] return sorted_names"},{"question":"def can_convert_to_palindrome(s: str, k: int) -> bool: Returns True if it's possible to convert string s into a palindrome using up to k reverse operations, otherwise returns False. >>> can_convert_to_palindrome(\\"abca\\", 1) True >>> can_convert_to_palindrome(\\"abcde\\", 1) False >>> can_convert_to_palindrome(\\"racecar\\", 0) True >>> can_convert_to_palindrome(\\"abccba\\", 2) True >>> can_convert_to_palindrome(\\"abcdef\\", 2) False >>> can_convert_to_palindrome(\\"aaabbb\\", 3) True >>> can_convert_to_palindrome(\\"abca\\", 2) True >>> can_convert_to_palindrome(\\"a\\", 0) True >>> can_convert_to_palindrome(\\"a\\", 1) True","solution":"def can_convert_to_palindrome(s, k): Returns True if it's possible to convert string s into a palindrome using up to k reverse operations, otherwise returns False. n = len(s) mismatch_count = 0 # Calculate the number of mismatched character pairs for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 # Each mismatch requires at least one reverse operation to correct return mismatch_count <= k"},{"question":"def min_workers(tasks: List[int], n: int) -> int: Returns the minimum number of workers required to complete all tasks such that no worker has more than \`n\` amount of work. Parameters: tasks (list): List of integers representing the time required for each task. n (int): Maximum time limit for any worker. Returns: int: Minimum number of workers required. >>> min_workers([4, 3, 2, 8, 4, 2], 10) == 3 >>> min_workers([5, 5, 5, 5], 10) == 2 >>> min_workers([1, 2, 3, 4], 4) == 3 >>> min_workers([9, 8, 7, 6, 5, 4, 3, 2, 1], 15) == 3 >>> min_workers([], 5) == 0 >>> min_workers([1, 1, 1, 1, 1, 1], 1) == 6","solution":"def min_workers(tasks, n): Returns the minimum number of workers required to complete all tasks such that no worker has more than \`n\` amount of work. Parameters: tasks (list): List of integers representing the time required for each task. n (int): Maximum time limit for any worker. Returns: int: Minimum number of workers required. from collections import defaultdict # Base case if not tasks: return 0 # Sort the tasks in descending order tasks.sort(reverse=True) # List to store the time allocation for each worker workers = [] # Assign tasks to workers for task in tasks: placed = False for i in range(len(workers)): if workers[i] + task <= n: workers[i] += task placed = True break if not placed: # Need a new worker for this task workers.append(task) return len(workers)"},{"question":"def max_sum_subgrid(grid, a, b): Find the maximum sum of any a x b sub-grid in the given m x n grid. Parameters: grid (list of list of int): The m x n grid filled with integers. a (int): Number of rows in the sub-grid. b (int): Number of columns in the sub-grid. Returns: int: The maximum sum of any a x b sub-grid. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_sum_subgrid(grid, 2, 2) 28 >>> grid = [ ... [1, 2], ... [3, 4] ... ] >>> max_sum_subgrid(grid, 2, 2) 10 >>> grid = [ ... [1, 2], ... [3, 4] ... ] >>> max_sum_subgrid(grid, 1, 1) 4 >>> grid = [ ... [1, -2, 3], ... [-1, 5, -6], ... [7, -8, 9] ... ] >>> max_sum_subgrid(grid, 3, 3) 8 >>> grid = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> max_sum_subgrid(grid, 2, 2) 54","solution":"def max_sum_subgrid(grid, a, b): Find the maximum sum of any a x b sub-grid in the given m x n grid. Parameters: grid (list of list of int): The m x n grid filled with integers. a (int): Number of rows in the sub-grid. b (int): Number of columns in the sub-grid. Returns: int: The maximum sum of any a x b sub-grid. m = len(grid) n = len(grid[0]) # Create a prefix sum array prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] # Calculate prefix sum for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = grid[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] max_sum = float('-inf') # Find maximum sum of a x b sub-grid for i in range(a, m + 1): for j in range(b, n + 1): current_sum = (prefix_sum[i][j] - prefix_sum[i - a][j] - prefix_sum[i][j - b] + prefix_sum[i - a][j - b]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def maxProfit(prices: List[int]) -> int: Given an array of integers representing the price of merchandise over several days, find the maximum profit you can achieve. You may complete at most two transactions. A transaction consists of buying and then selling one piece of merchandise. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the piece before you can buy again). >>> maxProfit([]) == 0 >>> maxProfit([5]) == 0 >>> maxProfit([7, 6, 4, 3, 1]) == 0 >>> maxProfit([1, 2, 3, 4, 5]) == 4 >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) == 6 >>> maxProfit([1, 2, 3, 4, 5, 6, 7, 8]) == 7 >>> maxProfit([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) == 13 >>> maxProfit([2, 1, 4, 5, 7, 2, 4, 9, 0]) == 13","solution":"def maxProfit(prices): Finds the maximum profit from at most two transactions on daily stock prices. Parameters: prices (List[int]): List of stock prices. Returns: int: The maximum profit possible. if not prices: return 0 first_buy, first_sell = float('-inf'), 0 second_buy, second_sell = float('-inf'), 0 for price in prices: first_buy = max(first_buy, -price) first_sell = max(first_sell, first_buy + price) second_buy = max(second_buy, first_sell - price) second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"def count_valid_pairs(heights: list[int], d: int) -> int: Counts the number of distinct pairs (i, j) such that the heights of the trees at i and j differ by at least d. Parameters: heights (list of int): The list of tree heights. d (int): The minimum difference in tree height required for a pair to be valid. Returns: int: The count of valid pairs. pass # Unit Tests def test_no_valid_pairs(): heights = [1, 1, 1] d = 2 assert count_valid_pairs(heights, d) == 0 def test_all_valid_pairs(): heights = [1, 3, 5] d = 2 assert count_valid_pairs(heights, d) == 3 def test_some_valid_pairs(): heights = [1, 2, 3] d = 1 assert count_valid_pairs(heights, d) == 3 def test_large_d_value(): heights = [2, 9, 4, 6, 3] d = 10 assert count_valid_pairs(heights, d) == 0 def test_empty_heights(): heights = [] d = 1 assert count_valid_pairs(heights, d) == 0 def test_single_tree_height(): heights = [5] d = 1 assert count_valid_pairs(heights, d) == 0 def test_equal_heights(): heights = [2, 2, 2, 2] d = 1 assert count_valid_pairs(heights, d) == 0","solution":"def count_valid_pairs(heights, d): Counts the number of distinct pairs (i, j) such that the heights of the trees at i and j differ by at least d. Parameters: heights (list of int): The list of tree heights. d (int): The minimum difference in tree height required for a pair to be valid. Returns: int: The count of valid pairs. n = len(heights) count = 0 for i in range(n): for j in range(i+1, n): if abs(heights[i] - heights[j]) >= d: count += 1 return count"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained after an infinite number of the allowed operations. >>> lexicographically_smallest_string(\\"\\") == \\"\\" >>> lexicographically_smallest_string(\\"a\\") == \\"a\\" >>> lexicographically_smallest_string(\\"z\\") == \\"z\\" >>> lexicographically_smallest_string(\\"aaaa\\") == \\"aaaa\\" >>> lexicographically_smallest_string(\\"dddd\\") == \\"dddd\\" >>> lexicographically_smallest_string(\\"abc\\") == \\"aaa\\" >>> lexicographically_smallest_string(\\"zxbc\\") == \\"bbbb\\" >>> lexicographically_smallest_string(\\"zaa\\") == \\"aaa\\" >>> lexicographically_smallest_string(\\"a\\" * 1000) == \\"a\\" * 1000 >>> lexicographically_smallest_string(\\"z\\" * 500 + \\"y\\" * 500) == \\"y\\" * 1000","solution":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained after an infinite number of the allowed operations. if not s: return \\"\\" smallest_char = min(s) return smallest_char * len(s)"},{"question":"def longest_subarray_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest subarray with at most k distinct characters. Args: s (str): The input string. k (int): The maximum number of distinct characters allowed. Returns: int: The length of the longest subarray with at most k distinct characters. >>> longest_subarray_with_k_distinct(\\"\\", 2) == 0 >>> longest_subarray_with_k_distinct(\\"abc\\", 0) == 0 >>> longest_subarray_with_k_distinct(\\"aaaaa\\", 1) == 5 >>> longest_subarray_with_k_distinct(\\"abcdef\\", 6) == 6 >>> longest_subarray_with_k_distinct(\\"aabacbebebe\\", 3) == 7 >>> longest_subarray_with_k_distinct(\\"aabbcc\\", 1) == 2 >>> longest_subarray_with_k_distinct(\\"aabbcc\\", 2) == 4 >>> longest_subarray_with_k_distinct(\\"aabbcc\\", 3) == 6 >>> longest_subarray_with_k_distinct(\\"aaaa\\", 1) == 4 >>> longest_subarray_with_k_distinct(\\"a\\", 2) == 1 >>> longest_subarray_with_k_distinct(\\"a\\", 1) == 1 >>> longest_subarray_with_k_distinct(\\"abcde\\", 2) == 2 pass","solution":"def longest_subarray_with_k_distinct(s, k): Returns the length of the longest subarray with at most k distinct characters. Args: s (str): The input string. k (int): The maximum number of distinct characters allowed. Returns: int: The length of the longest subarray with at most k distinct characters. if k == 0: return 0 char_count = {} left = 0 max_length = 0 for right in range(len(s)): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"abcde\\") 5 >>> length_of_longest_substring(\\"abba\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"aabaab!bb\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 max_len = 0 start = 0 used_chars = {} for i in range(n): if s[i] in used_chars and start <= used_chars[s[i]]: start = used_chars[s[i]] + 1 else: max_len = max(max_len, i - start + 1) used_chars[s[i]] = i return max_len"},{"question":"from typing import List def repeat_elements(nums: List[int], k: int) -> List[int]: Given an array of integers \`nums\` and an integer \`k\`, arrange the array such that each number in \`nums\` is repeated \`k\` times consecutively. The order of the elements should remain the same as the original order in \`nums\`. Return the modified array. >>> repeat_elements([1, 2, 3], 2) [1, 1, 2, 2, 3, 3] >>> repeat_elements([1], 3) [1, 1, 1] >>> repeat_elements([], 2) [] >>> repeat_elements([1, 2, 3], 0) [] >>> repeat_elements([1, 2, 3], -2) [] >>> repeat_elements([4, 5, 6], 1) [4, 5, 6] >>> repeat_elements([1, 2, 3, 4], 3) [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4] >>> repeat_elements([0, 1], 5) [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]","solution":"def repeat_elements(nums, k): Returns an array where each element in nums is repeated k times consecutively. Args: nums: A list of integers. k: An integer indicating how many times each element should be repeated. Returns: A list of integers where each element is repeated k times consecutively. if k <= 0: return [] result = [] for num in nums: result.extend([num] * k) return result"},{"question":"def split_string(s: str, k: int) -> List[str]: Determines if it's possible to split the string s into exactly k parts such that their lexicographic order is the same as their appearance in s. If possible, returns a list of the k substrings. Otherwise, returns an empty list. >>> split_string(\\"abcdef\\", 3) ['a', 'b', 'cdef'] >>> split_string(\\"abcdefgh\\", 4) ['a', 'b', 'c', 'defgh'] >>> split_string(\\"abcde\\", 2) ['a', 'bcde'] >>> split_string(\\"a\\", 2) [] >>> split_string(\\"abc\\", 4) [] >>> split_string(\\"abc\\", 3) ['a', 'b', 'c'] >>> split_string(\\"abcd\\", 4) ['a', 'b', 'c', 'd'] >>> split_string(\\"abc\\", 1) ['abc'] >>> split_string(\\"abcd\\", 1) ['abcd'] >>> split_string(\\"abc\\", 5) [] >>> split_string(\\"abcdefgh\\", 8) ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']","solution":"def split_string(s, k): Determines if it's possible to split the string s into exactly k parts such that their lexicographic order is the same as their appearance in s. If possible, returns a list of the k substrings. Otherwise, returns an empty list. n = len(s) # If k is greater than the number of characters in the string, it's not possible if k > n: return [] # Initialize a list to store the substrings substrings = [] # Start cutting the string start = 0 for i in range(1, k): substrings.append(s[start:i]) start = i substrings.append(s[start:]) return substrings"},{"question":"def min_palindrome_cuts(s: str) -> int: Given a string s, split it into as many parts as possible such that each part is a palindrome. Return the minimum number of cuts needed to achieve this. A palindrome is defined as a string that reads the same backward as forward. >>> min_palindrome_cuts(\\"a\\") == 0 >>> min_palindrome_cuts(\\"aa\\") == 0 >>> min_palindrome_cuts(\\"ab\\") == 1 >>> min_palindrome_cuts(\\"aba\\") == 0 >>> min_palindrome_cuts(\\"abc\\") == 2 >>> min_palindrome_cuts(\\"aab\\") == 1 >>> min_palindrome_cuts(\\"aabbc\\") == 2 >>> min_palindrome_cuts(\\"racecar\\") == 0 >>> min_palindrome_cuts(\\"ababbbabbababa\\") == 3","solution":"def min_palindrome_cuts(s): Returns the minimum number of cuts needed to partition the string s such that every part is a palindrome. n = len(s) if n <= 1: return 0 # Create a table to check if s[i:j+1] is a palindrome palindrome = [[False] * n for _ in range(n)] for i in range(n): palindrome[i][i] = True # Every single character is a palindrome for i in range(n-1): if s[i] == s[i+1]: palindrome[i][i+1] = True # Two consecutive same characters are a palindrome for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 palindrome[i][j] = (s[i] == s[j]) and palindrome[i+1][j-1] # Array to store the minimum cuts needed for a palindrome partition cuts = [0] * n for i in range(n): if palindrome[0][i]: cuts[i] = 0 else: min_cuts = float('inf') for j in range(1, i+1): if palindrome[j][i]: min_cuts = min(min_cuts, cuts[j-1] + 1) cuts[i] = min_cuts return cuts[-1]"},{"question":"class Interval: def __init__(self, start, end): self.start = start self.end = end def mergeIntervals(intervals): Given a list of intervals, merge all overlapping intervals and return a list of the merged intervals in sorted order. >>> intervals = [Interval(1, 3), Interval(2, 6), Interval(8, 10), Interval(15, 18)] >>> merged = mergeIntervals(intervals) >>> [[interval.start, interval.end] for interval in merged] [[1, 6], [8, 10], [15, 18]]","solution":"class Interval: def __init__(self, start, end): self.start = start self.end = end def mergeIntervals(intervals): if not intervals: return [] # Sort the intervals by the starting value intervals.sort(key=lambda x: x.start) merged = [] current_interval = intervals[0] for interval in intervals[1:]: # If the current interval overlaps with the next interval, merge them if current_interval.end >= interval.start: current_interval.end = max(current_interval.end, interval.end) else: # If they do not overlap, add the current interval to merged list merged.append(current_interval) current_interval = interval # Add the last interval merged.append(current_interval) return merged"},{"question":"def k_periodic_string(s: str, k: int) -> str: Determine if the string s is k-periodic and return the substring of length k that can be concatenated to form s, otherwise return an empty string. Parameters: s (str): The input string. k (int): The length of the substring to check for periodicity. Returns: str: The substring of length k if s is k-periodic, otherwise an empty string. >>> k_periodic_string(\\"ababab\\", 2) 'ab' >>> k_periodic_string(\\"aaaaaa\\", 1) 'a' >>> k_periodic_string(\\"abcabcabc\\", 3) 'abc' >>> k_periodic_string(\\"ababab\\", 1) '' >>> k_periodic_string(\\"abcde\\", 3) '' >>> k_periodic_string(\\"aaabaaa\\", 2) '' >>> k_periodic_string(\\"gggggg\\", 6) 'gggggg' >>> k_periodic_string(\\"\\", 1) '' >>> k_periodic_string(\\"a\\", 1) 'a' >>> k_periodic_string(\\"abcabcabc\\", 0) '' >>> k_periodic_string(\\"abcabcabc\\", -1) '' >>> k_periodic_string(\\"abcabcabc\\", 10) ''","solution":"def k_periodic_string(s, k): Determine if the string s is k-periodic and return the substring of length k that can be concatenated to form s, otherwise return an empty string. Parameters: s (str): The input string. k (int): The length of the substring to check for periodicity. Returns: str: The substring of length k if s is k-periodic, otherwise an empty string. if k <= 0 or k > len(s): return \\"\\" substring = s[:k] repeated_string = substring * (len(s) // k) if repeated_string == s: return substring else: return \\"\\""},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree as a list of lists. >>> root = TreeNode(3) >>> root.left =TreeNode(9) >>> root.right =TreeNode(20) >>> root.right.left =TreeNode(15) >>> root.right.right =TreeNode(7) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> level_order_traversal(TreeNode(1)) [[1]] >>> level_order_traversal(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree as a list of lists. if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Determine whether a given target number exists in a 2D integer matrix where each row is sorted in ascending order. Args: matrix (List[List[int]]): The 2D matrix of integers. target (int): The target number to search for. Returns: bool: True if the target is found, False otherwise. Examples: >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) True >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) False pass","solution":"def search_matrix(matrix, target): Returns True if the target exists in the matrix, False otherwise. The matrix is assumed to be sorted in ascending order in each row. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start at the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"import random from typing import List def shuffleDeck(deck: List[int]) -> List[int]: Shuffles the given deck of cards using the Fisher-Yates (Knuth) shuffle algorithm. >>> deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] >>> shuffled_deck = shuffleDeck(deck[:]) # Make a copy to shuffle >>> sorted(shuffled_deck) == sorted(deck) True # Implement the Fisher-Yates (Knuth) shuffle algorithm Unit Test: from solution import shuffleDeck def test_shuffleDeck_length(): deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] shuffled_deck = shuffleDeck(deck[:]) # Make a copy to shuffle assert len(shuffled_deck) == len(deck) def test_shuffleDeck_same_elements(): deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] shuffled_deck = shuffleDeck(deck[:]) # Make a copy to shuffle assert sorted(shuffled_deck) == sorted(deck) def test_shuffleDeck_uniformity(): deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] shuffle_counts = [0] * len(deck) trials = 10000 for _ in range(trials): shuffled_deck = shuffleDeck(deck[:]) # Make a copy to shuffle for i, card in enumerate(shuffled_deck): shuffle_counts[deck.index(card)] += 1 avg_count = sum(shuffle_counts) / len(shuffle_counts) for count in shuffle_counts: assert 0.9 * avg_count <= count <= 1.1 * avg_count, \\"Shuffle may not be uniform\\" def test_shuffleDeck_empty(): deck = [] shuffled_deck = shuffleDeck(deck[:]) assert shuffled_deck == deck def test_shuffleDeck_single_element(): deck = [1] shuffled_deck = shuffleDeck(deck[:]) assert shuffled_deck == deck","solution":"import random from typing import List def shuffleDeck(deck: List[int]) -> List[int]: Shuffles the given deck of cards in-place using the Fisher-Yates (Knuth) shuffle algorithm. for i in range(len(deck) - 1, 0, -1): j = random.randint(0, i) deck[i], deck[j] = deck[j], deck[i] return deck"},{"question":"def arrange_even_before_odd(arr: List[int]) -> List[int]: Given an integer array, returns the array such that all even numbers appear before all the odd numbers, while maintaining the relative order of even and odd numbers. The algorithm must have linear runtime complexity and use only constant extra space. >>> arrange_even_before_odd([2, 4, 6, 8]) == [2, 4, 6, 8] >>> arrange_even_before_odd([1, 3, 5, 7]) == [1, 3, 5, 7] >>> arrange_even_before_odd([3, 8, 5, 12, 7, 10]) == [8, 12, 10, 3, 5, 7] >>> arrange_even_before_odd([]) == [] >>> arrange_even_before_odd([2]) == [2] >>> arrange_even_before_odd([1]) == [1] >>> arrange_even_before_odd([13,12]) == [12, 13]","solution":"def arrange_even_before_odd(arr): Returns the array such that all even numbers appear before all the odd numbers, while maintaining the relative order of even and odd numbers. even = [] odd = [] for num in arr: if num % 2 == 0: even.append(num) else: odd.append(num) return even + odd"},{"question":"def buddy_strings(s: str, goal: str) -> bool: Determine if you can swap two letters in \`s\` such that the result is equal to \`goal\`. :param s: str - input string to be modified :param goal: str - target string to match :return: bool - True if s can be modified to match goal by swapping two letters, False otherwise >>> buddy_strings(\\"aabb\\", \\"aabb\\") True >>> buddy_strings(\\"abc\\", \\"abcd\\") False >>> buddy_strings(\\"ab\\", \\"ba\\") True >>> buddy_strings(\\"ab\\", \\"ab\\") False >>> buddy_strings(\\"abc\\", \\"abc\\") False >>> buddy_strings(\\"abcd\\", \\"badc\\") False >>> buddy_strings(\\"abcd\\", \\"abdc\\") True","solution":"def buddy_strings(s, goal): Determine if you can swap two letters in \`s\` such that the result is equal to \`goal\`. :param s: str - input string to be modified :param goal: str - target string to match :return: bool - True if s can be modified to match goal by swapping two letters, False otherwise if len(s) != len(goal): return False if s == goal and len(set(s)) < len(s): return True pairs = [] for a, b in zip(s, goal): if a != b: pairs.append((a, b)) if len(pairs) > 2: return False return len(pairs) == 2 and pairs[0] == pairs[1][::-1]"},{"question":"def count_unique_pairs(nums: List[int], x: int) -> int: Returns the count of unique pairs of elements in the array \`nums\` such that their sum is equal to \`x\`. >>> count_unique_pairs([1, 2, 3, 4], 10) == 0 >>> count_unique_pairs([1, 2, 3, 4], 5) == 2 # (1, 4) and (2, 3) >>> count_unique_pairs([1, 1, 2, 2, 3, 3], 4) == 2 # (1, 3) and (2, 2) >>> count_unique_pairs([1, 5, 7, -1, 5], 6) == 2 # (1, 5) and (7, -1) >>> count_unique_pairs([1000000, 999999, 1], 1000000) == 1 # (999999, 1) >>> count_unique_pairs([], 5) == 0 >>> count_unique_pairs([2], 4) == 0 >>> count_unique_pairs([1, 1, 1, 1, 1], 2) == 1 # (1, 1)","solution":"def count_unique_pairs(nums, x): Returns the count of unique pairs of elements in the array \`nums\` such that their sum is equal to \`x\`. seen = set() pairs = set() for num in nums: complement = x - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def min_time(tasks: List[int], k: int) -> int: Returns the minimum amount of time required to complete all tasks, given that you can process up to \`k\` tasks concurrently. Parameters: tasks: List[int], list of times required for each task k: int, maximum number of concurrent tasks Returns: int, minimum time to finish all tasks Examples: >>> min_time([3, 2, 1], 2) 3 >>> min_time([5], 1) 5 >>> min_time([4, 2, 3, 7, 1, 2], 3) 7 >>> min_time([8, 5, 3], 5) 8 >>> min_time([5, 5, 5, 5], 4) 5 >>> min_time([2, 2, 2, 2, 2, 2, 2, 2], 4) 4 >>> min_time([], 3) 0","solution":"import heapq def min_time(tasks, k): Returns the minimum amount of time required to complete all tasks, given that you can process up to \`k\` tasks concurrently. Parameters: tasks: List[int], list of times required for each task k: int, maximum number of concurrent tasks Returns: int, minimum time to finish all tasks if not tasks: return 0 # Create a min heap to store the current times of \`k\` workers heap = [0] * k for task_time in sorted(tasks, reverse=True): # Pop the worker with the least current time min_time_worker = heapq.heappop(heap) # Assign this task to that worker and update the worker's time heapq.heappush(heap, min_time_worker + task_time) # The total time to finish all tasks will be the maximum time in the heap return max(heap)"},{"question":"def max_favorite_items_picked(items: List[int], k: int, favoriteTypes: List[int]) -> int: Returns the maximum number of favorite items the robot can pick up from any segment of length k on the conveyor belt. :param items: List[int] - conveyor belt items :param k: int - number of arms (segment length) :param favoriteTypes: List[int] - favorite item types for each arm :return: int - maximum number of favorite items picked up >>> max_favorite_items_picked([1, 2, 3, 4, 1, 2, 3, 4], 3, [1, 2, 3]) 3 >>> max_favorite_items_picked([1, 1, 1, 1, 1], 2, [1]) 2 >>> max_favorite_items_picked([1, 2, 3, 1, 2, 3, 1], 3, [2, 3]) 2 >>> max_favorite_items_picked([1, 2, 3, 4, 5], 3, [6, 7, 8]) 0 >>> max_favorite_items_picked([1, 1, 1, 1, 1, 1, 1], 5, [1, 1, 1, 1, 1]) 5 >>> max_favorite_items_picked([1, 2, 3, 4, 5, 1, 2], 5, [1, 3, 4]) 3 >>> max_favorite_items_picked([3, 2, 1, 4], 4, [1, 2, 3, 4]) 4 >>> max_favorite_items_picked([1, 2, 3, 4, 5], 2, [6, 7]) 0 >>> max_favorite_items_picked([1, 3, 1, 3, 5, 1, 3], 4, [1, 3]) 4","solution":"def max_favorite_items_picked(items, k, favoriteTypes): Returns the maximum number of favorite items the robot can pick up from any segment of length k on the conveyor belt. :param items: List[int] - conveyor belt items :param k: int - number of arms (segment length) :param favoriteTypes: List[int] - favorite item types for each arm :return: int - maximum number of favorite items picked up n = len(items) max_favorite_count = 0 # Traverse through each possible segment of length k for i in range(n - k + 1): current_segment = items[i:i+k] favorite_count = sum(1 for j in range(k) if current_segment[j] in favoriteTypes) max_favorite_count = max(max_favorite_count, favorite_count) return max_favorite_count"},{"question":"def min_disks_required(arr: List[int], disk: int) -> int: Returns the minimum number of disks required to store all files. Parameters: arr (List[int]): List of integers representing the sizes of different files. disk (int): The capacity of a disk. Returns: int: The minimum number of disks required to store all files. Examples: >>> min_disks_required([4, 8, 1, 4, 2, 1], 10) 2 >>> min_disks_required([], 10) 0 >>> min_disks_required([5], 5) 1 >>> min_disks_required([3, 3, 3, 3], 3) 4 >>> min_disks_required([8, 2, 2, 2], 8) 2 >>> min_disks_required([15, 10, 10], 25) 2 >>> min_disks_required([3, 5, 3, 3, 5, 3, 1], 10) 3","solution":"def min_disks_required(arr, disk): Returns the minimum number of disks required to store all files. arr.sort(reverse=True) n = len(arr) used_disks = 0 used_space = [0] * n for i in range(n): placed = False for j in range(used_disks): if used_space[j] + arr[i] <= disk: used_space[j] += arr[i] placed = True break if not placed: used_space[used_disks] = arr[i] used_disks += 1 return used_disks"},{"question":"def count_bounded_subarrays(arr, left, right): You are given an array \`arr\` of positive integers. You are also given two integers \`left\` and \`right\`. A subarray is called **bounded** if the largest element in the subarray is in the range \`[left, right]\` (inclusive). Return the number of **bounded** subarrays in \`arr\`. >>> count_bounded_subarrays([2, 1, 4, 3], 2, 3) == 3 >>> count_bounded_subarrays([2, 9, 2, 5, 6], 2, 8) == 7 >>> count_bounded_subarrays([5], 4, 6) == 1 >>> count_bounded_subarrays([1, 1, 1], 2, 3) == 0 >>> count_bounded_subarrays([2, 3, 2], 2, 3) == 6 >>> count_bounded_subarrays([], 2, 3) == 0","solution":"def count_bounded_subarrays(arr, left, right): Returns the number of bounded subarrays within the range [left, right]. def count_subarrays_leq_max(arr, max_val): count = 0 current_length = 0 for num in arr: if num <= max_val: current_length += 1 count += current_length else: current_length = 0 return count return count_subarrays_leq_max(arr, right) - count_subarrays_leq_max(arr, left - 1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: TreeNode) -> List[int]: Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. >>> right_side_view(None) [] >>> right_side_view(TreeNode(1)) [1] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(3)), None) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> right_side_view(root) [1, 3, 5] >>> root = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3, None, TreeNode(4))) >>> right_side_view(root) [1, 3, 4]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom when observing from the right side. if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"def max_activities(activities): Returns the maximum number of non-overlapping activities one person can attend. Parameters: activities (list of tuples): A list where each tuple contains two integers representing the start and end times of an activity. Returns: int: The maximum number of non-overlapping activities. >>> max_activities([]) == 0 >>> max_activities([(1, 2)]) == 1 >>> max_activities([(1, 2), (2, 3), (3, 4)]) == 3 >>> max_activities([(1, 3), (2, 4), (3, 5)]) == 2 >>> max_activities([(1, 2), (2, 5), (3, 4)]) == 2 >>> max_activities([(1, 3), (2, 5), (3, 4), (4, 6), (5, 7), (6, 8)]) == 4","solution":"def max_activities(activities): Returns the maximum number of non-overlapping activities one person can attend. Parameters: activities (list of tuples): A list where each tuple contains two integers representing the start and end times of an activity. Returns: int: The maximum number of non-overlapping activities. if not activities: return 0 # Sort activities based on their end times activities.sort(key=lambda x: x[1]) max_count = 0 last_end_time = -1 for start, end in activities: if start >= last_end_time: max_count += 1 last_end_time = end return max_count"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if a string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aabbc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"level\\") True >>> can_form_palindrome(\\"aabbcd\\") False >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"aaaaaa\\") True # Implementation goes here","solution":"def can_form_palindrome(s): Returns True if it is possible to rearrange the string s to form a palindrome, False otherwise. from collections import Counter count = Counter(s) odd_counts = sum(1 for count in count.values() if count % 2 != 0) # For the string to be rearrangeable into a palindrome, # there must be at most one character with an odd count. return odd_counts <= 1"},{"question":"def longest_cycle(nums: List[int]) -> int: Returns the length of the longest cycle in the array. If no cycle exists, returns -1. >>> longest_cycle([0]) 1 >>> longest_cycle([1, 2, 3, -1]) -1 >>> longest_cycle([1, 2, 0]) 3 >>> longest_cycle([1, 0, 3, 4, 2]) 3 >>> longest_cycle([1, 2, 0, 4, 5, 3]) 3 >>> longest_cycle([]) -1 >>> longest_cycle([-1, -1, -1]) -1","solution":"def longest_cycle(nums): Returns the length of the longest cycle in the array. If no cycle exists, returns -1. def visit(node): nonlocal max_cycle_length stack = [] while node != -1 and not visited[node] and node not in stack: stack.append(node) node = nums[node] if node in stack: cycle_length = len(stack) - stack.index(node) max_cycle_length = max(max_cycle_length, cycle_length) for v in stack: visited[v] = True n = len(nums) visited = [False] * n max_cycle_length = -1 for i in range(n): if not visited[i]: visit(i) return max_cycle_length"},{"question":"def search_2d_matrix(matrix, x): Given a 2D matrix sorted in non-decreasing order both row-wise and column-wise, returns the index of the cell that contains the target height x. Args: matrix (list of list of int): The 2D grid of heights. x (int): The target height. Returns: tuple: The index of the cell containing the target height x, or (-1, -1) if the height isn't found. >>> search_2d_matrix([[1, 3, 5, 7], [2, 4, 6, 8], [3, 5, 7, 9], [4, 6, 8, 10]], 5) (0, 2) >>> search_2d_matrix([[1, 3, 5, 7], [2, 4, 6, 8], [3, 5, 7, 9], [4, 6, 8, 10]], 11) (-1, -1) >>> search_2d_matrix([[0, 1], [2, 3]], 3) (1, 1) >>> search_2d_matrix([], 5) (-1, -1) >>> search_2d_matrix([[]], 5) (-1, -1) >>> search_2d_matrix([[1]], 1) (0, 0) >>> search_2d_matrix([[1]], 2) (-1, -1)","solution":"def search_2d_matrix(matrix, x): Given a 2D matrix sorted in non-decreasing order both row-wise and column-wise, returns the index of the cell that contains the target height x. Args: matrix (list of list of int): The 2D grid of heights. x (int): The target height. Returns: tuple: The index of the cell containing the target height x, or (-1, -1) if the height isn't found. if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == x: return (row, col) elif matrix[row][col] > x: col -= 1 else: row += 1 return (-1, -1)"},{"question":"def min_operations_to_equal(arr, x): Returns the minimum number of operations required to make all elements of arr equal to x. Parameters: arr (list of int): The input array. x (int): The target value to make all elements equal to. Returns: int: The minimum number of operations. >>> min_operations_to_equal([1, 2, 3], 2) 2 >>> min_operations_to_equal([1, 1, 1], 1) 0 from solution import min_operations_to_equal def test_min_operations_to_equal(): # test examples based on the question assert min_operations_to_equal([1, 2, 3], 2) == 2 assert min_operations_to_equal([1, 1, 1], 1) == 0 assert min_operations_to_equal([1, 1, 1], 2) == 3 assert min_operations_to_equal([4, 5, 6], 5) == 2 assert min_operations_to_equal([0, -1, -2], 0) == 3 def test_empty_array(): # Test with an empty array assert min_operations_to_equal([], 5) == 0 def test_all_elements_same_as_target(): # Array where all elements are already equal to x assert min_operations_to_equal([5, 5, 5, 5], 5) == 0 def test_large_values(): # Test with large values in the array and for x assert min_operations_to_equal([1000, 2000, 3000], 1000) == 3000 # Large negative x assert min_operations_to_equal([-1000, -2000, -3000], -2000) == 2000 def test_single_element_array(): # Test with single element array assert min_operations_to_equal([5], 5) == 0 assert min_operations_to_equal([5], 10) == 5 assert min_operations_to_equal([5], 0) == 5","solution":"def min_operations_to_equal(arr, x): Returns the minimum number of operations required to make all elements of arr equal to x. Parameters: arr (list of int): The input array. x (int): The target value to make all elements equal to. Returns: int: The minimum number of operations. operations = 0 for element in arr: operations += abs(element - x) return operations"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: This function computes the number of unique paths in a grid with obstacles, where '1' indicates an obstacle and '0' indicates an accessible cell. Parameters: grid (list of list of int): The grid with obstacles represented by 1 and open cells by 0. Returns: int: The number of unique paths from top-left to bottom-right of the grid. Examples: >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def unique_paths_with_obstacles(grid): This function computes the number of unique paths in a grid with obstacles, where '1' indicates an obstacle and '0' indicates an accessible cell. Parameters: grid (list of list of int): The grid with obstacles represented by 1 and open cells by 0. Returns: int: The number of unique paths from top-left to bottom-right of the grid. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_even_nodes(head: ListNode) -> ListNode: Removes all nodes with even values from the linked list and returns the new head. >>> list_to_array(remove_even_nodes(array_to_list([1, 3, 5, 7]))) == [1, 3, 5, 7] >>> list_to_array(remove_even_nodes(array_to_list([2, 4, 6, 8]))) == [] >>> list_to_array(remove_even_nodes(array_to_list([1, 2, 3, 4, 5, 6, 7, 8, 9]))) == [1, 3, 5, 7, 9] >>> list_to_array(remove_even_nodes(array_to_list([2]))) == [] >>> list_to_array(remove_even_nodes(array_to_list([3]))) == [3] >>> remove_even_nodes(None) == None","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_even_nodes(head): Removes all nodes with even values from the linked list and returns the new head. # Use a dummy head to handle edge cases gracefully. dummy = ListNode(0) dummy.next = head current = dummy while current and current.next: if current.next.val % 2 == 0: # Skip the node with an even value. current.next = current.next.next else: # Move to the next node. current = current.next return dummy.next"},{"question":"from typing import List def rotateArray(nums: List[int], k: int) -> List[int]: Modify the array in such a way that each integer from the beginning of the array is moved to its position plus \`k\` indices ahead. Elements that are shifted beyond the array's last index should reappear at the beginning in a circular manner. :param nums: List[int] - The array to be rotated. :param k: int - The number of positions to rotate the array. :return: List[int] - The rotated array. >>> rotateArray([1], 3) [1] >>> rotateArray([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotateArray([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotateArray([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotateArray([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotateArray([1, 2, 3, 4, 5], 102) [4, 5, 1, 2, 3]","solution":"from typing import List def rotateArray(nums: List[int], k: int) -> List[int]: Rotates the elements of array nums k positions to the right. :param nums: List[int] - The array to be rotated. :param k: int - The number of positions to rotate the array. :return: List[int] - The rotated array. n = len(nums) k = k % n # handle cases where k is greater than the length of the array return nums[-k:] + nums[:-k]"},{"question":"def count_consistent_strings(words: List[str], allowed: str) -> int: Returns the number of consistent strings in the list \`words\`. A word is consistent if all its characters are in the string \`allowed\`. >>> count_consistent_strings(['a', 'b', 'aa', 'ab', 'bb'], 'ab') == 5 >>> count_consistent_strings(['c', 'd', 'e'], 'ab') == 0 >>> count_consistent_strings(['a', 'bc', 'abcd', 'ace'], 'abcde') == 4 >>> count_consistent_strings([], 'abc') == 0 >>> count_consistent_strings(['a', 'b', 'c'], '') == 0 >>> count_consistent_strings(['a', 'A', 'bB', 'Cc'], 'abcABC') == 4","solution":"def count_consistent_strings(words, allowed): Returns the number of consistent strings in the list \`words\`. A word is consistent if all its characters are in the string \`allowed\`. allowed_set = set(allowed) consistent_count = 0 for word in words: if all(char in allowed_set for char in word): consistent_count += 1 return consistent_count"},{"question":"def findSubarrays(nums: List[int], k: int, target: int) -> List[List[int]]: Returns all unique subarrays of length \`k\` that have a sum less than \`target\`. >>> findSubarrays([1, 2, 3, 4, 5], 3, 10) [[1, 2, 3], [2, 3, 4]] >>> findSubarrays([1, 1, 1, 1, 1], 2, 3) [[1, 1], [1, 1], [1, 1], [1, 1]] from solution import findSubarrays def test_findSubarrays_case1(): assert findSubarrays([1, 2, 3, 4, 5], 3, 10) == [[1, 2, 3], [2, 3, 4]] def test_findSubarrays_case2(): assert findSubarrays([1, 1, 1, 1, 1], 2, 3) == [[1, 1], [1, 1], [1, 1], [1, 1]] def test_findSubarrays_with_no_valid_subarray(): assert findSubarrays([5, 5, 5, 5], 2, 6) == [] def test_findSubarrays_with_single_element_subarrays(): assert findSubarrays([1, 2, 3, 4, 5], 1, 4) == [[1], [2], [3]] def test_findSubarrays_case_with_large_target(): assert findSubarrays([10, 20, 30, 40, 50], 2, 100) == [[10, 20], [20, 30], [30, 40], [40, 50]]","solution":"def findSubarrays(nums, k, target): Returns all unique subarrays of length \`k\` that have a sum less than \`target\`. n = len(nums) result = [] for i in range(n - k + 1): subarray = nums[i:i+k] if sum(subarray) < target: result.append(subarray) return result"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained by reversing a substring of length k in the given string s. >>> lexicographically_smallest_string(\\"cba\\", 1) \\"acb\\" >>> lexicographically_smallest_string(\\"baaca\\", 1) \\"aacab\\" >>> lexicographically_smallest_string(\\"cba\\", 2) \\"abc\\" >>> lexicographically_smallest_string(\\"baaca\\", 2) \\"aaabc\\" >>> lexicographically_smallest_string(\\"dcba\\", 4) \\"abcd\\" >>> lexicographically_smallest_string(\\"baaca\\", 3) \\"aaabc\\" >>> lexicographically_smallest_string(\\"dcba\\", 4) \\"abcd\\" >>> lexicographically_smallest_string(\\"zyx\\", 3) \\"xyz\\"","solution":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained by reversing a substring of length k in the given string s. if k == 1: # If k is 1, we can only rotate the string to get the smallest lexicographical order smallest = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest else: # If k > 1, we can sort the entire string to get the smallest lexicographical order return ''.join(sorted(s))"},{"question":"def longest_distinct_subsequence(s: str) -> int: Returns the length of the longest subsequence where any two consecutive characters are distinct. >>> longest_distinct_subsequence(\\"\\") 0 >>> longest_distinct_subsequence(\\"a\\") 1 >>> longest_distinct_subsequence(\\"abcdefg\\") 7 >>> longest_distinct_subsequence(\\"aaaaa\\") 1 >>> longest_distinct_subsequence(\\"aabbccddeeff\\") 6 >>> longest_distinct_subsequence(\\"abcabcabc\\") 9 >>> longest_distinct_subsequence(\\"aaabbbcccddd\\") 4","solution":"def longest_distinct_subsequence(s): Returns the length of the longest subsequence where any two consecutive characters are distinct. if not s: # If the string is empty, return 0 return 0 # The longest subsequence with distinct consecutive characters can't be longer # than the length of the string where each character is counted exactly once. longest_length = 1 # We must have at least one character in the subsequence. for i in range(1, len(s)): if s[i] != s[i-1]: longest_length += 1 return longest_length"},{"question":"def min_bonuses(ratings: List[int]) -> int: Calculate the minimum number of bonuses required for the given ratings. Each employee must receive at least one bonus, and employees with higher ratings receive strictly more bonuses than their neighbors. Parameters: ratings (List[int]): List of employee ratings. Returns: int: Minimum number of bonuses required. >>> min_bonuses([1, 0, 2]) 5 >>> min_bonuses([2, 2, 2]) 3 >>> min_bonuses([1, 2, 3, 4]) 10 >>> min_bonuses([4, 3, 2, 1]) 10 >>> min_bonuses([1, 3, 2, 2, 1]) 7 >>> min_bonuses([1]) 1 >>> min_bonuses([1, 2]) 3 >>> min_bonuses([2, 1]) 3 >>> min_bonuses([]) 0","solution":"def min_bonuses(ratings): Calculate the minimum number of bonuses required for the given ratings. Parameters: ratings (List[int]): List of employee ratings. Returns: int: Minimum number of bonuses required. n = len(ratings) if n == 0: return 0 bonuses = [1] * n # Forward pass to ensure right neighbor condition for i in range(1, n): if ratings[i] > ratings[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Backward pass to ensure left neighbor condition for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"from typing import List def rearrangeStudents(heights: List[int]) -> List[int]: Rearrange the students’ heights to ensure proper visibility, i.e., no student should be completely obscured by another taller student when viewed from the front. :param heights: List[int] - List of distinct student heights :return: List[int] - Rearranged list of student heights >>> rearrangeStudents([5, 7, 3, 6, 2]) [2, 3, 5, 6, 7] >>> rearrangeStudents([10, 1, 100, 50, 30]) [1, 10, 30, 50, 100] >>> rearrangeStudents([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> rearrangeStudents([1]) [1] >>> rearrangeStudents([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]","solution":"def rearrangeStudents(heights): Rearrange the students’ heights to ensure proper visibility, i.e., no student should be completely obscured by another taller student when viewed from the front. :param heights: List[int] - List of distinct student heights :return: List[int] - Rearranged list of student heights return sorted(heights)"},{"question":"def minimum_time_to_complete_tasks(n: int, prerequisites: List[Tuple[int, int]]) -> int: Return the minimum time required to complete all the tasks considering the given prerequisites. If it is impossible to complete all tasks, return -1. >>> minimum_time_to_complete_tasks(4, []) == 1 >>> minimum_time_to_complete_tasks(4, [(0, 1), (1, 2), (2, 3)]) == 4 >>> minimum_time_to_complete_tasks(3, [(0, 1), (1, 2), (2, 0)]) == -1 >>> minimum_time_to_complete_tasks(4, [(0, 1), (0, 2), (1, 3), (2, 3)]) == 3 >>> minimum_time_to_complete_tasks(4, [(0, 3), (1, 3), (2, 3)]) == 2","solution":"from collections import deque, defaultdict def minimum_time_to_complete_tasks(n, prerequisites): def get_indegree_and_graph(n, prerequisites): indegree = [0] * n graph = defaultdict(list) for a, b in prerequisites: graph[a].append(b) indegree[b] += 1 return indegree, graph indegree, graph = get_indegree_and_graph(n, prerequisites) queue = deque([i for i in range(n) if indegree[i] == 0]) time = 0 completed_tasks = 0 while queue: task_count = len(queue) time += 1 for _ in range(task_count): current_task = queue.popleft() completed_tasks += 1 for neighbor in graph[current_task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if completed_tasks == n: return time return -1"},{"question":"def canArrangeStudents(heights, comparison): Determine if it's possible to arrange all students in a line such that the given constraints are satisfied. heights: List[int] - List of integers representing the heights of students in a classroom comparison: List[List[int]] - List where comparison[i] = [ai, bi] indicates that student with height ai should stand in front of the student with height bi Returns: bool - True if such an arrangement is possible, False otherwise >>> heights = [1, 2, 3, 4] >>> comparison = [[1, 2], [2, 3], [3, 4]] >>> canArrangeStudents(heights, comparison) True >>> heights = [1, 2, 3, 4] >>> comparison = [[1, 2], [2, 3], [3, 1], [3, 4]] >>> canArrangeStudents(heights, comparison) False >>> heights = [1, 2, 3, 4] >>> comparison = [] >>> canArrangeStudents(heights, comparison) True >>> heights = [1] >>> comparison = [] >>> canArrangeStudents(heights, comparison) True >>> heights = [1, 2, 3, 4, 5] >>> comparison = [[1, 2], [2, 3], [2, 4], [3, 5], [4, 5]] >>> canArrangeStudents(heights, comparison) True >>> heights = [1, 2, 3] >>> comparison = [[1, 2], [2, 3], [3, 4]] >>> canArrangeStudents(heights, comparison) False pass","solution":"def canArrangeStudents(heights, comparison): from collections import defaultdict, deque graph = defaultdict(list) indegree = defaultdict(int) for a, b in comparison: graph[a].append(b) indegree[b] += 1 zero_indegree_queue = deque([h for h in heights if indegree[h] == 0]) sorted_order = [] while zero_indegree_queue: node = zero_indegree_queue.popleft() sorted_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) return len(sorted_order) == len(heights) # Example usage: # heights = [1, 2, 3, 4] # comparison = [[1, 2], [2, 3], [3, 4]] # canArrangeStudents(heights, comparison)"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Given a 2D grid of non-negative integers, calculate the minimum path sum from the top-left to the bottom-right corner by only moving down or right. Example: >>> min_path_sum([[1,3,1], [1,5,1], [4,2,1]]) 7 >>> min_path_sum([[1,2,3], [4,5,6]]) 12 >>> min_path_sum([[1,2,3]]) 6 >>> min_path_sum([[1], [2], [3]]) 6 >>> min_path_sum([[1]]) 1 >>> min_path_sum([[1, 3, 1, 4], [1, 5, 1, 2], [4, 2, 1, 3], [3, 2, 2, 1]]) 10","solution":"def min_path_sum(grid): Given a 2D grid of non-negative integers, calculate the minimum path sum from the top-left to the bottom-right corner by only moving down or right. m, n = len(grid), len(grid[0]) # Initialize DP array with the first cell's value dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def calculate_visibility(nums: List[int]) -> List[int]: Returns the number of people each person in the queue can see. >>> calculate_visibility([1, 1, 1, 1]) == [0, 0, 0, 0] >>> calculate_visibility([1, 2, 3, 4]) == [0, 1, 2, 3] >>> calculate_visibility([4, 3, 2, 1]) == [0, 0, 0, 0] >>> calculate_visibility([3, 1, 4, 2]) == [0, 0, 2, 1] >>> calculate_visibility([5]) == [0] >>> calculate_visibility([2, 2]) == [0, 0] >>> calculate_visibility([2, 3]) == [0, 1] >>> calculate_visibility([3, 2]) == [0, 0]","solution":"def calculate_visibility(nums): Returns the number of people each person in the queue can see. n = len(nums) visibility = [0] * n for i in range(n): count = 0 for j in range(i): if nums[j] < nums[i]: count += 1 visibility[i] = count return visibility"},{"question":"def largest_flat_terrain_component(field: List[List[int]]) -> int: Given the matrix \`field\`, return the size of the largest connected component of flat terrain. If there are no flat terrains, return \`0\`. >>> largest_flat_terrain_component([ ... [0, 1, 2], ... [0, 0, 3], ... [1, 0, 0], ... [2, 0, 1] ... ]) 6 >>> largest_flat_terrain_component([ ... [1, 2, 3], ... [1, 1, 2], ... [3, 2, 1] ... ]) 0","solution":"def largest_flat_terrain_component(field): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or field[x][y] != 0: return 0 field[x][y] = -1 # mark as visited size = 1 # count the current cell # Visit each of the four adjacent cells size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size if not field: return 0 m, n = len(field), len(field[0]) largest_component = 0 for i in range(m): for j in range(n): if field[i][j] == 0: largest_component = max(largest_component, dfs(i, j)) return largest_component"},{"question":"def is_prime(num): Check if a number is prime. pass def sum_of_primes(m, n): Returns the sum of all prime numbers between m and n inclusive. >>> sum_of_primes(1, 10) 17 >>> sum_of_primes(3, 3) 3 >>> sum_of_primes(1, 1) 0 >>> sum_of_primes(2, 3) 5 >>> sum_of_primes(10, 20) 60 >>> sum_of_primes(90, 100) 97 >>> sum_of_primes(5, 5) 5 pass","solution":"def is_prime(num): Check if a number is prime. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def sum_of_primes(m, n): Returns the sum of all prime numbers between m and n inclusive. return sum(num for num in range(m, n + 1) if is_prime(num))"},{"question":"def minimumCost(n: int, connections: List[List[int]]) -> int: Returns the minimum cost to connect all offices or -1 if it is impossible. >>> minimumCost(3, [[1, 2, 5], [1, 3, 6], [2, 3, 1]]) 6 >>> minimumCost(4, [[1, 2, 3], [3, 4, 4]]) -1 >>> minimumCost(4, [[1, 2, 1], [2, 3, 2], [3, 4, 3], [1, 4, 5]]) 6 >>> minimumCost(2, [[1, 2, 1]]) 1 >>> minimumCost(2, []) -1 >>> minimumCost(5, [[1, 2, 1], [2, 3, 2], [3, 4, 3], [4, 5, 4], [1, 5, 10]]) 10","solution":"def minimumCost(n, connections): Returns the minimum cost to connect all offices or -1 if it is impossible. # Helper function to find the representative/root of a component def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to union two components def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Initialize the parent and rank arrays for the union-find parent = [i for i in range(n)] rank = [0] * n # Sort connections by cost connections.sort(key=lambda x: x[2]) mst_cost = 0 edges_used = 0 for office1, office2, cost in connections: # Convert 1-indexed offices to 0-indexed for 0-based parent array root1 = find(parent, office1 - 1) root2 = find(parent, office2 - 1) if root1 != root2: union(parent, rank, root1, root2) mst_cost += cost edges_used += 1 # Check if we used exactly n-1 edges to connect the graph if edges_used == n - 1: return mst_cost else: return -1"},{"question":"def number_of_certificate_winners(scores: List[int], k: int) -> int: Returns the number of participants who will receive a certificate. Args: scores: list of integers representing the scores of participants. k: integer indicating the number of top scores to consider for certificates. Returns: integer: The number of participants who will receive a certificate. from solution import number_of_certificate_winners def test_number_of_certificate_winners_distinct_scores(): assert number_of_certificate_winners([50, 60, 70, 80, 90], 3) == 3 def test_number_of_certificate_winners_tie_at_kth_position(): assert number_of_certificate_winners([50, 60, 70, 70, 80, 80, 90], 3) == 5 def test_number_of_certificate_winners_all_same_scores(): assert number_of_certificate_winners([70, 70, 70, 70, 70], 2) == 5 def test_number_of_certificate_winners_k_greater_than_unique_scores(): assert number_of_certificate_winners([50, 60, 70], 5) == 3 def test_number_of_certificate_winners_single_participant(): assert number_of_certificate_winners([80], 1) == 1","solution":"def number_of_certificate_winners(scores, k): Returns the number of participants who will receive a certificate. Args: scores: list of integers representing the scores of participants. k: integer indicating the number of top scores to consider for certificates. Returns: integer: The number of participants who will receive a certificate. from collections import Counter # Get the frequency of each score score_counts = Counter(scores) # Get the unique scores sorted in descending order unique_scores = sorted(score_counts.keys(), reverse=True) # Find the k-th highest unique score if k > len(unique_scores): threshold_score = unique_scores[-1] else: threshold_score = unique_scores[k-1] # All scores greater than or equal to the threshold score will receive certificates num_certs = sum(count for score, count in score_counts.items() if score >= threshold_score) return num_certs"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses the given linked list and returns the head of the reversed list. :param head: ListNode - The head of the linked list. :return: ListNode - The new head of the reversed linked list. pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses the given linked list and returns the head of the reversed list. :param head: ListNode - The head of the linked list. :return: ListNode - The new head of the reversed linked list. prev_node = None current_node = head while current_node: next_node = current_node.next # Store next node current_node.next = prev_node # Reverse the current node's pointer prev_node = current_node # Move prev_node one step forward current_node = next_node # Move current_node one step forward return prev_node # prev_node will be the new head after the list is fully reversed"},{"question":"import heapq from typing import List, Tuple def shortest_path(graph: List[List[Tuple[int, int]]], start: int) -> List[int]: Finds the shortest path from the start node to all other nodes in a directed, weighted graph. Parameters: graph (list of list of pairs): Adjacency list representation of the graph where graph[u] contains (v, w) pairs. start (int): The starting node. Returns: list of int: The shortest path distances from the start node to each node, or -1 if a node is unreachable. >>> graph = [ ... [(1, 1), (2, 4)], ... [(2, 2), (3, 5)], ... [(3, 1)], ... [] ... ] >>> start_node = 0 >>> shortest_path(graph, start_node) [0, 1, 3, 4] >>> graph = [ ... [(1, 2)], ... [(2, 3)], ... [], ... [(2, 1)] ... ] >>> start_node = 0 >>> shortest_path(graph, start_node) [0, 2, 5, -1] >>> graph = [[]] >>> start_node = 0 >>> shortest_path(graph, start_node) [0] >>> graph = [ ... [(1, 1)], ... [], ... [(3, 1)], ... [] ... ] >>> start_node = 0 >>> shortest_path(graph, start_node) [0, 1, -1, -1] >>> graph = [ ... [(1, 1), (2, 2)], ... [(3, 1)], ... [(3, 1)], ... [] ... ] >>> start_node = 0 >>> shortest_path(graph, start_node) [0, 1, 2, 2]","solution":"import heapq def shortest_path(graph, start): Finds the shortest path from the start node to all other nodes in a directed, weighted graph. Parameters: graph (list of list of pairs): Adjacency list representation of the graph where graph[u] contains (v, w) pairs. start (int): The starting node. Returns: list of int: The shortest path distances from the start node to each node, or -1 if a node is unreachable. n = len(graph) distances = [float('inf')] * n distances[start] = 0 min_heap = [(0, start)] # (distance, node) while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) # Convert distances from infinity to -1 if not reachable. return [d if d != float('inf') else -1 for d in distances]"},{"question":"def transform(nums): Transforms the input array such that each element is replaced by the sum of all distinct integers except for the element at the current position. >>> transform([1]) == [0] >>> transform([1, 2]) == [2, 1] >>> transform([1, 2, 3]) == [5, 4, 3] >>> transform([4, 5, 6]) == [11, 10, 9] >>> transform([1, 2, 2, 3]) == [5, 4, 4, 3] pass def simulate_transform(nums, k): Simulates the transformation process \`k\` times. >>> simulate_transform([1, 2, 3], 1) == [5, 4, 3] >>> simulate_transform([1, 2, 3], 2) == [7, 8, 9] >>> simulate_transform([1, 2, 3], 3) == [17, 16, 15] >>> simulate_transform([1, 2, 2, 3], 1) == [5, 4, 4, 3] >>> simulate_transform([1, 2, 2, 3], 2) == [7, 8, 8, 9] pass","solution":"def transform(nums): Transforms the input array such that each element is replaced by the sum of all distinct integers except for the element at the current position. total_sum = sum(set(nums)) return [total_sum - num for num in nums] def simulate_transform(nums, k): Simulates the transformation process \`k\` times. for _ in range(k): nums = transform(nums) return nums"},{"question":"from collections import deque from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def kth_smallest_level_order(root: Optional[TreeNode], k: int) -> int: Find the k-th smallest value in the level order traversal of the tree. Return -1 if k is larger than the number of nodes in the tree. Args: root: The root of the binary tree. k: The k-th position. Returns: The k-th smallest value in level order traversal, or -1 if k is out of bounds. Examples: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> kth_smallest_level_order(root, 1) 3 >>> kth_smallest_level_order(root, 6) -1","solution":"from collections import deque # Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def kth_smallest_level_order(root, k): if not root: return -1 queue = deque([root]) counter = 0 while queue: node = queue.popleft() counter += 1 if counter == k: return node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return -1"},{"question":"def simplify_path(s: str) -> str: Simplify the given file path to its canonical form. >>> simplify_path(\\"/home//foo/../var/./lib//file.txt\\") \\"/home/var/lib/file.txt\\" >>> simplify_path(\\"/home/../etc/../usr//bin/\\") \\"/usr/bin\\"","solution":"def simplify_path(s): # Split the given path by '/' parts = [part for part in s.split('/') if part not in ['', '.']] stack = [] for part in parts: if part == '..': if stack: stack.pop() else: stack.append(part) # Join the stack to make the canonical path simplified_path = '/' + '/'.join(stack) return simplified_path"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. >>> node = TreeNode(1) >>> node.left = TreeNode(2) >>> node.right = TreeNode(3) >>> node.right.left = TreeNode(4) >>> node.right.right = TreeNode(5) >>> serialize(node) '1,2,#,#,3,4,#,#,5,#,#' >>> serialize(None) '#' def deserialize(data): Decodes your encoded data to tree. >>> deserialize('1,2,#,#,3,4,#,#,5,#,#').val 1 >>> deserialize('#') None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def preorder(node): if not node: return [\\"#\\"] return [str(node.val)] + preorder(node.left) + preorder(node.right) return ','.join(preorder(root)) def deserialize(data): Decodes your encoded data to tree. def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node nodes = iter(data.split(',')) return helper(nodes)"},{"question":"def min_number_of_days(days, tasks, workload): Returns the minimum number of days needed to complete all tasks or -1 if assignments are not possible within workload limits. :param days: List of int, representing the number of days :param tasks: List of int, representing durations of tasks :param workload: int, representing the maximum workload per day :return: int, minimum number of days needed or -1 >>> min_number_of_days([0, 0, 0], [5, 4, 3], 5) == 3 >>> min_number_of_days([0, 0, 0, 0], [4, 2, 3], 5) == 2 >>> min_number_of_days([0, 0], [6, 3], 5) == -1 >>> min_number_of_days([0, 0, 0, 0], [5, 2, 3], 6) == 2 >>> min_number_of_days([0, 0, 0], [1, 2, 3, 4], 5) == 2 >>> min_number_of_days([0, 0], [1, 1, 1, 1, 1, 1], 6) == 1 >>> min_number_of_days([0, 0, 0, 0], [1, 1, 1, 1, 1, 1], 2) == 3","solution":"def min_number_of_days(days, tasks, workload): Returns the minimum number of days needed to complete all tasks or -1 if assignments are not possible within workload limits. :param days: List of int, representing the number of days :param tasks: List of int, representing durations of tasks :param workload: int, representing the maximum workload per day :return: int, minimum number of days needed or -1 tasks.sort(reverse=True) day_loads = [0] * len(days) for task in tasks: assigned = False for i in range(len(day_loads)): if day_loads[i] + task <= workload: day_loads[i] += task assigned = True break if not assigned: return -1 utilized_days = 0 for load in day_loads: if load > 0: utilized_days += 1 return utilized_days"},{"question":"def min_cost_to_make_all_chars_same(s: str) -> int: Returns the minimum cost required to make all characters in the string s the same. >>> min_cost_to_make_all_chars_same(\\"abac\\") 3 >>> min_cost_to_make_all_chars_same(\\"aaaa\\") 1 >>> min_cost_to_make_all_chars_same(\\"abcde\\") 5 >>> min_cost_to_make_all_chars_same(\\"aabbccdd\\") 4 >>> min_cost_to_make_all_chars_same(\\"abcdefghijk\\") 11 >>> min_cost_to_make_all_chars_same(\\"a\\") 1 >>> min_cost_to_make_all_chars_same(\\"ab\\") 2 def test_min_cost_to_make_all_chars_same(): assert min_cost_to_make_all_chars_same(\\"abac\\") == 3 assert min_cost_to_make_all_chars_same(\\"aaaa\\") == 1 assert min_cost_to_make_all_chars_same(\\"abcde\\") == 5 assert min_cost_to_make_all_chars_same(\\"aabbccdd\\") == 4 assert min_cost_to_make_all_chars_same(\\"abcdefghijk\\") == 11 assert min_cost_to_make_all_chars_same(\\"a\\") == 1 assert min_cost_to_make_all_chars_same(\\"ab\\") == 2 def test_empty_string(): assert min_cost_to_make_all_chars_same(\\"\\") == 0 def test_single_char_strings(): assert min_cost_to_make_all_chars_same(\\"a\\") == 1 assert min_cost_to_make_all_chars_same(\\"z\\") == 1 def test_identical_chars(): assert min_cost_to_make_all_chars_same(\\"xxxxxxxx\\") == 1 assert min_cost_to_make_all_chars_same(\\"bbbbbbb\\") == 1 def test_two_diff_chars(): assert min_cost_to_make_all_chars_same(\\"abababab\\") == 2 assert min_cost_to_make_all_chars_same(\\"xyxyxyxy\\") == 2 def test_varied_chars(): assert min_cost_to_make_all_chars_same(\\"xyzxyzxyzxyz\\") == 3 assert min_cost_to_make_all_chars_same(\\"abcdef\\") == 6","solution":"def min_cost_to_make_all_chars_same(s): Returns the minimum cost required to make all characters in the string s the same. # Find the frequency of each character in the string freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 # The cost to make all characters the same is the total number of unique characters # As we can always replace everything to the most frequent character with the minimum cost return len(freq)"},{"question":"from typing import List def longest_substring_after_one_change(s: str) -> int: Returns the length of the longest substring that can be obtained by changing one character at most. >>> longest_substring_after_one_change(\\"aaaa\\") 4 >>> longest_substring_after_one_change(\\"abaaa\\") 5 >>> longest_substring_after_one_change(\\"abcde\\") 2 >>> longest_substring_after_one_change(\\"\\") 0 >>> longest_substring_after_one_change(\\"bbbbbb\\") 6 >>> longest_substring_after_one_change(\\"abcdef\\") 2 >>> longest_substring_after_one_change(\\"xxyyyyz\\") 5","solution":"def longest_substring_after_one_change(s): Returns the length of the longest substring that can be obtained by changing one character at most. from collections import defaultdict max_len = 0 # Helper function to calculate maximum segment with one character change def max_segment_with_one_change(char): left = 0 changes = 0 max_segment = 0 for right in range(len(s)): if s[right] != char: changes += 1 while changes > 1: if s[left] != char: changes -= 1 left += 1 max_segment = max(max_segment, right - left + 1) return max_segment # Check for all characters 'a' to 'z' for i in range(26): current_char = chr(ord('a') + i) max_len = max(max_len, max_segment_with_one_change(current_char)) return max_len"},{"question":"def min_cost_to_schedule_tasks(costs, k, time1, time2): Returns the minimum possible total cost of scheduling exactly k tasks where each worker can handle only non-overlapping tasks. Parameters: costs (list): List of integers representing the cost to schedule each task. k (int): Number of tasks to schedule. time1 (list): List of integers representing the time taken to complete each task by worker 1. time2 (list): List of integers representing the time taken to complete each task by worker 2. Returns: int: Minimum total cost to schedule exactly k tasks. >>> min_cost_to_schedule_tasks([5, 3, 8, 6], 2, [4, 2, 3, 5], [1, 7, 8, 4]) 8 >>> min_cost_to_schedule_tasks([7, 2, 1, 9], 3, [3, 1, 2, 4], [4, 2, 1, 3]) 10 >>> min_cost_to_schedule_tasks([10, 20, 30], 1, [1, 2, 3], [4, 5, 6]) 10 >>> min_cost_to_schedule_tasks([10, 20, 10], 2, [1, 1, 1], [1, 1, 1]) 20 >>> min_cost_to_schedule_tasks([3, 5, 2, 7, 1], 3, [4, 6, 5, 2, 7], [1, 3, 2, 4, 6]) 6 # Your implementation here","solution":"import heapq def min_cost_to_schedule_tasks(costs, k, time1, time2): Returns the minimum possible total cost of scheduling exactly k tasks where each worker can handle only non-overlapping tasks. Parameters: costs (list): List of integers representing the cost to schedule each task. k (int): Number of tasks to schedule. time1 (list): List of integers representing the time taken to complete each task by worker 1. time2 (list): List of integers representing the time taken to complete each task by worker 2. Returns: int: Minimum total cost to schedule exactly k tasks. # Combine costs with the minimum of time1 and time2 combined = list(zip(costs, time1, time2)) # Sort the tasks by cost sorted_combined = sorted(combined, key=lambda x: x[0]) # Use a priority queue to manage worker task assignments pq = [] worker1_end = worker2_end = 0 total_cost = 0 for i in range(k): cost, t1, t2 = sorted_combined[i] if worker1_end <= worker2_end: heapq.heappush(pq, (worker1_end + t1, 'worker1')) worker1_end += t1 else: heapq.heappush(pq, (worker2_end + t2, 'worker2')) worker2_end += t2 total_cost += cost return total_cost"},{"question":"def longest_unique_path(grid: List[List[str]]) -> int: Given a \`m x n\` grid containing characters, return the length of the longest path you can travel such that no letter is repeated on the path. You can move in four possible directions: up, down, left, or right. Note that you cannot visit the same cell more than once on a path. >>> longest_unique_path([]) == 0 >>> longest_unique_path([['a']]) == 1 >>> longest_unique_path([ ['a', 'b'], ['c', 'd'] ]) == 4 >>> longest_unique_path([ ['a', 'a'], ['a', 'a'] ]) == 1 >>> longest_unique_path([ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ]) == 9 >>> longest_unique_path([ ['a', 'b', 'c', 'e'], ['f', 'g', 'h', 'd'], ['i', 'j', 'k', 'l'] ]) == 12 >>> longest_unique_path([ ['a', 'b', 'c'], ['a', 'd', 'e'] ]) == 5","solution":"def longest_unique_path(grid): def dfs(x, y, visited): visited.add(grid[x][y]) max_length = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] not in visited: max_length = max(max_length, dfs(nx, ny, visited)) visited.remove(grid[x][y]) return max_length + 1 max_path = 0 for i in range(len(grid)): for j in range(len(grid[0])): max_path = max(max_path, dfs(i, j, set())) return max_path"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts the word into the trie. >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False >>> trie.insert(\\"app\\") >>> trie.search(\\"app\\") True pass def search(self, word: str) -> bool: Returns True if the word is in the trie, False otherwise. >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False >>> trie.insert(\\"app\\") >>> trie.search(\\"app\\") True pass # Example Usage: trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word): current_node = self.root for char in word: if char not in current_node.children: return False current_node = current_node.children[char] return current_node.is_end_of_word # Example Usage: trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root, p, q): Function to find the minimum value node that is a common ancestor of nodes p and q. pass def min_common_ancestor(root, p, q): Returns the value of the minimum value node that is a common ancestor of p and q. pass from solution import TreeNode, min_common_ancestor def create_sample_tree(): # Creating a sample tree: # 5 # / # 3 8 # / # 2 4 9 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(8) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(9) return root def test_min_common_ancestor(): root = create_sample_tree() assert min_common_ancestor(root, 2, 4) == 3, \\"Test Case 1 Failed\\" assert min_common_ancestor(root, 2, 8) == 5, \\"Test Case 2 Failed\\" assert min_common_ancestor(root, 2, 9) == 5, \\"Test Case 3 Failed\\" assert min_common_ancestor(root, 3, 4) == 3, \\"Test Case 4 Failed\\" assert min_common_ancestor(root, 9, 8) == 8, \\"Test Case 5 Failed\\" assert min_common_ancestor(root, 3, 2) == 3, \\"Test Case 6 Failed\\" print(\\"All test cases pass.\\") test_min_common_ancestor()","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root, p, q): Function to find the minimum value node that is a common ancestor of nodes p and q. if root is None: return None # If either p or q matches the root's value, this node is an ancestor. if root.val == p or root.val == q: return root # Recursively check the left and right subtrees. left_lca = find_lca(root.left, p, q) right_lca = find_lca(root.right, p, q) # If both left_lca and right_lca are non-null, this node is the common ancestor. if left_lca and right_lca: return root # Otherwise, return the non-null node. return left_lca if left_lca is not None else right_lca def min_common_ancestor(root, p, q): Returns the value of the minimum value node that is a common ancestor of p and q. lca = find_lca(root, p, q) return lca.val if lca else None"},{"question":"def nth_smallest_transformed(arr, n): Returns the nth smallest number in the transformed array, where each element can be either its original value or its negative counterpart. >>> nth_smallest_transformed([1, 3, 5], 1) == -5 >>> nth_smallest_transformed([1, 3, 5], 2) == -3 >>> nth_smallest_transformed([0, 1, 3], 3) == 0 >>> nth_smallest_transformed([3, -2, 5], 6) == 5 >>> nth_smallest_transformed([1, 1, 1], 4) == 1","solution":"def nth_smallest_transformed(arr, n): Returns the nth smallest number in the transformed array, where each element can be either its original value or its negative counterpart. transformed = [] for num in arr: transformed.append(num) transformed.append(-num) transformed.sort() return transformed[n-1]"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Reverse the order of characters in each word while preserving the order of the words. :param sentence: A string where each word is separated by a single space and consists of lowercase letters. :return: A string with each word's characters reversed. >>> reverse_words_in_sentence(\\"hello\\") \\"olleh\\" >>> reverse_words_in_sentence(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words_in_sentence(\\"the quick brown fox\\") \\"eht kciuq nworb xof\\" >>> reverse_words_in_sentence(\\"\\") \\"\\" >>> reverse_words_in_sentence(\\"a b c d\\") \\"a b c d\\" >>> reverse_words_in_sentence(\\"this is is this\\") \\"siht si si siht\\"","solution":"def reverse_words_in_sentence(sentence): Reverses the order of characters in each word while preserving the order of the words. :param sentence: A string where each word is separated by a single space :return: A string with each word's characters reversed words = sentence.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List def k_most_frequent(nums: List[int], k: int) -> List[int]: Find the k most frequent elements in the given sorted array nums. If there's a tie, the smaller elements are preferred. Return an array of length k consisting of the most frequent elements in sorted order. >>> k_most_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2] >>> k_most_frequent([1, 1, 2, 2, 3, 3, 4], 3) == [1, 2, 3] >>> k_most_frequent([4, 4, 1, 2, 2, 3, 3], 2) == [2, 3] >>> k_most_frequent([1, 2, 2, 3, 3, 4, 4], 2) == [2, 3] >>> k_most_frequent([1, 2, 2, 3, 3, 3], 1) == [3] >>> k_most_frequent([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] >>> k_most_frequent([1, 1, 2, 2, 3, 3], 5) == [1, 2, 3]","solution":"from collections import Counter def k_most_frequent(nums, k): Find the k most frequent elements in the given sorted array nums. If there's a tie, the smaller elements are preferred. Return an array of length k consisting of the most frequent elements in sorted order. # Count the frequency of each element in nums counts = Counter(nums) # Sort elements by frequency (descending) and then by value (ascending) sorted_elements = sorted(counts.items(), key=lambda x: (-x[1], x[0])) # Extract the top k most frequent elements result = [element for element, count in sorted_elements[:k]] # Return the sorted result return sorted(result)"},{"question":"def min_operations_to_normalize(s: str) -> int: Returns the minimum number of operations needed to normalize the string. >>> min_operations_to_normalize(\\"aaaa\\") == 0 >>> min_operations_to_normalize(\\"abcd\\") == 3 >>> min_operations_to_normalize(\\"ababab\\") == 5 >>> min_operations_to_normalize(\\"aabbbcc\\") == 2 >>> min_operations_to_normalize(\\"a\\") == 0 >>> min_operations_to_normalize(\\"aa\\") == 0 >>> min_operations_to_normalize(\\"aabbcc\\") == 2","solution":"def min_operations_to_normalize(s): Returns the minimum number of operations needed to normalize the string. total_operations = 0 for i in range(1, len(s)): if s[i] != s[i - 1]: total_operations += 1 return total_operations"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money the thief can rob without triggering the alarm. >>> rob([50]) 50 >>> rob([20, 30]) 30 >>> rob([10, 20, 30]) 40 >>> rob([10, 20, 30, 40]) 60 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([5, 5, 5, 5, 5]) 15 >>> rob([100, 200, 300, 400]) 600","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without triggering the alarm. :param nums: List[int] :return: int if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[-1]"},{"question":"def can_achieve_xp(xp: List[int], L: int) -> bool: Determines if the player can exactly achieve L XP by completing a subset of quests. :param xp: List of integers where xp[i] represents the XP value of the i-th quest. :param L: Integer representing the total XP needed to level up. :return: True if it's possible to achieve exactly L XP, otherwise False. >>> can_achieve_xp([1, 3, 5, 7], 8) True >>> can_achieve_xp([1, 3, 5, 7], 2) False >>> can_achieve_xp([], 5) False >>> can_achieve_xp([], 0) True >>> can_achieve_xp([5], 5) True >>> can_achieve_xp([4], 5) False >>> can_achieve_xp([1, 2, 3], 6) True >>> can_achieve_xp([1, 2, 3], 7) False >>> can_achieve_xp([10, 20, 30, 40, 50], 100) True >>> can_achieve_xp([10, 20, 30, 40, 50], 105) False","solution":"def can_achieve_xp(xp, L): Determines if the player can exactly achieve L XP by completing a subset of quests. :param xp: List of integers where xp[i] represents the XP value of the i-th quest. :param L: Integer representing the total XP needed to level up. :return: True if it's possible to achieve exactly L XP, otherwise False. n = len(xp) dp = [False] * (L + 1) dp[0] = True for x in xp: for i in range(L, x - 1, -1): dp[i] = dp[i] or dp[i - x] return dp[L]"},{"question":"from typing import List from collections import Counter def top_k_frequent(nums: List[int], k: int) -> List[int]: Given an array of integers nums and an integer k, return an array of the k most frequent elements in nums. If there are multiple elements with the same frequency, return any subset of the k elements. The solution should have a time complexity better than O(n log n), where n is the length of the input array. >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1], 1) [1] >>> top_k_frequent([], 1) [] >>> top_k_frequent([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> top_k_frequent([1, 1, 2, 2, 3], 0) [] >>> top_k_frequent([4, 4, 1, 1, 2, 2, 3], 10) [1, 2, 3, 4] pass","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Returns the k most frequent elements in the nums array. :param nums: List[int] - List of integers :param k: int - The number of most frequent elements to return :return: List[int] - List of k most frequent elements if not nums or k <= 0: return [] # Count the frequency of each element in the array count = Counter(nums) # Use a heap to find the k most frequent elements return [item for item, frequency in heapq.nlargest(k, count.items(), key=lambda x: x[1])]"},{"question":"import heapq class MedianFinder: A data structure that supports adding numbers and finding the median of the current numbers. def __init__(self): Initialize your data structure here. # max-heap for the first half of numbers self.low = [] # min-heap for the second half of numbers self.high = [] def addNum(self, num: int) -> None: Add a number into the data structure. Args: num (int): The number to be added. pass def findMedian(self) -> float: Find the median of current numbers. Returns: float: The median of the numbers. pass def test_median_finder(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1.0 mf.addNum(2) assert mf.findMedian() == 1.5 mf.addNum(3) assert mf.findMedian() == 2.0 mf.addNum(4) assert mf.findMedian() == 2.5 mf.addNum(5) assert mf.findMedian() == 3.0 def test_median_finder_with_negative_numbers(): mf = MedianFinder() mf.addNum(-1) assert mf.findMedian() == -1.0 mf.addNum(-10) assert mf.findMedian() == -5.5 mf.addNum(-3) assert mf.findMedian() == -3.0 mf.addNum(-8) assert mf.findMedian() == -5.5 mf.addNum(-2) assert mf.findMedian() == -3.0 def test_median_finder_mixed_numbers(): mf = MedianFinder() mf.addNum(10) mf.addNum(20) mf.addNum(30) mf.addNum(40) mf.addNum(50) assert mf.findMedian() == 30.0 mf.addNum(-10) assert mf.findMedian() == 25.0 mf.addNum(-20) assert mf.findMedian() == 20.0","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. # max-heap for the first half of numbers self.low = [] # min-heap for the second half of numbers self.high = [] def addNum(self, num: int) -> None: Adds a number into the data structure. # Add to max heap (invert num for max-heap behavior) heapq.heappush(self.low, -num) # Balance step: push the largest element of low to high heapq.heappush(self.high, -heapq.heappop(self.low)) # Maintain size property that max heap is allowed to have # at most one more element than the min heap if len(self.low) < len(self.high): heapq.heappush(self.low, -heapq.heappop(self.high)) def findMedian(self) -> float: Finds the median of current numbers. if len(self.low) > len(self.high): return float(-self.low[0]) else: return (-self.low[0] + self.high[0]) / 2.0"},{"question":"def min_window_substring(text: str, pattern: str) -> str: Given a string \`text\` and a string pattern consisting of distinct characters, determine the smallest substring in \`text\` that contains all the characters from \`pattern\`. If there is no such substring, return an empty string. >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window_substring(\\"a\\", \\"a\\") \\"a\\" >>> min_window_substring(\\"abc\\", \\"b\\") \\"b\\"","solution":"def min_window_substring(text, pattern): Finds the smallest substring in \`text\` containing all characters of \`pattern\`. If no such substring exists, it returns an empty string. from collections import Counter if not text or not pattern: return \\"\\" char_count = Counter(pattern) required = len(char_count) left, right = 0, 0 formed = 0 window_counts = {} min_len = float(\\"inf\\") min_left = 0 while right < len(text): char = text[right] window_counts[char] = window_counts.get(char, 0) + 1 if char in char_count and window_counts[char] == char_count[char]: formed += 1 while left <= right and formed == required: char = text[left] if right - left + 1 < min_len: min_len = right - left + 1 min_left = left window_counts[char] -= 1 if char in char_count and window_counts[char] < char_count[char]: formed -= 1 left += 1 right += 1 return \\"\\" if min_len == float(\\"inf\\") else text[min_left:min_left + min_len]"},{"question":"from typing import List def smallest_substring(s: str, queries: List[int]) -> List[str]: Given a string s and a list of queries, returns the lexicographically smallest substring for each query of length k. Args: s (str): A string consisting of only lowercase English letters. queries (List[int]): A list of integers representing the length of substrings to find. Returns: List[str]: A list of lexicographically smallest substrings for each query. >>> smallest_substring(\\"abcde\\", [2]) [\\"ab\\"] >>> smallest_substring(\\"banana\\", [3]) [\\"ana\\"] >>> smallest_substring(\\"alphabet\\", [5]) [\\"alpha\\"]","solution":"def smallest_substring(s, queries): Given a string s and a list of queries, returns the lexicographically smallest substring for each query of length k. Args: s (str): A string consisting of only lowercase English letters. queries (List[int]): A list of integers representing the length of substrings to find. Returns: List[str]: A list of lexicographically smallest substrings for each query. results = [] for k in queries: if k > len(s): results.append(\\"\\") continue min_substring = s[:k] for i in range(1, len(s) - k + 1): current_substring = s[i:i + k] if current_substring < min_substring: min_substring = current_substring results.append(min_substring) return results"},{"question":"from typing import List def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Given a list of words and a pattern, find all words that match the given pattern. A word matches the pattern if there exists a permutation of letters such that after replacing every letter in the pattern, we get the corresponding word. >>> find_and_replace_pattern([\\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") ['mee', 'aqq'] >>> find_and_replace_pattern([\\"mee\\", \\"aqq\\", \\"dkd\\"], \\"xyz\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"hjh\\"], \\"abb\\") ['mee', 'aqq'] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\", \\"aa\\", \\"bb\\"], \\"a\\") ['a', 'b', 'c'] >>> find_and_replace_pattern([\\"abc\\"], \\"abc\\") ['abc']","solution":"def find_and_replace_pattern(words, pattern): def word_pattern(word): mapping = {} pattern = [] next_char = 0 for char in word: if char not in mapping: mapping[char] = next_char next_char += 1 pattern.append(mapping[char]) return tuple(pattern) pattern_key = word_pattern(pattern) return [word for word in words if word_pattern(word) == pattern_key] # Test case words = [\\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"] pattern = \\"abb\\" print(find_and_replace_pattern(words, pattern)) # Output: [\\"mee\\", \\"aqq\\"]"},{"question":"def min_deletions_to_form_subsequence(s: str, t: str) -> int: Determines the minimum number of deletions required on string s to form t as a subsequence. Returns -1 if it's not possible to form t from s. >>> min_deletions_to_form_subsequence(\\"abcde\\", \\"ace\\") 2 >>> min_deletions_to_form_subsequence(\\"abcd\\", \\"abcd\\") 0 >>> min_deletions_to_form_subsequence(\\"xyzabcd\\", \\"xyz\\") 4 >>> min_deletions_to_form_subsequence(\\"axbycz\\", \\"abc\\") 3 >>> min_deletions_to_form_subsequence(\\"abc\\", \\"abcd\\") -1 >>> min_deletions_to_form_subsequence(\\"xyz\\", \\"abc\\") -1 >>> min_deletions_to_form_subsequence(\\"\\", \\"a\\") -1 >>> min_deletions_to_form_subsequence(\\"abc\\", \\"\\") 3 >>> min_deletions_to_form_subsequence(\\"\\", \\"\\") 0","solution":"def min_deletions_to_form_subsequence(s, t): Determines the minimum number of deletions required on string s to form t as a subsequence. Returns -1 if it's not possible to form t from s. # Pointer for tracking position in t t_index = 0 t_length = len(t) max_formable_length = 0 # Traverse through string s for char in s: if t_index < t_length and char == t[t_index]: t_index += 1 max_formable_length += 1 if max_formable_length < t_length: return -1 return len(s) - max_formable_length"},{"question":"import heapq from typing import List def min_max_completion_time(jobs: List[int], k: int) -> int: Returns the minimum possible maximum completion time of any processor given \`k\` processors and a list of \`n\` jobs with their respective completion times. >>> min_max_completion_time([5, 6, 7], 3) 7 >>> min_max_completion_time([1, 2, 3], 3) 3 >>> min_max_completion_time([4, 2, 1], 5) 4 >>> min_max_completion_time([6, 2], 5) 6 >>> min_max_completion_time([6], 5) 6 >>> min_max_completion_time([4, 3, 6, 1, 2], 1) 16 >>> min_max_completion_time([10, 2, 2, 2], 1) 16 >>> min_max_completion_time([4, 3, 6, 1, 2], 2) 8 >>> min_max_completion_time([5, 8, 8, 1, 2, 4], 2) 14 >>> min_max_completion_time([5, 8, 8, 1, 2, 4], 3) 10","solution":"import heapq def min_max_completion_time(jobs, k): Returns the minimum possible maximum completion time of any processor given \`k\` processors and a list of \`n\` jobs with their respective completion times. if k >= len(jobs): return max(jobs) # Priority queue to represent the current load of each processor processors = [0] * k heapq.heapify(processors) for job in sorted(jobs, reverse=True): least_loaded = heapq.heappop(processors) least_loaded += job heapq.heappush(processors, least_loaded) return max(processors)"},{"question":"def longest_common_substring(str1: str, str2: str) -> str: Returns the longest common substring between str1 and str2. If there are multiple with the same length, return the first one in str1. If there's no common substring, return an empty string. >>> longest_common_substring(\\"abcde\\", \\"abfde\\") == \\"ab\\" >>> longest_common_substring(\\"abcdef\\", \\"zcdemf\\") == \\"cde\\" >>> longest_common_substring(\\"abcdefg\\", \\"xyzabc\\") == \\"abc\\" >>> longest_common_substring(\\"abc\\", \\"xyz\\") == \\"\\" >>> longest_common_substring(\\"abc\\", \\"def\\") == \\"\\" >>> longest_common_substring(\\"\\", \\"abc\\") == \\"\\" >>> longest_common_substring(\\"abc\\", \\"\\") == \\"\\" >>> longest_common_substring(\\"\\", \\"\\") == \\"\\" >>> longest_common_substring(\\"ababc\\", \\"abcababc\\") == \\"ababc\\" >>> longest_common_substring(\\"ababc\\", \\"abab\\") == \\"abab\\" >>> longest_common_substring(\\"abababc\\", \\"ababcabc\\") == \\"ababc\\"","solution":"def longest_common_substring(str1, str2): Returns the longest common substring between str1 and str2. If there are multiple with the same length, return the first one in str1. If there's no common substring, return an empty string. if not str1 or not str2: return \\"\\" len1, len2 = len(str1), len(str2) longest = 0 end_pos = 0 dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > longest: longest = dp[i][j] end_pos = i else: dp[i][j] = 0 if longest == 0: return \\"\\" else: return str1[end_pos - longest:end_pos]"},{"question":"def validateBinaryTreeNodes(n: int, leftChild: list, rightChild: list) -> bool: Validates if the given binary tree with \`n\` nodes, specified by \`leftChild\` and \`rightChild\` arrays, is a valid binary tree. :param n: Number of nodes in the tree. :param leftChild: Array of left children nodes. :param rightChild: Array of right children nodes. :return: Boolean indicating if the tree is a valid binary tree. >>> validateBinaryTreeNodes(4, [1, -1, 3, -1], [2, -1, -1, -1]) True >>> validateBinaryTreeNodes(4, [1, -1, 3, -1], [2, 0, -1, -1]) False >>> validateBinaryTreeNodes(4, [1, -1, 3, -1], [2, -1, -1, -1]) True >>> validateBinaryTreeNodes(4, [1, -1, -1, -1], [2, -1, -1, -1]) False >>> validateBinaryTreeNodes(4, [1, -1, -1, -1], [-1, -1, -1, -1]) False >>> validateBinaryTreeNodes(1, [-1], [-1]) True","solution":"def validateBinaryTreeNodes(n, leftChild, rightChild): Validates if the given binary tree with \`n\` nodes, specified by \`leftChild\` and \`rightChild\` arrays, is a valid binary tree. :param n: Number of nodes in the tree. :param leftChild: Array of left children nodes. :param rightChild: Array of right children nodes. :return: Boolean indicating if the tree is a valid binary tree. in_degrees = [0] * n for i in range(n): if leftChild[i] != -1: in_degrees[leftChild[i]] += 1 if rightChild[i] != -1: in_degrees[rightChild[i]] += 1 roots = [i for i in range(n) if in_degrees[i] == 0] # There should be exactly one root if len(roots) != 1: return False visited = set() def dfs(node): if node == -1 or node in visited: return visited.add(node) dfs(leftChild[node]) dfs(rightChild[node]) # Start DFS from the root root = roots[0] dfs(root) # Ensuring all nodes are visited exactly once return len(visited) == n"},{"question":"class StockSpanner: Design an online stock span system that can calculate the span of the stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the price of the stock was less than or equal to today's price. Methods: * StockSpanner() : Initializes the StockSpanner object. * next(price: int) -> int : Returns the span of the stock's price for the current day. Example Usage: >>> ss = StockSpanner() >>> ss.next(100) 1 >>> ss.next(80) 1 >>> ss.next(60) 1 >>> ss.next(70) 2 >>> ss.next(60) 1 >>> ss.next(75) 4 >>> ss.next(85) 6 def __init__(self): pass def next(self, price: int) -> int: pass","solution":"class StockSpanner: def __init__(self): self.stack = [] # Each element is a tuple of (price, span) def next(self, price): span = 1 # Calculate the span by looking at the previous prices in the stack while self.stack and self.stack[-1][0] <= price: span += self.stack.pop()[1] # Append the current price and its span to the stack self.stack.append((price, span)) return span"},{"question":"class GroupManager: A class to manage groups in a social media platform. Methods: 1. createGroup(groupName: str) -> bool 2. addUserToGroup(groupName: str, userId: int) -> bool 3. removeUserFromGroup(groupName: str, userId: int) -> bool 4. getGroupMembers(groupName: str) -> List[int] 5. getAllGroups() -> List[str] def __init__(self): pass def createGroup(self, groupName): Creates a group with the specified groupName. Returns True if the group is successfully created, otherwise returns False if a group with the same name already exists. pass def addUserToGroup(self, groupName, userId): Adds the specified userId to the group with the specified groupName. Returns True if the user is successfully added, otherwise returns False if the group does not exist or the user is already a member of the group. pass def removeUserFromGroup(self, groupName, userId): Removes the specified userId from the group with the specified groupName. Returns True if the user is successfully removed, otherwise returns False if the group does not exist or the user is not a member of the group. pass def getGroupMembers(self, groupName): Returns a list of user IDs that are members of the group with the specified groupName. If the group does not exist, returns an empty list. pass def getAllGroups(self): Returns a list of all group names currently created in the platform, sorted in lexicographical order. pass # Unit tests def test_create_group(): gm = GroupManager() assert gm.createGroup(\\"group1\\") == True assert gm.createGroup(\\"group1\\") == False def test_add_user_to_group(): gm = GroupManager() gm.createGroup(\\"group1\\") assert gm.addUserToGroup(\\"group1\\", 1) == True assert gm.addUserToGroup(\\"group1\\", 1) == False assert gm.addUserToGroup(\\"group2\\", 2) == False def test_remove_user_from_group(): gm = GroupManager() gm.createGroup(\\"group1\\") gm.addUserToGroup(\\"group1\\", 1) assert gm.removeUserFromGroup(\\"group1\\", 1) == True assert gm.removeUserFromGroup(\\"group1\\", 1) == False assert gm.removeUserFromGroup(\\"group2\\", 1) == False def test_get_group_members(): gm = GroupManager() gm.createGroup(\\"group1\\") gm.addUserToGroup(\\"group1\\", 1) gm.addUserToGroup(\\"group1\\", 2) assert sorted(gm.getGroupMembers(\\"group1\\")) == [1, 2] assert gm.getGroupMembers(\\"group2\\") == [] def test_get_all_groups(): gm = GroupManager() gm.createGroup(\\"group1\\") gm.createGroup(\\"group2\\") gm.createGroup(\\"group3\\") assert gm.getAllGroups() == [\\"group1\\", \\"group2\\", \\"group3\\"]","solution":"class GroupManager: def __init__(self): self.groups = {} def createGroup(self, groupName): if groupName in self.groups: return False self.groups[groupName] = set() return True def addUserToGroup(self, groupName, userId): if groupName not in self.groups: return False if userId in self.groups[groupName]: return False self.groups[groupName].add(userId) return True def removeUserFromGroup(self, groupName, userId): if groupName not in self.groups or userId not in self.groups[groupName]: return False self.groups[groupName].remove(userId) return True def getGroupMembers(self, groupName): if groupName not in self.groups: return [] return list(self.groups[groupName]) def getAllGroups(self): return sorted(self.groups.keys())"},{"question":"def canReachEnd(nums: List[int]) -> bool: Determines if the frog can reach the last index. The frog can only move to a subsequent position if the steps taken are within the range specified by the current position in nums. :param nums: List[int] - list of steps the frog can take from each position :return: bool - True if the frog can reach the last index, False otherwise >>> canReachEnd([2, 3, 1, 1, 4]) == True >>> canReachEnd([3, 2, 1, 0, 4]) == False","solution":"def canReachEnd(nums): Determines if the frog can reach the last index. The frog can only move to a subsequent position if the steps taken are within the range specified by the current position in nums. :param nums: List[int] - list of steps the frog can take from each position :return: bool - True if the frog can reach the last index, False otherwise max_reach = 0 for i in range(len(nums)): if i > max_reach: return False max_reach = max(max_reach, i + nums[i]) return max_reach >= len(nums) - 1"},{"question":"def min_time_to_reach_end(heights, k): Determines the minimum time in seconds to reach the last building or returns -1 if it is not possible. Parameters: heights (List[int]): A list of integers representing the heights of buildings. k (int): The maximum number of jumps allowed. Returns: int: The minimum time in seconds to reach the last building, or -1 if it is not possible. >>> min_time_to_reach_end([5], 1) 0 >>> min_time_to_reach_end([5, 5, 5, 5], 1) 3 >>> min_time_to_reach_end([5, 4, 3, 2], 1) 3 >>> min_time_to_reach_end([5, 4, 3, 2], 3) 1 >>> min_time_to_reach_end([5, 6, 7, 8], 1) -1 >>> min_time_to_reach_end([5, 3, 4, 2, 1], 2) 2 >>> min_time_to_reach_end([5, 4, 5, 3, 2, 6, 1, 3, 0], 3) 3","solution":"def min_time_to_reach_end(heights, k): Returns the minimum time in seconds to reach the last building or -1 if it is not possible. n = len(heights) if n == 1: return 0 # Initialize the minimum time array with infinity min_time = [float('inf')] * n min_time[0] = 0 for i in range(n): for j in range(1, k + 1): if i + j < n and heights[i + j] <= heights[i]: min_time[i + j] = min(min_time[i + j], min_time[i] + 1) return -1 if min_time[-1] == float('inf') else min_time[-1]"},{"question":"from typing import List def get_kth_permutation(nums: List[int], k: int) -> List[int]: Returns the k-th permutation sequence (1-indexed) of the array of distinct integers nums. Parameters: nums (List[int]): The array of distinct integers. k (int): The index of the permutation sequence (1-indexed). Returns: List[int]: The k-th permutation sequence. Examples: >>> get_kth_permutation([1, 2, 3], 3) [2, 1, 3] >>> get_kth_permutation([1, 2, 3, 4], 9) [2, 3, 1, 4]","solution":"from math import factorial def get_kth_permutation(nums, k): Returns the k-th permutation sequence (1-indexed) of the array of distinct integers nums. Parameters: nums (List[int]): The array of distinct integers. k (int): The index of the permutation sequence (1-indexed). Returns: List[int]: The k-th permutation sequence. n = len(nums) k -= 1 # Convert k to 0-indexed permutation = [] elements = sorted(nums) for i in range(n, 0, -1): f = factorial(i - 1) index = k // f k %= f permutation.append(elements.pop(index)) return permutation"},{"question":"def search_rotated_array(arr: List[int], t: int) -> int: Searches for a target value \`t\` in a sorted and rotated array \`arr\`. If found, returns the index of \`t\`, otherwise returns -1. >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) -1","solution":"def search_rotated_array(arr, t): Searches for a target value \`t\` in a sorted and rotated array \`arr\`. If found, returns the index of \`t\`, otherwise returns -1. if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == t: return mid # If the left half is sorted if arr[left] <= arr[mid]: if arr[left] <= t < arr[mid]: right = mid - 1 else: left = mid + 1 # If the right half is sorted else: if arr[mid] < t <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def count_visible_buildings(heights): Returns the number of visible buildings in the skyline. Parameters: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The number of visible buildings from the skyline. Examples: >>> count_visible_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_visible_buildings([]) 0 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5","solution":"def count_visible_buildings(heights): Returns the number of visible buildings in the skyline. if not heights: return 0 visible_count = 0 max_height = -1 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups words that are anagrams of each other. Parameters: words (List[str]): A list of words consisting of lowercase letters. Returns: List[List[str]]: A list of lists, where each list contains words that are anagrams of each other. >>> group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"tac\\", \\"dog\\", \\"god\\"]) == [['bat', 'tab'], ['cat', 'act', 'tac'], ['dog', 'god']] >>> group_anagrams([]) == [] >>> group_anagrams([\\"bat\\", \\"cat\\", \\"dog\\"]) == [['bat'], ['cat'], ['dog']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"acb\\", \\"cba\\"]) == [['abc', 'bca', 'cab', 'bac', 'acb', 'cba']]","solution":"from collections import defaultdict def group_anagrams(words): Groups words that are anagrams of each other. Parameters: words (List[str]): A list of words consisting of lowercase letters. Returns: List[List[str]]: A list of lists, where each list contains words that are anagrams of each other. # Dictionary where the key is the sorted tuple of the word and the value is a list of anagrams anagrams = defaultdict(list) for word in words: # Sort the word to form the key sorted_word = tuple(sorted(word)) anagrams[sorted_word].append(word) # Return only the list of lists of anagrams return list(anagrams.values())"},{"question":"class QueenAttack: def __init__(self, n: int): Initializes a chessboard of size n x n. pass def bestPosition(self, blockedCells: List[Tuple[int, int]]) -> Tuple[int, int]: Returns the coordinates [row, col] of the position where the queen should be placed to maximize its attack on unattacked cells. Args: blockedCells: An array of coordinates where cells are considered as blocked and cannot be attacked. Returns: A tuple containing the row and column of the best position. Example: >>> qa = QueenAttack(8) >>> qa.bestPosition([(0, 1), (2, 2), (3, 4)]) (4, 4) pass from typing import List, Tuple def test_best_position_no_blocked_cells(): qa = QueenAttack(8) pos = qa.bestPosition([]) assert isinstance(pos, tuple), \\"The position should be a tuple.\\" assert len(pos) == 2, \\"The position should have two coordinates.\\" assert 0 <= pos[0] < 8 and 0 <= pos[1] < 8, \\"The position should be within the boundaries.\\" def test_best_position_some_blocked_cells(): blocked_cells = [(0, 1), (2, 2), (3, 4)] qa = QueenAttack(8) pos = qa.bestPosition(blocked_cells) assert isinstance(pos, tuple), \\"The position should be a tuple.\\" assert len(pos) == 2, \\"The position should have two coordinates.\\" assert 0 <= pos[0] < 8 and 0 <= pos[1] < 8, \\"The position should be within the boundaries.\\" def test_best_position_entire_row_blocked(): blocked_cells = [(0, i) for i in range(8)] qa = QueenAttack(8) pos = qa.bestPosition(blocked_cells) assert isinstance(pos, tuple), \\"The position should be a tuple.\\" assert len(pos) == 2, \\"The position should have two coordinates.\\" assert 0 <= pos[0] < 8 and 0 <= pos[1] < 8, \\"The position should be within the boundaries.\\" assert pos[0] != 0, \\"The position should not be in the blocked row.\\" def test_best_position_entire_column_blocked(): blocked_cells = [(i, 0) for i in range(8)] qa = QueenAttack(8) pos = qa.bestPosition(blocked_cells) assert isinstance(pos, tuple), \\"The position should be a tuple.\\" assert len(pos) == 2, \\"The position should have two coordinates.\\" assert 0 <= pos[0] < 8 and 0 <= pos[1] < 8, \\"The position should be within the boundaries.\\" assert pos[1] != 0, \\"The position should not be in the blocked column.\\"","solution":"class QueenAttack: def __init__(self, n): self.n = n def bestPosition(self, blockedCells): blocked = set(tuple(cell) for cell in blockedCells) max_attack = -1 best_position = (0, 0) def count_attacks(row, col): count = 0 directions = [ (1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (-1, 1), (1, -1) ] for dr, dc in directions: r, c = row + dr, col + dc while 0 <= r < self.n and 0 <= c < self.n: if (r, c) in blocked: break count += 1 r += dr c += dc return count for row in range(self.n): for col in range(self.n): if (row, col) not in blocked: current_attack = count_attacks(row, col) if current_attack > max_attack: max_attack = current_attack best_position = (row, col) return best_position"},{"question":"def min_days_to_reduce_candles(nums): Returns the minimum number of days to reduce all candles to zero height. Each integer in the list represents the height of a candle. Every day, we can choose any subset of candles and reduce their heights by one unit. When the height of a candle reaches zero, it is removed from the list. :param nums: List of non-negative integers where each integer represents the height of a candle. :return: Minimum number of days needed to reduce all candles to zero height. >>> min_days_to_reduce_candles([5]) 5 >>> min_days_to_reduce_candles([4, 2, 3, 1]) 4 >>> min_days_to_reduce_candles([]) 0 >>> min_days_to_reduce_candles([0, 0, 0]) 0 >>> min_days_to_reduce_candles([1, 2, 3, 4, 5]) 5 >>> min_days_to_reduce_candles([3, 3, 3, 3]) 3","solution":"def min_days_to_reduce_candles(nums): Returns the minimum number of days to reduce all candles to zero height. Each integer in the list represents the height of a candle. Every day, we can choose any subset of candles and reduce their heights by one unit. When the height of a candle reaches zero, it is removed from the list. :param nums: List of non-negative integers where each integer represents the height of a candle. :return: Minimum number of days needed to reduce all candles to zero height. # The minimum number of days needed is determined by the height of the tallest candle. return max(nums, default=0)"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Given a string \`s\` that represents a sequence of words separated by spaces, return the length of the longest substring that contains only unique characters. Note that only letters (both uppercase and lowercase) and digits should be considered as part of words, and spaces should be treated as delimiters. The substring should be a contiguous sequence of non-space characters. If no such substring exists, return 0. >>> length_of_longest_unique_substring(\\"abcdef\\") 6 >>> length_of_longest_unique_substring(\\"abca\\") 3 >>> length_of_longest_unique_substring(\\"abc abcd\\") 4 >>> length_of_longest_unique_substring(\\"aAbBcC\\") 6 >>> length_of_longest_unique_substring(\\"\\") 0 >>> length_of_longest_unique_substring(\\" \\") 0 >>> length_of_longest_unique_substring(\\"abc ab def ghij\\") 4","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring that contains only unique characters. max_len = 0 current_str = \\"\\" for ch in s: if ch == ' ': max_len = max(max_len, len(current_str)) current_str = \\"\\" else: if ch in current_str: while ch in current_str: current_str = current_str[1:] current_str += ch # Check the last word max_len = max(max_len, len(current_str)) return max_len"},{"question":"def weighted_sum(nums1: List[int], nums2: List[int], flag: bool) -> int: Returns the sum of elements in nums1 based on the value of flag. If flag is True, include an element from nums1 if its corresponding element in nums2 is even. If flag is False, include an element from nums1 if its corresponding element in nums2 is odd. >>> weighted_sum([3, 1, 5, 7], [4, 9, 2, 3], True) 8 >>> weighted_sum([3, 1, 5, 7], [4, 9, 2, 3], False) 8 >>> weighted_sum([], [], True) 0 >>> weighted_sum([], [], False) 0 >>> weighted_sum([1, 2, 3], [2, 4, 6], True) 6 >>> weighted_sum([1, 2, 3], [2, 4, 6], False) 0 >>> weighted_sum([1, 2, 3], [1, 3, 5], True) 0 >>> weighted_sum([1, 2, 3], [1, 3, 5], False) 6","solution":"def weighted_sum(nums1, nums2, flag): Returns the sum of elements in nums1 based on the value of flag. If flag is True, include an element from nums1 if its corresponding element in nums2 is even. If flag is False, include an element from nums1 if its corresponding element in nums2 is odd. if flag: return sum(num1 for num1, num2 in zip(nums1, nums2) if num2 % 2 == 0) else: return sum(num1 for num1, num2 in zip(nums1, nums2) if num2 % 2 != 0)"},{"question":"def find_subarray_with_sum(arr, x): Given an array of integers \`arr\` and an integer \`x\`, find a subarray of \`arr\` whose sum is exactly \`x\`. If such a subarray exists, return the starting and ending indexes of the subarray, otherwise return an empty array. The subarray should be continuous and 1-indexed. >>> find_subarray_with_sum([1, 2, 3, 7, 5], 12) == [2, 4] >>> find_subarray_with_sum([1, 2, 3, 4, 5], 20) == [] >>> find_subarray_with_sum([1, 2, 3, 7, 5], 7) == [4, 4] >>> find_subarray_with_sum([5, 2, 1, 2, 3, 2], 5) == [1, 1] >>> find_subarray_with_sum([3, 5, 9, -4, 1, -1, 10], 23) == [1, 7] pass","solution":"def find_subarray_with_sum(arr, x): Find a subarray whose sum is exactly x. Return the starting and ending indexes of the subarray in 1-indexed format. current_sum = 0 start_index = 0 for end_index in range(len(arr)): current_sum += arr[end_index] while current_sum > x and start_index <= end_index: current_sum -= arr[start_index] start_index += 1 if current_sum == x: return [start_index + 1, end_index + 1] return []"},{"question":"class CustomSet: Create a class \`CustomSet\` that implements a set-like data structure with the following methods: - add(val): Adds \`val\` to the set. - remove(val): Removes \`val\` from the set if it exists. - contains(val): Checks if \`val\` is present in the set, returning \`true\` or \`false\`. - union(otherSet): Returns a new \`CustomSet\` that contains all unique elements from both sets. - intersection(otherSet): Returns a new \`CustomSet\` that contains only the elements present in both sets. - difference(otherSet): Returns a new \`CustomSet\` that contains elements in the current set but not in \`otherSet\`. Example usage: >>> custom_set1 = CustomSet() >>> custom_set1.add(1) >>> custom_set1.add(2) >>> custom_set1.add(3) >>> custom_set1.contains(2) True >>> custom_set2 = CustomSet() >>> custom_set2.add(3) >>> custom_set2.add(4) >>> custom_set2.add(5) >>> union_set = custom_set1.union(custom_set2) >>> union_set.contains(4) True >>> intersection_set = custom_set1.intersection(custom_set2) >>> intersection_set.contains(3) True >>> difference_set = custom_set1.difference(custom_set2) >>> difference_set.contains(1) True def __init__(self): pass def add(self, val): pass def remove(self, val): pass def contains(self, val): pass def union(self, otherSet): pass def intersection(self, otherSet): pass def difference(self, otherSet): pass","solution":"class CustomSet: def __init__(self): self.elements = {} def add(self, val): self.elements[val] = True def remove(self, val): if val in self.elements: del self.elements[val] def contains(self, val): return val in self.elements def union(self, otherSet): result = CustomSet() result.elements = {**self.elements, **otherSet.elements} return result def intersection(self, otherSet): result = CustomSet() result.elements = {key: True for key in self.elements if key in otherSet.elements} return result def difference(self, otherSet): result = CustomSet() result.elements = {key: True for key in self.elements if key not in otherSet.elements} return result # Example usage custom_set1 = CustomSet() custom_set1.add(1) custom_set1.add(2) custom_set1.add(3) custom_set2 = CustomSet() custom_set2.add(3) custom_set2.add(4) custom_set2.add(5) union_set = custom_set1.union(custom_set2) intersection_set = custom_set1.intersection(custom_set2) difference_set = custom_set1.difference(custom_set2)"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Rearranges the characters in the string s such that the character at the i-th position moves to indices[i] in the resulting string. Parameters: s (str): The input string. indices (List[int]): The list of indices to rearrange the string. Returns: str: The newly rearranged string. Examples: >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) \\"leetcode\\" >>> restore_string(\\"a\\", [0]) \\"a\\" >>> restore_string(\\"abc\\", [0, 1, 2]) \\"abc\\" >>> restore_string(\\"abc\\", [2, 1, 0]) \\"cba\\" >>> restore_string(\\"\\", []) \\"\\" >>> restore_string(\\"aaaabbbb\\", [3, 2, 1, 0, 7, 6, 5, 4]) \\"aaaabbbb\\"","solution":"def restore_string(s, indices): Rearranges the characters in the string s such that the character at the i-th position moves to indices[i] in the resulting string. Parameters: s (str): The input string. indices (List[int]): The list of indices to rearrange the string. Returns: str: The newly rearranged string. n = len(s) result = [''] * n for i in range(n): result[indices[i]] = s[i] return ''.join(result)"},{"question":"class GuildManager: A class to manage the guild operations in an online multiplayer game. * GuildManager() Initializes the object of the system. * void addPlayer(int playerId) Adds a new player with the given playerId to the system. * void createGuild(int guildId) Creates a new guild with the given guildId. * boolean addPlayerToGuild(int playerId, int guildId) Adds the player with playerId to the guild with guildId. Return true if the operation is successful, false otherwise. * void addXPToPlayer(int playerId, int xp) Adds the given xp points to the player with playerId. * int getTotalXPGuild(int guildId) Returns the total XP of all players in the guild with guildId. Ensure that each player can only belong to one guild at a time and handle edge cases such as adding a player or guild that already exists. def __init__(self): pass def addPlayer(self, playerId): pass def createGuild(self, guildId): pass def addPlayerToGuild(self, playerId, guildId): pass def addXPToPlayer(self, playerId, xp): pass def getTotalXPGuild(self, guildId): pass # Unit Test import pytest def test_add_player(): gm = GuildManager() gm.addPlayer(1) assert 1 in gm.players def test_add_existing_player(): gm = GuildManager() gm.addPlayer(1) with pytest.raises(ValueError): gm.addPlayer(1) def test_create_guild(): gm = GuildManager() gm.createGuild(1) assert 1 in gm.guilds def test_create_existing_guild(): gm = GuildManager() gm.createGuild(1) with pytest.raises(ValueError): gm.createGuild(1) def test_add_player_to_guild(): gm = GuildManager() gm.addPlayer(1) gm.createGuild(1) assert gm.addPlayerToGuild(1, 1) == True assert gm.players[1]['guildId'] == 1 def test_add_player_to_nonexistent_guild(): gm = GuildManager() gm.addPlayer(1) with pytest.raises(ValueError): gm.addPlayerToGuild(1, 999) def test_add_nonexistent_player_to_guild(): gm = GuildManager() gm.createGuild(1) with pytest.raises(ValueError): gm.addPlayerToGuild(999, 1) def test_add_xp_to_player(): gm = GuildManager() gm.addPlayer(1) gm.addXPToPlayer(1, 100) assert gm.players[1]['xp'] == 100 def test_add_xp_to_nonexistent_player(): gm = GuildManager() with pytest.raises(ValueError): gm.addXPToPlayer(999, 100) def test_get_total_xp_guild(): gm = GuildManager() gm.addPlayer(1) gm.addPlayer(2) gm.createGuild(1) gm.addPlayerToGuild(1, 1) gm.addPlayerToGuild(2, 1) gm.addXPToPlayer(1, 100) gm.addXPToPlayer(2, 200) assert gm.getTotalXPGuild(1) == 300 def test_get_total_xp_nonexistent_guild(): gm = GuildManager() with pytest.raises(ValueError): gm.getTotalXPGuild(999) def test_player_in_only_one_guild(): gm = GuildManager() gm.addPlayer(1) gm.createGuild(1) gm.createGuild(2) gm.addPlayerToGuild(1, 1) assert gm.addPlayerToGuild(1, 2) == False assert gm.players[1]['guildId'] == 1","solution":"class GuildManager: def __init__(self): self.players = {} # playerId -> {xp: 0, guildId: None} self.guilds = {} # guildId -> [playerId1, playerId2, ...] def addPlayer(self, playerId): if playerId in self.players: raise ValueError(f\\"Player {playerId} already exists.\\") self.players[playerId] = {'xp': 0, 'guildId': None} def createGuild(self, guildId): if guildId in self.guilds: raise ValueError(f\\"Guild {guildId} already exists.\\") self.guilds[guildId] = [] def addPlayerToGuild(self, playerId, guildId): if playerId not in self.players: raise ValueError(f\\"Player {playerId} does not exist.\\") if guildId not in self.guilds: raise ValueError(f\\"Guild {guildId} does not exist.\\") player_data = self.players[playerId] if player_data['guildId'] is not None: return False # Player is already in a guild self.guilds[guildId].append(playerId) self.players[playerId]['guildId'] = guildId return True def addXPToPlayer(self, playerId, xp): if playerId not in self.players: raise ValueError(f\\"Player {playerId} does not exist.\\") self.players[playerId]['xp'] += xp def getTotalXPGuild(self, guildId): if guildId not in self.guilds: raise ValueError(f\\"Guild {guildId} does not exist.\\") total_xp = 0 for playerId in self.guilds[guildId]: total_xp += self.players[playerId]['xp'] return total_xp"},{"question":"from typing import List def max_sum_subarray(nums: List[int], k: int) -> List[int]: Given an array of integers nums and an integer k, return the maximum sum of a subarray of length k. If there are multiple subarrays with the same maximum sum, return the first one. >>> max_sum_subarray([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) [4, 2, 10, 23] >>> max_sum_subarray([1, 2, 3, 4, 5], 1) [5] >>> max_sum_subarray([1, 2, 3, 4, 5], 2) [4, 5] >>> max_sum_subarray([], 3) [] >>> max_sum_subarray([1, 4, 2], 5) [] >>> max_sum_subarray([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) [-1, -2]","solution":"from typing import List def max_sum_subarray(nums: List[int], k: int) -> List[int]: if not nums or k <= 0 or k > len(nums): return [] max_sum = float('-inf') current_sum = 0 max_subarray_start_index = 0 for i in range(k): current_sum += nums[i] max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum max_subarray_start_index = i - k + 1 return nums[max_subarray_start_index:max_subarray_start_index + k]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head: ListNode) -> ListNode: Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> new_head = oddEvenList(head) >>> list_to_array(new_head) == [1, 3, 5, 2, 4] True >>> head = array_to_list([]) >>> new_head = oddEvenList(head) >>> list_to_array(new_head) == [] True >>> head = array_to_list([1]) >>> new_head = oddEvenList(head) >>> list_to_array(new_head) == [1] True >>> head = array_to_list([1, 2]) >>> new_head = oddEvenList(head) >>> list_to_array(new_head) == [1, 2] True >>> head = array_to_list([2, 1, 3, 5, 6, 4, 7]) >>> new_head = oddEvenList(head) >>> list_to_array(new_head) == [2, 3, 6, 7, 1, 5, 4] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val=val self.next=next def oddEvenList(head): if not head: return head odd = head even = head.next evenHead = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenHead return head"},{"question":"from typing import List class Quadruplets: @staticmethod def findQuadruplets(nums: List[int], target: int) -> List[List[int]]: Given an integer array nums sorted in non-decreasing order, and an integer target, return all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 1. 0 <= a, b, c, d < len(nums) 2. a, b, c, and d are distinct. 3. nums[a] + nums[b] + nums[c] + nums[d] == target >>> Quadruplets.findQuadruplets([1, 0, -1, 0, -2, 2], 0) [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] >>> Quadruplets.findQuadruplets([2, 3, 1, 4, 6, -1], 50) [] >>> Quadruplets.findQuadruplets([1, 2, 3, 4], 10) [[1, 2, 3, 4]] >>> Quadruplets.findQuadruplets([1, 0, -1, 0, -2, 2, 2], 0) [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] >>> Quadruplets.findQuadruplets([0, 0, 0, 0, 0], 0) [[0, 0, 0, 0]]","solution":"from typing import List class Quadruplets: @staticmethod def findQuadruplets(nums: List[int], target: int) -> List[List[int]]: nums.sort() quadruplets = set() n = len(nums) for i in range(n - 3): for j in range(i + 1, n - 2): k, l = j + 1, n - 1 while k < l: total = nums[i] + nums[j] + nums[k] + nums[l] if total == target: quadruplets.add((nums[i], nums[j], nums[k], nums[l])) k += 1 l -= 1 elif total < target: k += 1 else: l -= 1 return [list(q) for q in quadruplets]"},{"question":"class ComplexNumber: A class to represent a complex number and perform basic operations. >>> c1 = ComplexNumber(1, 2) >>> c2 = ComplexNumber(3, 4) >>> c1.add(c2) 4 + 6i >>> c1.subtract(c2) -2 - 2i >>> c1.multiply(c2) -5 + 10i >>> c1 == ComplexNumber(1, 2) True >>> repr(c1) '1 + 2i' def __init__(self, real, imaginary): Initialize a complex number with the given real and imaginary parts. def add(self, other): Return a new complex number that is the sum of self and other. def subtract(self, other): Return a new complex number that is the difference of self and other. def multiply(self, other): Return a new complex number that is the product of self and other. def __eq__(self, other): Check if two complex numbers are equal. def __repr__(self): Return a string representation of the complex number. from solution import ComplexNumber def test_add(): c1 = ComplexNumber(1, 2) c2 = ComplexNumber(3, 4) result = c1.add(c2) assert result == ComplexNumber(4, 6) def test_subtract(): c1 = ComplexNumber(1, 2) c2 = ComplexNumber(3, 4) result = c1.subtract(c2) assert result == ComplexNumber(-2, -2) def test_multiply(): c1 = ComplexNumber(1, 2) c2 = ComplexNumber(3, 4) result = c1.multiply(c2) assert result == ComplexNumber(-5, 10) def test_eq(): c1 = ComplexNumber(1, 2) c2 = ComplexNumber(1, 2) assert c1 == c2 def test_repr(): c = ComplexNumber(1, 2) assert repr(c) == \\"1 + 2i\\"","solution":"class ComplexNumber: def __init__(self, real, imaginary): self.real = real self.imaginary = imaginary def add(self, other): return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary) def subtract(self, other): return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary) def multiply(self, other): real_part = self.real * other.real - self.imaginary * other.imaginary imaginary_part = self.real * other.imaginary + self.imaginary * other.real return ComplexNumber(real_part, imaginary_part) def __eq__(self, other): return self.real == other.real and self.imaginary == other.imaginary def __repr__(self): return f\\"{self.real} + {self.imaginary}i\\""},{"question":"def longest_increasing_subarray_length(arr: List[int]) -> int: Returns the length of the longest continuous subarray that is strictly increasing. >>> longest_increasing_subarray_length([1, 3, 5, 4, 7]) 3 >>> longest_increasing_subarray_length([10]) 1 >>> longest_increasing_subarray_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subarray_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray_length([10, 20, 30, 2, 3, 4, 5, 1, 2, 3]) 4 >>> longest_increasing_subarray_length([]) 0 >>> longest_increasing_subarray_length([3, 3, 3, 3, 3]) 1","solution":"def longest_increasing_subarray_length(arr): Returns the length of the longest continuous subarray that is strictly increasing. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len)"},{"question":"def findOverlap(intervals: List[List[int]]) -> int: Computes the total amount of time during which at least two jobs are overlapping. Args: intervals (List[List[int]]): A list of intervals, each represented by a list of two integers [start, end]. Returns: int: The total amount of time during which at least two jobs are overlapping. Example: >>> findOverlap([[1, 3], [2, 4], [5, 6]]) 1 >>> findOverlap([[1, 2], [3, 4], [5, 6]]) 0","solution":"def findOverlap(intervals): Computes the total amount of time during which at least two jobs are overlapping. if not intervals: return 0 # Generate a list of events events = [] for start, end in intervals: events.append((start, 1)) # Job starts events.append((end, -1)) # Job ends # Sort events, first by time, then by type of event to ensure end before start if at same time events.sort(key=lambda x: (x[0], x[1])) # Iterate through events to account for overlaps current_jobs = 0 overlap_time = 0 previous_time = None for time, event in events: if current_jobs >= 2: # We are in an overlap period overlap_time += time - previous_time current_jobs += event previous_time = time return overlap_time"},{"question":"def merge_alternately(word1: str, word2: str) -> str: Returns a new string formed by alternating the characters of the input strings word1 and word2. If one string is longer than the other, appends the additional characters at the end. >>> merge_alternately(\\"abc\\", \\"pqr\\") \\"apbqcr\\" >>> merge_alternately(\\"ab\\", \\"pqrs\\") \\"apbqrs\\" >>> merge_alternately(\\"abcd\\", \\"pq\\") \\"apbqcd\\" >>> merge_alternately(\\"\\", \\"xyz\\") \\"xyz\\" >>> merge_alternately(\\"abc\\", \\"\\") \\"abc\\" >>> merge_alternately(\\"\\", \\"\\") \\"\\"","solution":"def merge_alternately(word1, word2): Returns a new string formed by alternating the characters of the input strings word1 and word2. If one string is longer than the other, appends the additional characters at the end. merged = [] i, j = 0, 0 while i < len(word1) and j < len(word2): merged.append(word1[i]) merged.append(word2[j]) i += 1 j += 1 merged.extend(word1[i:]) merged.extend(word2[j:]) return ''.join(merged)"},{"question":"def coin_change(coins: List[int], target: int) -> int: Given an integer \`target\` and a list of positive integer denominations \`coins\`, return the minimum number of coins needed to make up the \`target\` amount. If it's not possible to make the \`target\` amount with the given coins, return \`-1\`. >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([2], 3) -1 >>> coin_change([1], 0) 0 >>> coin_change([2, 5], 3) -1 >>> coin_change([3, 7], 5) -1 >>> coin_change([1, 3, 4], 6) 2 >>> coin_change([1, 3, 4, 5], 7) 2 >>> coin_change([1], 1) 1 >>> coin_change([1, 2, 5], 5) 1 >>> coin_change([1, 2, 5], 100) 20","solution":"def coin_change(coins, target): Returns the minimum number of coins needed to make up the target amount. If it is not possible to make the target amount with the given coins, return -1. # Initialize a list for dynamic programming # dp[i] will be storing the minimum number of coins required for amount i dp = [float('inf')] * (target + 1) dp[0] = 0 # Base case: 0 coins are needed to make amount 0 # Iterate over each amount from 1 to target for i in range(1, target + 1): for coin in coins: if coin <= i: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[target] if dp[target] != float('inf') else -1"},{"question":"def convert(inputString: str, numRows: int) -> str: Convert the inputString into a zigzag pattern with the given number of rows and return the string read line by line. >>> convert(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" >>> convert(\\"ABCDEFGHI\\", 1) == \\"ABCDEFGHI\\" >>> convert(\\"AB\\", 3) == \\"AB\\" >>> convert(\\"ABCDEFGH\\", 2) == \\"ACEGBDFH\\" >>> convert(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\"","solution":"def convert(inputString, numRows): Convert the inputString into a zigzag pattern with the given number of rows and return the string read line by line. if numRows == 1 or numRows >= len(inputString): return inputString rows = [''] * numRows current_row = 0 going_down = False for char in inputString: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return ''.join(rows)"},{"question":"import re from collections import Counter class MostCommonWord: def __init__(self, paragraph: str, banned: List[str]): Initialize with a paragraph and a list of banned words. self.paragraph = paragraph self.banned = banned def mostCommonNonBannedWord(self) -> str: Return the most frequently occurring word in the paragraph that is not banned. >>> comment = \\"Bob hit a ball, the hit BALL flew far after it was hit.\\" >>> banned = [\\"hit\\"] >>> mcw = MostCommonWord(comment, banned) >>> mcw.mostCommonNonBannedWord() \\"ball\\" >>> comment = \\"Bob hit hit a ball, the ball ball flew far after it was hit hit.\\" >>> banned = [\\"hit\\"] >>> mcw = MostCommonWord(comment, banned) >>> mcw.mostCommonNonBannedWord() \\"ball\\" pass","solution":"import re from collections import Counter class MostCommonWord: def __init__(self, paragraph, banned): self.paragraph = paragraph self.banned = banned def mostCommonNonBannedWord(self): # Normalize the paragraph by converting to lowercase and removing punctuation filtered_paragraph = re.sub(r'[^ws]', ' ', self.paragraph).lower() # Split the filtered paragraph into words words = filtered_paragraph.split() # Create a count of each word, ignoring those that are banned word_counts = Counter(word for word in words if word not in self.banned) # Get the word with the highest count most_common_word = word_counts.most_common(1)[0][0] return most_common_word"},{"question":"def count_less_or_equal(nums, queries): Given an array of integers nums and a list of queries, each consisting of a single integer x, return an array of the number of integers in the array that are less than or equal to x for each query. Args: nums: List[int] - List of integers. queries: List[int] - List of queries. Returns: List[int] - List of results for each query.","solution":"def count_less_or_equal(nums, queries): Given an array of integers nums and a list of queries, each consisting of a single integer x, return an array of the number of integers in the array that are less than or equal to x for each query. Args: nums: List[int] - List of integers. queries: List[int] - List of queries. Returns: List[int] - List of results for each query. nums.sort() results = [] for query in queries: count = 0 for num in nums: if num <= query: count += 1 else: break results.append(count) return results"},{"question":"def min_subarrays(nums: List[int], threshold: int) -> int: Returns the minimum number of subarrays needed such that the sum of each subarray does not exceed the threshold. >>> min_subarrays([5], 5) 1 >>> min_subarrays([1, 2, 3], 6) 1 >>> min_subarrays([1, 2, 3], 5) 2 >>> min_subarrays([1, 2, 3, 4], 5) 3 >>> min_subarrays([1, 2, 3, 4, 5], 100) 1 >>> min_subarrays([1, 2, 3, 4, 1, 1, 1], 5) 4 >>> min_subarrays([10, 20, 30], 25) 3 >>> min_subarrays([5, 5, 5], 5) 3","solution":"def min_subarrays(nums, threshold): Returns the minimum number of subarrays needed such that the sum of each subarray does not exceed threshold. current_sum = 0 count = 1 for num in nums: if current_sum + num > threshold: count += 1 current_sum = num else: current_sum += num return count"},{"question":"def max_transformable_strings(words: List[str], targetWord: str, k: int) -> int: Returns the maximum number of strings from the words array that can be transformed to match the targetWord by changing at most k characters in each string. >>> max_transformable_strings([\\"abc\\", \\"abd\\", \\"abf\\"], \\"abc\\", 0) 1 >>> max_transformable_strings([\\"abc\\", \\"abd\\", \\"abf\\"], \\"abc\\", 1) 3 >>> max_transformable_strings([\\"abc\\", \\"def\\", \\"ghi\\"], \\"abc\\", 2) 1 >>> max_transformable_strings([\\"xyz\\", \\"uvw\\", \\"rst\\"], \\"abc\\", 1) 0 >>> max_transformable_strings([], \\"abc\\", 1) 0","solution":"def max_transformable_strings(words, targetWord, k): Returns the maximum number of strings from the words array that can be transformed to match the targetWord by changing at most k characters in each string. def can_transform(word, target, k): changes_needed = sum(1 for wc, tc in zip(word, target) if wc != tc) return changes_needed <= k count = 0 for word in words: if can_transform(word, targetWord, k): count += 1 return count"},{"question":"def min_meeting_rooms(meetings: List[List[int]]) -> int: Returns the minimum number of meeting rooms required to hold all the meetings without any overlaps. Args: meetings (List[List[int]]): A list of meetings where each meeting is represented as [start, end]. Returns: int: The minimum number of meeting rooms required. pass # Example unit tests def test_no_meetings(): assert min_meeting_rooms([]) == 0 def test_one_meeting(): assert min_meeting_rooms([[10, 20]]) == 1 def test_non_overlapping_meetings(): assert min_meeting_rooms([[10, 20], [30, 40], [50, 60]]) == 1 def test_overlapping_meetings(): assert min_meeting_rooms([[10, 20], [15, 25], [20, 30]]) == 2 def test_nested_meetings(): assert min_meeting_rooms([[10, 50], [20, 40], [30, 60]]) == 3 def test_all_rooms_needed(): assert min_meeting_rooms([[10, 20], [10, 20], [10, 20]]) == 3 def test_partial_overlap(): assert min_meeting_rooms([[10, 15], [12, 20], [18, 25]]) == 2 def test_consecutive_meetings(): assert min_meeting_rooms([[10, 20], [20, 30], [30, 40]]) == 1","solution":"def min_meeting_rooms(meetings): Returns the minimum number of meeting rooms required to hold all the meetings without any overlaps. Args: meetings (List[List[int]]): A list of meetings where each meeting is represented as [start, end]. Returns: int: The minimum number of meeting rooms required. if not meetings: return 0 start_times = sorted(meeting[0] for meeting in meetings) end_times = sorted(meeting[1] for meeting in meetings) start_pointer = end_pointer = 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(meetings): if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"def convertToTitle(n: int) -> str: Given a non-negative integer n, convert it to its corresponding column title as it would appear in an Excel spreadsheet. >>> convertToTitle(1) \\"A\\" >>> convertToTitle(27) \\"AA\\" >>> convertToTitle(701) \\"ZY\\"","solution":"def convertToTitle(n): Given a non-negative integer n, convert it to its corresponding column title as it would appear in an Excel spreadsheet. result = \\"\\" while n > 0: n -= 1 # Adjusting n to be zero-indexed result = chr(n % 26 + ord('A')) + result n //= 26 return result"},{"question":"class MatrixOperations: def __init__(self, matrix: List[List[int]]): Initializes the object with the integer matrix \`matrix\`. pass def rotate(self) -> None: Rotates the entire matrix clockwise by 90 degrees. pass def reflect(self) -> None: Reflects the matrix along its main diagonal. pass def getMatrix(self) -> List[List[int]]: Returns the current state of the matrix after all operations have been performed. pass Unit Test: import pytest from solution import MatrixOperations def test_rotate(): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] mo = MatrixOperations(matrix) mo.rotate() assert mo.getMatrix() == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def test_reflect(): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] mo = MatrixOperations(matrix) mo.reflect() assert mo.getMatrix() == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] def test_rotate_and_reflect(): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] mo = MatrixOperations(matrix) mo.rotate() mo.reflect() assert mo.getMatrix() == [[7, 8, 9], [4, 5, 6], [1, 2, 3]] def test_empty_matrix(): matrix = [] mo = MatrixOperations(matrix) assert mo.getMatrix() == [] def test_single_element_matrix(): matrix = [[1]] mo = MatrixOperations(matrix) mo.rotate() assert mo.getMatrix() == [[1]] mo.reflect() assert mo.getMatrix() == [[1]]","solution":"class MatrixOperations: def __init__(self, matrix): Initializes the object with the integer matrix. self.matrix = matrix def rotate(self): Rotates the entire matrix clockwise by 90 degrees. n = len(self.matrix) # First, reverse the rows of the matrix. self.matrix.reverse() # Then, swap the symmetry along the diagonal. for i in range(n): for j in range(i + 1, n): self.matrix[i][j], self.matrix[j][i] = self.matrix[j][i], self.matrix[i][j] def reflect(self): Reflects the matrix along its main diagonal. n = len(self.matrix) for i in range(n): for j in range(i): self.matrix[i][j], self.matrix[j][i] = self.matrix[j][i], self.matrix[i][j] def getMatrix(self): Returns the current state of the matrix after all operations have been performed. return self.matrix"},{"question":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray containing at most two distinct integers. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) == 4 >>> longest_subarray_with_two_distinct([1]) == 1 >>> longest_subarray_with_two_distinct([1, 2]) == 2 >>> longest_subarray_with_two_distinct([1, 1, 1, 1]) == 4 >>> longest_subarray_with_two_distinct([1, 2, 1, 3, 4]) == 3 >>> longest_subarray_with_two_distinct([4, 1, 1, 2, 1, 1, 3, 4]) == 5 >>> longest_subarray_with_two_distinct([]) == 0 >>> large_input = [1, 2] * 5000 + [3, 4] * 5000 >>> longest_subarray_with_two_distinct(large_input) == 10000 pass","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray containing at most two distinct integers. from collections import defaultdict n = len(nums) if n == 0: return 0 left = 0 max_len = 0 count = defaultdict(int) for right in range(n): count[nums[right]] += 1 while len(count) > 2: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def maxArea(height: List[int]) -> int: Given an array of integers height representing the height of a vertical line at each index, compute the maximum area of water that can be held between two lines. Two lines form a container such that the container cannot tilt, and the area of water it holds is calculated by the shorter line's height multiplied by the distance between the lines. >>> maxArea([1,8,6,2,5,4,8,3,7]) 49 >>> maxArea([1, 1]) 1 >>> maxArea([6,5,4,3,2,1]) 9 >>> maxArea([1,2,3,4,5,6]) 9 >>> maxArea([0,2,0,4,0,6,0,8,0]) 16 >>> maxArea([5, 5, 5, 5, 5, 5]) 25 >>> maxArea([2, 3, 10, 5, 7, 8, 9]) 36","solution":"from typing import List def maxArea(height: List[int]) -> int: Computes the maximum area of water that can be held between two lines represented by height array. left, right = 0, len(height) - 1 max_area = 0 while left < right: h = min(height[left], height[right]) w = right - left max_area = max(max_area, h * w) if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def treeToDoublyList(root): Converts a binary tree to a doubly linked list in-place following the in-order traversal. Args: root (Node): The root of the binary tree. Returns: Node: The head of the created doubly linked list. pass # Unit tests def test_empty_tree(): assert treeToDoublyList(None) == None def test_single_node_tree(): node = Node(1) head = treeToDoublyList(node) assert head == node assert head.right == head assert head.left == head def test_two_node_tree(): node1 = Node(1) node2 = Node(2) node1.right = node2 head = treeToDoublyList(node1) assert head == node1 assert head.right == node2 assert node2.left == head assert head.left == node2 assert node2.right == head def test_three_node_tree(): node1 = Node(1) node2 = Node(2) node3 = Node(3) node2.left = node1 node2.right = node3 head = treeToDoublyList(node2) assert head == node1 assert head.right == node2 assert node2.left == head assert node2.right == node3 assert node3.left == node2 assert head.left == node3 assert node3.right == head def test_large_tree(): nodes = [Node(i) for i in range(1, 8)] nodes[3].left = nodes[1] nodes[3].right = nodes[5] nodes[1].left = nodes[0] nodes[1].right = nodes[2] nodes[5].left = nodes[4] nodes[5].right = nodes[6] head = treeToDoublyList(nodes[3]) current = head for i in range(7): assert current.val == i + 1 current = current.right # Check circularity assert current == head for i in range(6, -1, -1): current = current.left assert current.val == i + 1 assert current == head","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def treeToDoublyList(root): Converts a binary tree to a doubly linked list in-place following the in-order traversal. Args: root (Node): The root of the binary tree. Returns: Node: The head of the created doubly linked list. if not root: return None def convert(node): nonlocal last, first if node: # In-order traversal: left convert(node.left) # Link the previous node (last) with the current node (node) if last: last.right = node node.left = last else: # We found the leftmost node which is now head of the list first = node last = node # In-order traversal: right convert(node.right) first, last = None, None convert(root) # Close the doubly linked list to make it circular if last and first: last.right = first first.left = last return first"},{"question":"def countStrings(n: int) -> int: Given an integer 'n', return the number of strings of length 'n' that are composed solely of the characters '0' and '1' and do not contain consecutive '1's. >>> countStrings(3) 5 >>> countStrings(4) 8 >>> countStrings(0) 1 >>> countStrings(1) 2 >>> countStrings(2) 3 >>> countStrings(5) 13 >>> countStrings(6) 21","solution":"def countStrings(n): Returns the number of strings of length n that are composed solely of the characters '0' and '1' and do not contain consecutive '1's. if n == 0: return 1 if n == 1: return 2 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 2 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"def my_atoi(s: str) -> int: Convert a given string to a 32-bit signed integer. If conversion is not possible, return 0. >>> my_atoi(\\" 42\\") 42 >>> my_atoi(\\"- 42\\") 0 >>> my_atoi(\\"+1\\") 1 >>> my_atoi(\\"-1\\") -1 >>> my_atoi(\\"2147483648\\") 2147483647 # INT_MAX + 1 >>> my_atoi(\\"-2147483649\\") -2147483648 # INT_MIN - 1 >>> my_atoi(\\"abc\\") 0 >>> my_atoi(\\" \\") 0 >>> my_atoi(\\"\\") 0 >>> my_atoi(\\"4193 with words\\") 4193 >>> my_atoi(\\"words and 987\\") 0 >>> my_atoi(\\"-91283472332\\") -2147483648 >>> my_atoi(\\"3.14159\\") 3 >>> my_atoi(\\"+-2\\") 0","solution":"def my_atoi(s: str) -> int: Convert a given string to a 32-bit signed integer. If conversion is not possible, return 0. s = s.strip() # Remove leading and trailing whitespaces if not s: return 0 i = 0 sign = 1 result = 0 INT_MAX = 2**31 - 1 INT_MIN = -2**31 # Check the sign if s[i] == '+' or s[i] == '-': sign = -1 if s[i] == '-' else 1 i += 1 # Convert digits to an integer while i < len(s) and s[i].isdigit(): result = result * 10 + int(s[i]) i += 1 result *= sign # Clamp the result within the 32-bit signed integer range if result < INT_MIN: return INT_MIN if result > INT_MAX: return INT_MAX return result"},{"question":"def minMeetingRooms(startTimes, endTimes): Determine the minimum number of meeting rooms required to accommodate all the meetings. Parameters: startTimes (list): List of start times of the meetings. endTimes (list): List of end times of the meetings. Returns: int: Minimum number of meeting rooms required. >>> minMeetingRooms([], []) == 0 >>> minMeetingRooms([9], [10]) == 1 >>> minMeetingRooms([9, 11, 13], [10, 12, 14]) == 1 >>> minMeetingRooms([9, 9, 9], [10, 11, 12]) == 3 >>> minMeetingRooms([9, 10, 11], [11, 12, 13]) == 2 >>> minMeetingRooms([1, 3, 6, 8], [4, 5, 7, 9]) == 2 >>> minMeetingRooms([1, 2, 3, 4], [2, 3, 4, 5]) == 1","solution":"def minMeetingRooms(startTimes, endTimes): Determine the minimum number of meeting rooms required to accommodate all the meetings. Parameters: startTimes (list): List of start times of the meetings. endTimes (list): List of end times of the meetings. Returns: int: Minimum number of meeting rooms required. if not startTimes or not endTimes or len(startTimes) != len(endTimes): return 0 # Sort the start and end times startTimes.sort() endTimes.sort() start_pointer = 0 end_pointer = 0 rooms = 0 max_rooms = 0 while start_pointer < len(startTimes): if startTimes[start_pointer] < endTimes[end_pointer]: rooms += 1 start_pointer += 1 else: rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, rooms) return max_rooms"},{"question":"def minimum_arrows(heights): Returns the minimum number of arrows required to eliminate all trees. Parameters: heights (list): A list of integers representing the height of trees. Returns: int: The minimum number of arrows required. Examples: >>> minimum_arrows([4, 3, 5, 1, 2]) 5 >>> minimum_arrows([3, 4, 4, 5, 5, 6]) 4 >>> minimum_arrows([3, 3, 3, 3, 3]) 1 >>> minimum_arrows([]) 0 >>> minimum_arrows([5]) 1","solution":"def minimum_arrows(heights): Returns the minimum number of arrows required to eliminate all trees. Parameters: heights (list): A list of integers representing the height of trees. Returns: int: The minimum number of arrows required. return len(set(heights))"},{"question":"def wave_sequence(nums: List[int]) -> List[int]: Rearranges the elements of the list into a wave sequence. A wave sequence is one such that for any two consecutive integers a and b, either a >= b or a <= b. The sequence is the lexicographically smallest possible wave sequence. :param nums: List of non-negative integers :return: List of integers in wave sequence order >>> wave_sequence([3, 6, 5, 10, 7, 20]) == [5, 3, 7, 6, 20, 10] >>> wave_sequence([1, 2, 3, 4, 5, 6]) == [2, 1, 4, 3, 6, 5] >>> wave_sequence([2, 2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2, 2] >>> wave_sequence([1]) == [1] >>> wave_sequence([4, 2]) == [4, 2] >>> wave_sequence([4, 2, 2, 3, 1, 3]) == [2, 1, 3, 2, 4, 3]","solution":"def wave_sequence(nums): Rearranges the elements of the list into a wave sequence. A wave sequence is one such that for any two consecutive integers a and b, either a >= b or a <= b. The sequence is the lexicographically smallest possible wave sequence. :param nums: List of non-negative integers :return: List of integers in wave sequence order # Sort \`nums\` to get the lexicographically smallest permutation nums.sort() # Swap adjacent elements to create the wave pattern for i in range(0, len(nums) - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"question":"from typing import List def partition_labels(s: str) -> List[int]: Partitions the given string such that each letter appears in at most one part. Returns a list of integers representing the length of each part. Parameters: s (str): The input string consisting of lowercase English letters. Returns: List[int]: The list of lengths of each partitioned part. >>> partition_labels(\\"a\\") == [1] >>> partition_labels(\\"aaaa\\") == [4] >>> partition_labels(\\"abacbc\\") == [6] >>> partition_labels(\\"abcdef\\") == [1, 1, 1, 1, 1, 1] >>> partition_labels(\\"ababcbacadefegdehijhklij\\") == [9, 7, 8] pass","solution":"def partition_labels(s): Partitions the given string such that each letter appears in at most one part. Returns a list of integers representing the length of each part. Parameters: s (str): The input string consisting of lowercase English letters. Returns: List[int]: The list of lengths of each partitioned part. # Record the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(s)} result = [] start, end = 0, 0 for index, char in enumerate(s): # Update the end boundary of the current part end = max(end, last_occurrence[char]) # If the current index reaches the end boundary if index == end: # Append the length of the current part result.append(end - start + 1) # Move the start to the next index after the current part start = index + 1 return result"},{"question":"def sum_last_level_nodes(tree: List[int]) -> int: Given a binary tree represented in an array-form, where for each node at index \`i\`, the left child is at index \`2*i + 1\` and the right child is at index \`2*i + 2\`, return the sum of values of all nodes that are at the last level of the binary tree. >>> sum_last_level_nodes([]) == 0 >>> sum_last_level_nodes([10]) == 10 >>> sum_last_level_nodes([1, 2, 3]) == 5 >>> sum_last_level_nodes([1, 2, 3, 4, 5, 6, 7]) == 22 >>> sum_last_level_nodes([1, 2, 3, 4, 5, 6]) == 15 >>> tree = [i for i in range(1, 32)] >>> sum_last_level_nodes(tree) == sum(range(16, 32))","solution":"def sum_last_level_nodes(tree): if not tree: return 0 level = 0 while (1 << level) - 1 < len(tree): level += 1 last_level_start = (1 << (level - 1)) - 1 return sum(tree[last_level_start:])"},{"question":"def split_string_into_k_substrings(s: str, k: int) -> List[str]: Splits a string into k non-empty substrings such that no two substrings are the same. Each substring contains at least one word, and words maintain their original order. Args: s (str): The input string containing words separated by spaces. k (int): The number of substrings to split into. Returns: list: A list of k substrings or an empty list if such a split is not possible. import pytest def test_sample_case_1(): assert split_string_into_k_substrings(\\"the quick brown fox jumps over the lazy dog\\", 2) == [\\"the brown jumps the dog\\", \\"quick fox over lazy\\"] def test_sample_case_2(): assert split_string_into_k_substrings(\\"one two three four five\\", 5) == [\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\"] def test_sample_case_3(): assert split_string_into_k_substrings(\\"apple banana cherry\\", 4) == [] def test_only_one_substring_needed(): assert split_string_into_k_substrings(\\"a b c d e\\", 1) == [\\"a b c d e\\"] def test_insufficient_words(): assert split_string_into_k_substrings(\\"one two\\", 3) == [] def test_unique_substrings_not_possible(): assert split_string_into_k_substrings(\\"aaa aaa aaa aaa\\", 2) == []","solution":"def split_string_into_k_substrings(s, k): Splits a string into k non-empty substrings such that no two substrings are the same. Each substring contains at least one word, and words maintain their original order. Args: s (str): The input string containing words separated by spaces. k (int): The number of substrings to split into. Returns: list: A list of k substrings or an empty list if such a split is not possible. words = s.split() # If there are not enough words to create k non-empty substrings if len(words) < k: return [] result = [''] * k index = 0 # Distribute words in a round-robin fashion for word in words: result[index] += word + ' ' index = (index + 1) % k # Remove trailing spaces result = [substring.strip() for substring in result] # Ensure all substrings are unique if len(set(result)) != k: return [] return result"},{"question":"def subarray_sum_exists(nums: List[int], target: int) -> bool: Returns True if there exists a contiguous subarray within nums that sums exactly to target, otherwise returns False. >>> subarray_sum_exists([1, 2, 3, 4, 5], 9) True >>> subarray_sum_exists([1, 2, 3, 4, 5], 11) False >>> subarray_sum_exists([5], 5) True >>> subarray_sum_exists([5], 1) False >>> subarray_sum_exists([1, 2, 3, 7, 5], 12) True >>> subarray_sum_exists([-1, -2, -3, -4], -5) True >>> subarray_sum_exists([3, 4, -7, 1], 1) True >>> subarray_sum_exists([], 1) False >>> subarray_sum_exists([1, 2, -3, 4, -4], 0) True","solution":"def subarray_sum_exists(nums, target): Returns True if there exists a contiguous subarray within nums that sums exactly to target, otherwise returns False. current_sum = 0 seen_sums = {0} # Initialize with 0 to handle cases where subarray starts from index 0 for num in nums: current_sum += num if (current_sum - target) in seen_sums: return True seen_sums.add(current_sum) return False"},{"question":"def sentence_with_most_words(paragraph: str) -> str: Returns the sentence with the most number of words from the given paragraph. If multiple sentences have the same number of words, returns the first one. :param paragraph: A string containing multiple sentences separated by periods. :return: The sentence with the most number of words. pass # Test cases def test_single_sentence(): paragraph = \\"This is a single sentence.\\" assert sentence_with_most_words(paragraph) == \\"This is a single sentence\\" def test_multiple_sentences(): paragraph = \\"This is a sentence. This is another sentence with more words.\\" assert sentence_with_most_words(paragraph) == \\"This is another sentence with more words\\" def test_sentences_with_equal_words(): paragraph = \\"First sentence here. Another one now.\\" assert sentence_with_most_words(paragraph) == \\"First sentence here\\" def test_empty_sentences(): paragraph = \\"This is a test. . Another sentence.\\" assert sentence_with_most_words(paragraph) == \\"This is a test\\" def test_no_sentences(): paragraph = \\"\\" assert sentence_with_most_words(paragraph) == \\"\\"","solution":"def sentence_with_most_words(paragraph): Returns the sentence with the most number of words from the given paragraph. If multiple sentences have the same number of words, returns the first one. :param paragraph: A string containing multiple sentences separated by periods. :return: The sentence with the most number of words. sentences = paragraph.split('.') max_word_count = 0 sentence_with_max_words = \\"\\" for sentence in sentences: words = sentence.strip().split() word_count = len(words) if word_count > max_word_count: max_word_count = word_count sentence_with_max_words = sentence.strip() return sentence_with_max_words"},{"question":"def max_reduced_height(towers: List[int]) -> int: Given a list of non-negative integers representing tower heights, returns the maximum possible height to which all towers can be reduced. >>> max_reduced_height([10]) == 10 >>> max_reduced_height([4, 4, 4]) == 4 >>> max_reduced_height([5, 7, 3, 9]) == 3 >>> max_reduced_height([10, 0, 5]) == 0 >>> max_reduced_height([]) == 0 >>> max_reduced_height([15, 25, 35, 20, 10, 5]) == 5","solution":"def max_reduced_height(towers): Given a list of non-negative integers representing tower heights, returns the maximum possible height to which all towers can be reduced. if not towers: return 0 return min(towers)"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of water that has accumulated between the buildings after the rainfall. >>> trap([]) 0 >>> trap([0, 1, 2, 3, 4, 5]) 0 >>> trap([3, 3, 3, 3]) 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([0]) 0 >>> trap([5]) 0 >>> trap([0, 2]) 0 >>> trap([2, 0]) 0 >>> trap([2, 2, 2, 2, 2]) 0 pass","solution":"def trap(height): Calculate the total amount of water that has accumulated between the buildings after the rainfall. :param height: List[int] - List of non-negative integers representing the heights of the buildings. :return: int - The total trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def are_anagrams(s: str, t: str) -> bool: Determine if two strings s and t are anagrams of each other. Case-insensitive and ignores spaces and punctuation. >>> are_anagrams(\\"anagram\\", \\"nagaram\\") == True >>> are_anagrams(\\"rat\\", \\"car\\") == False >>> are_anagrams(\\"anagram\\", \\"nag a ram\\") == True >>> are_anagrams(\\"a!na.gram?\\", \\"na?gar!am.\\") == True >>> are_anagrams(\\"AnAgRAM\\", \\"naGarAM\\") == True >>> are_anagrams(\\"anagram\\", \\"nagarams\\") == False >>> are_anagrams(\\"\\", \\"\\") == True >>> are_anagrams(\\"\\", \\"a\\") == False >>> are_anagrams(\\"a\\", \\"\\") == False >>> are_anagrams(\\"123anagram123\\", \\"nagaram!123\\") == True >>> are_anagrams(\\"!!!!\\", \\"???\\") == True >>> are_anagrams(\\"ab1c@#\\", \\"ca1b\\") == True","solution":"import re from collections import Counter def are_anagrams(s, t): Determine if two strings s and t are anagrams of each other. Case-insensitive and ignores spaces and punctuation. # Remove non-alphabetic characters and convert to lowercase clean_s = re.sub(r'[^a-zA-Z]', '', s).lower() clean_t = re.sub(r'[^a-zA-Z]', '', t).lower() # Return true if the character counts match return Counter(clean_s) == Counter(clean_t)"},{"question":"def minimum_operations_to_empty(s: str) -> int: Returns the minimum number of operations required to make the string empty by removing palindromic substrings. >>> minimum_operations_to_empty(\\"a\\") 1 >>> minimum_operations_to_empty(\\"abba\\") 1 >>> minimum_operations_to_empty(\\"abc\\") 2 >>> minimum_operations_to_empty(\\"ab\\") 2 >>> minimum_operations_to_empty(\\"racecar\\") 1 >>> minimum_operations_to_empty(\\"abacdfgdcaba\\") 2","solution":"def minimum_operations_to_empty(s): Returns the minimum number of operations required to make the string empty by removing palindromic substrings. # A single character is always a palindrome. if s == s[::-1]: return 1 return 2"},{"question":"def max_lex_string(s: str) -> str: Returns the lexicographically largest string obtainable by repeatedly replacing two adjacent characters with the maximum of the two. >>> max_lex_string(\\"abc\\") 'ccc' >>> max_lex_string(\\"dbca\\") 'dddd' >>> max_lex_string(\\"cab\\") 'ccc' >>> max_lex_string(\\"abcabcabc\\") 'ccccccccc' >>> max_lex_string(\\"zzzaa\\") 'zzzzz' >>> max_lex_string(\\"abcdefghijklmn\\") 'nnnnnnnnnnnnnn' >>> max_lex_string(\\"\\") ''","solution":"def max_lex_string(s): Returns the lexicographically largest string obtainable by repeatedly replacing two adjacent characters with the maximum of the two. :param s: a string containing only lowercase English letters :return: a string representing the lexicographically largest string obtainable if not s: return '' # The lexicographically largest string would be the string where all characters are the maximum. # Since we can always choose the maximum of adjacent characters and shrink the string towards the maximum character. return max(s) * len(s)"},{"question":"def transformable_words(words: List[str], target: str) -> List[str]: Returns a list of words from the input list \`words\` that can be rearranged to form the \`target\` string, sorted in ascending order. >>> transformable_words([\\"cat\\", \\"dog\\", \\"tac\\", \\"god\\"], \\"act\\") [\\"cat\\", \\"tac\\"] >>> transformable_words([\\"cat\\", \\"dog\\", \\"bird\\"], \\"horse\\") [] >>> transformable_words([\\"a\\", \\"b\\", \\"ab\\", \\"ba\\"], \\"ab\\") [\\"ab\\", \\"ba\\"] >>> transformable_words([], \\"act\\") [] >>> transformable_words([\\"cat\\", \\"dog\\"], \\"\\") [] >>> transformable_words([], \\"\\") [] >>> transformable_words([\\"Cat\\", \\"Tac\\"], \\"act\\") [] >>> transformable_words([\\"abc\\", \\"cab\\", \\"bca\\"], \\"abc\\") [\\"abc\\", \\"bca\\", \\"cab\\"] >>> transformable_words([\\"a!b\\", \\"b!a\\"], \\"!ab\\") [\\"a!b\\", \\"b!a\\"]","solution":"def transformable_words(words, target): Returns a list of words from the input list \`words\` that can be rearranged to form the \`target\` string, sorted in ascending order. sorted_target = sorted(target) result = [word for word in words if sorted(word) == sorted_target] return sorted(result)"},{"question":"def count_substrings(s: str, k: int, n: int) -> int: Counts the number of distinct substrings of length k that appear at least n times in s. Args: - s (str): The input string consisting of only lowercase English letters. - k (int): The length of substrings to consider. - n (int): The minimum number of times a substring must appear. Returns: - int: The number of distinct substrings of length k that appear at least n times. >>> count_substrings(\\"banana\\", 2, 2) 2 >>> count_substrings(\\"abcdef\\", 2, 2) 0 >>> count_substrings(\\"aaabaaab\\", 2, 3) 1 >>> count_substrings(\\"abcdef\\", 6, 1) 1 >>> count_substrings(\\"abcd\\", 5, 1) 0 >>> count_substrings(\\"aaaaa\\", 2, 2) 1","solution":"def count_substrings(s, k, n): Counts the number of distinct substrings of length k that appear at least n times in s. Args: - s (str): The input string consisting of only lowercase English letters. - k (int): The length of substrings to consider. - n (int): The minimum number of times a substring must appear. Returns: - int: The number of distinct substrings of length k that appear at least n times. from collections import defaultdict substring_count = defaultdict(int) # Traverse the string to find all substrings of length k for i in range(len(s) - k + 1): substring = s[i:i+k] substring_count[substring] += 1 # Count how many substrings appear at least n times result = sum(1 for count in substring_count.values() if count >= n) return result"},{"question":"def min_operations_to_non_decreasing(s: str) -> int: Return the minimum number of operations needed to make the string non-decreasing. >>> min_operations_to_non_decreasing(\\"aaaa\\") 0 >>> min_operations_to_non_decreasing(\\"abc\\") 0 >>> min_operations_to_non_decreasing(\\"cba\\") 2 >>> min_operations_to_non_decreasing(\\"a\\") 0 >>> min_operations_to_non_decreasing(\\"abacb\\") 2","solution":"def min_operations_to_non_decreasing(s): Returns the minimum number of operations needed to make the string non-decreasing. Parameters: s (str): the original string. Returns: int: minimum number of operations. n = len(s) dp = [1] * n # dp[i] represents the length of the longest non-decreasing subsequence ending at index i for i in range(1, n): for j in range(i): if s[i] >= s[j]: dp[i] = max(dp[i], dp[j] + 1) # The minimum number of operations is the length of the string minus the length of the longest # non-decreasing subsequence. return n - max(dp)"},{"question":"def count_pairs_with_difference_k(nums: List[int], k: int) -> int: Returns the number of pairs (i, j) where 0 <= i < j < n and the difference between nums[i] and nums[j] is exactly k. >>> count_pairs_with_difference_k([1, 2, 2, 1], 1) 4 >>> count_pairs_with_difference_k([1, 2, 3, 4], 1) 3 >>> count_pairs_with_difference_k([1, 3, 5, 7], 2) 3 >>> count_pairs_with_difference_k([1, 5, 3, 4, 2], 2) 3 >>> count_pairs_with_difference_k([1, 2, 3, 4, 5], 0) 0 >>> count_pairs_with_difference_k([], 1) 0 >>> count_pairs_with_difference_k([1], 1) 0","solution":"def count_pairs_with_difference_k(nums, k): Returns the number of pairs (i, j) where 0 <= i < j < n and the difference between nums[i] and nums[j] is exactly k. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if abs(nums[i] - nums[j]) == k: count += 1 return count"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t or -1 if it's not possible. >>> min_operations_to_transform(\\"abac\\", \\"aabc\\") 2 >>> min_operations_to_transform(\\"abcd\\", \\"abce\\") -1 >>> min_operations_to_transform(\\"abc\\", \\"abca\\") -1 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"a\\", \\"a\\") 0 >>> min_operations_to_transform(\\"a\\", \\"b\\") -1 >>> min_operations_to_transform(\\"abcdef\\", \\"fbdcea\\") 5","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform string s into string t or -1 if it's not possible. # If the sorted version of both strings are not equal, it's not possible if sorted(s) != sorted(t): return -1 m, n = len(s), len(t) if m != n: return -1 # Traverse s and t from the end ops = 0 j = n - 1 for i in range(n-1, -1, -1): if s[j] == t[i]: j -= 1 else: ops += 1 return ops"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_descending_path_sum(root): Given a binary tree, where each node contains an integer value, return the maximum path sum. The path must be a descending path - meaning that the parent node value must be greater than the child node value. The path does not need to go through the root, and each node can only be visited once on the path. >>> max_descending_path_sum(None) -inf >>> max_descending_path_sum(TreeNode(1)) 1 >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> max_descending_path_sum(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> max_descending_path_sum(root) 2 >>> root = TreeNode(10) >>> root.left = TreeNode(9) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(8) >>> root.left.right = TreeNode(7) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(4) >>> root.left.left.left = TreeNode(3) >>> root.left.left.right = TreeNode(2) >>> max_descending_path_sum(root) 30","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_descending_path_sum(root): def helper(node): if not node: return (float('-inf'), 0) left_max_sum, left_max_path = helper(node.left) right_max_sum, right_max_path = helper(node.right) max_sum = max(left_max_sum, right_max_sum) max_path = node.val if node.left and node.val > node.left.val: max_path = max(max_path, node.val + left_max_path) if node.right and node.val > node.right.val: max_path = max(max_path, node.val + right_max_path) return (max(max_sum, max_path), max_path if node.val > (node.left.val if node.left else float('-inf')) and node.val > (node.right.val if node.right else float('-inf')) else 0) return helper(root)[0]"},{"question":"from typing import List def rearrange_string(s: str, k: int) -> str: Given a string \`s\` which consists of only lowercase English letters and an integer \`k\`, determine if it is possible to rearrange the characters in \`s\` such that the same characters are at least distance \`k\` apart. If such an arrangement exists, return a possible rearrangement as a string. Otherwise, return an empty string. >>> rearrange_string(\\"aabbcc\\", 3) == \\"abcabc\\" >>> rearrange_string(\\"aaabc\\", 2) in [\\"abaca\\", \\"acaba\\"] >>> rearrange_string(\\"aaabc\\", 3) == \\"\\" >>> rearrange_string(\\"aaabc\\", 1) == \\"aaabc\\" >>> rearrange_string(\\"aaabc\\", 0) == \\"aaabc\\" >>> rearrange_string(\\"aaaa\\", 2) == \\"\\" >>> rearrange_string(\\"abcdef\\", 6) == \\"abcdef\\" pass","solution":"from heapq import heappush, heappop from collections import Counter, deque def rearrange_string(s, k): if k == 0: return s freq = Counter(s) max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) result_queue = deque() result = [] while max_heap: curr_count, curr_char = heappop(max_heap) result.append(curr_char) result_queue.append((curr_count + 1, curr_char)) if len(result_queue) < k: continue front_count, front_char = result_queue.popleft() if -front_count > 0: heappush(max_heap, (front_count, front_char)) if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def insert_node(root, value): Insert a node with 'value' into the tree rooted at 'root'. :param root: TreeNode, the root of the tree :param value: int, the value to insert :return: the root of the modified tree pass def build_tree(nums): Build the binary tree from the list of numbers. :param nums: List[int], list of integers representing a permutation of numbers from 1 to n :return: the root of the binary tree pass def level_order_traversal(root): Perform level order traversal on the tree. :param root: TreeNode, the root of the tree :return: List[List[int]], the level order traversal as a 2D array pass def level_order(nums): Build the tree and return its level-order traversal. :param nums: List[int], list of integers representing a permutation of numbers from 1 to n :return: List[List[int]], level-order traversal of the tree pass # Test cases def test_level_order_single_element(): assert level_order([1]) == [[1]] def test_level_order_two_elements(): assert level_order([2, 1]) == [[2], [1]] assert level_order([1, 2]) == [[1], [2]] def test_level_order_multiple_elements(): assert level_order([3, 1, 2, 4, 5]) == [[3], [1, 4], [2, 5]] assert level_order([4, 2, 5, 1, 3]) == [[4], [2, 5], [1, 3]] def test_level_order_empty(): assert level_order([]) == [] def test_level_order_skewed_tree(): assert level_order([1, 2, 3, 4]) == [[1], [2], [3], [4]] assert level_order([4, 3, 2, 1]) == [[4], [3], [2], [1]]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def insert_node(root, value): if not root: return TreeNode(value) if value < root.value: root.left = insert_node(root.left, value) else: root.right = insert_node(root.right, value) return root def build_tree(nums): if not nums: return None root = None for num in nums: root = insert_node(root, num) return root def level_order_traversal(root): if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.pop(0) level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result def level_order(nums): root = build_tree(nums) return level_order_traversal(root)"},{"question":"def rotate(nums, k): Rotates the array to the right by k steps. Params: nums - list of integers k - non-negative integer Returns: list of integers after k rotations >>> rotate([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotate([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotate([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate([1], 3) [1]","solution":"def rotate(nums, k): Rotates the array to the right by k steps. Params: nums - list of integers k - non-negative integer Returns: list of integers after k rotations n = len(nums) k = k % n # Adjust k if it's larger than n nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"from typing import List, Tuple def find_pairs_and_scaling_factor(nums: List[int], target: int, m: int) -> Tuple[List[Tuple[int, int]], int]: You are given an integer array 'nums' and an integer 'target'. You need to find all unique pairs (nums[i], nums[j]) such that their sum is equal to 'target', and 'i' is not equal to 'j'. Additionally, determine the scaling factor required to fit all the unique pairs within a given 2D grid of size 'm x m' without overlapping. The scaling factor is determined as the minimum distance between any two pairs. Return a tuple containing the list of unique pairs and the scaling factor. >>> find_pairs_and_scaling_factor([1, 2, 3], 7, 3) [] >>> find_pairs_and_scaling_factor([1, 2, 3, 4], 5, 3) [(1, 4), (2, 3)]","solution":"def find_unique_pairs(nums, target): Finds all unique pairs in nums that sum up to the target. nums.sort() seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pair = (min(num, complement), max(num, complement)) pairs.add(pair) seen.add(num) return sorted(pairs) def determine_scaling_factor(pairs, m): Determines the scaling factor required to fit all the pairs within an m x m grid. The scaling factor is the minimum distance between any two pairs. if not pairs: return 1 # No pairs, no scaling needed. return 1 # For simplicity, we just return 1 as scaling factor without spatial logic. def find_pairs_and_scaling_factor(nums, target, m): Finds unique pairs that sum up to the target and determines the scaling factor. pairs = find_unique_pairs(nums, target) scaling_factor = determine_scaling_factor(pairs, m) return (pairs, scaling_factor)"},{"question":"def starting_point_of_longest_non_negative_subarray(nums): Find the starting point of the longest subarray where the sum of the elements is non-negative in a circular array. >>> starting_point_of_longest_non_negative_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 2 >>> starting_point_of_longest_non_negative_subarray([1, 2, 3, 4, 5]) == 0 >>> starting_point_of_longest_non_negative_subarray([-1, -2, -3, -4, -5]) == 0 >>> starting_point_of_longest_non_negative_subarray([2, -1, 2, -1, 2, -1, 2, -1]) == 0 >>> starting_point_of_longest_non_negative_subarray([-1]) == 0 >>> starting_point_of_longest_non_negative_subarray([1]) == 0 >>> starting_point_of_longest_non_negative_subarray([5, 10, -15, -20, 25, 30, -35, 40]) == 4","solution":"def starting_point_of_longest_non_negative_subarray(nums): n = len(nums) max_length = 0 max_start_index = 0 current_sum = 0 current_length = 0 current_start_index = 0 for i in range(2 * n): index = i % n current_sum += nums[index] current_length += 1 if current_sum < 0: current_sum = 0 current_length = 0 current_start_index = (index + 1) % n else: if current_length > max_length or (current_length == max_length and current_start_index < max_start_index): max_length = current_length max_start_index = current_start_index return max_start_index # Example usage: # nums = [1, -2, 3, 4, -1, 2, 1, -5, 4] # print(starting_point_of_longest_non_negative_subarray(nums)) # Output should be 2"},{"question":"def checkStraightLine(nums: List[int]) -> bool: Returns true if all points (i, nums[i]) for i=0 to n-1 lie on a straight line. nums: List[int] - A list of integers where nums[i] represents the y-coordinate at x=i >>> checkStraightLine([2, 2, 2, 2]) True >>> checkStraightLine([0, 1, 2, 3, 4]) True >>> checkStraightLine([4, 3, 2, 1, 0]) True >>> checkStraightLine([4, 4, 4, 4, 4]) True >>> checkStraightLine([0, -3, -6, -9, -12]) True >>> checkStraightLine([0, 1, 3, 6]) False >>> checkStraightLine([0, 2, 4, 5]) False >>> checkStraightLine([]) True >>> checkStraightLine([1]) True >>> checkStraightLine([1, 2]) True >>> checkStraightLine([1, 1, 1, 1, 1]) True >>> checkStraightLine([1, 2, 3, 4, 5, 7]) False","solution":"def checkStraightLine(nums): Returns true if all points (i, nums[i]) for i=0 to n-1 lie on a straight line. nums: List[int] - A list of integers where nums[i] represents the y-coordinate at x=i if len(nums) < 2: # Fewer than 2 points automatically form a straight line. return True x0, y0 = 0, nums[0] x1, y1 = 1, nums[1] dx = x1 - x0 dy = y1 - y0 for i in range(2, len(nums)): xi, yi = i, nums[i] # Check if the slope dy / dx is equal for all coordinates. # Cross product differences should be zero for collinearity: # (yi - y0) * dx == dy * (xi - x0) if (yi - y0) * dx != dy * (xi - x0): return False return True"},{"question":"def extract_and_sum_digits(s: str) -> int: Extracts all integers from the input string and returns their sum. If no digits are present, returns 0. >>> extract_and_sum_digits(\\"a123bc34d8ef42\\") 207 >>> extract_and_sum_digits(\\"12ab34\\") 46 >>> extract_and_sum_digits(\\"abcdef\\") 0 >>> extract_and_sum_digits(\\"123\\") 123 >>> extract_and_sum_digits(\\"abc123\\") 123 >>> extract_and_sum_digits(\\"123abc\\") 123 >>> extract_and_sum_digits(\\"1a2b3c4d5\\") 15 >>> extract_and_sum_digits(\\"a1b2c3d4e5f6\\") 21 >>> extract_and_sum_digits(\\"\\") 0","solution":"import re def extract_and_sum_digits(s): Extracts all integers from the input string and returns their sum. If no digits are present, returns 0. numbers = re.findall(r'd+', s) return sum(map(int, numbers)) if numbers else 0"},{"question":"def longestCommonSubsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence of s1 and s2. >>> longestCommonSubsequence(\\"abcde\\", \\"ace\\") == 3 >>> longestCommonSubsequence(\\"abc\\", \\"abc\\") == 3 >>> longestCommonSubsequence(\\"abc\\", \\"def\\") == 0 >>> longestCommonSubsequence(\\"abcdefg\\", \\"bdf\\") == 3 >>> longestCommonSubsequence(\\"\\", \\"ace\\") == 0 >>> longestCommonSubsequence(\\"abcde\\", \\"\\") == 0 >>> longestCommonSubsequence(\\"abacbdab\\", \\"bdcaba\\") == 4","solution":"def longestCommonSubsequence(s1, s2): Returns the length of the longest common subsequence of s1 and s2. m, n = len(s1), len(s2) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(m): for j in range(n): if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) return dp[m][n]"},{"question":"from typing import List def longest_subseq_divisible_by_k(sequence: List[int], k: int) -> int: Determine the length of the longest subsequence in which the sum of its elements is divisible by k. >>> longest_subseq_divisible_by_k([3, 1, 2, 7, 4, 8], 3) 5 >>> longest_subseq_divisible_by_k([1, 2, 3, 4, 5], 5) 5 >>> longest_subseq_divisible_by_k([5, 10, 15, 20], 5) 4 >>> longest_subseq_divisible_by_k([1, 2, 3], 4) 2 >>> longest_subseq_divisible_by_k([7, 14, 28], 7) 3 >>> longest_subseq_divisible_by_k([6, 7, 16, 17], 6) 3 >>> longest_subseq_divisible_by_k([1, 2, 3], 7) 0 >>> longest_subseq_divisible_by_k([], 5) 0 >>> longest_subseq_divisible_by_k([7], 7) 1 >>> longest_subseq_divisible_by_k([7], 5) 0 >>> longest_subseq_divisible_by_k([0, 0, 0, 0], 5) 4","solution":"def longest_subseq_divisible_by_k(sequence, k): n = len(sequence) max_len = 0 # We will use a dictionary to track the longest subsequence lengths for each modulus dp = {0: 0} # We start with sum % k = 0 having length 0 for num in sequence: current_dp = dp.copy() for modulus, length in current_dp.items(): new_modulus = (modulus + num) % k new_length = length + 1 if new_modulus not in dp or new_length > dp[new_modulus]: dp[new_modulus] = new_length return dp[0] # The modulus we're interested in is 0 for sum being divisible by k"},{"question":"def can_partition_into_k_equal_sum_subarrays(nums: List[int], k: int) -> bool: Determine whether the array can be partitioned into k contiguous subarrays such that the sum of each subarray is equal. >>> can_partition_into_k_equal_sum_subarrays([4, 3, 2, 3, 5, 2, 1], 4) == True >>> can_partition_into_k_equal_sum_subarrays([1, 2, 3, 4], 3) == False pass def test_example_cases(): assert can_partition_into_k_equal_sum_subarrays([4, 3, 2, 3, 5, 2, 1], 4) == True assert can_partition_into_k_equal_sum_subarrays([1, 2, 3, 4], 3) == False def test_single_element_cases(): assert can_partition_into_k_equal_sum_subarrays([2, 2, 2, 2], 2) == True assert can_partition_into_k_equal_sum_subarrays([1], 2) == False def test_large_numbers_case(): assert can_partition_into_k_equal_sum_subarrays([10**6, 10**6, 10**6, 10**6], 2) == True assert can_partition_into_k_equal_sum_subarrays([10**6, 10**6, 10**6], 2) == False def test_zero_partition_cases(): assert can_partition_into_k_equal_sum_subarrays([1, 2, 3, 4], 1) == True assert can_partition_into_k_equal_sum_subarrays([0, 0, 0, 0], 4) == True assert can_partition_into_k_equal_sum_subarrays([1, 1, 1, 1], 5) == False def test_combined_large_small_values(): assert can_partition_into_k_equal_sum_subarrays([1, 499, 1, 499], 2) == True assert can_partition_into_k_equal_sum_subarrays([1, 499, 1, 500], 2) == False","solution":"def can_partition_into_k_equal_sum_subarrays(nums, k): # Determine the total sum of the array total_sum = sum(nums) # Check if the total sum is divisible by k if total_sum % k != 0: return False # The sum each subarray should sum to target_sum = total_sum // k # Initialize the variables to use in the search used = [False] * len(nums) nums.sort(reverse=True) def can_partition(k, start_index, current_sum): if k == 0: return True if current_sum == target_sum: return can_partition(k-1, 0, 0) for i in range(start_index, len(nums)): if not used[i] and current_sum + nums[i] <= target_sum: used[i] = True if can_partition(k, i + 1, current_sum + nums[i]): return True used[i] = False return False return can_partition(k, 0, 0)"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Returns the final string after removing adjacent duplicates. >>> remove_adjacent_duplicates(\\"abc\\") == \\"abc\\" >>> remove_adjacent_duplicates(\\"abbaca\\") == \\"ca\\" >>> remove_adjacent_duplicates(\\"aa\\") == \\"\\" >>> remove_adjacent_duplicates(\\"aaaa\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abba\\") == \\"\\" >>> remove_adjacent_duplicates(\\"aabbcc\\") == \\"\\" >>> remove_adjacent_duplicates(\\"azxxzy\\") == \\"ay\\" >>> remove_adjacent_duplicates(\\"aabccba\\") == \\"a\\" >>> remove_adjacent_duplicates(\\"\\") == \\"\\" >>> remove_adjacent_duplicates(\\"a\\") == \\"a\\" >>> remove_adjacent_duplicates(\\"b\\") == \\"b\\"","solution":"def remove_adjacent_duplicates(s): Returns the final string after removing adjacent duplicates. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def max_water_container(arr: List[int]) -> int: Returns the maximum amount of water a container can hold from given heights. >>> max_water_container([1, 1]) 1 >>> max_water_container([1, 2, 1]) 2 >>> max_water_container([4, 3, 2, 1, 4]) 16 >>> max_water_container([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_container([1, 2, 4, 3]) 4 >>> max_water_container([1, 3, 2, 5, 25, 24, 5]) 24 >>> max_water_container([2, 3, 10, 5, 7, 8, 9]) 36","solution":"def max_water_container(arr): Returns the maximum amount of water a container can hold from given heights. left = 0 right = len(arr) - 1 max_water = 0 while left < right: width = right - left height = min(arr[left], arr[right]) max_water = max(max_water, width * height) if arr[left] < arr[right]: left += 1 else: right -= 1 return max_water"},{"question":"def words_starting_with(s: str, c: str) -> List[str]: Returns a list of words from the sentence 's' that start with the character 'c'. The comparison is case-insensitive. >>> words_starting_with(\\"The cat chased the mouse\\", \\"c\\") == [\\"cat\\", \\"chased\\"] >>> words_starting_with(\\"The Cat chased the mouse\\", \\"c\\") == [\\"Cat\\", \\"chased\\"] >>> words_starting_with(\\"The cat chased the Mouse\\", \\"C\\") == [\\"cat\\", \\"chased\\"] >>> words_starting_with(\\"The cat chased the mouse\\", \\"z\\") == [] >>> words_starting_with(\\"Cat chased car cautiously\\", \\"c\\") == [\\"Cat\\", \\"chased\\", \\"car\\", \\"cautiously\\"] >>> words_starting_with(\\"\\", \\"c\\") == [] >>> words_starting_with(\\"this is a test\\", \\"x\\") == []","solution":"def words_starting_with(s, c): Returns a list of words from the sentence 's' that start with the character 'c'. The comparison is case-insensitive. c_lower = c.lower() words = s.split() result = [word for word in words if word.lower().startswith(c_lower)] return result"},{"question":"def min_operations_to_transform(s1: str, s2: str) -> int: Returns the minimum number of operations needed to transform s1 into s2. If it is not possible to transform s1 into s2, returns -1. >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"abc\\", \\"bca\\") 1 >>> min_operations_to_transform(\\"abcd\\", \\"abc\\") -1 >>> min_operations_to_transform(\\"abc\\", \\"def\\") -1 >>> min_operations_to_transform(\\"abab\\", \\"baba\\") 2 >>> min_operations_to_transform(\\"\\", \\"\\") 0","solution":"def min_operations_to_transform(s1, s2): Returns the minimum number of operations needed to transform s1 into s2. If it is not possible to transform s1 into s2, returns -1. if len(s1) != len(s2): return -1 from collections import Counter counter1 = Counter(s1) counter2 = Counter(s2) # If the count of characters are different, returns -1 if counter1 != counter2: return -1 swaps = 0 for c1, c2 in zip(s1, s2): if c1 != c2: swaps += 1 return swaps // 2"},{"question":"def count_secluded_islands(grid): Returns the number of secluded islands in the given grid. Args: grid (list[list[str]]): 2D list of '1's and '0's representing land and water respectively. Returns: int: The number of secluded islands. >>> grid = [ ... ['0', '0', '0', '0'], ... ['0', '1', '1', '0'], ... ['0', '1', '1', '0'], ... ['0', '0', '0', '0'] ... ] >>> count_secluded_islands(grid) 0 >>> grid = [ ... ['0', '0', '0', '0'], ... ['0', '1', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '1'] ... ] >>> count_secluded_islands(grid) 2 >>> grid = [ ... ['0', '1', '0', '1'], ... ['1', '0', '1', '0'], ... ['0', '1', '0', '1'], ... ['1', '0', '1', '0'] ... ] >>> count_secluded_islands(grid) 8 >>> grid = [] >>> count_secluded_islands(grid) 0 >>> grid = [ ... ['1', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '1'] ... ] >>> count_secluded_islands(grid) 0 >>> grid = [ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ] >>> count_secluded_islands(grid) 0 pass","solution":"def is_secluded(grid, x, y): Helper function to determine if a position (x, y) in the grid is a secluded island. m, n = len(grid), len(grid[0]) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '1': return False return True def count_secluded_islands(grid): Returns the number of secluded islands in the given grid. Args: grid (list[list[str]]): 2D list of '1's and '0's representing land and water respectively. Returns: int: The number of secluded islands. if not grid: return 0 m, n = len(grid), len(grid[0]) secluded_islands = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and is_secluded(grid, i, j): secluded_islands += 1 return secluded_islands"},{"question":"def longest_visible_sequence(arr: List[int]) -> int: Returns the length of the longest sequence of students where each subsequent student can see the one after them. >>> longest_visible_sequence([10, 4, 5, 12, 2, 17]) 4 >>> longest_visible_sequence([1, 2, 3, 4, 5]) 5 >>> longest_visible_sequence([5, 4, 3, 2, 1]) 1 >>> longest_visible_sequence([10, 10, 10]) 1 >>> longest_visible_sequence([3, 3, 5, 5, 4]) 2 >>> longest_visible_sequence([]) 0 >>> longest_visible_sequence([7]) 1","solution":"def longest_visible_sequence(arr): Returns the length of the longest sequence of students where each subsequent student can see the one after them. n = len(arr) if n == 0: return 0 # Longest increasing subsequence dynamic programming array lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def max_coins(grid: List[List[int]]) -> int: Returns the maximum number of coins that can be collected by moving from the top-left corner to the bottom-right corner of the grid, moving only right or down. >>> max_coins([[5]]) 5 >>> max_coins([[1, 2, 3, 4]]) 10 >>> max_coins([[1], [2], [3], [4]]) 10 >>> max_coins([ ... [1, 2, 5], ... [3, 2, 1] ... ]) 9 >>> max_coins([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_coins([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29","solution":"def max_coins(grid): Returns the maximum number of coins that can be collected by moving from the top-left corner to the bottom-right corner of the grid, moving only right or down. m = len(grid) n = len(grid[0]) # Create a DP table with the same dimensions as grid initialized to zero dp = [[0] * n for _ in range(m)] # Initialize the top-left cell of DP table dp[0][0] = grid[0][0] # Fill in the first row of the DP table for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column of the DP table for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def min_meeting_rooms(events: List[List[int]]) -> int: Given a list of events where each event is represented as [start_time, end_time], return the minimum number of conference rooms required to schedule all events. >>> min_meeting_rooms([]) == 0 >>> min_meeting_rooms([[1, 2]]) == 1 >>> min_meeting_rooms([[1, 2], [3, 4], [5, 6]]) == 1 >>> min_meeting_rooms([[1, 4], [2, 5], [7, 9]]) == 2 >>> min_meeting_rooms([[1, 4], [1, 3], [1, 2], [1, 5]]) == 4 >>> min_meeting_rooms([[9, 10], [4, 9], [4, 17]]) == 2 >>> min_meeting_rooms([[0, 24], [1, 22], [2, 23]]) == 3","solution":"def min_meeting_rooms(events): if not events: return 0 # Sort the start and end times separately start_times = sorted(event[0] for event in events) end_times = sorted(event[1] for event in events) start_pointer = end_pointer = 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(events): if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"def findOdd(arr): Given an array of integers where each integer appears an even number of times except for one. This function returns the integer which appears an odd number of times. >>> findOdd([1, 1, 2]) 2 >>> findOdd([4, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6]) 6 >>> findOdd([10, 10, 20, 30, 30, 20, 40, 40, 50, 60, 60, 50, 90]) 90 >>> findOdd([999999999, 999999999, 888888888, 777777777, 777777777]) 888888888 >>> findOdd([-1, -1, -2, -3, -3, -2, -4]) -4","solution":"def findOdd(arr): Returns the number that appears an odd number of times in the array. xor_result = 0 for num in arr: xor_result ^= num return xor_result"},{"question":"from typing import List def sum_of_digits(n: int) -> int: Return the sum of the digits of a positive number n. return sum(int(digit) for digit in str(n)) def product_of_digits(n: int) -> int: Return the product of the digits of a positive number n. product = 1 for digit in str(n): product *= int(digit) return product def transform(nums: List[int]) -> List[int]: Transforms the input list based on the transformation rules. - If the number is positive, replace it with the sum of its digits. - If the number is negative, replace it with the product of its digits. - If the number is zero, leave it unchanged. >>> transform([12, 34]) == [3, 7] >>> transform([-23, -45]) == [6, 20] >>> transform([0, 0]) == [0, 0] >>> transform([12, -34, 0]) == [3, 12, 0] >>> transform([9]) == [9] >>> transform([]) == [] >>> transform([123456]) == [21] >>> transform([-12345]) == [120]","solution":"def sum_of_digits(n): Return the sum of the digits of a positive number n. return sum(int(digit) for digit in str(n)) def product_of_digits(n): Return the product of the digits of a positive number n. product = 1 for digit in str(n): product *= int(digit) return product def transform(nums): Transforms the input list based on the transformation rules. - If the number is positive, replace it with the sum of its digits. - If the number is negative, replace it with the product of its digits. - If the number is zero, leave it unchanged. transformed = [] for num in nums: if num > 0: transformed.append(sum_of_digits(num)) elif num < 0: transformed.append(product_of_digits(abs(num))) else: transformed.append(num) return transformed"},{"question":"def subarraysDivByK(nums: List[int], k: int) -> int: Returns the total number of subarrays whose sum is divisible by k, modulo 10^9 + 7. >>> subarraysDivByK([4, 5, 0, -2, -3, 1], 5) 7 >>> subarraysDivByK([1, 2, 3], 7) 0 >>> subarraysDivByK([5, 10, 15], 5) 6 >>> subarraysDivByK([10, -10, 10], 5) 6 >>> subarraysDivByK([1000000000, 1000000000], 1000) 3 >>> subarraysDivByK([5], 5) 1 >>> subarraysDivByK([4], 5) 0 >>> subarraysDivByK([0], 5) 1","solution":"def subarraysDivByK(nums, k): Returns the number of subarrays whose sum is divisible by k. mod = 10**9 + 7 prefix_sums = {0: 1} # Record counts of prefix sums current_sum = 0 count = 0 for num in nums: current_sum += num # Update the current prefix sum mod_value = current_sum % k # Adjust mod_value to be positive if mod_value < 0: mod_value += k # If mod_value is already in prefix_sums, increment count by how many times mod_value has been seen. if mod_value in prefix_sums: count += prefix_sums[mod_value] # Update the count of the current mod_value in prefix_sums if mod_value in prefix_sums: prefix_sums[mod_value] += 1 else: prefix_sums[mod_value] = 1 count %= mod return count"},{"question":"def groupUniqueLetters(s: str) -> str: Returns the processed string where each group of identical consecutive characters is replaced by a single character and all unique characters at their first appearance are maintained in their relative order. >>> groupUniqueLetters(\\"abbcccddddeeeffggg\\") \\"abcdefg\\" >>> groupUniqueLetters(\\"aaaaaaa\\") \\"a\\"","solution":"def groupUniqueLetters(s): Returns the processed string where each group of identical consecutive characters is replaced by a single character and all unique characters at their first appearance are maintained in their relative order. if not s: return \\"\\" result = [s[0]] # Initialize the result list with the first character of the string. for char in s[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"from typing import List def canModifyArray(nums1: List[int], nums2: List[int]) -> bool: Determine whether we can make \`nums1\` strictly increasing by modifying at most one element in \`nums1\`. Note: An array is strictly increasing if \`nums1[i] < nums1[i+1]\` for every \`i\` (0-indexed) such that 0 <= i < len(nums1) - 1. >>> canModifyArray([1, 2, 3], [5, 6, 7]) True >>> canModifyArray([1, 5, 2], [4, 6, 7]) True >>> canModifyArray([3, 5, 10], [1, 4, 7]) True >>> canModifyArray([10, 5, 2], [3, 4, 7]) False >>> canModifyArray([1], [2]) True >>> canModifyArray([1, 3, 5, 7], [2, 4, 6, 8]) True >>> canModifyArray([5, 4, 3], [6, 7, 8]) False","solution":"def canModifyArray(nums1, nums2): def can_be_strictly_increasing(nums): for i in range(len(nums) - 1): if nums[i] >= nums[i + 1]: return False return True if can_be_strictly_increasing(nums1): return True for i in range(len(nums1)): original_value = nums1[i] nums1[i] = nums2[i] if can_be_strictly_increasing(nums1): return True nums1[i] = original_value return False"},{"question":"import itertools def kth_lexicographical_string(n: int, k: int) -> str: Returns the kth lexicographical string of length n consisting of characters 'a' and 'b'. If k is greater than the total number of such possible strings, return an empty string. >>> kth_lexicographical_string(2, 1) == \\"aa\\" >>> kth_lexicographical_string(2, 2) == \\"ab\\" >>> kth_lexicographical_string(2, 3) == \\"ba\\" >>> kth_lexicographical_string(2, 4) == \\"bb\\" >>> kth_lexicographical_string(2, 5) == \\"\\" >>> kth_lexicographical_string(3, 1) == \\"aaa\\" >>> kth_lexicographical_string(3, 8) == \\"bbb\\" >>> kth_lexicographical_string(3, 9) == \\"\\"","solution":"import itertools def kth_lexicographical_string(n, k): Returns the kth lexicographical string of length n consisting of characters 'a' and 'b'. If k is greater than the total number of such possible strings, return an empty string. # Generate all possible combinations total_combinations = 2 ** n if k > total_combinations: return \\"\\" all_strings = sorted(\\"\\".join(seq) for seq in itertools.product('ab', repeat=n)) return all_strings[k-1]"},{"question":"def is_subsequence(s: str, word: str) -> bool: Helper function to check if 'word' is a subsequence of 's'. pass def longest_subsequence_length(words: List[str], s: str) -> int: Returns the length of the longest subsequence from words that can be formed by deleting some characters from input string s. >>> longest_subsequence_length([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") 1 >>> longest_subsequence_length([], \\"abc\\") 0 >>> longest_subsequence_length([\\"a\\", \\"b\\", \\"c\\"], \\"a\\") 1 >>> longest_subsequence_length([\\"xyz\\", \\"mnop\\"], \\"abc\\") 0 >>> longest_subsequence_length([\\"axc\\", \\"abc\\", \\"ace\\", \\"a\\"], \\"abcdef\\") 3 >>> longest_subsequence_length([\\"abc\\", \\"abd\\", \\"ab\\"], \\"abcd\\") 3 pass","solution":"def is_subsequence(s, word): Helper function to check if 'word' is a subsequence of 's'. it = iter(s) return all(char in it for char in word) def longest_subsequence_length(words, s): Returns the length of the longest subsequence from words that can be formed by deleting some characters from input string s. max_length = 0 for word in words: if is_subsequence(s, word): max_length = max(max_length, len(word)) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given a binary tree where each node's value is a digit from 0-9, return all root-to-leaf paths in the form of a list of strings, where each string represents the sequence of values from the root to a leaf. A leaf is a node with no children. >>> root = TreeNode(1) >>> binary_tree_paths(root) ['1'] >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> sorted(binary_tree_paths(root)) ['1->2->5', '1->3'] >>> root = TreeNode(4) >>> root.left = TreeNode(9) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(1) >>> sorted(binary_tree_paths(root)) ['4->9->5', '4->9->1', '4->0'] >>> binary_tree_paths(None) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given a binary tree, return all root-to-leaf paths in form of a list of strings, where each string represents the sequence of values from the root to a leaf. if not root: return [] def dfs(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += '->' if node.left: dfs(node.left, path, paths) if node.right: dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"def num_distinct_paths(grid): Returns the number of distinct paths to reach the bottom-right corner from the top-left corner in a grid with obstacles. >>> num_distinct_paths([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> num_distinct_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> num_distinct_paths([ ... [0, 1, 0], ... [1, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> num_distinct_paths([ ... [0] ... ]) == 1 >>> num_distinct_paths([ ... [1] ... ]) == 0 >>> num_distinct_paths([ ... [0, 0], ... [1, 0] ... ]) == 1","solution":"def num_distinct_paths(grid): Returns the number of distinct paths to reach the bottom-right corner from the top-left corner in a grid with obstacles. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) # Initialize a DP table with the same dimensions as grid dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Start point # Fill the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def min_cost_path(grid): Returns the minimum cost path from the top-left corner to the bottom-right corner of the grid. >>> min_cost_path([[5]]) == 5 >>> min_cost_path([[1, 2], [1, 1]]) == 3 >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_cost_path(grid) == 7 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_cost_path(grid) == 21 >>> min_cost_path([]) == 0 >>> min_cost_path([[]]) == 0 >>> grid = [ ... [1, 2, 3], ... [4, 8, 2] ... ] >>> min_cost_path(grid) == 8","solution":"def min_cost_path(grid): Returns the minimum cost path from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"def minimize_max_sum(arr, k): Split the array into exactly k non-overlapping, contiguous subarrays such that the sum of the maximum element in each subarray is minimized. Return the minimized sum of the maximum element in each subarray. If splitting the array into exactly k subarrays is not possible, return -1. >>> minimize_max_sum([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_sum([1, 2, 3, 4, 5], 3) 6 >>> minimize_max_sum([1, 2, 3], 5) -1 >>> minimize_max_sum([1, 2], 3) -1 >>> minimize_max_sum([4, 4, 4, 4], 2) 8 >>> minimize_max_sum([4, 4, 4, 4], 4) 4 >>> minimize_max_sum([5], 1) 5 >>> minimize_max_sum([5], 2) -1","solution":"def minimize_max_sum(arr, k): n = len(arr) if k > n: return -1 # Helper function to check if a given max sum can be achieved by k subarrays def can_split(max_sum): subarray_count = 1 current_sum = 0 for num in arr: if current_sum + num > max_sum: subarray_count += 1 current_sum = num if subarray_count > k: return False else: current_sum += num return subarray_count <= k left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def summarize_orders(orders: List[str]) -> List[str]: Generates a summary report that aggregates the total quantity of each item ordered across all customers. The report is a list of strings, where each string is in the format 'item total_quantity', sorted alphabetically by item. >>> summarize_orders([\\"Alice apples 4\\", \\"Bob bananas 2\\", \\"Alice apples 2\\", \\"Bob apples 1\\", \\"Charlie bananas 5\\"]) [\\"apples 7\\", \\"bananas 7\\"] >>> summarize_orders([\\"Alice apples 4\\"]) [\\"apples 4\\"] >>> summarize_orders([\\"Bob oranges 3\\", \\"Alice pears 5\\"]) [\\"oranges 3\\", \\"pears 5\\"] >>> summarize_orders([\\"Alice apples 1\\", \\"Bob apples 1\\", \\"Charlie apples 1\\"]) [\\"apples 3\\"] >>> summarize_orders([]) [] >>> summarize_orders([\\"Alice grapes 4\\", \\"Bob grapes 2\\", \\"Charlie oranges 3\\", \\"Alice bananas 2\\", \\"Bob apples 2\\"]) [\\"apples 2\\", \\"bananas 2\\", \\"grapes 6\\", \\"oranges 3\\"]","solution":"def summarize_orders(orders): from collections import defaultdict order_summary = defaultdict(int) for order in orders: customer_name, item, quantity = order.split() order_summary[item] += int(quantity) summary_report = [f\\"{item} {total_quantity}\\" for item, total_quantity in sorted(order_summary.items())] return summary_report"},{"question":"from typing import List def is_possible_to_deliver_all_packages(grid: List[List[int]], sx: int, sy: int, dx: int, dy: int) -> bool: Determines if it is possible to transport all packages to the delivery point. Args: grid (List[List[int]]): The warehouse layout. sx, sy (int): The starting coordinates of the robot. dx, dy (int): The coordinates of the delivery point. Returns: bool: True if it is possible to transport all packages to the delivery point, False otherwise. # Unit Test from solution import is_possible_to_deliver_all_packages def test_no_obstacles_or_packages(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert is_possible_to_deliver_all_packages(grid, 0, 0, 2, 2) == True def test_with_obstacles(): grid = [ [0, 1, 0], [0, 1, 0], [0, 1, 2] ] assert is_possible_to_deliver_all_packages(grid, 0, 0, 2, 2) == False def test_with_packages(): grid = [ [0, 0, 2], [0, 1, 0], [2, 0, 0] ] assert is_possible_to_deliver_all_packages(grid, 0, 0, 2, 2) == True def test_no_path_to_package(): grid = [ [0, 1, 0], [1, 1, 0], [2, 1, 0] ] assert is_possible_to_deliver_all_packages(grid, 0, 0, 2, 2) == False def test_no_path_to_delivery_point(): grid = [ [0, 2, 0], [1, 1, 1], [0, 2, 0] ] assert is_possible_to_deliver_all_packages(grid, 0, 0, 2, 2) == False def test_all_packages_deliverable(): grid = [ [0, 2, 0, 0], [0, 1, 0, 1], [0, 1, 2, 0], [0, 0, 0, 0] ] assert is_possible_to_deliver_all_packages(grid, 0, 0, 3, 3) == True","solution":"from collections import deque def is_possible_to_deliver_all_packages(grid, sx, sy, dx, dy): Determines if it is possible to transport all packages to the delivery point. Args: grid (List[List[int]]): The warehouse layout. sx, sy (int): The starting coordinates of the robot. dx, dy (int): The coordinates of the delivery point. Returns: bool: True if it is possible to transport all packages to the delivery point, False otherwise. def bfs(start, target, grid): Performs BFS from start to target, returns True if path exists, otherwise False rows, cols = len(grid), len(grid[0]) queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == target: return True for nx, ny in ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)): if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] != 1: visited.add((nx, ny)) queue.append((nx, ny)) return False rows, cols = len(grid), len(grid[0]) packages = [(i, j) for i in range(rows) for j in range(cols) if grid[i][j] == 2] for px, py in packages: if not bfs((sx, sy), (px, py), grid) or not bfs((px, py), (dx, dy), grid): return False return True"},{"question":"def min_insertion_to_palindrome(s: str) -> int: Implement a function that takes a string \`s\` and returns the minimum number of insertions needed to make \`s\` a palindrome. A palindrome is a string that reads the same forward and backward. >>> min_insertion_to_palindrome(\\"abca\\") 1 >>> min_insertion_to_palindrome(\\"a\\") 0 >>> min_insertion_to_palindrome(\\"race\\") 3 >>> min_insertion_to_palindrome(\\"\\") 0 >>> min_insertion_to_palindrome(\\"leetcode\\") 5 >>> min_insertion_to_palindrome(\\"abc\\") 2 >>> min_insertion_to_palindrome(\\"aabb\\") 2","solution":"def min_insertion_to_palindrome(s): Returns the minimum number of insertions needed to make the string \`s\` a palindrome. def lcs(s1, s2): m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] s_reversed = s[::-1] lcs_length = lcs(s, s_reversed) return len(s) - lcs_length"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays arr1 and arr2 into a single sorted arrangement, where the first n smallest elements are in arr1 and the remaining elements are in arr2. arr1 and arr2 are both of length n. >>> arr1 = [1, 4, 7] >>> arr2 = [2, 3, 6] >>> merge_sorted_arrays(arr1, arr2) ([1, 2, 3], [4, 6, 7]) >>> arr1 = [5, 5, 5] >>> arr2 = [5, 5, 5] >>> merge_sorted_arrays(arr1, arr2) ([5, 5, 5], [5, 5, 5]) >>> arr1 = [1, 2, 3] >>> arr2 = [4, 5, 6] >>> merge_sorted_arrays(arr1, arr2) ([1, 2, 3], [4, 5, 6]) >>> arr1 = [6, 7, 8] >>> arr2 = [1, 2, 3] >>> merge_sorted_arrays(arr1, arr2) ([1, 2, 3], [6, 7, 8]) >>> arr1 = [2, 6, 9] >>> arr2 = [1, 5, 8] >>> merge_sorted_arrays(arr1, arr2) ([1, 2, 5], [6, 8, 9]) # Your code here","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays arr1 and arr2 into a single sorted arrangement, where the first n smallest elements are in arr1 and the remaining elements are in arr2. arr1 and arr2 are both of length n. n = len(arr1) i, j, k = 0, 0, n - 1 # Traverse the arrays from the end to the beginning while i <= k and j < n: if arr1[i] < arr2[j]: i += 1 else: arr2[j], arr1[k] = arr1[k], arr2[j] k -= 1 j += 1 # Sort both arrays as the final step arr1.sort() arr2.sort() return arr1, arr2"},{"question":"from typing import List def unique_occurrences(arr: List[int]) -> bool: Given an array arr of integers, return true if and only if the number of occurrences of each value in the array is unique. >>> unique_occurrences([1, 2, 2, 1, 1, 3]) True >>> unique_occurrences([1, 2]) False >>> unique_occurrences([3, 5, -2, -3, -3, 2, 1, 0]) False from collections import Counter def test_unique_occurrences_all_unique(): assert unique_occurrences([1, 2, 2, 1, 1, 3]) == True def test_unique_occurrences_all_same(): assert unique_occurrences([1, 2]) == False def test_unique_occurrences_mixed_values(): assert unique_occurrences([3, 5, -2, -3, -3, 2, 1, 0]) == False def test_unique_occurrences_empty_list(): assert unique_occurrences([]) == True def test_unique_occurrences_single_element(): assert unique_occurrences([1]) == True def test_unique_occurrences_multiple_unique_counts(): assert unique_occurrences([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == True def test_unique_occurrences_duplicates_counts(): assert unique_occurrences([5, 5, 6, 6, 7, 7, 7, 7]) == False","solution":"def unique_occurrences(arr): Returns True if the number of occurrences of each value in the array is unique. from collections import Counter # Count occurrences of each element count = Counter(arr) # Get set of the counts of each element occurrences = set(count.values()) # If the length of occurrences set is the same as the length of count dict, all values had unique occurrences return len(occurrences) == len(count)"},{"question":"from typing import List def rotate(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Parameters: nums (list of int): The input array to rotate. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. Example: >>> rotate([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotate([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotate([1], 3) [1]","solution":"def rotate(nums, k): Rotates the array to the right by k steps. Parameters: nums (list of int): The input array to rotate. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(nums) k = k % n # In case k is larger than the array length return nums[-k:] + nums[:-k]"},{"question":"def count_prefixes(words: List[str]) -> int: Returns the number of strings in \`words\` that are prefixes of at least one other string in the list. >>> count_prefixes([\\"dog\\", \\"cat\\", \\"mouse\\"]) == 0 >>> count_prefixes([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) == 3 >>> count_prefixes([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == 0 >>> count_prefixes([\\"xyz\\", \\"xy\\", \\"x\\", \\"a\\"]) == 2 >>> count_prefixes([]) == 0 >>> count_prefixes([\\"a\\"]) == 0","solution":"def count_prefixes(words): Returns the number of strings in \`words\` that are prefixes of at least one other string in the list. count = 0 for i, word1 in enumerate(words): is_prefix = any(word2.startswith(word1) for j, word2 in enumerate(words) if i != j) if is_prefix: count += 1 return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def even_odd_level_difference(root: TreeNode) -> int: Determine the sum of all nodes which are at an even level, subtracted by the sum of all nodes which are at an odd level in a given binary tree. >>> root = TreeNode(1) >>> even_odd_level_difference(root) 1 >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> even_odd_level_difference(root) -4 >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> even_odd_level_difference(root) 8","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def even_odd_level_difference(root): if not root: return 0 from collections import deque queue = deque([(root, 0)]) even_sum = 0 odd_sum = 0 while queue: node, level = queue.popleft() if level % 2 == 0: even_sum += node.val else: odd_sum += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return even_sum - odd_sum"},{"question":"def get_earliest_meeting_time(intervals): Determines the earliest time at which a 1-unit meeting can start, given that everyone must be available. :param intervals: List of tuples, where each tuple is (start, end) :return: Earliest start time of the meeting or -1 if no such time exists >>> get_earliest_meeting_time([(1, 4), (2, 5), (3, 6)]) == 3 >>> get_earliest_meeting_time([(1, 2), (2, 3), (3, 4)]) == -1 >>> get_earliest_meeting_time([(1, 5)]) == 1 >>> get_earliest_meeting_time([(1, 2), (3, 4), (5, 6)]) == -1 >>> get_earliest_meeting_time([]) == -1 >>> get_earliest_meeting_time([(2, 5), (2, 5), (2, 5)]) == 2 >>> get_earliest_meeting_time([(1, 5), (2, 6), (4, 7)]) == 4","solution":"def get_earliest_meeting_time(intervals): Determines the earliest time at which a 1-unit meeting can start, given that everyone must be available. :param intervals: List of tuples, where each tuple is (start, end) :return: Earliest start time of the meeting or -1 if no such time exists if not intervals: return -1 # Find the latest start time and earliest end time to establish the common available window latest_start = max(interval[0] for interval in intervals) earliest_end = min(interval[1] for interval in intervals) # Check if there is a common available time slot of at least 1 time unit if latest_start < earliest_end: return latest_start else: return -1"},{"question":"from typing import List, Tuple def min_steps_to_exit(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Determine the minimum number of steps needed to reach the ending point from the starting point in a grid. >>> min_steps_to_exit( ... [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ], ... (0, 0), ... (3, 3) ... ) 6 >>> min_steps_to_exit( ... [ ... [0, 0, 1, 0], ... [1, 1, 1, 1], ... [0, 0, 0, 0] ... ], ... (0, 0), ... (2, 3) ... ) -1 >>> min_steps_to_exit( ... [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ], ... (0, 0), ... (2, 2) ... ) -1 >>> min_steps_to_exit( ... [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ], ... (0, 0), ... (2, 2) ... ) -1 >>> min_steps_to_exit( ... [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ], ... (0, 0), ... (2, 2) ... ) 4 >>> min_steps_to_exit( ... [ ... [0, 0], ... [0, 0] ... ], ... (0, 0), ... (0, 1) ... ) 1 >>> min_steps_to_exit( ... [ ... [0, 0], ... [0, 0] ... ], ... (1, 1), ... (1, 1) ... ) 0","solution":"from typing import List, Tuple from collections import deque def min_steps_to_exit(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 n, m = len(grid), len(grid[0]) sx, sy = start ex, ey = end # Edge case: if start or end is a wall if grid[sx][sy] == 1 or grid[ex][ey] == 1: return -1 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] queue = deque([(sx, sy, 0)]) # (x, y, steps) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (ex, ey): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"class Solution: def __init__(self, nums): Initializes the object with the array nums. self.nums = nums def minimumDifference(self) -> int: Returns the minimum possible absolute difference between the sum of the coins in the two groups after dividing the array nums. >>> Solution([1, 2, 3, 4, 5, 6]).minimumDifference() 1 >>> Solution([10]).minimumDifference() 10 >>> Solution([4, 4, 4, 4]).minimumDifference() 0 >>> Solution([15, 10, 5, 25]).minimumDifference() 5 >>> Solution([0, 0, 0, 0]).minimumDifference() 0","solution":"class Solution: def __init__(self, nums): self.nums = nums def minimumDifference(self): total_sum = sum(self.nums) n = len(self.nums) dp = [0] * (total_sum // 2 + 1) for num in self.nums: for j in range(total_sum // 2, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) group1 = dp[-1] group2 = total_sum - group1 return abs(group2 - group1)"},{"question":"from typing import List def max_candies(candies: List[int]) -> int: Given a list of integers representing the number of candies in each bag, returns the maximum number of candies a kid can collect in one go. A kid can choose at most two bags, but they can only leave with at most one bag's worth of candies. >>> max_candies([5]) 5 >>> max_candies([3, 7]) 7 >>> max_candies([5, 10, 2, 8]) 10 >>> max_candies([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) 9 >>> max_candies([4, 4, 4, 4]) 4 >>> max_candies([]) 0","solution":"def max_candies(candies): Given a list of integers representing the number of candies in each bag, returns the maximum number of candies a kid can collect in one go. A kid can choose at most two bags, but they can only leave with at most one bag's worth of candies. if not candies: return 0 if len(candies) == 1: return candies[0] candies.sort(reverse=True) return max(candies[0], candies[1])"},{"question":"from typing import List def min_operations_to_one_distinct(nums: List[int]) -> int: Returns the minimum number of operations required to make the array nums contain no more than one distinct element. >>> min_operations_to_one_distinct([1, 3, 3, 2, 3, 1]) 3 >>> min_operations_to_one_distinct([1, 1, 1, 1]) 0 >>> min_operations_to_one_distinct([1, 2, 3, 4]) 3 >>> min_operations_to_one_distinct([]) 0 >>> min_operations_to_one_distinct([5, 5, 6]) 1 >>> min_operations_to_one_distinct([2, 2, 3, 3]) 2 >>> min_operations_to_one_distinct([1] * 100000 + [2] * 50000) 50000","solution":"from collections import Counter def min_operations_to_one_distinct(nums): Returns the minimum number of operations required to make the array nums contain no more than one distinct element. if not nums: return 0 # Count the frequency of each number in the array freq = Counter(nums) # Find the count of the most frequent element most_frequent_count = max(freq.values()) # Minimum operations are needed to remove all elements except the most frequent one return len(nums) - most_frequent_count"},{"question":"def subsequence_indexes(textQuoteStore: List[str], quote: str) -> List[int]: Returns a list of indexes of the quotes in textQuoteStore where 'quote' is a subsequence. >>> subsequence_indexes([\\"hello world\\", \\"herb\\", \\"hhooo\\"], \\"ho\\") == [0, 2] >>> subsequence_indexes([\\"abc\\", \\"def\\", \\"ghi\\"], \\"z\\") == [] >>> subsequence_indexes([\\"a quick brown fox\\", \\"a slow brown fox\\", \\"quick brown fox\\"], \\"quick\\") == [0, 2] >>> subsequence_indexes([\\"whatever\\", \\"you\\", \\"want\\"], \\"\\") == [0, 1, 2] >>> subsequence_indexes([], \\"abc\\") == [] >>> subsequence_indexes([\\"abcd\\", \\"abcde\\", \\"abcdef\\"], \\"abc\\") == [0, 1, 2]","solution":"def is_subsequence(s, t): Helper function to determine if the string s is a subsequence of t. iter_t = iter(t) return all(char in iter_t for char in s) def subsequence_indexes(textQuoteStore, quote): Returns a list of indexes of the quotes in textQuoteStore where 'quote' is a subsequence. result = [] for i, text in enumerate(textQuoteStore): if is_subsequence(quote, text): result.append(i) return result"},{"question":"from typing import List def maxRobbedAmount(houses: List[int]) -> int: Returns the maximum amount of money the thief can rob without triggering the alarm. :param houses: List of non-negative integers representing the amount of money on each house :return: int, the maximum amount of money that can be robbed >>> maxRobbedAmount([]) 0 >>> maxRobbedAmount([5]) 5 >>> maxRobbedAmount([2, 3]) 3 >>> maxRobbedAmount([2, 7, 9, 3, 1]) 12 >>> maxRobbedAmount([2, 1, 1, 2]) 4 >>> houses = [i for i in range(1, 101)] >>> maxRobbedAmount(houses) 2550","solution":"def maxRobbedAmount(houses): Returns the maximum amount of money the thief can rob without triggering the alarm. :param houses: List of non-negative integers representing the amount of money on each house :return: int, the maximum amount of money that can be robbed if not houses: return 0 elif len(houses) == 1: return houses[0] n = len(houses) dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"def longest_subsequence(nums: List[int], limit: int) -> int: Find the length of the longest subsequence of consecutive tasks such that the total execution time does not exceed the given limit. >>> longest_subsequence([5, 6, 7], 4) 0 >>> longest_subsequence([1, 2, 3], 10) 3 >>> longest_subsequence([1, 2, 3, 4, 5], 9) 3 >>> longest_subsequence([10, 1, 2, 3], 1) 1 >>> longest_subsequence([4, 2, 1, 6, 5], 8) 3 >>> longest_subsequence([5, 3, 6, 7, 2], 6) 1","solution":"def longest_subsequence(nums, limit): max_length = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > limit: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def is_one_edit_away(str1: str, str2: str) -> bool: Determine if two strings are one edit away from being the same. >>> is_one_edit_away(\\"abc\\", \\"abc\\") == True >>> is_one_edit_away(\\"abc\\", \\"abca\\") == True >>> is_one_edit_away(\\"abc\\", \\"aabc\\") == True >>> is_one_edit_away(\\"abc\\", \\"ab\\") == True >>> is_one_edit_away(\\"abc\\", \\"bc\\") == True >>> is_one_edit_away(\\"abc\\", \\"adc\\") == True >>> is_one_edit_away(\\"abc\\", \\"bbc\\") == True >>> is_one_edit_away(\\"abc\\", \\"def\\") == False >>> is_one_edit_away(\\"abc\\", \\"abcddef\\") == False >>> is_one_edit_away(\\"abc\\", \\"abcfghij\\") == False","solution":"def is_one_edit_away(str1, str2): Determine if two strings are one edit away from being the same. len1, len2 = len(str1), len(str2) # If the length difference is greater than 1, they can't be one edit away. if abs(len1 - len2) > 1: return False # Identify the longer and shorter strings. if len1 > len2: longer, shorter = str1, str2 else: longer, shorter = str2, str1 index_longer = index_shorter = 0 found_difference = False while index_longer < len(longer) and index_shorter < len(shorter): if longer[index_longer] != shorter[index_shorter]: if found_difference: return False found_difference = True # If the lengths are the same, move both indices. if len1 == len2: index_shorter += 1 else: index_shorter += 1 index_longer += 1 return True"},{"question":"def findPairsWithSum(nums, target): Returns a list of unique pairs [a, b] such that a + b == target. >>> findPairsWithSum([1, 2, 3], 7) [] >>> findPairsWithSum([1, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> findPairsWithSum([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> findPairsWithSum([-1, -2, -3, 0, 1, 2, 3], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> findPairsWithSum([1, 1, 2, 2, 3, 3, 4, 4], 5) [(1, 4), (2, 3)] >>> findPairsWithSum([1, -1, 2, -2, 3, -3, 4, -4], 0) [(-4, 4), (-3, 3), (-2, 2), (-1, 1)] >>> findPairsWithSum([], 5) []","solution":"def findPairsWithSum(nums, target): Returns a list of unique pairs [a, b] such that a + b == target nums = sorted(nums) pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(list(pairs))"},{"question":"from typing import List, Tuple def minConferenceRooms(events: List[Tuple[int, int]]) -> int: Determine the minimum number of conference rooms required to host all events. Args: events (List[Tuple[int, int]]): A list of intervals, where each interval is a pair of integers [start, end]. Returns: int: The minimum number of conference rooms required. Examples: >>> minConferenceRooms([]) 0 >>> minConferenceRooms([(10, 20)]) 1 >>> minConferenceRooms([(10, 20), (20, 30)]) 1 >>> minConferenceRooms([(0, 30), (5, 10), (15, 20)]) 2 >>> minConferenceRooms([(0, 10), (5, 15), (10, 20)]) 2 >>> minConferenceRooms([(10, 15), (10, 12), (12, 14), (13, 20), (15, 18)]) 3 pass","solution":"from typing import List, Tuple import heapq def minConferenceRooms(events: List[Tuple[int, int]]) -> int: if not events: return 0 # Sort the events by start time events.sort(key=lambda x: x[0]) # Create a min heap to track the end times of ongoing events min_heap = [] # Start by adding the first event's end time to the heap heapq.heappush(min_heap, events[0][1]) for i in range(1, len(events)): # Compare the start time of the current event with the earliest end time if events[i][0] >= min_heap[0]: # If the current event starts after the earliest event ends, remove the earliest event heapq.heappop(min_heap) # Add the current event's end time to the heap heapq.heappush(min_heap, events[i][1]) # The size of the heap is the minimum number of conference rooms required return len(min_heap)"},{"question":"def max_array_value(nums: list[int], k: int, updates: list[list[int]]) -> int: Returns the maximum value of the modified array nums after k range updates. Parameters: nums (list of int): The initial array of integers. k (int): The number of updates to be applied. updates (list of list of int): Each update is a list [l, r, v] meaning increment each nums[i] by v for all l <= i <= r. Returns: int: The maximum value of the array nums after all updates. Examples: >>> max_array_value([1, 2, 3, 4], 1, [[1, 2, 10]]) 13 >>> max_array_value([1, 2, 3, 4], 2, [[1, 2, 10], [2, 3, 5]]) 18 >>> max_array_value([1, 2, 3, 4], 0, []) 4 >>> max_array_value([1, 2, 3, 4], 1, [[0, 3, 10]]) 14 >>> max_array_value([1, 2, 3, 4], 1, [[0, 0, 100]]) 101 >>> max_array_value([1, 2, 3, 4], 1, [[0, 10000, 1]]) 5 >>> max_array_value([1, 2, 3, 4], 3, [[0, 1, 5], [1, 2, 10], [2, 3, 5]]) 18","solution":"def max_array_value(nums, k, updates): Returns the maximum value of the modified array nums after k range updates. Parameters: nums (list of int): The initial array of integers. k (int): The number of updates to be applied. updates (list of list of int): Each update is a list [l, r, v] meaning increment each nums[i] by v for all l <= i <= r. Returns: int: The maximum value of the array nums after all updates. n = len(nums) delta = [0] * (n + 1) for l, r, v in updates[:k]: delta[l] += v if r + 1 < n: delta[r + 1] -= v running_sum = 0 for i in range(n): running_sum += delta[i] nums[i] += running_sum return max(nums)"},{"question":"def is_sparse_matrix(mat: List[List[int]]) -> bool: Returns True if the matrix is sparse (more than 70% of its elements are zero), otherwise False. >>> is_sparse_matrix([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) == True >>> is_sparse_matrix([ [1, 0, 0], [0, 1, 0], [1, 0, 1] ]) == False >>> is_sparse_matrix([ [0, 0, 0], [0, 1, 1], [0, 0, 0] ]) == True >>> is_sparse_matrix([]) == False >>> is_sparse_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == False >>> is_sparse_matrix([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == True # Your implementation here","solution":"def is_sparse_matrix(mat): Returns True if the matrix is sparse (more than 70% of its elements are zero), otherwise False. if not mat: return False # An empty matrix is not considered sparse total_elements = len(mat) * len(mat[0]) zero_count = sum(row.count(0) for row in mat) return (zero_count / total_elements) > 0.7"},{"question":"from typing import List def find_invalid_transactions(transactions: List[str]) -> List[str]: Identify and return a list of all transactions that are considered \\"invalid.\\" A transaction is invalid if: 1. The amount exceeds 1000, or, 2. There are multiple transactions by the same person within a 60-minute window (including the current transaction). >>> find_invalid_transactions([\\"Alice 20 1200\\"]) [\\"Alice 20 1200\\"] >>> find_invalid_transactions([ ... \\"Alice 20 800\\", ... \\"Alice 50 900\\", ... \\"Bob 500 500\\", ... \\"Alice 100 1200\\" ... ]) [\\"Alice 20 800\\", \\"Alice 50 900\\", \\"Alice 100 1200\\"] >>> find_invalid_transactions([ ... \\"Alice 20 300\\", ... \\"Bob 30 500\\", ... \\"Alice 55 200\\", ... \\"Bob 700 1100\\", ... \\"Alice 75 600\\", ... \\"Bob 1000 200\\" ... ]) [\\"Alice 20 300\\", \\"Alice 55 200\\", \\"Bob 700 1100\\", \\"Alice 75 600\\"] >>> find_invalid_transactions([ ... \\"Alice 20 300\\", ... \\"Bob 30 500\\", ... \\"Alice 150 200\\", ... \\"Bob 700 700\\", ... \\"Alice 5000 600\\", ... \\"Bob 10000 200\\" ... ]) [] >>> find_invalid_transactions([ ... \\"Alice 20 1500\\", ... \\"Alice 50 300\\", ... \\"Bob 60 500\\", ... \\"Alice 75 600\\", ... \\"Bob 80 1100\\" ... ]) [\\"Alice 20 1500\\", \\"Alice 50 300\\", \\"Bob 60 500\\", \\"Alice 75 600\\", \\"Bob 80 1100\\"] pass # Write your implementation here","solution":"def find_invalid_transactions(transactions): Returns a list of invalid transactions based on the given rules. result = [] transactions_data = [t.split() for t in transactions] for i, transaction in enumerate(transactions_data): name, time, amount = transaction time = int(time) amount = int(amount) # Rule 1: Amount exceeds 1000 if amount > 1000: result.append(transactions[i]) continue # Rule 2: Multiple transactions by the same person within a 60-minute window for j, other_transaction in enumerate(transactions_data): if i != j and other_transaction[0] == name: other_time = int(other_transaction[1]) if abs(time - other_time) <= 60: result.append(transactions[i]) break return result"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring('') == 0 >>> length_of_longest_substring('a') == 1 >>> length_of_longest_substring('bbbbb') == 1 >>> length_of_longest_substring('abcdefg') == 7 >>> length_of_longest_substring('abcabcbb') == 3 >>> length_of_longest_substring('pwwkew') == 3 >>> length_of_longest_substring('dvdf') == 3 >>> length_of_longest_substring('abcdefghijklmnopqrstuvwxyz') == 26 >>> length_of_longest_substring('abcbabcdbb') == 4","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"def maxDistToClosest(seats: List[int]) -> int: Returns the maximum distance to the closest person in a row of seats. >>> maxDistToClosest([1, 0, 0, 0, 1]) 2 >>> maxDistToClosest([0, 1, 0, 0, 0]) 3 >>> maxDistToClosest([1, 0, 1]) 1","solution":"def maxDistToClosest(seats): Returns the maximum distance to the closest person. max_dist = 0 last_occupied = -1 for i, seat in enumerate(seats): if seat == 1: if last_occupied == -1: max_dist = i else: max_dist = max(max_dist, (i - last_occupied) // 2) last_occupied = i max_dist = max(max_dist, len(seats) - 1 - last_occupied) return max_dist"},{"question":"def are_vectors_forming_triangle(A, B, C): Determines if three vectors can form a triangle. Parameters: A, B, C : tuple Endpoints of the vectors represented as tuples (x, y). Returns: bool True if the vectors can form a triangle, False otherwise. >>> are_vectors_forming_triangle((1, 1), (2, 3), (3, 2)) True >>> are_vectors_forming_triangle((1, 1), (2, 2), (3, 3)) False >>> are_vectors_forming_triangle((0, 1), (0, 2), (0, 3)) False >>> are_vectors_forming_triangle((1, 1), (1, 1), (1, 1)) False >>> are_vectors_forming_triangle((0, 0), (1, 1), (2, 2)) False","solution":"def are_vectors_forming_triangle(A, B, C): Determines if three vectors can form a triangle. Parameters: A, B, C : tuple Endpoints of the vectors represented as tuples (x, y). Returns: bool True if the vectors can form a triangle, False otherwise. def area_of_triangle(A, B, C): Calculates the area of the triangle formed by vectors A, B, and C using the determinant method. Parameters: A, B, C : tuple Endpoints of the vectors represented as tuples (x, y). Returns: float The area of the triangle. return 0.5 * abs(A[0]*(B[1] - C[1]) + B[0]*(C[1] - A[1]) + C[0]*(A[1] - B[1])) # Calculate the area of the triangle formed by the vectors A, B, and C area = area_of_triangle(A, B, C) # If the area is zero, the vectors are collinear and cannot form a triangle return area != 0"},{"question":"class HappyCharacters: def __init__(self, s): Initializes the HappyCharacters object with the string s. pass def longestHappyGroup(self): Returns the length of the longest group of consecutive 'happy' characters in s. If the string is empty, returns 0. pass # Test Cases if __name__ == \\"__main__\\": hc = HappyCharacters(\\"\\") assert hc.longestHappyGroup() == 0, \\"Test case 1 failed\\" hc = HappyCharacters(\\"abcde\\") assert hc.longestHappyGroup() == 1, \\"Test case 2 failed\\" hc = HappyCharacters(\\"aaaaa\\") assert hc.longestHappyGroup() == 5, \\"Test case 3 failed\\" hc = HappyCharacters(\\"aabbccccdd\\") assert hc.longestHappyGroup() == 4, \\"Test case 4 failed\\" hc = HappyCharacters(\\"z\\") assert hc.longestHappyGroup() == 1, \\"Test case 5 failed\\" hc = HappyCharacters(\\"ababababa\\") assert hc.longestHappyGroup() == 1, \\"Test case 6 failed\\" print(\\"All test cases pass\\")","solution":"class HappyCharacters: def __init__(self, s): Initializes the HappyCharacters object with the string s. self.s = s def longestHappyGroup(self): Returns the length of the longest group of consecutive 'happy' characters in s. If the string is empty, returns 0. if not self.s: return 0 max_length = 1 current_length = 1 for i in range(1, len(self.s)): if self.s[i] == self.s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def majority_element(arr): Finds the majority element in the array that appears more than ⌊n / 2⌋ times. Assumes the majority element always exists. >>> majority_element([1]) == 1 >>> majority_element([2, 2, 2, 2, 2]) == 2 >>> majority_element([3, 3, 4, 3, 3]) == 3 >>> majority_element([-1, -1, -1, 2, -1, 2, 2]) == -1 >>> majority_element([10, 9, 9, 10, 10, 10]) == 10","solution":"def majority_element(arr): Finds the majority element in the array that appears more than ⌊n / 2⌋ times. Assumes the majority element always exists. :param arr: List[int] - The input array of integers :return: int - The majority element count = 0 candidate = None for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Given an n x n matrix where each of the rows and columns is sorted in ascending order, write a function to determine the k-th smallest element in the matrix. Assume k is always valid, 1 ≤ k ≤ n². # Implementation goes here # Unit test cases def test_small_matrix(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] assert kth_smallest(matrix, 1) == 1 assert kth_smallest(matrix, 2) == 5 assert kth_smallest(matrix, 5) == 11 assert kth_smallest(matrix, 8) == 13 def test_single_element_matrix(): matrix = [ [7] ] assert kth_smallest(matrix, 1) == 7 def test_two_by_two_matrix(): matrix = [ [1, 3], [2, 4] ] assert kth_smallest(matrix, 1) == 1 assert kth_smallest(matrix, 2) == 2 assert kth_smallest(matrix, 3) == 3 assert kth_smallest(matrix, 4) == 4 def test_large_k(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert kth_smallest(matrix, 9) == 9 assert kth_smallest(matrix, 5) == 5 def test_example_with_duplicates(): matrix = [ [1, 2, 2], [2, 2, 4], [3, 3, 5] ] assert kth_smallest(matrix, 4) == 2 assert kth_smallest(matrix, 7) == 3","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in the matrix. n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(k, n)): # We only need to consider at most the first k rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min from heap k times num = 0 for _ in range(k): num, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return num"},{"question":"from typing import List, Tuple def shortest_path_binary_matrix(mat: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Finds the shortest distance from start cell to target cell in a binary matrix. :param mat: List[List[int]], a binary matrix where 1 represents a wall and 0 represents an open space. :param start: Tuple[int, int], the starting position (start_row, start_col). :param target: Tuple[int, int], the target position (target_row, target_col). :return: int, the shortest distance from start to target, or -1 if no path exists. pass def test_shortest_path_binary_matrix(): mat = [ [0, 0, 1], [0, 1, 0], [0, 0, 0] ] start = (0, 0) target = (2, 2) assert shortest_path_binary_matrix(mat, start, target) == 4 def test_no_path_exists(): mat = [ [0, 1, 0], [1, 1, 0], [0, 1, 0] ] start = (0, 0) target = (2, 2) assert shortest_path_binary_matrix(mat, start, target) == -1 def test_start_is_wall(): mat = [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ] start = (0, 0) target = (2, 2) assert shortest_path_binary_matrix(mat, start, target) == -1 def test_target_is_wall(): mat = [ [0, 0, 0], [0, 1, 0], [0, 0, 1] ] start = (0, 0) target = (2, 2) assert shortest_path_binary_matrix(mat, start, target) == -1 def test_start_equals_target(): mat = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] start = (1, 2) target = (1, 2) assert shortest_path_binary_matrix(mat, start, target) == 0 def test_large_matrix(): mat = [[0 for _ in range(100)] for _ in range(100)] start = (0, 0) target = (99, 99) assert shortest_path_binary_matrix(mat, start, target) == 198","solution":"from collections import deque def shortest_path_binary_matrix(mat, start, target): Finds the shortest distance from start cell to target cell in binary matrix. :param mat: List[List[int]], a binary matrix where 1 represents wall and 0 represents open space. :param start: Tuple[int, int], the starting position (start_row, start_col). :param target: Tuple[int, int], the target position (target_row, target_col). :return: int, the shortest distance from start to target, or -1 if no path exists. rows, cols = len(mat), len(mat[0]) start_row, start_col = start target_row, target_col = target # Validate start and target positions if mat[start_row][start_col] == 1 or mat[target_row][target_col] == 1: return -1 # Initialize the queue for BFS and the set for visited nodes queue = deque([(start_row, start_col, 0)]) visited = set() visited.add((start_row, start_col)) # BFS to find the shortest path directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, down, left, right while queue: current_row, current_col, distance = queue.popleft() # Check if we have reached the target if (current_row, current_col) == (target_row, target_col): return distance # Explore all possible moves for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and mat[new_row][new_col] == 0: queue.append((new_row, new_col, distance + 1)) visited.add((new_row, new_col)) # If we haven't found the target, return -1 return -1"},{"question":"def find_the_difference(s: str, t: str) -> str: Returns the additional letter that was added to \`s\`. \`s\` is generated by shuffling the letters of \`t\` and adding one additional letter. >>> find_the_difference(\\"abcd\\", \\"abc\\") 'd' >>> find_the_difference(\\"eabcd\\", \\"abcd\\") 'e' >>> find_the_difference(\\"abcdz\\", \\"abcd\\") 'z' >>> find_the_difference(\\"abcde\\", \\"abcd\\") 'e' >>> find_the_difference(\\"aaaaaaab\\", \\"aaaaaaa\\") 'b' >>> find_the_difference(\\"xyzabc\\", \\"xyzab\\") 'c'","solution":"def find_the_difference(s, t): Returns the additional letter that was added to \`s\`. \`s\` is generated by shuffling the letters of \`t\` and adding one additional letter. # Using XOR operation to find the additional letter result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"def max_subsequence_sum(arr, d): Finds the maximum sum of a subsequence of array \`arr\` such that the difference between the indices of any two consecutive elements in this subsequence is at least \`d\`. Parameters: arr (list): The input array of integers d (int): The minimum allowed difference between indices of consecutive elements in the subsequence Returns: int: The maximum sum of such a subsequence Examples: >>> max_subsequence_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subsequence_sum([1, 1, 1, 1, 1], 1) 5","solution":"def max_subsequence_sum(arr, d): Finds the maximum sum of a subsequence of array \`arr\` such that the difference between the indices of any two consecutive elements in this subsequence is at least \`d\`. Parameters: arr (list): The input array of integers d (int): The minimum allowed difference between indices of consecutive elements in the subsequence Returns: int: The maximum sum of such a subsequence n = len(arr) if n == 0: return 0 # Initialize a dp array where dp[i] is the maximum sum of subsequence ending at index i dp = [0] * n # Initialize max_sum to the highest value in arr max_sum = max(arr) for i in range(n): dp[i] = arr[i] # The subsequence starting and ending at i if i >= d: # Update dp[i] by adding the maximum dp[j] (0 <= j <= i-d) dp[i] += max(dp[j] for j in range(i - d + 1)) # Update the overall maximum sum max_sum = max(max_sum, dp[i]) return max_sum"},{"question":"def min_removal_to_avoid_consecutive_duplicates(s: str) -> int: Determine the length of the shortest substring that can be removed from \`s\` such that the resulting string contains no consecutive characters that are the same. If the string already has no such consecutive characters, return \`0\`. If it's impossible by removing exactly one substring, return \`-1\`. >>> min_removal_to_avoid_consecutive_duplicates(\\"abc\\") == 0 >>> min_removal_to_avoid_consecutive_duplicates(\\"aab\\") == 1 >>> min_removal_to_avoid_consecutive_duplicates(\\"abb\\") == 1 >>> min_removal_to_avoid_consecutive_duplicates(\\"aabbab\\") == 2 >>> min_removal_to_avoid_consecutive_duplicates(\\"aaa\\") == 2 >>> min_removal_to_avoid_consecutive_duplicates(\\"abbaa\\") == 2 >>> min_removal_to_avoid_consecutive_duplicates(\\"bb\\") == 1 >>> min_removal_to_avoid_consecutive_duplicates(\\"abcde\\") == 0 >>> min_removal_to_avoid_consecutive_duplicates(\\"abcdefg\\") == 0 >>> min_removal_to_avoid_consecutive_duplicates(\\"a\\" * 1000) == 999 >>> min_removal_to_avoid_consecutive_duplicates(\\"a\\") == 0 >>> min_removal_to_avoid_consecutive_duplicates(\\"\\") == 0","solution":"def min_removal_to_avoid_consecutive_duplicates(s): n = len(s) # Check if string already meets the requirement if all(s[i] != s[i + 1] for i in range(n - 1)): return 0 # Try to find the minimum length substring to remove for length in range(1, n): for i in range(n - length + 1): new_s = s[:i] + s[i + length:] if all(new_s[j] != new_s[j + 1] for j in range(len(new_s) - 1)): return length # If no valid removal found, return -1 return -1"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects the start of the cycle in a linked list, if it exists. Args: head (ListNode): Head of the linked list. Returns: ListNode: Node where the cycle begins, or None if there is no cycle.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects the start of the cycle in a linked list, if it exists. Args: head (ListNode): Head of the linked list. Returns: ListNode: Node where the cycle begins, or None if there is no cycle. if not head: return None slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle detected return None # Start from the head and the meeting point to find the cycle start slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Prunes the binary tree by removing subtrees that contain all 0s. pass def tree_to_list(root): Helper function to convert tree to list level-wise. if not root: return [] result = [] queue = [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) while result and result[-1] is None: result.pop() return result def test_prune_tree(): root = TreeNode(1) root.right = TreeNode(0) root.right.left = TreeNode(0) root.right.right = TreeNode(1) expected = [1, None, 0, None, 1] pruned_tree = pruneTree(root) assert tree_to_list(pruned_tree) == expected def test_prune_tree_all_zeros(): root = TreeNode(0) root.left = TreeNode(0) root.right = TreeNode(0) expected = [] pruned_tree = pruneTree(root) assert tree_to_list(pruned_tree) == expected def test_prune_tree_mixed(): root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(1) root.left.left = TreeNode(0) root.left.right = TreeNode(0) root.right.left = TreeNode(0) root.right.right = TreeNode(1) expected = [1, None, 1, None, 1] pruned_tree = pruneTree(root) assert tree_to_list(pruned_tree) == expected def test_prune_tree_single_node(): root = TreeNode(1) expected = [1] pruned_tree = pruneTree(root) assert tree_to_list(pruned_tree) == expected def test_prune_tree_single_zero_node(): root = TreeNode(0) expected = [] pruned_tree = pruneTree(root) assert tree_to_list(pruned_tree) == expected","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Prunes the binary tree by removing subtrees that contain all 0s. def prune(node): if not node: return None node.left = prune(node.left) node.right = prune(node.right) if node.val == 0 and not node.left and not node.right: return None return node return prune(root)"},{"question":"def depth_sum(nestedList: List[Any]) -> int: Calculates the weighted sum of all numbers in the nested list based on their depth levels. Unit Tests: >>> depth_sum([[1, 1], 2, [1, 1]]) == 10 >>> depth_sum([1, [4, [6]]]) == 27 >>> depth_sum([]) == 0 >>> depth_sum([1, 2, 3, 4]) == 10 >>> depth_sum([[[[[[5]]]]]]) == 5*6 >>> depth_sum([1, [2, [3, [4, [5]]]]]) == 1*1 + 2*2 + 3*3 + 4*4 + 5*5 >>> depth_sum([[0, [0], [0, [0]]], 0]) == 0","solution":"def depth_sum(nestedList): Calculates the weighted sum of all numbers in the nested list based on their depth levels. def helper(nList, depth): result = 0 for element in nList: if isinstance(element, int): result += element * depth else: result += helper(element, depth + 1) return result return helper(nestedList, 1)"},{"question":"def can_reach_end(heights: List[int], k: int) -> bool: Determine if you can reach the last building from the first building by jumping between buildings. Each jump between buildings i and j must satisfy |heights[i] - heights[j]| <= k. >>> can_reach_end([5], 3) == True >>> can_reach_end([1, 1, 1, 1], 0) == True >>> can_reach_end([1, 3, 5, 6], 2) == True >>> can_reach_end([1, 3, 7, 10], 2) == False >>> can_reach_end([1, 100, 200, 300], 500) == True >>> can_reach_end([1, 10], 9) == True >>> can_reach_end([1, 10], 8) == False","solution":"def can_reach_end(heights, k): n = len(heights) if n == 1: return True # Single building, trivially true dp = [False] * n # dp[i] means if we can reach building i dp[0] = True for i in range(n): if dp[i]: # If building i is reachable for j in range(i + 1, n): if abs(heights[i] - heights[j]) <= k: dp[j] = True # Mark building j as reachable return dp[-1] # Can we reach the last building?"},{"question":"def get_second_highest_position_level_employees(): SQL query to find all employees with the second-highest position level.","solution":"def get_second_highest_position_level_employees(): SQL query to find all employees with the second-highest position level. query = SELECT employee_id FROM employees WHERE position_level = ( SELECT DISTINCT position_level FROM employees ORDER BY position_level DESC LIMIT 1 OFFSET 1 ) ORDER BY employee_id ASC; return query"},{"question":"def flood_fill(image, sr, sc, newColor): Perform a flood fill on the image starting from the given starting point and replacing the color of connected pixels with the new color. :param image: List[List[int]] - 2D grid representing the image :param sr: int - starting row index :param sc: int - starting column index :param newColor: int - the new color to apply :return: List[List[int]] - the image after flood fill pass # Test Cases def test_flood_fill_single_cell(): image = [[0]] sr, sc = 0, 0 newColor = 1 expected = [[1]] assert flood_fill(image, sr, sc, newColor) == expected def test_flood_fill_adjacent_pixels(): image = [ [1, 1, 0], [1, 0, 1], [0, 1, 1] ] sr, sc = 1, 0 newColor = 2 expected = [ [2, 2, 0], [2, 0, 1], [0, 1, 1] ] assert flood_fill(image, sr, sc, newColor) == expected def test_flood_fill_no_change(): image = [ [1, 1, 0], [1, 0, 1], [0, 1, 1] ] sr, sc = 1, 0 newColor = 1 assert flood_fill(image, sr, sc, newColor) == image def test_flood_fill_large_image(): image = [ [0, 0, 1, 1], [0, 1, 1, 1], [1, 1, 0, 0], [1, 0, 0, 0] ] sr, sc = 2, 2 newColor = 2 expected = [ [0, 0, 1, 1], [0, 1, 1, 1], [1, 1, 2, 2], [1, 2, 2, 2] ] assert flood_fill(image, sr, sc, newColor) == expected def test_flood_fill_diagonal_do_not_fill(): image = [ [1, 1, 0], [0, 1, 0], [0, 0, 1] ] sr, sc = 0, 0 newColor = 2 expected = [ [2, 2, 0], [0, 2, 0], [0, 0, 1] ] assert flood_fill(image, sr, sc, newColor) == expected","solution":"def flood_fill(image, sr, sc, newColor): Perform a flood fill on the image starting from the given starting point and replacing the color of connected pixels with the new color. :param image: List[List[int]] - 2D grid representing the image :param sr: int - starting row index :param sc: int - starting column index :param newColor: int - the new color to apply :return: List[List[int]] - the image after flood fill rows, cols = len(image), len(image[0]) oldColor = image[sr][sc] if oldColor == newColor: return image def fill(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or image[r][c] != oldColor: return image[r][c] = newColor fill(r + 1, c) fill(r - 1, c) fill(r, c + 1) fill(r, c - 1) fill(sr, sc) return image"},{"question":"def studentsDoingHomework(startTimes, endTimes, queryTime): Returns the number of students doing their homework at queryTime. :param startTimes: List of integers, each representing the start time of homework for a student :param endTimes: List of integers, each representing the end time of homework for a student :param queryTime: An integer representing the specific time to query :return: The number of students doing their homework at queryTime >>> studentsDoingHomework([], [], 5) == 0 >>> studentsDoingHomework([1], [3], 2) == 1 >>> studentsDoingHomework([1], [3], 4) == 0 >>> studentsDoingHomework([1, 2, 3], [3, 4, 5], 3) == 3 >>> studentsDoingHomework([1, 2, 3], [3, 4, 5], 6) == 0 >>> studentsDoingHomework([1, 2, 3], [3, 4, 5], 2) == 2 >>> studentsDoingHomework([1, 2, 3], [3, 4, 5], 1) == 1 >>> studentsDoingHomework([1, 2, 3], [3, 4, 5], 5) == 1 >>> studentsDoingHomework([1, 5, 8], [3, 9, 10], 7) == 1","solution":"def studentsDoingHomework(startTimes, endTimes, queryTime): Returns the number of students doing their homework at queryTime. :param startTimes: List of integers, each representing the start time of homework for a student :param endTimes: List of integers, each representing the end time of homework for a student :param queryTime: An integer representing the specific time to query :return: The number of students doing their homework at queryTime count = 0 for start, end in zip(startTimes, endTimes): if start <= queryTime <= end: count += 1 return count"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given the array \`nums\` and an integer \`target\`, return the indices of the two numbers such that they add up to the \`target\`. You can assume that each input would have exactly one solution, and you may not use the same element twice. >>> two_sum([2, 7, 11, 15], 9) == [0, 1] >>> two_sum([-3, 4, 3, 90], 0) == [0, 2] >>> two_sum([0, 4, 3, 0], 0) == [0, 3] >>> two_sum([1, 2, 3, 4, 5], 6) == [1, 3] >>> two_sum([5, 75, 25, 90], 100) == [1, 2]","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to target. num_map = {} for index, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], index] num_map[num] = index"},{"question":"def max_non_overlapping_jobs(startTime: List[int], endTime: List[int]) -> int: Find the maximum number of non-overlapping jobs from the given start and end times of jobs. >>> max_non_overlapping_jobs([1], [2]) 1 >>> max_non_overlapping_jobs([1, 3, 5], [2, 4, 6]) 3 >>> max_non_overlapping_jobs([1, 2, 3], [3, 4, 5]) 2 >>> max_non_overlapping_jobs([1, 1, 1], [2, 2, 2]) 1 >>> max_non_overlapping_jobs([1, 2, 3, 6], [3, 4, 5, 7]) 3 >>> max_non_overlapping_jobs([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) 4 >>> max_non_overlapping_jobs([6, 1, 2, 4, 8], [8, 3, 4, 7, 9]) 3","solution":"def max_non_overlapping_jobs(startTime, endTime): # Combine start and end times into a list of tuples and sort by end times jobs = sorted(zip(startTime, endTime), key=lambda x: x[1]) max_jobs = 0 end_time = float('-inf') for start, end in jobs: if start >= end_time: max_jobs += 1 end_time = end return max_jobs"},{"question":"def tarjan_scc(graph): Finds all the strongly connected components in a directed graph. Parameters: graph (dict): A dictionary representing the graph where keys are vertices and values are lists of adjacent vertices. Returns: list of list: A list of SCCs, each represented by a list of vertices. >>> tarjan_scc({1: []}) == [[1]] >>> tarjan_scc({1: [2], 2: [3], 3: []}) == [[1], [2], [3]] >>> tarjan_scc({1: [2], 2: [3], 3: [1]}) == [[1, 2, 3]] >>> tarjan_scc({1: [2], 2: [1], 3: [4], 4: [3]}) == [[1, 2], [3, 4]] >>> tarjan_scc({1: [2], 2: [3], 3: [1, 4], 4: [5], 5: [6], 6: [4], 7: [8], 8: [9], 9: [7]}) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> tarjan_scc({1: [2, 3], 2: [1], 3: [4, 5], 4: [5], 5: [3, 6], 6: [], 7: []}) == [[1, 2], [3, 4, 5], [6], [7]]","solution":"def tarjan_scc(graph): Finds all the strongly connected components in a directed graph. Parameters: graph (dict): A dictionary representing the graph where keys are vertices and values are lists of adjacent vertices. Returns: list of list: A list of SCCs, each represented by a list of vertices. index = 0 stack = [] lowlink = {} index_map = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index index_map[node] = index lowlink[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph.get(node, []): if neighbor not in index_map: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif on_stack[neighbor]: lowlink[node] = min(lowlink[node], index_map[neighbor]) if lowlink[node] == index_map[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(sorted(scc)) for node in graph: if node not in index_map: strongconnect(node) return sorted(sccs, key=lambda x: x[0])"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles. :param grid: List[List[int]]: 2D grid representing the maze where 0 represents an open path and 1 represents a wall. :return: int: Number of unique paths. >>> unique_paths_with_obstacles([[0,0,0],[0,0,0],[0,0,0]]) 6 >>> unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]]) 2 >>> unique_paths_with_obstacles([[0,1],[1,0]]) 0 >>> unique_paths_with_obstacles([[1,0],[0,0]]) 0 >>> unique_paths_with_obstacles([[0,0],[0,1]]) 0 >>> unique_paths_with_obstacles([[0,0,1],[1,0,1],[1,0,0]]) 1","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles. :param grid: List[List[int]]: 2D grid representing the maze where 0 represents an open path and 1 represents a wall. :return: int: Number of unique paths. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1]"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_trees_with_sum(n: int, m: int) -> List[Optional[TreeNode]]: Given two integers \`n\` and \`m\`, find all possible unique binary trees with \`n\` nodes such that the sum of the values of the nodes in the tree is equal to \`m\`. Return a list of such possible binary trees, where each tree is represented by its root node. Each node is represented as a value and two child nodes (left and right). The value of each node is a positive integer and all values in a binary tree must be unique. >>> result = binary_trees_with_sum(1, 1) >>> len(result) 1 >>> result[0].val 1 >>> result = binary_trees_with_sum(2, 3) >>> len(result) 2 >>> result = binary_trees_with_sum(3, 2) >>> len(result) 0 >>> result = binary_trees_with_sum(3, 6) >>> len(result) > 0","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_trees(n, m, start=1): if n == 0 and m == 0: return [None] if n <= 0 or m <= 0: return [] trees = [] for i in range(start, m + 1): left_trees = find_trees(n - 1, m - i, start) right_trees = find_trees(n - 1, m - i, start) for left in left_trees: for right in right_trees: root = TreeNode(i) root.left = left root.right = right trees.append(root) return trees def binary_trees_with_sum(n: int, m: int) -> List[Optional[TreeNode]]: return find_trees(n, m)"},{"question":"def shortest_path_maze(grid: List[List[int]]) -> int: Given a 2D grid representing a maze, each cell in the grid can contain either a 0 (an empty space) or a 1 (a wall). Ian wants to find a path from the top-left corner of the maze (i.e., cell (0, 0)) to the bottom-right corner (i.e., cell (m-1, n-1)). He can move up, down, left, or right, and cannot move through walls. Return the length of the shortest path from the top-left corner to the bottom-right corner. If there is no such path, return -1. >>> shortest_path_maze([[]]) == -1 >>> shortest_path_maze([[1, 0], [0, 0]]) == -1 >>> shortest_path_maze([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) == 5 >>> shortest_path_maze([[0, 1], [1, 0]]) == -1 >>> shortest_path_maze([[0]]) == 1 >>> shortest_path_maze([[1]]) == -1 >>> shortest_path_maze([ [0, 0, 1, 0], [1, 0, 1, 0], [1, 0, 1, 0], [1, 0, 0, 0] ]) == 7 >>> shortest_path_maze([ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) == 9 pass","solution":"from collections import deque def shortest_path_maze(grid): Given a 2D grid representing a maze, each cell in the grid can contain either a 0 (an empty space) or a 1 (a wall). The function returns the length of the shortest path from the top-left corner to the bottom-right corner, or -1 if no such path exists. # Directions for movement: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) queue = deque([(0, 0, 1)]) # (row, col, distance) grid[0][0] = 1 # mark as visited by setting to '1' while queue: r, c, d = queue.popleft() if r == m - 1 and c == n - 1: return d for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 0: queue.append((nr, nc, d + 1)) grid[nr][nc] = 1 # mark as visited return -1"},{"question":"def is_robot_bounded(instructions: str) -> bool: Determines if the robot movements bound it within a circle. The robot starts at the origin point (0,0) on a plane and faces north. Each character in the \`instructions\` string represents an instruction for the robot: - 'G' means move forward one unit. - 'L' means turn 90 degrees to the left. - 'R' means turn 90 degrees to the right. The function returns True if and only if there exists a circle such that the robot will eventually come back to the origin, following the instructions repeatedly. >>> is_robot_bounded(\\"GGLLGG\\") True >>> is_robot_bounded(\\"GG\\") False >>> is_robot_bounded(\\"GL\\") True >>> is_robot_bounded(\\"GRGL\\") False >>> is_robot_bounded(\\"GGR\\") True","solution":"def is_robot_bounded(instructions): Determines if the robot movements bound it within a circle. Args: instructions (str): A string containing characters 'G', 'L', 'R'. Returns: bool: Returns True if the robot is bounded in a circle, else False. # Initial position and direction (north = 0, east = 1, south = 2, west = 3) x, y = 0, 0 direction = 0 # Mapping of directions: 0 = north, 1 = east, 2 = south, 3 = west directions = [ (0, 1), # north: move up (1, 0), # east: move right (0, -1), # south: move down (-1, 0) # west: move left ] # Iterate over instructions for i in instructions: if i == 'G': x += directions[direction][0] y += directions[direction][1] elif i == 'L': direction = (direction + 3) % 4 # Turning left elif i == 'R': direction = (direction + 1) % 4 # Turning right # Robot returns to origin or orientation is not northward (facing the new direction) return (x == 0 and y == 0) or direction != 0"},{"question":"def count_visible_buildings(heights: List[int]) -> List[int]: You are given an array of integers \`heights\` representing the heights of buildings, where \`heights[i]\` is the height of the \`i\`-th building. An individual standing on top of a building can see the next building if and only if it is strictly shorter than the current one. Starting from the first building, return an array of integers where the \`i\`-th element represents the number of buildings visible from the \`i\`-th building to the end of the array. >>> count_visible_buildings([1, 2, 3, 4]) == [0, 0, 0, 0] >>> count_visible_buildings([4, 3, 2, 1]) == [3, 2, 1, 0] >>> count_visible_buildings([3, 1, 4, 2]) == [1, 0, 1, 0] >>> count_visible_buildings([2, 2, 2, 2]) == [0, 0, 0, 0] >>> count_visible_buildings([5, 3]) == [1, 0] >>> count_visible_buildings([5]) == [0] pass","solution":"def count_visible_buildings(heights): Returns an array of integers where the i-th element represents the number of buildings visible from the i-th building to the end of the array. n = len(heights) visible_counts = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] < heights[i]: count += 1 else: break visible_counts[i] = count return visible_counts"},{"question":"from typing import Dict def update_inventory(current_inventory: Dict[str, int], new_stock: Dict[str, int]) -> Dict[str, int]: Merges two dictionaries representing inventories by adding quantities of items. If an item exists in both inventories, their quantities are added. Returns the updated inventory. :param current_inventory: Dictionary of current inventory {item: quantity} :param new_stock: Dictionary of new stock to be added {item: quantity} :return: Updated inventory dictionary {item: quantity} >>> update_inventory({'apples': 10, 'bananas': 5}, {'oranges': 7, 'grapes': 3}) {'apples': 10, 'bananas': 5, 'oranges': 7, 'grapes': 3} >>> update_inventory({'apples': 10, 'bananas': 5}, {'apples': 5, 'oranges': 7}) {'apples': 15, 'bananas': 5, 'oranges': 7} >>> update_inventory({'apples': 10, 'bananas': 5}, {'apples': 5, 'bananas': 2}) {'apples': 15, 'bananas': 7} >>> update_inventory({'apples': 10, 'bananas': 5}, {}) {'apples': 10, 'bananas': 5} >>> update_inventory({}, {'oranges': 7, 'grapes': 3}) {'oranges': 7, 'grapes': 3} >>> update_inventory({}, {}) {}","solution":"def update_inventory(current_inventory, new_stock): Merges two dictionaries representing inventories by adding quantities of items. If an item exists in both inventories, their quantities are added. Returns the updated inventory. :param current_inventory: Dictionary of current inventory {item: quantity} :param new_stock: Dictionary of new stock to be added {item: quantity} :return: Updated inventory dictionary {item: quantity} updated_inventory = current_inventory.copy() for item, quantity in new_stock.items(): if item in updated_inventory: updated_inventory[item] += quantity else: updated_inventory[item] = quantity return updated_inventory"},{"question":"from typing import List def mergeSort(nums: List[int]) -> List[int]: Sort an array using the merge sort algorithm. >>> mergeSort([]) == [] >>> mergeSort([1]) == [1] >>> mergeSort([1, 2]) == [1, 2] >>> mergeSort([2, 1]) == [1, 2] >>> mergeSort([4, 1, 3, 9, 7]) == [1, 3, 4, 7, 9] >>> mergeSort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> mergeSort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> mergeSort([4, 5, 4, 1, 1, 3, 2, 4]) == [1, 1, 2, 3, 4, 4, 4, 5]","solution":"def mergeSort(nums): if len(nums) <= 1: return nums def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 while i < len(left): sorted_array.append(left[i]) i += 1 while j < len(right): sorted_array.append(right[j]) j += 1 return sorted_array mid = len(nums) // 2 left_half = mergeSort(nums[:mid]) right_half = mergeSort(nums[mid:]) return merge(left_half, right_half)"},{"question":"from typing import List def find_max_consecutive_ones(nums: List[int]) -> int: Given a binary array nums, the function returns the maximum number of 1s that can be contiguous after performing at most one flip (0 to 1 or 1 to 0). :param nums: List[int] - a binary array :return: int - maximum number of contiguous 1s after at most one flip >>> find_max_consecutive_ones([1,0,1,1,0]) == 4 >>> find_max_consecutive_ones([1,1,0,1,1]) == 5 >>> find_max_consecutive_ones([1,0,1,1,1,0,0,1,1]) == 5 >>> find_max_consecutive_ones([1,1,1,1,1]) == 5 >>> find_max_consecutive_ones([1]) == 1 >>> find_max_consecutive_ones([0,0,0,0]) == 1 >>> find_max_consecutive_ones([1,0,1,0,1,0]) == 3 >>> find_max_consecutive_ones([]) == 0","solution":"def find_max_consecutive_ones(nums): Given a binary array nums, the function returns the maximum number of 1s that can be contiguous after performing at most one flip (0 to 1 or 1 to 0). :param nums: List[int] - a binary array :return: int - maximum number of contiguous 1s after at most one flip max_ones = 0 zero_count = 0 left = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"def can_transform(word1: str, word2: str) -> bool: Check if you can transform word1 into word2 by rearranging its characters. >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abc\\", \\"bca\\") True >>> can_transform(\\"aabbcc\\", \\"aabbbc\\") False >>> can_transform(\\"abc\\", \\"def\\") False >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"a\\", \\"a\\") True >>> can_transform(\\"a\\", \\"b\\") False >>> can_transform(\\"a\\" * 1000, \\"a\\" * 1000) True >>> can_transform(\\"abc\\" * 1000, \\"cba\\" * 1000) True","solution":"def can_transform(word1, word2): Returns True if word1 can be transformed into word2 by rearranging the characters, else returns False. from collections import Counter return Counter(word1) == Counter(word2)"},{"question":"from typing import List def min_distinct_after_one_operation(arr: List[int]) -> int: Returns the minimum number of distinct integers in the array that can be achieved after performing the operation at most once. >>> min_distinct_after_one_operation([4, 5, 6, 4, 7]) 3 >>> min_distinct_after_one_operation([1, 1, 1, 1]) 1 >>> min_distinct_after_one_operation([1, 2, 3]) 2 >>> min_distinct_after_one_operation([1, 1, 2, 2, 3, 3, 3, 4]) 3 >>> min_distinct_after_one_operation([100, 200, 300, 400, 500, 600, 700]) 6 >>> min_distinct_after_one_operation([1]) 1 >>> min_distinct_after_one_operation([1, 1]) 1 >>> min_distinct_after_one_operation([1, 2]) 1 pass # Your implementation here","solution":"def min_distinct_after_one_operation(arr): Returns the minimum number of distinct integers in the array that can be achieved after performing the operation at most once. from collections import Counter # Count the frequency of each element count = Counter(arr) if len(count) == 1: return 1 # Current number of distinct elements current_distinct = len(count) # Try reducing the distinct count by changing each element to another existing element min_distinct = current_distinct for key in count: for another_key in count: if key != another_key: new_count = count.copy() new_count[another_key] += new_count[key] del new_count[key] min_distinct = min(min_distinct, len(new_count)) return min_distinct"},{"question":"def min_cost_to_identical(s1: str, s2: str) -> int: Returns the minimum cost required to make the two strings s1 and s2 identical by performing any number of character replacement operations. If the lengths of s1 and s2 are different, returns -1. >>> min_cost_to_identical(\\"abc\\", \\"abc\\") == 0 >>> min_cost_to_identical(\\"a\\", \\"b\\") == 1 >>> min_cost_to_identical(\\"abcd\\", \\"abc\\") == -1 >>> min_cost_to_identical(\\"aBc\\", \\"abc\\") == (abs(ord('B') - ord('b'))) >>> min_cost_to_identical(\\"kitten\\", \\"sitting\\") == -1 >>> min_cost_to_identical(\\"kitten\\", \\"kittin\\") == abs(ord('e') - ord('i')) >>> min_cost_to_identical(\\"hello world\\", \\"hella worle\\") == (abs(ord('o') - ord('a')) + abs(ord('d') - ord('e'))) pass","solution":"def min_cost_to_identical(s1, s2): Returns the minimum cost required to make the two strings s1 and s2 identical by performing any number of character replacement operations. If the lengths of s1 and s2 are different, returns -1. if len(s1) != len(s2): return -1 cost = 0 for ch1, ch2 in zip(s1, s2): cost += abs(ord(ch1) - ord(ch2)) return cost"},{"question":"def minimize_maximum_time(projects: List[int], k: int) -> int: Given an integer array \`projects\` where \`projects[i]\` represents the time required to complete the \`i\`-th project and an integer \`k\` representing the number of workers available, return the minimum possible value of the maximum working time assigned to a worker. >>> minimize_maximum_time([10, 20, 30], 2) 30 >>> minimize_maximum_time([10, 5, 10], 2) 15 >>> minimize_maximum_time([7, 2, 5, 10, 8], 2) 18 >>> minimize_maximum_time([1, 2, 3, 4, 5], 5) 5 >>> minimize_maximum_time([1, 2, 3, 4, 5], 1) 15","solution":"def is_valid(workloads, k, max_workload): current_sum = 0 workers_needed = 1 for workload in workloads: if current_sum + workload > max_workload: workers_needed += 1 current_sum = workload if workers_needed > k: return False else: current_sum += workload return True def minimize_maximum_time(projects, k): low, high = max(projects), sum(projects) while low < high: mid = (low + high) // 2 if is_valid(projects, k, mid): high = mid else: low = mid + 1 return low"},{"question":"def modify_array(nums: List[int]) -> List[int]: Modify the array such that each element at index i satisfies the condition: nums[i] = nums[i] + nums[j] for all j where 0 <= j < i. :param nums: List[int] - The input array consisting of integers :return: List[int] - The modified array >>> modify_array([1, 2, 3, 4]) [1, 3, 6, 10] >>> modify_array([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> modify_array([1, -1, 2, -2]) [1, 0, 2, 0] >>> modify_array([5]) [5] >>> modify_array([0, 0, 0, 0]) [0, 0, 0, 0] >>> modify_array([5, -2, 3, -1, 2]) [5, 3, 6, 5, 7]","solution":"def modify_array(nums): Modifies the array such that each element at index i is the sum of all previous elements including itself. :param nums: List[int] - The input array consisting of integers :return: List[int] - The modified array for i in range(1, len(nums)): nums[i] += nums[i-1] return nums"},{"question":"def min_operations_to_empty(s: str) -> int: Returns the minimum number of operations required to make the string empty by removing any subsequence matching the pattern \\"01\\". >>> min_operations_to_empty(\\"0000\\") == 0 >>> min_operations_to_empty(\\"1111\\") == 0 >>> min_operations_to_empty(\\"010101\\") == 3 >>> min_operations_to_empty(\\"00011000\\") == 2 >>> min_operations_to_empty(\\"1110111\\") == 1 >>> min_operations_to_empty(\\"\\") == 0","solution":"def min_operations_to_empty(s): Returns the minimum number of operations required to make the string empty by removing any subsequence matching the pattern \\"01\\". count_0 = s.count('0') count_1 = s.count('1') # The minimum number of operations needed will be the minimum count of '0's or '1's return min(count_0, count_1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees and returns the merged tree. Args: root1 (TreeNode): The root of the first binary tree. root2 (TreeNode): The root of the second binary tree. Returns: TreeNode: The root of the newly merged binary tree. Example: >>> tree1 = TreeNode(1, TreeNode(3), TreeNode(2)) >>> tree2 = TreeNode(2, TreeNode(1), TreeNode(3)) >>> merged_tree = merge_trees(tree1, tree2) >>> tree_to_list(merged_tree) [3, 4, 5]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees and returns the merged tree. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged_tree = TreeNode(root1.val + root2.val) merged_tree.left = merge_trees(root1.left, root2.left) merged_tree.right = merge_trees(root1.right, root2.right) return merged_tree"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeCodec: def deserialize(self, data): Constructs the binary tree from the given pre-order traversal string and returns the root node. pass def serialize(self, root): Returns the post-order traversal string of the constructed binary tree. pass # You can test your implementation using the following test cases: def test_deserialize_single_node(): codec = BinaryTreeCodec() root = codec.deserialize(\\"1,#,#\\") assert root.val == 1 assert root.left is None assert root.right is None def test_deserialize_full_tree(): codec = BinaryTreeCodec() root = codec.deserialize(\\"1,2,#,#,3,4,#,#,5,#,#\\") assert root.val == 1 assert root.left.val == 2 assert root.right.val == 3 assert root.right.left.val == 4 assert root.right.right.val == 5 def test_serialize_single_node(): codec = BinaryTreeCodec() root = TreeNode(1) serialized = codec.serialize(root) assert serialized == \\"#,#,1\\" def test_serialize_full_tree(): codec = BinaryTreeCodec() root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) serialized = codec.serialize(root) assert serialized == \\"#,#,2,#,#,4,#,#,5,3,1\\" def test_deserialize_and_serialize_complex_tree(): codec = BinaryTreeCodec() data = \\"1,2,#,#,3,4,#,#,5,#,#\\" root = codec.deserialize(data) serialized = codec.serialize(root) assert serialized == \\"#,#,2,#,#,4,#,#,5,3,1\\"","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeCodec: def deserialize(self, data): Constructs the binary tree from the given pre-order traversal string and returns the root node. def build(nodes): val = next(nodes) if val == '#': return None node = TreeNode(int(val)) node.left = build(nodes) node.right = build(nodes) return node nodes = iter(data.split(',')) return build(nodes) def serialize(self, root): Returns the post-order traversal string of the constructed binary tree. def post_order(node): if not node: return ['#'] left = post_order(node.left) right = post_order(node.right) return left + right + [str(node.val)] return ','.join(post_order(root))"},{"question":"def find_last_occurrence(nums: List[int], target: int) -> int: Given an array of integers \`nums\` and an integer \`target\`, return the index of the last occurrence of \`target\` in \`nums\`. If \`target\` is not present in \`nums\`, return -1. The array \`nums\` is not necessarily sorted. >>> find_last_occurrence([1, 2, 3, 4, 5], 3) == 2 >>> find_last_occurrence([1, 2, 3, 3, 5], 3) == 3 >>> find_last_occurrence([9, 3, 4, 3, 1], 3) == 3 >>> find_last_occurrence([1, 2, 3, 4, 5], 6) == -1 >>> find_last_occurrence([1, 2, 3, 4, 5], 0) == -1 >>> find_last_occurrence([], 3) == -1 >>> find_last_occurrence([3], 3) == 0 >>> find_last_occurrence([1], 3) == -1 >>> find_last_occurrence([3, 3, 3], 3) == 2 >>> find_last_occurrence([1, 3, 3, 3, 5, 3], 3) == 5","solution":"def find_last_occurrence(nums, target): Returns the index of the last occurrence of target in nums. If target is not present in nums, return -1. for i in range(len(nums) - 1, -1, -1): if nums[i] == target: return i return -1"},{"question":"from typing import List, Optional def determine_array_trend(nums: List[int]) -> Optional[str]: Determines if the array is non-increasing or non-decreasing. Args: nums : List[int] - A list of integers with at least two elements. Returns: str - \\"non-increasing\\" if the array is non-increasing, and \\"non-decreasing\\" if the array is non-decreasing. # Test cases def test_non_increasing(): assert determine_array_trend([5, 4, 3, 2, 1]) == \\"non-increasing\\" assert determine_array_trend([2, 2, 1]) == \\"non-increasing\\" def test_non_decreasing(): assert determine_array_trend([1, 2, 3, 4, 5]) == \\"non-decreasing\\" assert determine_array_trend([1, 1, 2]) == \\"non-decreasing\\" def test_mixed_trend(): assert determine_array_trend([1, 5, 2]) == None assert determine_array_trend([2, 1, 3]) == None def test_two_elements(): assert determine_array_trend([1, 2]) == \\"non-decreasing\\" assert determine_array_trend([2, 1]) == \\"non-increasing\\" def test_identical_elements(): assert determine_array_trend([3, 3, 3]) == \\"non-increasing\\" # or \\"non-decreasing\\" assert determine_array_trend([7, 7]) == \\"non-increasing\\" # or \\"non-decreasing\\"","solution":"def determine_array_trend(nums): Determines if the array is non-increasing or non-decreasing. Args: nums : List[int] - A list of integers with at least two elements. Returns: str - \\"non-increasing\\" if the array is non-increasing, and \\"non-decreasing\\" if the array is non-decreasing. non_increasing = True non_decreasing = True for i in range(1, len(nums)): if nums[i] > nums[i - 1]: non_increasing = False if nums[i] < nums[i - 1]: non_decreasing = False if non_increasing: return \\"non-increasing\\" elif non_decreasing: return \\"non-decreasing\\""},{"question":"def check_tic_tac_toe(board) -> int: Determines the state of a 3x3 tic-tac-toe game board. Parameters: board (list of list of int): 3x3 matrix representing the game state. Returns: int: The state of the game: 0 if the game is still ongoing, 1 if player 1 has won, 2 if player 2 has won, 3 if the game is a draw.","solution":"def check_tic_tac_toe(board): Determines the state of a 3x3 tic-tac-toe game board. Parameters: board (list of list of int): 3x3 matrix representing the game state. Returns: int: The state of the game: 0 if the game is still ongoing, 1 if player 1 has won, 2 if player 2 has won, 3 if the game is a draw. for i in range(3): # Check rows for a win if board[i][0] == board[i][1] == board[i][2] != 0: return board[i][0] # Check columns for a win if board[0][i] == board[1][i] == board[2][i] != 0: return board[0][i] # Check diagonals for a win if board[0][0] == board[1][1] == board[2][2] != 0: return board[0][0] if board[0][2] == board[1][1] == board[2][0] != 0: return board[0][2] # Check if there are any empty spaces left for row in board: if 0 in row: return 0 # Game is still ongoing return 3 # Game is a draw"},{"question":"def modify_string_to_have_k_consecutive_chars(s: str, k: int) -> str: Modify the string such that every character in the resulting string appears at least k times consecutively. If it's not possible to achieve this, return an empty string. If there are multiple valid modifications, return any one of them. >>> modify_string_to_have_k_consecutive_chars(\\"aabb\\", 2) == \\"aabb\\" >>> modify_string_to_have_k_consecutive_chars(\\"aaa\\", 3) == \\"aaa\\" >>> modify_string_to_have_k_consecutive_chars(\\"aaa\\", 2) == \\"\\" >>> modify_string_to_have_k_consecutive_chars(\\"abc\\", 2) == \\"\\" >>> modify_string_to_have_k_consecutive_chars(\\"\\", 1) == \\"\\" >>> modify_string_to_have_k_consecutive_chars(\\"\\", 0) == \\"\\" >>> modify_string_to_have_k_consecutive_chars(\\"aabbcc\\", 2) in [\\"aabbcc\\", \\"bbaacc\\", \\"ccaabb\\"] >>> modify_string_to_have_k_consecutive_chars(\\"aaaabbbb\\", 4) == \\"aaaabbbb\\"","solution":"def modify_string_to_have_k_consecutive_chars(s, k): Modify the string such that every character in the resulting string appears at least k times consecutively. If it's not possible to achieve this, return an empty string. if not s: return \\"\\" if k > 0 else s from collections import Counter counts = Counter(s) for char_count in counts.values(): if (char_count % k) != 0: return \\"\\" result = [] for char, count in counts.items(): result.append(char * count) return ''.join(result)"},{"question":"from typing import List, Union, Tuple def partition_equal_sum(arr: List[int]) -> Union[Tuple[List[int], List[int]], List[int]]: Partition the array into two contiguous subarrays such that the sum of the elements in the left subarray is equal to the sum of the elements in the right subarray. :param arr: List of integers :return: Tuple containing the left and right subarrays or an empty array if no partition exists >>> partition_equal_sum([1, 2, 3, 4, 10]) ([1, 2, 3, 4], [10]) >>> partition_equal_sum([1, 1, 1, 1, 1, 5]) ([1, 1, 1, 1, 1], [5]) >>> partition_equal_sum([1, 2, 3, 4]) [] >>> partition_equal_sum([1]) [] >>> partition_equal_sum([1, 2, 1]) [] >>> partition_equal_sum([]) [] >>> partition_equal_sum([2, 2, 2, 2]) ([2, 2], [2, 2]) >>> partition_equal_sum([1, 2, 3, 3, 2, 1]) ([1, 2, 3], [3, 2, 1]) or ([1, 2, 3, 3], [2, 1])","solution":"def partition_equal_sum(arr): Partition the array into two contiguous subarrays such that the sum of the elements in the left subarray is equal to the sum of the elements in the right subarray. :param arr: List of integers :return: Tuple containing the left and right subarrays or an empty array if no partition exists total_sum = sum(arr) left_sum = 0 for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total_sum - left_sum if left_sum == right_sum: return (arr[:i+1], arr[i+1:]) return []"},{"question":"from typing import List from collections import deque class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root: 'Node') -> List[List[int]]: Returns the level order traversal of an n-ary tree's nodes' values. Examples: >>> root = Node(1, [ ... Node(3, [ ... Node(5), ... Node(6) ... ]), ... Node(2), ... Node(4) ... ]) >>> level_order(root) [[1], [3, 2, 4], [5, 6]] >>> root = Node(1) >>> level_order(root) [[1]] >>> level_order(None) []","solution":"from collections import deque class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root: 'Node'): Returns the level order traversal of an n-ary tree's nodes' values. if root is None: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) for child in node.children: queue.append(child) result.append(current_level) return result"},{"question":"import math from typing import Tuple def gcd_and_lcm(a: int, b: int) -> Tuple[int, int]: Returns a tuple containing the GCD and LCM of two integers a and b. >>> gcd_and_lcm(15, 20) (5, 60) >>> gcd_and_lcm(0, 5) (5, 0) >>> gcd_and_lcm(-15, -25) (5, 75)","solution":"import math def gcd_and_lcm(a, b): Returns a tuple containing the GCD and LCM of two integers a and b. gcd = math.gcd(a, b) lcm = abs(a * b) // gcd if gcd != 0 else 0 return (gcd, lcm)"},{"question":"from typing import List def find_median(arr: List[int]) -> float: Compute the median of an array of integers. >>> find_median([1, 2, 3]) == 2.0 >>> find_median([4, 3, 2, 1]) == 2.5 >>> find_median([12, 3, 5, 7, 19, 26, 14]) == 12.0 def k_closest_to_median(arr: List[int], k: int) -> List[int]: Given an array of integers arr and an integer k, return the k closest integers to the median of arr. >>> k_closest_to_median([1, 2, 3, 4, 5], 2) == [3, 2] >>> k_closest_to_median([1, 2, 3, 4, 5, 6], 4) == [3, 4, 2, 5] >>> k_closest_to_median([1, 2, 3, 4, 5, 5], 4) == [3, 4, 2, 5]","solution":"def find_median(arr): arr_sorted = sorted(arr) n = len(arr) if n % 2 == 1: return float(arr_sorted[n // 2]) else: return (arr_sorted[n // 2 - 1] + arr_sorted[n // 2]) / 2.0 def k_closest_to_median(arr, k): median = find_median(arr) arr_sorted = sorted(arr, key=lambda x: (abs(x - median), x)) return arr_sorted[:k]"},{"question":"def has_subarray_sum(nums, target): Determine if there exists a continuous subarray of length at least 2 that sums to target. :param nums: List of integers :param target: Integer target sum :return: Boolean value indicating if such a subarray exists >>> has_subarray_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_sum([1, 2, 3, 4, 5], 15) True >>> has_subarray_sum([10, 20, 30, 40], 70) True >>> has_subarray_sum([1, 1, 1, 1, 1], 3) True >>> has_subarray_sum([1, 2, 3, 4, 5], 50) False >>> has_subarray_sum([1, 2, 1, 2, 1], 10) False >>> has_subarray_sum([], 1) False >>> has_subarray_sum([1], 1) False >>> has_subarray_sum([-1, -2, -3, -4, -5], -9) True >>> has_subarray_sum([-1, -1, -1, -1], -2) True >>> has_subarray_sum([1, -2, 3, -4, 5], 1) True >>> has_subarray_sum([-10, 20, -10, 10], 10) True >>> has_subarray_sum([0, 0, 0], 0) True >>> has_subarray_sum([0, 0, 0, 0], 0) True","solution":"def has_subarray_sum(nums, target): Determine if there exists a continuous subarray of length at least 2 that sums to target. :param nums: List of integers :param target: Integer target sum :return: Boolean value indicating if such a subarray exists n = len(nums) if n < 2: return False for i in range(n - 1): current_sum = nums[i] for j in range(i + 1, n): current_sum += nums[j] if current_sum == target: return True if current_sum > target: break return False"},{"question":"def count_students_out_of_place(heights): Returns the number of students who are not standing in the correct place. A student x is not in the correct place if there is a student y standing after him in the line who is shorter than x. :param heights: List[int] - The list of student heights. :return: int - The number of students out of place. pass # Test cases from solution import count_students_out_of_place def test_students_out_of_place(): assert count_students_out_of_place([5, 1, 2, 3, 4]) == 4 assert count_students_out_of_place([1, 2, 3, 4, 5]) == 0 assert count_students_out_of_place([2, 1, 3, 4, 5]) == 1 assert count_students_out_of_place([1, 3, 2, 4, 5]) == 1 assert count_students_out_of_place([4, 3, 2, 1, 5]) == 3 assert count_students_out_of_place([5, 5, 5, 5, 5]) == 0 assert count_students_out_of_place([1, 1, 2, 2, 3]) == 0 assert count_students_out_of_place([10, 20, 10, 20, 10]) == 2","solution":"def count_students_out_of_place(heights): Returns the number of students who are not standing in the correct place. A student x is not in the correct place if there is a student y standing after him in the line who is shorter than x. :param heights: List[int] - The list of student heights. :return: int - The number of students out of place. count = 0 max_seen = heights[0] for i in range(1, len(heights)): if heights[i] < max_seen: count += 1 else: max_seen = heights[i] return count"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given an array of n integers nums, find all unique triplets in the array which give the sum of zero. A triplet (nums[i], nums[j], nums[k]) is considered unique if and only if the set i, j, k are different. Return all the unique triplets in an array. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, -2, -1]) [] >>> three_sum([0, 0, 0]) [[0, 0, 0]] >>> three_sum([-4, -2, -1, 0, 1, 2, 3, 5, -1]) [[-4, -1, 5], [-4, 1, 3], [-2, -1, 3], [-2, 0, 2], [-1, -1, 2], [-1, 0, 1]] >>> three_sum([-2, -2, 0, 2, 2]) [[-2, 0, 2]]","solution":"def three_sum(nums): Returns all unique triplets in the array which give the sum of zero. :param nums: List of integers :return: List of lists containing triplets nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def max_sum_of_min_partition(arr: List[int]) -> int: Given an array of integers \`arr\`, partition the array into contiguous subarrays such that each contains at least one integer. Return the maximum possible sum of the minimum values of each subarray. >>> max_sum_of_min_partition([3, 1, 2, 4]) 10 >>> max_sum_of_min_partition([5]) 5 >>> max_sum_of_min_partition([2, 2, 2, 2]) 8 >>> max_sum_of_min_partition([]) 0 >>> max_sum_of_min_partition([100, 200, 300]) 600","solution":"def max_sum_of_min_partition(arr): Given an array of integers \`arr\`, partition the array into contiguous subarrays such that each contains at least one integer. Return the maximum possible sum of the minimum values of each subarray. if not arr: return 0 # Partitioning each element into its own subarray ensures the sum of min values is maximized # because each subarray will have its own value as the minimum. return sum(arr)"},{"question":"def carPooling(trips: List[List[int]], capacity: int) -> bool: Determines if it is possible to complete all trips without exceeding the given capacity at any time. Args: trips (List[List[int]]): List of trips, where each trip is represented as [numPassengers, from, to]. capacity (int): Maximum number of passengers that can be carried at any point in time. Returns: bool: True if it is possible to complete all trips without exceeding the capacity, else False. >>> carPooling([[2, 1, 5]], 3) True >>> carPooling([[2, 1, 5], [3, 6, 9]], 5) True >>> carPooling([[2, 1, 5], [3, 6, 9]], 10) True >>> carPooling([[2, 1, 5], [3, 4, 7]], 5) True >>> carPooling([[2, 1, 5], [3, 3, 7]], 4) False >>> carPooling([[2, 1, 5], [2, 5, 10]], 4) True >>> carPooling([[2, 1, 5], [1, 4, 6], [3, 5, 10]], 5) True >>> carPooling([[3, 2, 5], [4, 3, 7], [2, 4, 6]], 6) False","solution":"def carPooling(trips, capacity): Determines if it is possible to complete all trips without exceeding the given capacity at any time. Args: trips (List[List[int]]): List of trips, where each trip is represented as [numPassengers, from, to]. capacity (int): Maximum number of passengers that can be carried at any point in time. Returns: bool: True if it is possible to complete all trips without exceeding the capacity, else False. # Create a list to keep track of passenger changes at each location passenger_changes = [0] * 1001 # Record the number of passengers getting on and off at each location for numPassengers, start, end in trips: passenger_changes[start] += numPassengers passenger_changes[end] -= numPassengers # Track the number of passengers in the car as we progress through the locations current_passengers = 0 for change in passenger_changes: current_passengers += change if current_passengers > capacity: return False return True"},{"question":"def transform_array(arr, r=1): Returns a new array where each element in the input array is raised to the power of r. Parameters: arr (list): The input list of integers. r (int, optional): The power to which each element in the array will be raised. Defaults to 1. Returns: list: A new list with each element raised to the power of r. Examples: >>> transform_array([1, 2, 3, 4], 2) [1, 4, 9, 16] >>> transform_array([2, 3, 1]) [2, 3, 1] >>> transform_array([1, 2, 4], -1) [1, 0.5, 0.25] >>> transform_array([10, -10, 0], 0) [1, 1, 1]","solution":"def transform_array(arr, r=1): Returns a new array where each element in the input array is raised to the power of r. Parameters: arr (list): The input list of integers. r (int, optional): The power to which each element will be raised. Defaults to 1. Returns: list: A new list with each element raised to the power of r. return [x ** r for x in arr]"},{"question":"def longest_alphabetical_subsequence(s: str, char_index: List[int]) -> int: Given a string 's' and an integer array 'char_index', find the length of the longest subsequence of 's' that is in alphabetical order based on 'char_index'. >>> longest_alphabetical_subsequence(\\"abcabc\\", [2, 1, 0] + [-1]*23) # \\"ab\\" or \\"bc\\" 2 >>> longest_alphabetical_subsequence(\\"badcfehg\\", list(range(26))) # \\"adfh\\" 4 >>> longest_alphabetical_subsequence(\\"badcfehg\\", [1, 0] + list(range(2, 26))) # \\"bcfh\\" 5 >>> longest_alphabetical_subsequence(\\"\\", list(range(26))) 0 >>> longest_alphabetical_subsequence(\\"a\\", list(range(26))) 1 >>> longest_alphabetical_subsequence(\\"xyz\\", list(range(26))) # \\"xyz\\" 3 >>> longest_alphabetical_subsequence(\\"zyx\\", list(range(26))) # \\"z\\", \\"y\\" or \\"x\\" 1","solution":"def longest_alphabetical_subsequence(s, char_index): Given a string 's' and an integer array 'char_index', find the length of longest subsequence of 's' that is in alphabetical order based on 'char_index'. :param s: str, input string :param char_index: list of int, length 26, positional indices for each character :return: int, length of the longest subsequence n = len(s) dp = [1] * n for i in range(n): for j in range(i): if char_index[ord(s[j]) - ord('a')] <= char_index[ord(s[i]) - ord('a')]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) if s else 0"},{"question":"def firstUniqChar(s: str) -> int: Returns the index of the first non-repeating character in the string \`s\`. >>> firstUniqChar(\\"leetcode\\") 0 >>> firstUniqChar(\\"loveleetcode\\") 2 >>> firstUniqChar(\\"aabbcc\\") -1 >>> firstUniqChar(\\"\\") -1 >>> firstUniqChar(\\"aabbccd\\") 6 >>> firstUniqChar(\\"z\\") 0","solution":"def firstUniqChar(s: str) -> int: Returns the index of the first non-repeating character in the string \`s\`. If there is no such character, returns -1. # Dictionary to store the count of each character char_count = {} # First pass to count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index # If no non-repeating character is found return -1"},{"question":"from typing import List, Optional class Node: def __init__(self, val: int = None, children: Optional[List['Node']] = None): self.val = val self.children = children if children is not None else [] def level_order(root: Optional[Node]) -> List[List[int]]: Returns the level order traversal of an n-ary tree. >>> level_order(None) [] >>> level_order(Node(val=1)) [[1]] >>> level_order(Node(val=1, children=[Node(val=2), Node(val=3)])) [[1], [2, 3]] >>> level_order(Node(val=1, children=[ Node(val=2), Node(val=3, children=[Node(val=6), Node(val=7)]), Node(val=4) ])) [[1], [2, 3, 4], [6, 7]] >>> level_order(Node(val=1, children=[ Node(val=2, children=[Node(val=5)]), Node(val=3) ])) [[1], [2, 3], [5]] >>> level_order(Node(val=1, children=[ Node(val=2), Node(val=3), Node(val=4), Node(val=5) ])) [[1], [2, 3, 4, 5]]","solution":"from collections import deque from typing import List class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root: Node) -> List[List[int]]: Returns the level order traversal of an n-ary tree. if not root: return [] result = [] queue = deque([root]) while queue: level = [] for _ in range(len(queue)): node = queue.popleft() level.append(node.val) for child in node.children: queue.append(child) result.append(level) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self, root: TreeNode): Initializes the object with the root of the binary search tree. self.root = root def kthSmallest(self, k: int) -> int: Returns the k-th smallest element in the BST (1-indexed). >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> bst = BST(root) >>> bst.kthSmallest(1) 1 >>> bst.kthSmallest(2) 2 >>> bst.kthSmallest(3) 3 >>> bst.kthSmallest(4) 4 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.left.left = TreeNode(1) >>> root.right.right = TreeNode(9) >>> bst = BST(root) >>> bst.kthSmallest(1) 1 >>> bst.kthSmallest(2) 2 >>> bst.kthSmallest(3) 3 >>> bst.kthSmallest(4) 4 >>> bst.kthSmallest(5) 5 >>> bst.kthSmallest(6) 8 >>> bst.kthSmallest(7) 9 >>> bst_single = BST(TreeNode(10)) >>> bst_single.kthSmallest(1) 10","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self, root: TreeNode): self.root = root def kthSmallest(self, k: int) -> int: # In-order traversal generator def in_order_traversal(node): if node is not None: yield from in_order_traversal(node.left) yield node.val yield from in_order_traversal(node.right) # Generate in-order traversal and iterate k-1 times gen = in_order_traversal(self.root) for _ in range(k-1): next(gen) # The next element is the k-th smallest return next(gen)"},{"question":"class Solution: def __init__(self, grid: List[List[int]]): Initializes the object with the given grid. Args: grid (List[List[int]]): The 2D grid of the heights of the terrain. def querySum(self, x1: int, y1: int, x2: int, y2: int) -> int: Returns the sum of the heights of all cells within the subgrid formed by (x1, y1) and (x2, y2). Args: x1 (int): Row index of the first corner y1 (int): Column index of the first corner x2 (int): Row index of the second corner y2 (int): Column index of the second corner Returns: int: Sum of the heights of all cells in the specified subgrid. def test_query_sum(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] sol = Solution(grid) # Test for the total sum of the grid assert sol.querySum(0, 0, 2, 2) == 45 # Test for upper left 2x2 subgrid assert sol.querySum(0, 0, 1, 1) == 12 # Test for a single element assert sol.querySum(1, 1, 1, 1) == 5 # Test for a subgrid in the middle of the grid assert sol.querySum(1, 1, 2, 2) == 28 # Test for a single row assert sol.querySum(0, 1, 0, 2) == 5 # Test for a single column assert sol.querySum(1, 0, 2, 0) == 11","solution":"class Solution: def __init__(self, grid): Initializes the object with the given grid. Args: grid (List[List[int]]): The 2D grid of the heights of the terrain. if not grid or not grid[0]: raise ValueError(\\"Grid is empty\\") self.m = len(grid) self.n = len(grid[0]) self.prefix_sum = [[0] * (self.n + 1) for _ in range(self.m + 1)] # Compute the prefix sum matrix for i in range(self.m): for j in range(self.n): self.prefix_sum[i + 1][j + 1] = grid[i][j] + self.prefix_sum[i][j + 1] + self.prefix_sum[i + 1][j] - self.prefix_sum[i][j] def querySum(self, x1, y1, x2, y2): Returns the sum of the heights of all cells within the subgrid formed by (x1, y1) and (x2, y2). Args: x1 (int): Row index of the first corner y1 (int): Column index of the first corner x2 (int): Row index of the second corner y2 (int): Column index of the second corner Returns: int: Sum of the heights of all cells in the specified subgrid. return self.prefix_sum[x2 + 1][y2 + 1] - self.prefix_sum[x1][y2 + 1] - self.prefix_sum[x2 + 1][y1] + self.prefix_sum[x1][y1]"},{"question":"def minimum_cameras(buildings: List[int]) -> int: Determine the minimum number of cameras needed to cover all buildings in a cityscape. >>> minimum_cameras([5]) 1 >>> minimum_cameras([3, 3, 3, 3]) 1 >>> minimum_cameras([1, 2, 3, 4]) 1 >>> minimum_cameras([4, 3, 2, 1]) 4 >>> minimum_cameras([1, 3, 2, 5, 3, 4, 1, 2]) 3 >>> minimum_cameras([0, 0, 0, 0]) 1 >>> minimum_cameras([]) 0","solution":"from typing import List def minimum_cameras(buildings: List[int]) -> int: n = len(buildings) if n == 0: return 0 cameras = 1 # Place the first camera on the tallest building from the right tallest = buildings[-1] # Start with the last building as the tallest for i in range(n-2, -1, -1): if buildings[i] > tallest: cameras += 1 tallest = buildings[i] return cameras"},{"question":"from typing import List class MovingAverage: A class that calculates the moving average from a stream of integers. Parameters: size (int): The window size for the moving average. Methods: next(val: int) -> float: Accepts an integer 'val', adds it to the stream, and returns the current moving average of the last 'size' values in the stream. >>> ma = MovingAverage(3) >>> abs(ma.next(1) - 1.0) < 1e-6 True >>> abs(ma.next(10) - 5.5) < 1e-6 True >>> abs(ma.next(3) - 4.6666667) < 1e-6 True >>> abs(ma.next(5) - 6.0) < 1e-6 True >>> ma = MovingAverage(1) >>> abs(ma.next(4) - 4.0) < 1e-6 True >>> abs(ma.next(7) - 7.0) < 1e-6 True >>> abs(ma.next(9) - 9.0) < 1e-6 True def __init__(self, size: int): Initialize the moving average object with the window size. pass def next(self, val: int) -> float: Accept an integer value, add it to the stream, and return the current moving average of the last 'size' values in the stream. pass","solution":"from collections import deque class MovingAverage: def __init__(self, size): Initialize the moving average object with the window size. self.size = size self.window = deque() self.sum = 0 def next(self, val): Accept an integer value, add it to the stream, and return the current moving average of the last 'size' values in the stream. if len(self.window) == self.size: self.sum -= self.window.popleft() self.window.append(val) self.sum += val return self.sum / len(self.window)"},{"question":"from typing import List def min_operations_to_balance_string(s: str, n: int) -> int: Returns the minimum number of operations required to balance the string such that each character appears exactly n times. If it is not possible to achieve the balance, returns -1. :param s: input string consisting of lowercase English letters :param n: integer specifying the number of times each character should appear :return: minimum number of operations or -1 if not possible >>> min_operations_to_balance_string(\\"aabbcc\\", 2) 0 >>> min_operations_to_balance_string(\\"aabbccc\\", 2) 1 >>> min_operations_to_balance_string(\\"aabbccddd\\", 2) 1 >>> min_operations_to_balance_string(\\"abc\\", 2) -1 >>> min_operations_to_balance_string(\\"aaab\\", 2) 1 >>> min_operations_to_balance_string(\\"aabbb\\", 2) 1 >>> min_operations_to_balance_string(\\"aabc\\", 3) -1","solution":"from collections import Counter def min_operations_to_balance_string(s, n): Returns the minimum number of operations required to balance the string such that each character appears exactly n times. If it is not possible to achieve the balance, returns -1. :param s: input string consisting of lowercase English letters :param n: integer specifying the number of times each character should appear :return: minimum number of operations or -1 if not possible freq = Counter(s) total_chars_needed = n * len(freq) # If the total length of the string cannot be made to have n appearances of each char, return -1 if total_chars_needed > len(s): return -1 # Count deficiencies and excesses excess_count = 0 deficiency_count = 0 for char, count in freq.items(): if count < n: deficiency_count += n - count elif count > n: excess_count += count - n # If deficiency cannot be covered with excess, return -1 if deficiency_count > excess_count: return -1 return max(deficiency_count, excess_count)"},{"question":"def path_exists_with_cost(grid, T): Determines whether there exists a path in the grid from the top-left corner to the bottom-right corner such that the cost of the path is exactly T. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> T = 21 >>> path_exists_with_cost(grid, T) True >>> grid = [ ... [1, 2, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> T = 10 >>> path_exists_with_cost(grid, T) False >>> grid = [ ... [1, 2, 3] ... ] >>> T = 6 >>> path_exists_with_cost(grid, T) True >>> grid = [ ... [1], ... [2], ... [3] ... ] >>> T = 6 >>> path_exists_with_cost(grid, T) True >>> grid = [ ... [5] ... ] >>> T = 5 >>> path_exists_with_cost(grid, T) True >>> T = 3 >>> path_exists_with_cost(grid, T) False","solution":"def path_exists_with_cost(grid, T): Determines whether there exists a path in the grid from the top-left corner to the bottom-right corner such that the cost of the path is exactly T. def dfs(i, j, current_sum): # If we are out of bounds, return False if i >= len(grid) or j >= len(grid[0]): return False # Add the current cell's value to the current path sum current_sum += grid[i][j] # If we have reached the bottom-right corner, check if the path sum equals T if i == len(grid) - 1 and j == len(grid[0]) - 1: return current_sum == T # Otherwise, continue the search by moving right or down return dfs(i + 1, j, current_sum) or dfs(i, j + 1, current_sum) # Start the DFS traversal from the top-left corner with an initial sum of 0 return dfs(0, 0, 0)"},{"question":"from typing import List def find_position(matrix: List[List[int]], target: int) -> List[int]: Finds the position of the smallest number in the matrix which is greater than or equal to the target. If no such number exists, return [-1, -1]. :param matrix: List of List of integers, where each row is sorted and each column is sorted. :param target: Integer target to find the smallest number greater than or equal to it. :return: List containing row and column index of the found number, otherwise [-1, -1]. Example: >>> matrix = [ ... [1, 4, 7], ... [2, 5, 9], ... [3, 6, 10] ... ] >>> find_position(matrix, 5) [1, 1] >>> find_position(matrix, 8) [1, 2] >>> find_position(matrix, 11) [-1, -1] >>> find_position(matrix, 0) [0, 0] >>> find_position([], 1) [-1, -1] >>> find_position([[10]], 5) [0, 0]","solution":"def find_position(matrix, target): Finds the position of the smallest number in the matrix which is greater than or equal to the target. If no such number exists, return [-1, -1]. :param matrix: List of List of integers, where each row is sorted and each column is sorted. :param target: Integer target to find the smallest number greater than or equal to it. :return: List containing row and column index of the found number, otherwise [-1, -1]. n = len(matrix) if n == 0 or len(matrix[0]) == 0: return [-1, -1] row, col = n - 1, 0 result = [-1, -1] smallest_diff = float('inf') while row >= 0 and col < n: if matrix[row][col] >= target: if (matrix[row][col] - target < smallest_diff): result = [row, col] smallest_diff = matrix[row][col] - target row -= 1 else: col += 1 return result"},{"question":"def can_transform(s: str, t: str, k: int) -> bool: Determine if it is possible to transform string s into string t within k operations, where each operation consists of replacing any character in s with any other character. >>> can_transform(\\"abcd\\", \\"abcf\\", 1) == True >>> can_transform(\\"abcd\\", \\"wxyz\\", 4) == True >>> can_transform(\\"abcd\\", \\"abcd\\", 0) == True >>> can_transform(\\"abcd\\", \\"abcf\\", 0) == False >>> can_transform(\\"abcd\\", \\"wxyz\\", 3) == False >>> can_transform(\\"abcd\\", \\"abcf\\", 10) == True >>> can_transform(\\"abcd\\", \\"wxyz\\", 10) == True >>> can_transform(\\"abcdef\\", \\"ghijkl\\", 2) == False >>> can_transform(\\"abcdef\\", \\"azcdef\\", 0) == False >>> can_transform(\\"\\", \\"\\", 0) == True >>> can_transform(\\"\\", \\"a\\", 1) == True >>> can_transform(\\"a\\", \\"\\", 1) == True >>> can_transform(\\"test\\", \\"test\\", 0) == True >>> can_transform(\\"test\\", \\"test\\", 5) == True # Your code here","solution":"def can_transform(s, t, k): Determine if it is possible to transform string s into string t within k operations, where each operation consists of replacing any character in s with any other character. Parameters: s (str): The original string. t (str): The target string. k (int): The maximum number of operations allowed. Returns: bool: True if it is possible to transform s into t within k operations, otherwise False. # Calculate the number of differing characters. differing_characters = sum(1 for sc, tc in zip(s, t) if sc != tc) # Check if the number of differing characters is within the allowed operations. return differing_characters <= k"},{"question":"def reverse_words_in_sentence(s: str) -> str: Reverses each word in the sentence while maintaining the initial word order and spaces. >>> reverse_words_in_sentence(\\"hello\\") \\"olleh\\" >>> reverse_words_in_sentence(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words_in_sentence(\\"Python is fun\\") \\"nohtyP si nuf\\" >>> reverse_words_in_sentence(\\"\\") \\"\\" >>> reverse_words_in_sentence(\\"a b c\\") \\"a b c\\" >>> reverse_words_in_sentence(\\"HELLO WORLD\\") \\"OLLEH DLROW\\" >>> reverse_words_in_sentence(\\"Hello World\\") \\"olleh dlroW\\"","solution":"def reverse_words_in_sentence(s): Reverses each word in the sentence while maintaining the initial word order and spaces. Parameters: s (str): The input sentence as a string. Returns: str: The sentence with each word reversed. words = s.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"import heapq from typing import List def maximize_final_result(nums: List[int]) -> int: Perform operations to maximize the final result by summing the two largest elements until only one element remains in the list. :param nums: List of non-negative integers :return: The final remaining element in the list >>> maximize_final_result([7]) == 7 >>> maximize_final_result([1, 2]) == 3 >>> maximize_final_result([1, 2, 3, 4, 5]) == 15 >>> maximize_final_result([100, 100, 100, 100]) == 400 >>> maximize_final_result([900, 850, 800]) == 2550 >>> maximize_final_result([5, 1, 8, 3, 7, 2]) == 26","solution":"import heapq def maximize_final_result(nums): Perform operations to maximize the final result by summing the two largest elements until only one element remains in the list. :param nums: List of non-negative integers :return: The final remaining element in the list # Convert nums into a max-heap (use min-heap with negative values for max-heap behavior) max_heap = [-num for num in nums] heapq.heapify(max_heap) while len(max_heap) > 1: # Pop two largest elements (remember they are negative) first = -heapq.heappop(max_heap) second = -heapq.heappop(max_heap) # Add their sum back into the heap new_element = first + second heapq.heappush(max_heap, -new_element) # Return the final remaining element (convert back to positive) return -max_heap[0]"},{"question":"def count_unique_pairs(nums, target): Counts the number of unique pairs (i, j) such that nums[i] + nums[j] == target and i < j. Args: nums (list of int): List of integers. target (int): The target sum. Returns: int: Number of unique pairs. >>> count_unique_pairs([1, 2, 3, 4], 5) 2 >>> count_unique_pairs([1, 1, 1, 1], 2) 1 >>> count_unique_pairs([1, 2, 3], 7) 0","solution":"def count_unique_pairs(nums, target): Counts the number of unique pairs (i, j) such that nums[i] + nums[j] == target and i < j. Args: nums (list of int): List of integers. target (int): The target sum. Returns: int: Number of unique pairs. seen = {} pairs = set() for i, num in enumerate(nums): complement = target - num if complement in seen: for j in seen[complement]: if j < i: pairs.add((complement, num)) if num in seen: seen[num].append(i) else: seen[num] = [i] return len(pairs)"},{"question":"def sum_numbers_as_strings(numbers: List[str]) -> str: Given a list of n strings, where each string represents a number with digits, find the sum of all the numbers in the list and return the result as a string. The input numbers can be very large, so the result must also be returned as a string to handle any possible overflow. >>> sum_numbers_as_strings(['123', '456', '789']) == '1368' >>> sum_numbers_as_strings(['999999999', '999999999', '999999999']) == '2999999997' >>> sum_numbers_as_strings(['12345']) == '12345' >>> sum_numbers_as_strings(['1', '10', '100', '1000']) == '1111' >>> sum_numbers_as_strings([]) == '0' >>> sum_numbers_as_strings(['0', '0', '0']) == '0' >>> sum_numbers_as_strings(['-5', '-10', '15', '20']) == '20'","solution":"def sum_numbers_as_strings(numbers): Given a list of strings representing numbers, returns the sum of those numbers as a string. total_sum = sum(int(num) for num in numbers) return str(total_sum)"},{"question":"def can_transform(s1: str, s2: str, k: int) -> bool: Determines if s1 can be transformed into s2 using no more than k operations. >>> can_transform(\\"abc\\", \\"abd\\", 1) True >>> can_transform(\\"abc\\", \\"xyz\\", 3) True >>> can_transform(\\"abc\\", \\"abd\\", 2) True >>> can_transform(\\"abc\\", \\"abc\\", 0) True >>> can_transform(\\"abc\\", \\"xyz\\", 2) False >>> can_transform(\\"abc\\", \\"abcd\\", 4) False >>> can_transform(\\"\\", \\"\\", 0) True >>> can_transform(\\"\\", \\"\\", 5) True","solution":"def can_transform(s1, s2, k): Determines if s1 can be transformed into s2 using no more than k operations. if len(s1) != len(s2): return False differences = sum(1 for a, b in zip(s1, s2) if a != b) return differences <= k"},{"question":"from typing import List def can_rearrange_no_adjacent(s: str) -> bool: Determines if it is possible to rearrange the characters of string 's' such that no two adjacent characters are the same. >>> can_rearrange_no_adjacent('aabb') True >>> can_rearrange_no_adjacent('abc') True >>> can_rearrange_no_adjacent('aaa') False >>> can_rearrange_no_adjacent('aabbcc') True >>> can_rearrange_no_adjacent('aaab') False >>> can_rearrange_no_adjacent('') True >>> can_rearrange_no_adjacent('a') True","solution":"from collections import Counter import heapq def can_rearrange_no_adjacent(s): Determines if it is possible to rearrange the characters of string 's' such that no two adjacent characters are the same. Args: s (str): input string consisting of lowercase English letters. Returns: bool: True if it is possible to rearrange the characters, False otherwise. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char return len(result) == len(s)"},{"question":"from typing import List def most_common_identifier(snippets: List[str], keywords: List[str]) -> str: Analyze code snippets to determine the most common identifier. Parameters: snippets (list of str): List of code snippets. keywords (list of str): List of keywords to exclude from identifiers. Returns: str: The most common identifier or lexicographically smallest in case of tie. Returns an empty string if no identifiers are found. >>> most_common_identifier([\\"int a = 0;\\"], [\\"int\\", \\"return\\", \\"if\\", \\"else\\"]) == \\"a\\" >>> most_common_identifier([\\"int a = 0;\\", \\"int b = a + 1;\\", \\"int a = b * 2;\\"], [\\"int\\", \\"return\\", \\"if\\", \\"else\\"]) == \\"a\\" >>> most_common_identifier([\\"if (flag) { return x; }\\", \\"while (flag) { int x = 5; flag = 0; }\\"], [\\"if\\", \\"return\\", \\"while\\", \\"int\\"]) == \\"flag\\" >>> most_common_identifier([\\"alpha = 1;\\", \\"beta = 2;\\", \\"alpha = alpha + beta;\\", \\"beta = beta - alpha;\\"], []) == \\"alpha\\" >>> most_common_identifier([\\"if (true) { return 0; }\\"], [\\"if\\", \\"return\\", \\"true\\"]) == \\"\\" >>> most_common_identifier([\\"int if = 3;\\", \\"else if (x) { y = 3 + if; }\\"], [\\"int\\", \\"else\\", \\"if\\"]) == \\"x\\"","solution":"import re from collections import Counter def most_common_identifier(snippets, keywords): Returns the most common identifier from the list of code snippets. Parameters: snippets (list of str): List of code snippets. keywords (list of str): List of keywords to exclude from identifiers. Returns: str: The most common identifier or lexicographically smallest in case of tie. Returns empty string if no identifiers found. keywords_set = set(keywords) identifier_pattern = re.compile(r'b[_a-zA-Z][_a-zA-Z0-9]*b') identifiers = [] for snippet in snippets: found_identifiers = identifier_pattern.findall(snippet) for iden in found_identifiers: if iden not in keywords_set: identifiers.append(iden) if not identifiers: return \\"\\" identifier_counts = Counter(identifiers) most_common_count = identifier_counts.most_common(1)[0][1] most_common_identifiers = [iden for iden, count in identifier_counts.items() if count == most_common_count] return min(most_common_identifiers)"},{"question":"def min_collision_time(l: int, runners: List[List[int]]) -> float: Calculate the minimum time required for any two runners to collide on a circular track. Args: l (int): The length of the circular track. runners (List[List[int]]): An array where runners[i] = [si, vi] represents the starting point and speed of the i-th runner. Returns: float: The minimum time required for any two runners to collide, or -1 if no collision occurs. >>> min_collision_time(10, [[0, 1], [5, 1]]) -1 >>> min_collision_time(10, [[0, 1], [0, 1]]) 0 >>> min_collision_time(10, [[0, 1], [5, 2]]) 10 >>> min_collision_time(10, [[0, 1], [5, 2], [2, 3]]) 5 >>> min_collision_time(10, [[0, 2], [3, 2]]) -1","solution":"import math def min_collision_time(l, runners): min_time = float('inf') for i in range(len(runners)): for j in range(i + 1, len(runners)): s1, v1 = runners[i] s2, v2 = runners[j] if v1 == v2: # If speeds are the same, check if they start at the same point if s1 == s2: return 0 # they start at the same point and will collide instantly else: continue # they'll never collide if speeds are the same and start points different relative_speed = abs(v1 - v2) distance_between = abs(s1 - s2) modulo_distance = distance_between % l if modulo_distance == 0: min_time = 0 else: time_to_collision = l / math.gcd(relative_speed, l) min_time = min(min_time, time_to_collision) if min_time == float('inf'): return -1 return min_time"},{"question":"def num_unique_persons(photo): Returns the number of distinct persons in the given matrix. A person is represented by connected regions of '1's (connected horizontally or vertically). >>> num_unique_persons([ ... [\\"1\\", \\"0\\", \\"0\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"1\\", \\"1\\", \\"0\\"] ... ]) 3 >>> num_unique_persons([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"1\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) 2 >>> num_unique_persons([ ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) 0 >>> num_unique_persons([ ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\"] ... ]) 5 >>> num_unique_persons([ ... [\\"1\\"] ... ]) 1 >>> num_unique_persons([]) 0 >>> num_unique_persons([[\\"0\\"]]) 0 >>> num_unique_persons([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) 1","solution":"def num_unique_persons(photo): Returns the number of distinct persons in the given matrix. A person is represented by connected regions of '1's (connected horizontally or vertically). if not photo: return 0 m, n = len(photo), len(photo[0]) visited = [[False]*n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or photo[i][j] == '0' or visited[i][j]: return visited[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) count = 0 for i in range(m): for j in range(n): if photo[i][j] == '1' and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"class Library: A class to manage a collection of books in a library. Functions: - addBook(title): Adds a book with the given title to the library. - borrowBook(title, member): Allows a member to borrow a book if it's currently available. - returnBook(title, member): Allows a member to return a book they have borrowed. - getAvailableBooks(): Returns a list of titles of all books available in the library. Example: >>> library = Library() >>> library.addBook(\\"Book A\\") >>> library.getAvailableBooks() [\\"Book A\\"] >>> library.borrowBook(\\"Book A\\", \\"Member 1\\") True >>> library.getAvailableBooks() [] >>> library.returnBook(\\"Book A\\", \\"Member 1\\") >>> library.getAvailableBooks() [\\"Book A\\"] def __init__(self): pass def addBook(self, title: str): pass def borrowBook(self, title: str, member: str) -> bool: pass def returnBook(self, title: str, member: str): pass def getAvailableBooks(self) -> List[str]: pass","solution":"class Library: def __init__(self): self.books = {} def addBook(self, title): if title not in self.books: self.books[title] = None def borrowBook(self, title, member): if title in self.books and self.books[title] is None: self.books[title] = member return True return False def returnBook(self, title, member): if title in self.books and self.books[title] == member: self.books[title] = None def getAvailableBooks(self): return [title for title, borrower in self.books.items() if borrower is None]"},{"question":"import heapq from typing import List def lastStoneWeight(stones: List[int]) -> int: Returns the weight of the last remaining stone. Args: stones (list): List of integers representing the weights of the stones. Returns: int: The weight of the last remaining stone or 0 if all stones are destroyed. >>> lastStoneWeight([2, 7, 4, 1, 8, 1]) == 1 >>> lastStoneWeight([4, 4, 4, 4]) == 0 >>> lastStoneWeight([3]) == 3 >>> lastStoneWeight([8, 3]) == 5 >>> lastStoneWeight([]) == 0 pass","solution":"import heapq def lastStoneWeight(stones): Returns the weight of the last remaining stone. Args: stones (list): List of integers representing the weights of the stones. Returns: int: The weight of the last remaining stone or 0 if all stones are destroyed. # Convert all stones to negative for max heap simulation max_heap = [-stone for stone in stones] heapq.heapify(max_heap) while len(max_heap) > 1: first = -heapq.heappop(max_heap) second = -heapq.heappop(max_heap) if first != second: heapq.heappush(max_heap, -(first - second)) return -max_heap[0] if max_heap else 0"},{"question":"def minAddToMakeValid(s: str) -> int: Given a string 's', return the minimum number of parentheses (either '(' or ')') needed to make the string valid. A valid string is one where every close parenthesis ')' has a corresponding open parenthesis '(', and each open parenthesis '(' is matched by a close parenthesis ')'. >>> minAddToMakeValid(\\"()\\") 0 >>> minAddToMakeValid(\\"(())\\") 0 >>> minAddToMakeValid(\\"()()\\") 0 >>> minAddToMakeValid(\\"(()\\") 1 >>> minAddToMakeValid(\\"())\\") 1 >>> minAddToMakeValid(\\")))\\") 3 >>> minAddToMakeValid(\\"(((\\") 3 >>> minAddToMakeValid(\\"())(\\") 2 >>> minAddToMakeValid(\\"(()))(\\") 2 >>> minAddToMakeValid(\\"\\") 0 >>> minAddToMakeValid(\\")\\") 1 >>> minAddToMakeValid(\\"(\\") 1","solution":"def minAddToMakeValid(s): Returns the minimum number of parentheses required to make the input string valid. Args: s (str): The input string containing '(' and ')' Returns: int: The minimum number of parentheses needed to make the string valid. open_needed = 0 close_needed = 0 for char in s: if char == '(': open_needed += 1 elif char == ')': if open_needed > 0: open_needed -= 1 else: close_needed += 1 return open_needed + close_needed"},{"question":"def reconstruct_queue(people): Reconstructs the queue based on the height and the number of people in front of them. :param people: List of tuples (h, k) where h is the height and k is the number of people in front with height >= h :return: The reconstructed queue as a list of tuples (h, k) >>> reconstruct_queue([[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]) == [ ... [5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1] ... ] >>> reconstruct_queue([[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]) == [ ... [4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0] ... ] >>> reconstruct_queue([]) == [] >>> reconstruct_queue([[1, 0]]) == [[1, 0]] >>> reconstruct_queue([[3, 0], [3, 1], [3, 2]]) == [ ... [3, 0], [3, 1], [3, 2] ... ]","solution":"def reconstruct_queue(people): Reconstructs the queue based on the height and the number of people in front of them. :param people: List of tuples (h, k) where h is the height and k is the number of people in front with height >= h :return: The reconstructed queue as a list of tuples (h, k) # Sort the list firstly by height in descending order then by k in ascending order people.sort(key=lambda x: (-x[0], x[1])) queue = [] for person in people: queue.insert(person[1], person) return queue"},{"question":"def can_be_equal_with_swaps(s1: str, s2: str, pairs: List[List[int]]) -> bool: Determines if s1 can be made equal to s2 using the provided swap pairs. :param s1: str - The first string. :param s2: str - The second string. :param pairs: List[List[int]] - List of pairs indicating allowable swaps. :return: bool - True if s1 can be made equal to s2 with the allowable swaps, otherwise False. >>> can_be_equal_with_swaps(\\"abc\\", \\"abc\\", []) == True >>> can_be_equal_with_swaps(\\"abc\\", \\"bca\\", [[0, 1], [1, 2]]) == True >>> can_be_equal_with_swaps(\\"abc\\", \\"cba\\", [[0, 1]]) == False >>> can_be_equal_with_swaps(\\"abcd\\", \\"abcd\\", []) == True >>> can_be_equal_with_swaps(\\"abcd\\", \\"badc\\", [[0, 1], [2, 3]]) == True pass","solution":"def can_be_equal_with_swaps(s1, s2, pairs): Determines if s1 can be made equal to s2 using the provided swap pairs. :param s1: str - The first string. :param s2: str - The second string. :param pairs: List[List[int]] - List of pairs indicating allowable swaps. :return: bool - True if s1 can be made equal to s2 with the allowable swaps, otherwise False. # If the lengths of the strings are not the same, they cannot be equal if len(s1) != len(s2): return False # Function to find the root of the component def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Function to perform union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 n = len(s1) parent = list(range(n)) rank = [0] * n # Apply union operation for each pair for a, b in pairs: union(parent, rank, a, b) # Create a map for root to the list of characters that can be swapped in s1 and s2 from collections import defaultdict root_to_chars_s1 = defaultdict(list) root_to_chars_s2 = defaultdict(list) for i in range(n): root = find(parent, i) root_to_chars_s1[root].append(s1[i]) root_to_chars_s2[root].append(s2[i]) # Check if the characters in each component can be made equal for root in root_to_chars_s1: if sorted(root_to_chars_s1[root]) != sorted(root_to_chars_s2[root]): return False return True"},{"question":"def can_attend_meetings(meetings): Determine if a person can attend all meetings without any overlap. :param meetings: List of meetings represented as pairs of start and end times in the format [[HH:MM, HH:MM], ...] :return: Boolean value indicating whether a person can attend all meetings without overlap. >>> can_attend_meetings([[\\"09:00\\", \\"10:00\\"], [\\"10:15\\", \\"11:15\\"], [\\"11:30\\", \\"12:30\\"]]) True >>> can_attend_meetings([[\\"09:00\\", \\"10:00\\"], [\\"09:50\\", \\"11:15\\"], [\\"11:30\\", \\"12:30\\"]]) False >>> can_attend_meetings([[\\"09:00\\", \\"10:00\\"], [\\"10:00\\", \\"11:00\\"], [\\"11:00\\", \\"12:00\\"]]) True >>> can_attend_meetings([[\\"09:00\\", \\"10:00\\"]]) True >>> can_attend_meetings([]) True >>> can_attend_meetings([[\\"09:00\\", \\"10:00\\"], [\\"14:00\\", \\"15:00\\"]]) True >>> can_attend_meetings([[\\"23:00\\", \\"23:59\\"], [\\"00:00\\", \\"00:30\\"]]) True >>> can_attend_meetings([[\\"23:00\\", \\"23:59\\"], [\\"23:59\\", \\"00:30\\"]]) True","solution":"def can_attend_meetings(meetings): Determine if a person can attend all meetings without any overlap. :param meetings: List of meetings represented as pairs of start and end times in the format [[HH:MM, HH:MM], ...] :return: Boolean value indicating whether a person can attend all meetings without overlap. # Convert time strings to minutes from midnight def time_to_minutes(t): h, m = map(int, t.split(':')) return h * 60 + m # Convert meeting times to start and end in minutes meetings_in_minutes = [(time_to_minutes(start), time_to_minutes(end)) for start, end in meetings] # Sort meetings by start time meetings_in_minutes.sort() # Check for overlaps for i in range(1, len(meetings_in_minutes)): if meetings_in_minutes[i][0] < meetings_in_minutes[i-1][1]: return False return True"},{"question":"def count_safe_landings(obstacles: List[int]) -> int: Counts the number of positions you can safely land on, avoiding obstacles. Parameters: obstacles (list of int): List of obstacle heights. Returns: int: Total number of safe landing positions. >>> count_safe_landings([0, 0, 0, 0, 0]) 5 >>> count_safe_landings([1, 1, 1, 1, 1]) 0 >>> count_safe_landings([0, 1, 0, 1, 0]) 3 >>> count_safe_landings([0]) 1 >>> count_safe_landings([1, 1, 1, 0]) 1 >>> count_safe_landings([0, 0, 1, 0, 1, 0]) 4","solution":"def count_safe_landings(obstacles): Counts the number of positions you can safely land on, avoiding obstacles. Parameters: obstacles (list of int): List of obstacle heights. Returns: int: Total number of safe landing positions. n = len(obstacles) safe_positions = 0 jump_length = 1 for i in range(n): if obstacles[i] == 0: safe_positions += 1 jump_length += 1 return safe_positions"},{"question":"def find_connected_groups(n: int, connections: List[List[int]]) -> int: Returns the number of connected groups in the given set of people. >>> find_connected_groups(5, []) == 5 >>> find_connected_groups(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) == 1 >>> find_connected_groups(5, [[0, 1], [1, 2], [3, 4]]) == 2 >>> find_connected_groups(5, [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) == 5 >>> find_connected_groups(6, [[0, 1], [2, 3], [4, 5], [1, 2], [5, 0]]) == 1","solution":"def find_connected_groups(n, connections): Returns the number of connected groups in the given set of people. parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY for a, b in connections: union(a, b) return len(set(find(x) for x in range(n)))"},{"question":"def score_of_parentheses(s: str) -> int: Returns the score of a balanced parenthesis string based on the rules defined. >>> score_of_parentheses(\\"()\\") 1 >>> score_of_parentheses(\\"(())\\") 2 >>> score_of_parentheses(\\"()()\\") 2 >>> score_of_parentheses(\\"(()(()))\\") 6 >>> score_of_parentheses(\\"(()(()))()\\") 7","solution":"def score_of_parentheses(s): Returns the score of a balanced parenthesis string based on the rules defined. stack = [0] # The stack holds the score of the current frame for char in s: if char == '(': stack.append(0) # Start a new frame else: v = stack.pop() stack[-1] += max(2 * v, 1) # Complete the current frame return stack[0]"},{"question":"from typing import List, Dict, Union def sort_books(books: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: Sort the books by publication year first, then by title in lexicographical order. >>> sort_books([ ... {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960}, ... {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}, ... {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"year\\": 1932}, ... {\\"title\\": \\"Fahrenheit 451\\", \\"author\\": \\"Ray Bradbury\\", \\"year\\": 1953}, ... {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925} ... ]) [{'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald', 'year': 1925}, {'title': 'Brave New World', 'author': 'Aldous Huxley', 'year': 1932}, {'title': '1984', 'author': 'George Orwell', 'year': 1949}, {'title': 'Fahrenheit 451', 'author': 'Ray Bradbury', 'year': 1953}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee', 'year': 1960}] >>> sort_books([ ... {\\"title\\": \\"Animal Farm\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1945}, ... {\\"title\\": \\"Cannery Row\\", \\"author\\": \\"John Steinbeck\\", \\"year\\": 1945}, ... {\\"title\\": \\"Pippi Longstocking\\", \\"author\\": \\"Astrid Lindgren\\", \\"year\\": 1945} ... ]) [{'title': 'Animal Farm', 'author': 'George Orwell', 'year': 1945}, {'title': 'Cannery Row', 'author': 'John Steinbeck', 'year': 1945}, {'title': 'Pippi Longstocking', 'author': 'Astrid Lindgren', 'year': 1945}] >>> sort_books([]) [] >>> sort_books([ ... {\\"title\\": \\"One Hundred Years of Solitude\\", \\"author\\": \\"Gabriel Garcia Marquez\\", \\"year\\": 1967} ... ]) [{'title': 'One Hundred Years of Solitude', 'author': 'Gabriel Garcia Marquez', 'year': 1967}]","solution":"from typing import List, Dict, Union def sort_books(books: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: Sort the books by publication year first, then by title in lexicographical order. return sorted(books, key=lambda x: (x[\\"year\\"], x[\\"title\\"]))"},{"question":"def longestSubarrayDivisibleByK(nums, k): Returns the length of the longest subarray whose sum is divisible by k. >>> longestSubarrayDivisibleByK([1, 2, 3, 4, 5], 5) == 5 >>> longestSubarrayDivisibleByK([1, 2, 3], 7) == 0 >>> longestSubarrayDivisibleByK([5], 5) == 1 >>> longestSubarrayDivisibleByK([1, 2, -1, 4, 3], 3) == 5 >>> longestSubarrayDivisibleByK([0, 0, 0], 1) == 3 >>> longestSubarrayDivisibleByK([-5, -8, -10, -3], 2) == 4 >>> longestSubarrayDivisibleByK([1, 2, 3, 4, 6, 5], 3) == 6 >>> longestSubarrayDivisibleByK([1, 2, 3], -3) == 3 >>> longestSubarrayDivisibleByK([4, 5, 0, -2, -3, 1], 5) == 6","solution":"def longestSubarrayDivisibleByK(nums, k): Returns the length of the longest subarray whose sum is divisible by k. # Dictionary to store the first occurrence of each remainder remainder_index_map = {0: -1} max_length = 0 prefix_sum = 0 for i in range(len(nums)): prefix_sum += nums[i] remainder = prefix_sum % k if remainder < 0: remainder += k if remainder in remainder_index_map: subarray_length = i - remainder_index_map[remainder] max_length = max(max_length, subarray_length) else: remainder_index_map[remainder] = i return max_length"},{"question":"def can_transform_to_one_distinct_char(s: str) -> bool: Determines if it's possible to transform the string s into a string consisting of only one distinct character. >>> can_transform_to_one_distinct_char(\\"aaaa\\") True >>> can_transform_to_one_distinct_char(\\"abab\\") False >>> can_transform_to_one_distinct_char(\\"a\\") True >>> can_transform_to_one_distinct_char(\\"abc\\") False >>> can_transform_to_one_distinct_char(\\"\\") False >>> can_transform_to_one_distinct_char(\\"aa\\") True >>> can_transform_to_one_distinct_char(\\"ab\\") False","solution":"def can_transform_to_one_distinct_char(s): Determines if the string s can be transformed into a string consisting of only one distinct character. # Checking if all characters in the string are the same return len(set(s)) == 1"},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the list of integers can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1, 1, 3, 4, 7]) True >>> can_partition([2, 2, 3, 5]) False >>> can_partition([3, 3, 3, 4, 5]) True >>> can_partition([]) True >>> can_partition([1]) False >>> can_partition([2, 2]) True","solution":"def can_partition(nums): Determines if the list of integers can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, we can't partition it into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array where dp[i] indicates whether subset with sum i can be formed dp = [False] * (target + 1) dp[0] = True # Iterate through the numbers for num in nums: # Traverse the dp array from target to num for i in range(target, num-1, -1): # Update the dp array dp[i] = dp[i] or dp[i-num] return dp[target]"},{"question":"def single_number(nums: List[int]) -> int: Returns the element that appears only once in the array. All other elements appear exactly twice. >>> single_number([2, 2, 3, 4, 4]) == 3 >>> single_number([1]) == 1 >>> single_number([-1, -1, -2, -2, -3]) == -3 >>> single_number([10**6, 10**6, 999999, 999999, 500000]) == 500000 >>> single_number([7, 7, 8, 8, 5]) == 5","solution":"def single_number(nums): Returns the element that appears only once in the array. All other elements appear exactly twice. unique = 0 for num in nums: unique ^= num return unique"},{"question":"def reduce_string(s: str) -> str: Reduces the string by removing pairs of adjacent equal characters iteratively until no more such pairs can be removed. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The final reduced string after performing all possible reductions. >>> reduce_string(\\"abbaca\\") 'ca' >>> reduce_string(\\"\\") '' >>> reduce_string(\\"abc\\") 'abc' >>> reduce_string(\\"aaaa\\") '' >>> reduce_string(\\"abba\\") ''","solution":"def reduce_string(s): Reduces the string by removing pairs of adjacent equal characters iteratively until no more such pairs can be removed. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The final reduced string after performing all possible reductions. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def num_available_seating_areas(grid: List[List[str]]) -> int: Takes a 2D grid as input and returns the number of available seating areas. An available seating area is defined as a group of horizontally or vertically adjacent '0's. >>> num_available_seating_areas([ ['0', '0', '1', '1'], ['1', '0', '1', '1'], ['1', '0', '0', '1'], ['1', '1', '1', '1'] ]) 1 >>> num_available_seating_areas([ ['0', '0', '1', '1', '0'], ['1', '0', '1', '1', '0'], ['1', '1', '1', '0', '0'], ['0', '0', '1', '1', '1'] ]) 3 >>> num_available_seating_areas([ ['1', '1', '1', '1'], ['1', '1', '1', '1'], ['1', '1', '1', '1'], ['1', '1', '1', '1'] ]) 0 >>> num_available_seating_areas([ ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'] ]) 1 >>> num_available_seating_areas([ ['0', '1', '0'], ['1', '0', '1'], ['0', '1', '0'] ]) 5 >>> num_available_seating_areas([]) 0","solution":"def num_available_seating_areas(grid): Returns the number of available seating areas in the given 2D grid. An available seating area is defined as a group of horizontally or vertically adjacent '0's. if not grid: return 0 n = len(grid) m = len(grid[0]) def dfs(i, j): if i < 0 or j < 0 or i >= n or j >= m or grid[i][j] != '0': return grid[i][j] = 'visited' dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == '0': count += 1 dfs(i, j) return count"},{"question":"def longest_repeated_substring(s: str) -> str: Write a function that takes a string \`s\` and returns the longest substring that appears at least twice in \`s\`. If there are multiple such substrings of the same length, return any one of them. If no such substring exists, return an empty string. >>> longest_repeated_substring(\\"abcdef\\") '' >>> result = longest_repeated_substring(\\"aaaa\\") >>> result in {\\"aaa\\", \\"aa\\", \\"a\\"} True >>> longest_repeated_substring(\\"banana\\") 'ana' >>> result = longest_repeated_substring(\\"abcabcabc\\") >>> result in {\\"abcabc\\", \\"bcabca\\", \\"cabcab\\", \\"abc\\", \\"bca\\", \\"cab\\"} True >>> longest_repeated_substring(\\"aabcdaa\\") 'aa' >>> longest_repeated_substring(\\"\\") '' >>> result = longest_repeated_substring(\\"aaaaaa\\") >>> result in {\\"aaaaa\\", \\"aaaa\\", \\"aaa\\", \\"aa\\"} True","solution":"def longest_repeated_substring(s): Returns the longest substring that appears at least twice in the string \`s\`. If there are multiple such substrings of the same length, returns any one of them. If no such substring exists, returns an empty string. n = len(s) longest_substring = \\"\\" def has_repeated_substring(length): seen = set() for i in range(n - length + 1): substr = s[i:i + length] if substr in seen: return substr seen.add(substr) return \\"\\" left, right = 1, n while left <= right: mid = (left + right) // 2 repeated_substr = has_repeated_substring(mid) if repeated_substr: longest_substring = repeated_substr left = mid + 1 else: right = mid - 1 return longest_substring"},{"question":"def rearrange_string(s: str, k: int) -> str: Reorder the string such that every two adjacent characters are different. Return the lexicographically smallest possible reordered string. If it is not possible to rearrange the string, return an empty string. Args: s (str): Input string. k (int): Required distance between adjacent same characters. Returns: str: Reordered string or an empty string if reordering is not possible. >>> rearrange_string(\\"aabbcc\\", 3) 'abcabc' >>> rearrange_string(\\"aaadbbcc\\", 2) 'abacabad' >>> rearrange_string(\\"aaabc\\", 3) '' >>> rearrange_string(\\"a\\", 1) 'a' >>> rearrange_string(\\"abcdef\\", 0) 'abcdef' >>> rearrange_string(\\"cbafe\\", 0) 'abcef'","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): if k == 0: return ''.join(sorted(s)) counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((freq + 1, char)) if len(queue) >= k: next_item = queue.popleft() if next_item[0] < 0: heapq.heappush(max_heap, next_item) return ''.join(result) if len(result) == len(s) else ''"},{"question":"def can_sort_by_swapping_two(heights: List[int]) -> bool: Determines if the list of heights can be sorted by swapping at most two elements. Returns True if it's possible, otherwise False. >>> can_sort_by_swapping_two([1, 2, 3, 4, 5]) True >>> can_sort_by_swapping_two([2, 1, 3, 4, 5]) True >>> can_sort_by_swapping_two([3, 1, 2, 4, 5]) False >>> can_sort_by_swapping_two([1, 2, 3, 5, 4]) True >>> can_sort_by_swapping_two([1, 2, 2, 3, 3]) True >>> can_sort_by_swapping_two([1, 3, 2, 2, 3]) True >>> can_sort_by_swapping_two([3, 1, 2, 2, 3]) False","solution":"def can_sort_by_swapping_two(heights): Determines if the list can be sorted by swapping at most two elements. Returns True if it's possible, otherwise False. n = len(heights) sorted_heights = sorted(heights) diff = [] for i in range(n): if heights[i] != sorted_heights[i]: diff.append(i) if len(diff) == 0: return True # already sorted elif len(diff) == 2: # Only allowed to swap two students return heights[diff[0]] == sorted_heights[diff[1]] and heights[diff[1]] == sorted_heights[diff[0]] return False"},{"question":"from typing import List def max_subarray_sum(arr: List[int], m: int) -> int: Given an array of integers \`arr\`, and an integer \`m\`, find the maximum sum of a subarray with length exactly \`m\`. If the array has fewer than \`m\` elements, returns -1. >>> max_subarray_sum([1,2,3,4,5,6,7,8,9], 3) 24 >>> max_subarray_sum([5, 1, 3, 2, 8, 0, 4], 4) 14 >>> max_subarray_sum([2, 1], 3) -1 >>> max_subarray_sum([5], 1) 5 >>> max_subarray_sum([], 1) -1 >>> max_subarray_sum([1, 3, 5, 7], 4) 16 >>> max_subarray_sum([-1, -2, -3, -4], 2) -3 >>> max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5], 4) 16","solution":"def max_subarray_sum(arr, m): Returns the maximum sum of a subarray with the length exactly \`m\`. If the array has fewer than \`m\` elements, returns -1. if len(arr) < m: return -1 max_sum = float('-inf') current_sum = sum(arr[:m]) max_sum = max(max_sum, current_sum) for i in range(m, len(arr)): current_sum += arr[i] - arr[i - m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def merge_alternately(word1: str, word2: str) -> str: Merges two strings by pulling characters alternately from each string. Any remaining characters from the longer string are appended at the end. Parameters: word1 (str): The first string. word2 (str): The second string. Returns: str: The merged string. Examples: >>> merge_alternately(\\"abc\\", \\"pqr\\") 'apbqcr' >>> merge_alternately(\\"abcd\\", \\"pq\\") 'apbqcd' >>> merge_alternately(\\"ab\\", \\"pqrs\\") 'apbqrs' >>> merge_alternately(\\"\\", \\"\\") '' >>> merge_alternately(\\"abc\\", \\"\\") 'abc' >>> merge_alternately(\\"\\", \\"xyz\\") 'xyz' >>> merge_alternately(\\"a\\", \\"b\\") 'ab' >>> merge_alternately(\\"a\\", \\"bc\\") 'abc' >>> merge_alternately(\\"ab\\", \\"c\\") 'acb'","solution":"def merge_alternately(word1, word2): Merges two strings by pulling characters alternately from each string. Any remaining characters from the longer string are appended at the end. Parameters: word1 (str): The first string. word2 (str): The second string. Returns: str: The merged string. merged = [] i, j = 0, 0 while i < len(word1) and j < len(word2): merged.append(word1[i]) merged.append(word2[j]) i += 1 j += 1 if i < len(word1): merged.append(word1[i:]) if j < len(word2): merged.append(word2[j:]) return ''.join(merged) # Example usage: # merge_alternately(\\"abc\\", \\"pqr\\") # returns \\"apbqcr\\" # merge_alternately(\\"ab\\", \\"pqrs\\") # returns \\"apbqrs\\" # merge_alternately(\\"abcd\\", \\"pq\\") # returns \\"apbqcd\\""},{"question":"def max_subarray_sum(nums: List[int], k: int) -> int: Returns the maximum sum of a continuous subarray of length exactly k. If nums contains fewer than k elements, return -1. >>> max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum([1, -1, 5, -2, 3], 3) 6 >>> max_subarray_sum([1, 2], 3) -1 pass # Unit Tests def test_example_cases(): assert max_subarray_sum([1, 2, 3, 4, 5], 2) == 9 assert max_subarray_sum([1, -1, 5, -2, 3], 3) == 6 assert max_subarray_sum([1, 2], 3) == -1 def test_edge_cases(): assert max_subarray_sum([], 1) == -1 assert max_subarray_sum([1], 1) == 1 assert max_subarray_sum([1], 2) == -1 assert max_subarray_sum([4, 2, 1, 6], 4) == 13 def test_general_cases(): assert max_subarray_sum([1, 2, 1, 2, 6, 7, 5], 2) == 13 assert max_subarray_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 4) == 30 assert max_subarray_sum([1, -1, -1, 2, -5], 2) == 1 assert max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4], 2) == -3 assert max_subarray_sum([5, 5, 5, 5, 5, 5, 5], 3) == 15","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of a continuous subarray of length exactly k. If nums contains fewer than k elements, return -1. n = len(nums) if n < k: return -1 # compute the sum of the first 'k' elements max_sum = current_sum = sum(nums[:k]) # use sliding window to compute the sum of remaining subarrays of size 'k' for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_profit(orders: List[List[int]]) -> int: Determines the maximum profit that can be achieved by buying the product on one day and selling it on another day after the day you bought it. Args: orders (list of list of int): A 2D array where each sublist consists of [buyPrice, sellPrice]. Returns: int: The maximum profit possible. If no profit can be made, returns 0. >>> max_profit([[1, 5], [2, 7], [3, 9]]) 8 >>> max_profit([[7, 5], [5, 4], [3, 2]]) 0 >>> max_profit([[1, 10]]) 9 >>> max_profit([]) 0 >>> max_profit([[1, 2], [2, 4], [1, 5], [2, 6]]) 5 >>> max_profit([[9, 8], [8, 7], [7, 6], [6, 5]]) 0","solution":"def max_profit(orders): Determines the maximum profit that can be achieved by buying the product on one day and selling it on another day after the day you bought it. Args: orders (list of list of int): A 2D array where each sublist consists of [buyPrice, sellPrice]. Returns: int: The maximum profit possible. If no profit can be made, returns 0. if not orders: return 0 min_buy_price = float('inf') max_profit = 0 for buy_price, sell_price in orders: min_buy_price = min(min_buy_price, buy_price) max_profit = max(max_profit, sell_price - min_buy_price) return max_profit"},{"question":"def countTrailingZeros(n: int) -> int: Returns the number of trailing zeros in the factorial of n. >>> countTrailingZeros(5) 1 >>> countTrailingZeros(10) 2 >>> countTrailingZeros(20) 4 >>> countTrailingZeros(100) 24 >>> countTrailingZeros(0) 0 >>> countTrailingZeros(25) 6 >>> countTrailingZeros(50) 12","solution":"def countTrailingZeros(n): Returns the number of trailing zeros in the factorial of n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"def has_abs_difference_of_two(nums: List[int]) -> bool: Determines whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is exactly 2. >>> has_abs_difference_of_two([1, 3, 5, 7]) == True >>> has_abs_difference_of_two([1, 2, 4, 5]) == True >>> has_abs_difference_of_two([1, 1, 1, 1]) == False >>> has_abs_difference_of_two([1, -1, 3, 5]) == True >>> has_abs_difference_of_two([0]) == False >>> has_abs_difference_of_two([]) == False >>> has_abs_difference_of_two([2, 4, 6, 8]) == True >>> has_abs_difference_of_two([10, 12, 14, 16]) == True >>> has_abs_difference_of_two([100, 200, 300]) == False >>> has_abs_difference_of_two([-3, -1, 1, 3]) == True","solution":"def has_abs_difference_of_two(nums): Determines whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is exactly 2. :param nums: List of integers. :return: True if such indices exist, False otherwise. values = set(nums) for num in nums: if (num + 2) in values or (num - 2) in values: return True return False"},{"question":"def min_length_to_remove(t, words): Finds the minimum total length of segments to remove from \`t\` to ensure none of the strings in \`words\` is a subsequence of \`t\`. >>> min_length_to_remove(\\"abcdefgh\\", [\\"xyz\\", \\"mno\\"]) == 0 >>> min_length_to_remove(\\"abcdefghij\\", [\\"abc\\", \\"def\\"]) == 6 >>> min_length_to_remove(\\"abpcplea\\", [\\"apple\\", \\"ale\\"]) == 5 >>> min_length_to_remove(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) == 3 >>> min_length_to_remove(\\"abc\\", []) == 0 >>> min_length_to_remove(\\"aabbcc\\", [\\"abc\\", \\"bbc\\"]) == 3 pass # Your implementation here","solution":"def min_length_to_remove(t, words): Finds the minimum total length of segments to remove from \`t\` to ensure none of the strings in \`words\` is a subsequence of \`t\`. :param t: The input string from which segments need to be removed. :param words: List of strings that should not be subsequences of \`t\`. :return: Minimum total length of segments to remove. def is_subsequence(word, t): it = iter(t) return all(char in it for char in word) total_length = 0 for word in words: if is_subsequence(word, t): total_length += len(word) # Remove the subsequence from \`t\` subseq_chars = list(word) t = ''.join(char for char in t if not (subseq_chars and char == subseq_chars[0] and subseq_chars.pop(0))) return total_length"},{"question":"def plant_growth(m, n, k, coordinates): Simulates the growth of plants in a m x n grid over k days by setting plant growth in all 4 directions by 1 unit each day. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid k (int): number of days coordinates (List[Tuple[int, int]]): list of tuples representing initial plant coordinates Returns: List[List[int]]: grid state after k days >>> plant_growth(3, 3, 1, [(1, 1)]) [[0, 1, 0], [1, 1, 1], [0, 1, 0]] >>> plant_growth(3, 3, 0, [(1, 1)]) [[0, 0, 0], [0, 1, 0], [0, 0, 0]]","solution":"def plant_growth(m, n, k, coordinates): Simulates the growth of plants in a m x n grid over k days. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid k (int): number of days coordinates (List[Tuple[int, int]]): list of tuples representing initial plant coordinates Returns: List[List[int]]: grid state after k days grid = [[0] * n for _ in range(m)] for x, y in coordinates: grid[x][y] = 1 for _ in range(k): new_grid = [row[:] for row in grid] for i in range(m): for j in range(n): if grid[i][j] == 1: if i > 0: new_grid[i-1][j] = 1 if i < m - 1: new_grid[i+1][j] = 1 if j > 0: new_grid[i][j-1] = 1 if j < n - 1: new_grid[i][j+1] = 1 grid = new_grid return grid"},{"question":"def min_sum_of_max_elements(nums, k): Returns the minimum sum of the maximum elements of all subarrays of length k. Args: nums: List[int] - A list of non-negative integers. k: int - The length of subarrays to consider. Returns: int - The minimum sum of the maximum elements of all subarrays of length k. If k is greater than the length of the array, return None. Examples: >>> min_sum_of_max_elements([1, 3, 2, 4, 5], 3) 12 >>> min_sum_of_max_elements([1, 2, 3, 4, 5], 1) 15 >>> min_sum_of_max_elements([2, 2, 2, 2, 2], 3) 6 >>> min_sum_of_max_elements([4, 2, 1], 2) 6 >>> min_sum_of_max_elements([1, 2, 3, 4, 5], 5) 5 >>> min_sum_of_max_elements([1, 2, 3], 4) is None True","solution":"def min_sum_of_max_elements(nums, k): Returns the minimum sum of the maximum elements of all subarrays of length k. from collections import deque n = len(nums) if n < k: return None # Edge case: subarray length can't be greater than the length of nums # Array to store maximums of subarrays max_of_subarrays = [] dq = deque() # Process the first window (first k elements) for i in range(k): while dq and nums[dq[-1]] <= nums[i]: dq.pop() dq.append(i) # Process the rest of the elements for i in range(k, n): # The element at the front of the deque is the largest element of the previous window max_of_subarrays.append(nums[dq[0]]) # Remove elements that are out of this window while dq and dq[0] <= i - k: dq.popleft() # Remove elements not useful for this window while dq and nums[dq[-1]] <= nums[i]: dq.pop() dq.append(i) # Add the maximum element of the last window max_of_subarrays.append(nums[dq[0]]) # Return the sum of these maximum elements return sum(max_of_subarrays)"},{"question":"def is_match(s: str, p: str) -> bool: Returns true if the string \`s\` matches the pattern \`p\` where \`p\` may contain wildcard character \`*\` that can match any sequence of characters including the empty sequence. >>> is_match(\\"abc\\", \\"abc\\") True >>> is_match(\\"abc\\", \\"a*c\\") True >>> is_match(\\"abc\\", \\"*bc\\") True >>> is_match(\\"abc\\", \\"ab*\\") True >>> is_match(\\"abc\\", \\"*a*b*c*\\") True >>> is_match(\\"abc\\", \\"abd\\") False >>> is_match(\\"\\", \\"\\") True >>> is_match(\\"\\", \\"*\\") True >>> is_match(\\"abc\\", \\"\\") False >>> is_match(\\"ab\\", \\"abcd*\\") False","solution":"def is_match(s, p): Returns true if the string \`s\` matches the pattern \`p\` where \`p\` may contain wildcard character \`*\` that can match any sequence of characters including the empty sequence. m, n = len(s), len(p) # Create a 2D DP array to hold the match status dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # Empty pattern matches empty string # Initialize for patterns starting with '*' for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] # Fill the DP array for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] else: dp[i][j] = dp[i - 1][j - 1] and s[i - 1] == p[j - 1] return dp[m][n]"},{"question":"def min_subarray_len(s: int, arr: List[int]) -> int: Returns the minimum length of a contiguous subarray for which the sum is at least \`s\`. If no such subarray exists, returns 0. :param s: int - the target sum :param arr: List[int] - the input array :return: int - the length of the smallest subarray with sum at least s >>> min_subarray_len(7, [2,3,1,2,4,3]) 2 >>> min_subarray_len(15, [1,2,3,4,5]) 5 >>> min_subarray_len(6, [10, 2, 3]) 1 >>> min_subarray_len(100, [1,2,3,4,5]) 0 >>> min_subarray_len(10, []) 0 >>> min_subarray_len(5, [5]) 1 >>> min_subarray_len(5, [1,1,1,1,1,1,1,1]) 5 >>> min_subarray_len(1, [1]) 1","solution":"def min_subarray_len(s, arr): Returns the minimum length of a contiguous subarray for which the sum is at least \`s\`. If no such subarray exists, returns 0. :param s: int - the target sum :param arr: List[int] - the input array :return: int - the length of the smallest subarray with sum at least s n = len(arr) min_length = float('inf') left = 0 curr_sum = 0 for right in range(n): curr_sum += arr[right] while curr_sum >= s: min_length = min(min_length, right - left + 1) curr_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Determines if s1 is a rotation of s2. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a rotation of s2, False otherwise. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"hello\\", \\"oellh\\") False >>> is_rotation(\\"abcdef\\", \\"abcdef\\") True >>> is_rotation(\\"abc\\", \\"ab\\") False >>> is_rotation(\\"\\", \\"\\") True >>> is_rotation(\\"abc\\", \\"\\") False >>> is_rotation(\\"\\", \\"abc\\") False >>> is_rotation(\\"a\\", \\"a\\") True >>> is_rotation(\\"a\\", \\"b\\") False","solution":"def is_rotation(s1, s2): Determines if s1 is a rotation of s2. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a rotation of s2, False otherwise. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"def canFinish(numCourses, prerequisites): Determine if it is possible to finish all courses given the prerequisites. >>> canFinish(2, []) True >>> canFinish(2, [[1, 0]]) True >>> canFinish(2, [[1, 0], [0, 1]]) False >>> canFinish(4, [[1, 0], [2, 1], [3, 2]]) True >>> canFinish(4, [[1, 0], [2, 1], [3, 2], [1, 3]]) False >>> canFinish(5, [[1, 0], [2, 1], [4, 3]]) True >>> canFinish(1, []) True >>> canFinish(1, [[0, 0]]) False","solution":"def canFinish(numCourses, prerequisites): from collections import defaultdict, deque # Build the graph and compute in-degrees of each node graph = defaultdict(list) in_degree = [0] * numCourses for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Initialize queue with courses that have no prerequisites queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If count equals numCourses, there's no cycle and all courses can be completed return count == numCourses"},{"question":"from typing import List def find_min_radius(houses: List[int], heaters: List[int]) -> int: Find the minimum radius \`r\` such that all houses are covered by at least one heater. >>> find_min_radius([1, 2, 3], [2]) == 1 >>> find_min_radius([1, 2, 3, 4], [1, 4]) == 1 >>> find_min_radius([1, 5], [2]) == 3 >>> find_min_radius([1, 2, 3, 6, 7], [2, 3, 5]) == 2 >>> find_min_radius([1, 2, 3], []) == -1 >>> find_min_radius([], [1, 2, 3]) == -1 >>> find_min_radius([1, 5, 9], [2, 4, 6]) == 3 >>> find_min_radius([-1, 0, 1], [0]) == 1 >>> find_min_radius([-1, -2, -3], [-2]) == 1 >>> find_min_radius([1, 2, 3, 4, 9], [1, 4]) == 5","solution":"def find_min_radius(houses, heaters): if not houses or not heaters: return -1 houses.sort() heaters.sort() def binary_search(value): left, right = 0, len(heaters) - 1 while left <= right: mid = left + (right - left) // 2 if heaters[mid] < value: left = mid + 1 else: right = mid - 1 return left radius = 0 for house in houses: pos = binary_search(house) left_heater = heaters[pos-1] if pos - 1 >= 0 else float('-inf') right_heater = heaters[pos] if pos < len(heaters) else float('inf') min_dist = min(abs(left_heater - house), abs(right_heater - house)) radius = max(radius, min_dist) return radius"},{"question":"def can_see_front(arr: List[int]) -> List[int]: Rearrange the array such that each student can see the student directly in front of them unless they are shorter or of the same height. >>> can_see_front([4, 5, 6, 7]) [7, 6, 5, 4] >>> can_see_front([1, 3, 2, 4]) [4, 3, 2, 1] >>> can_see_front([2, 2, 2, 2]) [2, 2, 2, 2] >>> can_see_front([5, 1, 5, 1]) [5, 5, 1, 1] >>> can_see_front([3]) [3] >>> can_see_front([]) []","solution":"def can_see_front(arr): Rearrange the array such that each student can see the student directly in front unless they are shorter or of the same height. arr.sort(reverse=True) return arr"},{"question":"def get_factors_combinations(n: int) -> List[List[int]]: Write a function that takes an integer \`n\` and returns all possible unique combinations of factors (excluding 1 and \`n\`) that multiply to \`n\`. Each combination should be represented as a list of integers. The combinations can be returned in any order. However, the factors should be listed in non-descending order within each combination. If no combination exists, return an empty list. >>> get_factors_combinations(12) [[2, 6], [2, 2, 3], [3, 4]] >>> get_factors_combinations(15) [[3, 5]] >>> get_factors_combinations(28) [[2, 14], [2, 2, 7], [4, 7]] >>> get_factors_combinations(1) [] >>> get_factors_combinations(7) [] >>> get_factors_combinations(60) [ [2, 30], [2, 2, 15], [2, 2, 3, 5], [2, 3, 10], [2, 5, 6], [3, 20], [3, 4, 5], [4, 15], [5, 12], [6, 10] ]","solution":"def get_factors_combinations(n): def backtrack(start, n, curr_combo, results): if n == 1 and len(curr_combo) > 1: results.append(curr_combo[:]) return for i in range(start, int(n**0.5) + 1): if n % i == 0: curr_combo.append(i) backtrack(i, n // i, curr_combo, results) curr_combo.pop() if n >= start: curr_combo.append(n) backtrack(n, 1, curr_combo, results) curr_combo.pop() results = [] backtrack(2, n, [], results) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest value in the BST. >>> root = TreeNode(1) >>> kth_smallest(root, 1) 1 >>> root = TreeNode(3, TreeNode(2, TreeNode(1))) >>> kth_smallest(root, 1) 1 >>> kth_smallest(root, 2) 2 >>> kth_smallest(root, 3) 3 >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> kth_smallest(root, 1) 1 >>> kth_smallest(root, 2) 2 >>> kth_smallest(root, 3) 3 >>> root = TreeNode(3, TreeNode(1, None, TreeNode(2)), TreeNode(4)) >>> kth_smallest(root, 1) 1 >>> kth_smallest(root, 2) 2 >>> kth_smallest(root, 3) 3 >>> kth_smallest(root, 4) 4 >>> root = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(2)), TreeNode(3, None, TreeNode(4))), TreeNode(6)) >>> kth_smallest(root, 1) 2 >>> kth_smallest(root, 2) 2 >>> kth_smallest(root, 3) 3 >>> kth_smallest(root, 4) 3 >>> kth_smallest(root, 5) 4 >>> kth_smallest(root, 6) 5 >>> kth_smallest(root, 7) 6","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest value in the BST. def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] inorder_elements = inorder_traversal(root) return inorder_elements[k - 1]"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Determines the shortest path from the top-left corner to the bottom-right corner in an n x n grid containing only values 0 and 1. You can move up, down, left, or right. The path can only pass through cells containing 0. Parameters: grid (list of list of int): The grid containing 0s and 1s. Returns: int: Length of the shortest path or -1 if no such path exists. >>> shortest_path([[0, 1, 1], [1, 1, 0], [0, 1, 1]]) -1 >>> shortest_path([[0]]) 1 >>> shortest_path([[1]]) -1 >>> shortest_path([[0, 0, 0], [1, 1, 0], [1, 1, 0]]) 5 >>> shortest_path([[0, 0], [0, 0]]) 3 >>> shortest_path([[0, 0, 0, 0], [1, 1, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0]]) 7 >>> shortest_path([[0, 0, 1, 0], [1, 0, 1, 0], [1, 0, 1, 0], [1, 1, 1, 0]]) -1","solution":"from collections import deque def shortest_path(grid): Determines the shortest path from the top-left corner to the bottom-right corner in an n x n grid containing only values 0 and 1. You can move up, down, left, or right. The path can only pass through cells containing 0. Parameters: grid (list of list of int): The grid containing 0s and 1s. Returns: int: Length of the shortest path or -1 if no such path exists. n = len(grid) if grid[0][0] != 0 or grid[n-1][n-1] != 0: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, n-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def reorganize_string(s: str) -> str: Rearranges the characters of the string \`s\` so that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, return an empty string. If multiple valid rearrangements exist, return any of them. >>> reorganize_string(\\"aab\\") 'aba' >>> reorganize_string(\\"aaab\\") '' >>> reorganize_string(\\"a\\") 'a' >>> reorganize_string(\\"ab\\") 'ab' >>> reorganize_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"abcaba\\", \\"bacaba\\", \\"bacaba\\"] >>> s = \\"aaabbbccc\\" >>> result = reorganize_string(s) >>> assert result.startswith(\\"a\\") and \\"aaa\\" not in result and \\"bbb\\" not in result and \\"ccc\\" not in result","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: Rearranges the characters of the string so that no two adjacent characters are the same. If it is not possible, return an empty string. # Step 1: Count the frequencies of each character char_count = Counter(s) # Step 2: Create a max heap with (-frequency, char) so that we can pop the most frequent character first max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 # Decrement freq since it's added to result prev_char = char result_str = ''.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Finds two distinct numbers in the array that add up to the target and returns them sorted in ascending order. If multiple pairs exist, returns the pair with the smallest first number. If no such pair exists, returns an empty array. >>> two_sum([2, 7, 11, 15], 9) [2, 7] >>> two_sum([1, 2, 3, 4, 5], 8) [3, 5] >>> two_sum([1, 2, 3, 4, 5], 10) [] >>> two_sum([1, 1, 1, 1], 3) [] >>> two_sum([1, 9, 2, 8, 3, 7, 4, 6, 5], 10) [1, 9] >>> two_sum([10], 10) [] >>> two_sum([-1, -2, -3, -4, -5], -8) [-5, -3] pass","solution":"def two_sum(nums, target): Finds two distinct numbers in the array that add up to the target and returns them sorted in ascending order. If multiple pairs exist, returns the pair with the smallest first number. If no such pair exists, returns an empty array. seen = {} smallest_pair = None for num in nums: complement = target - num if complement in seen: current_pair = sorted([num, complement]) if smallest_pair is None or current_pair[0] < smallest_pair[0]: smallest_pair = current_pair seen[num] = True return smallest_pair if smallest_pair else []"},{"question":"def minimum_trips(packages: List[int], capacity: int) -> int: Determine the minimum number of trips the truck needs to make to deliver all packages. >>> minimum_trips([1, 2, 3, 4], 5) 4 >>> minimum_trips([10, 10, 10], 10) 3 >>> minimum_trips([10, 10, 10], 5) 6 >>> minimum_trips([15], 10) 2 >>> minimum_trips([3, 6, 9], 9) 3 >>> minimum_trips([1, 2, 3, 15], 10) 5 >>> minimum_trips([5, 5, 5, 5], 5) 4 >>> minimum_trips([], 10) 0","solution":"def minimum_trips(packages, capacity): trips = 0 i = 0 while i < len(packages): if packages[i] <= capacity: trips += 1 i += 1 else: trips += 1 packages[i] -= capacity return trips"},{"question":"def longest_even_odd_subarray(arr, queries): You are given a **0-indexed** array of non-negative integers \`arr\`. You are also given a **0-indexed** 2D integer array \`queries\` where \`queries[i] = [li, ri]\`, and each query represents a range \`[li, ri]\`. For each query, you need to calculate and return the length of the longest contiguous subarray within the specified range \`[li, ri]\` that has an equal number of even and odd numbers. Return _an array_ \`answer\` _of the same length as_ \`queries\`, _where_ \`answer[i]\` _is the answer to the_ \`ith\` _query_. If no such subarray exists, the answer for that query should be \`0\`. >>> longest_even_odd_subarray([1, 2, 3], [[0, 0]]) [0] >>> longest_even_odd_subarray([1, 2, 1, 2], [[0, 3]]) [4] >>> longest_even_odd_subarray([1, 2, 3, 4], [[1, 3]]) [2]","solution":"def longest_even_odd_subarray(arr, queries): def max_even_odd_length(subarr): n = len(subarr) even_count = 0 odd_count = 0 max_len = 0 prefix = {0: -1} # prefix counts to index for i in range(n): if subarr[i] % 2 == 0: even_count += 1 else: odd_count += 1 # check difference between counts in prefix diff = even_count - odd_count if diff in prefix: max_len = max(max_len, i - prefix[diff]) else: prefix[diff] = i return max_len result = [] for l, r in queries: subarr = arr[l:r+1] result.append(max_even_odd_length(subarr)) return result"},{"question":"def contains_magic_square(matrix): Determine if there is a magic square of size 3x3 in the given matrix. A magic square is a 3x3 grid filled with distinct integers from 1 to 9 such that each row, each column, and both diagonals all have the same sum. >>> contains_magic_square([ ... [10, 3, 5, 4, 9, 2], ... [8, 7, 6, 3, 5, 7], ... [1, 2, 3, 8, 1, 6] ... ]) == True >>> contains_magic_square([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == False","solution":"def is_magic_square(submatrix): s = 15 # Sum of each row/column/diagonal in a 3x3 magic square of 1-9 return ( sum(submatrix[0]) == s and sum(submatrix[1]) == s and sum(submatrix[2]) == s and sum(submatrix[i][0] for i in range(3)) == s and sum(submatrix[i][1] for i in range(3)) == s and sum(submatrix[i][2] for i in range(3)) == s and submatrix[0][0] + submatrix[1][1] + submatrix[2][2] == s and submatrix[0][2] + submatrix[1][1] + submatrix[2][0] == s and sorted(submatrix[i][j] for i in range(3) for j in range(3)) == list(range(1, 10)) ) def contains_magic_square(matrix): rows, cols = len(matrix), len(matrix[0]) for i in range(rows - 2): for j in range(cols - 2): submatrix = [matrix[i + x][j:j + 3] for x in range(3)] if is_magic_square(submatrix): return True return False"},{"question":"import itertools from typing import List, Tuple def generate_combinations(wordlist: List[str]) -> List[Tuple[str]]: Returns all possible permutations of the strings in the wordlist. Each permutation is unique based on its order. Parameters: wordlist (list of str): List of distinct strings. Returns: list of list of str: List of all permutations of the wordlist. pass def test_generate_combinations(): wordlist = [\\"apple\\", \\"banana\\", \\"cherry\\"] expected_permutations = [ (\\"apple\\", \\"banana\\", \\"cherry\\"), (\\"apple\\", \\"cherry\\", \\"banana\\"), (\\"banana\\", \\"apple\\", \\"cherry\\"), (\\"banana\\", \\"cherry\\", \\"apple\\"), (\\"cherry\\", \\"apple\\", \\"banana\\"), (\\"cherry\\", \\"banana\\", \\"apple\\") ] result = generate_combinations(wordlist) assert len(result) == len(expected_permutations) for perm in expected_permutations: assert perm in result def test_generate_combinations_single(): wordlist = [\\"apple\\"] expected_permutations = [ (\\"apple\\",) ] result = generate_combinations(wordlist) assert result == expected_permutations def test_generate_combinations_empty(): wordlist = [] expected_permutations = [ () ] result = generate_combinations(wordlist) assert result == expected_permutations def test_generate_combinations_two(): wordlist = [\\"apple\\", \\"banana\\"] expected_permutations = [ (\\"apple\\", \\"banana\\"), (\\"banana\\", \\"apple\\") ] result = generate_combinations(wordlist) assert len(result) == len(expected_permutations) for perm in expected_permutations: assert perm in result","solution":"import itertools def generate_combinations(wordlist): Returns all possible permutations of the strings in the wordlist. Each permutation is unique based on its order. Parameters: wordlist (list of str): List of distinct strings. Returns: list of list of str: List of all permutations of the wordlist. return list(itertools.permutations(wordlist))"},{"question":"def merge_sorted_arrays(nums1: List[int], nums2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. Args: nums1: List[int] - First sorted array. nums2: List[int] - Second sorted array. Returns: List[int] - Merged sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] pass","solution":"def merge_sorted_arrays(nums1, nums2): Merges two sorted arrays into a single sorted array. Args: nums1: List[int] - First sorted array. nums2: List[int] - Second sorted array. Returns: List[int] - Merged sorted array. merged_array = [] i, j = 0, 0 while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 # Append remaining elements of nums1 or nums2 while i < len(nums1): merged_array.append(nums1[i]) i += 1 while j < len(nums2): merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"from typing import List def min_steps_to_reach_end(grid: List[List[int]]) -> int: Find the minimum number of steps required to reach the bottom-right corner from the top-left corner. If it's not possible to reach the destination, return -1. >>> min_steps_to_reach_end([ ... [0, 0], ... [0, 0] ... ]) 2 >>> min_steps_to_reach_end([ ... [0, -1], ... [0, 0] ... ]) 2 >>> min_steps_to_reach_end([ ... [0, -1], ... [-1, 0] ... ]) -1 >>> min_steps_to_reach_end([ ... [0, 0, 0], ... [0, -1, 0], ... [0, 0, 0] ... ]) 4 >>> min_steps_to_reach_end([ ... [-1, 0], ... [0, -1] ... ]) -1 >>> min_steps_to_reach_end([ ... [0, 0, 0, 0], ... [0, -1, -1, -1], ... [0, 0, 0, 0], ... [-1, -1, -1, 0] ... ]) 6 pass","solution":"from collections import deque def min_steps_to_reach_end(grid): Find the minimum number of steps required to reach the bottom-right corner from the top-left corner. If it's not possible to reach the destination, return -1. rows, cols = len(grid), len(grid[0]) if grid[0][0] == -1 or grid[rows-1][cols-1] == -1: return -1 # Directions to move: right and down directions = [(0, 1), (1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set() visited.add((0, 0)) while queue: row, col, steps = queue.popleft() # If we reached the bottom-right corner if row == rows - 1 and col == cols - 1: return steps for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < rows and 0 <= c < cols and (r, c) not in visited and grid[r][c] != -1: queue.append((r, c, steps + 1)) visited.add((r, c)) # If we exit the loop without having reached the bottom-right corner, return -1 return -1"},{"question":"def smallest_integer_with_digit_sum(n: int) -> int: Returns the smallest integer k such that the sum of the digits of k is equal to n. If no such k exists, return -1. >>> smallest_integer_with_digit_sum(1) 1 >>> smallest_integer_with_digit_sum(5) 5 >>> smallest_integer_with_digit_sum(10) 19 >>> smallest_integer_with_digit_sum(15) 69 >>> smallest_integer_with_digit_sum(18) 99 >>> smallest_integer_with_digit_sum(0) -1 >>> smallest_integer_with_digit_sum(-1) -1","solution":"def smallest_integer_with_digit_sum(n): Returns the smallest integer k such that the sum of the digits of k is equal to n. If no such k exists, return -1. if n < 1: return -1 # The maximum sum of digits less than a single digit number is 9. # If the sum required is greater, we need to form the number using more digits. k = 0 if n <= 9: return n # Form the smallest number k where digits add up to n digits = [] while n > 0: if n >= 9: digits.append(9) n -= 9 else: digits.append(n) n = 0 # Convert digits array to a number k = int(''.join(map(str, digits[::-1]))) return k"},{"question":"def max_sum_contiguous_subarray(nums: List[int], k: int) -> Tuple[int, List[int]]: Finds the maximum sum of a contiguous subarray with at most \`k\` elements. Returns a tuple of the maximum sum and the subarray. >>> max_sum_contiguous_subarray([], 3) (0, []) >>> max_sum_contiguous_subarray([5], 3) (5, [5]) >>> max_sum_contiguous_subarray([1, 2, 3, 4, 5], 3) (12, [3,4,5]) >>> max_sum_contiguous_subarray([-1, -2, -3, -4, -5], 3) (-1, [-1]) >>> max_sum_contiguous_subarray([1, -1, 5, -2, 3, -3], 3) (6, [5, -2, 3]) >>> max_sum_contiguous_subarray([1, 2, 3], 5) (6, [1, 2, 3]) >>> res = max_sum_contiguous_subarray([3, 3, 3, 3], 2) >>> res in [(6, [3, 3])] True","solution":"def max_sum_contiguous_subarray(nums, k): Finds the maximum sum of a contiguous subarray with at most \`k\` elements. Returns a tuple of the maximum sum and the subarray. n = len(nums) if n == 0: return (0, []) max_sum = float('-inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] # Check if the current subarray length exceeds k if end - start + 1 > k: current_sum -= nums[start] start += 1 if current_sum > max_sum: max_sum = current_sum max_subarray = nums[start:end + 1] return (max_sum, max_subarray)"},{"question":"def max_non_overlapping_subarrays(arr: List[int], target: int) -> int: Finds the maximum number of non-overlapping subarrays with sum equal to target. :param arr: List[int] - The input array of integers. :param target: int - The target sum for subarrays. :return: int - The maximum number of non-overlapping subarrays with sum equal to target. >>> max_non_overlapping_subarrays([1,1,1,1,1], 2) 2 >>> max_non_overlapping_subarrays([-1,3,5,1,4,2,-9], 6) 2 >>> max_non_overlapping_subarrays([5], 5) 1 >>> max_non_overlapping_subarrays([1], 2) 0 >>> max_non_overlapping_subarrays([2,2,2,2], 4) 2 >>> max_non_overlapping_subarrays([3,3,3,3], 3) 4 >>> max_non_overlapping_subarrays([1,2,3,4,5], 20) 0 >>> max_non_overlapping_subarrays([5,5,5,5,5], 5) 5 >>> max_non_overlapping_subarrays([5,5,5,5,-5,5,5,-5,5], 0) 2","solution":"def max_non_overlapping_subarrays(arr, target): Finds the maximum number of non-overlapping subarrays with sum equal to target. :param arr: List[int] - The input array of integers. :param target: int - The target sum for subarrays. :return: int - The maximum number of non-overlapping subarrays with sum equal to target. sum_so_far = 0 count = 0 seen_sums = set([0]) for num in arr: sum_so_far += num if (sum_so_far - target) in seen_sums: count += 1 sum_so_far = 0 seen_sums = set([0]) else: seen_sums.add(sum_so_far) return count"},{"question":"def can_form_string(s: str, t: str) -> bool: Determines if it is possible to form string t from string s by removing some characters from s and rearranging the remaining characters. Parameters: s (str): Source string t (str): Target string Returns: bool: True if t can be formed from s, False otherwise. >>> can_form_string(\\"abc\\", \\"cab\\") True >>> can_form_string(\\"abcd\\", \\"badc\\") True >>> can_form_string(\\"aabbcc\\", \\"aabbccc\\") False","solution":"def can_form_string(s, t): Determines if it is possible to form string t from string s by removing some characters from s and rearranging the remaining characters. Parameters: s (str): Source string t (str): Target string Returns: bool: True if t can be formed from s, False otherwise. from collections import Counter # Count frequency of characters in s and t s_counter = Counter(s) t_counter = Counter(t) # For each character in t, check if s has enough of it for char in t_counter: if t_counter[char] > s_counter.get(char, 0): return False return True"},{"question":"def time_diff_in_minutes(time1: str, time2: str) -> int: Returns the difference in minutes between two time strings formatted as \\"HH:MM\\". >>> time_diff_in_minutes(\\"09:00\\", \\"10:30\\") 90 >>> time_diff_in_minutes(\\"09:00\\", \\"09:15\\") 15 >>> time_diff_in_minutes(\\"13:45\\", \\"14:15\\") 30 >>> time_diff_in_minutes(\\"16:00\\", \\"17:00\\") 60 >>> time_diff_in_minutes(\\"09:00\\", \\"09:00\\") 0 >>> time_diff_in_minutes(\\"23:30\\", \\"00:30\\") -1380 def calculate_total_minutes(logTimes: List[str]) -> List[int]: Given a list of log-in/log-out times in the format [\\"HH:MM-HH:MM\\", ...], returns a list of integers representing the total minutes for each entry. >>> calculate_total_minutes([\\"09:00-10:30\\"]) [90] >>> calculate_total_minutes([\\"09:00-10:30\\", \\"13:45-14:15\\", \\"16:00-17:00\\"]) [90, 30, 60] >>> calculate_total_minutes([\\"09:00-10:00\\", \\"09:00-10:00\\"]) [60, 60] >>> calculate_total_minutes([\\"09:00-09:00\\"]) [0] >>> calculate_total_minutes([\\"23:30-00:30\\"]) [-1380]","solution":"def time_diff_in_minutes(time1, time2): Returns the difference in minutes between two time strings formatted as \\"HH:MM\\". h1, m1 = map(int, time1.split(':')) h2, m2 = map(int, time2.split(':')) return (h2 - h1) * 60 + (m2 - m1) def calculate_total_minutes(logTimes): Given a list of log-in/log-out times in the format [\\"HH:MM-HH:MM\\", ...], returns a list of integers representing the total minutes for each entry. total_minutes = [] for period in logTimes: start, end = period.split('-') minutes = time_diff_in_minutes(start, end) total_minutes.append(minutes) return total_minutes"},{"question":"def difference_and_sort(arr1: List[int], arr2: List[int]) -> List[int]: Returns a new sorted array consisting of all the elements from arr1 that are not present in arr2. >>> difference_and_sort([1, 2, 3, 4], [3, 4, 5, 6]) [1, 2] >>> difference_and_sort([1, 2, 3], [4, 5, 6]) [1, 2, 3] >>> difference_and_sort([1, 2, 3, 4], [1, 2, 3, 4]) [] >>> difference_and_sort([], [1, 2, 3]) [] >>> difference_and_sort([1, 2, 3], []) [1, 2, 3] >>> difference_and_sort([4, 1, 3, 6, 5], [2, 5, 7, 1]) [3, 4, 6] >>> difference_and_sort([1, 2, 2, 3, 4], [2, 3]) [1, 4] >>> difference_and_sort([1000000, 2000000], [999999, 2000000]) [1000000]","solution":"def difference_and_sort(arr1, arr2): Returns a new sorted array consisting of all the elements from arr1 that are not present in arr2. set_arr2 = set(arr2) # Convert arr2 to a set for O(1) lookups result = [item for item in arr1 if item not in set_arr2] return sorted(result)"},{"question":"from typing import List def max_n_non_overlapping_events(startTimes: List[int], endTimes: List[int], n: int) -> int: You are given two integer arrays \`startTimes\` and \`endTimes\`, and an integer \`n\`. An event \`i\` starts at \`startTimes[i]\` and ends at \`endTimes[i]\`. Your task is to schedule exactly \`n\` non-overlapping events from the given events. Return the maximum number of events that can be scheduled to obtain exactly \`n\` non-overlapping events or \`-1\` if it is not possible to schedule exactly \`n\` non-overlapping events. >>> max_n_non_overlapping_events([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9], 3) 3 >>> max_n_non_overlapping_events([1, 2, 3], [2, 3, 4], 4) -1 >>> max_n_non_overlapping_events([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9], 2) 2 >>> max_n_non_overlapping_events([1, 2, 3], [2, 3, 4], 1) 1 >>> max_n_non_overlapping_events([1, 3, 5, 7], [2, 4, 6, 8], 3) 3 >>> max_n_non_overlapping_events([1, 3, 2, 5], [2, 4, 3, 6], 2) 2","solution":"def max_n_non_overlapping_events(startTimes, endTimes, n): events = sorted(zip(endTimes, startTimes)) selected_events = [] current_end = -1 for end, start in events: if start >= current_end: selected_events.append((start, end)) current_end = end if len(selected_events) == n: return len(selected_events) return -1 if len(selected_events) != n else len(selected_events)"},{"question":"def unique_elements(arr): Returns a list containing only the unique elements from \`arr\` in their original order. >>> unique_elements([1, 1, 2, 2, 3, 3, 4]) [1, 2, 3, 4] >>> unique_elements([1, 2, 3, 4]) [1, 2, 3, 4] >>> unique_elements([]) [] >>> unique_elements([1, 1, 1, 1]) [1] >>> unique_elements([5, 3, 5, 2, 3, 1, 4, 2]) [5, 3, 2, 1, 4] >>> unique_elements([1, -1, 2, -1, 3, 2]) [1, -1, 2, 3] >>> unique_elements([3, 1, 3, 2]) [3, 1, 2]","solution":"def unique_elements(arr): Returns a list containing only the unique elements from \`arr\` in their original order. seen = set() result = [] for element in arr: if element not in seen: seen.add(element) result.append(element) return result"},{"question":"def min_deletions_to_uniform_substrings(s: str) -> int: Returns the minimum number of deletions required to make the string formed by concatenating one or more uniform substrings. >>> min_deletions_to_uniform_substrings(\\"aab\\") 1 >>> min_deletions_to_uniform_substrings(\\"aaaa\\") 0 >>> min_deletions_to_uniform_substrings(\\"ababab\\") 5 >>> min_deletions_to_uniform_substrings(\\"\\") 0 >>> min_deletions_to_uniform_substrings(\\"a\\") 0 >>> min_deletions_to_uniform_substrings(\\"abbbaacc\\") 3 >>> min_deletions_to_uniform_substrings(\\"abcabcabc\\") 8 >>> min_deletions_to_uniform_substrings(\\"xxxxyyyz\\") 2 >>> min_deletions_to_uniform_substrings(\\"bbbbbaaaa\\") 1","solution":"def min_deletions_to_uniform_substrings(s): Returns the minimum number of deletions required to make the string formed by concatenating one or more uniform substrings. if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] != s[i - 1]: deletions += 1 return deletions"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_neg_ones_and_concatenate(head: ListNode) -> ListNode: Remove all nodes with the value -1 from the linked list and concatenate remaining nodes. :param head: ListNode, the head of the input linked list. :return: ListNode, the head of the modified linked list. >>> linked_list = list_to_linked_list([1, 2, -1, 3, 4, -1, 5]) >>> result = remove_neg_ones_and_concatenate(linked_list) >>> linked_list_to_list(result) [1, 2, 3, 4, 5] >>> linked_list = list_to_linked_list([1, 2, 3, 4, 5]) >>> result = remove_neg_ones_and_concatenate(linked_list) >>> linked_list_to_list(result) [1, 2, 3, 4, 5] >>> linked_list = list_to_linked_list([-1, -1, -1]) >>> result = remove_neg_ones_and_concatenate(linked_list) >>> linked_list_to_list(result) [] >>> linked_list = list_to_linked_list([-1, 1, 2, -1, 3, 4, -1]) >>> result = remove_neg_ones_and_concatenate(linked_list) >>> linked_list_to_list(result) [1, 2, 3, 4] >>> linked_list = list_to_linked_list([]) >>> result = remove_neg_ones_and_concatenate(linked_list) >>> linked_list_to_list(result) [] >>> linked_list = list_to_linked_list([-1]) >>> result = remove_neg_ones_and_concatenate(linked_list) >>> linked_list_to_list(result) [] >>> linked_list = list_to_linked_list([1]) >>> result = remove_neg_ones_and_concatenate(linked_list) >>> linked_list_to_list(result) [1] def linked_list_to_list(head: ListNode) -> list: Helper function to convert linked list to Python list for easy comparison in tests. result = [] current = head while current: result.append(current.val) current = current.next return result def list_to_linked_list(lst: list) -> ListNode: Helper function to convert Python list to linked list for easy creation in tests. if not lst: return None dummy = ListNode(0) curr = dummy for val in lst: curr.next = ListNode(val) curr = curr.next return dummy.next","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_neg_ones_and_concatenate(head): Remove all nodes with the value -1 from the linked list and concatenate remaining nodes. :param head: ListNode, the head of the input linked list. :return: ListNode, the head of the modified linked list. if not head: return None dummy = ListNode(0) current_new = dummy current_original = head while current_original: if current_original.val != -1: current_new.next = ListNode(current_original.val) current_new = current_new.next current_original = current_original.next return dummy.next"},{"question":"def removeConsecutiveDuplicates(s: str) -> str: Removes consecutive duplicate characters from the string \`s\`. >>> removeConsecutiveDuplicates(\\"aaabccba\\") == \\"abcba\\" >>> removeConsecutiveDuplicates(\\"abc\\") == \\"abc\\" >>> removeConsecutiveDuplicates(\\"aaa\\") == \\"a\\" >>> removeConsecutiveDuplicates(\\"aabbcc\\") == \\"abc\\" >>> removeConsecutiveDuplicates(\\"\\") == \\"\\" >>> removeConsecutiveDuplicates(\\"a\\") == \\"a\\" >>> removeConsecutiveDuplicates(\\"abcabc\\") == \\"abcabc\\" >>> removeConsecutiveDuplicates(\\"aabbaa\\") == \\"aba\\" >>> removeConsecutiveDuplicates(\\"acbacba\\") == \\"acbacba\\"","solution":"def removeConsecutiveDuplicates(s): Removes consecutive duplicate characters from the string \`s\`. Parameters: s (str): Input string containing only characters 'a', 'b', and 'c'. Returns: str: A string after removing consecutive duplicates. if not s: return \\"\\" result = [s[0]] # Initialize the result with the first character for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result)"},{"question":"from typing import List def maxStones(grid: List[List[int]]) -> int: Returns the maximum number of stones collected by starting from (0, 0) and moving to (m-1, n-1) only moving right or down. Args: grid (List[List[int]]): A 2D list representing the grid of stones. Returns: int: The maximum number of stones that can be collected. >>> maxStones([[5]]) 5 >>> maxStones([[1, 2, 3]]) 6 >>> maxStones([[1], [2], [3]]) 6 >>> maxStones([[1, 2], [1, 1]]) 4 >>> maxStones([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> maxStones([]) == 0","solution":"def maxStones(grid): Returns the maximum number of stones collected by starting from (0, 0) and moving to (m-1, n-1) only moving right or down. Args: grid (List[List[int]]): A 2D list representing the grid of stones. Returns: int: The maximum number of stones that can be collected. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def count_ongoing_events(startTime: List[int], endTime: List[int], queryTime: int) -> int: Returns the number of events that are ongoing at the queryTime. Args: startTime (list of int): List of start times of events. endTime (list of int): List of end times of events. queryTime (int): The time of query. Returns: int: Number of ongoing events at the queryTime. >>> count_ongoing_events([1, 2, 3], [10, 10, 10], 5) 3 >>> count_ongoing_events([1, 2, 8], [2, 4, 9], 5) 0 >>> count_ongoing_events([], [], 10) 0 >>> count_ongoing_events([1, 5, 9], [3, 7, 12], 6) 1 >>> count_ongoing_events([4], [9], 6) 1 >>> count_ongoing_events([4], [5], 6) 0 >>> count_ongoing_events([5, 7], [9, 10], 5) 1 >>> count_ongoing_events([2, 8], [4, 10], 4) 1","solution":"def count_ongoing_events(startTime, endTime, queryTime): Returns the number of events that are ongoing at the queryTime. Args: startTime (list of int): List of start times of events. endTime (list of int): List of end times of events. queryTime (int): The time of query. Returns: int: Number of ongoing events at the queryTime. count = 0 for start, end in zip(startTime, endTime): if start <= queryTime <= end: count += 1 return count"},{"question":"def can_jump_over_buildings(heights: List[int], k: int) -> bool: Determines if you can jump across all buildings from left to right given the maximum jump height k. :param heights: List[int] - a list of building heights :param k: int - the maximum jump height :return: bool - True if you can jump across all buildings, False otherwise >>> can_jump_over_buildings([1, 2, 3, 4], 1) True >>> can_jump_over_buildings([1, 3, 5, 7], 2) True >>> can_jump_over_buildings([1, 3, 7, 4], 2) False >>> can_jump_over_buildings([5, 1, 5], 3) False >>> can_jump_over_buildings([2, 2, 2, 2], 0) True >>> can_jump_over_buildings([1, 1, 1, 1], 0) True >>> can_jump_over_buildings([1, 2, 1], 0) False","solution":"def can_jump_over_buildings(heights, k): Determines if you can jump across all buildings from left to right given the maximum jump height k. :param heights: List[int] - a list of building heights :param k: int - the maximum jump height :return: bool - True if you can jump across all buildings, False otherwise for i in range(1, len(heights)): if abs(heights[i] - heights[i - 1]) > k: return False return True"},{"question":"def evaluate_expression(s: str) -> int: Evaluates a given arithmetic expression string containing only non-negative integers, + (addition) and * (multiplication) operators according to the standard precedence where multiplication is performed before addition. :param s: A string representing the arithmetic expression :return: Evaluated result as an integer >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"3*2+2\\") == 8 >>> evaluate_expression(\\"3+5*2*2\\") == 23 >>> evaluate_expression(\\"10+2*6\\") == 22 >>> evaluate_expression(\\"100+200*3+2\\") == 702 >>> evaluate_expression(\\"2*3+4*5\\") == 26 >>> evaluate_expression(\\"2*3*4*5\\") == 120 >>> evaluate_expression(\\"0+0*0\\") == 0 >>> evaluate_expression(\\"1*2*3*0\\") == 0 >>> evaluate_expression(\\"1000\\") == 1000 >>> evaluate_expression(\\"100*0+999\\") == 999 >>> evaluate_expression(\\"100*0*999\\") == 0","solution":"def evaluate_expression(s): Evaluates a given arithmetic expression string containing only non-negative integers, + (addition) and * (multiplication) operators according to the standard precedence where multiplication is performed before addition. :param s: A string representing the arithmetic expression :return: Evaluated result as an integer tokens = list(s) stack = [] num = 0 pre_op = '+' while len(tokens) > 0: ch = tokens.pop(0) if ch.isdigit(): num = num * 10 + int(ch) if ch in '+*' or len(tokens) == 0: if pre_op == '+': stack.append(num) elif pre_op == '*': stack.append(stack.pop() * num) pre_op = ch num = 0 return sum(stack)"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values(root): Given the root of a binary tree, return an array of the largest value in each row of the tree. >>> largest_values(None) [] >>> largest_values(TreeNode(10)) [10] >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largest_values(root) [1, 3, 9] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> largest_values(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(1) >>> largest_values(root) [1, 1, 1]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values(root): Given the root of a binary tree, return an array of the largest value in each row of the tree. if not root: return [] queue = deque([root]) largest_vals = [] while queue: level_size = len(queue) level_max = float('-inf') for _ in range(level_size): node = queue.popleft() level_max = max(level_max, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) largest_vals.append(level_max) return largest_vals"},{"question":"def max_plants_watered(heights: List[int], wateringCans: int) -> int: Returns the maximum number of plants that can be watered given the heights of plants and the number of watering cans available. >>> max_plants_watered([1, 2, 3, 2, 1, 2, 3], 2) 6 >>> max_plants_watered([4, 5, 1, 1, 3], 1) 3","solution":"def max_plants_watered(heights, wateringCans): Returns the maximum number of plants that can be watered given the heights of plants and the number of watering cans available. n = len(heights) if n == 0 or wateringCans == 0: return 0 # Helper function to find the longest non-decreasing subsequence starting from a given index def longest_non_decreasing_from(i): length = 0 while i < n - 1 and heights[i] <= heights[i + 1]: i += 1 length += 1 return length + 1 intervals = [] # Collect all intervals of non-decreasing subsequence lengths i = 0 while i < n: length = longest_non_decreasing_from(i) intervals.append(length) i += length # Sort the intervals by lengths in descending order intervals.sort(reverse=True) # Select the longest non-decreasing intervals that can be covered by the available watering cans max_plants = sum(intervals[:wateringCans]) return max_plants"},{"question":"from typing import List def min_deletions_to_avoid_subsequences(S: str, words: List[str]) -> int: Given a string S and a list of words, determine the minimum number of character deletions required in S such that no word in words is a subsequence of the modified string S. >>> min_deletions_to_avoid_subsequences(\\"abcdef\\", [\\"xyz\\", \\"uvw\\"]) 0 >>> min_deletions_to_avoid_subsequences(\\"abcde\\", [\\"ace\\"]) 3 >>> min_deletions_to_avoid_subsequences(\\"abppplee\\", [\\"apple\\", \\"app\\"]) 5 >>> min_deletions_to_avoid_subsequences(\\"abcdeabcdabcd\\", [\\"abcd\\", \\"bce\\", \\"abcdabcd\\"]) 8 >>> min_deletions_to_avoid_subsequences(\\"abc\\", [\\"d\\", \\"e\\", \\"f\\"]) 0 >>> min_deletions_to_avoid_subsequences(\\"\\", [\\"a\\", \\"b\\"]) 0","solution":"def min_deletions_to_avoid_subsequences(S, words): def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) max_length = 0 for word in words: if is_subsequence(word, S): max_length = max(max_length, len(word)) return max_length"},{"question":"def restore_string(s: str, indices: List[int]) -> str: You are given a string \`s\` and an array of integers \`indices\` of the same length. The string \`s\` is scrambled such that the character at the \`i\`-th position moves to \`indices[i]\` in the resulting string. Construct the resulting string from the scrambled string \`s\` and the array \`indices\`. Return the reconstructed string. >>> restore_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) 'leetcode' >>> restore_string(\\"a\\", [0]) 'a' >>> restore_string(\\"dcba\\", [3, 2, 1, 0]) 'abcd' >>> restore_string(\\"abcd\\", [0, 1, 2, 3]) 'abcd' >>> restore_string(\\"hello\\", [4, 3, 2, 1, 0]) 'olleh'","solution":"def restore_string(s, indices): Restores a scrambled string s based on the given indices. Parameters: s (str): The scrambled string. indices (list): A list of integers representing the indices of the scrambled string. Returns: str: The reconstructed string. # Initialize an empty list with the same length as the string restored = [''] * len(s) # Place each character in its correct position based on the indices array for i, index in enumerate(indices): restored[index] = s[i] # Join the list into a single string and return return ''.join(restored)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def splitListToParts(head: ListNode, k: int) -> List[ListNode]: Split the linked list into k consecutive linked list parts. >>> head = list_to_linkedlist([1, 2, 3]) >>> [linkedlist_to_list(part) for part in splitListToParts(head, 3)] [[1], [2], [3]] >>> head = list_to_linkedlist([1, 2]) >>> [linkedlist_to_list(part) for part in splitListToParts(head, 5)] [[1], [2], [], [], []] >>> head = list_to_linkedlist([1, 2, 3, 4]) >>> [linkedlist_to_list(part) for part in splitListToParts(head, 3)] [[1, 2], [3], [4]] >>> head = list_to_linkedlist(list(range(1, 21))) >>> [linkedlist_to_list(part) for part in splitListToParts(head, 5)] [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16], [17, 18, 19, 20]] >>> head = list_to_linkedlist([1]) >>> [linkedlist_to_list(part) for part in splitListToParts(head, 1)] [[1]]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def splitListToParts(head, k): # Count the length of the linked list current = head length = 0 while current: length += 1 current = current.next # Determine the size of each part part_size = length // k remainder = length % k # Initialize the result array parts = [] current = head for i in range(k): part_head = current part_tail = None # Create parts of size \`part_size\` with remainder distributed for j in range(part_size + (i < remainder)): part_tail = current if current: current = current.next if part_tail: part_tail.next = None parts.append(part_head) return parts"},{"question":"def count_non_common_characters(s1: str, s2: str) -> int: Given two strings \`s1\` and \`s2\`, return the number of characters in \`s2\` that do not appear in \`s1\`. Both strings only contain lowercase English letters. >>> count_non_common_characters(\\"abc\\", \\"xyz\\") 3 >>> count_non_common_characters(\\"abc\\", \\"bcd\\") 1 >>> count_non_common_characters(\\"abc\\", \\"cab\\") 0 >>> count_non_common_characters(\\"\\", \\"abc\\") 3 >>> count_non_common_characters(\\"abc\\", \\"\\") 0 >>> count_non_common_characters(\\"\\", \\"\\") 0 >>> count_non_common_characters(\\"abc\\", \\"bbccddee\\") 4","solution":"def count_non_common_characters(s1, s2): Returns the number of characters in s2 that do not appear in s1. set_s1 = set(s1) count = 0 for char in s2: if char not in set_s1: count += 1 return count"},{"question":"import heapq from typing import List def min_time_to_complete_tasks(times: List[int], tasks: int) -> int: Returns the minimum total time required to complete all tasks. :param times: List of time taken by each server to process a single task. :param tasks: Total number of tasks that need to be completed. :return: Minimum total time to complete all tasks. >>> min_time_to_complete_tasks([1, 2, 3], 6) == 4 >>> min_time_to_complete_tasks([5], 10) == 50 >>> min_time_to_complete_tasks([2, 2, 2], 3) == 2 >>> min_time_to_complete_tasks([1, 2, 3], 0) == 0 >>> min_time_to_complete_tasks([], 5) == 0 >>> min_time_to_complete_tasks([10], 1) == 10","solution":"import heapq def min_time_to_complete_tasks(times, tasks): Returns the minimum total time required to complete all tasks. :param times: List of time taken by each server to process a single task. :param tasks: Total number of tasks that need to be completed. :return: Minimum total time to complete all tasks. if len(times) == 0 or tasks == 0: return 0 heap = [(0, time) for time in times] # (total_time, time_per_task) heapq.heapify(heap) for _ in range(tasks): total_time, time_per_task = heapq.heappop(heap) total_time += time_per_task heapq.heappush(heap, (total_time, time_per_task)) return max(heap)[0]"},{"question":"def max_sum_of_averages(nums: List[int], k: int) -> float: Return the maximum sum of the averages obtainable from any partition of the array into k contiguous subarrays. Args: nums (List[int]): The list of positive integers. k (int): The number of partitions. Returns: float: The maximum sum of averages. Examples: >>> max_sum_of_averages([10], 1) 10.0 >>> max_sum_of_averages([1, 2], 1) 1.5 >>> max_sum_of_averages([1, 2], 2) 3.0 >>> max_sum_of_averages([9, 1, 2, 3, 9], 3) 20.0 >>> max_sum_of_averages([1, 2, 3, 4, 5], 1) 3.0 >>> max_sum_of_averages([1, 2, 3, 4, 5], 5) 15.0","solution":"def max_sum_of_averages(nums, k): Returns the maximum sum of the averages of k contiguous subarrays. :param nums: List[int], list of positive integers :param k: int, number of partitions :return: float, the maximum sum of averages n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i+1] = prefix_sum[i] + nums[i] def average(i, j): return (prefix_sum[j] - prefix_sum[i]) / float(j - i) dp = [[0] * (k + 1) for _ in range(n)] for i in range(n): dp[i][1] = average(0, i + 1) for kk in range(2, k + 1): for i in range(n): for j in range(i): dp[i][kk] = max(dp[i][kk], dp[j][kk-1] + average(j + 1, i + 1)) return dp[n-1][k]"},{"question":"from typing import List, Dict def average_salary_by_department(employees: List[Dict], department_name: str) -> float: Returns the average salary of employees in the specified department. Parameters: employees (list): A list of dictionaries representing employee data. department_name (str): The name of the department. Returns: float: The average salary of the employees in the specified department, rounded to 2 decimal places. Returns 0.0 if there are no employees in the specified department. >>> employees = [{\\"id\\": 1, \\"name\\": \\"John Doe\\", \\"department\\": \\"Engineering\\", \\"salary\\": 10000}, ... {\\"id\\": 2, \\"name\\": \\"Jane Smith\\", \\"department\\": \\"Engineering\\", \\"salary\\": 12000}, ... {\\"id\\": 3, \\"name\\": \\"Alice Johnson\\", \\"department\\": \\"HR\\", \\"salary\\": 7000}, ... {\\"id\\": 4, \\"name\\": \\"Bob Brown\\", \\"department\\": \\"Finance\\", \\"salary\\": 8000}, ... {\\"id\\": 5, \\"name\\": \\"Carol White\\", \\"department\\": \\"HR\\", \\"salary\\": 7500}] >>> average_salary_by_department(employees, \\"Engineering\\") == 11000.0 True >>> average_salary_by_department(employees, \\"HR\\") == 7250.0 True >>> average_salary_by_department(employees, \\"Finance\\") == 8000.0 True >>> average_salary_by_department(employees, \\"Marketing\\") == 0.0 True >>> average_salary_by_department([], \\"Engineering\\") == 0.0 True >>> additional_employees = [{\\"id\\": 6, \\"name\\": \\"Eve Black\\", \\"department\\": \\"Engineering\\", \\"salary\\": 9500}, ... {\\"id\\": 7, \\"name\\": \\"Ted Green\\", \\"department\\": \\"HR\\", \\"salary\\": 7200}] >>> all_employees = employees + additional_employees >>> average_salary_by_department(all_employees, \\"Engineering\\") == 10500.0 True >>> average_salary_by_department(all_employees, \\"HR\\") == 7233.33 True","solution":"def average_salary_by_department(employees, department_name): Returns the average salary of employees in the specified department. Parameters: employees (list): A list of dictionaries representing employee data. department_name (str): The name of the department. Returns: float: The average salary of the employees in the specified department, rounded to 2 decimal places. Returns 0.0 if there are no employees in the specified department. total_salary = 0 count = 0 for employee in employees: if employee['department'] == department_name: total_salary += employee['salary'] count += 1 if count == 0: return 0.0 return round(total_salary / count, 2) # Example employee data employees = [ {\\"id\\": 1, \\"name\\": \\"John Doe\\", \\"department\\": \\"Engineering\\", \\"salary\\": 10000}, {\\"id\\": 2, \\"name\\": \\"Jane Smith\\", \\"department\\": \\"Engineering\\", \\"salary\\": 12000}, {\\"id\\": 3, \\"name\\": \\"Alice Johnson\\", \\"department\\": \\"HR\\", \\"salary\\": 7000}, {\\"id\\": 4, \\"name\\": \\"Bob Brown\\", \\"department\\": \\"Finance\\", \\"salary\\": 8000} ] # Example usage print(average_salary_by_department(employees, \\"Engineering\\")) # Output: 11000.0"},{"question":"def find_nodes_with_no_incoming_edges(n: int, edges: List[List[int]]) -> List[int]: Returns an array of integers representing all nodes that have no incoming edges. >>> find_nodes_with_no_incoming_edges(6, [[0,1],[0,2],[2,3],[3,4],[4,5]]) [0] >>> find_nodes_with_no_incoming_edges(4, [[1,2], [2,3], [3,1]]) [0] >>> find_nodes_with_no_incoming_edges(5, [[0, 1], [2, 1], [3, 1], [4, 2]]) [0, 3, 4] >>> find_nodes_with_no_incoming_edges(3, [[1, 0], [2, 0], [1, 2]]) [1] >>> find_nodes_with_no_incoming_edges(3, []) [0, 1, 2]","solution":"def find_nodes_with_no_incoming_edges(n, edges): Returns a list of all nodes that have no incoming edges in the graph. # Initialize a list to keep track of the in-degree of each node in_degree = [0] * n # Calculate the in-degree for each node for edge in edges: in_degree[edge[1]] += 1 # Find all nodes with in-degree of 0 no_incoming_edges_nodes = [i for i in range(n) if in_degree[i] == 0] return no_incoming_edges_nodes"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def right_view(root): Return the right view of the binary tree. >>> # Tree: >>> # 1 >>> # / >>> # 2 3 >>> # / >>> # 5 4 6 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(6) >>> right_view(root) [1, 3, 6]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def right_view(root): if not root: return [] from collections import deque right_side = [] queue = deque([(root, 0)]) # store tuple of (node, level) while queue: node, level = queue.popleft() if level == len(right_side): right_side.append(node.val) else: right_side[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return right_side"},{"question":"def non_decreasing_sequence_exists(nums: List[int], k: int) -> bool: Determines if there exists a non-decreasing sequence of length k within the nums list. Parameters: nums (List[int]): List of non-negative integers each representing a single-digit number. k (int): Required length of the non-decreasing sequence. Returns: bool: True if there exists a non-decreasing sequence of length k, otherwise False. Examples: >>> non_decreasing_sequence_exists([1, 3, 2, 4, 5], 3) True >>> non_decreasing_sequence_exists([5, 4, 3, 2, 1], 2) False pass # Your implementation here","solution":"def non_decreasing_sequence_exists(nums, k): Determines if there exists a non-decreasing sequence of length k within the nums list. Parameters: nums (list of int): List of non-negative integers each representing a single-digit number. k (int): Required length of the non-decreasing sequence. Returns: bool: True if there exists a non-decreasing sequence of length k, otherwise False. if k <= 0: return True n = len(nums) if n < k: return False increasing_sequence = [1] * n # Initialize with 1, as each number is a non-decreasing sequence of length 1 # Traverse the list from the end to the start for i in range(n - 2, -1, -1): for j in range(i + 1, n): if nums[i] <= nums[j]: increasing_sequence[i] = max(increasing_sequence[i], 1 + increasing_sequence[j]) if increasing_sequence[i] >= k: # Early return if we already found sequence of length k return True return max(increasing_sequence) >= k"},{"question":"def schedule_jobs(jobs: List[Tuple[int, int, int]]) -> List[int]: Schedules jobs based on their priority and returns the order of job_ids. Parameters: jobs (list of tuples): A list where each tuple represents a job in the form (job_id, priority, execution_time) Returns: list: A list of job_ids ordered by their priority (higher to lower). If two jobs have the same priority, they maintain their input order. >>> schedule_jobs([(1, 5, 1000)]) == [1] >>> schedule_jobs([(1, 5, 1000), (2, 9, 500), (3, 3, 700)]) == [2, 1, 3] >>> schedule_jobs([(1, 8, 1000), (2, 8, 500), (3, 10, 700), (4, 6, 300)]) == [3, 1, 2, 4] >>> schedule_jobs([(1, 5, 1000), (2, 5, 500), (3, 5, 700)]) == [1, 2, 3] >>> schedule_jobs([(1, 3, 1000), (2, 1, 500), (3, 3, 700), (4, 2, 400), (5, 4, 600)]) == [5, 1, 3, 4, 2]","solution":"def schedule_jobs(jobs): Schedules jobs based on their priority and returns the order of job_ids. Parameters: jobs (list of tuples): A list where each tuple represents a job in the form (job_id, priority, execution_time) Returns: list: A list of job_ids ordered by their priority (higher to lower). If two jobs have the same priority, they maintain their input order. # Sort the jobs by priority (higher to lower), if same priority keep original order sorted_jobs = sorted(jobs, key=lambda job: -job[1]) # Extract the job_ids from the sorted jobs scheduled_order = [job[0] for job in sorted_jobs] return scheduled_order"},{"question":"def can_be_palindrome_by_one_insertion(s: str) -> str: Determines if a string can be made a palindrome with at most one insertion. >>> can_be_palindrome_by_one_insertion(\\"aba\\") == \\"YES\\" >>> can_be_palindrome_by_one_insertion(\\"abca\\") == \\"YES\\" >>> can_be_palindrome_by_one_insertion(\\"abc\\") == \\"NO\\" >>> can_be_palindrome_by_one_insertion(\\"\\") == \\"YES\\" >>> can_be_palindrome_by_one_insertion(\\"abcdefgh\\") == \\"NO\\"","solution":"def can_be_palindrome_by_one_insertion(s): Determines if a string can be made a palindrome with at most one insertion. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it can be made a palindrome with at most one insertion, otherwise \\"NO\\". def is_palindrome(substring): return substring == substring[::-1] l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: # Check by inserting character to make either side palindrome if is_palindrome(s[l:r]) or is_palindrome(s[l+1:r+1]): return \\"YES\\" else: return \\"NO\\" l += 1 r -= 1 return \\"YES\\" # If the original string is already a palindrome"},{"question":"def unique_morse_representations(words: List[str]) -> int: Given a list of words, return the number of unique Morse code representations of each word. >>> unique_morse_representations([\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"]) 2 >>> unique_morse_representations([\\"a\\", \\"z\\", \\"g\\", \\"m\\"]) 4 >>> unique_morse_representations([\\"a\\"]) 1 >>> unique_morse_representations([\\"a\\", \\"a\\", \\"a\\"]) 1 >>> unique_morse_representations([\\"gin\\", \\"gin\\"]) 1 >>> unique_morse_representations([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\", \\"h\\", \\"i\\", \\"j\\", \\"k\\", \\"l\\", \\"m\\", \\"n\\", \\"o\\", \\"p\\", \\"q\\", \\"r\\", \\"s\\", \\"t\\", \\"u\\", \\"v\\", \\"w\\", \\"x\\", \\"y\\", \\"z\\"]) 26 >>> unique_morse_representations([\\"a\\"] * 100) 1","solution":"def unique_morse_representations(words): Returns the number of unique Morse code representations of the given list of words. morse_codes = [\\".-\\",\\"-...\\",\\"-.-.\\",\\"-..\\",\\".\\",\\"..-.\\",\\"--.\\",\\"....\\",\\"..\\",\\".---\\",\\"-.-\\",\\".-..\\",\\"--\\",\\"-.\\",\\"---\\",\\".--.\\",\\"--.-\\",\\".-.\\",\\"...\\",\\"-\\",\\"..-\\",\\"...-\\",\\".--\\",\\"-..-\\",\\"-.--\\",\\"--..\\"] morse_dict = {chr(i + ord('a')): morse_codes[i] for i in range(26)} unique_representations = set() for word in words: morse_word = ''.join(morse_dict[letter] for letter in word) unique_representations.add(morse_word) return len(unique_representations)"},{"question":"def max_coins(grid): Returns the maximum number of coins collected from the top-left to the bottom-right of a 2D grid. You can only move to the right or down from your current position. # Test cases def test_max_coins_example(): grid = [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] assert max_coins(grid) == 12 def test_max_coins_empty_grid(): grid = [] assert max_coins(grid) == 0 def test_max_coins_single_row(): grid = [ [2, 4, 1] ] assert max_coins(grid) == 7 def test_max_coins_single_column(): grid = [ [2], [3], [4] ] assert max_coins(grid) == 9 def test_max_coins_all_zeros(): grid = [ [0, 0, 0], [0, 0, 0] ] assert max_coins(grid) == 0 def test_max_coins_varying_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_coins(grid) == 29","solution":"def max_coins(grid): Returns the maximum number of coins collected from the top-left to the bottom-right of a 2D grid. You can only move to the right or down from your current position. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def three_sum(nums, k): Determines if there exist three distinct elements in \`nums\` that sum up to \`k\`. Args: nums : list of integers k : integer Returns: bool: True if there exist three distinct elements that sum up to \`k\`, otherwise False. >>> three_sum([1, 4, 5, 6, 7], 15) = True >>> three_sum([-1, 2, -3, 4, 6], 3) = True >>> three_sum([1, 2, 4, 5], 15) = False >>> three_sum([], 5) = False >>> three_sum([5], 5) = False >>> three_sum([1, 2], 3) = False >>> three_sum([1, 1, 1, 2, 2, 2, 3, 3, 3], 6) = True # Your code here","solution":"def three_sum(nums, k): Determines if there exist three distinct elements in \`nums\` that sum up to \`k\`. Args: nums : list of integers k : integer Returns: bool: True if there exist three distinct elements that sum up to \`k\`, otherwise False. nums.sort() for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"def visible_trees(heights): Returns the array of heights of trees which are visible. A tree is considered visible if it is not shorter than any of the previous trees from left to right. >>> visible_trees([2, 3, 1, 4, 2, 5]) [2, 3, 4, 5] >>> visible_trees([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> visible_trees([5, 4, 3, 2, 1]) [5] >>> visible_trees([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [3, 4, 5, 9] >>> visible_trees([10]) [10] >>> visible_trees([]) []","solution":"def visible_trees(heights): Returns the array of heights of trees which are visible. A tree is considered visible if it is not shorter than any of the previous trees from left to right. visible = [] max_height = float('-inf') for height in heights: if height >= max_height: visible.append(height) max_height = height return visible"},{"question":"from typing import List def maxEnvelopes(arr: List[List[int]]) -> int: Determine the maximum number of envelopes you can fit one inside the other. :param arr: List of [width, height] lists, representing envelope sizes. :return: Maximum number of envelopes you can fit one inside the other. pass def test_example_case(): arr = [[5,4],[6,4],[6,7],[2,3]] assert maxEnvelopes(arr) == 3 def test_no_envelope(): arr = [] assert maxEnvelopes(arr) == 0 def test_single_envelope(): arr = [[1, 1]] assert maxEnvelopes(arr) == 1 def test_identical_envelopes(): arr = [[2,3],[2,3],[2,3]] assert maxEnvelopes(arr) == 1 def test_all_fit(): arr = [[1,1], [2,2], [3,3], [4,4]] assert maxEnvelopes(arr) == 4 def test_non_fitting(): arr = [[2, 3], [5, 4], [6, 7], [8, 6], [6, 9], [3, 10]] assert maxEnvelopes(arr) == 3 def test_envelopes_with_same_width(): arr = [[1, 2], [1, 3], [1, 4], [1, 5]] assert maxEnvelopes(arr) == 1","solution":"def maxEnvelopes(arr): Determine the maximum number of envelopes you can fit one inside the other. :param arr: List of [width, height] lists, representing envelope sizes. :return: Maximum number of envelopes you can fit one inside the other. if not arr: return 0 # Sort envelopes by width, and by height in descending order if widths are the same arr.sort(key=lambda x: (x[0], -x[1])) # Function to find the length of LIS (Longest Increasing Subsequence) def LIS(nums): from bisect import bisect_left sub = [] for x in nums: pos = bisect_left(sub, x) if pos == len(sub): sub.append(x) else: sub[pos] = x return len(sub) # Extract heights and find the length of LIS in heights heights = [h for w, h in arr] return LIS(heights)"},{"question":"def longest_subarray_with_m_distinct(nums: List[int], m: int) -> int: Finds the length of the longest subarray that contains at most m distinct elements. Parameters: nums (list): A list of integers. m (int): The number of distinct elements allowed in a subarray. Returns: int: The length of the longest subarray with at most m distinct elements. >>> longest_subarray_with_m_distinct([1, 2, 3, 4], 0) 0 >>> longest_subarray_with_m_distinct([1, 2, 3, 4], 4) 4 >>> longest_subarray_with_m_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_m_distinct([1, 2, 2, 1, 3], 3) 5 >>> longest_subarray_with_m_distinct([5, 5, 5, 5], 1) 4 >>> longest_subarray_with_m_distinct([5, 1, 2, 3, 4], 1) 1 >>> longest_subarray_with_m_distinct([5, 1, 2, 3, 4], 0) 0","solution":"def longest_subarray_with_m_distinct(nums, m): Finds the length of the longest subarray that contains at most m distinct elements. Parameters: nums (list): A list of integers. m (int): The number of distinct elements allowed in a subarray. Returns: int: The length of the longest subarray with at most m distinct elements. from collections import defaultdict n = len(nums) if m >= len(set(nums)): return n freq = defaultdict(int) left = 0 max_len = 0 distinct_count = 0 for right in range(n): if freq[nums[right]] == 0: distinct_count += 1 freq[nums[right]] += 1 while distinct_count > m: freq[nums[left]] -= 1 if freq[nums[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root: TreeNode, target: float) -> int: Given a binary search tree and a target value, returns the value in the BST that is closest to the target. If there are multiple values in the BST that are equally close to the target, returns the smaller value. >>> root = TreeNode(4) >>> root.left = TreeNode(2, TreeNode(1), TreeNode(3)) >>> root.right = TreeNode(6, TreeNode(5), TreeNode(7)) >>> closest_value(root, 3.7) 4 >>> closest_value(root, 5.2) 5 >>> closest_value(root, 4.5) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root: TreeNode, target: float) -> int: Given a binary search tree and a target value, returns the value in the BST that is closest to the target. If there are multiple values in the BST that are equally close to the target, returns the smaller value. closest = root.val while root: if abs(root.val - target) < abs(closest - target) or (abs(root.val - target) == abs(closest - target) and root.val < closest): closest = root.val if target < root.val: root = root.left else: root = root.right return closest"},{"question":"def max_plants_collected(heights: List[int], d: int) -> int: Returns the maximum number of plants that can be collected starting from any plant with jumps strictly to higher plants within a distance d. :param heights: List of integers representing the height of plants. :param d: Integer representing the maximum distance of each jump. :return: Integer representing the maximum number of plants that can be collected in one sequence of jumps. pass # Unit Tests def test_max_plants_collected_simple(): assert max_plants_collected([1, 2, 3, 4], 2) == 4 def test_max_plants_collected_no_possible_jumps(): assert max_plants_collected([4, 4, 4, 4], 1) == 1 def test_max_plants_collected_varying_heights(): assert max_plants_collected([3, 1, 3, 1, 3], 2) == 2 def test_max_plants_collected_large_jump_distance(): assert max_plants_collected([1, 3, 2, 5, 4], 10) == 4 def test_max_plants_collected_zigzag_heights(): assert max_plants_collected([2, 1, 4, 1, 5, 3, 2, 6], 3) == 4","solution":"def max_plants_collected(heights, d): Returns the maximum number of plants that can be collected starting from any plant with jumps strictly to higher plants within a distance d. :param heights: List of integers representing the height of plants. :param d: Integer representing the maximum distance of each jump. :return: Integer representing the maximum number of plants that can be collected in one sequence of jumps. n = len(heights) # Memoization list to store the max jumps starting from each plant dp = [0] * n def dfs(i): if dp[i] != 0: return dp[i] max_collect = 1 for direction in [-1, 1]: # -1 for left, 1 for right for j in range(1, d+1): ni = i + direction * j if 0 <= ni < n and heights[ni] > heights[i]: max_collect = max(max_collect, 1 + dfs(ni)) elif 0 <= ni < n and heights[ni] <= heights[i]: break dp[i] = max_collect return max_collect max_plants = 0 for i in range(n): max_plants = max(max_plants, dfs(i)) return max_plants"},{"question":"def total_shadow_length(heights: List[int]) -> int: Determine the total length of the shadow cast by the buildings. >>> total_shadow_length([3]) 1 >>> total_shadow_length([2, 2, 2, 2]) 1 >>> total_shadow_length([1, 2, 3, 4]) 4 >>> total_shadow_length([4, 3, 2, 1]) 1 >>> total_shadow_length([3, 1, 4, 2, 5]) 3 >>> total_shadow_length([]) 0 >>> total_shadow_length([2, 3, 1, 5, 4, 6, 3, 8, 2]) 5","solution":"def total_shadow_length(heights): Returns the total length of the shadow cast by the buildings. if not heights: return 0 total_length = 1 max_height = heights[0] for i in range(1, len(heights)): if heights[i] > max_height: total_length += 1 max_height = heights[i] return total_length"},{"question":"def minimal_votes_to_win(nums: List[int], k: int) -> int: Returns the minimal number of votes required for a candidate to guarantee winning at least one seat. If it's impossible for any candidate to guarantee a win, returns -1. >>> minimal_votes_to_win([5, 1, 3, 8, 7], 1) == 9 >>> minimal_votes_to_win([5, 1, 3, 8, 7], 2) == 8 >>> minimal_votes_to_win([5, 1, 3, 8, 7], 3) == 6 >>> minimal_votes_to_win([10, 20, 15, 5, 1], 6) == -1 >>> minimal_votes_to_win([], 1) == -1 >>> minimal_votes_to_win([4, 3, 2], 0) == -1 >>> minimal_votes_to_win([], 0) == -1 >>> minimal_votes_to_win([10, 20, 30], -1) == -1 >>> minimal_votes_to_win([1], 1) == 2 >>> minimal_votes_to_win([1, 2, 3], 2) == 3 >>> minimal_votes_to_win([1, 1, 1, 1, 1], 3) == 2 >>> minimal_votes_to_win([50], 1) == 51 >>> minimal_votes_to_win([50], 2) == -1","solution":"def minimal_votes_to_win(nums, k): Returns the minimal number of votes required for a candidate to guarantee winning at least one seat. If it's impossible for any candidate to guarantee a win, returns -1. if k <= 0 or not nums: return -1 sorted_votes = sorted(nums, reverse=True) # When there are more candidates than the number of seats if k > len(nums): return -1 # The candidate needs more votes than the number of votes of the k-th candidate return sorted_votes[k-1] + 1 if k <= len(nums) else -1"},{"question":"def largest_rectangle_area(nums: List[int]) -> int: Finds the area of the largest rectangle in the histogram represented by the list of integers 'nums'. :param nums: List of integers representing the histogram's heights. :return: The area of the largest rectangle. >>> largest_rectangle_area([2,1,5,6,2,3]) == 10 >>> largest_rectangle_area([2,4]) == 4 >>> largest_rectangle_area([6,2,5,4,5,1,6]) == 12 >>> largest_rectangle_area([1,1,1,1]) == 4 >>> largest_rectangle_area([0,1,0,1,0,1]) == 1 >>> largest_rectangle_area([2,1,2]) == 3 # Edge cases >>> largest_rectangle_area([]) == 0 >>> largest_rectangle_area([0]) == 0 >>> largest_rectangle_area([1]) == 1 >>> largest_rectangle_area([10, 10, 10, 10]) == 40","solution":"def largest_rectangle_area(nums): Finds the area of the largest rectangle in the histogram represented by the list of integers 'nums'. :param nums: List of integers representing the histogram's heights. :return: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(nums): if not stack or nums[index] >= nums[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxSumLongestPath(root: TreeNode) -> int: Returns the maximum sum of the values of all nodes on the longest path from the root to a leaf. Parameters: root (TreeNode): The root node of the binary tree. Returns: int: The maximum sum of the values of all nodes on the longest path from the root to a leaf. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(4) >>> root.right = TreeNode(3) >>> root.right.right = TreeNode(5) >>> root.right.right.right = TreeNode(6) >>> maxSumLongestPath(root) 15","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxSumLongestPath(root): Returns the maximum sum of the values of all nodes on the longest path from the root to a leaf. def dfs(node): if not node: return (0, 0) # (max_sum, max_length) left_sum, left_length = dfs(node.left) right_sum, right_length = dfs(node.right) if left_length > right_length: return (left_sum + node.val, left_length + 1) elif right_length > left_length: return (right_sum + node.val, right_length + 1) else: # left_length == right_length return (max(left_sum, right_sum) + node.val, left_length + 1) # Start the dfs from the root max_sum, _ = dfs(root) return max_sum"},{"question":"from typing import List def maximalSquare(matrix: List[List[str]]) -> int: Determine the size of the largest square containing only 1s and return its area. >>> maximalSquare([ ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\"] ... ]) 4 >>> maximalSquare([ ... [\\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\"] ... ]) 0 >>> maximalSquare([ ... [\\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\"] ... ]) 4 >>> maximalSquare([ ... [\\"1\\"], ... [\\"1\\"], ... [\\"1\\"], ... [\\"1\\"] ... ]) 1","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i - 1][j - 1] == '1': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_leaves(root): Given a binary tree, return a list of the leaf nodes in the tree ordered from left to right. A leaf node is a node that has no children. If the tree is empty, return an empty list. Example: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> find_leaves(root) [9, 15, 7] pass # Unit Test def test_find_leaves(): # Test case 1: Tree with multiple leaves root1 = TreeNode(3) root1.left = TreeNode(9) root1.right = TreeNode(20) root1.right.left = TreeNode(15) root1.right.right = TreeNode(7) assert find_leaves(root1) == [9, 15, 7] # Test case 2: Tree with single node root2 = TreeNode(1) assert find_leaves(root2) == [1] # Test case 3: Empty tree assert find_leaves(None) == [] # Test case 4: Tree with right nodes only root3 = TreeNode(1) root3.right = TreeNode(2) root3.right.right = TreeNode(3) assert find_leaves(root3) == [3] # Test case 5: Tree with left nodes only root4 = TreeNode(1) root4.left = TreeNode(2) root4.left.left = TreeNode(4) root4.left.right = TreeNode(5) assert find_leaves(root4) == [4, 5] # Helper function to create the following tree for use in additional test cases: # Tree Structure: # 1 # / # 2 3 # / # 4 5 6 def add_tree_to_test_collection(): root5 = TreeNode(1) root5.left = TreeNode(2) root5.right = TreeNode(3) root5.left.left = TreeNode(4) root5.left.right = TreeNode(5) root5.right.right = TreeNode(6) return root5 def test_additional_cases(): root5 = add_tree_to_test_collection() assert find_leaves(root5) == [4, 5, 6] test_find_leaves() test_additional_cases()","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_leaves(root): Returns a list of the leaf nodes in the binary tree ordered from left to right. if not root: return [] leaves = [] def dfs(node): if not node: return if not node.left and not node.right: leaves.append(node.val) dfs(node.left) dfs(node.right) dfs(root) return leaves"},{"question":"import heapq from typing import List class UpdateManager: You are managing a device that can perform multiple software updates. Each update operation can take place in a certain interval of time. Given a series of update operations represented by intervals [start, end), determine the minimum number of separate intervals needed such that no two updates overlap in any given interval. def __init__(self): pass def minUpdatesRequired(self, starts: List[int], ends: List[int]) -> int: Takes in two arrays, starts and ends, which represent the starting and ending times of the update operations. Returns an integer representing the minimum number of separate intervals required to accommodate all the updates without any overlap. >>> manager = UpdateManager() >>> manager.minUpdatesRequired([1, 2, 3, 4], [2, 3, 4, 5]) 1 >>> manager.minUpdatesRequired([1, 3, 5], [2, 4, 6]) 1 >>> manager.minUpdatesRequired([1, 2, 3, 4], [3, 3, 4, 5]) 2 >>> manager.minUpdatesRequired([1, 1.5, 1.2, 1.1], [2, 2.5, 3, 3.5]) 4 >>> manager.minUpdatesRequired([], []) 0 >>> manager.minUpdatesRequired([0], [1]) 1 pass def test_minUpdatesRequired_example(): manager = UpdateManager() starts = [1, 2, 3, 4] ends = [2, 3, 4, 5] assert manager.minUpdatesRequired(starts, ends) == 1 def test_minUpdatesRequired_no_overlap(): manager = UpdateManager() starts = [1, 3, 5] ends = [2, 4, 6] assert manager.minUpdatesRequired(starts, ends) == 1 def test_minUpdatesRequired_some_overlap(): manager = UpdateManager() starts = [1, 2, 3, 4] ends = [3, 3, 4, 5] assert manager.minUpdatesRequired(starts, ends) == 2 def test_minUpdatesRequired_all_overlap(): manager = UpdateManager() starts = [1, 1.5, 1.2, 1.1] ends = [2, 2.5, 3, 3.5] assert manager.minUpdatesRequired(starts, ends) == 4 def test_minUpdatesRequired_empty(): manager = UpdateManager() assert manager.minUpdatesRequired([], []) == 0 def test_minUpdatesRequired_single_interval(): manager = UpdateManager() starts = [0] ends = [1] assert manager.minUpdatesRequired(starts, ends) == 1","solution":"import heapq class UpdateManager: def __init__(self): pass def minUpdatesRequired(self, starts, ends): if not starts or not ends or len(starts) != len(ends): return 0 intervals = sorted(zip(starts, ends), key=lambda x: x[0]) heap = [] for start, end in intervals: if heap and heap[0] <= start: heapq.heapreplace(heap, end) else: heapq.heappush(heap, end) return len(heap)"},{"question":"class FileSystem: Implement a file system that supports the following operations: * \`createPath(String path, int value)\` - Creates a new path and associates a value with it if it does not already exist. If the path already exists or its parent path does not exist, return \`false\`, otherwise return \`true\`. * \`get(String path)\` - Returns the value associated with the path, or \`-1\` if the path does not exist. The format of a valid path is one or more concatenations of the form: \`/\` followed by one or more lowercase English letters. >>> fs = FileSystem() >>> fs.createPath(\\"/a\\", 1) == True >>> fs.get(\\"/a\\") == 1 >>> fs.createPath(\\"/a/b\\", 2) == True >>> fs.get(\\"/a/b\\") == 2 >>> fs.createPath(\\"/c/d\\", 1) == False >>> fs.get(\\"/c\\") == -1 >>> fs.createPath(\\"/a\\", 1) == True >>> fs.createPath(\\"/a\\", 2) == False >>> fs.get(\\"/nonexistent\\") == -1 def __init__(self): self.paths = {'': -1} def createPath(self, path: str, value: int) -> bool: pass def get(self, path: str) -> int: pass","solution":"class FileSystem: def __init__(self): self.paths = {'': -1} def createPath(self, path: str, value: int) -> bool: if not path or path[0] != '/' or path in self.paths: return False parent = path.rfind('/') parent_path = path[:parent] if parent_path not in self.paths: return False self.paths[path] = value return True def get(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"from typing import List def get_maximum_gold(grid: List[List[int]]) -> int: Find the maximum amount of gold that can be collected in the grid. >>> get_maximum_gold([[10]]) 10 >>> get_maximum_gold([[1, 2, 3]]) 6 >>> get_maximum_gold([[1], [2], [3]]) 6 >>> get_maximum_gold([[1, 2], [3, 4]]) 10 >>> get_maximum_gold([[0, 6, 0], [5, 8, 7], [0, 9, 0]]) 24 >>> get_maximum_gold([[1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0]]) 28 >>> get_maximum_gold([]) 0 >>> get_maximum_gold([[0, 0], [0, 0]]) 0 pass","solution":"from typing import List def get_maximum_gold(grid: List[List[int]]) -> int: Finds the maximum amount of gold that can be collected in the grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) max_gold = 0 def dfs(r, c, current_gold): nonlocal max_gold if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return current_gold += grid[r][c] max_gold = max(max_gold, current_gold) # Temporarily mark the cell as visited temp = grid[r][c] grid[r][c] = 0 # Explore adjacent cells dfs(r + 1, c, current_gold) dfs(r - 1, c, current_gold) dfs(r, c + 1, current_gold) dfs(r, c - 1, current_gold) # Backtrack and restore the cell's value grid[r][c] = temp for i in range(rows): for j in range(cols): if grid[i][j] != 0: dfs(i, j, 0) return max_gold"},{"question":"def remove_duplicates(nums): Removes duplicates in-place such that each unique element appears only once. Returns the number of unique elements. Parameters: nums (List[int]): A list of integers sorted in non-decreasing order. Returns: int: The number of unique elements in the list after removing duplicates. >>> remove_duplicates([1, 1, 2]) 2 >>> remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]) 5 >>> remove_duplicates([]) 0 >>> remove_duplicates([1, 2, 3, 4, 5]) 5 >>> remove_duplicates([1, 1, 1, 1, 1]) 1 >>> remove_duplicates([1, 2, 2, 3, 3, 4, 5, 5, 5, 6, 7, 7]) 7","solution":"def remove_duplicates(nums): Removes duplicates in-place such that each unique element appears only once. Returns the number of unique elements. Parameters: nums (List[int]): A list of integers sorted in non-decreasing order. Returns: int: The number of unique elements in the list after removing duplicates. if not nums: return 0 unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] return unique_index + 1"},{"question":"def minTime(nums: List[int], n: int) -> int: Given an integer array 'nums' representing the amount of data that needs to be processed and an integer 'n' representing the number of available processors, return the minimum total completion time required if the processors can work in parallel. Each processor can handle a contiguous segment of the array. The completion time for a processor is defined as the sum of the processing times of the assigned segment. >>> minTime([10, 20, 30], 1) == 60 >>> minTime([1, 2, 3, 4, 5], 5) == 5 >>> minTime([7, 2, 5, 10, 8], 2) == 18 >>> minTime([1] * 1000, 500) == 2 >>> minTime([1, 2, 3, 1000], 2) == 1000","solution":"def minTime(nums, n): def canDistribute(nums, n, maxTime): total, count = 0, 1 for num in nums: total += num if total > maxTime: total = num count += 1 if count > n: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canDistribute(nums, n, mid): right = mid else: left = mid + 1 return left"},{"question":"def is_transformable(nums: List[int], k: int) -> bool: Determines if the array nums can be transformed to an array of all zeros using the specified operation. :param nums: List of integers :param k: Length of subarray to consider :return: Boolean indicating if the array can be transformed >>> is_transformable([0, 0, 0], 2) == True >>> is_transformable([1, 1, 1], 1) == False >>> is_transformable([0, 0, 0, 0], 2) == True >>> is_transformable([1, 2, 3, 0], 4) == False >>> is_transformable([0, 3, 3, 0], 2) == False >>> is_transformable([0, 0, 0], 3) == True >>> is_transformable([1, 2, 3, 0], 3) == False >>> is_transformable([0, 0, 0], 1) == True >>> is_transformable([0, 2, 0], 2) == False >>> is_transformable([5, 5, 5, 5, 5], 5) == False >>> is_transformable([0], 1) == True >>> is_transformable([1], 1) == False >>> is_transformable([2], 1) == False","solution":"def is_transformable(nums, k): Determines if the array nums can be transformed to an array of all zeros using the specified operation. :param nums: List of integers :param k: Length of subarray to consider :return: Boolean indicating if the array can be transformed if k <= 0: return False # k must be a positive number n = len(nums) if k == 1: return all(num == 0 for num in nums) min_value = min(nums) # Check if the array can be \\"flattened\\" to all elements being the minimum value for i in range(n - k + 1): subarray = nums[i:i + k] if len(set(subarray)) != 1: return False return min_value == 0"},{"question":"def count_visible_buildings(heights): Counts the number of visible buildings in a skyline view from the left most position. Args: heights (list): List of integers representing the heights of buildings. Returns: int: Number of visible buildings. Examples: >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([5, 4, 3, 2, 1]) 1 >>> count_visible_buildings([3, 3, 3, 3]) 1 >>> count_visible_buildings([1, 3, 2, 4, 2, 5]) 4 >>> count_visible_buildings([7]) 1 >>> count_visible_buildings([]) 0 >>> count_visible_buildings([2, 4, 2, 5, 2, 6]) 4 >>> count_visible_buildings([2, 2, 2, 2]) 1","solution":"def count_visible_buildings(heights): Counts the number of visible buildings in a skyline view from the left most position. Args: heights (list): List of integers representing the heights of buildings. Returns: int: Number of visible buildings. if not heights: return 0 visible_count = 0 max_height_so_far = 0 for height in heights: if height > max_height_so_far: visible_count += 1 max_height_so_far = height return visible_count"},{"question":"def longest_substring_two_distinct(str: str) -> str: Returns the longest substring that contains at most two distinct characters. >>> longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") == \\"bcbbbbcccb\\" >>> longest_substring_two_distinct(\\"aaaaa\\") == \\"aaaaa\\" >>> longest_substring_two_distinct(\\"abababababab\\") == \\"abababababab\\" >>> longest_substring_two_distinct(\\"eceba\\") == \\"ece\\" >>> longest_substring_two_distinct(\\"\\") == \\"\\" >>> longest_substring_two_distinct(\\"a\\") == \\"a\\" >>> longest_substring_two_distinct(\\"aa\\") == \\"aa\\" >>> longest_substring_two_distinct(\\"abac\\") == \\"aba\\" >>> longest_substring_two_distinct(\\"abcdefg\\") == \\"ab\\"","solution":"def longest_substring_two_distinct(str): Returns the longest substring that contains at most two distinct characters. If there are multiple substrings with the same length, returns the one that appears first. max_len = 0 max_substr = \\"\\" window_start = 0 char_map = {} for window_end in range(len(str)): current_char = str[window_end] if current_char not in char_map: char_map[current_char] = 0 char_map[current_char] += 1 while len(char_map) > 2: left_char = str[window_start] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] window_start += 1 current_length = window_end - window_start + 1 if current_length > max_len: max_len = current_length max_substr = str[window_start:window_end+1] return max_substr"},{"question":"def max_positions_occupied(heights: List[int], maxDifference: int) -> int: Return the maximum number of positions from the original list that can remain occupied in a valid permutation. Args: heights (List[int]): A list of integers representing the heights of students. maxDifference (int): The maximum allowed difference in height between any two adjacent students. Returns: int: The maximum number of positions that can remain occupied, -1 if no positions can remain occupied. Examples: >>> max_positions_occupied([1, 2, 3, 6], 2) 3 >>> max_positions_occupied([1, 3, 5, 7], 1) 1 >>> max_positions_occupied([2, 3, 6, 7, 8], 2) 3 >>> max_positions_occupied([4], 1) 1 >>> max_positions_occupied([], 3) -1 >>> max_positions_occupied([4, 4, 4, 4], 0) 4 >>> max_positions_occupied([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) 10","solution":"def max_positions_occupied(heights, maxDifference): # Calculate the number of students n = len(heights) if n == 0: return -1 # No students to place max_positions = 0 current_pos = 0 while current_pos < n: count = 1 # The first student in the contiguous sequence while current_pos + count < n and heights[current_pos + count] - heights[current_pos + count - 1] <= maxDifference: count += 1 max_positions = max(max_positions, count) current_pos += count return max_positions if max_positions > 0 else -1"},{"question":"import heapq from typing import List def findKthLargest(nums: List[int], k: int) -> int: Returns the k-th largest element in the list. It uses a min-heap to maintain the k largest elements found so far. >>> findKthLargest([3,2,1,5,6,4], 2) 5 >>> findKthLargest([3,2,3,1,2,4,5,5,6], 4) 4 >>> findKthLargest([10, 4, 5, 8, 6, 11, 26], 3) 10 >>> findKthLargest([1], 1) 1 >>> findKthLargest([7, 10, 4, 3, 20, 15], 3) 10 >>> findKthLargest([7, 10, 4, 20, 15], 4) 7 >>> findKthLargest([-1, -2, -3, -4, -5], 2) -2 >>> findKthLargest([0, 0, 0, 0, 0], 1) 0","solution":"import heapq def findKthLargest(nums, k): This function returns the k-th largest element in the input list \`nums\`. It uses a min-heap to maintain the k largest elements found so far. # Use a min-heap with k elements to store the k largest elements min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return min_heap[0]"},{"question":"def rob(houses: List[int]) -> int: Given a list of non-negative integers representing the amount of money in each house, returns the maximum amount of money you can steal without stealing from two adjacent houses. >>> rob([]) == 0 >>> rob([10]) == 10 >>> rob([10, 20]) == 20 >>> rob([20, 10]) == 20 >>> rob([10, 15, 20]) == 30 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 1, 1, 2]) == 4 >>> rob([5, 5, 5, 5]) == 10 >>> rob([4, 3, 2, 1]) == 6","solution":"def rob(houses): Given a list of non-negative integers representing the amount of money in each house, returns the maximum amount of money you can steal without stealing from two adjacent houses. if not houses: return 0 if len(houses) <= 2: return max(houses) dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], houses[i] + dp[i-2]) return dp[-1]"},{"question":"def find_kth_missing(arr: List[int], k: int) -> int: Given a sorted array of distinct integers \`arr\` and an integer \`k\`, return the \`k\`-th missing positive integer. >>> find_kth_missing([2, 3, 4, 7, 11], 5) == 9 >>> find_kth_missing([1, 2, 3, 4], 2) == 6 >>> find_kth_missing([1, 3, 5, 7, 9], 3) == 6 >>> find_kth_missing([5, 6, 7], 4) == 4 >>> find_kth_missing([1, 2, 3, 4, 5], 1) == 6","solution":"def find_kth_missing(arr, k): Returns the k-th missing positive integer from the sorted array \`arr\`. missing_count = 0 last_num = 0 for num in arr: num_missings = num - last_num - 1 if missing_count + num_missings >= k: return last_num + (k - missing_count) missing_count += num_missings last_num = num # If k-th missing is beyond the last element in the array return last_num + (k - missing_count)"},{"question":"def get_factors(n: int) -> List[List[int]]: Given an integer n, return the list of all unique combinations of factors (excluding 1 and the number itself) that multiply to n. Each combination should be sorted in ascending order, and the result list should be sorted lexicographically. >>> get_factors(12) [[2, 2, 3], [2, 6], [3, 4]] >>> get_factors(15) [[3, 5]] >>> get_factors(16) [[2, 2, 2, 2], [2, 2, 4], [2, 8], [4, 4]] >>> get_factors(1) [] >>> get_factors(37) [] >>> get_factors(28) [[2, 2, 7], [2, 14], [4, 7]]","solution":"def get_factors(n): Returns a list of all unique combinations of factors (excluding 1 and the number itself) that multiply to \`n\`. Each combination is sorted in ascending order, and the result list is sorted lexicographically. def backtrack(start, target, path): if target == 1: if len(path) > 1: result.append(path[:]) return for i in range(start, target + 1): if target % i == 0: path.append(i) backtrack(i, target // i, path) path.pop() result = [] backtrack(2, n, []) return result"},{"question":"def can_make_palindrome(s: str) -> bool: Return \`true\` if you can make the string a palindrome with one swap or no swaps. >>> can_make_palindrome(\\"abca\\") True >>> can_make_palindrome(\\"raccear\\") True >>> can_make_palindrome(\\"abcdef\\") False >>> can_make_palindrome(\\"abcd\\") False >>> can_make_palindrome(\\"\\") True >>> can_make_palindrome(\\"a\\") True >>> can_make_palindrome(\\"aa\\") True >>> can_make_palindrome(\\"ab\\") True","solution":"def can_make_palindrome(s): Return \`true\` if you can make the string a palindrome with one swap or no swaps. def is_palindrome(st): return st == st[::-1] n = len(s) if is_palindrome(s): return True # Find pairs of mismatched characters mismatched_pairs = [] for i in range(n // 2): if s[i] != s[n - i - 1]: mismatched_pairs.append((i, n - i - 1)) # If there are more than 2 mismatched pairs, it is not possible to make a palindrome with one swap if len(mismatched_pairs) > 2: return False # Special case for when there are exactly 2 mismatched pairs if len(mismatched_pairs) == 2: (i1, j1), (i2, j2) = mismatched_pairs if (s[i1] == s[j2] and s[j1] == s[i2]): return True # If there are 0 or 1 mismatched pairs, it's already handled - can be made palindrome with one swap or is already a palindrome return len(mismatched_pairs) == 0 or len(mismatched_pairs) == 1"},{"question":"from typing import List def longest_reverse_diagonal_word_length(grid: List[List[str]]) -> int: Returns the length of the longest word that can be constructed by following the letters in reverse diagonal order in a given n x n grid. >>> grid1 = [ ... ['a', 'b', 'c'], ... ['d', 'e', 'f'], ... ['g', 'h', 'i'] ... ] >>> longest_reverse_diagonal_word_length(grid1) 3 >>> grid2 = [ ... ['a', 'b'], ... ['c', 'd'] ... ] >>> longest_reverse_diagonal_word_length(grid2) 2 >>> grid3 = [ ... ['x'] ... ] >>> longest_reverse_diagonal_word_length(grid3) 1 >>> grid4 = [ ... ['r', 't', 'o', 'p'], ... ['a', 'e', 'g', 'h'], ... ['q', 'b', 'k', 'f'], ... ['y', 'l', 'd', 'j'] ... ] >>> longest_reverse_diagonal_word_length(grid4) 4 >>> grid5 = [] >>> longest_reverse_diagonal_word_length(grid5) 0","solution":"def longest_reverse_diagonal_word_length(grid): Returns the length of the longest word that can be constructed by following the letters in reverse diagonal order in a given n x n grid. n = len(grid) max_length = 0 def dfs(x, y, length): nonlocal max_length max_length = max(max_length, length) if x + 1 < n and y - 1 >= 0: dfs(x + 1, y - 1, length + 1) # Process all cells in the first column and the first row for i in range(n): dfs(i, 0, 1) dfs(0, i, 1) return max_length"},{"question":"from typing import List def max_rectangle_area(heights: List[int]) -> int: Finds the maximum rectangular area that can be formed using one or more consecutive buildings given their heights. >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([]) 0 >>> max_rectangle_area([4]) 4 >>> max_rectangle_area([3, 3, 3, 3]) 12 >>> max_rectangle_area([1, 2, 3, 4, 5]) 9 >>> max_rectangle_area([5, 4, 3, 2, 1]) 9 >>> max_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> max_rectangle_area([2, 4, 4, 4, 2]) 12","solution":"from typing import List def max_rectangle_area(heights: List[int]) -> int: Finds the maximum rectangular area that can be formed using one or more consecutive buildings given their heights. n = len(heights) if n == 0: return 0 max_area = 0 stack = [] for i in range(n): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] if stack: width = i - stack[-1] - 1 else: width = i max_area = max(max_area, h * width) stack.append(i) while stack: h = heights[stack.pop()] if stack: width = n - stack[-1] - 1 else: width = n max_area = max(max_area, h * width) return max_area"},{"question":"def maximalRectangle(matrix: List[List[str]]) -> int: Given a \`m x n\` binary matrix \`mat\`, return the maximum area of a rectangle that contains only '1's. >>> maximalRectangle([[\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"]]) 6 >>> maximalRectangle([[\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\"]]) 0 >>> maximalRectangle([[\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\"]]) 9 >>> maximalRectangle([[\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"]]) 6 >>> maximalRectangle([]) 0","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 dp = [0] * len(matrix[0]) for row in matrix: for index, val in enumerate(row): dp[index] = dp[index] + 1 if val == '1' else 0 max_area = max(max_area, largestRectangleArea(dp)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"def longest_substring_with_k_deletions(s: str, k: int) -> int: Returns the length of the longest substring where at most k characters have been removed. >>> longest_substring_with_k_deletions(\\"abcde\\", 2) 5 >>> longest_substring_with_k_deletions(\\"abcdef\\", 0) 6 >>> longest_substring_with_k_deletions(\\"aabbcc\\", 3) 6 >>> longest_substring_with_k_deletions(\\"abcabc\\", 2) 6 >>> longest_substring_with_k_deletions(\\"aaaaaa\\", 2) 6 >>> longest_substring_with_k_deletions(\\"\\", 2) 0 >>> longest_substring_with_k_deletions(\\"aaaaa\\", 2) 5 >>> longest_substring_with_k_deletions(\\"abcde\\", 10) 5 >>> longest_substring_with_k_deletions(\\"abcdef\\", 0) 6","solution":"def longest_substring_with_k_deletions(s, k): Returns the length of the longest substring where at most k characters have been removed from it. n = len(s) left = 0 max_length = 0 while left < n: for right in range(left, n + 1): if len(s[left:right]) + k >= n: max_length = max(max_length, right - left) left += 1 return max_length # Testing the function with the given example s = \\"abcde\\" k = 2 print(longest_substring_with_k_deletions(s, k)) # Output should be 5"},{"question":"def find_kth_missing(arr: List[int], k: int) -> int: Return the k-th missing positive integer from the sorted array \`arr\`. >>> find_kth_missing([2, 3, 4, 7, 11], 5) == 9 >>> find_kth_missing([1, 2, 3, 4], 2) == 6 >>> find_kth_missing([1, 2, 3], 1) == 4 >>> find_kth_missing([4, 7, 9, 10], 1) == 1 >>> find_kth_missing([4, 7, 9, 10], 3) == 3 >>> find_kth_missing([1, 2, 4], 2) == 5 >>> find_kth_missing([2], 1) == 1 >>> find_kth_missing([2], 2) == 3 >>> find_kth_missing([], 1) == 1 >>> find_kth_missing([], 2) == 2 >>> find_kth_missing([1, 2, 3, 4, 5], 10) == 15","solution":"def find_kth_missing(arr, k): Returns the k-th missing positive integer from the sorted array \`arr\`. :param arr: List[int] - A sorted list of distinct integers. :param k: int - The 1-based index of the missing positive integer to find. :return: int - The k-th missing positive integer. missing_count = 0 i, current = 0, 1 while True: if i < len(arr) and arr[i] == current: i += 1 else: missing_count += 1 if missing_count == k: return current current += 1"},{"question":"def max_frequency(arr: List[int], k: int) -> int: Returns the maximum possible frequency of any one value in the array after performing at most k changes. >>> max_frequency([1, 2, 4, 4, 3], 2) 3 >>> max_frequency([1, 2, 4, 4, 3], 10) 5 >>> max_frequency([2, 2, 2], 1) 3 >>> max_frequency([1, 2, 3], 0) 1 >>> max_frequency([5], 100) 1 >>> max_frequency([1, 10, 100, 1000], 10) 2","solution":"def max_frequency(arr, k): Returns the maximum possible frequency of any one value in the array after performing at most k changes. :param arr: List[int] - the list of integers :param k: int - the maximum number of changes allowed :return: int - the maximum possible frequency of any one value arr.sort() left, total, result = 0, 0, 0 for right in range(len(arr)): total += arr[right] while (arr[right] * (right - left + 1) - total) > k: total -= arr[left] left += 1 result = max(result, right - left + 1) return result"},{"question":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths in a 2D grid with obstacles. :param grid: List[List[int]] representing a 2D grid with 0s (empty) and 1s (obstacle) :return: int - Number of unique paths from top-left to bottom-right >>> unique_paths_with_obstacles([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 6 >>> unique_paths_with_obstacles([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> unique_paths_with_obstacles([ [1, 0], [0, 0] ]) 0 >>> unique_paths_with_obstacles([ [0, 0], [0, 1] ]) 0 >>> unique_paths_with_obstacles([ [1] ]) 0 >>> unique_paths_with_obstacles([ [0] ]) 1 >>> unique_paths_with_obstacles([ [0, 0, 0], [0, 1, 0], [1, 0, 0] ]) 1","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths in a 2D grid with obstacles. :param grid: List[List[int]] representing a 2D grid with 0s (empty) and 1s (obstacle) :return: int - Number of unique paths from top-left to bottom-right if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def min_swaps_to_sort(height: List[int]) -> int: Returns the minimum number of swaps required to sort the array height in non-decreasing order. Example: >>> min_swaps_to_sort([4, 3, 2, 1]) 2","solution":"def min_swaps_to_sort(height): Returns the minimum number of swaps required to sort the array height in non-decreasing order. # Create a list of tuples where each tuple contains a height and its index in the original array indexed_height = list(enumerate(height)) # Sort the list based on heights indexed_height.sort(key=lambda x: x[1]) # Initialize an array to check if a shelf has been visited during the cycle detection visited = [False] * len(height) swaps = 0 for i in range(len(height)): if visited[i] or indexed_height[i][0] == i: continue # Find the cycle length cycle_length = 0 x = i while not visited[x]: visited[x] = True x = indexed_height[x][0] cycle_length += 1 # If cycle length is n, we need (n-1) swaps to sort the cycle if cycle_length > 0: swaps += (cycle_length - 1) return swaps"},{"question":"from typing import List def min_moves_to_coincide(points: List[List[int]], k: int) -> int: Calculate the minimum number of moves required to make all points coincident (i.e., the same position). If it is not possible to make all points coincident, return -1. Args: points: List of points represented as [xi, yi]. k: Integer representing the maximum distance a point can move in a single move. Returns: The minimum number of moves required or -1 if not possible. >>> min_moves_to_coincide([[1, 2]], 3) 0 >>> min_moves_to_coincide([[1, 2], [3, 3]], 3) 1 >>> min_moves_to_coincide([[1, 2], [10, 10]], 3) -1 >>> min_moves_to_coincide([[1, 1], [2, 2], [1, 2]], 2) 1 >>> min_moves_to_coincide([[1, 1], [2, 2], [2, 1], [1, 2]], 2) 1 >>> min_moves_to_coincide([[0, 0], [5, 5], [10, 10]], 1) -1","solution":"# Given the problem constraints, the task is complex. To simplify, let's analyze. # Given a set of points, the goal is to minimize the moves required to make them coincide. # Being each move restricted by a maximum distance k, we need to check all possible pairs of points and # analyze whether we can make a point coincide at the same location within given constraints. from math import sqrt def min_moves_to_coincide(points, k): def can_move_within_distance(p1, p2): distance = sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) return distance <= k n = len(points) # If there's only one point, it is already coincident if n == 1: return 0 # Iterate through each point and check if we can move all other points to coincide with it for i in range(n): valid = True for j in range(n): if i != j and not can_move_within_distance(points[i], points[j]): valid = False break if valid: return 1 # If we can move all points to coincide with \`points[i]\`, return 1 move # If no point can be used to coincide all points within distance k, return -1 return -1"},{"question":"from typing import List, Dict def generate_synonym_sentences(mappings: Dict[str, List[str]], sentences: List[str]) -> List[str]: Given a dictionary of mappings where each key is a word and its value is a list of synonyms, and a list of sentences, returns a list of all possible sentences where each word in the original sentence is replaced with one of its synonyms. Words without synonyms should remain unchanged. >>> mappings = {\\"quick\\": [\\"fast\\", \\"speedy\\"], \\"brown\\": [\\"chocolate\\"]} >>> sentences = [\\"The quick brown fox\\"] >>> generate_synonym_sentences(mappings, sentences) ['The fast chocolate fox', 'The speedy chocolate fox', 'The quick chocolate fox', 'The fast brown fox', 'The speedy brown fox', 'The quick brown fox'] >>> mappings = {} >>> sentences = [\\"The quick brown fox\\"] >>> generate_synonym_sentences(mappings, sentences) ['The quick brown fox'] def test_basic_case(): mappings = {\\"quick\\": [\\"fast\\", \\"speedy\\"], \\"brown\\": [\\"chocolate\\"]} sentences = [\\"The quick brown fox\\"] expected = [ \\"The fast chocolate fox\\", \\"The speedy chocolate fox\\", \\"The quick chocolate fox\\", \\"The fast brown fox\\", \\"The speedy brown fox\\", \\"The quick brown fox\\" ] result = generate_synonym_sentences(mappings, sentences) assert set(result) == set(expected) def test_no_mappings(): mappings = {} sentences = [\\"The quick brown fox\\"] expected = [\\"The quick brown fox\\"] result = generate_synonym_sentences(mappings, sentences) assert result == expected def test_partial_mapping(): mappings = {\\"quick\\": [\\"fast\\"]} sentences = [\\"The quick brown fox\\"] expected = [\\"The fast brown fox\\", \\"The quick brown fox\\"] result = generate_synonym_sentences(mappings, sentences) assert set(result) == set(expected) def test_multiple_sentences(): mappings = {\\"quick\\": [\\"fast\\"], \\"brown\\": [\\"chocolate\\"]} sentences = [\\"The quick brown fox\\", \\"A quick movement\\"] expected = [ \\"The fast chocolate fox\\", \\"The quick chocolate fox\\", \\"The quick brown fox\\", \\"The fast brown fox\\", \\"A fast movement\\", \\"A quick movement\\" ] result = generate_synonym_sentences(mappings, sentences) assert set(result) == set(expected) def test_repeated_words(): mappings = {\\"quick\\": [\\"fast\\"]} sentences = [\\"quick quick quick\\"] expected = [ \\"quick quick quick\\", \\"fast quick quick\\", \\"quick fast quick\\", \\"quick quick fast\\", \\"fast fast quick\\", \\"fast quick fast\\", \\"quick fast fast\\", \\"fast fast fast\\" ] result = generate_synonym_sentences(mappings, sentences) assert set(result) == set(expected)","solution":"from typing import List, Dict import itertools def generate_synonym_sentences(mappings: Dict[str, List[str]], sentences: List[str]) -> List[str]: Given a dictionary of mappings where each key is a word and its value is a list of synonyms, and a list of sentences, returns a list of all possible sentences where each word in the original sentences is replaced with one of its synonyms. :param mappings: Dict[str, List[str]] - word to synonyms mapping :param sentences: List[str] - original sentences :return: List[str] - all possible sentences with synonyms replacements result = [] def generate_variants(words: List[str], index: int) -> List[str]: if index == len(words): # Base case: return current completed variant as a single-item list return [' '.join(words)] word = words[index] # Generate sentences with current word and all its synonyms variants = [] # Use the original word itself next_words = words[:index] + [word] + words[index+1:] variants.extend(generate_variants(next_words, index + 1)) if word in mappings: for synonym in mappings[word]: next_words = words[:index] + [synonym] + words[index+1:] variants.extend(generate_variants(next_words, index + 1)) return variants for sentence in sentences: words = sentence.split() result.extend(generate_variants(words, 0)) return result"},{"question":"from typing import List, Tuple class IntervalCollection: A data structure that supports operations on a collection of intervals, including merging intervals and finding the maximum number of overlapping intervals. def __init__(self): Initializes the interval collection. pass def addInterval(self, start: int, end: int) -> None: Adds an interval [start, end] to the collection. Each interval [start, end] includes all the integers between start and end, including the endpoints. pass def getMergedIntervals(self) -> List[Tuple[int, int]]: Returns a list of merged intervals where all overlapping intervals have been merged. pass def getMaxOverlapping(self) -> int: Returns the maximum number of overlapping intervals at any point in the collection. pass","solution":"from typing import List, Tuple class IntervalCollection: def __init__(self): self.intervals = [] def addInterval(self, start: int, end: int) -> None: self.intervals.append((start, end)) def getMergedIntervals(self) -> List[Tuple[int, int]]: if not self.intervals: return [] # Sort intervals by their start time self.intervals.sort() merged_intervals = [self.intervals[0]] for current in self.intervals[1:]: last_merged = merged_intervals[-1] if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals def getMaxOverlapping(self) -> int: if not self.intervals: return 0 events = [] for start, end in self.intervals: events.append((start, 1)) events.append((end + 1, -1)) events.sort() max_overlap = 0 current_overlap = 0 for time, change in events: current_overlap += change max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"def trap(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped after raining. >>> trap([]) == 0 >>> trap([1]) == 0 >>> trap([1, 2]) == 0 >>> trap([1, 0, 2]) == 1 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([3, 3, 3, 3]) == 0 >>> trap([4, 2, 0, 3, 2, 5]) == 9","solution":"def trap(height): Calculate the total amount of water trapped based on the input height array. :param height: List[int], the elevation map. :return: int, total water trapped. if not height: return 0 length = len(height) left_max = [0] * length right_max = [0] * length water_trapped = 0 left_max[0] = height[0] for i in range(1, length): left_max[i] = max(left_max[i - 1], height[i]) right_max[length - 1] = height[length - 1] for i in range(length - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(length): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def num_valid_subsequences(word: str, k: int) -> int: Returns the number of valid subsequences of the given word that contain at most k distinct characters. >>> num_valid_subsequences(\\"abc\\", 2) 6 >>> num_valid_subsequences(\\"ab\\", 1) 2 >>> num_valid_subsequences(\\"aaa\\", 2) 7 >>> num_valid_subsequences(\\"abcde\\", 3) 25 >>> num_valid_subsequences(\\"a\\", 1) 1 >>> num_valid_subsequences(\\"a\\", 0) 0 >>> num_valid_subsequences(\\"xyz\\", 0) 0 >>> num_valid_subsequences(\\"aaaa\\", 1) 15 >>> num_valid_subsequences(\\"abcd\\", 4) 15 >>> num_valid_subsequences(\\"abcd\\", 3) 14 >>> num_valid_subsequences(\\"abcd\\", 2) 10 >>> num_valid_subsequences(\\"abcd\\", 1) 4 MOD = 10**9 + 7 n = len(word) all_masks = 1 << n valid_count = 0 from collections import defaultdict from functools import lru_cache @lru_cache(None) def count_distinct_chars(mask): char_set = set() for i in range(n): if (mask & (1 << i)): char_set.add(word[i]) return len(char_set) for mask in range(1, all_masks): if count_distinct_chars(mask) <= k: valid_count = (valid_count + 1) % MOD return valid_count","solution":"def num_valid_subsequences(word, k): Returns the number of valid subsequences of the given word that contain at most k distinct characters. MOD = 10**9 + 7 n = len(word) all_masks = 1 << n valid_count = 0 from collections import defaultdict from functools import lru_cache @lru_cache(None) def count_distinct_chars(mask): char_set = set() for i in range(n): if (mask & (1 << i)): char_set.add(word[i]) return len(char_set) for mask in range(1, all_masks): if count_distinct_chars(mask) <= k: valid_count = (valid_count + 1) % MOD return valid_count"},{"question":"class StreamChecker: def __init__(self, words): Initializes the StreamChecker with the list of given words. Args: words (List[str]): List of words to check against during queries. pass def query(self, letter): Appends the letter to the query stream and checks if any word appears as a suffix. Args: letter (str): The character to be queried. Returns: bool: Returns True if any word is found as a suffix, otherwise False. pass from solution import StreamChecker def test_stream_checker_single_query(): checker = StreamChecker([\\"cd\\", \\"f\\", \\"kl\\"]) assert checker.query('a') == False assert checker.query('b') == False assert checker.query('c') == False assert checker.query('d') == True # 'cd' is present def test_stream_checker_multiple_queries(): checker = StreamChecker([\\"ab\\", \\"ba\\", \\"aaab\\", \\"abab\\", \\"baa\\"]) assert checker.query('a') == False assert checker.query('a') == False assert checker.query('a') == False assert checker.query('b') == True # 'aaab' is present assert checker.query('a') == True # 'ba' is present def test_stream_checker_with_long_word(): long_word = \\"a\\" * 2000 checker = StreamChecker([long_word]) for _ in range(2000): assert checker.query(\\"a\\") == (_ == 1999) def test_stream_checker_no_match(): checker = StreamChecker([\\"hello\\", \\"world\\"]) assert checker.query('h') == False assert checker.query('e') == False assert checker.query('a') == False def test_stream_checker_edge_case_empty_queries(): checker = StreamChecker([\\"empty\\"]) assert checker.query('e') == False assert checker.query('m') == False assert checker.query('p') == False assert checker.query('t') == False assert checker.query('y') == True # 'empty' is present","solution":"class StreamChecker: def __init__(self, words): Initializes the StreamChecker with the list of given words. self.queries = [] self.word_set = set() max_len = 0 for word in words: reversed_word = word[::-1] # Reverse the word and store in set self.word_set.add(reversed_word) max_len = max(max_len, len(reversed_word)) self.max_len = max_len def query(self, letter): Appends the letter to the query stream and checks if any word appears as a suffix. self.queries.append(letter) if len(self.queries) > self.max_len: self.queries.pop(0) current_string = ''.join(self.queries[::-1]) for word in self.word_set: if current_string.startswith(word): return True return False"},{"question":"def is_peak_arrangement(heights: List[int]) -> bool: Returns True if the given building heights are in a peak arrangement, otherwise False. >>> is_peak_arrangement([1, 2, 3, 4, 3, 2, 1]) True >>> is_peak_arrangement([1, 2, 2, 4, 3, 2, 1]) False >>> is_peak_arrangement([1, 2, 3, 4, 3, 3, 1]) False >>> is_peak_arrangement([1, 2, 4, 3, 2, 3, 1]) False >>> is_peak_arrangement([1, 2, 3, 4, 4, 3, 2]) False >>> is_peak_arrangement([1]) True >>> is_peak_arrangement([1, 2, 1]) True >>> is_peak_arrangement([1, 2, 3, 2, 1]) True","solution":"def is_peak_arrangement(heights): Returns True if the given building heights are in a peak arrangement, otherwise False. n = len(heights) peak_index = heights.index(max(heights)) # Check if the max height is at the center index if peak_index != n // 2: return False # Check the left side (strictly increasing) for i in range(peak_index): if heights[i] >= heights[i + 1]: return False # Check the right side (strictly decreasing) for i in range(peak_index, n - 1): if heights[i] <= heights[i + 1]: return False return True"},{"question":"def build_file_structure(paths): Transforms an array of paths into a nested dictionary structure. Args: paths (list): List of path strings. Returns: dict: Nested dictionary representing the file structure. pass from solution import build_file_structure def test_single_file(): assert build_file_structure([\\"file.txt\\"]) == {\\"file.txt\\": None} def test_nested_directories(): assert build_file_structure([\\"dir1/dir2/file.txt\\"]) == {\\"dir1\\": {\\"dir2\\": {\\"file.txt\\": None}}} def test_multiple_files_same_directory(): assert build_file_structure([\\"dir1/file1.txt\\", \\"dir1/file2.txt\\"]) == {\\"dir1\\": {\\"file1.txt\\": None, \\"file2.txt\\": None}} def test_multiple_files_different_directories(): assert build_file_structure([\\"dir1/file1.txt\\", \\"dir2/file2.txt\\"]) == {\\"dir1\\": {\\"file1.txt\\": None}, \\"dir2\\": {\\"file2.txt\\": None}} def test_complex_structure(): input_paths = [ \\"dir1/file1.txt\\", \\"dir1/dir2/file2.txt\\", \\"dir1/dir2/file3.txt\\", \\"dir1/file4.txt\\", \\"dir3/dir4/file5.txt\\" ] expected_structure = { \\"dir1\\": { \\"file1.txt\\": None, \\"dir2\\": { \\"file2.txt\\": None, \\"file3.txt\\": None, }, \\"file4.txt\\": None }, \\"dir3\\": { \\"dir4\\": { \\"file5.txt\\": None, } } } assert build_file_structure(input_paths) == expected_structure","solution":"def build_file_structure(paths): Transforms an array of paths into a nested dictionary structure. Args: paths (list): List of path strings. Returns: dict: Nested dictionary representing the file structure. file_structure = {} for path in paths: components = path.split('/') current_level = file_structure for component in components[:-1]: if component not in current_level: current_level[component] = {} current_level = current_level[component] current_level[components[-1]] = None return file_structure"},{"question":"def min_changes_to_good_string(s: str) -> int: Returns the minimum number of characters to be changed to make the string a good string. :param s: A string consisting of lowercase English letters. :return: Minimum number of changes required. >>> min_changes_to_good_string(\\"aaaa\\") == 0 >>> min_changes_to_good_string(\\"ab\\") == 1 >>> min_changes_to_good_string(\\"abc\\") == 2 >>> min_changes_to_good_string(\\"aabb\\") == 2 >>> min_changes_to_good_string(\\"aabbb\\") == 2 >>> min_changes_to_good_string(\\"a\\") == 0 >>> min_changes_to_good_string(\\"aabbcc\\") == 4 >>> min_changes_to_good_string(\\"aaabbbccc\\") == 6","solution":"def min_changes_to_good_string(s): Returns the minimum number of characters to be changed to make the string a good string. :param s: A string consisting of lowercase English letters. :return: Minimum number of changes required. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 max_frequency = max(frequency.values()) return len(s) - max_frequency"},{"question":"from typing import List from collections import Counter def min_replacements_to_anagram(s: str, t: str) -> int: Given two strings s and t, return the minimum number of single-character replacements needed to make s an anagram of t. Return -1 if it's not possible to transform s into an anagram of t. >>> min_replacements_to_anagram(\\"abc\\", \\"abc\\") 0 >>> min_replacements_to_anagram(\\"aabc\\", \\"abbd\\") 2 >>> min_replacements_to_anagram(\\"aabbcc\\", \\"xyzxyz\\") 6 >>> min_replacements_to_anagram(\\"aabbc\\", \\"aabc\\") -1 >>> min_replacements_to_anagram(\\"abc\\", \\"abcd\\") -1","solution":"from collections import Counter def min_replacements_to_anagram(s, t): Given two strings s and t, returns the minimum number of single-character replacements needed to make s an anagram of t. Returns -1 if it's not possible to transform s into an anagram of t. if len(s) != len(t): return -1 count_s = Counter(s) count_t = Counter(t) # Calculate the number of replacements needed. replacements = 0 for char in count_t: if char in count_s: if count_t[char] > count_s[char]: replacements += count_t[char] - count_s[char] else: replacements += count_t[char] return replacements"},{"question":"from typing import Set def word_ladder_length(start: str, end: str, dictionary: Set[str]) -> int: Returns the length of the shortest word ladder from start to end using the given dictionary. Parameters: start (str): The starting word. end (str): The ending word. dictionary (set): A set of valid words. Returns: int: Length of the shortest word ladder, or 0 if no such sequence exists. >>> word_ladder_length(\\"hit\\", \\"cog\\", {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"}) 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"}) 0 from collections import deque def test_word_ladder_direct_connection(): assert word_ladder_length(\\"hit\\", \\"cog\\", {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"}) == 5 def test_word_ladder_no_connection(): assert word_ladder_length(\\"hit\\", \\"cog\\", {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"}) == 0 def test_word_ladder_single_letter(): assert word_ladder_length(\\"a\\", \\"c\\", {\\"a\\", \\"b\\", \\"c\\"}) == 2 def test_word_ladder_start_end_same(): assert word_ladder_length(\\"hit\\", \\"hit\\", {\\"hot\\", \\"dot\\", \\"hit\\", \\"lot\\", \\"log\\"}) == 1 def test_word_ladder_large_dict(): dictionary = set(\\"lie, lit, lot, let, sit, sat, set, bit, bat, bet, cot, cat, pat, put, pot, pit, pen, pan, pen, pit, fit, bar, car, war, far, for, nor, rot, not, cot, cut, cup\\".split(\\", \\")) assert word_ladder_length(\\"hit\\", \\"cup\\", dictionary) == 5","solution":"from collections import deque def word_ladder_length(start, end, dictionary): Returns the length of the shortest word ladder from start to end using the given dictionary. Parameters: start (str): The starting word. end (str): The ending word. dictionary (set): A set of valid words. Returns: int: Length of the shortest word ladder, or 0 if no such sequence exists. if end not in dictionary: return 0 dictionary.add(start) queue = deque([(start, 1)]) # (current_word, current_length) while queue: current_word, current_length = queue.popleft() if current_word == end: return current_length for i in range(len(current_word)): for char in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + char + current_word[i+1:] if next_word in dictionary: dictionary.remove(next_word) queue.append((next_word, current_length + 1)) return 0"},{"question":"def max_area(heights: List[int]) -> int: Returns the maximum area of water that can be trapped between two pillars. >>> max_area([1,8,6,2,5,4,8,3,7]) == 49 >>> max_area([1,1]) == 1 >>> max_area([4,3,2,1,4]) == 16 >>> max_area([1,2,1]) == 2 from solution import max_area def test_max_area(): assert max_area([1,8,6,2,5,4,8,3,7]) == 49 assert max_area([1,1]) == 1 assert max_area([4,3,2,1,4]) == 16 assert max_area([1,2,1]) == 2 def test_max_area_empty_and_single(): assert max_area([]) == 0 assert max_area([5]) == 0 def test_max_area_same_heights(): assert max_area([3,3,3,3,3]) == 12 def test_max_area_inner_peak(): assert max_area([1,3,2,5,2,4,1]) == 12","solution":"def max_area(heights): Returns the maximum area of water that can be trapped between two pillars. if len(heights) < 2: return 0 max_area = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def min_operations_to_permutations(words: List[str], target: str) -> int: Returns the minimum number of operations required to make \`words\` a subset of permutations of \`target\`. If it's not possible, returns -1. >>> min_operations_to_permutations([\\"abc\\", \\"bca\\"], \\"cab\\") 2 >>> min_operations_to_permutations([\\"abc\\", \\"xyz\\"], \\"abc\\") -1 >>> min_operations_to_permutations([\\"abc\\", \\"bca\\", \\"abb\\"], \\"cba\\") -1 >>> min_operations_to_permutations([\\"abc\\", \\"bac\\", \\"cab\\", \\"cba\\", \\"acb\\", \\"bca\\"], \\"abc\\") 6 >>> min_operations_to_permutations([], \\"abc\\") 0 pass","solution":"def min_operations_to_permutations(words, target): Returns the minimum number of operations required to make \`words\` a subset of permutations of \`target\`. If it's not possible, returns -1. from collections import Counter def can_become_permutation(word, target_counter): Helper function to check if a word can be transformed to a permutation of target by reversing substrings. return Counter(word) == target_counter target_counter = Counter(target) operations = 0 for word in words: if not can_become_permutation(word, target_counter): return -1 operations += 1 return operations"},{"question":"def can_partition(arr, k, target): Determines if it is possible to partition the array into exactly k non-empty subarrays such that the sum of each subarray is greater than or equal to a given integer target. :param arr: List of integers :param k: Number of partitions :param target: Target sum for each subarray :return: True if possible, otherwise False >>> can_partition([1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 10) == True >>> can_partition([5, 5, 5, 5, 5], 4, 5) == True >>> can_partition([15, 7, 8, 9, 10], 2, 15) == True >>> can_partition([1, 2, 3, 4, 5], 3, 9) == False >>> can_partition([1, 1, 1, 1], 2, 4) == False >>> can_partition([2, 2, 2, 2], 2, 10) == False >>> can_partition([10], 1, 10) == True >>> can_partition([9], 1, 10) == False >>> can_partition([], 1, 10) == False","solution":"def can_partition(arr, k, target): Determines if it is possible to partition the array into exactly k non-empty subarrays such that the sum of each subarray is greater than or equal to a given integer target. :param arr: List of integers :param k: Number of partitions :param target: Target sum for each subarray :return: True if possible, otherwise False def can_form_partitions(arr, k, target): current_sum = 0 partitions = 0 for num in arr: current_sum += num if current_sum >= target: partitions += 1 current_sum = 0 return partitions >= k if sum(arr) < k * target: return False return can_form_partitions(arr, k, target)"},{"question":"def longestSubstringWithTwoDistinct(s: str) -> int: Determine the length of the longest substring that contains no more than two distinct characters. >>> longestSubstringWithTwoDistinct(\\"eceba\\") 3 >>> longestSubstringWithTwoDistinct(\\"ccaabbb\\") 5 >>> longestSubstringWithTwoDistinct(\\"a\\") 1 >>> longestSubstringWithTwoDistinct(\\"ab\\") 2 >>> longestSubstringWithTwoDistinct(\\"aaaa\\") 4 >>> longestSubstringWithTwoDistinct(\\"\\") 0 >>> longestSubstringWithTwoDistinct(\\"aab\\") 3 >>> longestSubstringWithTwoDistinct(\\"aabbbaaa\\") 8","solution":"def longestSubstringWithTwoDistinct(s): Returns the length of the longest substring that contains no more than two distinct characters. n = len(s) if n < 3: return n # Sliding window left and right pointers left, right = 0, 0 # Hashmap to keep track of characters and their rightmost positions hashmap = {} max_len = 2 while right < n: # Slide the window hashmap[s[right]] = right right += 1 # If the map contains more than 2 distinct characters if len(hashmap) > 2: # Get the leftmost character del_idx = min(hashmap.values()) # Remove it from the map del hashmap[s[del_idx]] # Slide the left pointer of the window left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def remove_consecutive_duplicates(s: str) -> str: Removes all consecutive duplicate characters from the string s and returns the resulting string. >>> remove_consecutive_duplicates(\\"abbaccd\\") == \\"abacd\\" >>> remove_consecutive_duplicates(\\"abcd\\") == \\"abcd\\" >>> remove_consecutive_duplicates(\\"aaa\\") == \\"a\\" >>> remove_consecutive_duplicates(\\"aabbbccdaa\\") == \\"abcda\\" >>> remove_consecutive_duplicates(\\"a b c\\") == \\"a b c\\" >>> remove_consecutive_duplicates(\\"\\") == \\"\\" >>> remove_consecutive_duplicates(\\"a\\") == \\"a\\"","solution":"def remove_consecutive_duplicates(s): Removes all consecutive duplicate characters from the string s and returns the resulting string. if not s: return \\"\\" result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result)"},{"question":"def min_difference(tasks: List[int]) -> int: Return the minimum possible difference between the total durations assigned to the two workers. :param tasks: List[int] - a list of task durations :return: int - the minimum difference between the two workers' total task durations >>> min_difference([10]) == 10 >>> min_difference([10, 10, 10, 10]) == 0 >>> min_difference([1, 2, 3, 4, 5]) == 1 >>> min_difference([1, 2, 3, 100]) == 94 >>> min_difference([6, 8, 4, 5]) == 1 >>> min_difference([1, 1, 1, 1, 1]) == 1","solution":"def min_difference(tasks): Return the minimum possible difference between the total durations assigned to the two workers. :param tasks: List[int] - a list of task durations :return: int - the minimum difference between the two workers' total task durations total_sum = sum(tasks) half_sum = total_sum // 2 # Initialize a DP set with a single element 0 (indicating zero sum) dp = {0} for task in tasks: # Update DP set with new possible sums new_dp = dp.copy() for s in dp: new_dp.add(s + task) dp = new_dp # Find the closest sum to half_sum closest_sum = max(s for s in dp if s <= half_sum) return abs(total_sum - 2 * closest_sum)"},{"question":"def min_cost_transform(s: str, t: str) -> int: Returns the minimum cost to transform string s into string t. The cost is 1 unit per character change. >>> min_cost_transform(\\"abc\\", \\"abc\\") == 0 >>> min_cost_transform(\\"abc\\", \\"abd\\") == 1 >>> min_cost_transform(\\"abc\\", \\"def\\") == 3 >>> min_cost_transform(\\"abcdef\\", \\"azcefh\\") == 4 >>> min_cost_transform(\\"abcde\\", \\"abzde\\") == 1 >>> min_cost_transform(\\"\\", \\"\\") == 0 >>> min_cost_transform(\\"abc\\", \\"abcd\\") == -1","solution":"def min_cost_transform(s, t): Returns the minimum cost to transform string s into string t. The cost is 1 unit per character change. if len(s) != len(t): return -1 # Cost is determined by the number of differing characters. cost = 0 for sc, tc in zip(s, t): if sc != tc: cost += 1 return cost"},{"question":"from typing import List def max_distinct_chars(matrix: List[List[str]]) -> int: Returns the maximum number of distinct characters that can be collected by following a path that starts at any cell and moves to adjacent cells (up, down, left, or right) without revisiting any cell in the given matrix. >>> max_distinct_chars([['a']]) 1 >>> max_distinct_chars([ ... ['a', 'b', 'c'], ... ['d', 'e', 'f'], ... ['g', 'h', 'i'] ... ]) 9 >>> max_distinct_chars([ ... ['a', 'b', 'a'], ... ['a', 'c', 'd'], ... ['e', 'a', 'f'] ... ]) 6 >>> max_distinct_chars([ ... ['a', 'a', 'a'], ... ['a', 'a', 'a'], ... ['a', 'a', 'a'] ... ]) 1 >>> max_distinct_chars([]) 0 >>> max_distinct_chars([ ... ['a', 'b', 'c', 'd'], ... ['e', 'f', 'g', 'h'], ... ['i', 'j', 'k', 'l'], ... ['m', 'n', 'o', 'p'], ... ]) 16","solution":"def max_distinct_chars(matrix): Returns the maximum number of distinct characters that can be collected by following a path that starts at any cell and moves to adjacent cells (up, down, left, or right) without revisiting any cell in the given matrix. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_distinct = 0 def dfs(x, y, visited): nonlocal max_distinct if 0 <= x < rows and 0 <= y < cols and matrix[x][y] not in visited: visited.add(matrix[x][y]) max_distinct = max(max_distinct, len(visited)) dfs(x + 1, y, visited) dfs(x - 1, y, visited) dfs(x, y + 1, visited) dfs(x, y - 1, visited) visited.remove(matrix[x][y]) for i in range(rows): for j in range(cols): dfs(i, j, set()) return max_distinct"},{"question":"def count_peak_buildings(heights: List[int]) -> int: Returns the number of peak buildings in the heights array. A peak building is one that is taller than the buildings to its left and right. The buildings at the ends of the street cannot be peak buildings. >>> count_peak_buildings([2, 2, 2, 2, 2]) == 0 >>> count_peak_buildings([1, 3, 1]) == 1 >>> count_peak_buildings([1, 3, 1, 3, 1, 3, 1]) == 3 from solution import count_peak_buildings def test_no_peaks(): assert count_peak_buildings([2, 2, 2, 2, 2]) == 0 assert count_peak_buildings([1, 2]) == 0 assert count_peak_buildings([]) == 0 def test_one_peak(): assert count_peak_buildings([1, 3, 1]) == 1 assert count_peak_buildings([1, 2, 1, 2, 1]) == 2 def test_multiple_peaks(): assert count_peak_buildings([1, 3, 1, 3, 1, 3, 1]) == 3 assert count_peak_buildings([2, 1, 3, 1, 2, 1, 4, 1]) == 3 def test_edge_cases(): assert count_peak_buildings([1, 2, 3, 2, 1]) == 1 assert count_peak_buildings([1, 2, 3, 4, 3, 2, 1]) == 1 assert count_peak_buildings([1, 3, 2, 3, 2, 3, 2, 1]) == 3 assert count_peak_buildings([1, 2, 3, 1, 1, 2, 3, 1]) == 2","solution":"def count_peak_buildings(heights): Returns the number of peak buildings in the \`heights\` array. A peak building is one that is taller than the buildings to its left and right. n = len(heights) if n < 3: return 0 peak_count = 0 for i in range(1, n-1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: peak_count += 1 return peak_count"},{"question":"def smallest_lexicographical_string(s: str, k: int) -> str: Returns the lexicographically smallest string after rearranging any substring of s at most k times. >>> smallest_lexicographical_string(\\"ba\\", 1) \\"ab\\" >>> smallest_lexicographical_string(\\"cba\\", 1) \\"acb\\" >>> smallest_lexicographical_string(\\"dcab\\", 1) \\"abdc\\" >>> smallest_lexicographical_string(\\"ba\\", 2) \\"ab\\" >>> smallest_lexicographical_string(\\"cba\\", 3) \\"abc\\" >>> smallest_lexicographical_string(\\"dcab\\", 2) \\"abcd\\" >>> smallest_lexicographical_string(\\"abc\\", 1) \\"abc\\" >>> smallest_lexicographical_string(\\"abc\\", 2) \\"abc\\" >>> smallest_lexicographical_string(\\"zxywvu\\", 100) \\"uvwxyz\\"","solution":"def smallest_lexicographical_string(s, k): Returns the lexicographically smallest string after rearranging any substring of s at most k times. if k == 1: # Generate all cyclic rotations of the string min_s = s for i in range(1, len(s)): rotated = s[i:] + s[:i] if rotated < min_s: min_s = rotated return min_s else: # If k is more than 1, we can fully sort the string return \\"\\".join(sorted(s))"},{"question":"def largest_rectangle_area(hist: List[int]) -> int: Calculates the area of the largest rectangle that can be formed in a histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 2, 2, 2]) 8 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9","solution":"def largest_rectangle_area(hist): Calculates the area of the largest rectangle that can be formed in a histogram. Parameters: hist (list): List of non-negative integers representing the height of histogram bars. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(hist): if not stack or hist[index] >= hist[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (hist[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (hist[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def count_award_eligible_students(heights: List[int]) -> int: Returns the number of students eligible for an award. A student is eligible if they are taller than both their immediate neighbors. Parameters: heights (List[int]): list of student heights Returns: int: number of students eligible for an award Examples: >>> count_award_eligible_students([160, 180, 160, 170, 160]) 2 >>> count_award_eligible_students([190, 180, 170, 160, 150]) 0 >>> count_award_eligible_students([160, 180, 170, 160]) 1","solution":"def count_award_eligible_students(heights): Returns the number of students eligible for an award. A student is eligible if they are taller than both their immediate neighbors. :param heights: List[int] - list of student heights :return: int - number of students eligible for an award if len(heights) < 3: return 0 eligible_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: eligible_count += 1 return eligible_count"},{"question":"def max_abs_difference(nums): Returns the maximum absolute value of the difference between two elements such that the larger element appears after the smaller element in the array. >>> max_abs_difference([2, 3, 10, 6, 4, 8, 1]) == 8 >>> max_abs_difference([1, 2, -10, 3, 4, -6, 8]) == 18 >>> max_abs_difference([-10, -3, -1, -5]) == 9 >>> max_abs_difference([1, 2]) == 1 >>> max_abs_difference([2, 1]) == 1 >>> max_abs_difference([5, 5, 5, 5]) == 0 >>> max_abs_difference([]) == 0 >>> max_abs_difference([5]) == 0","solution":"def max_abs_difference(nums): Returns the maximum absolute value of the difference between two elements such that the larger element appears after the smaller element in the array. if not nums or len(nums) < 2: return 0 min_element = nums[0] max_diff = 0 for j in range(1, len(nums)): max_diff = max(max_diff, abs(nums[j] - min_element)) min_element = min(min_element, nums[j]) return max_diff"},{"question":"def reverse_pairs(nums: List[int]) -> int: Given an integer array nums, return the number of reverse pairs. A reverse pair is defined as a pair of indices (i, j) where i < j and nums[i] > 2 * nums[j].","solution":"def reverse_pairs(nums): Given an integer array nums, return the number of reverse pairs. A reverse pair is defined as a pair of indices (i, j) where i < j and nums[i] > 2 * nums[j]. def merge_sort_and_count(arr, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(arr, left, mid) + merge_sort_and_count(arr, mid + 1, right) j = mid + 1 for i in range(left, mid + 1): while j <= right and arr[i] > 2 * arr[j]: j += 1 count += j - (mid + 1) # Merge the sorted halves arr[left:right + 1] = sorted(arr[left:right + 1]) return count return merge_sort_and_count(nums, 0, len(nums) - 1)"},{"question":"def merge_strings(word1: str, word2: str) -> str: Merges two strings by interleaving their characters starting with word1. If one string runs out of characters before the other, appends the remaining characters. >>> merge_strings(\\"abc\\", \\"123\\") == \\"a1b2c3\\" >>> merge_strings(\\"abcd\\", \\"12\\") == \\"a1b2cd\\" >>> merge_strings(\\"ab\\", \\"1234\\") == \\"a1b234\\" >>> merge_strings(\\"\\", \\"1234\\") == \\"1234\\" >>> merge_strings(\\"abcd\\", \\"\\") == \\"abcd\\" >>> merge_strings(\\"\\", \\"\\") == \\"\\"","solution":"def merge_strings(word1, word2): Merges two strings by interleaving their characters starting with word1. If one string runs out of characters before the other, appends the remaining characters. merged = [] len1, len2 = len(word1), len(word2) i = 0 # Traverse through both strings until the end of the shorter one while i < len1 and i < len2: merged.append(word1[i]) merged.append(word2[i]) i += 1 # Append remaining characters of the longer string if i < len1: merged.append(word1[i:]) elif i < len2: merged.append(word2[i:]) return ''.join(merged)"},{"question":"class PlayerRankings: Manages the players and their scores. Methods: ---------- __init__(self, scores: List[int]) -> None: Initializes the rankings with the given list of scores. challenge(self, i: int, j: int) -> None: Updates the scores after player \`i\` challenges player \`j\` and wins. getRankings(self) -> List[int]: Returns an array of player indices in descending order of their scores. If two players have the same score, they should be ranked in ascending order of their indices. >>> rankings = PlayerRankings([40, 20, 60, 10]) >>> rankings.getRankings() [2, 0, 1, 3] >>> rankings.challenge(0, 1) >>> rankings.getRankings() [0, 2, 1, 3] from typing import List def __init__(self, scores: List[int]) -> None: pass def challenge(self, i: int, j: int) -> None: pass def getRankings(self) -> List[int]: pass","solution":"class PlayerRankings: def __init__(self, scores): Initializes the rankings with the given list of scores. self.scores = scores def challenge(self, i, j): Updates the scores after player \`i\` challenges player \`j\` and wins. self.scores[i] += self.scores[j] def getRankings(self): Returns an array of player indices in descending order of their scores. If two players have the same score, they should be ranked in ascending order of their indices. return sorted(range(len(self.scores)), key=lambda x: (-self.scores[x], x))"},{"question":"def is_path_exists(grid: List[List[int]]) -> bool: Returns true if there is a path from the top-left corner to the bottom-right corner of the grid. We can only move up, down, left, or right and only through cells that contain the value 1. >>> is_path_exists([[1, 0], [1, 1]]) True >>> is_path_exists([[1, 0], [0, 1]]) False >>> is_path_exists([[1]]) True >>> is_path_exists([[0, 1], [1, 1]]) False >>> is_path_exists([[1, 1], [1, 0]]) False >>> is_path_exists([[1, 0, 1, 1, 1], [1, 1, 1, 0, 1], [0, 0, 1, 1, 1], [1, 1, 0, 0, 1], [1, 1, 1, 1, 1]]) True >>> is_path_exists([[1, 0, 1, 1, 0], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1]]) False","solution":"def is_path_exists(grid): Returns true if there is a path from the top-left corner to the bottom-right corner of the grid. We can only move up, down, left, or right and only through cells that contain the value 1. m, n = len(grid), len(grid[0]) if grid[0][0] == 0 or grid[m-1][n-1] == 0: return False # Directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False]*n for _ in range(m)] def dfs(x, y): if x == m - 1 and y == n - 1: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1: if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"def searchInsert(nums: List[int], target: int) -> int: Returns the index of the target if found in the list, otherwise returns the index where the target should be inserted in order. Args: nums (list of int): The list of non-negative integers in ascending order. target (int): The target value to find or insert. Returns: int: The index of the target or the insertion position. >>> searchInsert([1, 3, 5, 6], 5) 2 >>> searchInsert([1, 3, 5, 6], 2) 1 >>> searchInsert([], 5) 0 >>> searchInsert([1], 0) 0 >>> searchInsert([1], 2) 1","solution":"def searchInsert(nums, target): Returns the index of the target if found in the list, otherwise returns the index where the target should be inserted in order. Args: nums (list of int): The list of non-negative integers in ascending order. target (int): The target value to find or insert. Returns: int: The index of the target or the insertion position. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def lengthOfLongestSubstring(s: str) -> int: Finds the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. Examples: >>> lengthOfLongestSubstring(\\"abcabcbb\\") 3 >>> lengthOfLongestSubstring(\\"bbbbb\\") 1 >>> lengthOfLongestSubstring(\\"pwwkew\\") 3","solution":"def lengthOfLongestSubstring(s): Finds the length of the longest substring without repeating characters. Args: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_length_subarray_product_one(arr: List[int]) -> int: Returns the maximum length of any subarray where the product of all its elements is 1. >>> max_length_subarray_product_one([1, -1, 1, 1, -1, 1]) 6 >>> max_length_subarray_product_one([1, -1, 1, -1, -1, 1]) 4 >>> max_length_subarray_product_one([1, 1, 1, 1]) 4 >>> max_length_subarray_product_one([-1, -1, -1, -1]) 4 >>> max_length_subarray_product_one([0, 0, 0, 0]) 0 >>> max_length_subarray_product_one([1, -1, 0, 1, 1, -1]) 2 >>> max_length_subarray_product_one([1, 1, 0, -1, -1]) 2 >>> max_length_subarray_product_one([1]) 1 >>> max_length_subarray_product_one([-1]) 0 >>> max_length_subarray_product_one([0]) 0","solution":"def max_length_subarray_product_one(arr): Returns the maximum length of any subarray where the product of all its elements is 1. max_len = 0 count_1 = 0 count_neg_ones = 0 first_neg_one_index = -1 last_neg_one_index = -1 for i, num in enumerate(arr): if num == 0: count_1 = 0 count_neg_ones = 0 first_neg_one_index = -1 last_neg_one_index = -1 else: if num == 1: count_1 += 1 elif num == -1: count_neg_ones += 1 if first_neg_one_index == -1: first_neg_one_index = i last_neg_one_index = i if count_neg_ones % 2 == 0: current_len = count_1 + count_neg_ones max_len = max(max_len, current_len) else: if first_neg_one_index != -1: current_len = i - first_neg_one_index max_len = max(max_len, current_len) return max_len"},{"question":"def can_create_string(s: str, x: int) -> bool: Returns True if it's possible to remove characters from s such that no two adjacent characters in the new string are the same and the total number of removed characters is a multiple of x. Otherwise, returns False. >>> can_create_string(\\"aabccd\\", 1) True >>> can_create_string(\\"abcdef\\", 1) True >>> can_create_string(\\"aaabbbccc\\", 3) True >>> can_create_string(\\"aabbcc\\", 4) False >>> can_create_string(\\"\\", 1) False >>> can_create_string(\\"aabccd\\", 0) False >>> can_create_string(\\"a\\", 1) True >>> can_create_string(\\"abcdefg\\", 2) True","solution":"def can_create_string(s, x): Returns True if it's possible to remove characters from s such that no two adjacent characters in the new string are the same and the total number of removed characters is a multiple of x. Otherwise, returns False. if not s or x <= 0: return False removed_count = 0 i = 1 # Iterate the string and count characters to be removed while i < len(s): if s[i] == s[i - 1]: removed_count += 1 i += 1 # Check if number of characters removed is a multiple of x return removed_count % x == 0"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Returns the maximum depth of the binary tree rooted at 'root'. >>> maxDepth(None) 0 >>> root = TreeNode(1) >>> maxDepth(root) 1 >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> maxDepth(root) 2 >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> maxDepth(root) 3 >>> root.left.left.left = TreeNode(7) >>> maxDepth(root) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of the binary tree rooted at 'root'. if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def product_except_self(arr): Given an array \`arr\` of positive integers, return an array \`result\` such that \`result[i]\` is the product of all elements in \`arr\` except \`arr[i]\`, without using division. The solution should be of linear time complexity and use constant space complexity (excluding the output array). >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([100, 200, 300]) [60000, 30000, 20000] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 0, 2, 3]) [0, 0, 0, 0] >>> product_except_self([]) [] pass","solution":"def product_except_self(arr): Returns an array \`result\` where result[i] is the product of all elements in \`arr\` except arr[i]. length = len(arr) if length == 0: return [] result = [1] * length # Calculate left products, each result[i] contains the product of all elements to the left of arr[i] left_product = 1 for i in range(length): result[i] = left_product left_product *= arr[i] # Calculate right products and update the result array right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"def minSteps(recipe: str, available: str) -> int: Calculate the minimum number of ingredient additions needed to be able to prepare the recipe. Parameters: recipe (str): The string representing a sequence of ingredients in a recipe. available (str): The string representing the ingredients currently available. Returns: int: The minimum number of ingredient additions needed. Examples: >>> minSteps(\\"ab\\", \\"ab\\") 0 >>> minSteps(\\"abac\\", \\"abc\\") 1 >>> minSteps(\\"abcd\\", \\"\\") 4 >>> minSteps(\\"xyz\\", \\"\\") 3 >>> minSteps(\\"abc\\", \\"abcd\\") 0 >>> minSteps(\\"aabbcc\\", \\"aabbc\\") 1 >>> minSteps(\\"aA\\", \\"aa\\") 1 >>> minSteps(\\"bB\\", \\"bb\\") 1 >>> minSteps(\\"\\", \\"abcdef\\") 0 >>> minSteps(\\"abc\\", \\"\\") 3","solution":"def minSteps(recipe, available): from collections import Counter recipe_count = Counter(recipe) available_count = Counter(available) steps = 0 for ingredient, count in recipe_count.items(): if available_count[ingredient] < count: steps += count - available_count[ingredient] return steps"},{"question":"def maximize_minimum(nums: List[int], k: int) -> int: Returns the maximum possible minimum value of the array after adding k to one element. >>> maximize_minimum([1, 3, 5], 2) == 3 >>> maximize_minimum([10, 4, 7], 5) == 9 >>> maximize_minimum([0, 0, 0], 1) == 1 >>> maximize_minimum([7, 7, 7], 3) == 10 >>> maximize_minimum([2, 2, 2, 8], 4) == 6 >>> maximize_minimum([1], 2) == 3 >>> maximize_minimum([1, 2, 3], 0) == 1 >>> maximize_minimum([0, 0, 0], 0) == 0 >>> maximize_minimum([5, 5, 5], 10) == 15","solution":"def maximize_minimum(nums, k): Returns the maximum possible minimum value of the array after adding k to one element. min_value = min(nums) return min_value + k"},{"question":"from typing import List, Tuple def k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[Tuple[int, int]]: Find the k pairs (u, v) from nums1 and nums2 with the smallest sums. >>> k_smallest_pairs([1, 7, 11], [2, 4, 6], 3) [(1, 2), (1, 4), (1, 6)] >>> k_smallest_pairs([1, 1, 2], [1, 2, 3], 2) [(1, 1), (1, 1)] >>> k_smallest_pairs([1, 2], [3], 3) [(1, 3), (2, 3)] >>> k_smallest_pairs([], [2, 4, 6], 3) [] >>> k_smallest_pairs([1, 7, 11], [], 3) [] >>> k_smallest_pairs([1, 7], [2, 4, 6], 10) [(1, 2), (1, 4), (1, 6), (7, 2), (7, 4), (7, 6)]","solution":"import heapq from typing import List, Tuple def k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[Tuple[int, int]]: Find the k pairs (u, v) from nums1 and nums2 with the smallest sums. if not nums1 or not nums2: return [] min_heap = [] for i in range(min(len(nums1), k)): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) result = [] while k > 0 and min_heap: _, i, j = heapq.heappop(min_heap) result.append((nums1[i], nums2[j])) if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1)) k -= 1 return result"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Find the largest rectangular area in a histogram represented by heights. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([2, 2, 2, 2]) 8 >>> largest_rectangle_area([4, 3, 6, 5, 2, 4]) 12 >>> largest_rectangle_area([1, 1, 1, 1, 1, 1, 1]) 7 >>> largest_rectangle_area([0, 0, 0, 0]) 0 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([4, 2, 0, 3, 2, 5]) 6","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed within the bounds made by the bars. :param heights: List of non-negative integers representing the heights of bars. :return: Integer representing the area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() current_area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, current_area) while stack: top_of_stack = stack.pop() current_area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, current_area) return max_area"},{"question":"def max_profit(profits: List[int]) -> int: Returns the maximum profit that can be earned by not taking jobs on two consecutive days. Args: profits (List[int]): List of integers where each integer represents the profit of completing a job on that day. Returns: int: Maximum profit that can be earned. >>> max_profit([]) == 0 >>> max_profit([5]) == 5 >>> max_profit([10]) == 10 >>> max_profit([5, 1]) == 5 >>> max_profit([1, 5]) == 5 >>> max_profit([5, 5]) == 5 >>> max_profit([1, 2, 3, 1]) == 4 >>> max_profit([2, 7, 9, 3, 1]) == 12 >>> max_profit([3, 2, 5, 10, 7]) == 15 >>> max_profit([6, 7, 1, 30, 8, 2, 4]) == 41 >>> max_profit([5, 5, 5, 5, 5]) == 15 >>> max_profit([1, 100, 1, 100, 1]) == 200 >>> max_profit([0, 0, 0, 0, 0]) == 0","solution":"def max_profit(profits): Returns the maximum profit that can be earned by not taking jobs on two consecutive days. Args: profits (List[int]): List of integers where each integer represents the profit of completing a job on that day. Returns: int: Maximum profit that can be earned. n = len(profits) if n == 0: return 0 if n == 1: return profits[0] max_prof = [0] * n max_prof[0] = profits[0] max_prof[1] = max(profits[0], profits[1]) for i in range(2, n): max_prof[i] = max(max_prof[i-1], max_prof[i-2] + profits[i]) return max_prof[-1]"},{"question":"def can_split_into_k_subarrays(arr, k): Determines if the array can be split into k non-empty subarrays with the same sum. Parameters: arr (list of int): The array of integers. k (int): The number of subarrays. Returns: bool: True if it is possible to split the array as described, else False. Examples: >>> can_split_into_k_subarrays([2, 2, 2, 2], 2) True >>> can_split_into_k_subarrays([1, 2, 3, 4], 3) False","solution":"def can_split_into_k_subarrays(arr, k): Determines if the array can be split into k non-empty subarrays with the same sum. Parameters: arr (list of int): The array of integers. k (int): The number of subarrays. Returns: bool: True if it is possible to split the array as described, else False. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k current_sum, subarray_count = 0, 0 for num in arr: current_sum += num if current_sum == target_sum: subarray_count += 1 current_sum = 0 elif current_sum > target_sum: return False return subarray_count == k"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the list that add up to the target. :param nums: List of integers :param target: Integer target sum :return: List containing the indices of the two numbers that add up to the target, or an empty list if no such pair exists >>> two_sum([2, 7, 11, 15], 9) == [0, 1] >>> two_sum([3, 2, 4], 6) == [1, 2] >>> two_sum([3, 3], 6) == [0, 1] >>> two_sum([2, 7, 11, 15], 20) == [] >>> two_sum([1, 2, 5], 10) == [] >>> two_sum([1, 2, 3, 4, 4], 8) == [3, 4] >>> two_sum([1], 2) == [] >>> two_sum([], 2) == [] >>> two_sum([1, -1, 2, -2], 0) == [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. :param nums: List of integers :param target: Integer target sum :return: List containing the indices of the two numbers that add up to the target, or an empty list if no such pair exists num_to_index = {} # A dictionary to store number and its index for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], index]) num_to_index[num] = index return []"},{"question":"def count_k_palin_substrings(s: str, k: int) -> int: Return the number of k-palin substrings in the string s. A k-palin is a substring that can be rearranged to form a palindrome with at most k characters having an odd frequency. >>> count_k_palin_substrings(\\"\\", 1) == 0 >>> count_k_palin_substrings(\\"a\\", 1) == 1 >>> count_k_palin_substrings(\\"aaaa\\", 0) == 10 >>> count_k_palin_substrings(\\"aa\\", 0) == 3 >>> count_k_palin_substrings(\\"aabb\\", 1) == 10 >>> count_k_palin_substrings(\\"abcd\\", 0) == 4 >>> count_k_palin_substrings(\\"aabb\\", 2) == 10","solution":"from collections import Counter def is_k_palin(substring, k): Helper function to check if the substring can be rearranged to form a k-palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. For k-palindrome, it's allowed to have up to k characters with odd counts. count = Counter(substring) odd_counts = sum(1 for cnt in count.values() if cnt % 2 != 0) return odd_counts // 2 <= k def count_k_palin_substrings(s, k): Returns the number of k-palin substrings in the given string s. n = len(s) k_palin_count = 0 # Iterate through all possible substrings for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] if is_k_palin(substring, k): k_palin_count += 1 return k_palin_count"},{"question":"def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the array nums to the right by k steps. The array nums represents a circular queue. :param nums: List[int], the array to be rotated :param k: int, the number of steps to rotate the array :return: List[int], the rotated array >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 8) [3, 4, 5, 1, 2] >>> rotate_array([1], 3) [1] >>> rotate_array([1, 2], 1) [2, 1] >>> rotate_array([1, 2], 2) [1, 2] >>> rotate_array([1, 2], 3) [2, 1]","solution":"def rotate_array(nums, k): Rotates the array nums to the right by k steps. :param nums: List[int], the array to be rotated :param k: int, the number of steps to rotate the array :return: List[int], the rotated array n = len(nums) k = k % n # In case k is greater than the length of nums return nums[-k:] + nums[:-k]"},{"question":"def spiralOrder(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in a clockwise spiral order. >>> spiralOrder([ ... [ 1, 2, 3, 4], ... [12, 13, 14, 5], ... [11, 16, 15, 6], ... [10, 9, 8, 7] ... ]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] >>> spiralOrder([ ... [1, 2], ... [4, 3] ... ]) == [1, 2, 3, 4]","solution":"def spiralOrder(matrix): Returns the elements of the matrix in a clockwise spiral order. if not matrix: return [] m, n = len(matrix), len(matrix[0]) result = [] top, bottom, left, right = 0, m - 1, 0, n - 1 while top <= bottom and left <= right: for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def clone_linked_list(head): Clone a linked list with cycles and random pointers. Return the head of the cloned linked list. >>> clone_linked_list(None) is None True >>> node = Node(1) >>> cloned_head = clone_linked_list(node) >>> cloned_head is not node True >>> cloned_head.val == 1 True >>> cloned_head.next is None True >>> cloned_head.random is None True pass","solution":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def clone_linked_list(head): if not head: return None # Create a dictionary to hold original nodes and their clones old_to_new = {} # First, create all the nodes current = head while current: clone = Node(current.val) old_to_new[current] = clone current = current.next # Now, set the next and random references current = head while current: if current.next: old_to_new[current].next = old_to_new[current.next] if current.random: old_to_new[current].random = old_to_new[current.random] current = current.next # Return the cloned head return old_to_new[head]"},{"question":"def identify_high_spenders(transactionLog): Identifies users who have processed transactions totaling more than 10,000. Parameters: transactionLog (list of str): List of transactions where each transaction is in the format \\"user_id:amount\\". Returns: dict: Dictionary with user_id as key and their total transaction amount as the value for users who have exceeded the 10,000 threshold. from solution import identify_high_spenders def test_identify_high_spenders_single_transaction(): transactionLog = [\\"user1:5000\\", \\"user2:11000\\", \\"user3:15000\\"] result = identify_high_spenders(transactionLog) assert result == {\\"user2\\": 11000, \\"user3\\": 15000} def test_identify_high_spenders_multiple_transactions(): transactionLog = [\\"user1:5000\\", \\"user1:6000\\", \\"user2:4000\\", \\"user2:7000\\", \\"user3:2000\\"] result = identify_high_spenders(transactionLog) assert result == {\\"user1\\": 11000, \\"user2\\": 11000} def test_identify_high_spenders_no_high_spenders(): transactionLog = [\\"user1:5000\\", \\"user2:4000\\", \\"user3:2000\\"] result = identify_high_spenders(transactionLog) assert result == {} def test_identify_high_spenders_exactly_10000(): transactionLog = [\\"user1:5000\\", \\"user1:5000\\", \\"user2:10000\\"] result = identify_high_spenders(transactionLog) assert result == {} def test_identify_high_spenders_empty_list(): transactionLog = [] result = identify_high_spenders(transactionLog) assert result == {}","solution":"def identify_high_spenders(transactionLog): Identifies users who have processed transactions totaling more than 10,000. Parameters: transactionLog (list of str): List of transactions where each transaction is in the format \\"user_id:amount\\". Returns: dict: Dictionary with user_id as key and their total transaction amount as the value for users who have exceeded the 10,000 threshold. user_totals = {} for transaction in transactionLog: user_id, amount = transaction.split(':') amount = int(amount) if user_id in user_totals: user_totals[user_id] += amount else: user_totals[user_id] = amount high_spenders = {user_id: total for user_id, total in user_totals.items() if total > 10000} return dict(sorted(high_spenders.items()))"},{"question":"def is_path_possible(grid: List[List[int]]) -> bool: Given a matrix of integers \`grid\` representing a 2D grid of integers, determine if there is a path from the top-left corner to the bottom-right corner (both inclusive) that only moves up, down, left, or right, and only travels through non-negative cells (cells with value >= 0). Return \`true\` if such a path exists, or \`false\` otherwise. >>> is_path_possible([ [0, 1, 1], [1, 0, -1], [1, 1, 0] ]) True >>> is_path_possible([ [0, 1, -1], [-1, 0, -1], [1, -1, 0] ]) False >>> is_path_possible([ [0, -1], [-1, 0] ]) False >>> is_path_possible([ [0, 1], [1, 0] ]) True >>> is_path_possible([ [0, 1, 1, -1], [1, -1, 1, 1], [1, 1, -1, 1], [-1, 1, 1, 0] ]) True >>> is_path_possible([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) True >>> is_path_possible([ [-1] ]) False >>> is_path_possible([ [0] ]) True >>> is_path_possible([ [-1, 1], [1, 0] ]) False >>> is_path_possible([ [0, 1], [1, -1] ]) False","solution":"def is_path_possible(grid): rows = len(grid) cols = len(grid[0]) if grid[0][0] < 0 or grid[rows-1][cols-1] < 0: return False def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] >= 0 def dfs(x, y, visited): if (x, y) == (rows-1, cols-1): return True visited.add((x, y)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: if dfs(nx, ny, visited): return True visited.discard((x, y)) return False return dfs(0, 0, set())"},{"question":"def minSwapsToSort(arr: List[int]) -> int: Returns the minimum number of adjacent swaps required to sort the array. >>> minSwapsToSort([4, 3, 2, 1]) 2 >>> minSwapsToSort([0, 1, 2, 3]) 0 >>> minSwapsToSort([3, 2, 1, 0]) 2 >>> minSwapsToSort([0]) 0 >>> minSwapsToSort([1, 0]) 1 >>> minSwapsToSort([1, 0, 3, 2]) 2","solution":"def minSwapsToSort(arr): Returns the minimum number of adjacent swaps required to sort the array. n = len(arr) # Pair the element with its initial index in the array arrpos = [(val, idx) for idx, val in enumerate(arr)] # Sort the array by the array values arrpos.sort() # To keep track of visited elements visited = {i: False for i in range(n)} swaps = 0 for i in range(n): # If the element is already in the correct place or already visited if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arrpos[x][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"from typing import List def can_find_subsequence_with_diff(arr: List[int], d: int) -> bool: Determine if there exists a subsequence of \`arr\` such that the absolute difference between any two consecutive elements of the subsequence is at most \`d\`. Args: arr (List[int]): An integer array consisting of \`n\` elements. d (int): An integer representing the allowed difference. Returns: bool: \`True\` if such a subsequence exists, and \`False\` otherwise. Examples: >>> can_find_subsequence_with_diff([5, 1, 9, 7], 2) True >>> can_find_subsequence_with_diff([1, 2, 3, 4, 5], 0) False","solution":"def can_find_subsequence_with_diff(arr, d): if not arr: return False arr.sort() for i in range(len(arr) - 1): if abs(arr[i+1] - arr[i]) <= d: return True return False"},{"question":"def find_longest_word(s: str, dict: List[str]) -> str: Given a string s and an array of strings dict, return the longest string in dict that can be formed by deleting some of the characters of s. If there are multiple strings with the same length, return the lexicographically smallest one. If there is no possible result, return an empty string. >>> find_longest_word(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) \\"apple\\" >>> find_longest_word(\\"abc\\", [\\"def\\", \\"ghi\\"]) \\"\\" >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"a\\" >>> find_longest_word(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"\\" >>> find_longest_word(\\"abpcplea\\", []) \\"\\" >>> find_longest_word(\\"applepenapple\\", [\\"pen\\", \\"applepen\\", \\"apple\\", \\"applen\\"]) \\"applepen\\"","solution":"def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) def find_longest_word(s, dict): dict.sort(key=lambda x: (-len(x), x)) for word in dict: if is_subsequence(word, s): return word return \\"\\""},{"question":"class MovieReservationSystem: A class to manage a movie theater reservation system where customers can book, cancel, and query seats for shows. The theater has a fixed number of rows and seats per row, both numbered starting from 1. Each show has its own seating arrangement. Methods: - addShow(showId): Adds a new show to the system with the given showId, initializing its seating arrangement. - bookSeat(showId, row, seat): Books the seat at row and seat for the show with showId. Returns True if the booking is successful, or False if the seat is already booked or the show does not exist. - cancelSeat(showId, row, seat): Cancels the booking of the seat at row and seat for the show with showId. Returns True if the cancellation is successful, or False if the seat is not booked or the show does not exist. - checkAvailability(showId, row, seat): Checks the availability of the seat at row and seat for the show with showId. Returns \\"Available\\" if the seat is not booked, \\"Booked\\" if the seat is already booked, or \\"Show not found\\" if the show does not exist. - getTotalSeatCount(showId): Returns the total number of seats available and the total number of seats booked for the show with showId as a 2-element array [availableSeats, bookedSeats]. Returns [-1, -1] if the show does not exist. def __init__(self, numRows, numSeatsPerRow): pass def addShow(self, showId): pass def bookSeat(self, showId, row, seat): pass def cancelSeat(self, showId, row, seat): pass def checkAvailability(self, showId, row, seat): pass def getTotalSeatCount(self, showId): pass # Test cases to verify the implementation def test_movie_reservation_system(): system = MovieReservationSystem(10, 10) # Test adding a show system.addShow(\\"Show1\\") assert \\"Show1\\" in system.shows # Test booking a seat assert system.bookSeat(\\"Show1\\", 1, 1) == True assert system.bookSeat(\\"Show1\\", 1, 1) == False assert system.bookSeat(\\"InvalidShow\\", 1, 1) == False assert system.bookSeat(\\"Show1\\", 11, 1) == False assert system.bookSeat(\\"Show1\\", 1, 11) == False # Test cancelling a seat assert system.cancelSeat(\\"Show1\\", 1, 1) == True assert system.cancelSeat(\\"Show1\\", 1, 1) == False assert system.cancelSeat(\\"InvalidShow\\", 1, 1) == False assert system.cancelSeat(\\"Show1\\", 11, 1) == False assert system.cancelSeat(\\"Show1\\", 1, 11) == False # Test checking availability assert system.checkAvailability(\\"Show1\\", 1, 1) == \\"Available\\" system.bookSeat(\\"Show1\\", 1, 1) assert system.checkAvailability(\\"Show1\\", 1, 1) == \\"Booked\\" assert system.checkAvailability(\\"InvalidShow\\", 1, 1) == \\"Show not found\\" assert system.checkAvailability(\\"Show1\\", 11, 1) == \\"Invalid seat\\" assert system.checkAvailability(\\"Show1\\", 1, 11) == \\"Invalid seat\\" # Test getting total seat count assert system.getTotalSeatCount(\\"Show1\\") == [99, 1] assert system.getTotalSeatCount(\\"InvalidShow\\") == [-1, -1] # Test booking and total seat count system.addShow(\\"Show2\\") for row in range(1, 11): for seat in range(1, 11): system.bookSeat(\\"Show2\\", row, seat) assert system.getTotalSeatCount(\\"Show2\\") == [0, 100]","solution":"class MovieReservationSystem: def __init__(self, numRows, numSeatsPerRow): self.numRows = numRows self.numSeatsPerRow = numSeatsPerRow self.shows = {} def addShow(self, showId): self.shows[showId] = [[False] * self.numSeatsPerRow for _ in range(self.numRows)] def bookSeat(self, showId, row, seat): if showId not in self.shows: return False if row < 1 or row > self.numRows or seat < 1 or seat > self.numSeatsPerRow: return False if self.shows[showId][row-1][seat-1]: return False self.shows[showId][row-1][seat-1] = True return True def cancelSeat(self, showId, row, seat): if showId not in self.shows: return False if row < 1 or row > self.numRows or seat < 1 or seat > self.numSeatsPerRow: return False if not self.shows[showId][row-1][seat-1]: return False self.shows[showId][row-1][seat-1] = False return True def checkAvailability(self, showId, row, seat): if showId not in self.shows: return \\"Show not found\\" if row < 1 or row > self.numRows or seat < 1 or seat > self.numSeatsPerRow: return \\"Invalid seat\\" if self.shows[showId][row-1][seat-1]: return \\"Booked\\" else: return \\"Available\\" def getTotalSeatCount(self, showId): if showId not in self.shows: return [-1, -1] totalSeats = self.numRows * self.numSeatsPerRow bookedSeats = sum(map(sum, self.shows[showId])) availableSeats = totalSeats - bookedSeats return [availableSeats, bookedSeats]"},{"question":"def min_days_to_complete_tasks(days: List[int], n: int) -> int: Calculate the minimum number of days required to complete all tasks. Args: days (List[int]): Array representing the number of tasks on each day. n (int): Maximum number of consecutive working days allowed. Returns: int: Minimum number of days required to complete all tasks. pass from solution import min_days_to_complete_tasks def test_min_days_to_complete_tasks_no_rest(): assert min_days_to_complete_tasks([1, 2, 3, 4, 5], 5) == 5 def test_min_days_to_complete_tasks_with_rest(): assert min_days_to_complete_tasks([1, 2, 3, 4, 5], 2) == 7 assert min_days_to_complete_tasks([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == 13 def test_min_days_small_array(): assert min_days_to_complete_tasks([1], 3) == 1 assert min_days_to_complete_tasks([1, 2], 2) == 2 def test_min_days_all_rest_days(): assert min_days_to_complete_tasks([1, 2, 3, 4, 5, 6, 7], 1) == 13 def test_min_days_exact_multiple_of_work_days(): assert min_days_to_complete_tasks([1, 2, 3, 4, 5, 6, 7, 8], 2) == 11","solution":"def min_days_to_complete_tasks(days, n): Calculate the minimum number of days required to complete all tasks. Args: days (List[int]): Array representing the number of tasks on each day. n (int): Maximum number of consecutive working days allowed. Returns: int: Minimum number of days required to complete all tasks. total_days = 0 index = 0 while index < len(days): total_days += min(n, len(days) - index) # work for n days or until the end of the array index += n # move the index n days forward if index < len(days): total_days += 1 # add a mandatory rest day return total_days"},{"question":"def trapRainwater(heights): Given an array of integers heights where heights[i] represents the height of the i-th building in a row, return the total amount of rainwater that can be trapped after it rains. Parameters: heights (list of int): List of building heights. Returns: int: Total amount of trapped rainwater. pass def test_empty_array(): assert trapRainwater([]) == 0 def test_no_trapped_water(): assert trapRainwater([1, 2, 3, 4, 5]) == 0 assert trapRainwater([5, 4, 3, 2, 1]) == 0 def test_basic_case(): assert trapRainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_flat_surface(): assert trapRainwater([3, 3, 3, 3, 3]) == 0 def test_high_peaks(): assert trapRainwater([5, 0, 5]) == 5 def test_varying_heights(): assert trapRainwater([4, 1, 3, 1, 5]) == 7","solution":"def trapRainwater(heights): Given an array of integers heights where heights[i] represents the height of the i-th building in a row, return the total amount of rainwater that can be trapped after it rains. Parameters: heights (list of int): List of building heights. Returns: int: Total amount of trapped rainwater. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"from typing import List def three_sum(arr: List[int], target: int) -> List[List[int]]: Find if there exist three elements in \`arr\` such that their sum is equal to \`target\`. Return all unique triplets in the array which gives the sum of \`target\`. Args: arr: List[int] - List of integers target: int - Target sum for the triplets Returns: List[List[int]] - List of unique triplets that sum up to the target >>> sorted(three_sum([-1, 0, 1, 2, -1, -4], 0)) == sorted([[-1, -1, 2], [-1, 0, 1]]) >>> sorted(three_sum([1, 1, -2, 2, 3, 0], 2)) == sorted([[-2, 1, 3], [0, 1, 1]]) >>> three_sum([], 0) == [] >>> three_sum([1, 2, 3, 4, 5], 50) == [] >>> sorted(three_sum([0, 0, 0, 0], 0)) == [[0, 0, 0]]","solution":"def three_sum(arr, target): Finds all unique triplets in the array which sum up to the target value. Args: arr: List[int] - List of integers target: int - Target sum for the triplets Returns: List[List[int]] - List of unique triplets that sum up to the target arr.sort() triplets = [] for i in range(len(arr) - 2): # Skip the same element to avoid duplicate triplets if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: triplets.append([arr[i], arr[left], arr[right]]) # Skip duplicates for \`left\` and \`right\` while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_gold_collect(node: TreeNode) -> int: Function to find the maximum amount of gold that can be collected by starting at any node and following a path (down or up). >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> max_gold_collect(root) 15 >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> max_gold_collect(root) 17","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_gold_collect(node): Function to find the maximum amount of gold that can be collected by starting at any node and following a path. def max_gain(node): if not node: return 0 # Recursively get the maximum gain from left and right subtrees left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # Current maximum path sum including the current node's value current_max_path = node.value + left_gain + right_gain # Update the global maximum gold amount max_gold_collect.max_gold = max(max_gold_collect.max_gold, current_max_path) # For recursion: return the maximum gain from either left or right path return node.value + max(left_gain, right_gain) max_gold_collect.max_gold = float('-inf') max_gain(node) return max_gold_collect.max_gold"},{"question":"def find_duplicates(arr): Given an array 'arr' of integers where some elements appear twice and others appear once, find all the elements that appear twice. Your algorithm should run in O(n) time and use only O(1) extra space. Return a list of integers that appear twice in the input array. You can assume that the elements in the array are in the range 1 to the length of the array. >>> find_duplicates([1, 2, 3, 4]) [] >>> find_duplicates([1, 2, 3, 2]) [2] >>> find_duplicates([1, 2, 3, 2, 3, 4, 5]) [2, 3] >>> find_duplicates([2, 2, 3, 3, 4, 4]) [2, 3, 4] >>> find_duplicates([1, 3, 2, 4, 1, 2]) [1, 2] >>> find_duplicates([]) [] >>> find_duplicates([1]) []","solution":"def find_duplicates(arr): Returns a list of integers that appear twice in the input array. result = [] for num in arr: index = abs(num) - 1 if arr[index] < 0: result.append(index + 1) arr[index] = -arr[index] return result"},{"question":"def max_profit(prices: List[int], d: int) -> int: You are given a 0-indexed integer array prices where prices[i] represents the price of a given item on the i-th day. You are also given an integer d. You want to buy an item on one of the days and sell it on another day such that the difference between the buying and selling days is greater than or equal to d. Your goal is to maximize your profit. Return the maximum profit you can achieve from these transactions. If no profit can be achieved, return 0. >>> max_profit([7, 1, 5, 3, 6, 4], 2) == 5 >>> max_profit([7, 6, 4, 3, 1], 2) == 0 >>> max_profit([1], 1) == 0 >>> max_profit([1, 5, 3, 6, 4], 0) == 5 >>> max_profit([3, 2, 6, 5, 0, 3], 10) == 0 >>> max_profit([3, 2, 6, 5, 0, 3], 1) == 4 >>> max_profit([5, 5, 5, 5, 5], 2) == 0","solution":"def max_profit(prices, d): Returns the maximum profit that can be achieved with a constraint on the difference between the buying and selling days. :param prices: List of integers represents the price of an item on the i-th day. :param d: Integer represents the minimum difference in days between buying and selling. :return: Maximum profit possible. n = len(prices) if n <= d: return 0 max_profit = 0 for buy_day in range(n - d): for sell_day in range(buy_day + d, n): profit = prices[sell_day] - prices[buy_day] max_profit = max(max_profit, profit) return max_profit"},{"question":"def maximal_square(grid: List[List[int]]) -> int: Computes the area of the largest square containing all 1's in the given binary matrix. :param grid: List[List[int]] - Binary matrix of size n x n :return: int - Area of the largest maximal square Examples: >>> maximal_square([]) 0 >>> maximal_square([[0, 0], [0, 0]]) 0 >>> maximal_square([[1, 1], [1, 1]]) 4 >>> maximal_square([[1, 0, 1], [1, 1, 1], [0, 1, 1]]) 4 >>> maximal_square([[1], [1], [1]]) 1 >>> maximal_square([[1, 1, 1]]) 1 >>> maximal_square([[1]]) 1 >>> maximal_square([[0]]) 0 >>> maximal_square([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) 4","solution":"def maximal_square(grid): Computes the area of the largest square containing all 1's in the given binary matrix. :param grid: List[List[int]] - Binary matrix of size n x n :return: int - Area of the largest maximal square if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def max_sum_of_subsequence(nums: List[int], k: int) -> int: Return the maximum sum of a non-empty subsequence of nums such that the maximum element of the subsequence appears at least k times in the subsequence. If no such subsequence exists, return -1. >>> max_sum_of_subsequence([1, 2, 3, 4, 5], 1) 5 >>> max_sum_of_subsequence([1, 2, 3, 4, 5], 2) -1","solution":"def max_sum_of_subsequence(nums, k): from collections import Counter # Count the frequency of each element in nums frequency = Counter(nums) # Filter out elements that appear at least k times valid_elements = [num for num, count in frequency.items() if count >= k] if not valid_elements: return -1 # Find the maximum element among valid elements max_element = max(valid_elements) # The maximum sum is max_element appearing exactly k times max_sum = max_element * k return max_sum"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string \`s\` of lowercase alphabets, return the length of the longest substring that contains no more than two distinct characters. >>> length_of_longest_substring_two_distinct('eceba') == 3 >>> length_of_longest_substring_two_distinct('ccaabbb') == 5 >>> length_of_longest_substring_two_distinct('abcabcabc') == 2 >>> length_of_longest_substring_two_distinct('aa') == 2 >>> length_of_longest_substring_two_distinct('aaabbb') == 6 >>> length_of_longest_substring_two_distinct('abaccc') == 4 >>> length_of_longest_substring_two_distinct(' ') == 1 >>> length_of_longest_substring_two_distinct('') == 0 >>> length_of_longest_substring_two_distinct('a') == 1 >>> length_of_longest_substring_two_distinct('ab') == 2 >>> length_of_longest_substring_two_distinct('aabbcc') == 4","solution":"def length_of_longest_substring_two_distinct(s): Given a string \`s\`, return the length of the longest substring that contains no more than two distinct characters. if not s: return 0 left, right = 0, 0 max_len = 0 char_map = {} while right < len(s): char_map[s[right]] = right right += 1 if len(char_map) > 2: del_idx = min(char_map.values()) del char_map[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def split_array(nums: List[int], m: int) -> int: Partition the array into one or more subarrays such that the maximum sum of any subarray is minimized. Args: nums: List of positive integers. m: Integer representing the maximum number of subarrays. Returns: The minimized maximum sum achievable by splitting the array at most \`m\` times. >>> split_array([7,2,5,10,8], 2) == 18 >>> split_array([1], 1) == 1 >>> split_array([3,3,3,3], 2) == 6 >>> split_array([1,2,3,4], 5) == 4 >>> split_array([5,5,5,5,10,10], 3) == 15","solution":"def split_array(nums, m): def can_split(max_sum): current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def find_duplicate_words(s: str) -> List[str]: Returns a list of duplicate words in the order they first appear in the string. >>> find_duplicate_words(\\"this is a test\\") [] >>> find_duplicate_words(\\"this is is a test\\") [\\"is\\"] >>> find_duplicate_words(\\"this test is a test this is a test\\") [\\"test\\", \\"this\\", \\"is\\", \\"a\\"] >>> find_duplicate_words(\\"each word here is unique\\") [] >>> find_duplicate_words(\\"\\") [] >>> find_duplicate_words(\\"this is a test Test test\\") [\\"test\\"] >>> find_duplicate_words(\\"hello world, hello world.\\") [\\"hello\\"]","solution":"def find_duplicate_words(s): Returns a list of duplicate words in the order they first appear in the string. words = s.split() word_count = {} duplicates = [] for word in words: if word in word_count: word_count[word] += 1 if word_count[word] == 2: # Add to duplicates list on the second occurrence duplicates.append(word) else: word_count[word] = 1 return duplicates"},{"question":"from typing import List def majority_element(nums: List[int]) -> int: Finds the majority element in the array nums. The majority element is the element that appears more than n // 2 times. This function uses the Boyer-Moore Voting Algorithm to achieve O(n) time complexity and O(1) space complexity. >>> majority_element([3, 2, 3]) 3 >>> majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> majority_element([1]) 1 >>> majority_element([6, 5, 5]) 5 >>> majority_element([7, 7, 7, 7, 7]) 7 >>> majority_element([1, 1, 1, 1, 0, 0, 0, 1, 1]) 1","solution":"def majority_element(nums): Finds the majority element in the array nums. The majority element is the element that appears more than n // 2 times. Uses the Boyer-Moore Voting Algorithm to achieve O(n) time complexity and O(1) space complexity. # Boyer-Moore Voting Algorithm count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Since the majority element is guaranteed to exist, we can return the candidate directly. return candidate"},{"question":"def find(parent, i): Finds the root of the set in which element i is present. Args: parent (List[int]): The parent list representing the union-find structure. i (int): The index of the element for which to find the root. Returns: int: The root of the set in which element i is present. ... def union(parent, rank, x, y): Unites the sets that contain x and y. Args: parent (List[int]): The parent list representing the union-find structure. rank (List[int]): The rank list representing the depth of the trees in the union-find structure. x (int): The first element. y (int): The second element. ... def smallestStringWithSwaps(s, pairs): Returns the lexicographically smallest string that can be obtained after any number of given swaps in any order. Args: s (str): The initial string. pairs (List[List[int]]): List of pairs of indices to swap. Returns: str: The lexicographically smallest string possible after swaps. >>> smallestStringWithSwaps(\\"cba\\", [[0, 1], [1, 2]]) 'abc' >>> smallestStringWithSwaps(\\"dcab\\", [[0, 3], [1, 2], [0, 2]]) 'abcd' >>> smallestStringWithSwaps(\\"dcab\\", [[0, 3], [1, 2]]) 'bacd' >>> smallestStringWithSwaps(\\"dcab\\", []) 'dcab' >>> smallestStringWithSwaps(\\"dcab\\", [[0, 3], [3, 0], [1, 2]]) 'bacd' ...","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def smallestStringWithSwaps(s, pairs): n = len(s) parent = list(range(n)) rank = [0] * n for i, j in pairs: union(parent, rank, i, j) from collections import defaultdict groups = defaultdict(list) for i in range(n): root = find(parent, i) groups[root].append(i) res = list(s) for key in groups: indices = groups[key] chars = [res[i] for i in indices] chars.sort() for i, char in zip(sorted(indices), chars): res[i] = char return ''.join(res)"},{"question":"def minDeletions(s: str) -> int: Determine the minimum number of deletions required so that no two adjacent characters are the same. Parameters: s (str): The input string consisting only of characters 'a', 'b', and 'c'. Returns: int: The minimum number of deletions required. Examples: >>> minDeletions(\\"aab\\") 1 >>> minDeletions(\\"aaaa\\") 3","solution":"def minDeletions(s): Determine the minimum number of deletions required so that no two adjacent characters are the same. Parameters: s (str): The input string consisting only of characters 'a', 'b', and 'c'. Returns: int: The minimum number of deletions required. if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"from typing import List def split_array_same_average(arr: List[int]) -> bool: Given an integer array \`arr\`, return true if and only if you can split the array into two non-empty subarrays left and right such that the average of elements in left is equal to the average of elements in right. >>> split_array_same_average([1, 2, 3, 4, 5, 6, 7, 8]) True >>> split_array_same_average([3, 1]) False >>> split_array_same_average([10]) False >>> split_array_same_average([1, 2, 9]) False >>> split_array_same_average([1, 7, 15, 29, 11, 9]) True >>> split_array_same_average([2, 2, 2, 2, 2, 2, 2]) True pass","solution":"def split_array_same_average(arr): Returns true if and only if you can split the array into two non-empty subarrays left and right such that the average of elements in left is equal to the average of elements in right. from itertools import combinations n = len(arr) total_sum = sum(arr) for size in range(1, n): if (total_sum * size) % n == 0: left_sum = (total_sum * size) // n if any(sum(comb) == left_sum for comb in combinations(arr, size)): return True return False"},{"question":"def knapsack(weights, values, W): Returns the maximum total value that can be accumulated without exceeding capacity W. :param weights: List of item weights. :param values: List of item values. :param W: Maximum capacity. :return: Maximum total value. >>> knapsack([1, 2, 3], [10, 15, 40], 5) 55 >>> knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7) 9 >>> knapsack([1, 2, 3], [10, 20, 30], 0) 0 >>> knapsack([2], [3], 2) 3 >>> knapsack([1, 2, 5, 6, 7], [1, 6, 18, 22, 28], 11) 40 >>> knapsack([1, 2, 3], [10, 20, 30], 6) 60","solution":"def knapsack(weights, values, W): Returns the maximum total value that can be accumulated without exceeding capacity W. :param weights: List of item weights. :param values: List of item values. :param W: Maximum capacity. :return: Maximum total value. n = len(weights) dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"def minPathSum(matrix): Returns the minimum sum of the path from top-left to bottom-right of the matrix, where you can only move right or down. >> minPathSum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 7 >> minPathSum([ [1, 2, 3] ]) 6 >> minPathSum([ [1], [2], [3] ]) 6 >> minPathSum([ [5] ]) 5 >> minPathSum([]) 0 >> minPathSum([ [1, 2, 5], [3, 2, 1] ]) 6","solution":"def minPathSum(matrix): Returns the minimum sum of the path from top-left to bottom-right of the matrix, where you can only move right or down. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill in the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"def generate_parentheses(n): Generates all combinations of well-formed parentheses of length 2n. >>> generate_parentheses(0) [\\"\\"] >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(4) [ \\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\" ]","solution":"def generate_parentheses(n): Generates all combinations of well-formed parentheses of length 2n. def backtrack(current, open_count, close_count): if len(current) == 2 * n: result.append(current) return if open_count < n: backtrack(current + \\"(\\", open_count + 1, close_count) if close_count < open_count: backtrack(current + \\")\\", open_count, close_count + 1) result = [] backtrack(\\"\\", 0, 0) return result"},{"question":"def smallest_subsequence(s: str, k: int) -> str: Returns the lexicographically smallest subsequence of length k that can be obtained by removing zero or more characters from s. >>> smallest_subsequence(\\"bcabc\\", 2) \\"ab\\" >>> smallest_subsequence(\\"cbbaac\\", 3) \\"aac\\" >>> smallest_subsequence(\\"aaaa\\", 1) \\"a\\" >>> smallest_subsequence(\\"abcdef\\", 3) \\"abc\\" >>> smallest_subsequence(\\"ababab\\", 2) \\"aa\\" >>> smallest_subsequence(\\"ddddddd\\", 3) \\"ddd\\"","solution":"def smallest_subsequence(s, k): Returns the lexicographically smallest subsequence of length k that can be obtained by removing zero or more characters from s. stack = [] # This will store the smallest subsequence to_remove = len(s) - k # Number of characters we can remove to get subsequence of length k for i, char in enumerate(s): # While stack is not empty, we need to ensure the characters in stack are in ascending order while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) return ''.join(stack[:k])"},{"question":"def replace_characters(s: str) -> str: Replaces every 'a' with 'b', every 'b' with 'c', and every 'c' with 'a' in the given string. Args: s (str): Input string consisting of only characters 'a', 'b', and 'c'. Returns: str: Modified string after replacements. >>> replace_characters(\\"aaa\\") == \\"bbb\\" >>> replace_characters(\\"bbb\\") == \\"ccc\\" >>> replace_characters(\\"ccc\\") == \\"aaa\\" >>> replace_characters(\\"abc\\") == \\"bca\\" >>> replace_characters(\\"cab\\") == \\"abc\\" >>> replace_characters(\\"cba\\") == \\"acb\\" >>> replace_characters(\\"\\") == \\"\\" pass","solution":"def replace_characters(s): Replaces every 'a' with 'b', every 'b' with 'c', and every 'c' with 'a' in the given string. Args: s (str): Input string consisting of only characters 'a', 'b', and 'c'. Returns: str: Modified string after replacements. translation_table = str.maketrans('abc', 'bca') return s.translate(translation_table)"},{"question":"def min_swaps_to_transform(s: str, t: str) -> int: Returns the minimum number of swaps required to transform string s into string t. If it is impossible, returns -1. >>> min_swaps_to_transform(\\"1100\\", \\"0011\\") == 2 >>> min_swaps_to_transform(\\"1100\\", \\"1100\\") == 0 >>> min_swaps_to_transform(\\"1110\\", \\"1011\\") == 1 >>> min_swaps_to_transform(\\"1100\\", \\"1111\\") == -1 >>> min_swaps_to_transform(\\"1100\\", \\"0000\\") == -1 >>> min_swaps_to_transform(\\"0110\\", \\"1001\\") == 2 >>> min_swaps_to_transform(\\"1010\\", \\"0101\\") == 2 >>> min_swaps_to_transform(\\"\\", \\"\\") == 0 >>> min_swaps_to_transform(\\"0\\", \\"1\\") == -1 >>> min_swaps_to_transform(\\"1\\", \\"1\\") == 0 >>> min_swaps_to_transform(\\"0\\", \\"0\\") == 0","solution":"def min_swaps_to_transform(s, t): Returns the minimum number of swaps required to transform string s into string t. If it is impossible, returns -1. if len(s) != len(t): return -1 # Count differences between \`s\` and \`t\` count_0_in_s = count_1_in_s = count_0_in_t = count_1_in_t = 0 for i in range(len(s)): if s[i] != t[i]: if s[i] == '0': count_0_in_s += 1 else: count_1_in_s += 1 if t[i] == '0': count_0_in_t += 1 else: count_1_in_t += 1 # Check if transformation is possible if count_0_in_s != count_0_in_t or count_1_in_s != count_1_in_t: return -1 # Number of swaps needed is the number of different '0's (or '1's) in s and t return count_0_in_s"},{"question":"def minimize_removed_elements_sum(arr): Modify the array to have all unique elements and return the minimized sum of removed elements. Args: arr (list): The input array which may contain duplicates. Returns: int: The sum of all removed elements to make all elements in the array unique. from solution import minimize_removed_elements_sum def test_no_duplicates(): assert minimize_removed_elements_sum([1, 2, 3]) == 0 def test_all_duplicates(): assert minimize_removed_elements_sum([1, 1, 1, 1]) == 3 assert minimize_removed_elements_sum([2, 2, 2, 2, 2]) == 8 def test_mixed_elements(): assert minimize_removed_elements_sum([1, 2, 2, 3, 3, 3]) == 8 assert minimize_removed_elements_sum([4, 5, 5, 5, 4, 4]) == 18 def test_single_element(): assert minimize_removed_elements_sum([10]) == 0 def test_empty_list(): assert minimize_removed_elements_sum([]) == 0","solution":"def minimize_removed_elements_sum(arr): Modify the array to have all unique elements and return the minimized sum of removed elements. Args: arr (list): The input array which may contain duplicates. Returns: int: The sum of all removed elements to make all elements in the array unique. from collections import Counter element_count = Counter(arr) removed_sum = 0 for element, count in element_count.items(): if count > 1: removed_sum += (count - 1) * element return removed_sum"},{"question":"def find_person_with_ball(n: int, k: int) -> int: Returns the number of the person who will receive the ball the k-th time in a circle of n people. >>> find_person_with_ball(5, 1) 1 >>> find_person_with_ball(5, 2) 2 >>> find_person_with_ball(5, 5) 5 >>> find_person_with_ball(5, 6) 1 >>> find_person_with_ball(5, 7) 2 >>> find_person_with_ball(5, 10) 5 >>> find_person_with_ball(1, 1) 1 >>> find_person_with_ball(1, 5) 1 >>> find_person_with_ball(100, 101) 1 >>> find_person_with_ball(100, 200) 100 >>> find_person_with_ball(100, 201) 1","solution":"def find_person_with_ball(n, k): Returns the number of the person who will receive the ball the k-th time in a circle of n people. # The ball is passed n times in a complete round. # The person who receives the k-th pass can be found using modulo arithmetic. return (k - 1) % n + 1"},{"question":"def shortest_palindrome(s: str) -> str: Given a string \`s\`, return the shortest palindromic substring that can be obtained by inserting the fewest number of characters at any position of the string. Note that a palindromic string reads the same forward and backward. >>> shortest_palindrome(\\"racecar\\") == \\"racecar\\" >>> shortest_palindrome(\\"aaa\\") == \\"aaa\\" >>> shortest_palindrome(\\"abcd\\") == \\"dcbabcd\\" >>> shortest_palindrome(\\"aacecaaa\\") == \\"aaacecaaa\\" >>> shortest_palindrome(\\"\\") == \\"\\" >>> shortest_palindrome(\\"a\\") == \\"a\\" >>> shortest_palindrome(\\"ab\\") == \\"bab\\" >>> shortest_palindrome(\\"Aa\\") == \\"aAa\\"","solution":"def shortest_palindrome(s): Returns the shortest palindromic substring that can be obtained by inserting the fewest number of characters at any position of the string. if s == s[::-1]: return s rev_s = s[::-1] for i in range(len(s)): if s.startswith(rev_s[i:]): return rev_s[:i] + s return \\"\\""},{"question":"def can_form_by_inserting_one_char(s1: str, s2: str) -> bool: Determine if s2 can be obtained by rearranging characters of s1 and inserting exactly one character. Args: s1 (str): The source string. s2 (str): The target string that should be checked. Returns: bool: True if s2 can be formed, otherwise False. >>> can_form_by_inserting_one_char(\\"abc\\", \\"abcc\\") True >>> can_form_by_inserting_one_char(\\"abc\\", \\"abcd\\") True >>> can_form_by_inserting_one_char(\\"abc\\", \\"abec\\") True >>> can_form_by_inserting_one_char(\\"abc\\", \\"aabbc\\") False >>> can_form_by_inserting_one_char(\\"abc\\", \\"cab\\") False >>> can_form_by_inserting_one_char(\\"abc\\", \\"dabce\\") False >>> can_form_by_inserting_one_char(\\"\\", \\"a\\") True >>> can_form_by_inserting_one_char(\\"a\\", \\"aa\\") True >>> can_form_by_inserting_one_char(\\"a\\", \\"ab\\") True >>> can_form_by_inserting_one_char(\\"a\\", \\"b\\") False >>> can_form_by_inserting_one_char(\\"abcd\\", \\"abcde\\") True >>> can_form_by_inserting_one_char(\\"abcd\\", \\"abcdde\\") False >>> can_form_by_inserting_one_char(\\"abcd\\", \\"eabcd\\") True","solution":"def can_form_by_inserting_one_char(s1, s2): Determine if s2 can be obtained by rearranging characters of s1 and inserting exactly one character. Args: s1 (str): The source string. s2 (str): The target string that should be checked. Returns: bool: True if s2 can be formed, otherwise False. if len(s2) != len(s1) + 1: return False # Count characters in both strings from collections import Counter count_s1 = Counter(s1) count_s2 = Counter(s2) # There should be exactly one character in s2 that is not in s1 before insertion extra_char_count = 0 for char in count_s2: if count_s2[char] > count_s1[char]: extra_char_count += count_s2[char] - count_s1[char] return extra_char_count == 1"},{"question":"def min_time_to_complete_tasks(nums: List[int]) -> int: Finds the minimum time required to complete all tasks if optimally assigned to two workers. :param nums: List[int] - An array where each element represents the amount of time a task takes to complete. :return: int - The minimum possible time required to complete all tasks. # Your implementation goes here from solution import min_time_to_complete_tasks def test_minimal(): assert min_time_to_complete_tasks([1]) == 1 def test_equal_tasks(): assert min_time_to_complete_tasks([2, 2, 2, 2]) == 4 def test_distributed_tasks(): assert min_time_to_complete_tasks([3, 1, 4, 3]) == 6 def test_varied_tasks(): assert min_time_to_complete_tasks([10, 20, 30, 40, 50, 60]) == 110 def test_two_tasks(): assert min_time_to_complete_tasks([5, 10]) == 10 def test_larger_set(): assert min_time_to_complete_tasks([1, 2, 3, 4, 5, 6, 7, 8]) == 18","solution":"def min_time_to_complete_tasks(nums): Finds the minimum time required to complete all tasks if optimally assigned to two workers. :param nums: List[int] - An array where each element represents the amount of time a task takes to complete. :return: int - The minimum possible time required to complete all tasks. nums.sort(reverse=True) worker_a_time = 0 worker_b_time = 0 for time in nums: if worker_a_time <= worker_b_time: worker_a_time += time else: worker_b_time += time return max(worker_a_time, worker_b_time)"},{"question":"from typing import List def running_sum(nums: List[int]) -> List[int]: Calculate the running sum of a 0-indexed integer array. Returns a list where runningSum[i] is the sum of the elements from nums[0] to nums[i]. >>> running_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> running_sum([5]) [5] >>> running_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> running_sum([3, -1, 4, -2, 2]) [3, 2, 6, 4, 6] >>> running_sum([]) []","solution":"def running_sum(nums): Returns the running sum of the given array. running_sum_array = [] current_sum = 0 for num in nums: current_sum += num running_sum_array.append(current_sum) return running_sum_array"},{"question":"def can_form_string(s: str, words: List[str]) -> bool: Determines whether the string \`s\` can be formed by concatenating each string in \`words\` exactly once and in any order. :param s: The target string. :param words: An array of strings. :return: True if \`s\` can be formed; False otherwise. >>> can_form_string(\\"helloworld\\", [\\"hello\\", \\"world\\"]) True >>> can_form_string(\\"abcabc\\", [\\"abc\\", \\"abc\\"]) True >>> can_form_string(\\"abccba\\", [\\"abc\\", \\"cba\\"]) True >>> can_form_string(\\"helloword\\", [\\"hello\\", \\"world\\"]) False >>> can_form_string(\\"abcde\\", [\\"abc\\", \\"ab\\", \\"de\\"]) False >>> can_form_string(\\"abcabc\\", [\\"abc\\", \\"abcd\\"]) False >>> can_form_string(\\"\\", []) True >>> can_form_string(\\"\\", [\\"\\"]) True >>> can_form_string(\\"a\\", [\\"\\"]) False >>> can_form_string(\\"a\\", [\\"a\\"]) True >>> can_form_string(\\"abc\\", [\\"abc\\"]) True >>> can_form_string(\\"abc\\", [\\"ab\\"]) False >>> can_form_string(\\"abc\\", [\\"abcd\\"]) False pass","solution":"def can_form_string(s, words): Determines whether the string \`s\` can be formed by concatenating each string in \`words\` exactly once and in any order. :param s: The target string. :param words: An array of strings. :return: True if \`s\` can be formed; False otherwise. from collections import Counter # Concatenate all words and check if its sorted characters match those in s concatenated_words = ''.join(words) if Counter(concatenated_words) == Counter(s): return True return False"},{"question":"def rearrange_string(s: str, k: int) -> str: Reorganize the string \`s\` such that the same characters are at least \`k\` distance apart. If it is not possible, return an empty string. >>> rearrange_string(\\"aabbcc\\", 3) 'abcabc' >>> rearrange_string(\\"aaabc\\", 2) 'abaca' >>> rearrange_string(\\"aaabc\\", 3) '' >>> rearrange_string(\\"aaabc\\", 0) 'aaabc' >>> rearrange_string(\\"a\\", 2) 'a' >>> rearrange_string(\\"aabbccdd\\", 2) 'abcdabcd' >>> rearrange_string(\\"aabb\\", 5) ''","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s, k): if k == 0: return s # Count the frequencies of each character char_count = Counter(s) # Use a max-heap to store the characters based on their frequency max_heap = [] for char, freq in char_count.items(): heappush(max_heap, (-freq, char)) result = [] queue = [] while max_heap: freq, char = heappop(max_heap) result.append(char) # Decrement the frequency queue.append((freq + 1, char)) if len(queue) >= k: f, c = queue.pop(0) if f < 0: heappush(max_heap, (f, c)) return ''.join(result) if len(result) == len(s) else ''"},{"question":"def numFullySurroundedIslands(grid) -> int: You are given an \`m x n\` binary matrix \`grid\`, where \`0\` represents a sea cell and \`1\` represents a land cell. An island is a maximal 4-directionally connected group of \`1\`s. The grid is said to be fully surrounded by \`0\`s if it contains no connected \`1\`s that are connected to the boundary of the grid. Write a function \`numFullySurroundedIslands(grid)\` that returns the number of fully surrounded islands in the grid. >>> numFullySurroundedIslands([ [1, 0, 0, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 0] ]) 1 >>> numFullySurroundedIslands([ [0, 0, 1, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ]) 1 >>> numFullySurroundedIslands([ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) 1 >>> numFullySurroundedIslands([]) 0 >>> numFullySurroundedIslands([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 1 >>> numFullySurroundedIslands([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0","solution":"def numFullySurroundedIslands(grid): if not grid or not grid[0]: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]: dfs(i + x, j + y) def is_on_boundary(i, j): return i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1 # Turn boundary-connected '1's and their connected components into '0's for i in range(len(grid)): for j in range(len(grid[0])): if is_on_boundary(i, j) and grid[i][j] == 1: dfs(i, j) # Count the fully surrounded islands count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: count += 1 dfs(i, j) return count"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Finds all the integers that appear twice in the nums array. >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([1, 1, 2, 2, 3, 3, 4, 4]) [1, 2, 3, 4] >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1, 1]) [1] >>> find_duplicates([1, 2, 2]) [2] >>> find_duplicates([3, 4, 5, 5, 6, 6]) [5, 6] >>> find_duplicates([]) [] >>> find_duplicates([1]) []","solution":"def find_duplicates(nums): Finds all the integers that appear twice in the nums array. Args: nums (List[int]): A list of integers. Returns: List[int]: A list of integers that appear twice in nums. # Result list to store duplicates duplicates = [] # Go through each number in nums for num in nums: # Find the index that corresponds to the number's value (1-based index) index = abs(num) - 1 if nums[index] < 0: # If the value at this index is negative, the number is a duplicate duplicates.append(abs(num)) else: # Mark the value at this index as seen by making it negative nums[index] = -nums[index] return duplicates"},{"question":"def two_sum(arr: List[int], target: int) -> List[int]: Finds the two indices in the list \`arr\` such that the numbers at those indices add up to \`target\`. Parameters: arr (list of int): List of integers. target (int): The target sum. Returns: list of int: The indices of the two numbers that add up to the target, in increasing order. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3], 7) [] >>> two_sum([-1, -2, -3, -4], -6) [1, 3] >>> two_sum([0, 4, 3, -2], 1) [2, 3] >>> two_sum([1, -1, 2, 3], 0) [0, 1] from solution import two_sum def test_two_sum_found(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_two_sum_no_solution(): assert two_sum([1, 2, 3], 7) == [] def test_two_sum_negative_numbers(): assert two_sum([-1, -2, -3, -4], -6) == [1, 3] def test_two_sum_with_zero(): assert two_sum([0, 4, 3, -2], 1) == [2, 3] def test_two_sum_target_zero(): assert two_sum([1, -1, 2, 3], 0) == [0, 1]","solution":"def two_sum(arr, target): Finds the two indices in the list \`arr\` such that the numbers at those indices add up to \`target\`. Parameters: arr (list of int): List of integers. target (int): The target sum. Returns: list of int: The indices of the two numbers that add up to the target, in increasing order. num_to_index = {} for index, num in enumerate(arr): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], index]) num_to_index[num] = index return []"},{"question":"from typing import List from collections import deque, defaultdict def max_graph_depth(n: int, edges: List[List[int]], start: int) -> int: Returns the maximum depth of the graph starting from the node \`start\`. Parameters: n (int): Number of vertices in the graph. edges (list of list of int): List of edges in the graph where edges[i] = [u, v] represents an undirected edge between the vertices u and v. start (int): Starting node to calculate the maximum depth from. Returns: int: Maximum depth of the graph from the starting node. Examples: >>> max_graph_depth(4, [[0, 1], [1, 2], [1, 3]], 0) 2 >>> max_graph_depth(5, [[0, 1], [1, 2], [3, 4]], 0) 2 >>> max_graph_depth(1, [], 0) 0 >>> max_graph_depth(5, [[0, 1], [1, 2], [2, 3], [3, 4]], 0) 4 >>> max_graph_depth(7, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]], 0) 2","solution":"from collections import deque, defaultdict def max_graph_depth(n, edges, start): Returns the maximum depth of the graph starting from the node \`start\`. Parameters: n (int): Number of vertices in the graph. edges (list of list of int): List of edges in the graph where edges[i] = [u, v] represents an undirected edge between the vertices u and v. start (int): Starting node to calculate the maximum depth from. Returns: int: Maximum depth of the graph from the starting node. if n == 0 or not edges: return 0 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() queue = deque([(start, 0)]) visited.add(start) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, depth + 1)) return max_depth"},{"question":"from typing import List def waterFlow(heights: List[List[int]]) -> List[List[int]]: Determine the list of coordinates where water can flow to both the Pacific and Atlantic oceans. >>> heights1 = [ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ] >>> sorted(waterFlow(heights1)) [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] >>> heights2 = [[1]] >>> waterFlow(heights2) [[0, 0]] >>> heights3 = [ ... [2, 1], ... [1, 2] ... ] >>> sorted(waterFlow(heights3)) [[0, 0], [0, 1], [1, 0], [1, 1]] >>> heights4 = [ ... [10, 10, 10], ... [10, 1, 10], ... [10, 10, 10] ... ] >>> sorted(waterFlow(heights4)) [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]] >>> heights5 = [] >>> waterFlow(heights5) []","solution":"from typing import List def waterFlow(heights: List[List[int]]) -> List[List[int]]: if not heights or not heights[0]: return [] m, n = len(heights), len(heights[0]) pacific_reachable = [[False] * n for _ in range(m)] atlantic_reachable = [[False] * n for _ in range(m)] def dfs(x, y, reachable): reachable[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not reachable[nx][ny] and heights[nx][ny] >= heights[x][y]: dfs(nx, ny, reachable) for i in range(m): dfs(i, 0, pacific_reachable) dfs(i, n - 1, atlantic_reachable) for j in range(n): dfs(0, j, pacific_reachable) dfs(m - 1, j, atlantic_reachable) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"def dailyTemperatures(T: List[int]) -> List[int]: Given a list of daily temperatures, returns a list where each element represents the number of days to wait for a warmer temperature. If there is no future day with a warmer temperature, returns 0 for that day. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([76, 75, 74, 73, 72, 71]) [0, 0, 0, 0, 0, 0] >>> dailyTemperatures([71, 72, 73, 74, 75, 76]) [1, 1, 1, 1, 1, 0] >>> dailyTemperatures([75]) [0] >>> dailyTemperatures([70, 70, 70, 70]) [0, 0, 0, 0] >>> dailyTemperatures([70, 80, 60, 70, 90]) [1, 3, 1, 1, 0]","solution":"def dailyTemperatures(T): Given a list of daily temperatures, returns a list where each element represents the number of days to wait for a warmer temperature. If there is no future day with a warmer temperature, returns 0 for that day. :param T: List[int] - List of daily temperatures. :return: List[int] - List of days to wait for a warmer temperature. n = len(T) answer = [0] * n stack = [] # Stack to store indices of the temperatures for i in range(n): # Check the stack and process until we find a lower temperature while stack and T[i] > T[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def coin_change(nums: List[int], target: int) -> int: Given a list of integers \`nums\` representing a set of coins and an integer \`target\`, return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return \`-1\`. For example: >>> coin_change([1, 2, 5], 11) == 3 >>> coin_change([2], 3) == -1 >>> coin_change([1], 0) == 0 >>> coin_change([1], 2) == 2 >>> coin_change([1, 2, 5], 100) == 20 >>> coin_change([1, 2, 5, 10, 25, 50], 1000) == 20","solution":"def coin_change(nums, target): Returns the fewest number of coins needed to make the target amount. If the target amount cannot be made up by any combination of the coins, returns -1. # Initializing the dp array with a value greater than any possible number of coins dp = [float('inf')] * (target + 1) # Base case: No coins needed to make 0 amount dp[0] = 0 for coin in nums: for i in range(coin, target + 1): dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[target] is still infinity, it means it's not possible to make that amount with the given coins return dp[target] if dp[target] != float('inf') else -1"},{"question":"def count_divisible_pairs(arr: List[int], k: int) -> int: Returns the number of distinct pairs (i, j) in the array such that arr[i] + arr[j] is divisible by k and i < j. >>> count_divisible_pairs([1, 2, 3, 4, 5], 3) == 4 >>> count_divisible_pairs([1, 2, 3], 7) == 0 >>> count_divisible_pairs([1, 2, 3, 4], 1) == 6 >>> count_divisible_pairs([2, 4, 6, 8], 2) == 6 >>> count_divisible_pairs([10**6, 2*10**6, 3*10**6, 4*10**6], 10**6) == 6 >>> count_divisible_pairs([5], 3) == 0 >>> count_divisible_pairs([], 5) == 0","solution":"def count_divisible_pairs(arr, k): Returns the number of distinct pairs (i, j) in the array such that arr[i] + arr[j] is divisible by k and i < j. Parameters: arr (list): The input list of integers. k (int): The integer divisor. Returns: int: The count of valid pairs. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"def distinct_substrings(s: str) -> int: Given a string \`s\`, return the total number of distinct non-empty substrings of \`s\` modulo 10^9 + 7. >>> distinct_substrings(\\"abc\\") == 6 >>> distinct_substrings(\\"aaa\\") == 3 >>> distinct_substrings(\\"abac\\") == 9 >>> distinct_substrings(\\"a\\") == 1 >>> distinct_substrings(\\"abc!@\\") == 15","solution":"def distinct_substrings(s): Returns the total number of distinct non-empty substrings of \`s\` modulo 10^9 + 7. MODULO = 10**9 + 7 n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) % MODULO"},{"question":"def min_deletions_to_beautiful(s: str, k: int) -> int: Determines the minimum number of deletions required to make the string beautiful, ensuring there are no adjacent characters in the string that are the same. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The maximum number of deletions allowed. Returns: int: The number of deletions needed to make the string beautiful, or -1 if it is not possible within k deletions. >>> min_deletions_to_beautiful(\\"aabb\\", 2) 2 >>> min_deletions_to_beautiful(\\"aabbcc\\", 3) 3 >>> min_deletions_to_beautiful(\\"abc\\", 1) 0 >>> min_deletions_to_beautiful(\\"aaabb\\", 1) -1 >>> min_deletions_to_beautiful(\\"aabb\\", 1) -1 >>> min_deletions_to_beautiful(\\"\\", 0) 0 >>> min_deletions_to_beautiful(\\"a\\", 0) 0 >>> min_deletions_to_beautiful(\\"aa\\", 1) 1 >>> min_deletions_to_beautiful(\\"aa\\", 0) -1","solution":"def min_deletions_to_beautiful(s, k): Determines the minimum number of deletions required to make the string beautiful, ensuring no more than 'k' deletions are performed. deletions = 0 n = len(s) if n == 0: return 0 i = 0 while i < n - 1: if s[i] == s[i + 1]: deletions += 1 i += 1 return deletions if deletions <= k else -1"},{"question":"def countUniquePairs(nums: List[int], target: int) -> int: Returns the number of unique pairs in the array \`nums\` whose sum is equal to \`target\`. >>> countUniquePairs([1, 2, 3, 4, 3, 2, 1], 5) 2 >>> countUniquePairs([1, 1, 1, 1], 2) 1 >>> countUniquePairs([1, 2, 3, 4, 5], 10) 0 >>> countUniquePairs([-1, -2, -3, 1, 2, 3], 0) 3 >>> countUniquePairs([1, 3, 2, 2, 4, 5], 6) 2 >>> countUniquePairs([], 5) 0 >>> countUniquePairs([5], 10) 0","solution":"def countUniquePairs(nums, target): Returns the number of unique pairs in the array \`nums\` whose sum is equal to \`target\`. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def max_balanced_groups(heights, k): Returns the maximum number of balanced groups that can be formed from the given heights with the condition that the absolute difference between the heights in any group is at most k. Args: heights (List[int]): A list of integers representing the heights of students. k (int): An integer representing the maximum allowed absolute difference in heights within a group. Returns: int: The maximum number of balanced groups that can be formed. Example Usage: >>> max_balanced_groups([1, 3, 5, 6], 2) 2 >>> max_balanced_groups([5], 2) 1","solution":"def max_balanced_groups(heights, k): Returns the maximum number of balanced groups that can be formed from the given heights with the condition that the absolute difference between the heights in any group is at most k. if not heights: return 0 groups = 1 min_height = heights[0] max_height = heights[0] for height in heights[1:]: if height < min_height: min_height = height if height > max_height: max_height = height if max_height - min_height > k: groups += 1 min_height = height max_height = height return groups"},{"question":"def rearrange_string(s: str) -> str: Rearranges the input string so that all digits are moved to the end while maintaining the order of both the letters and digits. >>> rearrange_string(\\"\\") \\"\\" >>> rearrange_string(\\"abc\\") \\"abc\\" >>> rearrange_string(\\"123\\") \\"123\\" >>> rearrange_string(\\"a3c2b1\\") \\"acb321\\" >>> rearrange_string(\\"4d5e3a\\") \\"dea453\\" >>> rearrange_string(\\"abc123\\") \\"abc123\\" >>> rearrange_string(\\"123abc\\") \\"abc123\\"","solution":"def rearrange_string(s): Rearranges the input string so that all digits are moved to the end while maintaining the order of both the letters and digits. Args: s (str): Input string containing letters and digits. Returns: str: String with all digits grouped together at the end. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters) + ''.join(digits)"},{"question":"def longest_unique_concatenated_string(strings: List[str]) -> str: Returns the longest string that can be constructed by concatenating any subset of the given strings such that each string in the resulting concatenated string appears exactly once. If multiple longest strings exist, return the lexicographically smallest one. Return an empty string if no valid string can be formed. >>> longest_unique_concatenated_string([\\"abc\\"]) == \\"abc\\" >>> longest_unique_concatenated_string([\\"abc\\", \\"def\\", \\"g\\"]) == \\"abcdefg\\" >>> longest_unique_concatenated_string([\\"aa\\", \\"bb\\", \\"cc\\"]) == \\"\\" >>> longest_unique_concatenated_string([\\"a\\", \\"ab\\", \\"bc\\"]) == \\"abc\\" >>> longest_unique_concatenated_string([\\"ab\\", \\"ba\\", \\"cd\\"]) == \\"abcd\\" >>> longest_unique_concatenated_string([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]) == \\"abcdefghijklmnop\\" >>> longest_unique_concatenated_string([]) == \\"\\" >>> longest_unique_concatenated_string([\\"a\\", \\"bc\\", \\"de\\", \\"fg\\", \\"hij\\"]) == \\"abcdefghij\\"","solution":"def longest_unique_concatenated_string(strings): Returns the longest string that can be constructed by concatenating any subset of the given strings such that each string in the resulting concatenated string appears exactly once. If multiple longest strings exist, return the lexicographically smallest one. Return an empty string if no valid string can be formed. from itertools import combinations def is_unique(s): return len(s) == len(set(s)) sorted_strings = sorted(strings) # Sort to ensure lexicographical order max_len = 0 result = \\"\\" # Check all subsets of different lengths for r in range(1, len(strings) + 1): for subset in combinations(sorted_strings, r): combined = ''.join(subset) if is_unique(combined): if len(combined) > max_len or (len(combined) == max_len and combined < result): max_len = len(combined) result = combined return result"},{"question":"class EventTracker: A class to track 'start' and 'end' events and provide analytics on them. Methods: - addEvent(event_type: str, timestamp: int): Records an event. - getAverageStartToEndTime() -> float: Returns the average time elapsed between 'start' and 'end' events. - getIncompleteEventCount() -> int: Returns the count of 'start' events without corresponding 'end' events. >>> tracker = EventTracker() >>> tracker.addEvent(\\"start\\", 1) >>> tracker.addEvent(\\"end\\", 2) >>> tracker.getAverageStartToEndTime() 1.0 >>> tracker.getIncompleteEventCount() 0 >>> tracker.addEvent(\\"start\\", 3) >>> tracker.getAverageStartToEndTime() 1.0 >>> tracker.getIncompleteEventCount() 1 def __init__(self): pass def addEvent(self, event_type: str, timestamp: int): pass def getAverageStartToEndTime(self) -> float: pass def getIncompleteEventCount(self) -> int: pass","solution":"class EventTracker: def __init__(self): self.events = [] self.start_times = [] def addEvent(self, event_type, timestamp): Records an event with the given event_type and timestamp. self.events.append((event_type, timestamp)) if event_type == \\"start\\": self.start_times.append(timestamp) elif event_type == \\"end\\": self.start_times.sort() self.events.sort(key=lambda x: x[1]) earliest_start = self.start_times.pop(0) def getAverageStartToEndTime(self): Returns the average time elapsed between each 'start' and the corresponding 'end' event. If there are no complete start-end pairs, return 0.0. start_times = [] start_end_pairs = [] self.events.sort(key=lambda x: x[1]) for event_type, timestamp in self.events: if event_type == \\"start\\": start_times.append(timestamp) elif event_type == \\"end\\": if start_times: start_time = start_times.pop(0) start_end_pairs.append(timestamp - start_time) if not start_end_pairs: return 0.0 return sum(start_end_pairs) / len(start_end_pairs) def getIncompleteEventCount(self): Returns the count of 'start' events that do not have a corresponding 'end' event. start_times = [] self.events.sort(key=lambda x: x[1]) for event_type, timestamp in self.events: if event_type == \\"start\\": start_times.append(timestamp) elif event_type == \\"end\\": if start_times: start_times.pop(0) return len(start_times)"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Given an array of integers, finds and returns the largest sum of any contiguous subarray. If the array contains only negative numbers, returns the single largest number. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(nums): Returns the largest sum of any contiguous subarray. If the array contains only negative numbers, returns the single largest number. if not nums: return 0 current_subarray_sum = max_subarray_sum = nums[0] for num in nums[1:]: current_subarray_sum = max(num, current_subarray_sum + num) max_subarray_sum = max(max_subarray_sum, current_subarray_sum) return max_subarray_sum"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_numbers(root): Returns the sum of all the numbers formed by the root-to-leaf paths in the binary tree. def test_single_node_tree(): root = TreeNode(1) assert sum_numbers(root) == 1 def test_two_level_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert sum_numbers(root) == 25 # 12 + 13 def test_three_level_tree(): root = TreeNode(4) root.left = TreeNode(9) root.right = TreeNode(0) root.left.left = TreeNode(5) root.left.right = TreeNode(1) assert sum_numbers(root) == 1026 # 495 + 491 + 40 def test_unbalanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert sum_numbers(root) == 123 def test_no_nodes(): assert sum_numbers(None) == 0","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_numbers(root): Returns the sum of all the numbers formed by the root-to-leaf paths in the binary tree. def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.value # If it's a leaf node, return the current number if not node.left and not node.right: return current_number # Otherwise, sum up the values from left and right subtrees left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"def knapsack(values, weights, capacity): Determines the maximum total value of items that can be included in the knapsack without exceeding the weight capacity. :param values: List of values of the items. :param weights: List of weights of the items. :param capacity: Maximum weight capacity of the knapsack. :return: Integer, the maximum total value. >>> knapsack([60, 100, 120], [10, 20, 30], 50) 220 >>> knapsack([], [], 50) 0 >>> knapsack([60, 100, 120], [10, 20, 30], 0) 0 >>> knapsack([60], [10], 10) 60 >>> knapsack([60], [10], 5) 0 >>> knapsack([10, 40, 30, 50], [5, 4, 6, 3], 10) 90 >>> knapsack([10, 20, 30], [1, 2, 3], 6) 60","solution":"def knapsack(values, weights, capacity): Determines the maximum total value of items that can be included in the knapsack without exceeding the weight capacity. :param values: List of values of the items. :param weights: List of weights of the items. :param capacity: Maximum weight capacity of the knapsack. :return: Integer, the maximum total value. n = len(values) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"def increasing_triplet(nums: List[int]) -> bool: Determines if there exists a triple (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. Args: nums (List[int]): The input list of integers. Returns: bool: True if such a triplet exists, else False. >>> increasing_triplet([1, 2, 3, 4, 5]) True >>> increasing_triplet([5, 4, 3, 2, 1]) False >>> increasing_triplet([2, 1, 5, 0, 4, 6]) True >>> increasing_triplet([1, 2]) False >>> increasing_triplet([1, 2, 3]) True >>> increasing_triplet([-2, -1, 0]) True >>> increasing_triplet([-3, -2, -1]) True >>> increasing_triplet([1, 1, 1, 1, 1]) False >>> increasing_triplet([1, 2, 2, 3]) True >>> increasing_triplet([1, 100000, 1000000000]) True","solution":"def increasing_triplet(nums): Determines if there exists a triple (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. Args: nums (List[int]): The input list of integers. Returns: bool: True if such a triplet exists, else False. first = second = float('inf') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Returns the area of the largest rectangle that can be formed within the histogram. :param heights: List of positive integers representing the heights of bars. :return: Integer representing the largest rectangle area. >>> largest_rectangle_area([2]) == 2 >>> largest_rectangle_area([2, 2, 2, 2]) == 8 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([6, 5, 4, 3, 2, 1]) == 12 >>> largest_rectangle_area([1, 2, 3, 4, 5, 6]) == 12 >>> largest_rectangle_area([]) == 0","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed within the histogram. :param heights: List of positive integers representing the heights of bars. :return: Integer representing the largest rectangle area. stack = [] max_area = 0 index = 0 while index < len(heights): # If stack is empty or current bar is taller than # the bar at stack's top index if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root: TreeNode) -> int: Returns the level of the binary tree with the maximum sum of node values. In case of a tie, the smallest level number is returned. The root level is considered as level 1. >>> root = TreeNode(5) >>> maxLevelSum(root) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> maxLevelSum(root) 2 >>> root = TreeNode(1, TreeNode(7, TreeNode(7), TreeNode(-8)), TreeNode(0)) >>> maxLevelSum(root) 2 >>> root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(8)))) >>> maxLevelSum(root) 4 >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(4, None, TreeNode(8)))) >>> maxLevelSum(root) 4","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root: TreeNode) -> int: if not root: return 0 max_sum = float('-inf') max_level = 0 level = 1 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) if level_sum > max_sum: max_sum = level_sum max_level = level level += 1 return max_level"},{"question":"def interleaveStrings(s1: str, s2: str) -> str: Interleaves two strings of the same length by alternating their characters. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The interleaved string. Examples: >>> interleaveStrings(\\"abc\\", \\"def\\") \\"adbecf\\" >>> interleaveStrings(\\"123\\", \\"456\\") \\"142536\\" >>> interleaveStrings(\\"a\\", \\"b\\") \\"ab\\" >>> interleaveStrings(\\"aa\\", \\"bb\\") \\"abab\\" >>> interleaveStrings(\\"\\", \\"\\") \\"\\"","solution":"def interleaveStrings(s1, s2): Interleaves two strings of the same length by alternating their characters. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The interleaved string. result = [] for i in range(len(s1)): result.append(s1[i]) result.append(s2[i]) return ''.join(result)"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray. >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([7]) == 7 >>> max_subarray_sum([-7]) == -7 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def word_pattern(s: str, pattern: str) -> bool: Determine if the words in the string s follow the same order as characters in the string pattern. Returns True if there is a bijection between a letter in pattern and a non-empty word in s. >>> word_pattern(\\"dog cat cat dog\\", \\"abba\\") True >>> word_pattern(\\"dog cat cat fish\\", \\"abba\\") False >>> word_pattern(\\"dog cat cat\\", \\"abba\\") False >>> word_pattern(\\"dog dog dog dog\\", \\"abba\\") False >>> word_pattern(\\"\\", \\"\\") True >>> word_pattern(\\"dog\\", \\"a\\") True >>> word_pattern(\\"dog dog dog dog\\", \\"aaaa\\") True >>> word_pattern(\\"dog cat cat dog\\", \\"aaaa\\") False","solution":"def word_pattern(s, pattern): Returns True if words in string s follow the same order as characters in string pattern. words = s.split() if len(words) != len(pattern): return False char_to_word = {} word_to_char = {} for c, word in zip(pattern, words): if c in char_to_word: if char_to_word[c] != word: return False else: if word in word_to_char: if word_to_char[word] != c: return False char_to_word[c] = word word_to_char[word] = c return True"},{"question":"def insert_intervals(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]: Insert a new interval into a list of non-overlapping intervals and return the new list of intervals, sorted in ascending order by start time. >>> insert_intervals([[1,3],[6,9]], [2,5]) [[1,5],[6,9]] >>> insert_intervals([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]) [[1,2],[3,10],[12,16]] >>> insert_intervals([], [5,7]) [[5,7]] >>> insert_intervals([[1,5]], [2,3]) [[1,5]] >>> insert_intervals([[1,5]], [2,7]) [[1,7]] >>> insert_intervals([[1,3],[6,9]], [10,11]) [[1,3],[6,9],[10,11]]","solution":"def insert_intervals(intervals, newInterval): result = [] i, n = 0, len(intervals) # Add all intervals before newInterval while i < n and intervals[i][1] < newInterval[0]: result.append(intervals[i]) i += 1 # Merge intervals that overlap with newInterval while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 # Add the merged interval result.append(newInterval) # Add the remaining intervals while i < n: result.append(intervals[i]) i += 1 return result"},{"question":"def is_happy(n: int) -> bool: Determines if a number n is a \\"happy number\\". A happy number is defined by the following process: - Starting with any positive integer, replace the number by the sum of the squares of its digits. - Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1. - Those numbers for which this process ends in 1 are happy numbers. Parameters: n (int): The number to check. Returns: bool: True if n is a happy number, False otherwise. >>> is_happy(19) True >>> is_happy(2) False","solution":"def is_happy(n): Determines if a number n is a \\"happy number\\". Parameters: n (int): The number to check. Returns: bool: True if n is a happy number, False otherwise. def sum_of_squares(num): return sum(int(digit) ** 2 for digit in str(num)) seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares(n) return n == 1"},{"question":"def count_of_atoms(formula: str) -> str: Given a string representing a chemical formula, return the count of each chemical element in a sorted order of elements. Args: formula (str): A string representing a valid chemical formula. Returns: str: A string representation with the element followed by its count in sorted order. >>> count_of_atoms(\\"H2O\\") 'H2O1' >>> count_of_atoms(\\"Mg(OH)2\\") 'H2Mg1O2' >>> count_of_atoms(\\"K4(ON(SO3)2)2\\") 'K4N2O14S4' >>> count_of_atoms(\\"C6H12O6\\") 'C6H12O6' >>> count_of_atoms(\\"CO2\\") 'C1O2'","solution":"def count_of_atoms(formula): import re from collections import defaultdict def parse_formula(formula): \\"Recursive function to parse the formula inside brackets\\" stack = [[]] i = 0 while i < len(formula): if formula[i] == '(': stack.append([]) i += 1 elif formula[i] == ')': number = '' i += 1 while i < len(formula) and formula[i].isdigit(): number += formula[i] i += 1 multiplier = int(number) if number else 1 elements = stack.pop() for el in elements: el[1] *= multiplier stack[-1].extend(elements) else: element = formula[i] i += 1 if i < len(formula) and formula[i].islower(): element += formula[i] i += 1 number = '' while i < len(formula) and formula[i].isdigit(): number += formula[i] i += 1 count = int(number) if number else 1 stack[-1].append([element, count]) return stack[0] def count_elements(elements): element_count = defaultdict(int) for element, count in elements: element_count[element] += count return element_count parsed_formula = parse_formula(formula) element_count = count_elements(parsed_formula) sorted_elements = sorted(element_count.items()) return ''.join(f\\"{el}{count}\\" for el, count in sorted_elements) # Example print(count_of_atoms(\\"K4(ON(SO3)2)2\\")) # K4N2O14S4"},{"question":"def num_of_paths(grid: List[List[int]]) -> int: You are given an m x n binary matrix \`grid\`, where \`0\` represents an empty cell and \`1\` represents a blocked cell. You start at the top-left corner of the grid (0, 0) and need to reach the bottom-right corner (m-1, n-1). You can only move right or down. Your task is to determine the number of distinct paths from the start to the destination while avoiding blocked cells. If there is no valid path, return 0. Return the number of distinct paths from the top-left corner to the bottom-right corner of the grid. Since the number of paths can be large, return the answer **modulo** \`10^9 + 7\`. >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> num_of_paths(grid) 6 >>> grid = [ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> num_of_paths(grid) 3 >>> grid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]] >>> num_of_paths(grid) 0 >>> grid = [[0, 0, 0], [0, 0, 0], [0, 0, 1]] >>> num_of_paths(grid) 0 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> num_of_paths(grid) 0 >>> grid = [[0, 0], [0, 0]] >>> num_of_paths(grid) 2 >>> grid = [ ... [0, 0, 1], ... [1, 0, 0], ... [0, 0, 0] ... ] >>> num_of_paths(grid) 2","solution":"def num_of_paths(grid): MOD = 10**9 + 7 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[m-1][n-1]"},{"question":"def min_refills(plants: List[int], k: int) -> int: Determine the minimum number of refills required to water all the plants in a row. Parameters: plants (list): List of integers where plants[i] represents the water requirement of the i-th plant. k (int): Capacity of the watering can. Returns: int: Minimum number of refills required. >>> min_refills([1, 2, 3, 4], 10) 0 >>> min_refills([2, 2, 2], 1) 3 >>> min_refills([1, 2, 3, 4], 5) 2 >>> min_refills([2, 2, 2, 2], 2) 3 >>> min_refills([5, 5, 5, 5], 20) 0 >>> min_refills([5], 3) 1 >>> min_refills([5], 10) 0 >>> min_refills([1, 5, 1, 1, 5, 1], 5) 4","solution":"def min_refills(plants, k): Returns the minimum number of refills required to water all the plants. Parameters: plants (list): List of integers where plants[i] represents the water requirement of the i-th plant. k (int): Watering can capacity. Returns: int: Minimum number of refills required. current_water = k # Start with a full can refills = 0 for requirement in plants: if requirement > current_water: # If the current requirement is more than the remaining water, refill the can refills += 1 current_water = k # Refill the can current_water -= requirement # Water the plant return refills"},{"question":"def is_consecutive_sequence(arr): Determines if the array can be rearranged to form a consecutive sequence starting from 1 to len(arr). :param arr: List[int] - an integer array representing a permutation of numbers from 1 to len(arr) :return: bool - True if the array can be rearranged to form [1, 2, 3, ..., len(arr)], otherwise False >>> is_consecutive_sequence([4, 3, 2, 1]) True >>> is_consecutive_sequence([1, 2, 3, 4, 5]) True >>> is_consecutive_sequence([3, 2, 5, 4, 1]) True >>> is_consecutive_sequence([4, 1, 3]) False >>> is_consecutive_sequence([1, 2, 3, 5]) False >>> is_consecutive_sequence([1]) True >>> is_consecutive_sequence([]) True >>> is_consecutive_sequence([2, 1]) True >>> is_consecutive_sequence([10]) False","solution":"def is_consecutive_sequence(arr): Determines if the array can be rearranged to form a consecutive sequence starting from 1 to len(arr). :param arr: List[int] - an integer array representing a permutation of numbers from 1 to len(arr) :return: bool - True if the array can be rearranged to form [1, 2, 3, ..., len(arr)], otherwise False return sorted(arr) == list(range(1, len(arr) + 1))"},{"question":"def count_compositions(n: int, k: int) -> int: Returns the number of compositions of the integer n into exactly k parts (each part being a positive integer), modulo 10^9 + 7. >>> count_compositions(3, 3) == 1 >>> count_compositions(5, 2) == 4 >>> count_compositions(5, 5) == 1 >>> count_compositions(0, 0) == 1 >>> count_compositions(1, 1) == 1 >>> count_compositions(10, 0) == 0 >>> count_compositions(0, 1) == 0 >>> count_compositions(1, 0) == 0 >>> count_compositions(10, 11) == 0 >>> count_compositions(1000, 100) % (10**9 + 7) == count_compositions(1000, 100)","solution":"def count_compositions(n, k): Returns the number of compositions of the integer n into exactly k parts (each part being a positive integer), modulo 10^9 + 7. MOD = 10**9 + 7 # Initialize a dp array where dp[i][j] represents the number of ways to write i as the sum of j positive integers dp = [[0] * (k + 1) for _ in range(n + 1)] # There's only one way to write 0 using 0 parts: using no parts at all dp[0][0] = 1 # Fill the dp array for i in range(1, n + 1): for j in range(1, k + 1): dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD return dp[n][k]"},{"question":"def find_buildings_with_ocean_view(heights): Returns the number of buildings that have an ocean view. A building has an ocean view if all the buildings to its right are shorter. :param heights: List[int] - A list of integers representing the heights of buildings :return: int - The number of buildings that have an ocean view >>> find_buildings_with_ocean_view([5]) 1 >>> find_buildings_with_ocean_view([4, 3, 2, 1]) 4 >>> find_buildings_with_ocean_view([1, 2, 3, 4]) 1 >>> find_buildings_with_ocean_view([4, 2, 3, 1]) 3 >>> find_buildings_with_ocean_view([]) 0 >>> find_buildings_with_ocean_view([2, 2, 2, 2]) 1","solution":"def find_buildings_with_ocean_view(heights): Returns the number of buildings that have an ocean view. A building has an ocean view if all the buildings to its right are shorter. :param heights: List[int] - A list of integers representing the heights of buildings :return: int - The number of buildings that have an ocean view if not heights: return 0 count = 1 # The last building always has an ocean view max_height = heights[-1] for i in range(len(heights) - 2, -1, -1): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"def island_perimeter(grid): Returns the perimeter of the island in the given 2D grid. >>> island_perimeter([[1]]) == 4 >>> island_perimeter([[0, 1, 1], [0, 1, 1]]) == 8 >>> island_perimeter([[1, 1], [1, 1]]) == 8 >>> island_perimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]) == 16 >>> island_perimeter([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> island_perimeter([[1, 1, 1, 1]]) == 10 >>> island_perimeter([[1], [1], [1], [1]]) == 10","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given 2D grid. def count_perimeter(i, j): perimeter = 0 if i == 0 or grid[i-1][j] == 0: perimeter += 1 if i == len(grid)-1 or grid[i+1][j] == 0: perimeter += 1 if j == 0 or grid[i][j-1] == 0: perimeter += 1 if j == len(grid[0])-1 or grid[i][j+1] == 0: perimeter += 1 return perimeter total_perimeter = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: total_perimeter += count_perimeter(i, j) return total_perimeter"},{"question":"def longest_increasing_subsequence(nums: List[int]) -> int: Write a function that takes a list of integers and returns the longest increasing subsequence (LIS). The subsequence consists of elements from the list that are in increasing order and form a contiguous segment from the original list, not necessarily consecutive elements. The function should return the length of the LIS found. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 >>> longest_increasing_subsequence([-1, -2, -3, -4]) == 1 >>> longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) == 4 >>> longest_increasing_subsequence([1, 2, 2, 2, 3, 4]) == 4 >>> longest_increasing_subsequence([10]) == 1 >>> longest_increasing_subsequence([]) == 0 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1","solution":"def longest_increasing_subsequence(nums): if not nums: return 0 # Initialize lengths list with 1 as the smallest LIS has at least one element lis = [1] * len(nums) # Iterate over each number in the list for i in range(1, len(nums)): # Compare with all previous numbers for j in range(i): # If the current number is greater than the previous one and the LIS ending with the previous one +1 is # greater than current LIS ending at the current index if nums[i] > nums[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Find the maximum value in the lis array which represents the longest increasing subsequence return max(lis)"},{"question":"def minMeetingRooms(intervals: List[List[int]]) -> int: Given a list of meeting time intervals consisting of start and end times \`[[s1,e1],[s2,e2],...]\` (s_i < e_i), find the minimum number of conference rooms required. >>> minMeetingRooms([]) 0 >>> minMeetingRooms([[1, 5]]) 1 >>> minMeetingRooms([[1, 5], [6, 10]]) 1 >>> minMeetingRooms([[1, 5], [2, 6], [8, 10]]) 2 >>> minMeetingRooms([[1, 10], [2, 6], [5, 9]]) 3 >>> minMeetingRooms([[1, 3], [3, 5], [5, 7]]) 1 >>> minMeetingRooms([[1, 5], [1, 6], [1, 7]]) 3 >>> minMeetingRooms([[1, 4], [2, 5], [3, 6]]) 3 >>> minMeetingRooms([[0, 30], [5, 10], [15, 20], [20, 30], [25, 35], [30, 40]]) 3","solution":"def minMeetingRooms(intervals): if not intervals: return 0 start_times = sorted(interval[0] for interval in intervals) end_times = sorted(interval[1] for interval in intervals) start_pointer = end_pointer = 0 used_rooms = 0 while start_pointer < len(intervals): if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"def num_decodings(s: str) -> int: Given a digit string \`s\`, return the number of ways the string can be decoded into an alphabet where 'A' is represented by \`1\`, 'B' by \`2\`, ..., and 'Z' by \`26\`. >>> num_decodings(\\"1\\") == 1 >>> num_decodings(\\"12\\") == 2 # \\"AB\\" and \\"L\\" >>> num_decodings(\\"226\\") == 3 # \\"BZ\\", \\"VF\\", \\"BBF\\" >>> num_decodings(\\"0\\") == 0 >>> num_decodings(\\"\\") == 0","solution":"def num_decodings(s): Returns the number of ways the string can be decoded. if not s: return 0 n = len(s) dp = [0] * (n + 1) # Base cases dp[0] = 1 # empty string can be decoded in one way dp[1] = 1 if s[0] != '0' else 0 # single character string cannot start with '0' for i in range(2, n + 1): # Check single digit decode if s[i-1] != '0': dp[i] += dp[i-1] # Check two digit decode two_digit = int(s[i-2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"from typing import List def min_subarray_len(transactions: List[int], target: int) -> int: Find the length of the smallest subarray with a sum of at least target. :param transactions: List of integer transactions. :param target: Target sum. :return: Length of the smallest subarray with sum >= target or -1 if no such subarray exists. >>> min_subarray_len([2, 1, 5, 2, 3, 2], 7) 2 >>> min_subarray_len([2, 1, 5, 2, 8], 7) 1 >>> min_subarray_len([3, 4, 1, 1, 6], 8) 3 >>> min_subarray_len([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([1, 2, 3, 4, 5], 16) -1 >>> min_subarray_len([], 10) -1 >>> min_subarray_len([10, 2, -1, 2], 10) 1 >>> min_subarray_len([1, 2, 3], 6) 3 >>> min_subarray_len([1], 1) 1 >>> min_subarray_len([1], 2) -1","solution":"def min_subarray_len(transactions, target): Find the length of the smallest subarray with a sum of at least target. :param transactions: List of integer transactions. :param target: Target sum. :return: Length of the smallest subarray with sum >= target or -1 if no such subarray exists. n = len(transactions) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += transactions[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= transactions[start] start += 1 return min_len if min_len != float('inf') else -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Serializes a binary tree to a string. :param root: TreeNode, the root of the binary tree :return: str, the serialized string representation of the binary tree >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> serialize(root) '1,2,4,None,None,5,None,None,3,6,None,None,7,None,None,' def deserialize(data: str) -> TreeNode: Deserializes a string to a binary tree. :param data: str, the serialized string representation of a binary tree :return: TreeNode, the root of the deserialized binary tree >>> data = '1,2,4,None,None,5,None,None,3,6,None,None,7,None,None,' >>> root = deserialize(data) >>> root.val 1 >>> root.left.val 2 >>> root.right.val 3 def test_serialize_deserialize_single_node(): root = TreeNode(1) data = serialize(root) assert data == \\"1,None,None,\\" new_root = deserialize(data) assert new_root.val == 1 assert new_root.left == None assert new_root.right == None def test_serialize_deserialize_complete_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) data = serialize(root) assert data == \\"1,2,4,None,None,5,None,None,3,6,None,None,7,None,None,\\" new_root = deserialize(data) assert new_root.val == 1 assert new_root.left.val == 2 assert new_root.right.val == 3 assert new_root.left.left.val == 4 assert new_root.left.right.val == 5 assert new_root.right.left.val == 6 assert new_root.right.right.val == 7 def test_serialize_deserialize_left_skewed_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) data = serialize(root) assert data == \\"1,2,3,None,None,None,None,\\" new_root = deserialize(data) assert new_root.val == 1 assert new_root.left.val == 2 assert new_root.left.left.val == 3 assert new_root.right == None def test_serialize_deserialize_right_skewed_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) data = serialize(root) assert data == \\"1,None,2,None,3,None,None,\\" new_root = deserialize(data) assert new_root.val == 1 assert new_root.left == None assert new_root.right.val == 2 assert new_root.right.right.val == 3 def test_serialize_deserialize_empty_tree(): root = None data = serialize(root) assert data == \\"None,\\" new_root = deserialize(data) assert new_root == None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): def helper(node): if not node: return \\"None,\\" return str(node.val) + \\",\\" + helper(node.left) + helper(node.right) return helper(root) def deserialize(data): def helper(data_list): if data_list[0] == \\"None\\": data_list.pop(0) return None root = TreeNode(int(data_list.pop(0))) root.left = helper(data_list) root.right = helper(data_list) return root data_list = data.split(\\",\\") root = helper(data_list) return root"},{"question":"import random def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot_index = partition(arr, low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def kthSmallest(arr, k): Returns the k-th smallest element in the array. >>> kthSmallest([7, 10, 4, 3, 20, 15], 3) 7 >>> kthSmallest([7, 10, 4, 3, 20, 15], 2) 4 >>> kthSmallest([1, 2], 1) 1 >>> kthSmallest([1, 2], 2) 2 >>> kthSmallest([-1, -2, 0, 2], 1) -2 >>> kthSmallest([-1, -2, 0, 2], 3) 0 >>> kthSmallest([1, 1, 1, 2, 2, 3], 4) 2 >>> kthSmallest([1, 1, 1, 1, 1, 1], 3) 1 if k < 1 or k > len(arr): raise ValueError(\\"k is out of bounds of the array length.\\") return quickselect(arr, 0, len(arr) - 1, k - 1)","solution":"import random def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot_index = partition(arr, low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def kthSmallest(arr, k): Returns the k-th smallest element in the array. if k < 1 or k > len(arr): raise ValueError(\\"k is out of bounds of the array length.\\") return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root: TreeNode) -> int: Returns the number of good nodes in the binary tree. A node is considered good if in the path from the root to the node there are no nodes with a value greater than the node's value. >>> root = TreeNode( ... 3, ... left=TreeNode(1, left=TreeNode(3)), ... right=TreeNode(4, left=TreeNode(1, right=TreeNode(5))) ... ) >>> good_nodes(root) 4 >>> root = TreeNode( ... 3, ... left=TreeNode(3), ... right=TreeNode(3) ... ) >>> good_nodes(root) 3 >>> root = TreeNode( ... 2, ... left=TreeNode(1), ... right=TreeNode(3, right=TreeNode(4, right=TreeNode(5))) ... ) >>> good_nodes(root) 4","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root): def dfs(node, max_val): if not node: return 0 is_good = node.val >= max_val max_val = max(max_val, node.val) return is_good + dfs(node.left, max_val) + dfs(node.right, max_val) return dfs(root, root.val)"},{"question":"def max_modulus_permutation(nums): Given an integer array nums, this function finds the permutation of nums that maximizes the modulus operation: modulus(perm) = sum(|perm[i] - i| for all i) If there are multiple permutations yielding the same maximum value, return the lexicographically smallest permutation. Args: nums (List[int]): The input integer array. Returns: List[int]: The permutation that maximizes the modulus operation. # Unit tests def test_single_element(): assert max_modulus_permutation([1]) == [1] assert max_modulus_permutation([100]) == [100] def test_unique_elements(): assert max_modulus_permutation([1, 2, 3]) == [3, 2, 1] assert max_modulus_permutation([3, 1, 2]) == [3, 2, 1] def test_non_unique_elements(): assert max_modulus_permutation([1, 1, 2]) == [2, 1, 1] assert max_modulus_permutation([4, 5, 2, 2, 4]) == [5, 4, 4, 2, 2] def test_already_sorted(): assert max_modulus_permutation([5, 4, 3, 2, 1]) == [5, 4, 3, 2, 1] assert max_modulus_permutation([1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1] def test_large_numbers(): assert max_modulus_permutation([1000, 2000, 3000]) == [3000, 2000, 1000] assert max_modulus_permutation([3000, 1000, 2000]) == [3000, 2000, 1000]","solution":"def max_modulus_permutation(nums): Given an integer array nums, this function finds the permutation of nums that maximizes the modulus operation: modulus(perm) = sum(|perm[i] - i| for all i) If there are multiple permutations yielding the same maximum value, return the lexicographically smallest permutation. Args: nums (List[int]): The input integer array. Returns: List[int]: The permutation that maximizes the modulus operation. nums.sort(reverse=True) return nums"},{"question":"def partition_labels(s: str) -> List[int]: Partition the string s into as many parts as possible so that each letter appears in at most one part. Return the lengths of these parts in a list. >>> partition_labels(\\"abca\\") [4] >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"abcdef\\") [1, 1, 1, 1, 1, 1] >>> partition_labels(\\"aaaaa\\") [5] >>> partition_labels(\\"eccbbbbdec\\") [10]","solution":"def partition_labels(s): Partition the string s into as many parts as possible so that each letter appears in at most one part. Return the lengths of these parts in a list. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"def max_projects_funded(projects: List[int], B: int) -> int: Returns the maximum number of projects that can be funded within the given budget B. :param projects: List[int] - a list of integers representing the cost of each project :param B: int - the total budget available :return: int - the maximum number of projects that can be funded >>> max_projects_funded([10], 15) 1 >>> max_projects_funded([10], 10) 1 >>> max_projects_funded([20], 15) 0 >>> max_projects_funded([10, 20, 30], 40) 2 >>> max_projects_funded([5, 10, 15], 100) 3 >>> max_projects_funded([10, 20, 30], 5) 0 >>> max_projects_funded([10, 5, 2, 7], 17) 3 # 10 + 5 + 2 = 17 >>> max_projects_funded([1, 2, 3, 4, 5], 10) 4 # 1 + 2 + 3 + 4 = 10 >>> max_projects_funded([5, 5], 5) 1 >>> max_projects_funded([], 50) 0 >>> max_projects_funded([1000, 2000, 3000], 5000) 2","solution":"def max_projects_funded(projects, B): Returns the maximum number of projects that can be funded within the given budget B. :param projects: List[int] - a list of integers representing the cost of each project :param B: int - the total budget available :return: int - the maximum number of projects that can be funded projects.sort() funded_projects = 0 current_budget = 0 for cost in projects: if current_budget + cost <= B: current_budget += cost funded_projects += 1 else: break return funded_projects"},{"question":"def find_scc_count(graph: List[List[int]]) -> int: Finds the number of strongly connected components (SCCs) in a graph. Parameters: graph (List[List[int]]): n x n adjacency matrix where graph[i][j] == 1 indicates a directed edge from node i to node j, and graph[i][j] == 0 indicates no direct edge from node i to node j. Returns: int: The number of strongly connected components in the graph. Examples: >>> find_scc_count([[0, 1, 1, 0], [0, 0, 0, 1], [0, 0, 0, 1], [1, 0, 0, 0]]) 1 >>> find_scc_count([[0, 1, 0], [0, 0, 0], [0, 0, 0]]) 3 >>> find_scc_count([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 3","solution":"from collections import defaultdict def find_scc_count(graph): Finds the number of strongly connected components (SCCs) in a graph. Parameters: graph (List[List[int]]): n x n adjacency matrix where graph[i][j] == 1 indicates a directed edge from node i to node j, and graph[i][j] == 0 indicates no direct edge from node i to node j. Returns: int: The number of strongly connected components in the graph. def dfs(v, visited, stack): visited[v] = True for i in range(len(graph)): if graph[v][i] == 1 and not visited[i]: dfs(i, visited, stack) stack.append(v) def transpose_graph(): return [[graph[j][i] for j in range(len(graph))] for i in range(len(graph))] def fill_order(): visited = [False] * len(graph) stack = [] for i in range(len(graph)): if not visited[i]: dfs(i, visited, stack) return stack def dfs_on_transpose(v, visited): visited[v] = True for i in range(len(transposed_graph)): if transposed_graph[v][i] == 1 and not visited[i]: dfs_on_transpose(i, visited) # Step 1: Fill vertices in stack according to their finishing times stack = fill_order() # Step 2: Create a transposed graph transposed_graph = transpose_graph() # Step 3: Do DFS on transposed graph in the order defined by the stack visited = [False] * len(graph) strongly_connected_components = 0 while stack: i = stack.pop() if not visited[i]: dfs_on_transpose(i, visited) strongly_connected_components += 1 return strongly_connected_components"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determines if the linked list has a cycle. :param head: ListNode, the head of the linked list :return: Boolean, True if there is a cycle, False otherwise from solution import ListNode, hasCycle def test_hasCycle_no_cycle(): # 1 -> 2 -> 3 -> 4 -> None node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 assert hasCycle(node1) == False def test_hasCycle_small_cycle(): # 1 -> 2 -> 3 -> 4 -> 2 (cycle) node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 assert hasCycle(node1) == True def test_hasCycle_large_cycle(): # 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 3 (cycle) node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node6 = ListNode(6) node7 = ListNode(7) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node6 node6.next = node7 node7.next = node3 assert hasCycle(node1) == True def test_hasCycle_empty_list(): # Empty list assert hasCycle(None) == False def test_hasCycle_single_node_no_cycle(): # 1 -> None node1 = ListNode(1) assert hasCycle(node1) == False def test_hasCycle_single_node_with_cycle(): # 1 -> 1 (cycle) node1 = ListNode(1) node1.next = node1 assert hasCycle(node1) == True","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determines if the linked list has a cycle. :param head: ListNode, the head of the linked list :return: Boolean, True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"def longest_pattern_length(s: str, patterns: List[str]) -> int: Returns the length of the longest pattern found in string s. If no patterns are found, returns -1. >>> longest_pattern_length(\\"hello world\\", [\\"hello\\", \\"world\\", \\"test\\"]) == 5 >>> longest_pattern_length(\\"abcdefgh\\", [\\"def\\", \\"abcd\\", \\"xyz\\"]) == 4 >>> longest_pattern_length(\\"hello world\\", [\\"xyz\\", \\"abc\\"]) == -1 >>> longest_pattern_length(\\"abcdefgh\\", [\\"ijk\\", \\"lmn\\"]) == -1 >>> longest_pattern_length(\\"\\", [\\"test\\", \\"pattern\\"]) == -1 >>> longest_pattern_length(\\"hello world\\", []) == -1 >>> longest_pattern_length(\\"hello\\", [\\"he\\", \\"hell\\"]) == 4 >>> longest_pattern_length(\\"foobar\\", [\\"foo\\", \\"bar\\", \\"baz\\"]) == 3 >>> longest_pattern_length(\\"hello\\", [\\"\\", \\"h\\", \\"e\\"]) == 1 >>> longest_pattern_length(\\"world\\", [\\"\\", \\"wo\\", \\"orl\\"]) == 3 >>> longest_pattern_length(\\"abcabc\\", [\\"a\\", \\"ab\\", \\"abc\\"]) == 3","solution":"def longest_pattern_length(s, patterns): Returns the length of the longest pattern found in string s. If no patterns are found, returns -1. max_length = -1 for pattern in patterns: if pattern in s: max_length = max(max_length, len(pattern)) return max_length"},{"question":"def lcs_length(nums1, nums2): Returns the length of the Longest Common Subsequence (LCS) between two sequences nums1 and nums2. >>> lcs_length([1, 3, 4, 1], [3, 4, 1, 2, 1, 3]) == 3 >>> lcs_length([1, 2, 3], [4, 5, 6]) == 0 >>> lcs_length([1, 2, 3], [1, 2, 3]) == 3 >>> lcs_length([1, 2, 3], []) == 0 >>> lcs_length([], [1, 2, 3]) == 0 >>> lcs_length([1, 4, 3, 4], [4, 3, 4]) == 3 >>> lcs_length([1], [1]) == 1 >>> lcs_length([1], [0]) == 0 >>> lcs_length([1, 3, 4, 1, 2], [3, 4, 1, 3]) == 3","solution":"def lcs_length(nums1, nums2): Returns the length of the Longest Common Subsequence (LCS) between two sequences nums1 and nums2. n = len(nums1) m = len(nums2) dp = [[0 for _ in range(m+1)] for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m+1): if nums1[i-1] == nums2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[n][m]"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the string s. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"ab\\") 2 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"aba\\") 4 >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"abcdefgh\\") 8 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"\\") 0 >>> count_palindromic_substrings(\\"aaaa\\") 10","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the string s. n = len(s) count = 0 # Helper function to expand around center def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd-length palindromes (single character center) expand_around_center(i, i) # Even-length palindromes (two character center) expand_around_center(i, i + 1) return count"},{"question":"def maximum_difference(nums): Given a 0-indexed integer array \`nums\`, return the maximum difference between any pair of indices (i, j) such that i < j and nums[i] < nums[j]. If no such pair exists, return -1. >>> maximum_difference([7, 1, 5, 4]) 4 >>> maximum_difference([9, 8, 7, 6]) -1 >>> maximum_difference([1, 2]) 1 >>> maximum_difference([1, 2, 90, 10, 110]) 109 >>> maximum_difference([5, 5, 5, 5]) -1 >>> maximum_difference([1, 100]) 99 >>> maximum_difference([2, 3, 10, 6, 4, 8, 1]) 8","solution":"def maximum_difference(nums): Given a 0-indexed integer array \`nums\`, return the maximum difference between any pair of indices (i, j) such that i < j and nums[i] < nums[j]. If no such pair exists, return -1. max_diff = -1 min_value = nums[0] for j in range(1, len(nums)): if nums[j] > min_value: max_diff = max(max_diff, nums[j] - min_value) min_value = min(min_value, nums[j]) return max_diff"},{"question":"def max_visible_buildings(heights): Arrange the buildings to form the maximum possible number of buildings visible in the skyline silhouette. >>> max_visible_buildings([1, 3, 2, 5, 4]) == 5 >>> max_visible_buildings([4, 2, 3, 1]) == 4 >>> max_visible_buildings([5, 5, 5, 5, 5, 5]) == 1 >>> max_visible_buildings([]) == 0 >>> max_visible_buildings([9]) == 1","solution":"def max_visible_buildings(heights): Arrange the buildings to form the maximum possible number of buildings visible in the skyline silhouette. # To maximize the number of visible buildings, we need to maintain strictly increasing heights. heights.sort() visible_count = 0 max_height = 0 for height in heights: # A building is only visible if it is taller than all previous buildings. if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root): Returns the values of nodes in a binary tree in zigzag level order. >>> zigzag_level_order(None) [] >>> root = TreeNode(1) >>> zigzag_level_order(root) [[1]] >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> zigzag_level_order(root) [[1], [3, 2]] >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzag_level_order(root) [[1], [3, 2], [4, 5, 6, 7]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root): Returns the values of nodes in a binary tree in zigzag level order. if not root: return [] results = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) current_level = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: current_level.append(node.val) else: current_level.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) results.append(list(current_level)) left_to_right = not left_to_right return results"},{"question":"def max_points(points: List[int]) -> int: Given an integer array \`points\` where \`points[i]\` represents the point value of the i-th game, determine the maximum points that can be earned under the given constraints. - You earn points if you play a game, but need to skip the next game; - You can alternatively skip any game without penalty. >>> max_points([]) 0 >>> max_points([10]) 10 >>> max_points([10, 5]) 10 >>> max_points([5, 10]) 10 >>> max_points([1, 2, 9]) 10 >>> max_points([10, 5, 20]) 30 >>> max_points([5, 10, 10]) 15 >>> max_points([3, 2, 5, 10, 7]) 15 >>> max_points([10, 2, 10, 2, 10]) 30 >>> max_points([1, 3, 1, 3, 100]) 103","solution":"def max_points(points): n = len(points) if n == 0: return 0 if n == 1: return points[0] # dp[i] will store the maximum points we can get till index i dp = [0] * n dp[0] = points[0] if n > 1: dp[1] = max(points[0], points[1]) for i in range(2, n): dp[i] = max(dp[i-1], points[i] + dp[i-2]) return dp[-1]"},{"question":"def isValidBST(tree: List[int]) -> bool: Returns whether the given binary tree is a valid Binary Search Tree (BST). >>> isValidBST([2, 1, 3]) True >>> isValidBST([5, 1, 4, -1, -1, 3, 6]) False >>> isValidBST([1]) True >>> isValidBST([]) True >>> isValidBST([3, 2, -1, 1, -1, -1, -1, 0]) True >>> isValidBST([1, -1, 2, -1, -1, -1, 3]) True >>> isValidBST([10, 5, 15, 1, 12, -1, -1]) False >>> isValidBST([10, 5, 15, -1, -1, 6, 20]) False","solution":"def isValidBST(tree): Returns whether the given binary tree is a valid Binary Search Tree (BST). def isValidBSTHelper(tree, index, left, right): if index >= len(tree) or tree[index] == -1: return True value = tree[index] if not (left < value < right): return False left_index = 2 * index + 1 right_index = 2 * index + 2 return (isValidBSTHelper(tree, left_index, left, value) and isValidBSTHelper(tree, right_index, value, right)) return isValidBSTHelper(tree, 0, float('-inf'), float('inf'))"},{"question":"def max_weight_substring(s: str, k: int) -> int: Calculates the maximum weight of all substrings of s with length k. :param s: Input string consisting of lowercase English letters :param k: Length of the substrings to consider :return: Maximum weight of all substrings of s with length k >>> max_weight_substring(\\"abcabc\\", 3) 3 >>> max_weight_substring(\\"aabbcc\\", 2) 2 >>> max_weight_substring(\\"abcde\\", 5) 5 >>> max_weight_substring(\\"aaaaa\\", 3) 1 >>> max_weight_substring(\\"\\", 3) 0 >>> max_weight_substring(\\"a\\", 1) 1 >>> max_weight_substring(\\"abc\\", 4) 0 >>> max_weight_substring(\\"bacacb\\", 3) 3 >>> max_weight_substring(\\"xyzzxy\\", 4) 3 >>> max_weight_substring(\\"aabcde\\", 2) 2 >>> max_weight_substring(\\"abcaaa\\", 3) 3","solution":"def max_weight_substring(s, k): Calculates the maximum weight of all substrings of s with length k. :param s: Input string consisting of lowercase English letters :param k: Length of the substrings to consider :return: Maximum weight of all substrings of s with length k if not s or k <= 0 or k > len(s): return 0 max_weight = 0 for i in range(len(s) - k + 1): substring = s[i:i+k] distinct_chars = set(substring) max_weight = max(max_weight, len(distinct_chars)) return max_weight"},{"question":"def can_form_string(words: List[str], s: str) -> bool: Returns True if string s can be formed by concatenating some of the words in the list, without reusing any word from the list. Otherwise, returns False. >>> can_form_string(['one', 'two', 'three'], 'onetwothree') True >>> can_form_string(['cat', 'dog'], 'catdog') True >>> can_form_string(['ab', 'abc', 'cd', 'def', 'abcd'], 'abcdef') True >>> can_form_string(['one', 'two', 'three'], 'onetwothreefour') False >>> can_form_string(['cat', 'dog'], 'catdogcat') False >>> can_form_string(['ab', 'abc', 'cd', 'def', 'abcd'], 'abcedef') False >>> can_form_string([], 'word') False >>> can_form_string(['one', 'two'], '') True >>> can_form_string(['one', 'one', 'two', 'two'], 'onetwo') True >>> can_form_string(['one', 'two', 'three'], 'onetwoone') False","solution":"def can_form_string(words, s): Returns True if string s can be formed by concatenating some of the words in the list, without reusing any word from the list. Otherwise, returns False. def backtrack(remaining, words): if not remaining: return True for i, word in enumerate(words): if remaining.startswith(word): if backtrack(remaining[len(word):], words[:i] + words[i+1:]): return True return False return backtrack(s, words)"},{"question":"def transform_and_sort(arr, k): Given an array of integers \`arr\` and an integer \`k\`, modify the array in such a way that every element in the array becomes \`arr[i] % k\`. After modifying the array, sort it in non-decreasing order. Return the transformed and sorted array. >>> transform_and_sort([8, 5, 6, 3], 4) [0, 1, 2, 3] >>> transform_and_sort([4, 8, 12, 16], 4) [0, 0, 0, 0] >>> transform_and_sort([-8, -5, -6, -3], 4) [0, 1, 2, 3] >>> transform_and_sort([8, -5, 6, -3], 4) [0, 1, 2, 3] >>> transform_and_sort([8, 5, 6, 3], 10) [3, 5, 6, 8] >>> transform_and_sort([], 5) [] >>> transform_and_sort([8, 5, 6, 3], 1) [0, 0, 0, 0]","solution":"def transform_and_sort(arr, k): Modifies the array such that each element becomes arr[i] % k, and then sorts the array. Parameters: arr (list): List of integers. k (int): The integer by which we take the modulus of each element. Returns: list: Transformed and sorted array. transformed_arr = [x % k for x in arr] transformed_arr.sort() return transformed_arr"},{"question":"def process_operations(operations: List[str]) -> List[str]: Processes a list of operations and returns the results of 'R' operations. Args: operations (list of str): A list where each element is a string corresponding to an operation. Returns: list of str: A list of strings which are the results of 'R' operations. pass # Unit tests def test_process_operations_simple_append(): assert process_operations([\\"A a\\", \\"A b\\", \\"R\\"]) == [\\"ab\\"] def test_process_operations_with_delete(): assert process_operations([\\"A a\\", \\"A b\\", \\"D\\", \\"R\\"]) == [\\"a\\"] def test_process_operations_multiple_results(): assert process_operations([\\"A a\\", \\"R\\", \\"A b\\", \\"R\\"]) == [\\"a\\", \\"ab\\"] def test_process_operations_no_R(): assert process_operations([\\"A a\\", \\"A b\\", \\"D\\"]) == [] def test_process_operations_complex(): assert process_operations([\\"A a\\", \\"A b\\", \\"R\\", \\"D\\", \\"R\\", \\"A c\\", \\"R\\", \\"A d\\", \\"R\\"]) == [\\"ab\\", \\"a\\", \\"ac\\", \\"acd\\"] def test_process_operations_empty_list(): assert process_operations([]) == [] def test_process_operations_only_R(): assert process_operations([\\"R\\", \\"R\\", \\"R\\"]) == [\\"\\", \\"\\", \\"\\"] def test_process_operations_edges(): assert process_operations([\\"D\\", \\"R\\"]) == [\\"\\"] assert process_operations([\\"R\\"]) == [\\"\\"]","solution":"def process_operations(operations): Processes a list of operations and returns the results of 'R' operations. Args: operations (list of str): A list where each element is a string corresponding to an operation. Returns: list of str: A list of strings which are the results of 'R' operations. result = [] current_string = \\"\\" for operation in operations: if operation.startswith('A '): current_string += operation[2] elif operation == 'D': current_string = current_string[:-1] elif operation == 'R': result.append(current_string) return result"},{"question":"def maximum_savings(prices: List[int], discount: int, k: int) -> float: You are given a **0-indexed** integer array \`prices\` representing the prices of products in a store. You also have an integer \`discount\` representing a percentage discount. You want to apply this discount to the prices but only to the first \`k\` products in the array. However, the discount can be applied to a continuous substring (subarray) of products, and you must maximize the total savings. Return the **maximum** savings possible by applying the discount to any continuous substring of length \`k\` in the array \`prices\`. If there are no such subarrays of length \`k\`, return \`0\`. >>> maximum_savings([10, 20, 30, 40, 50], 10, 3) 12.0 >>> maximum_savings([10, 20, 30, 40, 50], 10, 5) 15.0 >>> maximum_savings([10, 20, 30], 10, 4) 0 >>> maximum_savings([10], 10, 1) 1.0 >>> maximum_savings([10, 20, 30, 40, 50], 0, 3) 0.0 >>> maximum_savings([10, 10, 10, 10, 10], 10, 2) 2.0","solution":"def maximum_savings(prices, discount, k): if k > len(prices): return 0 max_saving = 0 discount = discount / 100 for i in range(len(prices) - k + 1): subarray = prices[i:i+k] savings = sum(subarray) * discount max_saving = max(max_saving, savings) return max_saving"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]: Given the root of the binary tree, returns a list of lists, where each sub-list represents one level of the tree. >>> root = TreeNode(1) >>> Solution().levelOrder(root) [[1]] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> Solution().levelOrder(root) [[1], [2, 3]] >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) >>> Solution().levelOrder(root) [[1], [2, 3], [4]] >>> Solution().levelOrder(None) [] >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, TreeNode(6, None, TreeNode(8)), TreeNode(7))) >>> Solution().levelOrder(root) [[1], [2, 3], [4, 5, 6, 7], [8]]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for i in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def run_length_encode(s: str, n: int) -> str: Encodes the string \`s\` using run-length encoding with segment length limited to \`n\`. Parameters: s (str): The input string to be encoded. n (int): The maximum length of any encoded segment. Returns: str: The encoded string.","solution":"def run_length_encode(s, n): Encodes the string \`s\` using run-length encoding with segment length limited to \`n\`. Parameters: s (str): The input string to be encoded. n (int): The maximum length of any encoded segment. Returns: str: The encoded string. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: while count > n: encoded_string.append(f\\"{current_char}{n}\\") count -= n encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 while count > n: encoded_string.append(f\\"{current_char}{n}\\") count -= n encoded_string.append(f\\"{current_char}{count}\\") return \\"\\".join(encoded_string)"},{"question":"def unshuffle_string(s: str, indexes: List[int]) -> str: Return the original string by rearranging the characters of 's' using the 'indexes' array. >>> unshuffle_string(\\"aiohn\\", [3, 1, 4, 2, 0]) 'nihao' >>> unshuffle_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) 'leetcode' >>> unshuffle_string(\\"a\\", [0]) 'a' >>> unshuffle_string(\\"abc\\", [0, 1, 2]) 'abc' >>> unshuffle_string(\\"dcba\\", [3, 2, 1, 0]) 'abcd'","solution":"def unshuffle_string(s, indexes): Returns the original string by rearranging the characters of 's' using the 'indexes' array. n = len(s) result = [''] * n for i, char in enumerate(s): result[indexes[i]] = char return ''.join(result)"},{"question":"def can_sum(nums: List[int], target: int) -> bool: Given an array of integers \`nums\` and an integer \`target\`, return True if you can sum up to the target using the elements in the array. Each number in the array can be used multiple times, otherwise return False. >>> can_sum([2, 3], 7) == True >>> can_sum([2, 4], 7) == False >>> can_sum([7], 7) == True >>> can_sum([1, 2, 3], 0) == True >>> can_sum([5, 3, 4, 7], 2) == False >>> can_sum([2, 3], 300) == True >>> can_sum([5, 6, 7], 12) == True","solution":"def can_sum(nums, target): Returns True if the target can be summed using elements in nums, otherwise False. Each number in nums can be used multiple times. dp = [False] * (target + 1) dp[0] = True for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"class Solution: def __init__(self, s: str, indices: List[int]): Initializes the object with the shuffled string s and the array indices. self.s = s self.indices = indices def restore(self) -> str: Returns the original string by sorting the characters of s according to the given indices array. >>> Solution(\\"abc\\", [2, 1, 0]).restore() \\"cba\\" >>> Solution(\\"aabbcc\\", [5, 4, 3, 2, 1, 0]).restore() \\"ccbbaa\\" >>> Solution(\\"hlowrdelo\\", [0, 1, 2, 3, 4, 5, 6, 7, 8]).restore() \\"hlowrdelo\\" >>> Solution(\\"edcba\\", [4, 3, 2, 1, 0]).restore() \\"abcde\\" >>> Solution(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]).restore() \\"leetcode\\"","solution":"class Solution: def __init__(self, s, indices): Initializes the object with the shuffled string s and the array indices. self.s = s self.indices = indices def restore(self): Returns the original string by sorting the characters of s according to the given indices array. original = [''] * len(self.s) for i, idx in enumerate(self.indices): original[idx] = self.s[i] return ''.join(original)"},{"question":"from typing import List def find_visible_buildings(heights: List[int]) -> List[bool]: Returns a list of booleans indicating if corresponding buildings are visible. A building is visible if there are no taller buildings to its right. >>> find_visible_buildings([1, 2, 3]) [False, False, True] >>> find_visible_buildings([3, 2, 1]) [True, True, True] >>> find_visible_buildings([3, 2, 4, 1]) [False, False, True, True] >>> find_visible_buildings([1]) [True] >>> find_visible_buildings([]) [] >>> find_visible_buildings([2, 2, 2]) [False, False, True]","solution":"def find_visible_buildings(heights): Returns a list of booleans indicating if corresponding buildings are visible. A building is visible if there are no taller buildings to its right. n = len(heights) if n == 0: return [] visible = [False] * n max_height_to_right = 0 for i in reversed(range(n)): if heights[i] > max_height_to_right: visible[i] = True max_height_to_right = heights[i] return visible"},{"question":"from typing import List def min_elements_to_remove(arr: List[int], k: int) -> int: Given an integer array \`arr\` and an integer \`k\`, return the minimum number of elements that need to be removed from \`arr\` to make the array such that the absolute difference between the maximum and minimum element in the modified array is less than or equal to \`k\`. # Test Cases def test_min_elements_to_remove_same_elements(): arr = [1, 1, 1, 1] k = 0 assert min_elements_to_remove(arr, k) == 0 def test_min_elements_to_remove_no_removal_needed(): arr = [1, 2, 3, 4] k = 3 assert min_elements_to_remove(arr, k) == 0 def test_min_elements_to_remove_all_removable(): arr = [1, 10, 20, 30] k = 5 assert min_elements_to_remove(arr, k) == 3 def test_min_elements_to_remove_some_removal(): arr = [1, 3, 6, 9, 11, 17] k = 5 assert min_elements_to_remove(arr, k) == 3 def test_min_elements_to_remove_large_k(): arr = [1, 2, 3, 10, 20, 30] k = 50 assert min_elements_to_remove(arr, k) == 0 def test_min_elements_to_remove_single_element(): arr = [5] k = 10 assert min_elements_to_remove(arr, k) == 0 def test_min_elements_to_remove_empty_array(): arr = [] k = 5 assert min_elements_to_remove(arr, k) == 0","solution":"def min_elements_to_remove(arr, k): Returns the minimum number of elements that need to be removed to make the difference between the maximum and minimum elements in the array less than or equal to k. arr.sort() n = len(arr) left = 0 right = 0 max_elements_to_keep = 0 while right < n: if arr[right] - arr[left] <= k: max_elements_to_keep = max(max_elements_to_keep, right - left + 1) right += 1 else: left += 1 return n - max_elements_to_keep"},{"question":"def remove_characters(text: str, indices: List[int]) -> str: Remove characters from \`text\` at the indices specified in \`indices\`. The resulting string retains the order of the remaining characters. Parameters: text (str): The input string. indices (List[int]): The indices of characters to be removed from \`text\`. Returns: str: The resulting string after removal. Examples: >>> remove_characters(\\"hello\\", [0, 1]) 'llo' >>> remove_characters(\\"hello\\", [4]) 'hell' >>> remove_characters(\\"hello\\", []) 'hello' >>> remove_characters(\\"hello\\", [0, 1, 2, 3, 4]) '' >>> remove_characters(\\"\\", [0]) '' >>> remove_characters(\\"a\\", [0]) '' >>> remove_characters(\\"ab\\", [1]) 'a' >>> remove_characters(\\"ab\\", [0]) 'b' >>> remove_characters(\\"abcdef\\", [1, 3, 5]) 'ace' >>> remove_characters(\\"abcdef\\", [0, 2, 4]) 'bdf'","solution":"def remove_characters(text, indices): Removes characters from \`text\` at the indices specified in \`indices\`. The resulting string retains the order of the remaining characters. Parameters: - text: str, the input string. - indices: list of int, the indices of characters to be removed from \`text\`. Returns: - str, the resulting string after removal. # Convert indices list to set for O(1) lookup indices_set = set(indices) # Build the new string skipping indices specified in indices_set return ''.join(char for i, char in enumerate(text) if i not in indices_set)"},{"question":"def type_with_max_sum(items: List[List[int]]) -> int: Given a 2D integer array \`items\` where each \`items[i] = [type_i, value_i]\` represents an item with a type and its associated value, return the type that has the maximum sum of associated values. If there is a tie, return the smallest type among them. >>> type_with_max_sum([[1, 10], [2, 5], [1, 7], [3, 8]]) == 1 >>> type_with_max_sum([[1, 10]]) == 1 >>> type_with_max_sum([[1, 10], [2, 5]]) == 1 >>> type_with_max_sum([[1, 10], [2, 10], [3, 10]]) == 1 >>> type_with_max_sum([[1, 1000], [2, 2000], [1, 3000]]) == 1 >>> type_with_max_sum([[1, 3], [2, 10], [2, 1], [3, 5], [1, 7], [3, 20], [4, 13], [3, 10], [4, 10]]) == 3","solution":"def type_with_max_sum(items): Returns the type that has the maximum sum of associated values. If there is a tie, returns the smallest type among them. from collections import defaultdict type_sum = defaultdict(int) # Calculate the sum for each type for type_i, value_i in items: type_sum[type_i] += value_i # Find the type with the maximum sum max_sum = max(type_sum.values()) max_sum_types = [type_i for type_i, total in type_sum.items() if total == max_sum] return min(max_sum_types)"},{"question":"def swap_ab(s: str) -> str: Perform the 'ab' to 'ba' swapping move until no more moves can be done. >>> swap_ab(\\"ab\\") == \\"ba\\" >>> swap_ab(\\"abab\\") == \\"bbaa\\" >>> swap_ab(\\"baba\\") == \\"bbaa\\" >>> swap_ab(\\"aaaa\\") == \\"aaaa\\" >>> swap_ab(\\"bbbb\\") == \\"bbbb\\" >>> swap_ab(\\"aabb\\") == \\"bbaa\\" >>> swap_ab(\\"ba\\") == \\"ba\\"","solution":"def swap_ab(s): Perform the 'ab' to 'ba' swapping move until no more moves can be done. while 'ab' in s: s = s.replace('ab', 'ba', 1) return s"},{"question":"def reverse_words(s: str) -> str: Return the input string with the words in reversed order. >>> reverse_words(\\"Hello\\") == \\"Hello\\" >>> reverse_words(\\"Hello world\\") == \\"world Hello\\" >>> reverse_words(\\"The quick brown fox jumps over the lazy dog\\") == \\"dog lazy the over jumps fox brown quick The\\" >>> reverse_words(\\" The quick brown fox jumps \\") == \\"jumps fox brown quick The\\" >>> reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\"Hello, world!\\") == \\"world! Hello,\\" >>> reverse_words(\\"123 456 789\\") == \\"789 456 123\\"","solution":"def reverse_words(s): Returns the input string with the words in reversed order. Parameters: s (str): The input string representing a sentence. Returns: str: The sentence with words in reversed order. # Split the string into words based on spaces words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a single string with a single space separator reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def reverseStr(s: str, k: int) -> str: Given a string s and an integer k, reverse the order of the first k characters of s, the order of the second k characters of s, the order of the third k characters of s, and so on. If there are fewer than k characters left in a segment, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original. Return the altered string as the result. >>> reverseStr(\\"abcdefg\\", 2) -> \\"bacdfeg\\" >>> reverseStr(\\"abcdefgh\\", 4) -> \\"dcbaefgh\\" >>> reverseStr(\\"abc\\", 5) -> \\"cba\\" >>> reverseStr(\\"abcd\\", 4) -> \\"dcba\\" >>> reverseStr(\\"\\", 3) -> \\"\\" >>> reverseStr(\\"a\\", 3) -> \\"a\\" >>> reverseStr(\\"abcdef\\", 3) -> \\"cbadef\\" >>> reverseStr(\\"abcdefghij\\", 2) -> \\"bacdfeghji\\" pass","solution":"def reverseStr(s, k): Reverse the first k characters for every 2k characters in the string. :param s: input string :param k: number of characters to reverse in each segment :return: string with specified segments reversed result = [] for i in range(0, len(s), 2 * k): part1 = s[i:i + k][::-1] # Reverse first k characters part2 = s[i + k:i + 2 * k] # Leave rest as original until next 2k segment result.append(part1 + part2) return ''.join(result)"},{"question":"def rob(nums): Returns the maximum amount of money that can be stolen without stealing from two adjacent houses. Since the houses are arranged in a circular manner, we consider two cases: 1. Including the first house and not the last. 2. Including the last house and not the first. >>> rob([]) == 0 >>> rob([4]) == 4 >>> rob([2, 3]) == 3 >>> rob([2, 3, 2]) == 3 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 3, 2, 5, 7]) == 10 >>> rob([10, 1, 2, 10, 5, 2]) == 20","solution":"def rob(nums): Returns the maximum amount of money that can be stolen without stealing from two adjacent houses. Since the houses are arranged in a circular manner, we consider two cases: 1. Including the first house and not the last. 2. Including the last house and not the first. if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] def rob_linear(houses): prev = curr = 0 for house in houses: prev, curr = curr, max(curr, prev + house) return curr # Exclude last house, include first house max1 = rob_linear(nums[:-1]) # Exclude first house, include last house max2 = rob_linear(nums[1:]) return max(max1, max2)"},{"question":"def find_itinerary(tickets: List[List[str]]) -> List[str]: Use a list of flight tickets to construct an itinerary starting from 'JFK' such that you visit all airports exactly once and return to the starting airport. The itinerary should have the smallest lexical order when read as a single string. If no flights are available, return ['JFK']. >>> find_itinerary([[\\"MUC\\", \\"LHR\\"], [\\"JFK\\", \\"MUC\\"], [\\"SFO\\", \\"SJC\\"], [\\"LHR\\", \\"SFO\\"]]) [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] >>> find_itinerary([[\\"JFK\\", \\"KUL\\"], [\\"JFK\\", \\"NRT\\"], [\\"NRT\\", \\"JFK\\"]]) [\\"JFK\\", \\"NRT\\", \\"JFK\\", \\"KUL\\"]","solution":"def find_itinerary(tickets): from collections import defaultdict import heapq # Build the graph graph = defaultdict(list) for frm, to in tickets: heapq.heappush(graph[frm], to) # Use stack to perform Depth-First Search (DFS) stack = [\\"JFK\\"] path = [] while stack: # Loop to ensure that we use valid tickets from current node while graph[stack[-1]]: next_dest = heapq.heappop(graph[stack[-1]]) stack.append(next_dest) path.append(stack.pop()) # The path is constructed in reverse order, so reverse it at the end return path[::-1]"},{"question":"def reverseWords(s: str) -> str: Write a function \`reverseWords\` that takes a string \`s\` as input, which consists of words and whitespaces. The function should reverse the order of the words in the string while preserving whitespace and initial word order within the sentence. Words are defined as sequences of non-whitespace characters. Multiple spaces between words should be reduced to a single space in the output. The function should return the modified string. >>> reverseWords(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverseWords(\\" the sky is blue \\") \\"blue is sky the\\" >>> reverseWords(\\"hello\\") \\"hello\\" >>> reverseWords(\\"\\") \\"\\" >>> reverseWords(\\" hello \\") \\"hello\\" >>> reverseWords(\\"a b c d e f g\\") \\"g f e d c b a\\" >>> reverseWords(\\" \\") \\"\\"","solution":"def reverseWords(s): Reverses the order of the words in the string while preserving whitespace and initial word order within the sentence. Multiple spaces between words should be reduced to a single space. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Determine whether there exists a contiguous subarray of length k that has the highest possible sum of elements among all contiguous subarrays of the same length. Return the starting index of such a subarray. If there are multiple subarrays with the same maximum sum, return the starting index of the first one. If k is greater than the length of the array, return -1. >>> max_sum_subarray([1, 2, 3], 4) -1 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 0 >>> max_sum_subarray([1, 2, 3, 4, 5], 2) 3 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) 0 >>> max_sum_subarray([1, -2, 3, 10, -4, 7, 2, -5], 3) 3 >>> max_sum_subarray([1, 2, 3, 4, 3, 4, 3], 2) 2","solution":"def max_sum_subarray(arr, k): Returns the starting index of the contiguous subarray of length k that has the highest possible sum. If k is greater than the length of the array, returns -1. n = len(arr) if k > n: return -1 max_sum = sum(arr[:k]) current_sum = max_sum start_index = 0 for i in range(1, n - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum start_index = i return start_index"},{"question":"def can_transform(s: str, t: str) -> bool: Returns True if it is possible to transform string \`s\` into string \`t\` using exactly three types of operations: 1. Swap any two characters in \`s\`. 2. Change any character in \`s\` to any other lowercase letter. 3. Reverse the whole string \`s\`. Otherwise, returns False. >>> can_transform(\\"abc\\", \\"cab\\") True >>> can_transform(\\"abc\\", \\"abcd\\") False >>> can_transform(\\"a\\", \\"a\\") True >>> can_transform(\\"aaabbbb\\", \\"bbabbaa\\") True >>> can_transform(\\"abc\\", \\"def\\") False","solution":"def can_transform(s, t): Returns True if it is possible to transform string \`s\` into string \`t\` using the given operations. return sorted(s) == sorted(t)"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups words that are anagrams of each other. Args: words (list of str): The list of words to be grouped. Returns: list of list of str: A list of groups, where each group contains anagrams. >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\"]) [['listen', 'silent', 'enlist'], ['rat', 'tar', 'art']] >>> group_anagrams([\\"hello\\", \\"world\\"]) [['hello'], ['world']] >>> group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\", \\"tac\\", \\"act\\"]) [['bat', 'tab'], ['cat', 'tac', 'act']] >>> group_anagrams([]) [] >>> group_anagrams([\\"word\\"]) [['word']]","solution":"from collections import defaultdict def group_anagrams(words): Groups words that are anagrams of each other. Args: words (list of str): The list of words to be grouped. Returns: list of list of str: A list of groups, where each group contains anagrams. anagrams = defaultdict(list) for word in words: # Sort each word and use it as the key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"from typing import List, Optional def max_depth(level_order: List[Optional[int]]) -> int: Calculate the maximum depth of a binary tree represented by a level order traversal list. >>> max_depth([None]) 0 >>> max_depth([]) 0 >>> max_depth([1]) 1 >>> max_depth([1, 2, 3, 4, 5, 6, 7]) 3 >>> max_depth([1, 2, None, 3, None, None, None, 4]) 4 >>> max_depth([1, 2, 3, None, 4, None, 5]) 3","solution":"from typing import List, Optional from collections import deque def max_depth(level_order: List[Optional[int]]) -> int: Calculate the maximum depth of a binary tree represented by a level order traversal list. if not level_order or level_order[0] is None: return 0 index = 0 level = 0 queue = deque([index]) while queue: level += 1 for _ in range(len(queue)): idx = queue.popleft() left_child_idx = 2 * idx + 1 right_child_idx = 2 * idx + 2 if left_child_idx < len(level_order) and level_order[left_child_idx] is not None: queue.append(left_child_idx) if right_child_idx < len(level_order) and level_order[right_child_idx] is not None: queue.append(right_child_idx) return level"},{"question":"import math from typing import List def count_good_strings(n: int) -> int: Returns the number of good strings of length n that can be formed using only lowercase English letters. A good string must have all unique characters. >>> count_good_strings(1) == 26 >>> count_good_strings(2) == 650 >>> count_good_strings(3) == 15600 >>> count_good_strings(26) == math.factorial(26) >>> count_good_strings(27) == 0","solution":"import math def count_good_strings(n): Returns the number of good strings of length n that can be formed using only lowercase English letters. Good strings have all unique characters. if n > 26: return 0 return math.perm(26, n)"},{"question":"from typing import List def countCharacters(words: List[str], chars: str) -> int: Given a list of strings \`words\` and a list of characters \`chars\`, return the length of all words that can be formed using characters from \`chars\` without reusing characters from \`chars\`. Each character in \`chars\` can only be used once for each word. >>> countCharacters([\\"cat\\",\\"bt\\",\\"hat\\",\\"tree\\"], \\"atach\\") 6 >>> countCharacters([\\"hello\\",\\"world\\",\\"leetcode\\"], \\"welldonehoneyr\\") 10 >>> countCharacters([\\"hello\\",\\"world\\"], \\"abcdefg\\") 0 >>> countCharacters([], \\"abcdefg\\") 0 >>> countCharacters([\\"hello\\",\\"world\\"], \\"\\") 0 >>> countCharacters([\\"aaa\\",\\"bbb\\"], \\"xyz\\") 0 >>> countCharacters([\\"aaaa\\",\\"aabb\\"], \\"aabb\\") 4","solution":"def countCharacters(words, chars): from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[c] <= chars_count[c] for c in word_count): total_length += len(word) return total_length"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def getMinimumDifference(root): Returns the minimum absolute difference between the values of any two different nodes in the BST. >>> single_node_tree = TreeNode(1) >>> getMinimumDifference(single_node_tree) inf >>> two_node_tree = TreeNode(1) >>> two_node_tree.right = TreeNode(3) >>> getMinimumDifference(two_node_tree) 2 >>> three_node_balanced_tree = TreeNode(4) >>> three_node_balanced_tree.left = TreeNode(2) >>> three_node_balanced_tree.right = TreeNode(6) >>> three_node_balanced_tree.left.left = TreeNode(1) >>> three_node_balanced_tree.left.right = TreeNode(3) >>> getMinimumDifference(three_node_balanced_tree) 1 >>> bst_with_neg_values = TreeNode(0) >>> bst_with_neg_values.left = TreeNode(-3) >>> bst_with_neg_values.right = TreeNode(9) >>> bst_with_neg_values.left.left = TreeNode(-10) >>> bst_with_neg_values.left.right = TreeNode(-2) >>> bst_with_neg_values.right.right = TreeNode(18) >>> getMinimumDifference(bst_with_neg_values) 1 >>> large_tree = TreeNode(15) >>> large_tree.left = TreeNode(5) >>> large_tree.right = TreeNode(20) >>> large_tree.left.left = TreeNode(3) >>> large_tree.left.right = TreeNode(6) >>> large_tree.right.left = TreeNode(18) >>> large_tree.right.right = TreeNode(25) >>> getMinimumDifference(large_tree) 1","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def getMinimumDifference(root): Returns the minimum absolute difference between the values of any two different nodes in the BST. def in_order_traversal(node, values): Perform in-order traversal and collect node values. if node is None: return in_order_traversal(node.left, values) values.append(node.val) in_order_traversal(node.right, values) values = [] in_order_traversal(root, values) min_diff = float('inf') for i in range(1, len(values)): min_diff = min(min_diff, values[i] - values[i-1]) return min_diff"},{"question":"from typing import List def canTypeSentence(words: List[str], s: str) -> bool: Determine if the sentence can be typed using the letters from the given dictionary. Each letter can only be used once. >>> canTypeSentence([\\"hello\\", \\"world\\"], \\"hello world\\") True >>> canTypeSentence([\\"hello\\", \\"world\\"], \\"helloo world\\") False","solution":"from typing import List def canTypeSentence(words: List[str], s: str) -> bool: Returns True if the sentence \`s\` can be typed using the provided list of words, False otherwise. Each letter can only be used once. # Create a dictionary to count the frequency of each character in words list letter_count = {} for word in words: for letter in word: if letter not in letter_count: letter_count[letter] = 0 letter_count[letter] += 1 # Check if we can form the sentence s with the given letters for letter in s: if letter != ' ': if letter not in letter_count or letter_count[letter] == 0: return False letter_count[letter] -= 1 return True"},{"question":"def max_subarray_sum_circular(nums): Returns the maximum sum of any subarray within the circular array nums. >>> max_subarray_sum_circular([1, -2, 3, -2]) 3 >>> max_subarray_sum_circular([5, -3, 5]) 10 >>> max_subarray_sum_circular([3, -1, 2, -1]) 4 >>> max_subarray_sum_circular([3, -2, 2, -3]) 3 >>> max_subarray_sum_circular([-2, -3, -1]) -1 >>> max_subarray_sum_circular([8, -8, 9, -9, 10, -11, 12]) 22 >>> max_subarray_sum_circular([5, -2, 5, 6, -4]) 14 # Your code goes here","solution":"def max_subarray_sum_circular(nums): Returns the maximum sum of any subarray within the circular array nums. def kadane(arr): curr_sum = max_sum = arr[0] for num in arr[1:]: curr_sum = max(num, curr_sum + num) max_sum = max(max_sum, curr_sum) return max_sum max_kadane = kadane(nums) total_sum = sum(nums) for i in range(len(nums)): nums[i] = -nums[i] inverted_kadane = kadane(nums) max_wraparound = total_sum + inverted_kadane if max_wraparound == 0: return max_kadane else: return max(max_kadane, max_wraparound)"},{"question":"def min_operations_to_make_strings_identical(s1: str, s2: str) -> int: Determine the minimum number of operations required to make \`s1\` and \`s2\` identical. You are allowed to perform two operations on the strings: 1. Choose a character from \`s1\` and move it to the start of \`s2\`. 2. Choose a character from \`s2\` and move it to the start of \`s1\`. Returns the minimum number of operations needed or -1 if it is impossible to make the two strings identical. >>> min_operations_to_make_strings_identical(\\"abc\\", \\"bca\\") 2 >>> min_operations_to_make_strings_identical(\\"aab\\", \\"bba\\") -1 >>> min_operations_to_make_strings_identical(\\"xxy\\", \\"yxx\\") 1 >>> min_operations_to_make_strings_identical(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_make_strings_identical(\\"ab\\", \\"cd\\") -1 pass","solution":"def min_operations_to_make_strings_identical(s1, s2): Determine the minimum number of operations to make the two strings identical. Returns the minimum number of operations needed or -1 if it is impossible. if sorted(s1) != sorted(s2): return -1 # Use two pointers starting from the end of s1 and s2 i, j = len(s1) - 1, len(s2) - 1 ops = 0 while i >= 0 and j >= 0: if s1[i] == s2[j]: j -= 1 else: ops += 1 i -= 1 return ops"},{"question":"from typing import List, Tuple def find_pairs(arr: List[int], sum: int) -> List[Tuple[int, int]]: Returns a list of unique pairs (a, b) from arr such that a + b equals sum and a <= b. >>> find_pairs([1, 2, 3], 6) == [] >>> find_pairs([1, 2, 3], 4) == [(1, 3)] >>> sorted(find_pairs([1, 2, 3, 2, 1], 4)) == sorted([(1, 3), (2, 2)]) >>> find_pairs([1, 1, 1, 1], 2) == [(1, 1)] >>> sorted(find_pairs([-1, -2, 1, 2, 3, 4], 1)) == sorted([(-2, 3), (-1, 2)]) >>> find_pairs([], 10) == [] >>> sorted(find_pairs([0, 0, 0, 0], 0)) == [(0, 0)]","solution":"from typing import List, Tuple def find_pairs(arr: List[int], sum: int) -> List[Tuple[int, int]]: Returns a list of unique pairs (a, b) from arr such that a + b equals sum and a <= b. pairs = set() seen = set() for num in arr: complement = sum - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return list(pairs)"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Return all unique quadruples [nums[a], nums[b], nums[c], nums[d]] such that: 0 <= a, b, c, d < len(nums) and a, b, c, and d are distinct, and nums[a] + nums[b] + nums[c] + nums[d] == target. Examples: >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]]","solution":"def four_sum(nums, target): Returns all unique quadruples [nums[a], nums[b], nums[c], nums[d]] that sum up to the target. nums.sort() results, n = [], len(nums) for i in range(n-3): if i > 0 and nums[i] == nums[i-1]: # skip duplicate 'i' continue for j in range(i+1, n-2): if j > i+1 and nums[j] == nums[j-1]: # skip duplicate 'j' continue left, right = j+1, n-1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: results.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: # skip duplicate 'left' left += 1 while left < right and nums[right] == nums[right-1]: # skip duplicate 'right' right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return results"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the letters of the string \`s\` can be rearranged to form a palindrome. :param s: The input string containing letters, digits, and special characters. :type s: str :return: True if the letters can be rearranged to form a palindrome, False otherwise. :rtype: bool >>> can_form_palindrome(\\"aabbcc\\") == True >>> can_form_palindrome(\\"aabbccc\\") == True >>> can_form_palindrome(\\"abc\\") == False >>> can_form_palindrome(\\"a!a@bb\\") == True >>> can_form_palindrome(\\"a1a2b3b\\") == True >>> can_form_palindrome(\\"AaBb\\") == False >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"\\") == True","solution":"from collections import Counter def can_form_palindrome(s): Determines if the letters of the string \`s\` can be rearranged to form a palindrome. :param s: The input string containing letters, digits, and special characters. :type s: str :return: True if the letters can be rearranged to form a palindrome, False otherwise. :rtype: bool # Filter out non-letter characters letters = [char for char in s if char.isalpha()] # Count the frequency of each letter letter_count = Counter(letters) # Count how many letters have an odd frequency odd_count = sum(1 for count in letter_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one letter with an odd frequency return odd_count <= 1"},{"question":"def calculate(expression: str) -> int: Calculate the result of the mathematical expression consisting of non-negative integers and operators +, -, *, and parentheses (). >>> calculate(\\"1+1\\") 2 >>> calculate(\\"2+3*4\\") 14 >>> calculate(\\"(2+3)*4\\") 20 >>> calculate(\\"3+(2*2)-1\\") 6 >>> calculate(\\"((2+3)*4)-3\\") 17 >>> calculate(\\"10-3-2\\") 5","solution":"def calculate(expression): def update_op(op, v): if op == '+': stack.append(v) if op == '-': stack.append(-v) if op == '*': stack.append(stack.pop() * v) if op == '/': stack.append(int(stack.pop() / v)) stack = [] num, op = 0, '+' i = 0 while i < len(expression): if expression[i].isdigit(): num = num * 10 + int(expression[i]) elif expression[i] in '+-*/': update_op(op, num) num, op = 0, expression[i] elif expression[i] == '(': j = i braces = 0 while True: if expression[j] == '(': braces += 1 if expression[j] == ')': braces -= 1 if braces == 0: break j += 1 num = calculate(expression[i + 1:j]) i = j i += 1 update_op(op, num) return sum(stack)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_traversal(root): Return the nodes' values in a zigzag traversal order. >>> zigzag_traversal(TreeNode(1, TreeNode(2), TreeNode(3))) [1, 3, 2] >>> zigzag_traversal(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))) [1, 3, 2, 4, 5, 6, 7] >>> zigzag_traversal(None) [] >>> zigzag_traversal(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) [1, 2, 3] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_traversal(root): Return the nodes' values in a zigzag traversal order. if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [] next_level = [] for node in current_level: level_values.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_values.reverse() result.extend(level_values) current_level = next_level left_to_right = not left_to_right return result"},{"question":"from collections import Counter def min_operations_to_no_adjacent(s: str) -> int: Determine the minimum number of operations needed so that no two adjacent characters in the string are the same. You can perform an operation where you choose one character and move it to the beginning of the string. Args: s (str): The input string containing only lowercase English letters. Returns: int: The minimum number of such operations needed, or -1 if it is impossible. >>> min_operations_to_no_adjacent(\\"aaaa\\") == -1 >>> min_operations_to_no_adjacent(\\"aaaab\\") == -1 >>> min_operations_to_no_adjacent(\\"abab\\") == 0 >>> min_operations_to_no_adjacent(\\"abcabc\\") == 0 >>> min_operations_to_no_adjacent(\\"a\\") == 0 >>> min_operations_to_no_adjacent(\\"aabb\\") == 0 # Example, proper logic needed for actual steps >>> min_operations_to_no_adjacent(\\"aaabbbccc\\") == 0 # Example, proper logic needed for actual steps","solution":"from collections import Counter def min_operations_to_no_adjacent(s: str) -> int: counter = Counter(s) max_count = max(counter.values()) n = len(s) if max_count > (n + 1) // 2: return -1 else: return 0 # Further implementation needed for actual moves calculations."},{"question":"class Node: def __init__(self, val, prev=None, next=None, child=None): self.val = val self.prev = prev self.next = next self.child = child def flatten(head: Node) -> Node: Given a doubly linked list with additional \`child\` pointers, flatten the list so that all nodes appear in a single-level doubly linked list and return the head of the flattened list. >>> head = Node(1) >>> node2 = Node(2) >>> head.next = node2 >>> node2.prev = head >>> node3 = Node(3) >>> node2.child = node3 >>> flattened = flatten(head) >>> list_to_array(flattened) == [1, 2, 3] True def list_to_array(head: Node) -> list: Convert the doubly linked list to an array representation for testing. array = [] while head: array.append(head.val) head = head.next return array # Tests import pytest def test_flatten_empty_list(): assert flatten(None) is None def test_flatten_single_node_no_child(): node = Node(1) assert list_to_array(flatten(node)) == [1] def test_flatten_multi_level_list(): node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) node1.next = node2 node2.prev = node1 node2.next = node3 node3.prev = node2 node3.child = node4 node4.next = node5 node5.prev = node4 expected = [1, 2, 3, 4, 5] assert list_to_array(flatten(node1)) == expected def test_flatten_complex_list(): node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) node6 = Node(6) node7 = Node(7) node1.next = node2 node2.prev = node1 node2.next = node3 node3.prev = node2 node2.child = node4 node4.next = node5 node5.prev = node4 node5.child = node6 node6.next = node7 node7.prev = node6 expected = [1, 2, 4, 5, 6, 7, 3] assert list_to_array(flatten(node1)) == expected","solution":"class Node: def __init__(self, val, prev=None, next=None, child=None): self.val = val self.prev = prev self.next = next self.child = child def flatten(head): if not head: return None current = head stack = [] while current: if current.child: if current.next: stack.append(current.next) current.next = current.child current.child.prev = current current.child = None if not current.next and stack: current.next = stack.pop() current.next.prev = current current = current.next return head"},{"question":"def find_duplicates(item_codes: List[str]) -> List[str]: Returns a list of duplicate item codes in sorted order. >>> find_duplicates([\\"A\\", \\"B\\", \\"C\\", \\"D\\"]) == [] >>> find_duplicates([\\"A\\", \\"B\\", \\"C\\", \\"A\\"]) == [\\"A\\"] >>> find_duplicates([\\"A\\", \\"B\\", \\"B\\", \\"C\\", \\"C\\", \\"C\\", \\"D\\"]) == [\\"B\\", \\"C\\"] >>> find_duplicates([\\"A\\", \\"A\\", \\"A\\", \\"A\\"]) == [\\"A\\"] >>> find_duplicates([\\"A\\", \\"b\\", \\"B\\", \\"a\\", \\"A\\", \\"B\\"]) == [\\"A\\", \\"B\\"] >>> find_duplicates([]) == []","solution":"def find_duplicates(item_codes): Returns a list of duplicate item codes in sorted order. Args: item_codes (list): List of item codes as strings. Returns: list: Sorted list of duplicate item codes. from collections import Counter # Count the occurrences of each item code count = Counter(item_codes) # Find the item codes that have a count greater than 1 (duplicates) duplicates = [item for item, freq in count.items() if freq > 1] # Return the duplicates in sorted order return sorted(duplicates)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the N-th node from the end of the list and returns its head. pass def list_to_array(head): array = [] while head: array.append(head.val) head = head.next return array def array_to_list(array): dummy = ListNode() current = dummy for value in array: current.next = ListNode(value) current = current.next return dummy.next def test_remove_nth_from_end(): # Case 1: Remove the last element from the list [1,2,3,4,5] head = array_to_list([1, 2, 3, 4, 5]) new_head = remove_nth_from_end(head, 1) assert list_to_array(new_head) == [1, 2, 3, 4] # Case 2: Remove the third element from the end of the list [1,2,3,4,5] head = array_to_list([1, 2, 3, 4, 5]) new_head = remove_nth_from_end(head, 3) assert list_to_array(new_head) == [1, 2, 4, 5] # Case 3: Remove the first element from the list [1] head = array_to_list([1]) new_head = remove_nth_from_end(head, 1) assert list_to_array(new_head) == [] # Case 4: Remove the second element from the list [1, 2] head = array_to_list([1, 2]) new_head = remove_nth_from_end(head, 1) assert list_to_array(new_head) == [1] # Case 5: Remove the first element (also the last element) from the list [1, 2] head = array_to_list([1, 2]) new_head = remove_nth_from_end(head, 2) assert list_to_array(new_head) == [2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the N-th node from the end of the list and returns its head. dummy = ListNode(0, head) fast = slow = dummy # Move fast ahead by n+1 steps to maintain a gap of n between slow and fast for _ in range(n + 1): fast = fast.next # Move both fast and slow until fast reaches the end while fast: fast = fast.next slow = slow.next # Slow is now pointing to the node just before the node to be removed slow.next = slow.next.next return dummy.next"},{"question":"def is_happy_string(word: str) -> bool: Determine if a given word is a \\"happy string\\". A word is a \\"happy string\\" if there are no two consecutive letters that are the same. >>> is_happy_string(\\"a\\") True >>> is_happy_string(\\"abc\\") True >>> is_happy_string(\\"abac\\") True >>> is_happy_string(\\"aabbcc\\") False >>> is_happy_string(\\"aabbccdd\\") False >>> is_happy_string(\\"abcaabb\\") False >>> is_happy_string(\\"abcdabc\\") True >>> is_happy_string(\\"\\") True >>> is_happy_string(\\"aa\\") False >>> is_happy_string(\\"ab\\") True","solution":"def is_happy_string(word): Returns True if the word is a \\"happy string\\", False otherwise. A word is a \\"happy string\\" if there are no two consecutive letters that are the same. for i in range(len(word) - 1): if word[i] == word[i + 1]: return False return True"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, return the length of the longest substring of s that contains only unique characters. >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"aab\\") == 2 >>> length_of_longest_substring(\\"abcdefg\\") == 7 >>> length_of_longest_substring(\\"pwwkew\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring of s that contains only unique characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def maxJumps(arr: List[int], d: int) -> int: You are given an integer array arr and an integer d. An element in the array can jump to a different index i (0-based) within the array if the following conditions are met: * You can jump to the index i from the current index j if arr[i] < arr[j]. * You can only jump to the indices within the range [j - d, j + d] (inclusive) and should stay inside the boundaries of the array. You need to find out the maximum length of a jump sequence you can generate starting from any index. Return the maximum length of any such jump sequence. >>> maxJumps([6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2) 4 >>> maxJumps([3, 3, 3, 3, 3], 3) 1 >>> maxJumps([7, 6, 5, 4, 3, 2, 1], 1) 7 >>> maxJumps([7, 1, 7, 1, 7, 1], 3) 2 >>> maxJumps([66], 1) 1","solution":"def maxJumps(arr, d): n = len(arr) # Helper function using memoization for recursion def dfs(i): if memo[i] != -1: return memo[i] max_len = 1 # Since minimum length including the element itself is 1 # Look to the left within the boundary for j in range(i-1, max(i-d-1, -1), -1): if arr[j] < arr[i]: max_len = max(max_len, 1 + dfs(j)) else: break # Look to the right within the boundary for j in range(i+1, min(i+d+1, n)): if arr[j] < arr[i]: max_len = max(max_len, 1 + dfs(j)) else: break memo[i] = max_len return memo[i] memo = [-1] * n # Initialize memoization array with -1 max_jump_length = 0 for i in range(n): max_jump_length = max(max_jump_length, dfs(i)) return max_jump_length"},{"question":"from typing import List def maxAreaOfIsland(grid: List[List[int]]) -> int: Given a 2D grid of 0s and 1s, returns the size of the largest island. An island is a group of 1s connected 4-directionally (vertical or horizontal). >>> maxAreaOfIsland([ ... [1, 1, 0, 0, 1], ... [1, 0, 0, 1, 1], ... [0, 0, 1, 0, 0] ... ]) == 3 >>> maxAreaOfIsland([ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 0, 0] ... ]) == 3 >>> maxAreaOfIsland([ ... [1, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 1], ... [0, 1, 1, 1] ... ]) == 7 >>> maxAreaOfIsland([ ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0] ... ]) == 1 >>> maxAreaOfIsland([ ... [0, 0], ... [0, 0] ... ]) == 0","solution":"def maxAreaOfIsland(grid): Given a 2D grid of 0s and 1s, returns the size of the largest island. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0 or visited[r][c]: return 0 visited[r][c] = True return 1 + dfs(r+1, c) + dfs(r-1, c) + dfs(r, c+1) + dfs(r, c-1) max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"def max_segments(slopes: List[int], k: int) -> int: Returns the maximum number of segments that the slopes array can be split into, given each segment's sum of steepness is no more than k. :param slopes: List[int] - List of non-negative integers representing steepness. :param k: int - The maximum allowable sum of slopes in each segment. :returns: int - The maximum number of segments. >>> max_segments([1, 2, 3, 4], 10) 4 >>> max_segments([1, 2, 3, 4], 6) 3 >>> max_segments([5, 1, 3, 2], 5) 2 >>> max_segments([8, 1, 2, 5], 7) 2 >>> max_segments([10], 10) 1 >>> max_segments([], 5) 0","solution":"def max_segments(slopes, k): Returns the maximum number of segments that the slopes array can be split into, given each segment's sum of steepness is no more than k. :param slopes: List[int] - List of non-negative integers representing steepness. :param k: int - The maximum allowable sum of slopes in each segment. :returns: int - The maximum number of segments. n = len(slopes) start = 0 current_sum = 0 segments = 0 for end in range(n): current_sum += slopes[end] while current_sum > k and start <= end: current_sum -= slopes[start] start += 1 if current_sum <= k: segments = max(segments, end - start + 1) return segments"},{"question":"def find_repeating_substring(s: str) -> int: Determines the smallest index i such that the substring s[0:i+1] can be repeated one or more times to form the entire string s. Returns -1 if no such index exists. Examples: >>> find_repeating_substring(\\"abcabcabc\\") 2 >>> find_repeating_substring(\\"abcdef\\") -1 >>> find_repeating_substring(\\"aaaaaa\\") 0 >>> find_repeating_substring(\\"ababab\\") 1 >>> find_repeating_substring(\\"abcd\\") -1 >>> find_repeating_substring(\\"xyzxyzxyzxyz\\") 2 >>> find_repeating_substring(\\"xyxyxyxy\\") 1 >>> find_repeating_substring(\\"abcdabc\\") -1","solution":"def find_repeating_substring(s): Determines the smallest index i such that the substring s[0:i+1] can be repeated one or more times to form the entire string s. Returns -1 if no such index exists. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: substring = s[:i] if substring * (n // i) == s: return i - 1 return -1"},{"question":"from typing import List def orangesRotting(grid: List[List[int]]) -> int: Given an m x n matrix \`board\` representing a grid, where each cell can have one of three values: - 0 representing an empty cell, - 1 representing a fresh orange, - 2 representing a rotten orange, Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. >>> grid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]] >>> orangesRotting(grid) 4 >>> grid = [[2, 1, 1], [0, 1, 1], [1, 0, 1]] >>> orangesRotting(grid) -1 >>> grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> orangesRotting(grid) 0 >>> grid = [[2, 0, 1]] >>> orangesRotting(grid) -1 >>> grid = [[2]] >>> orangesRotting(grid) 0","solution":"from collections import deque def orangesRotting(grid): rows, cols = len(grid), len(grid[0]) queue = deque() fresh = 0 # Initialize the queue with all rotten oranges and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh += 1 # Direction vectors for the 4 possible directions (left, right, top, bottom) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] minutes = 0 # BFS starting from initially rotten oranges while queue and fresh > 0: minutes += 1 for _ in range(len(queue)): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if nr in range(rows) and nc in range(cols) and grid[nr][nc] == 1: grid[nr][nc] = 2 queue.append((nr, nc)) fresh -= 1 return minutes if fresh == 0 else -1"},{"question":"def smallest_lexicographic_string(s: str, words: List[str]) -> str: Returns the lexicographically smallest string that can be formed by concatenating some or all strings from the words list exactly once. >>> smallest_lexicographic_string('', ['apple']) 'apple' >>> smallest_lexicographic_string('', ['banana', 'apple']) 'applebanana' >>> smallest_lexicographic_string('', ['banana', 'apple', 'cherry', 'date']) 'applebananacherrydate' >>> smallest_lexicographic_string('', ['banana', 'apple', 'apple', 'date']) 'appleapplebananadate' >>> smallest_lexicographic_string('', []) '' >>> smallest_lexicographic_string('', ['aaa', 'aaa', 'aaa']) 'aaaaaaaaa'","solution":"def smallest_lexicographic_string(s, words): Returns the lexicographically smallest string that can be formed by concatenating some or all strings from the words list exactly once. words.sort() result = ''.join(words) return result"},{"question":"def move_target_to_end(nums: List[int], target: int) -> List[int]: Moves all occurrences of target to the end of the array while maintaining the relative order of the other elements. Args: nums: List[int] - The input array target: int - The target integer to move to the end Returns: List[int] - The modified array with all occurrences of target moved to the end >>> move_target_to_end([2, 1, 3, 4, 2, 5], 2) [1, 3, 4, 5, 2, 2] >>> move_target_to_end([1, 2, 3, 4, 2, 5, 2], 2) [1, 3, 4, 5, 2, 2, 2]","solution":"def move_target_to_end(nums, target): Moves all occurrences of target to the end of the array while maintaining the relative order of the other elements. Args: nums: List[int] - The input array target: int - The target integer to move to the end Returns: List[int] - The modified array with all occurrences of target moved to the end non_target_index = 0 for i in range(len(nums)): if nums[i] != target: nums[non_target_index] = nums[i] non_target_index += 1 # Fill the rest of the array with the target value for i in range(non_target_index, len(nums)): nums[i] = target return nums"},{"question":"def max_k_consecutive_sum(nums: List[int], k: int) -> int: Return the largest possible sum of any k consecutive elements after rearranging nums. >>> max_k_consecutive_sum([1, 3, 2, 6, 4, 5], 3) 15 >>> max_k_consecutive_sum([1, 2], 3) 0 >>> max_k_consecutive_sum([5, 5, 5, 5], 2) 10 >>> max_k_consecutive_sum([7, 3, 9, 1], 1) 9 >>> max_k_consecutive_sum([2, 4, 6], 3) 12 >>> max_k_consecutive_sum([], 3) 0 >>> max_k_consecutive_sum([10], 1) 10 >>> max_k_consecutive_sum([-1, -2, -3, -4], 2) -3","solution":"def max_k_consecutive_sum(nums, k): Return the largest possible sum of any k consecutive elements after rearranging nums. if len(nums) < k: return 0 sorted_nums = sorted(nums, reverse=True) return sum(sorted_nums[:k])"},{"question":"from typing import List def combination_sum_count(nums: List[int], target: int) -> int: You are given a list of integers \`nums\` representing the values of various items and an integer \`target\` representing the sum you need to achieve using the items. You can use an element from \`nums\` any number of times. Return the number of unique combinations where the sum of the combination is equal to \`target\`. Each combination should be a sorted list of numbers, and the combinations themselves should not be repeated. Order of elements in the combination does not matter but output should be the count of unique combinations. If no combinations can achieve the target, return \`0\`. >>> combination_sum_count([1, 2, 3], 4) 7 >>> combination_sum_count([2, 4], 7) 0 >>> combination_sum_count([5], 10) 1 >>> combination_sum_count([1, 2, 3], 0) 1 >>> combination_sum_count([1, 2], 5) 8","solution":"def combination_sum_count(nums, target): nums.sort() dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if num <= i: dp[i] += dp[i - num] else: break return dp[target]"},{"question":"from typing import List def canAchieveFavoriteCandies(candies: List[int], favorite: List[int]) -> List[bool]: Returns a list of boolean values indicating for each favorite number whether it can be obtained by summing any subset of the given candies. >>> canAchieveFavoriteCandies([1, 2, 3], [3, 2, 4, 6]) == [True, True, True, True] >>> canAchieveFavoriteCandies([1, 2, 3], [5, 7, 0, 10]) == [True, False, True, False] >>> canAchieveFavoriteCandies([], [1, 2, 0]) == [False, False, True] >>> canAchieveFavoriteCandies([10, 20, 30, 40], [15, 50, 60, 70, 25]) == [False, True, True, True, False] >>> canAchieveFavoriteCandies([5, 5, 5, 5], [10, 15, 20]) == [True, True, True]","solution":"def canAchieveFavoriteCandies(candies, favorite): Returns a list of boolean values indicating for each favorite number whether it can be obtained by summing any subset of the given candies. n = len(candies) max_sum = sum(candies) possible_sums = [False] * (max_sum + 1) possible_sums[0] = True # Process each candy to update the possible sums for candy in candies: for i in range(max_sum, candy - 1, -1): if possible_sums[i - candy]: possible_sums[i] = True result = [] for fav in favorite: if fav <= max_sum: result.append(possible_sums[fav]) else: result.append(False) return result"},{"question":"def num_clusters(grid): Determine the number of disconnected clusters of occupied cells in a 2D grid. >>> num_clusters([[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) == 3 >>> num_clusters([[1, 0, 0, 1], [0, 0, 1, 0], [1, 1, 1, 1], [0, 0, 0, 0]]) == 3 >>> num_clusters([[0, 0], [0, 0]]) == 0 >>> num_clusters([[1, 1], [1, 1]]) == 1 >>> num_clusters([[1, 0], [0, 1]]) == 2","solution":"def num_clusters(grid): if not grid or not grid[0]: return 0 def dfs(grid, visited, x, y): nrows, ncols = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < nrows and 0 <= ny < ncols and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True stack.append((nx, ny)) nrows, ncols = len(grid), len(grid[0]) visited = [[False for _ in range(ncols)] for _ in range(nrows)] clusters = 0 for i in range(nrows): for j in range(ncols): if grid[i][j] == 1 and not visited[i][j]: clusters += 1 visited[i][j] = True dfs(grid, visited, i, j) return clusters"},{"question":"from collections import deque class RateLimiter: A class to control how frequently a particular method can be executed. Attributes: maxCalls (int): The maximum number of calls allowed within the time window. timeWindow (int): The allowed time window in seconds. Methods: shouldAllow(): Returns true if the method call is within the rate limits, otherwise returns false. def __init__(self, maxCalls, timeWindow): pass def shouldAllow(self): pass # Example Usage and Test Cases def test_rate_limiter_allows_initial_requests(): rl = RateLimiter(5, 1) assert rl.shouldAllow() == True assert rl.shouldAllow() == True assert rl.shouldAllow() == True assert rl.shouldAllow() == True assert rl.shouldAllow() == True def test_rate_limiter_blocks_excess_requests(): rl = RateLimiter(5, 1) assert rl.shouldAllow() == True assert rl.shouldAllow() == True assert rl.shouldAllow() == True assert rl.shouldAllow() == True assert rl.shouldAllow() == True assert rl.shouldAllow() == False # 6th call should be blocked def test_rate_limiter_allows_after_time_window(): rl = RateLimiter(5, 1) for _ in range(5): assert rl.shouldAllow() == True assert rl.shouldAllow() == False # 6th call should be blocked time.sleep(1) # Wait for the time window to pass assert rl.shouldAllow() == True # Call should be allowed after time window def test_rate_limiter_partial_window(): rl = RateLimiter(2, 2) assert rl.shouldAllow() == True time.sleep(1) assert rl.shouldAllow() == True assert rl.shouldAllow() == False time.sleep(1) assert rl.shouldAllow() == True # Call should be allowed after sliding window def test_rate_limiter_with_no_limit(): rl = RateLimiter(1, 0.001) # Practically no window limit assert rl.shouldAllow() == True assert rl.shouldAllow() == False time.sleep(0.001) assert rl.shouldAllow() == True # Call should be allowed after sleep","solution":"from collections import deque from time import time class RateLimiter: def __init__(self, maxCalls, timeWindow): self.maxCalls = maxCalls self.timeWindow = timeWindow self.calls = deque() def shouldAllow(self): current_time = time() # Slide the window: Remove calls older than the time window from queue while self.calls and self.calls[0] < current_time - self.timeWindow: self.calls.popleft() if len(self.calls) < self.maxCalls: self.calls.append(current_time) return True else: return False"},{"question":"def max_buildings_in_segment(heights: List[int], K: int) -> int: Given an integer array \`heights\` representing the heights of buildings in a row, and an integer \`K\`, return the maximum number of buildings you can include in a segment such that the difference in heights between the tallest and shortest building in the segment is less than or equal to \`K\`. >>> max_buildings_in_segment([1, 3, 6, 7, 9], 2) 2 >>> max_buildings_in_segment([5, 5, 5, 5], 0) 4 >>> max_buildings_in_segment([1, 10, 20, 30], 5) 1 >>> max_buildings_in_segment([3, 4, 5, 6, 7], 4) 5 >>> max_buildings_in_segment([1, 5, 9, 3, 8, 7, 4], 3) 2 >>> max_buildings_in_segment([5, 4, 3, 4, 5], 0) 1 >>> max_buildings_in_segment([1, 2, 3, 4, 5], 10) 5","solution":"def max_buildings_in_segment(heights, K): Returns the maximum number of buildings in a segment such that the difference in heights between the tallest and shortest building in the segment is <= K. n = len(heights) max_length = 0 left = 0 current_min = heights[0] current_max = heights[0] for right in range(n): current_min = min(current_min, heights[right]) current_max = max(current_max, heights[right]) while current_max - current_min > K: left += 1 current_min = min(heights[left:right+1]) current_max = max(heights[left:right+1]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def findPair(arr: List[int], x: int) -> List[int]: Given a 0-indexed integer array \`arr\` of unique integers sorted in ascending order and an integer \`x\`, finds two distinct indices i and j such that arr[i] + arr[j] == x. Parameters: arr (List[int]): The input array of unique integers. x (int): The target sum. Returns: List[int]: The indices of the two integers in the array whose sum is equal to x, or [] if no such pair exists. >>> findPair([1, 2, 3, 4, 5], 9) [3, 4] >>> findPair([1, 2, 3, 4, 5], 5) [0, 3] >>> findPair([1, 2, 3, 4, 5], 10) [] >>> findPair([1, 2], 3) [0, 1] def test_findPair_found_case(): assert findPair([1, 2, 3, 4, 5], 9) == [3, 4] or findPair([1, 2, 3, 4, 5], 9) == [4, 3] assert findPair([1, 2, 3, 4, 5], 5) == [0, 3] or findPair([1, 2, 3, 4, 5], 5) == [3, 0] def test_findPair_not_found_case(): assert findPair([1, 2, 3, 4, 5], 10) == [] assert findPair([1, 2, 3, 4, 5], 1) == [] def test_findPair_edge_case(): assert findPair([1, 2], 3) == [0, 1] or findPair([1, 2], 3) == [1, 0] assert findPair([1, 2], 4) == [] assert findPair([], 5) == [] def test_findPair_large_numbers(): assert findPair([1, 100, 200, 300, 400, 500], 600) == [1, 5] or findPair([1, 100, 200, 300, 400, 500], 600) == [5, 1] assert findPair([1, 100, 200, 300, 400, 500], 1000) == []","solution":"from typing import List def findPair(arr: List[int], x: int) -> List[int]: Given a 0-indexed integer array \`arr\` of unique integers sorted in ascending order and an integer \`x\`, finds two distinct indices i and j such that arr[i] + arr[j] == x. Parameters: arr (List[int]): The input array of unique integers. x (int): The target sum. Returns: List[int]: The indices of the two integers in the array whose sum is equal to x, or [] if no such pair exists. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == x: return [left, right] elif current_sum < x: left += 1 else: right -= 1 return []"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Given a binary tree, return the values of the nodes you can see ordered from top to bottom from the right side. >>> right_side_view(TreeNode(1, TreeNode(2, right=TreeNode(5)), TreeNode(3, right=TreeNode(4)))) [1, 3, 4] >>> right_side_view(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) [1, 2, 3] >>> right_side_view(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): if not root: return [] queue = deque([(root, 0)]) rightmost_value_at_depth = dict() max_depth = -1 while queue: node, depth = queue.popleft() if node: max_depth = max(max_depth, depth) rightmost_value_at_depth[depth] = node.val queue.append((node.left, depth + 1)) queue.append((node.right, depth + 1)) return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, sum: int) -> bool: Given a non-empty binary tree, find a path in the tree such that the sum of the node values is equal to a given sum. This path must go from the root node to any leaf node. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> hasPathSum(root, 22) True >>> root = TreeNode(1) >>> hasPathSum(root, 1) True >>> hasPathSum(root, 2) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> hasPathSum(root, 5) False >>> root = TreeNode(-2) >>> root.right = TreeNode(-3) >>> hasPathSum(root, -5) True >>> hasPathSum(root, -3) False >>> hasPathSum(None, 0) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, sum: int) -> bool: if not root: return False # If we reached a leaf node, check if the remaining sum equals to current node's value if not root.left and not root.right: return root.val == sum # Recursively check left and right subtrees with the updated sum sum -= root.val return hasPathSum(root.left, sum) or hasPathSum(root.right, sum)"},{"question":"def count_valid_pairs(height: List[int], d: int) -> int: Returns the number of valid pairs (i, j) in the height array where 0 <= i < j < len(height) and |height[i] - height[j]| <= d. >>> count_valid_pairs([1, 10, 20], 5) == 0 >>> count_valid_pairs([2, 3, 4, 5], 3) == 6 >>> count_valid_pairs([1, 2, 3, 10], 2) == 3 >>> count_valid_pairs([5], 1) == 0 >>> count_valid_pairs([1, 2, 3, 5, 8], 10) == 10 >>> count_valid_pairs([3, 3, 3, 3], 0) == 6","solution":"def count_valid_pairs(height, d): Returns the number of valid pairs (i, j) in the height array where 0 <= i < j < len(height) and |height[i] - height[j]| <= d. Args: height (list of int): List of tree heights. d (int): Maximum allowed height difference. Returns: int: Count of valid pairs. n = len(height) count = 0 for i in range(n): for j in range(i + 1, n): if abs(height[i] - height[j]) <= d: count += 1 return count"},{"question":"def evaluate_postfix(s: str) -> int: Evaluates a postfix expression and returns the result as an integer. Returns None if the expression is invalid. >>> evaluate_postfix(\\"2 3 + 5 *\\") 25 >>> evaluate_postfix(\\"2 3 5 + *\\") 16 >>> evaluate_postfix(\\"42\\") 42 >>> evaluate_postfix(\\"\\") None >>> evaluate_postfix(\\"2 3 + +\\") None >>> evaluate_postfix(\\"2 +\\") None >>> evaluate_postfix(\\"2 3 + /\\") None >>> evaluate_postfix(\\"+ - * /\\") None >>> evaluate_postfix(\\"4 0 /\\") None >>> evaluate_postfix(\\"3 4 + 2 * 7 /\\") 2 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14","solution":"def evaluate_postfix(s): Evaluates a postfix expression and returns the result as an integer. Returns None if the expression is invalid. Parameters: s (str): A string representing the postfix expression. Returns: int: The result of the postfix expression, or None if invalid. if not s: return None stack = [] operators = set(['+', '-', '*', '/']) for token in s.split(): if token.isdigit(): stack.append(int(token)) elif token in operators: if len(stack) < 2: return None b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': # Python division of integers follows floor division for // operator, # but \\"/\\" will give float. Hence, we use \\"//\\" for integer division. if b == 0: return None # Division by zero is invalid. stack.append(a // b) else: return None return stack[0] if len(stack) == 1 else None"},{"question":"def min_swaps_to_equal(nums1, nums2): Determine the minimum number of adjacent swaps required to make nums1 equal to nums2. Args: nums1: List of integers. nums2: List of integers. Returns: int: The minimum number of swaps necessary to align the two arrays, or -1 if it is not possible. >>> min_swaps_to_equal([1, 2, 3], [1, 2, 3]) 0 >>> min_swaps_to_equal([1, 3, 2], [1, 2, 3]) 1 >>> min_swaps_to_equal([3, 1, 2], [1, 2, 3]) 2 >>> min_swaps_to_equal([1, 2, 3], [4, 5, 6]) -1 >>> min_swaps_to_equal([1, 2, 3], [3, 2, 1]) 1","solution":"def min_swaps_to_equal(nums1, nums2): Returns the minimum number of adjacent swaps required to make nums1 equal to nums2. if sorted(nums1) != sorted(nums2): return -1 index_map = {value: i for i, value in enumerate(nums2)} swaps = 0 for i in range(len(nums1)): while nums1[i] != nums2[i]: swap_index = index_map[nums1[i]] nums2[i], nums2[swap_index] = nums2[swap_index], nums2[i] index_map[nums2[swap_index]] = swap_index swaps += 1 return swaps"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def clone_tree(root): Clone the binary tree with random pointers. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.random = root.right >>> root.left.random = root >>> root.right.random = root.left >>> cloned_root = clone_tree(root) >>> cloned_root is not root True >>> cloned_root.val == root.val True >>> cloned_root.left.val == root.left.val True >>> cloned_root.right.val == root.right.val True >>> cloned_root.random.val == root.random.val True >>> cloned_root.left.random.val == root.left.random.val True >>> cloned_root.right.random.val == root.right.random.val True >>> root = None >>> clone_tree(root) is None True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def clone_tree(root): if not root: return None def clone_nodes(node): if not node: return None new_node = TreeNode(node.val) clones[node] = new_node new_node.left = clone_nodes(node.left) new_node.right = clone_nodes(node.right) return new_node def clone_random_pointers(node): if not node: return if node.random: clones[node].random = clones[node.random] clone_random_pointers(node.left) clone_random_pointers(node.right) clones = {} cloned_root = clone_nodes(root) clone_random_pointers(root) return cloned_root"},{"question":"from typing import List def partition_labels(s: str) -> List[int]: Given a string \`s\` consisting of lowercase alphabets, split it into as many parts as possible such that each letter appears in at most one part. Return a list of integers representing the lengths of these parts. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") == [9, 7, 8] >>> partition_labels(\\"a\\") == [1] >>> partition_labels(\\"eccbbbbdec\\") == [10] >>> partition_labels(\\"aabbcc\\") == [2, 2, 2] >>> partition_labels(\\"abcdefg\\") == [1, 1, 1, 1, 1, 1, 1] >>> partition_labels(\\"\\") == []","solution":"def partition_labels(s): Returns a list of integers representing the lengths of the parts created, such that each letter appears in at most one part. last_occurrences = {char: idx for idx, char in enumerate(s)} j = anchor = 0 results = [] for i, char in enumerate(s): j = max(j, last_occurrences[char]) if i == j: results.append(i - anchor + 1) anchor = i + 1 return results"},{"question":"def minimum_effort_path(grid: list[list[int]], source: tuple[int, int], destination: tuple[int, int]) -> int: Returns the minimum value of the maximum absolute difference of heights between consecutive cells in the path from source to destination. >>> grid = [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ] >>> source = (0, 0) >>> destination = (2, 2) >>> minimum_effort_path(grid, source, destination) == 2 True >>> grid = [ ... [1, 10], ... [10, 1] ... ] >>> source = (0, 0) >>> destination = (1, 1) >>> minimum_effort_path(grid, source, destination) == 9 True >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> source = (0, 0) >>> destination = (1, 2) >>> minimum_effort_path(grid, source, destination) == 3 True >>> grid = [ ... [0] ... ] >>> source = (0, 0) >>> destination = (0, 0) >>> minimum_effort_path(grid, source, destination) == 0 True >>> grid = [ ... [1, 2, 1, 1], ... [1, 1, 1, 8], ... ] >>> source = (0, 0) >>> destination = (1, 3) >>> minimum_effort_path(grid, source, destination) == 7 True","solution":"import heapq def minimum_effort_path(grid: list[list[int]], source: tuple[int, int], destination: tuple[int, int]) -> int: Returns the minimum value of the maximum absolute difference of heights between consecutive cells in the path from source to destination. def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]): yield new_x, new_y heap = [(0, source[0], source[1])] efforts = {(source[0], source[1]): 0} while heap: effort, x, y = heapq.heappop(heap) if (x, y) == destination: return effort for new_x, new_y in neighbors(x, y): new_effort = max(effort, abs(grid[new_x][new_y] - grid[x][y])) if new_effort < efforts.get((new_x, new_y), float('inf')): efforts[(new_x, new_y)] = new_effort heapq.heappush(heap, (new_effort, new_x, new_y)) return -1"},{"question":"def min_days_to_bloom(days: List[int], bouquets: int, flowersPerBouquet: int) -> int: Return the minimum number of days required to form exactly the given number of bouquets using the specified number of flowers for each bouquet. Args: days (List[int]): List where days[i] represents the number of flowers that bloom on the i-th day. bouquets (int): The required number of bouquets. flowersPerBouquet (int): The number of flowers required to form a single bouquet. Returns: int: The minimum number of days required to form the specified number of bouquets. If it's impossible, return -1. Examples: >>> min_days_to_bloom([1, 10, 3, 10, 2], 3, 1) 3 >>> min_days_to_bloom([1, 10, 3, 10, 2], 3, 2) -1 >>> min_days_to_bloom([7, 7, 7, 7, 12, 7, 7], 2, 3) 12 >>> min_days_to_bloom([1000000], 1, 1) 1000000 >>> min_days_to_bloom([1, 2, 4, 5, 6, 3, 2, 1], 4, 3) -1 >>> min_days_to_bloom([1, 2, 3, 4, 5], 1, 5) 5","solution":"def min_days_to_bloom(days, bouquets, flowersPerBouquet): def can_make_bouquets(day_limit): flowers = 0 count_bouquets = 0 for day in days: if day <= day_limit: flowers += 1 if flowers == flowersPerBouquet: count_bouquets += 1 flowers = 0 else: flowers = 0 return count_bouquets >= bouquets if bouquets * flowersPerBouquet > len(days): return -1 left, right = min(days), max(days) while left < right: mid = (left + right) // 2 if can_make_bouquets(mid): right = mid else: left = mid + 1 return left if can_make_bouquets(left) else -1"},{"question":"def min_time_to_visit_all_points(points: List[List[int]]) -> int: Returns the minimum time in seconds to visit all given points in order. >>> min_time_to_visit_all_points([[1,1], [3,4], [-1,0]]) == 7 >>> min_time_to_visit_all_points([[3,2], [-2,2]]) == 5 >>> min_time_to_visit_all_points([[0,0], [1,1], [1,2]]) == 2 >>> min_time_to_visit_all_points([[0,0]]) == 0 >>> min_time_to_visit_all_points([[0,0], [0,1], [1,1], [1,0]]) == 3","solution":"def min_time_to_visit_all_points(points): Returns the minimum time in seconds to visit all given points in order. def distance(p1, p2): return max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) total_time = 0 for i in range(len(points) - 1): total_time += distance(points[i], points[i + 1]) return total_time"},{"question":"def smallest_subarray_with_min_max(nums: List[int]) -> int: Given an array of integers nums, return the smallest subarray length that contains at least one occurrence of the maximum element and at least one occurrence of the minimum element from the array. If the array contains only one element, the subarray length should be 1. >>> smallest_subarray_with_min_max([1]) == 1 >>> smallest_subarray_with_min_max([1,3,2,1,4,5,1,5,1,4]) == 2 >>> smallest_subarray_with_min_max([2, 2, 2, 2, 2]) == 1 >>> smallest_subarray_with_min_max([1, 3, 1, 3, 1, 3]) == 2 >>> smallest_subarray_with_min_max([1, 2, 3, 1, 4, 3, 5, 1, 5, 5, 4, 3, 2, 1]) == 2 >>> smallest_subarray_with_min_max([3, 2, 1, 5, 6, 1, 6, 1]) == 2","solution":"def smallest_subarray_with_min_max(nums): Returns the smallest subarray length that contains at least one occurrence of the maximum element and at least one occurrence of the minimum element from the array. if len(nums) <= 1: return len(nums) maximum = max(nums) minimum = min(nums) if maximum == minimum: return 1 min_pos = -1 max_pos = -1 min_distance = len(nums) for index, num in enumerate(nums): if num == minimum: min_pos = index if num == maximum: max_pos = index if min_pos != -1 and max_pos != -1: min_distance = min(min_distance, abs(max_pos - min_pos) + 1) return min_distance"},{"question":"def longest_mountain(arr: List[int]) -> int: Given an array of integers 'arr', this function returns the length of the longest mountain in the array. A mountain is defined as a sequence of elements that first strictly increases to a peak and then strictly decreases, and must have at least three elements. If there is no mountain, return 0. >>> longest_mountain([1, 2, 3, 4, 5]) == 0 >>> longest_mountain([5, 4, 3, 2, 1]) == 0 >>> longest_mountain([2, 2, 2, 2, 2]) == 0 >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) == 5 >>> longest_mountain([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 9 >>> longest_mountain([2, 1, 4, 7, 3, 2, 9, 10, 8, 7, 3, 2, 4, 6, 7, 6, 5, 4, 2]) == 8 >>> longest_mountain([0, 1, 0, 2, 3, 4, 3, 2, 0, 5, 6, 7, 2, 1, 5]) == 7 >>> longest_mountain([2, 1]) == 0 >>> longest_mountain([]) == 0 >>> array = [i for i in range(1000)] + [i for i in range(1000, 0, -1)] >>> longest_mountain(array) == 2000","solution":"def longest_mountain(arr): Returns the length of the longest mountain in the array. A mountain is defined as a sequence of elements that strictly increases to a peak and then strictly decreases. It must have at least three elements. If there is no mountain, return 0. n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 right = i + 1 while left > 0 and arr[left] > arr[left - 1]: left -= 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def minimumSwaps(heights: List[int], K: int) -> int: Return the minimum number of swaps required to sort the array in non-decreasing order. If it is not possible to sort the array with the given number of swaps, return -1. >>> minimumSwaps([4, 3, 1, 2], 3) 3 >>> minimumSwaps([4, 3, 1, 2], 2) -1 >>> minimumSwaps([1, 2, 3, 4], 0) 0 >>> minimumSwaps([5, 4, 3, 2, 1], 10) 2","solution":"def minimumSwaps(heights, K): Return the minimum number of swaps required to sort the array in non-decreasing order. If it is not possible to sort the array with the given number of swaps, return -1. n = len(heights) sorted_heights = sorted(heights) index_map = {v: i for i, v in enumerate(heights)} swaps = 0 for i in range(n): # If heights[i] is not at the correct position if heights[i] != sorted_heights[i]: swaps += 1 # Swap heights[i] with the correct element correct_value = sorted_heights[i] to_swap_idx = index_map[correct_value] # Update index_map to reflect the swap index_map[heights[i]] = to_swap_idx index_map[correct_value] = i # Perform the swap heights[i], heights[to_swap_idx] = heights[to_swap_idx], heights[i] return swaps if swaps <= K else -1"},{"question":"from typing import List def topKFrequentWords(words: List[str], k: int) -> List[str]: Returns the \`k\` most frequent words from the list \`words\`. In case of ties, the lexicographical order is considered. >>> topKFrequentWords([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) == [\\"i\\", \\"love\\"] >>> topKFrequentWords([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) == [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] >>> topKFrequentWords([\\"apple\\", \\"banana\\", \\"cherry\\"], 2) == [\\"apple\\", \\"banana\\"] >>> topKFrequentWords([\\"d\\", \\"c\\", \\"b\\", \\"a\\"], 3) == [\\"a\\", \\"b\\", \\"c\\"] >>> topKFrequentWords([], 3) == [] >>> topKFrequentWords([\\"alpha\\", \\"beta\\", \\"gamma\\", \\"alpha\\", \\"beta\\"], 5) == [\\"alpha\\", \\"beta\\", \\"gamma\\"] >>> topKFrequentWords([\\"test\\"], 1) == [\\"test\\"]","solution":"from typing import List from collections import Counter def topKFrequentWords(words: List[str], k: int) -> List[str]: Returns the \`k\` most frequent words from the list \`words\`. In case of ties, the lexicographical order is considered. # Count the frequency of each word word_count = Counter(words) # Sort by frequency first (in descending order), then lexicographically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k frequent words result = [word for word, _ in sorted_words[:k]] return result"},{"question":"from typing import List def min_operations_to_make_one_island(grid: List[List[int]]) -> int: You are given a 2D grid \`grid\` of size \`m x n\` where each cell represents a plot of land. The grid is initially filled with 0's, representing water, and 1's, representing land. You can perform an operation to add a land cell at any water cell (\`0\`). Find the minimum number of operations required to make the grid into one single island (a contiguous region of land). Return the minimum number of operations needed to make the grid a single island. An island is considered contiguous if each cell is connected to another horizontally or vertically. If the entire grid is already a single island, return \`0\`. If it's impossible to connect all the land cells into a single island, return \`-1\`. >>> min_operations_to_make_one_island([ ... [0, 0], ... [0, 0] ... ]) -1 >>> min_operations_to_make_one_island([ ... [1, 1], ... [1, 1] ... ]) 0 >>> min_operations_to_make_one_island([ ... [1, 0], ... [0, 1] ... ]) 1 >>> min_operations_to_make_one_island([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) 2 >>> min_operations_to_make_one_island([ ... [1, 1, 0], ... [0, 1, 1], ... [1, 0, 1] ... ]) 1 >>> min_operations_to_make_one_island([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0","solution":"def min_operations_to_make_one_island(grid): from collections import deque def is_within_grid(x, y, m, n): return 0 <= x < m and 0 <= y < n def bfs(grid, m, n): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False for _ in range(n)] for _ in range(m)] queue = deque() found_land = False for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j)) visited[i][j] = True found_land = True break if found_land: break if not found_land: return 0, visited steps = 0 while queue: size = len(queue) steps += 1 for _ in range(size): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_grid(nx, ny, m, n) and not visited[nx][ny]: visited[nx][ny] = True if grid[nx][ny] == 1: queue.append((nx, ny)) return steps - 1, visited def count_islands(grid, m, n, visited): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] island_count = 0 def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if is_within_grid(nx, ny, m, n) and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True stack.append((nx, ny)) for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: island_count += 1 visited[i][j] = True dfs(i, j) return island_count m, n = len(grid), len(grid[0]) if all(cell == 0 for row in grid for cell in row): return -1 initial_steps, initial_visits = bfs(grid, m, n) if all(all(initial_visits[i][j] for j in range(n)) for i in range(m)): return 0 total = 0 for row in grid: total += sum(row) if total == 1: return -1 for i in range(m): for j in range(n): if grid[i][j] == 0: grid[i][j] = 1 visited_new = [[False for _ in range(n)] for _ in range(m)] num_islands = count_islands(grid, m, n, visited_new) grid[i][j] = 0 if num_islands == 1: return 1 return 2"},{"question":"def max_absolute_difference_permutation(arr: List[int]) -> List[int]: Given an integer array \`arr\` of unique elements, returns one of the possible permutations of \`arr\` such that the sum of the absolute differences between consecutive elements is maximal. pass # Unit Tests def test_single_element_array(): assert max_absolute_difference_permutation([1]) == [1] def test_two_element_array(): assert max_absolute_difference_permutation([1, 2]) == [2, 1] def test_three_element_array(): result = max_absolute_difference_permutation([1, 2, 3]) assert result in ([3, 1, 2], [3, 2, 1]) def test_even_number_of_elements(): result = max_absolute_difference_permutation([1, 2, 3, 4]) assert result in ([4, 1, 3, 2], [4, 2, 3, 1]) def test_odd_number_of_elements(): result = max_absolute_difference_permutation([1, 3, 9]) assert result in ([9, 1, 3], [9, 3, 1]) def test_large_array(): result = max_absolute_difference_permutation([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) assert result == [10, 1, 9, 2, 8, 3, 7, 4, 6, 5] def test_another_large_array(): result = max_absolute_difference_permutation([1, 10, 4, 7, 3, 5, 2, 6, 9, 8]) assert result in ([10, 1, 9, 2, 8, 3, 7, 4, 6, 5], [10, 2, 9, 3, 8, 4, 7, 5, 6, 1])","solution":"def max_absolute_difference_permutation(arr): Given an integer array \`arr\` of unique elements, returns one of the possible permutations of \`arr\` such that the sum of the absolute differences between consecutive elements is maximal. arr.sort() result = [] i, j = 0, len(arr) - 1 while i <= j: if i != j: result.append(arr[j]) result.append(arr[i]) else: result.append(arr[i]) i += 1 j -= 1 return result"},{"question":"def max_time_spent_on_task(logs: List[List[Union[int, str]]]) -> int: Given an array \`logs\` where \`logs[i]\` contains three different elements \`[id, status, timestamp]\`, find the maximum time any employee has spent on a task. :param logs: List of logs. Each log is a list with three elements [id, status, timestamp] :return: id of the employee with the maximum time spent on a task >>> max_time_spent_on_task([[1, \\"start\\", 1], [1, \\"end\\", 10]]) 1 >>> max_time_spent_on_task([[1, \\"start\\", 1], [1, \\"end\\", 10], [1, \\"start\\", 20], [1, \\"end\\", 30]]) 1 >>> max_time_spent_on_task([[1, \\"start\\", 1], [1, \\"end\\", 10], [2, \\"start\\", 5], [2, \\"end\\", 20], [3, \\"start\\", 100], [3, \\"end\\", 105]]) 2 >>> max_time_spent_on_task([[1, \\"start\\", 1], [1, \\"end\\", 10], [2, \\"start\\", 3], [2, \\"end\\", 12]]) 1 >>> max_time_spent_on_task([[1, \\"start\\", 1], [2, \\"start\\", 5]]) float('inf') >>> max_time_spent_on_task([[1, \\"start\\", 1], [2, \\"end\\", 10]]) float('inf') pass","solution":"def max_time_spent_on_task(logs): Returns the id of the employee who has the maximum time spent on a task. :param logs: List of logs. Each log is a list with three elements [id, status, timestamp] :return: id of the employee with maximum time spent on a task task_times = {} start_times = {} for log in logs: emp_id, status, timestamp = log if status == \\"start\\": start_times[emp_id] = timestamp elif status == \\"end\\": if emp_id in start_times: elapsed_time = timestamp - start_times[emp_id] if emp_id in task_times: task_times[emp_id] = max(task_times[emp_id], elapsed_time) else: task_times[emp_id] = elapsed_time max_time = -1 max_id = float('inf') for emp_id, time in task_times.items(): if time > max_time or (time == max_time and emp_id < max_id): max_time = time max_id = emp_id return max_id"},{"question":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next class LinkedList: def __init__(self, values=None): Initialize the linked list with an optional values argument. values: List of integers to populate the linked list. Examples: >>> ll = LinkedList([1, 2, 3]) >>> ll.to_list() [1, 2, 3] >>> ll.reverse() >>> ll.to_list() [3, 2, 1] self.head = None if values: for value in values: self.append(value) def append(self, value): Append a value to the end of the linked list. if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self): Reverse the linked list in-place. def to_list(self): Convert the linked list to a Python list containing the same elements in the same order. Examples: >>> ll = LinkedList([1, 2, 3]) >>> ll.to_list() [1, 2, 3] >>> ll.reverse() >>> ll.to_list() [3, 2, 1]","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next class LinkedList: def __init__(self, values=None): self.head = None if values: for value in values: self.append(value) def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self): elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"def can_attend_all_events(intervals: List[Tuple[int, int]]) -> bool: Determines if a person can attend all events without overlapping. arguments: intervals -- List of tuples representing events with start and end times. returns: True if a person can attend all events without overlap, otherwise False. >>> can_attend_all_events([(1, 2), (3, 5), (6, 8)]) == True >>> can_attend_all_events([(1, 3), (2, 4), (5, 7)]) == False >>> can_attend_all_events([(1, 2), (2, 3), (3, 4)]) == True >>> can_attend_all_events([(1, 3), (1, 3), (1, 3)]) == False >>> can_attend_all_events([(1, 2), (2, 2), (3, 4)]) == True >>> can_attend_all_events([(1, 2)]) == True >>> can_attend_all_events([(5, 7), (1, 3), (3, 4)]) == True","solution":"def can_attend_all_events(intervals): Determines if a person can attend all events without overlapping. Arguments: intervals -- List of tuples representing events with start and end times. Returns: True if a person can attend all events without overlap, otherwise False. # Sort intervals based on the start time intervals.sort() for i in range(1, len(intervals)): # If the start time of the current interval is less than the end time of the previous interval if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merge k sorted linked lists into one sorted linked list and return it. >>> linked_list_to_array(mergeKLists([array_to_linked_list([1, 4, 5]), array_to_linked_list([1, 3, 4]), array_to_linked_list([2, 6])])) [1, 1, 2, 3, 4, 4, 5, 6] >>> linked_list_to_array(mergeKLists([array_to_linked_list([]), array_to_linked_list([]), array_to_linked_list([])])) [] >>> linked_list_to_array(mergeKLists([array_to_linked_list([1, 2, 3])])) [1, 2, 3] >>> linked_list_to_array(mergeKLists([array_to_linked_list([]), array_to_linked_list([5]), array_to_linked_list([])])) [5] >>> linked_list_to_array(mergeKLists([array_to_linked_list([1, 4, 5]), array_to_linked_list([]), array_to_linked_list([2, 6]), array_to_linked_list([]), array_to_linked_list([3])])) [1, 2, 3, 4, 5, 6] def array_to_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_array(node): array = [] current = node while current: array.append(current.val) current = current.next return array","solution":"from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: import heapq ListNode.__lt__ = lambda self, other: self.val < other.val min_heap = [] for i in range(len(lists)): if lists[i]: heapq.heappush(min_heap, lists[i]) head = ListNode(0) curr = head while min_heap: node = heapq.heappop(min_heap) curr.next = node curr = curr.next if node.next: heapq.heappush(min_heap, node.next) return head.next def array_to_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_array(node): array = [] current = node while current: array.append(current.val) current = current.next return array"},{"question":"from typing import List def four_sum_exists(arr: List[int], target: int) -> bool: Determines if there are four elements in \`arr\` whose sum is equal to \`target\`. :param arr: list of integers :param target: integer target sum :return: True if four elements sum to \`target\`, otherwise False >>> four_sum_exists([1, 2, 3, 4, 5], 10) True >>> four_sum_exists([1, 0, -1, 0, -2, 2], 0) True >>> four_sum_exists([1, 2, 3, 4], 15) False >>> four_sum_exists([0, 0, 0, 0], 0) True >>> four_sum_exists([-1, 0, 1, 1, 2, -1, -4], 0) True >>> four_sum_exists([5, 5, 5, 5, 5], 20) True >>> four_sum_exists([], 0) False >>> four_sum_exists([1, 2, 3, 4, 5], 50) False >>> four_sum_exists([1, 2, 3, 4, 5, 6], 21) False >>> four_sum_exists([-2, -1, 0, 1, 2, 3], 2) True >>> four_sum_exists([2, 2, 2, 2, 2], 8) True","solution":"def four_sum_exists(arr, target): Determines if there are four elements in \`arr\` whose sum is equal to \`target\`. :param arr: list of integers :param target: integer target sum :return: True if four elements sum to \`target\`, otherwise False arr.sort() length = len(arr) for i in range(length - 3): for j in range(i + 1, length - 2): left, right = j + 1, length - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def valid_left_parentheses_indices(s: str) -> int: Given a string \`s\`, return the number of indices \`i\` where the following conditions hold: 1. \`s[i] == '(' 2. For every character \`s[j]\` where \`j < i\` and \`s[j] == '(', there is a corresponding \`s[k] == ')'\` where \`j < k < i\` and every \`s[m]\` where \`j < m < k\` and \`s[m] == '(' also has a corresponding \`s[n] == ')'\` where \`m < n < k\`. >>> valid_left_parentheses_indices(\\"(()())\\") 0 >>> valid_left_parentheses_indices(\\"((())\\") 1 >>> valid_left_parentheses_indices(\\"())(\\") 1 >>> valid_left_parentheses_indices(\\")\\") 0 >>> valid_left_parentheses_indices(\\"()\\") 0 >>> valid_left_parentheses_indices(\\"(((()\\") 3 >>> valid_left_parentheses_indices(\\"\\") 0 >>> valid_left_parentheses_indices(\\")))\\") 0 pass","solution":"def valid_left_parentheses_indices(s): Returns the number of indices i where the conditions hold: 1. s[i] == '(' 2. For every character s[j] where j < i and s[j] == '(', there is a corresponding s[k] == ')' where j < k < i and every s[m] where j < m < k and s[m] == '(' also has a corresponding s[n] == ')' where m < n < k. open_count = 0 for i in range(len(s)): if s[i] == '(': open_count += 1 elif s[i] == ')' and open_count > 0: open_count -= 1 return open_count"},{"question":"MOD = 10**9 + 7 def num_decodings(s: str) -> int: Returns the total number of ways to decode the string \`s\` into alphabetic characters. Args: s (str): A string containing only digits. Returns: int: The total number of ways to decode the string \`s\`, modulo 10^9 + 7. Examples: >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"10\\") 1 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"\\") 0 >>> num_decodings(\\"1\\") 1 >>> num_decodings(\\"27\\") 1 >>> num_decodings(\\"2101\\") 1 >>> num_decodings(\\"123123\\") 9 >>> num_decodings(\\"11106\\") 2 >>> num_decodings(\\"1\\" * 1000) > 0 True >>> num_decodings(\\"1\\" * 10000) % (10**9 + 7) == (num_decodings(\\"1\\" * 10000) % (10**9 + 7)) True # Your code here","solution":"MOD = 10**9 + 7 def num_decodings(s): Returns the total number of ways to decode the string \`s\` into alphabetic characters. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] = dp[i - 1] if i != 1 and '10' <= s[i-2:i] <= '26': dp[i] = (dp[i] + dp[i - 2]) % MOD return dp[n]"},{"question":"from typing import List def minimizeLargestSum(nums: List[int], threshold: int) -> int: Find the minimum possible largest sum of the subarrays that the list can be divided into, such that the sum of each subarray does not exceed the threshold. >>> minimizeLargestSum([7, 2, 5, 10, 8], 2) 18 >>> minimizeLargestSum([1, 2, 3, 4, 5], 2) 9 >>> minimizeLargestSum([1, 4, 4], 3) 4 >>> minimizeLargestSum([1, 2, 3, 4, 5], 1) 15 >>> minimizeLargestSum([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17","solution":"from typing import List def can_split(nums: List[int], max_sum: int, threshold: int) -> bool: current_sum = 0 count_splits = 1 for num in nums: if current_sum + num <= max_sum: current_sum += num else: count_splits += 1 current_sum = num if count_splits > threshold: return False return True def minimizeLargestSum(nums: List[int], threshold: int) -> int: left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_split(nums, mid, threshold): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def three_sum(nums): Find all unique triplets in the list which gives the sum of zero. Parameters: nums (List[int]): List of integers Returns: List[List[int]]: List of lists containing triplets that sum to zero. from solution import three_sum def test_three_sum_no_triplets(): assert three_sum([1, 2, -2, -1]) == [] def test_three_sum_single_triplet(): assert three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] def test_three_sum_multiple_triplets(): assert three_sum([-2, 0, 0, 2, 2]) == [[-2, 0, 2]] def test_three_sum_no_elements(): assert three_sum([]) == [] def test_three_sum_single_element(): assert three_sum([0]) == [] def test_three_sum_all_zeros(): assert three_sum([0, 0, 0, 0]) == [[0, 0, 0]]","solution":"def three_sum(nums): Find all unique triplets in the list which gives the sum of zero. Parameters: nums (List[int]): List of integers Returns: List[List[int]]: List of lists containing triplets that sum to zero. nums.sort() # Sorting the array helps in avoiding duplicates result = [] for i in range(len(nums)-2): if i > 0 and nums[i] == nums[i-1]: continue # Avoid duplicates for the first element left, right = i+1, len(nums)-1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: left += 1 # Avoid duplicates for the second element while left < right and nums[right] == nums[right-1]: right -= 1 # Avoid duplicates for the third element left += 1 right -= 1 return result"},{"question":"from typing import List def least_interval(tasks: List[str], n: int) -> int: Determines the least number of units of time the CPU will take to finish all the given tasks considering the cooldown period \`n\` between performing two of the same tasks. Args: tasks (List[str]): A list of tasks represented by characters. n (int): Cooldown period between two same tasks. Returns: int: The minimum number of units of time to finish all the given tasks. >>> least_interval(['A','A','A','B','B','B'], 2) 8 >>> least_interval(['A','A','A','B','B','B'], 0) 6 >>> least_interval(['A'], 2) 1 >>> least_interval(['A','A','A','B','B','B','C','C','D','D'], 2) 10 >>> least_interval(['A','A','A'], 2) 7 >>> least_interval(['A','B','C','D','E'], 2) 5","solution":"from collections import Counter import heapq def least_interval(tasks, n): Determines the least number of units of time the CPU will take to finish all the given tasks considering the cooldown period \`n\` between performing two of the same tasks. Args: tasks (List[str]): A list of tasks represented by characters. n (int): Cooldown period between two same tasks. Returns: int: The minimum number of units of time to finish all the given tasks. if n == 0: return len(tasks) task_counts = Counter(tasks) max_heap = [-cnt for cnt in task_counts.values()] heapq.heapify(max_heap) time = 0 cooldown = [] while max_heap or cooldown: time += 1 if max_heap: count = heapq.heappop(max_heap) + 1 if count: cooldown.append((count, time + n)) if cooldown and cooldown[0][1] == time: heapq.heappush(max_heap, cooldown.pop(0)[0]) return time"},{"question":"def longest_common_substring_length(str1: str, str2: str) -> int: Returns the length of the longest common substring between str1 and str2. >>> longest_common_substring_length(\\"abc\\", \\"def\\") == 0 >>> longest_common_substring_length(\\"abc\\", \\"abc\\") == 3 >>> longest_common_substring_length(\\"ab\\", \\"bc\\") == 1 >>> longest_common_substring_length(\\"abcdef\\", \\"zabcf\\") == 3 >>> longest_common_substring_length(\\"xyabcd\\", \\"abcxyz\\") == 3 >>> longest_common_substring_length(\\"\\", \\"\\") == 0 >>> longest_common_substring_length(\\"abc\\", \\"\\") == 0 >>> longest_common_substring_length(\\"\\", \\"abc\\") == 0 >>> longest_common_substring_length(\\"abcxyabcd\\", \\"abczabcdxyz\\") == 4","solution":"def longest_common_substring_length(str1, str2): Returns the length of the longest common substring between str1 and str2. len1, len2 = len(str1), len(str2) if len1 == 0 or len2 == 0: return 0 # Initialize DP table dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_length = 0 # Build the table in bottom-up fashion for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"def max_profit(prices): Returns the maximum profit that can be made by buying and selling on two different days. If no profit can be made, returns 0. :param prices: List of integers representing daily profits or losses. :return: The maximum profit or 0 if no profit can be made. pass def test_max_profit_basic(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 # Buy on day 2 (price = 1) and sell on day 5 (price = 6) assert max_profit([7, 6, 4, 3, 1]) == 0 # No profit can be made def test_max_profit_edge_cases(): assert max_profit([1, 2]) == 1 # Buy on day 1 (price = 1) and sell on day 2 (price = 2) assert max_profit([2, 1]) == 0 # Prices are descending, no profit assert max_profit([]) == 0 # Empty list assert max_profit([5]) == 0 # Single element list def test_max_profit_all_same_price(): assert max_profit([3, 3, 3, 3, 3]) == 0 # All prices are the same, no profit def test_max_profit_mixed_prices(): assert max_profit([10, 7, 5, 8, 11, 9]) == 6 # Buy on day 3 (price = 5) and sell on day 5 (price = 11) assert max_profit([1, 2, 3, 4, 5]) == 4 # Buy on day 1 (price = 1) and sell on day 5 (price = 5) def test_max_profit_with_negative_values(): assert max_profit([-1, -2, -3, 4, -1, 2]) == 7 # Buy on day 3 (price = -3) and sell on day 4 (price = 4) assert max_profit([-3, -2, -1, -5]) == 2 # Buy on day 1 (price = -3) and sell on day 3 (price = -1) assert max_profit([-1, -2, -3]) == 0 # No profit can be made","solution":"def max_profit(prices): Returns the maximum profit that can be made by buying and selling on two different days. If no profit can be made, returns 0. :param prices: List of integers representing daily profits or losses. :return: The maximum profit or 0 if no profit can be made. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def activeCourses(startTime: List[int], endTime: List[int], queryTime: List[int]) -> List[int]: Returns a list of integers representing the number of active courses at each query time. Parameters: startTime (List[int]): The list of start times of the courses. endTime (List[int]): The list of end times of the courses. queryTime (List[int]): The list of query times. Returns: List[int]: The list of active courses at each query time. >>> activeCourses([1, 2, 3], [4, 5, 6], [2, 3, 5]) [1, 2, 1] >>> activeCourses([1, 2], [3, 4], [1, 4]) [1, 0]","solution":"def activeCourses(startTime, endTime, queryTime): Returns a list of integers representing the number of active courses at each query time. Parameters: startTime (List[int]): The list of start times of the courses. endTime (List[int]): The list of end times of the courses. queryTime (List[int]): The list of query times. Returns: List[int]: The list of active courses at each query time. result = [] for qt in queryTime: count = 0 for st, et in zip(startTime, endTime): if st <= qt <= et: count += 1 result.append(count) return result"},{"question":"def can_move_boxes_to_targets(boxes, targets): Determines if every box can be moved to a target with at least the same capacity. Args: boxes (list of int): Sizes of the boxes. targets (list of int): Target capacities. Returns: bool: True if every box can be moved to a target with at least the same capacity, False otherwise. >>> can_move_boxes_to_targets([1, 2, 3], [3, 2, 1]) True >>> can_move_boxes_to_targets([1, 2, 3], [4, 5, 6]) True >>> can_move_boxes_to_targets([1, 2, 3], [2, 2, 2]) False >>> can_move_boxes_to_targets([], []) True >>> can_move_boxes_to_targets([1], [1]) True >>> can_move_boxes_to_targets([2], [1]) False >>> can_move_boxes_to_targets([3, 2, 2, 1], [1, 2, 2, 3]) True >>> boxes = list(range(1, 1001)) >>> targets = list(range(1, 1001)) >>> can_move_boxes_to_targets(boxes, targets) True >>> targets[998] = 998 # making one less to be smaller than box size 999 >>> can_move_boxes_to_targets(boxes, targets) False","solution":"def can_move_boxes_to_targets(boxes, targets): Determines if every box can be moved to a target with at least the same capacity. Args: boxes (list of int): Sizes of the boxes. targets (list of int): Target capacities. Returns: bool: True if every box can be moved to a target with at least the same capacity, False otherwise. # Sort both boxes and targets to facilitate the process of matching boxes.sort() targets.sort() # Compare each box to the corresponding target for box_size, target_capacity in zip(boxes, targets): if box_size > target_capacity: return False return True"},{"question":"def can_sort_with_k_operations(arr: List[int], k: int) -> bool: Determines if it's possible to sort the array \`arr\` in non-decreasing order with at most \`k\` swap operations. Parameters: arr (list of int): A 0-indexed integer array. k (int): Maximum number of swap operations allowed. Returns: bool: True if the array can be sorted with at most \`k\` operations, False otherwise. >>> can_sort_with_k_operations([4, 3, 2, 1], 2) True >>> can_sort_with_k_operations([4, 3, 2, 1], 1) False >>> can_sort_with_k_operations([1, 5, 4, 3, 2], 2) True >>> can_sort_with_k_operations([1, 5, 4, 3, 2], 1) False >>> can_sort_with_k_operations([1, 2, 3, 4, 5], 0) True >>> can_sort_with_k_operations([1, 2, 3, 4, 5], 1) True >>> can_sort_with_k_operations([1], 0) True >>> can_sort_with_k_operations([1], 1) True >>> can_sort_with_k_operations([2, 1], 0) False >>> can_sort_with_k_operations([2, 1], 1) True >>> can_sort_with_k_operations([4, 3, 2, 1], 4) True >>> can_sort_with_k_operations([3, 2, 1, 4], 2) True >>> can_sort_with_k_operations([2, 1, 1, 2], 1) True >>> can_sort_with_k_operations([2, 1, 1, 2], 0) False # Your code here","solution":"def can_sort_with_k_operations(arr, k): Determines if it's possible to sort the array \`arr\` in non-decreasing order with at most \`k\` swap operations. Parameters: arr (list of int): A 0-indexed integer array. k (int): Maximum number of swap operations allowed. Returns: bool: True if the array can be sorted with at most \`k\` operations, False otherwise. # Track the number of misplaced elements misplaced_count = 0 # Create a sorted version of the array to compare against sorted_arr = sorted(arr) # Iterate through the array and count the number of misplaced elements for i, val in enumerate(arr): if val != sorted_arr[i]: misplaced_count += 1 # Calculate the minimum number of swaps needed min_swaps_needed = misplaced_count // 2 # Check if the minimum required swaps are within the allowed operations return min_swaps_needed <= k"},{"question":"def count_blocked_buildings(heights: List[int]) -> List[int]: Returns an array of length n such that result[i] contains the number of buildings that are blocked by building i. >>> count_blocked_buildings([4, 2, 3, 1]) [0, 1, 1, 3] >>> count_blocked_buildings([3]) [0] >>> count_blocked_buildings([2, 2, 2, 2]) [0, 1, 2, 3] >>> count_blocked_buildings([1, 2, 3, 4]) [0, 0, 0, 0] >>> count_blocked_buildings([4, 3, 2, 1]) [0, 1, 2, 3] >>> count_blocked_buildings([3, 2, 2, 4, 1]) [0, 1, 2, 0, 4]","solution":"def count_blocked_buildings(heights): Returns an array of length n such that result[i] contains the number of buildings that are blocked by building i. n = len(heights) result = [0] * n for i in range(1, n): count = 0 for j in range(i): if heights[j] >= heights[i]: count += 1 result[i] = count return result"},{"question":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: Return the zigzag level order traversal of a binary tree's nodes' values. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> zigzagLevelOrder(root) [[1], [3, 2]] def test_zigzag_level_order_empty_tree(): assert zigzagLevelOrder(None) == [] def test_zigzag_level_order_single_node(): root = TreeNode(1) assert zigzagLevelOrder(root) == [[1]] def test_zigzag_level_order_two_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert zigzagLevelOrder(root) == [[1], [3, 2]] def test_zigzag_level_order_three_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert zigzagLevelOrder(root) == [[1], [3, 2], [4, 5, 6, 7]] def test_zigzag_level_order_three_levels_unbalanced(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.right = TreeNode(7) assert zigzagLevelOrder(root) == [[1], [3, 2], [4, 7]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"def min_moves_to_non_decreasing(heights: List[int]) -> int: Returns the minimum number of students that must be moved in order to form a non-decreasing order. :param heights: List of integers representing the height of students. :return: Integer representing the minimum number of moves needed. >>> min_moves_to_non_decreasing([5, 3, 8, 6, 7]) 2 >>> min_moves_to_non_decreasing([1, 2, 3, 4, 5]) 0 >>> min_moves_to_non_decreasing([5, 4, 3, 2, 1]) 4 >>> min_moves_to_non_decreasing([2, 1, 5, 3, 4]) 2 >>> min_moves_to_non_decreasing([10]) 0 >>> min_moves_to_non_decreasing([4, 4, 4, 4, 4]) 0 >>> min_moves_to_non_decreasing([10, 1, 3, 2, 6, 15, 4]) 3","solution":"def min_moves_to_non_decreasing(heights): Returns the minimum number of students that must be moved to form a non-decreasing order. :param heights: List of integers representing the height of students. :return: Integer representing the minimum number of moves needed. n = len(heights) # Find longest increasing subsequence lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) longest_increasing_subsequence_length = max(lis) # Minimum number of moves is the length of the array minus the length of longest increasing subsequence return n - longest_increasing_subsequence_length"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def longest_consecutive(head): Returns the length of the longest sequence of consecutive numbers in the linked list. >>> head = construct_linked_list([100, 4, 200, 1, 3, 2]) >>> longest_consecutive(head) 4 >>> head = construct_linked_list([10, 11, 10, 12, 10, 13, 10]) >>> longest_consecutive(head) 4 >>> head = construct_linked_list([5, 2, 99, 3, 4, 1, 100]) >>> longest_consecutive(head) 5 >>> head = construct_linked_list([10, 20, 30, 40]) >>> longest_consecutive(head) 1 >>> head = construct_linked_list([1, 2, 3, 4, 5]) >>> longest_consecutive(head) 5 >>> head = construct_linked_list([]) >>> longest_consecutive(head) 0 >>> head = construct_linked_list([10]) >>> longest_consecutive(head) 1","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def longest_consecutive(head): Returns the length of the longest sequence of consecutive numbers in the linked list. if not head: return 0 nums = set() current = head while current: nums.add(current.val) current = current.next longest_streak = 0 for num in nums: if num - 1 not in nums: current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def minCoins(coins: List[int], target: int) -> int: Function to find the minimum number of coins needed to make up a given amount. If that amount cannot be made up by any combination of the coins, return -1. :param coins: List[int] - a list of different denominations of coins. :param target: int - the total amount to make. :return: int - the minimum number of coins to make the target amount or -1 if not possible. >>> minCoins([1, 2, 5], 11) 3 >>> minCoins([2], 3) -1","solution":"def minCoins(coins, target): Function to find the minimum number of coins needed to make up a given amount. If that amount cannot be made up by any combination of the coins, return -1. :param coins: List[int] - a list of different denominations of coins. :param target: int - the total amount to make. :return: int - the minimum number of coins to make the target amount or -1 if not possible. # Initialize DP array with infinity for all values except 0 which needs 0 coins to make. dp = [float('inf')] * (target + 1) dp[0] = 0 for coin in coins: for x in range(coin, target + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[target] if dp[target] != float('inf') else -1"},{"question":"def word_mapper(words): Returns a dictionary where each key is a word from the list and the value is a list of indices at which the word appears in the list. Args: words (List[str]): List of words to map to their indices Returns: Dict[str, List[int]]: Dictionary mapping words to list of indices Examples: >>> word_mapper([\\"apple\\", \\"banana\\", \\"orange\\"]) {'apple': [0], 'banana': [1], 'orange': [2]} >>> word_mapper([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) {'apple': [0, 2, 5], 'banana': [1, 4], 'orange': [3]} >>> word_mapper([\\"one\\", \\"two\\", \\"three\\", \\"four\\"]) {'one': [0], 'two': [1], 'three': [2], 'four': [3]} >>> word_mapper([]) {} >>> word_mapper([\\"apple\\", \\"Apple\\", \\"APPLE\\", \\"apple\\"]) {'apple': [0, 3], 'Apple': [1], 'APPLE': [2]} >>> word_mapper([\\"apple\\", \\"apple\\", \\"apple\\"]) {'apple': [0, 1, 2]} >>> word_mapper([\\"dog\\", \\"cat\\", \\"dog\\", \\"bird\\", \\"cat\\", \\"dog\\"]) {'dog': [0, 2, 5], 'cat': [1, 4], 'bird': [3]}","solution":"def word_mapper(words): Returns a dictionary where each key is a word from the list and the value is a list of indices at which the word appears in the list. word_dict = {} for index, word in enumerate(words): if word in word_dict: word_dict[word].append(index) else: word_dict[word] = [index] return word_dict"},{"question":"def minimize_string_length(s: str) -> int: Given a string s containing only characters 'a', 'b', and 'c', return the length of the shortest string possible after performing any number of operations. >>> minimize_string_length(\\"aaa\\") 3 >>> minimize_string_length(\\"bbb\\") 3 >>> minimize_string_length(\\"ab\\") 2 >>> minimize_string_length(\\"ccba\\") 2 >>> minimize_string_length(\\"abc\\") 2 >>> minimize_string_length(\\"abacbacabc\\") 2 >>> minimize_string_length(\\"\\") 0","solution":"def minimize_string_length(s): Given a string s containing only characters 'a', 'b', and 'c', return the length of the shortest string possible after performing any number of operations. # If all characters are the same, we can't reduce the string if len(s) == 0 or all(char == s[0] for char in s): return len(s) # If there are exactly two different characters if len(set(s)) == 2: return 2 # For three different characters return 2 if len(set(s)) == 3 else 1"},{"question":"def trap_rainwater(arr): Calculate the total amount of trapped rainwater. Args: arr (list of int): List of building heights. Returns: int: Total amount of trapped rainwater. >>> trap_rainwater([]) == 0 >>> trap_rainwater([5]) == 0 >>> trap_rainwater([1, 2]) == 0 >>> trap_rainwater([0, 1, 2, 1, 0]) == 0 >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rainwater([3, 0, 1, 3, 0, 5]) == 8 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rainwater([3, 3, 3, 3, 3]) == 0","solution":"def trap_rainwater(arr): Calculate the total amount of trapped rainwater. Args: arr (list of int): List of building heights. Returns: int: Total amount of trapped rainwater. if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - arr[i] return total_water"},{"question":"def max_subarray_sum(nums: List[int], m: int) -> int: Returns the maximum sum of any subarray of size m within the list nums. >>> max_subarray_sum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_subarray_sum([5], 1) 5 >>> max_subarray_sum([3, 3, 3, 3, 3], 2) 6 >>> max_subarray_sum([7, 1, 5, 3, 6, 4], 6) 26 >>> max_subarray_sum([2, 1, 5, 1, 3, 2], 3) 9 >>> max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5], 4) 16 >>> max_subarray_sum([1, 2, 3], 5) Traceback (most recent call last): ... ValueError: Subarray size m cannot be larger than the array size.","solution":"def max_subarray_sum(nums, m): Returns the maximum sum of any subarray of size m within the list nums. n = len(nums) if n < m: raise ValueError(\\"Subarray size m cannot be larger than the array size.\\") max_sum = sum(nums[:m]) current_sum = max_sum for i in range(m, n): current_sum += nums[i] - nums[i-m] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def canPartition(weights: List[int], limit: int) -> bool: Partition the array into two subsets such that the weight of each partition does not exceed \`limit\` and the sum of the weights in each subset is as close as possible. >>> canPartition([1, 5, 11, 5], 11) True >>> canPartition([1, 2, 3, 5], 5) False >>> canPartition([3, 3, 3, 4, 5], 10) True >>> canPartition([1, 2, 3, 4, 5, 6, 7], 20) True >>> canPartition([1], 1) False >>> canPartition([4, 4], 4) True pass # Your code here","solution":"def canPartition(weights, limit): n = len(weights) total_weight = sum(weights) if total_weight % 2 != 0: return False target = total_weight // 2 if target > limit: return False dp = [False] * (target + 1) dp[0] = True for weight in weights: for j in range(target, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] return dp[target]"},{"question":"def min_boxes(X, Y, Z, N): Determines the minimum number of boxes required to exactly fit N units. If it is not possible to exactly fit N units, returns -1. Parameters: X (int): units small box can hold. Y (int): units medium box can hold. Z (int): units large box can hold. N (int): total units to fit into boxes. Returns: int: minimum number of boxes or -1 if not possible. >>> min_boxes(1, 3, 5, 9) 3 >>> min_boxes(2, 4, 6, 12) 2 >>> min_boxes(2, 3, 5, 8) 2 >>> min_boxes(5, 10, 15, 7) -1 >>> min_boxes(6, 9, 20, 4) -1 >>> min_boxes(3, 5, 7, 1) -1 >>> min_boxes(1, 1, 1, 0) 0 >>> min_boxes(1, 1, 1, 1) 1 >>> min_boxes(10, 10, 10, 30) 3 >>> min_boxes(2, 3, 4, 7) 2 >>> min_boxes(8, 12, 20, 40) 2 >>> min_boxes(3, 5, 7, 20) 4","solution":"def min_boxes(X, Y, Z, N): Determines the minimum number of boxes required to exactly fit N units. If it is not possible to exactly fit N units, returns -1. Parameters: X (int): units small box can hold. Y (int): units medium box can hold. Z (int): units large box can hold. N (int): total units to fit into boxes. Returns: int: minimum number of boxes or -1 if not possible. # Let's use a dynamic programming approach to solve this problem. # dp[i] will store the minimum number of boxes required to fit exactly i units. dp = [float('inf')] * (N + 1) dp[0] = 0 # No box is needed to fit 0 units for i in range(1, N + 1): if i >= X and dp[i - X] != float('inf'): dp[i] = min(dp[i], dp[i - X] + 1) if i >= Y and dp[i - Y] != float('inf'): dp[i] = min(dp[i], dp[i - Y] + 1) if i >= Z and dp[i - Z] != float('inf'): dp[i] = min(dp[i], dp[i - Z] + 1) return dp[N] if dp[N] != float('inf') else -1"},{"question":"from typing import List def max_length_subarray(arr: List[int], k: int) -> int: Returns the maximum length of a subarray where the absolute difference between any two elements is at most k. >>> max_length_subarray([1], 3) 1 >>> max_length_subarray([], 3) 0 >>> max_length_subarray([1, 3, 2], 2) 3 >>> max_length_subarray([1, 3, 6], 2) 2 >>> max_length_subarray([1, 3, 6, 10, 15], 100) 5 >>> max_length_subarray([1, 3, 6, 10, 15], 0) 1 >>> max_length_subarray([10, 1, 6, 2, 8, 3], 2) 3","solution":"def max_length_subarray(arr, k): Returns the maximum length of a subarray where the absolute difference between any two elements is at most k. n = len(arr) if n == 0: return 0 arr.sort() left = 0 max_len = 1 for right in range(1, n): while arr[right] - arr[left] > k: left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def shortest_path(grid: List[List[int]], startRow: int, startCol: int, endRow: int, endCol: int) -> int: Determines the shortest path in the grid from the start cell to the target cell. Returns the length of the shortest path, or -1 if no path exists. >>> grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] >>> shortest_path(grid, 0, 0, 2, 2) 4 >>> grid = [[0, 0, 1], [0, 1, 0], [0, 0, 0]] >>> shortest_path(grid, 0, 0, 2, 2) 4 >>> grid = [[0, 1, 0], [1, 1, 0], [0, 0, 0]] >>> shortest_path(grid, 0, 0, 2, 2) -1 >>> grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] >>> shortest_path(grid, 0, 0, 0, 0) 0","solution":"from collections import deque def shortest_path(grid, startRow, startCol, endRow, endCol): Determines the shortest path in the grid from the start cell to the target cell. Returns the length of the shortest path, or -1 if no path exists. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set((startRow, startCol)) queue = deque([(startRow, startCol, 0)]) # (x, y, step count) while queue: x, y, steps = queue.popleft() if (x, y) == (endRow, endCol): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # No path found"},{"question":"def kill_process(pid_list: List[int], ppid_list: List[int], kill: int) -> List[int]: Returns the list of process IDs that are killed if a given process ID is killed. :param pid_list: List of process IDs. :param ppid_list: List of parent process IDs corresponding to each process ID. :param kill: Process ID to be killed. :return: List of process IDs that are killed. >>> kill_process([1, 3, 10, 5], [3, 0, 5, 3], 10) [10] >>> kill_process([1, 3, 10, 5], [3, 0, 5, 3], 3) [3, 1, 5, 10] >>> kill_process([1, 2, 3, 4, 5], [0, 1, 1, 2, 2], 1) [1, 2, 3, 4, 5] >>> kill_process([1, 2, 3, 4, 5], [0, 1, 1, 2, 2], 5) [5] >>> kill_process([1, 2, 3, 4, 5], [0, 1, 1, 2, 2], 2) [2, 4, 5]","solution":"def kill_process(pid_list, ppid_list, kill): Returns the list of process IDs that are killed if a given process ID is killed. :param pid_list: List of process IDs. :param ppid_list: List of parent process IDs corresponding to each process ID. :param kill: Process ID to be killed. :return: List of process IDs that are killed. from collections import defaultdict, deque # Building the process tree process_tree = defaultdict(list) for i in range(len(pid_list)): process_tree[ppid_list[i]].append(pid_list[i]) # Performing BFS to collect all processes to be killed killed_processes = [] queue = deque([kill]) while queue: current = queue.popleft() killed_processes.append(current) queue.extend(process_tree[current]) return killed_processes"},{"question":"from typing import List def alienOrder(words: List[str]) -> str: Determine the order of characters in an alien language. :param List[str] words: List of words sorted lexicographically in the alien language :return str: A string representing the order of characters or \\"\\" if no valid ordering exists >>> alienOrder([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) == \\"wertf\\" >>> alienOrder([\\"abc\\", \\"ab\\"]) == \\"\\" >>> alienOrder([\\"z\\"]) == \\"z\\" >>> alienOrder([\\"ab\\", \\"ac\\"]) == \\"abc\\" >>> order = alienOrder([\\"abc\\", \\"abx\\", \\"bca\\", \\"bcx\\"]) >>> set(order) == set(\\"abcx\\") >>> order.index('a') < order.index('b') >>> order.index('b') < max(order.index('c'), order.index('x')) >>> alienOrder([\\"z\\", \\"x\\", \\"z\\"]) == \\"\\" >>> alienOrder([\\"z\\", \\"x\\", \\"y\\"]) == \\"zyx\\" or \\"yxz\\" or \\"xzy\\" >>> alienOrder([\\"abcd\\",\\"abcf\\",\\"abcg\\"]) == \\"abcdfg\\"","solution":"from collections import defaultdict, deque def alienOrder(words): Determine the order of characters in an alien language. :param List[str] words: List of words sorted lexicographically in the alien language :return str: A string representing the order of characters or \\"\\" if no valid ordering exists # Create data structures adj_list = defaultdict(set) in_degree = {char: 0 for word in words for char in word} # Build the graph for i in range(len(words) - 1): first_word, second_word = words[i], words[i + 1] min_length = min(len(first_word), len(second_word)) # Check if the first word is a prefix of the second word if len(first_word) > len(second_word) and first_word[:min_length] == second_word[:min_length]: return \\"\\" # Create edges for j in range(min_length): if first_word[j] != second_word[j]: if second_word[j] not in adj_list[first_word[j]]: adj_list[first_word[j]].add(second_word[j]) in_degree[second_word[j]] += 1 break # Topological Sort (Kahn's algorithm) zero_in_degree_queue = deque([char for char in in_degree if in_degree[char] == 0]) ordered_chars = [] while zero_in_degree_queue: char = zero_in_degree_queue.popleft() ordered_chars.append(char) # Reduce the in-degree of the neighbor nodes for neighbor in adj_list[char]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the topologically sorted order has all the characters, return as a string if len(ordered_chars) == len(in_degree): return \\"\\".join(ordered_chars) else: return \\"\\""},{"question":"def find_buildings_with_view(height): Returns the list of indices of buildings that have a view. :param height: List[int] - list of building heights :return: List[int] - indices of buildings with a view in ascending order >>> find_buildings_with_view([4, 2, 3, 1]) [0, 2, 3] >>> find_buildings_with_view([4, 4, 4, 4]) [3] >>> find_buildings_with_view([4, 3, 2, 1]) [0, 1, 2, 3] >>> find_buildings_with_view([1, 2, 3, 4]) [3] >>> find_buildings_with_view([1]) [0] >>> find_buildings_with_view([]) [] >>> find_buildings_with_view([5, 3, 3, 4, 1]) [0, 3, 4]","solution":"def find_buildings_with_view(height): Returns the list of indices of buildings that have a view. n = len(height) if n == 0: return [] view_indices = [] max_height_so_far = float('-inf') for i in range(n - 1, -1, -1): if height[i] > max_height_so_far: view_indices.append(i) max_height_so_far = height[i] view_indices.reverse() return view_indices"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Calculate the minimum cost to navigate from the top-left corner to the bottom-right corner of the grid. Args: grid (list of lists of int): The m x n grid with non-negative numbers. Returns: int: The minimum cost to reach the bottom-right corner. Examples: >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3]]) 6 >>> min_path_sum([[1], [2], [3]]) 6 >>> min_path_sum([]) 0 >>> min_path_sum([[5]]) 5","solution":"def min_path_sum(grid): Calculate the minimum cost to navigate from the top-left corner to the bottom-right corner of the grid. Args: grid (list of lists of int): The m x n grid with non-negative numbers. Returns: int: The minimum cost to reach the bottom-right corner. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the cost matrix with the same dimensions as the grid cost = [[0 for _ in range(cols)] for _ in range(rows)] # Start from the top-left corner cost[0][0] = grid[0][0] # Initialize the first row (can only come from the left) for j in range(1, cols): cost[0][j] = cost[0][j-1] + grid[0][j] # Initialize the first column (can only come from above) for i in range(1, rows): cost[i][0] = cost[i-1][0] + grid[i][0] # Fill the cost matrix for i in range(1, rows): for j in range(1, cols): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[rows-1][cols-1]"},{"question":"from typing import List def smallest_common_number(arrays: List[List[int]], k: int) -> int: Given m arrays of integers, where the ith array arr[i] is sorted in non-decreasing order, return the smallest number that appears in at least k of the m arrays. If there is no such number, return -1. The input arrays may contain negative numbers. >>> smallest_common_number([[1, 2, 3], [2, 3, 4], [2, 4, 5]], 2) 2 >>> smallest_common_number([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) -1 >>> smallest_common_number([[1, 2, 3, 4, 5]], 1) 1 >>> smallest_common_number([[1, 2, 2], [2, 2, 3, 4], [1, 2, 4, 5]], 3) 2 >>> smallest_common_number([[-3, -2, -1, 1], [2, -1, 3], [-1, 4, 5]], 2) -1 >>> smallest_common_number([[7], [7], [7]], 1) 7","solution":"from collections import defaultdict def smallest_common_number(arrays, k): Finds the smallest number that appears in at least k of the m sorted arrays. :param arrays: List of m sorted arrays. :param k: Minimum number of arrays a number should appear in. :return: The smallest number that appears in at least k of the m arrays, or -1 if no such number exists. number_count = defaultdict(int) for array in arrays: unique_elements = set(array) for num in unique_elements: number_count[num] += 1 result = float('inf') for num, count in number_count.items(): if count >= k: result = min(result, num) return result if result != float('inf') else -1"},{"question":"def can_single_swap_make_equal(s: str, goal: str) -> bool: Returns true if and only if s can become goal after exactly one swap in s, or if s is equal to goal. >>> can_single_swap_make_equal(\\"abc\\", \\"abc\\") True >>> can_single_swap_make_equal(\\"ab\\", \\"ba\\") True >>> can_single_swap_make_equal(\\"abc\\", \\"bca\\") False >>> can_single_swap_make_equal(\\"abcd\\", \\"abc\\") False >>> can_single_swap_make_equal(\\"abcdef\\", \\"abcfde\\") False >>> can_single_swap_make_equal(\\"abab\\", \\"abba\\") True >>> can_single_swap_make_equal(\\"aabbcc\\", \\"ababcc\\") True >>> can_single_swap_make_equal(\\"aabb\\", \\"aabb\\") True","solution":"def can_single_swap_make_equal(s, goal): Returns true if and only if s can become goal after exactly one swap in s, or if s is equal to goal. if s == goal: return True if len(s) != len(goal): return False diff = [(a, b) for a, b in zip(s, goal) if a != b] if len(diff) == 2 and diff[0] == diff[1][::-1]: return True return False"},{"question":"def min_window_substring(s: str, t: str) -> str: Returns the minimum window substring of \`s\` that contains all the characters in \`t\`. >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window_substring(\\"ADOBECODEBANC\\", \\"XYZ\\") \\"\\" >>> min_window_substring(\\"\\", \\"ABC\\") \\"\\" >>> min_window_substring(\\"ADOBECODEBANC\\", \\"\\") \\"\\" >>> min_window_substring(\\"ABC\\", \\"ABC\\") \\"ABC\\" >>> min_window_substring(\\"ABCDEF\\", \\"ABC\\") \\"ABC\\" >>> min_window_substring(\\"DEFABC\\", \\"ABC\\") \\"ABC\\"","solution":"from collections import Counter def min_window_substring(s, t): Returns the minimum window substring of \`s\` that contains all the characters in \`t\`. if not s or not t: return \\"\\" t_counter = Counter(t) s_counter = Counter() required = len(t_counter) formed = 0 l, r = 0, 0 min_len = float(\\"inf\\") min_window = \\"\\" while r < len(s): character = s[r] s_counter[character] += 1 if character in t_counter and s_counter[character] == t_counter[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < min_len: min_len = r - l + 1 min_window = s[l:r+1] s_counter[character] -= 1 if character in t_counter and s_counter[character] < t_counter[character]: formed -= 1 l += 1 r += 1 return min_window"},{"question":"def match_pattern(words: List[str], pattern: str) -> List[str]: You are given a list of words and a pattern. The pattern is a string where each character represents a different letter but all letters that occur the same number of times in the pattern must appear the same number of times in the words. For example, pattern \\"aabb\\" means that valid words must have two letters appearing twice each. Return a list of words from the provided list that match the pattern. Each word in the list contains only lowercase English letters, and the length of each word is the same as the length of the pattern. Each word contains distinct characters that map uniquely to the characters in the pattern. >>> match_pattern([\\"abba\\", \\"abcd\\", \\"mnmn\\", \\"aabb\\"], \\"aabb\\") [\\"abba\\", \\"mnmn\\", \\"aabb\\"] >>> match_pattern([], \\"aabb\\") [] >>> match_pattern([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], \\"aabb\\") [] >>> match_pattern([\\"aabb\\", \\"yyzz\\", \\"mmoo\\"], \\"aabb\\") [\\"aabb\\", \\"yyzz\\", \\"mmoo\\"] >>> match_pattern([\\"a\\", \\"b\\", \\"c\\"], \\"a\\") [\\"a\\", \\"b\\", \\"c\\"] >>> match_pattern([\\"abcd\\", \\"efgh\\"], \\"xxy\\") [] pass","solution":"def match_pattern(words, pattern): from collections import Counter def encode(word): counter = Counter(word) return tuple(sorted(counter.values())) pattern_code = encode(pattern) return [word for word in words if encode(word) == pattern_code]"},{"question":"def three_sum(arr: List[int], target: int) -> List[List[int]]: Finds all unique triplets in the array which gives the sum of target. :param arr: List[int] - The input array of integers :param target: int - The target sum for the triplets :return: List[List[int]] - List of unique triplets that sum up to the target >>> three_sum([1, 2, 3, 4, 5], 9) [[1, 3, 5], [2, 3, 4]] >>> three_sum([-1, 0, 1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3], 10) [] >>> three_sum([0, 0, 0, 0], 0) [[0, 0, 0]] >>> three_sum([-1, 0, 1, -2, 2, -4, 4], 0) [[-4, 0, 4], [-2, 0, 2], [-1, 0, 1]] pass","solution":"def three_sum(arr, target): Finds all unique triplets in the array which gives the sum of target. :param arr: List[int] - The input array of integers :param target: int - The target sum for the triplets :return: List[List[int]] - List of unique triplets that sum up to the target arr.sort() result = [] n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicate elements left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: result.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 # Skip duplicates while left < right and arr[right] == arr[right - 1]: right -= 1 # Skip duplicates left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"def min_subarray_len(nums: List[int], k: int) -> int: Returns the length of the smallest contiguous subarray sum that is greater than or equal to k. If there is no such subarray, return 0. >>> min_subarray_len([1, 2, 3], 7) 0 >>> min_subarray_len([2, 3, 1, 2, 4, 3], 4) 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1], 6) 6 >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 8) 2","solution":"def min_subarray_len(nums, k): Returns the length of the smallest contiguous subarray sum that is greater than or equal to k. If there is no such subarray, return 0. n = len(nums) min_len = float('inf') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= k: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of swaps required to sort the array in non-decreasing order. >>> min_swaps_to_sort([1, 2, 3, 4, 5]) == 0 >>> min_swaps_to_sort([5, 4, 3, 2, 1]) == 2 >>> min_swaps_to_sort([1]) == 0 >>> min_swaps_to_sort([2, 3, 2, 1, 3]) == 2 >>> min_swaps_to_sort([4, 3, 2, 1, 6, 5]) == 3 >>> min_swaps_to_sort([1, 2, 2, 3, 4]) == 0 >>> min_swaps_to_sort([2, 2, 2, 2, 2]) == 0","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in non-decreasing order. n = len(arr) # Create a list of tuples where each tuple is (value, index) arr_pos = [(value, idx) for idx, value in enumerate(arr)] # Sort the array by the values arr_pos.sort(key=lambda x: x[0]) # Create a visited array to mark already visited elements visited = [False] * n swaps = 0 for i in range(n): # If element is already visited or already in the correct place if visited[i] or arr_pos[i][1] == i: continue # Calculate the size of the cycle cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 # If there is a cycle of k nodes, the number of swaps required is (k-1) if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def count_reverse_pairs(arr: List[int]) -> int: Count the number of important reverse pairs in the array. An important reverse pair is defined as a pair (i, j) where 0 <= i < j < len(arr) and arr[i] > 2 * arr[j]. >>> count_reverse_pairs([1, 3, 2, 3, 1]) 2 >>> count_reverse_pairs([1, 2, 3, 4, 5]) 0 >>> count_reverse_pairs([2, 2, 2, 2]) 0 >>> count_reverse_pairs([4, 3, 2, 1]) 2 >>> count_reverse_pairs([1, 10, 3, 4, 2, 6, 5]) 3 >>> count_reverse_pairs([]) 0 >>> count_reverse_pairs([1]) 0","solution":"def count_reverse_pairs(arr): def merge_and_count(nums, temp, left, mid, right): i, j, k = left, mid + 1, left count = 0 # Count important reverse pairs while i <= mid and j <= right: if nums[i] > 2 * nums[j]: count += (mid - i + 1) j += 1 else: i += 1 # Merge the two halves i, j = left, mid + 1 while i <= mid and j <= right: if nums[i] <= nums[j]: temp[k] = nums[i] i += 1 else: temp[k] = nums[j] j += 1 k += 1 while i <= mid: temp[k] = nums[i] k += 1 i += 1 while j <= right: temp[k] = nums[j] k += 1 j += 1 for i in range(left, right + 1): nums[i] = temp[i] return count def merge_sort_and_count(nums, temp, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(nums, temp, left, mid) count += merge_sort_and_count(nums, temp, mid + 1, right) count += merge_and_count(nums, temp, left, mid, right) return count return merge_sort_and_count(arr, [0] * len(arr), 0, len(arr) - 1)"},{"question":"def minInsertionsToPalindrome(s: str) -> int: Given a string \`s\` consisting of lowercase letters, return the minimum number of characters needed to be inserted to make the string a palindrome. >>> minInsertionsToPalindrome(\\"a\\") == 0 >>> minInsertionsToPalindrome(\\"aa\\") == 0 >>> minInsertionsToPalindrome(\\"ab\\") == 1 >>> minInsertionsToPalindrome(\\"racecar\\") == 0 >>> minInsertionsToPalindrome(\\"google\\") == 2 >>> minInsertionsToPalindrome(\\"abcde\\") == 4","solution":"def minInsertionsToPalindrome(s): Returns the minimum number of characters needed to be inserted to make the string a palindrome. n = len(s) # Create a DP table of size n x n where dp[i][j] represents # the minimum number of insertions to make the substring s[i:j+1] a palindrome dp = [[0] * n for _ in range(n)] # Fill the table for length in range(2, n+1): # length of the current substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1 return dp[0][n-1]"},{"question":"def findMaxLength(nums: List[int]) -> int: Finds the length of the longest subarray with an equal number of 0's and 1's. >>> findMaxLength([0, 1]) 2 >>> findMaxLength([1, 0]) 2 >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 1, 0, 1]) 4 >>> findMaxLength([0, 1, 1, 0, 1, 1, 1, 0, 0, 0]) 10 >>> findMaxLength([0, 0, 1, 1, 0, 0, 1, 1, 0]) 8 >>> findMaxLength([1, 1, 0, 0, 1, 1, 0, 0, 1, 0]) 10","solution":"def findMaxLength(nums): Finds the length of the longest subarray with an equal number of 0's and 1's. Parameters: nums (list of int): A binary array where each element is either 0 or 1. Returns: int: The length of the longest subarray with equal number of 0's and 1's. count = 0 max_length = 0 count_index_map = {0: -1} for index, num in enumerate(nums): count += -1 if num == 0 else 1 if count in count_index_map: max_length = max(max_length, index - count_index_map[count]) else: count_index_map[count] = index return max_length"},{"question":"from typing import List def countSubarrays(nums: List[int], target: int) -> int: Returns the number of contiguous subarrays that sum to the given target. >>> countSubarrays([5], 5) 1 >>> countSubarrays([1], 5) 0 >>> countSubarrays([1, 1, 1], 2) 2 >>> countSubarrays([1, 2, 3], 7) 0 >>> countSubarrays([1, 2, 3, 4, 5], 9) 2 >>> countSubarrays([100, 200, 300, 400], 500) 1 >>> countSubarrays([1, 2, 3, 3, 2, 1], 6) 3 >>> countSubarrays([0, 2, 3, 0, 4, 0], 0) 3 >>> countSubarrays([1, 1, 1, 1], 1) 4 >>> countSubarrays([5, 10, 7, -2], 20) 1","solution":"from typing import List def countSubarrays(nums: List[int], target: int) -> int: Returns the number of contiguous subarrays that sum to the given target. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if current_sum - target in prefix_sums: count += prefix_sums[current_sum - target] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"def construct_lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string possible after performing exactly \`k\` operations of removing any one character from the string \`s\` and adding it back to any position in the string. Parameters: s (str): input string containing only lowercase English letters k (int): number of allowed operations Returns: str: lexicographically smallest string after \`k\` operations from solution import construct_lexicographically_smallest_string def test_with_operations(): assert construct_lexicographically_smallest_string(\\"cba\\", 1) == 'abc' assert construct_lexicographically_smallest_string(\\"ba\\", 2) == 'ab' assert construct_lexicographically_smallest_string(\\"edcba\\", 3) == 'abcde' assert construct_lexicographically_smallest_string(\\"faced\\", 4) == 'acdef' def test_no_operations(): assert construct_lexicographically_smallest_string(\\"bda\\", 0) == 'bda' assert construct_lexicographically_smallest_string(\\"zxy\\", 0) == 'zxy' def test_single_character(): assert construct_lexicographically_smallest_string(\\"x\\", 5) == 'x' assert construct_lexicographically_smallest_string(\\"a\\", 0) == 'a' def test_already_sorted_string(): assert construct_lexicographically_smallest_string(\\"abc\\", 3) == 'abc' assert construct_lexicographically_smallest_string(\\"abcdefg\\", 2) == 'abcdefg' def test_all_same_characters(): assert construct_lexicographically_smallest_string(\\"aaaa\\", 2) == 'aaaa' assert construct_lexicographically_smallest_string(\\"bbb\\", 1) == 'bbb'","solution":"def construct_lexicographically_smallest_string(s, k): Returns the lexicographically smallest string possible after performing exactly \`k\` operations of removing any one character from the string \`s\` and adding it back to any position in the string. Parameters: s (str): input string containing only lowercase English letters k (int): number of allowed operations Returns: str: lexicographically smallest string after \`k\` operations if k > 0: s = sorted(s) return ''.join(s) else: return s"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: You are given a 2D grid of integers representing a map where \`land\` is represented by \`1\` and \`water\` is represented by \`0\`. An island is a group of \`1\`s connected horizontally or vertically (but not diagonally). The grid is surrounded by water. Write a function that returns the number of distinct islands. Two islands are considered distinct if and only if one island is not the same as another by shape. Formally, two islands are distinct if and only if one island is not the translate, rotate, or reflect of another. >>> numDistinctIslands([ ... [1, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 0, 0, 1], ... [0, 0, 1, 1] ... ]) == 2 >>> numDistinctIslands([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> numDistinctIslands([ ... [1, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 0, 1], ... [0, 1, 0, 1] ... ]) == 3 >>> numDistinctIslands([ ... [1, 0, 1, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0], ... [1, 0, 1, 0], ... [1, 0, 1, 0] ... ]) == 1","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, path): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 path.append(direction) direction_vectors = [(-1, 0, 'U'), (1, 0, 'D'), (0, -1, 'L'), (0, 1, 'R')] for dx, dy, dir in direction_vectors: dfs(x + dx, y + dy, dir, path) path.append('B') # Backtrack unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path = [] dfs(i, j, 'O', path) unique_islands.add(tuple(path)) return len(unique_islands)"},{"question":"from typing import List, Tuple def calculate_left_right_max(heights: List[int]) -> Tuple[List[int], List[int]]: Given a list of building heights, generate and return two lists: 1. leftMax - the maximum height of all buildings to the left of each building. 2. rightMax - the maximum height of all buildings to the right of each building. :param heights: List[int] - list of building heights :return: Tuple[List[int], List[int]] - tuple containing leftMax and rightMax lists >>> calculate_left_right_max([4, 2, 0, 3, 2, 5]) ([0, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 0]) >>> calculate_left_right_max([1]) ([0], [0]) >>> calculate_left_right_max([1, 2]) ([0, 1], [2, 0]) >>> calculate_left_right_max([3, 3, 3, 3]) ([0, 3, 3, 3], [3, 3, 3, 0]) >>> calculate_left_right_max([]) ([], [])","solution":"def calculate_left_right_max(heights): Given a list of building heights, generate and return two lists: 1. leftMax - the maximum height of all buildings to the left of each building. 2. rightMax - the maximum height of all buildings to the right of each building. :param heights: List[int] - list of building heights :return: Tuple[List[int], List[int]] - tuple containing leftMax and rightMax lists n = len(heights) if n == 0: return [], [] leftMax = [0] * n rightMax = [0] * n # Fill leftMax array for i in range(1, n): leftMax[i] = max(leftMax[i-1], heights[i-1]) # Fill rightMax array for i in range(n-2, -1, -1): rightMax[i] = max(rightMax[i+1], heights[i+1]) return leftMax, rightMax"},{"question":"def max_subarray_length(nums: List[int], threshold: int) -> int: Returns the length of the longest subarray where the sum of its elements does not exceed \`threshold\`. >>> max_subarray_length([1, 2, 3, 4, 5], 7) 3 >>> max_subarray_length([3, 1, 2, 1, 4, 5], 7) 4 >>> max_subarray_length([-1, -2, 3, -1, 2], 2) 5 >>> max_subarray_length([6], 5) 0 >>> max_subarray_length([10, 5, 6], 4) 0","solution":"def max_subarray_length(nums, threshold): Returns the length of the longest subarray where the sum of its elements does not exceed \`threshold\`. n = len(nums) max_len = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > threshold and start <= end: current_sum -= nums[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def removeAdjacentDuplicates(s: str) -> str: Recursively remove all adjacent duplicates in the string s. >>> removeAdjacentDuplicates(\\"abbaca\\") \\"ca\\" >>> removeAdjacentDuplicates(\\"azxxzy\\") \\"ay\\" >>> removeAdjacentDuplicates(\\"aabbcc\\") \\"\\" >>> removeAdjacentDuplicates(\\"abc\\") \\"abc\\" >>> removeAdjacentDuplicates(\\"\\") \\"\\" >>> removeAdjacentDuplicates(\\"a\\") \\"a\\" >>> removeAdjacentDuplicates(\\"aa\\") \\"\\" >>> removeAdjacentDuplicates(\\"abba\\") \\"\\" >>> removeAdjacentDuplicates(\\"mississippi\\") \\"m\\" def test_remove_adjacent_duplicates(): assert removeAdjacentDuplicates(\\"abbaca\\") == \\"ca\\" assert removeAdjacentDuplicates(\\"azxxzy\\") == \\"ay\\" assert removeAdjacentDuplicates(\\"aabbcc\\") == \\"\\" assert removeAdjacentDuplicates(\\"abc\\") == \\"abc\\" assert removeAdjacentDuplicates(\\"\\") == \\"\\" assert removeAdjacentDuplicates(\\"a\\") == \\"a\\" assert removeAdjacentDuplicates(\\"aa\\") == \\"\\" assert removeAdjacentDuplicates(\\"abba\\") == \\"\\" assert removeAdjacentDuplicates(\\"mississippi\\") == \\"m\\" def test_remove_adjacent_single_character(): assert removeAdjacentDuplicates(\\"a\\") == \\"a\\" def test_remove_adjacent_empty_string(): assert removeAdjacentDuplicates(\\"\\") == \\"\\" def test_remove_adjacent_no_duplicates(): assert removeAdjacentDuplicates(\\"abcdef\\") == \\"abcdef\\"","solution":"def removeAdjacentDuplicates(s): Recursively remove all adjacent duplicates in the string s. Parameters: s (str): The input string. Returns: str: The string after removing all adjacent duplicates. # Using a stack to process the string and remove adjacent duplicates stack = [] # Traverse through the string for char in s: # If the stack is not empty and the top of the stack is equal to current character, # it means we found an adjacent duplicate, so we remove the top element from stack if stack and stack[-1] == char: stack.pop() else: # Otherwise, we push the current character to the stack stack.append(char) # The remaining elements in the stack form the result string return ''.join(stack)"},{"question":"def count_clear_views(buildings: List[int]) -> int: Returns the number of buildings that have a clear view of the sunset. Parameters: buildings (list of int): List of building heights. Returns: int: The number of buildings with a clear view of the sunset. >>> count_clear_views([3, 7, 8, 3, 6, 1]) 3 >>> count_clear_views([5]) 1 >>> count_clear_views([4, 4, 4, 4]) 1 >>> count_clear_views([1, 2, 3, 4, 5]) 1 >>> count_clear_views([5, 4, 3, 2, 1]) 5 >>> count_clear_views([2, 3, 4, 1, 5, 0]) 2 >>> count_clear_views([]) 0","solution":"def count_clear_views(buildings): Returns the number of buildings that have a clear view of the sunset. Parameters: buildings (list of int): List of building heights. Returns: int: The number of buildings with a clear view of the sunset. if not buildings: return 0 clear_view_count = 1 max_height = buildings[-1] for height in reversed(buildings[:-1]): if height > max_height: clear_view_count += 1 max_height = height return clear_view_count"},{"question":"def rob(nums: List[int]) -> int: Determines the maximum amount of money that can be robbed from a list of houses in a circular manner without robbing two adjacent houses. :param nums: List of positive integers representing the amount of money in each house. :return: The maximum amount of money that can be robbed. >>> rob([2, 3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([1, 2]) 2 >>> rob([10, 10, 10, 10]) 20 >>> rob([1, 2, 3, 4, 5, 6]) 12 >>> rob([6, 5, 4, 3, 2, 1]) 12 >>> rob([100, 1, 1, 1]) 101","solution":"def rob(nums): Determines the maximum amount of money that can be robbed from a list of houses in a circular manner without robbing two adjacent houses. :param nums: List of positive integers representing the amount of money in each house. :return: The maximum amount of money that can be robbed. def rob_line(houses): prev1, prev2 = 0, 0 for money in houses: temp = prev1 prev1 = max(prev1, prev2 + money) prev2 = temp return prev1 n = len(nums) if n == 1: return nums[0] return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"def cyclic_rotate(arr, k): Returns the array after \`k\` cyclic rotations. Parameters: arr (list): List of integers to be rotated. k (int): Number of cyclic rotations to be performed. Returns: list: The rotated list. >>> cyclic_rotate([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] >>> cyclic_rotate([1, 2, 3, 4, 5], 1) == [5, 1, 2, 3, 4] >>> cyclic_rotate([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> cyclic_rotate([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] >>> cyclic_rotate([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3]","solution":"def cyclic_rotate(arr, k): Returns the array after \`k\` cyclic rotations. Parameters: arr (list): List of integers to be rotated. k (int): Number of cyclic rotations to be performed. Returns: list: The rotated list. n = len(arr) # Normalize k to be within the length of the array k = k % n # Perform the rotations return arr[-k:] + arr[:-k]"},{"question":"def coin_change(k: int, nums: List[int]) -> int: Determine the minimum number of coins needed to make amount \`k\` using given coin denominations in \`nums\`. Returns -1 if it's not possible. >>> coin_change(11, [1, 2, 5]) 3 >>> coin_change(3, [2]) -1 >>> coin_change(10, [10]) 1 >>> coin_change(100, [1, 5, 10, 25]) 4 >>> coin_change(9, [3]) 3 >>> coin_change(12, [1, 6, 10]) 2 >>> coin_change(0, [1, 2, 3]) 0 >>> coin_change(10, []) -1","solution":"def coin_change(k, nums): Determine the minimum number of coins needed to make amount \`k\` using given coin denominations in \`nums\`. Returns -1 if it's not possible. Args: k (int): The total amount of money to make. nums (list): List of integers representing coin denominations. Returns: int: Minimum number of coins needed to make amount \`k\` or -1 if not possible. # Initialize the dp array with a value greater than the maximum possible number of coins dp = [float('inf')] * (k + 1) dp[0] = 0 # Base case: no coins are needed to make 0 amount for coin in nums: for i in range(coin, k + 1): if dp[i - coin] != float('inf'): dp[i] = min(dp[i], dp[i - coin] + 1) return dp[k] if dp[k] != float('inf') else -1"},{"question":"class VersionControl: You are implementing a version-controlled system for a file. Each version of the file can be represented as a string. >>> vc = VersionControl() >>> vc.commit(\\"Version 1\\") >>> vc.commit(\\"Version 2\\") >>> vc.rollback(1) 'Version 1' >>> vc.rollback(2) '' >>> vc.diff(1, 2) 'v1: Version 1 || v2: Version 2' >>> vc.diff(0, 3) 'Invalid version numbers' def __init__(self): pass def commit(self, s): pass def rollback(self, steps): pass def diff(self, v1, v2): pass","solution":"class VersionControl: def __init__(self): self.versions = [\\"\\"] def commit(self, s): self.versions.append(s) def rollback(self, steps): if steps >= len(self.versions): return self.versions[0] else: return self.versions[-1 - steps] def diff(self, v1, v2): if 0 <= v1 < len(self.versions) and 0 <= v2 < len(self.versions): version1 = self.versions[v1] version2 = self.versions[v2] return f\\"v{v1}: {version1} || v{v2}: {version2}\\" else: return \\"Invalid version numbers\\""},{"question":"def max_sum_after_swapping(nums1, nums2): Returns the maximum possible sum of widgets in nums1 after the optimal sequence of swap operations. Parameters: nums1 (list of int): The first array representing widgets produced each day. nums2 (list of int): The second array representing widgets produced each day. Returns: int: The maximum sum of nums1 after optimal swaps. pass # Unit Tests def test_max_sum_after_swapping_all_swaps_beneficial(): nums1 = [1, 2, 3] nums2 = [4, 5, 6] assert max_sum_after_swapping(nums1, nums2) == 15 def test_max_sum_after_swapping_no_swaps_beneficial(): nums1 = [4, 5, 6] nums2 = [1, 2, 3] assert max_sum_after_swapping(nums1, nums2) == 15 def test_max_sum_after_swapping_some_swaps_beneficial(): nums1 = [1, 5, 3] nums2 = [4, 2, 6] assert max_sum_after_swapping(nums1, nums2) == 15 def test_max_sum_after_swapping_identical_arrays(): nums1 = [3, 3, 3] nums2 = [3, 3, 3] assert max_sum_after_swapping(nums1, nums2) == 9 def test_max_sum_after_swapping_single_element_arrays(): nums1 = [5] nums2 = [10] assert max_sum_after_swapping(nums1, nums2) == 10 def test_max_sum_after_swapping_large_input(): nums1 = [i for i in range(1, 1001)] nums2 = [i for i in range(1001, 2001)] expected_sum = sum(range(1001, 2001)) assert max_sum_after_swapping(nums1, nums2) == expected_sum","solution":"def max_sum_after_swapping(nums1, nums2): Returns the maximum possible sum of widgets in nums1 after the optimal sequence of swap operations. Parameters: nums1 (list of int): The first array representing widgets produced each day. nums2 (list of int): The second array representing widgets produced each day. Returns: int: The maximum sum of nums1 after optimal swaps. max_sum = sum(nums1) current_sum = sum(nums1) for i in range(len(nums1)): # Try swapping swap_sum = current_sum - nums1[i] + nums2[i] # Update current_sum and max_sum if swap_sum is greater if swap_sum > current_sum: current_sum = swap_sum # Ensure max_sum always holds the highest possible sum max_sum = max(max_sum, swap_sum) return max_sum"},{"question":"def minimize_stones(arr: List[int]) -> int: Returns the minimum number of stones left after making all possible moves. Args: arr (List[int]): A list of integers representing the number of stones in each pile. Returns: int: The minimum number of stones left. >>> minimize_stones([10, 10]) == 0 >>> minimize_stones([4, 4, 4]) == 0 >>> minimize_stones([5, 7, 9]) == 1 >>> minimize_stones([100]) == 100 >>> minimize_stones([0, 0, 0]) == 0 >>> minimize_stones([10, 0, 0]) == 10 >>> minimize_stones([5, 1, 1, 1]) == 2 >>> minimize_stones([3, 1, 2]) == 0 >>> minimize_stones([8, 6, 4, 2]) == 0 >>> minimize_stones([4, 2, 3]) == 1","solution":"def minimize_stones(arr): Returns the minimum number of stones left after making all possible moves. import heapq # Convert the list into a max-heap (invert the values for max-heap simulation) neg_arr = [-a for a in arr if a > 0] heapq.heapify(neg_arr) while len(neg_arr) > 1: # Extract the two largest piles first = -heapq.heappop(neg_arr) second = -heapq.heappop(neg_arr) if first > 1 or second > 1: # Reduce both piles by the number of stones from the smaller pile first -= 1 second -= 1 # Add the remaining stones back to the heap if above zero if first > 0: heapq.heappush(neg_arr, -first) if second > 0: heapq.heappush(neg_arr, -second) return sum([-x for x in neg_arr])"},{"question":"def canPartitionKSubsets(arr: List[int], k: int) -> bool: Determines if it is possible to partition the array into k non-empty subsets whose sums are all equal. Args: arr (List[int]): array of non-negative integers k (int): number of subsets Returns: bool: True if such a partition is possible, False otherwise Example usage: >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> canPartitionKSubsets([1, 2, 3, 4], 3) False >>> canPartitionKSubsets([2, 2, 2, 2, 3, 4, 5], 4) False >>> canPartitionKSubsets([2, 2, 2, 2, 2, 2, 2, 2], 4) True >>> canPartitionKSubsets([1, 1, 1, 1, 1, 1, 1, 1], 8) True >>> canPartitionKSubsets([1, 1, 1, 1, 1, 1, 1, 1], 1) True >>> canPartitionKSubsets([4, 4, 4, 4], 4) True >>> canPartitionKSubsets([4, 4, 4, 6], 2) False >>> canPartitionKSubsets([1], 1) True >>> canPartitionKSubsets([0,0,0,0], 4) True","solution":"def canPartitionKSubsets(arr, k): Determines if the array can be partitioned into k non-empty subsets with equal sums. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) used = [False] * len(arr) subsets = [0] * k def can_partition(index): if index == len(arr): return all(subset == target_sum for subset in subsets) for i in range(k): if subsets[i] + arr[index] <= target_sum: subsets[i] += arr[index] if can_partition(index + 1): return True subsets[i] -= arr[index] if subsets[i] == 0: break return False return can_partition(0)"},{"question":"from datetime import datetime def day_of_week(date_str: str) -> str: Returns the day of the week for the given date string in format \\"YYYY-MM-DD\\". >>> day_of_week(\\"2023-10-01\\") \\"Sunday\\" >>> day_of_week(\\"2023-10-02\\") \\"Monday\\" >>> day_of_week(\\"2023-10-03\\") \\"Tuesday\\" >>> day_of_week(\\"2023-10-04\\") \\"Wednesday\\" >>> day_of_week(\\"2023-10-05\\") \\"Thursday\\" >>> day_of_week(\\"2023-10-06\\") \\"Friday\\" >>> day_of_week(\\"2023-10-07\\") \\"Saturday\\" >>> day_of_week(\\"2000-01-01\\") \\"Saturday\\" >>> day_of_week(\\"1971-02-15\\") \\"Monday\\" >>> day_of_week(\\"2100-12-31\\") \\"Friday\\"","solution":"from datetime import datetime def day_of_week(date_str): Returns the day of the week for the given date string in format \\"YYYY-MM-DD\\". date = datetime.strptime(date_str, \\"%Y-%m-%d\\") days = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] return days[date.weekday()]"},{"question":"def is_palindrome_possible(s: str) -> int: Determine the length of the smallest substring that, when sorted, would form a palindrome. Returns -1 if no such substring exists. >>> is_palindrome_possible(\\"\\") == -1 >>> is_palindrome_possible(\\"a\\") == 1 >>> is_palindrome_possible(\\"ab\\") == -1 >>> is_palindrome_possible(\\"aa\\") == 2 >>> is_palindrome_possible(\\"abccba\\") == 6 >>> is_palindrome_possible(\\"aabbccc\\") == 7 >>> is_palindrome_possible(\\"abcdef\\") == -1 >>> is_palindrome_possible(\\"civic\\") == 5 >>> is_palindrome_possible(\\"ivicc\\") == 5","solution":"def is_palindrome_possible(s): Returns the length of the smallest substring of s that can be rearranged to form a palindrome, or -1 if no such substring exists. from collections import Counter if not s: return -1 char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one character has an odd count, it's not possible to form a palindrome if odd_count > 1: return -1 # A palindrome can be formed by a substring containing all characters, rearranged correctly return len(s)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_sequence(root: TreeNode) -> int: Returns the length of the longest path where each node in the path has a value incrementing by 1 in a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> longest_increasing_sequence(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.left.right.left = TreeNode(4) >>> longest_increasing_sequence(root) 4 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(8) >>> longest_increasing_sequence(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(10) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> root.left.right.right = TreeNode(4) >>> longest_increasing_sequence(root) 4 >>> root = TreeNode(1) >>> longest_increasing_sequence(root) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_sequence(root): Returns the length of the longest path where each node in the path has a value incrementing by 1 in a binary tree. def dfs(node): if not node: return 0, 0 left_len, max_left_len = dfs(node.left) right_len, max_right_len = dfs(node.right) curr_len = 1 if node.left and node.val + 1 == node.left.val: curr_len = max(curr_len, left_len + 1) if node.right and node.val + 1 == node.right.val: curr_len = max(curr_len, right_len + 1) max_len = max(max_left_len, max_right_len, curr_len) return curr_len, max_len _, max_len = dfs(root) return max_len"},{"question":"class TreeLinkNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Given a binary tree, populate each next pointer to point to its next right node. If there's no next right node, the next pointer should be set to \`null\`. >>> example_tree = TreeLinkNode(1, TreeLinkNode(2, TreeLinkNode(4), TreeLinkNode(5)), TreeLinkNode(3, None, TreeLinkNode(7))) >>> connect(example_tree) >>> example_tree.next is None True >>> example_tree.left.next == example_tree.right True >>> example_tree.left.left.next == example_tree.left.right True >>> example_tree.left.right.next == example_tree.right.right True >>> example_tree.right.right.next is None True def tree_as_level_order_list(root): if not root: return [] result = [] current = root while current: node = current while node: result.append(node.val) node = node.next result.append(None) while current and not current.left and not current.right: current = current.next if current: current = current.left or current.right return result def test_connect(): node1 = TreeLinkNode(1) node2 = TreeLinkNode(2) node3 = TreeLinkNode(3) node4 = TreeLinkNode(4) node5 = TreeLinkNode(5) node7 = TreeLinkNode(7) node1.left = node2 node1.right = node3 node2.left = node4 node2.right = node5 node3.right = node7 connect(node1) assert node1.next == None assert node2.next == node3 assert node3.next == None assert node4.next == node5 assert node5.next == node7 assert node7.next == None assert tree_as_level_order_list(node1) == [1, None, 2, 3, None, 4, 5, 7, None] def test_connect_none_root(): assert connect(None) == None def test_connect_single_node(): node = TreeLinkNode(1) connect(node) assert node.next == None assert tree_as_level_order_list(node) == [1, None] def test_connect_two_nodes(): node1 = TreeLinkNode(1) node2 = TreeLinkNode(2) node1.left = node2 connect(node1) assert node1.next == None assert node2.next == None assert tree_as_level_order_list(node1) == [1, None, 2, None] node1 = TreeLinkNode(1) node2 = TreeLinkNode(2) node1.right = node2 connect(node1) assert node1.next == None assert node2.next == None assert tree_as_level_order_list(node1) == [1, None, 2, None]","solution":"class TreeLinkNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return None from collections import deque queue = deque([root]) while queue: prev = None level_size = len(queue) for _ in range(level_size): node = queue.popleft() if prev: prev.next = node prev = node if node.left: queue.append(node.left) if node.right: queue.append(node.right) prev.next = None return root"},{"question":"def transform_array(nums): Transform the array according to the given rules. :param nums: List[int] - The input array of integers. :return: List[int] - The transformed array. pass # Unit Test from function_to_test import transform_array def test_transform_array_general_case(): assert transform_array([1, 2, 3, 4, 5]) == [1, 1, 3, 6, 5] def test_transform_array_single_element(): assert transform_array([10]) == [10] def test_transform_array_two_elements(): assert transform_array([5, 9]) == [5, 9] def test_transform_array_empty_array(): assert transform_array([]) == [] def test_transform_array_negative_numbers(): assert transform_array([-1, -2, -3, -4]) == [-1, -1, -3, -4] def test_transform_array_mixed_numbers(): assert transform_array([1, -1, 2, -2, 3]) == [1, 1, 0, 2, 3]","solution":"def transform_array(nums): Transform the array according to the given rules. :param nums: List[int] - The input array of integers. :return: List[int] - The transformed array. if not nums: return [] n = len(nums) result = [0] * n result[0] = nums[0] result[-1] = nums[-1] for i in range(1, n - 1): result[i] = sum(nums[:i]) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root: TreeNode) -> TreeNode: Prunes the binary tree such that every subtree not containing a 1 is removed. :param root: TreeNode :return: TreeNode pass from solution import TreeNode, pruneTree def tree_to_list(root: TreeNode): if not root: return [] result = [root.val] nodes = [root] while nodes: node = nodes.pop(0) if node.left: result.append(node.left.val) nodes.append(node.left) else: if node.left is not None: result.append(None) if node.right: result.append(node.right.val) nodes.append(node.right) else: if node.right is not None: result.append(None) return result def test_prune_tree_example(): # Construct the tree # 1 # / # 0 1 # / # 0 0 root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(1) root.left.left = TreeNode(0) root.left.right = TreeNode(0) pruned_tree = pruneTree(root) pruned_tree_list = tree_to_list(pruned_tree) # Expected output tree: # 1 # # 1 expected_tree = TreeNode(1) expected_tree.right = TreeNode(1) expected_tree_list = tree_to_list(expected_tree) assert pruned_tree_list == expected_tree_list def test_prune_tree_all_zeros(): # Construct the tree # 0 # / # 0 root = TreeNode(0) root.left = TreeNode(0) pruned_tree = pruneTree(root) pruned_tree_list = tree_to_list(pruned_tree) # Expected output tree: None assert pruned_tree_list == [] def test_prune_tree_mixed_values(): # Construct the tree # 1 # / # 0 0 # / # 1 0 root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(0) root.left.left = TreeNode(1) root.left.right = TreeNode(0) pruned_tree = pruneTree(root) pruned_tree_list = tree_to_list(pruned_tree) # Expected output tree: # 1 # / # 0 # / # 1 expected_tree = TreeNode(1) expected_tree.left = TreeNode(0) expected_tree.left.left = TreeNode(1) expected_tree_list = tree_to_list(expected_tree) assert pruned_tree_list == expected_tree_list def test_prune_tree_single_node(): # Construct the tree # 0 root = TreeNode(0) pruned_tree = pruneTree(root) pruned_tree_list = tree_to_list(pruned_tree) # Expected output tree: None assert pruned_tree_list == [] # Construct the tree # 1 root = TreeNode(1) pruned_tree = pruneTree(root) pruned_tree_list = tree_to_list(pruned_tree) # Expected output tree: [1] assert pruned_tree_list == [1]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root: TreeNode) -> TreeNode: Prunes the binary tree such that every subtree not containing a 1 is removed. :param root: TreeNode :return: TreeNode if not root: return None # Recursively prune the left and right subtrees root.left = pruneTree(root.left) root.right = pruneTree(root.right) # If the current node is 0 and both of its subtrees are None, then it should be pruned (return None) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"def min_rooms_required(interviews: List[Tuple[int, int, str]]) -> int: Determine the minimum number of rooms required to conduct all interviews without conflicts within the same panel. :param interviews: List of tuples (start, end, panel) indicating the start time, end time, and panel of each interview. :return: Minimum number of rooms required. >>> min_rooms_required([(900, 1000, 'Panel1'), (1100, 1200, 'Panel1'), (1300, 1400, 'Panel1')]) 1 >>> min_rooms_required([(900, 1000, 'Panel1'), (930, 1030, 'Panel1'), (1000, 1100, 'Panel1')]) 2 >>> min_rooms_required([(900, 1000, 'Panel1'), (1100, 1200, 'Panel1'), (900, 1000, 'Panel2'), (1100, 1200, 'Panel2')]) 1 >>> min_rooms_required([(900, 1000, 'Panel1'), (930, 1030, 'Panel1'), (900, 1000, 'Panel2'), (930, 1030, 'Panel2')]) 2","solution":"def min_rooms_required(interviews): Determine the minimum number of rooms required to conduct all interviews without conflicts within the same panel. :param interviews: List of tuples (start, end, panel) indicating the start time, end time, and panel of each interview. :return: Minimum number of rooms required. from collections import defaultdict import heapq # Separate the interviews by panel panels = defaultdict(list) for start, end, panel in interviews: panels[panel].append((start, end)) max_rooms = 0 # Process each panel separately for panel in panels: events = [] for start, end in panels[panel]: events.append((start, 1)) # start time indicates +1 room events.append((end, -1)) # end time indicates -1 room events.sort() # Sort events by time, with start times processed before end times at the same time current_rooms = 0 for _, event in events: current_rooms += event max_rooms = max(max_rooms, current_rooms) return max_rooms"},{"question":"def longest_anagram_of_palindrome_substring(s: str) -> int: Returns the length of the longest substring of \`s\` that is an anagram of a palindrome. >>> longest_anagram_of_palindrome_substring(\\"abccccdd\\") == 7 >>> longest_anagram_of_palindrome_substring(\\"aabbcc\\") == 6 >>> longest_anagram_of_palindrome_substring(\\"aabc\\") == 3 >>> longest_anagram_of_palindrome_substring(\\"abc\\") == 1 >>> longest_anagram_of_palindrome_substring(\\"abcaacb\\") == 7 >>> longest_anagram_of_palindrome_substring(\\"a\\") == 1 >>> longest_anagram_of_palindrome_substring(\\"aa\\") == 2 >>> longest_anagram_of_palindrome_substring(\\"ab\\") == 1 >>> longest_anagram_of_palindrome_substring(\\"\\") == 0 >>> longest_anagram_of_palindrome_substring(\\"racecar\\") == 7 >>> longest_anagram_of_palindrome_substring(\\"madam\\") == 5","solution":"def longest_anagram_of_palindrome_substring(s): Returns the length of the longest substring of \`s\` that is an anagram of a palindrome. def is_anagram_of_palindrome(sub): count = {} for char in sub: count[char] = count.get(char, 0) + 1 odd_count = 0 for c in count.values(): if c % 2 != 0: odd_count += 1 if odd_count > 1: return False return True n = len(s) max_len = 0 for i in range(n): for j in range(i, n): if is_anagram_of_palindrome(s[i:j+1]): max_len = max(max_len, j - i + 1) return max_len"},{"question":"def max_tasks_within_limit(tasks, x): Return the maximum number of tasks that can be completed consecutively within x minutes. >>> max_tasks_within_limit([5, 10, 15], 30) 3 >>> max_tasks_within_limit([10, 20, 30], 5) 0 >>> max_tasks_within_limit([5, 10, 20, 5], 15) 2 >>> max_tasks_within_limit([8], 10) 1 >>> max_tasks_within_limit([12], 10) 0 >>> max_tasks_within_limit([1, 2, 3, 4, 5], 9) 3 >>> max_tasks_within_limit([5, 5, 5, 5], 15) 3","solution":"def max_tasks_within_limit(tasks, x): Return the maximum number of tasks that can be completed consecutively within x minutes. max_tasks = 0 n = len(tasks) for i in range(n): total_time = 0 current_tasks = 0 for j in range(i, n): total_time += tasks[j] if total_time > x: break current_tasks += 1 max_tasks = max(max_tasks, current_tasks) return max_tasks"},{"question":"def num_islands(grid: List[List[str]]) -> int: You are given a 2D grid representing a map where each cell is either '1' (land) or '0' (water). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write a function that returns the number of islands. The function should explore all four directions around each piece of land and mark it as visited. Consider using Depth-First Search (DFS) for this purpose. >>> num_islands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 3 >>> num_islands([ ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ... ]) 1 >>> num_islands([ ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ... ]) 0 >>> num_islands([]) == 0 >>> num_islands([ ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 4","solution":"def num_islands(grid): if not grid: return 0 def dfs(grid, r, c): nr = len(grid) nc = len(grid[0]) if r < 0 or c < 0 or r >= nr or c >= nc or grid[r][c] == '0': return grid[r][c] = '0' # Mark as visited # Explore in all directions directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(grid, r + dr, c + dc) num_islands = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1': num_islands += 1 dfs(grid, r, c) return num_islands"},{"question":"from typing import List def invalid_transactions(transactions: List[str]) -> List[str]: Identify invalid transactions based on the given conditions. Args: transactions (list of str): List of transactions where each transaction is represented by a string in the format \\"name,time,amount,city\\". Returns: list of str: List of invalid transactions in the order they appear in the input list. >>> invalid_transactions([\\"alice,20,1200,montreal\\", \\"bob,50,1000,toronto\\"]) [\\"alice,20,1200,montreal\\"] >>> invalid_transactions([\\"alice,20,800,newyork\\", \\"alice,50,1000,chicago\\"]) [\\"alice,20,800,newyork\\", \\"alice,50,1000,chicago\\"] >>> invalid_transactions([\\"alice,20,1200,montreal\\", \\"alice,50,800,toronto\\", \\"bob,60,1000,nyc\\", \\"bob,10,80,nyc\\"]) [\\"alice,20,1200,montreal\\"] >>> invalid_transactions([]) []","solution":"def invalid_transactions(transactions): Identify invalid transactions based on the given conditions. Args: transactions (list of str): List of transactions where each transaction is represented by a string in the format \\"name,time,amount,city\\". Returns: list of str: List of invalid transactions in the order they appear in the input list. n = len(transactions) invalid = [] trans_info = [] for i in range(n): name, time, amount, city = transactions[i].split(',') trans_info.append((name, int(time), int(amount), city, transactions[i])) # Check conditions for each transaction for i in range(n): name1, time1, amount1, city1, raw1 = trans_info[i] if amount1 > 1000: invalid.append(raw1) continue for j in range(n): if i != j: name2, time2, amount2, city2, raw2 = trans_info[j] if name1 == name2 and abs(time1 - time2) <= 60 and city1 != city2: invalid.append(raw1) break return invalid"},{"question":"def last_remaining_element(nums: List[int]) -> int: Given a list of integers \`nums\`, perform a sequence of operations on the list: 1. Choose any two elements \`x\` and \`y\` from the list. 2. Remove them and append the absolute difference \`|x - y|\` to the list. Repeat until only one element remains in the list. Return the value of this last remaining element. If the list initially has no elements, return \`0\`. >>> last_remaining_element([5]) 5 >>> last_remaining_element([]) 0 >>> last_remaining_element([3, 3]) 0 >>> last_remaining_element([7, 4]) 3 >>> last_remaining_element([2, 7, 4, 1, 8, 1]) 1 >>> last_remaining_element([100, 200, 150]) 50 >>> last_remaining_element([0, 0, 0, 0]) 0","solution":"def last_remaining_element(nums): Given a list of integers \`nums\`, perform a sequence of operations on the list: 1. Choose any two elements \`x\` and \`y\` from the list. 2. Remove them and append the absolute difference \`|x - y|\` to the list. Repeat until only one element remains in the list. Return the value of this last remaining element. If the list initially has no elements, return \`0\`. :param nums: List of integers :return: The last remaining element. if not nums: return 0 import heapq nums = [-num for num in nums] heapq.heapify(nums) while len(nums) > 1: x = -heapq.heappop(nums) y = -heapq.heappop(nums) if x != y: heapq.heappush(nums, -(abs(x - y))) return -nums[0] if nums else 0"},{"question":"from typing import List def canCross(nums: List[int]) -> bool: Determine if the frog can cross the river and reach the last stone following the given rules. >>> canCross([0,1,3,5,6,8,12,17]) True >>> canCross([0]) True >>> canCross([0,1,2,3,4,8,9,11]) False >>> canCross([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]) True >>> canCross([0,1,3,4,5,7,9,10,12]) True >>> canCross([0,1,3,6,7,8,10,12,13,14]) True","solution":"from typing import List def canCross(nums: List[int]) -> bool: # Using a dictionary to store positions and the successful jumps that led there stone_positions = {stone: set() for stone in nums} stone_positions[nums[0]].add(0) # initial position with a jump of '0' for stone in nums: for jump in stone_positions[stone]: for step in {jump-1, jump, jump+1}: if step > 0 and stone + step in stone_positions: stone_positions[stone + step].add(step) return bool(stone_positions[nums[-1]])"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Return the minimum number of operations needed to transform s into t. If it is impossible, return -1. >>> min_operations_to_transform(\\"ab\\", \\"ba\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"bca\\") 2 >>> min_operations_to_transform(\\"aabbcc\\", \\"ccbbaa\\") 4 >>> min_operations_to_transform(\\"abc\\", \\"def\\") -1 >>> min_operations_to_transform(\\"a\\", \\"aa\\") -1 >>> min_operations_to_transform(\\"abc\\", \\"abcd\\") -1 >>> min_operations_to_transform(\\"a\\", \\"a\\") 0 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"\\", \\"\\") 0 >>> min_operations_to_transform(\\"a\\", \\"\\") -1 >>> min_operations_to_transform(\\"\\", \\"a\\") -1","solution":"def min_operations_to_transform(s, t): Return the minimum number of operations needed to transform s into t. If it is impossible, return -1. # If the sorted strings are not equal, it's impossible to transform s into t if sorted(s) != sorted(t): return -1 # Initialize indices for s and t i = len(s) - 1 j = len(t) - 1 # Initialize the number of operations to 0 operations = 0 # Traverse both strings from the end to the beginning while i >= 0: if s[i] == t[j]: # If the characters are the same, move j to the left j -= 1 else: # If characters are not same, increment operations count operations += 1 # Move i to the left i -= 1 return operations"},{"question":"from typing import List def findCheapestPrice(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: Finds the cheapest price from \`src\` to \`dst\` with at most \`k\` stops. Parameters: n (int): Number of cities flights (List[List[int]]): List of flights where each flight is represented as [ai, bi, costi] src (int): Starting city dst (int): Destination city k (int): Maximum number of stops allowed Returns: int: Minimum cost to travel from \`src\` to \`dst\` with at most \`k\` stops. If no such route exists, returns -1. Examples: >>> findCheapestPrice(3, [], 0, 2, 1) -1 >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1) 200 >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100]], 0, 2, 0) -1 >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 2) 200 >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [2, 0, 100]], 0, 2, 0) -1 >>> findCheapestPrice(4, [[0, 1, 100], [1, 2, 100], [0, 2, 500], [2, 3, 100], [1, 3, 600]], 0, 3, 2) 300 >>> findCheapestPrice(1, [], 0, 0, 0) 0","solution":"import heapq from collections import defaultdict, deque def findCheapestPrice(n, flights, src, dst, k): Finds the cheapest price from src to dst with at most k stops. Parameters: n (int): Number of cities flights (List[List[int]]): List of flights where each flight is represented as [ai, bi, costi] src (int): Starting city dst (int): Destination city k (int): Maximum number of stops allowed Returns: int: Minimum cost to travel from src to dst with at most k stops. If no such route exists, returns -1. # Create an adjacency list graph = defaultdict(list) for start, end, cost in flights: graph[start].append((end, cost)) # Min-heap to store (cost, current_city, stops) heap = [(0, src, 0)] # costs dictionary that stores the minimum cost to reach a city with a certain number of stops costs = defaultdict(lambda: float('inf')) costs[(src, 0)] = 0 while heap: current_cost, current_city, stops = heapq.heappop(heap) # If we reach the destination city if current_city == dst: return current_cost # If we have stops available if stops <= k: for next_city, next_cost in graph[current_city]: new_cost = current_cost + next_cost if new_cost < costs[(next_city, stops + 1)]: costs[(next_city, stops + 1)] = new_cost heapq.heappush(heap, (new_cost, next_city, stops + 1)) return -1"},{"question":"def ladderLength(beginWord: str, endWord: str, wordList: List[str]) -> int: Returns the length of the shortest transformation sequence from beginWord to endWord. Returns 0 if no such transformation sequence exists. Args: beginWord (str): The word to start from. endWord (str): The word to end at. wordList (List[str]): The list of allowed words for transformation. Returns: int: The length of the shortest transformation sequence from beginWord to endWord. >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) 5 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) 0 >>> ladderLength(\\"hit\\", \\"hot\\", [\\"hot\\"]) 2 >>> ladderLength(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) 2 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"dots\\",\\"dots\\",\\"dags\\",\\"logs\\",\\"logs\\",\\"cogs\\"]) 0","solution":"from collections import deque def ladderLength(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord if endWord not in wordList or not endWord or not beginWord or not wordList: return 0 L = len(beginWord) all_combo_dict = {} for word in wordList: for i in range(L): new_word = word[:i] + \\"*\\" + word[i+1:] if new_word not in all_combo_dict: all_combo_dict[new_word] = [word] else: all_combo_dict[new_word].append(word) queue = deque([(beginWord, 1)]) visited = {beginWord: True} while queue: current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \\"*\\" + current_word[i+1:] for word in all_combo_dict.get(intermediate_word, []): if word == endWord: return level + 1 if word not in visited: visited[word] = True queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] return 0"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def second_to_last(head): Returns the value of the second to last node in the linked list. If the linked list has fewer than two nodes, returns -1. from solution import ListNode, second_to_last def test_second_to_last_normal(): # List: 1 -> 2 -> 3 head = ListNode(1, ListNode(2, ListNode(3))) assert second_to_last(head) == 2 def test_second_to_last_single_node(): # List: 1 head = ListNode(1) assert second_to_last(head) == -1 def test_second_to_last_two_nodes(): # List: 1 -> 2 head = ListNode(1, ListNode(2)) assert second_to_last(head) == 1 def test_second_to_last_long_list(): # List: 1 -> 2 -> 3 -> 4 -> 5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) assert second_to_last(head) == 4 def test_second_to_last_repeated_values(): # List: 1 -> 1 -> 1 -> 1 head = ListNode(1, ListNode(1, ListNode(1, ListNode(1)))) assert second_to_last(head) == 1","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def second_to_last(head): Returns the value of the second to last node in the linked list. If the linked list has fewer than two nodes, returns -1. if not head or not head.next: return -1 current = head while current.next.next: current = current.next return current.value"},{"question":"from typing import List def add_operators(num: str, target: int) -> List[str]: Write a function that takes a string containing digits from '0' to '9' and a target value. The function should return all possible ways to add the binary operators '+', '-', and/or '*' between the digits so they evaluate to the target value. >>> add_operators(\\"123\\", 6) == [\\"1+2+3\\", \\"1*2*3\\"] >>> add_operators(\\"232\\", 8) == [\\"2*3+2\\", \\"2+3*2\\"] >>> add_operators(\\"105\\", 5) == [\\"1*0+5\\", \\"10-5\\"] >>> add_operators(\\"00\\", 0) == [\\"0+0\\", \\"0-0\\", \\"0*0\\"] pass","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def backtrack(index, path, value, last): if index == len(num): if value == target: result.append(path) return for i in range(index, len(num)): temp_str = num[index:i+1] temp_val = int(temp_str) if i != index and num[index] == '0': break if index == 0: backtrack(i + 1, temp_str, temp_val, temp_val) else: backtrack(i + 1, path + '+' + temp_str, value + temp_val, temp_val) backtrack(i + 1, path + '-' + temp_str, value - temp_val, -temp_val) backtrack(i + 1, path + '*' + temp_str, value - last + last * temp_val, last * temp_val) result = [] backtrack(0, \\"\\", 0, 0) return result"},{"question":"from typing import List def min_difference_partition(arr: List[int]) -> int: Given an array of integers \`arr\` consisting of \`n\` elements, where \`n\` is even, divide the array into two subsets of \`equal size\` such that the sum of the elements in both subsets is as close as possible. Return the absolute difference between the sums of the two subsets after the division. >>> min_difference_partition([1, 2, 3, 4]) 0 >>> min_difference_partition([1, 6, 11, 5]) 1","solution":"from itertools import combinations def min_difference_partition(arr): n = len(arr) half_n = n // 2 total_sum = sum(arr) target = total_sum // 2 def get_combinations_closest_sum(): best_comb_sum = float('inf') best_comb_diff = float('inf') for comb in combinations(arr, half_n): comb_sum = sum(comb) comb_diff = abs((total_sum - comb_sum) - comb_sum) if comb_diff < best_comb_diff: best_comb_sum = comb_sum best_comb_diff = comb_diff return best_comb_sum half_sum = get_combinations_closest_sum() other_half_sum = total_sum - half_sum return abs(half_sum - other_half_sum)"},{"question":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def preorder_traversal(root): Perform a preorder traversal of an n-ary tree. :param root: Root node of the n-ary tree :return: List of integers representing the values of the nodes in preorder traversal >>> root = Node(1) >>> preorder_traversal(root) [1] >>> root = Node(1, [Node(2), Node(3)]) >>> preorder_traversal(root) [1, 2, 3] >>> root = Node(1, [Node(2, [Node(5), Node(6)]), Node(3), Node(4)]) >>> preorder_traversal(root) [1, 2, 5, 6, 3, 4] >>> preorder_traversal(None) [] >>> root = Node(1, [Node(2), Node(3, [Node(6), Node(7, [Node(8)])]), Node(4, [Node(9), Node(10)]), Node(5)]) >>> preorder_traversal(root) [1, 2, 3, 6, 7, 8, 4, 9, 10, 5]","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def preorder_traversal(root): Perform a preorder traversal of an n-ary tree. :param root: Root node of the n-ary tree :return: List of integers representing the values of the nodes in preorder traversal if root is None: return [] result = [] def traverse(node): if node: result.append(node.val) for child in node.children: traverse(child) traverse(root) return result"},{"question":"def max_staircase_students(heights: List[int]) -> int: Returns the maximum number of students that can form a \\"staircase\\". A \\"staircase\\" means every next student is taller than the previous one. :param heights: List[int] - List of students' heights. :return: int - Maximum number of students to form a \\"staircase\\". >>> max_staircase_students([]) 0 >>> max_staircase_students([1]) 1 >>> max_staircase_students([1, 2, 3, 4, 5]) 5 >>> max_staircase_students([5, 4, 3, 2, 1]) 1 >>> max_staircase_students([1, 3, 2, 5, 4, 6]) 4 >>> max_staircase_students([10, 1, 2, 11, 3, 4]) 4 >>> max_staircase_students([1, 2, 2, 3, 3, 4]) 4","solution":"def max_staircase_students(heights): Returns the maximum number of students that can form a \\"staircase\\". A \\"staircase\\" means every next student is taller than the previous one. :param heights: List[int] - List of students' heights. :return: int - Maximum number of students to form a \\"staircase\\". if not heights: return 0 n = len(heights) dp = [1] * n # dp[i] will be the length of staircase ending with heights[i] for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def calculate(s: str) -> int: Given a string s representing an arithmetic expression containing just integers and the operators '+', '-', '*', and '/', evaluate it and return the result as an integer. The integer division should truncate towards zero. >>> calculate(\\"3+2*2\\") 7 >>> calculate(\\" 3/2 \\") 1 >>> calculate(\\" 3+5 / 2 \\") 5","solution":"def calculate(s): def evaluate_expression(tokens): stack = [] current_number = 0 current_operator = '+' for token in tokens + ['+']: if token.isdigit(): current_number = current_number * 10 + int(token) elif token in '+-*/': if current_operator == '+': stack.append(current_number) elif current_operator == '-': stack.append(-current_number) elif current_operator == '*': stack[-1] = stack[-1] * current_number elif current_operator == '/': stack[-1] = int(stack[-1] / current_number) current_operator = token current_number = 0 return sum(stack) tokens = list(s.replace(' ', '')) return evaluate_expression(tokens)"},{"question":"def unobstructed_buildings(heights: List[int]) -> List[int]: Returns the list of indices of unobstructed buildings in ascending order. >>> unobstructed_buildings([4, 2, 3, 1]) [0, 2, 3] >>> unobstructed_buildings([1, 1, 1, 1]) [0, 1, 2, 3] >>> unobstructed_buildings([1, 2, 3, 4]) [3] >>> unobstructed_buildings([4, 3, 2, 1]) [0, 1, 2, 3] >>> unobstructed_buildings([10]) [0] >>> unobstructed_buildings([3, 0, 2, 0, 1]) [0, 2, 4] >>> unobstructed_buildings([]) [] pass","solution":"def unobstructed_buildings(heights): Returns the list of indices of unobstructed buildings in ascending order. n = len(heights) unobstructed = [] max_height = float('-inf') for i in range(n - 1, -1, -1): if heights[i] >= max_height: unobstructed.append(i) max_height = heights[i] return unobstructed[::-1] # return in ascending order"},{"question":"def min_steps_to_goal(grid: List[List[str]]) -> int: Returns the minimum number of steps required to reach the goal 'G' from the starting position 'S' in a 2D grid. If the goal cannot be reached, return -1. >>> min_steps_to_goal([ ... ['S', '.', '.', 'G'], ... ['#', '#', '#', '.'], ... ['.', '.', '.', '.'] ... ]) == 3 >>> min_steps_to_goal([ ... ['S', '#', '.', 'G'], ... ['#', '#', '#', '#'], ... ['#', '#', '#', '#'] ... ]) == -1 >>> min_steps_to_goal([ ... ['S', '.', 'G'] ... ]) == 2 >>> min_steps_to_goal([ ... ['.', '.', '.', 'G'], ... ['.', '#', '#', '.'], ... ['.', '.', '.', '.'] ... ]) == -1 >>> min_steps_to_goal([ ... ['S', '.', '.', '.'], ... ['#', '#', '#', '.'], ... ['.', '.', '.', '.'] ... ]) == -1","solution":"from collections import deque def min_steps_to_goal(grid): Returns the minimum number of steps required to reach the goal 'G' from the starting position 'S' in a 2D grid. If the goal cannot be reached, return -1. rows = len(grid) columns = len(grid[0]) # Directions array for movement (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find the starting position 'S' start = None for i in range(rows): for j in range(columns): if grid[i][j] == 'S': start = (i, j) break if start: break if not start: return -1 # No start position found # BFS to find the shortest path from 'S' to 'G' queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set() visited.add(start) while queue: x, y, steps = queue.popleft() if grid[x][y] == 'G': return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < columns and (nx, ny) not in visited and grid[nx][ny] != '#': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1 # Goal not reachable"},{"question":"def can_flow_to_both_lakes(grid: List[List[int]]) -> bool: Determine if there exists a path that allows water to flow from Lake A (top-left corner) to Lake B (bottom-right corner) in the given grid. Water can only flow from a cell to a lower or equal height cell, and can move in all four cardinal directions (left, right, up, down). Parameters: grid (List[List[int]]): 2D grid of positive integers representing the height of the terrain. Returns: bool: True if there exists a path that allows water to flow from Lake A to Lake B, False otherwise. >>> can_flow_to_both_lakes([ [1, 2, 2], [3, 1, 2], [4, 3, 3] ]) == True >>> can_flow_to_both_lakes([ [1, 2, 6], [5, 3, 7], [8, 6, 4] ]) == False","solution":"def can_flow_to_both_lakes(grid): if not grid: return False n = len(grid) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x, y, visited): stack = [(x, y)] visited.add((x, y)) while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] <= grid[cx][cy]: visited.add((nx, ny)) stack.append((nx, ny)) visited_from_a = set() visited_from_b = set() dfs(0, 0, visited_from_a) dfs(n - 1, n - 1, visited_from_b) # If there's any common cell in both visited sets, there is a path return len(visited_from_a & visited_from_b) > 0"},{"question":"def four_sum_count(arr: List[int], target: int) -> int: Returns the number of unique tuples (i, j, k, l) such that arr[i] + arr[j] + arr[k] + arr[l] == target and 0 <= i < j < k < l < len(arr). >>> four_sum_count([1, 0, -1, 0, -2, 2], 0) 3 >>> four_sum_count([1, 2, 3, 4], 100) 0 >>> four_sum_count([1, 2, 3, -6, 0], -1) 1 >>> four_sum_count([0, 0, 0, 0, 0], 0) 5 >>> four_sum_count([10**6, 10**6, -10**6, -10**6, 0], 0) 1","solution":"def four_sum_count(arr, target): Returns the number of unique tuples (i, j, k, l) such that arr[i] + arr[j] + arr[k] + arr[l] == target and 0 <= i < j < k < l < len(arr). from itertools import combinations n = len(arr) count = 0 # Generate all combinations of 4 indices for i, j, k, l in combinations(range(n), 4): if arr[i] + arr[j] + arr[k] + arr[l] == target: count += 1 return count"},{"question":"def count_sunset_buildings(heights: List[int]) -> int: Returns the count of buildings that have an unobstructed view of the sunset. A building has an unobstructed view if there are no taller buildings to its right. >>> count_sunset_buildings([1, 2, 3, 4, 5]) 1 >>> count_sunset_buildings([5, 4, 3, 2, 1]) 5 >>> count_sunset_buildings([4, 2, 3, 1]) 3","solution":"def count_sunset_buildings(heights): Returns the count of buildings that have an unobstructed view of the sunset. A building has an unobstructed view if there are no taller buildings to its right. count = 0 max_height = 0 # Traverse the list from right to left for height in reversed(heights): if height > max_height: count += 1 max_height = height return count"},{"question":"def reconstruct_sentence(words: List[str], positions: List[int]) -> str: Reconstructs the original sentence from the given words and their positions. Args: words: List of words to be arranged. positions: List of integers indicating the initial index of each word. Returns: A single string with words arranged in the correct order separated by a single space. >>> reconstruct_sentence([\\"hello\\"], [0]) 'hello' >>> reconstruct_sentence([\\"world\\", \\"hello\\"], [1, 0]) 'hello world' >>> reconstruct_sentence([\\"is\\", \\"test\\", \\"a\\", \\"this\\"], [3, 2, 1, 0]) 'this a test is' >>> reconstruct_sentence([\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\"], [0, 1, 2, 3]) 'the quick brown fox' >>> reconstruct_sentence([\\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\"], [4, 2, 0, 1, 3]) 'the lazy over dog jumps'","solution":"def reconstruct_sentence(words, positions): Reconstructs the original sentence from the given words and their positions. Args: words: List of words to be arranged. positions: List of integers indicating the initial index of each word. Returns: A single string with words arranged in the correct order separated by a single space. # Create a list of the correct size filled with empty strings sentence = [\\"\\"] * len(words) # Place each word in its correct position for word, position in zip(words, positions): sentence[position] = word # Join the list into a single string with words separated by spaces return \\" \\".join(sentence)"},{"question":"from typing import List def find_course_order(num_courses: int, prerequisites: List[List[int]]) -> List[int]: Returns the order in which to take courses to satisfy all prerequisites. Parameters: num_courses (int): Total number of courses. prerequisites (list): List of prerequisite pairs Returns: list: Ordered list of courses >>> find_course_order(2, [[1, 0]]) [0, 1] >>> find_course_order(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) in ([0, 1, 2, 3], [0, 2, 1, 3]) True >>> find_course_order(3, []) [0, 1, 2] >>> find_course_order(1, []) [0] >>> find_course_order(3, [[1, 0], [2, 1]]) [0, 1, 2]","solution":"from collections import deque, defaultdict def find_course_order(num_courses, prerequisites): Returns the order in which to take courses to satisfy all prerequisites. Parameters: num_courses (int): Total number of courses. prerequisites (list): List of prerequisite pairs Returns: list: Ordered list of courses # Create an adjacency list representation of the graph adj_list = defaultdict(list) in_degree = [0] * num_courses for course, prereq in prerequisites: adj_list[prereq].append(course) in_degree[course] += 1 # Initialize a queue with all courses having zero in-degrees queue = deque([course for course in range(num_courses) if in_degree[course] == 0]) order = [] while queue: current_course = queue.popleft() order.append(current_course) for next_course in adj_list[current_course]: in_degree[next_course] -= 1 if in_degree[next_course] == 0: queue.append(next_course) return order"},{"question":"def reverse_words_in_string(s: str) -> str: Given a string \`s\` containing one or more words, transform it such that each word is reversed but the order of words remains the same. A word is defined as a sequence of non-space characters, separated by spaces. The function should return the transformed string with spacing preserved as in the original string. >>> reverse_words_in_string(\\"the sky is blue\\") == \\"eht yks si eulb\\" >>> reverse_words_in_string(\\"hello\\") == \\"olleh\\" >>> reverse_words_in_string(\\"double spaces\\") == \\"elbuod secaps\\" >>> reverse_words_in_string(\\"hello, world!\\") == \\",olleh !dlrow\\" >>> reverse_words_in_string(\\"\\") == \\"\\" >>> reverse_words_in_string(\\" hello world \\") == \\" olleh dlrow \\" # Your code here","solution":"def reverse_words_in_string(s): Returns a transformed string such that each word in the input string is reversed but the order of words remains the same. return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"def are_islands_connected(grid, loc1, loc2): Returns true if two islands are connected, false otherwise. :param grid: List[List[str]]: The 2D grid map of '1's and '0's. :param loc1: Tuple[int, int]: First location (row, col) of the first island. :param loc2: Tuple[int, int]: Second location (row, col) of the second island. >>> are_islands_connected([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '1', '1'], ['0', '0', '0', '1', '1'], ['0', '1', '1', '0', '0'], ['0', '0', '0', '0', '0']], (1, 1), (1, 4)) == False >>> are_islands_connected([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '1', '1'], ['0', '0', '0', '1', '1'], ['0', '1', '1', '0', '0'], ['0', '0', '0', '0', '0']], (0, 1), (2, 3)) == False >>> are_islands_connected([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '1', '1'], ['0', '0', '0', '1', '1'], ['0', '1', '1', '0', '0'], ['0', '0', '0', '0', '0']], (3, 1), (3, 2)) == True >>> are_islands_connected([], (0, 0), (0, 0)) == False >>> are_islands_connected([['1']], (0, 0), (0, 0)) == True >>> are_islands_connected([['0']], (0, 0), (0, 0)) == False","solution":"def are_islands_connected(grid, loc1, loc2): Returns true if two islands are connected, false otherwise. :param grid: List[List[str]]: The 2D grid map of '1's and '0's. :param loc1: Tuple[int, int]: First location (row, col) of the first island. :param loc2: Tuple[int, int]: Second location (row, col) of the second island. if not grid or not grid[0]: return False n, m = len(grid), len(grid[0]) def dfs(x, y, visited): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '0' or (x, y) in visited: return visited.add((x, y)) # explore all 4-connected neighbors for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, visited) visited = set() dfs(loc1[0], loc1[1], visited) return loc2 in visited"},{"question":"def min_moves_to_equal_elements(nums: List[int]) -> int: Returns the minimum number of moves required to make all elements of the array equal. In one move, you can increment or decrement an element of the array by 1. The optimal choice is to make all elements equal to the median. >>> min_moves_to_equal_elements([1, 1, 1]) == 0 >>> min_moves_to_equal_elements([1, 2, 3]) == 2 >>> min_moves_to_equal_elements([-1, 0, 1]) == 2 >>> min_moves_to_equal_elements([1, 10, 2, 9]) == 16 >>> min_moves_to_equal_elements([5]) == 0 >>> min_moves_to_equal_elements([1, 2, 2, 3]) == 2","solution":"def min_moves_to_equal_elements(nums): Returns the minimum number of moves required to make all elements of the array equal. In one move, you can increment or decrement an element of the array by 1. The optimal choice is to make all elements equal to the median. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Given a linked list, rotate the list to the right by k places. Return the head of the rotated linked list. >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> new_head = rotateRight(head, 2) >>> result = [] >>> while new_head: ... result.append(new_head.val) ... new_head = new_head.next >>> result [4, 5, 1, 2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or k == 0: return head # Compute the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Make the list circular tail.next = head # Find the new head which is (length - k % length) steps away from the current head k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"def max_difference(grid): Returns the maximum difference in height between any two adjacent cells in the grid. Args: grid (list of list of int): 2D list representing the grid of heights. Returns: int: The maximum difference in height between any two adjacent cells. pass from solution import max_difference def test_single_cell(): assert max_difference([[5]]) == 0 def test_two_adjacent_cells_vertical(): assert max_difference([[3], [9]]) == 6 def test_two_adjacent_cells_horizontal(): assert max_difference([[3, 10]]) == 7 def test_larger_grid(): assert max_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 3 def test_complex_grid(): assert max_difference([[8, 1, 6], [3, 5, 7], [4, 9, 0]]) == 9 def test_different_row_col_numbers(): assert max_difference([[1, 3, 6], [4, 8, 5]]) == 5 def test_grid_with_equal_values(): assert max_difference([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 0","solution":"def max_difference(grid): Returns the maximum difference in height between any two adjacent cells in the grid. Args: grid (list of list of int): 2D list representing the grid of heights. Returns: int: The maximum difference in height between any two adjacent cells. rows = len(grid) cols = len(grid[0]) max_diff = 0 for i in range(rows): for j in range(cols): # Check right neighbor if j + 1 < cols: max_diff = max(max_diff, abs(grid[i][j] - grid[i][j + 1])) # Check bottom neighbor if i + 1 < rows: max_diff = max(max_diff, abs(grid[i][j] - grid[i + 1][j])) return max_diff"},{"question":"def distinct_characters_in_substrings(s: str, queries: List[List[int]]) -> List[int]: Given a string \`s\` and a list of queries, this function returns the number of distinct characters in the substring \`s[lefti...righti]\` for each query. Args: s (str): The input string consisting of lowercase English letters. queries (List[List[int]]): A list of queries, where each query is a list [lefti, righti]. Returns: List[int]: A list containing the number of distinct characters for each query. Examples: >>> distinct_characters_in_substrings(\\"abcde\\", [[0, 0], [1, 1], [2, 2]]) [1, 1, 1] >>> distinct_characters_in_substrings(\\"abcde\\", [[0, 4]]) [5] >>> distinct_characters_in_substrings(\\"aabbccddeeff\\", [[0, 1], [0, 3], [1, 5], [4, 7]]) [1, 2, 3, 2] >>> distinct_characters_in_substrings(\\"abcdefgh\\", [[1, 3], [2, 5], [5, 7]]) [3, 4, 3] >>> distinct_characters_in_substrings(\\"xyzxyzxyz\\", [[0, 8], [0, 2], [3, 5], [6, 8]]) [3, 3, 3, 3]","solution":"def distinct_characters_in_substrings(s, queries): Given a string \`s\` and a list of queries, this function returns the number of distinct characters in the substring \`s[lefti...righti]\` for each query. Args: s (str): The input string consisting of lowercase English letters. queries (List[List[int]]): A list of queries, where each query is a list [lefti, righti]. Returns: List[int]: A list containing the number of distinct characters for each query. result = [] for left, right in queries: substring = s[left:right+1] distinct_chars = set(substring) result.append(len(distinct_chars)) return result"},{"question":"from typing import List, Optional, Tuple class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None def create_tree_node(data: List[Tuple[int, Optional[int], Optional[int]]]) -> Optional[TreeNode]: Create a binary tree from a list of tuples. >>> data = [(2, 1, 3), (1, None, None), (3, None, None)] >>> root = create_tree_node(data) >>> root.val 2 >>> root.left.val 1 >>> root.right.val 3 pass def is_valid_bst(root: Optional[TreeNode]) -> bool: Determine if the binary tree is a valid binary search tree (BST). >>> data = [(2, 1, 3), (1, None, None), (3, None, None)] >>> root = create_tree_node(data) >>> is_valid_bst(root) True >>> data = [(5, 1, 4), (1, None, None), (4, 3, 6)] >>> root = create_tree_node(data) >>> is_valid_bst(root) False pass","solution":"from typing import List, Optional, Tuple class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None def create_tree_node(data: List[Tuple[int, Optional[int], Optional[int]]]) -> Optional[TreeNode]: if not data: return None nodes = {val: TreeNode(val) for val, _, _ in data} for val, left, right in data: if left is not None: nodes[val].left = nodes[left] if right is not None: nodes[val].right = nodes[right] return nodes[data[0][0]] def is_valid_bst(root: Optional[TreeNode]) -> bool: def helper(node: Optional[TreeNode], low: float, high: float) -> bool: if not node: return True if not (low < node.val < high): return False return helper(node.left, low, node.val) and helper(node.right, node.val, high) return helper(root, float('-inf'), float('inf'))"},{"question":"class MaxStack: Design a class that represents a Last In First Out (LIFO) stack with an additional operation \`getMax()\`. Implement the \`MaxStack\` class: * \`MaxStack()\` - Initializes the stack. * \`void push(int val)\` - Pushes the element \`val\` onto the stack. * \`int pop()\` - Removes and returns the element on the top of the stack. If the stack is empty, return \`-1\`. * \`int top()\` - Returns the element on the top of the stack without removing it. If the stack is empty, return \`-1\`. * \`int getMax()\` - Retrieves the maximum element in the stack. If the stack is empty, return \`-1\`. Example: >>> stack = MaxStack() >>> stack.push(5) >>> stack.getMax() 5 >>> stack.push(1) >>> stack.getMax() 5 >>> stack.push(5) >>> stack.getMax() 5 >>> stack.pop() 5 >>> stack.getMax() 5 >>> stack.pop() 1 >>> stack.getMax() 5 >>> stack.pop() 5 >>> stack.getMax() -1 >>> stack.pop() -1 >>> stack.top() -1 def __init__(self): pass def push(self, val: int) -> None: pass def pop(self) -> int: pass def top(self) -> int: pass def getMax(self) -> int: pass","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.max_stack or val >= self.max_stack[-1]: self.max_stack.append(val) def pop(self) -> int: if not self.stack: return -1 val = self.stack.pop() if val == self.max_stack[-1]: self.max_stack.pop() return val def top(self) -> int: if not self.stack: return -1 return self.stack[-1] def getMax(self) -> int: if not self.max_stack: return -1 return self.max_stack[-1]"},{"question":"def remove_k_characters(s: str, k: int) -> str: Returns the lexicographically smallest string by removing exactly k characters from s. >>> remove_k_characters('abcde', 2) == 'abc' >>> remove_k_characters('bcabc', 1) == 'babc' >>> remove_k_characters('bcabc', 2) == 'abc' >>> remove_k_characters('bcabc', 3) == 'ab' >>> remove_k_characters('a', 0) == 'a' >>> remove_k_characters('a', 1) == '' , >>> remove_k_characters('zyxwvutsrqponmlkjihgfedcba', 25) == 'a' >>> remove_k_characters('aaaaa', 3) == 'aa' >>> remove_k_characters('abcdefgh', 4) == 'abcd' >>> remove_k_characters('randomstring', 12) == ''","solution":"def remove_k_characters(s, k): Returns the lexicographically smallest string by removing exactly k characters from s. stack = [] for char in s: while stack and k > 0 and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still characters to remove while k > 0: stack.pop() k -= 1 return \\"\\".join(stack)"},{"question":"def total_fruit(tree): Returns the maximum number of fruits collected from at most two different types of trees. >>> total_fruit([1, 1, 1, 1]) == 4 >>> total_fruit([1, 2, 1, 2, 1, 2]) == 6 >>> total_fruit([1, 2, 3, 2, 2]) == 4 >>> total_fruit([]) == 0 >>> total_fruit([1, 2, 1, 3, 4]) == 3 >>> total_fruit([1, 2, 2, 3, 4, 4, 4, 4]) == 5 >>> total_fruit([1, 1, 2, 2, 3, 3, 4, 4]) == 4","solution":"def total_fruit(tree): Returns the maximum number of fruits collected from at most two different types of trees. if len(tree) == 0: return 0 max_fruits = 0 fruit_count = {} left = 0 for right in range(len(tree)): if tree[right] in fruit_count: fruit_count[tree[right]] += 1 else: fruit_count[tree[right]] = 1 while len(fruit_count) > 2: fruit_count[tree[left]] -= 1 if fruit_count[tree[left]] == 0: del fruit_count[tree[left]] left += 1 current_fruits = right - left + 1 max_fruits = max(max_fruits, current_fruits) return max_fruits"},{"question":"def longest_subsequence(arr, k): Returns the length of the longest subsequence such that the difference between adjacent elements is less than or equal to k. >>> longest_subsequence([1, 3, 5, 7], 2) == 4 >>> longest_subsequence([1, 3, 9, 15], 5) == 2 >>> longest_subsequence([10], 5) == 1 >>> longest_subsequence([], 5) == 0 >>> longest_subsequence([5, 5, 5], 0) == 3 >>> longest_subsequence([1, 5, 9, 2, 3, 4], 10) == 6 >>> longest_subsequence([1, 100, 200, 300], 50) == 1","solution":"def longest_subsequence(arr, k): Returns the length of the longest subsequence such that the difference between adjacent elements is less than or equal to k. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) <= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def numIslands(grid: List[List[int]]) -> int: Returns the number of islands in the given grid. :param grid: List[List[int]] - 2D binary grid representing the map of '1's (land) and '0's (water). :return: int - the number of islands. >>> numIslands([['1', '1', '0', '0', '0'],['1', '1', '0', '0', '0'],['0', '0', '1', '0', '0'],['0', '0', '0', '1', '1']]) 3 >>> numIslands([['0']]) 0 >>> numIslands([['1']]) 1 >>> numIslands([['1', '1', '1'],['1', '1', '1'],['1', '1', '1']]) 1 >>> numIslands([['0', '0', '0'],['0', '0', '0'],['0', '0', '0']]) 0 >>> numIslands([['1', '0', '0'],['0', '1', '0'],['0', '0', '1']]) 3 >>> numIslands([['1', '1', '1', '0'],['1', '1', '0', '0'],['0', '0', '1', '0'],['0', '0', '0', '1']]) 3","solution":"def numIslands(grid): Returns the number of islands in the given grid. :param grid: List[List[int]] - 2D binary grid representing the map of '1's (land) and '0's (water). :return: int - the number of islands. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == '0': return grid[x][y] = '0' # Mark as visited # Visit all adjacent cells dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) number_of_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': number_of_islands += 1 dfs(i, j) return number_of_islands"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_ancestor_diff(root: TreeNode) -> int: Given a binary tree, find the maximum difference between the value of any node and the value of any ancestor node. The difference is computed as the node value minus the ancestor value. >>> root = TreeNode(8) >>> root.left = TreeNode(3) >>> root.right = TreeNode(10) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(6) >>> root.left.right.left = TreeNode(4) >>> root.left.right.right = TreeNode(7) >>> root.right.right = TreeNode(14) >>> root.right.right.left = TreeNode(13) >>> max_ancestor_diff(root) 7","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_ancestor_diff(root: TreeNode) -> int: def helper(node, cur_min, cur_max): if not node: return cur_max - cur_min cur_min = min(cur_min, node.val) cur_max = max(cur_max, node.val) left_diff = helper(node.left, cur_min, cur_max) right_diff = helper(node.right, cur_min, cur_max) return max(left_diff, right_diff) return helper(root, root.val, root.val)"},{"question":"def min_days_to_equal_heights(heights): Returns the minimum number of days required to make all building heights equal. If it is not possible to make all buildings the same height, returns -1. >>> min_days_to_equal_heights([5, 5, 5, 5]) == 0 >>> min_days_to_equal_heights([3, 4, 5]) == 3 >>> min_days_to_equal_heights([1, 2, 3, 4]) == 6 >>> min_days_to_equal_heights([7]) == 0 >>> min_days_to_equal_heights([-1, 1, 2]) == -1 >>> min_days_to_equal_heights([]) == 0 >>> min_days_to_equal_heights([10**6, 10**6 + 1]) == 1","solution":"def min_days_to_equal_heights(heights): Returns the minimum number of days required to make all building heights equal. If it is not possible to make all buildings the same height, returns -1. if not heights: return 0 max_height = max(heights) min_height = min(heights) # If all buildings already have the same height if max_height == min_height: return 0 total_increase_needed = 0 for height in heights: total_increase_needed += max_height - height unique_heights = set(heights) # Check if it's a valid configuration to make all heights equal # All buildings should be able to reach the max height if len(unique_heights) > 1 and min_height >= 0: return total_increase_needed else: return -1"},{"question":"def max_friends_with_tickets(prices: List[int], ranges: List[Tuple[int, int]]) -> int: Given a list of ticket prices and a list of acceptable price ranges for each friend, this function returns the maximum number of friends that can get a ticket, such that each friend gets exactly one ticket and the ticket price is within their respective range. >>> max_friends_with_tickets([30, 50, 70, 90], [(20, 60), (40, 80), (60, 80), (10, 20)]) 3 >>> max_friends_with_tickets([30, 50, 70, 90], [(100, 150), (110, 180), (120, 200)]) 0 >>> max_friends_with_tickets([30, 50, 70, 90], [(20, 90), (20, 90), (20, 90)]) 3 >>> max_friends_with_tickets([25, 35, 60, 50, 75, 15], [(10, 40), (30, 80), (50, 70), (60, 100), (15, 65)]) 5","solution":"def max_friends_with_tickets(prices, ranges): Given a list of ticket prices and a list of acceptable price ranges for each friend, this function returns the maximum number of friends that can get a ticket, such that each friend gets exactly one ticket and the ticket price is within their respective range. # Sort the prices and ranges prices.sort() ranges.sort(key=lambda x: x[1]) tickets_given = 0 for min_price, max_price in ranges: for i in range(len(prices)): if min_price <= prices[i] <= max_price: tickets_given += 1 prices[i] = float('inf') # Mark this price as used break return tickets_given"},{"question":"def rob(nums: List[int]) -> int: Calculate the maximum amount of money that can be robbed without triggering the alarm. Args: nums (List[int]): List of non-negative integers representing the amount of money of each house. Returns: int: The maximum amount of money that can be robbed. >>> rob([]) 0 >>> rob([5]) 5 >>> rob([1, 2]) 2 >>> rob([1, 2, 3]) 4 >>> rob([2, 7, 9, 3, 1]) 12","solution":"def rob(nums): Calculate the maximum amount of money that can be robbed without triggering the alarm. Args: nums (List[int]): List of non-negative integers representing the amount of money of each house. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 elif len(nums) == 1: return nums[0] n = len(nums) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def find_cheapest_price(n, flights, src, dst, k): Takes the number of airports n, a list of flights where each flight is represented as [origin, destination, price], the source airport src, the destination airport dst, and the number of allowed stops k. Returns the minimum cost to travel from src to dst with at most k stops. If no such route exists, returns -1. >>> flights = [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 3, 500]] >>> find_cheapest_price(4, flights, 0, 3, 1) 500 >>> flights = [[0, 1, 200], [1, 2, 100], [0, 2, 500], [2, 3, 100], [1, 3, 800]] >>> find_cheapest_price(4, flights, 0, 3, 2) 400","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, src, dst, k): Takes the number of airports n, a list of flights where each flight is represented as [origin, destination, price], the source airport src, the destination airport dst, and the number of allowed stops k. Returns the minimum cost to travel from src to dst with at most k stops. If no such route exists, returns -1. # Build graph graph = defaultdict(list) for origin, destination, price in flights: graph[origin].append((destination, price)) # Use priority queue to store (price, node, stops) heap = [(0, src, 0)] # Dictionary to store the minimum distance to each node # considering the number of stops min_price = {} # Implement Dijkstra's-like algorithm with up to k stops while heap: price, node, stops = heapq.heappop(heap) if node == dst: return price if stops > k: continue for neighbor, w in graph[node]: total_price = price + w if (neighbor, stops + 1) not in min_price or total_price < min_price[(neighbor, stops + 1)]: min_price[(neighbor, stops + 1)] = total_price heapq.heappush(heap, (total_price, neighbor, stops + 1)) return -1"},{"question":"def three_sum(arr, target): Given a list of integers arr and an integer target, returns a list of all unique triplets in the array that sum up to the given target. Each triplet is sorted and the output list does not contain duplicate triplets. >>> three_sum([1, 2, 3, 4, 5], 9) [[1, 3, 5], [2, 3, 4]] >>> three_sum([-1, 0, 1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3], 10) [] >>> three_sum([0, 0, 0, 0], 0) [[0, 0, 0]] >>> three_sum([0, -1, 2, -3, 1], 0) [[-3, 1, 2], [-1, 0, 1]] >>> three_sum([1, 1, 1], 3) [[1, 1, 1]] >>> three_sum([10**6, -10**6, 0, 10**6, -10**6, 10**6], 0) [[-1000000, 0, 1000000]]","solution":"def three_sum(arr, target): Given a list of integers arr and an integer target, returns a list of all unique triplets in the array that sum up to the given target. Each triplet is sorted and the output list does not contain duplicate triplets. arr.sort() triplets = [] length = len(arr) for i in range(length - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, length - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"from typing import List def max_coins(mat: List[List[int]]) -> int: Given a matrix mat of dimensions m x n, determine the maximum number of coins that can be collected starting from any cell in the first column and moving to any cell in the last column by repeatedly moving right, up-right, or down-right. >>> max_coins([[1, 2, 3, 4]]) 10 >>> max_coins([[1], [2], [3], [4]]) 4 >>> max_coins([ ... [0, 2, 2, 1], ... [3, 1, 1, 3], ... [1, 1, 2, 4] ... ]) 10 >>> max_coins([ ... [1, 3, 1, 5], ... [2, 2, 4, 1], ... [5, 0, 2, 3], ... [0, 6, 1, 2] ... ]) 16 >>> max_coins([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) 0","solution":"def max_coins(mat): Given a matrix mat of dimensions m x n, determine the maximum number of coins that can be collected starting from any cell in the first column and moving to any cell in the last column by repeatedly moving right, up-right, or down-right. m, n = len(mat), len(mat[0]) # Create a DP table with the same dimensions as mat. dp = [[0] * n for _ in range(m)] # Initialize the first column of the DP table with the same values as the mat. for i in range(m): dp[i][0] = mat[i][0] # Fill the rest of the DP table. for j in range(1, n): for i in range(m): # Collect the coins from the right, upper-right, and lower-right cells. right = dp[i][j-1] up_right = dp[i-1][j-1] if i > 0 else 0 down_right = dp[i+1][j-1] if i < m-1 else 0 dp[i][j] = mat[i][j] + max(right, up_right, down_right) # The result is the maximum value in the last column of the DP table. return max(dp[i][n-1] for i in range(m))"},{"question":"def min_subarray_len(nums: List[int], k: int) -> int: Returns the length of the shortest contiguous subarray whose sum is equal to or greater than 'k'. If no such subarray exists, returns -1. >>> min_subarray_len([1, 2, 3], 10) -1 >>> min_subarray_len([1, 2, 3], 6) 3 >>> min_subarray_len([1, 2, 3, 4], 4) 1 >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([2, 3, 1, 2, 4, 3], 6) 2 >>> min_subarray_len([1, 4, 4], 8) 2 >>> min_subarray_len([5], 5) 1 >>> min_subarray_len([1], 2) -1","solution":"def min_subarray_len(nums, k): Returns the length of the shortest contiguous subarray whose sum is equal to or greater than 'k'. If no such subarray exists, returns -1. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def count_subarrays(arr, x, y): Given a list of integers and two integers, \`x\` and \`y\`, find the number of subarrays where the maximum element of that subarray is less than or equal to \`x\`, and the minimum element of that subarray is greater than or equal to \`y\`. Return the number of such subarrays in the list. Args: arr: List[int] - List of integers. x: int - Maximum value constraint. y: int - Minimum value constraint. Returns: int - Number of subarrays meeting the criteria. Examples: >>> count_subarrays([1, 2, 3, 4], 3, 1) 6 >>> count_subarrays([2, 1, 4, 3], 4, 1) 10 >>> count_subarrays([7, 8, 9], 3, 4) 0 >>> count_subarrays([3, 5, 3, 2], 5, 3) 6 >>> count_subarrays([3, 3, 3], 3, 3) 6","solution":"def count_subarrays(arr, x, y): Returns the number of subarrays in which the maximum element is <= x and the minimum element is >= y. n = len(arr) count = 0 for start in range(n): for end in range(start, n): subarray = arr[start:end + 1] if max(subarray) <= x and min(subarray) >= y: count += 1 return count"},{"question":"def trap_rain_water(arr): Returns the maximum amount of water that can be trapped after it rains. Parameters: arr (list): List of integers representing the heights of the landscape. Returns: int: Maximum amount of water that can be trapped. >>> trap_rain_water([]) == 0 >>> trap_rain_water([1, 1, 1, 1]) == 0 >>> trap_rain_water([1, 0, 1]) == 1 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([5, 4, 3, 2, 1]) == 0 >>> trap_rain_water([1, 2, 3, 4, 5]) == 0 >>> trap_rain_water([1, 0, 2, 0, 1]) == 2 >>> trap_rain_water([3, 0, 3, 0, 3]) == 6","solution":"def trap_rain_water(arr): Returns the maximum amount of water that can be trapped after it rains. Parameters: arr (list): List of integers representing the heights of the landscape. Returns: int: Maximum amount of water that can be trapped. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"class SparseArray: def __init__(self, size): Initialize an array of given size with all elements set to 0. pass def set(self, index, value): Update the element at the specified index to value. pass def get(self, index): Returns the value of the element at the specified index. pass def find_first(self, low, high): Finds the first index in the specified range [low, high] containing a non-zero value and returns that index. If no such index exists, return -1. pass import pytest def test_sparse_array_set_and_get(): arr = SparseArray(10) assert arr.get(5) == 0 # initially 0 arr.set(5, 10) assert arr.get(5) == 10 arr.set(5, 0) assert arr.get(5) == 0 # reset to 0 def test_sparse_array_find_first(): arr = SparseArray(10) arr.set(4, 20) arr.set(7, 30) assert arr.find_first(0, 3) == -1 assert arr.find_first(0, 4) == 4 assert arr.find_first(5, 8) == 7 assert arr.find_first(8, 9) == -1 def test_sparse_array_operations(): arr = SparseArray(10) arr.set(1, 1) arr.set(3, 3) arr.set(5, 5) arr.set(7, 7) assert arr.get(1) == 1 assert arr.get(2) == 0 assert arr.get(3) == 3 assert arr.get(7) == 7 assert arr.get(9) == 0 assert arr.find_first(0, 6) == 1 assert arr.find_first(2, 5) == 3 assert arr.find_first(4, 7) == 5 assert arr.set(3, 0) == None assert arr.find_first(0, 6) == 1 assert arr.find_first(2, 5) == 5 def test_sparse_array_large_size_effective_memory_usage(): arr = SparseArray(1000000) assert arr.get(999999) == 0 arr.set(999999, 12345) assert arr.get(999999) == 12345 arr.set(999999, 0) assert arr.get(999999) == 0","solution":"class SparseArray: def __init__(self, size): Initialize an array of given size with all elements set to 0. self.size = size self.data = {} def set(self, index, value): Update the element at the specified index to value. if value != 0: self.data[index] = value elif index in self.data: del self.data[index] def get(self, index): Returns the value of the element at the specified index. return self.data.get(index, 0) def find_first(self, low, high): Finds the first index in the specified range [low, high] containing a non-zero value and returns that index. If no such index exists, return -1. for index in range(low, high + 1): if self.get(index) != 0: return index return -1"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def max_path_sum(root): Returns the maximum path sum from root to any leaf node. The path must traverse only downwards. pass # Implement your solution here # Test Cases def test_single_node_tree(): root = TreeNode(10) assert max_path_sum(root) == 10 def test_two_level_tree(): root = TreeNode(5) child1 = TreeNode(3) child2 = TreeNode(8) root.children = [child1, child2] assert max_path_sum(root) == 13 # 5 -> 8 def test_three_level_tree(): root = TreeNode(1) child1 = TreeNode(2) child2 = TreeNode(3) grandchild = TreeNode(10) child1.children = [grandchild] root.children = [child1, child2] assert max_path_sum(root) == 13 # 1 -> 2 -> 10 def test_multiple_children(): root = TreeNode(1) child1 = TreeNode(2) child2 = TreeNode(3) child3 = TreeNode(4) grandchild1 = TreeNode(5) grandchild2 = TreeNode(6) child1.children = [grandchild1] child2.children = [grandchild2] root.children = [child1, child2, child3] assert max_path_sum(root) == 10 # 1 -> 2 -> 5 def test_complex_tree(): root = TreeNode(5) child1 = TreeNode(4) child2 = TreeNode(3) child3 = TreeNode(2) grandchild1 = TreeNode(11) grandchild2 = TreeNode(8) grandchild3 = TreeNode(7) grandchild4 = TreeNode(6) child1.children = [grandchild1, grandchild2] child2.children = [grandchild3] child3.children = [grandchild4] root.children = [child1, child2, child3] assert max_path_sum(root) == 20 # 5 -> 4 -> 11","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def max_path_sum(root): Returns the maximum path sum from root to any leaf node. The path must traverse only downwards. if root is None: return 0 if not root.children: return root.value max_child_sum = max(max_path_sum(child) for child in root.children) return root.value + max_child_sum"},{"question":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the object with the size of the moving average window. :param size: The size of the moving average window pass def next(self, val: int) -> float: Returns the moving average of the last size values from the stream after including the current value val. :param val: The next value in the stream :return: The moving average of the last size values pass def test_moving_average(): m_avg = MovingAverage(3) assert m_avg.next(1) == 1.0 # 1 / 1 assert m_avg.next(10) == 5.5 # (1 + 10) / 2 assert m_avg.next(3) == 4.666666666666667 # (1 + 10 + 3) / 3 assert m_avg.next(5) == 6.0 # (10 + 3 + 5) / 3 def test_moving_average_with_initial_size_of_1(): m_avg = MovingAverage(1) assert m_avg.next(1) == 1.0 assert m_avg.next(10) == 10.0 assert m_avg.next(3) == 3.0 def test_moving_average_with_initial_size_of_2(): m_avg = MovingAverage(2) assert m_avg.next(1) == 1.0 # 1 / 1 assert m_avg.next(10) == 5.5 # (1 + 10) / 2 assert m_avg.next(3) == 6.5 # (10 + 3) / 2 assert m_avg.next(5) == 4.0 # (3 + 5) / 2","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the object with the size of the moving average window. :param size: The size of the moving average window self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: Returns the moving average of the last size values from the stream after including the current value val. :param val: The next value in the stream :return: The moving average of the last size values self.queue.append(val) self.sum += val if len(self.queue) > self.size: self.sum -= self.queue.popleft() return self.sum / len(self.queue)"},{"question":"def intersection(nums1, nums2): Given two arrays nums1 and nums2 of integers, return an array of their intersection. Each element in the result must be unique, and you may return the result in any order. The solution should have an expected time complexity better than O(n^2). >>> intersection([1, 2, 2, 1], [2, 2]) [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> intersection([1, 2, 3], [4, 5, 6]) [] >>> intersection([7, 8], [9, 10]) [] >>> intersection([1, 1, 1], [1, 1, 1]) [1] >>> intersection([3, 3, 3, 2, 2, 2], [3, 2, 2, 2, 3, 3]) [2, 3] >>> intersection([1, 2, 3, 4, 5], [2, 4, 6, 8]) [2, 4] >>> intersection([10, 20, 30, 40], [15, 20, 25, 30]) [20, 30]","solution":"def intersection(nums1, nums2): Returns an array of the intersection of nums1 and nums2 with unique elements. The result can be in any order. # Convert the lists to sets to remove duplicates and for efficient intersection set1 = set(nums1) set2 = set(nums2) # Find the intersection of two sets intersection_set = set1.intersection(set2) # Return the result as a list return list(intersection_set)"},{"question":"def is_path_exist(grid: List[List[str]]) -> bool: Determines if there is a path from the top-left corner to the bottom-right corner, moving only through safe zones ('S'). >>> is_path_exist([ ['S', 'S', 'S', 'W'], ['S', 'W', 'S', 'S'], ['S', 'S', 'W', 'D'], ['D', 'S', 'S', 'S'] ]) True >>> is_path_exist([ ['S', 'W', 'S', 'W'], ['S', 'W', 'S', 'S'], ['S', 'D', 'W', 'D'], ['D', 'S', 'S', 'S'] ]) False >>> is_path_exist([ ['S', 'S', 'W'], ['D', 'W', 'S'], ['S', 'S', 'S'] ]) False >>> is_path_exist([ ['S', 'S', 'S', 'S'], ['W', 'W', 'W', 'S'], ['S', 'S', 'S', 'S'], ['S', 'W', 'W', 'S'], ]) True >>> is_path_exist([ ['S', 'W'], ['S', 'S'] ]) True >>> is_path_exist([ ['S', 'W'], ['D', 'S'] ]) False >>> is_path_exist([ ['S'] ]) True >>> is_path_exist([ ['D'] ]) False >>> is_path_exist([ ['W'] ]) False >>> is_path_exist([]) False","solution":"def is_path_exist(grid): Determines if there is a path from the top-left corner to the bottom-right corner, moving only through safe zones ('S'). if not grid or not grid[0] or grid[0][0] != 'S' or grid[-1][-1] != 'S': return False m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x == m - 1 and y == n - 1: return True visited[x][y] = True for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)): nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 'S': if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"def max_candies_types(nums: List[int]) -> int: Returns the maximum number of different types of candies each person can have. Parameters: nums (list): List of integers representing different types of candies. Returns: int: Maximum number of different types of candies each person can have. >>> max_candies_types([1, 2, 3, 1, 2, 3]) 3 >>> max_candies_types([1, 2, 1, 2, 1, 2]) 2 >>> max_candies_types([1, 1, 1, 1, 2, 2]) 2 >>> max_candies_types([1, 1, 1, 1, 1, 1]) 1 >>> max_candies_types([1, 2, 3, 4, 5, 6]) 3 >>> nums = list(range(1000)) * 2 >>> max_candies_types(nums) 1000","solution":"def max_candies_types(nums): Returns the maximum number of different types of candies each person can have. Parameters: nums (list): List of integers representing different types of candies. Returns: int: Maximum number of different types of candies each person can have. unique_candies = len(set(nums)) half_length = len(nums) // 2 return min(unique_candies, half_length)"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root: TreeNode, targetSum: int) -> List[List[int]]: Find all paths in a binary tree where the sum of the values along the path equals a given sum. Each path should be represented as a list of node values. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right = TreeNode(8) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> targetSum = 22 >>> pathSum(root, targetSum) [[5, 4, 11, 2]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> targetSum = 5 >>> pathSum(root, targetSum) [] >>> root = None >>> targetSum = 0 >>> pathSum(root, targetSum) []","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root: TreeNode, targetSum: int) -> List[List[int]]: def dfs(node, current_path, total_sum): if not node: return current_path.append(node.val) total_sum += node.val if not node.left and not node.right: if total_sum == targetSum: result.append(list(current_path)) else: if node.left: dfs(node.left, current_path, total_sum) if node.right: dfs(node.right, current_path, total_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"def avoidFlood(rain: List[int]) -> List[int]: Returns an array where each index corresponds to the decision made on that day. For rainy days, return -1. For dry days, return the lake number that you decide to drain. If it's impossible to avoid flooding, return an empty array. >>> avoidFlood([1, 2, 0, 0, 2, 1]) [-1, -1, 2, 1, -1, -1] >>> avoidFlood([1, 2, 3, 4, 1, 2]) [] >>> avoidFlood([0, 0, 0, 0]) [1, 1, 1, 1] >>> avoidFlood([1, 0, 2, 0, 1, 0, 2]) [-1, 1, -1, 2, -1, 1, -1] >>> avoidFlood([1, 0, 2, 3, 1, 2, 0, 3, 3]) [] pass","solution":"def avoidFlood(rain): Returns an array where each index corresponds to the decision made on that day. For rainy days, return -1. For dry days, return the lake number that you decide to drain. If it's impossible to avoid flooding, return an empty array. n = len(rain) lake_to_day = {} dry_days = [] result = [-1] * n for i in range(n): if rain[i] > 0: lake = rain[i] if lake in lake_to_day: if not dry_days: return [] dry_day = None for j, day in enumerate(dry_days): if day > lake_to_day[lake]: dry_day = day break if dry_day is None: return [] result[dry_day] = lake dry_days.pop(j) lake_to_day[lake] = i else: dry_days.append(i) for day in dry_days: result[day] = 1 # Any arbitrary number can replace 1 if needed return result"},{"question":"def max_apples(grid): Calculate the maximum number of apples that can be collected when traveling from the top-left corner of the grid to the bottom-right corner. >>> max_apples([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_apples([ ... [1, 2, 3, 4, 5] ... ]) 15 >>> max_apples([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) 15 >>> max_apples([]) 0 >>> max_apples([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def max_apples(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"from typing import List def min_steps(obstacles: List[List[int]], startRow: int, startCol: int, endRow: int, endCol: int) -> int: Calculates the minimum number of steps required to travel from (startRow, startCol) to (endRow, endCol) on a grid with obstacles. Returns -1 if no such path exists. >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> min_steps(grid, 0, 0, 2, 2) 4 >>> grid = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> min_steps(grid, 0, 0, 2, 2) 4 >>> grid = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0] ... ] >>> min_steps(grid, 0, 0, 2, 2) -1 >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> min_steps(grid, 0, 0, 2, 2) -1 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> min_steps(grid, 0, 0, 2, 2) -1 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> min_steps(grid, 1, 1, 1, 1) 0 >>> grid = [ ... [0, 0, 1, 0, 0], ... [1, 0, 1, 0, 1], ... [0, 0, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> min_steps(grid, 0, 0, 4, 4) 8","solution":"from collections import deque def min_steps(obstacles, startRow, startCol, endRow, endCol): Calculates the minimum number of steps to travel from start to end on a grid with obstacles. rows = len(obstacles) cols = len(obstacles[0]) if obstacles[startRow][startCol] == 1 or obstacles[endRow][endCol] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(startRow, startCol, 0)]) visited = set((startRow, startCol)) while queue: row, col, steps = queue.popleft() if (row, col) == (endRow, endCol): return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and obstacles[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"from typing import List, Union def lexicographically_smallest_rearrangement(arr: List[int], m: int) -> Union[List[int], int]: Rearranges the elements within arr to ensure the sum of every continuous subarray of length m is distinct, and returns the lexicographically smallest rearrangement that meets the condition. If not possible to obtain such a rearrangement, return -1. >>> lexicographically_smallest_rearrangement([4, 3, 1, 2], 2) [1, 2, 3, 4] >>> lexicographically_smallest_rearrangement([1, 1, 1], 2) -1 >>> lexicographically_smallest_rearrangement([1, 3, 6, 7], 3) [1, 3, 6, 7] >>> lexicographically_smallest_rearrangement([10, 20, 30], 4) -1 >>> lexicographically_smallest_rearrangement([1], 1) [1] >>> lexicographically_smallest_rearrangement([5, 3, 2, 4, 1], 2) [1, 2, 3, 4, 5]","solution":"def lexicographically_smallest_rearrangement(arr, m): Rearranges the elements within arr to ensure the sum of every continuous subarray of length m is distinct, and returns the lexicographically smallest rearrangement that meets the condition. If not possible to obtain such a rearrangement, return -1. n = len(arr) if m > n: return -1 arr.sort() sums = set() for i in range(n - m + 1): subarray_sum = sum(arr[i:i + m]) if subarray_sum in sums: return -1 sums.add(subarray_sum) return arr"},{"question":"from typing import List def most_unique_logins(logins: List[str]) -> str: Finds the user with the highest number of unique logins and returns their <id>. If there is a tie, return the user with the smallest <id> (lexicographically). >>> most_unique_logins([\\"user1:159431\\", \\"user2:159432\\", \\"user1:159433\\", \\"user3:159434\\", \\"user2:159433\\", \\"user3:159432\\", \\"user2:159435\\", \\"user3:159436\\", \\"user1:159437\\"]) 'user1' >>> most_unique_logins([\\"user1:159431\\", \\"user2:159432\\", \\"user3:159433\\", \\"user4:159434\\"]) 'user1' >>> most_unique_logins([]) None","solution":"def most_unique_logins(logins): Finds the user with the highest number of unique logins and returns their <id>. If there's a tie, returns the user with the smallest <id>. from collections import defaultdict login_records = defaultdict(set) for login in logins: user_id, timestamp = login.split(\\":\\") login_records[user_id].add(timestamp) max_unique_logins = 0 result_user = None for user_id, timestamps in login_records.items(): if len(timestamps) > max_unique_logins or (len(timestamps) == max_unique_logins and (result_user is None or user_id < result_user)): max_unique_logins = len(timestamps) result_user = user_id return result_user"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode: Given the head of two singly linked lists, find the node at which the two lists intersect. :param headA: ListNode :param headB: ListNode :return: ListNode or None Assumes the linked lists retain their original structure after the intersection check. If the two linked lists have no intersection, return None. import pytest from solution import ListNode, Solution def test_intersection_node(): # Creating the intersected parts intersected = ListNode(8) intersected.next = ListNode(10) # Creating first linked list headA = ListNode(3) headA.next = ListNode(6) headA.next.next = ListNode(9) headA.next.next.next = intersected # Creating second linked list headB = ListNode(4) headB.next = ListNode(7) headB.next.next = intersected # Create a solution object sol = Solution() # Assert that the lists intersect at node with value 8 assert sol.getIntersectionNode(headA, headB).val == 8 def test_no_intersection(): # Creating first linked list headA = ListNode(1) headA.next = ListNode(2) headA.next.next = ListNode(3) # Creating second linked list headB = ListNode(4) headB.next = ListNode(5) headB.next.next = ListNode(6) # Create a solution object sol = Solution() # Assert that the lists do not intersect assert sol.getIntersectionNode(headA, headB) is None def test_empty_lists(): # Create a solution object sol = Solution() # Assert that two empty lists will not intersect assert sol.getIntersectionNode(None, None) is None def test_one_empty_list(): # Creating a non-empty linked list headA = ListNode(1) headA.next = ListNode(2) # Create a solution object sol = Solution() # Assert that one empty list and one non-empty list will not intersect assert sol.getIntersectionNode(headA, None) is None assert sol.getIntersectionNode(None, headA) is None","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode: if headA is None or headB is None: return None # Use two pointers pA = headA pB = headB # Iterate through both lists while pA is not pB: # If pointer hits the end, move it to the head of the other list if pA is None: pA = headB else: pA = pA.next if pB is None: pB = headA else: pB = pB.next return pA"},{"question":"from typing import List def can_reach_bottom_right(heights: List[List[int]], k: int) -> bool: Determine if a path exists from the top-left to the bottom-right of the heights matrix with the given maximum allowed height difference for adjacent cells. >>> can_reach_bottom_right([[1, 2, 2], [3, 8, 2], [5, 3, 5]], 2) True >>> can_reach_bottom_right([[1, 10, 1], [10, 10, 10], [1, 10, 1]], 1) False >>> can_reach_bottom_right([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) True >>> can_reach_bottom_right([[3]], 0) True >>> can_reach_bottom_right([ [1, 3, 5, 7], [2, 4, 6, 8], [7, 6, 5, 4], [8, 7, 6, 3] ], 5) True","solution":"def can_reach_bottom_right(heights, k): Determine if a path exists from the top-left to the bottom-right of the heights matrix with the given maximum allowed height difference for adjacent cells. from collections import deque def valid(x, y): return 0 <= x < len(heights) and 0 <= y < len(heights[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] m, n = len(heights), len(heights[0]) visited = [[False for _ in range(n)] for _ in range(m)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if valid(nx, ny) and not visited[nx][ny] and abs(heights[nx][ny] - heights[x][y]) <= k: queue.append((nx, ny)) visited[nx][ny] = True return False"},{"question":"class ParkingSystem: A parking lot system that keeps track of incoming and outgoing vehicles. Initialization: parking_system = ParkingSystem(big, medium, small) # Initialize with the number of available spots for each car type Methods: parking_system.addCar(carType) # Add a car of type carType. Returns True if the car was successfully parked, otherwise False. parking_system.removeCar(carType) # Remove a car of type carType. Returns True if the car was successfully removed, otherwise False. parking_system.availableSpots() # Returns the total number of available parking spots. def __init__(self, big: int, medium: int, small: int): pass def addCar(self, carType: int) -> bool: pass def removeCar(self, carType: int) -> bool: pass def availableSpots(self) -> int: pass # Unit tests def test_addCar_success(): parking_system = ParkingSystem(1, 1, 1) assert parking_system.addCar(1) == True # Big car assert parking_system.addCar(2) == True # Medium car assert parking_system.addCar(3) == True # Small car def test_addCar_failure(): parking_system = ParkingSystem(1, 1, 1) parking_system.addCar(1) # Occupy the only big car spot assert parking_system.addCar(1) == False # Another big car should fail def test_removeCar_success(): parking_system = ParkingSystem(1, 1, 1) parking_system.addCar(1) assert parking_system.removeCar(1) == True # Remove the big car def test_removeCar_failure(): parking_system = ParkingSystem(1, 1, 1) assert parking_system.removeCar(1) == False # No big car to remove def test_availableSpots(): parking_system = ParkingSystem(2, 2, 2) assert parking_system.availableSpots() == 6 # Initially all spots are available parking_system.addCar(1) assert parking_system.availableSpots() == 5 # One big car occupies a spot parking_system.addCar(2) assert parking_system.availableSpots() == 4 # One medium car occupies a spot parking_system.removeCar(1) assert parking_system.availableSpots() == 5 # Removed a big car, spot available again","solution":"class ParkingSystem: def __init__(self, big: int, medium: int, small: int): self.available_spots = {1: big, 2: medium, 3: small} self.capacity = {1: big, 2: medium, 3: small} def addCar(self, carType: int) -> bool: if self.available_spots[carType] > 0: self.available_spots[carType] -= 1 return True return False def removeCar(self, carType: int) -> bool: if self.available_spots[carType] < self.capacity[carType]: self.available_spots[carType] += 1 return True return False def availableSpots(self) -> int: return sum(self.available_spots.values())"},{"question":"def run_length_encode(s: str) -> str: Returns the run-length encoded form of the given string s. >>> run_length_encode(\\"aaabbbc\\") == \\"3a3b1c\\" >>> run_length_encode(\\"wwwwaaadexxxxxx\\") == \\"4w3a1d1e6x\\" >>> run_length_encode(\\"a\\") == \\"1a\\" >>> run_length_encode(\\"abc\\") == \\"1a1b1c\\" >>> run_length_encode(\\"\\") == \\"\\" >>> run_length_encode(\\"tttsssuuuuhhh\\") == \\"3t3s4u3h\\" >>> run_length_encode(\\"abbbabbbb\\") == \\"1a3b1a4b\\"","solution":"def run_length_encode(s): Returns the run-length encoded form of the given string s. if not s: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str += str(count) + s[i - 1] count = 1 encoded_str += str(count) + s[-1] return encoded_str"},{"question":"def remove_duplicates(s: str) -> str: Returns a new string with the duplicate characters removed, while preserving the original order of characters. >>> remove_duplicates(\\"programming\\") == \\"progamin\\" >>> remove_duplicates(\\"abcabc\\") == \\"abc\\" >>> remove_duplicates(\\"aabbcc\\") == \\"abc\\" >>> remove_duplicates(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"abcdefghijklmnopqrstuvwxyz\\" >>> remove_duplicates(\\"thequickbrownfoxjumpsoverthelazydog\\") == \\"thequickbrownfxjmpsvlazydg\\" >>> remove_duplicates(\\"aaaaaaa\\") == \\"a\\" >>> remove_duplicates(\\"a\\") == \\"a\\" >>> remove_duplicates(\\"\\") == \\"\\"","solution":"def remove_duplicates(s): Returns a new string with the duplicate characters removed, while preserving the original order of characters. :param s: Input string :returns: New string with duplicates removed seen = [False] * 26 # There are 26 lowercase English letters result = [] for char in s: if not seen[ord(char) - ord('a')]: seen[ord(char) - ord('a')] = True result.append(char) return ''.join(result)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode: Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. >>> list1 = [1, 2, 4] >>> list2 = [1, 3, 4] >>> mergeTwoLists(list1, list2) == [1, 1, 2, 3, 4, 4] >>> list1 = [] >>> list2 = [1, 3, 4] >>> mergeTwoLists(list1, list2) == [1, 3, 4] # Here are some utility functions and tests def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(node): lst = [] current = node while current: lst.append(current.val) current = current.next return lst def test_merge_two_sorted_lists(): list1 = list_to_linked_list([1, 2, 4]) list2 = list_to_linked_list([1, 3, 4]) merged = mergeTwoLists(list1, list2) assert linked_list_to_list(merged) == [1, 1, 2, 3, 4, 4] def test_merge_one_empty_list(): list1 = list_to_linked_list([]) list2 = list_to_linked_list([1, 3, 4]) merged = mergeTwoLists(list1, list2) assert linked_list_to_list(merged) == [1, 3, 4] list1 = list_to_linked_list([1, 2, 4]) list2 = list_to_linked_list([]) merged = mergeTwoLists(list1, list2) assert linked_list_to_list(merged) == [1, 2, 4] def test_merge_both_empty_lists(): list1 = list_to_linked_list([]) list2 = list_to_linked_list([]) merged = mergeTwoLists(list1, list2) assert linked_list_to_list(merged) == [] def test_merge_identical_elements(): list1 = list_to_linked_list([2, 2, 2]) list2 = list_to_linked_list([2, 2, 2]) merged = mergeTwoLists(list1, list2) assert linked_list_to_list(merged) == [2, 2, 2, 2, 2, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode: dummy = ListNode() current = dummy while list1 and list2: if list1.val <= list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1: current.next = list1 if list2: current.next = list2 return dummy.next"},{"question":"def matrix_multiply(A, B): Multiplies two matrices A and B if they are compatible for multiplication. Args: A: list of lists representing matrix A. B: list of lists representing matrix B. Returns: A resultant matrix which is a product of matrices A and B. Raises: ValueError: If the dimensions of A and B are incompatible for matrix multiplication. pass # Unit Tests def test_matrix_multiply_empty_matrices(): assert matrix_multiply([], []) == [] def test_matrix_multiply_incompatible_dimensions(): A = [ [1, 2, 3], [4, 5, 6] ] B = [ [1, 2], [3, 4] ] try: matrix_multiply(A, B) except ValueError as ve: assert str(ve) == \\"Incompatible dimensions for matrix multiplication\\" def test_matrix_multiply_compatible_matrices(): A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiply(A, B) assert result == [[58, 64], [139, 154]] def test_matrix_multiply_single_element_matrices(): A = [[2]] B = [[3]] result = matrix_multiply(A, B) assert result == [[6]] def test_matrix_multiply_single_row_and_column(): A = [[1, 2, 3]] B = [[4], [5], [6]] result = matrix_multiply(A, B) assert result == [[32]] def test_matrix_multiply_different_dimensions(): A = [ [1, 4], [2, 5], [3, 6] ] B = [ [7, 8, 9], [10, 11, 12] ] result = matrix_multiply(A, B) assert result == [ [47, 52, 57], [64, 71, 78], [81, 90, 99] ]","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B if they are compatible for multiplication. Args: A: list of lists representing matrix A. B: list of lists representing matrix B. Returns: A resultant matrix which is a product of matrices A and B. # Check if the matrices are compatible for multiplication if len(A) == 0 or len(B) == 0: return [] rows_A = len(A) cols_A = len(A[0]) rows_B = len(B) cols_B = len(B[0]) if cols_A != rows_B: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Initialize the result matrix with zeroes result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"def rectangle_area(length: int, width: int) -> int: Returns the area of a rectangle with given length and width. If either length or width is zero, returns 0. >>> rectangle_area(3, 4) 12 >>> rectangle_area(0, 5) 0 >>> rectangle_area(7, 0) 0 >>> rectangle_area(10, 10) 100 >>> rectangle_area(100000, 100000) 10000000000 >>> rectangle_area(99999, 99999) 9999800001","solution":"def rectangle_area(length, width): Returns the area of a rectangle with given length and width. If either length or width is zero, returns 0. return length * width if length > 0 and width > 0 else 0"},{"question":"def roman_to_integer(s: str) -> int: Given a string s representing a valid Roman numeral, convert s to an integer. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Symbol Value: I 1 V 5 X 10 L 50 C 100 D 500 M 1000 Example 1: >>> roman_to_integer(\\"III\\") 3 Example 2: >>> roman_to_integer(\\"IV\\") 4 Example 3: >>> roman_to_integer(\\"IX\\") 9 Example 4: >>> roman_to_integer(\\"LVIII\\") 58 Example 5: >>> roman_to_integer(\\"MCMXCIV\\") 1994 Note: - The given string s is any valid Roman numeral from 1 to 3999. - It is guaranteed that s is valid, so solutions do not need to account for malformed Roman numerals. from solution import roman_to_integer def test_roman_to_integer_basic(): assert roman_to_integer(\\"III\\") == 3 assert roman_to_integer(\\"IV\\") == 4 assert roman_to_integer(\\"IX\\") == 9 def test_roman_to_integer_combined(): assert roman_to_integer(\\"LVIII\\") == 58 assert roman_to_integer(\\"MCMXCIV\\") == 1994 def test_roman_to_integer_edge_cases(): assert roman_to_integer(\\"I\\") == 1 assert roman_to_integer(\\"MMMCMXCIX\\") == 3999 def test_roman_to_integer_mixed_numerals(): assert roman_to_integer(\\"CCXLVI\\") == 246 assert roman_to_integer(\\"MCMLXXXIV\\") == 1984","solution":"def roman_to_integer(s): roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"def can_form_palindrome(s1: str, s2: str) -> bool: Determine if we can form a palindrome by choosing characters from both \`s1\` and \`s2\`. Args: s1: str - First string containing lower case alphabets. s2: str - Second string containing lower case alphabets. Returns: bool - True if it is possible to form a palindrome, False otherwise. >>> can_form_palindrome(\\"axxy\\", \\"yya\\") True >>> can_form_palindrome(\\"abc\\", \\"def\\") False","solution":"def can_form_palindrome(s1, s2): Determine if we can form a palindrome by choosing characters from both \`s1\` and \`s2\`. Args: s1: str - First string containing lower case alphabets. s2: str - Second string containing lower case alphabets. Returns: bool - True if it is possible to form a palindrome, False otherwise. # Create a set of characters that are in both s1 and s2 common_chars = set(s1) & set(s2) # If there is at least one common character, it is possible to form a palindrome. return len(common_chars) > 0"},{"question":"def process_operations(n, q, operations): Process a list of operations on a sequence of integers. Parameters: n (int): Length of the sequence. q (int): Number of operations. operations (list of list): List of operations to be performed. Returns: list: Result of type-2 operations. pass from solution import process_operations def test_example_operations(): n = 6 q = 5 operations = [ [1, 1, 3, 5], [2, 2], [1, 2, 6, 3], [2, 4], [2, 6] ] assert process_operations(n, q, operations) == [5, 3, 3] def test_no_updates(): n = 5 q = 1 operations = [ [2, 3] ] assert process_operations(n, q, operations) == [0] def test_single_update(): n = 3 q = 2 operations = [ [1, 1, 3, 2], [2, 2] ] assert process_operations(n, q, operations) == [2] def test_large_updates(): n = 10 q = 4 operations = [ [1, 1, 10, 1000], [1, 1, 5, -500], [2, 3], [2, 10] ] assert process_operations(n, q, operations) == [500, 1000] def test_edge_cases(): n = 1 q = 2 operations = [ [1, 1, 1, 999], [2, 1] ] assert process_operations(n, q, operations) == [999]","solution":"def process_operations(n, q, operations): Process a list of operations on a sequence of integers. Parameters: n (int): Length of the sequence. q (int): Number of operations. operations (list of list): List of operations to be performed. Returns: list: Result of type-2 operations. sequence = [0] * n results = [] for operation in operations: if operation[0] == 1: l, r, x = operation[1] - 1, operation[2] - 1, operation[3] for i in range(l, r + 1): sequence[i] += x elif operation[0] == 2: idx = operation[1] - 1 results.append(sequence[idx]) return results"},{"question":"def longest_word(s: str) -> str: Returns the longest word in the string \`s\`. If multiple words have the same length, returns the first one that appears. >>> longest_word(\\"Write a function that finds the longest word in this sentence\\") \\"function\\" >>> longest_word(\\"I think this is a challenge\\") \\"challenge\\" >>> longest_word(\\"Hello, world!\\") \\"Hello,\\" >>> longest_word(\\"Extraordinary\\") \\"Extraordinary\\" >>> longest_word(\\"cat hat bat mat\\") \\"cat\\" >>> longest_word(\\"\\") \\"\\" >>> longest_word(\\"The quick Brown fox\\") \\"quick\\"","solution":"def longest_word(s): Returns the longest word in the string \`s\`. If multiple words have the same length, returns the first one that appears. words = s.split() max_word = \\"\\" for word in words: if len(word) > len(max_word): max_word = word return max_word"},{"question":"from typing import List, Tuple def find_median_book_identifiers(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and a list of test cases where each test case consists of the number of book identifiers and the list of book identifiers, return the identifier of the median book for each test case. >>> find_median_book_identifiers(3, [(5, [1, 3, 5, 7, 9]), (4, [10, 20, 30, 40]), (3, [100, 200, 300])]) [5, 20, 200] >>> find_median_book_identifiers(1, [(1, [100])]) [100] >>> find_median_book_identifiers(2, [(2, [3, 1]), (5, [9, 5, 7, 3, 1])]) [1, 5] >>> find_median_book_identifiers(1, [(6, [-1, -5, -3, 0, 2, 4])]) [-1] >>> find_median_book_identifiers(1, [(8, [12, 45, 23, 0, 18, 25, 9, 3])]) [12]","solution":"def find_median_book_identifiers(T, test_cases): medians = [] for i in range(T): N = test_cases[i][0] book_identifiers = test_cases[i][1] sorted_identifiers = sorted(book_identifiers) median_index = (N - 1) // 2 medians.append(sorted_identifiers[median_index]) return medians"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return the product of all integers except for the current index without using the division operation. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0,1,2,3,4]) [24, 0, 0, 0, 0] >>> product_except_self([-3, 8, 4, 2]) [64, -24, -48, -96] >>> product_except_self([9, 3, 2]) [6, 18, 27]","solution":"def product_except_self(nums): Returns a list where the ith element is the product of all the elements of nums except nums[i]. n = len(nums) # Initialize lists for the left and right products left_products = [1] * n right_products = [1] * n result = [1] * n # Build the left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Build the right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Build the result array for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def find_minimum_moves(current_combination: str, target_combination: str) -> int: Calculates the minimum number of moves required to change the current combination to the target combination. Each move can increase or decrease a digit and wraps around. Args: - current_combination (str): The current combination string of digits. - target_combination (str): The target combination string of digits. Returns: - int: The minimum number of moves required to change the current combination to the target combination. Examples: >>> find_minimum_moves(\\"023\\", \\"394\\") 7 >>> find_minimum_moves(\\"1234\\", \\"5678\\") 16 from solution import find_minimum_moves def test_example_case(): assert find_minimum_moves(\\"023\\", \\"394\\") == 7 def test_identical_combinations(): assert find_minimum_moves(\\"0000\\", \\"0000\\") == 0 def test_wrap_around_increase(): assert find_minimum_moves(\\"0000\\", \\"9999\\") == 4 def test_wrap_around_decrease(): assert find_minimum_moves(\\"9999\\", \\"0000\\") == 4 def test_different_lengths(): assert find_minimum_moves(\\"1234\\", \\"5678\\") == 16 def test_single_move(): assert find_minimum_moves(\\"1234\\", \\"1244\\") == 1 def test_multiple_moves(): assert find_minimum_moves(\\"1111\\", \\"9999\\") == 4 * 2 def test_large_input(): assert find_minimum_moves(\\"0\\"*1000, \\"9\\"*1000) == 1000*1","solution":"def find_minimum_moves(current_combination, target_combination): Calculates the minimum number of moves required to change the current combination to the target combination. Each move can increase or decrease a digit and wraps around. Args: - current_combination (str): The current combination string of digits. - target_combination (str): The target combination string of digits. Returns: - int: The minimum number of moves required to change the current combination to the target combination. total_moves = 0 for current_digit, target_digit in zip(current_combination, target_combination): current_digit = int(current_digit) target_digit = int(target_digit) # Calculate the absolute difference between current and target digits diff = abs(current_digit - target_digit) # The minimum moves is either the direct difference or the wrapped around difference moves = min(diff, 10 - diff) total_moves += moves return total_moves"},{"question":"def min_bit_flips_required(N: int) -> int: Given a non-negative integer N, determine the minimum number of bit flips required to make the binary representation of N into a valid binary number that could have resulted from flipping at most one bit. >>> min_bit_flips_required(5) 1 >>> min_bit_flips_required(10) 1 >>> min_bit_flips_required(15) 0","solution":"def min_bit_flips_required(N): Given a non-negative integer N, determine the minimum number of bit flips required to make the binary representation of N into a valid binary number that could have resulted from flipping at most one bit. # Converting the number to binary string binary_rep = bin(N)[2:] # Calculate the number of 1s in the binary representation ones_count = binary_rep.count('1') # If the number of 1s is 0 or 1, no flips are needed because it is already valid if ones_count == 0 or ones_count == len(binary_rep): return 0 # Since only one bit flip is allowed, having more than one '0' or more than one '1' means at least 1 flip is needed return 1 def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) results = [] for i in range(1, T + 1): N = int(data[i]) results.append(min_bit_flips_required(N)) print(\\"n\\".join(map(str, results))) if __name__ == \\"__main__\\": main()"},{"question":"def compress_array(arr: list[int]) -> list[int]: Compresses the input array by removing all adjacent duplicate elements and returns the resulting array. Args: arr (list of int): The input array. Returns: list of int: The compressed array. >>> compress_array([1, 2, 2, 3, 3, 3, 2, 2, 1]) == [1, 2, 3, 2, 1] >>> compress_array([4, 4, 4, 4, 4]) == [4] >>> compress_array([1, 1, 2, 3, 3, 4, 4, 5, 5, 5, 1, 1, 2, 2]) == [1, 2, 3, 4, 5, 1, 2]","solution":"def compress_array(arr): Compresses an input array by removing all adjacent duplicate elements. Args: arr (list of int): The input array. Returns: list of int: The compressed array. if not arr: # If the array is empty, return an empty array return [] compressed = [arr[0]] for i in range(1, len(arr)): if arr[i] != arr[i-1]: compressed.append(arr[i]) return compressed"},{"question":"def max_area(nums: List[int]) -> int: Find the maximum amount of water a container can hold given the heights of the columns. Parameters: nums (list): A list of integers representing the heights of the columns. Returns: int: The maximum volume of water the container can hold. Example: >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 1]) 1","solution":"def max_area(nums): Find the maximum amount of water a container can hold given the heights of the columns. Parameters: nums (list): A list of integers representing the heights of the columns. Returns: int: The maximum volume of water the container can hold. left = 0 right = len(nums) - 1 max_area = 0 while left < right: # Calculate the area with the current boundary columns height = min(nums[left], nums[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) # Move the pointers if nums[left] < nums[right]: left += 1 else: right -= 1 return max_area"},{"question":"def reverseStr(s: str, k: int) -> str: Reverses the first k characters for every 2k characters of the string s. :param s: The input string :param k: The number of characters to reverse every 2k characters from the start of the string :return: A modified string >>> reverseStr(\\"abcdefg\\", 2) 'bacdfeg' >>> reverseStr(\\"abcd\\", 2) 'bacd'","solution":"def reverseStr(s, k): Reverses the first k characters for every 2k characters of the string s. :param s: The input string :param k: The number of characters to reverse every 2k characters from the start of the string :return: A modified string result = list(s) for i in range(0, len(s), 2*k): result[i:i+k] = reversed(result[i:i+k]) return ''.join(result)"},{"question":"def add_binary(bin1: str, bin2: str) -> str: Returns the sum of two binary strings as a binary string. >>> add_binary(\\"101\\", \\"1101\\") \\"10010\\" >>> add_binary(\\"1010\\", \\"0110\\") \\"10000\\" >>> add_binary(\\"1111\\", \\"1\\") \\"10000\\" >>> add_binary(\\"0\\", \\"0\\") \\"0\\" >>> add_binary(\\"0\\", \\"1\\") \\"1\\" >>> add_binary(\\"1\\", \\"0\\") \\"1\\" >>> add_binary(\\"1010101010101010\\", \\"1010101010101010\\") \\"10101010101010100\\" >>> add_binary(\\"101\\", \\"10\\") \\"111\\" >>> add_binary(\\"101\\", \\"10000\\") \\"10101\\" pass","solution":"def add_binary(bin1, bin2): Returns the sum of two binary strings as a binary string. # Convert binary strings to integers, add them, then convert the result back to a binary string. sum_int = int(bin1, 2) + int(bin2, 2) return bin(sum_int)[2:]"},{"question":"def count_pairs_with_difference(nums: list[int], k: int) -> int: Count the number of distinct pairs (i, j) in the list such that the absolute difference between nums[i] and nums[j] is equal to k. Args: nums (list[int]): List of integers. k (int): Absolute difference. Returns: int: Number of distinct pairs with absolute difference k. >>> count_pairs_with_difference([1, 5, 3, 4, 2], 2) 3 >>> count_pairs_with_difference([1, 2, 3, 4, 5], 10) 0 >>> count_pairs_with_difference([1, 10**9, 10**9 - 1], 1) 1 >>> count_pairs_with_difference([1, 5, 3, 4, 2, 3], 1) 4 >>> count_pairs_with_difference([1, 1, 1, 1], 0) 0","solution":"def count_pairs_with_difference(nums, k): Counts the number of distinct pairs (i, j) in the list such that the absolute difference between nums[i] and nums[j] is equal to k. Args: nums (list): List of integers. k (int): Absolute difference. Returns: int: Number of distinct pairs with absolute difference k. nums_set = set(nums) count = 0 for num in nums_set: if (num + k) in nums_set: count += 1 if (num - k) in nums_set and k != 0: count += 1 return count // 2 # Each pair is counted twice"},{"question":"from typing import List, Dict def countWords(titles: List[str]) -> Dict[str, int]: Count the number of unique words in the titles of songs. Arguments: titles -- list of song titles Returns: dictionary with unique words as keys and their respective counts as values Examples: >>> countWords([\\"Hello, Goodbye\\", \\"Hello, Sunshine\\", \\"Goodbye Moon\\"]) {'hello': 2, 'goodbye': 2, 'sunshine': 1, 'moon': 1} >>> countWords([\\"HELLO, hello\\", \\"HellO\\"]) {'hello': 3} >>> countWords([\\"Hello! Goodbye?\\", \\"What's sunshine?\\", \\"Goodbye, Moon!\\"]) {'hello': 1, 'goodbye': 2, 'whats': 1, 'sunshine': 1, 'moon': 1} >>> countWords([]) {} >>> countWords([\\"Repeat repeat repeat\\", \\"repeat\\"]) {'repeat': 4} >>> countWords([\\"Hello-World, Goodbye.World\\"]) {'helloworld': 1, 'goodbyeworld': 1} # Implementation here","solution":"import string def countWords(titles): Count the number of unique words in the titles of songs. Arguments: titles -- list of song titles Returns: dictionary with unique words as keys and their respective counts as values word_count = {} for title in titles: # Convert title to lowercase title = title.lower() # Remove punctuation title = title.translate(str.maketrans(\\"\\", \\"\\", string.punctuation)) # Split title into words words = title.split() # Count words for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"def sum_of_powered_digits(n: int) -> int: Write a function that takes a positive integer \`n\` and returns the sum of all digits of \`n\` each raised to the power of their respective positions (starting from 1). Example: >>> sum_of_powered_digits(987) 416 >>> sum_of_powered_digits(1234) 288 # Your code here","solution":"def sum_of_powered_digits(n): Returns the sum of all digits of n each raised to the power of their respective positions. digits = [int(d) for d in str(n)] sum_powered = sum(digit ** (i + 1) for i, digit in enumerate(digits)) return sum_powered"},{"question":"from typing import List, Optional def second_largest(numbers: List[int]) -> Optional[int]: Returns the second largest number in the list, or None if there isn't one. >>> second_largest([3, 1, 4, 1, 5, 9, 2, 6]) == 6 >>> second_largest([3]) == None >>> second_largest([10, 10, 10]) == None","solution":"from typing import List, Optional def second_largest(numbers: List[int]) -> Optional[int]: Returns the second largest number in the list, or None if there isn't one. if len(numbers) < 2: return None first, second = float('-inf'), float('-inf') for number in numbers: if number > first: second = first first = number elif first > number > second: second = number return second if second != float('-inf') else None"},{"question":"def is_reverse(arr1: List[int], arr2: List[int]) -> bool: Check if one array is the reverse of the other. >>> is_reverse([1, 2, 3], [3, 2, 1]) True >>> is_reverse([1, 2, 3], [1, 2, 3]) False >>> is_reverse([4, 5, 6, 7], [7, 6, 5, 4]) True >>> is_reverse([5, 6, 7], [7, 6, 5, 0]) False >>> is_reverse([], []) True >>> is_reverse([2], [3]) False","solution":"from typing import List def is_reverse(arr1: List[int], arr2: List[int]) -> bool: Check if one array is the reverse of the other. Parameters: arr1 (List[int]): First array arr2 (List[int]): Second array Returns: bool: True if one array is the reverse of the other, False otherwise return arr1 == arr2[::-1]"},{"question":"def rotate_left(lst: List[int], n: int) -> List[int]: Rotates the elements of the list to the left by n positions. If n is negative, rotates the elements to the right by the absolute value of n. >>> rotate_left([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotate_left([1, 2, 3, 4, 5], -1) [5, 1, 2, 3, 4] >>> rotate_left([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5]","solution":"def rotate_left(lst, n): Rotates the elements of the list to the left by n positions. If n is negative, rotates the elements to the right by the absolute value of n. if not lst: return lst n = n % len(lst) # Handle cases where n is larger than the length of the list. return lst[n:] + lst[:n] if n >= 0 else lst[n:] + lst[:n]"},{"question":"def book_sales(inventory, sales): Simulate the sale of books from the inventory and calculate total revenue. Parameters: - inventory: list of dictionaries, each representing a book with keys 'ISBN', 'price', and 'copies'. - sales: list of dictionaries, each representing a sale with keys 'ISBN' and 'quantity'. Returns: - total revenue generated from all the sales. After the function runs, the inventory should be updated to reflect the remaining copies of each book. Examples: >>> inventory = [ ... {'ISBN': 1001, 'price': 20, 'copies': 5}, ... {'ISBN': 1002, 'price': 35, 'copies': 3}, ... {'ISBN': 1003, 'price': 50, 'copies': 2} ... ] >>> sales = [ ... {'ISBN': 1001, 'quantity': 3}, ... {'ISBN': 1002, 'quantity': 1}, ... {'ISBN': 1003, 'quantity': 5} ... ] >>> total_revenue = book_sales(inventory, sales) >>> total_revenue 195 >>> inventory [ {'ISBN': 1001, 'price': 20, 'copies': 2}, {'ISBN': 1002, 'price': 35, 'copies': 2}, {'ISBN': 1003, 'price': 50, 'copies': 0} ]","solution":"def book_sales(inventory, sales): total_revenue = 0 isbn_to_book = {book['ISBN']: book for book in inventory} for sale in sales: isbn = sale['ISBN'] quantity = sale['quantity'] if isbn in isbn_to_book: book = isbn_to_book[isbn] available_copies = book['copies'] copies_to_sell = min(quantity, available_copies) total_revenue += copies_to_sell * book['price'] book['copies'] -= copies_to_sell return total_revenue"},{"question":"def can_form_palindrome(n: int) -> bool: Returns True if the digits of the positive integer n can be re-arranged to form a palindrome, False otherwise. >>> can_form_palindrome(121) True >>> can_form_palindrome(12312) True >>> can_form_palindrome(123) False","solution":"def can_form_palindrome(n): Returns True if the digits of the positive integer n can be re-arranged to form a palindrome, False otherwise. from collections import Counter digit_counts = Counter(str(n)) # A number can form a palindrome if at most one digit has an odd count. odd_count = sum(1 for count in digit_counts.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def length_of_longest_non_decreasing_subsequence(sequence): Returns the length of the longest non-decreasing subsequence in a given sequence of numbers. >>> length_of_longest_non_decreasing_subsequence([5, 3, 4, 8, 6, 7, 8, 6]) 5 >>> length_of_longest_non_decreasing_subsequence([1, 3, 2, 4, 5]) 4 >>> length_of_longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) 1 >>> length_of_longest_non_decreasing_subsequence([]) 0 >>> length_of_longest_non_decreasing_subsequence([10]) 1 def process_test_cases(T, test_cases): Process multiple test cases and return the results for each. >>> T = 2 >>> test_cases = [[8, 5, 3, 4, 8, 6, 7, 8, 6], [5, 1, 3, 2, 4, 5]] >>> process_test_cases(T, test_cases) [5, 4] >>> T = 1 >>> test_cases = [[5, 5, 4, 3, 2, 1]] >>> process_test_cases(T, test_cases) [1]","solution":"def length_of_longest_non_decreasing_subsequence(sequence): Returns the length of the longest non-decreasing subsequence in a given sequence of numbers. if not sequence: return 0 n = len(sequence) dp = [1] * n for i in range(n): for j in range(i): if sequence[i] >= sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(T, test_cases): results = [] for test_case in test_cases: N = test_case[0] sequence = test_case[1:] results.append(length_of_longest_non_decreasing_subsequence(sequence)) return results"},{"question":"def array_diff(arr1, arr2): Write a function that takes two arrays of integers and returns a new array containing elements that are present in the first array but not in the second array. The order of elements in the returned array should match their order in the first array. Consider no duplicate elements within the arrays. :param arr1: list, the first array of integers :param arr2: list, the second array of integers :return: list, a new array with elements from arr1 not in arr2 >>> array_diff([1, 2, 2, 2, 3], [2]) [1, 3] >>> array_diff([1, 2, 3], [4, 5]) [1, 2, 3]","solution":"def array_diff(arr1, arr2): Returns a new array containing elements that are present in arr1 but not in arr2. The order of elements in the returned array matches their order in arr1. :param arr1: list, the first array of integers :param arr2: list, the second array of integers :return: list, a new array with elements from arr1 not in arr2 return [element for element in arr1 if element not in arr2]"},{"question":"def sum_neighbors(lst: List[int]) -> List[int]: Given a list of integers, return a new list in which each element is the sum of its neighbors and itself. For elements at the beginning and end of the list, assume their \\"outside\\" neighbors are zero. >>> sum_neighbors([1, 2, 3, 4]) [3, 6, 9, 7] >>> sum_neighbors([0, 0, 0, 0]) [0, 0, 0, 0] >>> sum_neighbors([1, -1, 1, -1]) [0, 1, -1, 0]","solution":"def sum_neighbors(lst): Given a list of integers, return a new list where each element is the sum of its neighbors and itself. Assume neighbors of elements at the beginning and end of the list are zero. if not lst: return [] n = len(lst) result = [] for i in range(n): left = lst[i-1] if i > 0 else 0 middle = lst[i] right = lst[i+1] if i < n-1 else 0 result.append(left + middle + right) return result"},{"question":"from typing import List def rearrange_queue(heights: List[int]) -> List[int]: Rearranges the queue based on the given movement rules. :param heights: List of integers representing the heights from front to back. :return: List of integers representing the heights in the final arrangement. >>> rearrange_queue([5, 3, 2, 4, 6, 1]) [5, 4, 3, 2, 1, 6] >>> rearrange_queue([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> rearrange_queue([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> rearrange_queue([4, 5, 6, 5, 4]) [6, 5, 5, 4, 4] >>> rearrange_queue([]) [] >>> rearrange_queue([1]) [1] # Implementation goes here","solution":"def rearrange_queue(heights): Rearranges the queue based on the given movement rules. :param heights: List of integers representing the heights from front to back. :return: List of integers representing the heights in the final arrangement. n = len(heights) if n <= 1: return heights moved = True while moved: moved = False for i in range(n - 1): if heights[i] < heights[i + 1]: heights[i], heights[i + 1] = heights[i + 1], heights[i] moved = True return heights"},{"question":"def max_histogram_area(heights): Given a list of heights, calculates the largest rectangular area under the histogram represented by the list. >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([1, 2, 3, 4, 5]) 9 >>> max_histogram_area([4, 3, 2, 1]) 6 pass def largest_rectangle_areas(test_cases): Given a list of test cases, calculates the largest rectangular area for each. >>> largest_rectangle_areas([(6, [2, 1, 5, 6, 2, 3]), (5, [1, 2, 3, 4, 5]), (4, [4, 3, 2, 1])]) [10, 9, 6] pass","solution":"def max_histogram_area(heights): Given a list of heights, calculates the largest rectangular area under the histogram represented by the list. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_rectangle_areas(test_cases): Given a list of test cases, calculates the largest rectangular area for each. results = [] for n, heights in test_cases: results.append(max_histogram_area(heights)) return results"},{"question":"def canPartition(digits, divisor): Returns whether a partition is possible such that each subarray forms a number divisible by the given divisor. Examples: >>> canPartition([1,0,2,4], 4) True >>> canPartition([7,3,1,6], 3) False >>> canPartition([8,1,2,0], 2) True","solution":"def canPartition(digits, divisor): Returns whether a partition is possible such that each subarray forms a number divisible by the given divisor. def is_valid_partition(index): if index == len(digits): return True num = 0 for i in range(index, len(digits)): num = num * 10 + digits[i] if num % divisor == 0: if is_valid_partition(i + 1): return True return False return is_valid_partition(0)"},{"question":"import heapq from typing import List def findKthLargest(nums: List[int], k: int) -> int: Find the k-th largest element in the list nums. Args: nums (List[int]): A list of integers. k (int): The position (1-based) of the element you need to find. Returns: int: The k-th largest element in the list nums. Example: >>> findKthLargest([3, 2, 1, 5, 6, 4], 2) 5 >>> findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"import heapq def findKthLargest(nums, k): Find the k-th largest element in the list nums. # Transform list into a min-heap heapq.heapify(nums) # Convert the min-heap to a max-heap by making elements negative nums = [-num for num in nums] heapq.heapify(nums) # Extract k elements from the heap to find the k-th largest for _ in range(k - 1): heapq.heappop(nums) return -heapq.heappop(nums)"},{"question":"def is_armstrong_number(n: int) -> bool: Determine if the given integer is an Armstrong number. Parameters: - n: int - The number to check. Returns: - bool - True if the number is an Armstrong number, False otherwise. >>> is_armstrong_number(153) True >>> is_armstrong_number(9474) True >>> is_armstrong_number(9475) False from solution import is_armstrong_number def test_is_armstrong_number(): assert is_armstrong_number(153) == True assert is_armstrong_number(9474) == True assert is_armstrong_number(9475) == False assert is_armstrong_number(0) == True assert is_armstrong_number(1) == True assert is_armstrong_number(370) == True assert is_armstrong_number(371) == True assert is_armstrong_number(407) == True assert is_armstrong_number(123) == False assert is_armstrong_number(8208) == True assert is_armstrong_number(9474) == True assert is_armstrong_number(9926315) == True","solution":"def is_armstrong_number(n): Determine if the given integer is an Armstrong number. Parameters: - n: int - The number to check. Returns: - bool - True if the number is an Armstrong number, False otherwise. num_str = str(n) num_digits = len(num_str) sum_of_powers = sum(int(digit) ** num_digits for digit in num_str) return sum_of_powers == n"},{"question":"def isAnagram(str1: str, str2: str) -> bool: Determines if two given strings are anagrams of each other (case insensitive). >>> isAnagram(\\"Listen\\", \\"Silent\\") True >>> isAnagram(\\"Hello\\", \\"World\\") False >>> isAnagram(\\"Dormitory\\", \\"Dirtyroom\\") True >>> isAnagram(\\"Triangle\\", \\"Integral\\") True >>> isAnagram(\\"A man, a plan, a canal, Panama\\", \\"A man, a plan, a canal, Panama\\") True >>> isAnagram(\\"\\", \\"\\") True >>> isAnagram(\\"a\\", \\"\\") False >>> isAnagram(\\"abc\\", \\"ab\\") False","solution":"def isAnagram(str1, str2): Determines if two given strings are anagrams of each other (case insensitive). # Convert both strings to lower case to make the function case insensitive str1 = str1.lower() str2 = str2.lower() # Sort the characters of both strings sorted_str1 = sorted(str1) sorted_str2 = sorted(str2) # Compare the sorted characters return sorted_str1 == sorted_str2"},{"question":"from typing import List, Tuple def shortest_path(n: int, edges: List[Tuple[int, int, int]]) -> List[int]: Identify the shortest path from city hall (intersection 0) to market (intersection n-1). >>> shortest_path(5, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 3, 3), (3, 4, 1)]) [0, 1, 2, 3, 4] >>> shortest_path(4, [(0, 1, 1), (1, 2, 1)]) []","solution":"import heapq def shortest_path(n, edges): from collections import defaultdict # Create adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find shortest path from 0 to n-1 def dijkstra(source, target): heap = [(0, source, [])] visited = set() while heap: cost, node, path = heapq.heappop(heap) if node in visited: continue visited.add(node) path = path + [node] if node == target: return path for neighbor, weight in graph[node]: if neighbor not in visited: heapq.heappush(heap, (cost + weight, neighbor, path)) return [] return dijkstra(0, n-1)"},{"question":"def find_max_sum_submatrix(grid: List[List[int]]) -> None: Find the submatrix in the given grid with the highest sum of impact values. >>> find_max_sum_submatrix([[1, 2, -1, -4], [-8, 3, 4, 2], [3, 8, -10, 1], [1, -4, 7, -6]]) 3 4 8 -10 -4 7 >>> find_max_sum_submatrix([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -1 >>> find_max_sum_submatrix([[10]]) 10 >>> find_max_sum_submatrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 from typing import List","solution":"def find_max_sum_submatrix(grid): m = len(grid) n = len(grid[0]) max_sum = float('-inf') best_left = best_right = best_up = best_down = 0 for left in range(n): temp = [0] * m for right in range(left, n): for i in range(m): temp[i] += grid[i][right] current_sum = 0 start = 0 for end in range(m): current_sum += temp[end] if current_sum > max_sum: max_sum = current_sum best_left, best_right = left, right best_up, best_down = start, end if current_sum < 0: current_sum = 0 start = end + 1 # Output the resulting submatrix submatrix = [] for i in range(best_up, best_down + 1): submatrix.append(grid[i][best_left:best_right + 1]) for row in submatrix: print(\\" \\".join(map(str, row))) # Sample Input grid = [ [1, 2, -1, -4], [-8, 3, 4, 2], [3, 8, -10, 1], [1, -4, 7, -6] ] find_max_sum_submatrix(grid)"},{"question":"def trap(height: List[int]) -> int: Given a list of non-negative integers representing the heights of columns, returns the maximum amount of water that can be trapped after it rains. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([]) == 0 >>> trap([1, 1, 1, 1]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([2, 0, 2]) == 2 >>> trap([3, 0, 1, 3, 0, 2]) == 7","solution":"def trap(height): Given a list of non-negative integers representing the heights of columns, returns the maximum amount of water that can be trapped after it rains. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def next_palindrome(n: int) -> int: Find the smallest integer greater than the given number that is a palindrome. The number itself is not considered a valid answer if it is already a palindrome. >>> next_palindrome(123) 131 >>> next_palindrome(989) 999 >>> next_palindrome(120) 121","solution":"def next_palindrome(n): Returns the smallest palindrome greater than the given number \`n\`. def is_palindrome(x): s = str(x) return s == s[::-1] num = n + 1 while True: if is_palindrome(num): return num num += 1"},{"question":"def sum_of_two(arr1, arr2, target): Returns true if there exists one element from each array whose sum equals the target, and false otherwise. >>> sum_of_two([1, 2, 3], [10, 20, 30, 40], 42) True >>> sum_of_two([1, 2, 3], [10, 20, 30, 40], 50) False >>> sum_of_two([1], [1], 2) True >>> sum_of_two([1], [1], 3) False >>> sum_of_two([1, 2, 3, 7], [9, 10, 11, 12], 18) True >>> sum_of_two([-1, -2, -3], [1, 2, 3], 0) True >>> sum_of_two([1, 2, -1], [-2, -1, 0], 0) True >>> sum_of_two([1, 2, 3], [4, 5, 6], 0) False >>> arr1 = list(range(1000)) >>> arr2 = list(range(1000)) >>> sum_of_two(arr1, arr2, 1998) True >>> sum_of_two(arr1, arr2, 2000) False","solution":"def sum_of_two(arr1, arr2, target): Returns true if there exists one element from each array whose sum equals the target. complement_set = set() for num in arr1: complement_set.add(target - num) for num in arr2: if num in complement_set: return True return False"},{"question":"def minimum_delivery_route(n: int, delivery_points: List[int]) -> int: Returns the minimum delivery route distance required to return to the starting point after covering all delivery points. >>> minimum_delivery_route(4, [1, 3, 7, 8]) 7 >>> minimum_delivery_route(6, [2, 5, 8, 12, 15, 19]) 17 >>> minimum_delivery_route(3, [0, 4, 9]) 5 >>> minimum_delivery_route(1, [5]) 0 >>> minimum_delivery_route(2, [3, 8]) 5 >>> minimum_delivery_route(3, [1, 2, 3]) 2 >>> minimum_delivery_route(3, [1000000, 5000000, 999999999]) 999999999 - 1000000","solution":"def minimum_delivery_route(n, delivery_points): Returns the minimum delivery route distance required to return to the starting point after covering all delivery points. if n == 1: return 0 delivery_points.sort() # The farthest point is the difference between the last and the first point in sorted order. farthest_distance = delivery_points[-1] - delivery_points[0] # The possible minimum route distance will be either: # 1. Twice the maximum gap (because we go to the farthest point and back) # 2. The direct difference to cover from start to the farthest point. return max(farthest_distance, delivery_points[-1] - delivery_points[0]) # Example usage n = 4 delivery_points = [1, 3, 7, 8] print(minimum_delivery_route(n, delivery_points)) # Should print 7"},{"question":"def findLongestPalindrome(s: str) -> str: Find the longest palindrome subsequence within a string, ignoring spaces, punctuation, and capitalization. >>> findLongestPalindrome(\\"I saw a racecar driving at noon\\") \\"racecar\\" >>> findLongestPalindrome(\\"No lemon, no melon\\") \\"nolemonnomelon\\" >>> findLongestPalindrome(\\"A man, a plan, a canal, Panama!\\") \\"amanaplanacanalpanama\\" >>> findLongestPalindrome(\\"a\\") \\"a\\" >>> findLongestPalindrome(\\"abcde\\") \\"a\\" >>> findLongestPalindrome(\\"\\") \\"\\" >>> findLongestPalindrome(\\"banana\\") \\"anana\\" >>> findLongestPalindrome(\\"123abccba321\\") \\"123abccba321\\"","solution":"import re def findLongestPalindrome(s: str) -> str: def clean_string(s): return re.sub(r'[^A-Za-z0-9]', '', s).lower() def is_palindrome(s): return s == s[::-1] cleaned_s = clean_string(s) n = len(cleaned_s) max_length = 0 longest_palindrome = \\"\\" for i in range(n): for j in range(i, n): substring = cleaned_s[i:j+1] if is_palindrome(substring) and len(substring) > max_length: max_length = len(substring) longest_palindrome = substring return longest_palindrome"},{"question":"def min_total_time(n: int, capacities: List[int]) -> int: Returns the minimum total number of unit time required to distribute tasks to all machines according to their capacities. >>> min_total_time(3, [2, 3, 1]) 6 >>> min_total_time(5, [4, 1, 2, 3, 5]) 15 >>> min_total_time(1, [10]) 10 >>> min_total_time(4, [1, 1, 1, 1]) 4 >>> min_total_time(6, [1, 2, 3, 4, 5, 6]) 21 >>> min_total_time(100000, [1] * 100000) 100000","solution":"def min_total_time(n, capacities): Returns the minimum total number of unit time required to distribute tasks to all machines according to their capacities. return sum(capacities)"},{"question":"def cleaning_schedule(T: int, test_cases: List[Tuple[int, int]]) -> List[Tuple[int, List[Tuple[int, int]]]]: Determine the minimum number of days required to clean all the rooms in the building and the rooms that should be cleaned on each of these days. Args: - T (int): The number of test cases. - test_cases (List[Tuple[int, int]]): Each tuple contains two integers N (number of floors) and M (number of rooms per floor). Returns: - List[Tuple[int, List[Tuple[int, int]]]]: For each test case, return a tuple containing an integer K (the minimum number of days) and K lists of pairs of integers representing the rooms to clean on each day. Example: >>> cleaning_schedule(1, [(3, 4)]) [(2, [(1, 2), (1, 4), (2, 2), (2, 4), (3, 2), (3, 4)], [(1, 1), (1, 3), (2, 1), (2, 3), (3, 1), (3, 3)])] >>> cleaning_schedule(1, [(1, 1)]) [(2, [], [(1, 1)])]","solution":"def cleaning_schedule(T, test_cases): Function to determine the cleaning schedule. Args: - T (int): number of test cases. - test_cases (list of tuples): each tuple contains two integers N (number of floors) and M (number of rooms per floor). Returns: - list of tuples: each tuple contains the number of days and the schedule for cleaning. results = [] for N, M in test_cases: days = 2 day1_rooms = [] day2_rooms = [] for i in range(1, N+1): for j in range(1, M+1): if j % 2 == 0: day1_rooms.append((i, j)) else: day2_rooms.append((i, j)) results.append((days, day1_rooms, day2_rooms)) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a fully parenthesized mathematical expression containing positive integers and +, -, *, / operators. >>> evaluate_expression(\\"1+2\\") 3 >>> evaluate_expression(\\"(1+2+3)\\") 6 >>> evaluate_expression(\\"((1+2)*(3-1))\\") 6 >>> evaluate_expression(\\"((2+3)/5)\\") 1 pass","solution":"def evaluate_expression(expression: str) -> int: def helper(s): stack = [] num = 0 prev_op = '+' while len(s) > 0: c = s.pop(0) if c.isdigit(): num = num * 10 + int(c) if c == '(': num = helper(s) if (not c.isdigit() and c != ' ' and c != '(') or len(s) == 0: if prev_op == '+': stack.append(num) elif prev_op == '-': stack.append(-num) elif prev_op == '*': stack.append(stack.pop() * num) elif prev_op == '/': stack.append(int(stack.pop() / num)) # integer division prev_op = c num = 0 if c == ')': break return sum(stack) return helper(list(expression)) # Examples print(evaluate_expression(\\"1+2\\")) # Output: 3 print(evaluate_expression(\\"(1+2+3)\\")) # Output: 6 print(evaluate_expression(\\"((1+2)*(3-1))\\")) # Output: 6 print(evaluate_expression(\\"((2+3)/5)\\")) # Output: 1"},{"question":"def calculate_tree_depths(n, edges): For the given number of servers (n) and their connections (edges), calculate the depths of each node in the tree. >>> calculate_tree_depths(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) [-1, 0, 1, 1, 2, 2] pass def minimum_servers_to_isolate(n, edges, scenarios): For the given number of servers (n), their connections (edges), and the scenarios of sensitive servers, find the minimum number of servers to disable to isolate each sensitive server. >>> minimum_servers_to_isolate(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [3, 4, 5]) [1, 2, 2] >>> minimum_servers_to_isolate(1, [], [1]) [0] >>> minimum_servers_to_isolate(6, [(1, 2), (1, 3), (2, 4), (2, 5), (4, 6)], [1, 2, 3, 4, 5, 6]) [0, 1, 1, 2, 2, 3] >>> calculate_tree_depths(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) [-1, 0, 1, 1, 2, 2, 2, 2] pass","solution":"def calculate_tree_depths(n, edges): from collections import deque, defaultdict tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) depths = [-1] * (n + 1) queue = deque([(1, 0)]) depths[1] = 0 while queue: node, depth = queue.popleft() for neighbor in tree[node]: if depths[neighbor] == -1: depths[neighbor] = depth + 1 queue.append((neighbor, depth + 1)) return depths def minimum_servers_to_isolate(n, edges, scenarios): depths = calculate_tree_depths(n, edges) return [depths[s] for s in scenarios]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression and returns the result as an integer. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"10/2+3*4\\") 17 >>> evaluate_expression(\\"20%(2+3)\\") 0 # Test cases def test_simple_addition(): assert evaluate_expression(\\"2+3\\") == 5 def test_simple_subtraction(): assert evaluate_expression(\\"5-2\\") == 3 def test_precedence_multiplication_over_addition(): assert evaluate_expression(\\"3+5*2\\") == 13 def test_parentheses(): assert evaluate_expression(\\"(2+3)*4\\") == 20 def test_combined_operations(): assert evaluate_expression(\\"10/2+3*4\\") == 17 def test_modulo_operation(): assert evaluate_expression(\\"20%(2+3)\\") == 0 def test_nested_parentheses(): assert evaluate_expression(\\"((2+3)*4-5)/5\\") == 3 def test_complex_expression(): assert evaluate_expression(\\"10-3*2+(8/2)\\") == 8 def test_whitespace_handling(): assert evaluate_expression(\\" 3 + 5 * 2 \\") == 13","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression and returns the result as an integer. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/' or op == '%': return 2 return 0 def apply_op(operands, operators): right = operands.pop() left = operands.pop() op = operators.pop() if op == '+': operands.append(left + right) elif op == '-': operands.append(left - right) elif op == '*': operands.append(left * right) elif op == '/': operands.append(left // right) # Integer division elif op == '%': operands.append(left % right) def evaluate(tokens): operands = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue elif tokens[i] == '(': operators.append(tokens[i]) elif tokens[i].isdigit(): num = 0 while i < len(tokens) and tokens[i].isdigit(): num = num * 10 + int(tokens[i]) i += 1 operands.append(num) i -= 1 elif tokens[i] == ')': while len(operators) != 0 and operators[-1] != '(': apply_op(operands, operators) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(tokens[i])): apply_op(operands, operators) operators.append(tokens[i]) i += 1 while len(operators) != 0: apply_op(operands, operators) return operands[-1] return evaluate(expression)"},{"question":"def maxProfit(k: int, prices: List[int]) -> int: Given an array of integers A, return the maximum profit that can be achieved by buying and selling stocks. You are allowed to complete at most k transactions. Example 1: >>> maxProfit(2, [3,2,6,5,0,3]) 7 Example 2: >>> maxProfit(2, [2, 4, 1]) 2","solution":"def maxProfit(k, prices): if not prices or k == 0: return 0 n = len(prices) # If k is greater than n//2, it is equivalent to infinite transactions if k >= n // 2: return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_so_far = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j-1], prices[j] + max_so_far) max_so_far = max(max_so_far, dp[i-1][j] - prices[j]) return dp[k][n-1]"},{"question":"def first_unique_char(s: str) -> int: Find the first non-repeating character in the string and return its index. If all characters are repeating, return -1. Examples: >>> first_unique_char(\\"leetcode\\") 0 >>> first_unique_char(\\"loveleetcode\\") 2 >>> first_unique_char(\\"aabb\\") -1","solution":"def first_unique_char(s: str) -> int: Find the first non-repeating character in the string and return its index. If all characters are repeating, return -1. char_count = {} # Count the occurrences of each character for char in s: char_count[char] = char_count.get(char, 0) + 1 # Find the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"from typing import List, Tuple def count_tree_clusters(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: You are given a grid of size N x M. Each cell of the grid contains a lowercase English letter. The grid represents a map of a forest where some areas are covered by trees and some are clear. This function counts the number of distinct tree clusters in the forest. A tree cluster is defined as a group of adjacent cells containing the same tree letter. Cells are considered adjacent if they share a common edge (up, down, left, or right). Args: T: The number of test cases. test_cases: A list of tuples, each containing: - Two integers N and M. - A list of N strings, each of length M, representing the grid. Returns: A list of integers, each representing the number of distinct tree clusters for each test case. >>> count_tree_clusters(1, [(3, 3, [\\"aaa\\", \\"abb\\", \\"aab\\"])]) [2] >>> count_tree_clusters(1, [(4, 4, [\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"])]) [16] pass def test_single_cluster(): T = 1 test_cases = [(3, 3, [\\"aaa\\", \\"abb\\", \\"aab\\"])] result = count_tree_clusters(T, test_cases) assert result == [2] def test_multiple_clusters(): T = 1 test_cases = [(4, 4, [\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"])] result = count_tree_clusters(T, test_cases) assert result == [16] def test_large_single_cluster(): T = 1 test_cases = [(3, 3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"])] result = count_tree_clusters(T, test_cases) assert result == [1] def test_disjoint_clusters(): T = 1 test_cases = [(2, 4, [\\"aabb\\", \\"aabb\\"])] result = count_tree_clusters(T, test_cases) assert result == [2] def test_single_row_multiple_clusters(): T = 1 test_cases = [(1, 5, [\\"abcde\\"])] result = count_tree_clusters(T, test_cases) assert result == [5] def test_single_column_multiple_clusters(): T = 1 test_cases = [(5, 1, [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"])] result = count_tree_clusters(T, test_cases) assert result == [5] def test_no_trees(): T = 1 test_cases = [(1, 1, [\\"a\\"])] result = count_tree_clusters(T, test_cases) assert result == [1]","solution":"def count_tree_clusters(T, test_cases): def dfs(grid, x, y, visited, N, M, letter): stack = [(x, y)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while stack: i, j = stack.pop() for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < N and 0 <= nj < M and not visited[ni][nj] and grid[ni][nj] == letter: visited[ni][nj] = True stack.append((ni, nj)) results = [] for N, M, grid in test_cases: visited = [[False] * M for _ in range(N)] cluster_count = 0 for i in range(N): for j in range(M): if not visited[i][j]: visited[i][j] = True dfs(grid, i, j, visited, N, M, grid[i][j]) cluster_count += 1 results.append(cluster_count) return results"},{"question":"def longest_increasing_subsequence(heights: List[int]) -> int: Returns the length of the longest strictly increasing subsequence of heights. >>> longest_increasing_subsequence([3, 4, 5, 1, 2, 8]) 4 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> longest_increasing_subsequence([5, 3, 4, 8, 6, 7]) 4 >>> longest_increasing_subsequence([1, 2, 2, 3, 4]) 4 >>> longest_increasing_subsequence([3, 3, 3, 3, 3, 3]) 1 >>> longest_increasing_subsequence([9, 8, 7, 6, 5]) 1 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([100, 200, 300, 400, 500]) 5","solution":"def longest_increasing_subsequence(heights): Returns the length of the longest strictly increasing subsequence of heights. if not heights: return 0 # Array to store the length of the longest increasing subsequence up to each position lis = [1] * len(heights) # Build the \`lis\` array for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n. Uses the Sieve of Eratosthenes algorithm for efficient computation. >>> sieve_of_eratosthenes(1) == [] >>> sieve_of_eratosthenes(2) == [2] >>> sieve_of_eratosthenes(3) == [2, 3] >>> sieve_of_eratosthenes(10) == [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> sieve_of_eratosthenes(100) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> sieve_of_eratosthenes(0) == [] >>> sieve_of_eratosthenes(-10) == []","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n. Uses the Sieve of Eratosthenes algorithm for efficient computation. if n < 2: return [] sieve = [True] * (n + 1) sieve[0], sieve[1] = False, False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n+1, start): sieve[multiple] = False return [num for num in range(n + 1) if sieve[num]]"},{"question":"def can_cut_tree(total_length: int, required_lengths: List[int]) -> bool: Determine if it is possible to meet the demand of required lengths from the total length of the tree. >>> can_cut_tree(20, [4, 5, 6, 5]) True >>> can_cut_tree(15, [2, 6, 10]) False def check_tree_cutting_possibility(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: For each test case, determine if it's possible to cut the tree into the required lengths exactly. >>> check_tree_cutting_possibility(2, [(20, [4, 5, 6, 5]), (15, [2, 6, 10])]) [\\"YES\\", \\"NO\\"] >>> check_tree_cutting_possibility(1, [(10, [1, 2, 3, 4])]) [\\"YES\\"] from typing import List, Tuple # You can use the following test cases to validate your solution def test_can_cut_tree(): assert can_cut_tree(20, [4, 5, 6, 5]) == True assert can_cut_tree(15, [2, 6, 10]) == False assert can_cut_tree(10, [1, 2, 3, 4]) == True assert can_cut_tree(100, [50, 50]) == True assert can_cut_tree(50, [25, 25, 1]) == False def test_check_tree_cutting_possibility(): assert check_tree_cutting_possibility(2, [(20, [4, 5, 6, 5]), (15, [2, 6, 10])]) == [\\"YES\\", \\"NO\\"] assert check_tree_cutting_possibility(1, [(10, [1, 2, 3, 4])]) == [\\"YES\\"] assert check_tree_cutting_possibility(3, [(15, [5, 5, 5]), (30, [10, 10, 10]), (25, [10, 10, 5])]) == [\\"YES\\", \\"YES\\", \\"YES\\"] assert check_tree_cutting_possibility(1, [(50, [25, 25, 25])]) == [\\"NO\\"]","solution":"def can_cut_tree(total_length, required_lengths): Determine if it is possible to meet the demand of required_lengths from the total_length of the tree. return sum(required_lengths) == total_length def check_tree_cutting_possibility(T, test_cases): results = [] for case in test_cases: total_length, required_lengths = case if can_cut_tree(total_length, required_lengths): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_valid_license_plate(plate: str) -> bool: Returns whether the input string is a valid license plate number or not. A valid license plate number follows these rules: - It contains exactly 6 or 7 characters. - The first character must be an uppercase English letter. - The remaining characters must be all digits. >>> is_valid_license_plate(\\"X123456\\") True >>> is_valid_license_plate(\\"A12345\\") True >>> is_valid_license_plate(\\"1234567\\") False >>> is_valid_license_plate(\\"a123456\\") False >>> is_valid_license_plate(\\"ABCDE12\\") False","solution":"def is_valid_license_plate(plate): Returns whether the input string is a valid license plate number or not. A valid license plate number follows these rules: - It contains exactly 6 or 7 characters. - The first character must be an uppercase English letter. - The remaining characters must be all digits. if len(plate) == 6 or len(plate) == 7: if plate[0].isupper() and plate[0].isalpha() and plate[1:].isdigit(): return True return False"},{"question":"def min_operations_to_delete_string(s: str) -> int: Given a string s, return the minimum number of operations required to delete all characters in the string. In one operation, you can choose a non-empty substring t of s such that all the characters in t are the same and remove it from s. >>> min_operations_to_delete_string(\\"aaabbcc\\") 3 >>> min_operations_to_delete_string(\\"abc\\") 3 >>> min_operations_to_delete_string(\\"aabbccddeeff\\") 6 >>> min_operations_to_delete_string(\\"zzz\\") 1","solution":"def min_operations_to_delete_string(s): Returns the minimum number of operations required to delete all characters in the string. if not s: return 0 # Initialize the count of operations with 1 (for the first character of any string) operations = 1 # Loop through the string and count transitions between different characters for i in range(1, len(s)): if s[i] != s[i - 1]: operations += 1 return operations"},{"question":"from typing import List, Tuple def longest_subarray_with_two_distinct(nums: List[int]) -> int: Given an array of integers, return the length of the longest subarray that contains at most two distinct integers. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 4]) 4 >>> longest_subarray_with_two_distinct([1, 2, 2, 1]) 4 >>> longest_subarray_with_two_distinct([5, 5, 5, 5, 5]) 5 >>> longest_subarray_with_two_distinct([1]) 1 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_two_distinct([]) 0 def process_queries(T: int, query_list: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases, returning the length of the longest subarray with at most two distinct integers for each test case. >>> process_queries(3, [(6, [1, 2, 1, 2, 3, 4]), (4, [1, 2, 2, 1]), (5, [5, 5, 5, 5, 5])]) [4, 4, 5] >>> process_queries(2, [(5, [1, 3, 3, 1, 2]), (7, [1, 2, 1, 3, 4, 3, 5])]) [4, 3]","solution":"def longest_subarray_with_two_distinct(nums): Given an array of integers, return the length of the longest subarray that contains at most two distinct integers. n = len(nums) if n == 0: return 0 max_length = 0 left = 0 count = {} for right in range(n): if nums[right] in count: count[nums[right]] += 1 else: count[nums[right]] = 1 while len(count) > 2: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length def process_queries(T, query_list): results = [] for i in range(T): N = query_list[i][0] array = query_list[i][1] result = longest_subarray_with_two_distinct(array) results.append(result) return results"},{"question":"def isValidXYZCode(s: str) -> bool: Checks if the given string s is a valid 'XYZ-code'. >>> isValidXYZCode(\\"abcXdefYghiZjkl\\") True >>> isValidXYZCode(\\"YabcXZ\\") False >>> isValidXYZCode(\\"ZZYX\\") False >>> isValidXYZCode(\\"XyyyyyZZZZZZ\\") False >>> isValidXYZCode(\\"abcX\\") False >>> isValidXYZCode(\\"XYZ\\") True >>> isValidXYZCode(\\"abcYdefZghi\\") False >>> isValidXYZCode(\\"XabcYdefghi\\") False >>> isValidXYZCode(\\"abcdefghi\\") False >>> isValidXYZCode(\\"XXYXYZZ\\") True >>> isValidXYZCode(\\"XZY\\") False pass","solution":"def isValidXYZCode(s): Returns True if the string s is a valid 'XYZ-code', False otherwise. found_X = found_Y = found_Z = False for char in s: if char == 'X': found_X = True elif char == 'Y' and found_X: found_Y = True elif char == 'Z' and found_Y: found_Z = True break return found_X and found_Y and found_Z"},{"question":"def max_subarray_sum(N: int, array: List[int]) -> int: Given an array of integers, find the sum of the maximum subarray. A subarray is a contiguous part of an array. The goal is to choose a subarray with the highest sum among all possible subarrays. Parameters: N (int): The size of the array. array (list): List of integers. Returns: int: The sum of the maximum subarray. Examples: >>> max_subarray_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(1, [5]) 5 >>> max_subarray_sum(4, [-1, -2, -3, -4]) -1 import pytest from solution import max_subarray_sum def test_max_subarray_sum_example(): assert max_subarray_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_max_subarray_sum_single_element(): assert max_subarray_sum(1, [5]) == 5 assert max_subarray_sum(1, [-5]) == -5 def test_max_subarray_sum_all_negative(): assert max_subarray_sum(4, [-1, -2, -3, -4]) == -1 def test_max_subarray_sum_mixed_values(): assert max_subarray_sum(5, [1, -2, 3, 10, -4, 7, 2, -5]) == 18 def test_max_subarray_sum_large_input(): large_array = [1] * 10**5 # Large array with all elements as 1 assert max_subarray_sum(10**5, large_array) == 10**5","solution":"def max_subarray_sum(N, array): Given an integer N and an array of integers, returns the sum of the maximum subarray. Parameters: N (int): The size of the array. array (list): List of integers. Returns: int: The sum of the maximum subarray. max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def longest_hill(arr: List[int]) -> int: Given an array of integers, return the length of the longest hill in the array. If there are no hills, return 0. A \\"hill\\" is defined as a set of consecutive integers in the array that steadily increases to a peak and then steadily decreases. A peak is the highest value in that set. Examples: >>> longest_hill([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_hill([1, 2, 3, 4, 5, 6]) 0 >>> longest_hill([4, 3, 2, 1]) 0 >>> longest_hill([2, 1, 2, 1, 2, 1, 2, 1]) 3","solution":"def longest_hill(arr): max_len = 0 n = len(arr) if n < 3: return 0 i = 1 while i < n - 1: if arr[i-1] < arr[i] > arr[i+1]: left = i - 1 while left > 0 and arr[left-1] < arr[left]: left -= 1 right = i + 1 while right < n - 1 and arr[right] > arr[right+1]: right += 1 current_len = right - left + 1 max_len = max(max_len, current_len) i = right else: i += 1 return max_len"},{"question":"import re from typing import List def count_unique_words(text: str) -> int: Returns the number of unique words in the string \`text\`. Words are case-insensitive and punctuation is ignored. >>> count_unique_words(\\"\\") 0 >>> count_unique_words(\\"Hello\\") 1 >>> count_unique_words(\\"Hello hello HeLLo\\") 1 >>> count_unique_words(\\"Hello world!\\") 2 >>> count_unique_words(\\"Hello, world! Hello again.\\") 3 >>> count_unique_words(\\"Cat dog cat. Dog!\\") 2","solution":"import re def count_unique_words(text): Returns the number of unique words in the string \`text\`. Words are case-insensitive and punctuation is ignored. words = re.findall(r'bw+b', text.lower()) unique_words = set(words) return len(unique_words)"},{"question":"def isPalindrome(data): Returns True if the input data (string or number) is a palindrome, otherwise False. Returns False for any other type of data. >>> isPalindrome(\\"madam\\") == True >>> isPalindrome(\\"hello\\") == False >>> isPalindrome(12321) == True >>> isPalindrome(12345) == False >>> isPalindrome([1, 2, 2, 1]) == False >>> isPalindrome(\\"\\") == True >>> isPalindrome(12.21) == False","solution":"def isPalindrome(data): Returns True if the input data (string or number) is a palindrome, otherwise False. Returns False for any other type of data. # Check if the data is a string or an integer if isinstance(data, (str, int)): # Convert the data to a string and compare it with its reverse return str(data) == str(data)[::-1] else: # Return False for any other type of data return False"},{"question":"def length_of_longest_substring(s: str) -> int: Implement a function that takes an input string \`s\` and returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\" \\") 1 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 pass","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: Input string :return: Length of the longest substring without repeating characters char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(char_map[s[right]] + 1, left) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def calculate_message_hash(message: str) -> int: Calculate the hash value of a given message based on the ASCII values of the characters and their positions in the message. The message should only contain alphanumeric characters and spaces. If the input contains any other characters, the function should return 0. >>> calculate_message_hash(\\"Hello World\\") == 6480 >>> calculate_message_hash(\\"\\") == 0 >>> calculate_message_hash(\\"A\\") == 65 >>> calculate_message_hash(\\"a\\") == 97 >>> calculate_message_hash(\\"Aa1 \\") == 65 + 2*97 + 3*49 + 4*32 >>> calculate_message_hash(\\"Hello!\\") == 0 >>> calculate_message_hash(\\"Test@123\\") == 0 >>> calculate_message_hash(\\"12345\\") == sum((i * (48 + i)) for i in range(1, 6)) >>> calculate_message_hash(\\"aaa\\") == 97 + 2*97 + 3*97","solution":"def calculate_message_hash(message: str) -> int: Calculate the hash value of a given message based on the ASCII values of the characters and their positions in the message. Parameters: message (str): The message to calculate the hash for. Returns: int: The calculated hash value, or 0 if the message contains invalid characters. allowed_chars = set(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \\") if any(char not in allowed_chars for char in message): return 0 hash_value = 0 for position, char in enumerate(message, start=1): hash_value += position * ord(char) return hash_value"},{"question":"def rearrange_array(arr: List[int]) -> List[int]: Rearranges the elements of the array such that the absolute difference between any two adjacent elements is minimized. Args: arr : list of int Returns: list of int Example: >>> rearrange_array([1, 3, 2, 4]) [1, 2, 3, 4] >>> rearrange_array([10, -10, 5, 7, 3]) [-10, 3, 5, 7, 10] def test_basic_case(): assert rearrange_array([1, 3, 2, 4]) == [1, 2, 3, 4] def test_case_with_negative_numbers(): assert rearrange_array([10, -10, 5, 7, 3]) == [-10, 3, 5, 7, 10] def test_case_with_duplicates(): assert rearrange_array([4, 2, 1, 4, 3]) == [1, 2, 3, 4, 4] def test_already_sorted_array(): assert rearrange_array([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_reversed_array(): assert rearrange_array([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_single_element_array(): # Even though constraints said N >= 2, we include this for robustness assert rearrange_array([1]) == [1] def test_large_range(): assert rearrange_array([1000, -1000, 0]) == [-1000, 0, 1000]","solution":"def rearrange_array(arr): Rearranges the elements of the array such that the absolute difference between any two adjacent elements is minimized. Args: arr : list of int Returns: list of int return sorted(arr)"},{"question":"def max_consecutive_blooming(n: int, flower_row: str) -> int: Returns the maximum number of consecutive blooming flowers in the row. Parameters: n (int): The number of flowers. flower_row (str): A string representing the flowers where 'B' is blooming and 'N' is not blooming. Returns: int: The maximum number of consecutive blooming flowers. >>> max_consecutive_blooming(8, 'BBNNBBBN') 3 >>> max_consecutive_blooming(5, 'BBBBB') 5 >>> max_consecutive_blooming(5, 'NNNNN') 0 >>> max_consecutive_blooming(6, 'BNBNBN') 1 >>> max_consecutive_blooming(1, 'B') 1 >>> max_consecutive_blooming(1, 'N') 0 >>> max_consecutive_blooming(12, 'BNNNBBBBBNNB') 5","solution":"def max_consecutive_blooming(n, flower_row): Returns the maximum number of consecutive blooming flowers in the row. Parameters: n (int): The number of flowers. flower_row (str): A string representing the flowers where 'B' is blooming and 'N' is not blooming. Returns: int: The maximum number of consecutive blooming flowers. max_blooming = 0 current_blooming = 0 for flower in flower_row: if flower == 'B': current_blooming += 1 max_blooming = max(max_blooming, current_blooming) else: current_blooming = 0 return max_blooming"},{"question":"def arrange_participants(skill_ratings): Arranges the skill ratings of participants in the order that minimizes the total difference between consecutive participants. Parameters: skill_ratings (list): A list of integers representing the skill ratings of participants. Returns: list: The skill ratings arranged to minimize the difference between consecutive participants. pass # Unit Tests def test_basic_case(): assert arrange_participants([4, 2, 1, 3, 6]) == [1, 2, 3, 4, 6] def test_three_participants(): assert arrange_participants([10, 1, 20]) == [1, 10, 20] def test_already_sorted(): assert arrange_participants([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_reverse_sorted(): assert arrange_participants([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_identical_numbers(): assert arrange_participants([3, 3, 3, 3]) == [3, 3, 3, 3] def test_two_participants(): assert arrange_participants([5, 9]) == [5, 9] def test_max_numbers(): assert arrange_participants([1000000000, 1]) == [1, 1000000000]","solution":"def arrange_participants(skill_ratings): Arranges the skill ratings of participants in the order that minimizes the total difference between consecutive participants. Parameters: skill_ratings (list): A list of integers representing the skill ratings of participants. Returns: list: The skill ratings arranged to minimize the difference between consecutive participants. return sorted(skill_ratings)"},{"question":"def caesar_cipher(S: str, K: int) -> str: Transforms the given string S by rotating each alphabetic character by K positions. Non-alphabetic characters are not changed. >>> caesar_cipher(\\"Hello, World!\\", 5) 'Mjqqt, Btwqi!' >>> caesar_cipher(\\"abcXYZ\\", 2) 'cdeZAB' >>> caesar_cipher(\\"Python3.8\\", 10) 'Zidryx3.8'","solution":"def caesar_cipher(S, K): Transforms the given string S by rotating each alphabetic character by K positions. Non-alphabetic characters are not changed. result = [] for char in S: if char.isalpha(): # Determine if the character is uppercase or lowercase offset = 65 if char.isupper() else 97 # Perform the rotation rotated_char = chr((ord(char) - offset + K) % 26 + offset) result.append(rotated_char) else: result.append(char) return ''.join(result)"},{"question":"def minDistance(s1: str, s2: str) -> int: Calculate the minimum number of operations required to convert s1 to s2. Args: s1 (str): First string. s2 (str): Second string. Returns: int: The minimum number of operations required to convert s1 to s2. Examples: >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"abc\\", \\"abc\\") 0 >>> minDistance(\\"abc\\", \\"\\") 3 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"\\", \\"\\") 0","solution":"def minDistance(s1, s2): Calculate the minimum number of operations required to convert s1 to s2. Args: s1 (str): First string. s2 (str): Second string. Returns: int: The minimum number of operations required to convert s1 to s2. m, n = len(s1), len(s2) # Create a 2D DP array with (m+1) x (n+1) dimensions dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(1, m + 1): dp[i][0] = i # cost of deleting all characters in s1 for j in range(1, n + 1): dp[0][j] = j # cost of adding all characters to s1 to match s2 # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no extra cost else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete (from s1) dp[i][j - 1], # Insert (to s1) dp[i - 1][j - 1])# Replace (from s1) return dp[m][n]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing integers, +, -, *, and /. The division operator (/) represents integer division. Arguments: expression -- a string containing the mathematical expression. Returns: Result of the integer evaluation of the expression. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3 + 5 / 2 \\") 5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers, +, -, *, and /. The division operator (/) represents integer division. import re # Remove whitespace expression = expression.replace(\\" \\", \\"\\") # Split numbers and operators numbers = list(map(int, re.split('[+-*/]', expression))) operators = re.findall('[+-*/]', expression) # Priority of operations: First *, / index = 0 while index < len(operators): if operators[index] in '*/': if operators[index] == '*': result = numbers[index] * numbers[index + 1] else: result = numbers[index] // numbers[index + 1] numbers[index] = result del numbers[index + 1] del operators[index] else: index += 1 # Now the remaining operations are +, - result = numbers[0] for i in range(len(operators)): if operators[i] == '+': result += numbers[i + 1] else: result -= numbers[i + 1] return result"},{"question":"from typing import List def interpolate_missing_heights(heights: List[int]) -> List[int]: Given a list representing the plant's height recorded each day, where \`None\` indicates a missing recording, return a list where the missing heights have been filled in using linear interpolation. >>> interpolate_missing_heights([1, 2, None, 4]) [1, 2, 3, 4] >>> interpolate_missing_heights([None, None, 3, None, 5, None, 7]) [3, 3, 3, 4, 5, 6, 7] >>> interpolate_missing_heights([1, None, None, 4, None, 6, 7]) [1, 2, 3, 4, 5, 6, 7]","solution":"def interpolate_missing_heights(heights): n = len(heights) result = heights[:] for i in range(n): if heights[i] is None: # find nearest previous and next non-None values prev_idx, next_idx = i - 1, i + 1 while prev_idx >= 0 and heights[prev_idx] is None: prev_idx -= 1 while next_idx < n and heights[next_idx] is None: next_idx += 1 if prev_idx < 0: result[i] = heights[next_idx] elif next_idx >= n: result[i] = heights[prev_idx] else: # linear interpolation formula prev_value = heights[prev_idx] next_value = heights[next_idx] distance = next_idx - prev_idx result[i] = prev_value + (next_value - prev_value) * (i - prev_idx) / distance return result"},{"question":"def check_input(input_value): Checks if the input value is a palindrome if it's a string, returns the square if it is an integer, and returns 'Invalid input' for any other type. >>> check_input(\\"racecar\\") True >>> check_input(\\"hello\\") False >>> check_input(4) 16 >>> check_input(-3) 9 >>> check_input(3.14) \\"Invalid input\\" >>> check_input(['a', 'b', 'c']) \\"Invalid input\\" >>> check_input(None) \\"Invalid input\\" >>> check_input(\\"\\") True","solution":"def check_input(input_value): Checks if the input value is a palindrome if it's a string, returns the square if it is an integer, and returns 'Invalid input' for any other type. if isinstance(input_value, str): return input_value == input_value[::-1] elif isinstance(input_value, int): return input_value ** 2 else: return \\"Invalid input\\""},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit that can be achieved from a single buy and sell operation. :param prices: List of daily stock prices. :return: Maximum profit possible. If no profit is possible, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0","solution":"def max_profit(prices): Calculate the maximum profit that can be achieved from a single buy and sell operation. :param prices: List of daily stock prices. :return: Maximum profit possible. If no profit is possible, return 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def find_words(words): Returns a list of words that can be typed using letters of a single row on an English QWERTY keyboard. Consider the rows of the keyboard as follows: - First row: \\"qwertyuiop\\" - Second row: \\"asdfghjkl\\" - Third row: \\"zxcvbnm\\" >>> find_words([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) [\\"Alaska\\", \\"Dad\\"] >>> find_words([]) [] >>> find_words([\\"Test\\", \\"Quiz\\"]) [] >>> find_words([\\"qwerty\\", \\"dada\\", \\"zzzz\\"]) [\\"qwerty\\", \\"dada\\", \\"zzzz\\"] >>> find_words([\\"QwErTy\\", \\"DaDA\\", \\"ZZZZ\\"]) [\\"QwErTy\\", \\"DaDA\\", \\"ZZZZ\\"]","solution":"def find_words(words): Returns a list of words that can be typed using letters of a single row on an English QWERTY keyboard. first_row = set(\\"qwertyuiop\\") second_row = set(\\"asdfghjkl\\") third_row = set(\\"zxcvbnm\\") def can_be_typed_with_one_row(word): lower_word = set(word.lower()) return (lower_word.issubset(first_row) or lower_word.issubset(second_row) or lower_word.issubset(third_row)) return [word for word in words if can_be_typed_with_one_row(word)]"},{"question":"from typing import List def max_profit_with_two_transactions(prices: List[int]) -> int: Given an array of integers \`prices\` representing stock prices on different days, find and return the maximum profit you can make by completing at most two transactions. A transaction consists of buying and then selling one share of the stock. Note that you cannot engage in multiple transactions at the same time, that is, you must sell the stock before you buy it again. Example: >>> max_profit_with_two_transactions([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit_with_two_transactions([1, 2, 3, 4, 5]) 4 >>> max_profit_with_two_transactions([7, 6, 4, 3, 1]) 0 >>> max_profit_with_two_transactions([1]) 0 >>> max_profit_with_two_transactions([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) 13","solution":"def max_profit_with_two_transactions(prices): if not prices or len(prices) < 2: return 0 N = len(prices) # Initialize arrays to store the maximum profit up to each day left_profits = [0] * N right_profits = [0] * N # Forward pass: calculate max profit if we only make one transaction until day i min_price = prices[0] for i in range(1, N): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i-1], prices[i] - min_price) # Backward pass: calculate max profit if we only make one transaction from day i to end max_price = prices[N-1] for i in range(N-2, -1, -1): max_price = max(max_price, prices[i]) right_profits[i] = max(right_profits[i+1], max_price - prices[i]) # Calculate the maximum profit by combining the two portions max_profit = 0 for i in range(N): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"def max_profit(prices: list[int]) -> int: Returns the maximum profit that can be achieved by making at most one buy and one sell transaction. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([5]) == 0 >>> max_profit([1, 5]) == 4 >>> max_profit([5, 1]) == 0 >>> max_profit([5, 5, 5, 5, 5]) == 0 >>> max_profit([10, 22, 5, 75, 65, 80]) == 75","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by making at most one buy and one sell transaction. If no profit is possible, returns 0. if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def find_missing_number(arr: List[int]) -> int: Returns the missing number from the list of integers in the range of 1 to n+1. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 >>> find_missing_number([1, 2, 4, 6, 3, 7, 8]) == 5","solution":"def find_missing_number(arr): Returns the missing number from the list of integers in the range of 1 to n+1. n = len(arr) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"from typing import List def first_non_repeating(nums: List[int]) -> int: Returns the first non-repeating element in the array. If no such element exists, returns -1. >>> first_non_repeating([4, 5, 1, 2, 0, 4]) 5 >>> first_non_repeating([7, 7, 7, 8, 8, 8]) -1 >>> first_non_repeating([7, 3, 5, 4, 5, 3, 4, 10]) 7 >>> first_non_repeating([1]) 1 pass","solution":"def first_non_repeating(nums): Returns the first non-repeating element in the array. If no such element exists, returns -1. frequency = {} # First pass to count the frequency of each element for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Second pass to find the first non-repeating element for num in nums: if frequency[num] == 1: return num return -1"},{"question":"def can_form_sequence(observations): Determines if it is possible to form a continuous sequence from 0 to the highest number in the observations. Args: observations (list of int): List of non-negative integers. Returns: bool: True if a continuous sequence can be formed, otherwise False. Examples: >>> can_form_sequence([9, 1, 3, 0, 6]) False >>> can_form_sequence([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) True","solution":"def can_form_sequence(observations): Determines if it is possible to form a continuous sequence from 0 to the highest number in the observations. Args: observations (list of int): List of non-negative integers. Returns: bool: True if a continuous sequence can be formed, otherwise False. if not observations: return False max_num = max(observations) expected_set = set(range(max_num + 1)) observations_set = set(observations) return expected_set == observations_set"},{"question":"from typing import List from collections import Counter from heapq import heappop, heappush def rearrange_string(S: str, K: int) -> str: Given a string S containing only lowercase alphabets and an integer K, determine whether it is possible to rearrange the characters in S such that the same characters are at least K distance apart. Return the rearranged string if possible, otherwise return an empty string. >>> rearrange_string(\\"aabbcc\\", 2) \\"abcabc\\" >>> rearrange_string(\\"aaabc\\", 3) \\"\\" >>> rearrange_string(\\"aabbcc\\", 0) \\"aabbcc\\" >>> rearrange_string(\\"aabbcc\\", 1) \\"abcabc\\" >>> rearrange_string(\\"aaabb\\", 2) in [\\"ababa\\", \\"abbaa\\"] >>> rearrange_string(\\"aaa\\", 2) \\"\\" >>> rearrange_string(\\"abb\\", 2) in [\\"bab\\", \\"bba\\"]","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(S, K): if K == 0: return S # No need to rearrange if K is 0 counter = Counter(S) max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) wait_queue = [] result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) wait_queue.append((freq + 1, char)) # Decrement frequency (stored as negative) if len(wait_queue) >= K: freq, char = wait_queue.pop(0) if -freq > 0: heappush(max_heap, (freq, char)) return ''.join(result) if len(result) == len(S) else \\"\\""},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequently occurring character in the string \`s\`. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. Returns None if the input string is empty. >>> most_frequent_character(\\"a\\") == 'a' >>> most_frequent_character(\\"abc\\") == 'a' >>> most_frequent_character(\\"abbccc\\") == 'c' >>> most_frequent_character(\\"aabb\\") == 'a' >>> most_frequent_character(\\"aA\\") == 'a' >>> most_frequent_character(\\"AaaAAaA\\") == 'A' >>> most_frequent_character(\\"\\") == None >>> most_frequent_character(\\"!!@@!!\\") == '!'","solution":"def most_frequent_character(s): Returns the most frequently occurring character in the string \`s\`. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. Returns None if the input string is empty. if not s: return None frequency = {} max_count = 0 most_frequent_char = None for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 if frequency[char] > max_count: max_count = frequency[char] most_frequent_char = char return most_frequent_char"},{"question":"def first_repeated_char(s: str) -> str: Returns the first character that appears more than once in the string s. If no such character exists, returns an empty string. >>> first_repeated_char(\\"programming\\") 'r' >>> first_repeated_char(\\"abcdefgh\\") '' >>> first_repeated_char(\\"aabbcc\\") 'a'","solution":"def first_repeated_char(s): Returns the first character that appears more than once in the string s. If no such character exists, returns an empty string. :param s: str, input string :return: str, first repeated character or an empty string char_set = set() for char in s: if char in char_set: return char char_set.add(char) return \\"\\""},{"question":"def reverseWords(sentence: str) -> str: This function reverses the order of words in a sentence while maintaining the order of characters within each word. >>> reverseWords(\\"hello world!\\") == \\"world! hello\\" >>> reverseWords(\\"Python is fun\\") == \\"fun is Python\\" >>> reverseWords(\\"\\") == \\"\\" >>> reverseWords(\\"A B C D\\") == \\"D C B A\\" >>> reverseWords(\\"code@work time!\\") == \\"time! code@work\\"","solution":"def reverseWords(sentence): This function reverses the order of words in a sentence while maintaining the order of characters within each word. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List, Dict, Union def organize_books(books: List[Dict[str, Union[str, int]]]) -> Dict[str, Dict[str, Dict[str, List[str]]]]: Organize books into a nested dictionary by genre, author, and publication year. >>> books = [ ... {\\"title\\": \\"Book A\\", \\"genre\\": \\"Fiction\\", \\"author\\": \\"Author X\\", \\"year\\": 2001}, ... {\\"title\\": \\"Book B\\", \\"genre\\": \\"Fiction\\", \\"author\\": \\"Author Y\\", \\"year\\": 2000}, ... {\\"title\\": \\"Book C\\", \\"genre\\": \\"Non-Fiction\\", \\"author\\": \\"Author X\\", \\"year\\": 2001}, ... {\\"title\\": \\"Book D\\", \\"genre\\": \\"Fiction\\", \\"author\\": \\"Author X\\", \\"year\\": 2001} ... ] >>> organize_books(books) { \\"Fiction\\": { \\"Author X\\": { \\"2001\\": [\\"Book A\\", \\"Book D\\"] }, \\"Author Y\\": { \\"2000\\": [\\"Book B\\"] } }, \\"Non-Fiction\\": { \\"Author X\\": { \\"2001\\": [\\"Book C\\"] } } }","solution":"from typing import List, Dict, Union def organize_books(books: List[Dict[str, Union[str, int]]]) -> Dict[str, Dict[str, Dict[str, List[str]]]]: organized_books = {} for book in books: genre = book['genre'] author = book['author'] year = str(book['year']) title = book['title'] if genre not in organized_books: organized_books[genre] = {} if author not in organized_books[genre]: organized_books[genre][author] = {} if year not in organized_books[genre][author]: organized_books[genre][author][year] = [] organized_books[genre][author][year].append(title) return organized_books"},{"question":"def canPartition(nums): Determines if the array can be partitioned into two subsets with equal sum. :param nums: List[int] - list of integers :return: bool - True if the array can be partitioned into two subsets with equal sum, otherwise False. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False","solution":"def canPartition(nums): Determines if the array can be partitioned into two subsets with equal sum. total_sum = sum(nums) if total_sum % 2 != 0: return False target = total_sum // 2 possible_sums = {0} for num in nums: current_sums = list(possible_sums) for s in current_sums: if s + num == target: return True possible_sums.add(s + num) return target in possible_sums"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Finds the maximum sum of a subarray of size k. :param arr: List[int], the input array of integers :param k: int, size of the subarray :return: int, the maximum sum of a subarray of size k >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([2, 3, 4, 1, 5], 2) 7 # Your code here","solution":"def max_sum_subarray(arr, k): Finds the maximum sum of a subarray of size k. :param arr: List[int], the input array of integers :param k: int, size of the subarray :return: int, the maximum sum of a subarray of size k n = len(arr) if n < k: return 0 max_sum = sum(arr[:k]) window_sum = max_sum for i in range(n - k): window_sum = window_sum - arr[i] + arr[i + k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def review_string(s): Analyze the content of the input string and return a dictionary with its statistics. >>> review_string(\\"Hello World 123\\") {\\"length\\": 15, \\"vowels\\": 3, \\"consonants\\": 7, \\"digits\\": 3, \\"whitespace\\": 2} >>> review_string(12345) \\"Invalid input!\\"","solution":"def review_string(s): if not isinstance(s, str): return \\"Invalid input!\\" vowels = set('aeiouAEIOU') result = { \\"length\\": len(s), \\"vowels\\": 0, \\"consonants\\": 0, \\"digits\\": 0, \\"whitespace\\": 0 } for char in s: if char in vowels: result[\\"vowels\\"] += 1 elif char.isalpha(): result[\\"consonants\\"] += 1 elif char.isdigit(): result[\\"digits\\"] += 1 elif char.isspace(): result[\\"whitespace\\"] += 1 return result"},{"question":"def removeAdjacentDuplicates(s: str) -> str: Removes adjacent duplicate characters from the string s until no two adjacent characters are the same. :param s: str :return: str def test_remove_adjacent_duplicates(): assert removeAdjacentDuplicates(\\"abccba\\") == \\"\\" assert removeAdjacentDuplicates(\\"azxxzy\\") == \\"ay\\" assert removeAdjacentDuplicates(\\"aabccba\\") == \\"a\\" assert removeAdjacentDuplicates(\\"a\\") == \\"a\\" assert removeAdjacentDuplicates(\\"\\") == \\"\\" assert removeAdjacentDuplicates(\\"aa\\") == \\"\\" assert removeAdjacentDuplicates(\\"abba\\") == \\"\\" assert removeAdjacentDuplicates(\\"abcde\\") == \\"abcde\\" assert removeAdjacentDuplicates(\\"ababababab\\") == \\"ababababab\\" assert removeAdjacentDuplicates(\\"ababab\\") == \\"ababab\\"","solution":"def removeAdjacentDuplicates(s): Removes adjacent duplicate characters from the string s until no two adjacent characters are the same. :param s: str :return: str stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the last character if it's the same as the current one else: stack.append(char) # Add the current character to the stack return ''.join(stack)"},{"question":"def find_anagrams(s: str, p: str) -> List[int]: Given a string s that consists of only lowercase English letters and a pattern p, find all the start indices of p's anagrams in s. The output should be sorted in ascending order of indices. Example 1: >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] Example 2: >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] Note: - The input string is 's' will have length from 1 to 10000. - The pattern string 'p' will have length from 1 to 100. - The output should be an ascending order of starting indices where the substrings of \`s\` starting from those indices are anagrams of \`p\`.","solution":"from collections import Counter def find_anagrams(s, p): Given a string s and a pattern p, find all the start indices of p's anagrams in s. The output is sorted in ascending order of indices. p_count = Counter(p) s_count = Counter() result = [] p_len = len(p) for i in range(len(s)): # Add current character to the current window counter s_count[s[i]] += 1 if i >= p_len: # Remove the character that is left out of window if s_count[s[i - p_len]] == 1: del s_count[s[i - p_len]] else: s_count[s[i - p_len]] -= 1 if s_count == p_count: result.append(i - p_len + 1) return result"},{"question":"def check_circle_overlap(circles): Checks if there is any pair of overlapping circles. Parameters: circles (list of tuples): A list of tuples where each tuple contains (x, y, r) representing the center and radius of a circle. Returns: str: 'YES' if at least one pair of circles overlap, otherwise 'NO' from math import sqrt pass # To be implemented by the user. def test_no_overlap(): circles = [(-10, -10, 2), (10, 10, 2)] assert check_circle_overlap(circles) == \\"NO\\" def test_overlap(): circles = [(0, 0, 3), (10, 10, 2), (5, 5, 7)] assert check_circle_overlap(circles) == \\"YES\\" circles = [(0, 0, 1), (1, 0, 1)] assert check_circle_overlap(circles) == \\"YES\\" def test_single_circle(): circles = [(0, 0, 1)] assert check_circle_overlap(circles) == \\"NO\\" def test_large_non_overlapping_circle(): circles = [(0, 0, 1e9), (3e9, 3e9, 1e9)] assert check_circle_overlap(circles) == \\"NO\\" def test_large_overlapping_circle(): circles = [(0, 0, 1e9), (0, 0, 1e9)] assert check_circle_overlap(circles) == \\"YES\\" def test_boundary_conditions(): # Boundaries with minimal distance where they just touch circles = [(0, 0, 1), (2, 0, 1)] assert check_circle_overlap(circles) == \\"NO\\" # Boundaries where they overlap slightly circles = [(0, 0, 1), (1, 0, 1)] assert check_circle_overlap(circles) == \\"YES\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) circles = [] for i in range(1, len(data), 3): x = int(data[i]) y = int(data[i + 1]) r = int(data[i + 2]) circles.append((x, y, r)) result = check_circle_overlap(circles) print(result)","solution":"def check_circle_overlap(circles): Checks if there is any pair of overlapping circles. Parameters: circles (list of tuples): A list of tuples where each tuple contains (x, y, r) representing the center and radius of a circle. Returns: str: 'YES' if at least one pair of circles overlap, otherwise 'NO' from math import sqrt n = len(circles) for i in range(n): for j in range(i + 1, n): x1, y1, r1 = circles[i] x2, y2, r2 = circles[j] # Calculate the distance between the centers of the circles distance = sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) # Check if circles overlap if distance < r1 + r2: return \\"YES\\" return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) circles = [] for i in range(1, len(data), 3): x = int(data[i]) y = int(data[i + 1]) r = int(data[i + 2]) circles.append((x, y, r)) result = check_circle_overlap(circles) print(result)"},{"question":"from typing import List def max_temperature_difference(temperatures: List[int]) -> int: Given a list of integers representing temperatures recorded over a week, find the maximum difference between two temperatures such that the second temperature occurs after the first one. If no such pair exists, return 0. Example 1: >>> max_temperature_difference([30, 20, 25, 28, 33, 24, 30]) 13 Example 2: >>> max_temperature_difference([35, 34, 33, 32, 31]) 0 Example 3: >>> max_temperature_difference([20, 18, 22, 23, 21, 24, 19]) 6 Example 4: >>> max_temperature_difference([50]) 0","solution":"def max_temperature_difference(temperatures): Finds the maximum difference between two temperatures such that the second temperature occurs after the first one. Returns 0 if no such pair exists. if len(temperatures) < 2: return 0 max_diff = 0 min_temp = temperatures[0] for temp in temperatures[1:]: if temp - min_temp > max_diff: max_diff = temp - min_temp if temp < min_temp: min_temp = temp return max_diff"},{"question":"def fizzbuzz(n: int) -> str: Returns a string representation of numbers from 1 to n with specific rules: - \\"Fizz\\" for multiples of three. - \\"Buzz\\" for multiples of five. - \\"FizzBuzz\\" for multiples of both three and five. >>> fizzbuzz(15) '1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz' >>> fizzbuzz(5) '1 2 Fizz 4 Buzz'","solution":"def fizzbuzz(n): Returns a string representation of numbers from 1 to n with specific rules: - \\"Fizz\\" for multiples of three. - \\"Buzz\\" for multiples of five. - \\"FizzBuzz\\" for multiples of both three and five. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return ' '.join(result)"},{"question":"def palindromeNumber(num: int) -> bool: Returns True if the number is a palindrome, False otherwise. >>> palindromeNumber(121) True >>> palindromeNumber(123) False >>> palindromeNumber(1001) True >>> palindromeNumber(13531) True >>> palindromeNumber(233) False >>> palindromeNumber(9) True >>> palindromeNumber(44) True >>> palindromeNumber(21) False","solution":"def palindromeNumber(num): Returns True if the number is a palindrome, False otherwise. return str(num) == str(num)[::-1]"},{"question":"from typing import List, Tuple, Dict def genreCount(tracks: List[Tuple[str, str]]) -> Dict[str, int]: Returns a dictionary with counts of tracks for each genre, treating genres as case-insensitive. >>> tracks = [ ... (\\"track1\\", \\"pop\\"), ... (\\"track2\\", \\"rock\\"), ... (\\"track3\\", \\"pop\\"), ... (\\"track4\\", \\"jazz\\"), ... (\\"track5\\", \\"classical\\"), ... (\\"track6\\", \\"rock\\") ...] >>> genreCount(tracks) {'pop': 2, 'rock': 2, 'jazz': 1, 'classical': 1} >>> tracks = [ ... (\\"track1\\", \\"Pop\\"), ... (\\"track2\\", \\"Rock\\"), ... (\\"track3\\", \\"POP\\"), ... (\\"track4\\", \\"jazz\\"), ... (\\"track5\\", \\"classical\\"), ... (\\"track6\\", \\"ROCK\\") ...] >>> genreCount(tracks) {'pop': 2, 'rock': 2, 'jazz': 1, 'classical': 1} >>> tracks = [] >>> genreCount(tracks) {} >>> tracks = [ ... (\\"track1\\", \\"pop\\"), ... (\\"track2\\", \\"pop\\"), ... (\\"track3\\", \\"pop\\"), ...] >>> genreCount(tracks) {'pop': 3} >>> tracks = [ ... (\\"track1\\", \\"pop\\"), ... (\\"track2\\", \\"rock\\"), ... (\\"track3\\", \\"Pop\\"), ... (\\"track4\\", \\"rock\\"), ... (\\"track5\\", \\"Rock\\"), ... (\\"track6\\", \\"JAZZ\\"), ... (\\"track7\\", \\"Classical\\"), ... (\\"track8\\", \\"Jazz\\"), ...] >>> genreCount(tracks) {'pop': 2, 'rock': 3, 'jazz': 2, 'classical': 1}","solution":"from typing import List, Tuple, Dict def genreCount(tracks: List[Tuple[str, str]]) -> Dict[str, int]: Returns a dictionary with counts of tracks for each genre, treating genres as case-insensitive. genre_counter = {} for track_id, genre in tracks: genre_lower = genre.lower() if genre_lower in genre_counter: genre_counter[genre_lower] += 1 else: genre_counter[genre_lower] = 1 return genre_counter"},{"question":"def validate_vehicle_reg(reg_num: str) -> bool: Checks if the given registration number is valid based on the specified rules. >>> validate_vehicle_reg(\\"ABC2019@\\") True >>> validate_vehicle_reg(\\"abc2019\\") False >>> validate_vehicle_reg(\\"XYZ1875#@\\") False >>> validate_vehicle_reg(\\"AB2019@\\") False >>> validate_vehicle_reg(\\"ABC201900@\\") False >>> validate_vehicle_reg(\\"ABC2019AA\\") False >>> validate_vehicle_reg(\\"ABC2019A\\") False >>> validate_vehicle_reg(\\"ABC1900@\\") True >>> validate_vehicle_reg(\\"ABC2022@\\") True >>> validate_vehicle_reg(\\"ABC1899@\\") False >>> validate_vehicle_reg(\\"ABC2023@\\") False >>> validate_vehicle_reg(\\"ABC2019\\") True >>> validate_vehicle_reg(\\"ABC2019%#\\") True >>> validate_vehicle_reg(\\"ABC2019@@\\") True >>> validate_vehicle_reg(\\"ABC2019&&\\") True >>> validate_vehicle_reg(\\"ABC2019**\\") True","solution":"def validate_vehicle_reg(reg_num): Checks if the given registration number is valid based on the specified rules. Parameters: reg_num (str): The vehicle registration number to be validated. Returns: bool: True if the registration number is valid, False otherwise. if len(reg_num) != 9: return False # Check if the first three characters are uppercase English alphabets if not reg_num[:3].isalpha() or not reg_num[:3].isupper(): return False # Check if the next four characters are digits and if they represent a valid year year = reg_num[3:7] if not year.isdigit() or not (1900 <= int(year) <= 2022): return False # Check if the last two characters are valid special characters if reg_num[7] not in '%#@&*' or reg_num[8] not in '%#@&*': return False return True"},{"question":"def count_unicode_characters(s: str) -> dict: Returns a dictionary with the count of each unique Unicode character in the string \`s\`. >>> count_unicode_characters(\\"Hello, 世界! 🌍🌎🌏\\") {'H': 1, 'e': 1, 'l': 2, 'o': 1, ',': 1, ' ': 2, '世': 1, '界': 1, '!': 1, '🌍': 1, '🌎': 1, '🌏': 1} >>> count_unicode_characters(\\"\\") {} >>> count_unicode_characters(\\"🌍\\") {'🌍': 1} >>> count_unicode_characters(\\"aaabbc\\") {'a': 3, 'b': 2, 'c': 1} >>> count_unicode_characters(\\"hello こんにちは\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1, ' ': 1, 'こ': 1, 'ん': 1, 'に': 1, 'ち': 1, 'は': 1} >>> count_unicode_characters(\\"Hi! How are you?\\") {'H': 2, 'i': 1, '!': 1, ' ': 3, 'o': 2, 'w': 1, 'a': 1, 'r': 1, 'e': 1, 'y': 1, 'u': 1, '?': 1}","solution":"from collections import Counter def count_unicode_characters(s: str) -> dict: Returns a dictionary with the count of each unique Unicode character in the string \`s\`. return dict(Counter(s))"},{"question":"def capitalizeWords(s: str) -> str: Capitalizes the first letter of each word in the given string while retaining all types of whitespace properly. >>> capitalizeWords(\\"hello world\\") \\"Hello World\\" >>> capitalizeWords(\\" this is a test\\") \\" This Is A Test\\" >>> capitalizeWords(\\"multiple spaces\\") \\"Multiple Spaces\\" >>> capitalizeWords(\\"tabtcharacters\\") \\"TabtCharacters\\" >>> capitalizeWords(\\"a mix ofnnewlinesnand spaces\\") \\"A Mix OfnNewlinesnAnd Spaces\\"","solution":"def capitalizeWords(s): Capitalizes the first letter of each word in the string. return ' '.join(word.capitalize() for word in s.split(' ')) # Note: This solution works for normal spaces and ensures multiple spaces are preserved as expected # but it treats different white spaces like t and n as characters, meaning it won't handle them separately."},{"question":"class OperationHandler: A class to handle increment and query operations on an array. Args: N (int): The size of the array. initial_array (List[int]): The initial values of the array. def __init__(self, N: int, initial_array: List[int]): self.N = N self.array = initial_array def increment(self, L: int, R: int, X: int) -> None: Increment each element in the range [L, R] (inclusive) by X. Args: L (int): Left index (1-based). R (int): Right index (1-based). X (int): The increment value. pass def query(self, L: int, R: int) -> int: Compute the sum of the elements in the range [L, R] (inclusive). Args: L (int): Left index (1-based). R (int): Right index (1-based). Returns: int: The sum of the elements in the specified range. pass # Unit Test def test_operations(): handler = OperationHandler(5, [1, 2, 3, 4, 5]) # Testing Increment Operation handler.increment(1, 3, 2) assert handler.array == [3, 4, 5, 4, 5] # Testing Query Operation assert handler.query(2, 4) == 13 # Further Increment Operation handler.increment(2, 5, 1) assert handler.array == [3, 5, 6, 5, 6] # Further Query Operation assert handler.query(1, 5) == 25 def test_edge_cases(): handler = OperationHandler(3, [-100000, 0, 100000]) # Increment all to zero handler.increment(1, 3, 100000) assert handler.array == [0, 100000, 200000] # Query full range assert handler.query(1, 3) == 300000","solution":"class OperationHandler: def __init__(self, N, initial_array): self.N = N self.array = initial_array def increment(self, L, R, X): for i in range(L-1, R): self.array[i] += X def query(self, L, R): return sum(self.array[L-1:R])"},{"question":"def max_product_of_two(arr): Given a list of integers, returns the maximum product of two distinct elements. pass def process_test_cases(T, test_cases): Processes multiple test cases and returns the results as a list. pass # Example usage: # >>> process_test_cases(2, [[1, 2, 3, 4], [-10, -20, 5]]) # [12, 200] # >>> max_product_of_two([1, 2, 3, 4]) # 12 # >>> max_product_of_two([-10, -20, 5]) # 200","solution":"def max_product_of_two(arr): Given a list of integers, returns the maximum product of two distinct elements. if len(arr) < 2: raise ValueError(\\"The array must contain at least two elements.\\") # Sorting the array arr.sort() # Maximum product can be the product of the two largest elements # or the product of the two smallest (most negative) elements return max(arr[-1] * arr[-2], arr[0] * arr[1]) def process_test_cases(T, test_cases): Processes multiple test cases and returns the results as a list. results = [] for case in test_cases: results.append(max_product_of_two(case)) return results"},{"question":"def findLHS(sequence): Given a sequence of integers, this function finds the length of the longest harmonious subsequence. pass def longest_harmonious_subsequence(test_cases): For each test case, given a sequence of integers, this function finds the length of the longest harmonious subsequence. pass # Unit tests def test_findLHS(): assert findLHS([1, 2, 2, 1, 3, 3]) == 4 assert findLHS([1, 2, 3, 4, 5]) == 2 assert findLHS([1, 3, 2, 2, 5, 2, 3, 7]) == 5 assert findLHS([1, 1, 1, 1]) == 0 assert findLHS([10, 11, 11, 10, 12, 11, 10]) == 6 def test_longest_harmonious_subsequence(): test_cases = [ (6, [1, 2, 2, 1, 3, 3]), (5, [1, 2, 3, 4, 5]) ] assert longest_harmonious_subsequence(test_cases) == [4, 2] test_cases2 = [ (8, [1, 3, 2, 2, 5, 2, 3, 7]), (4, [1, 1, 1, 1]) ] assert longest_harmonious_subsequence(test_cases2) == [5, 0]","solution":"def findLHS(sequence): Given a sequence of integers, this function finds the length of the longest harmonious subsequence. from collections import Counter freq = Counter(sequence) max_length = 0 for key in freq: if key + 1 in freq: max_length = max(max_length, freq[key] + freq[key + 1]) return max_length def longest_harmonious_subsequence(test_cases): For each test case, given a sequence of integers, this function finds the length of the longest harmonious subsequence. results = [] for case in test_cases: N, sequence = case results.append(findLHS(sequence)) return results"},{"question":"import numpy as np def create_full_and_eye(shape, value, dtype=int): Create an array of the given shape and type filled with the specified value using numpy.full, and then create an identity matrix using numpy.eye. Parameters: shape (tuple): Shape of the array. value (int or float): The value to fill the array with. dtype (data-type): Desired output data-type for the array, default is int. Returns: tuple: The filled array and the identity matrix. >>> create_full_and_eye((2, 2), 7) (array([[7, 7], [7, 7]]), array([[1, 0], [0, 1]])) >>> create_full_and_eye((2, 2), 7.0, dtype=float) (array([[7.0, 7.0], [7.0, 7.0]]), array([[1.0, 0.0], [0.0, 1.0]])) >>> create_full_and_eye((3, 2), 5) (array([[5, 5], [5, 5], [5, 5]]), array([[1, 0], [0, 1], [0, 0]])) >>> create_full_and_eye((2, 3), 1) (array([[1, 1, 1], [1, 1, 1]]), array([[1, 0, 0], [0, 1, 0]]))","solution":"import numpy as np def create_full_and_eye(shape, value, dtype=int): Create an array of the given shape and type filled with the specified value using numpy.full, and then create an identity matrix using numpy.eye. Parameters: shape (tuple): Shape of the array. value (int or float): The value to fill the array with. dtype (data-type): Desired output data-type for the array, default is int. Returns: tuple: The filled array and the identity matrix. filled_array = np.full(shape, value, dtype=dtype) identity_matrix = np.eye(shape[0], shape[1], dtype=dtype) return filled_array, identity_matrix"},{"question":"def count_elements_less_equal(a, m): This function takes a list 'a' of integers and a maximum value 'm'. It returns a list 'b' where each element 'b[i]' represents the number of elements in 'a' that are less than or equal to 'i'. def solve(test_cases): This function takes a list of test cases, where each test case is a tuple of: - n (number of elements in array 'a') - m (maximum value in array 'a') - a (list of integers of length n) It returns a list of results, where each result is the array 'b' for the corresponding test case. def parse_input(input_string): This function takes the input string and parses it into a list of test cases. Each test case should be represented as a tuple (n, m, a) where: - n: integer, number of elements in array 'a' - m: integer, maximum value in array 'a' - a: list of integers of length n It returns a list of these parsed test cases. import pytest from solution import count_elements_less_equal, solve, parse_input def test_count_elements_less_equal(): assert count_elements_less_equal([1, 2, 1, 3, 2], 5) == [2, 4, 5, 5, 5] assert count_elements_less_equal([1, 3, 3, 2], 3) == [1, 2, 4] def test_solve(): input_data = [ (5, 5, [1, 2, 1, 3, 2]), (4, 3, [1, 3, 3, 2]) ] expected_output = [ [2, 4, 5, 5, 5], [1, 2, 4] ] assert solve(input_data) == expected_output def test_parse_input(): input_string = \\"2n5 5n1 2 1 3 2n4 3n1 3 3 2n\\" expected_output = [ (5, 5, [1, 2, 1, 3, 2]), (4, 3, [1, 3, 3, 2]) ] assert parse_input(input_string) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def count_elements_less_equal(a, m): This function takes a list 'a' of integers and a maximum value 'm'. It returns a list 'b' where each element 'b[i]' represents the number of elements in 'a' that are less than or equal to 'i'. # Create a list to store the count of elements except initializing to zero. counts = [0] * (m + 1) # Count the frequency of each element in the array 'a'. for num in a: counts[num] += 1 # Compute the cumulative count. cumulative_count = 0 result = [] for i in range(1, m + 1): cumulative_count += counts[i] result.append(cumulative_count) return result def solve(test_cases): results = [] for (n, m, a) in test_cases: b = count_elements_less_equal(a, m) results.append(b) return results def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) a = list(map(int, lines[index + 1].split())) test_cases.append((n, m, a)) index += 2 return test_cases"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n grid from top-left to bottom-right. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28","solution":"def unique_paths(m, n): Calculate the number of unique paths in an m x n grid from top-left to bottom-right. # Create a 2D list with all elements initialized to 1 because there's only 1 way to reach cells in the first row or first column. dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from the cell (1,1) to calculate the number of unique paths to each cell. for i in range(1, m): for j in range(1, n): # The number of paths to reach a cell is the sum of the paths to reach the cell above it and the cell to the left of it. dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right cell contains the number of unique paths to the finish. return dp[m-1][n-1]"},{"question":"def verify_packing(T: int, test_cases: List[Dict[str, Any]]) -> List[str]: Verify if Alice has packed all the required items from her checklist. Args: T (int): The number of test cases test_cases (List[Dict[str, Any]]): A list of dictionaries, each containing: - 'N': The number of items in the checklist - 'checklist': A list of strings representing the items in the checklist - 'M': The number of items already packed - 'packed_items': A list of strings representing the items packed Returns: List[str]: A list of strings \\"All items packed\\" or \\"Missing items\\" for each test case. Example: T = 4 test_cases = [ { 'N': 5, 'checklist': ['tent', 'sleepingbag', 'flashlight', 'stove', 'food'], 'M': 4, 'packed_items': ['tent', 'flashlight', 'food', 'stove'] }, { 'N': 3, 'checklist': ['water', 'bottle', 'map'], 'M': 3, 'packed_items': ['map', 'bottle'] }, { 'N': 2, 'checklist': ['firstaid', 'guidebook'], 'M': 4, 'packed_items': ['firstaid', 'guidebook', 'map', 'blanket'] }, { 'N': 3, 'checklist': ['jacket', 'compass', 'lantern'], 'M': 2, 'packed_items': ['jacket', 'compass'] } ] verify_packing(T, test_cases) -> [\\"Missing items\\", \\"Missing items\\", \\"All items packed\\", \\"Missing items\\"]","solution":"def verify_packing(T, test_cases): results = [] for i in range(T): N = test_cases[i]['N'] checklist = set(test_cases[i]['checklist']) M = test_cases[i]['M'] packed_items = set(test_cases[i]['packed_items']) if checklist.issubset(packed_items): results.append(\\"All items packed\\") else: results.append(\\"Missing items\\") return results"},{"question":"def remove_vowels(s): Removes all vowels (a, e, i, o, u) from the input string, case insensitive. Preserves the case of non-vowel letters and positioning of non-letter characters. Returns \\"Invalid input\\" if the input is not a string. >>> remove_vowels(\\"this is an example\\") == \\"ths s n xmpl\\" >>> remove_vowels(\\"This is An ExAmplE\\") == \\"Ths s n xmpl\\" >>> remove_vowels(\\"Th!s Is @n ex@mpl3!\\") == \\"Th!s s @n x@mpl3!\\" >>> remove_vowels(\\"aeiouAEIOU\\") == \\"\\" >>> remove_vowels(\\"BcDfgH\\") == \\"BcDfgH\\" >>> remove_vowels(\\"\\") == \\"\\" >>> remove_vowels(123) == \\"Invalid input\\" >>> remove_vowels([\\"This\\", \\"is\\", \\"a\\", \\"list\\"]) == \\"Invalid input\\" >>> remove_vowels(None) == \\"Invalid input\\"","solution":"def remove_vowels(s): Removes all vowels (a, e, i, o, u) from the input string, case insensitive. Preserves the case of non-vowel letters and positioning of non-letter characters. Returns \\"Invalid input\\" if the input is not a string. if not isinstance(s, str): return \\"Invalid input\\" vowels = \\"aeiouAEIOU\\" return ''.join([char for char in s if char not in vowels])"},{"question":"def water_trapped(pillar_heights): Calculate the total amount of water trapped between the pillars after it rains. :param pillar_heights: A list of integers representing the heights of the pillars. :return: The total amount of water trapped. >>> water_trapped([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> water_trapped([2,0,2]) 2 >>> water_trapped([3,0,0,2,0,4]) 10 >>> water_trapped([]) 0 >>> water_trapped([1, 1, 1, 1]) 0 >>> water_trapped([2]) 0 >>> water_trapped([5, 4, 3, 2, 1]) 0 >>> water_trapped([1, 2, 3, 4, 5]) 0 >>> water_trapped([0, 1, 3, 2, 1, 2, 1, 2, 1, 0, 2]) 5","solution":"def water_trapped(pillar_heights): Calculate the total amount of water trapped between the pillars after it rains. :param pillar_heights: A list of integers representing the heights of the pillars. :return: The total amount of water trapped. if not pillar_heights: return 0 left, right = 0, len(pillar_heights) - 1 left_max, right_max = pillar_heights[left], pillar_heights[right] water_trapped = 0 while left < right: if pillar_heights[left] < pillar_heights[right]: if pillar_heights[left] >= left_max: left_max = pillar_heights[left] else: water_trapped += left_max - pillar_heights[left] left += 1 else: if pillar_heights[right] >= right_max: right_max = pillar_heights[right] else: water_trapped += right_max - pillar_heights[right] right -= 1 return water_trapped"},{"question":"def count_distinct_in_subarrays(n: int, arr: List[int], k: int) -> List[int]: Function to count the number of distinct integers in every subarray of length k. Parameters: n (int): The size of the array. arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: list of int: A list where the i-th element represents the number of distinct integers in the subarray starting at index i. >>> count_distinct_in_subarrays(7, [1, 2, 1, 3, 4, 2, 3], 4) [3, 4, 4, 3] >>> count_distinct_in_subarrays(5, [1, 1, 1, 1, 1], 1) [1, 1, 1, 1, 1]","solution":"def count_distinct_in_subarrays(n, arr, k): Function to count the number of distinct integers in every subarray of length k. Parameters: n (int): The size of the array. arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: list of int: A list where the i-th element represents the number of distinct integers in the subarray starting at index i. from collections import defaultdict distinct_counts = [] freq = defaultdict(int) distinct = 0 # Initialize the frequency dictionary for the first window for i in range(k): if freq[arr[i]] == 0: distinct += 1 freq[arr[i]] += 1 distinct_counts.append(distinct) # Slide the window from start to end for i in range(k, n): if freq[arr[i - k]] == 1: distinct -= 1 freq[arr[i - k]] -= 1 if freq[arr[i]] == 0: distinct += 1 freq[arr[i]] += 1 distinct_counts.append(distinct) return distinct_counts"},{"question":"def find_max_index(arr: List[int]) -> int: Returns the index of the element with the highest value. If there are multiple elements with the highest value, returns the index of the first occurrence. >>> find_max_index([1, 3, 7, 7, 2]) 2 >>> find_max_index([5]) 0 >>> find_max_index([-1, -3, -7, -7, -2]) 0 >>> find_max_index([5, 5, 5, 5, 5]) 0 >>> find_max_index(list(range(-10**6, 10**6))) 1999999 >>> find_max_index([3, 2, 1, 10**6]) 3","solution":"from typing import List def find_max_index(arr: List[int]) -> int: Returns the index of the element with the highest value. If there are multiple elements with the highest value, returns the index of the first occurrence. # Initialize the maximum value and its index max_value = arr[0] max_index = 0 # Iterate through the array to find the maximum value and its index for index in range(1, len(arr)): if arr[index] > max_value: max_value = arr[index] max_index = index return max_index"},{"question":"def max_difference(nums: List[int]) -> int: Return the maximum difference between two elements in the list \`nums\` such that the larger element appears after the smaller element. >>> max_difference([7, 1, 5, 3, 6, 4]) == 5 >>> max_difference([9, 8, 7, 6, 5]) == -1 >>> max_difference([5]) == -1 >>> max_difference([1, 2]) == 1 >>> max_difference([2, 1]) == -1 >>> max_difference([1, 3, -1, -2, 8, 10]) == 12 >>> max_difference([-100000, 0, 100000]) == 200000 >>> max_difference([100000, 0, -100000]) == -1","solution":"def max_difference(nums): Return the maximum difference between two elements in the list \`nums\` such that the larger element appears after the smaller element. if not nums or len(nums) < 2: return -1 min_element = nums[0] max_diff = -1 for num in nums[1:]: if num - min_element > max_diff: max_diff = num - min_element if num < min_element: min_element = num return max_diff"},{"question":"def largest_square_submatrix_area(matrix): Find the largest square submatrix that contains only 1s and return its area. >>> largest_square_submatrix_area([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) 4 >>> largest_square_submatrix_area([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9 >>> largest_square_submatrix_area([[0]]) 0 >>> largest_square_submatrix_area([[1]]) 1","solution":"def largest_square_submatrix_area(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Initialize a 2D dp array with zeros dp = [[0] * n for _ in range(m)] max_side = 0 # Fill the dp array for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) # The area of the largest square submatrix with only 1s return max_side * max_side"},{"question":"import heapq from typing import List class RunningMedian: Maintains and calculates the median of all elements seen so far in the stream of integers. Methods: - __init__(): Initializes the RunningMedian object. - addNum(num: int): Adds the integer \`num\` to the stream of numbers. - findMedian() -> float: Returns the median of all elements seen so far. Example: >>> rm = RunningMedian() >>> rm.addNum(1) >>> print(rm.findMedian()) # Output: 1.0 >>> rm.addNum(2) >>> print(rm.findMedian()) # Output: 1.5 >>> rm.addNum(3) >>> print(rm.findMedian()) # Output: 2.0 def __init__(self): pass def addNum(self, num: int): pass def findMedian(self) -> float: pass # Unit tests def test_single_element(): rm = RunningMedian() rm.addNum(1) assert rm.findMedian() == 1.0 def test_two_elements(): rm = RunningMedian() rm.addNum(1) rm.addNum(2) assert rm.findMedian() == 1.5 def test_three_elements(): rm = RunningMedian() rm.addNum(1) rm.addNum(2) rm.addNum(3) assert rm.findMedian() == 2.0 def test_even_number_of_elements(): rm = RunningMedian() rm.addNum(1) rm.addNum(2) rm.addNum(3) rm.addNum(4) assert rm.findMedian() == 2.5 def test_mixed_elements(): rm = RunningMedian() rm.addNum(5) rm.addNum(15) rm.addNum(1) assert rm.findMedian() == 5.0 rm.addNum(3) assert rm.findMedian() == 4.0 def test_large_set_of_elements(): import random rm = RunningMedian() stream = [random.randint(-100000, 100000) for _ in range(10000)] for num in stream: rm.addNum(num) assert isinstance(rm.findMedian(), float) def test_negative_numbers(): rm = RunningMedian() rm.addNum(-5) rm.addNum(-10) assert rm.findMedian() == -7.5 rm.addNum(-1) assert rm.findMedian() == -5.0","solution":"import heapq class RunningMedian: def __init__(self): self.low = [] # Max-heap for the lower half of the numbers self.high = [] # Min-heap for the upper half of the numbers def addNum(self, num: int): heapq.heappush(self.low, -num) if self.low and self.high and (-self.low[0] > self.high[0]): heapq.heappush(self.high, -heapq.heappop(self.low)) if len(self.low) > len(self.high) + 1: heapq.heappush(self.high, -heapq.heappop(self.low)) if len(self.high) > len(self.low): heapq.heappush(self.low, -heapq.heappop(self.high)) def findMedian(self) -> float: if len(self.low) > len(self.high): return float(-self.low[0]) return (-self.low[0] + self.high[0]) / 2.0"},{"question":"from collections import defaultdict, OrderedDict class LFUCache: A class to implement a Least Frequently Used (LFU) cache. The constructor takes a positive integer capacity as an argument, representing the maximum capacity of the cache. The function \`get(key)\` returns the value of the key if it exists in the cache, otherwise returns -1. The function \`put(key, value)\` updates or inserts the value for the key if it doesn't exist. When the cache reaches its capacity, it should invalidate the least frequently used items. When there is a tie, least recently used keys should be invalidated first. >>> cache = LFUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) >>> cache.get(2) -1 >>> cache.get(3) 3 >>> cache.put(4, 4) >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass","solution":"from collections import defaultdict, OrderedDict class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.min_freq = 1 self.key_to_val = {} self.key_to_freq = {} self.freq_to_keys = defaultdict(OrderedDict) def get(self, key: int) -> int: if key not in self.key_to_val: return -1 # Update the frequency of the key self.update_freq(key) return self.key_to_val[key] def put(self, key: int, value: int) -> None: if self.capacity <= 0: return if key in self.key_to_val: # Update value and frequency self.key_to_val[key] = value self.update_freq(key) else: if len(self.key_to_val) >= self.capacity: # Evict the least frequent and least recently used key self.evict() # Insert the new key-value pair self.key_to_val[key] = value self.key_to_freq[key] = 1 self.freq_to_keys[1][key] = None self.min_freq = 1 def update_freq(self, key: int): freq = self.key_to_freq[key] del self.freq_to_keys[freq][key] if not self.freq_to_keys[freq]: del self.freq_to_keys[freq] if self.min_freq == freq: self.min_freq += 1 new_freq = freq + 1 self.key_to_freq[key] = new_freq self.freq_to_keys[new_freq][key] = None def evict(self): key, _ = self.freq_to_keys[self.min_freq].popitem(last=False) del self.key_to_val[key] del self.key_to_freq[key] if not self.freq_to_keys[self.min_freq]: del self.freq_to_keys[self.min_freq]"}]`),F={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const s=this.searchQuery.trim().toLowerCase();return s?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(s)||e.solution&&e.solution.toLowerCase().includes(s)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(s=>setTimeout(s,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},C={class:"card-container"},z={key:0,class:"empty-state"},I=["disabled"],P={key:0},D={key:1};function M(s,e,l,h,i,a){const c=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):u("",!0)]),t("div",C,[(r(!0),n(x,null,y(a.displayedPoems,(o,f)=>(r(),w(c,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",z,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(r(),n("span",D,"Loading...")):(r(),n("span",P,"See more"))],8,I)):u("",!0)])}const B=_(F,[["render",M],["__scopeId","data-v-7cf31276"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/51.md","filePath":"guide/51.md"}'),E={name:"guide/51.md"},W=Object.assign(E,{setup(s){return(e,l)=>(r(),n("div",null,[v(B)]))}});export{O as __pageData,W as default};
